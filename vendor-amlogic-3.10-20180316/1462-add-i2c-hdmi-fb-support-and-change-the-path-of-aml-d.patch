From adf1a8700956d2499a58afaa5e5a61c3665aff60 Mon Sep 17 00:00:00 2001
From: "yun.cai" <yun.cai@amlogic.com>
Date: Fri, 18 Oct 2013 14:56:21 +0800
Subject: [PATCH 1462/5965] add i2c hdmi fb support, and change the path of aml
 drivers' head files--include/linux/amlogic

---
 arch/arm/configs/meson8_defconfig             |   13 +-
 arch/arm/mach-meson8/vpu.c                    |    2 +-
 drivers/amlogic/Kconfig                       |   22 +-
 drivers/amlogic/Makefile                      |    4 +-
 drivers/amlogic/amaudio/amaudio.c             |    2 +-
 drivers/amlogic/amports/encoder.c             |    2 +-
 drivers/amlogic/amports/jpegdec.c             |    2 +-
 drivers/amlogic/audiodsp/audiodsp_module.c    |   10 +-
 drivers/amlogic/audiodsp/audiodsp_module.h    |    2 +-
 drivers/amlogic/audiodsp/dsp_codec.c          |    4 +-
 drivers/amlogic/audiodsp/dsp_control.c        |    2 +-
 drivers/amlogic/audiodsp/dsp_mailbox.c        |    4 +-
 drivers/amlogic/audiodsp/dsp_microcode.c      |    2 +-
 drivers/amlogic/audiodsp/pcmenc_module.c      |    4 +-
 drivers/amlogic/audiodsp/pcmenc_stream.c      |    2 +-
 drivers/amlogic/audiodsp/spdif_module.c       |    4 +-
 drivers/amlogic/canvas/canvas.c               |    2 +-
 drivers/amlogic/display/osd/osd_dev.c         |    6 +-
 drivers/amlogic/display/osd/osd_hw.c          |   10 +-
 drivers/amlogic/display/osd/osd_hw_def.h      |    4 +-
 drivers/amlogic/display/osd/osd_main.c        |    6 +-
 drivers/amlogic/display/osd/osd_prot.c        |    8 +-
 drivers/amlogic/display/osd/osd_prot.h        |    2 +-
 drivers/amlogic/display/vout/edp_drv.c        |    2 +-
 drivers/amlogic/display/vout/enc_clk_config.c |    4 +-
 drivers/amlogic/display/vout/lcdoutc.c        |    8 +-
 drivers/amlogic/display/vout/tvconf.c         |    4 +-
 drivers/amlogic/display/vout/tvconf.h         |    2 +-
 drivers/amlogic/display/vout/tvoutc.c         |    4 +-
 drivers/amlogic/display/vout/vdac_switch.c    |    8 +-
 drivers/amlogic/display/vout/vout_notify.c    |    2 +-
 drivers/amlogic/display/vout/vout_serve.c     |    4 +-
 drivers/amlogic/display/vout/vout_serve.h     |    2 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c   |    2 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c        |    2 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c    |    2 +-
 .../amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c |    4 +-
 .../amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c   |    2 +-
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c  |    4 +-
 drivers/amlogic/tvin/tvafe/tvafe.c            |    2 +-
 drivers/amlogic/tvin/tvafe/tvin_vbi.c         |    2 +-
 drivers/amlogic/tvin/vdin/vdin_drv.c          |    2 +-
 include/linux/amlogic/aml_bl.h                |   16 +
 include/linux/amlogic/amlog.h                 |   85 +
 include/linux/amlogic/amports/amaudio.h       |   86 +
 include/linux/amlogic/amports/amstream.h      |  318 ++++
 include/linux/amlogic/amports/canvas.h        |  174 ++
 include/linux/amlogic/amports/dsp_register.h  |  241 +++
 include/linux/amlogic/amports/ptsserv.h       |   65 +
 include/linux/amlogic/amports/timestamp.h     |   53 +
 include/linux/amlogic/amports/tsync.h         |  108 ++
 include/linux/amlogic/amports/ve.h            |  184 ++
 include/linux/amlogic/amports/vframe.h        |  216 +++
 .../linux/amlogic/amports/vframe_provider.h   |   90 +
 .../linux/amlogic/amports/vframe_receiver.h   |   79 +
 include/linux/amlogic/ge2d/bitblt.h           |   99 +
 include/linux/amlogic/ge2d/ge2d.h             |  553 ++++++
 include/linux/amlogic/ge2d/ge2d_main.h        |   58 +
 include/linux/amlogic/ge2d/ge2d_wq.h          |  264 +++
 include/linux/amlogic/ge2d/ge2dgen.h          |   65 +
 include/linux/amlogic/logo/err_code.h         |   25 +
 include/linux/amlogic/logo/logo.h             |   65 +
 include/linux/amlogic/logo/logo_base_type.h   |   60 +
 include/linux/amlogic/logo/logo_dev.h         |   52 +
 include/linux/amlogic/logo/logo_parser.h      |   56 +
 include/linux/amlogic/major.h                 |   21 +
 include/linux/amlogic/osd/osd.h               |  149 ++
 include/linux/amlogic/osd/osd_dev.h           |  128 ++
 include/linux/amlogic/osd/osd_hw.h            |  119 ++
 include/linux/amlogic/osd/osd_main.h          |  197 ++
 include/linux/amlogic/tvin/tvin.h             |  782 ++++++++
 include/linux/amlogic/vout/enc_clk_config.h   |   35 +
 include/linux/amlogic/vout/vdac_switch.h      |   39 +
 include/linux/{ => amlogic}/vout/vinfo.h      |    0
 include/linux/amlogic/vout/vout_notify.h      |   95 +
 include/linux/i2c-aml.h                       |  145 ++
 sound/soc/Kconfig                             |    3 +
 sound/soc/Makefile                            |    1 +
 sound/soc/aml/Kconfig                         |  120 ++
 sound/soc/aml/Makefile                        |   81 +
 sound/soc/aml/aml.dtd                         |   59 +
 sound/soc/aml/aml_alsa_common.h               |   12 +
 sound/soc/aml/aml_audio_hw.c                  | 1191 ++++++++++++
 sound/soc/aml/aml_audio_hw.h                  |  202 ++
 sound/soc/aml/aml_audio_hw_pcm2bt.c           |  314 ++++
 sound/soc/aml/aml_audio_hw_pcm2bt.h           |   21 +
 sound/soc/aml/aml_dai.c                       |  308 ++++
 sound/soc/aml/aml_dai.h                       |    6 +
 sound/soc/aml/aml_m1.c                        |  156 ++
 sound/soc/aml/aml_m1_armdev_wm8900.c          |  446 +++++
 sound/soc/aml/aml_m1_codec.c                  |  509 +++++
 sound/soc/aml/aml_m1_codec.h                  |    7 +
 sound/soc/aml/aml_m1_mid_cs42l52.c            |  340 ++++
 sound/soc/aml/aml_m1_mid_rt5621.c             |  351 ++++
 sound/soc/aml/aml_m1_mid_wm8900.c             |  338 ++++
 sound/soc/aml/aml_m3.c                        |  352 ++++
 sound/soc/aml/aml_m3_codec.c                  |  970 ++++++++++
 sound/soc/aml/aml_m3_codec.h                  |    7 +
 sound/soc/aml/aml_m6_rt3261.c                 |  651 +++++++
 sound/soc/aml/aml_m6_rt5631.c                 |  536 ++++++
 sound/soc/aml/aml_m6_wm8960.c                 |  624 +++++++
 sound/soc/aml/aml_m6tv_audio.c                |  338 ++++
 sound/soc/aml/aml_m8.c                        |  658 +++++++
 sound/soc/aml/aml_m_dummy.c                   |  338 ++++
 sound/soc/aml/aml_mixer.c                     |  371 ++++
 sound/soc/aml/aml_notify.c                    |   43 +
 sound/soc/aml/aml_pcm.c                       | 1633 +++++++++++++++++
 sound/soc/aml/aml_pcm.h                       |   75 +
 sound/soc/aml/aml_platform.c                  |  573 ++++++
 sound/soc/aml/aml_platform.h                  |   36 +
 sound/soc/aml/aml_platform_pcm2bt.c           |  687 +++++++
 sound/soc/aml/aml_platform_pcm2bt.h           |    6 +
 sound/soc/aml/aml_syno9629_codec.c            | 1213 ++++++++++++
 sound/soc/aml/aml_syno9629_codec.h            |  215 +++
 114 files changed, 18605 insertions(+), 89 deletions(-)
 mode change 100644 => 100755 drivers/amlogic/audiodsp/dsp_codec.c
 mode change 100644 => 100755 drivers/amlogic/audiodsp/pcmenc_module.c
 mode change 100644 => 100755 drivers/amlogic/audiodsp/pcmenc_stream.c
 mode change 100644 => 100755 drivers/amlogic/audiodsp/spdif_module.c
 mode change 100644 => 100755 drivers/amlogic/display/vout/vdac_switch.c
 create mode 100755 include/linux/amlogic/aml_bl.h
 create mode 100755 include/linux/amlogic/amlog.h
 create mode 100755 include/linux/amlogic/amports/amaudio.h
 create mode 100755 include/linux/amlogic/amports/amstream.h
 create mode 100755 include/linux/amlogic/amports/canvas.h
 create mode 100755 include/linux/amlogic/amports/dsp_register.h
 create mode 100755 include/linux/amlogic/amports/ptsserv.h
 create mode 100755 include/linux/amlogic/amports/timestamp.h
 create mode 100755 include/linux/amlogic/amports/tsync.h
 create mode 100755 include/linux/amlogic/amports/ve.h
 create mode 100755 include/linux/amlogic/amports/vframe.h
 create mode 100755 include/linux/amlogic/amports/vframe_provider.h
 create mode 100755 include/linux/amlogic/amports/vframe_receiver.h
 create mode 100755 include/linux/amlogic/ge2d/bitblt.h
 create mode 100755 include/linux/amlogic/ge2d/ge2d.h
 create mode 100755 include/linux/amlogic/ge2d/ge2d_main.h
 create mode 100755 include/linux/amlogic/ge2d/ge2d_wq.h
 create mode 100755 include/linux/amlogic/ge2d/ge2dgen.h
 create mode 100755 include/linux/amlogic/logo/err_code.h
 create mode 100755 include/linux/amlogic/logo/logo.h
 create mode 100755 include/linux/amlogic/logo/logo_base_type.h
 create mode 100755 include/linux/amlogic/logo/logo_dev.h
 create mode 100755 include/linux/amlogic/logo/logo_parser.h
 create mode 100755 include/linux/amlogic/major.h
 create mode 100755 include/linux/amlogic/osd/osd.h
 create mode 100755 include/linux/amlogic/osd/osd_dev.h
 create mode 100755 include/linux/amlogic/osd/osd_hw.h
 create mode 100755 include/linux/amlogic/osd/osd_main.h
 create mode 100755 include/linux/amlogic/tvin/tvin.h
 create mode 100755 include/linux/amlogic/vout/enc_clk_config.h
 create mode 100755 include/linux/amlogic/vout/vdac_switch.h
 rename include/linux/{ => amlogic}/vout/vinfo.h (100%)
 create mode 100755 include/linux/amlogic/vout/vout_notify.h
 create mode 100755 include/linux/i2c-aml.h
 mode change 100644 => 100755 sound/soc/Kconfig
 mode change 100644 => 100755 sound/soc/Makefile
 create mode 100755 sound/soc/aml/Kconfig
 create mode 100755 sound/soc/aml/Makefile
 create mode 100755 sound/soc/aml/aml.dtd
 create mode 100644 sound/soc/aml/aml_alsa_common.h
 create mode 100755 sound/soc/aml/aml_audio_hw.c
 create mode 100755 sound/soc/aml/aml_audio_hw.h
 create mode 100755 sound/soc/aml/aml_audio_hw_pcm2bt.c
 create mode 100755 sound/soc/aml/aml_audio_hw_pcm2bt.h
 create mode 100755 sound/soc/aml/aml_dai.c
 create mode 100644 sound/soc/aml/aml_dai.h
 create mode 100644 sound/soc/aml/aml_m1.c
 create mode 100644 sound/soc/aml/aml_m1_armdev_wm8900.c
 create mode 100644 sound/soc/aml/aml_m1_codec.c
 create mode 100644 sound/soc/aml/aml_m1_codec.h
 create mode 100644 sound/soc/aml/aml_m1_mid_cs42l52.c
 create mode 100644 sound/soc/aml/aml_m1_mid_rt5621.c
 create mode 100644 sound/soc/aml/aml_m1_mid_wm8900.c
 create mode 100644 sound/soc/aml/aml_m3.c
 create mode 100644 sound/soc/aml/aml_m3_codec.c
 create mode 100644 sound/soc/aml/aml_m3_codec.h
 create mode 100755 sound/soc/aml/aml_m6_rt3261.c
 create mode 100755 sound/soc/aml/aml_m6_rt5631.c
 create mode 100644 sound/soc/aml/aml_m6_wm8960.c
 create mode 100644 sound/soc/aml/aml_m6tv_audio.c
 create mode 100755 sound/soc/aml/aml_m8.c
 create mode 100755 sound/soc/aml/aml_m_dummy.c
 create mode 100644 sound/soc/aml/aml_mixer.c
 create mode 100644 sound/soc/aml/aml_notify.c
 create mode 100755 sound/soc/aml/aml_pcm.c
 create mode 100755 sound/soc/aml/aml_pcm.h
 create mode 100755 sound/soc/aml/aml_platform.c
 create mode 100755 sound/soc/aml/aml_platform.h
 create mode 100755 sound/soc/aml/aml_platform_pcm2bt.c
 create mode 100755 sound/soc/aml/aml_platform_pcm2bt.h
 create mode 100644 sound/soc/aml/aml_syno9629_codec.c
 create mode 100644 sound/soc/aml/aml_syno9629_codec.h

diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 96c819783558..7f598b0189b0 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -24,16 +24,15 @@ CONFIG_VFP=y
 CONFIG_NEON=y
 CONFIG_BINFMT_MISC=y
 # CONFIG_SUSPEND is not set
+CONFIG_I2C_AML=y
 # CONFIG_AML_RTC is not set
 # CONFIG_MESON_INPUT_REMOTE is not set
 # CONFIG_MESON_INPUT_KEYBOARD is not set
 CONFIG_EFUSE=y
+CONFIG_AML_NEXT_GEN_NAND=y
 # CONFIG_AMAUDIO is not set
-# CONFIG_AM_DISPLAY_MODULE is not set
-# CONFIG_AML_HDMI_TX is not set
-# CONFIG_TVIN is not set
-# CONFIG_UMP is not set
-# CONFIG_MALI400 is not set
+# CONFIG_AM_LCD_OUTPUT is not set
+CONFIG_FB_AM=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
@@ -46,8 +45,12 @@ CONFIG_OF_SELFTEST=y
 CONFIG_SERIO_LIBPS2=y
 CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
 # CONFIG_HWMON is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
 # CONFIG_HID is not set
 # CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
 # CONFIG_IOMMU_SUPPORT is not set
 # CONFIG_FILE_LOCKING is not set
 # CONFIG_DNOTIFY is not set
diff --git a/arch/arm/mach-meson8/vpu.c b/arch/arm/mach-meson8/vpu.c
index 374e2145abfb..4771baefa61f 100755
--- a/arch/arm/mach-meson8/vpu.c
+++ b/arch/arm/mach-meson8/vpu.c
@@ -14,7 +14,7 @@
 #include <plat/io.h>
 #include <mach/am_regs.h>
 #include <mach/vpu.h>
-#include <linux/vout/vinfo.h>
+#include <linux/amlogic/vout/vinfo.h>
 
 #define VPU_VERION	"v01"
 
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index d680f8a6183a..a2f0b4c27ff6 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -15,14 +15,14 @@ source "drivers/amlogic/uart/Kconfig"
 source "drivers/amlogic/of/Kconfig"
 source "drivers/amlogic/rtc/Kconfig"
 source "drivers/amlogic/i2c/Kconfig"
-#source "drivers/amlogic/input/Kconfig"
+source "drivers/amlogic/input/Kconfig"
 source "drivers/amlogic/gpio/Kconfig"
 source "drivers/amlogic/pinctrl/Kconfig"
 source "drivers/amlogic/power/Kconfig"
 #source "drivers/amlogic/securitykeys/Kconfig"
 #source "drivers/amlogic/keymanage/Kconfig"
 #source "drivers/amlogic/extern_io/Kconfig"
-#source "drivers/amlogic/gpio/Kconfig"
+source "drivers/amlogic/gpio/Kconfig"
 #source "drivers/amlogic/minilvds/Kconfig"
 source "drivers/amlogic/efuse/Kconfig"
 #source "drivers/amlogic/smartcard/Kconfig"
@@ -37,12 +37,12 @@ source "drivers/amlogic/efuse/Kconfig"
 #	Block devices
 #
 #comment "Block devices"
-#source "drivers/amlogic/usb/Kconfig"
+source "drivers/amlogic/usb/Kconfig"
 #source "drivers/amlogic/cardreader/Kconfig"
-#source "drivers/amlogic/mmc/Kconfig"
+source "drivers/amlogic/mmc/Kconfig"
 #source "drivers/amlogic/spi_nor/Kconfig"
 #source "drivers/amlogic/nand/Kconfig"
-#source "drivers/amlogic/amlnf/Kconfig"
+source "drivers/amlogic/amlnf/Kconfig"
 
 #
 #	Network devices
@@ -58,17 +58,17 @@ source "drivers/amlogic/efuse/Kconfig"
 #  Audio
 #
 #comment "Audio devices"
-#source "drivers/amlogic/amaudio/Kconfig"
-#source "drivers/amlogic/audiodsp/Kconfig"
+source "drivers/amlogic/amaudio/Kconfig"
+source "drivers/amlogic/audiodsp/Kconfig"
 
 #
 #  Video
 #
 #comment "Video devices"
-#source "drivers/amlogic/amports/Kconfig"
-#source "drivers/amlogic/canvas/Kconfig"
-#source "drivers/amlogic/display/Kconfig"
-#source "drivers/amlogic/hdmi/Kconfig"
+source "drivers/amlogic/amports/Kconfig"
+source "drivers/amlogic/canvas/Kconfig"
+source "drivers/amlogic/display/Kconfig"
+source "drivers/amlogic/hdmi/Kconfig"
 #source "drivers/amlogic/tvin/Kconfig"
 #source "drivers/amlogic/cmem/Kconfig"
 #source "drivers/amlogic/jpeglogo/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index ae01463908f8..e95d538511ce 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -55,7 +55,7 @@ obj-$(CONFIG_I2C) += i2c/
 
 obj-$(CONFIG_AMLOGIC_SPI_NOR) += spi_nor/
 
-obj-$(CONFIG_CARDREADER) += cardreader/
+#obj-$(CONFIG_CARDREADER) += cardreader/
 obj-$(CONFIG_MMC_AML) +=mmc/
 
 #obj-y += vfm/
@@ -82,7 +82,7 @@ obj-$(CONFIG_EFUSE)+=efuse/
 #####Sound system is later init in kernel default..######################
 obj-$(CONFIG_AMAUDIO) += amaudio/
 
-#obj-y += hdmi/
+obj-y += hdmi/
 
 ifeq ($(CONFIG_AM_NEW_TV_ARCH),y)
 #obj-$(CONFIG_AM_DVB) += dvb_tv/
diff --git a/drivers/amlogic/amaudio/amaudio.c b/drivers/amlogic/amaudio/amaudio.c
index 8d012ce16bd5..af3b842bd1b5 100755
--- a/drivers/amlogic/amaudio/amaudio.c
+++ b/drivers/amlogic/amaudio/amaudio.c
@@ -17,7 +17,7 @@
 #include <linux/sched.h>
 
 #include <mach/am_regs.h>
-#include <linux/amports/amaudio.h>
+#include <linux/amlogic/amports/amaudio.h>
 
 #include "amaudio.h"
 
diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index afd978879d70..39988725102f 100755
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -1333,7 +1333,7 @@ static int avc_mmap(struct file *filp, struct vm_area_struct *vma)
     }
     off += gAmvencbuff.buf_start;
     debug_level(0,"vma_size is %d , off is %ld \n" , vma_size ,off);
-    vma->vm_flags |= VM_RESERVED | VM_IO;
+    vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
     //vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
     if (remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
                         vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
diff --git a/drivers/amlogic/amports/jpegdec.c b/drivers/amlogic/amports/jpegdec.c
index dc3ce1e6c900..a9626dad2756 100755
--- a/drivers/amlogic/amports/jpegdec.c
+++ b/drivers/amlogic/amports/jpegdec.c
@@ -533,7 +533,7 @@ static int mmap(struct file *filp, struct vm_area_struct *vma)
     //printk("mmap:%x\n",vm_size);
     off += jegdec_mem_info.canv_addr;
 
-    vma->vm_flags |= VM_RESERVED | VM_IO;
+    vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
 
     if (remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
                         vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
diff --git a/drivers/amlogic/audiodsp/audiodsp_module.c b/drivers/amlogic/audiodsp/audiodsp_module.c
index 8776776425cb..7e58ab1d119e 100755
--- a/drivers/amlogic/audiodsp/audiodsp_module.c
+++ b/drivers/amlogic/audiodsp/audiodsp_module.c
@@ -13,7 +13,7 @@
 #include <linux/delay.h>
 #include <asm/cacheflush.h>
 #include <mach/am_regs.h>
-#include <linux/major.h>
+#include <linux/amlogic/major.h>
 #include <linux/slab.h>
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6  
@@ -24,7 +24,7 @@
 #include "audiodsp_control.h"	// temp here
 
 #include <asm/uaccess.h>
-#include <linux/amports/amstream.h>
+#include <linux/amlogic/amports/amstream.h>
 
 #include "audiodsp_module.h"
 #include "dsp_control.h"
@@ -34,9 +34,9 @@
 
 #include "dsp_codec.h"
 #include <linux/dma-mapping.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/timestamp.h>
-#include <linux/amports/tsync.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/tsync.h>
 
 extern void tsync_pcr_recover(void);extern void tsync_pcr_recover(void);
 
diff --git a/drivers/amlogic/audiodsp/audiodsp_module.h b/drivers/amlogic/audiodsp/audiodsp_module.h
index 584811777f23..e613146b59ae 100755
--- a/drivers/amlogic/audiodsp/audiodsp_module.h
+++ b/drivers/amlogic/audiodsp/audiodsp_module.h
@@ -8,7 +8,7 @@
 #include <asm/dsp/dsp_register.h>
 */
 #include "audiodsp_control.h"
-#include <linux/amports/dsp_register.h>
+#include <linux/amlogic/amports/dsp_register.h>
 
 #include "codec_message.h"
 #include <linux/dma-mapping.h>
diff --git a/drivers/amlogic/audiodsp/dsp_codec.c b/drivers/amlogic/audiodsp/dsp_codec.c
old mode 100644
new mode 100755
index c91d0cfaf88a..edf97d105f2c
--- a/drivers/amlogic/audiodsp/dsp_codec.c
+++ b/drivers/amlogic/audiodsp/dsp_codec.c
@@ -7,8 +7,8 @@
 #include <mach/am_regs.h>
 //#include <asm/bsp.h>
 
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/timestamp.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/timestamp.h>
 //#include <asm/dsp/dsp_register.h>
 
 #include "dsp_microcode.h"
diff --git a/drivers/amlogic/audiodsp/dsp_control.c b/drivers/amlogic/audiodsp/dsp_control.c
index 69434401f004..d6795e4b0f51 100755
--- a/drivers/amlogic/audiodsp/dsp_control.c
+++ b/drivers/amlogic/audiodsp/dsp_control.c
@@ -16,7 +16,7 @@
 
 
 //#include <asm/dsp/dsp_register.h>
-#include <linux/amports/dsp_register.h>
+#include <linux/amlogic/amports/dsp_register.h>
 
 
 #include "dsp_mailbox.h"
diff --git a/drivers/amlogic/audiodsp/dsp_mailbox.c b/drivers/amlogic/audiodsp/dsp_mailbox.c
index de8548475eba..babd1e7310be 100755
--- a/drivers/amlogic/audiodsp/dsp_mailbox.c
+++ b/drivers/amlogic/audiodsp/dsp_mailbox.c
@@ -16,8 +16,8 @@
 //#include <asm/arch/am_regs.h>
 #include <mach/am_regs.h>
 
-#include <linux/amports/tsync.h>
-#include <linux/amports/timestamp.h>
+#include <linux/amlogic/amports/tsync.h>
+#include <linux/amlogic/amports/timestamp.h>
 #include "dsp_mailbox.h"
 #include "dsp_codec.h"
 extern void set_pcminfo_data(void * pcm_encoded_info);
diff --git a/drivers/amlogic/audiodsp/dsp_microcode.c b/drivers/amlogic/audiodsp/dsp_microcode.c
index fec28e7a9faa..33745b9ebb80 100755
--- a/drivers/amlogic/audiodsp/dsp_microcode.c
+++ b/drivers/amlogic/audiodsp/dsp_microcode.c
@@ -13,7 +13,7 @@
 #include "audiodsp_control.h"
 
 #include <linux/firmware.h>
-#include <linux/major.h>
+#include <linux/amlogic/major.h>
 #include <linux/device.h>
 
 
diff --git a/drivers/amlogic/audiodsp/pcmenc_module.c b/drivers/amlogic/audiodsp/pcmenc_module.c
old mode 100644
new mode 100755
index 68e69af4f068..dd1fd10b93f3
--- a/drivers/amlogic/audiodsp/pcmenc_module.c
+++ b/drivers/amlogic/audiodsp/pcmenc_module.c
@@ -17,7 +17,7 @@
 #include <linux/mm.h>
 #include <mach/am_regs.h>
 #include "pcmenc_stream.h"	
-#include <linux/amports/dsp_register.h>
+#include <linux/amlogic/amports/dsp_register.h>
 
 
 
@@ -228,7 +228,7 @@ static int audiodsp_pcmenc_mmap(struct file *filp, struct vm_area_struct *vma)
     }
     off += virt_to_phys((void*)priv_data.stream_buffer_start);
 
-    vma->vm_flags |= VM_RESERVED | VM_IO;
+    vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
 
     if (remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
                         vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
diff --git a/drivers/amlogic/audiodsp/pcmenc_stream.c b/drivers/amlogic/audiodsp/pcmenc_stream.c
old mode 100644
new mode 100755
index aa7f0538bcb0..486f24453363
--- a/drivers/amlogic/audiodsp/pcmenc_stream.c
+++ b/drivers/amlogic/audiodsp/pcmenc_stream.c
@@ -10,7 +10,7 @@
  *******************************************************************/
 
 #include "pcmenc_stream.h"
-#include <linux/amports/dsp_register.h>
+#include <linux/amlogic/amports/dsp_register.h>
 #include <linux/dma-mapping.h>
 
 typedef struct
diff --git a/drivers/amlogic/audiodsp/spdif_module.c b/drivers/amlogic/audiodsp/spdif_module.c
old mode 100644
new mode 100755
index 932ef3622e12..12df2b7d886d
--- a/drivers/amlogic/audiodsp/spdif_module.c
+++ b/drivers/amlogic/audiodsp/spdif_module.c
@@ -18,7 +18,7 @@
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
 #include <mach/am_regs.h>
-#include <linux/amports/dsp_register.h>
+#include <linux/amlogic/amports/dsp_register.h>
 
 #include "spdif_module.h"
 
@@ -154,7 +154,7 @@ static int audio_spdif_mmap(struct file *file, struct vm_area_struct *vma)
     }
     off = READ_MPEG_REG(AIU_MEM_IEC958_START_PTR);//mapping the 958 dma buffer to user space to write
 
-    vma->vm_flags |= VM_RESERVED | VM_IO/*|VM_MAYWRITE|VM_MAYSHARE*/;
+    vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO/*|VM_MAYWRITE|VM_MAYSHARE*/;
     if (remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
                         vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
         printk("	audio spdif : failed remap_pfn_range\n");
diff --git a/drivers/amlogic/canvas/canvas.c b/drivers/amlogic/canvas/canvas.c
index 694ce8e88f7e..3499b4047369 100755
--- a/drivers/amlogic/canvas/canvas.c
+++ b/drivers/amlogic/canvas/canvas.c
@@ -28,7 +28,7 @@
 #include <linux/major.h>
 #include <mach/am_regs.h>
 #include <mach/canvas.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/amports/canvas.h>
 
 #define DRIVER_NAME "amcanvas"
 #define MODULE_NAME "amcanvas"
diff --git a/drivers/amlogic/display/osd/osd_dev.c b/drivers/amlogic/display/osd/osd_dev.c
index 3df286daf7e6..e27a85bf2b32 100755
--- a/drivers/amlogic/display/osd/osd_dev.c
+++ b/drivers/amlogic/display/osd/osd_dev.c
@@ -29,9 +29,9 @@
 #include <linux/fb.h>
 #include <mach/am_regs.h>
 
-#include <linux/osd/osd.h>
-#include <linux/osd/osd_dev.h>
-#include <linux/osd/osd_hw.h>
+#include <linux/amlogic/osd/osd.h>
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/osd/osd_hw.h>
 /* to-do: TV output mode should be configured by
  * sysfs attribute
  */
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index b136cf6f3200..c36734abcbe0 100755
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -31,12 +31,12 @@
 #include <linux/irq.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
-#include <linux/osd/osd.h>
-#include <linux/vout/vout_notify.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/osd/osd.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/amports/canvas.h>
 #include "osd_log.h"
-#include <linux/amlog.h>
-#include <linux/amports/vframe_receiver.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
 #include "osd_hw_def.h"
 #include "osd_prot.h"
 //#include <mach/utils.h>
diff --git a/drivers/amlogic/display/osd/osd_hw_def.h b/drivers/amlogic/display/osd/osd_hw_def.h
index fb40bdd98bd6..da019ed4a0a8 100755
--- a/drivers/amlogic/display/osd/osd_hw_def.h
+++ b/drivers/amlogic/display/osd/osd_hw_def.h
@@ -1,7 +1,7 @@
 #ifndef   _OSD_HW_DEF_H
 #define	_OSD_HW_DEF_H
-#include <linux/osd/osd_hw.h>
-#include <linux/amports/vframe_provider.h>
+#include <linux/amlogic/osd/osd_hw.h>
+#include <linux/amlogic/amports/vframe_provider.h>
 #include <plat/fiq_bridge.h>
 
 /************************************************************************
diff --git a/drivers/amlogic/display/osd/osd_main.c b/drivers/amlogic/display/osd/osd_main.c
index dc9bcaead208..ac0e33b0e20e 100755
--- a/drivers/amlogic/display/osd/osd_main.c
+++ b/drivers/amlogic/display/osd/osd_main.c
@@ -41,13 +41,13 @@
 #include <linux/file.h>
 #include <linux/fdtable.h>
 #include <linux/console.h>
-#include <linux/osd/osd_main.h>
-#include <linux/osd/osd_dev.h>
+#include <linux/amlogic/osd/osd_main.h>
+#include <linux/amlogic/osd/osd_dev.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
 #include <linux/of.h>
 #include "osd_log.h"
-#include <linux/amlog.h>
+#include <linux/amlogic/amlog.h>
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend early_suspend;
diff --git a/drivers/amlogic/display/osd/osd_prot.c b/drivers/amlogic/display/osd/osd_prot.c
index b4757e9b0f23..d9cc442e3967 100755
--- a/drivers/amlogic/display/osd/osd_prot.c
+++ b/drivers/amlogic/display/osd/osd_prot.c
@@ -31,11 +31,11 @@
 #include <linux/irq.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
-#include <linux/osd/osd.h>
-#include <linux/vout/vout_notify.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/osd/osd.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/amports/canvas.h>
 #include "osd_log.h"
-#include <linux/amlog.h>
+#include <linux/amlogic/amlog.h>
 #include "osd_prot.h"
 int osd_set_prot(unsigned char   x_rev,
                 unsigned char   y_rev,
diff --git a/drivers/amlogic/display/osd/osd_prot.h b/drivers/amlogic/display/osd/osd_prot.h
index ec389fef0cb4..7d634bea8442 100755
--- a/drivers/amlogic/display/osd/osd_prot.h
+++ b/drivers/amlogic/display/osd/osd_prot.h
@@ -1,6 +1,6 @@
 #ifndef  _OSD_PROT_H
 #define _OSD_PROT_H
-#include <linux/osd/osd_hw.h>
+#include <linux/amlogic/osd/osd_hw.h>
 
 #define  CUGT		0
 #define  CID_VALUE  	161
diff --git a/drivers/amlogic/display/vout/edp_drv.c b/drivers/amlogic/display/vout/edp_drv.c
index a941f98408dc..b3de912af06c 100755
--- a/drivers/amlogic/display/vout/edp_drv.c
+++ b/drivers/amlogic/display/vout/edp_drv.c
@@ -14,7 +14,7 @@
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
-#include <linux/logo/logo.h>
+#include <linux/amlogic/logo/logo.h>
 #include <mach/am_regs.h>
 #include <mach/clock.h>
 #include <asm/fiq.h>
diff --git a/drivers/amlogic/display/vout/enc_clk_config.c b/drivers/amlogic/display/vout/enc_clk_config.c
index 9e4635be154e..efb90a62b570 100755
--- a/drivers/amlogic/display/vout/enc_clk_config.c
+++ b/drivers/amlogic/display/vout/enc_clk_config.c
@@ -1,6 +1,6 @@
 #include <linux/kernel.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/enc_clk_config.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
 #include <mach/register.h>
 #include <mach/am_regs.h>
 #include <mach/clock.h>
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 98914d9680d2..25cedf1d837e 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -28,12 +28,12 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/string.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vout_notify.h>
-#include <linux/aml_bl.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/aml_bl.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
-#include <linux/logo/logo.h>
+#include <linux/amlogic/logo/logo.h>
 #include <mach/am_regs.h>
 #include <linux/amlogic/vout/lcd_reg.h>
 #include <linux/amlogic/vout/lcdoutc.h>
diff --git a/drivers/amlogic/display/vout/tvconf.c b/drivers/amlogic/display/vout/tvconf.c
index be95a3bbada9..3c5705aae34d 100755
--- a/drivers/amlogic/display/vout/tvconf.c
+++ b/drivers/amlogic/display/vout/tvconf.c
@@ -37,7 +37,7 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/ctype.h>
-#include <linux/vout/vinfo.h>
+#include <linux/amlogic/vout/vinfo.h>
 #include <mach/am_regs.h>
 #include <mach/vpu.h>
 #include <asm/uaccess.h>
@@ -45,7 +45,7 @@
 #include "tvconf.h"
 #include "tvmode.h"
 #include "vout_log.h"
-#include <linux/amlog.h>
+#include <linux/amlogic/amlog.h>
 #include <mach/power_gate.h>
 
 #define PIN_MUX_REG_0	  0x202c
diff --git a/drivers/amlogic/display/vout/tvconf.h b/drivers/amlogic/display/vout/tvconf.h
index f421660e1a0c..4f066c50adff 100755
--- a/drivers/amlogic/display/vout/tvconf.h
+++ b/drivers/amlogic/display/vout/tvconf.h
@@ -2,7 +2,7 @@
 #define   _TV_CONF_H
 
 #include "tvoutc.h"
-#include  <linux/vout/vout_notify.h>
+#include  <linux/amlogic/vout/vout_notify.h>
 
 
 /*****************************************************************
diff --git a/drivers/amlogic/display/vout/tvoutc.c b/drivers/amlogic/display/vout/tvoutc.c
index 4e91bee5ff3f..fc64d52e98f1 100755
--- a/drivers/amlogic/display/vout/tvoutc.c
+++ b/drivers/amlogic/display/vout/tvoutc.c
@@ -28,13 +28,13 @@
 
 #include <mach/am_regs.h>
 
-#include <linux/vout/vinfo.h>
+#include <linux/amlogic/vout/vinfo.h>
 #include "tvoutc.h"
 #include <linux/clk.h>
 #include <plat/io.h>
 #include <mach/tvregs.h>
 #include <mach/mod_gate.h>
-#include <linux/vout/enc_clk_config.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
 
 static u32 curr_vdac_setting=DEFAULT_VDAC_SEQUENCE;
 
diff --git a/drivers/amlogic/display/vout/vdac_switch.c b/drivers/amlogic/display/vout/vdac_switch.c
old mode 100644
new mode 100755
index 6325ebceaf3f..2312983eaef8
--- a/drivers/amlogic/display/vout/vdac_switch.c
+++ b/drivers/amlogic/display/vout/vdac_switch.c
@@ -31,15 +31,15 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/ctype.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vdac_switch.h>
-#include  <linux/vout/vout_notify.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vdac_switch.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #include "tvmode.h"
 #include <linux/of.h>
 #include <linux/slab.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 
-#include <linux/amlog.h>
+#include <linux/amlogic/amlog.h>
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend early_suspend;
diff --git a/drivers/amlogic/display/vout/vout_notify.c b/drivers/amlogic/display/vout/vout_notify.c
index 5ae7ce2c6ea2..fa7cfde0f42c 100755
--- a/drivers/amlogic/display/vout/vout_notify.c
+++ b/drivers/amlogic/display/vout/vout_notify.c
@@ -10,7 +10,7 @@
  *		 jianfeng_wang@amlogic
  */
 #include <linux/module.h>
-#include <linux/vout/vout_notify.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
 
diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
index adf567e285ae..3c2125137ac8 100755
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -36,14 +36,14 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/ctype.h>
-#include <linux/vout/vinfo.h>
+#include <linux/amlogic/vout/vinfo.h>
 #include <mach/am_regs.h>
 #include <asm/uaccess.h>
 #include <linux/major.h>
 #include "vout_serve.h"
 #include "tvmode.h"
 #include "vout_log.h"
-#include <linux/amlog.h>
+#include <linux/amlogic/amlog.h>
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend early_suspend;
diff --git a/drivers/amlogic/display/vout/vout_serve.h b/drivers/amlogic/display/vout/vout_serve.h
index 1f085222fce3..981257b54580 100755
--- a/drivers/amlogic/display/vout/vout_serve.h
+++ b/drivers/amlogic/display/vout/vout_serve.h
@@ -4,7 +4,7 @@
 #ifdef CONFIG_AM_TV_OUTPUT
 #include  "tvoutc.h"	
 #endif
-#include  <linux/vout/vout_notify.h>
+#include  <linux/amlogic/vout/vout_notify.h>
 
 /*****************************************************************
 **
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
index 5fee132c425e..94ccd1645c21 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
@@ -28,7 +28,7 @@
 #include <asm/delay.h>
 #include <mach/am_regs.h>
 #include <mach/power_gate.h>
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 #include <mach/gpio.h>
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 826113d1757d..80bead64d76a 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -34,7 +34,7 @@
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
-#include <linux/osd/osd_dev.h>
+#include <linux/amlogic/osd/osd_dev.h>
 #include <linux/switch.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index b26a12a6ce0a..aef299fbbe4c 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -46,7 +46,7 @@
 #include <asm/delay.h>
 #include <mach/am_regs.h>
 #include <mach/power_gate.h>
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 #include <mach/gpio.h>
 #include "hw/hdmi_tx_reg.h"
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c
index d253f90d0c48..0bb699170a16 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c
@@ -37,8 +37,8 @@
 #include <mach/power_gate.h>
 #include <linux/clk.h>
 #include <mach/clock.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/enc_clk_config.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
 
 #include "hdmi_info_global.h"
 #include "hdmi_tx_module.h"
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c
index f045c2715b91..79d832aca3cd 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c
@@ -16,7 +16,7 @@
 #include <linux/mutex.h>
 #include <linux/cdev.h>
 #include <linux/proc_fs.h> 
-#include <linux/logo/logo.h>
+#include <linux/amlogic/logo/logo.h>
 
 #include <mach/am_regs.h>
 #include <mach/io.h>
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
index f421298989cc..4ff06d27d4c6 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
@@ -38,8 +38,8 @@
 #include <mach/power_gate.h>
 #include <linux/clk.h>
 #include <mach/clock.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/enc_clk_config.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
 #include <mach/io.h>
 #include <mach/register.h>
 
diff --git a/drivers/amlogic/tvin/tvafe/tvafe.c b/drivers/amlogic/tvin/tvafe/tvafe.c
index aaf68114284e..eef5fc3fd1e9 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe.c
@@ -1234,7 +1234,7 @@ static int tvafe_mmap(struct file *file, struct vm_area_struct * vma)
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-	vma->vm_flags |= VM_IO | VM_RESERVED;
+	vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
 
 	size = vma->vm_end - vma->vm_start;
 	pfn  = off >> PAGE_SHIFT;
diff --git a/drivers/amlogic/tvin/tvafe/tvin_vbi.c b/drivers/amlogic/tvin/tvafe/tvin_vbi.c
index 6e5678e0692a..d6579dd98939 100755
--- a/drivers/amlogic/tvin/tvafe/tvin_vbi.c
+++ b/drivers/amlogic/tvin/tvafe/tvin_vbi.c
@@ -1003,7 +1003,7 @@ static int vbi_mmap(struct file *file, struct vm_area_struct * vma)
     vma->vm_pgoff = off >> PAGE_SHIFT;
 
     vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-    vma->vm_flags |= VM_IO | VM_RESERVED;
+    vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
 
     size = vma->vm_end - vma->vm_start;
     pfn  = off >> PAGE_SHIFT;
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.c b/drivers/amlogic/tvin/vdin/vdin_drv.c
index b5d350786e6e..5a6b22d76060 100755
--- a/drivers/amlogic/tvin/vdin/vdin_drv.c
+++ b/drivers/amlogic/tvin/vdin/vdin_drv.c
@@ -1809,7 +1809,7 @@ static int vdin_mmap(struct file *file, struct vm_area_struct * vma)
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-	vma->vm_flags |= VM_IO | VM_RESERVED;
+	vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
 
 	size = vma->vm_end - vma->vm_start;
 	pfn  = off >> PAGE_SHIFT;
diff --git a/include/linux/amlogic/aml_bl.h b/include/linux/amlogic/aml_bl.h
new file mode 100755
index 000000000000..71bce6b6030a
--- /dev/null
+++ b/include/linux/amlogic/aml_bl.h
@@ -0,0 +1,16 @@
+
+#ifndef __INCLUDE_AML_BL_H
+#define __INCLUDE_AML_BL_H
+
+struct aml_bl_platform_data {
+	void (*bl_init)(void);
+	void (*power_on_bl)(void);
+	void (*power_off_bl)(void);
+	unsigned (*get_bl_level)(void);
+	void (*set_bl_level)(unsigned);
+	int max_brightness;
+	int dft_brightness;
+};
+
+#endif
+
diff --git a/include/linux/amlogic/amlog.h b/include/linux/amlogic/amlog.h
new file mode 100755
index 000000000000..d7a6540c30fd
--- /dev/null
+++ b/include/linux/amlogic/amlog.h
@@ -0,0 +1,85 @@
+#ifndef __AMLOG_H
+#define __AMLOG_H
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+
+#ifdef AMLOG
+
+#define AMLOG_DEFAULT_LEVEL 0
+#define AMLOG_DEFAULT_MASK 0xffffffffUL
+#define AMLOG_DEFAULT_LEVEL_DESC "log_level."
+#define AMLOG_DEFAULT_MASK_DESC "log_mask."
+
+#define MODULE_AMLOG(def_level, def_mask, desc_level, desc_mask) \
+u32 LOG_LEVEL_VAR = def_level; \
+module_param(LOG_LEVEL_VAR, uint, S_IRWXU); \
+MODULE_PARM_DESC(LOG_LEVEL_VAR, desc_level); \
+u32 LOG_MASK_VAR = def_mask; \
+module_param(LOG_MASK_VAR, uint, S_IRWXU); \
+MODULE_PARM_DESC(LOG_MASK_VAR, desc_mask)
+
+#ifndef LOG_LEVEL_VAR
+#error LOG_LEVEL_VAR undefined.
+#endif
+
+#ifndef LOG_MASK_VAR
+#error LOG_MASK_VAR undefined.
+#endif
+
+extern u32 LOG_LEVEL_VAR, LOG_MASK_VAR;
+
+#define amlog(x...) printk(x)
+
+#define amlog_level(level, x...) \
+	do { \
+		if (level >= LOG_LEVEL_VAR) \
+			printk(x); \
+	} while (0);
+
+#define amlog_mask(mask, x...) \
+	do { \
+		if (mask & LOG_MASK_VAR) \
+			printk(x); \
+	} while (0);
+
+#define amlog_mask_level(mask, level, x...) \
+	do { \
+		if ((level >= LOG_LEVEL_VAR) && (mask & LOG_MASK_VAR)) \
+			printk(x); \
+	} while (0);
+
+#define amlog_if(cond, x...) do {if (cond) printk(x);} while {0};
+
+#define amlog_level_if(cond, level, x...) \
+	do { \
+		if ((cond) && (level >= LOG_LEVEL_VAR)) \
+			printk(x); \
+	} while (0);
+
+#define amlog_mask_if(cond, mask, x...) \
+	do { \
+		if ((cond) && (mask & LOG_MASK_VAR)) \
+			printk(x); \
+	} while (0);
+
+#define amlog_mask_levelif(cond, mask, level, x...) \
+	do { \
+		if ((cond) && (level >= LOG_LEVEL_VAR) && (mask & LOG_MASK_VAR)) \
+			printk(x...); \
+	} while (0);
+
+#else
+#define MODULE_AMLOG(def_level, def_mask, desc_level, desc_mask)
+#define amlog(x...)
+#define amlog_level(level, x...)
+#define amlog_mask(mask, x...)
+#define amlog_mask_level(mask, level, x...)
+#define amlog_if(cond, x...)
+#define amlog_level_if(cond, level, x...)
+#define amlog_mask_if(cond, mask, x...)
+#define amlog_mask_level_if(cond, mask, level, x...)
+#endif 
+
+#endif /* __AMLOG_H */
diff --git a/include/linux/amlogic/amports/amaudio.h b/include/linux/amlogic/amports/amaudio.h
new file mode 100755
index 000000000000..742eb12e1b20
--- /dev/null
+++ b/include/linux/amlogic/amports/amaudio.h
@@ -0,0 +1,86 @@
+/*
+ * AMLOGIC Audio port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Kevin Wang <kevin.wang@amlogic.com>
+ *
+ */
+#ifndef AMAUDIO_H
+#define AMAUDIO_H
+
+#include <linux/interrupt.h>
+
+#define AMAUDIO_IOC_MAGIC  'A'
+
+#define AMAUDIO_IOC_GET_I2S_OUT_SIZE		_IOW(AMAUDIO_IOC_MAGIC, 0x00, int)
+
+#define AMAUDIO_IOC_GET_I2S_OUT_PTR			_IOW(AMAUDIO_IOC_MAGIC, 0x01, int)
+
+#define AMAUDIO_IOC_SET_I2S_OUT_RD_PTR	    _IOW(AMAUDIO_IOC_MAGIC, 0x02, int)
+
+#define AMAUDIO_IOC_GET_I2S_IN_SIZE			_IOW(AMAUDIO_IOC_MAGIC, 0x03, int)
+
+#define AMAUDIO_IOC_GET_I2S_IN_PTR			_IOW(AMAUDIO_IOC_MAGIC, 0x04, int)
+
+#define AMAUDIO_IOC_SET_I2S_IN_RD_PTR		_IOW(AMAUDIO_IOC_MAGIC, 0x05, int)
+
+#define AMAUDIO_IOC_SET_I2S_IN_MODE         _IOW(AMAUDIO_IOC_MAGIC, 0x06, int)
+
+#define AMAUDIO_IOC_SET_I2S_OUT_MODE        _IOW(AMAUDIO_IOC_MAGIC, 0x07, int)
+
+#define AMAUDIO_IOC_GET_I2S_IN_RD_PTR       _IOW(AMAUDIO_IOC_MAGIC, 0x08, int)
+
+#define AMAUDIO_IOC_GET_I2S_OUT_RD_PTR      _IOW(AMAUDIO_IOC_MAGIC, 0x09, int)
+
+#define AMAUDIO_IOC_SET_I2S_IN_WR_PTR       _IOW(AMAUDIO_IOC_MAGIC, 0x0a, int)
+
+#define AMAUDIO_IOC_SET_I2S_OUT_WR_PTR      _IOW(AMAUDIO_IOC_MAGIC, 0x0b, int)
+
+#define AMAUDIO_IOC_GET_I2S_IN_WR_PTR       _IOW(AMAUDIO_IOC_MAGIC, 0x0c, int)
+
+#define AMAUDIO_IOC_GET_I2S_OUT_WR_PTR      _IOW(AMAUDIO_IOC_MAGIC, 0x0d, int)
+
+#define AMAUDIO_IOC_SET_LEFT_MONO		_IOW(AMAUDIO_IOC_MAGIC, 0x0e, int)
+
+#define AMAUDIO_IOC_SET_RIGHT_MONO		_IOW(AMAUDIO_IOC_MAGIC, 0x0f, int)
+
+#define AMAUDIO_IOC_SET_STEREO			_IOW(AMAUDIO_IOC_MAGIC, 0x10, int)
+
+#define AMAUDIO_IOC_SET_CHANNEL_SWAP		_IOW(AMAUDIO_IOC_MAGIC, 0x11, int)
+
+#define AMAUDIO_IOC_DIRECT_AUDIO			_IOW(AMAUDIO_IOC_MAGIC, 0x12, int)
+
+#define AMAUDIO_IOC_DIRECT_LEFT_GAIN  _IOW(AMAUDIO_IOC_MAGIC, 0x13, int)
+
+#define AMAUDIO_IOC_DIRECT_RIGHT_GAIN _IOW(AMAUDIO_IOC_MAGIC, 0x14, int)
+#define AMAUDIO_IOC_START_LINE_IN           _IOW(AMAUDIO_IOC_MAGIC, 0x15, int)
+#define AMAUDIO_IOC_START_HDMI_IN           _IOW(AMAUDIO_IOC_MAGIC, 0x16, int)
+#define AMAUDIO_IOC_STOP_LINE_IN            _IOW(AMAUDIO_IOC_MAGIC, 0x17, int)
+#define AMAUDIO_IOC_STOP_HDMI_IN            _IOW(AMAUDIO_IOC_MAGIC, 0x18, int)
+#define AMAUDIO_IOC_SET_RESAMPLE_ENA        _IOW(AMAUDIO_IOC_MAGIC, 0x19, unsigned long)
+#define AMAUDIO_IOC_GET_RESAMPLE_ENA        _IOR(AMAUDIO_IOC_MAGIC, 0x1a, unsigned long)
+#define AMAUDIO_IOC_SET_RESAMPLE_TYPE       _IOW(AMAUDIO_IOC_MAGIC, 0x1b, unsigned long)
+#define AMAUDIO_IOC_GET_RESAMPLE_TYPE       _IOR(AMAUDIO_IOC_MAGIC, 0x1c, unsigned long)
+#define AMAUDIO_IOC_SET_RESAMPLE_DELTA      _IOW(AMAUDIO_IOC_MAGIC, 0x1d, unsigned long)
+#define AMAUDIO_IOC_GET_RESAMPLE_DELTA      _IOW(AMAUDIO_IOC_MAGIC, 0x1e, unsigned long)
+
+
+
+#define DIRECT_AUDIO_OFF	0
+#define DIRECT_AUDIO_ON	    1
+
+#endif
+
diff --git a/include/linux/amlogic/amports/amstream.h b/include/linux/amlogic/amports/amstream.h
new file mode 100755
index 000000000000..eb1fe23b7efa
--- /dev/null
+++ b/include/linux/amlogic/amports/amstream.h
@@ -0,0 +1,318 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef AMSTREAM_H
+#define AMSTREAM_H
+
+//#include <linux/interrupt.h>
+#include "ve.h"
+
+#ifdef __KERNEL__
+#define PORT_FLAG_IN_USE    0x0001
+#define PORT_FLAG_VFORMAT   0x0002
+#define PORT_FLAG_AFORMAT   0x0004
+#define PORT_FLAG_FORMAT    (PORT_FLAG_VFORMAT | PORT_FLAG_AFORMAT)
+#define PORT_FLAG_VID       0x0008
+#define PORT_FLAG_AID       0x0010
+#define PORT_FLAG_SID       0x0020
+#define PORT_FLAG_UD       0x0040
+#define PORT_FLAG_DRM       0x0080
+#define PORT_FLAG_ID        (PORT_FLAG_VID | PORT_FLAG_AID | PORT_FLAG_SID | PORT_FLAG_UD)
+#define PORT_FLAG_INITED    0x100
+
+#define PORT_TYPE_VIDEO     0x01
+#define PORT_TYPE_AUDIO     0x02
+#define PORT_TYPE_MPTS      0x04
+#define PORT_TYPE_MPPS      0x08
+#define PORT_TYPE_ES        0x10
+#define PORT_TYPE_RM        0x20
+#define PORT_TYPE_SUB       0x40
+#define PORT_TYPE_SUB_RD    0x80
+#define PORT_TYPE_USERDATA	0x200
+#endif
+
+#define AMSTREAM_IOC_MAGIC  'S'
+
+#define AMSTREAM_IOC_VB_START   _IOW(AMSTREAM_IOC_MAGIC, 0x00, int)
+#define AMSTREAM_IOC_VB_SIZE    _IOW(AMSTREAM_IOC_MAGIC, 0x01, int)
+#define AMSTREAM_IOC_AB_START   _IOW(AMSTREAM_IOC_MAGIC, 0x02, int)
+#define AMSTREAM_IOC_AB_SIZE    _IOW(AMSTREAM_IOC_MAGIC, 0x03, int)
+#define AMSTREAM_IOC_VFORMAT    _IOW(AMSTREAM_IOC_MAGIC, 0x04, int)
+#define AMSTREAM_IOC_AFORMAT    _IOW(AMSTREAM_IOC_MAGIC, 0x05, int)
+#define AMSTREAM_IOC_VID        _IOW(AMSTREAM_IOC_MAGIC, 0x06, int)
+#define AMSTREAM_IOC_AID        _IOW(AMSTREAM_IOC_MAGIC, 0x07, int)
+#define AMSTREAM_IOC_VB_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x08, unsigned long)
+#define AMSTREAM_IOC_AB_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x09, unsigned long)
+#define AMSTREAM_IOC_SYSINFO    _IOW(AMSTREAM_IOC_MAGIC, 0x0a, int)
+#define AMSTREAM_IOC_ACHANNEL   _IOW(AMSTREAM_IOC_MAGIC, 0x0b, int)
+#define AMSTREAM_IOC_SAMPLERATE _IOW(AMSTREAM_IOC_MAGIC, 0x0c, int)
+#define AMSTREAM_IOC_DATAWIDTH  _IOW(AMSTREAM_IOC_MAGIC, 0x0d, int)
+#define AMSTREAM_IOC_TSTAMP     _IOW(AMSTREAM_IOC_MAGIC, 0x0e, unsigned long)
+#define AMSTREAM_IOC_VDECSTAT   _IOR(AMSTREAM_IOC_MAGIC, 0x0f, unsigned long)
+#define AMSTREAM_IOC_ADECSTAT   _IOR(AMSTREAM_IOC_MAGIC, 0x10, unsigned long)
+
+#define AMSTREAM_IOC_PORT_INIT   _IO(AMSTREAM_IOC_MAGIC, 0x11)
+#define AMSTREAM_IOC_TRICKMODE  _IOW(AMSTREAM_IOC_MAGIC, 0x12, unsigned long)
+
+#define AMSTREAM_IOC_AUDIO_INFO	_IOW(AMSTREAM_IOC_MAGIC, 0x13, unsigned long)
+#define AMSTREAM_IOC_TRICK_STAT  _IOR(AMSTREAM_IOC_MAGIC, 0x14, unsigned long)
+#define AMSTREAM_IOC_AUDIO_RESET _IO(AMSTREAM_IOC_MAGIC, 0x15)
+#define AMSTREAM_IOC_SID         _IOW(AMSTREAM_IOC_MAGIC, 0x16, int)
+#define AMSTREAM_IOC_VPAUSE      _IOW(AMSTREAM_IOC_MAGIC, 0x17, int)
+#define AMSTREAM_IOC_AVTHRESH   _IOW(AMSTREAM_IOC_MAGIC, 0x18, int)
+#define AMSTREAM_IOC_SYNCTHRESH _IOW(AMSTREAM_IOC_MAGIC, 0x19, int)
+#define AMSTREAM_IOC_SUB_RESET   _IOW(AMSTREAM_IOC_MAGIC, 0x1a, int)
+#define AMSTREAM_IOC_SUB_LENGTH  _IOR(AMSTREAM_IOC_MAGIC, 0x1b, unsigned long)
+#define AMSTREAM_IOC_SET_DEC_RESET _IOW(AMSTREAM_IOC_MAGIC, 0x1c, int)
+#define AMSTREAM_IOC_TS_SKIPBYTE _IOW(AMSTREAM_IOC_MAGIC, 0x1d, int)
+#define AMSTREAM_IOC_SUB_TYPE    _IOW(AMSTREAM_IOC_MAGIC, 0x1e, int)
+#define AMSTREAM_IOC_CLEAR_VIDEO _IOW(AMSTREAM_IOC_MAGIC, 0x1f, int)
+
+#define AMSTREAM_IOC_APTS             _IOR(AMSTREAM_IOC_MAGIC, 0x40, unsigned long)
+#define AMSTREAM_IOC_VPTS             _IOR(AMSTREAM_IOC_MAGIC, 0x41, unsigned long)
+#define AMSTREAM_IOC_PCRSCR           _IOR(AMSTREAM_IOC_MAGIC, 0x42, unsigned long)
+#define AMSTREAM_IOC_SYNCENABLE      _IOW(AMSTREAM_IOC_MAGIC, 0x43, unsigned long)
+#define AMSTREAM_IOC_GET_SYNC_ADISCON  _IOR(AMSTREAM_IOC_MAGIC, 0x44, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_ADISCON  _IOW(AMSTREAM_IOC_MAGIC, 0x45, unsigned long)
+#define AMSTREAM_IOC_GET_SYNC_VDISCON  _IOR(AMSTREAM_IOC_MAGIC, 0x46, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_VDISCON  _IOW(AMSTREAM_IOC_MAGIC, 0x47, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_DISABLE  _IOR(AMSTREAM_IOC_MAGIC, 0x48, unsigned long)
+#define AMSTREAM_IOC_SET_VIDEO_DISABLE  _IOW(AMSTREAM_IOC_MAGIC, 0x49, unsigned long)
+#define AMSTREAM_IOC_SET_PCRSCR       _IOW(AMSTREAM_IOC_MAGIC, 0x4a, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_AXIS   _IOR(AMSTREAM_IOC_MAGIC, 0x4b, unsigned long)
+#define AMSTREAM_IOC_SET_VIDEO_AXIS   _IOW(AMSTREAM_IOC_MAGIC, 0x4c, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_CROP   _IOR(AMSTREAM_IOC_MAGIC, 0x4d, unsigned long)
+#define AMSTREAM_IOC_SET_VIDEO_CROP   _IOW(AMSTREAM_IOC_MAGIC, 0x4e, unsigned long)
+
+// VPP.VE IOCTL command list
+#define AMSTREAM_IOC_VE_BEXT   _IOW(AMSTREAM_IOC_MAGIC, 0x20, struct ve_bext_s  )
+#define AMSTREAM_IOC_VE_DNLP   _IOW(AMSTREAM_IOC_MAGIC, 0x21, struct ve_dnlp_s  )
+#define AMSTREAM_IOC_VE_HSVS   _IOW(AMSTREAM_IOC_MAGIC, 0x22, struct ve_hsvs_s  )
+#define AMSTREAM_IOC_VE_CCOR   _IOW(AMSTREAM_IOC_MAGIC, 0x23, struct ve_ccor_s  )
+#define AMSTREAM_IOC_VE_BENH   _IOW(AMSTREAM_IOC_MAGIC, 0x24, struct ve_benh_s  )
+#define AMSTREAM_IOC_VE_DEMO   _IOW(AMSTREAM_IOC_MAGIC, 0x25, struct ve_demo_s  )
+#define AMSTREAM_IOC_VE_VDO_MEAS _IOW(AMSTREAM_IOC_MAGIC, 0x27, struct vdo_meas_s )
+#define AMSTREAM_IOC_VE_DEBUG    _IOWR(AMSTREAM_IOC_MAGIC, 0x28, unsigned long long)
+#define AMSTREAM_IOC_VE_REGMAP   _IOW(AMSTREAM_IOC_MAGIC, 0x29, struct ve_regmap_s)
+
+// VPP.CM IOCTL command list
+#define AMSTREAM_IOC_CM_REGION _IOW(AMSTREAM_IOC_MAGIC, 0x30, struct cm_region_s)
+#define AMSTREAM_IOC_CM_TOP    _IOW(AMSTREAM_IOC_MAGIC, 0x31, struct cm_top_s   )
+#define AMSTREAM_IOC_CM_DEMO   _IOW(AMSTREAM_IOC_MAGIC, 0x32, struct cm_demo_s  )
+#define AMSTREAM_IOC_CM_DEBUG  _IOWR(AMSTREAM_IOC_MAGIC, 0x33, unsigned long long)
+#define AMSTREAM_IOC_CM_REGMAP  _IOW(AMSTREAM_IOC_MAGIC, 0x34, struct cm_regmap_s)
+
+#define AMSTREAM_IOC_SUB_NUM	_IOR(AMSTREAM_IOC_MAGIC, 0x50, unsigned long)
+#define AMSTREAM_IOC_SUB_INFO	_IOR(AMSTREAM_IOC_MAGIC, 0x51, unsigned long)
+#define AMSTREAM_IOC_GET_BLACKOUT_POLICY   _IOR(AMSTREAM_IOC_MAGIC, 0x52, unsigned long)
+#define AMSTREAM_IOC_SET_BLACKOUT_POLICY   _IOW(AMSTREAM_IOC_MAGIC, 0x53, unsigned long)
+#define AMSTREAM_IOC_GET_SCREEN_MODE _IOR(AMSTREAM_IOC_MAGIC, 0x58, int)
+#define AMSTREAM_IOC_SET_SCREEN_MODE _IOW(AMSTREAM_IOC_MAGIC, 0x59, int)
+#define AMSTREAM_IOC_GET_VIDEO_DISCONTINUE_REPORT _IOR(AMSTREAM_IOC_MAGIC, 0x5a, int)
+#define AMSTREAM_IOC_SET_VIDEO_DISCONTINUE_REPORT _IOW(AMSTREAM_IOC_MAGIC, 0x5b, int)
+#define AMSTREAM_IOC_VF_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x60, unsigned long)
+#define AMSTREAM_IOC_CLEAR_VBUF _IO(AMSTREAM_IOC_MAGIC, 0x80)
+
+#define AMSTREAM_IOC_APTS_LOOKUP    _IOR(AMSTREAM_IOC_MAGIC, 0x81, unsigned long)
+#define GET_FIRST_APTS_FLAG    _IOR(AMSTREAM_IOC_MAGIC, 0x82, long)
+
+#define AMSTREAM_IOC_GET_SYNC_ADISCON_DIFF  _IOR(AMSTREAM_IOC_MAGIC, 0x83, unsigned long)
+#define AMSTREAM_IOC_GET_SYNC_VDISCON_DIFF  _IOR(AMSTREAM_IOC_MAGIC, 0x84, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_ADISCON_DIFF  _IOW(AMSTREAM_IOC_MAGIC, 0x85, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_VDISCON_DIFF  _IOW(AMSTREAM_IOC_MAGIC, 0x86, unsigned long)
+#define AMSTREAM_IOC_GET_FREERUN_MODE  _IOR(AMSTREAM_IOC_MAGIC, 0x87, unsigned long)
+#define AMSTREAM_IOC_SET_FREERUN_MODE  _IOW(AMSTREAM_IOC_MAGIC, 0x88, unsigned long)
+#define AMSTREAM_IOC_SET_VSYNC_UPINT   _IOW(AMSTREAM_IOC_MAGIC, 0x89, unsigned long)
+#define AMSTREAM_IOC_SET_DEMUX  _IOW(AMSTREAM_IOC_MAGIC, 0x90, unsigned long)
+#define AMSTREAM_IOC_SET_DRMMODE _IOW(AMSTREAM_IOC_MAGIC, 0x91, unsigned long)
+
+#define AMSTREAM_IOC_SET_VIDEO_DELAY_LIMIT_MS _IOW(AMSTREAM_IOC_MAGIC, 0xa0, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_DELAY_LIMIT_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa1, unsigned long)
+#define AMSTREAM_IOC_SET_AUDIO_DELAY_LIMIT_MS _IOW(AMSTREAM_IOC_MAGIC, 0xa2, unsigned long)
+#define AMSTREAM_IOC_GET_AUDIO_DELAY_LIMIT_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa3, unsigned long)
+#define AMSTREAM_IOC_GET_AUDIO_CUR_DELAY_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa4, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_CUR_DELAY_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa5, unsigned long)
+#define AMSTREAM_IOC_GET_AUDIO_AVG_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xa6, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_AVG_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xa7, unsigned long)
+#define AMSTREAM_IOC_SET_APTS                  _IOW(AMSTREAM_IOC_MAGIC, 0xa8, unsigned long)                
+#define AMSTREAM_IOC_GET_LAST_CHECKIN_APTS   _IOR(AMSTREAM_IOC_MAGIC, 0xa9, unsigned long)
+#define AMSTREAM_IOC_GET_LAST_CHECKIN_VPTS   _IOR(AMSTREAM_IOC_MAGIC, 0xaa, unsigned long)
+#define AMSTREAM_IOC_GET_LAST_CHECKOUT_APTS  _IOR(AMSTREAM_IOC_MAGIC, 0xab, unsigned long)
+#define AMSTREAM_IOC_GET_LAST_CHECKOUT_VPTS  _IOR(AMSTREAM_IOC_MAGIC, 0xac, unsigned long)
+
+#define TRICKMODE_NONE       0x00
+#define TRICKMODE_I          0x01
+#define TRICKMODE_FFFB       0x02
+
+#define TRICK_STAT_DONE     0x01
+#define TRICK_STAT_WAIT     0x00
+
+#define AUDIO_EXTRA_DATA_SIZE   (4096)
+#define MAX_SUB_NUM		32
+
+#define MAX_STREAMBUFFER_SIZE (1024*1024*15)
+
+
+enum VIDEO_DEC_TYPE
+{
+        VIDEO_DEC_FORMAT_UNKNOW,
+        VIDEO_DEC_FORMAT_MPEG4_3,
+        VIDEO_DEC_FORMAT_MPEG4_4,
+        VIDEO_DEC_FORMAT_MPEG4_5,
+        VIDEO_DEC_FORMAT_H264,
+        VIDEO_DEC_FORMAT_MJPEG,
+        VIDEO_DEC_FORMAT_MP4,
+        VIDEO_DEC_FORMAT_H263,
+        VIDEO_DEC_FORMAT_REAL_8,
+        VIDEO_DEC_FORMAT_REAL_9,
+        VIDEO_DEC_FORMAT_WMV3,
+        VIDEO_DEC_FORMAT_WVC1,
+        VIDEO_DEC_FORMAT_SW,
+    	VIDEO_DEC_FORMAT_MAX
+};
+
+struct buf_status {
+        int size;
+        int data_len;
+        int free_len;
+        unsigned int read_pointer;
+        unsigned int write_pointer;
+};
+
+
+struct vdec_status {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fps;
+        unsigned int error_count;
+        unsigned int status;
+};
+
+struct adec_status {
+        unsigned int channels;
+        unsigned int sample_rate;
+        unsigned int resolution;
+        unsigned int error_count;
+        unsigned int status;
+};
+
+struct am_io_param {
+    union {
+          int data;
+          int id;//get bufstatus? //or others
+    };
+
+    int len; //buffer size;
+
+    union {
+        char buf[1];
+        struct buf_status status;
+        struct vdec_status vstatus;
+        struct adec_status astatus;
+    };
+};
+struct audio_info {
+    int valid;
+    int sample_rate;
+    int channels;
+    int bitrate;
+    int codec_id;
+    int block_align;
+    int extradata_size;
+    char extradata[AUDIO_EXTRA_DATA_SIZE];
+};
+
+struct dec_sysinfo {
+    unsigned int    format;
+    unsigned int    width;
+    unsigned int    height;
+    unsigned int    rate;
+    unsigned int    extra;
+    unsigned int    status;
+    unsigned int    ratio;
+    void *          param;
+	unsigned long long    ratio64;
+};
+
+struct subtitle_info
+{
+    unsigned char id;      
+    unsigned char width;
+    unsigned char height;
+    unsigned char type;    
+};
+
+struct codec_profile_t
+{
+	char *name;		// video codec short name 
+	char *profile;	// Attributes,seperated by commas 
+};
+#define SUPPORT_VDEC_NUM	(8)
+
+int vcodec_profile_register(const struct codec_profile_t *vdec_profile);
+ssize_t vcodec_profile_read(char *buf);
+
+#ifdef __KERNEL__
+#ifdef ENABLE_DEMUX_DRIVER
+/*TS demux operation interface*/
+struct tsdemux_ops {
+    int (*reset)(void);
+    int (*set_reset_flag)(void);
+    int (*request_irq)(irq_handler_t handler, void *data);
+    int (*free_irq)(void);
+    int (*set_vid)(int vpid);
+    int (*set_aid)(int apid);
+    int (*set_sid)(int spid);
+    int (*set_skipbyte)(int skipbyte);
+    int (*set_demux)(int dev);	
+};
+
+void tsdemux_set_ops(struct tsdemux_ops *ops);
+int tsdemux_set_reset_flag(void);
+
+#endif /*ENABLE_DEMUX_DRIVER*/
+void set_vdec_func(int (*vdec_func)(struct vdec_status *));
+void set_adec_func(int (*adec_func)(struct adec_status *));
+void set_trickmode_func(int (*trickmode_func)(unsigned long trickmode));
+void wakeup_sub_poll(void);
+int wakeup_userdata_poll(int wp, int start_phyaddr, int buf_size);
+int get_sub_type(void);
+#endif
+
+typedef struct tcon_gamma_table_s {
+    u16 data[256];
+} tcon_gamma_table_t;
+
+typedef struct tcon_rgb_ogo_s {
+    unsigned int en;
+             int r_pre_offset;  // s11.0, range -1024~+1023, default is 0
+             int g_pre_offset;  // s11.0, range -1024~+1023, default is 0
+             int b_pre_offset;  // s11.0, range -1024~+1023, default is 0
+    unsigned int r_gain;        // u1.10, range 0~2047, default is 1024 (1.0x)
+    unsigned int g_gain;        // u1.10, range 0~2047, default is 1024 (1.0x)
+    unsigned int b_gain;        // u1.10, range 0~2047, default is 1024 (1.0x)
+             int r_post_offset; // s11.0, range -1024~+1023, default is 0
+             int g_post_offset; // s11.0, range -1024~+1023, default is 0
+             int b_post_offset; // s11.0, range -1024~+1023, default is 0
+} tcon_rgb_ogo_t;
+
+#endif /* AMSTREAM_H */
+
diff --git a/include/linux/amlogic/amports/canvas.h b/include/linux/amlogic/amports/canvas.h
new file mode 100755
index 000000000000..e6920dbf8369
--- /dev/null
+++ b/include/linux/amlogic/amports/canvas.h
@@ -0,0 +1,174 @@
+/*
+ * AMLOGIC Canvas management driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef CANVAS_H
+#define CANVAS_H
+
+#include <linux/types.h>
+#include <linux/kobject.h>
+
+#include <mach/cpu.h>
+
+typedef struct {
+    struct kobject kobj;
+    ulong addr;
+    u32 width;
+    u32 height;
+    u32 wrap;
+    u32 blkmode;
+} canvas_t;
+
+#define AMVDEC_ALL_CANVAS_INDEX 0x0
+#define AMVDEC_ALL_CANVAS_RANGE_0 0xb  // vc1/real/mpeg12/mpeg4/ jpeg logo / h264 
+#define AMVDEC_ALL_CANVAS_RANGE_1 0x17 //mjpeg
+
+#define AMVDEC_H264MVC_CANVAS_INDEX 0x78
+#define AMVDEC_H264MVC_CANVAS_MAX 0xbf
+
+#define AMVDEC_H264_4K2K_CANVAS_INDEX 0x78
+#define AMVDEC_H264_4K2K_CANVAS_MAX 0xbf
+
+#define AMVDEC_H264_CANVAS_INDEX 0x80
+#define AMVDEC_H264_CANVAS_MAX 0xbf
+
+
+//tvin camera  vdin0: 0x18-0x1d   vdin1: 0x1e-0x23, nv21 chroma: 0x24-0x2f
+#define VDIN_CAMERA_CANVAS_INDEX   0x18
+#define VDIN_CAMERA_CANVAS_MAX_INDEX 0x2f
+
+//jpeg dec
+#define JPEGDEC_CANVAS_INDEX   0//0x18//0x3a
+#define JPEGDEC_CANVAS_MAX_INDEX 5//0x1d//0x3f
+
+#define OSD1_CANVAS_INDEX 0x40
+#define OSD2_CANVAS_INDEX 0x43
+#define OSD3_CANVAS_INDEX 0x41
+#define OSD4_CANVAS_INDEX 0x42
+#define ALLOC_CANVAS_INDEX  0x46
+
+#define FREESCALE_CANVAS_INDEX 0x50   //for osd&video scale use
+#define MAX_FREESCALE_CANVAS_INDEX 0x55
+
+#define VM_CANVAS_INDEX 0x50   //vm
+#define VM_CANVAS_MAX_INDEX 0x5f
+
+#define DISPLAY_CANVAS_BASE_INDEX   0x60
+#define DISPLAY_CANVAS_MAX_INDEX    0x65
+
+/*do not define both CONFIG_VSYNC_RDMA and CONFIG_AM_VIDEO2 */
+#ifdef CONFIG_VSYNC_RDMA
+#define DISPLAY_CANVAS_BASE_INDEX2   0x10
+#define DISPLAY_CANVAS_MAX_INDEX2    0x15
+#endif
+
+#ifdef CONFIG_AM_VIDEO2
+#define DISPLAY2_CANVAS_BASE_INDEX   0x1a
+#define DISPLAY2_CANVAS_MAX_INDEX    0x1f
+#endif
+
+/*here ppmgr share the same canvas with deinterlace and mipi driver for m6*/
+#define PPMGR_CANVAS_INDEX 0x70
+#define PPMGR_DOUBLE_CANVAS_INDEX 0x74  //for double canvas use
+#define PPMGR_DEINTERLACE_BUF_CANVAS 0x77   /*for progressive mjpeg use*/
+
+#define PPMGR_DEINTERLACE_BUF_NV21_CANVAS 0x7a   /*for progressive mjpeg (nv21 output)use*/
+
+#define DI_USE_FIXED_CANVAS_IDX
+#ifdef DI_USE_FIXED_CANVAS_IDX
+#define DI_PRE_MEM_NR_CANVAS_IDX        0x70
+#define DI_PRE_CHAN2_NR_CANVAS_IDX      0x71
+#define DI_PRE_WR_NR_CANVAS_IDX         0x72
+#define DI_PRE_WR_MTN_CANVAS_IDX        0x73
+//NEW DI
+#define DI_CONTPRD_CANVAS_IDX           0x74
+#define DI_CONTP2RD_CANVAS_IDX           0x75
+#define DI_CONTWR_CANVAS_IDX            0x76
+//DI POST, share with DISPLAY
+#define DI_POST_BUF0_CANVAS_IDX         0x66
+#define DI_POST_BUF1_CANVAS_IDX         0x67
+#define DI_POST_MTNCRD_CANVAS_IDX       0x68
+#define DI_POST_MTNPRD_CANVAS_IDX       0x69
+
+#ifdef CONFIG_VSYNC_RDMA
+#define DI_POST_BUF0_CANVAS_IDX2         0x6a
+#define DI_POST_BUF1_CANVAS_IDX2         0x6b
+#define DI_POST_MTNCRD_CANVAS_IDX2       0x6c
+#define DI_POST_MTNPRD_CANVAS_IDX2       0x6d
+#endif
+
+#else
+#define DEINTERLACE_CANVAS_BASE_INDEX	0x70
+#define DEINTERLACE_CANVAS_MAX_INDEX	0x7f
+#endif
+
+#define MIPI_CANVAS_INDEX 0x70
+#define MIPI_CANVAS_MAX_INDEX 0x7f
+
+//tvin vdin0: 0x80-0x97 share with h264 decoder only for tvin&camera
+#define VDIN0_CANVAS_INDEX              0x80
+#define VDIN0_CANVAS_MAX_INDEX          0x97
+//tvin vdin1: 0x24-0x3b
+#define VDIN1_CANVAS_INDEX              0x24
+#define VDIN1_CANVAS_MAX_INDEX          0x3B
+
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+#define AMLVIDEO2_RES_CANVAS 0xD8
+#define AMLVIDEO2_MAX_RES_CANVAS 0xDB
+#else
+#define AMLVIDEO2_RES_CANVAS 0x3c
+#define AMLVIDEO2_MAX_RES_CANVAS 0x3f
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+#define AMVENC_CANVAS_INDEX 0xDC
+#define AMVENC_CANVAS_MAX_INDEX 0xE4
+
+#define D2D3_CANVAS_DPG_INDEX      0xE5
+#define D2D3_CANVAS_DBR_INDEX      0xE6
+#endif
+
+extern void canvas_config(u32 index, ulong addr, u32 width,
+                          u32 height, u32 wrap, u32 blkmode);
+
+extern void canvas_read(u32 index, canvas_t *p);
+
+extern void canvas_copy(unsigned src, unsigned dst);
+
+extern void canvas_update_addr(u32 index, u32 addr);
+
+extern unsigned int canvas_get_addr(u32 index);
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+// TODO: move to register headers
+#define CANVAS_ADDR_NOWRAP      0x00
+#define CANVAS_ADDR_WRAPX       0x01
+#define CANVAS_ADDR_WRAPY       0x02
+#define CANVAS_BLKMODE_MASK     3
+#define CANVAS_BLKMODE_BIT      24
+#define CANVAS_BLKMODE_LINEAR   0x00
+#define CANVAS_BLKMODE_32X32    0x01
+#define CANVAS_BLKMODE_64X32    0x02
+
+#endif
+
+
+#endif /* CANVAS_H */
diff --git a/include/linux/amlogic/amports/dsp_register.h b/include/linux/amlogic/amports/dsp_register.h
new file mode 100755
index 000000000000..e9afbf9c1500
--- /dev/null
+++ b/include/linux/amlogic/amports/dsp_register.h
@@ -0,0 +1,241 @@
+/*
+dsp_register.h
+*/
+#ifndef DSP_REGISTER_H
+#define DSP_REGISTER_H
+#include <linux/dma-mapping.h>
+
+#ifdef CONFIG_ARCH_MESON8
+#define SYS_MEM_START	0x00000000
+#else
+#define SYS_MEM_START	0x80000000
+#endif
+#define SYS_MEM_SIZE	0x8000000
+
+#define S_1K					(1024)
+#define S_1M					(S_1K*S_1K)
+
+#define AUDIO_DSP_MEM_SIZE		 S_1M
+#ifdef CONFIG_ARCH_MESON8
+#define AUDIO_DSP_START_PHY_ADDR 0x05000000
+#else
+#define AUDIO_DSP_START_PHY_ADDR 0x84000000
+#endif
+#define AUDIO_DSP_START_ADDR	((unsigned)phys_to_virt(AUDIO_DSP_START_PHY_ADDR))//((SYS_MEM_START+SYS_MEM_SIZE)-AUDIO_DSP_MEM_SIZE)
+#define AUDIO_DSP_END_ADDR		((AUDIO_DSP_START_ADDR+AUDIO_DSP_MEM_SIZE))
+#define REG_MEM_SIZE					(S_1K*4)
+
+
+
+
+#define DSP_REG_OFFSET	(AUDIO_DSP_START_ADDR+ AUDIO_DSP_MEM_SIZE-REG_MEM_SIZE)
+#define DSP_REG_END			(AUDIO_DSP_START_ADDR+ AUDIO_DSP_MEM_SIZE-4)
+#define DSP_REG(x)			(DSP_REG_OFFSET | ((x)<<5))
+
+#define DSP_STATUS_HALT		('H'<<24 | 'a'<<16|'l'<<8 |'t')
+#define DSP_STATUS_RUNING		('R'<<16|'u'<<8 |'n')
+#define DSP_STATUS_SLEEP    ('S'<<24 | 'L'<<16|'E'<<8 |'P')
+#define DSP_STATUS_WAKEUP   ('W'<<24 | 'A'<<16|'K'<<8 |'E')
+#define DSP_AUDIOINFO_READY ('A'<<24 | 'I'<<16|'R'<<8 |'D')
+
+#define DSP_STATUS				DSP_REG(0)
+#define DSP_JIFFIES				DSP_REG(1)
+#define DSP_STACK_START   DSP_REG(3)
+#define DSP_STACK_END   	DSP_REG(4)
+#define DSP_GP_STACK_START   DSP_REG(5)
+#define DSP_GP_STACK_END   	DSP_REG(6)
+
+#define DSP_MEM_START  		DSP_REG(7)
+#define DSP_MEM_END 	 		DSP_REG(8)
+
+
+#define DSP_DECODE_OUT_START_ADDR  	DSP_REG(9)
+#define DSP_DECODE_OUT_END_ADDR   	DSP_REG(10)
+#define DSP_DECODE_OUT_RD_ADDR  	  DSP_REG(11)
+#define DSP_DECODE_OUT_WD_ADDR  		DSP_REG(12)
+#define DSP_AUDIOINFO_STATUS              DSP_REG(13)
+#define DSP_SLEEP_STATUS                DSP_REG(14)
+//#define DEBUG_TIME_TEST
+#ifdef DEBUG_TIME_TEST
+#define DSP_TEST_TIME_VALUE                DSP_REG(15)
+#endif
+#define DSP_ARM_REF_CLK_VAL                DSP_REG(16)
+
+#define DSP_DECODE_OUT_WD_PTR       DSP_REG(18)
+#define DSP_BUFFERED_LEN  		DSP_REG(19)
+#define DSP_AFIFO_RD_OFFSET1  		DSP_REG(20)
+
+#define DSP_DECODE_OPTION       DSP_REG(21)
+#define DSP_AUDIO_FORMAT_INFO  DSP_REG(22)
+
+#define DSP_GET_EXTRA_INFO_FINISH    DSP_REG(23)
+#define DSP_HDMI_SR                  DSP_REG(24)
+
+#define DSP_LOG_START_ADDR  	DSP_REG(28)
+#define DSP_LOG_END_ADDR   	    DSP_REG(29)
+#define DSP_LOG_RD_ADDR  	    DSP_REG(30)
+#define DSP_LOG_WD_ADDR  		DSP_REG(31)
+
+#define DSP_CHIP_SUBID          DSP_REG(32)
+// other definations
+
+// for wifi-display 
+#define DSP_SKIP_BYTES          DSP_REG(38)
+
+#define MAILBOX1_REG(n)	DSP_REG(40+n)
+#define MAILBOX2_REG(n)	DSP_REG(40+32+n)
+
+
+//----------------------------------------------
+#define DSP_DECODE_51PCM_OUT_START_ADDR  	DSP_REG(106)
+#define DSP_DECODE_51PCM_OUT_END_ADDR   	DSP_REG(107)
+#define DSP_DECODE_51PCM_OUT_RD_ADDR  	    DSP_REG(108)
+#define DSP_DECODE_51PCM_OUT_WD_ADDR  		DSP_REG(109)
+//------------------------------------------------
+/*
+as iec958 ouput maybe be enabled before the spdif module inititation finish in the spdif driver,
+in this case,it will cause 958 module not work.so add a protocal register to co-work for that
+*/
+#define DSP_IEC958_INIT_READY_INFO  		DSP_REG(110) 
+#define DSP_AC3_DRC_INFO 					DSP_IEC958_INIT_READY_INFO
+#define DSP_DTS_DEC_INFO					DSP_REG(111)
+#define DSP_WORK_INFO (AUDIO_DSP_END_ADDR - 128)
+
+
+
+#ifndef __ASSEMBLY__
+/*mailbox struct*/
+struct mail_msg{
+int cmd;
+int status;//0x1:pending.0:free
+char *data;
+int len;
+};
+#endif
+
+#define M1B_IRQ0_PRINT							(0+16)
+#define M1B_IRQ1_BUF_OVERFLOW					(1+16)
+#define M1B_IRQ2_BUF_UNDERFLOW				(2+16)
+#define M1B_IRQ3_DECODE_ERROR					(3+16)
+#define M1B_IRQ4_DECODE_FINISH_FRAME 		(4+16)
+#define M1B_IRQ5_STREAM_FMT_CHANGED 			(5+16)
+#define M1B_IRQ5_STREAM_RD_WD_TEST 			(6+16)
+#define M1B_IRQ7_DECODE_FATAL_ERR			(7+16)
+#define M1B_IRQ8_IEC958_INFO                (8+16)
+
+
+#define M2B_IRQ0_DSP_HALT							(0)
+#define M2B_IRQ1_DSP_RESET						(1)
+#define M2B_IRQ2_DECODE_START					(2)
+#define M2B_IRQ3_DECODE_STOP					(3)
+#define M2B_IRQ4_AUDIO_INFO					(4)
+#define M2B_IRQ0_DSP_SLEEP					(5)
+#define M2B_IRQ0_DSP_WAKEUP					(6)
+#define M2B_IRQ0_DSP_AUDIO_EFFECT			(7) //audio post process cmd 
+
+#define CMD_PRINT_LOG					(1234<<8 |1)
+
+#if  MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 //>= m8
+#define MB0_REG EE_ASSIST_MBOX0_IRQ_REG
+#define MB0_SEL EE_ASSIST_MBOX0_FIQ_SEL
+#define MB0_CLR EE_ASSIST_MBOX0_CLR_REG
+#define MB0_MSK EE_ASSIST_MBOX0_MASK
+#define MB1_REG EE_ASSIST_MBOX1_IRQ_REG
+#define MB1_SEL EE_ASSIST_MBOX1_FIQ_SEL
+#define MB1_CLR EE_ASSIST_MBOX1_CLR_REG
+#define MB1_MSK EE_ASSIST_MBOX1_MASK
+#define MB2_REG EE_ASSIST_MBOX2_IRQ_REG
+#define MB2_SEL EE_ASSIST_MBOX2_FIQ_SEL
+#define MB2_CLR EE_ASSIST_MBOX2_CLR_REG
+#define MB2_MSK EE_ASSIST_MBOX2_MASK
+
+#define READ_VREG(r) READ_CBUS_REG(r)
+#define WRITE_VREG(r, val) WRITE_CBUS_REG(r, val)
+#define WRITE_VREG_BITS(r, val, start, len) WRITE_CBUS_REG_BITS(r, val, start, len)
+#define SET_VREG_MASK(r, mask) SET_CBUS_REG_MASK(r, mask)
+#define CLEAR_VREG_MASK(r, mask) CLEAR_CBUS_REG_MASK(r, mask)
+#else  //m6, m6tv
+#define MB0_REG VDEC_ASSIST_MBOX0_IRQ_REG
+#define MB0_SEL VDEC_ASSIST_MBOX0_FIQ_SEL
+#define MB0_CLR VDEC_ASSIST_MBOX0_CLR_REG
+#define MB0_MSK VDEC_ASSIST_MBOX0_MASK
+#define MB1_REG VDEC_ASSIST_MBOX1_IRQ_REG
+#define MB1_SEL VDEC_ASSIST_MBOX1_FIQ_SEL
+#define MB1_CLR VDEC_ASSIST_MBOX1_CLR_REG
+#define MB1_MSK VDEC_ASSIST_MBOX1_MASK
+#define MB2_REG VDEC_ASSIST_MBOX2_IRQ_REG
+#define MB2_SEL VDEC_ASSIST_MBOX2_FIQ_SEL
+#define MB2_CLR VDEC_ASSIST_MBOX2_CLR_REG
+#define MB2_MSK VDEC_ASSIST_MBOX2_MASK
+
+#define READ_VREG(r) (__raw_readl(DOS_REG_ADDR(r)))
+#define WRITE_VREG(r, val) __raw_writel(val, DOS_REG_ADDR(r))
+#define WRITE_VREG_BITS(r, val, start, len) \
+    WRITE_VREG(r, (READ_VREG(r) & ~(((1L<<(len))-1)<<(start)))|((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#define SET_VREG_MASK(r, mask) WRITE_VREG(r, READ_VREG(r) | (mask))
+#define CLEAR_VREG_MASK(r, mask) WRITE_VREG(r, READ_VREG(r) & ~(mask))
+#endif
+#else // < m6
+#define MB0_REG ASSIST_MBOX0_IRQ_REG
+#define MB0_SEL ASSIST_MBOX0_FIQ_SEL
+#define MB0_CLR ASSIST_MBOX0_CLR_REG
+#define MB0_MSK ASSIST_MBOX0_MASK
+#define MB1_REG ASSIST_MBOX1_IRQ_REG
+#define MB1_SEL ASSIST_MBOX1_FIQ_SEL
+#define MB1_CLR ASSIST_MBOX1_CLR_REG
+#define MB1_MSK ASSIST_MBOX1_MASK
+#define MB2_REG ASSIST_MBOX2_IRQ_REG
+#define MB2_SEL ASSIST_MBOX2_FIQ_SEL
+#define MB2_CLR ASSIST_MBOX2_CLR_REG
+#define MB2_MSK ASSIST_MBOX2_MASK
+
+#define READ_VREG(r) READ_CBUS_REG(r)
+#define WRITE_VREG(r, val) WRITE_CBUS_REG(r, val)
+#define WRITE_VREG_BITS(r, val, start, len) WRITE_CBUS_REG_BITS(r, val, start, len)
+#define SET_VREG_MASK(r, mask) SET_CBUS_REG_MASK(r, mask)
+#define CLEAR_VREG_MASK(r, mask) CLEAR_CBUS_REG_MASK(r, mask)
+
+#endif
+
+#define MDEC_TRIGGER_IRQ(irq)	{SET_VREG_MASK(MB0_SEL,1<<irq);\
+								WRITE_VREG(MB0_REG,1<<irq);}
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 //>= m8
+#define SYS_TRIGGER_IRQ(irq)		{/*SET_VREG_MASK(MB1_SEL,1<<irq);*/ \
+								WRITE_VREG(MB1_REG,1<<irq);}
+#define SYS_CLEAR_IRQ(irq)		{/*CLEAR_VREG_MASK(MB1_SEL,1<<irq); */\
+								WRITE_VREG(MB1_CLR,1<<irq);}
+#define DSP_TRIGGER_IRQ(irq)		{/*SET_VREG_MASK(MB2_SEL,1<<irq); */\
+								WRITE_VREG(MB2_REG,1<<irq);}
+#else
+#define SYS_TRIGGER_IRQ(irq)		{SET_VREG_MASK(MB1_SEL,1<<irq); \
+								WRITE_VREG(MB1_REG,1<<irq);}
+#define SYS_CLEAR_IRQ(irq)		{CLEAR_VREG_MASK(MB1_SEL,1<<irq); \
+								WRITE_VREG(MB1_CLR,1<<irq);}
+#define DSP_TRIGGER_IRQ(irq)		{SET_VREG_MASK(MB2_SEL,1<<irq); \
+								WRITE_VREG(MB2_REG,1<<irq);}
+#endif
+
+
+#define MDEC_CLEAR_IRQ(irq)		{CLEAR_VREG_MASK(MB0_SEL,1<<irq); \
+								WRITE_VREG(MB0_CLR,1<<irq);}
+
+
+
+#define DSP_CLEAR_IRQ(irq)		{CLEAR_VREG_MASK(MB2_SEL,1<<irq); \
+								WRITE_VREG(MB2_CLR,1<<irq);}
+
+
+#define MAIBOX0_IRQ_ENABLE(irq)		SET_VREG_MASK(MB0_MSK,1<<irq)
+#define MAIBOX1_IRQ_ENABLE(irq)		SET_VREG_MASK(MB1_MSK,1<<irq)
+#define MAIBOX2_IRQ_ENABLE(irq)		SET_VREG_MASK(MB2_MSK,1<<irq)
+
+#define ARC_2_ARM_ADDR_SWAP(addr)  ((unsigned long)(phys_to_virt(addr)))
+#define ARM_2_ARC_ADDR_SWAP(addr)  (virt_to_phys((void*)addr))
+
+#define DSP_RD(reg)	  (*((volatile unsigned long *)reg))
+#define DSP_WD(reg,val)	({(*((volatile unsigned long *)(reg)))=val;})
+
+#endif
+
+
diff --git a/include/linux/amlogic/amports/ptsserv.h b/include/linux/amlogic/amports/ptsserv.h
new file mode 100755
index 000000000000..e00b652dce1a
--- /dev/null
+++ b/include/linux/amlogic/amports/ptsserv.h
@@ -0,0 +1,65 @@
+/*
+ * AMLOGIC PTS Manager Driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef PTSSERV_H
+#define PTSSERV_H
+
+enum {
+    PTS_TYPE_VIDEO = 0,
+    PTS_TYPE_AUDIO = 1,
+    PTS_TYPE_MAX   = 2
+};
+
+#define apts_checkin(x) pts_checkin(PTS_TYPE_AUDIO, (x))
+#define vpts_checkin(x) pts_checkin(PTS_TYPE_VIDEO, (x))
+
+#ifndef CALC_CACHED_TIME
+#define CALC_CACHED_TIME
+#endif
+extern int pts_checkin(u8 type, u32 val);
+
+extern int pts_checkin_wrptr(u8 type, u32 ptr, u32 val);
+
+extern int pts_checkin_offset(u8 type, u32 offset, u32 val);
+
+extern int get_last_checkin_pts(u8 type);
+
+extern int get_last_checkout_pts(u8 type);
+
+extern int pts_lookup(u8 type, u32 *val, u32 pts_margin);
+
+extern int pts_lookup_offset(u8 type, u32 offset, u32 *val, u32 pts_margin);
+
+extern int pts_set_resolution(u8 type, u32 level);
+
+extern int pts_set_rec_size(u8 type, u32 val);
+
+extern int pts_start(u8 type);
+
+extern int pts_stop(u8 type);
+
+extern int first_lookup_pts_failed(u8 type);
+
+extern int first_pts_checkin_complete(u8 type);
+extern int calculation_stream_delayed_ms(u8 type,u32 *latestbirate,u32*avg_bitare);
+
+
+#endif /* PTSSERV_H */
diff --git a/include/linux/amlogic/amports/timestamp.h b/include/linux/amlogic/amports/timestamp.h
new file mode 100755
index 000000000000..7d79faa4652c
--- /dev/null
+++ b/include/linux/amlogic/amports/timestamp.h
@@ -0,0 +1,53 @@
+/*
+ * AMLOGIC PTS Manager Driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef TIMESTAMP_H
+#define TIMESTAMP_H
+
+extern u32 timestamp_vpts_get(void);
+
+extern void timestamp_vpts_set(u32 pts);
+
+extern void timestamp_vpts_inc(s32 val);
+
+extern u32 timestamp_apts_get(void);
+
+extern void timestamp_apts_set(u32 pts);
+
+extern void timestamp_apts_inc(s32 val);
+
+extern u32 timestamp_pcrscr_get(void);
+
+extern void timestamp_pcrscr_set(u32 pts);
+
+extern void timestamp_pcrscr_inc(s32 val);
+
+extern void timestamp_pcrscr_enable(u32 enable);
+
+extern void timestamp_pcrscr_set_adj(s32 inc);
+
+extern void timestamp_apts_enable(u32 enable);
+
+extern void  timestamp_apts_start(u32 enable);
+
+extern u32 timestamp_apts_started(void);
+
+#endif /* TIMESTAMP_H */
diff --git a/include/linux/amlogic/amports/tsync.h b/include/linux/amlogic/amports/tsync.h
new file mode 100755
index 000000000000..dc56c3ff67be
--- /dev/null
+++ b/include/linux/amlogic/amports/tsync.h
@@ -0,0 +1,108 @@
+/*
+ * AMLOGIC PTS Manager Driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef TSYNC_H
+#define TSYNC_H
+
+#define TIME_UNIT90K    (90000)
+#define VIDEO_HOLD_THRESHOLD        (TIME_UNIT90K * 3)
+#define VIDEO_HOLD_SLOWSYNC_THRESHOLD        (TIME_UNIT90K / 10)
+#define AV_DISCONTINUE_THREDHOLD_MIN    (TIME_UNIT90K * 3)
+#define AV_DISCONTINUE_THREDHOLD_MAX    (TIME_UNIT90K * 60)
+
+typedef enum {
+    VIDEO_START,
+    VIDEO_PAUSE,
+    VIDEO_STOP,
+    VIDEO_TSTAMP_DISCONTINUITY,
+    AUDIO_START,
+    AUDIO_PAUSE,
+    AUDIO_RESUME,
+    AUDIO_STOP,
+    AUDIO_TSTAMP_DISCONTINUITY,
+    AUDIO_PRE_START
+} avevent_t;
+
+typedef enum {
+    TSYNC_MODE_VMASTER,
+    TSYNC_MODE_AMASTER,
+} tsync_mode_t;
+
+extern void tsync_avevent_locked(avevent_t event, u32 param);
+
+extern void tsync_mode_reinit(void);
+
+extern void tsync_avevent(avevent_t event, u32 param);
+
+extern void tsync_audio_break(int audio_break);
+
+extern void tsync_trick_mode(int trick_mode);
+
+extern void tsync_set_avthresh(unsigned int av_thresh);
+
+extern void tsync_set_syncthresh(unsigned int sync_thresh);
+
+extern void tsync_set_dec_reset(void);
+
+extern void tsync_set_enable(int enable);
+
+extern int tsync_get_sync_adiscont(void);
+
+extern int tsync_get_sync_vdiscont(void);
+
+extern void tsync_set_sync_adiscont(int syncdiscont);
+
+extern void tsync_set_sync_vdiscont(int syncdiscont);
+
+extern u32 tsync_get_sync_adiscont_diff(void);
+
+extern u32 tsync_get_sync_vdiscont_diff(void);
+
+extern void tsync_set_sync_adiscont_diff(u32 discontinue_diff);
+
+extern void tsync_set_sync_vdiscont_diff(u32 discontinue_diff);
+extern int tsync_set_apts(unsigned pts);
+
+
+
+extern void tsync_set_automute_on(int automute_on);
+
+extern int tsync_get_debug_pts_checkin(void);
+
+extern int tsync_get_debug_pts_checkout(void);
+
+extern int tsync_get_debug_vpts(void);
+
+extern int tsync_get_debug_apts(void);
+extern int tsync_get_av_threshold_min(void);
+
+extern int tsync_get_av_threshold_max(void);
+
+extern int tsync_set_av_threshold_min(int min);
+
+extern int tsync_set_av_threshold_max(int max);
+
+static inline u32 tsync_vpts_discontinuity_margin(void)
+{
+    return tsync_get_av_threshold_min();
+}
+
+#endif /* TSYNC_H */
diff --git a/include/linux/amlogic/amports/ve.h b/include/linux/amlogic/amports/ve.h
new file mode 100755
index 000000000000..2f57cea2665a
--- /dev/null
+++ b/include/linux/amlogic/amports/ve.h
@@ -0,0 +1,184 @@
+/*
+ * Video Enhancement
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __VE_H
+#define __VE_H
+
+// ***************************************************************************
+// *** enum definitions *********************************************
+// ***************************************************************************
+
+typedef enum ve_demo_pos_e {
+  VE_DEMO_POS_TOP = 0,
+  VE_DEMO_POS_BOTTOM,
+  VE_DEMO_POS_LEFT,
+  VE_DEMO_POS_RIGHT,
+} ve_demo_pos_t;
+
+typedef enum ve_dnlp_rt_e {
+	VE_DNLP_RT_0S = 0,
+	VE_DNLP_RT_1S = 6,
+    VE_DNLP_RT_2S,
+    VE_DNLP_RT_4S,
+    VE_DNLP_RT_8S,
+    VE_DNLP_RT_16S,
+    VE_DNLP_RT_32S,
+    VE_DNLP_RT_64S,
+    VE_DNLP_RT_FREEZE,
+} ve_dnlp_rt_t;
+
+// ***************************************************************************
+// *** struct definitions *********************************************
+// ***************************************************************************
+
+typedef struct ve_bext_s {
+    unsigned char en;
+    unsigned char start;
+    unsigned char slope1;
+    unsigned char midpt;
+    unsigned char slope2;
+} ve_bext_t;
+#if defined(CONFIG_AM_VECM)
+typedef struct ve_dnlp_s {
+    unsigned int      en;
+    unsigned int rt;    //       0 ~ 255,
+    unsigned int rl;    //       0 ~  15, 1.0000x ~ 1.9375x, step 0.0625x
+    unsigned int black; //       0 ~  16, weak ~ strong
+    unsigned int white; //       0 ~  16, weak ~ strong
+} ve_dnlp_t;
+#else
+typedef struct ve_dnlp_s {
+    unsigned char en;
+    enum  ve_dnlp_rt_e rt;
+    unsigned char gamma[64];
+} ve_dnlp_t;
+#endif
+typedef struct ve_hsvs_s {
+    unsigned char en;
+    unsigned char peak_gain_h1;
+    unsigned char peak_gain_h2;
+    unsigned char peak_gain_h3;
+    unsigned char peak_gain_h4;
+    unsigned char peak_gain_h5;
+    unsigned char peak_gain_v1;
+    unsigned char peak_gain_v2;
+    unsigned char peak_gain_v3;
+    unsigned char peak_gain_v4;
+    unsigned char peak_gain_v5;
+    unsigned char peak_gain_v6;
+    unsigned char hpeak_slope1;
+    unsigned char hpeak_slope2;
+    unsigned char hpeak_thr1;
+    unsigned char hpeak_thr2;
+    unsigned char hpeak_nlp_cor_thr;
+    unsigned char hpeak_nlp_gain_pos;
+    unsigned char hpeak_nlp_gain_neg;
+    unsigned char vpeak_slope1;
+    unsigned char vpeak_slope2;
+    unsigned char vpeak_thr1;
+    unsigned char vpeak_thr2;
+    unsigned char vpeak_nlp_cor_thr;
+    unsigned char vpeak_nlp_gain_pos;
+    unsigned char vpeak_nlp_gain_neg;
+    unsigned char speak_slope1;
+    unsigned char speak_slope2;
+    unsigned char speak_thr1;
+    unsigned char speak_thr2;
+    unsigned char speak_nlp_cor_thr;
+    unsigned char speak_nlp_gain_pos;
+    unsigned char speak_nlp_gain_neg;
+    unsigned char peak_cor_gain;
+    unsigned char peak_cor_thr_l;
+    unsigned char peak_cor_thr_h;
+    unsigned char vlti_step;
+    unsigned char vlti_step2;
+    unsigned char vlti_thr;
+    unsigned char vlti_gain_pos;
+    unsigned char vlti_gain_neg;
+    unsigned char vlti_blend_factor;
+    unsigned char hlti_step;
+    unsigned char hlti_thr;
+    unsigned char hlti_gain_pos;
+    unsigned char hlti_gain_neg;
+    unsigned char hlti_blend_factor;
+    unsigned char vlimit_coef_h;
+    unsigned char vlimit_coef_l;
+    unsigned char hlimit_coef_h;
+    unsigned char hlimit_coef_l;
+    unsigned char cti_444_422_en;
+    unsigned char cti_422_444_en;
+    unsigned char cti_blend_factor;
+    unsigned char vcti_buf_en;
+    unsigned char vcti_buf_mode_c5l;
+    unsigned char vcti_filter;
+    unsigned char hcti_step;
+    unsigned char hcti_step2;
+    unsigned char hcti_thr;
+    unsigned char hcti_gain;
+    unsigned char hcti_mode_median;
+} ve_hsvs_t;
+
+typedef struct ve_ccor_s {
+    unsigned char en;
+    unsigned char slope;
+    unsigned char thr;
+} ve_ccor_t;
+
+typedef struct ve_benh_s {
+    unsigned char en;
+    unsigned char cb_inc;
+    unsigned char cr_inc;
+    unsigned char gain_cr;
+    unsigned char gain_cb4cr;
+    unsigned char luma_h;
+    unsigned char err_crp;
+    unsigned char err_crn;
+    unsigned char err_cbp;
+    unsigned char err_cbn;
+} ve_benh_t;
+
+typedef struct ve_cbar_s {
+    unsigned char en;
+    unsigned char wid;
+    unsigned char cr;
+    unsigned char cb;
+    unsigned char y;
+} ve_cbar_t;
+typedef struct ve_demo_s {
+    unsigned char bext;
+    unsigned char dnlp;
+    unsigned char hsvs;
+    unsigned char ccor;
+    unsigned char benh;
+    enum  ve_demo_pos_e  pos;
+    unsigned long wid;
+    struct ve_cbar_s   cbar;
+} ve_demo_t;
+
+typedef struct vdo_meas_s {
+    //...
+} vdo_meas_t;
+
+typedef struct ve_regmap_s {
+    unsigned long reg[43];
+} ve_regmap_t;
+
+// ***************************************************************************
+// *** MACRO definitions **********
+// ***************************************************************************
+
+// ***************************************************************************
+// *** FUNCTION definitions **********
+// ***************************************************************************
+
+#endif  // _VE_H
diff --git a/include/linux/amlogic/amports/vframe.h b/include/linux/amlogic/amports/vframe.h
new file mode 100755
index 000000000000..be4479ef1604
--- /dev/null
+++ b/include/linux/amlogic/amports/vframe.h
@@ -0,0 +1,216 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef VFRAME_H
+#define VFRAME_H
+
+#include <mach/cpu.h>
+
+#include <linux/types.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#define VIDTYPE_PROGRESSIVE             0x0
+#define VIDTYPE_INTERLACE_TOP           0x1
+#define VIDTYPE_INTERLACE_BOTTOM        0x3
+#define VIDTYPE_TYPEMASK                0x7
+#define VIDTYPE_INTERLACE               0x1
+#define VIDTYPE_INTERLACE_FIRST         0x8
+#define VIDTYPE_MVC                     0x10
+#define VIDTYPE_NO_VIDEO_ENABLE         0x20
+#define VIDTYPE_VIU_422                 0x800
+#define VIDTYPE_VIU_FIELD               0x1000
+#define VIDTYPE_VIU_SINGLE_PLANE        0x2000
+#define VIDTYPE_VIU_444                 0x4000
+#define VIDTYPE_VIU_NV21                0x8000
+#define VIDTYPE_VSCALE_DISABLE          0x10000
+#define VIDTYPE_CANVAS_TOGGLE           0x20000
+#define VIDTYPE_PRE_INTERLACE           0x40000
+#define VIDTYPE_HIGHRUN                 0x80000
+
+#define DISP_RATIO_FORCECONFIG          0x80000000
+#define DISP_RATIO_FORCE_NORMALWIDE     0x40000000
+#define DISP_RATIO_FORCE_FULL_STRETCH   0x20000000
+#define DISP_RATIO_CTRL_MASK            0x00000003
+#define DISP_RATIO_NO_KEEPRATIO         0x00000000
+#define DISP_RATIO_KEEPRATIO            0x00000001
+#define DISP_RATIO_PORTRAIT_MODE        0x00000004
+
+#define DISP_RATIO_ASPECT_RATIO_MASK    0x0003ff00
+#define DISP_RATIO_ASPECT_RATIO_BIT     8
+#define DISP_RATIO_ASPECT_RATIO_MAX     0x3ff
+
+typedef enum pixel_aspect_ratio_e {
+        PIXEL_ASPECT_RATIO_1_1,
+        PIXEL_ASPECT_RATIO_8_9,
+        PIXEL_ASPECT_RATIO_16_15,
+} pixel_aspect_ratio_t;
+
+/*
+ * If pixel_sum[21:0] == 0, then all Histogram information are invalid
+ */
+typedef struct vframe_hist_s
+{
+        unsigned int   luma_sum;
+        unsigned int   chroma_sum;
+        unsigned int   pixel_sum;  // [31:30] POW [21:0] PIXEL_SUM
+        unsigned int   height;
+        unsigned int   width;  
+        unsigned char  luma_max;
+        unsigned char  luma_min;
+        unsigned short gamma[64];
+#ifdef AML_LOCAL_DIMMING
+        unsigned int   ldim_max[100];
+#endif
+} vframe_hist_t;
+
+
+/*
+ * If bottom == 0 or right == 0, then all Blackbar information are invalid
+ */
+typedef struct vframe_bbar_s
+{
+        unsigned short top;
+        unsigned short bottom;
+        unsigned short left;
+        unsigned short right;
+} vfame_bbar_t;
+
+
+/*
+ * If vsin == 0, then all Measurement information are invalid
+ */
+typedef struct vframe_meas_s
+{
+        //float          frin;      // Frame Rate of Video Input in the unit of Hz
+        unsigned int        vs_span_cnt;
+        unsigned long long  vs_cnt;
+        unsigned int        hs_cnt0;
+        unsigned int        hs_cnt1;
+        unsigned int        hs_cnt2;
+        unsigned int        hs_cnt3;
+        unsigned int vs_cycle;
+        unsigned int vs_stamp;
+} vframe_meas_t;
+
+typedef struct vframe_view_s {
+        int start_x;
+        int start_y;
+        unsigned int width;
+        unsigned int height;
+} vframe_view_t;
+
+/* vframe properties */
+typedef struct vframe_prop_s
+{
+        struct vframe_hist_s hist;
+        struct vframe_bbar_s bbar;
+        struct vframe_meas_s meas;
+} vframe_prop_t;
+
+typedef enum vframe_source_type_e {
+        VFRAME_SOURCE_TYPE_OTHERS = 0,
+        VFRAME_SOURCE_TYPE_TUNER,
+        VFRAME_SOURCE_TYPE_CVBS,
+        VFRAME_SOURCE_TYPE_COMP,
+        VFRAME_SOURCE_TYPE_HDMI,
+        VFRAME_SOURCE_TYPE_PPMGR,
+        VFRAME_SOURCE_TYPE_OSD,
+} vframe_source_type_t;
+
+typedef enum vframe_source_mode_e {
+        VFRAME_SOURCE_MODE_OTHERS = 0,
+        VFRAME_SOURCE_MODE_PAL,
+        VFRAME_SOURCE_MODE_NTSC,
+        VFRAME_SOURCE_MODE_SECAM,
+} vframe_source_mode_t;
+typedef enum vframe_secam_phase_e {
+        VFRAME_PHASE_DB = 0,
+        VFRAME_PHASE_DR,
+} vframe_secam_phase_t;
+typedef struct vframe_s {
+        u32 index;
+        u32 type;
+        u32 type_backup;
+        u32 blend_mode;
+        u32 duration;
+        u32 duration_pulldown;
+        u32 pts;
+        u32 flag;
+
+        u32 canvas0Addr;
+        u32 canvas1Addr;
+
+        u32 bufWidth;
+        u32 width;
+        u32 height;
+        u32 ratio_control;
+
+        u32 orientation;
+        enum vframe_source_type_e source_type;
+        enum vframe_secam_phase_e  phase;
+        enum vframe_source_mode_e source_mode;
+        tvin_sig_fmt_t sig_fmt;
+
+        enum tvin_trans_fmt  trans_fmt;
+        struct vframe_view_s left_eye;
+        struct vframe_view_s right_eye;
+        u32   mode_3d_enable ;
+
+        /* vframe extension */
+        int (*early_process_fun)(void* arg, struct vframe_s* vf);
+        int (*process_fun)(void* arg, unsigned zoom_start_x_lines,
+                        unsigned zoom_end_x_lines, unsigned zoom_start_y_lines, unsigned zoom_end_y_lines, struct vframe_s* vf);
+        void* private_data;
+#if 1
+        /* vframe properties */
+        struct vframe_prop_s prop;
+#endif
+        struct list_head list;
+        struct tvafe_vga_parm_s vga_parm;
+        /* pixel aspect ratio */
+        enum pixel_aspect_ratio_e pixel_ratio;
+} vframe_t;
+
+#if 0
+struct vframe_prop_s * vdin_get_vframe_prop(u32 index);
+#endif
+int get_curren_frame_para(int* top ,int* left , int* bottom, int* right);
+
+
+#ifdef CONFIG_VSYNC_RDMA
+int VSYNC_WR_MPEG_REG(unsigned long adr, unsigned long val);
+int VSYNC_WR_MPEG_REG_BITS(unsigned long adr, unsigned long val, unsigned long start, unsigned long len);
+unsigned long VSYNC_RD_MPEG_REG(unsigned long adr);
+#elif MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#define VSYNC_WR_MPEG_REG(adr,val) WRITE_VCBUS_REG(adr, val)
+#define VSYNC_WR_MPEG_REG_BITS(adr, val, start, len)  WRITE_VCBUS_REG_BITS(adr, val, start, len)
+#define VSYNC_RD_MPEG_REG(adr) READ_VCBUS_REG(adr)
+#else
+#define VSYNC_WR_MPEG_REG(adr,val) WRITE_MPEG_REG(adr, val)
+#define VSYNC_WR_MPEG_REG_BITS(adr, val, start, len)  WRITE_MPEG_REG_BITS(adr, val, start, len)
+#define VSYNC_RD_MPEG_REG(adr) READ_MPEG_REG(adr)
+#endif
+
+u8 is_vpp_postblend(void);
+
+void pause_video(unsigned char);
+#endif /* VFRAME_H */
+
diff --git a/include/linux/amlogic/amports/vframe_provider.h b/include/linux/amlogic/amports/vframe_provider.h
new file mode 100755
index 000000000000..491211e382b8
--- /dev/null
+++ b/include/linux/amlogic/amports/vframe_provider.h
@@ -0,0 +1,90 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef VFRAME_PROVIDER_H
+#define VFRAME_PROVIDER_H
+
+/* Standard Linux headers */
+#include <linux/list.h>
+
+/* Amlogic headers */
+#include <linux/amlogic/amports/vframe.h>
+typedef struct vframe_states {
+	int vf_pool_size;
+	int buf_free_num;
+	int buf_recycle_num;
+    int buf_avail_num;
+} vframe_states_t;
+
+#define VFRAME_EVENT_RECEIVER_GET               0x01
+#define VFRAME_EVENT_RECEIVER_PUT               0x02
+#define VFRAME_EVENT_RECEIVER_FRAME_WAIT        0x04
+#define VFRAME_EVENT_RECEIVER_POS_CHANGED       0x08
+#define VFRAME_EVENT_RECEIVER_PARAM_SET       	0x10
+#define VFRAME_EVENT_RECEIVER_RESET				0x20
+#define VFRAME_EVENT_RECEIVER_FORCE_UNREG			0x40
+
+typedef struct vframe_operations_s {
+    struct vframe_s * (*peek) (void* op_arg);
+    struct vframe_s * (*get ) (void* op_arg);
+    void (*put ) (struct vframe_s *, void* op_arg);
+    int  (*event_cb)(int type, void* data, void* private_data);
+  	int (*vf_states)(vframe_states_t *states, void* op_arg);
+} vframe_operations_t;
+
+typedef struct vframe_provider_s {
+    const char *name;
+	const struct vframe_operations_s *ops;
+  void* op_arg;
+	struct list_head list;
+} vframe_provider_t;
+
+extern struct vframe_provider_s *vf_provider_alloc(void);
+extern void vf_provider_init(struct vframe_provider_s *prov,
+    const char *name, const struct vframe_operations_s *ops, void* op_arg);
+extern void vf_provider_free(struct vframe_provider_s *prov);
+
+
+extern int vf_reg_provider(struct vframe_provider_s *prov);
+extern void vf_unreg_provider(struct vframe_provider_s *prov);
+extern int vf_notify_provider(const char* receiver_name, int event_type, void* data);
+
+void vf_light_unreg_provider(struct vframe_provider_s *prov);
+void vf_ext_light_unreg_provider(struct vframe_provider_s *prov);
+struct vframe_provider_s * vf_get_provider(const char *name);
+
+struct vframe_s *vf_peek(const char* receiver);
+struct vframe_s *vf_get(const char* receiver);
+void vf_put(struct vframe_s *vf, const char *receiver);
+
+unsigned int get_post_canvas(void);
+unsigned int vf_keep_current(void);
+void get_video_keep_buffer(unsigned long *addr, unsigned long *phys_addr);
+vframe_t* get_cur_dispbuf(void);
+int query_video_status(int type , int* value);
+
+#ifdef CONFIG_V4L_AMLOGIC_VIDEO 
+void v4l_reg_provider(struct vframe_provider_s *prov);
+void v4l_unreg_provider(void);
+const vframe_provider_t * v4l_get_vfp(void);
+#endif
+#endif /* VFRAME_PROVIDER_H */
+
diff --git a/include/linux/amlogic/amports/vframe_receiver.h b/include/linux/amlogic/amports/vframe_receiver.h
new file mode 100755
index 000000000000..8267a00a4289
--- /dev/null
+++ b/include/linux/amlogic/amports/vframe_receiver.h
@@ -0,0 +1,79 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef VFRAME_RECEIVER_H
+#define VFRAME_RECEIVER_H
+
+/* Standard Linux headers */
+#include <linux/list.h>
+
+/* Amlogic headers */
+#include <linux/amlogic/amports/vframe.h>
+
+#define VFRAME_EVENT_PROVIDER_UNREG             1
+#define VFRAME_EVENT_PROVIDER_LIGHT_UNREG       2
+#define VFRAME_EVENT_PROVIDER_START             3
+#define VFRAME_EVENT_PROVIDER_VFRAME_READY      4
+#define VFRAME_EVENT_PROVIDER_QUREY_STATE        5 
+#define VFRAME_EVENT_PROVIDER_RESET             6
+#define VFRAME_EVENT_PROVIDER_FORCE_BLACKOUT		7
+#define VFRAME_EVENT_PROVIDER_REG               8
+#define VFRAME_EVENT_PROVIDER_LIGHT_UNREG_RETURN_VFRAME   9
+#define VFRAME_EVENT_PROVIDER_DPBUF_CONFIG              10
+#define VFRAME_EVENT_PROVIDER_QUREY_VDIN2NR         11
+#define VFRAME_EVENT_PROVIDER_SET_3D_VFRAME_INTERLEAVE         12
+
+typedef enum {
+  RECEIVER_STATE_NULL = -1,
+  RECEIVER_STATE_NONE = 0,
+	RECEIVER_INACTIVE,
+	RECEIVER_ACTIVE
+}receviver_start_e;
+
+typedef struct vframe_receiver_op_s {
+    int (*event_cb)(int type, void* data, void* private_data);
+} vframe_receiver_op_t;
+
+typedef struct vframe_receiver_s {
+    const char *name;
+    const struct vframe_receiver_op_s *ops;
+    void* op_arg;
+    struct list_head list;
+} vframe_receiver_t;
+
+
+extern struct vframe_receiver_s *vf_receiver_alloc(void);
+extern void vf_receiver_init(struct vframe_receiver_s *recv,
+    const char *name, const struct vframe_receiver_op_s *ops, void* op_arg);
+extern void vf_receiver_free(struct vframe_receiver_s *recv);
+
+extern int vf_reg_receiver(struct vframe_receiver_s *recv);
+extern void vf_unreg_receiver(struct vframe_receiver_s *recv);
+
+struct vframe_receiver_s * vf_get_receiver(const char *provider_name);
+
+int vf_notify_receiver(const char* provider_name, int event_type, void* data);
+
+int vf_notify_receiver_by_name(const char* receiver_name, int event_type, void* data);
+
+
+#endif /* VFRAME_RECEIVER_H */
+
diff --git a/include/linux/amlogic/ge2d/bitblt.h b/include/linux/amlogic/ge2d/bitblt.h
new file mode 100755
index 000000000000..182791dfef94
--- /dev/null
+++ b/include/linux/amlogic/ge2d/bitblt.h
@@ -0,0 +1,99 @@
+#ifndef BITBLT_H
+#define BITBLT_H
+
+#define BLENDOP_ADD           0    //Cd = Cs*Fs+Cd*Fd
+#define BLENDOP_SUB           1    //Cd = Cs*Fs-Cd*Fd
+#define BLENDOP_REVERSE_SUB   2    //Cd = Cd*Fd-Cs*Fs
+#define BLENDOP_MIN           3    //Cd = Min(Cd*Fd,Cs*Fs)
+#define BLENDOP_MAX           4    //Cd = Max(Cd*Fd,Cs*Fs)
+#define BLENDOP_LOGIC         5    //Cd = Cs op Cd
+#define BLENDOP_LOGIC_CLEAR       (BLENDOP_LOGIC+0 )
+#define BLENDOP_LOGIC_COPY        (BLENDOP_LOGIC+1 )
+#define BLENDOP_LOGIC_NOOP        (BLENDOP_LOGIC+2 )
+#define BLENDOP_LOGIC_SET         (BLENDOP_LOGIC+3 )
+#define BLENDOP_LOGIC_COPY_INVERT (BLENDOP_LOGIC+4 )
+#define BLENDOP_LOGIC_INVERT      (BLENDOP_LOGIC+5 )
+#define BLENDOP_LOGIC_AND_REVERSE (BLENDOP_LOGIC+6 )
+#define BLENDOP_LOGIC_OR_REVERSE  (BLENDOP_LOGIC+7 )
+#define BLENDOP_LOGIC_AND         (BLENDOP_LOGIC+8 )
+#define BLENDOP_LOGIC_OR          (BLENDOP_LOGIC+9 )
+#define BLENDOP_LOGIC_NAND        (BLENDOP_LOGIC+10)
+#define BLENDOP_LOGIC_NOR         (BLENDOP_LOGIC+11)
+#define BLENDOP_LOGIC_XOR         (BLENDOP_LOGIC+12)
+#define BLENDOP_LOGIC_EQUIV       (BLENDOP_LOGIC+13)
+#define BLENDOP_LOGIC_AND_INVERT  (BLENDOP_LOGIC+14)
+#define BLENDOP_LOGIC_OR_INVERT   (BLENDOP_LOGIC+15) 
+
+static inline unsigned blendop(unsigned color_blending_mode,
+                               unsigned color_blending_src_factor,
+                               unsigned color_blending_dst_factor,
+                               unsigned alpha_blending_mode,
+                               unsigned alpha_blending_src_factor,
+                               unsigned alpha_blending_dst_factor)
+{
+    return (color_blending_mode << 24) |
+           (color_blending_src_factor << 20) |
+           (color_blending_dst_factor << 16) |
+           (alpha_blending_mode << 8) |
+           (alpha_blending_src_factor << 4) |
+           (alpha_blending_dst_factor << 0);
+}
+
+void bitblt(ge2d_context_t *wq,
+            int src_x, int src_y, int w, int h,
+            int dst_x, int dst_y);
+
+void bitblt_noblk(ge2d_context_t *wq,
+            int src_x, int src_y, int w, int h,
+            int dst_x, int dst_y);
+
+void bitblt_noalpha(ge2d_context_t *wq,
+                    int src_x, int src_y, int w, int h,
+                    int dst_x, int dst_y);
+
+void bitblt_noalpha_noblk(ge2d_context_t *wq,
+                    int src_x, int src_y, int w, int h,
+                    int dst_x, int dst_y);
+
+void stretchblt(ge2d_context_t *wq,
+                int src_x, int src_y, int src_w, int src_h,
+                int dst_x, int dst_y, int dst_w, int dst_h);
+
+void stretchblt_noblk(ge2d_context_t *wq,
+                int src_x, int src_y, int src_w, int src_h,
+                int dst_x, int dst_y, int dst_w, int dst_h);
+
+void stretchblt_noalpha(ge2d_context_t *wq,
+                        int src_x, int src_y, int src_w, int src_h,
+                        int dst_x, int dst_y, int dst_w, int dst_h);
+
+void stretchblt_noalpha_noblk(ge2d_context_t *wq,
+                        int src_x, int src_y, int src_w, int src_h,
+                        int dst_x, int dst_y, int dst_w, int dst_h);
+
+void fillrect(ge2d_context_t *wq,
+              int x, int y, int w, int h, unsigned color);
+
+void fillrect_noblk(ge2d_context_t *wq,
+              int x, int y, int w, int h, unsigned color);
+
+unsigned blendop(unsigned color_blending_mode,
+                 unsigned color_blending_src_factor,
+                 unsigned color_blending_dst_factor,
+                 unsigned alpha_blending_mode,
+                 unsigned alpha_blending_src_factor,
+                 unsigned alpha_blending_dst_factor);
+
+void blend(ge2d_context_t *wq,
+           int src_x, int src_y, int src_w, int src_h, 
+           int src2_x, int src2_y, int src2_w, int src2_h,
+           int dst_x, int dst_y, int dst_w, int dst_h,
+           int op);
+
+void blend_noblk(ge2d_context_t *wq,
+           int src_x, int src_y, int src_w, int src_h, 
+           int src2_x, int src2_y, int src2_w, int src2_h,
+           int dst_x, int dst_y, int dst_w, int dst_h,
+           int op);
+
+#endif
diff --git a/include/linux/amlogic/ge2d/ge2d.h b/include/linux/amlogic/ge2d/ge2d.h
new file mode 100755
index 000000000000..88cd39c9a30c
--- /dev/null
+++ b/include/linux/amlogic/ge2d/ge2d.h
@@ -0,0 +1,553 @@
+#ifndef _GE2D_H_
+#define _GE2D_H_
+#include <mach/am_regs.h>
+#include  <linux/module.h>
+
+#define	AVMem_kmalloc(x)	kmalloc(x,GFP_KERNEL)
+#define	AVMem_calloc(a,b)	kcalloc(a,b,GFP_KERNEL)
+#define	AVMem_free		kfree
+
+
+#define MAX_BITBLT_WORK_CONFIG 4
+#define MAX_GE2D_CMD  32   //64  
+
+#define GE2D_STATE_IDLE          0
+#define GE2D_STATE_RUNNING       1
+#define GE2D_STATE_CLEANUP       2
+#define GE2D_STATE_REMOVING_WQ 3
+#define	GE2D_PROCESS_QUEUE_START   	0
+#define	GE2D_PROCESS_QUEUE_STOP		1
+
+#define RELEASE_SRC1_CANVAS 0x01
+#define RELEASE_SRC2_CANVAS 0x02
+#define RELEASE_SRC1_BUFFER 0x04
+#define RELEASE_SRC2_BUFFER 0x08
+#define RELEASE_CB          0x10
+#define RELEASE_REQUIRED    0x1f
+
+#define START_FLAG          0x20
+#define RELEASE_FLAG        0x40
+#define FINISH_FLAG         0x80
+
+#define FORMAT_8BIT_COMPONENT   0
+    #define COMPONENT_Y_OR_R      0
+    #define COMPONENT_Cb_OR_G     1
+    #define COMPONENT_Cr_OR_B     2
+    #define COMPONENT_ALPHA       3
+#define FORMAT_422_YUV          1
+#define FORMAT_444_YUV_OR_RGB   2
+#define FORMAT_YUVA_OR_RGBA     3
+
+#define FILL_MODE_BOUNDARY_PIXEL    0
+#define FILL_MODE_DEFAULT_COLOR     1
+
+#define OPERATION_ADD           0    //Cd = Cs*Fs+Cd*Fd
+#define OPERATION_SUB           1    //Cd = Cs*Fs-Cd*Fd
+#define OPERATION_REVERSE_SUB   2    //Cd = Cd*Fd-Cs*Fs
+#define OPERATION_MIN           3    //Cd = Min(Cd*Fd,Cs*Fs)
+#define OPERATION_MAX           4    //Cd = Max(Cd*Fd,Cs*Fs)
+#define OPERATION_LOGIC         5
+
+#define COLOR_FACTOR_ZERO                     0
+#define COLOR_FACTOR_ONE                      1
+#define COLOR_FACTOR_SRC_COLOR                2
+#define COLOR_FACTOR_ONE_MINUS_SRC_COLOR      3
+#define COLOR_FACTOR_DST_COLOR                4
+#define COLOR_FACTOR_ONE_MINUS_DST_COLOR      5
+#define COLOR_FACTOR_SRC_ALPHA                6
+#define COLOR_FACTOR_ONE_MINUS_SRC_ALPHA      7
+#define COLOR_FACTOR_DST_ALPHA                8
+#define COLOR_FACTOR_ONE_MINUS_DST_ALPHA      9
+#define COLOR_FACTOR_CONST_COLOR              10
+#define COLOR_FACTOR_ONE_MINUS_CONST_COLOR    11
+#define COLOR_FACTOR_CONST_ALPHA              12
+#define COLOR_FACTOR_ONE_MINUS_CONST_ALPHA    13
+#define COLOR_FACTOR_SRC_ALPHA_SATURATE       14
+
+#define ALPHA_FACTOR_ZERO                     0
+#define ALPHA_FACTOR_ONE                      1
+#define ALPHA_FACTOR_SRC_ALPHA                2
+#define ALPHA_FACTOR_ONE_MINUS_SRC_ALPHA      3
+#define ALPHA_FACTOR_DST_ALPHA                4
+#define ALPHA_FACTOR_ONE_MINUS_DST_ALPHA      5
+#define ALPHA_FACTOR_CONST_ALPHA              6
+#define ALPHA_FACTOR_ONE_MINUS_CONST_ALPHA    7
+
+#define LOGIC_OPERATION_CLEAR       0
+#define LOGIC_OPERATION_COPY        1
+#define LOGIC_OPERATION_NOOP        2
+#define LOGIC_OPERATION_SET         3
+#define LOGIC_OPERATION_COPY_INVERT 4
+#define LOGIC_OPERATION_INVERT      5
+#define LOGIC_OPERATION_AND_REVERSE 6
+#define LOGIC_OPERATION_OR_REVERSE  7
+#define LOGIC_OPERATION_AND         8
+#define LOGIC_OPERATION_OR          9
+#define LOGIC_OPERATION_NAND        10
+#define LOGIC_OPERATION_NOR         11
+#define LOGIC_OPERATION_XOR         12
+#define LOGIC_OPERATION_EQUIV       13
+#define LOGIC_OPERATION_AND_INVERT  14
+#define LOGIC_OPERATION_OR_INVERT   15 
+
+#define DST_CLIP_MODE_INSIDE    0
+#define DST_CLIP_MODE_OUTSIDE   1
+
+#define FILTER_TYPE_BICUBIC     1
+#define FILTER_TYPE_BILINEAR    2
+#define FILTER_TYPE_TRIANGLE    3
+
+#define MATRIX_YCC_TO_RGB               1
+#define MATRIX_RGB_TO_YCC               2
+#define MATRIX_FULL_RANGE_YCC_TO_RGB    3
+
+
+#define GE2D_ENDIAN_SHIFT       	24
+#define GE2D_ENDIAN_MASK            (0x1 << GE2D_ENDIAN_SHIFT)
+#define GE2D_BIG_ENDIAN             (0 << GE2D_ENDIAN_SHIFT)
+#define GE2D_LITTLE_ENDIAN          (1 << GE2D_ENDIAN_SHIFT)
+
+#define GE2D_COLOR_MAP_SHIFT        20
+#define GE2D_COLOR_MAP_MASK         (0xf << GE2D_COLOR_MAP_SHIFT)
+/* nv12 &nv21, only works on m6*/
+#define GE2D_COLOR_MAP_NV12		(15 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_NV21		(14 << GE2D_COLOR_MAP_SHIFT)
+/* 16 bit */
+#define GE2D_COLOR_MAP_YUV422		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGB655		(1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV655		(1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGB844		(2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV844		(2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA6442     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA6442     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA4444     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA4444     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGB565       (5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV565       (5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB4444		(6 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV4444		(6 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB1555     (7 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV1555     (7 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA4642     (8 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA4642     (8 << GE2D_COLOR_MAP_SHIFT)
+/* 24 bit */
+#define GE2D_COLOR_MAP_RGB888       (0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV444       (0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA5658     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA5658     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB8565     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV8565     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA6666     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA6666     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB6666     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV6666     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_BGR888		(5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_VUY888		(5 << GE2D_COLOR_MAP_SHIFT)
+/* 32 bit */
+#define GE2D_COLOR_MAP_RGBA8888		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA8888		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB8888     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV8888     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ABGR8888     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AVUY8888     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_BGRA8888     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_VUYA8888     (3 << GE2D_COLOR_MAP_SHIFT)
+
+/* format code is defined as:
+[11] : 1-YUV color space, 0-RGB color space
+[10] : compress_range
+[9:8]: format
+[7:6]: 8bit_mode_sel
+[5]  : LUT_EN
+[4:3]: PIC_STRUCT
+[2]  : SEP_EN
+[1:0]: X_YC_RATIO, SRC1_Y_YC_RATIO
+*/
+#define GE2D_FORMAT_MASK            0x0ffff
+#define GE2D_BPP_MASK								0x00300
+#define GE2D_BPP_8BIT								0x00000
+#define GE2D_BPP_16BIT							0x00100
+#define GE2D_BPP_24BIT							0x00200
+#define GE2D_BPP_32BIT							0x00300
+#define GE2D_FORMAT_YUV             0x20000
+#define GE2D_FORMAT_COMP_RANGE      0x10000
+/*bit8(2)  format   bi6(2) mode_8b_sel  bit5(1)lut_en   bit2 sep_en*/
+/*M  seperate block S one block.*/ 
+
+#define GE2D_FMT_S8_Y            	0x00000 /* 00_00_0_00_0_00 */
+#define GE2D_FMT_S8_CB           	0x00040 /* 00_01_0_00_0_00 */
+#define GE2D_FMT_S8_CR           	0x00080 /* 00_10_0_00_0_00 */
+#define GE2D_FMT_S8_R            	0x00000 /* 00_00_0_00_0_00 */
+#define GE2D_FMT_S8_G            	0x00040 /* 00_01_0_00_0_00 */
+#define GE2D_FMT_S8_B            	0x00080 /* 00_10_0_00_0_00 */
+#define GE2D_FMT_S8_A            	0x000c0 /* 00_11_0_00_0_00 */
+#define GE2D_FMT_S8_LUT          	0x00020 /* 00_00_1_00_0_00 */
+#define GE2D_FMT_S16_YUV422      	0x20102 /* 01_00_0_00_0_00 */
+#define GE2D_FMT_S16_RGB         	(GE2D_LITTLE_ENDIAN|0x00100) /* 01_00_0_00_0_00 */
+#define GE2D_FMT_S24_YUV444      	0x20200 /* 10_00_0_00_0_00 */
+#define GE2D_FMT_S24_RGB         	(GE2D_LITTLE_ENDIAN|0x00200) /* 10_00_0_00_0_00 */
+#define GE2D_FMT_S32_YUVA444     	0x20300 /* 11_00_0_00_0_00 */
+#define GE2D_FMT_S32_RGBA        	(GE2D_LITTLE_ENDIAN|0x00300) /* 11_00_0_00_0_00 */
+#define GE2D_FMT_M24_YUV420      	0x20007 /* 00_00_0_00_1_11 */
+#define GE2D_FMT_M24_YUV422      	0x20006 /* 00_00_0_00_1_10 */
+#define GE2D_FMT_M24_YUV444      	0x20004 /* 00_00_0_00_1_00 */
+#define GE2D_FMT_M24_RGB         	0x00004 /* 00_00_0_00_1_00 */
+#define GE2D_FMT_M24_YUV420T     	0x20017 /* 00_00_0_10_1_11 */
+#define GE2D_FMT_M24_YUV420B     	0x2001f /* 00_00_0_11_1_11 */
+
+#define GE2D_FMT_M24_YUV420SP		0x20207
+#define GE2D_FMT_M24_YUV420SPT		0x20217 /* 01_00_0_00_1_11 nv12 &nv21, only works on m6. */
+#define GE2D_FMT_M24_YUV420SPB		0x2021f /* 01_00_0_00_1_11 nv12 &nv21, only works on m6. */
+
+#define GE2D_FMT_S16_YUV422T     	0x20110 /* 01_00_0_10_0_00 */
+#define GE2D_FMT_S16_YUV422B     	0x20138 /* 01_00_0_11_0_00 */
+#define GE2D_FMT_S24_YUV444T     	0x20210 /* 10_00_0_10_0_00 */
+#define GE2D_FMT_S24_YUV444B     	0x20218 /* 10_00_0_11_0_00 */
+
+/* back compatible defines */
+#define GE2D_FORMAT_S8_Y            (GE2D_FORMAT_YUV|GE2D_FMT_S8_Y)            
+#define GE2D_FORMAT_S8_CB          (GE2D_FORMAT_YUV|GE2D_FMT_S8_CB)          
+#define GE2D_FORMAT_S8_CR          (GE2D_FORMAT_YUV|GE2D_FMT_S8_CR)          
+#define GE2D_FORMAT_S8_R            GE2D_FMT_S8_R            
+#define GE2D_FORMAT_S8_G            GE2D_FMT_S8_G            
+#define GE2D_FORMAT_S8_B            GE2D_FMT_S8_B            
+#define GE2D_FORMAT_S8_A            GE2D_FMT_S8_A            
+#define GE2D_FORMAT_S8_LUT          GE2D_FMT_S8_LUT
+/* nv12 &nv21, only works on m6. */
+#define GE2D_FORMAT_M24_NV12	    (GE2D_FMT_M24_YUV420SP| GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_M24_NV12T	    (GE2D_FMT_M24_YUV420SPT| GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_M24_NV12B	    (GE2D_FMT_M24_YUV420SPB| GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_M24_NV21	    (GE2D_FMT_M24_YUV420SP| GE2D_COLOR_MAP_NV21)
+#define GE2D_FORMAT_M24_NV21T	    (GE2D_FMT_M24_YUV420SPT| GE2D_COLOR_MAP_NV21)
+#define GE2D_FORMAT_M24_NV21B	    (GE2D_FMT_M24_YUV420SPB| GE2D_COLOR_MAP_NV21)
+
+
+
+#define GE2D_FORMAT_S12_RGB_655         (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGB655)      
+#define GE2D_FORMAT_S16_YUV422      (GE2D_FMT_S16_YUV422  | GE2D_COLOR_MAP_YUV422)
+#define GE2D_FORMAT_S16_RGB_655         (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGB655)  
+#define GE2D_FORMAT_S24_YUV444      (GE2D_FMT_S24_YUV444  | GE2D_COLOR_MAP_YUV444) 
+#define GE2D_FORMAT_S24_RGB         (GE2D_FMT_S24_RGB     | GE2D_COLOR_MAP_RGB888)   
+#define GE2D_FORMAT_S32_YUVA444     (GE2D_FMT_S32_YUVA444 | GE2D_COLOR_MAP_YUVA4444)   
+#define GE2D_FORMAT_S32_RGBA        (GE2D_FMT_S32_RGBA    | GE2D_COLOR_MAP_RGBA8888) 
+#define GE2D_FORMAT_M24_YUV420      GE2D_FMT_M24_YUV420    
+#define GE2D_FORMAT_M24_YUV422      GE2D_FMT_M24_YUV422
+#define GE2D_FORMAT_M24_YUV444      GE2D_FMT_M24_YUV444
+#define GE2D_FORMAT_M24_RGB         GE2D_FMT_M24_RGB
+#define GE2D_FORMAT_M24_YUV420T     GE2D_FMT_M24_YUV420T
+#define GE2D_FORMAT_M24_YUV420B     GE2D_FMT_M24_YUV420B
+#define GE2D_FORMAT_S16_YUV422T     (GE2D_FMT_S16_YUV422T | GE2D_COLOR_MAP_YUV422)
+#define GE2D_FORMAT_S16_YUV422B     (GE2D_FMT_S16_YUV422B | GE2D_COLOR_MAP_YUV422)   
+#define GE2D_FORMAT_S24_YUV444T     (GE2D_FMT_S24_YUV444T | GE2D_COLOR_MAP_YUV444)   
+#define GE2D_FORMAT_S24_YUV444B     (GE2D_FMT_S24_YUV444B | GE2D_COLOR_MAP_YUV444)
+//format added in A1H
+/*16 bit*/
+#define GE2D_FORMAT_S16_RGB_565         (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGB565) 
+#define GE2D_FORMAT_S16_RGB_844         (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGB844) 
+#define GE2D_FORMAT_S16_RGBA_6442        (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGBA6442)
+#define GE2D_FORMAT_S16_RGBA_4444        (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGBA4444)
+#define GE2D_FORMAT_S16_ARGB_4444        (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_ARGB4444)
+#define GE2D_FORMAT_S16_ARGB_1555        (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_ARGB1555)
+#define GE2D_FORMAT_S16_RGBA_4642        (GE2D_FMT_S16_RGB     | GE2D_COLOR_MAP_RGBA4642)
+/*24 bit*/
+#define GE2D_FORMAT_S24_RGBA_5658         (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_RGBA5658)  
+#define GE2D_FORMAT_S24_ARGB_8565         (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_ARGB8565) 
+#define GE2D_FORMAT_S24_RGBA_6666         (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_RGBA6666)
+#define GE2D_FORMAT_S24_ARGB_6666         (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_ARGB6666)
+#define GE2D_FORMAT_S24_BGR        	     	   (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_BGR888)
+/*32 bit*/
+#define GE2D_FORMAT_S32_ARGB        (GE2D_FMT_S32_RGBA    | GE2D_COLOR_MAP_ARGB8888) 
+#define GE2D_FORMAT_S32_ABGR        (GE2D_FMT_S32_RGBA    | GE2D_COLOR_MAP_ABGR8888) 
+#define GE2D_FORMAT_S32_BGRA        (GE2D_FMT_S32_RGBA    | GE2D_COLOR_MAP_BGRA8888) 
+
+
+
+#define OSD0      0
+#define OSD1     1
+#define	VID0      2
+#define VID1      3
+typedef struct {
+     int            x;   /* X coordinate of its top-left point */
+     int            y;   /* Y coordinate of its top-left point */
+     int            w;   /* width of it */
+     int            h;   /* height of it */
+} rectangle_t;
+typedef  struct {
+	unsigned int    color ;
+	rectangle_t src1_rect;
+	rectangle_t src2_rect;
+	rectangle_t	dst_rect;
+	int			op;
+}ge2d_para_t ;
+
+typedef  struct  {
+	int  config_index ;//possible index OSD0 OSD1 VID0 VID1 
+	int  handle[MAX_BITBLT_WORK_CONFIG] ;
+}ge2d_config_handle_t ;
+
+
+typedef struct {
+    unsigned char     interrupt_ctrl;
+    
+    unsigned char     dp_onoff_mode;
+    unsigned char     vfmt_onoff_en;
+    unsigned int      dp_on_cnt;
+    unsigned int      dp_off_cnt;
+} ge2d_gen_t;
+
+
+typedef struct {
+    unsigned char     urgent_en;
+    unsigned char     ddr_burst_size_y;
+    unsigned char     ddr_burst_size_cb;
+    unsigned char     ddr_burst_size_cr;
+	unsigned int	  canaddr;
+    unsigned char     x_yc_ratio;
+    unsigned char     y_yc_ratio;
+    unsigned char     sep_en;
+    unsigned char     format;
+
+	unsigned char     endian;
+	unsigned char     color_map;
+ 
+    unsigned char     mode_8b_sel;
+    unsigned char     lut_en;
+    unsigned int      def_color;
+    unsigned int      format_all;
+} ge2d_src1_data_t;
+
+typedef struct {
+	int               clipx_start;
+	int               clipx_end;
+	int               clipy_start;
+	int               clipy_end;
+	unsigned char     clipx_start_ex;
+	unsigned char     clipx_end_ex;
+	unsigned char     clipy_start_ex;
+	unsigned char     clipy_end_ex;
+	unsigned char     pic_struct;
+	unsigned char     fill_mode; //bit1 for outside alpha , bit0 for color data
+	unsigned int      outside_alpha;
+	unsigned char     chfmt_rpt_pix;
+	unsigned char     cvfmt_rpt_pix;
+} ge2d_src1_gen_t;
+
+typedef struct {
+	unsigned char     urgent_en;
+	unsigned char     ddr_burst_size;
+	unsigned char     src2_canaddr;
+	unsigned char     src2_format;
+
+	unsigned char     src2_endian;
+	unsigned char     src2_color_map;
+    
+	unsigned char     src2_mode_8b_sel;
+	unsigned int      src2_def_color;
+
+	unsigned int     dst_canaddr;
+	unsigned char    dst_format;
+
+	unsigned char     dst_endian;
+	unsigned char     dst_color_map;
+   
+	unsigned char     dst_mode_8b_sel;
+
+	unsigned int      src2_format_all;
+	unsigned int      dst_format_all;
+	
+	/* only for m6 */
+	unsigned char	dst2_pixel_byte_width;
+	unsigned char	dst2_color_map;
+	unsigned char	dst2_discard_mode;
+	unsigned char	dst2_enable;
+	
+} ge2d_src2_dst_data_t;
+
+
+typedef struct {
+    int               src2_clipx_start;
+    int               src2_clipx_end;
+    int               src2_clipy_start;
+    int               src2_clipy_end;
+    unsigned char     src2_pic_struct;
+    unsigned char     src2_fill_mode; //bit1 for outside alpha , bit0 for color data
+    unsigned int      src2_outside_alpha;
+
+    int               dst_clipx_start;
+    int               dst_clipx_end;
+    int               dst_clipy_start;
+    int               dst_clipy_end;
+    unsigned char     dst_clip_mode;
+    unsigned char     dst_pic_struct;
+} ge2d_src2_dst_gen_t;
+
+typedef struct {
+    //scaler related
+    unsigned char     src1_vsc_bank_length;
+    unsigned char     src1_vsc_phase0_always_en;
+    unsigned char     src1_hsc_bank_length;
+    unsigned char     src1_hsc_phase0_always_en;
+    unsigned char     src1_hsc_rpt_ctrl;  //1bit, 0: using minus, 1: using repeat data
+    unsigned char     src1_vsc_rpt_ctrl;  //1bit, 0: using minus  1: using repeat data
+    unsigned char     src1_hsc_nearest_en; 
+    unsigned char     src1_vsc_nearest_en; 
+    
+    unsigned char     antiflick_en;
+    unsigned char     antiflick_ycbcr_rgb_sel;
+    unsigned char     antiflick_cbcr_en;
+    unsigned int      antiflick_r_coef;      //Y= (R * r_coef + G * g_coef + B * b_coef)/256
+    unsigned int      antiflick_g_coef;
+    unsigned int      antiflick_b_coef;
+    unsigned int      antiflick_color_filter_n1[4];
+    unsigned int      antiflick_color_filter_n2[4];
+    unsigned int      antiflick_color_filter_n3[4];
+    unsigned int      antiflick_color_filter_th[3];
+    unsigned int      antiflick_alpha_filter_n1[4];
+    unsigned int      antiflick_alpha_filter_n2[4];
+    unsigned int      antiflick_alpha_filter_n3[4];
+    unsigned int      antiflick_alpha_filter_th[3];    
+    //matrix related
+    unsigned char     use_matrix_default;
+    unsigned char     conv_matrix_en;
+    unsigned char     matrix_sat_in_en;     
+    unsigned char     matrix_minus_16_ctrl; //3bit 
+    unsigned char     matrix_sign_ctrl;     //3bit 
+    int               matrix_offset[3];
+    int               matrix_coef[9];
+    
+    unsigned char     src1_gb_alpha;
+    unsigned int      alu_const_color;
+
+    unsigned char     src1_key_en;
+    unsigned char     src2_key_en;
+    unsigned char     src1_key_mode;
+    unsigned char     src2_key_mode;
+    unsigned int      src1_key;
+    unsigned int      src2_key;
+    unsigned int      src1_key_mask;
+    unsigned int      src2_key_mask;
+    unsigned char     bitmask_en;
+    unsigned char     bytemask_only;
+    unsigned int      bitmask;
+
+} ge2d_dp_gen_t;
+
+typedef struct {
+    int              src1_x_start;
+    int              src1_y_start;
+    int              src1_x_end;
+    int              src1_y_end;
+    //unsigned char    src1_x_start_ex;
+    //unsigned char    src1_y_start_ex;
+    //unsigned char    src1_x_end_ex;
+    //unsigned char    src1_y_end_ex;
+   
+    unsigned char    src1_x_rev;
+    unsigned char    src1_y_rev;    
+    //unsigned char    src1_x_chr_phase;
+    //unsigned char    src1_y_chr_phase;
+    unsigned char    src1_fill_color_en;
+     
+    int              src2_x_start;
+    int              src2_y_start;
+    int              src2_x_end;
+    int              src2_y_end;
+    unsigned char    src2_x_rev;
+    unsigned char    src2_y_rev;
+    unsigned char    src2_fill_color_en;
+
+    int              dst_x_start;
+    int              dst_y_start;
+    int              dst_x_end;
+    int              dst_y_end;
+    unsigned char    dst_xy_swap;
+    unsigned char    dst_x_rev;
+    unsigned char    dst_y_rev;
+
+    int              sc_prehsc_en;
+    int              sc_prevsc_en;
+    int              sc_hsc_en;
+    int              sc_vsc_en;
+    int              vsc_phase_step;
+    int              vsc_phase_slope;
+    unsigned char    vsc_rpt_l0_num;
+    int              vsc_ini_phase;
+    int              hsc_phase_step;
+    int              hsc_phase_slope;
+    unsigned char    hsc_rpt_p0_num;
+    int              hsc_ini_phase;
+    unsigned char    hsc_div_en; 
+    unsigned int    hsc_div_length;
+    int              hsc_adv_num;
+    int              hsc_adv_phase;
+
+    unsigned char    src1_cmult_asel;
+    unsigned char    src2_cmult_asel;
+    
+    unsigned char    color_blend_mode;
+    unsigned char    color_src_blend_factor;        
+    unsigned char    color_dst_blend_factor;        
+    unsigned char    color_logic_op;
+    
+    unsigned char    alpha_blend_mode;
+    unsigned char    alpha_src_blend_factor;        
+    unsigned char    alpha_dst_blend_factor;        
+    unsigned char    alpha_logic_op;
+    
+    int (*cmd_cb)(unsigned);
+    unsigned int     cmd_cb_param;
+    unsigned int     src1_buffer;
+    unsigned int     src2_buffer;
+    unsigned char    release_flag;
+    unsigned char    wait_done_flag;
+} ge2d_cmd_t;
+
+typedef struct {
+    ge2d_gen_t            gen;
+    ge2d_src1_data_t      src1_data;
+    ge2d_src1_gen_t       src1_gen;
+    ge2d_src2_dst_data_t  src2_dst_data;
+    ge2d_src2_dst_gen_t   src2_dst_gen;
+    ge2d_dp_gen_t         dp_gen;
+    unsigned              v_scale_coef_type; 
+    unsigned              h_scale_coef_type; 
+    unsigned              update_flag;
+} ge2d_config_t;
+typedef   struct tasklet_struct   tasklet_struct_t;
+
+extern void ge2d_set_src1_data(ge2d_src1_data_t *cfg);
+
+extern void ge2d_set_src1_gen(ge2d_src1_gen_t *cfg);
+
+extern void ge2d_set_src2_dst_data(ge2d_src2_dst_data_t *cfg);
+
+extern void ge2d_set_src2_dst_gen(ge2d_src2_dst_gen_t *cfg);
+
+extern void ge2d_set_dp_gen(ge2d_dp_gen_t *cfg);
+
+extern void ge2d_set_cmd(ge2d_cmd_t *cfg);
+
+extern void ge2d_wait_done(void);
+
+extern void ge2d_set_src1_scale_coef(unsigned v_filt_type, unsigned h_filt_type);
+
+extern void ge2d_set_gen(ge2d_gen_t * cfg);
+
+extern void ge2d_soft_rst(void);
+
+extern int ge2d_is_busy (void);
+
+extern int ge2d_cmd_fifo_full(void);
+#define     	INT32S     signed  int 
+#define		INT32U	  unsigned int 	
+#define 		INT16U	  unsigned short
+#define 		INT8U	  unsigned char 
+#define 		INT8S	  signed char
+#include "ge2d_wq.h"
+#include "ge2dgen.h"
+#include "bitblt.h"
+#include <linux/fb.h>
+
+
+#endif
+
diff --git a/include/linux/amlogic/ge2d/ge2d_main.h b/include/linux/amlogic/ge2d/ge2d_main.h
new file mode 100755
index 000000000000..b80d86b3f838
--- /dev/null
+++ b/include/linux/amlogic/ge2d/ge2d_main.h
@@ -0,0 +1,58 @@
+#ifndef  _GE2D_MAIN_H
+#define  _GE2D_MAIN_H
+#include "ge2d.h"
+#include <linux/interrupt.h>
+#include <linux/compat.h>
+#include <mach/am_regs.h>
+#include <linux/amports/canvas.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
+#include <linux/sysfs.h>
+#include  <linux/spinlock.h>
+#include <linux/kthread.h>
+
+
+/**************************************************************
+**																	 **
+**	macro define		 												 **
+**																	 **
+***************************************************************/
+
+#define    	GE2D_CLASS_NAME   				"ge2d"
+
+#define  	 	GE2D_STRETCHBLIT_NOALPHA_NOBLOCK   	0x4708
+#define  		GE2D_BLIT_NOALPHA_NOBLOCK 			0x4707
+#define  		GE2D_BLEND_NOBLOCK 	 				0x4706
+#define  		GE2D_BLIT_NOBLOCK 	 				0x4705
+#define  		GE2D_STRETCHBLIT_NOBLOCK 			0x4704
+#define  		GE2D_FILLRECTANGLE_NOBLOCK 			0x4703
+
+
+#define  	 	GE2D_STRETCHBLIT_NOALPHA   			0x4702
+#define  		GE2D_BLIT_NOALPHA	 					0x4701
+#define  		GE2D_BLEND			 					0x4700
+#define  		GE2D_BLIT    			 				0x46ff
+#define  		GE2D_STRETCHBLIT   						0x46fe
+#define  		GE2D_FILLRECTANGLE   					0x46fd
+#define  		GE2D_SRCCOLORKEY   					0x46fc
+#define		GE2D_SET_COEF							0x46fb
+#define  		GE2D_CONFIG_EX  			       			0x46fa
+#define  		GE2D_CONFIG							0x46f9
+#define		GE2D_ANTIFLICKER_ENABLE				0x46f8
+
+/**************************************************************
+**																	 **
+**	type  define		 												 **
+**																	 **
+***************************************************************/
+
+typedef  struct {
+	char  			name[20];
+	unsigned int 		open_count;
+	int	 			major;
+	unsigned  int 		dbg_enable;
+	struct class 		*cla;
+	struct device		*dev;
+}ge2d_device_t;
+#endif
diff --git a/include/linux/amlogic/ge2d/ge2d_wq.h b/include/linux/amlogic/ge2d/ge2d_wq.h
new file mode 100755
index 000000000000..52e83808ac09
--- /dev/null
+++ b/include/linux/amlogic/ge2d/ge2d_wq.h
@@ -0,0 +1,264 @@
+#ifndef BITBLT_H_
+#define BITBLT_H_
+
+#include <linux/mutex.h>
+#include <linux/semaphore.h>
+#include <linux/list.h>
+#include <linux/amlogic/osd/osd.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#define 	GE2D_HIGHEST_PRIORITY   0
+#define 	GE2D_LOWEST_PRIORITY    255
+
+#define 	FLAG_CONFIG_UPDATE_ONLY 0
+#define 	FLAG_CONFIG_ALL         1
+
+#define 	UPDATE_SRC_DATA     0x01
+#define 	UPDATE_SRC_GEN      0x02
+#define 	UPDATE_DST_DATA     0x04
+#define 	UPDATE_DST_GEN      0x08
+#define 	UPDATE_DP_GEN       0x10
+#define 	UPDATE_SCALE_COEF   0x20
+#define 	UPDATE_ALL          0x3f
+#define	GE2D_ATTR_MAX	  2
+#define   GE2D_MAX_WORK_QUEUE_NUM   4
+#define   GE2D_IRQ_NO   	INT_GE2D
+#define	FILE_NAME		"[GE2D_WQ]"
+typedef  enum  	
+{
+		OSD0_OSD0 =0,
+		OSD0_OSD1,	 
+		OSD1_OSD1,
+		OSD1_OSD0,
+		ALLOC_OSD0,
+		ALLOC_OSD1,
+		ALLOC_ALLOC,
+		TYPE_INVALID,
+}ge2d_src_dst_t;
+typedef enum  	
+{
+    CANVAS_OSD0 =0,
+    CANVAS_OSD1,	 
+    CANVAS_ALLOC,
+    CANVAS_TYPE_INVALID,
+}ge2d_src_canvas_type;
+typedef  struct {
+  struct list_head  list;
+  ge2d_cmd_t   cmd ;
+  ge2d_config_t config;
+
+}ge2d_queue_item_t;
+
+typedef struct{
+	struct list_head   list;			//connect all process in one queue for RR process.
+    	ge2d_config_t       config;   //current wq configuration
+    	ge2d_cmd_t         	cmd;
+	struct list_head	work_queue;
+   	struct list_head	free_queue;
+	wait_queue_head_t	cmd_complete;
+   	int				queue_dirty;
+   	int				queue_need_recycle;
+	spinlock_t	 	lock; 	// for get and release item.
+} ge2d_context_t;
+
+typedef  struct {
+	wait_queue_head_t	cmd_complete;
+	struct completion		process_complete;
+	spinlock_t	 	sem_lock;  //for queue switch and create destroy queue.
+	struct semaphore		cmd_in_sem;
+}ge2d_event_t;
+
+
+
+typedef  struct {
+   struct list_head			process_queue;
+   ge2d_context_t*		current_wq;
+   ge2d_context_t*		last_wq;
+   struct task_struct*		ge2d_thread;
+   ge2d_event_t			event ;
+   int		 			irq_num;
+   int 		 			ge2d_state;
+   int					process_queue_state;
+}ge2d_manager_t ;
+
+typedef  struct  {
+	int  xres;
+	int  yres ;
+	int  canvas_index;
+	int  bpp;
+	int  ge2d_color_index;
+}src_dst_para_t ;
+
+static const  int   bpp_type_lut[]={
+	//16bit 
+	COLOR_INDEX_16_655, 	// 0
+	COLOR_INDEX_16_844, 	// 1
+	COLOR_INDEX_16_6442, 	// 2
+	COLOR_INDEX_16_4444_R,	// 3
+	COLOR_INDEX_16_565,		// 4
+	COLOR_INDEX_16_4444_A,	// 5
+	COLOR_INDEX_16_1555_A,	// 6
+	COLOR_INDEX_16_4642_R,	// 7
+	//24bit
+	COLOR_INDEX_24_RGB,	// 0
+	COLOR_INDEX_24_5658,	// 1
+	COLOR_INDEX_24_8565,	// 2
+	COLOR_INDEX_24_6666_R,	// 3
+	COLOR_INDEX_24_6666_A,	// 4
+	COLOR_INDEX_24_888_B,	// 5
+	0,
+	0,
+	//32bit
+	COLOR_INDEX_32_RGBA,	// 0
+	COLOR_INDEX_32_ARGB,	// 1
+	COLOR_INDEX_32_ABGR, 	// 2
+	COLOR_INDEX_32_BGRA,	// 3
+	0,0,0,0
+};
+
+static const  int   default_ge2d_color_lut[]={
+	0, 
+	0,
+	0,//BPP_TYPE_02_PAL4    = 2, 
+	0,
+	0,//BPP_TYPE_04_PAL16   = 4,
+    	0,
+    	0, 
+    	0,
+	0,//BPP_TYPE_08_PAL256=8,
+	GE2D_FORMAT_S16_RGB_655,//BPP_TYPE_16_655 =9,
+	GE2D_FORMAT_S16_RGB_844,//BPP_TYPE_16_844 =10,
+	GE2D_FORMAT_S16_RGBA_6442,//BPP_TYPE_16_6442 =11 ,
+	GE2D_FORMAT_S16_RGBA_4444,//BPP_TYPE_16_4444_R = 12,
+	GE2D_FORMAT_S16_RGBA_4642,//BPP_TYPE_16_4642_R = 13,
+	GE2D_FORMAT_S16_ARGB_1555,//BPP_TYPE_16_1555_A=14,
+	GE2D_FORMAT_S16_ARGB_4444,//BPP_TYPE_16_4444_A = 15,
+	GE2D_FORMAT_S16_RGB_565,//BPP_TYPE_16_565 =16,
+	0,
+	0,
+	GE2D_FORMAT_S24_ARGB_6666,//BPP_TYPE_24_6666_A=19,
+	GE2D_FORMAT_S24_RGBA_6666,//BPP_TYPE_24_6666_R=20,
+	GE2D_FORMAT_S24_ARGB_8565,//BPP_TYPE_24_8565 =21,
+	GE2D_FORMAT_S24_RGBA_5658,//BPP_TYPE_24_5658 = 22,
+	GE2D_FORMAT_S24_BGR,//BPP_TYPE_24_888_B = 23,
+	GE2D_FORMAT_S24_RGB,//BPP_TYPE_24_RGB = 24,
+	0,
+	0,
+	0,
+	0,
+	GE2D_FORMAT_S32_BGRA,//BPP_TYPE_32_BGRA=29,
+	GE2D_FORMAT_S32_ABGR,//BPP_TYPE_32_ABGR = 30,
+	GE2D_FORMAT_S32_RGBA,//BPP_TYPE_32_RGBA=31,
+	GE2D_FORMAT_S32_ARGB,//BPP_TYPE_32_ARGB=32,
+};
+typedef   enum{
+	GE2D_OP_DEFAULT=0,
+	GE2D_OP_FILLRECT,
+	GE2D_OP_BLIT,
+	GE2D_OP_STRETCHBLIT,
+	GE2D_OP_BLEND,
+	GE2D_OP_MAXNUM
+}ge2d_op_type_t;
+
+typedef struct {
+	unsigned long  addr;
+	unsigned int	w;
+	unsigned int	h;
+}config_planes_t;
+
+typedef  struct{
+	int	key_enable;
+	int	key_color;
+	int 	key_mask;
+	int   key_mode;
+}src_key_ctrl_t;
+typedef    struct {
+	int  src_dst_type;
+	int  alu_const_color;
+	unsigned int src_format;
+	unsigned int dst_format ; //add for src&dst all in user space.
+
+	config_planes_t src_planes[4];
+	config_planes_t dst_planes[4];
+	src_key_ctrl_t  src_key;
+}config_para_t;
+
+typedef  struct  {
+    int  canvas_index;
+    int  top;
+    int  left;
+    int  width;
+    int  height;
+    int  format;
+    int  mem_type;
+    int  color;
+    unsigned char x_rev;
+    unsigned char y_rev;
+    unsigned char fill_color_en;
+    unsigned char fill_mode;    
+}src_dst_para_ex_t ;
+
+typedef    struct {
+    src_dst_para_ex_t src_para;
+    src_dst_para_ex_t src2_para;
+    src_dst_para_ex_t dst_para;
+
+//key mask
+    src_key_ctrl_t  src_key;
+    src_key_ctrl_t  src2_key;
+
+    int alu_const_color;
+    unsigned src1_gb_alpha;
+    unsigned op_mode;
+    unsigned char bitmask_en;
+    unsigned char bytemask_only;
+    unsigned int  bitmask;
+    unsigned char dst_xy_swap;
+
+// scaler and phase releated
+    unsigned hf_init_phase;
+    int hf_rpt_num;
+    unsigned hsc_start_phase_step;
+    int hsc_phase_slope;
+    unsigned vf_init_phase;
+    int vf_rpt_num;
+    unsigned vsc_start_phase_step;
+    int vsc_phase_slope;
+    unsigned char src1_vsc_phase0_always_en;
+    unsigned char src1_hsc_phase0_always_en;
+    unsigned char src1_hsc_rpt_ctrl;  //1bit, 0: using minus, 1: using repeat data
+    unsigned char src1_vsc_rpt_ctrl;  //1bit, 0: using minus  1: using repeat data
+
+//canvas info
+    config_planes_t src_planes[4];
+    config_planes_t src2_planes[4];
+    config_planes_t dst_planes[4];
+}config_para_ex_t;
+extern int   ge2d_setup(void);
+extern int   ge2d_deinit(void);
+extern int   ge2d_context_config(ge2d_context_t *context, config_para_t *ge2d_config);
+extern int   ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_config);
+	
+extern int ge2d_wq_init(void);
+extern int  destroy_ge2d_work_queue(ge2d_context_t* ) ;
+extern ge2d_context_t* create_ge2d_work_queue(void) ;
+
+extern int ge2d_wq_remove_config(ge2d_context_t *wq);
+
+extern void ge2d_wq_set_scale_coef(ge2d_context_t *wq, unsigned v_scale_coef, unsigned h_scale_coef);
+extern int	ge2d_antiflicker_enable(ge2d_context_t *context,unsigned long enable);
+extern ge2d_src1_data_t * ge2d_wq_get_src_data(ge2d_context_t *wq);
+extern ge2d_src1_gen_t * ge2d_wq_get_src_gen(ge2d_context_t *wq);
+extern ge2d_src2_dst_data_t * ge2d_wq_get_dst_data(ge2d_context_t *wq);
+extern ge2d_src2_dst_gen_t * ge2d_wq_get_dst_gen(ge2d_context_t *wq);
+extern ge2d_dp_gen_t * ge2d_wq_get_dp_gen(ge2d_context_t *wq);
+extern ge2d_cmd_t * ge2d_wq_get_cmd(ge2d_context_t *wq);
+
+extern int ge2d_wq_add_work(ge2d_context_t *wq);
+
+
+
+#endif // BITBLT_H
diff --git a/include/linux/amlogic/ge2d/ge2dgen.h b/include/linux/amlogic/ge2d/ge2dgen.h
new file mode 100755
index 000000000000..b3d58def3c2a
--- /dev/null
+++ b/include/linux/amlogic/ge2d/ge2dgen.h
@@ -0,0 +1,65 @@
+#ifndef GE2DGEN_H
+#define GE2DGEN_H
+
+
+
+void ge2dgen_src(ge2d_context_t *wq,
+                 unsigned canvas_addr,
+                 unsigned format);
+
+void ge2dgen_post_release_src1buf(ge2d_context_t *wq, unsigned buffer);
+
+void ge2dgen_post_release_src1canvas(ge2d_context_t *wq);
+
+void ge2dgen_post_release_src2buf(ge2d_context_t *wq, unsigned buffer);
+
+void ge2dgen_post_release_src2canvas(ge2d_context_t *wq);
+
+void ge2dgen_src2(ge2d_context_t *wq,
+                  unsigned canvas_addr,
+                  unsigned format);
+
+void ge2dgen_src2_clip(ge2d_context_t *wq,
+                      int x, int y, int w, int h);
+void ge2dgen_antiflicker(ge2d_context_t *wq,unsigned long enable) ;
+void ge2dgen_rendering_dir(ge2d_context_t *wq,
+                           int src1_xrev,
+                           int src1_yrev,
+                           int dst_xrev,
+                           int dst_yrev,
+                           int dst_xy_swap);
+
+void ge2dgen_dst(ge2d_context_t *wq,
+                 unsigned canvas_addr,
+                 unsigned format);
+
+void ge2dgen_src_clip(ge2d_context_t *wq,
+                      int x, int y, int w, int h);
+
+void ge2dgen_src_key(ge2d_context_t *wq,
+                     int en, int key, int keymask,int keymode);
+
+void ge2dgent_src_gbalpha(ge2d_context_t *wq,
+                          unsigned char alpha);
+
+void ge2dgen_src_color(ge2d_context_t *wq,
+                       unsigned color);
+
+void ge2dgent_rendering_dir(ge2d_context_t *wq,
+                            int src_x_dir, int src_y_dir,
+                            int dst_x_dir, int dst_y_dir);
+
+void ge2dgen_src2(ge2d_context_t *wq, unsigned canvas_addr, unsigned format);
+
+void ge2dgen_dst_clip(ge2d_context_t *wq,
+                      int x, int y, int w, int h, int mode);
+
+void ge2dgent_src2_clip(ge2d_context_t *wq,
+                        int x, int y, int w, int h);
+
+void ge2dgen_cb(ge2d_context_t *wq, int (*cmd_cb)(unsigned), unsigned param);
+
+void ge2dgen_const_color(ge2d_context_t *wq, unsigned color);
+
+#endif /* GE2DGEN_H */
+
diff --git a/include/linux/amlogic/logo/err_code.h b/include/linux/amlogic/logo/err_code.h
new file mode 100755
index 000000000000..587ec79119a4
--- /dev/null
+++ b/include/linux/amlogic/logo/err_code.h
@@ -0,0 +1,25 @@
+#ifndef  ERR_CODE_H_
+#define ERR_CODE_H_
+
+#define   TRUE		1
+#define	FALSE		0
+#define	SUCCESS	0
+#define	FAIL		1
+
+
+#define	LOGO_PARA_UNPARSED	0x30001
+//parser
+
+#define    ENOPARSER				0x10001	
+#define    PARSER_FOUND			0x10002
+#define    PARSER_UNFOUND		0x10003	
+#define 	PARSER_DECODE_FAIL	0x10004
+
+//dev
+#define  	EDEV_NO_TRANSFER_NEED 	0x20001
+#define    OUTPUT_DEV_FOUND			0x20002
+#define 	OUTPUT_DEV_UNFOUND	 	0x20003
+#define	OUTPUT_DEV_SETUP_FAIL		0x20004
+#define	OUTPUT_DEV_GE2D_SETUP_FAIL	0x20005
+#endif
+
diff --git a/include/linux/amlogic/logo/logo.h b/include/linux/amlogic/logo/logo.h
new file mode 100755
index 000000000000..10e3152d8e8d
--- /dev/null
+++ b/include/linux/amlogic/logo/logo.h
@@ -0,0 +1,65 @@
+#ifndef LOGO_H
+#define LOGO_H
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <mach/am_regs.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/amlogic/osd/osd.h>
+#include <linux/amlogic/osd/osd_hw.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include "err_code.h"
+#include "logo_base_type.h"
+#include "logo_dev.h"
+#include "logo_parser.h"
+
+
+#undef  MODULE
+/**************************************************************
+************************ type define part ***************************
+***************************************************************/
+//loader 
+
+
+
+
+
+
+/**************************************************************
+************************ macro define part ************************
+***************************************************************/
+extern	logo_object_t  aml_logo; 
+#define   TOLOWER(x) ((x) | 0x20)
+
+#define	LOGO_NAME	"aml_logo"
+#define   dev_to_platformdev(dev)   (container_of((dev), struct platform_device,dev) )
+extern struct bus_type platform_bus_type;
+  	
+
+
+/***************************************************************
+*********************  para define part  *****************************
+****************************************************************/
+
+
+
+
+
+
+/**************************************************************
+************************ macro define part ************************
+***************************************************************/
+
+extern  logo_object_t* get_current_logo_obj(void);
+extern int  register_logo_parser(logo_parser_t* logo_parser) ;
+extern int  register_logo_output_dev(logo_output_dev_t* new_dev);
+
+
+#endif
diff --git a/include/linux/amlogic/logo/logo_base_type.h b/include/linux/amlogic/logo/logo_base_type.h
new file mode 100755
index 000000000000..80a6c37fa2fe
--- /dev/null
+++ b/include/linux/amlogic/logo/logo_base_type.h
@@ -0,0 +1,60 @@
+#ifndef  LOGO_BASE_TYPE_H
+#define LOGO_BASE_TYPE_H
+
+
+struct logo_output_dev;
+struct logo_parser ;
+typedef enum {
+	DISP_MODE_ORIGIN,	//at top-left corner.
+	DISP_MODE_CENTER,
+	DISP_MODE_FULL_SCREEN
+}logo_display_mode_t;
+
+typedef enum{
+	LOGO_DEV_OSD0=0,
+	LOGO_DEV_OSD1,
+	LOGO_DEV_VID,
+	LOGO_DEV_MEM,
+	LOGO_DEV_MAX
+}platform_dev_t;
+
+typedef enum  {
+	SRC_TYPE_BMP=0,
+	SRC_TYPE_JPG ,
+	SRC_TYPE_PNG,
+	MAX_PIC_TYPE,
+}pic_type_t;
+
+typedef  struct {
+	int  x;
+	int  y;
+	int  w;
+	int  h;
+}logo_rect_t;
+typedef  struct {
+	char  name[10];
+	int    mem_start;
+	int 	mem_end;
+}platform_resource_t;
+
+struct logo_input_para{
+	char *mem_addr;  //represent logo load addr .
+	platform_dev_t  output_dev_type;
+	logo_display_mode_t dis_mode; 
+	vmode_t vout_mode;
+	int	progress;
+	int	loaded;
+	int needscaler;
+};
+typedef struct logo_input_para logo_input_para_t ;
+typedef  struct {
+	char name[10];
+	struct logo_input_para para;
+	struct logo_output_dev *dev; 
+	struct logo_parser  *parser;
+	int	need_transfer;  //logo pic need transfer from parser output to
+					   // logo output device.
+	platform_resource_t platform_res[LOGO_DEV_MAX];				   
+}logo_object_t;
+
+#endif
diff --git a/include/linux/amlogic/logo/logo_dev.h b/include/linux/amlogic/logo/logo_dev.h
new file mode 100755
index 000000000000..bfe8c3dceb42
--- /dev/null
+++ b/include/linux/amlogic/logo/logo_dev.h
@@ -0,0 +1,52 @@
+#ifndef LOGO_DEV_H
+#define LOGO_DEV_H
+#include "logo_base_type.h"
+#include <linux/amlogic/ge2d/ge2d.h>
+typedef struct{
+	logo_rect_t screen;
+	int mem_start;
+	int mem_end;
+	int color_depth;
+}dev_osd_t;
+
+typedef struct{
+	logo_rect_t screen;
+	int mem_start;
+	int mem_end;
+	u32 canvas_index;
+}dev_vid_t;
+
+typedef union{
+	dev_osd_t osd;
+	dev_vid_t	  vid;
+}output_dev_t;
+
+struct output_dev_op{
+	int	(*init)(logo_object_t *);
+	int  	(*transfer)(logo_object_t *);
+	int  	(*enable)(int);
+	int	(*deinit)(void);
+};
+typedef  struct output_dev_op output_dev_op_t;
+struct logo_output_dev{
+	platform_dev_t idx;
+	logo_rect_t	 window;
+	output_dev_t  output_dev;
+	output_dev_op_t op;
+	const vinfo_t		*vinfo;
+	ge2d_context_t  *ge2d_context;
+	int			hw_initialized;
+};
+typedef struct logo_output_dev logo_output_dev_t ;
+
+typedef  struct{
+	logo_output_dev_t *dev;
+	struct list_head  list;	
+}output_dev_list_t;
+
+//function define 
+extern int  setup_output_device(logo_object_t *plogo);
+extern int dev_osd_setup(void);
+extern int dev_vid_setup(void) ;
+
+#endif
diff --git a/include/linux/amlogic/logo/logo_parser.h b/include/linux/amlogic/logo/logo_parser.h
new file mode 100755
index 000000000000..b34fc6b4955c
--- /dev/null
+++ b/include/linux/amlogic/logo/logo_parser.h
@@ -0,0 +1,56 @@
+#ifndef  LOGO_PARSER_H
+#define  LOGO_PARSER_H
+
+//parser
+typedef  struct {
+	int  (*init)(logo_object_t *logo);
+	int  (*decode)(logo_object_t *logo);
+	int  (*deinit)(logo_object_t *logo);
+	
+}logo_parser_op_t;
+
+typedef  struct{
+	int  color_depth;
+}bmp_decoder_t;
+
+typedef  struct{
+	u32  component;
+	u32  out_canvas_index;
+}jpg_decoder_t;
+
+typedef  union{
+	bmp_decoder_t bmp;
+	jpg_decoder_t	jpg;
+}decoder_t;
+
+typedef  struct{
+	unsigned int	width;
+	unsigned int	height;
+	unsigned int	color_info;
+	int	size; //file size
+}pic_info_t;
+
+struct logo_parser{
+	char  name[10];
+	logo_parser_op_t  op;
+	char *output_addr;
+	decoder_t  decoder;
+	output_dev_t out_dev; //?maybe not useful
+	pic_info_t	 logo_pic_info;
+	void *priv;
+};
+typedef  struct logo_parser  logo_parser_t;
+typedef  struct {
+	logo_parser_t *parser;
+	struct list_head  list;
+}parser_list_t;
+
+/**************************************************************
+************************ function define part ************************
+***************************************************************/
+ extern int start_logo(void) ;
+ extern int exit_logo(logo_object_t *logo);
+ //all kind of parser setup .
+ extern int bmp_setup(void);
+ extern int jpeg_setup(void);
+#endif
diff --git a/include/linux/amlogic/major.h b/include/linux/amlogic/major.h
new file mode 100755
index 000000000000..94530e6ac7d2
--- /dev/null
+++ b/include/linux/amlogic/major.h
@@ -0,0 +1,21 @@
+#ifndef _LINUX_MAJOR_H
+#define _LINUX_MAJOR_H
+
+/* Amlogic extension */
+#define HDMI_MAJOR			231
+#define AUDIODSP_MAJOR		232
+#define AMSTREAM_MAJOR		233
+#define UIO_MAJOR			234
+#define USB_DEV_EP_MAJOR	235
+#define TV_CONF_MAJOR		236
+#define HIDRAW_MAJOR		237
+#define HWJPEGDEC_MAJOR		238
+#define AMVIDEO_MAJOR		239
+#define AML_DEMOD_MAJOR		242
+#define AMAUDIO_MAJOR		243
+#define AMVIDEO2_MAJOR		245
+#define TV2_CONF_MAJOR		246
+#define BLOCK_EXT_MAJOR		259
+#define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
+
+#endif
diff --git a/include/linux/amlogic/osd/osd.h b/include/linux/amlogic/osd/osd.h
new file mode 100755
index 000000000000..13b057963e2b
--- /dev/null
+++ b/include/linux/amlogic/osd/osd.h
@@ -0,0 +1,149 @@
+/*
+ * Amlogic OSD
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef OSD_H
+#define OSD_H
+#include  <linux/fb.h>
+
+typedef  enum {
+	COLOR_INDEX_02_PAL4    = 2,  // 0
+    	COLOR_INDEX_04_PAL16   = 4, // 0
+	COLOR_INDEX_08_PAL256=8,
+	COLOR_INDEX_16_655 =9,
+	COLOR_INDEX_16_844 =10,
+	COLOR_INDEX_16_6442 =11 ,
+	COLOR_INDEX_16_4444_R = 12,
+	COLOR_INDEX_16_4642_R = 13,
+	COLOR_INDEX_16_1555_A=14,
+	COLOR_INDEX_16_4444_A = 15,
+	COLOR_INDEX_16_565 =16,
+	
+	COLOR_INDEX_24_6666_A=19,
+	COLOR_INDEX_24_6666_R=20,
+	COLOR_INDEX_24_8565 =21,
+	COLOR_INDEX_24_5658 = 22,
+	COLOR_INDEX_24_888_B = 23,
+	COLOR_INDEX_24_RGB = 24,
+
+	COLOR_INDEX_32_BGRA=29,
+	COLOR_INDEX_32_ABGR = 30,
+	COLOR_INDEX_32_RGBA=31,
+	COLOR_INDEX_32_ARGB=32,
+
+	COLOR_INDEX_YUV_422=33,
+	
+}color_index_t;
+
+
+
+typedef  struct {
+	color_index_t	color_index;
+	u8	hw_colormat;
+	u8	hw_blkmode;
+
+	u8	red_offset ;
+	u8	red_length;
+	u8	red_msb_right;
+	
+	u8	green_offset;
+	u8	green_length;
+	u8	green_msb_right;
+
+	u8	blue_offset;
+	u8	blue_length;
+	u8	blue_msb_right;
+
+	u8	transp_offset;
+	u8	transp_length;
+	u8	transp_msb_right;
+
+	u8	color_type;
+	u8	bpp;
+
+		
+	
+}color_bit_define_t;
+typedef struct osd_ctl_s {
+    u32  xres_virtual;
+    u32  yres_virtual;
+    u32  xres;
+    u32  yres;
+    u32  disp_start_x; //coordinate of screen 
+    u32  disp_start_y;
+    u32  disp_end_x;
+    u32  disp_end_y;
+    u32  addr;
+    u32  index;
+} osd_ctl_t;
+#define  INVALID_BPP_ITEM    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
+
+static const  color_bit_define_t   default_color_format_array[]={
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{COLOR_INDEX_02_PAL4,0,0,/*red*/ 0,2,0,/*green*/0,2,0,/*blue*/0,2,0,/*trans*/0,0,0,FB_VISUAL_PSEUDOCOLOR,2},
+	INVALID_BPP_ITEM,	
+	{COLOR_INDEX_04_PAL16,0,1,/*red*/ 0,4,0,/*green*/0,4,0,/*blue*/0,4,0,/*trans*/0,0,0,FB_VISUAL_PSEUDOCOLOR,4},
+	INVALID_BPP_ITEM,	
+	INVALID_BPP_ITEM,	
+	INVALID_BPP_ITEM,	
+	{COLOR_INDEX_08_PAL256,0,2,/*red*/ 0,8,0,/*green*/0,8,0,/*blue*/0,8,0,/*trans*/0,0,0,FB_VISUAL_PSEUDOCOLOR,8},
+/*16 bit color*/
+	{COLOR_INDEX_16_655,0,4,/*red*/ 10,6,0,/*green*/5,5,0,/*blue*/0,5,0,/*trans*/0,0,0,FB_VISUAL_TRUECOLOR,16},
+	{COLOR_INDEX_16_844,1,4,/*red*/ 8,8,0,/*green*/4,4,0,/*blue*/0,4,0,/*trans*/0,0,0,FB_VISUAL_TRUECOLOR,16},
+	{COLOR_INDEX_16_6442,2,4,/*red*/ 10,6,0,/*green*/6,4,0,/*blue*/2,4,0,/*trans*/0,2,0,FB_VISUAL_TRUECOLOR,16},
+	{COLOR_INDEX_16_4444_R,3,4,/*red*/ 12,4,0,/*green*/8,4,0,/*blue*/4,4,0,/*trans*/0,4,0,FB_VISUAL_TRUECOLOR,16,},
+	{COLOR_INDEX_16_4642_R,7,4,/*red*/ 12,4,0,/*green*/6,6,0,/*blue*/2,4,0,/*trans*/0,2,0,FB_VISUAL_TRUECOLOR,16},
+	{COLOR_INDEX_16_1555_A,6,4,/*red*/ 10,5,0,/*green*/5,5,0,/*blue*/0,5,0,/*trans*/15,1,0,FB_VISUAL_TRUECOLOR,16},
+	{COLOR_INDEX_16_4444_A,5,4,/*red*/ 8,4,0,/*green*/4,4,0,/*blue*/0,4,0,/*trans*/12,4,0,FB_VISUAL_TRUECOLOR,16},
+	{COLOR_INDEX_16_565,4,4,/*red*/ 11,5,0,/*green*/5,6,0,/*blue*/0,5,0,/*trans*/0,0,0,FB_VISUAL_TRUECOLOR,16},
+/*24 bit color*/
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{COLOR_INDEX_24_6666_A,4,7,/*red*/ 12,6,0,/*green*/6,6,0,/*blue*/0,6,0,/*trans*/18,6,0,FB_VISUAL_TRUECOLOR,24},
+	{COLOR_INDEX_24_6666_R,3,7,/*red*/ 18,6,0,/*green*/12,6,0,/*blue*/6,6,0,/*trans*/0,6,0,FB_VISUAL_TRUECOLOR,24},
+	{COLOR_INDEX_24_8565,2,7,/*red*/ 11,5,0,/*green*/5,6,0,/*blue*/0,5,0,/*trans*/16,8,0,FB_VISUAL_TRUECOLOR,24},
+	{COLOR_INDEX_24_5658,1,7,/*red*/ 19,5,0,/*green*/13,6,0,/*blue*/8,5,0,/*trans*/0,8,0,FB_VISUAL_TRUECOLOR,24},
+	{COLOR_INDEX_24_888_B,5,7,/*red*/ 0,8,0,/*green*/8,8,0,/*blue*/16,8,0,/*trans*/0,0,0,FB_VISUAL_TRUECOLOR,24},
+	{COLOR_INDEX_24_RGB,0,7,/*red*/ 16,8,0,/*green*/8,8,0,/*blue*/0,8,0,/*trans*/0,0,0,FB_VISUAL_TRUECOLOR,24},
+/*32 bit color*/
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	INVALID_BPP_ITEM,
+	{COLOR_INDEX_32_BGRA,3,5,/*red*/ 8,8,0,/*green*/16,8,0,/*blue*/24,8,0,/*trans*/0,8,0,FB_VISUAL_TRUECOLOR,32},
+	{COLOR_INDEX_32_ABGR,2,5,/*red*/ 0,8,0,/*green*/8,8,0,/*blue*/16,8,0,/*trans*/24,8,0,FB_VISUAL_TRUECOLOR,32},
+	{COLOR_INDEX_32_RGBA,0,5,/*red*/ 24,8,0,/*green*/16,8,0,/*blue*/8,8,0,/*trans*/0,8,0,FB_VISUAL_TRUECOLOR,32},
+	{COLOR_INDEX_32_ARGB,1,5,/*red*/ 16,8,0,/*green*/8,8,0,/*blue*/0,8,0,/*trans*/24,8,0,FB_VISUAL_TRUECOLOR,32},
+/*YUV color*/
+	{COLOR_INDEX_YUV_422,0,3,0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,16},
+};
+
+typedef struct reg_val_pair{
+    uint reg;
+    uint val;
+} reg_val_pair_t;	
+	
+
+
+#endif /* OSD1_H */
diff --git a/include/linux/amlogic/osd/osd_dev.h b/include/linux/amlogic/osd/osd_dev.h
new file mode 100755
index 000000000000..4531a2d739cf
--- /dev/null
+++ b/include/linux/amlogic/osd/osd_dev.h
@@ -0,0 +1,128 @@
+/*
+ * Amlogic osd
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef OSD_DEV_H
+#define OSD_DEV_H
+
+#include "osd.h"
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/logo/logo.h>
+
+#define  OSD_COUNT 	2 /* we have two osd layer on hardware*/
+
+#define KEYCOLOR_FLAG_TARGET  1
+#define KEYCOLOR_FLAG_ONHOLD  2
+#define KEYCOLOR_FLAG_CURRENT 4
+
+typedef struct myfb_dev {
+    struct mutex lock;
+
+    struct fb_info *fb_info;
+    struct platform_device *dev;
+
+	u32 fb_mem_paddr;
+	void __iomem *fb_mem_vaddr;
+	u32 fb_len;
+	const color_bit_define_t  *color;
+   	 vmode_t vmode;
+    	
+    	struct osd_ctl_s osd_ctl;
+	u32  order;	
+	u32  scale;	
+	u32  enable_3d;
+	u32  preblend_enable;
+	u32  enable_key_flag;
+	u32  color_key;	
+} myfb_dev_t;
+typedef  struct list_head   list_head_t ;
+
+typedef   struct{
+	list_head_t  list;
+	struct myfb_dev *fbdev;
+}fb_list_t,*pfb_list_t;
+
+typedef  struct {
+	int start ;
+	int end ;
+	int fix_line_length;
+}osd_addr_t ;
+
+
+
+#define fbdev_lock(dev) mutex_lock(&dev->lock);
+#define fbdev_unlock(dev) mutex_unlock(&dev->lock);
+extern u32 osddev_get_osd_order(u32 index);
+extern void osddev_change_osd_order(u32 index,u32 order);
+extern void osddev_free_scale_enable(u32 index ,u32 enable);
+extern void osddev_get_free_scale_enable(u32 index, u32 * free_scale_enable);
+extern void osddev_free_scale_mode(u32 index ,u32 freescale_mode);
+extern void osddev_get_free_scale_mode(u32 index, u32 *freescale_mode);
+extern void osddev_free_scale_width(u32 index ,u32 width);
+extern void osddev_get_free_scale_width(u32 index, u32 * free_scale_width);
+extern void osddev_free_scale_height(u32 index ,u32 height);
+extern void osddev_get_free_scale_height(u32 index, u32 * free_scale_height);
+extern void osddev_get_free_scale_axis(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
+extern void osddev_set_free_scale_axis(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osddev_get_scale_axis(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
+extern void osddev_set_scale_axis(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osddev_get_window_axis(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
+extern void osddev_set_window_axis(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osddev_get_osd_info(u32 index, s32 (*posdval)[4], u32 (*posdreq)[5], s32 info_flag);
+extern void osddev_get_block_windows(u32 index, u32 *windows);
+extern void osddev_set_block_windows(u32 index, u32 *windows);
+extern void osddev_get_block_mode(u32 index, u32 *mode);
+extern void osddev_set_block_mode(u32 index, u32 mode);
+extern int osddev_select_mode(struct myfb_dev *fbdev);
+extern void osddev_enable_3d_mode(u32 index ,u32 enable);
+extern void osddev_set_2x_scale(u32 index,u16 h_scale_enable,u16 v_scale_enable);
+extern void osddev_get_flush_rate(u32 *break_rate);
+extern void osddev_get_osd_reverse(u32 index, u32 *reverse);
+extern void osddev_set_osd_reverse(u32 index, u32 reverse);
+extern void osddev_get_osd_rotate_on(u32 index, u32 *on_off);
+extern void osddev_set_osd_rotate_on(u32 index, u32 on_off);
+extern void osddev_get_osd_rotate_angle(u32 index, u32 *angle);
+extern void osddev_set_osd_rotate_angle(u32 index, u32 angle);
+extern void osddev_get_prot_canvas(u32 index, s32 *x_start, s32 *y_start, s32 *x_end, s32 *y_end);
+extern void osddev_set_prot_canvas(u32 index, s32 x_start, s32 y_start, s32 x_end, s32 y_end);
+extern void osddev_set(struct myfb_dev *fbdev);
+extern void osddev_update_disp_axis(struct myfb_dev *fbdev,int  mode_change) ;
+extern int osddev_setcolreg(unsigned regno, u16 red, u16 green, u16 blue,
+        u16 transp, struct myfb_dev *fbdev);
+extern void osddev_init(void) ;        
+extern void osddev_enable(int enable,int index);
+
+extern void osddev_pan_display(struct fb_var_screeninfo *var,struct fb_info *fbi);
+
+#if defined (CONFIG_FB_OSD2_CURSOR)
+extern void osddev_cursor(struct myfb_dev *fbdev, s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h);
+#endif
+
+extern  void  osddev_set_colorkey(u32 index,u32 bpp,u32 colorkey );
+extern  void  osddev_srckey_enable(u32  index,u8 enable);
+extern void  osddev_set_gbl_alpha(u32 index,u32 gbl_alpha) ;
+extern u32  osddev_get_gbl_alpha(u32  index);
+extern  void  osddev_suspend(void);
+extern  void  osddev_resume(void);
+#endif /* OSDFBDEV_H */
+
diff --git a/include/linux/amlogic/osd/osd_hw.h b/include/linux/amlogic/osd/osd_hw.h
new file mode 100755
index 000000000000..80a9d264f66f
--- /dev/null
+++ b/include/linux/amlogic/osd/osd_hw.h
@@ -0,0 +1,119 @@
+#ifndef  OSD_HW_H
+#define OSD_HW_H
+
+typedef  enum{
+	OSD1=0,
+	OSD2
+}osd_index_t;
+
+typedef  enum{
+	DISABLE=0,
+	ENABLE
+}osd_enable_t;
+
+typedef  enum{
+	SCAN_MODE_INTERLACE,
+	SCAN_MODE_PROGRESSIVE	
+}scan_mode_t;
+
+typedef  enum{
+	OSD_COLOR_MODE=0,
+	OSD_ENABLE,
+	OSD_COLOR_KEY,
+	OSD_COLOR_KEY_ENABLE,
+	OSD_GBL_ALPHA,
+	OSD_CHANGE_ORDER,
+	OSD_FREESCALE_COEF,
+	DISP_GEOMETRY,
+	DISP_SCALE_ENABLE,
+	DISP_FREESCALE_ENABLE,
+	DISP_OSD_REVERSE,
+	DISP_OSD_ROTATE,
+	HW_REG_INDEX_MAX
+}hw_reg_index;
+
+
+typedef struct {
+	s32 x_start;
+	s32 x_end;
+	s32 y_start;
+	s32 y_end;
+} pandata_t;
+
+#define  OSD_ORDER_01		1	 /*forground osd1*/
+#define  OSD_ORDER_10		2	 /*forground osd2*/
+#define OSD_GLOBAL_ALPHA_DEF  0xff
+#define OSD_DATA_BIG_ENDIAN 	0
+#define OSD_DATA_LITTLE_ENDIAN 1
+#define OSD_TC_ALPHA_ENABLE_DEF 0  //disable tc_alpha
+#define   REG_OFFSET		(0x20<<2)
+
+extern void  osd_set_colorkey_hw(u32 index,u32 bpp,u32 colorkey ) ;
+extern void  osd_srckey_enable_hw(u32  index,u8 enable);
+extern void  osd_set_gbl_alpha_hw(u32 index,u32 gbl_alpha);
+extern u32  osd_get_gbl_alpha_hw(u32  index);
+extern void osd_setup(struct osd_ctl_s *osd_ctl,
+                u32 xoffset,
+                u32 yoffset,
+                u32 xres,
+                u32 yres,
+                u32 xres_virtual ,
+                u32 yres_virtual,
+                u32 disp_start_x,
+                u32 disp_start_y,
+                u32 disp_end_x,
+                u32 disp_end_y,
+                u32 fbmem,
+              	  const color_bit_define_t *color,
+                int index);
+extern void  osddev_update_disp_axis_hw(
+			u32 display_h_start,
+                  	u32 display_h_end,
+                  	u32 display_v_start,
+                  	u32 display_v_end,
+			u32 xoffset,
+                  	u32 yoffset,
+                  	u32 mode_change,
+                  	u32 index) ;
+extern void osd_change_osd_order_hw(u32 index,u32 order);
+extern u32 osd_get_osd_order_hw(u32 index);
+extern void osd_free_scale_enable_hw(u32 index,u32 enable);
+extern void osd_get_free_scale_enable_hw(u32 index, u32 * free_scale_enable);
+extern void osd_free_scale_mode_hw(u32 index,u32 freescale_mode);
+extern void osd_get_free_scale_mode_hw(u32 index, u32 *freescale_mode);
+extern void osd_free_scale_width_hw(u32 index,u32 width) ;
+extern void osd_get_free_scale_width_hw(u32 index, u32 * free_scale_width);
+extern void osd_free_scale_height_hw(u32 index,u32 height);
+extern void osd_get_free_scale_height_hw(u32 index, u32 * free_scale_height);
+extern void osd_get_free_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
+extern void osd_set_free_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osd_get_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
+extern void osd_get_window_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
+extern void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osd_set_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern void osd_get_osd_info_hw(u32 index, s32 (*posdval)[4], u32 (*posdreg)[5], s32 info_flag);
+extern void osd_get_block_windows_hw(u32 index, u32 *windows);
+extern void osd_set_block_windows_hw(u32 index, u32 *windows);
+extern void osd_get_block_mode_hw(u32 index, u32 *mode);
+extern void osd_set_block_mode_hw(u32 index, u32 mode);
+extern void osd_enable_3d_mode_hw(int index,int enable);
+extern void osd_set_2x_scale_hw(u32 index,u16 h_scale_enable,u16 v_scale_enable);
+extern void osd_get_flush_rate(u32 *break_rate);
+extern void osd_set_osd_reverse_hw(u32 index, u32 reverse);
+extern void osd_get_osd_reverse_hw(u32 index, u32 *reverse);
+extern void osd_set_osd_rotate_on_hw(u32 index, u32 on_off);
+extern void osd_get_osd_rotate_on_hw(u32 index, u32 *on_off);
+extern void osd_set_osd_rotate_angle_hw(u32 index, u32 angle);
+extern void osd_get_osd_rotate_angle_hw(u32 index, u32 *angle);
+extern void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end, s32 *y_end);
+extern void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end, s32 y_end);
+extern void osd_setpal_hw(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp,int index);
+extern void osd_enable_hw(int enable,int index );
+extern void osd_pan_display_hw(unsigned int xoffset, unsigned int yoffset,int index );
+#if defined(CONFIG_FB_OSD2_CURSOR)
+extern void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h, int index);
+#endif
+extern void osd_suspend_hw(void);
+extern void osd_resume_hw(void);
+extern void osd_init_hw(u32  logo_loaded);
+#endif 
diff --git a/include/linux/amlogic/osd/osd_main.h b/include/linux/amlogic/osd/osd_main.h
new file mode 100755
index 000000000000..95cb38339b80
--- /dev/null
+++ b/include/linux/amlogic/osd/osd_main.h
@@ -0,0 +1,197 @@
+/*
+ * Amlogic osd
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef OSD_MAIN_H
+#define OSD_MAIN_H
+#include  <linux/list.h>
+#include  <linux/amlogic/vout/vout_notify.h>
+#include  <linux/fb.h>
+
+static __u32 var_screeninfo[5];
+
+static struct fb_var_screeninfo mydef_var[] = {
+{
+	.xres            = 1200,
+	.yres            = 690,
+	.xres_virtual    = 1200,
+	.yres_virtual    = 1380,
+	.xoffset         = 0,
+	.yoffset         = 0,
+	.bits_per_pixel = 16,
+	.grayscale       = 0,
+	.red             = {0, 0, 0},
+	.green           = {0, 0, 0},
+	.blue            = {0, 0, 0},
+	.transp          = {0, 0, 0},
+	.nonstd          = 0,
+	.activate        = FB_ACTIVATE_NOW,
+	.height          = -1,
+	.width           = -1,
+	.accel_flags     = 0,
+	.pixclock        = 0,
+	.left_margin     = 0,
+	.right_margin    = 0,
+	.upper_margin    = 0,
+	.lower_margin    = 0,
+	.hsync_len       = 0,
+	.vsync_len       = 0,
+	.sync            = 0,
+	.vmode           = FB_VMODE_NONINTERLACED,
+	.rotate          = 0,
+	
+}
+
+#ifdef  CONFIG_FB_OSD2_ENABLE
+,
+{
+#if defined(CONFIG_FB_OSD2_DEFAULT_WIDTH)
+	.xres            = CONFIG_FB_OSD2_DEFAULT_WIDTH,
+#else
+	.xres            = 32,
+#endif
+#if defined(CONFIG_FB_OSD2_DEFAULT_HEIGHT)
+	.yres            = CONFIG_FB_OSD2_DEFAULT_HEIGHT,
+#else
+	.yres            = 32,
+#endif
+#if defined(CONFIG_FB_OSD2_DEFAULT_WIDTH_VIRTUAL)
+	.xres_virtual    = CONFIG_FB_OSD2_DEFAULT_WIDTH_VIRTUAL,
+#else
+	.xres_virtual    = 32,
+#endif
+#if defined(CONFIG_FB_OSD2_DEFAULT_HEIGHT_VIRTUAL)
+	.yres_virtual    = CONFIG_FB_OSD2_DEFAULT_HEIGHT_VIRTUAL,
+#else
+	.yres_virtual    = 32,
+#endif
+	.xoffset         = 0,
+	.yoffset         = 0,
+#if defined(CONFIG_FB_OSD2_DEFAULT_BITS_PER_PIXEL)
+	.bits_per_pixel  = CONFIG_FB_OSD2_DEFAULT_BITS_PER_PIXEL,
+#else
+	.bits_per_pixel = 32,
+#endif
+	.grayscale       = 0,
+	.red             = {0, 0, 0},  //leave as it is ,set by system.
+	.green           = {0, 0, 0},
+	.blue            = {0, 0, 0},
+	.transp          = {0, 0, 0},
+	.nonstd          = 0,
+	.activate        = FB_ACTIVATE_NOW,
+	.height          = -1,
+	.width           = -1,
+	.accel_flags     = 0,
+	.pixclock        = 0,
+	.left_margin     = 0,
+	.right_margin    = 0,
+	.upper_margin    = 0,
+	.lower_margin    = 0,
+	.hsync_len       = 0,
+	.vsync_len       = 0,
+	.sync            = 0,
+	.vmode           = FB_VMODE_NONINTERLACED,
+	.rotate          = 0,
+}
+#endif 
+};
+
+
+static struct fb_fix_screeninfo mydef_fix = {
+	.id		    = "OSD FB",
+	.xpanstep 	= 1,
+	.ypanstep 	= 1,
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_TRUECOLOR,
+	.accel		= FB_ACCEL_NONE,
+};
+
+typedef  struct {
+	int x ;
+	int y ;
+	int w ;
+	int h ;
+}disp_rect_t;
+#define DRIVER_NAME "osdfb"
+#define MODULE_NAME "osdfb"
+#define  FBIOPUT_OSD_SRCCOLORKEY	0x46fb
+#define  FBIOPUT_OSD_SRCKEY_ENABLE	0x46fa
+#define  FBIOPUT_OSD_SET_GBL_ALPHA	0x4500
+#define  FBIOGET_OSD_GET_GBL_ALPHA	0x4501
+#define  FBIOPUT_OSD_2X_SCALE		0x4502
+#define  FBIOPUT_OSD_ENABLE_3D_MODE	0x4503
+#define  FBIOPUT_OSD_FREE_SCALE_ENABLE	0x4504
+#define  FBIOPUT_OSD_FREE_SCALE_WIDTH	0x4505
+#define  FBIOPUT_OSD_FREE_SCALE_HEIGHT	0x4506
+#define  FBIOPUT_OSD_ORDER  		0x4507
+#define  FBIOGET_OSD_ORDER  		0x4508
+#define  FBIOGET_OSD_SCALE_AXIS		0x4509
+#define  FBIOPUT_OSD_SCALE_AXIS		0x450a
+#define  FBIOGET_OSD_BLOCK_WINDOWS	0x450b
+#define  FBIOPUT_OSD_BLOCK_WINDOWS	0x450c
+#define  FBIOGET_OSD_BLOCK_MODE		0x450d
+#define  FBIOPUT_OSD_BLOCK_MODE		0x450e
+#define  FBIOGET_OSD_FREE_SCALE_AXIS 0x450f
+#define  FBIOPUT_OSD_FREE_SCALE_AXIS  0x4510
+#define  FBIOPUT_OSD_FREE_SCALE_MODE  0x4511
+#define  FBIOGET_OSD_WINDOW_AXIS  	0x4512
+#define  FBIOPUT_OSD_WINDOW_AXIS  	0x4513
+#define  FBIOGET_OSD_FLUSH_RATE	0x4514
+#define  FBIOPUT_OSD_REVERSE		0x4515
+#define  FBIOPUT_OSD_ROTATE_ON   	0x4516
+#define	 FBIOPUT_OSD_ROTATE_ANGLE	0x4517
+
+#define  OSD_INVALID_INFO   		0xffffffff
+
+#define  OSD_FIRST_GROUP_START   	1
+#define  OSD_SECOND_GROUP_START 	4
+#define  OSD_END			5
+
+typedef  struct {
+	u32 index;
+	u32 osd_reverse;
+}osd_info_t;
+
+typedef  struct {
+	char *name;
+	u32   info;
+	u32   prev_idx;
+	u32   next_idx;
+	u32   cur_group_start;
+	u32   cur_group_end;
+}para_osd_info_t;
+
+typedef enum{
+	DEV_OSD0 = 0,
+	DEV_OSD1,
+	DEV_ALL,
+	DEV_MAX
+}osd_dev_t;
+
+typedef enum{
+	REVERSE_FALSE = 0,
+	REVERSE_TRUE,
+	REVERSE_MAX
+}reverse_info_t;
+
+#endif /* OSD_MAIN_H */
diff --git a/include/linux/amlogic/tvin/tvin.h b/include/linux/amlogic/tvin/tvin.h
new file mode 100755
index 000000000000..ce09683ab467
--- /dev/null
+++ b/include/linux/amlogic/tvin/tvin.h
@@ -0,0 +1,782 @@
+/*
+ * TVIN Modules Exported Header File
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __TVIN_H
+#define __TVIN_H
+
+#include <plat/io.h>
+
+#define R_CBUS_REG(reg) aml_read_reg32(CBUS_REG_ADDR(reg))
+#define W_CBUS_REG(reg, val) aml_write_reg32(CBUS_REG_ADDR(reg), val)
+#define R_CBUS_BIT(reg, start, len) \
+	aml_get_reg32_bits(CBUS_REG_ADDR(reg), start, len)
+#define W_CBUS_BIT(reg, val, start, len) \
+	aml_set_reg32_bits(CBUS_REG_ADDR(reg), val, start, len)
+
+#define R_APB_REG(reg) aml_read_reg32(APB_REG_ADDR(reg))
+#define W_APB_REG(reg, val) aml_write_reg32(APB_REG_ADDR(reg), val)
+#define R_APB_BIT(reg, start, len) \
+	aml_get_reg32_bits(APB_REG_ADDR(reg), start, len)
+#define W_APB_BIT(reg, val, start, len) \
+	aml_set_reg32_bits(APB_REG_ADDR(reg), val, start, len)
+
+
+enum {
+    MEMP_VDIN_WITHOUT_3D = 0,
+    MEMP_VDIN_WITH_3D,
+    MEMP_DCDR_WITHOUT_3D,
+    MEMP_DCDR_WITH_3D,
+    MEMP_ATV_WITHOUT_3D,
+    MEMP_ATV_WITH_3D,
+};
+
+// ***************************************************************************
+// *** TVIN general definition/enum/struct ***********************************
+// ***************************************************************************
+/* tvin input port select */
+typedef enum tvin_port_e {
+        TVIN_PORT_NULL    = 0x00000000,
+        TVIN_PORT_MPEG0   = 0x00000100,
+        TVIN_PORT_BT656   = 0x00000200,
+        TVIN_PORT_BT601,
+        TVIN_PORT_CAMERA,
+        TVIN_PORT_VGA0    = 0x00000400,
+        TVIN_PORT_VGA1,
+        TVIN_PORT_VGA2,
+        TVIN_PORT_VGA3,
+        TVIN_PORT_VGA4,
+        TVIN_PORT_VGA5,
+        TVIN_PORT_VGA6,
+        TVIN_PORT_VGA7,
+        TVIN_PORT_COMP0   = 0x00000800,
+        TVIN_PORT_COMP1,
+        TVIN_PORT_COMP2,
+        TVIN_PORT_COMP3,
+        TVIN_PORT_COMP4,
+        TVIN_PORT_COMP5,
+        TVIN_PORT_COMP6,
+        TVIN_PORT_COMP7,
+        TVIN_PORT_CVBS0   = 0x00001000,
+        TVIN_PORT_CVBS1,
+        TVIN_PORT_CVBS2,
+        TVIN_PORT_CVBS3,
+        TVIN_PORT_CVBS4,
+        TVIN_PORT_CVBS5,
+        TVIN_PORT_CVBS6,
+        TVIN_PORT_CVBS7,
+        TVIN_PORT_SVIDEO0 = 0x00002000,
+        TVIN_PORT_SVIDEO1,
+        TVIN_PORT_SVIDEO2,
+        TVIN_PORT_SVIDEO3,
+        TVIN_PORT_SVIDEO4,
+        TVIN_PORT_SVIDEO5,
+        TVIN_PORT_SVIDEO6,
+        TVIN_PORT_SVIDEO7,
+        TVIN_PORT_HDMI0   = 0x00004000,
+        TVIN_PORT_HDMI1,
+        TVIN_PORT_HDMI2,
+        TVIN_PORT_HDMI3,
+        TVIN_PORT_HDMI4,
+        TVIN_PORT_HDMI5,
+        TVIN_PORT_HDMI6,
+        TVIN_PORT_HDMI7,
+        TVIN_PORT_DVIN0   = 0x00008000,
+        TVIN_PORT_VIU     = 0x0000C000,
+        TVIN_PORT_MIPI    = 0x00010000,
+        TVIN_PORT_ISP     = 0x00020000,
+        TVIN_PORT_MAX     = 0x80000000,
+} tvin_port_t;
+
+const char * tvin_port_str(enum tvin_port_e port);
+
+
+/* tvin signal format table */
+typedef enum tvin_sig_fmt_e {
+        TVIN_SIG_FMT_NULL = 0,
+        //VGA Formats
+        TVIN_SIG_FMT_VGA_512X384P_60HZ_D147             = 0x001,
+        TVIN_SIG_FMT_VGA_560X384P_60HZ_D147             = 0x002,
+        TVIN_SIG_FMT_VGA_640X200P_59HZ_D924             = 0x003,
+        TVIN_SIG_FMT_VGA_640X350P_85HZ_D080             = 0x004,
+        TVIN_SIG_FMT_VGA_640X400P_59HZ_D940             = 0x005,
+        TVIN_SIG_FMT_VGA_640X400P_85HZ_D080             = 0x006,
+        TVIN_SIG_FMT_VGA_640X400P_59HZ_D638             = 0x007,
+        TVIN_SIG_FMT_VGA_640X400P_56HZ_D416             = 0x008,
+        TVIN_SIG_FMT_VGA_640X480P_66HZ_D619             = 0x009,
+        TVIN_SIG_FMT_VGA_640X480P_66HZ_D667             = 0x00a,
+        TVIN_SIG_FMT_VGA_640X480P_59HZ_D940             = 0x00b,
+        TVIN_SIG_FMT_VGA_640X480P_60HZ_D000             = 0x00c,
+        TVIN_SIG_FMT_VGA_640X480P_72HZ_D809             = 0x00d,
+        TVIN_SIG_FMT_VGA_640X480P_75HZ_D000_A           = 0x00e,
+        TVIN_SIG_FMT_VGA_640X480P_85HZ_D008             = 0x00f,
+        TVIN_SIG_FMT_VGA_640X480P_59HZ_D638             = 0x010,
+        TVIN_SIG_FMT_VGA_640X480P_75HZ_D000_B           = 0x011,
+        TVIN_SIG_FMT_VGA_640X870P_75HZ_D000             = 0x012,
+        TVIN_SIG_FMT_VGA_720X350P_70HZ_D086             = 0x013,
+        TVIN_SIG_FMT_VGA_720X400P_85HZ_D039             = 0x014,
+        TVIN_SIG_FMT_VGA_720X400P_70HZ_D086             = 0x015,
+        TVIN_SIG_FMT_VGA_720X400P_87HZ_D849             = 0x016,
+        TVIN_SIG_FMT_VGA_720X400P_59HZ_D940             = 0x017,
+        TVIN_SIG_FMT_VGA_720X480P_59HZ_D940             = 0x018,
+        TVIN_SIG_FMT_VGA_768X480P_59HZ_D896             = 0x019,
+        TVIN_SIG_FMT_VGA_800X600P_56HZ_D250             = 0x01a,
+        TVIN_SIG_FMT_VGA_800X600P_60HZ_D000             = 0x01b,
+        TVIN_SIG_FMT_VGA_800X600P_60HZ_D000_A           = 0x01c,
+        TVIN_SIG_FMT_VGA_800X600P_60HZ_D317             = 0x01d,
+        TVIN_SIG_FMT_VGA_800X600P_72HZ_D188             = 0x01e,
+        TVIN_SIG_FMT_VGA_800X600P_75HZ_D000             = 0x01f,
+        TVIN_SIG_FMT_VGA_800X600P_85HZ_D061             = 0x020,
+        TVIN_SIG_FMT_VGA_832X624P_75HZ_D087             = 0x021,
+        TVIN_SIG_FMT_VGA_848X480P_84HZ_D751             = 0x022,
+        TVIN_SIG_FMT_VGA_960X600P_59HZ_D635             = 0x023,
+        TVIN_SIG_FMT_VGA_1024X768P_59HZ_D278            = 0x024,
+        TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000            = 0x025,
+        TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_A          = 0x026,
+        TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_B          = 0x027,
+        TVIN_SIG_FMT_VGA_1024X768P_74HZ_D927            = 0x028,
+        TVIN_SIG_FMT_VGA_1024X768P_60HZ_D004            = 0x029,
+        TVIN_SIG_FMT_VGA_1024X768P_70HZ_D069            = 0x02a,
+        TVIN_SIG_FMT_VGA_1024X768P_75HZ_D029            = 0x02b,
+        TVIN_SIG_FMT_VGA_1024X768P_84HZ_D997            = 0x02c,
+        TVIN_SIG_FMT_VGA_1024X768P_74HZ_D925            = 0x02d,
+        TVIN_SIG_FMT_VGA_1024X768P_75HZ_D020            = 0x02e,
+        TVIN_SIG_FMT_VGA_1024X768P_70HZ_D008            = 0x02f,
+        TVIN_SIG_FMT_VGA_1024X768P_75HZ_D782            = 0x030,
+        TVIN_SIG_FMT_VGA_1024X768P_77HZ_D069            = 0x031,
+        TVIN_SIG_FMT_VGA_1024X768P_71HZ_D799            = 0x032,
+        TVIN_SIG_FMT_VGA_1024X1024P_60HZ_D000           = 0x033,
+        TVIN_SIG_FMT_VGA_1152X864P_60HZ_D000            = 0x034,
+        TVIN_SIG_FMT_VGA_1152X864P_70HZ_D012            = 0x035,
+        TVIN_SIG_FMT_VGA_1152X864P_75HZ_D000            = 0x036,
+        TVIN_SIG_FMT_VGA_1152X864P_84HZ_D999            = 0x037,
+        TVIN_SIG_FMT_VGA_1152X870P_75HZ_D062            = 0x038,
+        TVIN_SIG_FMT_VGA_1152X900P_65HZ_D950            = 0x039,
+        TVIN_SIG_FMT_VGA_1152X900P_66HZ_D004            = 0x03a,
+        TVIN_SIG_FMT_VGA_1152X900P_76HZ_D047            = 0x03b,
+        TVIN_SIG_FMT_VGA_1152X900P_76HZ_D149            = 0x03c,
+        TVIN_SIG_FMT_VGA_1280X720P_59HZ_D855            = 0x03d,
+        TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_A          = 0x03e,
+        TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_B          = 0x03f,
+        TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_C          = 0x040,
+        TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_D          = 0x041,
+        TVIN_SIG_FMT_VGA_1280X768P_59HZ_D870            = 0x042,
+        TVIN_SIG_FMT_VGA_1280X768P_59HZ_D995            = 0x043,
+        TVIN_SIG_FMT_VGA_1280X768P_60HZ_D100            = 0x044,
+        TVIN_SIG_FMT_VGA_1280X768P_85HZ_D000            = 0x045,
+        TVIN_SIG_FMT_VGA_1280X768P_74HZ_D893            = 0x046,
+        TVIN_SIG_FMT_VGA_1280X768P_84HZ_D837            = 0x047,
+        TVIN_SIG_FMT_VGA_1280X800P_59HZ_D810            = 0x048,
+        TVIN_SIG_FMT_VGA_1280X800P_59HZ_D810_A          = 0x049,
+        TVIN_SIG_FMT_VGA_1280X800P_60HZ_D000            = 0x04a,
+        TVIN_SIG_FMT_VGA_1280X800P_85HZ_D000            = 0x04b,
+        TVIN_SIG_FMT_VGA_1280X960P_60HZ_D000            = 0x04c,
+        TVIN_SIG_FMT_VGA_1280X960P_60HZ_D000_A          = 0x04d,
+        TVIN_SIG_FMT_VGA_1280X960P_75HZ_D000            = 0x04e,
+        TVIN_SIG_FMT_VGA_1280X960P_85HZ_D002            = 0x04f,
+        TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D020           = 0x050,
+        TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D020_A         = 0x051,
+        TVIN_SIG_FMT_VGA_1280X1024P_75HZ_D025           = 0x052,
+        TVIN_SIG_FMT_VGA_1280X1024P_85HZ_D024           = 0x053,
+        TVIN_SIG_FMT_VGA_1280X1024P_59HZ_D979           = 0x054,
+        TVIN_SIG_FMT_VGA_1280X1024P_72HZ_D005           = 0x055,
+        TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D002           = 0x056,
+        TVIN_SIG_FMT_VGA_1280X1024P_67HZ_D003           = 0x057,
+        TVIN_SIG_FMT_VGA_1280X1024P_74HZ_D112           = 0x058,
+        TVIN_SIG_FMT_VGA_1280X1024P_76HZ_D179           = 0x059,
+        TVIN_SIG_FMT_VGA_1280X1024P_66HZ_D718           = 0x05a,
+        TVIN_SIG_FMT_VGA_1280X1024P_66HZ_D677           = 0x05b,
+        TVIN_SIG_FMT_VGA_1280X1024P_76HZ_D107           = 0x05c,
+        TVIN_SIG_FMT_VGA_1280X1024P_59HZ_D996           = 0x05d,
+        TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D000           = 0x05e,
+        TVIN_SIG_FMT_VGA_1360X768P_59HZ_D799            = 0x05f,
+        TVIN_SIG_FMT_VGA_1360X768P_60HZ_D015            = 0x060,
+        TVIN_SIG_FMT_VGA_1360X768P_60HZ_D015_A          = 0x061,
+        TVIN_SIG_FMT_VGA_1360X850P_60HZ_D000            = 0x062,
+        TVIN_SIG_FMT_VGA_1360X1024P_60HZ_D000           = 0x063,
+        TVIN_SIG_FMT_VGA_1366X768P_59HZ_D790            = 0x064,
+        TVIN_SIG_FMT_VGA_1366X768P_60HZ_D000            = 0x065,
+        TVIN_SIG_FMT_VGA_1400X1050P_59HZ_D978           = 0x066,
+        TVIN_SIG_FMT_VGA_1440X900P_59HZ_D887            = 0x067,
+        TVIN_SIG_FMT_VGA_1440X1080P_60HZ_D000           = 0x068,
+        TVIN_SIG_FMT_VGA_1600X900P_60HZ_D000            = 0x069,
+        TVIN_SIG_FMT_VGA_1600X1024P_60HZ_D000           = 0x06a,
+        TVIN_SIG_FMT_VGA_1600X1200P_59HZ_D869           = 0x06b,
+        TVIN_SIG_FMT_VGA_1600X1200P_60HZ_D000           = 0x06c,
+        TVIN_SIG_FMT_VGA_1600X1200P_65HZ_D000           = 0x06d,
+        TVIN_SIG_FMT_VGA_1600X1200P_70HZ_D000           = 0x06e,
+        TVIN_SIG_FMT_VGA_1680X1050P_59HZ_D954           = 0x06f,
+        TVIN_SIG_FMT_VGA_1680X1080P_60HZ_D000           = 0x070,
+        TVIN_SIG_FMT_VGA_1920X1080P_49HZ_D929           = 0x071,
+        TVIN_SIG_FMT_VGA_1920X1080P_59HZ_D963_A         = 0x072,
+        TVIN_SIG_FMT_VGA_1920X1080P_59HZ_D963           = 0x073,
+        TVIN_SIG_FMT_VGA_1920X1080P_60HZ_D000           = 0x074,
+        TVIN_SIG_FMT_VGA_1920X1200P_59HZ_D950           = 0x075,
+        TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_C          = 0x076,
+        TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_D          = 0x077,
+        TVIN_SIG_FMT_VGA_1920X1200P_59HZ_D988            = 0x078,
+        TVIN_SIG_FMT_VGA_1400X900P_60HZ_D000             = 0x079,
+        TVIN_SIG_FMT_VGA_1680X1050P_60HZ_D000            = 0x07a,
+        TVIN_SIG_FMT_VGA_RESERVE6                       = 0x07b,
+        TVIN_SIG_FMT_VGA_RESERVE7                       = 0x07c,
+        TVIN_SIG_FMT_VGA_RESERVE8                       = 0x07d,
+        TVIN_SIG_FMT_VGA_RESERVE9                       = 0x07e,
+        TVIN_SIG_FMT_VGA_RESERVE10                      = 0x07f,
+        TVIN_SIG_FMT_VGA_RESERVE11                      = 0x080,
+        TVIN_SIG_FMT_VGA_RESERVE12                      = 0x081,
+        TVIN_SIG_FMT_VGA_MAX                            = 0x082,
+        TVIN_SIG_FMT_VGA_THRESHOLD                      = 0x200,
+        //Component Formats
+        TVIN_SIG_FMT_COMP_480P_60HZ_D000                = 0x201,
+        TVIN_SIG_FMT_COMP_480I_59HZ_D940                = 0x202,
+        TVIN_SIG_FMT_COMP_576P_50HZ_D000                = 0x203,
+        TVIN_SIG_FMT_COMP_576I_50HZ_D000                = 0x204,
+        TVIN_SIG_FMT_COMP_720P_59HZ_D940                = 0x205,
+        TVIN_SIG_FMT_COMP_720P_50HZ_D000                = 0x206,
+        TVIN_SIG_FMT_COMP_1080P_23HZ_D976               = 0x207,
+        TVIN_SIG_FMT_COMP_1080P_24HZ_D000               = 0x208,
+        TVIN_SIG_FMT_COMP_1080P_25HZ_D000               = 0x209,
+        TVIN_SIG_FMT_COMP_1080P_30HZ_D000               = 0x20a,
+        TVIN_SIG_FMT_COMP_1080P_50HZ_D000               = 0x20b,
+        TVIN_SIG_FMT_COMP_1080P_60HZ_D000               = 0x20c,
+        TVIN_SIG_FMT_COMP_1080I_47HZ_D952               = 0x20d,
+        TVIN_SIG_FMT_COMP_1080I_48HZ_D000               = 0x20e,
+        TVIN_SIG_FMT_COMP_1080I_50HZ_D000_A             = 0x20f,
+        TVIN_SIG_FMT_COMP_1080I_50HZ_D000_B             = 0x210,
+        TVIN_SIG_FMT_COMP_1080I_50HZ_D000_C             = 0x211,
+        TVIN_SIG_FMT_COMP_1080I_60HZ_D000               = 0x212,
+        TVIN_SIG_FMT_COMP_MAX                           = 0x213,
+        TVIN_SIG_FMT_COMP_THRESHOLD                     = 0x400,
+        //HDMI Formats
+        TVIN_SIG_FMT_HDMI_640X480P_60HZ                 = 0x401,
+        TVIN_SIG_FMT_HDMI_720X480P_60HZ                 = 0x402,
+        TVIN_SIG_FMT_HDMI_1280X720P_60HZ                = 0x403,
+        TVIN_SIG_FMT_HDMI_1920X1080I_60HZ               = 0x404,
+        TVIN_SIG_FMT_HDMI_1440X480I_60HZ                = 0x405,
+        TVIN_SIG_FMT_HDMI_1440X240P_60HZ                = 0x406,
+        TVIN_SIG_FMT_HDMI_2880X480I_60HZ                = 0x407,
+        TVIN_SIG_FMT_HDMI_2880X240P_60HZ                = 0x408,
+        TVIN_SIG_FMT_HDMI_1440X480P_60HZ                = 0x409,
+        TVIN_SIG_FMT_HDMI_1920X1080P_60HZ               = 0x40a,
+        TVIN_SIG_FMT_HDMI_720X576P_50HZ                 = 0x40b,
+        TVIN_SIG_FMT_HDMI_1280X720P_50HZ                = 0x40c,
+        TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_A             = 0x40d,
+        TVIN_SIG_FMT_HDMI_1440X576I_50HZ                = 0x40e,
+        TVIN_SIG_FMT_HDMI_1440X288P_50HZ                = 0x40f,
+        TVIN_SIG_FMT_HDMI_2880X576I_50HZ                = 0x410,
+        TVIN_SIG_FMT_HDMI_2880X288P_50HZ                = 0x411,
+        TVIN_SIG_FMT_HDMI_1440X576P_50HZ                = 0x412,
+        TVIN_SIG_FMT_HDMI_1920X1080P_50HZ               = 0x413,
+        TVIN_SIG_FMT_HDMI_1920X1080P_24HZ               = 0x414,
+        TVIN_SIG_FMT_HDMI_1920X1080P_25HZ               = 0x415,
+        TVIN_SIG_FMT_HDMI_1920X1080P_30HZ               = 0x416,
+        TVIN_SIG_FMT_HDMI_2880X480P_60HZ                = 0x417,
+        TVIN_SIG_FMT_HDMI_2880X576P_60HZ                = 0x418,
+        TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_B             = 0x419,
+        TVIN_SIG_FMT_HDMI_1920X1080I_100HZ              = 0x41a,
+        TVIN_SIG_FMT_HDMI_1280X720P_100HZ               = 0x41b,
+        TVIN_SIG_FMT_HDMI_720X576P_100HZ                = 0x41c,
+        TVIN_SIG_FMT_HDMI_1440X576I_100HZ               = 0x41d,
+        TVIN_SIG_FMT_HDMI_1920X1080I_120HZ              = 0x41e,
+        TVIN_SIG_FMT_HDMI_1280X720P_120HZ               = 0x41f,
+        TVIN_SIG_FMT_HDMI_720X480P_120HZ                = 0x420,
+        TVIN_SIG_FMT_HDMI_1440X480I_120HZ               = 0x421,
+        TVIN_SIG_FMT_HDMI_720X576P_200HZ                = 0x422,
+        TVIN_SIG_FMT_HDMI_1440X576I_200HZ               = 0x423,
+        TVIN_SIG_FMT_HDMI_720X480P_240HZ                = 0x424,
+        TVIN_SIG_FMT_HDMI_1440X480I_240HZ               = 0x425,
+        TVIN_SIG_FMT_HDMI_1280X720P_24HZ                = 0x426,
+        TVIN_SIG_FMT_HDMI_1280X720P_25HZ                = 0x427,
+        TVIN_SIG_FMT_HDMI_1280X720P_30HZ                = 0x428,
+        TVIN_SIG_FMT_HDMI_1920X1080P_120HZ              = 0x429,
+        TVIN_SIG_FMT_HDMI_1920X1080P_100HZ              = 0x42a,
+        TVIN_SIG_FMT_HDMI_1280X720P_60HZ_FRAME_PACKING  = 0x42b,
+        TVIN_SIG_FMT_HDMI_1280X720P_50HZ_FRAME_PACKING  = 0x42c,
+        TVIN_SIG_FMT_HDMI_1280X720P_24HZ_FRAME_PACKING  = 0x42d,
+        TVIN_SIG_FMT_HDMI_1280X720P_30HZ_FRAME_PACKING  = 0x42e,
+        TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_FRAME_PACKING = 0x42f,
+        TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_FRAME_PACKING = 0x430,
+        TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_FRAME_PACKING = 0x431,
+        TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_FRAME_PACKING = 0x432,
+        TVIN_SIG_FMT_HDMI_800X600_00HZ                  = 0x433,
+        TVIN_SIG_FMT_HDMI_1024X768_00HZ                 = 0x434,
+        TVIN_SIG_FMT_HDMI_720X400_00HZ                  = 0x435,
+        TVIN_SIG_FMT_HDMI_1280X768_00HZ                 = 0x436,
+        TVIN_SIG_FMT_HDMI_1280X800_00HZ                 = 0x437,
+        TVIN_SIG_FMT_HDMI_1280X960_00HZ                 = 0x438,
+        TVIN_SIG_FMT_HDMI_1280X1024_00HZ                = 0x439,
+        TVIN_SIG_FMT_HDMI_1360X768_00HZ                 = 0x43a,
+        TVIN_SIG_FMT_HDMI_1366X768_00HZ                 = 0x43b,
+        TVIN_SIG_FMT_HDMI_1600X1200_00HZ                = 0x43c,
+        TVIN_SIG_FMT_HDMI_1920X1200_00HZ                = 0x43d,
+        TVIN_SIG_FMT_HDMI_1440X900_00HZ                 = 0x43e,
+        TVIN_SIG_FMT_HDMI_1400X1050_00HZ                = 0x43f,
+        TVIN_SIG_FMT_HDMI_1680X1050_00HZ                = 0x440,
+            /* for alternative and 4k2k */
+        TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_ALTERNATIVE   = 0x441,
+        TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_ALTERNATIVE   = 0x442,
+        TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_ALTERNATIVE   = 0x443,
+        TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_ALTERNATIVE   = 0x444,
+        TVIN_SIG_FMT_HDMI_3840_2160_00HZ                = 0x445,
+        TVIN_SIG_FMT_HDMI_4096_2160_00HZ                = 0x446,
+        TVIN_SIG_FMT_HDMI_RESERVE7                      = 0x447,
+        TVIN_SIG_FMT_HDMI_RESERVE8                      = 0x448,
+        TVIN_SIG_FMT_HDMI_RESERVE9                      = 0x449,
+        TVIN_SIG_FMT_HDMI_RESERVE10                     = 0x44a,
+        TVIN_SIG_FMT_HDMI_RESERVE11                     = 0x44b,
+        TVIN_SIG_FMT_HDMI_720X480P_60HZ_FRAME_PACKING   = 0x44c,
+        TVIN_SIG_FMT_HDMI_720X576P_50HZ_FRAME_PACKING   = 0x44d,
+        TVIN_SIG_FMT_HDMI_MAX                           = 0x44e,
+        TVIN_SIG_FMT_HDMI_THRESHOLD                     = 0x600,
+        //Video Formats
+        TVIN_SIG_FMT_CVBS_NTSC_M                        = 0x601,
+        TVIN_SIG_FMT_CVBS_NTSC_443                      = 0x602,
+        TVIN_SIG_FMT_CVBS_PAL_I                         = 0x603,
+        TVIN_SIG_FMT_CVBS_PAL_M                         = 0x604,
+        TVIN_SIG_FMT_CVBS_PAL_60                        = 0x605,
+        TVIN_SIG_FMT_CVBS_PAL_CN                        = 0x606,
+        TVIN_SIG_FMT_CVBS_SECAM                         = 0x607,
+        TVIN_SIG_FMT_CVBS_MAX                           = 0x608,
+        TVIN_SIG_FMT_CVBS_THRESHOLD                     = 0x800,
+        //656 Formats
+        TVIN_SIG_FMT_BT656IN_576I_50HZ                  = 0x801,
+        TVIN_SIG_FMT_BT656IN_480I_60HZ                  = 0x802,
+        //601 Formats
+        TVIN_SIG_FMT_BT601IN_576I_50HZ                  = 0x803,
+        TVIN_SIG_FMT_BT601IN_480I_60HZ                  = 0x804,
+        //Camera Formats
+        TVIN_SIG_FMT_CAMERA_640X480P_30HZ               = 0x805,
+        TVIN_SIG_FMT_CAMERA_800X600P_30HZ               = 0x806,
+        TVIN_SIG_FMT_CAMERA_1024X768P_30HZ              = 0x807,
+        TVIN_SIG_FMT_CAMERA_1920X1080P_30HZ             = 0x808,
+        TVIN_SIG_FMT_CAMERA_1280X720P_30HZ              = 0x809,
+        TVIN_SIG_FMT_BT601_MAX                          = 0x80a,
+        TVIN_SIG_FMT_BT601_THRESHOLD                    = 0xa00,
+        TVIN_SIG_FMT_MAX,
+} tvin_sig_fmt_t;
+
+//tvin signal status
+typedef enum tvin_sig_status_e {
+        TVIN_SIG_STATUS_NULL = 0, // processing status from init to the finding of the 1st confirmed status
+        TVIN_SIG_STATUS_NOSIG,    // no signal - physically no signal
+        TVIN_SIG_STATUS_UNSTABLE, // unstable - physically bad signal
+        TVIN_SIG_STATUS_NOTSUP,   // not supported - physically good signal & not supported
+        TVIN_SIG_STATUS_STABLE,   // stable - physically good signal & supported
+} tvin_sig_status_t;
+
+const char *tvin_sig_status_str(enum tvin_sig_status_e status);
+
+// tvin parameters
+#define TVIN_PARM_FLAG_CAP      0x00000001 //tvin_parm_t.flag[ 0]: 1/enable or 0/disable frame capture function
+#define TVIN_PARM_FLAG_CAL      0x00000002 //tvin_parm_t.flag[ 1]: 1/enable or 0/disable adc calibration
+/*used for processing 3d in ppmgr set this flag to drop one field and send real height in vframe*/
+#define TVIN_PARM_FLAG_2D_TO_3D 0x00000004 //tvin_parm_t.flag[ 2]: 1/enable or 0/disable 2D->3D mode
+
+typedef enum tvin_trans_fmt {
+        TVIN_TFMT_2D = 0,
+        TVIN_TFMT_3D_LRH_OLOR,  // 1 Primary: Side-by-Side(Half) Odd/Left picture, Odd/Right p
+        TVIN_TFMT_3D_LRH_OLER,  // 2 Primary: Side-by-Side(Half) Odd/Left picture, Even/Right picture
+        TVIN_TFMT_3D_LRH_ELOR,  // 3 Primary: Side-by-Side(Half) Even/Left picture, Odd/Right picture
+        TVIN_TFMT_3D_LRH_ELER,  // 4 Primary: Side-by-Side(Half) Even/Left picture, Even/Right picture
+        TVIN_TFMT_3D_TB,   // 5 Primary: Top-and-Bottom
+        TVIN_TFMT_3D_FP,   // 6 Primary: Frame Packing
+        TVIN_TFMT_3D_FA,   // 7 Secondary: Field Alternative
+        TVIN_TFMT_3D_LA,   // 8 Secondary: Line Alternative
+        TVIN_TFMT_3D_LRF,  // 9 Secondary: Side-by-Side(Full)
+        TVIN_TFMT_3D_LD,   // 10 Secondary: L+depth
+        TVIN_TFMT_3D_LDGD, // 11 Secondary: L+depth+Graphics+Graphics-depth
+        /* normal 3D format */
+        TVIN_TFMT_3D_DET_TB,// 12
+        TVIN_TFMT_3D_DET_LR,// 13
+        TVIN_TFMT_3D_DET_INTERLACE,// 14
+        TVIN_TFMT_3D_DET_CHESSBOARD,// 15
+} tvin_trans_fmt_t;
+
+const char *tvin_trans_fmt_str(enum tvin_trans_fmt trans_fmt);
+
+typedef enum tvin_color_fmt_e {
+        TVIN_RGB444 = 0,
+        TVIN_YUV422, // 1
+        TVIN_YUV444, // 2
+        TVIN_YUYV422,// 3
+        TVIN_YVYU422,// 4
+        TVIN_UYVY422,// 5
+        TVIN_VYUY422,// 6
+        TVIN_NV12,   // 7
+        TVIN_NV21,   // 8
+        TVIN_COLOR_FMT_MAX,
+}tvin_color_fmt_t;
+
+const char *tvin_color_fmt_str(enum tvin_color_fmt_e color_fmt);
+typedef enum tvin_scan_mode_e {
+        TVIN_SCAN_MODE_NULL = 0,
+        TVIN_SCAN_MODE_PROGRESSIVE,
+        TVIN_SCAN_MODE_INTERLACED,
+} tvin_scan_mode_t;
+
+typedef struct tvin_info_s {
+        enum tvin_trans_fmt    trans_fmt;
+        enum tvin_sig_fmt_e    fmt;
+        enum tvin_sig_status_e status;
+        unsigned int           reserved;
+}tvin_info_t;
+
+typedef struct tvin_buf_info_s {
+        unsigned int vf_size;
+        unsigned int buf_count;
+        unsigned int buf_width;
+        unsigned int buf_height;
+        unsigned int buf_size;
+        unsigned int wr_list_size;
+} tvin_buf_info_t;
+
+typedef struct tvin_video_buf_s {
+        unsigned int index;
+        unsigned int reserved;
+} tvin_video_buf_t;
+
+// hs=he=vs=ve=0 is to disable Cut Window
+typedef struct tvin_cutwin_s {
+        unsigned int hs;
+        unsigned int he;
+        unsigned int vs;
+        unsigned int ve;
+} tvin_cutwin_t;
+
+typedef struct tvin_parm_s {
+        int                         index;    // index of frontend for vdin
+        enum tvin_port_e            port;     // must set port in IOCTL
+        struct tvin_info_s          info;
+        struct tvin_cutwin_s        cutwin;
+        unsigned short              histgram[64];
+        unsigned int                flag;
+        unsigned int                reserved;
+} tvin_parm_t;
+
+
+
+// ***************************************************************************
+// *** AFE module definition/enum/struct *************************************
+// ***************************************************************************
+
+typedef enum tvafe_cmd_status_e {
+        TVAFE_CMD_STATUS_IDLE = 0,   // idle, be ready for TVIN_IOC_S_AFE_VGA_AUTO command
+        TVAFE_CMD_STATUS_PROCESSING, // TVIN_IOC_S_AFE_VGA_AUTO command is in process
+        TVAFE_CMD_STATUS_SUCCESSFUL, // TVIN_IOC_S_AFE_VGA_AUTO command is done with success
+        TVAFE_CMD_STATUS_FAILED,     // TVIN_IOC_S_AFE_VGA_AUTO command is done with failure
+        TVAFE_CMD_STATUS_TERMINATED, // TVIN_IOC_S_AFE_VGA_AUTO command is terminated by others related
+} tvafe_cmd_status_t;
+
+typedef struct tvafe_vga_edid_s {
+        unsigned char value[256]; //256 byte EDID
+} tvafe_vga_edid_t;
+
+typedef struct tvafe_comp_wss_s {
+        unsigned int wss1[5];
+        unsigned int wss2[5];
+} tvafe_comp_wss_t;
+
+typedef struct tvafe_vga_parm_s {
+        signed short clk_step;  // clock < 0, tune down clock freq
+        // clock > 0, tune up clock freq
+        unsigned short phase;     // phase is 0~31, it is absolute value
+        signed short hpos_step; // hpos_step < 0, shift display to left
+        // hpos_step > 0, shift display to right
+        signed short vpos_step; // vpos_step < 0, shift display to top
+        // vpos_step > 0, shift display to bottom
+        unsigned int   vga_in_clean;  // flage for vga clean screen
+} tvafe_vga_parm_t;
+
+#define TVAFE_ADC_CAL_VALID 0x00000001
+typedef struct tvafe_adc_cal_s {
+        // ADC A
+        unsigned short a_analog_clamp;    // 0x00~0x7f
+        unsigned short a_analog_gain;     // 0x00~0xff, means 0dB~6dB
+        unsigned short a_digital_offset1; // offset for fine-tuning
+        // s11.0:   signed value, 11 integer bits,  0 fraction bits
+        unsigned short a_digital_gain;    // 0~3.999
+        // u2.10: unsigned value,  2 integer bits, 10 fraction bits
+        unsigned short a_digital_offset2; // offset for format
+        // s11.0:   signed value, 11 integer bits,  0 fraction bits
+        // ADC B
+        unsigned short b_analog_clamp;    // ditto to ADC A
+        unsigned short b_analog_gain;
+        unsigned short b_digital_offset1;
+        unsigned short b_digital_gain;
+        unsigned short b_digital_offset2;
+        // ADC C
+        unsigned short c_analog_clamp;    // ditto to ADC A
+        unsigned short c_analog_gain;
+        unsigned short c_digital_offset1;
+        unsigned short c_digital_gain;
+        unsigned short c_digital_offset2;
+        // ADC D
+        unsigned short d_analog_clamp;    // ditto to ADC A
+        unsigned short d_analog_gain;
+        unsigned short d_digital_offset1;
+        unsigned short d_digital_gain;
+        unsigned short d_digital_offset2;
+        unsigned int   reserved;          // bit[ 0]: TVAFE_ADC_CAL_VALID
+} tvafe_adc_cal_t;
+
+typedef struct tvafe_adc_comp_cal_s {
+    struct tvafe_adc_cal_s comp_cal_val[3];
+} tvafe_adc_comp_cal_t;
+
+typedef enum tvafe_cvbs_video_e {
+        TVAFE_CVBS_VIDEO_HV_UNLOCKED = 0,
+        TVAFE_CVBS_VIDEO_H_LOCKED,
+        TVAFE_CVBS_VIDEO_V_LOCKED,
+        TVAFE_CVBS_VIDEO_HV_LOCKED,
+} tvafe_cvbs_video_t;
+
+// for pin selection
+typedef enum tvafe_adc_pin_e {
+        TVAFE_ADC_PIN_NULL = 0,
+        TVAFE_ADC_PIN_A_PGA_0,
+        TVAFE_ADC_PIN_A_PGA_1,
+        TVAFE_ADC_PIN_A_PGA_2,
+        TVAFE_ADC_PIN_A_PGA_3,
+        TVAFE_ADC_PIN_A_PGA_4,
+        TVAFE_ADC_PIN_A_PGA_5,
+        TVAFE_ADC_PIN_A_PGA_6,
+        TVAFE_ADC_PIN_A_PGA_7,
+        TVAFE_ADC_PIN_A_0,
+        TVAFE_ADC_PIN_A_1,
+        TVAFE_ADC_PIN_A_2,
+        TVAFE_ADC_PIN_A_3,
+        TVAFE_ADC_PIN_A_4,
+        TVAFE_ADC_PIN_A_5,
+        TVAFE_ADC_PIN_A_6,
+        TVAFE_ADC_PIN_A_7,
+        TVAFE_ADC_PIN_B_0,
+        TVAFE_ADC_PIN_B_1,
+        TVAFE_ADC_PIN_B_2,
+        TVAFE_ADC_PIN_B_3,
+        TVAFE_ADC_PIN_B_4,
+        TVAFE_ADC_PIN_B_5,
+        TVAFE_ADC_PIN_B_6,
+        TVAFE_ADC_PIN_B_7,
+        TVAFE_ADC_PIN_C_0,
+        TVAFE_ADC_PIN_C_1,
+        TVAFE_ADC_PIN_C_2,
+        TVAFE_ADC_PIN_C_3,
+        TVAFE_ADC_PIN_C_4,
+        TVAFE_ADC_PIN_C_5,
+        TVAFE_ADC_PIN_C_6,
+        TVAFE_ADC_PIN_C_7,
+        TVAFE_ADC_PIN_D_0,
+        TVAFE_ADC_PIN_D_1,
+        TVAFE_ADC_PIN_D_2,
+        TVAFE_ADC_PIN_D_3,
+        TVAFE_ADC_PIN_D_4,
+        TVAFE_ADC_PIN_D_5,
+        TVAFE_ADC_PIN_D_6,
+        TVAFE_ADC_PIN_D_7,
+        TVAFE_ADC_PIN_SOG_0,
+        TVAFE_ADC_PIN_SOG_1,
+        TVAFE_ADC_PIN_SOG_2,
+        TVAFE_ADC_PIN_SOG_3,
+        TVAFE_ADC_PIN_SOG_4,
+        TVAFE_ADC_PIN_SOG_5,
+        TVAFE_ADC_PIN_SOG_6,
+        TVAFE_ADC_PIN_SOG_7,
+        TVAFE_ADC_PIN_MAX,
+} tvafe_adc_pin_t;
+
+typedef enum tvafe_src_sig_e {
+        CVBS0_Y = 0,
+        CVBS0_SOG,
+        CVBS1_Y,
+        CVBS1_SOG,
+        CVBS2_Y,
+        CVBS2_SOG,
+        CVBS3_Y,
+        CVBS3_SOG,
+        CVBS4_Y,
+        CVBS4_SOG,
+        CVBS5_Y,
+        CVBS5_SOG,
+        CVBS6_Y,
+        CVBS6_SOG,
+        CVBS7_Y,
+        CVBS7_SOG,
+        S_VIDEO0_Y,
+        S_VIDEO0_C,
+        S_VIDEO0_SOG,
+        S_VIDEO1_Y,
+        S_VIDEO1_C,
+        S_VIDEO1_SOG,
+        S_VIDEO2_Y,
+        S_VIDEO2_C,
+        S_VIDEO2_SOG,
+        S_VIDEO3_Y,
+        S_VIDEO3_C,
+        S_VIDEO3_SOG,
+        S_VIDEO4_Y,
+        S_VIDEO4_C,
+        S_VIDEO4_SOG,
+        S_VIDEO5_Y,
+        S_VIDEO5_C,
+        S_VIDEO5_SOG,
+        S_VIDEO6_Y,
+        S_VIDEO6_C,
+        S_VIDEO6_SOG,
+        S_VIDEO7_Y,
+        S_VIDEO7_C,
+        S_VIDEO7_SOG,
+        VGA0_G,
+        VGA0_B,
+        VGA0_R,
+        VGA0_SOG,
+        VGA1_G,
+        VGA1_B,
+        VGA1_R,
+        VGA1_SOG,
+        VGA2_G,
+        VGA2_B,
+        VGA2_R,
+        VGA2_SOG,
+        VGA3_G,
+        VGA3_B,
+        VGA3_R,
+        VGA3_SOG,
+        VGA4_G,
+        VGA4_B,
+        VGA4_R,
+        VGA4_SOG,
+        VGA5_G,
+        VGA5_B,
+        VGA5_R,
+        VGA5_SOG,
+        VGA6_G,
+        VGA6_B,
+        VGA6_R,
+        VGA6_SOG,
+        VGA7_G,
+        VGA7_B,
+        VGA7_R,
+        VGA7_SOG,
+        COMP0_Y,
+        COMP0_PB,
+        COMP0_PR,
+        COMP0_SOG,
+        COMP1_Y,
+        COMP1_PB,
+        COMP1_PR,
+        COMP1_SOG,
+        COMP2_Y,
+        COMP2_PB,
+        COMP2_PR,
+        COMP2_SOG,
+        COMP3_Y,
+        COMP3_PB,
+        COMP3_PR,
+        COMP3_SOG,
+        COMP4_Y,
+        COMP4_PB,
+        COMP4_PR,
+        COMP4_SOG,
+        COMP5_Y,
+        COMP5_PB,
+        COMP5_PR,
+        COMP5_SOG,
+        COMP6_Y,
+        COMP6_PB,
+        COMP6_PR,
+        COMP6_SOG,
+        COMP7_Y,
+        COMP7_PB,
+        COMP7_PR,
+        COMP7_SOG,
+        SCART0_G,
+        SCART0_B,
+        SCART0_R,
+        SCART0_CVBS,
+        SCART1_G,
+        SCART1_B,
+        SCART1_R,
+        SCART1_CVBS,
+        SCART2_G,
+        SCART2_B,
+        SCART2_R,
+        SCART2_CVBS,
+        SCART3_G,
+        SCART3_B,
+        SCART3_R,
+        SCART3_CVBS,
+        SCART4_G,
+        SCART4_B,
+        SCART4_R,
+        SCART4_CVBS,
+        SCART5_G,
+        SCART5_B,
+        SCART5_R,
+        SCART5_CVBS,
+        SCART6_G,
+        SCART6_B,
+        SCART6_R,
+        SCART6_CVBS,
+        SCART7_G,
+        SCART7_B,
+        SCART7_R,
+        SCART7_CVBS,
+        TVAFE_SRC_SIG_MAX_NUM,
+} tvafe_src_sig_t;
+
+typedef struct tvafe_pin_mux_s {
+        enum tvafe_adc_pin_e pin[TVAFE_SRC_SIG_MAX_NUM];
+} tvafe_pin_mux_t;
+
+// ***************************************************************************
+// *** IOCTL command definition **********************************************
+// ***************************************************************************
+
+#define TVIN_IOC_MAGIC 'T'
+
+//GENERAL
+#define TVIN_IOC_OPEN               _IOW(TVIN_IOC_MAGIC, 0x01, struct tvin_parm_s)
+#define TVIN_IOC_START_DEC          _IOW(TVIN_IOC_MAGIC, 0x02, struct tvin_parm_s)
+#define TVIN_IOC_STOP_DEC           _IO( TVIN_IOC_MAGIC, 0x03)
+#define TVIN_IOC_CLOSE              _IO( TVIN_IOC_MAGIC, 0x04)
+#define TVIN_IOC_G_PARM             _IOR(TVIN_IOC_MAGIC, 0x05, struct tvin_parm_s)
+#define TVIN_IOC_S_PARM             _IOW(TVIN_IOC_MAGIC, 0x06, struct tvin_parm_s)
+#define TVIN_IOC_G_SIG_INFO         _IOR(TVIN_IOC_MAGIC, 0x07, struct tvin_info_s)
+#define TVIN_IOC_G_BUF_INFO         _IOR(TVIN_IOC_MAGIC, 0x08, struct tvin_buf_info_s)
+#define TVIN_IOC_START_GET_BUF      _IO( TVIN_IOC_MAGIC, 0x09)
+#define TVIN_IOC_GET_BUF            _IOR(TVIN_IOC_MAGIC, 0x10, struct tvin_video_buf_s)
+#define TVIN_IOC_PAUSE_DEC          _IO(TVIN_IOC_MAGIC, 0x41)
+#define TVIN_IOC_RESUME_DEC         _IO(TVIN_IOC_MAGIC, 0x42)
+#define TVIN_IOC_VF_REG             _IO(TVIN_IOC_MAGIC, 0x43)
+#define TVIN_IOC_VF_UNREG           _IO(TVIN_IOC_MAGIC, 0x44)
+#define TVIN_IOC_FREEZE_VF          _IO(TVIN_IOC_MAGIC, 0x45)
+#define TVIN_IOC_UNFREEZE_VF        _IO(TVIN_IOC_MAGIC, 0x46)
+
+
+//TVAFE
+#define TVIN_IOC_S_AFE_ADC_CAL      _IOW(TVIN_IOC_MAGIC, 0x11, struct tvafe_adc_cal_s)
+#define TVIN_IOC_G_AFE_ADC_CAL      _IOR(TVIN_IOC_MAGIC, 0x12, struct tvafe_adc_cal_s)
+#define TVIN_IOC_G_AFE_COMP_WSS     _IOR(TVIN_IOC_MAGIC, 0x13, struct tvafe_comp_wss_s)
+#define TVIN_IOC_S_AFE_VGA_EDID     _IOW(TVIN_IOC_MAGIC, 0x14, struct tvafe_vga_edid_s)
+#define TVIN_IOC_G_AFE_VGA_EDID     _IOR(TVIN_IOC_MAGIC, 0x15, struct tvafe_vga_edid_s)
+#define TVIN_IOC_S_AFE_VGA_PARM     _IOW(TVIN_IOC_MAGIC, 0x16, struct tvafe_vga_parm_s)
+#define TVIN_IOC_G_AFE_VGA_PARM     _IOR(TVIN_IOC_MAGIC, 0x17, struct tvafe_vga_parm_s)
+#define TVIN_IOC_S_AFE_VGA_AUTO     _IO( TVIN_IOC_MAGIC, 0x18)
+#define TVIN_IOC_G_AFE_CMD_STATUS   _IOR(TVIN_IOC_MAGIC, 0x19, enum tvafe_cmd_status_e)
+#define TVIN_IOC_G_AFE_CVBS_LOCK    _IOR(TVIN_IOC_MAGIC, 0x1a, enum tvafe_cvbs_video_e)
+#define TVIN_IOC_S_AFE_CVBS_STD     _IOW(TVIN_IOC_MAGIC, 0x1b, enum tvin_sig_fmt_e)
+#define TVIN_IOC_CALLMASTER_SET     _IOW(TVIN_IOC_MAGIC, 0x1c, enum tvin_port_e)
+#define TVIN_IOC_CALLMASTER_GET	    _IO( TVIN_IOC_MAGIC, 0x1d)
+#define TVIN_IOC_S_AFE_ADC_COMP_CAL  _IOW(TVIN_IOC_MAGIC, 0x1e, struct tvafe_adc_comp_cal_s)
+#define TVIN_IOC_G_AFE_ADC_COMP_CAL  _IOR(TVIN_IOC_MAGIC, 0x1f, struct tvafe_adc_comp_cal_s)
+#endif
diff --git a/include/linux/amlogic/vout/enc_clk_config.h b/include/linux/amlogic/vout/enc_clk_config.h
new file mode 100755
index 000000000000..4f21a79994a7
--- /dev/null
+++ b/include/linux/amlogic/vout/enc_clk_config.h
@@ -0,0 +1,35 @@
+#ifndef __ENC_CLK_CONFIG_H__
+#define __ENC_CLK_CONFIG_H__
+
+typedef enum viu_type {
+    VIU_ENCL = 0,
+    VIU_ENCI,
+    VIU_ENCP,
+    VIU_ENCT,
+} viu_type_e;
+
+extern int set_viu_path(unsigned viu_channel_sel, viu_type_e viu_type_sel);
+extern void set_enci_clk(unsigned clk);
+extern void set_encp_clk(unsigned clk);
+extern void set_vmode_clk(vmode_t mode);
+
+
+typedef struct enc_clk_val{
+    vmode_t mode;
+    unsigned hpll_clk_out;
+    unsigned hpll_hdmi_od;
+    unsigned viu_path;
+    viu_type_e viu_type;
+    unsigned vid_pll_div;
+    unsigned clk_final_div;
+    unsigned hdmi_tx_pixel_div;
+    unsigned encp_div;
+    unsigned enci_div;
+    unsigned enct_div;
+    unsigned encl_div;
+    unsigned vdac0_div;
+    unsigned vdac1_div;
+}enc_clk_val_t;
+
+
+#endif
diff --git a/include/linux/amlogic/vout/vdac_switch.h b/include/linux/amlogic/vout/vdac_switch.h
new file mode 100755
index 000000000000..38fa70c4a6ad
--- /dev/null
+++ b/include/linux/amlogic/vout/vdac_switch.h
@@ -0,0 +1,39 @@
+/*
+ * VDAC SWITCH definitions
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __AML_VDAC_SWITCH_H__
+#define __AML_VDAC_SWITCH_H__
+
+#include <linux/types.h>
+
+enum aml_vdac_switch_type {
+	VOUT_CVBS,
+	VOUT_COMPONENT,
+	VOUT_VGA,
+	VOUT_MAX
+};
+
+#ifdef CONFIG_USE_OF
+struct aml_vdac_hw_ctrl {
+    unsigned int pin1;
+    unsigned int val1;
+    unsigned int pin2;
+    unsigned int val2;
+};
+
+struct aml_vdac_hw_switch {
+    struct aml_vdac_hw_ctrl cvbs;
+    struct aml_vdac_hw_ctrl ypbr;
+    struct aml_vdac_hw_ctrl vga;
+};
+#endif
+
+struct aml_vdac_switch_platform_data {
+	void (*vdac_switch_change_type_func)(unsigned type);
+};
+
+#endif
diff --git a/include/linux/vout/vinfo.h b/include/linux/amlogic/vout/vinfo.h
similarity index 100%
rename from include/linux/vout/vinfo.h
rename to include/linux/amlogic/vout/vinfo.h
diff --git a/include/linux/amlogic/vout/vout_notify.h b/include/linux/amlogic/vout/vout_notify.h
new file mode 100755
index 000000000000..9cd2084bbc5f
--- /dev/null
+++ b/include/linux/amlogic/vout/vout_notify.h
@@ -0,0 +1,95 @@
+/*
+ * Amlogic Apollo
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	jianfeng_wang
+ *
+ */
+#ifndef  VOUT_NOTIFY_H
+#define  VOUT_NOTIFY_H
+
+#include <linux/notifier.h>
+#include <linux/list.h>
+#include <linux/pm.h>
+#include "vinfo.h"
+
+typedef struct 
+{
+	const vinfo_t* (*get_vinfo)(void);
+	int		 (*set_vmode)(vmode_t);
+	vmode_t  (*validate_vmode)(char *);
+	int		(*vmode_is_supported)(vmode_t);
+	int		(*disable)(vmode_t );
+	int		(*vout_suspend)(void);
+	int		(*vout_resume)(void);
+}vout_op_t ;
+
+
+typedef  struct list_head  list_head_T;
+
+
+typedef struct 
+{
+	list_head_T  list;
+	char  	  *name;
+	vout_op_t  op;
+} vout_server_t;
+
+typedef struct {
+	list_head_T   vout_server_list;
+	vout_server_t *curr_vout_server;
+}vout_module_t;
+
+extern int vout_register_client(struct notifier_block * ) ;
+extern int vout_unregister_client(struct notifier_block *) ;
+extern int vout_register_server(vout_server_t *);
+extern int vout_unregister_server(vout_server_t*  );
+extern int vout_notifier_call_chain(unsigned long, void *) ;
+
+extern const vinfo_t *get_current_vinfo(void);
+extern vmode_t get_current_vmode(void);
+extern int set_current_vmode(vmode_t);
+extern vmode_t validate_vmode(char *);
+
+extern int vout_suspend(void); 
+extern int vout_resume(void);
+
+#define VOUT_EVENT_MODE_CHANGE		0x00010000	
+#define VOUT_EVENT_OSD_BLANK			0x00020000
+#define VOUT_EVENT_OSD_DISP_AXIS			0x00030000
+#define  VOUT_EVENT_OSD_PREBLEND_ENABLE		0x00040000
+
+/* vout2 */
+extern int vout2_register_client(struct notifier_block * ) ;
+extern int vout2_unregister_client(struct notifier_block *) ;
+extern int vout2_register_server(vout_server_t *);
+extern int vout2_unregister_server(vout_server_t*  );
+extern int vout2_notifier_call_chain(unsigned long, void *) ;
+
+extern const vinfo_t *get_current_vinfo2(void);
+extern vmode_t get_current_vmode2(void);
+extern int set_current_vmode2(vmode_t);
+extern vmode_t validate_vmode2(char *);
+extern void  set_vout2_mode_internal(char * name);
+
+extern int vout2_suspend(void); 
+extern int vout2_resume(void);
+/**/
+
+#endif /* VOUT_NOTIFY_H */
diff --git a/include/linux/i2c-aml.h b/include/linux/i2c-aml.h
new file mode 100755
index 000000000000..221c7f09dff6
--- /dev/null
+++ b/include/linux/i2c-aml.h
@@ -0,0 +1,145 @@
+/*
+* linux/arch/arm/mach-meson/include/mach/i2c.h
+*/
+#ifndef AML_MACH_I2C
+#define AML_MACH_I2C
+#include <mach/pinmux.h>
+#include <mach/am_regs.h>
+//#include <mach/regs.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON3
+//#include <mach/ao_regs.h>
+#endif
+#define MESON_I2C_MASTER_A_START		CBUS_REG_ADDR(I2C_M_0_CONTROL_REG)
+#define MESON_I2C_MASTER_A_END		(CBUS_REG_ADDR(I2C_M_0_RDATA_REG1+1)-1)
+
+#define MESON_I2C_MASTER_B_START		CBUS_REG_ADDR(I2C_M_1_CONTROL_REG)
+#define MESON_I2C_MASTER_B_END		(CBUS_REG_ADDR(I2C_M_1_RDATA_REG1+1)-1)
+
+#define MESON_I2C_SLAVE_START			CBUS_REG_ADDR(I2C_S_CONTROL_REG)
+#define MESON_I2C_SLAVE_END			(CBUS_REG_ADDR(I2C_S_CNTL1_REG+1)-1)
+
+#define MESON_I2C_MASTER_AO_START			AOBUS_REG_ADDR(AO_I2C_M_0_CONTROL_REG)
+#define MESON_I2C_MASTER_AO_END			(AOBUS_REG_ADDR(AO_I2C_M_0_RDATA_REG1+1)-1)
+
+#define AML_I2C_MASTER_AO			0
+#define AML_I2C_MASTER_A			1
+#define AML_I2C_MASTER_B 			2
+#define AML_I2C_MASTER_C 			3
+#define AML_I2C_MASTER_D 			4
+
+#define AML_I2C_SLAVE_ADDR			0x6c
+#if 0
+/*M1 i2c pinmux
+ *       I/O			I2C_MASTER_A		I2C_MASTER_B		I2C_SLAVE
+ * GPIO_JTAG_TMS	SCK_A REG1[12]							SCK_A REG1[13]
+ * GPIO_JTAG_TDI		SDA_A REG1[12]							SDA_A REG1[13]
+ * GPIO_JTAG_TCK						SCK_B REG1[16]		SCK_A REG1[17]
+ * GPIO_JTAG_TDO						SDA_B REG1[20]		SDA_A REG1[21]
+ * GPIOB_0								SCK_B REG2[5]		SCK_A REG2[6]
+ * GPIOB_1								SDA_B REG2[2]		SDA_A REG2[3]
+ * GPIOB_2			SCK_A REGS[13]							SCK_A REG2[14]
+ * GPIOB_3			SDA_A REG2[9]							SDA_A REG2[10]
+ * GPIOC_13								SCK_B REG3[28]		SCK_A REG3[29]
+ * GPIOC_14								SDA_B REG3[25]		SDA_A REG3[26]
+ * GPIOC_21			SCK_A REG7[9]							SCK_A REG7[10]
+ * GPIOC_22			SDA_A REG7[6]							SDA_A REG7[7]
+ * GPIOE_16								SCK_B REG5[27]		SCK_A REG5[28]
+ * GPIOE_17								SDA_B REG5[25]		SDA_A REG5[26]
+*/
+
+/*i2c master a*/
+
+#define MESON_I2C_MASTER_GPIOX_26_REG		CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_MASTER_GPIOX_26_BIT		(1<<26)
+#define MESON_I2C_MASTER_GPIOX_25_REG		CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_MASTER_GPIOX_25_BIT		(1<<27)
+
+#define MESON_I2C_MASTER_GPIOX_28_REG  		CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_MASTER_GPIOX_28_BIT  		(1<<30)
+#define MESON_I2C_MASTER_GPIOX_27_REG  		CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define MESON_I2C_MASTER_GPIOX_27_BIT  		(1<<31)
+
+#define MESON_I2C_MASTER_GPIOAO_4_REG		AOBUS_REG_ADDR(AO_RTI_PIN_MUX_REG)
+#define MESON_I2C_MASTER_GPIOAO_4_BIT		(1<<6)
+#define MESON_I2C_MASTER_GPIOAO_5_REG		AOBUS_REG_ADDR(AO_RTI_PIN_MUX_REG)
+#define MESON_I2C_MASTER_GPIOAO_5_BIT		(1<<5)
+
+#endif
+
+#define AML_I2C_SPPED_50K			50000
+#define AML_I2C_SPPED_100K			100000
+#define AML_I2C_SPPED_200K			200000
+#define AML_I2C_SPPED_300K			300000
+#define AML_I2C_SPPED_400K			400000
+#if 0
+struct aml_pinmux_reg_bit {
+	unsigned int	scl_reg;
+	unsigned int  			scl_bit;
+	unsigned int	sda_reg;
+	unsigned int  			sda_bit;
+};
+#endif
+
+struct aml_i2c_platform{
+	unsigned int		slave_addr;/*7bit addr*/
+	unsigned int 		wait_count;/*i2c wait ack timeout =
+											wait_count * wait_ack_interval */
+	unsigned int 		wait_ack_interval;
+	unsigned int 		wait_read_interval;
+	unsigned int 		wait_xfer_interval;
+	unsigned int 		master_no;
+	unsigned int		master_i2c_speed;
+	unsigned int		master_i2c_speed2;/*the same adapter, different speed*/
+    /*reserved*/
+	unsigned int		use_pio;/*0: hardware i2c, 1: manual pio i2c*/
+#if 0
+    struct aml_pinmux_reg_bit master_a_pinmux;
+	struct aml_pinmux_reg_bit master_b_pinmux;
+    struct aml_pinmux_reg_bit master_pinmux;
+#endif
+	pinmux_set_t  master_pinmux;
+	pinmux_set_t  master_a_pinmux;
+	pinmux_set_t  master_b_pinmux;
+	char *master_state_name;
+};
+
+/**************i2c software gpio***************/
+
+#define MESON_I2C_PREG_GPIOC_OE			CBUS_REG_ADDR(PREG_FGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOC_OUTLVL		CBUS_REG_ADDR(PREG_FGPIO_O)
+#define MESON_I2C_PREG_GPIOC_INLVL		CBUS_REG_ADDR(PREG_FGPIO_I)
+
+#define MESON_I2C_PREG_GPIOE_OE			CBUS_REG_ADDR(PREG_HGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOE_OUTLVL		CBUS_REG_ADDR(PREG_HGPIO_O)
+#define MESON_I2C_PREG_GPIOE_INLVL		CBUS_REG_ADDR(PREG_HGPIO_I)
+
+#define MESON_I2C_PREG_GPIOA_OE			CBUS_REG_ADDR(PREG_EGPIO_EN_N)
+#define MESON_I2C_PREG_GPIOA_OUTLVL		CBUS_REG_ADDR(PREG_EGPIO_O)
+#define MESON_I2C_PREG_GPIOA_INLVL		CBUS_REG_ADDR(PREG_EGPIO_I)
+
+struct aml_sw_i2c_pins
+{
+	unsigned int scl_reg_out;
+	unsigned int scl_reg_in;
+	unsigned int scl_bit;
+	unsigned int scl_oe;
+	unsigned int sda_reg_out;
+	unsigned int sda_reg_in;
+	unsigned int sda_bit;
+	unsigned int sda_oe;
+};
+
+
+struct aml_sw_i2c_platform {
+	struct aml_sw_i2c_pins sw_pins;
+
+	/* local settings */
+	int udelay;		/* half clock cycle time in us,
+				   minimum 2 us for fast-mode I2C,
+				   minimum 5 us for standard-mode I2C and SMBus,
+				   maximum 50 us for SMBus */
+	int timeout;		/* in jiffies */
+};
+
+#endif
+
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
old mode 100644
new mode 100755
index 9e675c76436c..1d43e7af63b3
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -55,6 +55,9 @@ source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
 
+# for Amlogic SoC
+source "sound/soc/aml/Kconfig"
+
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
 
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
old mode 100644
new mode 100755
index 197b6ae54c8d..2d6b5aa1abd0
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -32,3 +32,4 @@ obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
+obj-$(CONFIG_SND_SOC)	+= aml/
\ No newline at end of file
diff --git a/sound/soc/aml/Kconfig b/sound/soc/aml/Kconfig
new file mode 100755
index 000000000000..4d2658a6de1a
--- /dev/null
+++ b/sound/soc/aml/Kconfig
@@ -0,0 +1,120 @@
+config SND_AML_SOC
+	tristate "Audio for Amlogic Meson SoC"
+	depends on PLAT_MESON
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the Amlogic I2S interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_AML_M1
+	tristate "M1 evaluation board with internel audio dac"
+	depends on SND_AML_SOC
+	depends on ARCH_MESON1
+
+config SND_AML_M1_MID_WM8900
+	tristate "AML6236 MID board with WM8900"
+	depends on SND_AML_SOC
+        select SND_SOC_WM8900 if SND_AML_M1_MID_WM8900
+
+config SND_AML_M1_ARMDEV_WM8900
+	tristate "AML8726M ARM Dev board with WM8900"
+	depends on SND_AML_SOC
+	select SND_SOC_WM8900 if SND_AML_M1_ARMDEV_WM8900
+
+config SND_AML_M1_MID_RT5621
+	tristate "AML8726M MID board with RT5621"
+	depends on SND_AML_SOC
+	select SND_SOC_RT5621 if SND_AML_M1_MID_RT5621
+
+config SND_AML_M2
+	tristate "M2 evaluation board with internal audio codec"
+	depends on SND_AML_SOC
+	depends on ARCH_MESON2
+
+config SND_AML_M3
+	tristate "M3 evaluation board with internal audio codec"
+	depends on SND_AML_SOC
+	depends on ARCH_MESON3
+
+config SND_AML_M6_RT5631
+	tristate "M6 evaluation board with RT5631"
+	depends on SND_AML_SOC
+	select SND_SOC_RT5631 if SND_AML_M6_RT5631
+
+config SND_AML_M6_RT5616
+	tristate "M6 evaluation board with RT5616"
+	depends on SND_AML_SOC
+	select SND_SOC_RT5616 if SND_AML_M6_RT5616
+
+config SND_AML_M6_RT3261
+	tristate "M6 evaluation board with RT3261"
+	depends on SND_AML_SOC
+	select SND_SOC_RT3261 if SND_AML_M6_RT3261
+	select SND_HWDEP
+config SND_AML_M6_WM8960
+	tristate "M6 evaluation board with WM8960"
+	depends on SND_AML_SOC
+	select SND_SOC_WM8960 if SND_AML_M6_WM8960
+config SND_AML_M6_PCM2BT
+	tristate "M6 evaluation board with PCM2BT"
+	depends on SND_AML_SOC
+	select SND_SOC_PCM2BT
+	
+config SND_AML_M_DUMMY_CODEC
+    tristate "AML M series board with DUMMY_CODEC"
+    depends on SND_AML_SOC
+    select SND_SOC_DUMMY_CODEC if SND_AML_M_DUMMY_CODEC
+config SND_AML_M6TV_AUDIO_CODEC
+	tristate "AML M6TV evaluation board,this must be selected for all m6tv board"
+	depends on SND_AML_SOC
+config SND_AML_M6TV_SYNOPSYS9629_CODEC
+	tristate "AML M6TV  board with internal syno9629 codec"
+	depends on SND_AML_M6TV_AUDIO_CODEC 
+config SND_AML_M6TV_RT5631
+	tristate "AML M6TV board with RT5631 codec"
+	depends on SND_AML_M6TV_AUDIO_CODEC
+	select SND_SOC_RT5631 if SND_AML_M6TV_RT5631	
+config SND_AML_M6TV_STA380
+	tristate "AML M6TV board with STA380 codec"
+	depends on SND_AML_M6TV_AUDIO_CODEC
+	select SND_SOC_STA380 if SND_AML_M6TV_STA380	
+config SND_AML_M6TV_TAS5711
+	tristate "AML M6TV board with TAS5711 codec"	
+	depends on SND_AML_M6TV_AUDIO_CODEC	
+	select SND_SOC_TAS5711 if SND_AML_M6TV_TAS5711
+if SND_AML_M6TV_TAS5711
+choice        
+	prompt "TAS5711 work mode"        
+	default TAS5711_2_CHANNEL
+config TAS5711_2_CHANNEL        
+	bool "2 BTL channel mode"
+config TAS5711_2_PLUS_1_CHANNEL
+	bool "2.1 channel mode"
+config TAS5711_2_SUBWOOFER_CHANNEL        
+	bool "2 BTL subwoofer channel"
+endchoice
+endif
+config SND_AML_M6TV_TAS5707
+	tristate "AML M6TV board with TAS5707 codec"	
+	depends on SND_AML_M6TV_AUDIO_CODEC	
+	select SND_SOC_TAS5707 if SND_AML_M6TV_TAS5707
+if SND_AML_M6TV_TAS5707
+choice        
+	prompt "TAS5707 work mode"        
+	default TAS5707_2_CHANNEL
+config TAS5707_2_CHANNEL        
+	bool "2 BTL channel mode"
+config TAS5707_2_SUBWOOFER_CHANNEL        
+	bool "2 BTL subwoofer channel"
+endchoice
+endif
+
+config SND_AML_M8
+	tristate "AML-SND-M8 Board"
+	depends on SND_AML_SOC && SWITCH
+	select SND_SOC_AML_M8_CODEC if SND_AML_M8
+	
+config SND_AML_M8_PCM
+	tristate "M8 evaluation board with PCM2BT"
+	depends on SND_AML_SOC
+	select SND_SOC_PCM2BT
diff --git a/sound/soc/aml/Makefile b/sound/soc/aml/Makefile
new file mode 100755
index 000000000000..2aeeb5a62d52
--- /dev/null
+++ b/sound/soc/aml/Makefile
@@ -0,0 +1,81 @@
+# AML Platform Support
+snd-soc-aml-pcm-objs := aml_pcm.o
+snd-soc-aml-platform-pcm2bt-objs := aml_platform_pcm2bt.o
+snd-soc-aml-dai-objs := aml_dai.o
+snd-soc-aml-hw-objs  := aml_audio_hw.o
+snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
+snd-soc-aml-platform-objs := aml_platform.o
+
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-pcm.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-dai.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw.o
+obj-$(CONFIG_SND_AML_SOC) += aml_notify.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform-pcm2bt.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw-pcm2bt.o
+
+#AML M1 Machine support
+
+snd-soc-aml-m1-objs := aml_m1.o
+snd-soc-aml-codec-objs := aml_m1_codec.o
+
+obj-$(CONFIG_SND_AML_M1) += snd-soc-aml-m1.o
+obj-$(CONFIG_SND_AML_M1) += snd-soc-aml-codec.o
+
+#AML M1 MID with WM8900 support
+
+snd-soc-aml-m1-mid-wm8900-objs := aml_m1_mid_wm8900.o
+obj-$(CONFIG_SND_AML_M1_MID_WM8900) += snd-soc-aml-m1-mid-wm8900.o
+
+#AML M1 ARM DEV Board with wm8900 support
+
+snd-soc-aml-m1-armdev-wm8900-objs := aml_m1_armdev_wm8900.o
+obj-$(CONFIG_SND_AML_M1_ARMDEV_WM8900) += snd-soc-aml-m1-armdev-wm8900.o
+
+#AML M1 MID with RT5621 support
+snd-soc-aml-m1-mid-rt5621-objs := aml_m1_mid_rt5621.o
+obj-$(CONFIG_SND_AML_M1_MID_RT5621) += snd-soc-aml-m1-mid-rt5621.o
+
+
+# AML M2 Machine support
+
+snd-soc-aml-m2-objs := aml_m2.o
+snd-soc-aml-codec-objs := aml_m2_codec.o
+obj-$(CONFIG_SND_AML_M2) += snd-soc-aml-m2.o
+obj-$(CONFIG_SND_AML_M2) += snd-soc-aml-codec.o
+
+# AML M3 Machine support
+
+snd-soc-aml-m3-objs := aml_m3.o
+snd-soc-aml-codec-objs := aml_m3_codec.o
+obj-$(CONFIG_SND_AML_M3) += snd-soc-aml-m3.o
+obj-$(CONFIG_SND_AML_M3) += snd-soc-aml-codec.o
+
+#AML M6 Machine support
+snd-soc-aml-m6-rt5631-objs := aml_m6_rt5631.o
+obj-$(CONFIG_SND_AML_M6_RT5631) += snd-soc-aml-m6-rt5631.o
+
+#AML M6 Machine support
+snd-soc-aml-m6-rt5616-objs := aml_m6_rt5616.o
+obj-$(CONFIG_SND_AML_M6_RT5616) += snd-soc-aml-m6-rt5616.o
+
+#AML M6 Machine support
+snd-soc-aml-m6-rt3261-objs := aml_m6_rt3261.o
+obj-$(CONFIG_SND_AML_M6_RT3261) += snd-soc-aml-m6-rt3261.o
+snd-soc-aml-m6-wm8960-objs := aml_m6_wm8960.o
+obj-$(CONFIG_SND_AML_M6_WM8960) += snd-soc-aml-m6-wm8960.o
+
+#AML M series with dummy codec support
+snd-soc-aml-m-dummy-objs := aml_m_dummy.o
+obj-$(CONFIG_SND_AML_M_DUMMY_CODEC) += snd-soc-aml-m-dummy.o
+
+# AML M6TV Machine support
+snd-soc-aml-m6tv-audio-objs := aml_m6tv_audio.o
+snd-soc-aml-syno9629-codec-objs := aml_syno9629_codec.o
+obj-$(CONFIG_SND_AML_M6TV_AUDIO_CODEC) += snd-soc-aml-m6tv-audio.o
+obj-$(CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC) += snd-soc-aml-syno9629-codec.o
+
+#AML M8 Machine support
+snd-soc-aml-m8-objs := aml_m8.o
+obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
+
diff --git a/sound/soc/aml/aml.dtd b/sound/soc/aml/aml.dtd
new file mode 100755
index 000000000000..7e3011a4642c
--- /dev/null
+++ b/sound/soc/aml/aml.dtd
@@ -0,0 +1,59 @@
+#ifdef CONFIG_SND_AML_SOC
+//$$ DEVICE="audio_platform"
+//$$ L2 PROP_STR = "status"
+    audio_platform{
+        compatible = "amlogic,aml-audio";
+        dev_name = "aml-audio.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_dai"
+//$$ L2 PROP_STR = "status"
+    audio_dai{
+        compatible = "amlogic,aml-dai";
+        dev_name = "aml-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_m8_audio"
+//$$ L2 PROP_STR = "status"
+    audio_m8_audio{
+        compatible = "amlogic,m8_audio_codec";
+        dev_name = "aml_m8_codec.0";
+        status = "okay";
+    };
+#endif        
+
+#ifdef CONFIG_SND_AML_M8
+//$$ DEVICE="aml_m8_sound_card"
+//$$ L2 PROP_STR = "aml,sound_card"
+//$$ L2 PROP_STR = "aml,codec_dai"
+//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
+//$$ L2 PROP_STR = "mute_gpio"
+//$$ L2 PROP_U32 5 = "hp_paraments"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Audio_pin_0_match" = "pinctrl-0"
+    aml_m8_sound_card{
+        compatible = "sound_card, aml_snd_m8";
+        aml,sound_card = "AML-M8AUDIO";
+        aml,codec_dai = "AML-M8";
+        aml,audio-routing =
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
+        mute_gpio = "GPIOY_15";
+        //mute_inv;
+        hp_paraments = <800 713 300 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
+        status = "okay";
+        
+    };
+#endif
+
+
+
diff --git a/sound/soc/aml/aml_alsa_common.h b/sound/soc/aml/aml_alsa_common.h
new file mode 100644
index 000000000000..31d8a768faa4
--- /dev/null
+++ b/sound/soc/aml/aml_alsa_common.h
@@ -0,0 +1,12 @@
+#ifndef __AML_ALSA_COMMOM_H__
+#define __AML_ALSA_COMMON_H__
+
+#define VOLUME_SCALE	100
+#define VOLUME_SHIFT	15
+
+extern int aml_alsa_create_ctrl(struct snd_card *card, void *p_value);
+
+extern int get_mixer_output_volume(void);
+
+extern int set_mixer_output_volume(int volume);
+#endif
diff --git a/sound/soc/aml/aml_audio_hw.c b/sound/soc/aml/aml_audio_hw.c
new file mode 100755
index 000000000000..90df8bc52a8d
--- /dev/null
+++ b/sound/soc/aml/aml_audio_hw.c
@@ -0,0 +1,1191 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <mach/am_regs.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+//#include <mach/utils.h>
+#endif
+
+#include "aml_audio_hw.h"
+
+#ifndef MREG_AIU_958_chstat0
+#define AIU_958_chstat0	AIU_958_CHSTAT_L0
+#endif
+
+#ifndef MREG_AIU_958_chstat1
+#define AIU_958_chstat1	AIU_958_CHSTAT_L1
+#endif
+
+
+unsigned ENABLE_IEC958 = 1;
+unsigned IEC958_MODE   = AIU_958_MODE_PCM16;
+unsigned I2S_MODE      = AIU_I2S_MODE_PCM16;
+
+
+int  audio_in_buf_ready = 0;
+int audio_out_buf_ready = 0;
+
+unsigned int IEC958_bpf = 0x7dd;
+unsigned int IEC958_brst = 0xc;
+unsigned int IEC958_length = 0x7dd*8;
+unsigned int IEC958_padsize = 0x8000;
+unsigned int IEC958_mode = 1;
+unsigned int IEC958_syncword1 = 0x7ffe;
+unsigned int IEC958_syncword2 = 0x8001;
+unsigned int IEC958_syncword3 = 0;
+unsigned int IEC958_syncword1_mask = 0;
+unsigned int IEC958_syncword2_mask = 0;
+unsigned int IEC958_syncword3_mask = 0xffff;
+unsigned int IEC958_chstat0_l = 0x1902 ;
+unsigned int IEC958_chstat0_r = 0x1902 ;
+unsigned int IEC958_chstat1_l = 0x200;
+unsigned int IEC958_chstat1_r = 0x200;
+unsigned int IEC958_mode_raw = 0;
+/*
+ 0 --  other formats except(DD,DD+,DTS)
+ 1 --  DTS
+ 2 --  DD
+ 3 -- DTS with 958 PCM RAW package mode
+ 4 -- DD+
+*/
+unsigned int IEC958_mode_codec;
+/*
+bit 0:soc in slave mode for adc;
+bit 1:audio in data source from spdif in;
+bit 2:adc & spdif in work at the same time;
+*/
+unsigned audioin_mode = I2SIN_MASTER_MODE;
+
+EXPORT_SYMBOL(IEC958_bpf);
+EXPORT_SYMBOL(IEC958_brst);
+EXPORT_SYMBOL(IEC958_length);
+EXPORT_SYMBOL(IEC958_padsize);
+EXPORT_SYMBOL(IEC958_mode);
+EXPORT_SYMBOL(IEC958_syncword1);
+EXPORT_SYMBOL(IEC958_syncword2);
+EXPORT_SYMBOL(IEC958_syncword3);
+EXPORT_SYMBOL(IEC958_syncword1_mask);
+EXPORT_SYMBOL(IEC958_syncword2_mask);
+EXPORT_SYMBOL(IEC958_syncword3_mask);
+EXPORT_SYMBOL(IEC958_chstat0_l);
+EXPORT_SYMBOL(IEC958_chstat0_r);
+EXPORT_SYMBOL(IEC958_chstat1_l);
+EXPORT_SYMBOL(IEC958_chstat1_r);
+EXPORT_SYMBOL(IEC958_mode_raw);
+EXPORT_SYMBOL(IEC958_mode_codec);
+
+// Bit 3:  mute constant
+//         0 => 'h0000000
+//         1 => 'h800000
+unsigned int dac_mute_const = 0x800000;
+
+/*
+                                fIn * (M)
+            Fout   =  -----------------------------
+                      		(N) * (OD+1) * (XD)
+*/
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+int audio_clock_config_table[][12][2]=
+{
+	/*{HIU Reg , XD - 1)
+	   //7.875k, 8K, 11.025k, 12k, 16k, 22.05k, 24k, 32k, 44.1k, 48k, 96k, 192k
+	*/
+	{
+	//256
+#if OVERCLOCK == 0
+		{0x0004f880, (50-1)},  // 32
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8	
+		{0x0005e965, (40-1)}, //44.1	
+		{0x0004c9a0,	(50-1)},	//48K
+#else		
+		{0x0004cdf3, (42-1)},  // 44.1
+		{0x0007c4e6, (23-1)},  // 48
+#endif	
+		{0x0006d0a4, (13-1)},  // 96
+		{0x0004e15a, (9 -1)},   // 192
+		{0x0007f400, (125-1)}, // 8k
+		{0x0006c6f6, (116-1)}, // 11.025
+		{0x0007e47f, (86-1)},  // 12
+		{0x0004f880, (100-1)}, // 16
+		{0x0004c4a4, (87-1)},  // 22.05
+		{0x0007e47f, (43-1)},  // 24
+		{0x0007f3f0, (127-1)}, // 7875
+#else
+	//512FS
+		{0x0004f880, (25-1)},  // 32
+		{0x0004cdf3, (21-1)},  // 44.1
+		{0x0006d0a4, (13-1)},  // 48
+		{0x0004e15a, (9 -1)},  // 96
+		{0x0006f207, (3 -1)},   // 192
+		{0x0004f880, (100-1)}, // 8k
+		{0x0004c4a4, (87-1)}, // 11.025
+		{0x0007e47f, (43-1)},  // 12
+		{0x0004f880, (50-1)}, // 16
+		{0x0004cdf3, (42-1)},  // 22.05
+		{0x0007c4e6, (23-1)},  // 24
+		{0x0006e1b6, (76-1)}, // 7875
+#endif
+	},
+	{
+	//384
+		{0x0007c4e6, (23-1)},  // 32
+		{0x0004c4a4, (29-1)},  // 44.1
+		{0x0004cb18, (26-1)},  // 48
+		{0x0004cb18, (13-1)},  // 96
+		{0x0004e15a, (6 -1)},   // 192
+		{0x0007e47f, (86-1)},  // 8k
+		{0x0007efa5, (61-1)},  // 11.025
+		{0x0006de98, (67-1)},  // 12
+		{0x0007e47f, (43-1)},  // 16
+		{0x0004c4a4, (58-1)},  // 22.05
+		{0x0004c60e, (53-1)},  // 24
+		{0x0007fdfa, (83-1)},  // 7875
+	}
+};
+#else
+int audio_clock_config_table[][11][2]=
+{
+  // 128*Fs
+  //
+	/*{M, N, OD, XD-1*/
+	{
+	//24M
+        {(64<<0) | (3<<9) | (0<<14) , (125-1)}, // 32K, 4.096M
+#if OVERCLOCK==0
+        {(147<<0) | (5<<9) | (0<<14) , (125-1)}, // 44.1K, 5.6448M
+        {(32<<0) | (1<<9) | (0<<14) , (125-1)}, // 48K, 6.144M
+#else
+        {(143<<0) | (8<<9) | (0<<14) , (19-1)}, // 44.1K, 5.6448M*4=22.5792M
+        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, // 48K, 6.144M*4=24.576M
+#endif
+        {(128<<0) | (5<<9) | (1<<14) , (25-1)}, // 96K, 12.288M
+        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, //192K, 24.576M
+        {(64<<0) | (3<<9) | (1<<14) , (250-1)}, // 8K, 1.024M
+        {(147<<0) | (5<<9) | (1<<14) , (250-1)}, //11.025K,1.4112M
+        {(32<<0) | (1<<9) | (1<<14) , (250-1)}, // 12K, 1.536M
+        {(64<<0) | (3<<9) | (1<<14) , (125-1)}, // 16K, 2.048M
+        {(147<<0) | (5<<9) | (1<<14) , (125-1)}, //22.050K, 2.8224M
+        {(32<<0) | (1<<9) | (1<<14) , (125-1)}, // 24K, 3.072M
+	},
+	{
+	//25M
+        {(29<<0) | (1<<9) | (0<<14) , (177-1)}, // 32K, 4.096M
+#if OVERCLOCK==0
+        {(21<<0) | (1<<9) | (0<<14) , (93-1)}, // 44.1K, 5.6448M
+        {(29<<0) | (1<<9) | (1<<14) , (59-1)}, // 48K, 6.144M
+#else
+        {(28<<0) | (1<<9) | (0<<14) , (31-1)}, // 44.1K, 5.6448M*4=22.5792M
+        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, // 48K, 6.144M*4=24.576M
+#endif
+        {(29<<0) | (1<<9) | (0<<14) , (59-1)}, // 96K, 12.288M
+        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, //192K, 24.576M
+        {(58<<0) | (3<<9) | (1<<14) , (236-1)}, // 8K, 1.024M
+        {(162<<0) | (7<<9) | (1<<14) , (205-1)}, //11.025K,1.4112M
+        {(29<<0) | (1<<9) | (1<<14) , (236-1)}, // 12K, 1.536M
+        {(29<<0) | (1<<9) | (1<<14) , (177-1)}, // 16K, 2.048M
+        {(162<<0) | (7<<9) | (0<<14) , (205-1)}, //22.050K, 2.8224M
+        {(29<<0) | (1<<9) | (1<<14) , (118-1)}, // 24K, 3.072M
+	}
+};
+#endif
+
+
+void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
+{
+	printk("====== %s ======\n",__FUNCTION__);
+    WRITE_MPEG_REG(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
+    WRITE_MPEG_REG(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+    if(channel == 8)
+		WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 256); 
+	else
+    WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);   //this is for 16bit 2 channel
+
+    WRITE_MPEG_REG(AIU_I2S_MISC,		0x0004);	// Hold I2S
+	WRITE_MPEG_REG(AIU_I2S_MUTE_SWAP,	0x0000);	// No mute, no swap
+	// As the default amclk is 24.576MHz, set i2s and iec958 divisor appropriately so as not to exceed the maximum sample rate.
+	WRITE_MPEG_REG(AIU_I2S_MISC,		0x0010 );	// Release hold and force audio data to left or right
+
+	if(channel == 8){
+		printk(" %s channel == 8\n",__FUNCTION__);
+	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
+								(0xff << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+								(0xff << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+		}
+	else 
+	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
+								(0x3 << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+								(0x3 << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+
+    // 16 bit PCM mode
+    //  WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
+	// Set init high then low to initilize the I2S memory logic
+	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1 );
+	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1 );
+
+	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
+	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
+
+    audio_out_buf_ready = 1;
+}
+
+void audio_set_958outbuf(u32 addr, u32 size,int flag)
+{
+    if (ENABLE_IEC958) {
+        WRITE_MPEG_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+	  	if(READ_MPEG_REG(AIU_MEM_IEC958_START_PTR) == READ_MPEG_REG(AIU_MEM_I2S_START_PTR)){
+			WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, READ_MPEG_REG(AIU_MEM_I2S_RD_PTR));
+		}
+		else
+        WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
+        if(flag == 0){
+          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);    // this is for 16bit 2 channel
+        }else{
+          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 1);    // this is for RAW mode
+        }
+
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
+
+        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
+        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
+    }
+}
+/*
+i2s mode 0: master 1: slave
+*/
+static void i2sin_fifo0_set_buf(u32 addr, u32 size,u32 i2s_mode)
+{
+	unsigned char  mode = 0;
+	if(i2s_mode &I2SIN_SLAVE_MODE)
+		mode = 1;
+	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(1<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
+									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
+								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+		    						|(0<<16)	//to DDR
+                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(0<<17)    // Overflow Interrupt mask
+                                                       |(0<<18)    // Audio in INT
+			                                	//|(1<<19)	//hold 0 enable
+								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
+				  );
+
+    WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,    0 << 4                       // fifo0_dest_sel
+                                       | 2 << 2                       // fifo0_din_byte_num
+                                       | 0 << 0);                      // fifo0_din_pos
+
+
+	WRITE_MPEG_REG(AUDIN_I2SIN_CTRL, //(0<<I2SIN_SIZE)			///*bit8*/  16bit
+									 (3<<I2SIN_SIZE)
+									|(1<<I2SIN_CHAN_EN)		/*bit10~13*/ //2 channel
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+									|(0<<I2SIN_POS_SYNC)
+#else
+									|(1<<I2SIN_POS_SYNC)
+#endif
+									|(1<<I2SIN_LRCLK_SKEW)
+                                    				|(1<<I2SIN_LRCLK_INVT)
+									|(!mode<<I2SIN_CLK_SEL)
+									|(!mode<<I2SIN_LRCLK_SEL)
+				    				|(!mode<<I2SIN_DIR)
+				  );
+
+}
+static void spdifin_fifo1_set_buf(u32 addr, u32 size)
+{
+	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffffff);
+	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(0<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
+									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
+								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+		    						|(0<<16)	//to DDR
+                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(0<<17)    // Overflow Interrupt mask
+                                                       |(0<<18)    // Audio in INT
+			                                	//|(1<<19)	//hold 0 enable
+								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
+				  );
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,0xc);
+}
+void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode)
+{
+	if(i2s_mode&SPDIFIN_MODE){ //spdif in ,use fifo1
+		printk("spdifin_fifo1_set_buf \n");			
+		spdifin_fifo1_set_buf(addr,size);
+	}
+	else{
+		printk("i2sin_fifo0_set_buf \n");		
+		i2sin_fifo0_set_buf(addr,size,i2s_mode);
+	}	
+       audio_in_buf_ready = 1;
+
+}
+void audio_in_spdif_set_buf(u32 addr, u32 size)
+{
+}
+//extern void audio_in_enabled(int flag);
+
+void audio_in_i2s_enable(int flag)
+{
+  	int rd = 0, start=0;
+	if(flag){
+          /* reset only when start i2s input */
+reset_again:
+	     WRITE_MPEG_REG_BITS(AUDIN_FIFO0_CTRL, 1, 1, 1); // reset FIFO 0
+            WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 0);
+            rd = READ_MPEG_REG(AUDIN_FIFO0_PTR);
+            start = READ_MPEG_REG(AUDIN_FIFO0_START);
+            if(rd != start){
+              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
+              goto reset_again;
+            }
+		if(audioin_mode == 	SPDIFIN_MODE)
+			WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));
+		else
+			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 1, I2SIN_EN, 1);
+
+	}else{
+		if(audioin_mode == 	SPDIFIN_MODE)	
+			WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));
+		else
+			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 0, I2SIN_EN, 1);
+	}
+}
+
+int if_audio_in_i2s_enable()
+{
+	return READ_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, I2SIN_EN, 1);
+}
+
+void audio_in_spdif_enable(int flag)
+{
+  int rd = 0, start=0;
+
+	if(flag){
+reset_again:
+#if 0	
+	     WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1); // reset FIFO 0
+            WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
+            rd = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+            start = READ_MPEG_REG(AUDIN_FIFO1_START);
+            if(rd != start){
+              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
+              goto reset_again;
+            }
+#endif			
+		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));		
+	}else{
+		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));				
+	}
+}
+unsigned int audio_in_i2s_rd_ptr(void)
+{
+	unsigned int val;
+	val = READ_MPEG_REG(AUDIN_FIFO0_RDPTR);
+	printk("audio in i2s rd ptr: %x\n", val);
+	return val;
+}
+unsigned int audio_in_i2s_wr_ptr(void)
+{
+	unsigned int val;
+      WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 1);
+	val = READ_MPEG_REG(AUDIN_FIFO0_PTR);
+	return (val)&(~0x3F);
+	//return val&(~0x7);
+}
+void audio_in_i2s_set_wrptr(unsigned int val)
+{
+	WRITE_MPEG_REG(AUDIN_FIFO0_RDPTR, val);
+}
+
+void audio_set_i2s_mode(u32 mode)
+{
+    const unsigned short mask[4] = {
+        0x303,                  /* 2x16 */
+        0x303,                  /* 2x24 */
+        0x303,                 /* 8x24 */
+        0x303,                  /* 2x32 */
+    };
+
+    if (mode < sizeof(mask)/ sizeof(unsigned short)) {
+       /* four two channels stream */
+        WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 1);
+
+        if (mode == AIU_I2S_MODE_PCM16) {
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 0, 5, 1);
+        } else if(mode == AIU_I2S_MODE_PCM32){
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
+        }else if(mode == AIU_I2S_MODE_PCM24){
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
+        }
+
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
+
+        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1);
+        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1);
+
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, mask[mode], 0,
+                                16);
+            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
+            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
+        }
+    }
+}
+
+/**
+ *  if normal clock, i2s clock is twice of 958 clock, so the divisor for i2s is 8, but 4 for 958
+ *  if over clock, the devisor for i2s is 8, but for 958 should be 1, because 958 should be 4 times speed according to i2s
+ *  This is dolby digital plus's spec
+ * */
+
+void audio_util_set_dac_format(unsigned format)
+{
+  	WRITE_MPEG_REG(AIU_CLK_CTRL,		 (0 << 12) | // 958 divisor more, if true, divided by 2, 4, 6, 8.
+							(1 <<  8) | // alrclk skew: 1=alrclk transitions on the cycle before msb is sent
+							(1 <<  6) | // invert aoclk
+							(1 <<  7) | // invert lrclk
+#if OVERCLOCK == 1
+							(3 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+							(3 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#else
+							(1 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+							(2 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#endif
+							(1 <<  1) | // enable 958 clock
+							(1 <<  0)); // enable I2S clock
+    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
+    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
+    }
+ 	if(dac_mute_const == 0x800000)
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
+    else
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
+	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel
+}
+
+// iec958 and i2s clock are separated after M6TV.
+void audio_util_set_dac_958_format(unsigned format)
+{
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,0,12,1);// 958 divisor more, if true, divided by 2, 4, 6, 8
+#if IEC958_OVERCLOCK == 1
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+#else
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+#endif.
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,1,1);// enable 958 clock
+}
+
+void audio_util_set_dac_i2s_format(unsigned format)
+{	
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,6,1);//invert aoclk
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,7,1);//invert lrclk
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,8,2);// alrclk skew: 1=alrclk transitions on the cycle before msb is sent
+#if OVERCLOCK == 1
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,2,2);// i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#else
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,2,2,2); // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#endif
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,0,1);// enable I2S clock
+	
+    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
+    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
+    }
+ 	if(dac_mute_const == 0x800000)
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
+    else
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
+	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel	
+}
+
+extern unsigned int get_ddr_pll_clk(void);
+
+void audio_set_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+   // if (fs_config == AUDIO_CLK_256FS) {
+   if(1){
+		int index=0;
+		switch(freq)
+		{
+			case AUDIO_CLK_FREQ_192:
+				index=4;
+				break;
+			case AUDIO_CLK_FREQ_96:
+				index=3;
+				break;
+			case AUDIO_CLK_FREQ_48:
+				index=2;
+				break;
+			case AUDIO_CLK_FREQ_441:
+				index=1;
+				break;
+			case AUDIO_CLK_FREQ_32:
+				index=0;
+				break;
+			case AUDIO_CLK_FREQ_8:
+				index = 5;
+				break;
+			case AUDIO_CLK_FREQ_11:
+				index = 6;
+				break;
+			case AUDIO_CLK_FREQ_12:
+				index = 7;
+				break;
+			case AUDIO_CLK_FREQ_16:
+				index = 8;
+				break;
+			case AUDIO_CLK_FREQ_22:
+				index = 9;
+				break;
+			case AUDIO_CLK_FREQ_24:
+				index = 10;
+				break;
+			default:
+				index=0;
+				break;
+		};
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+	// get system crystal freq
+		clk=clk_get_sys("clk_xtal", NULL);
+		if(!clk)
+		{
+			printk(KERN_ERR "can't find clk %s for AUDIO PLL SETTING!\n\n","clk_xtal");
+			//return -1;
+		}
+		else
+		{
+			xtal=clk_get_rate(clk);
+			xtal=xtal/1000000;
+			if(xtal>=24 && xtal <=25)/*current only support 24,25*/
+			{
+				xtal-=24;
+			}
+			else
+			{
+				printk(KERN_WARNING "UNsupport xtal setting for audio xtal=%d,default to 24M\n",xtal);
+				xtal=0;
+			}
+		}
+
+		audio_clock_config = audio_clock_config_table[xtal];
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+#endif
+
+#ifdef CONFIG_SND_AML_M3
+	if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==516000000)&&(index=2))) // 48k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 516/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 48k clock from ddr pll %dM\n", 516);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==508000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 45-1, 0, 8); // 508/45
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 508);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==486000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 43-1, 0, 8); // 486/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 486);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==474000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 474/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 474);
+		return;
+	}
+#endif
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+
+//#ifdef CONFIG_SND_AML_M3
+#ifdef CONFIG_ARCH_MESON3
+	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL2, 0x065e31ff);
+	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL3, 0x9649a941);
+	// select Audio PLL as MCLK source
+	//WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 9));
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 9, 3);
+	//WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 25-1, 0, 8);
+
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 13-1, 0, 8);
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+  WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+#endif
+
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+    // Put the PLL to sleep
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15));//found
+
+//#ifdef CONFIG_SND_AML_M3
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
+	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+#endif
+    // Bring out of reset but keep bypassed to allow to stablize
+    //Wr( HHI_AUD_PLL_CNTL, (1 << 15) | (0 << 14) | (hiu_reg & 0x3FFF) );
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, (1 << 15) | (audio_clock_config[index][0] & 0x7FFF) );//found
+    // Set the XD value
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, (READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(0xff << 0)) | audio_clock_config[index][1]);//found
+    // delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+    // Bring the PLL out of sleep
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));//found
+
+    // gate the clock on
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));//found
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));// gate audac_clkpi
+#endif
+#else // endif CONFIG_ARCH_MESON6
+    WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+
+	// Select Multi-Phase PLL2 as clock source
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 3);
+
+	// Configure Multi-Phase PLL2
+	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
+	// Set the XD value
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV
+	//Audio DAC Clock enable
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
+/* ADC clock  configuration */
+// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 8, 1);
+
+    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 3, 9, 2);
+
+    // Set pll over mclk ratio
+    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
+#if OVERCLOCK == 0
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 0, 8);
+#else
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)*2-1, 0, 8);
+#endif
+
+    // Set mclk over sclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
+
+    // Set sclk over lrclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);
+
+    // Enable sclk
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
+    // Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 8, 1);
+#endif
+
+#endif // endif CONFIG_ARCH_MESON6
+    // delay 2uS
+	//udelay(2);
+	for (i = 0; i < 200000; i++) ;
+
+    } else if (fs_config == AUDIO_CLK_384FS) {
+    }
+}
+
+// iec958 and i2s clock are separated after M6TV. Use PLL2 for i2s DAC & ADC clock
+void audio_set_i2s_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+	int index=0;
+	switch(freq)
+	{
+		case AUDIO_CLK_FREQ_192:
+			index=4;
+			break;
+		case AUDIO_CLK_FREQ_96:
+			index=3;
+			break;
+		case AUDIO_CLK_FREQ_48:
+			index=2;
+			break;
+		case AUDIO_CLK_FREQ_441:
+			index=1;
+			break;
+		case AUDIO_CLK_FREQ_32:
+			index=0;
+			break;
+		case AUDIO_CLK_FREQ_8:
+			index = 5;
+			break;
+		case AUDIO_CLK_FREQ_11:
+			index = 6;
+			break;
+		case AUDIO_CLK_FREQ_12:
+			index = 7;
+			break;
+		case AUDIO_CLK_FREQ_16:
+			index = 8;
+			break;
+		case AUDIO_CLK_FREQ_22:
+			index = 9;
+			break;
+		case AUDIO_CLK_FREQ_24:
+			index = 10;
+			break;
+		default:
+			index=0;
+			break;
+	};
+
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+	WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	
+	//Set filter register
+	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+
+	/*--- DAC clock  configuration--- */
+	// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 2);
+
+	// Configure Multi-Phase PLL2
+	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
+	// Set the XD value
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk--64fs
+	
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+
+	//Audio DAC Clock enable
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
+	
+	/* ---ADC clock  configuration--- */
+	// Disable mclk
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
+
+    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 3, 9, 2);
+
+    // Set pll over mclk ratio
+    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
+#if OVERCLOCK == 0
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+#else
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, (audio_clock_config[index][1]+1)*2-1, 0, 8);
+#endif
+
+    // Set mclk over sclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
+
+    // Set sclk over lrclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12); //set codec adc ratio---lrclk--64fs
+
+    // Enable sclk
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
+    // Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 8, 1);
+
+    // delay 2uS
+	//udelay(2);
+	for (i = 0; i < 200000; i++) ;
+}
+
+// iec958 and i2s clock are separated after M6TV. Use PLL1 for iec958 clock
+void audio_set_958_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+	int index=0;
+	switch(freq)
+	{
+		case AUDIO_CLK_FREQ_192:
+			index=4;
+			break;
+		case AUDIO_CLK_FREQ_96:
+			index=3;
+			break;
+		case AUDIO_CLK_FREQ_48:
+			index=2;
+			break;
+		case AUDIO_CLK_FREQ_441:
+			index=1;
+			break;
+		case AUDIO_CLK_FREQ_32:
+			index=0;
+			break;
+		case AUDIO_CLK_FREQ_8:
+			index = 5;
+			break;
+		case AUDIO_CLK_FREQ_11:
+			index = 6;
+			break;
+		case AUDIO_CLK_FREQ_12:
+			index = 7;
+			break;
+		case AUDIO_CLK_FREQ_16:
+			index = 8;
+			break;
+		case AUDIO_CLK_FREQ_22:
+			index = 9;
+			break;
+		case AUDIO_CLK_FREQ_24:
+			index = 10;
+			break;
+		default:
+			index=0;
+			break;
+	};
+
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+	//WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	
+	//Set filter register
+	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+
+	/*--- IEC958 clock  configuration, use MPLL1--- */
+	// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 24, 1);
+	//IEC958_USE_CNTL
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 1, 27, 1);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 2, 25, 2);
+
+	// Configure Multi-Phase PLL1
+	WRITE_MPEG_REG(HHI_MPLL_CNTL8, audio_clock_config[index][0]);
+	// Set the XD value
+#if IEC958_OVERCLOCK	==1
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)/2 -1, 16, 8);
+#else
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 16, 8);
+#endif
+
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+	// Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 24, 1);
+}
+
+//extern void audio_out_enabled(int flag);
+void audio_hw_958_raw(void);
+
+void audio_enable_ouput(int flag)
+{
+    if (flag) {
+        WRITE_MPEG_REG(AIU_RST_SOFT, 0x05);
+        READ_MPEG_REG(AIU_I2S_SYNC);
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
+
+        if (ENABLE_IEC958) {
+            if(IEC958_MODE == AIU_958_MODE_RAW)
+            {
+              //audio_hw_958_raw();
+            }
+            //else
+            {
+              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
+              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+              //WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 1);
+
+              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+            }
+        }
+        // Maybe cause POP noise
+        // audio_i2s_unmute();
+    } else {
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
+
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
+        }
+        // Maybe cause POP noise
+        // audio_i2s_mute();
+    }
+    //audio_out_enabled(flag);
+}
+
+int if_audio_out_enable()
+{
+	return READ_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 2);
+}
+
+unsigned int read_i2s_rd_ptr(void)
+{
+    unsigned int val;
+    val = READ_MPEG_REG(AIU_MEM_I2S_RD_PTR);
+    return val;
+}
+
+void audio_i2s_unmute(void)
+{
+    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0, 8, 8);
+    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 0, 3, 2);
+}
+
+void audio_i2s_mute(void)
+{
+    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0xff, 8, 8);
+    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 3, 3, 2);
+}
+
+void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
+{
+	WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL,0);
+    WRITE_MPEG_REG(AIU_RST_SOFT,
+                   (slow_domain << 3) | (fast_domain << 2));
+}
+
+void audio_hw_958_raw()
+{
+    if (ENABLE_IEC958) {
+         WRITE_MPEG_REG(AIU_958_MISC, 1);
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
+    }
+
+    WRITE_MPEG_REG(AIU_958_BPF, IEC958_bpf);
+    WRITE_MPEG_REG(AIU_958_BRST, IEC958_brst);
+    WRITE_MPEG_REG(AIU_958_LENGTH, IEC958_length);
+    WRITE_MPEG_REG(AIU_958_PADDSIZE, IEC958_padsize);
+    WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 2, 2);// disable int
+
+    if(IEC958_mode == 1){ // search in byte
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 7, 4, 3);
+    }else if(IEC958_mode == 2) { // search in word
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 5, 4, 3);
+    }else{
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 4, 3);
+    }
+    WRITE_MPEG_REG(AIU_958_CHSTAT_L0, IEC958_chstat0_l);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_L1, IEC958_chstat1_l);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_R0, IEC958_chstat0_r);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_R1, IEC958_chstat1_r);
+
+    WRITE_MPEG_REG(AIU_958_SYNWORD1, IEC958_syncword1);
+    WRITE_MPEG_REG(AIU_958_SYNWORD2, IEC958_syncword2);
+    WRITE_MPEG_REG(AIU_958_SYNWORD3, IEC958_syncword3);
+    WRITE_MPEG_REG(AIU_958_SYNWORD1_MASK, IEC958_syncword1_mask);
+    WRITE_MPEG_REG(AIU_958_SYNWORD2_MASK, IEC958_syncword2_mask);
+    WRITE_MPEG_REG(AIU_958_SYNWORD3_MASK, IEC958_syncword3_mask);
+
+    printk("%s: %d\n", __func__, __LINE__);
+    printk("\tBPF: %x\n", IEC958_bpf);
+    printk("\tBRST: %x\n", IEC958_brst);
+    printk("\tLENGTH: %x\n", IEC958_length);
+    printk("\tPADDSIZE: %x\n", IEC958_length);
+    printk("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1, IEC958_syncword2, IEC958_syncword3);
+
+}
+
+void set_958_channel_status(_aiu_958_channel_status_t * set)
+{
+    if (set) {
+		WRITE_MPEG_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
+    }
+}
+
+static void audio_hw_set_958_pcm24(_aiu_958_raw_setting_t * set)
+{
+    WRITE_MPEG_REG(AIU_958_BPF, 0x80); /* in pcm mode, set bpf to 128 */
+    set_958_channel_status(set->chan_stat);
+}
+
+void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set)
+{
+    if(mode == AIU_958_MODE_PCM_RAW){
+    	mode = AIU_958_MODE_PCM16; //use 958 raw pcm mode
+       WRITE_MPEG_REG(AIU_958_VALID_CTRL,3);//enable 958 invalid bit	
+    } 
+    else
+	WRITE_MPEG_REG(AIU_958_VALID_CTRL,0);
+    if (mode == AIU_958_MODE_RAW) {
+
+        audio_hw_958_raw();
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 1);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
+        }
+
+        printk("IEC958 RAW\n");
+    }else if(mode == AIU_958_MODE_PCM32){
+        audio_hw_set_958_pcm24(set);
+        if(ENABLE_IEC958){
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+        }
+        printk("IEC958 PCM32 \n");
+    }else if (mode == AIU_958_MODE_PCM24) {
+        audio_hw_set_958_pcm24(set);
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+
+        }
+        printk("IEC958 24bit\n");
+    } else if (mode == AIU_958_MODE_PCM16) {
+        audio_hw_set_958_pcm24(set);
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2042);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+
+        }
+        printk("IEC958 16bit\n");
+    }
+
+    audio_hw_958_reset(0, 1);
+
+    WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 1);
+}
+
+void audio_hw_958_enable(unsigned flag)
+{
+    if (ENABLE_IEC958) {
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 2, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 1, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 0, 1);
+    }
+}
+
+unsigned int read_i2s_mute_swap_reg(void)
+{
+	unsigned int val;
+    	val = READ_MPEG_REG(AIU_I2S_MUTE_SWAP);
+    	return val;
+}
+
+void audio_i2s_swap_left_right(unsigned int flag)
+{
+	if (ENABLE_IEC958)
+	{
+		WRITE_MPEG_REG_BITS(AIU_958_CTRL, flag, 1, 2);
+	}
+	WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, flag, 0, 2);
+}
+unsigned int audio_hdmi_init_ready()
+{
+	return 	READ_MPEG_REG_BITS(AIU_HDMI_CLK_DATA_CTRL, 0, 2);
+}
diff --git a/sound/soc/aml/aml_audio_hw.h b/sound/soc/aml/aml_audio_hw.h
new file mode 100755
index 000000000000..378b36feb745
--- /dev/null
+++ b/sound/soc/aml/aml_audio_hw.h
@@ -0,0 +1,202 @@
+#ifndef __AML_AUDIO_HW_H__
+#define __AML_AUDIO_HW_H__
+
+#if defined (CONFIG_ARCH_MESON) || defined (CONFIG_ARCH_MESON2) || defined (CONFIG_ARCH_MESON3)
+
+
+/* assumming PLL source is 24M */
+
+#define AUDIO_384FS_PLL_192K        0x507d  /* 36.864M */
+#define AUDIO_384FS_PLL_192K_MUX    12
+#define AUDIO_384FS_CLK_192K        0x5eb
+
+#define AUDIO_384FS_PLL_176K        0x0e7c  /* 33.8688M */
+#define AUDIO_384FS_PLL_176K_MUX    25
+#define AUDIO_384FS_CLK_176K        0x5eb
+
+#define AUDIO_384FS_PLL_96K         0x507d  /* 36.864M */
+#define AUDIO_384FS_PLL_96K_MUX     12
+#define AUDIO_384FS_CLK_96K         0x5ef
+
+#define AUDIO_384FS_PLL_88K         0x0e7c  /* 33.8688M */
+#define AUDIO_384FS_PLL_88K_MUX     25
+#define AUDIO_384FS_CLK_88K         0x5ef
+
+#define AUDIO_384FS_PLL_48K         0x487d  /* 18.432M */
+#define AUDIO_384FS_PLL_48K_MUX     12
+#define AUDIO_384FS_CLK_48K_AC3     0x5ed
+#define AUDIO_384FS_CLK_48K         0x5ef
+
+#define AUDIO_384FS_PLL_44K         0x0aa3  /* 16.9344M */
+#define AUDIO_384FS_PLL_44K_MUX     23
+#define AUDIO_384FS_CLK_44K         0x5ef
+
+#define AUDIO_384FS_PLL_32K         0x1480  /* 12.288M */
+#define AUDIO_384FS_PLL_32K_MUX     24
+#define AUDIO_384FS_CLK_32K         0x5ef
+
+#define AUDIO_384FS_DAC_CFG         0x6
+
+#define AUDIO_256FS_PLL_192K        0x0a53  /* 24.576M */
+#define AUDIO_256FS_PLL_192K_MUX    17
+#define AUDIO_256FS_CLK_192K        0x5c7
+
+#define AUDIO_256FS_PLL_176K        0x0eba  /* 22.5792M */
+#define AUDIO_256FS_PLL_176K_MUX    25
+#define AUDIO_256FS_CLK_176K        0x5c7
+
+#define AUDIO_256FS_PLL_96K         0x0a53  /* 24.576M */
+#define AUDIO_256FS_PLL_96K_MUX     17
+#define AUDIO_256FS_CLK_96K         0x5db
+
+#define AUDIO_256FS_PLL_88K         0x0eba  /* 22.5792M */
+#define AUDIO_256FS_PLL_88K_MUX     25
+#define AUDIO_256FS_CLK_88K         0x5db
+
+#define AUDIO_256FS_PLL_48K         0x08d3  /* 12.288M */
+#define AUDIO_256FS_PLL_48K_MUX     27
+#define AUDIO_256FS_CLK_48K_AC3     0x5d9
+#define AUDIO_256FS_CLK_48K         0x5db
+
+#define AUDIO_256FS_PLL_44K         0x06b9  /* 11.2896M */
+#define AUDIO_256FS_PLL_44K_MUX     29
+#define AUDIO_256FS_CLK_44K         0x5db
+
+#define AUDIO_256FS_PLL_32K         0x4252  /* 8.192M */
+#define AUDIO_256FS_PLL_32K_MUX     14
+#define AUDIO_256FS_CLK_32K         0x5db
+#define AUDIO_256FS_DAC_CFG         0x7
+
+#endif
+
+typedef struct {
+    unsigned short pll;
+    unsigned short mux;
+    unsigned short devisor;
+} _aiu_clk_setting_t;
+
+typedef struct {
+    unsigned short chstat0_l;
+    unsigned short chstat1_l;
+    unsigned short chstat0_r;
+    unsigned short chstat1_r;
+} _aiu_958_channel_status_t;
+
+typedef struct {
+    /* audio clock */
+    unsigned short clock;
+    /* analog output */
+    unsigned short i2s_mode;
+    unsigned short i2s_dac_mode;
+    unsigned short i2s_preemphsis;
+    /* digital output */
+    unsigned short i958_buf_start_addr;
+    unsigned short i958_buf_blksize;
+    unsigned short i958_int_flag;
+    unsigned short i958_mode;
+    unsigned short i958_sync_mode;
+    unsigned short i958_preemphsis;
+    unsigned short i958_copyright;
+    unsigned short bpf;
+    unsigned short brst;
+    unsigned short length;
+    unsigned short paddsize;
+    _aiu_958_channel_status_t chan_status;
+} audio_output_config_t;
+
+typedef struct {
+    unsigned short int_flag;
+    unsigned short bpf;
+    unsigned short brst;
+    unsigned short length;
+    unsigned short paddsize;
+    _aiu_958_channel_status_t *chan_stat;
+} _aiu_958_raw_setting_t;
+
+enum {
+	I2SIN_MASTER_MODE = 0,
+	I2SIN_SLAVE_MODE  =   1<<0,
+	SPDIFIN_MODE   = 1<<1,
+};
+#define AUDIO_CLK_256FS             0
+#define AUDIO_CLK_384FS             1
+
+#define AUDIO_CLK_FREQ_192  0
+#define AUDIO_CLK_FREQ_1764 1
+#define AUDIO_CLK_FREQ_96   2
+#define AUDIO_CLK_FREQ_882  3
+#define AUDIO_CLK_FREQ_48   4
+#define AUDIO_CLK_FREQ_441  5
+#define AUDIO_CLK_FREQ_32   6
+
+#define AUDIO_CLK_FREQ_8		7
+#define AUDIO_CLK_FREQ_11		8
+#define AUDIO_CLK_FREQ_12		9
+#define AUDIO_CLK_FREQ_16		10
+#define AUDIO_CLK_FREQ_22		11
+#define AUDIO_CLK_FREQ_24		12
+
+
+#define AIU_958_MODE_RAW    0
+#define AIU_958_MODE_PCM16  1
+#define AIU_958_MODE_PCM24  2
+#define AIU_958_MODE_PCM32  3
+#define AIU_958_MODE_PCM_RAW  4
+
+#define AIU_I2S_MODE_PCM16   0
+#define AIU_I2S_MODE_PCM24   2
+#define AIU_I2S_MODE_PCM32   3
+
+#define AUDIO_ALGOUT_DAC_FORMAT_DSP             0
+#define AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY    1
+
+extern unsigned ENABLE_IEC958;
+extern unsigned IEC958_MODE;
+extern unsigned I2S_MODE;
+
+void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
+void audio_set_958outbuf(u32 addr, u32 size, int flag);
+void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode);
+void audio_in_spdif_set_buf(u32 addr, u32 size);
+void audio_in_i2s_enable(int flag);
+void audio_in_spdif_enable(int flag);
+unsigned int audio_in_i2s_rd_ptr(void);
+unsigned int audio_in_i2s_wr_ptr(void);
+void audio_set_i2s_mode(u32 mode);
+void audio_set_clk(unsigned freq, unsigned fs_config);
+void audio_set_i2s_clk(unsigned freq, unsigned fs_config);
+void audio_set_958_clk(unsigned freq, unsigned fs_config);
+void audio_enable_ouput(int flag);
+unsigned int read_i2s_rd_ptr(void);
+void audio_i2s_unmute(void);
+void audio_i2s_mute(void);
+void audio_util_set_dac_format(unsigned format);
+void audio_util_set_dac_i2s_format(unsigned format);
+void audio_util_set_dac_958_format(unsigned format);
+void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set);
+unsigned int read_i2s_mute_swap_reg(void);
+void audio_i2s_swap_left_right(unsigned int flag);
+int if_audio_out_enable(void);
+int if_audio_in_i2s_enable(void);
+void audio_hw_958_enable(unsigned flag);
+void audio_out_enabled(int flag);
+void audio_util_set_dac_format(unsigned format);
+unsigned int audio_hdmi_init_ready(void);
+
+#include "mach/cpu.h"
+
+/*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+#define OVERCLOCK 0
+#define IEC958_OVERCLOCK 1
+#else
+#define OVERCLOCK 1
+#endif
+
+#if (OVERCLOCK == 1)
+#define MCLKFS_RATIO 512
+#else
+#define MCLKFS_RATIO 256
+#endif
+
+#endif
diff --git a/sound/soc/aml/aml_audio_hw_pcm2bt.c b/sound/soc/aml/aml_audio_hw_pcm2bt.c
new file mode 100755
index 000000000000..adfa4bda6574
--- /dev/null
+++ b/sound/soc/aml/aml_audio_hw_pcm2bt.c
@@ -0,0 +1,314 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <mach/am_regs.h>
+#include <linux/clk.h>
+
+#include "aml_audio_hw_pcm2bt.h"
+
+//#define PCM_DEBUG
+
+#ifdef PCM_DEBUG
+#define pcm_debug           pr_info
+#else
+#define pcm_debug(fmt, ...) \
+        do {} while(0)
+#endif
+
+static unsigned int pcmin_buffer_addr = 0;
+static unsigned int pcmin_buffer_size = 0;
+
+static unsigned int pcmout_buffer_addr = 0;
+static unsigned int pcmout_buffer_size = 0;
+
+static void pcm_in_register_show(void)
+{
+    pcm_debug("PCMIN registers show:\n");
+    pcm_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START, READ_MPEG_REG(AUDIN_FIFO1_START));
+    pcm_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END, READ_MPEG_REG(AUDIN_FIFO1_END));
+    pcm_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR, READ_MPEG_REG(AUDIN_FIFO1_PTR));
+    pcm_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR, READ_MPEG_REG(AUDIN_FIFO1_RDPTR));
+    pcm_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL, READ_MPEG_REG(AUDIN_FIFO1_CTRL));
+    pcm_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1, READ_MPEG_REG(AUDIN_FIFO1_CTRL1));
+    pcm_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0, READ_MPEG_REG(PCMIN_CTRL0));
+    pcm_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1, READ_MPEG_REG(PCMIN_CTRL1));
+}
+
+void pcm_in_enable(int flag)
+{
+    /* reset fifo */
+RESET_FIFO:    
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1);
+    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
+    if (READ_MPEG_REG(AUDIN_FIFO1_PTR) != READ_MPEG_REG(AUDIN_FIFO1_START))
+        goto RESET_FIFO;
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 1, 1);
+
+    /* reset pcmin */
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 30, 1);
+
+    /* disable fifo */
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 0, 1);
+
+    /* disable pcmin */
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 31, 1);
+
+    if (flag) {
+        /* set buffer start ptr end */
+    	WRITE_MPEG_REG(AUDIN_FIFO1_START, pcmin_buffer_addr);
+    	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+    	WRITE_MPEG_REG(AUDIN_FIFO1_END, pcmin_buffer_addr + pcmin_buffer_size - 8);
+
+        /* fifo control */
+        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1 << 15) |    // urgent request
+                                         (1 << 11) |    // channel
+                                         (6 << 8) |     // endian
+                                         //(0 << 8) |     // endian
+                                         (2 << 3) |     // PCMIN input selection
+                                         (1 << 2) |     // load address
+                                         (0 << 1) |     // reset fifo
+                                         (1 << 0)       // fifo enable
+                        );
+
+        /* fifo control1 */
+        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1, (0 << 4) |    // data destination DDR
+                                          (1 << 2) |    // 16bits
+                                          (0 << 0)      // data position
+                        );
+
+        /* pcmin control1 */
+        WRITE_MPEG_REG(PCMIN_CTRL1, (0 << 29) |         // external chip
+                                    (0 << 28) |         // external chip
+                                    (1 << 27) |         // using negedge of PCM clock to latch the input data
+                                    (15 << 21) |        // slot bit msb 16 clocks per slot
+                                    (15 << 16) |        // data msb 16bits data
+                                    (1 << 0)            // slot valid
+                        );
+
+        /* pcmin control0 */
+        WRITE_MPEG_REG(PCMIN_CTRL0, (1 << 31) |         // pcmin enable
+                                    (1 << 29) |         // sync on clock posedge
+                                    (0 << 16) |         // FS SKEW
+                                    (0 << 4) |          // waithing 1 system clock cycles then sample the PCMIN singals
+                                    (0 << 3) |          // use clock counter to do the sample
+                                    (0 << 2) |          // fs not inverted. H = left, L = right
+                                    (1 << 1) |          // msb first
+                                    (1 << 0)            // left justified
+                        );
+    }
+
+    pcm_debug("PCMIN %s\n", flag ? "enable" : "disable");
+    pcm_in_register_show();
+}
+
+void pcm_in_set_buf(unsigned int addr, unsigned int size)
+{
+    pcmin_buffer_addr = addr;
+    pcmin_buffer_size = size;
+
+    pcm_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n", pcmin_buffer_addr, pcmin_buffer_size);
+}
+
+int pcm_in_is_enable(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMIN_CTRL0, 31, 1) & 0x01);
+
+    return value;
+}
+
+unsigned int pcm_in_rd_ptr(void)
+{
+    unsigned int value = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
+
+    return value;
+}
+
+unsigned int pcm_in_set_rd_ptr(unsigned int value)
+{
+    unsigned int old = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+    WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, value);
+    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
+
+    return old;
+}
+
+unsigned int pcm_in_wr_ptr(void)
+{
+	unsigned int writing = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+    unsigned int written = 0;
+    unsigned int value = 0;
+
+    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
+	written = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+    pcm_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
+
+    //value = written;
+    value = written & (~0x07);
+    return value;
+}
+
+unsigned int pcm_in_fifo_int(void)
+{
+    unsigned int value = 0;
+    value = READ_MPEG_REG(AUDIN_FIFO_INT);
+    pcm_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
+
+    return value;
+}
+
+static void pcm_out_register_show(void)
+{
+    pcm_debug("PCMOUT registers show:\n");
+    pcm_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA, READ_MPEG_REG(AUDOUT_BUF0_STA));
+    pcm_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA, READ_MPEG_REG(AUDOUT_BUF0_EDA));
+    pcm_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR, READ_MPEG_REG(AUDOUT_BUF0_WPTR));
+    pcm_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR, READ_MPEG_REG(AUDOUT_FIFO_RPTR));
+    pcm_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL, READ_MPEG_REG(AUDOUT_CTRL));
+    pcm_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1, READ_MPEG_REG(AUDOUT_CTRL1));
+    pcm_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0, READ_MPEG_REG(PCMOUT_CTRL0));
+    pcm_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1, READ_MPEG_REG(PCMOUT_CTRL1));
+    pcm_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2, READ_MPEG_REG(PCMOUT_CTRL2));
+    pcm_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3, READ_MPEG_REG(PCMOUT_CTRL3));
+}
+
+void pcm_out_enable(int flag)
+{
+    /* reset fifo */
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 30, 1);
+
+    /* reset pcmout */
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 30, 1);
+
+    /* disable fifo */
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 31, 1);
+
+    /* disable pcmout */
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 31, 1);
+
+    if (flag) {
+        /* set buffer start ptr end */
+    	WRITE_MPEG_REG(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+    	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+    	WRITE_MPEG_REG(AUDOUT_BUF0_EDA, pcmout_buffer_addr + pcmout_buffer_size - 8);
+
+        /* fifo control */
+        WRITE_MPEG_REG(AUDOUT_CTRL, (0 << 31) |     // fifo enable
+                                    (0 << 30) |     // soft reset
+                                    (1 << 29) |     // load address
+                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
+                                    (52 << 15) |    // data request size
+                                    (64 << 8) |     // buffer level to keep
+                                    (0 << 7) |      // buffer level control
+                                    (1 << 6) |      // DMA mode
+                                    (1 << 5) |      // circular buffer
+                                    (0 << 4) |      // use register set 0 always
+                                    (1 << 3) |       // urgent request
+                                    (6 << 0)         //endian
+                        );
+
+        WRITE_MPEG_REG(AUDOUT_CTRL, (1 << 31) |     // fifo enable
+                                    (0 << 30) |     // soft reset
+                                    (0 << 29) |     // load address
+                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
+                                    (52 << 15) |    // data request size
+                                    (64 << 8) |     // buffer level to keep
+                                    (0 << 7) |      // buffer level control
+                                    (1 << 6) |      // DMA mode
+                                    (1 << 5) |      // circular buffer
+                                    (0 << 4) |      // use register set 0 always
+                                    (1 << 3) |       // urgent request
+                                    (6 << 0)         //endian
+                                    
+                        );
+        /* pcmout control3 */
+        WRITE_MPEG_REG(PCMOUT_CTRL3, 0);            // mute constant
+
+        /* pcmout control2 */
+        WRITE_MPEG_REG(PCMOUT_CTRL2,(0 << 29) |     // underrun use mute constant
+                                    (0 << 22) |     // 1 channel per frame
+                                    (15 << 16) |    // 16 bits per slot
+                                    (1 << 0)        // enable 1 slot
+                        );
+
+        /* pcmout control1 */
+        WRITE_MPEG_REG(PCMOUT_CTRL1,(1 << 30) |     // data byte numbe n - 1?
+                                    (0 << 28) |     // use posedge of PCM clock to output data
+                                    (1 << 27)       // use negedge of pcm clock to check the fs
+                        );
+
+        /* pcmout control0 */
+        WRITE_MPEG_REG(PCMOUT_CTRL0,(1 << 31) |     // enable
+                                    (0 << 29) |     // slave
+                                    (1 << 28) |     // sync on clock rising edge
+                                    (0 << 27) |     // data sample mode
+                                    (1 << 15) |     // sync on 4 system clock later ?
+                                    (1 << 14) |     // msb first
+                                    (1 << 13) |     // left justified
+                                    (0 << 12) |     // data position
+                                    (3 << 6) |      // sync fs with the slot bit counter.
+                                    (0 << 0)        // sync fs with frame slot counter.
+                        );
+    }
+
+    pcm_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+    pcm_out_register_show();
+}
+
+void pcm_out_mute(int flag)
+{
+    int value = flag ? 1: 0;
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL2, value, 31, 1);
+}
+
+void pcm_out_set_buf(unsigned int addr, unsigned int size)
+{
+    pcmout_buffer_addr = addr;
+    pcmout_buffer_size = size;
+
+    pcm_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n", pcmout_buffer_addr, pcmout_buffer_size);
+}
+
+int pcm_out_is_enable(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL0, 31, 1) & 0x01);
+
+    return value;
+}
+
+int  pcm_out_is_mute(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL2, 31, 1) & 0x01);
+
+    return value;
+}
+
+unsigned int pcm_out_rd_ptr(void)
+{
+    unsigned int value = READ_MPEG_REG(AUDOUT_FIFO_RPTR);
+    pcm_debug("PCMOUT read pointer: 0x%08x\n", value);
+
+    return value;
+}
+
+unsigned int pcm_out_wr_ptr(void)
+{
+    unsigned int value = 0;
+ 	value = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
+    pcm_debug("PCMOUT write pointer: 0x%08x\n", value);
+    return value;
+}
+
+unsigned int pcm_out_set_wr_ptr(unsigned int value)
+{
+    unsigned int old = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
+ 	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, value);
+    pcm_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
+
+    return old;
+}
+
diff --git a/sound/soc/aml/aml_audio_hw_pcm2bt.h b/sound/soc/aml/aml_audio_hw_pcm2bt.h
new file mode 100755
index 000000000000..4afc8d6a6425
--- /dev/null
+++ b/sound/soc/aml/aml_audio_hw_pcm2bt.h
@@ -0,0 +1,21 @@
+#ifndef __AML_PCM_HW_H__
+#define __AML_PCM_HW_H__
+
+void pcm_in_enable(int flag);
+void pcm_in_set_buf(unsigned int addr, unsigned int size);
+int  pcm_in_is_enable(void);
+unsigned int pcm_in_rd_ptr(void);
+unsigned int pcm_in_wr_ptr(void);
+unsigned int pcm_in_set_rd_ptr(unsigned int value);
+unsigned int pcm_in_fifo_int(void);
+
+void pcm_out_enable(int flag);
+void pcm_out_mute(int flag);
+void pcm_out_set_buf(unsigned int addr, unsigned int size);
+int  pcm_out_is_enable(void);
+int  pcm_out_is_mute(void);
+unsigned int pcm_out_rd_ptr(void);
+unsigned int pcm_out_wr_ptr(void);
+unsigned int pcm_out_set_wr_ptr(unsigned int value);
+
+#endif
diff --git a/sound/soc/aml/aml_dai.c b/sound/soc/aml/aml_dai.c
new file mode 100755
index 000000000000..82a9de53b32e
--- /dev/null
+++ b/sound/soc/aml/aml_dai.c
@@ -0,0 +1,308 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include <linux/of.h>
+
+static aml_dai_info_t dai_info[3] = {{0}};
+//#define AML_DAI_DEBUG
+
+#define AML_DAI_PCM_SUPPORT
+
+static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+
+static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	{
+		s->i2s_mode = dai_info[dai->id].i2s_mode;
+	}
+	return 0;
+}
+
+static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)//slave mode 
+		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
+	return 0;
+}
+
+static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#  define aml_dai_i2s_suspend	NULL
+#  define aml_dai_i2s_resume	NULL
+#endif /* CONFIG_PM */
+
+#ifdef AML_DAI_PCM_SUPPORT
+
+static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+
+static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)
+	snd_soc_dai_get_drvdata(dai);		
+	return 0;
+}
+
+static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#  define aml_dai_pcm_suspend	NULL
+#  define aml_dai_pcm_resume	NULL
+#endif /* CONFIG_PM */
+
+#endif
+
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_96000)
+#define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+#ifdef AML_DAI_PCM_SUPPORT
+#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
+#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#endif
+
+static struct snd_soc_dai_ops aml_dai_i2s_ops = {
+	.startup	= aml_dai_i2s_startup,
+	.shutdown	= aml_dai_i2s_shutdown,
+	.prepare	= aml_dai_i2s_prepare,
+	.hw_params	= aml_dai_i2s_hw_params,
+	.set_fmt	= aml_dai_set_i2s_fmt,
+	.set_sysclk	= aml_dai_set_i2s_sysclk,
+};
+
+#ifdef AML_DAI_PCM_SUPPORT
+static struct snd_soc_dai_ops aml_dai_pcm_ops = {
+	.startup	= aml_dai_pcm_startup,
+	.shutdown	= aml_dai_pcm_shutdown,
+	.prepare	= aml_dai_pcm_prepare,
+	.hw_params	= aml_dai_pcm_hw_params,
+	.set_fmt	= aml_dai_set_pcm_fmt,
+	.set_sysclk	= aml_dai_set_pcm_sysclk,
+};
+#endif
+
+struct snd_soc_dai_driver aml_dai[] = {
+	{	.name = "aml-dai0",
+		.id = 0,
+		.suspend = aml_dai_i2s_suspend,
+		.resume = aml_dai_i2s_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = AML_DAI_I2S_RATES,
+			.formats = AML_DAI_I2S_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = AML_DAI_I2S_RATES,
+			.formats = AML_DAI_I2S_FORMATS,},
+		.ops = &aml_dai_i2s_ops,
+	},
+#ifdef AML_DAI_PCM_SUPPORT
+	{	.name = "aml-dai1",
+		.id = 1,
+		.suspend = aml_dai_pcm_suspend,
+		.resume = aml_dai_pcm_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.ops = &aml_dai_pcm_ops,
+	},
+#endif
+};
+
+EXPORT_SYMBOL_GPL(aml_dai);
+
+static int aml_dai_probe(struct platform_device *pdev)
+{
+	printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0
+	BUG_ON(pdev->id < 0);
+	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
+	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
+#else
+	return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
+#endif
+}
+
+static int aml_dai_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_dai(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-dai",
+	},
+	{},
+};
+#else
+#define amlogic_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_dai_driver = {
+	.driver = {
+		.name = "aml-dai",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_dai_dt_match,
+	},
+
+	.probe = aml_dai_probe,
+	.remove = aml_dai_remove,
+};
+
+static int __init aml_dai_modinit(void)
+{
+	return platform_driver_register(&aml_dai_driver);
+}
+module_init(aml_dai_modinit);
+
+static void __exit aml_dai_modexit(void)
+{
+	platform_driver_unregister(&aml_dai_driver);
+}
+module_exit(aml_dai_modexit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML DAI driver for ALSA");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_dai.h b/sound/soc/aml/aml_dai.h
new file mode 100644
index 000000000000..332f1da65d9d
--- /dev/null
+++ b/sound/soc/aml/aml_dai.h
@@ -0,0 +1,6 @@
+#ifndef AML_DAI_H
+#define AML_DAI_H
+
+extern struct snd_soc_dai_driver aml_dai[];
+
+#endif
diff --git a/sound/soc/aml/aml_m1.c b/sound/soc/aml/aml_m1.c
new file mode 100644
index 000000000000..8e362d34876d
--- /dev/null
+++ b/sound/soc/aml/aml_m1.c
@@ -0,0 +1,156 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_m1_codec.h"
+
+	
+static int aml_m1_set_bias_level(struct snd_soc_card *card,
+					enum snd_soc_bias_level level)
+{
+	int ret = 0;
+    //struct snd_soc_codec *codec = card->codec;
+    switch(level){
+      case SND_SOC_BIAS_ON:
+      case SND_SOC_BIAS_PREPARE:
+        break;
+      case SND_SOC_BIAS_OFF:
+      case SND_SOC_BIAS_STANDBY:
+        break;
+    }
+	return ret;
+}
+
+static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_LINE("HP", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+    {"Ext Spk", NULL, "LINEOUTL"},
+    {"Ext Spk", NULL, "LINEOUTR"},
+    {"HP", NULL, "HP_L"},
+    {"HP", NULL, "HP_R"},
+};
+
+static int aml_m1_codec_init(struct snd_soc_codec *codec)
+{
+    struct snd_soc_card *card = codec->socdev->card;
+    int err;
+    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
+    if(err){
+      dev_warn(card->dev, "Failed to register DAPM widgets\n");
+      return 0;
+    }
+    err = snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
+    if(err){
+      dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
+      return 0;
+    }
+    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+    snd_soc_dapm_enable_pin(codec, "HP");
+    snd_soc_dapm_sync(codec);
+	return 0;
+}
+
+
+static struct snd_soc_dai_link aml_m1_dai = {
+	.name = "AML-M1",
+	.stream_name = "AML M1 PCM",
+	.cpu_dai = &aml_dai[0],  //////
+	.codec_dai = &aml_m1_codec_dai,
+	.init = aml_m1_codec_init,
+};
+
+static struct snd_soc_card snd_soc_aml_m1 = {
+	.name = "AML-M1",
+	.platform = &aml_soc_platform,
+	.dai_link = &aml_m1_dai,
+	.num_links = 1,
+	.set_bias_level = aml_m1_set_bias_level,
+};
+
+static struct snd_soc_device aml_m1_snd_devdata = {
+	.card = &snd_soc_aml_m1,
+	.codec_dev = &soc_codec_dev_aml_m1,
+};
+
+static struct platform_device *aml_m1_snd_device;
+static struct platform_device *aml_m1_platform_device;
+
+static int aml_m1_audio_probe(struct platform_device *pdev)
+{
+		int ret;
+		aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
+		if (!aml_m1_snd_device) {
+			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+			ret = -ENOMEM;
+		}
+	
+		platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
+		aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
+	
+		ret = platform_device_add(aml_m1_snd_device);
+		if (ret) {
+			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+			goto error;
+		}
+		
+		aml_m1_platform_device = platform_device_register_simple("aml_m1_codec",
+								-1, NULL, 0);
+		return 0;							
+error:								
+		platform_device_put(aml_m1_snd_device);								
+		return ret;
+}
+
+static int aml_m1_audio_remove(struct platform_device *pdev)
+{
+printk("***Entered %s:%s\n", __FILE__,__func__);
+		platform_device_unregister(aml_m1_snd_device);
+		return 0;
+}
+
+static struct platform_driver aml_m1_audio_driver = {
+	.probe  = aml_m1_audio_probe,
+	.remove = aml_m1_audio_remove,
+	.driver = {
+		.name = "aml_m1_audio",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init aml_m1_init(void)
+{
+		return platform_driver_register(&aml_m1_audio_driver);
+}
+
+static void __exit aml_m1_exit(void)
+{
+		platform_driver_unregister(&aml_m1_audio_driver);
+}
+
+module_init(aml_m1_init);
+module_exit(aml_m1_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_armdev_wm8900.c b/sound/soc/aml/aml_m1_armdev_wm8900.c
new file mode 100644
index 000000000000..fd4b41a6cd39
--- /dev/null
+++ b/sound/soc/aml/aml_m1_armdev_wm8900.c
@@ -0,0 +1,446 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "../codecs/wm8900.h"
+
+#define HP_DET	0//1
+
+#if HP_DET
+static struct timer_list timer;
+#endif
+
+static int aml_m1_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+		struct snd_soc_pcm_runtime *rtd = substream->private_data;
+		struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+		struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+		int ret;
+		// TODO
+printk("***Entered %s:%s\n", __FILE__,__func__);				
+		
+		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+		if(ret<0)
+			return ret;
+			
+		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+		if(ret<0)
+			return ret;
+		
+		
+	return 0;
+}
+	
+static struct snd_soc_ops aml_m1_ops = {
+	.hw_params = aml_m1_hw_params,
+};
+
+static int aml_m1_set_bias_level(struct snd_soc_card *card,
+					enum snd_soc_bias_level level)
+{
+	int ret = 0;
+	// TODO
+printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+#if HP_DET		
+		del_timer_sync(&timer);
+		timer.expires = jiffies + HZ*1;
+		del_timer(&timer);
+		add_timer(&timer);
+#endif		
+		break;
+	case SND_SOC_BIAS_OFF:
+	case SND_SOC_BIAS_STANDBY:
+#if HP_DET		
+		del_timer(&timer);
+#endif		
+		break;
+	};
+	
+	return ret;
+}
+
+static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("AVout Jack", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Headphone Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+
+	/* speaker connected to LINEOUT */
+	{"AVout Jack", NULL, "LINEOUT1L"},
+	{"AVout Jack", NULL, "LINEOUT1R"},
+	
+	{"Headphone Jack", NULL, "HP_L"},
+	{"Headphone Jack", NULL, "HP_R"},
+	
+	/* input */
+/*
+	{"RINPUT2", NULL, "Mic Bias"},
+	{"LINPUT2", NULL, "Headphone Mic"},
+	{"Mic Bias", NULL, "Headphone Mic"},	
+*/	
+};
+
+#if HP_DET
+
+/* Hook switch */
+
+static struct snd_soc_jack hp_jack;
+
+static struct snd_soc_jack_pin hp_jack_pins[] = {
+	{ .pin = "Headphone Jack", .mask = SND_JACK_HEADSET },
+};
+
+static struct snd_soc_jack av_jack;
+
+static struct snd_soc_jack_pin av_jack_pins[] = {
+	{ .pin = "AVout Jack", .mask = SND_JACK_AVOUT },
+};
+
+// use LED_CS1 as detect pin
+
+/*
+ * inner_cs_input_level
+ * VGHL B/LCS0/1.
+ * : AML8726-M_DEV_BOARD 2010-10-11_V1.0
+ * P4(VGHL_CS0/1)   T2(LED_CS1)  T1(LED_CS0)
+ * 0.7V0.4V
+ * 
+ * 
+       level[12]  <-->  VGHL_CS1
+       level[ 8]  <-->  VGHL_CS0
+       level[ 4]  <-->  LED_CS1
+       level[ 0]  <-->  LED_CS0
+ */
+#define PWM_TCNT        (600-1)
+#define PWM_MAX_VAL    (420)
+ 
+static unsigned int inner_cs_input_level()
+{
+		unsigned int level = 0;
+    unsigned int cs_no = 0;
+    //pin64 LED_CS0
+    CLEAR_CBUS_REG_MASK(PERIPHS_PIN_MUX_0, (3<<21));
+    // Enable VBG_EN
+    WRITE_CBUS_REG_BITS(PREG_AM_ANALOG_ADDR, 1, 0, 1);
+    // pin mux 
+    // wire            pm_gpioA_7_led_pwm          = pin_mux_reg0[22];
+    WRITE_CBUS_REG(LED_PWM_REG0, 0);
+    WRITE_CBUS_REG(LED_PWM_REG1, 0);
+    WRITE_CBUS_REG(LED_PWM_REG2, 0);
+    WRITE_CBUS_REG(LED_PWM_REG3, 0);
+    WRITE_CBUS_REG(LED_PWM_REG4, 0);
+    WRITE_CBUS_REG(LED_PWM_REG0,  (0 << 31)           |       // disable the overall circuit
+                            (0 << 30)           |       // 1:Closed Loop  0:Open Loop
+                            (PWM_TCNT << 16)    |       // PWM total count
+                            (0 << 13)           |       // Enable
+                            (1 << 12)           |       // enable
+                            (0 << 10)           |       // test
+                            (7 << 7)            |       // CS0 REF, Voltage FeedBack: about 0.505V
+                            (7 << 4)            |       // CS1 REF, Current FeedBack: about 0.505V
+                            (0 << 0)                   // DIMCTL Analog dimmer
+                      );
+     WRITE_CBUS_REG(LED_PWM_REG1,   (1 << 30)           |       // enable high frequency clock
+                            (PWM_MAX_VAL << 16) |       // MAX PWM value
+                            (0  << 0)                  // MIN PWM value
+                      );
+     WRITE_CBUS_REG(LED_PWM_REG2,    (0 << 31)       |       // disable timeout test mode
+                            (0 << 30)       |       // timeout based on the comparator output
+                            (0 << 16)       |       // timeout = 10uS
+                            (0 << 13)       |       // Select oscillator as the clock (just for grins)
+                            (1 << 11)       |       // 1:Enable OverCurrent Portection  0:Disable
+                            (3 << 8)        |       // Filter: shift every 3 ticks
+                            (0 << 6)        |       // Filter: count 1uS ticks
+                            (0 << 5)        |       // PWM polarity : negative
+                            (0 << 4)        |       // comparator: negative, Different with NikeD3
+                            (1 << 0)               // +/- 1
+                      );
+    WRITE_CBUS_REG(LED_PWM_REG3,  (   1 << 16) |    // Feedback down-sampling = PWM_freq/1 = PWM_freq
+                          (   1 << 14) |    // enable to re-write MATCH_VAL
+                          (   210 <<  0)   // preset PWM_duty = 50%
+                      );
+    WRITE_CBUS_REG(LED_PWM_REG4,  (   0 << 30) |    // 1:Digital Dimmer  0:Analog Dimmer
+                          (   2 << 28) |    // dimmer_timebase = 1uS
+                          (1000 << 14) |    // Digital dimmer_duty = 0%, the most darkness
+                          (1000 <<  0)     // dimmer_freq = 1KHz
+                      );
+    cs_no = READ_CBUS_REG(LED_PWM_REG3);
+    
+    if(cs_no &(1<<14))
+      level |= (1<<0);
+    if(cs_no &(1<<15))
+      level |= (1<<4);
+      
+    WRITE_CBUS_REG(VGHL_PWM_REG0, 0);
+    WRITE_CBUS_REG(VGHL_PWM_REG1, 0);
+    WRITE_CBUS_REG(VGHL_PWM_REG2, 0);
+    WRITE_CBUS_REG(VGHL_PWM_REG3, 0);
+    WRITE_CBUS_REG(VGHL_PWM_REG4, 0);
+    WRITE_CBUS_REG(VGHL_PWM_REG0, (0 << 31)           |       // disable the overall circuit
+                            (0 << 30)           |       // 1:Closed Loop  0:Open Loop
+                            (PWM_TCNT << 16)    |       // PWM total count
+                            (0 << 13)           |       // Enable
+                            (1 << 12)           |       // enable
+                            (0 << 10)           |       // test
+                            (7 << 7)            |       // CS0 REF, Voltage FeedBack: about 0.505V
+                            (7 << 4)            |       // CS1 REF, Current FeedBack: about 0.505V
+                            (0 << 0)                   // DIMCTL Analog dimmer
+                       );
+     WRITE_CBUS_REG(VGHL_PWM_REG1,   (1 << 30)           |       // enable high frequency clock
+                            (PWM_MAX_VAL << 16) |       // MAX PWM value
+                            (0  << 0)                  // MIN PWM value
+                       );
+     WRITE_CBUS_REG(VGHL_PWM_REG2,   (0 << 31)       |       // disable timeout test mode
+                            (0 << 30)       |       // timeout based on the comparator output
+                            (0 << 16)       |       // timeout = 10uS
+                            (0 << 13)       |       // Select oscillator as the clock (just for grins)
+                            (1 << 11)       |       // 1:Enable OverCurrent Portection  0:Disable
+                            (3 << 8)        |       // Filter: shift every 3 ticks
+                            (0 << 6)        |       // Filter: count 1uS ticks
+                            (0 << 5)        |       // PWM polarity : negative
+                            (0 << 4)        |       // comparator: negative, Different with NikeD3
+                            (1 << 0)               // +/- 1
+                       );
+    WRITE_CBUS_REG (VGHL_PWM_REG3,  (   1 << 16) |    // Feedback down-sampling = PWM_freq/1 = PWM_freq
+                          (   1 << 14) |    // enable to re-write MATCH_VAL
+                          (   210 <<  0)   // preset PWM_duty = 50%
+                       );
+    WRITE_CBUS_REG(VGHL_PWM_REG4,  (   0 << 30) |    // 1:Digital Dimmer  0:Analog Dimmer
+                          (   2 << 28) |    // dimmer_timebase = 1uS
+                          (1000 << 14) |    // Digital dimmer_duty = 0%, the most darkness
+                          (1000 <<  0)     // dimmer_freq = 1KHz
+                       );
+    cs_no = READ_CBUS_REG(VGHL_PWM_REG3);
+    
+    if(cs_no &(1<<14))
+      level |= (1<<8);
+    if(cs_no &(1<<15))
+      level |= (1<<12);
+
+    return level;
+}
+
+static int hp_detect_flag = 0;
+static spinlock_t lock;
+static void wm8900_hp_detect_queue(struct work_struct*);
+static struct wm8900_work_t{
+   unsigned long data;
+   struct work_struct wm8900_workqueue;
+}wm8900_work;
+
+static void wm8900_hp_detect_queue(struct work_struct* work)
+{
+	int level = inner_cs_input_level();
+	struct wm8900_work_t* pwork = container_of(work,struct wm8900_work_t, wm8900_workqueue);
+	struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
+		
+		if(level == 0x1 && hp_detect_flag!= 0x1){	// HP
+			snd_soc_dapm_disable_pin(codec, "AVout Jack");
+	   		snd_soc_dapm_sync(codec);
+			snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
+			hp_detect_flag = 0x1;
+		}else if(level == 0x10 && hp_detect_flag != 0x10){	// AV
+			
+			snd_soc_jack_report(&av_jack, SND_JACK_AVOUT, SND_JACK_AVOUT);
+			hp_detect_flag = 0x10;
+		}else if(level != hp_detect_flag){	// HDMI
+			snd_soc_dapm_disable_pin(codec, "AVout Jack");
+			snd_soc_dapm_disable_pin(codec, "Headphone Jack");
+	   		snd_soc_dapm_sync(codec);
+			hp_detect_flag = level;
+		}
+}
+
+static void wm8900_hp_detect_timer(unsigned long data)
+{
+		struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
+		wm8900_work.data = (unsigned long)codec;
+		schedule_work(&wm8900_work.wm8900_workqueue);
+		mod_timer(&timer, jiffies + HZ*1);
+}
+
+#endif
+
+static int aml_m1_codec_init(struct snd_soc_codec *codec)
+{
+		struct snd_soc_dai *codec_dai = codec->dai;
+		struct snd_soc_card *card = codec->socdev->card;
+	
+		int err;
+ 
+		//Add board specific DAPM widgets and routes
+		err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
+		if(err){
+			dev_warn(card->dev, "Failed to register DAPM widgets\n");
+			return 0;
+		}
+		
+		err = snd_soc_dapm_add_routes(codec, intercon,
+				      ARRAY_SIZE(intercon));
+		if(err){
+			dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
+			return 0;
+		}
+		
+		//hook switch
+#if HP_DET
+		hp_detect_flag = 0;
+				
+		err = snd_soc_jack_new(card, "hp_switch",
+				SND_JACK_HEADSET, &hp_jack);
+		if(err){
+			dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
+		}else{
+				err = snd_soc_jack_add_pins(&hp_jack,
+						ARRAY_SIZE(hp_jack_pins),
+						hp_jack_pins);
+				if(err){
+						dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
+				}
+		}
+		
+		err =	snd_soc_jack_new(card, "av_switch",
+				SND_JACK_HEADSET, &av_jack);
+		if(err){
+				dev_warn(card->dev, "Failed to alloc resource for av hook switch\n");
+		}else{		
+			err = snd_soc_jack_add_pins(&av_jack,
+						ARRAY_SIZE(av_jack_pins),
+						av_jack_pins);
+				if(err){
+						dev_warn(card->dev, "Failed to setup hook av jack pin\n");
+				}			
+		}		
+		// create a timer to poll the HP IN status
+		timer.function = &wm8900_hp_detect_timer;
+  	timer.data = (unsigned long)codec;
+  	timer.expires = jiffies + HZ*1;
+  	init_timer(&timer);
+#endif 
+		snd_soc_dapm_nc_pin(codec,"LINPUT1");
+		snd_soc_dapm_nc_pin(codec,"RINPUT1");
+		
+		snd_soc_dapm_enable_pin(codec, "AVout Jack");
+		snd_soc_dapm_disable_pin(codec, "Headphone Jack");
+		snd_soc_dapm_disable_pin(codec, "Headphone Mic");
+		
+		snd_soc_dapm_sync(codec);
+
+		return 0;
+}
+
+
+static struct snd_soc_dai_link aml_m1_dai = {
+	.name = "AML-M1",
+	.stream_name = "AML M1 PCM",
+	.cpu_dai = &aml_dai[0],  //////
+	.codec_dai = &wm8900_dai,
+	.init = aml_m1_codec_init,
+	.ops = &aml_m1_ops,
+};
+
+static struct snd_soc_card snd_soc_aml_m1 = {
+	.name = "AML-M1",
+	.platform = &aml_soc_platform,
+	.dai_link = &aml_m1_dai,
+	.num_links = 1,
+	.set_bias_level = aml_m1_set_bias_level,
+};
+
+static struct snd_soc_device aml_m1_snd_devdata = {
+	.card = &snd_soc_aml_m1,
+	.codec_dev = &soc_codec_dev_wm8900,
+};
+
+static struct platform_device *aml_m1_snd_device;
+static struct platform_device *aml_m1_platform_device;
+
+static int aml_m1_audio_probe(struct platform_device *pdev)
+{
+		int ret;
+		//pdev->dev.platform_data;
+		// TODO
+printk("***Entered %s:%s\n", __FILE__,__func__);
+		aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
+		if (!aml_m1_snd_device) {
+			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+			ret = -ENOMEM;
+		}
+	
+		platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
+		aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
+	
+		ret = platform_device_add(aml_m1_snd_device);
+		if (ret) {
+			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+			goto error;
+		}
+		
+		aml_m1_platform_device = platform_device_register_simple("aml_m1_codec",
+								-1, NULL, 0);
+		return 0;							
+error:								
+		platform_device_put(aml_m1_snd_device);								
+		return ret;
+}
+
+static int aml_m1_audio_remove(struct platform_device *pdev)
+{
+printk("***Entered %s:%s\n", __FILE__,__func__);
+
+#if HP_DET		
+		del_timer_sync(&timer);
+#endif
+		platform_device_unregister(aml_m1_snd_device);
+		return 0;
+}
+
+static struct platform_driver aml_m1_audio_driver = {
+	.probe  = aml_m1_audio_probe,
+	.remove = aml_m1_audio_remove,
+	.driver = {
+		.name = "aml_m1_audio_wm8900",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init aml_m1_init(void)
+{
+		return platform_driver_register(&aml_m1_audio_driver);
+}
+
+static void __exit aml_m1_exit(void)
+{
+		platform_driver_unregister(&aml_m1_audio_driver);
+}
+
+module_init(aml_m1_init);
+module_exit(aml_m1_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_codec.c b/sound/soc/aml/aml_m1_codec.c
new file mode 100644
index 000000000000..4faedebe297c
--- /dev/null
+++ b/sound/soc/aml/aml_m1_codec.c
@@ -0,0 +1,509 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <mach/am_regs.h>
+#include "aml_audio_hw.h"
+
+#define APB_BASE	0x5000
+
+#define ADAC_RESET                		0x00
+#define ADAC_LATCH                		0x01
+#define ADAC_CLOCK                		0x02
+// 0x03-0x0b  reserved
+#define ADAC_I2S_CONFIG_REG1      		0x0c
+#define ADAC_I2S_CONFIG_REG2      		0x0d
+// 0x0e - 0x0f reserved
+#define ADAC_POWER_CTRL_REG1      		0x10
+#define ADAC_POWER_CTRL_REG2      		0x11
+#define ADAC_POWER_CTRL_REG3      		0x12
+// 0x13-0x17 reserved
+#define ADAC_MUTE_CTRL_REG1       		0x18
+#define ADAC_MUTE_CTRL_REG2						0x19
+#define ADAC_DAC_ADC_MIXER        		0x1a
+// 0x1b-0x1f reserved
+#define ADAC_PLAYBACK_VOL_CTRL_LSB              0x20
+#define ADAC_PLAYBACK_VOL_CTRL_MSB              0x21
+#define ADAC_STEREO_HS_VOL_CTRL_LSB             0x22
+#define ADAC_STEREO_HS_VOL_CTRL_MSB             0x23
+
+#define ADAC_MAXREG	0x24
+
+struct snd_soc_codec_device soc_codec_dev_aml_m1;
+static struct snd_soc_codec *aml_m1_codec;
+
+/* codec private data */
+struct aml_m1_codec_priv {
+	struct snd_soc_codec codec;
+	u16 reg_cache[ADAC_MAXREG];
+	unsigned int sysclk;
+};
+
+void latch (struct snd_soc_codec* codec)
+{
+    int latch;
+    latch = 1;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+    latch = 0;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+}
+
+void aml_m1_reset(struct snd_soc_codec* codec, bool first_time)
+{
+	unsigned long   data32;
+    if(first_time){
+      /* initialize clock for audiodac */
+	  audio_set_clk(AUDIO_CLK_FREQ_48,0);
+      /* power up pll */
+  	  WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));
+      /* enable audiodac clock */
+	  WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 23, 1); 
+      msleep(100);
+      
+	  data32  = 0;
+      data32 |= 0 << 15;  // [15]  audac_soft_reset_n
+      data32 |= 0 << 14;  // [14]  audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
+      data32 |= 0 << 9;   // [9]   delay_rd_en
+      data32 |= 0 << 8;   // [8]   audac_reg_clk_inv
+      data32 |= 0 << 1;   // [7:1] audac_i2caddr
+      data32 |= 0 << 0;   // [0]   audac_intfsel: 0=use host bus; 1=use I2C.
+      WRITE_MPEG_REG(AIU_AUDAC_CTRL0, data32);
+      // Enable APB3 fail on error
+      data32  = 0;
+      data32 |= 1     << 15;  // [15]     err_en
+      data32 |= 255   << 0;   // [11:0]   max_err
+      WRITE_MPEG_REG(AIU_AUDAC_CTRL1, data32);
+	
+      snd_soc_write(codec, ADAC_RESET, (0<<1));
+      snd_soc_write(codec, ADAC_RESET, (0<<1));
+	  snd_soc_write(codec, ADAC_RESET, (0<<1));
+	  snd_soc_write(codec, ADAC_RESET, (0<<1));
+	  snd_soc_write(codec, ADAC_RESET, (0<<1));
+	  msleep(100);
+	  snd_soc_write(codec,ADAC_CLOCK, 0);
+	  snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, 6);	
+	  snd_soc_write(codec, ADAC_I2S_CONFIG_REG2, 1|(1<<3)); 		// I2S, split
+	
+	  snd_soc_write(codec, ADAC_POWER_CTRL_REG1, 0xc3);
+	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0);
+	  snd_soc_write(codec, ADAC_MUTE_CTRL_REG1,0);
+	  snd_soc_write(codec,ADAC_DAC_ADC_MIXER, 0);
+      snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_LSB, 0x54);
+      snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_MSB, 0x54);
+      snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_LSB, 0x28);
+      snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_MSB, 0x28); 
+
+      latch(codec);
+	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (0<<7));
+      latch(codec);
+	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (1<<7));
+      latch(codec);
+    }else{
+ 
+      latch(codec);
+	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (0<<7));
+      latch(codec);
+	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (1<<7));
+      latch(codec);
+    }
+  
+	snd_soc_write(codec, ADAC_RESET, (0<<1));
+    latch(codec);
+	snd_soc_write(codec, ADAC_RESET, (1<<1));
+    latch(codec);
+    msleep(100);
+}
+
+
+static const DECLARE_TLV_DB_SCALE(dac_volume, -12600, 150, 0);
+static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
+
+static const struct snd_kcontrol_new amlm1_snd_controls[] = {
+	SOC_DOUBLE_R_TLV("Master Playback Volume", ADAC_PLAYBACK_VOL_CTRL_LSB, ADAC_PLAYBACK_VOL_CTRL_MSB,
+	       0, 84, 0, dac_volume),
+	      
+	SOC_DOUBLE_R_TLV("HeadSet Driver Volume", ADAC_STEREO_HS_VOL_CTRL_LSB, ADAC_STEREO_HS_VOL_CTRL_MSB,
+	       0, 46, 0, hs_volume),
+
+    SOC_DOUBLE("Loud Speaker Mute", ADAC_MUTE_CTRL_REG1, 0, 1, 1, 0),
+    SOC_DOUBLE("Head Set Mute", ADAC_MUTE_CTRL_REG1, 6, 7, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget amlm1_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+	SND_SOC_DAPM_OUTPUT("HP_L"),
+	SND_SOC_DAPM_OUTPUT("HP_R"),
+	
+	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
+	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
+	
+	SND_SOC_DAPM_PGA("HeadSet Switch Left", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HeadSet Switch Right", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
+};
+
+/* Target, Path, Source */
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	{"LINEOUTL", NULL, "DACL"},
+	{"LINEOUTR", NULL, "DACR"},
+	{"HP_L", NULL, "HeadSet Switch Left"},
+	{"HP_R", NULL, "HeadSet Switch Right"},
+    {"HeadSet Switch Left", NULL, "DACL"},    
+    {"HeadSet Switch Right", NULL, "DACR"},
+};
+
+static int amlm1_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, amlm1_dapm_widgets,
+				  ARRAY_SIZE(amlm1_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	return 0;
+}
+static int aml_m1_volatile_register(unsigned int reg)
+{
+	return 0;
+}
+static int aml_m1_write(struct snd_soc_codec *codec, unsigned int reg,
+							unsigned int value)
+{
+	u16 *reg_cache = codec->reg_cache;
+
+	if (reg >= codec->reg_cache_size)
+		return -EINVAL;
+	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
+	reg_cache[reg] = value;
+	return 0;
+}
+
+static unsigned int aml_m1_read(struct snd_soc_codec *codec,
+							unsigned int reg)
+{
+	return READ_APB_REG(APB_BASE+(reg<<2));
+}
+
+static int aml_m1_codec_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	//struct aml_m1_codec_priv *aml = codec->private_data;
+    u16 reg, val;
+    
+    switch(params_rate(params)){
+      case 8000:    val=0;  break;
+      case 11025:   val=1;  break;
+      case 12000:   val=2;  break;
+      case 16000:   val=3;  break;
+      case 22050:   val=4;  break;
+      case 24000:   val=5;  break;
+      case 32000:   val=6;  break;
+      case 44100:   val=7;  break;
+      case 48000:   val=8;  break;
+      case 88200:   val=9;  break;
+      case 96000:   val=10; break;
+      case 19200:   val=11; break;
+      default:  val=8; break;
+    }
+    reg = snd_soc_read(codec, ADAC_I2S_CONFIG_REG1);
+    reg &= ~0xf;
+    reg |= val;
+    snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, reg);
+
+    snd_soc_write(codec, ADAC_RESET, (0<<1));
+    latch(codec);
+	snd_soc_write(codec, ADAC_RESET, (1<<1));
+    latch(codec);
+
+	return 0;
+}
+
+static int aml_m1_codec_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 reg;
+
+	reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
+	if(mute){
+		reg |= 3|(3<<6);    /* mute hs and ls*/
+	}
+	else{
+		reg &= ~(3|(3<<6));
+	}
+	snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg);
+
+	snd_soc_write(codec, ADAC_RESET, (0<<1));
+    latch(codec);
+	snd_soc_write(codec, ADAC_RESET, (1<<1));
+    latch(codec);
+
+	return 0;
+}
+
+
+#define AML_RATES SNDRV_PCM_RATE_8000_96000
+
+#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+
+static struct snd_soc_dai_ops aml_m1_codec_dai_ops = {
+	.hw_params	= aml_m1_codec_hw_params,
+	.digital_mute	= aml_m1_codec_mute,
+};
+
+struct snd_soc_dai aml_m1_codec_dai = {
+	.name = "AML-M1",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.ops = &aml_m1_codec_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL_GPL(aml_m1_codec_dai);
+
+static int aml_m1_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+        aml_m1_reset(codec, false);
+		break;
+    case SND_SOC_BIAS_PREPARE:
+        break;
+	case SND_SOC_BIAS_STANDBY:
+   	case SND_SOC_BIAS_OFF:
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
+	    break;
+	default:
+	    break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+static int aml_m1_codec_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	if (!aml_m1_codec) {
+		dev_err(&pdev->dev, "AML_M1_CODEC not yet discovered\n");
+		return -ENODEV;
+	}
+	codec = aml_m1_codec;			
+	socdev->card->codec = codec;	
+	
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		kfree(codec);
+		dev_err(codec->dev, "aml m1 codec: failed to create pcms: %d\n", ret);
+		goto pcm_err;
+	}
+	
+    snd_soc_add_controls(codec, amlm1_snd_controls,
+				ARRAY_SIZE(amlm1_snd_controls));
+	amlm1_add_widgets(codec);
+pcm_err:
+
+	return 0;
+}
+
+
+static int aml_m1_codec_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+//	struct snd_soc_codec *codec = socdev->card->codec;
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_m1_codec_suspend(struct platform_device* pdev)
+{
+	if (!aml_m1_codec) {
+		dev_err(&pdev->dev, "AML_M1_CODEC not yet discovered\n");
+		return -ENODEV;
+	}
+	struct snd_soc_codec *codec;
+    codec = aml_m1_codec;
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
+    return 0;
+}
+
+static int aml_m1_codec_resume(struct platform_device* pdev)
+{
+	if (!aml_m1_codec) {
+		dev_err(&pdev->dev, "AML_M1_CODEC not yet discovered\n");
+		return -ENODEV;
+	}
+	struct snd_soc_codec *codec;
+    codec = aml_m1_codec;
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 1<<7);
+    return 0;
+}
+#endif
+
+struct snd_soc_codec_device soc_codec_dev_aml_m1 = {
+	.probe =	aml_m1_codec_probe,
+	.remove =	aml_m1_codec_remove,
+#ifdef CONFIG_PM	
+	.suspend = aml_m1_codec_suspend,
+	.resume = aml_m1_codec_resume,
+#else
+	.suspend = NULL,
+	.resume = NULL,
+#endif
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_aml_m1);
+
+static int aml_m1_register(struct aml_m1_codec_priv* aml_m1)
+{
+	struct snd_soc_codec* codec = &aml_m1->codec;
+	int ret;
+		
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	codec->name = "AML_M1_CODEC";
+	codec->owner = THIS_MODULE;
+	codec->private_data = aml_m1;
+
+	codec->dai = &aml_m1_codec_dai;
+	codec->num_dai = 1;
+
+	codec->reg_cache = &aml_m1->reg_cache;
+	codec->reg_cache_size = ARRAY_SIZE(aml_m1->reg_cache);
+	codec->read = aml_m1_read;
+	codec->write = aml_m1_write;
+	codec->volatile_register = aml_m1_volatile_register;
+	
+	codec->bias_level = SND_SOC_BIAS_OFF;
+	codec->set_bias_level = aml_m1_set_bias_level;
+	aml_m1_codec_dai.dev = codec->dev;
+	aml_m1_reset(codec, true);
+
+	aml_m1_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	aml_m1_codec = codec;
+
+	ret = snd_soc_register_codec(codec);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
+		goto err;
+	}
+
+	ret = snd_soc_register_dai(&aml_m1_codec_dai);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register DAI: %d\n", ret);
+		goto err_codec;
+	}
+
+	return 0;
+
+err_codec:
+	snd_soc_unregister_codec(codec);
+err:
+	aml_m1_codec = NULL;
+	kfree(aml_m1);
+	return ret;
+		
+}
+
+static void aml_m1_unregister(struct aml_m1_codec_priv *aml_m1)
+{
+	snd_soc_unregister_dai(&aml_m1_codec_dai);
+	snd_soc_unregister_codec(&aml_m1->codec);
+	aml_m1_codec = NULL;
+	kfree(aml_m1);
+}
+
+static int aml_m1_codec_platform_probe(struct platform_device *pdev)
+{
+	struct aml_m1_codec_priv *aml_m1;
+	struct snd_soc_codec *codec;
+
+	aml_m1 = kzalloc(sizeof(struct aml_m1_codec_priv), GFP_KERNEL);
+	if (aml_m1 == NULL)
+		return -ENOMEM;
+
+	codec = &aml_m1->codec;
+
+	codec->control_data = NULL;
+	codec->hw_write = NULL;
+	codec->pop_time = 0;
+
+	codec->dev = &pdev->dev;
+	platform_set_drvdata(pdev, aml_m1);
+
+	return aml_m1_register(aml_m1);
+}
+
+static int __exit aml_m1_codec_platform_remove(struct platform_device *pdev)
+{
+	struct aml_m1_codec_priv *aml_m1 = platform_get_drvdata(pdev);
+
+	aml_m1_unregister(aml_m1);
+	return 0;
+}
+
+static struct platform_driver aml_m1_codec_platform_driver = {
+	.driver = {
+		.name = "aml_m1_codec",
+		.owner = THIS_MODULE,
+		},
+	.probe = aml_m1_codec_platform_probe,
+	.remove = __exit_p(aml_m1_codec_platform_remove),
+};
+
+static int __init aml_m1_codec_modinit(void)
+{
+        printk("****%s %d*****", __func__, __LINE__);
+		return platform_driver_register(&aml_m1_codec_platform_driver);
+}
+
+static void __exit aml_m1_codec_exit(void)
+{
+		platform_driver_unregister(&aml_m1_codec_platform_driver);
+}
+
+module_init(aml_m1_codec_modinit);
+module_exit(aml_m1_codec_exit);
+
+
+MODULE_DESCRIPTION("ASoC AML M1 codec driver");
+MODULE_AUTHOR("AMLogic Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_codec.h b/sound/soc/aml/aml_m1_codec.h
new file mode 100644
index 000000000000..b2ac8bef007f
--- /dev/null
+++ b/sound/soc/aml/aml_m1_codec.h
@@ -0,0 +1,7 @@
+#ifndef _AML_M1_CODEC_H
+#define _AML_M1_CODEC_H
+
+extern struct snd_soc_dai aml_m1_codec_dai;
+extern struct snd_soc_codec_device soc_codec_dev_aml_m1;
+
+#endif
diff --git a/sound/soc/aml/aml_m1_mid_cs42l52.c b/sound/soc/aml/aml_m1_mid_cs42l52.c
new file mode 100644
index 000000000000..a56b8ac91ae0
--- /dev/null
+++ b/sound/soc/aml/aml_m1_mid_cs42l52.c
@@ -0,0 +1,340 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/cs42l52.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "../codecs/cs42l52.h"
+
+//#define HP_DET 1
+
+#if HP_DET
+static struct timer_list timer;
+static int hp_detect_flag = 0;
+void mute_spk(struct snd_soc_codec* codec, int flag);
+#endif
+
+static int aml_m1_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+    int ret;
+    // TODO
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+    if(ret<0)
+        return ret;
+
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+    if(ret<0)
+        return ret;
+
+    return 0;
+}
+    
+static struct snd_soc_ops aml_m1_ops = {
+    .hw_params = aml_m1_hw_params,
+};
+
+static int aml_m1_set_bias_level(struct snd_soc_card *card,
+    enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct snd_soc_codec *codec = card->codec;
+    // TODO
+    printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+    case SND_SOC_BIAS_PREPARE:
+#if HP_DET
+        del_timer_sync(&timer);
+        timer.expires = jiffies + HZ*5;
+        del_timer(&timer);
+        add_timer(&timer);
+        hp_detect_flag = 0xf0000000;
+#endif
+        break;
+    case SND_SOC_BIAS_OFF:
+    case SND_SOC_BIAS_STANDBY:
+#if HP_DET
+        del_timer(&timer);
+        hp_detect_flag = 0xf0000000;        
+        mute_spk(codec,1);
+#endif
+        break;
+    };
+
+    return ret;
+}
+
+static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MIC IN", NULL),
+    SND_SOC_DAPM_MIC("HP MIC", NULL),
+    SND_SOC_DAPM_LINE("FM IN", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+
+    /* speaker connected to LINEOUT */
+    {"Ext Spk", NULL, "LINEOUT1L"},
+    {"Ext Spk", NULL, "LINEOUT1R"},
+    /* mic is connected to Mic Jack, with WM8731 Mic Bias */
+    {"HP", NULL, "HP_L"},
+    {"HP", NULL, "HP_R"},
+    {"LINPUT2", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "MIC IN"},
+    {"RINPUT2", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "HP MIC"},
+    {"LINPUT3", NULL, "FM IN"},
+    {"RINPUT3", NULL, "FM IN"},
+};
+
+#if HP_DET
+
+/* Hook switch */
+
+static struct snd_soc_jack hp_jack;
+
+static struct snd_soc_jack_pin hp_jack_pins[] = {
+    { .pin = "HP", .mask = SND_JACK_HEADSET },
+};
+
+static spinlock_t lock;
+static void cs42l52_hp_detect_queue(struct work_struct*);
+static struct cs42l52_work_t{
+unsigned long data;
+struct work_struct cs42l52_workqueue;
+}cs42l52_work;
+
+void mute_spk(struct snd_soc_codec* codec, int flag)
+{
+    /*
+    int gpio_status = 0;
+    if(flag){
+        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
+        gpio_status &= ~(7<<4);
+        gpio_status |= (6<<4);
+        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
+    }else{
+        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
+        gpio_status &= ~(7<<4);
+        gpio_status |= (7<<4);
+        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
+    }
+    */
+}
+
+static void cs42l52_hp_detect_queue(struct work_struct* work)
+{
+    int level = 0x0;
+    struct cs42l52_work_t* pwork = container_of(work,struct cs42l52_work_t, cs42l52_workqueue);
+    struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
+
+    if ((soc_cs42l52_dai.ac97_pdata) && ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged)
+        level = ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged();
+
+    //printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
+    if(level == 0x1 && hp_detect_flag!= 0x1){ // HP
+        printk("Headphone pluged in\n");
+        snd_soc_dapm_disable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+        snd_soc_dapm_sync(codec);
+        // pull down the gpio to mute spk
+        mute_spk(codec, 1);
+        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
+        hp_detect_flag = level;
+    }else if(level != hp_detect_flag){ // HDMI
+        printk("Headphone unpluged\n");
+        snd_soc_dapm_enable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+        snd_soc_dapm_sync(codec);
+        snd_soc_jack_report(&hp_jack,0, SND_JACK_HEADSET);
+        hp_detect_flag = level;
+        mute_spk(codec, 0);
+    }
+}
+
+static void cs42l52_hp_detect_timer(unsigned long data)
+{
+    struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
+    cs42l52_work.data = (unsigned long)codec;
+    schedule_work(&cs42l52_work.cs42l52_workqueue);
+    mod_timer(&timer, jiffies + HZ*1);
+}
+
+#endif
+
+static int aml_m1_codec_init(struct snd_soc_codec *codec)
+{
+    struct snd_soc_card *card = codec->socdev->card;
+
+    int err;
+    //Add board specific DAPM widgets and routes
+    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
+    if(err){
+        dev_warn(card->dev, "Failed to register DAPM widgets\n");
+        return 0;
+    }
+
+    err = snd_soc_dapm_add_routes(codec, intercon,
+        ARRAY_SIZE(intercon));
+    if(err){
+        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
+        return 0;
+    }
+
+#if HP_DET
+    if ((soc_cs42l52_dai.ac97_pdata) && ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged)
+        hp_detect_flag = ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged() ? (0) : (1);
+    else
+        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
+
+    err = snd_soc_jack_new(card, "hp_switch",
+        SND_JACK_HEADSET, &hp_jack);
+    if(err){
+        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
+    }else{
+        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
+        if(err){
+            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
+        }
+    }
+
+    // create a timer to poll the HP IN status
+    spin_lock_init(&lock);
+    timer.function = &cs42l52_hp_detect_timer;
+    timer.data = (unsigned long)codec;
+    timer.expires = jiffies + HZ*10;
+    init_timer(&timer);
+    INIT_WORK(&cs42l52_work.cs42l52_workqueue, cs42l52_hp_detect_queue);
+#endif
+
+    snd_soc_dapm_nc_pin(codec,"LINPUT1");
+    snd_soc_dapm_nc_pin(codec,"RINPUT1");
+
+    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+    snd_soc_dapm_disable_pin(codec, "HP");
+    snd_soc_dapm_enable_pin(codec, "MIC IN");
+    snd_soc_dapm_disable_pin(codec, "HP MIC");
+    snd_soc_dapm_disable_pin(codec, "FM IN");
+
+    snd_soc_dapm_sync(codec);
+
+    return 0;
+}
+
+
+static struct snd_soc_dai_link aml_m1_dai = {
+    .name = "AML-M1",
+    .stream_name = "AML M1 PCM",
+    .cpu_dai = &aml_dai[0],  //////
+    .codec_dai = &soc_cs42l52_dai,
+    .init = aml_m1_codec_init,
+    .ops = &aml_m1_ops,
+};
+
+static struct snd_soc_card snd_soc_aml_m1 = {
+    .name = "AML-M1",
+    .platform = &aml_soc_platform,
+    .dai_link = &aml_m1_dai,
+    .num_links = 1,
+    .set_bias_level = aml_m1_set_bias_level,
+};
+
+static struct snd_soc_device aml_m1_snd_devdata = {
+    .card = &snd_soc_aml_m1,
+    .codec_dev = &soc_codec_cs42l52_dev,
+};
+
+static struct platform_device *aml_m1_snd_device;
+static struct platform_device *aml_m1_platform_device;
+
+static int aml_m1_audio_probe(struct platform_device *pdev)
+{
+    int ret;
+
+    // TODO
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+    aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!aml_m1_snd_device) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+    }
+
+    platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
+    aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
+
+    ret = platform_device_add(aml_m1_snd_device);
+    if (ret) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto error;
+    }
+
+    aml_m1_platform_device = platform_device_register_simple("aml_m1_codec", -1, NULL, 0);
+    return 0;
+error:
+    platform_device_put(aml_m1_snd_device);
+    return ret;
+}
+
+static int aml_m1_audio_remove(struct platform_device *pdev)
+{
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+#if HP_DET
+    del_timer_sync(&timer);
+    
+#endif
+    platform_device_unregister(aml_m1_snd_device);
+    return 0;
+}
+
+static struct platform_driver aml_m1_audio_driver = {
+    .probe  = aml_m1_audio_probe,
+    .remove = aml_m1_audio_remove,
+    .driver = {
+        .name = "aml_m1_audio_cs42l52",
+        .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m1_init(void)
+{
+    return platform_driver_register(&aml_m1_audio_driver);
+}
+
+static void __exit aml_m1_exit(void)
+{
+    platform_driver_unregister(&aml_m1_audio_driver);
+}
+
+module_init(aml_m1_init);
+module_exit(aml_m1_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/aml/aml_m1_mid_rt5621.c b/sound/soc/aml/aml_m1_mid_rt5621.c
new file mode 100644
index 000000000000..9807ea3b0699
--- /dev/null
+++ b/sound/soc/aml/aml_m1_mid_rt5621.c
@@ -0,0 +1,351 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/rt5621.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "../codecs/rt5621.h"
+
+#define HP_DET	1
+
+#if HP_DET
+static struct timer_list timer;
+#endif
+
+static int aml_m1_hw_params(struct snd_pcm_substream *substream,
+                            struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+    int ret;
+    // TODO
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+    if (ret<0)
+        return ret;
+
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+    if (ret<0)
+        return ret;
+
+    return 0;
+}
+
+static struct snd_soc_ops aml_m1_ops = {
+    .hw_params = aml_m1_hw_params,
+};
+
+static int aml_m1_set_bias_level(struct snd_soc_card *card,
+                                 enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct snd_soc_codec *codec = card->codec;
+    // TODO
+    printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+    case SND_SOC_BIAS_PREPARE:
+        #if HP_DET		
+		del_timer_sync(&timer);
+		timer.expires = jiffies + HZ*1;
+		del_timer(&timer);
+		add_timer(&timer);
+		switch_audio(0);
+       #endif
+        break;
+    case SND_SOC_BIAS_OFF:
+    case SND_SOC_BIAS_STANDBY:
+        #if HP_DET		
+		del_timer(&timer);
+		switch_audio(1);
+        #endif
+        break;
+    };
+
+    return ret;
+}
+
+static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MIC IN", NULL),
+    SND_SOC_DAPM_MIC("HP MIC", NULL),
+    SND_SOC_DAPM_LINE("FM IN", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+
+    /* speaker connected to LINEOUT */
+    {"Ext Spk", NULL, "LINEOUT1L"},
+    {"Ext Spk", NULL, "LINEOUT1R"},
+    /* mic is connected to Mic Jack, with WM8731 Mic Bias */
+    {"HP", NULL, "HP_L"},
+    {"HP", NULL, "HP_R"},
+    {"LINPUT2", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "MIC IN"},
+    {"RINPUT2", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "HP MIC"},
+    {"LINPUT3", NULL, "FM IN"},
+    {"RINPUT3", NULL, "FM IN"},
+};
+
+#if HP_DET
+
+/* Hook switch */
+
+static struct snd_soc_jack hp_jack;
+
+static struct snd_soc_jack_pin hp_jack_pins[] = {
+	{ .pin = "HP", .mask = SND_JACK_HEADSET },
+};
+
+static int hp_detect_flag = 0x0;
+static spinlock_t lock;
+static void rt5621_hp_detect_queue(struct work_struct*);
+static struct rt5621_work_t{
+   unsigned long data;
+   struct work_struct rt5621_workqueue;
+}rt5621_work;
+
+static void rt5621_hp_detect_queue(struct work_struct* work)
+{
+    int level = 0x0;
+	struct rt5621_work_t* pwork = container_of(work,struct rt5621_work_t, rt5621_workqueue);
+	struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
+
+    if ((rt5621_dai.ac97_pdata) && ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged)
+        level = ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged();
+
+    //printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
+    if(level == 0x1 && hp_detect_flag!= 0x1){ // HP OUT
+        printk("Headphone pluged in\n");
+	    snd_soc_dapm_disable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+	    snd_soc_dapm_sync(codec);
+	    // pull down the gpio to mute spk
+	    switch_audio(1);
+        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
+        hp_detect_flag = level;
+    }else if(level != hp_detect_flag){ // AUX OUT
+        printk("Headphone unpluged\n");
+	    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+	    snd_soc_dapm_sync(codec);
+        snd_soc_jack_report(&hp_jack, 0, SND_JACK_HEADSET);
+        hp_detect_flag = level;
+	    switch_audio(0);
+    } 
+}
+
+static void rt5621_hp_detect_timer(unsigned long data)
+{
+	struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
+	rt5621_work.data = (unsigned long)codec;
+	schedule_work(&rt5621_work.rt5621_workqueue);
+	mod_timer(&timer, jiffies + HZ*1);
+}
+
+#endif
+static int Init_Aux_Hp(struct snd_soc_codec *codec)
+{
+    if (hp_detect_flag==1){
+    	printk("Init: Headphone has been pluged\n");
+	    snd_soc_dapm_disable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+	    snd_soc_dapm_sync(codec);
+	    // pull down the gpio to mute spk
+	    switch_audio(1);
+        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
+    }else if(hp_detect_flag==0){
+    	printk("Init: Headphone has been unpluged\n");
+	    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+	    snd_soc_dapm_sync(codec);
+        snd_soc_jack_report(&hp_jack, 0, SND_JACK_HEADSET);
+	    switch_audio(0);
+    }
+}
+static int aml_m1_codec_init(struct snd_soc_codec *codec)
+{
+    struct snd_soc_card *card = codec->socdev->card;
+
+    int err;
+
+    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
+    if(err){
+	    dev_warn(card->dev, "Failed to register DAPM widgets\n");
+		return 0;
+	}
+/*
+    err = snd_soc_dapm_add_routes(codec, intercon,
+        ARRAY_SIZE(intercon));
+    if(err){
+        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
+        return 0;
+    }
+*/
+
+#if HP_DET
+    if ((rt5621_dai.ac97_pdata) && ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged)
+        hp_detect_flag = ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged() ? (0) : (1);
+    else
+        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
+
+    err = snd_soc_jack_new(card, "hp_switch",
+        SND_JACK_HEADSET, &hp_jack);
+    if(err){
+        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
+    }else{
+        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
+        if(err){
+            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
+        }
+    }
+
+    // create a timer to poll the HP IN status
+    spin_lock_init(&lock);
+    timer.function = &rt5621_hp_detect_timer;
+    timer.data = (unsigned long)codec;
+    timer.expires = jiffies + HZ*1;
+    init_timer(&timer);
+	INIT_WORK(&rt5621_work.rt5621_workqueue, rt5621_hp_detect_queue);
+	add_timer(&timer);
+#endif
+
+    snd_soc_dapm_nc_pin(codec,"LINPUT1");
+    snd_soc_dapm_nc_pin(codec,"RINPUT1");
+
+    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+    snd_soc_dapm_disable_pin(codec, "HP");
+    snd_soc_dapm_enable_pin(codec, "MIC IN");
+    snd_soc_dapm_disable_pin(codec, "HP MIC");
+    snd_soc_dapm_disable_pin(codec, "FM IN");
+
+//    snd_soc_dapm_sync(codec);
+	Init_Aux_Hp(codec);    
+    return 0;
+}
+
+
+static struct snd_soc_dai_link aml_m1_dai = {
+    .name = "AML-M1",
+    .stream_name = "AML M1 PCM",
+    .cpu_dai = &aml_dai[0],  //////
+    .codec_dai = &rt5621_dai,
+    .init = aml_m1_codec_init,
+    .ops = &aml_m1_ops,
+};
+
+static struct snd_soc_card snd_soc_aml_m1 = {
+    .name = "AML-M1",
+    .platform = &aml_soc_platform,
+    .dai_link = &aml_m1_dai,
+    .num_links = 1,
+    .set_bias_level = aml_m1_set_bias_level,
+};
+
+//flove111810_S
+static struct rt5621_setup_data aml_rt5621_setup =
+{
+    .i2c_address = RT5621_I2C_ADDR,
+    .i2c_bus = 0,
+};
+//flove111810_E
+
+static struct snd_soc_device aml_m1_snd_devdata =
+{
+    .card = &snd_soc_aml_m1,
+    .codec_dev = &soc_codec_dev_rt5621,
+    .codec_data = &aml_rt5621_setup,	//flove111810
+};
+
+static struct platform_device *aml_m1_snd_device;
+static struct platform_device *aml_m1_platform_device;
+
+static int aml_m1_audio_probe(struct platform_device *pdev)
+{
+    int ret;
+    //pdev->dev.platform_data;
+    // TODO
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+    aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!aml_m1_snd_device) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+    }
+
+    platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
+    aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
+
+    ret = platform_device_add(aml_m1_snd_device);
+    if (ret) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto error;
+    }
+
+    aml_m1_platform_device = platform_device_register_simple("aml_m1_codec", -1, NULL, 0);
+    return 0;
+error:
+    platform_device_put(aml_m1_snd_device);
+    return ret;
+}
+
+static int aml_m1_audio_remove(struct platform_device *pdev)
+{
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+
+#if HP_DET
+    del_timer_sync(&timer);
+    
+#endif
+    platform_device_unregister(aml_m1_snd_device);
+    return 0;
+}
+
+static struct platform_driver aml_m1_audio_driver =
+{
+    .probe  = aml_m1_audio_probe,
+    .remove = aml_m1_audio_remove,
+    .driver = {
+        .name = "aml_m1_audio_rt5621",
+        .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m1_init(void)
+{
+    return platform_driver_register(&aml_m1_audio_driver);
+}
+
+static void __exit aml_m1_exit(void)
+{
+    platform_driver_unregister(&aml_m1_audio_driver);
+}
+
+module_init(aml_m1_init);
+module_exit(aml_m1_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_mid_wm8900.c b/sound/soc/aml/aml_m1_mid_wm8900.c
new file mode 100644
index 000000000000..e46506f42954
--- /dev/null
+++ b/sound/soc/aml/aml_m1_mid_wm8900.c
@@ -0,0 +1,338 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/wm8900.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "../codecs/wm8900.h"
+
+#define HP_DET 1
+
+#if HP_DET
+static struct timer_list timer;
+static int hp_detect_flag = 0;
+void mute_spk(struct snd_soc_codec* codec, int flag);
+#endif
+
+static int aml_m1_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+    int ret;
+    // TODO
+printk("***Entered %s:%s\n", __FILE__,__func__);
+
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+    if(ret<0)
+        return ret;
+
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+    if(ret<0)
+        return ret;
+
+    return 0;
+}
+    
+static struct snd_soc_ops aml_m1_ops = {
+    .hw_params = aml_m1_hw_params,
+};
+
+static int aml_m1_set_bias_level(struct snd_soc_card *card,
+    enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct snd_soc_codec *codec = card->codec;
+    // TODO
+printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+    case SND_SOC_BIAS_PREPARE:
+#if HP_DET
+        del_timer_sync(&timer);
+        timer.expires = jiffies + HZ*5;
+        del_timer(&timer);
+        add_timer(&timer);
+        hp_detect_flag = 0xf0000000;
+#endif
+        break;
+    case SND_SOC_BIAS_OFF:
+    case SND_SOC_BIAS_STANDBY:
+#if HP_DET
+        del_timer(&timer);
+        hp_detect_flag = 0xf0000000;        
+        mute_spk(codec,1);
+#endif
+        break;
+    };
+
+    return ret;
+}
+
+static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MIC IN", NULL),
+    SND_SOC_DAPM_MIC("HP MIC", NULL),
+    SND_SOC_DAPM_LINE("FM IN", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+
+    /* speaker connected to LINEOUT */
+    {"Ext Spk", NULL, "LINEOUT1L"},
+    {"Ext Spk", NULL, "LINEOUT1R"},
+    /* mic is connected to Mic Jack, with WM8731 Mic Bias */
+    {"HP", NULL, "HP_L"},
+    {"HP", NULL, "HP_R"},
+    {"LINPUT2", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "MIC IN"},
+    {"RINPUT2", NULL, "Mic Bias"},
+    {"Mic Bias", NULL, "HP MIC"},
+    {"LINPUT3", NULL, "FM IN"},
+    {"RINPUT3", NULL, "FM IN"},
+};
+
+#if HP_DET
+
+/* Hook switch */
+
+static struct snd_soc_jack hp_jack;
+
+static struct snd_soc_jack_pin hp_jack_pins[] = {
+    { .pin = "HP", .mask = SND_JACK_HEADSET },
+};
+
+static spinlock_t lock;
+static void wm8900_hp_detect_queue(struct work_struct*);
+static struct wm8900_work_t{
+unsigned long data;
+struct work_struct wm8900_workqueue;
+}wm8900_work;
+
+void mute_spk(struct snd_soc_codec* codec, int flag)
+{
+    int gpio_status = 0;
+    if(flag){
+        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
+        gpio_status &= ~(7<<4);
+        gpio_status |= (6<<4);
+        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
+    }else{
+        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
+        gpio_status &= ~(7<<4);
+        gpio_status |= (7<<4);
+        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
+    }
+}
+
+static void wm8900_hp_detect_queue(struct work_struct* work)
+{
+    int level = 0x0;
+    struct wm8900_work_t* pwork = container_of(work,struct wm8900_work_t, wm8900_workqueue);
+    struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
+
+    if ((wm8900_dai.ac97_pdata) && ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged)
+        level = ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged();
+
+    //printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
+    if(level == 0x1 && hp_detect_flag!= 0x1){ // HP
+        printk("Headphone pluged in\n");
+        snd_soc_dapm_disable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+        snd_soc_dapm_sync(codec);
+        // pull down the gpio to mute spk
+        mute_spk(codec, 1);
+        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
+        hp_detect_flag = level;
+    }else if(level != hp_detect_flag){ // HDMI
+        printk("Headphone unpluged\n");
+        snd_soc_dapm_enable_pin(codec, "Ext Spk");
+        snd_soc_dapm_enable_pin(codec, "MIC IN");
+        snd_soc_dapm_sync(codec);
+        snd_soc_jack_report(&hp_jack,0, SND_JACK_HEADSET);
+        hp_detect_flag = level;
+        mute_spk(codec, 0);
+    }
+}
+
+static void wm8900_hp_detect_timer(unsigned long data)
+{
+    struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
+    wm8900_work.data = (unsigned long)codec;
+    schedule_work(&wm8900_work.wm8900_workqueue);
+    mod_timer(&timer, jiffies + HZ*1);
+}
+
+#endif
+
+static int aml_m1_codec_init(struct snd_soc_codec *codec)
+{
+    struct snd_soc_card *card = codec->socdev->card;
+
+    int err;
+    //Add board specific DAPM widgets and routes
+    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
+    if(err){
+        dev_warn(card->dev, "Failed to register DAPM widgets\n");
+        return 0;
+    }
+
+    err = snd_soc_dapm_add_routes(codec, intercon,
+        ARRAY_SIZE(intercon));
+    if(err){
+        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
+        return 0;
+    }
+
+#if HP_DET
+    if ((wm8900_dai.ac97_pdata) && ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged)
+        hp_detect_flag = ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged() ? (0) : (1);
+    else
+        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
+
+    err = snd_soc_jack_new(card, "hp_switch",
+        SND_JACK_HEADSET, &hp_jack);
+    if(err){
+        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
+    }else{
+        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
+        if(err){
+            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
+        }
+    }
+
+    // create a timer to poll the HP IN status
+    spin_lock_init(&lock);
+    timer.function = &wm8900_hp_detect_timer;
+    timer.data = (unsigned long)codec;
+    timer.expires = jiffies + HZ*10;
+    init_timer(&timer);
+    INIT_WORK(&wm8900_work.wm8900_workqueue, wm8900_hp_detect_queue);
+#endif
+
+    snd_soc_dapm_nc_pin(codec,"LINPUT1");
+    snd_soc_dapm_nc_pin(codec,"RINPUT1");
+
+    snd_soc_dapm_enable_pin(codec, "Ext Spk");
+    snd_soc_dapm_disable_pin(codec, "HP");
+    snd_soc_dapm_enable_pin(codec, "MIC IN");
+    snd_soc_dapm_disable_pin(codec, "HP MIC");
+    snd_soc_dapm_disable_pin(codec, "FM IN");
+
+    snd_soc_dapm_sync(codec);
+
+    return 0;
+}
+
+
+static struct snd_soc_dai_link aml_m1_dai = {
+    .name = "AML-M1",
+    .stream_name = "AML M1 PCM",
+    .cpu_dai = &aml_dai[0],  //////
+    .codec_dai = &wm8900_dai,
+    .init = aml_m1_codec_init,
+    .ops = &aml_m1_ops,
+};
+
+static struct snd_soc_card snd_soc_aml_m1 = {
+    .name = "AML-M1",
+    .platform = &aml_soc_platform,
+    .dai_link = &aml_m1_dai,
+    .num_links = 1,
+    .set_bias_level = aml_m1_set_bias_level,
+};
+
+static struct snd_soc_device aml_m1_snd_devdata = {
+    .card = &snd_soc_aml_m1,
+    .codec_dev = &soc_codec_dev_wm8900,
+};
+
+static struct platform_device *aml_m1_snd_device;
+static struct platform_device *aml_m1_platform_device;
+
+static int aml_m1_audio_probe(struct platform_device *pdev)
+{
+    int ret;
+
+    // TODO
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+    aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!aml_m1_snd_device) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+    }
+
+    platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
+    aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
+
+    ret = platform_device_add(aml_m1_snd_device);
+    if (ret) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto error;
+    }
+
+    aml_m1_platform_device = platform_device_register_simple("aml_m1_codec", -1, NULL, 0);
+    return 0;
+error:
+    platform_device_put(aml_m1_snd_device);
+    return ret;
+}
+
+static int aml_m1_audio_remove(struct platform_device *pdev)
+{
+printk("***Entered %s:%s\n", __FILE__,__func__);
+
+#if HP_DET
+    del_timer_sync(&timer);
+    
+#endif
+    platform_device_unregister(aml_m1_snd_device);
+    return 0;
+}
+
+static struct platform_driver aml_m1_audio_driver = {
+    .probe  = aml_m1_audio_probe,
+    .remove = aml_m1_audio_remove,
+    .driver = {
+    .name = "aml_m1_audio_wm8900",
+    .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m1_init(void)
+{
+    return platform_driver_register(&aml_m1_audio_driver);
+}
+
+static void __exit aml_m1_exit(void)
+{
+    platform_driver_unregister(&aml_m1_audio_driver);
+}
+
+module_init(aml_m1_init);
+module_exit(aml_m1_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m3.c b/sound/soc/aml/aml_m3.c
new file mode 100644
index 000000000000..6600f67ede33
--- /dev/null
+++ b/sound/soc/aml/aml_m3.c
@@ -0,0 +1,352 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/switch.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <sound/aml_platform.h>
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_m3_codec.h"
+#include "aml_audio_hw.h"
+#define HP_DET 1
+
+
+static struct aml_audio_platform * audio_platform_data = NULL;
+
+#if HP_DET
+static struct snd_soc_jack hp_jack;
+
+static struct snd_soc_jack_pin hp_jack_pins[] = {
+    { .pin = "HP", .mask = SND_JACK_HEADSET },
+    { .pin = "HP_L", .mask = SND_JACK_HEADSET },
+    { .pin = "HP_R", .mask = SND_JACK_HEADSET },
+    { .pin = "HP_L Switch", .mask = SND_JACK_HEADSET },
+    { .pin = "HP_R Switch", .mask = SND_JACK_HEADSET },
+};
+
+static struct timer_list timer;
+static int hp_detect_flag = 0;
+static struct switch_dev sdev;
+#endif
+
+static int aml_m3_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+		struct snd_soc_pcm_runtime *rtd = substream->private_data;
+		struct snd_soc_dai *codec_dai = rtd->codec_dai;
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		int ret;
+		// TODO
+#ifdef _AML_M3_HW_DEBUG_
+printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+		
+		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+		if(ret<0)
+			return ret;
+			
+		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
+		if(ret<0)
+			return ret;
+		
+	return 0;
+}
+	
+static struct snd_soc_ops aml_m3_ops = {
+	.hw_params = aml_m3_hw_params,
+};
+
+static int aml_m3_set_bias_level(struct snd_soc_card *card,
+					enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    //struct snd_soc_codec *codec = card->dapm.codec;
+    // TODO
+
+#ifdef _AML_M3_HW_DEBUG_
+printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
+#endif
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+    case SND_SOC_BIAS_PREPARE:
+#if HP_DET
+        del_timer_sync(&timer);
+        timer.expires = jiffies + HZ*5;
+        del_timer(&timer);
+        add_timer(&timer);
+        hp_detect_flag = 0xf0000000;
+#endif
+        break;
+    case SND_SOC_BIAS_OFF:
+    case SND_SOC_BIAS_STANDBY:
+#if HP_DET
+        del_timer(&timer);
+        hp_detect_flag = 0xf0000000;        
+        if(audio_platform_data->mute_spk)
+          audio_platform_data->mute_spk(1);
+#endif
+        break;
+    };
+
+    return ret;
+}
+
+static const struct snd_soc_dapm_widget aml_m3_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MIC IN", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+
+	{"Ext Spk", NULL, "LINEOUTL"},
+    {"Ext Spk", NULL, "LINEOUTR"},
+    {"HP", NULL, "HP_L"},
+    {"HP", NULL, "HP_R"},
+	//{"LINEINL", "MICBIAS", "MIC IN"},
+	//{"LINEINR", "MICBIAS", "MIC IN"},
+		
+	{"MICBIAS", NULL, "MIC IN"},
+	{"LINEINR", NULL, "MICBIAS"},
+	{"LINEINL", NULL, "MICBIAS"},
+};
+
+#if HP_DET
+
+/* Hook switch */
+
+static spinlock_t lock;
+static void aml_m3_hp_detect_queue(struct work_struct*);
+static struct aml_m3_work_t{
+	unsigned long data;
+	struct work_struct aml_m3_workqueue;
+}aml_m3_work;
+
+extern void latch_(struct snd_soc_codec* codec);
+
+static void aml_m3_hp_detect_queue(struct work_struct* work)
+{
+	int level = 0x0;
+	u16 reg;
+	struct aml_m3_work_t* pwork = container_of(work,struct aml_m3_work_t, aml_m3_workqueue);
+    struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
+
+    //if ((aml_dai[1].ac97_pdata) && ((struct aml_m3_pdata *) (aml_dai[1].ac97_pdata))->is_hp_pluged)
+        //level = ((struct aml_m3_pdata *) (aml_dai[1].ac97_pdata))->is_hp_pluged();
+    if(audio_platform_data->is_hp_pluged)
+    	level = audio_platform_data->is_hp_pluged();
+	//printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
+
+	if(level == 0x1 && hp_detect_flag!= 0x1){ // HP
+		printk("Headphone pluged in\n");
+		snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
+		reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
+		reg &= ~0xc0;
+		snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg); //unmute HP
+        if(audio_platform_data->mute_spk)
+        	audio_platform_data->mute_spk(1);
+    	latch_(codec);
+		hp_detect_flag = level;
+		switch_set_state(&sdev, 1);
+	}else if(level != hp_detect_flag){ // HDMI
+		printk("Headphone unpluged\n");
+        snd_soc_jack_report(&hp_jack,0, SND_JACK_HEADSET);
+		reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
+		reg |= 0xc0;
+		snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg);//mute HP
+        if(audio_platform_data->mute_spk)
+    		audio_platform_data->mute_spk(0);
+		latch_(codec);
+		hp_detect_flag = level;
+		switch_set_state(&sdev, 0);
+	}
+}
+
+static void aml_m3_hp_detect_timer(unsigned long data)
+{
+    struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
+    aml_m3_work.data = (unsigned long)codec;
+    schedule_work(&aml_m3_work.aml_m3_workqueue);
+    mod_timer(&timer, jiffies + HZ*1);
+}
+
+#endif
+
+static int aml_m3_codec_init(struct snd_soc_pcm_runtime *runtime)
+{
+    struct snd_soc_codec* codec = runtime->codec;
+    struct snd_soc_card *card = codec->card;
+  struct snd_soc_dapm_context* dapm = &codec->dapm;
+	int err;
+	printk("***Entered %s:%s:\n", __FILE__,__func__);
+   
+    //Add board specific DAPM widgets and routes
+    err = snd_soc_dapm_new_controls(&codec->dapm, aml_m3_dapm_widgets, ARRAY_SIZE(aml_m3_dapm_widgets));
+    if(err){
+        dev_warn(card->dev, "Failed to register DAPM widgets\n");
+        return 0;
+    }
+
+    err = snd_soc_dapm_add_routes(&codec->dapm, intercon,
+        ARRAY_SIZE(intercon));
+    if(err){
+        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
+        return 0;
+    }
+
+#if HP_DET
+        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
+
+    err = snd_soc_jack_new(codec, "hp_switch",
+        SND_JACK_HEADSET, &hp_jack);
+    if(err){
+        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
+    }else{
+        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
+        if(err){
+            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
+        }
+    }
+	/**/
+    // create a timer to poll the HP IN status
+    spin_lock_init(&lock);
+    timer.function = &aml_m3_hp_detect_timer;
+    timer.data = (unsigned long)codec;
+    timer.expires = jiffies + HZ*10;
+    init_timer(&timer);
+    INIT_WORK(&aml_m3_work.aml_m3_workqueue, aml_m3_hp_detect_queue);
+#endif
+
+    snd_soc_dapm_nc_pin(dapm,"LINPUT1");
+    snd_soc_dapm_nc_pin(dapm,"RINPUT1");
+
+    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+    snd_soc_dapm_disable_pin(dapm, "HP");
+    snd_soc_dapm_enable_pin(dapm, "MIC IN");
+    snd_soc_dapm_disable_pin(dapm, "HP MIC");
+    snd_soc_dapm_disable_pin(dapm, "FM IN");
+
+    snd_soc_dapm_sync(dapm);
+	/**/
+    return 0;
+}
+
+
+static struct snd_soc_dai_link aml_m3_dai = {
+	.name = "AML-M3",
+	.stream_name = "AML M3 PCM",
+	.codec_name = "aml_m3_codec",
+	.platform_name = "aml-audio",
+	.cpu_dai_name = "aml-dai0",
+	.codec_dai_name = "AML-M3",
+	.init = aml_m3_codec_init,
+	.ops = &aml_m3_ops,
+};
+
+static struct snd_soc_card snd_soc_aml_m3 = {
+	.name = "AML-M3",
+	.dai_link = &aml_m3_dai,
+	.num_links = 1,
+	.set_bias_level = aml_m3_set_bias_level,
+};
+
+static struct platform_device *aml_m3_snd_device;
+static struct platform_device *aml_m3_platform_device;
+static int aml_m3_audio_probe(struct platform_device *pdev)
+{
+		int ret;
+		//pdev->dev.platform_data;
+		// TODO
+printk("***Entered %s:%s\n", __FILE__,__func__);
+		aml_m3_snd_device = platform_device_alloc("soc-audio", -1);
+		if (!aml_m3_snd_device) {
+			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+			ret = -ENOMEM;
+		}
+
+		audio_platform_data = (struct aml_audio_platform*) pdev->dev.platform_data;
+
+		platform_set_drvdata(aml_m3_snd_device, &snd_soc_aml_m3);
+
+		ret = platform_device_add(aml_m3_snd_device);
+		if (ret) {
+			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+			goto error2;
+		}
+		
+		aml_m3_platform_device = platform_device_register_simple("aml_m3_codec",
+								-1, NULL, 0);
+#if HP_DET
+		sdev.name = "h2w";//for report headphone to android
+		ret = switch_dev_register(&sdev);
+		if (ret < 0){
+			printk(KERN_ERR "ASoC: register switch dev failed\n");
+			goto error1;
+		}
+#endif
+		return 0;
+error1:
+		platform_device_unregister(aml_m3_snd_device);
+error2:
+		platform_device_put(aml_m3_snd_device);
+		return ret;
+}
+
+static int aml_m3_audio_remove(struct platform_device *pdev)
+{
+printk("***Entered %s:%s\n", __FILE__,__func__);
+
+#if HP_DET
+    del_timer_sync(&timer);
+    switch_dev_unregister(&sdev);
+#endif
+    platform_device_unregister(aml_m3_snd_device);
+    return 0;
+}
+
+static struct platform_driver aml_m3_audio_driver = {
+	.probe  = aml_m3_audio_probe,
+	.remove = aml_m3_audio_remove,
+	.driver = {
+		.name = "aml_m3_audio",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init aml_m3_init(void)
+{
+		return platform_driver_register(&aml_m3_audio_driver);
+}
+
+static void __exit aml_m3_exit(void)
+{
+		platform_driver_unregister(&aml_m3_audio_driver);
+}
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m3_init);
+#else
+module_init(aml_m3_init);
+#endif
+module_exit(aml_m3_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("ALSA SoC AML M3 AUDIO");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m3_codec.c b/sound/soc/aml/aml_m3_codec.c
new file mode 100644
index 000000000000..9daadcdacb37
--- /dev/null
+++ b/sound/soc/aml/aml_m3_codec.c
@@ -0,0 +1,970 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <mach/am_regs.h>
+#include "aml_audio_hw.h"
+
+static struct snd_soc_codec *aml_m3_codec;
+
+static int (*is_hp_pluged)(void) = NULL;
+static void (*mute_spk)(struct snd_soc_codec* codec, int flag) = NULL;
+
+/* codec private data */
+struct aml_m3_codec_priv {
+	struct snd_soc_codec codec;
+	u16 reg_cache[ADAC_MAXREG];
+	unsigned int sysclk;
+};
+
+u16 aml_m3_reg[ADAC_MAXREG] = {0};
+
+unsigned long aml_rate_table[] = {
+    8000, 11025, 12000, 16000, 22050, 24000, 32000, 
+    44100, 48000, 88200, 96000, 192000
+};
+
+void latch_ (struct snd_soc_codec* codec)
+{
+    int latch;
+    latch = 1;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+    latch = 0;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+}
+
+
+typedef enum  {
+    AML_PWR_DOWN,
+    AML_PWR_UP,
+    AML_PWR_KEEP,
+} AML_PATH_SET_TYPE;
+
+void aml_reset_path(struct snd_soc_codec* codec, AML_PATH_SET_TYPE type)
+{
+    unsigned int pwr_reg2 = snd_soc_read(codec, ADAC_POWER_CTRL_REG2);
+    latch_(codec);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
+    latch_(codec);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2|(1<<7));
+    latch_(codec);
+     
+    if (AML_PWR_DOWN == type)
+    {
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
+        latch_(codec);
+    }
+    
+    if (AML_PWR_KEEP == type)
+    {
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2);
+        latch_(codec);
+    }
+}
+
+void aml_m3_reset(struct snd_soc_codec* codec, bool first_time)
+{
+	unsigned long   data32;
+
+	if (first_time)
+	{
+        //audio_set_clk(AUDIO_CLK_FREQ_48,0);
+        audio_set_clk(AUDIO_CLK_FREQ_192,0);
+	 	set_acodec_source(AIU_I2SOUT_TO_DAC);   // 0=no clock to CODEC; 1=pcmout to DAC; 2=Aiu I2S out to DAC.
+
+    	// --------------------------------------------------------
+    	// Configure audio DAC control interface
+    	// --------------------------------------------------------
+
+	    data32  = 0;
+	    data32 |= 0     << 15;  // [15]     audac_soft_reset_n
+	    data32 |= 0     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
+	    data32 |= 0     << 9;   // [9]      delay_rd_en
+	    data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
+	    data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
+	    data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
+	    WRITE_MPEG_REG(AIU_AUDAC_CTRL0, data32);
+			
+			
+	    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));
+	    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 23, 1);
+	    WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+	    msleep(100);
+	 
+	    // Enable APB3 fail on error
+	    data32  = 0;
+	    data32 |= 1     << 15;  // [15]     err_en
+	    data32 |= 255   << 0;   // [11:0]   max_err
+	    WRITE_MPEG_REG(AIU_AUDAC_CTRL1, data32);
+	    // Check read back data
+	    data32 = READ_MPEG_REG(AIU_AUDAC_CTRL0);
+	    if (data32 != (0x55 << 1)) {
+			printk("audiocodec init error: AIU_AUDAC_CTRL0 = %lx\n", data32);
+		}
+			
+		data32 = READ_MPEG_REG(AIU_AUDAC_CTRL1);
+		if (data32 != 0x80ff) {
+			printk("audiocodec init error: AIU_AUDAC_CTRL1 = %lx\n", data32);
+		}
+
+		wr_regbank (0,			// rstdpz: active low.
+					0,			// mclksel[3:0]: master clock freq sel. 0=256Fs, 1=384Fs, ... 
+					8,		    // i2sfsadc[3:0]: sample freq sel. 0=8kHz, 1=11.025k, 2=12k, 3=16k, 4=22.05k, 5=24k, 6=32k, 7=44.1k, 8=48k, 9=88.2k, 10=96k, 11=192k, >11=Rsrv.
+					8,		    // i2sfsdac[3:0]: sample freq sel. 0=8kHz, 1=11.025k, 2=12k, 3=16k, 4=22.05k, 5=24k, 6=32k, 7=44.1k, 8=48k, 9=88.2k, 10=96k, 11=192k, >11=Rsrv.
+					1,			// i2ssplit: 0=single mode, 1=dual mode.
+					1,			// i2smode[2:0]: Data format sel. 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
+					1,			// pdauxdrvrz: 0=power down active, 1=normal.
+					1,			// pdauxdrvlz: 0=power down active, 1=normal.
+					1,			// pdhsdrvrz: 0=power down active, 1=normal.
+					1,			// pdhsdrvlz: 0=power down active, 1=normal.
+					1,			// pdlsdrvz: 0=power down active, 1=normal.
+					1,			// pddacrz: 0=power down active, 1=normal.
+					1,			// pddaclz: 0=power down active, 1=normal.
+					0,			// pdz: 0=power down active, 1=normal.
+					1,			// pdmbiasz: 0=power down active, 1=normal.
+					1,			// pdvcmbufz: 0=power down active, 1=normal.
+					1,			// pdrpgaz: 0=power down active, 1=normal.
+					1,			// pdlpgaz: 0=power down active, 1=normal.
+					1,			// pdadcrz: 0=power down active, 1=normal.
+					1,			// pdadclz: 0=power down active, 1=normal.
+					0,			// hsmute[1:0]: bit[1] Analog playback right channel mute, bit[0] Analog playback left channel mute.
+					0,			// recmute[1:0]: bit[1] Digital record right channel mute, bit[0] Digital record left channel mute.
+					0,			// micmute[1:0]: bit[1] Input PGA right channel mute, bit[0] Input PGA left channel mute.
+					0,			// lmmute[1:0]: bit[1] Digital playback right channel mute, bit[0] Digital playback left channel mute.
+					0,			// lsmute: loud speaker mute.
+					0,			// lmmix: Playback digital mixer sel.
+					0,			// recmix: Record digital mixer sel.
+					0,			// ctr[1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
+					1,			// enhp: Record channel high pass filter enable.
+					0x5454, 	// lmvol[15:0]: Digital playback volumn control, [15:8] control right channel, [7:0] control left channel.
+								// 0=-126dB, 1=-124.5dB, ..., 0x53=-1.5dB, 0x54=0dB, >=0x55 Rsrv.
+					0x2828, 	// hsvol[15:0]: Analog playback headset volumn control, [15:8] control right channel, [7:0] control left channel.
+								// 0=-40dB, 1=-39dB, ..., 0x28=0dB, ..., 0x2e=6dB, >=0x2f Rsrv.
+					0,			// pbmix[15:0]: Playback channel mixing sel. [15:8] control right channel, [7:0] control left channel.
+								// 0=Left(Right) digital source only, 1=Analog source only, 2=Analog + left(right) digital,
+								// 3=Right(Left) digital sourcd only, 4=Left(Right) digital + right(left) digital, 5=Analog + right(left) digital,
+								// 6=Analog + left(right) digital + right(left) digital, >=7 Rsrv.
+					0x0001, 	// lsmix[15:0]
+					0x1212, 	// micvol[15:0]: Input PGA volume control. [15:8] control right channel, [7:0] control left channel.
+								// 0=-6dB, 1=-4.5dB, ..., 4=0dB, ..., 0x11=19.5dB, 0x12=21dB, >=0x13 Rsrv.
+					0x1111, 	// recvol[15:0]: Digital record channel master volume control. [15:8] control right channel, [7:0] control left channel.
+								// 0=30dB, 1=28.5dB, ..., 0x13=1.5dB, 0x14=0dB, 0x15=-1.5dB, ..., 0x54=-96dB, >=0x55 Rsrv.
+					0x0101);	// recsel[15:0]: Input PGA selection. [15:8] control right channel, [7:0] control left channel.
+								// 0x01=input1, 0x03=input2, 0x05=input3, 0x09=input4,
+								// 0x11=input5, 0x21=input6, 0x41=input7, 0x81=input8, others=Rsrv.
+        adac_power_up_mode_2();
+        adac_startup_seq();
+
+	    udelay(10);
+	    
+	    if(is_hp_pluged && is_hp_pluged()) {
+	    	data32 = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
+		    data32 &= ~0xc0;
+		    snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, data32); //unmute HP
+    	    if(mute_spk)
+              mute_spk(codec, 1);
+    	    latch_(codec);
+    	}
+    	else {
+    		data32 = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
+	    	data32 |= 0xc0;
+		    snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, data32);//mute HP
+    		if(mute_spk)
+              mute_spk(codec, 0);
+	    	latch_(codec);
+        }
+	    
+/*			snd_soc_write(codec, ADAC_RESET, (0<<1));
+	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
+	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
+	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
+	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
+	    	msleep(100);
+	        
+
+	    	snd_soc_write(codec,ADAC_CLOCK, 0); // 256fs
+	    	snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, (7<<4)|7);	 // samplerate for ADC&DAC
+	    	snd_soc_write(codec, ADAC_I2S_CONFIG_REG2, 1|(1<<3)); 		// I2S | split
+
+	        snd_soc_write(codec, ADAC_MUTE_CTRL_REG1,0);
+	    	snd_soc_write(codec, ADAC_MUTE_CTRL_REG2, 0);
+	        
+	        snd_soc_write(codec,ADAC_DAC_ADC_MIXER, 0);
+
+	        snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_LSB, 0x54);
+	        snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_MSB, 0x54);
+	        snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_LSB, 0x28);
+	        snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_MSB, 0x28); 
+
+	        snd_soc_write(codec, ADAC_PLAYBACK_MIX_CTRL_LSB, 0);
+	        snd_soc_write(codec, ADAC_PLAYBACK_MIX_CTRL_MSB, 0);
+
+	        snd_soc_write(codec, ADAC_STEREO_PGA_VOL_LSB, 4);
+	        snd_soc_write(codec, ADAC_STEREO_PGA_VOL_MSB, 4);
+
+	        snd_soc_write(codec, ADAC_RECVOL_CTRL_LSB, 0x14);
+	        snd_soc_write(codec, ADAC_RECVOL_CTRL_MSB, 0x14);
+
+	        snd_soc_write(codec, ADAC_REC_CH_SEL_LSB, 1|(1<<(1-1)));// 1|(1<<(channel-1))
+	        snd_soc_write(codec, ADAC_REC_CH_SEL_MSB, 1|(1<<(1-1)));// 1|(1<<(channel-1))
+
+	        snd_soc_write(codec, ADAC_POWER_CTRL_REG1, 0xf7);
+	      	snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0x2f);
+
+	        snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
+	        snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
+	   
+	    	aml_reset_path(codec, AML_PWR_UP);
+	        aml_reset_path(codec, AML_PWR_DOWN);
+*/
+
+	}
+    else
+    {
+        snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
+        snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
+        aml_reset_path(codec, AML_PWR_UP);
+
+    	latch_(codec);
+	    snd_soc_write(codec, ADAC_RESET, (0<<1));
+        latch_(codec);
+	    latch_(codec);
+    	latch_(codec);
+	    snd_soc_write(codec, ADAC_RESET, (1<<1));
+        latch_(codec);
+	    latch_(codec);
+    }
+    msleep(200);
+}
+
+
+int audio_dac_set(unsigned freq)
+{
+  return 0;
+}
+
+static int post_reset(struct snd_soc_dapm_widget *w,
+	    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+    
+	if (SND_SOC_DAPM_POST_PMU == event)
+		{
+        aml_m3_reset(codec,false);
+        }
+    else if (SND_SOC_DAPM_POST_PMD == event && codec->active == 0)
+        aml_reset_path(codec, AML_PWR_DOWN);
+	return 0;
+}
+
+static int aml_switch_get_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    struct snd_soc_dapm_widget *w;
+    //struct snd_soc_dapm_context * dapm = &codec->dapm;
+    char *lname = NULL;
+    char *rname = NULL;
+
+    switch (e->reg)
+    {
+    case ADAC_POWER_CTRL_REG1:
+        if (6 == e->shift_l)
+        {
+            lname = "LINEOUTL";
+            rname = "LINEOUTR";
+        }
+        else if (4 == e->shift_l)
+        {
+            lname = "HP_L";
+            rname = "HP_R";
+        }
+        else if (2 == e->shift_l)
+        {
+            lname = "SPEAKER";
+        }
+    break;
+    case ADAC_POWER_CTRL_REG2:
+        if (2 == e->shift_l)
+        {
+            lname = "LINEINL";
+            rname = "LINEINR";
+        }
+    break;
+    default:
+    break;
+    }
+    
+	list_for_each_entry(w, &codec->card->widgets, list) {
+        if (lname && !strcmp(lname, w->name))
+            ucontrol->value.enumerated.item[0] = w->connected;
+        if (rname && !strcmp(rname, w->name))
+            ucontrol->value.enumerated.item[0] = w->connected;
+	}
+
+	return 0;
+}
+
+static int aml_switch_put_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    struct snd_soc_dapm_widget *w;
+    char *lname = NULL;
+    char *rname = NULL;
+    unsigned int pwr_reg;
+
+    switch (e->reg)
+    {
+    case ADAC_POWER_CTRL_REG1:
+        if (6 == e->shift_l)
+        {
+            lname = "LINEOUTL";
+            rname = "LINEOUTR";
+        }
+        else if (4 == e->shift_l)
+        {
+            lname = "HP_L";
+            rname = "HP_R";
+        }
+        else if (2 == e->shift_l)
+        {
+            lname = "SPEAKER";
+        }
+    break;
+    case ADAC_POWER_CTRL_REG2:
+        if (2 == e->shift_l)
+        {
+            lname = "LINEINL";
+            rname = "LINEINR";
+        }
+    break;
+    default:
+    break;
+    }
+
+    pwr_reg = snd_soc_read(codec, e->reg);
+    if(ucontrol->value.enumerated.item[0] == 0){
+    snd_soc_write(codec, e->reg, (pwr_reg&(~(0x1<<(e->shift_l)|0x1<<(e->shift_r)))));
+    }
+    else{
+    snd_soc_write(codec, e->reg, (pwr_reg|(0x1<<(e->shift_l)|0x1<<(e->shift_r))));
+    }
+
+	list_for_each_entry(w, &codec->card->widgets, list) {
+        if (lname && !strcmp(lname, w->name))
+        {
+            w->connected = ucontrol->value.enumerated.item[0];
+            printk("%s:connect=%d\n",w->name,w->connected);
+        }
+        if (rname && !strcmp(rname, w->name))
+        {
+            w->connected = ucontrol->value.enumerated.item[0];
+            printk("%s:connect=%d\n",w->name,w->connected);
+        }
+	}
+
+	return 0;
+}
+
+static int aml_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    int err = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+    if (err < 0)
+        return err;
+
+    aml_reset_path(codec, AML_PWR_KEEP);
+    return 0;
+}
+
+static int aml_ai_source_get_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    //struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 0)
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+    
+    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 1) 
+        ucontrol->value.enumerated.item[0] = 0;// linein
+    else
+        ucontrol->value.enumerated.item[0] = 1;//hdmi
+        
+    return 0;
+}
+
+static int aml_ai_source_put_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    
+    if (ucontrol->value.enumerated.item[0] == 0)
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+    else
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL,    (1<<4) | (2 << 0));    // Select HDMI RX output as AUDIN source
+
+    snd_soc_write(codec, ADAC_RESET, (0<<1));
+    latch_(codec);
+    snd_soc_write(codec, ADAC_RESET, (1<<1));
+    latch_(codec);
+    
+    return 0;
+}
+
+void aml_linein_start(void)
+{
+    // power up adc
+    unsigned int pwr_reg2 = snd_soc_read(aml_m3_codec, ADAC_POWER_CTRL_REG2);
+    snd_soc_write(aml_m3_codec, ADAC_POWER_CTRL_REG2, pwr_reg2|0xF);
+    latch_(aml_m3_codec);
+    // power up codec
+    aml_reset_path(aml_m3_codec, AML_PWR_UP);
+    snd_soc_write(aml_m3_codec, ADAC_RESET, (0<<1));
+    latch_(aml_m3_codec);
+    snd_soc_write(aml_m3_codec, ADAC_RESET, (1<<1));
+    latch_(aml_m3_codec);
+}
+
+void aml_linein_stop(void)
+{
+    // power down adc
+    unsigned int pwr_reg2 = snd_soc_read(aml_m3_codec, ADAC_POWER_CTRL_REG2);
+    snd_soc_write(aml_m3_codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~0xF));
+    latch_(aml_m3_codec);
+    // power down codec
+    if (aml_m3_codec->active == 0)
+        aml_reset_path(aml_m3_codec, AML_PWR_DOWN);
+}
+
+static const DECLARE_TLV_DB_SCALE(lineout_volume, -12600, 150, 0);
+static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
+static const DECLARE_TLV_DB_SCALE(linein_volume, -9600, 150, 0);
+
+static const char *left_linein_texts[] = {
+	"Left Line In 1", "Left Line In 2", "Left Line In 3", "Left Line In 4",
+	"Left Line In 5", "Left Line In 6", "Left Line In 7", "Left Line In 8"
+	};
+
+static const char *right_linein_texts[] = {
+	"Right Line In 1", "Right Line In 2", "Right Line In 3", "Right Line In 4",
+	"Right Line In 5", "Right Line In 6", "Right Line In 7", "Right Line In 8"
+	};
+
+static const unsigned int linein_values[] = {
+    1|(1<<(1-1)),
+    1|(1<<(2-1)),
+    1|(1<<(3-1)),
+    1|(1<<(4-1)),
+    1|(1<<(5-1)),
+    1|(1<<(6-1)),
+    1|(1<<(7-1)),
+    1|(1<<(8-1))
+    };
+
+static const char *iis_split_texts[] = {
+	"iis_not_split", "iis_split"
+	};
+
+static const unsigned int iis_split_values[] = {
+	0,
+	1
+    };
+
+
+static const SOC_VALUE_ENUM_SINGLE_DECL(left_linein_select, ADAC_REC_CH_SEL_LSB,
+		0, 0xff, left_linein_texts, linein_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(right_linein_select, ADAC_REC_CH_SEL_MSB,
+		0, 0xff, right_linein_texts, linein_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(iis_split_select, ADAC_I2S_CONFIG_REG2,
+		3, 0xff, iis_split_texts, iis_split_values);
+
+static const char *switch_op_modes_texts[] = {
+	"OFF", "ON"
+};
+static const struct soc_enum lineout_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG1, 6, 7,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+static const struct soc_enum hp_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG1, 4, 5,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+static const struct soc_enum linein_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG2, 2, 2,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+static const struct soc_enum sp_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG1, 2, 3,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+
+static const char *audio_in_source_texts[] = {
+	"LINEIN", "HDMI"
+};
+static const struct soc_enum audio_in_source_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
+			ARRAY_SIZE(audio_in_source_texts),
+			audio_in_source_texts);
+
+
+static const struct snd_kcontrol_new amlm3_snd_controls[] = {
+	SOC_DOUBLE_R_EXT_TLV("LINEOUT Playback Volume", ADAC_PLAYBACK_VOL_CTRL_LSB, ADAC_PLAYBACK_VOL_CTRL_MSB,
+	       0, 84, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, lineout_volume),
+	      
+	 SOC_DOUBLE_R_EXT_TLV("HeadSet Playback Volume", ADAC_STEREO_HS_VOL_CTRL_LSB, ADAC_STEREO_HS_VOL_CTRL_MSB,
+	       0, 46, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, hs_volume),
+
+    SOC_DOUBLE_R_EXT_TLV("LINEIN Capture Volume", ADAC_RECVOL_CTRL_LSB, ADAC_RECVOL_CTRL_MSB,
+	       0, 84, 1, snd_soc_get_volsw_2r, aml_put_volsw_2r, linein_volume),
+
+	SOC_VALUE_ENUM("Left LINEIN Select",left_linein_select),
+	SOC_VALUE_ENUM("Right LINEIN Select",right_linein_select),
+	SOC_VALUE_ENUM("IIS Split Select", iis_split_select),
+
+    SOC_ENUM_EXT("LOUT Playback Switch", lineout_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+    SOC_ENUM_EXT("HP Playback Switch", hp_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+	SOC_ENUM_EXT("LIN Capture Switch", linein_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+	SOC_ENUM_EXT("SP Playback Switch", sp_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+
+    SOC_ENUM_EXT("Audio In Source", audio_in_source_enum,
+        aml_ai_source_get_enum,aml_ai_source_put_enum),
+
+};
+
+static const struct snd_kcontrol_new lineoutl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 0, 1, 1);
+static const struct snd_kcontrol_new lineoutr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 1, 1, 1);
+static const struct snd_kcontrol_new hsl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 6, 1, 1);
+static const struct snd_kcontrol_new hsr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 7, 1, 1);
+static const struct snd_kcontrol_new spk_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 2, 1, 1);
+
+static const struct snd_kcontrol_new lineinl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 4, 1, 1);
+static const struct snd_kcontrol_new lineinr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 5, 1, 1);
+
+static const struct snd_soc_dapm_widget aml_m3_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+	SND_SOC_DAPM_OUTPUT("HP_L"),
+	SND_SOC_DAPM_OUTPUT("HP_R"),
+	SND_SOC_DAPM_OUTPUT("SPEAKER"),
+
+	SND_SOC_DAPM_INPUT("LINEINL"),
+	SND_SOC_DAPM_INPUT("LINEINR"),
+	
+	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
+	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
+	SND_SOC_DAPM_ADC("ADCL", "Left ADC Capture", ADAC_POWER_CTRL_REG2, 0, 0),
+	SND_SOC_DAPM_ADC("ADCR", "Right ADC Capture", ADAC_POWER_CTRL_REG2, 1, 0),
+
+	SND_SOC_DAPM_SWITCH("LINEOUTL Switch", ADAC_POWER_CTRL_REG1, 6, 0,
+			    &lineoutl_switch_controls),
+	SND_SOC_DAPM_SWITCH("LINEOUTR Switch", ADAC_POWER_CTRL_REG1, 7, 0,
+			    &lineoutr_switch_controls),
+	SND_SOC_DAPM_SWITCH("HP_L Switch", ADAC_POWER_CTRL_REG1, 4, 0,
+			    &hsl_switch_controls),
+	SND_SOC_DAPM_SWITCH("HP_R Switch", ADAC_POWER_CTRL_REG1, 5, 0,
+			    &hsr_switch_controls),
+	SND_SOC_DAPM_SWITCH("SPEAKER Switch", ADAC_POWER_CTRL_REG1, 2, 0,
+			    &spk_switch_controls),
+
+	SND_SOC_DAPM_SWITCH("LINEINL Switch", ADAC_POWER_CTRL_REG2, 2, 0,
+			    &lineinl_switch_controls),
+	SND_SOC_DAPM_SWITCH("LINEINR Switch", ADAC_POWER_CTRL_REG2, 3, 0,
+			    &lineinr_switch_controls),
+
+    SND_SOC_DAPM_POST("RESET", post_reset),
+	
+	//SND_SOC_DAPM_PGA("HSL", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
+	//SND_SOC_DAPM_PGA("HSR", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
+	
+	//SND_SOC_DAPM_PGA("PDZ", ADAC_POWER_CTRL_REG2, 7, 0, NULL, 0),
+	SND_SOC_DAPM_MICBIAS("MICBIAS", ADAC_POWER_CTRL_REG2, 5, 0)
+};
+
+/* Target, Path, Source */
+
+static const struct snd_soc_dapm_route aml_m3_audio_map[] = {
+	{"LINEOUTL", NULL, "LINEOUTL Switch"},
+	{"LINEOUTL Switch", NULL, "DACL"},
+	{"LINEOUTR", NULL, "LINEOUTR Switch"},
+	{"LINEOUTR Switch", NULL, "DACR"},
+	
+	{"HP_L", NULL, "HP_L Switch"},
+	{"HP_L Switch", NULL, "DACL"},
+	{"HP_R", NULL, "HP_R Switch"},
+	{"HP_R Switch", NULL, "DACR"},
+
+	{"SPEAKER", NULL, "SPEAKER Switch"},
+	{"SPEAKER Switch", NULL, "DACL"},
+	{"SPEAKER Switch", NULL, "DACR"},
+
+    {"ADCL", NULL, "LINEINL Switch"},
+    {"LINEINL Switch", NULL, "LINEINL"},
+	{"ADCR", NULL, "LINEINR Switch"},
+	{"LINEINR Switch", NULL, "LINEINR"},
+};
+
+static int aml_m3_write(struct snd_soc_codec *codec, unsigned int reg,
+							unsigned int value)
+{
+    u16 *reg_cache = codec->reg_cache;
+	
+	//printk("***Entered %s:%s:\nWriting reg is %#x; value=%#x\n",__FILE__,__func__, reg, value);
+	if (reg >= codec->reg_size/sizeof(u16))
+		return -EINVAL;
+	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
+	reg_cache[reg] = value;
+
+//printk("Read back reg is %#x value=%#x\n", reg, READ_APB_REG(APB_BASE+(reg<<2)));
+
+	return 0;
+}
+
+static unsigned int aml_m3_read(struct snd_soc_codec *codec,
+							unsigned int reg)
+{
+	//u16 *reg_cache = codec->reg_cache;
+	if (reg >= codec->reg_size/sizeof(u16))
+		return -EINVAL;
+	
+	return READ_APB_REG(APB_BASE+(reg<<2));
+	//return reg_cache[reg];
+}
+
+static int aml_m3_codec_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+    unsigned int i2sfs;
+    unsigned long rate = params_rate(params);
+    int rate_idx = 0;
+
+    for (rate_idx = 0; rate_idx < ARRAY_SIZE(aml_rate_table); rate_idx++)
+        if (aml_rate_table[rate_idx] == rate)
+            break;
+    if (ARRAY_SIZE(aml_rate_table) == rate_idx)
+        rate_idx = 0;
+
+    i2sfs = snd_soc_read(codec, ADAC_I2S_CONFIG_REG1);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, (i2sfs&0x0f)|(rate_idx<<4));
+    else
+        snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, (i2sfs&0xf0)|rate_idx);
+
+    aml_reset_path(codec, AML_PWR_KEEP);
+	return 0;
+}
+
+
+static int aml_m3_codec_pcm_prepare(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	//struct snd_soc_codec *codec = dai->codec;
+	/* set active */
+	
+	// TODO
+
+	return 0;
+}
+
+static void aml_m3_codec_shutdown(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	/* deactivate */
+	if (!codec->active) {
+		udelay(50);
+		
+		// TODO
+	}
+}
+
+static int aml_m3_codec_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 reg;
+	// TODO
+
+	reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
+	if(mute){
+		reg |= 3;
+	}
+	else{
+		reg &= ~3;
+	}
+	printk("aml_m3_codec_mute mute=%d\n",mute);
+//	snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg);
+	return 0;
+}
+
+static int aml_m3_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	//struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned long data = 0;
+	
+	switch (freq) {
+	case 32000:
+		data = 6;
+		break;
+	case 44100:
+		data = 7;
+		break;
+	case 48000:
+		data = 8;
+		break;
+	case 96000:
+		data = 10;
+		break;
+	default:
+		data = 6;
+		break;
+	}
+	//snd_soc_write(codec,ADAC_CLOCK, 0);
+	//snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, data);
+	return 0;
+}
+
+
+static int aml_m3_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	//struct snd_soc_codec *codec = codec_dai->codec;
+	u16 iface = 0;
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set iface */
+	
+	// TODO
+	
+	return 0;
+}
+
+#define AML_RATES SNDRV_PCM_RATE_8000_96000
+
+#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+
+static struct snd_soc_dai_ops aml_m3_codec_dai_ops = {
+	.prepare	= aml_m3_codec_pcm_prepare,
+	.hw_params	= aml_m3_codec_hw_params,
+	.shutdown	= aml_m3_codec_shutdown,
+	.digital_mute	= aml_m3_codec_mute,
+	.set_sysclk	= aml_m3_codec_set_dai_sysclk,
+	.set_fmt	= aml_m3_codec_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver aml_m3_codec_dai = {
+	.name = "AML-M3",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.ops = &aml_m3_codec_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL_GPL(aml_m3_codec_dai);
+
+static int aml_m3_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		break;
+	case SND_SOC_BIAS_OFF:
+	    break;
+	default:
+	    break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static int aml_m3_soc_probe(struct snd_soc_codec *codec){
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	
+	aml_m3_reset(codec, true);
+	aml_m3_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	
+	snd_soc_add_controls(codec, amlm3_snd_controls,
+				ARRAY_SIZE(amlm3_snd_controls));
+	
+	snd_soc_dapm_new_controls(dapm, aml_m3_dapm_widgets,
+				  ARRAY_SIZE(aml_m3_dapm_widgets));
+
+	snd_soc_dapm_add_routes(dapm, aml_m3_audio_map, ARRAY_SIZE(aml_m3_audio_map));
+	
+    aml_m3_codec = codec;                
+    return 0;
+}
+static int aml_m3_soc_remove(struct snd_soc_codec *codec){
+	return 0;
+}
+static int aml_m3_soc_suspend(struct snd_soc_codec *codec,	pm_message_t state){
+	printk("aml_m3_codec_suspend\n");
+	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)&~(1 << 2));
+    aml_reset_path(codec, AML_PWR_DOWN);	
+    return 0;
+}
+
+static int aml_m3_soc_resume(struct snd_soc_codec *codec){
+	printk("aml_m3_codec resume\n");
+
+    WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)|(1 << 2));
+    aml_m3_reset(codec, true);	
+    return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_m3 = {
+	.probe = 	aml_m3_soc_probe,
+	.remove = 	aml_m3_soc_remove,
+	.suspend =	aml_m3_soc_suspend,
+	.resume = 	aml_m3_soc_resume,
+	.read = aml_m3_read,
+	.write = aml_m3_write,
+	.set_bias_level = aml_m3_set_bias_level,
+	.reg_cache_size = ARRAY_SIZE(aml_m3_reg),
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 2,
+	.reg_cache_default = aml_m3_reg,
+	.dapm_widgets = aml_m3_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(aml_m3_dapm_widgets),
+	.dapm_routes = aml_m3_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(aml_m3_audio_map),
+};
+
+static int aml_m3_codec_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, 
+		&soc_codec_dev_m3, &aml_m3_codec_dai, 1);
+}
+
+static int __exit aml_m3_codec_platform_remove(struct platform_device *pdev)
+{	
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver aml_m3_codec_platform_driver = {
+	.driver = {
+		.name = "aml_m3_codec",
+		.owner = THIS_MODULE,
+		},
+	.probe = aml_m3_codec_platform_probe,
+	.remove = __exit_p(aml_m3_codec_platform_remove),
+};
+
+static int __init aml_m3_codec_modinit(void)
+{
+		return platform_driver_register(&aml_m3_codec_platform_driver);
+}
+
+static void __exit aml_m3_codec_exit(void)
+{
+		platform_driver_unregister(&aml_m3_codec_platform_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m3_codec_modinit);
+#else
+module_init(aml_m3_codec_modinit);
+#endif
+module_exit(aml_m3_codec_exit);
+
+
+MODULE_DESCRIPTION("ASoC AML M3 codec driver");
+MODULE_AUTHOR("AMLogic Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m3_codec.h b/sound/soc/aml/aml_m3_codec.h
new file mode 100644
index 000000000000..b35e33e5350a
--- /dev/null
+++ b/sound/soc/aml/aml_m3_codec.h
@@ -0,0 +1,7 @@
+#ifndef _AML_M3_CODEC_H
+#define _AML_M3_CODEC_H
+
+extern struct snd_soc_dai aml_m3_codec_dai;
+extern struct snd_soc_codec_device soc_codec_dev_aml_m3;
+
+#endif
diff --git a/sound/soc/aml/aml_m6_rt3261.c b/sound/soc/aml/aml_m6_rt3261.c
new file mode 100755
index 000000000000..fa166478528f
--- /dev/null
+++ b/sound/soc/aml/aml_m6_rt3261.c
@@ -0,0 +1,651 @@
+/*
+ * aml_m6_rt3261.c  --  SoC audio for AML M6
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/rt3261.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+
+
+#include "../codecs/rt3261/rt3261.h"
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#define HP_DET                  1
+
+struct rt3261_private_data {
+    int bias_level;
+    int clock_en;
+#if HP_DET
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+    struct switch_dev sdev; // for android
+#endif
+};
+
+#define DEBUG	1
+//#undef DEBUG
+#ifdef DEBUG
+#define dprintk(msg...) printk(msg)
+#else
+#define dprintk(msg...) while(0){}
+#endif
+
+static struct rt3261_platform_data *rt3261_snd_pdata = NULL;
+static struct rt3261_private_data* rt3261_snd_priv = NULL;
+
+static void rt3261_dev_init(void)
+{
+    if (rt3261_snd_pdata->device_init) {
+        rt3261_snd_pdata->device_init();
+    }
+}
+
+static void rt3261_dev_uninit(void)
+{
+    if (rt3261_snd_pdata->device_uninit) {
+        rt3261_snd_pdata->device_uninit();
+    }
+}
+
+static void rt3261_set_clock(int enable)
+{
+    /* set clock gating */
+    rt3261_snd_priv->clock_en = enable;
+
+    return ;
+}
+
+static void rt3261_set_output(struct snd_soc_codec *codec)
+{
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+#if 0
+    if (rt3261_snd_pdata->spk_output != RT3261_SPK_STEREO) {
+        if (rt3261_snd_pdata->spk_output == RT3261_SPK_RIGHT) {
+            snd_soc_dapm_nc_pin(dapm, "SPOL");
+
+            snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
+                0xf000,
+                RT3261_M_SPKVOL_L_TO_SPOL_MIXER | RT3261_M_SPKVOL_R_TO_SPOL_MIXER);
+        } else {
+            snd_soc_dapm_nc_pin(dapm, "SPOR");
+
+            snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
+                0xf000,
+                RT3261_M_SPKVOL_L_TO_SPOR_MIXER | RT3261_M_SPKVOL_R_TO_SPOR_MIXER);
+        }
+
+        snd_soc_update_bits(codec, RT3261_SPK_MONO_HP_OUT_CTRL,
+            RT3261_SPK_L_MUX_SEL_MASK | RT3261_SPK_R_MUX_SEL_MASK | RT3261_HP_L_MUX_SEL_MASK | RT3261_HP_R_MUX_SEL_MASK,
+            RT3261_SPK_L_MUX_SEL_SPKMIXER_L | RT3261_SPK_R_MUX_SEL_SPKMIXER_R | RT3261_HP_L_MUX_SEL_HPVOL_L | RT3261_HP_R_MUX_SEL_HPVOL_R);
+    } else {
+        snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
+            0xf000,
+            RT3261_M_SPKVOL_R_TO_SPOL_MIXER | RT3261_M_SPKVOL_L_TO_SPOR_MIXER);
+
+        snd_soc_update_bits(codec, RT3261_SPK_MONO_HP_OUT_CTRL,
+            RT3261_SPK_L_MUX_SEL_MASK | RT3261_SPK_R_MUX_SEL_MASK | RT3261_HP_L_MUX_SEL_MASK | RT3261_HP_R_MUX_SEL_MASK,
+            RT3261_SPK_L_MUX_SEL_SPKMIXER_L | RT3261_SPK_R_MUX_SEL_SPKMIXER_R | RT3261_HP_L_MUX_SEL_HPVOL_L | RT3261_HP_R_MUX_SEL_HPVOL_R);
+    }
+#endif
+}
+
+static void rt3261_set_input(struct snd_soc_codec *codec)
+{
+#if 0
+    if (rt3261_snd_pdata->mic_input == RT3261_MIC_SINGLEENDED) {
+        /* single-ended input mode */
+        snd_soc_update_bits(codec, RT3261_MIC_CTRL_1,
+            RT3261_MIC1_DIFF_INPUT_CTRL,
+            0);
+    } else {
+        /* differential input mode */
+        snd_soc_update_bits(codec, RT3261_MIC_CTRL_1,
+            RT3261_MIC1_DIFF_INPUT_CTRL,
+            RT3261_MIC1_DIFF_INPUT_CTRL);
+    }
+#endif
+}
+
+#if HP_DET
+static int rt3261_detect_hp(void)
+{
+    int flag = -1;
+
+    if (rt3261_snd_pdata->hp_detect)
+    {
+        flag = rt3261_snd_pdata->hp_detect();
+    }
+
+    return flag;
+}
+
+static void rt3261_start_timer(unsigned long delay)
+{
+    rt3261_snd_priv->timer.expires = jiffies + delay;
+    rt3261_snd_priv->timer.data = (unsigned long)rt3261_snd_priv;
+    rt3261_snd_priv->detect_flag = -1;
+    add_timer(&rt3261_snd_priv->timer);
+    rt3261_snd_priv->timer_en = 1;
+}
+
+static void rt3261_stop_timer(void)
+{
+    del_timer_sync(&rt3261_snd_priv->timer);
+    cancel_work_sync(&rt3261_snd_priv->work);
+    rt3261_snd_priv->timer_en = 0;
+    rt3261_snd_priv->detect_flag = -1;
+}
+
+static void rt3261_work_func(struct work_struct *work)
+{
+    struct rt3261_private_data *pdata = NULL;
+    struct snd_soc_codec *codec = NULL;
+    int jack_type = 0;
+    int flag = -1;
+	int status = SND_JACK_HEADPHONE;
+
+    pdata = container_of(work, struct rt3261_private_data, work);
+    codec = (struct snd_soc_codec *)pdata->data;
+
+    flag = rt3261_detect_hp();
+    if(pdata->detect_flag != flag) {
+        if (flag == 1) {
+	    jack_type = rt3261_headset_detect(codec, 1);
+            dprintk(KERN_INFO "rt3261 hp pluged jack_type: %d\n", jack_type);
+            snd_soc_jack_report(&pdata->jack, status, SND_JACK_HEADPHONE);
+            switch_set_state(&pdata->sdev, 1); 
+        } else {
+            dprintk(KERN_INFO "rt3261 hp unpluged\n");
+	    rt3261_headset_detect(codec, 0);
+            snd_soc_jack_report(&pdata->jack, 0, SND_JACK_HEADPHONE);
+            switch_set_state(&pdata->sdev, 0);
+        }
+
+        pdata->detect_flag = flag;
+    }
+}
+
+
+static void rt3261_timer_func(unsigned long data)
+{
+    struct rt3261_private_data *pdata = (struct rt3261_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&pdata->work);
+    mod_timer(&pdata->timer, jiffies + delay);
+}
+#endif
+
+static int rt3261_prepare(struct snd_pcm_substream *substream)
+{
+    dprintk(KERN_INFO "enter %s stream: %s\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture");
+#if HP_DET
+    mutex_lock(&rt3261_snd_priv->lock);
+    if (!rt3261_snd_priv->timer_en) {
+        rt3261_start_timer(msecs_to_jiffies(100));
+    }
+    mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+    return 0;
+}
+
+static int rt3261_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    dprintk(KERN_INFO "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set codec DAI clock */
+    //ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * MCLKFS_RATIO, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    //ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * MCLKFS_RATIO, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static int rt3261_voice_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    dprintk(KERN_INFO "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_A |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_DSP_A |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+    //bard 10-22 s
+    //ret = snd_soc_dai_set_pll(codec_dai, 0, RT3261_PLL1_S_MCLK, 12288000, 12288000);
+    ret = snd_soc_dai_set_pll(codec_dai, 0, RT3261_PLL1_S_MCLK, 24576000, 24576000);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai pll failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+    //bard 10-22 e
+
+    /* set codec DAI clock */
+    #if 0 //org
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256 * 6, SND_SOC_CLOCK_IN);
+    #else //bard 10-22
+    //ret = snd_soc_dai_set_sysclk(codec_dai, RT3261_SCLK_S_PLL1, params_rate(params) * 256 * 6, SND_SOC_CLOCK_IN);
+    ret = snd_soc_dai_set_sysclk(codec_dai, RT3261_SCLK_S_PLL1, params_rate(params) * 256 * 12, SND_SOC_CLOCK_IN);
+    #endif
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops rt3261_soc_ops = {
+    .prepare   = rt3261_prepare,
+    .hw_params = rt3261_hw_params,
+};
+
+static struct snd_soc_ops rt3261_voice_ops = {
+	.prepare   = rt3261_prepare,
+	.hw_params = rt3261_voice_hw_params,
+};
+
+static int rt3261_set_bias_level(struct snd_soc_card *card,
+			      enum snd_soc_bias_level level)
+{
+    int ret = 0;
+
+    dprintk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+
+    if (rt3261_snd_priv->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+#if HP_DET
+        mutex_lock(&rt3261_snd_priv->lock);
+        if (!rt3261_snd_priv->timer_en) {
+            rt3261_start_timer(msecs_to_jiffies(100));
+        }
+        mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!rt3261_snd_priv->clock_en) {
+            rt3261_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (rt3261_snd_priv->clock_en) {
+            rt3261_set_clock(0);
+        }
+#if HP_DET
+        /* stop timer */
+        mutex_lock(&rt3261_snd_priv->lock);
+        if (rt3261_snd_priv->timer_en) {
+            rt3261_stop_timer();
+        }
+        mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+        break;
+    default:
+        return ret;
+    }
+
+    rt3261_snd_priv->bias_level = (int)level;
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rt3261_suspend_pre(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+#if HP_DET
+    /* stop timer */
+    mutex_lock(&rt3261_snd_priv->lock);
+    if (rt3261_snd_priv->timer_en) {
+        rt3261_stop_timer();
+    }
+    mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+    return 0;
+}
+
+static int rt3261_suspend_post(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int rt3261_resume_pre(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int rt3261_resume_post(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define rt3261_suspend_pre  NULL
+#define rt3261_suspend_post NULL
+#define rt3261_resume_pre   NULL
+#define rt3261_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget rt3261_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+};
+
+static const struct snd_soc_dapm_route rt3261_dapm_intercon[] = {
+    {"Ext Spk", NULL, "SPOL"},
+    {"Ext Spk", NULL, "SPOR"},
+
+    {"HP", NULL, "HPOL"},
+    {"HP", NULL, "HPOR"},
+};
+
+#if HP_DET
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADPHONE,
+    }
+};
+#endif
+static int rt3261_codec_init2(struct snd_soc_pcm_runtime *rtd)
+{
+    return 0;
+}
+
+static int rt3261_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_codec *codec = rtd->codec;
+    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    int ret = 0;
+
+    dprintk(KERN_DEBUG "enter %s rt3261_snd_pdata: %p\n", __func__, rt3261_snd_pdata);
+
+    /* Add specific widgets */
+    snd_soc_dapm_new_controls(dapm, rt3261_dapm_widgets,
+                  ARRAY_SIZE(rt3261_dapm_widgets));
+    /* Set up specific audio path interconnects */
+    snd_soc_dapm_add_routes(dapm, rt3261_dapm_intercon, ARRAY_SIZE(rt3261_dapm_intercon));
+#if 0 //we have 3g, so do not set endpoint,add jf.s
+    /* Setup spk/hp/mono output */
+    rt3261_set_output(codec);
+
+    /* Setuo mic input */
+    rt3261_set_input(codec);
+#endif
+    /* not connected */
+    snd_soc_dapm_nc_pin(dapm, "MONO");
+    snd_soc_dapm_nc_pin(dapm, "AUXO2");
+
+    snd_soc_dapm_nc_pin(dapm, "DMIC");
+    snd_soc_dapm_nc_pin(dapm, "AXIL");
+    snd_soc_dapm_nc_pin(dapm, "AXIR");
+
+    /* always connected */
+    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+
+    /* disable connected */
+    snd_soc_dapm_disable_pin(dapm, "HP");
+
+    snd_soc_dapm_sync(dapm);
+
+#if HP_DET
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &rt3261_snd_priv->jack);
+    if (ret) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&rt3261_snd_priv->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret) {
+            dprintk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+    rt3261_snd_priv->data= (void*)codec;
+
+    init_timer(&rt3261_snd_priv->timer);
+    rt3261_snd_priv->timer.function = rt3261_timer_func;
+    rt3261_snd_priv->timer.data = (unsigned long)rt3261_snd_priv;
+
+    INIT_WORK(&rt3261_snd_priv->work, rt3261_work_func);
+    mutex_init(&rt3261_snd_priv->lock);
+#endif
+
+    return 0;
+}
+
+static struct snd_soc_dai_link rt3261_dai_link[] = {
+    {
+        .name = "RT3261",
+        .stream_name = "RT3261 PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "rt3261-aif1",
+        .init = rt3261_codec_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "rt3261.1-001c",
+        .ops = &rt3261_soc_ops,
+    },
+#if 1 //add jf.s
+    {
+        .name = "RT3261_BT_VOICE",
+        .stream_name = "RT3261 BT PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "rt3261-aif2",
+        .init = rt3261_codec_init2,
+        .platform_name = "aml-audio.0",
+        .codec_name = "rt3261.1-001c",
+        .ops = &rt3261_voice_ops,
+    },
+#endif
+};
+#define POP_TIME  10   //10ms
+static struct snd_soc_card snd_soc_rt3261 = {
+    .name = "AML-RT3261",
+    .driver_name = "SOC-Audio",
+    .dai_link = &rt3261_dai_link[0],
+    .num_links = ARRAY_SIZE(rt3261_dai_link),
+    .set_bias_level = rt3261_set_bias_level,
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = rt3261_suspend_pre,
+	.suspend_post   = rt3261_suspend_post,
+	.resume_pre     = rt3261_resume_pre,
+	.resume_post    = rt3261_resume_post,
+#endif
+//	.pop_time 		= POP_TIME,   //add by jf.s for power up/down widgets
+};
+
+static struct platform_device *rt3261_snd_device = NULL;
+
+static int rt3261_audio_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    printk("rt3261, rt3261_audio_probe\n");
+    rt3261_snd_pdata = pdev->dev.platform_data;
+    snd_BUG_ON(!rt3261_snd_pdata);
+
+    rt3261_snd_priv = (struct rt3261_private_data*)kzalloc(sizeof(struct rt3261_private_data), GFP_KERNEL);
+    if (!rt3261_snd_priv) {
+        dprintk(KERN_ERR "ASoC: Platform driver data allocation failed\n");
+        return -ENOMEM;
+    }
+
+    rt3261_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!rt3261_snd_device) {
+        dprintk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    platform_set_drvdata(rt3261_snd_device, &snd_soc_rt3261);
+
+    ret = platform_device_add(rt3261_snd_device);
+    if (ret) {
+        dprintk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto err_device_add;
+    }
+
+    rt3261_snd_priv->bias_level = SND_SOC_BIAS_OFF;
+    rt3261_snd_priv->clock_en = 0;
+
+#if HP_DET
+    rt3261_snd_priv->sdev.name = "h2w";//for report headphone to android
+    ret = switch_dev_register(&rt3261_snd_priv->sdev);
+    if (ret < 0){
+        printk(KERN_ERR "ASoC: register switch dev failed\n");
+        goto err;
+    }
+#endif
+
+
+    rt3261_dev_init();
+
+    return ret;
+
+err_device_add:
+    platform_device_put(rt3261_snd_device);
+
+err:
+    kfree(rt3261_snd_priv);
+
+    return ret;
+}
+
+static int rt3261_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    rt3261_dev_uninit();
+
+    platform_device_put(rt3261_snd_device);
+    kfree(rt3261_snd_priv);
+
+    rt3261_snd_device = NULL;
+    rt3261_snd_priv = NULL;
+    rt3261_snd_pdata = NULL;
+
+    return ret;
+}
+
+static struct platform_driver aml_m6_rt3261_driver = {
+    .probe  = rt3261_audio_probe,
+    .remove = __devexit_p(rt3261_audio_remove),
+    .driver = {
+        .name = "aml_rt3261_audio",
+        .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m6_rt3261_init(void)
+{
+    return platform_driver_register(&aml_m6_rt3261_driver);
+}
+
+static void __exit aml_m6_rt3261_exit(void)
+{
+    platform_driver_unregister(&aml_m6_rt3261_driver);
+}
+
+module_init(aml_m6_rt3261_init);
+module_exit(aml_m6_rt3261_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML RT3261 audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m6_rt5631.c b/sound/soc/aml/aml_m6_rt5631.c
new file mode 100755
index 000000000000..1c2582793dfc
--- /dev/null
+++ b/sound/soc/aml/aml_m6_rt5631.c
@@ -0,0 +1,536 @@
+/*
+ * aml_m6_asoc_audio.c  --  SoC audio for AML M6
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/rt5631.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+
+//#include "../codecs/rt5631.h"
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+#define DRV_NAME "aml_rt5631_card"
+#define HP_DET                  1
+#define HP_IRQ                  0
+struct aml_audio_private_data {
+    int bias_level;
+    int clock_en;
+	int gpio_hp_det;
+	bool det_pol_inv;
+	struct pinctrl *pin_ctl;
+
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+
+	struct switch_dev sdev; // for android
+};
+
+static void aml_set_clock(int enable)
+{
+    /* set clock gating */
+    //p_aml_audio->clock_en = enable;
+
+    return ;
+}
+
+#if HP_DET
+static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
+{
+    p_aml_audio->timer.expires = jiffies + delay;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->detect_flag = -1;
+    add_timer(&p_aml_audio->timer);
+    p_aml_audio->timer_en = 1;
+}
+
+static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
+{
+    del_timer_sync(&p_aml_audio->timer);
+    cancel_work_sync(&p_aml_audio->work);
+    p_aml_audio->timer_en = 0;
+    p_aml_audio->detect_flag = -1;
+}
+
+static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
+{
+	int val = amlogic_get_value(p_aml_audio->gpio_hp_det,"rt5631");
+	return p_aml_audio->det_pol_inv ? (!val):val; 
+}
+
+
+static void aml_asoc_work_func(struct work_struct *work)
+{
+    struct aml_audio_private_data *p_aml_audio = NULL;
+    struct snd_soc_card *card = NULL;
+    int jack_type = 0;
+    int flag = -1;
+	int status = SND_JACK_HEADPHONE;
+    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
+    card = (struct snd_soc_card *)p_aml_audio->data;
+
+    flag = aml_audio_hp_detect(p_aml_audio);
+
+    if(p_aml_audio->detect_flag != flag) {
+        if (flag == 1) {
+			switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
+            printk(KERN_INFO "aml aduio hp pluged jack_type: %d\n", jack_type);
+            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+        } else {
+            printk(KERN_INFO "aml audio hp unpluged\n");
+			switch_set_state(&p_aml_audio->sdev, 0);
+            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+        }
+
+        p_aml_audio->detect_flag = flag;
+    }
+}
+
+
+static void aml_asoc_timer_func(unsigned long data)
+{
+    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&p_aml_audio->work);
+    mod_timer(&p_aml_audio->timer, jiffies + delay);
+}
+#endif
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+    .hw_params = aml_asoc_hw_params,
+};
+
+static int aml_set_bias_level(struct snd_soc_card *card,
+		struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+    int ret = 0;
+	struct aml_audio_private_data * p_aml_audio;
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+
+    if (p_aml_audio->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!p_aml_audio->clock_en) {
+            aml_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    default:
+        return ret;
+    }
+
+    p_aml_audio->bias_level = (int)level;
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0//HP_DET
+    /* stop timer */
+    mutex_lock(&p_aml_audio->lock);
+    if (p_aml_audio->timer_en) {
+       // rt5631_stop_timer();
+    }
+    mutex_unlock(&p_aml_audio->lock);
+#endif
+    return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define aml_suspend_pre  NULL
+#define aml_suspend_post NULL
+#define aml_resume_pre   NULL
+#define aml_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MAIN MIC", NULL),
+    SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADPHONE,
+    }
+};
+#if HP_IRQ
+static struct snd_soc_jack_gpio aml_audio_hp_jack_gpio = {
+	.name = "Headset detection",
+	.report = SND_JACK_HEADSET,
+	.debounce_time = 150,
+};
+#endif
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+    struct snd_soc_codec *codec = rtd->codec;
+    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aml_audio_private_data * p_aml_audio;
+    int ret = 0;
+	
+    printk(KERN_DEBUG "enter %s \n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    /* Add specific widgets */
+    snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+                  ARRAY_SIZE(aml_asoc_dapm_widgets));
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
+    if (ret) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret) {
+            printk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+#if HP_IRQ	
+	p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"rt5631_gpio",0);
+
+	if (gpio_is_valid(p_aml_audio->gpio_hp_det)) {
+		aml_audio_hp_jack_gpio.gpio = p_aml_audio->gpio_hp_det;
+		snd_soc_jack_add_gpios(&p_aml_audio->jack,
+						1, &aml_audio_hp_jack_gpio);
+	}
+#endif
+#if HP_DET
+    init_timer(&p_aml_audio->timer);
+    p_aml_audio->timer.function = aml_asoc_timer_func;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->data= (void*)card;
+
+    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
+    mutex_init(&p_aml_audio->lock);
+
+    mutex_lock(&p_aml_audio->lock);
+    if (!p_aml_audio->timer_en) {
+        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
+    }
+    mutex_unlock(&p_aml_audio->lock);
+
+#endif
+
+    return 0;
+}
+
+static struct snd_soc_dai_link aml_codec_dai_link[] = {
+    {
+        .name = "RT5631",
+        .stream_name = "AML PCM",
+        .cpu_dai_name = "aml-dai0",
+        //.codec_dai_name = "rt5631-hifi",
+        .init = aml_asoc_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "rt5631.1-001a",
+        .ops = &aml_asoc_ops,
+    },
+};
+
+static struct snd_soc_card aml_snd_soc_card = {
+    //.name = "AML-RT5631",
+    .driver_name = "SOC-Audio",
+    .dai_link = &aml_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(aml_codec_dai_link),
+    .set_bias_level = aml_set_bias_level,
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = aml_suspend_pre,
+	.suspend_post   = aml_suspend_post,
+	.resume_pre     = aml_resume_pre,
+	.resume_post    = aml_resume_post,
+#endif
+};
+
+static void aml_m6_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+	const char *str;
+	int ret;
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "rt5631_audio");
+#if HP_DET
+	ret = of_property_read_string(card->dev->of_node, "rt5631_gpio", &str);
+	if (ret) {
+		printk("rt5631: faild to get gpio!\n");
+	}
+	p_aml_audio->gpio_hp_det = amlogic_gpio_name_map_num(str);
+//	p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"rt5631_gpio",0);
+	p_aml_audio->det_pol_inv = of_property_read_bool(card->dev->of_node,"hp_det_inv");
+	amlogic_gpio_request_one(p_aml_audio->gpio_hp_det,GPIOF_IN,"rt5631");
+#endif
+	printk("=%s==,aml_m6_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
+}
+
+static void aml_m6_pinmux_deinit(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	amlogic_gpio_free(p_aml_audio->gpio_hp_det,"rt5631");
+	devm_pinctrl_put(p_aml_audio->pin_ctl);
+}
+static int aml_m6_audio_probe(struct platform_device *pdev)
+{
+	//struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &aml_snd_soc_card;
+	struct aml_audio_private_data *p_aml_audio;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s\n", __func__);
+
+#ifdef CONFIG_USE_OF
+	p_aml_audio = devm_kzalloc(&pdev->dev,
+			sizeof(struct aml_audio_private_data), GFP_KERNEL);
+	if (!p_aml_audio) {
+		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+	snd_soc_card_set_drvdata(card, p_aml_audio);
+	if (!(pdev->dev.of_node)) {
+		dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
+	if (ret)
+		goto err;
+	
+	ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
+			0, &aml_codec_dai_link[0].codec_dai_name);
+	if (ret)
+		goto err;
+
+	ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+	if (ret)
+		goto err;
+
+//	aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+//			pdev->dev.of_node, "aml,audio-codec", 0);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+			ret);
+		goto err;
+	}
+
+	aml_m6_pinmux_init(card);
+
+	p_aml_audio->sdev.name = "h2w";//for report headphone to android
+	ret = switch_dev_register(&p_aml_audio->sdev);
+	if (ret < 0){
+			printk(KERN_ERR "ASoC: register switch dev failed\n");
+			goto err;
+	}
+
+	return 0;
+#endif
+
+err:
+    kfree(p_aml_audio);
+    return ret;
+}
+
+static int aml_m6_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct aml_audio_private_data *p_aml_audio;
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+#if HP_IRQ
+
+	snd_soc_jack_free_gpios(&p_aml_audio->jack, 1,//
+			&aml_audio_hp_jack_gpio);//
+#endif
+	snd_soc_unregister_card(card);
+#if HP_DET
+	/* stop timer */
+	mutex_lock(&p_aml_audio->lock);
+	if (p_aml_audio->timer_en) {
+		aml_audio_stop_timer(p_aml_audio);
+	}
+	mutex_unlock(&p_aml_audio->lock);
+#endif
+
+	aml_m6_pinmux_deinit(card);
+    kfree(p_aml_audio);
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "sound_card,rt5631",//"amlogic,aml_rt5631_audio",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_m6_rt5631_audio_driver = {
+    .probe  = aml_m6_audio_probe,
+    .remove = aml_m6_audio_remove,
+    .driver = {
+        .name = DRV_NAME,//"aml_rt5631_audio",
+        .owner = THIS_MODULE,
+        .pm = &snd_soc_pm_ops,
+        .of_match_table = amlogic_audio_dt_match,
+    },
+};
+
+static int __init aml_m6_rt5631_audio_init(void)
+{
+    return platform_driver_register(&aml_m6_rt5631_audio_driver);
+}
+
+static void __exit aml_m6_rt5631_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m6_rt5631_audio_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m6_rt5631_audio_init);
+#else
+module_init(aml_m6_rt5631_audio_init);
+#endif
+module_exit(aml_m6_rt5631_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_M6 audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
+
diff --git a/sound/soc/aml/aml_m6_wm8960.c b/sound/soc/aml/aml_m6_wm8960.c
new file mode 100644
index 000000000000..5138b49ac767
--- /dev/null
+++ b/sound/soc/aml/aml_m6_wm8960.c
@@ -0,0 +1,624 @@
+/*
+ * aml_m6_asoc_audio.c  --  SoC audio for AML M6
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/wm8960.h>
+#include <linux/delay.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+
+#include "../codecs/wm8960.h"
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+#define DRV_NAME "aml_wm8960_card"
+#define HP_DET                  1
+#define HP_IRQ                  0
+struct aml_audio_private_data {
+    int bias_level;
+    int clock_en;
+    int gpio_hp_det;
+    bool det_pol_inv;
+    bool dis_hp_det;  /* Disable Headphone detect through codec*/
+    struct pinctrl *pin_ctl;
+
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+
+    struct switch_dev sdev; // for android
+};
+
+static void aml_set_clock(int enable)
+{
+    /* set clock gating */
+    //p_aml_audio->clock_en = enable;
+
+    return ;
+}
+
+#if HP_DET
+static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
+{
+    //printk("**********%s*************\n",__func__);
+    p_aml_audio->timer.expires = jiffies + delay;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->detect_flag = -1;
+    add_timer(&p_aml_audio->timer);
+    p_aml_audio->timer_en = 1;
+}
+
+static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
+{
+   // printk("**********%s*************\n",__func__);
+    del_timer_sync(&p_aml_audio->timer);
+    cancel_work_sync(&p_aml_audio->work);
+    p_aml_audio->timer_en = 0;
+    p_aml_audio->detect_flag = -1;
+}
+
+static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
+{
+    int val = amlogic_get_value(p_aml_audio->gpio_hp_det,"wm8960");
+    //printk("***********%s*****val=%d******\n",__func__,val);
+    return p_aml_audio->det_pol_inv ? val:(!val); 
+}
+
+
+static void aml_asoc_work_func(struct work_struct *work)
+{
+    struct aml_audio_private_data *p_aml_audio = NULL;
+    struct snd_soc_card *card = NULL;
+    int jack_type = 0;
+    int flag = -1;
+    int status = SND_JACK_HEADPHONE;
+    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
+    card = (struct snd_soc_card *)p_aml_audio->data;
+
+    flag = aml_audio_hp_detect(p_aml_audio);
+   // printk("******%s***flag=%d**\n",__func__,flag);
+    if(p_aml_audio->detect_flag != flag) {
+        if (flag == 1) {
+            switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
+            printk(KERN_INFO "aml aduio hp pluged jack_type: %d\n", jack_type);
+            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+        } else {
+            printk(KERN_INFO "aml audio hp unpluged\n");
+            switch_set_state(&p_aml_audio->sdev, 0);
+            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+        }
+
+        p_aml_audio->detect_flag = flag;
+    }
+}
+
+
+static void aml_asoc_timer_func(unsigned long data)
+{
+    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&p_aml_audio->work);
+    mod_timer(&p_aml_audio->timer, jiffies + delay);
+}
+#endif
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+    /*set codec DAI sysclk divider,now 512fs for MCLK,sysclk divide 2  */
+    snd_soc_dai_set_clkdiv(codec_dai,WM8960_SYSCLKDIV,WM8960_SYSCLK_DIV_2);
+    
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+    .hw_params = aml_asoc_hw_params,
+};
+
+static int aml_set_bias_level(struct snd_soc_card *card,
+        struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct aml_audio_private_data * p_aml_audio;
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+   // printk("*****enter %s level: %d\n", __func__, level);
+    if (p_aml_audio->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!p_aml_audio->clock_en) {
+            aml_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    default:
+        return ret;
+    }
+
+    p_aml_audio->bias_level = (int)level;
+   // dapm->bias_level = level;
+
+    //snd_soc_dapm_sync(dapm);
+
+   // printk("**pp**dapm->codec=%d*****\n",dapm->codec);
+
+    return ret;
+}
+
+
+#ifdef CONFIG_PM_SLEEP
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+#if 0//HP_DET
+    /* stop timer */
+    mutex_lock(&p_aml_audio->lock);
+    if (p_aml_audio->timer_en) {
+       // rt5631_stop_timer();
+    }
+    mutex_unlock(&p_aml_audio->lock);
+#endif
+    return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+    return 0;
+}
+#else
+#define aml_suspend_pre  NULL
+#define aml_suspend_post NULL
+#define aml_resume_pre   NULL
+#define aml_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("Mic", NULL),
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADSET,
+    }
+};
+#if HP_IRQ
+static struct snd_soc_jack_gpio aml_audio_hp_jack_gpio = {
+    .name = "Headset detection",
+    .report = SND_JACK_HEADPHONE,
+    .debounce_time = 150,
+};
+#endif
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_card *card = rtd->card;
+    struct snd_soc_codec *codec = rtd->codec;
+    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    struct aml_audio_private_data * p_aml_audio;
+    int ret = 0;
+    
+    printk(KERN_DEBUG "enter %s \n", __func__);
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    /* Add specific widgets */
+  //  snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+ //                ARRAY_SIZE(aml_asoc_dapm_widgets));
+    /* set ADCLRC/GPIO1 Pin Function Select */
+    snd_soc_update_bits(codec, WM8960_IFACE2, (1 << 6), (1 << 6));
+
+    /* not connected */
+    snd_soc_dapm_nc_pin(dapm, "LINPUT3");
+    snd_soc_dapm_nc_pin(dapm, "RINPUT3");
+    
+    snd_soc_dapm_nc_pin(dapm, "OUT3");
+
+    /* always connected */
+    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+    snd_soc_dapm_enable_pin(dapm, "Mic");
+
+    /* disable connected */
+    snd_soc_dapm_disable_pin(dapm, "HP");
+
+    snd_soc_dapm_sync(dapm);
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
+    if (ret) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret) {
+            printk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+#if HP_IRQ  
+    p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"wm8960_gpio",0);
+
+    if (gpio_is_valid(p_aml_audio->gpio_hp_det)) {
+        aml_audio_hp_jack_gpio.gpio = p_aml_audio->gpio_hp_det;
+        snd_soc_jack_add_gpios(&p_aml_audio->jack,
+                        1, &aml_audio_hp_jack_gpio);
+    }
+#endif
+#if HP_DET
+    init_timer(&p_aml_audio->timer);
+    p_aml_audio->timer.function = aml_asoc_timer_func;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->data= (void*)card;
+
+    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
+    mutex_init(&p_aml_audio->lock);
+
+    mutex_lock(&p_aml_audio->lock);
+    if (!p_aml_audio->timer_en) {
+        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
+    }
+    mutex_unlock(&p_aml_audio->lock);
+
+#endif
+
+//p_aml_audio->dis_hp_det = of_property_read_bool(card->dev->of_node,"dis_hp_det");
+     ret = of_property_read_u32(card->dev->of_node,"dis_hp_det",&p_aml_audio->dis_hp_det);
+     printk("******p_aml_audio->dis_hp_det=%d***\n",p_aml_audio->dis_hp_det);
+    if(ret){
+        printk("don't find match dis_hp_det\n");
+        goto out1;
+    }
+  
+    if(!p_aml_audio->dis_hp_det){
+        printk("****mm**p_aml_audio->dis_hp_det\n");
+        //JD2 as headphone detect
+        snd_soc_update_bits(codec,27, 0x008, 0x008);// OUT3 buffer Enabled and disabled with HPL and HPR jack detect              
+        //INSERT_DELAY    [1] 
+        mdelay(1);      
+        ///GPIO1 output the "jack detect output"
+        snd_soc_update_bits(codec,48, 0x03A, 0x03A);// JD2 used for Jack Detect Input, GPIO function = jack detect output 
+
+        snd_soc_update_bits(codec,24, 0x040, 0x040);// HPDETECT LOW = Speaker 
+    
+        snd_soc_update_bits(codec, 23, 0x1D1, 0x1D1);
+        mdelay(500);
+
+    }
+out1:    
+   
+    return 0;
+}
+
+static struct snd_soc_dai_link aml_codec_dai_link[] = {
+    {
+        .name = "WM8960",
+        .stream_name = "AML PCM",
+        .cpu_dai_name = "aml-dai0",
+       // .codec_dai_name = "wm8960-hifi",
+        .init = aml_asoc_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "wm8960.1-001a",
+        .ops = &aml_asoc_ops,
+    },
+};
+
+static struct snd_soc_card aml_snd_soc_card = {
+    //.name = "AML-WM8960",
+    .driver_name = "SOC-Audio",
+    .dai_link = &aml_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(aml_codec_dai_link),
+    .dapm_widgets = aml_asoc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(aml_asoc_dapm_widgets),
+    .set_bias_level = aml_set_bias_level,
+    //.set_bias_level_post = aml_set_bias_level_post,
+    .fully_routed = true,
+#ifdef CONFIG_PM_SLEEP
+    .suspend_pre    = aml_suspend_pre,
+    .suspend_post   = aml_suspend_post,
+    .resume_pre     = aml_resume_pre,
+    .resume_post    = aml_resume_post,
+#endif
+};
+
+static void aml_m6_pinmux_init(struct snd_soc_card *card)
+{
+    struct aml_audio_private_data *p_aml_audio;
+    const char *str;
+    int ret;
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+    p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "wm8960_audio");
+#if HP_DET
+    //p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"wm8960_gpio",0);
+    ret = of_property_read_string(card->dev->of_node, "wm8960_gpio", &str);
+    if (ret) {
+        printk("wm8960: faild to get gpio!\n");
+    }
+    p_aml_audio->gpio_hp_det = amlogic_gpio_name_map_num(str);
+    p_aml_audio->det_pol_inv = of_property_read_bool(card->dev->of_node,"hp_det_inv");
+    amlogic_gpio_request_one(p_aml_audio->gpio_hp_det,GPIOF_IN,"wm8960");
+#endif
+    printk("=%s==,aml_m6_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
+}
+
+static void aml_m6_pinmux_deinit(struct snd_soc_card *card)
+{
+    struct aml_audio_private_data *p_aml_audio;
+
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    amlogic_gpio_free(p_aml_audio->gpio_hp_det,"wm8960");
+    devm_pinctrl_put(p_aml_audio->pin_ctl);
+}
+
+/*
+static struct device_node * find_avaliable_asoc_device(struct device_node *pnode,
+    const char *name)
+{
+    struct device_node *sound_cardp;
+    struct device_node *np;
+    printk(KERN_DEBUG "enter %s \n",__func__);
+    sound_cardp = pnode;
+
+    for (np = of_get_next_child(sound_cardp, NULL); np;
+            np = of_get_next_child(sound_cardp, np)) {
+        int status = of_device_is_available(np); 
+        if(status){
+            printk("find usable sound card in the parent node of %s\n",name);      
+            of_node_put(sound_cardp);
+            return np;
+        }else{
+            continue;
+        }   
+    }
+    return NULL;
+}
+
+*/       
+static int aml_m6_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *npc;
+    struct snd_soc_card *card = &aml_snd_soc_card;
+    struct aml_audio_private_data *p_aml_audio;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    printk("***enter %s\n", __func__);
+
+#ifdef CONFIG_USE_OF
+
+    p_aml_audio = devm_kzalloc(&pdev->dev,
+            sizeof(struct aml_audio_private_data), GFP_KERNEL);
+    if (!p_aml_audio) {
+        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    card->dev = &pdev->dev;
+    platform_set_drvdata(pdev, card);
+    snd_soc_card_set_drvdata(card, p_aml_audio);
+    if (!(pdev->dev.of_node)) {
+        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
+    if (ret)
+        goto err;
+
+    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
+            0, &aml_codec_dai_link[0].codec_dai_name);
+    if (ret)
+        goto err;
+
+    ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+    if (ret)
+        goto err;
+
+  //  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+  //          pdev->dev.of_node, "aml,audio-codec", 0);
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+            ret);
+        goto err;
+    }
+
+    aml_m6_pinmux_init(card);
+
+    p_aml_audio->sdev.name = "h2w";//for report headphone to android
+    ret = switch_dev_register(&p_aml_audio->sdev);
+    if (ret < 0){
+            printk(KERN_ERR "ASoC: register switch dev failed\n");
+            goto err;
+    }
+
+    return 0;
+#endif
+
+err:
+    kfree(p_aml_audio);
+    return ret;
+}
+
+static int aml_m6_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *npc;
+    struct snd_soc_card *card;
+    struct aml_audio_private_data *p_aml_audio;
+
+    card = platform_get_drvdata(pdev);  
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+#if HP_IRQ
+
+    snd_soc_jack_free_gpios(&p_aml_audio->jack, 1,//
+            &aml_audio_hp_jack_gpio);//
+#endif
+    snd_soc_unregister_card(card);
+#if HP_DET
+    /* stop timer */
+    mutex_lock(&p_aml_audio->lock);
+    if (p_aml_audio->timer_en) {
+        aml_audio_stop_timer(p_aml_audio);
+    }
+    mutex_unlock(&p_aml_audio->lock);
+#endif
+
+    aml_m6_pinmux_deinit(card);
+    kfree(p_aml_audio);
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+    {   .compatible = "sound_card,wm8960",//"amlogic,aml_rt5631_audio",
+    },
+    {},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_m6_wm8960_audio_driver = {
+    .probe  = aml_m6_audio_probe,
+    .remove = aml_m6_audio_remove,
+    .driver = {
+        .name = DRV_NAME,//"aml_rt5631_audio",
+        .owner = THIS_MODULE,
+        .pm = &snd_soc_pm_ops,
+        .of_match_table = amlogic_audio_dt_match,
+    },
+};
+
+static int __init aml_m6_wm8960_audio_init(void)
+{
+    return platform_driver_register(&aml_m6_wm8960_audio_driver);
+}
+
+static void __exit aml_m6_wm8960_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m6_wm8960_audio_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m6_wm8960_audio_init);
+#else
+module_init(aml_m6_wm8960_audio_init);
+#endif
+module_exit(aml_m6_wm8960_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_M6 audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
+
+
diff --git a/sound/soc/aml/aml_m6tv_audio.c b/sound/soc/aml/aml_m6tv_audio.c
new file mode 100644
index 000000000000..79fb11041787
--- /dev/null
+++ b/sound/soc/aml/aml_m6tv_audio.c
@@ -0,0 +1,338 @@
+/*
+	amlogic  M6TV sound card machine   driver code.
+	it support multi-codec on board, one codec as the main codec,others as
+	aux devices.
+*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+#include <sound/aml_m6tv_audio.h>
+
+static struct platform_device *m6tv_audio_snd_device = NULL;
+static struct m6tv_audio_codec_platform_data *m6tv_audio_snd_pdata = NULL;
+//static struct m6tv_audio_private_data* m6tv_audio_snd_priv = NULL;
+#define CODEC_DEBUG  printk
+static void m6tv_audio_dev_init(void)
+{
+    if (m6tv_audio_snd_pdata->device_init) {
+        m6tv_audio_snd_pdata->device_init();
+    }
+}
+
+static void m6tv_audio_dev_uninit(void)
+{
+    if (m6tv_audio_snd_pdata->device_uninit) {
+        m6tv_audio_snd_pdata->device_uninit();
+    }
+}
+static int m6tv_audio_prepare(struct snd_pcm_substream *substream)
+{
+    CODEC_DEBUG( "enter %s stream: %s\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture");
+    return 0;
+}
+static int m6tv_audio_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+    CODEC_DEBUG( "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+static struct snd_soc_ops m6tv_audio_soc_ops = {
+    .prepare   = m6tv_audio_prepare,
+    .hw_params = m6tv_audio_hw_params,
+};	
+
+
+static int m6tv_audio_set_bias_level(struct snd_soc_card *card,
+					enum snd_soc_bias_level level)
+{
+	int ret = 0;
+    	CODEC_DEBUG( "enter %s level: %d\n", __func__, level);
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int m6tv_audio_suspend_pre(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+
+static int m6tv_audio_suspend_post(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+
+static int m6tv_audio_resume_pre(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+
+static int m6tv_audio_resume_post(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define m6tv_audio_suspend_pre  NULL
+#define m6tv_audio_suspend_post NULL
+#define m6tv_audio_resume_pre   NULL
+#define m6tv_audio_resume_post  NULL
+#endif
+
+static int m6tv_audio_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_codec *codec = rtd->codec;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    int ret = 0;
+
+    CODEC_DEBUG( "enter %s\n", __func__);
+
+  
+    return 0;
+}
+#ifdef CONFIG_SND_AML_M6TV_STA380
+static int m6tv_sta381xx_init(struct snd_soc_dapm_context *dapm)
+{
+	CODEC_DEBUG("~~~~%s\n", __func__);
+
+	snd_soc_codec_set_sysclk(dapm->codec, 1, 48000 * 512, 0);
+	return 0;
+}
+#endif
+#ifdef CONFIG_SND_AML_M6TV_TAS5711
+static int m6tv_tas5711_init(struct snd_soc_dapm_context *dapm)
+{
+	struct snd_soc_codec *codec = dapm->codec;
+	CODEC_DEBUG("~~~~%s\n", __func__);
+
+	return 0;
+}
+#endif
+static struct snd_soc_dai_link m6tv_audio_dai_link[] = {
+#ifdef CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC
+    {
+        .name = "syno9629",
+        .stream_name = "SYNO9629 PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "syno9629-hifi",
+        .init = m6tv_audio_codec_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "syno9629.0",
+        .ops = &m6tv_audio_soc_ops,
+    },
+#endif    
+};
+struct snd_soc_aux_dev m6tv_audio_aux_dev[] = {
+#ifdef CONFIG_SND_AML_M6TV_RT5631	
+	{
+		.name = "rt5631",
+		.codec_name = "rt5631.0-001a",
+		.init = NULL,
+	},
+#endif	
+#ifdef CONFIG_SND_AML_M6TV_STA380
+	{
+		.name = "sta381xx",
+		.codec_name = "sta381xx.0-001c",
+		.init = m6tv_sta381xx_init,
+	},
+#endif
+#ifdef CONFIG_SND_AML_M6TV_TAS5711
+	{
+		.name = "tas5711",
+		.codec_name = "tas5711.0-001b",
+		.init = m6tv_tas5711_init,
+	},
+#endif
+};
+
+static struct snd_soc_codec_conf m6tv_audio_codec_conf[] = {
+#ifdef CONFIG_SND_AML_M6TV_RT5631	
+	
+	{
+		.dev_name = "rt5631.0-001a",
+		.name_prefix = "b",
+	},
+#endif
+#ifdef CONFIG_SND_AML_M6TV_STA380	
+	{
+		.dev_name = "sta381xx.0-001c",
+		.name_prefix = "AMP",
+	},
+#endif
+#ifdef CONFIG_SND_AML_M6TV_TAS5711	
+	{
+		.dev_name = "tas5711.0-001b",
+		.name_prefix = "AMP",
+	},
+#endif
+};
+static struct snd_soc_card snd_soc_m6tv_audio = {
+    .name = "AML-M6TV",
+    .driver_name = "SOC-Audio",
+    .dai_link = m6tv_audio_dai_link,
+    .num_links = ARRAY_SIZE(m6tv_audio_dai_link),
+    .set_bias_level = m6tv_audio_set_bias_level,
+    .aux_dev = m6tv_audio_aux_dev,
+    .num_aux_devs = ARRAY_SIZE(m6tv_audio_aux_dev),
+    .codec_conf = m6tv_audio_codec_conf,
+    .num_configs = ARRAY_SIZE(m6tv_audio_codec_conf),
+    
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = m6tv_audio_suspend_pre,
+	.suspend_post   = m6tv_audio_suspend_post,
+	.resume_pre     = m6tv_audio_resume_pre,
+	.resume_post    = m6tv_audio_resume_post,
+#endif
+};
+
+
+
+
+
+
+static int m6tv_audio_audio_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	m6tv_audio_snd_pdata = pdev->dev.platform_data;
+	snd_BUG_ON(!m6tv_audio_snd_pdata);
+#if 0
+	m6tv_audio_snd_priv = (struct m6tv_audio_private_data*)kzalloc(sizeof(struct m6tv_audio_private_data), GFP_KERNEL);
+	if (!m6tv_audio_snd_priv) {
+		CODEC_DEBUG(KERN_ERR "ASoC: Platform driver data allocation failed\n");
+		return -ENOMEM;
+	}
+#endif
+	m6tv_audio_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!m6tv_audio_snd_device) {
+		CODEC_DEBUG(KERN_ERR "ASoC: Platform device allocation failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	platform_set_drvdata(m6tv_audio_snd_device, &snd_soc_m6tv_audio);
+	m6tv_audio_snd_device->dev.platform_data = m6tv_audio_snd_pdata;
+
+	ret = platform_device_add(m6tv_audio_snd_device);
+	if (ret) {
+		CODEC_DEBUG(KERN_ERR "ASoC: Platform device allocation failed\n");
+		goto err_device_add;
+	}
+
+//	m6tv_audio_snd_priv->bias_level = SND_SOC_BIAS_OFF;
+//	m6tv_audio_snd_priv->clock_en = 0;
+
+	m6tv_audio_dev_init();
+	return ret;
+err_device_add:
+	platform_device_put(m6tv_audio_snd_device);
+
+err:
+//	kfree(m6tv_audio_snd_priv);
+
+	return ret;
+}
+
+static int m6tv_audio_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+    m6tv_audio_dev_uninit();
+    platform_device_put(m6tv_audio_snd_device);
+//    kfree(m6tv_audio_snd_priv);
+    m6tv_audio_snd_device = NULL;
+//    m6tv_audio_snd_priv = NULL;
+    m6tv_audio_snd_pdata = NULL;
+    return ret;
+}
+
+static struct platform_driver aml_m6tv_audio_driver = {
+    .probe  = m6tv_audio_audio_probe,
+    .remove = __devexit_p(m6tv_audio_audio_remove),
+    .driver = {
+        .name = "aml_m6tv_audio",
+        .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m6tv_audio_init(void)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+	return platform_driver_register(&aml_m6tv_audio_driver);
+}
+
+static void __exit aml_m6tv_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m6tv_audio_driver);
+}
+
+module_init(aml_m6tv_audio_init);
+module_exit(aml_m6tv_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("jian.xu@amlogic.com AMLogic, Inc.");
+MODULE_DESCRIPTION("AML SYNO9629 ALSA machine layer driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/aml/aml_m8.c b/sound/soc/aml/aml_m8.c
new file mode 100755
index 000000000000..2ecedb1fae70
--- /dev/null
+++ b/sound/soc/aml/aml_m8.c
@@ -0,0 +1,658 @@
+/*
+ * aml_m8.c  --  SoC audio for AML M8
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+#include <linux/amlogic/saradc.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+#include "../codecs/aml_m8_codec.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+#define DRV_NAME "aml_snd_m8"
+#define HP_DET                  1
+struct aml_audio_private_data {
+    int bias_level;
+    int clock_en;
+	int gpio_hp_det;
+	bool det_pol_inv;
+	int gpio_mute;
+	bool mute_inv;
+	struct pinctrl *pin_ctl;
+    int hp_last_state;
+    unsigned int hp_val_h;
+    unsigned int hp_val_l;
+    unsigned int mic_val;
+    unsigned int hp_detal;
+    unsigned int hp_adc_ch;
+
+    bool mic_det;
+    
+
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+
+	struct switch_dev sdev; // for android
+	struct switch_dev mic_sdev; // for android
+};
+
+static void aml_set_clock(int enable)
+{
+    /* set clock gating */
+    //p_aml_audio->clock_en = enable;
+
+    return ;
+}
+
+#if HP_DET
+static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
+{
+    p_aml_audio->timer.expires = jiffies + delay;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->detect_flag = -1;
+    add_timer(&p_aml_audio->timer);
+    p_aml_audio->timer_en = 1;
+}
+
+static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
+{
+    del_timer_sync(&p_aml_audio->timer);
+    cancel_work_sync(&p_aml_audio->work);
+    p_aml_audio->timer_en = 0;
+    p_aml_audio->detect_flag = -1;
+}
+
+static int hp_det_adc_value(struct aml_audio_private_data *p_aml_audio)
+{
+    int ret,hp_value,hp_val_sum,loop_num;
+    hp_val_sum = 0;
+    loop_num = 0;
+    unsigned int mic_ret = 0;
+    
+    while(loop_num < 8){
+        hp_value = get_adc_sample(p_aml_audio->hp_adc_ch);
+        if(hp_value <0){
+            printk("hp detect get error adc value!\n");
+            continue;
+        }
+        hp_val_sum += hp_value;
+        loop_num ++;
+        msleep(15);
+    }
+    hp_val_sum = hp_val_sum >> 3;
+
+    if(hp_val_sum >= p_aml_audio->hp_val_h){
+        ret = 0;
+    }else if((hp_val_sum <= (p_aml_audio->hp_val_l))&& hp_val_sum >=0){
+        ret = 1;
+        if(p_aml_audio->mic_det){
+            if(hp_val_sum <=  p_aml_audio->mic_val){
+                mic_ret = 8;
+                ret |= mic_ret;
+            }
+        }
+    }else{
+        ret = 2;
+        if(p_aml_audio->mic_det){
+            ret = 0;
+            mic_ret = 8;
+            ret |= mic_ret; 
+        }
+            
+    }
+    
+    return ret;
+}
+
+
+static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
+{
+       // return 0;
+   int loop_num = 0;
+   int ret;
+
+    mutex_lock(&p_aml_audio->lock);
+
+    while(loop_num < 3){
+        ret = hp_det_adc_value(p_aml_audio);
+        if(p_aml_audio->hp_last_state != ret){
+            loop_num = 0;
+            msleep(50);
+            if(ret < 0){
+                ret = p_aml_audio->hp_last_state;
+            }else {
+                p_aml_audio->hp_last_state = ret;
+            }
+        }else{
+            msleep(50);
+            loop_num = loop_num + 1;
+        }
+    }
+ 
+    mutex_unlock(&p_aml_audio->lock);
+
+    return ret; 
+}
+
+
+static void aml_asoc_work_func(struct work_struct *work)
+{
+    struct aml_audio_private_data *p_aml_audio = NULL;
+    struct snd_soc_card *card = NULL;
+    int jack_type = 0;
+    int flag = -1;
+	int status = SND_JACK_HEADPHONE;
+    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
+    card = (struct snd_soc_card *)p_aml_audio->data;
+
+    flag = aml_audio_hp_detect(p_aml_audio);
+
+    if(p_aml_audio->detect_flag != flag) {
+
+        p_aml_audio->detect_flag = flag;
+        
+        if (flag & 0x1) {
+            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
+            adac_wr_reg (71, 0x0101); // use board mic
+            printk(KERN_INFO "aml aduio hp pluged 3 jack_type: %d\n", SND_JACK_HEADPHONE);
+           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+
+           // mic port detect
+           if(p_aml_audio->mic_det){
+               if(flag & 0x8){
+                  switch_set_state(&p_aml_audio->mic_sdev, 1);
+                  adac_wr_reg (71, 0x0005); // use hp mic
+                  printk(KERN_INFO "aml aduio mic pluged jack_type: %d\n", SND_JACK_MICROPHONE);
+                  //snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+              }
+           }
+
+        } else if(flag & 0x2){
+            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            switch_set_state(&p_aml_audio->sdev, 1);  // 1 :have mic ;  2 no mic
+            adac_wr_reg (71, 0x0005); // use hp mic
+            printk(KERN_INFO "aml aduio hp pluged 4 jack_type: %d\n", SND_JACK_HEADSET);
+           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+        } else {
+            printk(KERN_INFO "aml audio hp unpluged\n");
+            amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+            adac_wr_reg (71, 0x0101); // use board mic
+            switch_set_state(&p_aml_audio->sdev, 0);
+            //snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+
+            // mic port detect
+            if(p_aml_audio->mic_det){
+                if(flag & 0x8){
+                   switch_set_state(&p_aml_audio->mic_sdev, 1);
+                   adac_wr_reg (71, 0x0005); // use hp mic
+                   printk(KERN_INFO "aml aduio mic pluged jack_type: %d\n", SND_JACK_MICROPHONE);
+                   //snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+               }
+            }
+        }
+        
+    }
+}
+
+
+static void aml_asoc_timer_func(unsigned long data)
+{
+    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&p_aml_audio->work);
+    mod_timer(&p_aml_audio->timer, jiffies + delay);
+}
+#endif
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+#if 0
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+#endif
+    return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+    .hw_params = aml_asoc_hw_params,
+};
+
+static int aml_set_bias_level(struct snd_soc_card *card,
+        struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct aml_audio_private_data * p_aml_audio;
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+
+    int hp_state = p_aml_audio->detect_flag;
+    if (p_aml_audio->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        if(hp_state==0){
+            amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+            printk("enter %s : unmute spk \n",__func__);
+        }
+        /* clock enable */
+        if (!p_aml_audio->clock_en) {
+            aml_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        if(hp_state==0){
+            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            printk("enter %s : mute spk \n",__func__);
+        }
+        /* clock disable */
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    default:
+        return ret;
+    }
+
+    p_aml_audio->bias_level = (int)level;
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+#if HP_DET
+
+#endif
+    return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define aml_suspend_pre  NULL
+#define aml_suspend_post NULL
+#define aml_resume_pre   NULL
+#define aml_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MAIN MIC", NULL),
+    SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADPHONE,
+    }
+};
+
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+    struct snd_soc_codec *codec = rtd->codec;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aml_audio_private_data * p_aml_audio;
+    int ret = 0;
+    int hp_paraments[5];
+	
+    printk(KERN_DEBUG "enter %s \n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    /* Add specific widgets */
+    //snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+    //              ARRAY_SIZE(aml_asoc_dapm_widgets));
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
+    if (ret < 0) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret < 0) {
+            printk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+
+#if HP_DET
+    p_aml_audio->mic_det = of_property_read_bool(card->dev->of_node,"mic_det");
+
+    printk("entern %s : mic_det=%d \n",__func__,p_aml_audio->mic_det);
+    ret = of_property_read_u32_array(card->dev->of_node, "hp_paraments", &hp_paraments[0], 5);
+    if(ret){
+        printk("falied to get hp detect paraments from dts file\n");
+    }else{
+        p_aml_audio->hp_val_h  = hp_paraments[0];  // hp adc value higher base, hp unplugged
+        p_aml_audio->hp_val_l  = hp_paraments[1];  // hp adc value low base, 3 section hp plugged.
+        p_aml_audio->mic_val   = hp_paraments[2];  // hp adc value mic detect value.
+        p_aml_audio->hp_detal  = hp_paraments[3];  // hp adc value test toerance
+        p_aml_audio->hp_adc_ch = hp_paraments[4];  // get adc value from which adc port for hp detect
+
+        printk("hp detect paraments: h=%d,l=%d,mic=%d,det=%d,ch=%d \n",p_aml_audio->hp_val_h,p_aml_audio->hp_val_l,
+            p_aml_audio->mic_val,p_aml_audio->hp_detal,p_aml_audio->hp_adc_ch);
+    }
+    init_timer(&p_aml_audio->timer);
+    p_aml_audio->timer.function = aml_asoc_timer_func;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->data= (void*)card;
+
+    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
+    mutex_init(&p_aml_audio->lock);
+
+    mutex_lock(&p_aml_audio->lock);
+    if (!p_aml_audio->timer_en) {
+        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
+    }
+    mutex_unlock(&p_aml_audio->lock);
+
+#endif
+
+    return 0;
+}
+
+static struct snd_soc_dai_link aml_codec_dai_link[] = {
+    {
+        .name = "SND_M8",
+        .stream_name = "AML PCM",
+        .cpu_dai_name = "aml-dai0",
+        .init = aml_asoc_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "aml_m8_codec.0",
+        .ops = &aml_asoc_ops,
+    },
+};
+
+static struct snd_soc_card aml_snd_soc_card = {
+    .driver_name = "SOC-Audio",
+    .dai_link = &aml_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(aml_codec_dai_link),
+    .set_bias_level = aml_set_bias_level,
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = aml_suspend_pre,
+	.suspend_post   = aml_suspend_post,
+	.resume_pre     = aml_resume_pre,
+	.resume_post    = aml_resume_post,
+#endif
+};
+
+static void aml_m8_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+	const char *str=NULL;
+	int ret;
+	p_aml_audio = snd_soc_card_get_drvdata(card);   
+    p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "aml_snd_m8");
+    
+
+	ret = of_property_read_string(card->dev->of_node, "mute_gpio", &str);
+	if (ret < 0) {
+		printk("aml_snd_m8: faild to get mute_gpio!\n");
+	}else{
+		p_aml_audio->gpio_mute = amlogic_gpio_name_map_num(str);
+		p_aml_audio->mute_inv = of_property_read_bool(card->dev->of_node,"mute_inv");
+		amlogic_gpio_request_one(p_aml_audio->gpio_mute,GPIOF_OUT_INIT_HIGH,"mute_spk");
+		amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+	}
+
+	printk("=%s==,aml_m8_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
+}
+
+static void aml_m8_pinmux_deinit(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	if(p_aml_audio->gpio_hp_det)
+		amlogic_gpio_free(p_aml_audio->gpio_hp_det,"hp_det");
+	if(p_aml_audio->gpio_mute)
+		amlogic_gpio_free(p_aml_audio->gpio_mute,"mute_spk"); 
+    if(p_aml_audio->pin_ctl)
+        devm_pinctrl_put(p_aml_audio->pin_ctl);
+}
+static int aml_m8_audio_probe(struct platform_device *pdev)
+{
+    //struct device_node *np = pdev->dev.of_node;
+    struct snd_soc_card *card = &aml_snd_soc_card;
+    struct aml_audio_private_data *p_aml_audio;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s\n", __func__);
+
+#ifdef CONFIG_USE_OF
+    p_aml_audio = devm_kzalloc(&pdev->dev,
+            sizeof(struct aml_audio_private_data), GFP_KERNEL);
+    if (!p_aml_audio) {
+        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    card->dev = &pdev->dev;
+    platform_set_drvdata(pdev, card);
+    snd_soc_card_set_drvdata(card, p_aml_audio);
+    if (!(pdev->dev.of_node)) {
+        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
+    if (ret)
+        goto err;
+    
+    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
+            0, &aml_codec_dai_link[0].codec_dai_name);
+    if (ret)
+        goto err;
+
+    //ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+    //if (ret)
+    //  goto err;
+
+//  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+//          pdev->dev.of_node, "aml,audio-codec", 0);
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+            ret);
+        goto err;
+    }
+
+    aml_m8_pinmux_init(card);
+
+    p_aml_audio->sdev.name = "h2w";//for report headphone to android
+    ret = switch_dev_register(&p_aml_audio->sdev);
+    if (ret < 0){
+        printk(KERN_ERR "ASoC: register hp switch dev failed\n");
+        goto err;
+    }
+
+    p_aml_audio->mic_sdev.name = "mic_dev";//for micphone detect
+    ret = switch_dev_register(&p_aml_audio->mic_sdev);
+    if (ret < 0){
+        printk(KERN_ERR "ASoC: register mic switch dev failed\n");
+        goto err;
+    }
+
+    return 0;
+#endif
+
+err:
+    kfree(p_aml_audio);
+    return ret;
+}
+
+static int aml_m8_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	snd_soc_unregister_card(card);
+#if HP_DET
+	/* stop timer */
+	mutex_lock(&p_aml_audio->lock);
+	if (p_aml_audio->timer_en) {
+		aml_audio_stop_timer(p_aml_audio);
+	}
+	mutex_unlock(&p_aml_audio->lock);
+#endif
+
+	aml_m8_pinmux_deinit(card);
+    kfree(p_aml_audio);
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{ .compatible = "sound_card, aml_snd_m8", },
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_m8_audio_driver = {
+    .probe  = aml_m8_audio_probe,
+    .remove = aml_m8_audio_remove,
+    .driver = {
+        .name = DRV_NAME,
+        .owner = THIS_MODULE,
+        .pm = &snd_soc_pm_ops,
+        .of_match_table = amlogic_audio_dt_match,
+    },
+};
+
+static int __init aml_m8_audio_init(void)
+{
+    return platform_driver_register(&aml_m8_audio_driver);
+}
+
+static void __exit aml_m8_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m8_audio_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m8_audio_init);
+#else
+module_init(aml_m8_audio_init);
+#endif
+module_exit(aml_m8_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_M8 audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
+
diff --git a/sound/soc/aml/aml_m_dummy.c b/sound/soc/aml/aml_m_dummy.c
new file mode 100755
index 000000000000..d99e480ef84b
--- /dev/null
+++ b/sound/soc/aml/aml_m_dummy.c
@@ -0,0 +1,338 @@
+/*
+ * aml_m_dummy_codec.c  --  SoC audio for AML M series
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/dummy_codec.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+static struct dummy_codec_platform_data *dummy_codec_snd_pdata = NULL;
+
+#ifdef CONFIG_USE_OF
+static struct device_node *np = NULL;
+static struct dummy_codec_platform_data *dummy_codec_pdata = NULL;
+struct device *dummy_codec_dev = NULL;
+struct pinctrl *p = NULL;
+#endif
+static void dummy_codec_dev_init(void)
+{
+    if (dummy_codec_snd_pdata->device_init) {
+        dummy_codec_snd_pdata->device_init();
+    }
+}
+
+static void dummy_codec_dev_uninit(void)
+{
+    if (dummy_codec_snd_pdata->device_uninit) {
+        dummy_codec_snd_pdata->device_uninit();
+    }
+}
+
+static void dummy_codec_mute_speaker(int mute)
+{
+	if (dummy_codec_snd_pdata->mute_spk){
+		dummy_codec_snd_pdata->mute_spk(mute);
+	}
+}
+static int dummy_codec_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s rate: %d format: %d\n", __func__, params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	}
+	else
+    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+#if 0   //no audio in
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+#endif
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops dummy_codec_soc_ops = {
+    .hw_params = dummy_codec_hw_params,
+};
+
+static int dummy_codec_set_bias_level(struct snd_soc_card *card,
+			      enum snd_soc_bias_level level)
+{
+    int ret = 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+    	dummy_codec_mute_speaker(0);
+        break;
+
+    case SND_SOC_BIAS_OFF:
+    	break;
+    case SND_SOC_BIAS_STANDBY:
+        dummy_codec_mute_speaker(1);
+        break;
+    default:
+        return ret;
+    }
+    return 0;
+}
+
+static int dummy_codec_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    return 0;
+}
+
+static struct snd_soc_dai_link dummy_codec_dai_link[] = {
+    {
+        .name = "DUMMY_CODEC",
+        .stream_name = "DUMMY_CODEC PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "dummy_codec",
+        .init = dummy_codec_codec_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "dummy_codec.0",
+        .ops = &dummy_codec_soc_ops,
+    },
+#ifdef CONFIG_SND_SOC_PCM2BT
+    {
+        .name = "BT Voice",
+        .stream_name = "Voice PCM",
+        .cpu_dai_name = "aml-dai1",
+        .codec_dai_name = "pcm2bt-pcm",
+        .platform_name = "aml-audio.0",
+        .codec_name = "pcm2bt.0",
+        //.ops = &voice_soc_ops,
+    },
+#endif
+};
+
+static struct snd_soc_card snd_soc_dummy_codec = {
+    .name = "AML-DUMMY-CODEC",
+    .driver_name = "SOC-Audio",
+    .dai_link = &dummy_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(dummy_codec_dai_link),
+    .set_bias_level = dummy_codec_set_bias_level,
+};
+
+#ifdef CONFIG_USE_OF
+static void dummy_codec_device_init(void)
+{
+#ifdef CONFIG_USE_OF
+	int ret;
+	struct pinctrl_state *s;
+	p = pinctrl_get(dummy_codec_dev);
+
+	if (IS_ERR(p))
+		return p;
+			
+	s = pinctrl_lookup_state(p, "dummy_codec_audio");
+	if (IS_ERR(s)) {
+		pinctrl_put(p);
+		return ERR_PTR(PTR_ERR(s));
+	}
+		
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+	printk("=%s==,dummy_codec_audio init done\n",__func__);
+#else
+    /* audio pinmux */
+//    pinmux_set(&rt5631_pinmux_set);
+
+    /* GPIOA_19 PULL_UP_REG0 bit19 */
+//    aml_set_reg32_bits(P_PAD_PULL_UP_REG0, 1, 19, 1);
+#endif
+}
+
+static void dummy_codec_device_deinit(void)
+{
+#ifdef CONFIG_USE_OF
+	pinctrl_put(p);
+#else
+//    pinmux_clr(&rt5631_pinmux_set);
+#endif
+}
+#endif
+static struct platform_device *dummy_codec_snd_device = NULL;
+
+static int dummy_codec_audio_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    //printk(KERN_DEBUG "enter %s\n", __func__);
+    printk("enter %s\n", __func__);
+#ifdef CONFIG_USE_OF		
+		dummy_codec_pdata = kzalloc(sizeof(struct dummy_codec_platform_data), GFP_KERNEL);
+		if(!dummy_codec_pdata){
+           // kfree(dummy_codec_pdata);
+			return -1;
+		}
+
+		if (pdev->dev.of_node) {
+            np = pdev->dev.of_node;
+            ret = of_property_match_string(np,"status","okay");
+            if(ret){
+                printk("the platform not register this codec\n");
+				goto err1;
+            }
+		}
+		dummy_codec_dev=&pdev->dev;		
+    dummy_codec_pdata->device_init = &dummy_codec_device_init;
+    dummy_codec_pdata->device_uninit = &dummy_codec_device_deinit;
+         
+		pdev->dev.platform_data = dummy_codec_pdata;
+#endif
+
+    dummy_codec_snd_pdata = pdev->dev.platform_data;
+    snd_BUG_ON(!dummy_codec_snd_pdata);
+    dummy_codec_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!dummy_codec_snd_device) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    platform_set_drvdata(dummy_codec_snd_device, &snd_soc_dummy_codec);
+
+    ret = platform_device_add(dummy_codec_snd_device);
+    if (ret) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto err_device_add;
+    }
+
+
+    dummy_codec_dev_init();
+
+    return ret;
+
+err_device_add:
+    platform_device_put(dummy_codec_snd_device);
+err:
+err1:
+    kfree(dummy_codec_pdata);
+    return ret;
+}
+
+static int dummy_codec_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    dummy_codec_dev_uninit();
+
+    platform_device_put(dummy_codec_snd_device);
+    kfree(dummy_codec_pdata);
+
+    dummy_codec_snd_device = NULL;
+    dummy_codec_snd_pdata = NULL;
+
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_dummy_codec_dt_match[]={
+	{	.compatible = "amlogic,aml_dummy_codec_audio",
+	},
+	{},
+};
+#else
+#define aml_dummy_codec_dt_match NULL
+#endif
+static struct platform_driver aml_m_dummy_codec_driver = {
+    .probe  = dummy_codec_audio_probe,
+    .remove = dummy_codec_audio_remove,
+    .driver = {
+        .name = "aml_dummy_codec_audio",
+        .owner = THIS_MODULE,
+        .of_match_table = aml_dummy_codec_dt_match,
+    },
+};
+
+static int __init aml_m_dummy_codec_init(void)
+{
+    return platform_driver_register(&aml_m_dummy_codec_driver);
+}
+
+static void __exit aml_m_dummy_codec_exit(void)
+{
+    platform_driver_unregister(&aml_m_dummy_codec_driver);
+}
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m_dummy_codec_init);
+#else
+module_init(aml_m_dummy_codec_init);
+#endif
+module_exit(aml_m_dummy_codec_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML dummy_codec audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_mixer.c b/sound/soc/aml/aml_mixer.c
new file mode 100644
index 000000000000..d7aab5661ee8
--- /dev/null
+++ b/sound/soc/aml/aml_mixer.c
@@ -0,0 +1,371 @@
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/soundcard.h>
+
+#include "aml_pcm.h"
+#include "aml_alsa_common.h"
+#include "aml_audio_hw.h"
+
+extern audio_tone_control_t audio_tone_control;
+
+static int pcm_pb_volume_info(struct snd_kcontrol *kcontrol,
+                              struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 100;
+    uinfo->value.integer.step = 1;
+
+    return 0;
+}
+
+static int pcm_pb_volume_get(struct snd_kcontrol *kcontrol,
+                             struct snd_ctl_elem_value *uvalue)
+{
+    int val;
+
+    val = get_mixer_output_volume();
+    val = val & 0xff;
+    uvalue->value.integer.value[0] = val;
+
+    return 0;
+}
+
+static int pcm_pb_volume_put(struct snd_kcontrol *kcontrol,
+                             struct snd_ctl_elem_value *uvalue)
+{
+    int volume;
+
+    volume = uvalue->value.integer.value[0];
+  //  volume = volume | (volume << 8);
+    set_mixer_output_volume(volume);
+    return 0;
+}
+
+static int pcm_pb_mute_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_pb_mute_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_pb_mute_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag)
+	 	audio_i2s_unmute();
+	 else
+	 	audio_i2s_mute();
+
+     return 0;
+}
+
+static int pcm_left_mono_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_left_mono_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_left_mono_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(1);
+     }
+
+     return 0;
+}
+
+static int pcm_right_mono_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_right_mono_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_right_mono_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(2);
+     }
+
+     return 0;
+}
+
+static int pcm_stereo_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_stereo_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_stereo_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(0);
+     }
+
+     return 0;
+}
+
+static int pcm_swap_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_swap_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_swap_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+     unsigned int reg;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+		reg = read_i2s_mute_swap_reg();
+		if((reg & 0x3))
+			audio_i2s_swap_left_right(0);
+		else
+			audio_i2s_swap_left_right(3);
+     }
+
+     return 0;
+}
+
+static int pcm_pb_data_info(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+    uinfo->count = 128;
+
+    return 0;
+}
+
+static int pcm_pb_data_get(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_value *uvalue)
+{
+    unsigned int rd_ptr;
+
+    rd_ptr = read_i2s_rd_ptr();
+    memcpy(uvalue->value.bytes.data, (unsigned char*)rd_ptr, 128);
+    return 0;
+}
+
+static int pcm_pb_tone_info(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_pb_tone_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     audio_tone_control.tone_flag = 1;
+	
+     return 0;
+}
+static int pcm_pb_tone_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     return 0;
+}
+struct snd_kcontrol_new pcm_control_pb_vol = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "Master Playback Volume",
+    .index = 0x00,
+    .info = pcm_pb_volume_info,
+    .get = pcm_pb_volume_get,
+    .put = pcm_pb_volume_put,
+    .private_value = 0x0,
+};
+
+struct snd_kcontrol_new pcm_switch_pb_mute = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "switch playback mute",
+     .index = 0x00,
+     .info = pcm_pb_mute_info,
+     .get = pcm_pb_mute_get,
+     .put = pcm_pb_mute_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_left_mono = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Left Mono",
+     .index = 0x00,
+     .info = pcm_left_mono_info,
+     .get = pcm_left_mono_get,
+     .put = pcm_left_mono_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_right_mono = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Right Mono",
+     .index = 0x00,
+     .info = pcm_right_mono_info,
+     .get = pcm_right_mono_get,
+     .put = pcm_right_mono_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_stereo = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Stereo Out",
+     .index = 0x00,
+     .info = pcm_stereo_info,
+     .get = pcm_stereo_get,
+     .put = pcm_stereo_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_swap = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Swap Left Right",
+     .index = 0x00,
+     .info = pcm_swap_info,
+     .get = pcm_swap_get,
+     .put = pcm_swap_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_data_read = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Playback Data Get",
+	.info = pcm_pb_data_info,
+	.get = pcm_pb_data_get,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_VOLATILE),
+};
+
+struct snd_kcontrol_new pcm_tone_play = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Playback Tone",
+	.info = pcm_pb_tone_info,
+	.put = pcm_pb_tone_put,
+	.get = pcm_pb_tone_get,
+	.access = (SNDRV_CTL_ELEM_ACCESS_WRITE |
+	          SNDRV_CTL_ELEM_ACCESS_READ), 
+	          
+};
+
+int aml_alsa_create_ctrl(struct snd_card *card, void *p_value)
+{
+    int err = 0;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_control_pb_vol, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_switch_pb_mute, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_left_mono, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_right_mono, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_stereo, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_swap, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_data_read, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_tone_play, p_value))) < 0)
+        return err;
+	
+    return 0;
+}
diff --git a/sound/soc/aml/aml_notify.c b/sound/soc/aml/aml_notify.c
new file mode 100644
index 000000000000..d24962f6ed47
--- /dev/null
+++ b/sound/soc/aml/aml_notify.c
@@ -0,0 +1,43 @@
+/*
+ *  linux/drivers/video/apollo/aout_notify.c
+ *
+ *  Copyright (C) 2009 amlogic
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+
+static BLOCKING_NOTIFIER_HEAD(aout_notifier_list);
+/**
+ *	aout_register_client - register a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int aout_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&aout_notifier_list, nb);
+}
+EXPORT_SYMBOL(aout_register_client);
+
+/**
+ *	aout_unregister_client - unregister a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int aout_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&aout_notifier_list, nb);
+}
+EXPORT_SYMBOL(aout_unregister_client);
+
+/**
+ * aout_notifier_call_chain - notify clients of fb_events
+ *
+ */
+int aout_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&aout_notifier_list, val, v);
+}
+EXPORT_SYMBOL_GPL(aout_notifier_call_chain);
+
+
diff --git a/sound/soc/aml/aml_pcm.c b/sound/soc/aml/aml_pcm.c
new file mode 100755
index 000000000000..cee71e35d34b
--- /dev/null
+++ b/sound/soc/aml/aml_pcm.c
@@ -0,0 +1,1633 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/hrtimer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/rt5631.h>
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include <linux/amports/amaudio.h>
+
+#include <mach/mod_gate.h>
+
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+#include "aml_platform.h"
+
+//#define _AML_PCM_DEBUG_
+//
+
+#define USE_HRTIMER 0
+#define HRTIMER_PERIOD (1000000000UL/48000)
+
+#define AOUT_EVENT_IEC_60958_PCM                0x1
+#define AOUT_EVENT_RAWDATA_AC_3                 0x2
+#define AOUT_EVENT_RAWDATA_MPEG1                0x3
+#define AOUT_EVENT_RAWDATA_MP3                  0x4
+#define AOUT_EVENT_RAWDATA_MPEG2                0x5
+#define AOUT_EVENT_RAWDATA_AAC                  0x6
+#define AOUT_EVENT_RAWDATA_DTS                  0x7
+#define AOUT_EVENT_RAWDATA_ATRAC                0x8
+#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
+#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
+#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
+#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
+#define AOUT_EVENT_RAWDATA_DST                  0xD
+#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
+
+extern int aout_notifier_call_chain(unsigned long val, void *v);
+extern void	aml_alsa_hw_reprepare(void);
+
+extern unsigned IEC958_mode_raw;
+extern unsigned IEC958_mode_codec;
+
+unsigned int aml_pcm_playback_start_addr = 0;
+unsigned int aml_pcm_capture_start_addr  = 0;
+
+unsigned int aml_pcm_playback_end_addr = 0;
+unsigned int aml_pcm_capture_end_addr = 0;
+
+unsigned int aml_pcm_capture_start_phy = 0;
+unsigned int aml_pcm_capture_buf_size = 0;
+unsigned int aml_pcm_playback_phy_start_addr = 0;
+unsigned int aml_pcm_capture_phy_start_addr  = 0;
+unsigned int aml_pcm_playback_phy_end_addr = 0;
+unsigned int aml_pcm_capture_phy_end_addr = 0;
+unsigned int aml_pcm_playback_off = 0;
+unsigned int aml_pcm_playback_enable = 1;
+
+unsigned int aml_iec958_playback_start_addr = 0;
+unsigned int aml_iec958_playback_start_phy = 0;
+unsigned int aml_iec958_playback_size = 0;  // in bytes
+
+static  unsigned  playback_substream_handle = 0 ;
+/*to keep the pcm status for clockgating*/
+static unsigned clock_gating_status = 0;
+static unsigned clock_gating_playback = 1;
+static unsigned clock_gating_capture = 2;
+static int audio_type_info = -1;
+static int audio_sr_info = -1;
+extern unsigned audioin_mode;
+
+
+static int audio_ch_info = -1;
+
+//static struct rt5631_platform_data *rt5631_snd_pdata = NULL;
+static struct aml_pcm_work_t{
+	struct snd_pcm_substream *substream;
+	struct work_struct aml_codec_workqueue;
+}aml_pcm_work;
+
+int codec_power=1;
+unsigned int flag=0;
+static int num=0;
+
+static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int status);
+
+EXPORT_SYMBOL(aml_pcm_playback_start_addr);
+EXPORT_SYMBOL(aml_pcm_capture_start_addr);
+EXPORT_SYMBOL(aml_pcm_playback_off);
+EXPORT_SYMBOL(aml_pcm_playback_enable);
+
+static void aml_codec_power_switch_queue(struct work_struct* work)
+{
+
+#ifdef _AML_PCM_DEBUG_
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	// disable power down/up, which caused pop noise
+	//codec_power_switch(substream, clock_gating_status);
+}
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE,
+
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 128 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static const struct snd_pcm_hardware aml_pcm_capture = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_MMAP |
+						 	SNDRV_PCM_INFO_MMAP_VALID |
+						  SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static char snd_pcm_tmp[32*1024];
+
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+/*--------------------------------------------------------------------------*\
+ * audio clock gating
+\*--------------------------------------------------------------------------*/
+#if 0
+static void aml_audio_clock_gating_disable(void)
+{
+#ifdef _AML_PCM_DEBUG_
+			printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+/*
+	aml_clr_reg32_mask(P_HHI_GCLK_MPEG0, (1<<18));
+	aml_clr_reg32_mask(P_HHI_GCLK_MPEG1, (1<<2)
+										|(0xba<<6)
+								    	);
+	aml_clr_reg32_mask(P_HHI_GCLK_OTHER, (1<<18)
+										|(0x6<<14)
+								    	);
+ */   aml_clr_reg32_mask( P_HHI_AUD_CLK_CNTL, (1 << 8));
+
+	//printk("P_HHI_GCLK_MPEG0=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG0));
+	//printk("P_HHI_GCLK_MPEG1=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG1));
+	//printk("P_HHI_GCLK_OTHER=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_OTHER));
+}
+
+static void aml_audio_clock_gating_enable(void)
+{
+#ifdef _AML_PCM_DEBUG_
+			printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+/*	aml_set_reg32_mask(P_HHI_GCLK_MPEG0, (1<<18));
+	aml_set_reg32_mask(P_HHI_GCLK_MPEG1, (1<<2)
+								    	|(0xba<<6)
+								   		 );
+	aml_set_reg32_mask(P_HHI_GCLK_OTHER, (1<<18)
+								    	|(0x6<<14)
+								    	);
+*/    aml_set_reg32_mask( P_HHI_AUD_CLK_CNTL, (1 << 8));
+	//printk("P_HHI_GCLK_MPEG0=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG0));
+	//printk("P_HHI_GCLK_MPEG1=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG1));
+	//printk("P_HHI_GCLK_OTHER=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_OTHER));
+}
+#endif
+
+#if 0
+static void aml_clock_gating(unsigned int status)
+{
+//printk("-----status=%d\n\n",status);
+	if(status){
+		aml_audio_clock_gating_enable();
+	}
+	else{
+		aml_audio_clock_gating_disable();
+	}
+}
+#endif
+/*--------------------------------------------------------------------------*\
+ * audio codec power management
+\*--------------------------------------------------------------------------*/
+#if 0
+static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int status)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+#ifdef _AML_PCM_DEBUG_
+			printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(status && codec_dai->driver->ops->startup)
+			codec_dai->driver->ops->startup(substream, codec_dai);
+
+	if((flag)&& (!status) && (codec_dai->driver->ops->shutdown))
+			codec_dai->driver->ops->shutdown(substream, codec_dai);
+	return 0;
+}
+#endif
+/*--------------------------------------------------------------------------*\
+ * Helper functions
+\*--------------------------------------------------------------------------*/
+static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+	size_t size = 0;
+
+    if(pcm->device == 0)
+    {
+	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		    size = aml_pcm_hardware.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+            /* one size for i2s output, another for 958, and 128 for alignment */
+		    buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-pcm %d:"
+		    "playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+
+            /* alloc iec958 buffer */
+
+            aml_pcm_playback_start_addr = (unsigned int)buf->area;
+		    aml_pcm_playback_end_addr = (unsigned int)buf->area + size;
+
+		aml_pcm_playback_phy_start_addr = buf->addr;
+		aml_pcm_playback_phy_end_addr = buf->addr+size;
+
+        /* alloc iec958 buffer */
+        aml_iec958_playback_start_addr = (unsigned int)dma_alloc_coherent(pcm->card->dev, size*4,
+           (dma_addr_t *)(&aml_iec958_playback_start_phy), GFP_KERNEL);
+        if(aml_iec958_playback_start_addr == 0){
+          printk("aml-pcm %d: alloc iec958 buffer failed\n", stream);
+          return -ENOMEM;
+        }
+        aml_iec958_playback_size = size*4;
+        printk("iec958 %d: preallocate dma buffer start=%p, size=%x\n", stream, (void*)aml_iec958_playback_start_addr, size*4);
+	}else{
+		size = aml_pcm_capture.buffer_bytes_max;
+		buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		buf->dev.dev = pcm->card->dev;
+		buf->private_data = NULL;
+		buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-pcm %d:"
+		    "capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+
+            aml_pcm_capture_start_addr = (unsigned int)buf->area;
+		    aml_pcm_capture_end_addr = (unsigned int)buf->area+size;
+		    aml_pcm_capture_start_phy = buf->addr;
+		    aml_pcm_capture_buf_size = size;
+		    aml_pcm_capture_phy_start_addr = buf->addr;
+		    aml_pcm_capture_phy_end_addr = buf->addr+size;
+	    }
+
+	    if (!buf->area)
+		    return -ENOMEM;
+
+	    buf->bytes = size;
+	    return 0;
+    }
+    else
+    {
+	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		    size = aml_pcm_hardware.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+            /* one size for i2s output, another for 958, and 128 for alignment */
+		    //buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
+					  //&buf->addr, GFP_KERNEL);
+            buf->area = aml_pcm_playback_start_addr;
+            buf->addr = aml_pcm_playback_phy_start_addr;
+		    printk("aml-pcm %d:"
+		    "dev>0 playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+
+        }else{
+		    size = aml_pcm_capture.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+		    //buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
+		    //			  &buf->addr, GFP_KERNEL);
+		    buf->area = aml_pcm_capture_start_addr;
+            buf->addr = aml_pcm_capture_phy_start_addr;
+		    printk("aml-pcm %d:"
+		    "dev>0 capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+	    }
+
+	    if (!buf->area)
+		    return -ENOMEM;
+
+	    buf->bytes = size;
+	    return 0;
+
+    }
+}
+/*--------------------------------------------------------------------------*\
+ * ISR
+\*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*\
+ * PCM operations
+\*--------------------------------------------------------------------------*/
+static int aml_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+//	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	audio_stream_t *s = &prtd->s;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		aml_iec958_playback_size = runtime->dma_bytes*4;
+	s->I2S_addr = runtime->dma_addr;
+
+    /*
+     * Both capture and playback need to reset the last ptr to the start address,
+       playback and capture use different address calculate, so we reset the different
+       start address to the last ptr
+   * */
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+        /* s->last_ptr must initialized as dma buffer's start addr */
+        s->last_ptr = runtime->dma_addr;
+    }else{
+
+	s->last_ptr = 0;
+    }
+
+	return 0;
+}
+
+static int aml_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	struct aml_pcm_dma_params *params = prtd->params;
+	if (params != NULL) {
+
+	}
+
+	return 0;
+}
+/*
+the I2S hw  and IEC958 PCM output initation,958 initation here,
+for the case that only use our ALSA driver for PCM s/pdif output.
+*/
+static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
+{
+
+
+		switch(runtime->format){
+		case SNDRV_PCM_FORMAT_S32_LE:
+			I2S_MODE = AIU_I2S_MODE_PCM32;
+		// IEC958_MODE = AIU_958_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			I2S_MODE = AIU_I2S_MODE_PCM24;
+		// IEC958_MODE = AIU_958_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16_LE:
+			I2S_MODE = AIU_I2S_MODE_PCM16;
+		// IEC958_MODE = AIU_958_MODE_PCM16;
+			break;
+		}
+		audio_set_i2s_mode(I2S_MODE);
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, runtime->channels);
+		memset((void*)runtime->dma_area,0,runtime->dma_bytes + 4096);
+		/* update the i2s hw buffer end addr as android may update that */
+		aml_pcm_playback_phy_end_addr = aml_pcm_playback_phy_start_addr+runtime->dma_bytes;
+		printk("I2S hw init,i2s mode %d\n",I2S_MODE);
+
+}
+/*add audio_hdmi_init_ready check ,as hdmi audio may init fails:
+AIU_HDMI_CLK_DATA_CTRL can be writen sucessfully when audio PLL OFF.
+so notify HDMI to set audio parameter every time when HDMI AUDIO not ready
+*/
+
+static int audio_notify_hdmi_info(int audio_type, void *v){
+    	struct snd_pcm_substream *substream =(struct snd_pcm_substream*)v;
+	if(substream->runtime->rate != audio_sr_info || audio_type_info != audio_type || !audio_hdmi_init_ready()
+		|| substream->runtime->channels != audio_ch_info)
+	{
+		printk("audio info changed.notify to hdmi: type %d,sr %d,ch %d\n",audio_type,substream->runtime->rate,
+			substream->runtime->channels);
+		aout_notifier_call_chain(audio_type,v);
+	}
+	audio_sr_info = substream->runtime->rate;
+	audio_ch_info = substream->runtime->channels;
+	audio_type_info = audio_type;
+
+}
+static void iec958_notify_hdmi_info(void)
+{
+	unsigned audio_type = AOUT_EVENT_IEC_60958_PCM;
+	if(playback_substream_handle){
+		if(IEC958_mode_codec == 2) //dd
+			audio_type = AOUT_EVENT_RAWDATA_AC_3;
+		else if(IEC958_mode_codec == 4)//dd+
+			audio_type = AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS;
+		else if(IEC958_mode_codec == 1|| IEC958_mode_codec == 3)//dts
+			audio_type = AOUT_EVENT_RAWDATA_DTS;
+		else
+			audio_type = AOUT_EVENT_IEC_60958_PCM;
+		printk("iec958 nodify hdmi audio type %d\n",	audio_type);
+		audio_notify_hdmi_info(audio_type, (struct snd_pcm_substream *)playback_substream_handle);
+	}
+	else{
+		printk("substream for playback NULL\n");
+	}
+
+}
+/*
+special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
+1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
+2)PCM  output for  all audio, when pcm mode is selected by user .
+3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
+*/
+static void aml_hw_iec958_init(void)
+{
+    _aiu_958_raw_setting_t set;
+    _aiu_958_channel_status_t chstat;
+    unsigned start,size;
+	memset((void*)(&set), 0, sizeof(set));
+	memset((void*)(&chstat), 0, sizeof(chstat));
+	set.chan_stat = &chstat;
+   	/* case 1,raw mode enabled */
+	if(IEC958_mode_codec){
+	  if(IEC958_mode_codec == 1){ //dts, use raw sync-word mode
+	    	IEC958_MODE = AIU_958_MODE_RAW;
+		printk("iec958 mode RAW\n");
+	  }
+	  else{ //ac3,use the same pcm mode as i2s configuration
+		IEC958_MODE = AIU_958_MODE_PCM_RAW;
+		printk("iec958 mode %s\n",(I2S_MODE == AIU_I2S_MODE_PCM32)?"PCM32_RAW":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24_RAW":"PCM16_RAW"));
+	  }
+	}else{	/* case 2,3 */
+	  if(I2S_MODE == AIU_I2S_MODE_PCM32)
+	  	IEC958_MODE = AIU_958_MODE_PCM32;
+	  else if(I2S_MODE == AIU_I2S_MODE_PCM24)
+	  	IEC958_MODE = AIU_958_MODE_PCM24;
+	  else
+	  	IEC958_MODE = AIU_958_MODE_PCM16;
+  	  printk("iec958 mode %s\n",(I2S_MODE == AIU_I2S_MODE_PCM32)?"PCM32":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24":"PCM16"));
+	}
+
+	if(IEC958_MODE == AIU_958_MODE_PCM16 || IEC958_MODE == AIU_958_MODE_PCM24 ||
+	  IEC958_MODE == AIU_958_MODE_PCM32){
+	    set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+        start = (aml_pcm_playback_phy_start_addr);
+        size = aml_pcm_playback_phy_end_addr - aml_pcm_playback_phy_start_addr;
+		audio_set_958outbuf(start, size, 0);
+	  }else{
+		set.chan_stat->chstat0_l = 0x1902;//NONE-PCM
+		set.chan_stat->chstat0_r = 0x1902;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+        // start = ((aml_pcm_playback_phy_end_addr + 4096)&(~127));
+        // size  = aml_pcm_playback_phy_end_addr - aml_pcm_playback_phy_start_addr;
+        start = aml_iec958_playback_start_phy;
+        size = aml_iec958_playback_size;
+		audio_set_958outbuf(start, size, (IEC958_MODE == AIU_958_MODE_RAW)?1:0);
+		memset((void*)aml_iec958_playback_start_addr,0,size);
+
+	}
+	audio_set_958_mode(IEC958_MODE, &set);
+	if(IEC958_mode_codec == 4)  //dd+
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2); // 4x than i2s
+	else
+#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1	
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);//512fs divide 4 == 128fs
+#else
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 4, 2); //256fs divide 2 == 128fs
+#endif
+	iec958_notify_hdmi_info();
+
+
+}
+
+void	aml_alsa_hw_reprepare(void)
+{
+	/* diable 958 module before call initiation */
+	audio_hw_958_enable(0);
+  aml_hw_iec958_init();
+
+}
+
+static int aml_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+    int iec958 = 0;
+
+	if(prtd == 0)
+		return 0;
+
+	switch(runtime->rate){
+		case 192000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_192;
+			break;
+		case 176400:
+			s->sample_rate	=	AUDIO_CLK_FREQ_1764;
+			break;
+		case 96000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_96;
+			break;
+		case 88200:
+			s->sample_rate	=	AUDIO_CLK_FREQ_882;
+			break;
+		case 48000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_48;
+            iec958 = 2;
+			break;
+		case 44100:
+			s->sample_rate	=	AUDIO_CLK_FREQ_441;
+            iec958 = 0;
+			break;
+		case 32000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_32;
+            iec958 = 3;
+			break;
+		case 8000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_8;
+			break;
+		case 11025:
+			s->sample_rate	=	AUDIO_CLK_FREQ_11;
+			break;
+		case 16000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_16;
+			break;
+		case 22050:
+			s->sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		case 12000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_12;
+			break;
+		case 24000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		default:
+			s->sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+	};
+	// iec958 and i2s clock are separated after M6TV
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6TV	
+	audio_set_clk(s->sample_rate, AUDIO_CLK_256FS);
+	audio_util_set_dac_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#else
+	audio_set_i2s_clk(s->sample_rate, AUDIO_CLK_256FS);
+	audio_set_958_clk(s->sample_rate, AUDIO_CLK_256FS);
+	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#endif
+	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+			aml_hw_i2s_init(runtime);
+		  aml_hw_iec958_init();
+	}
+	else{
+			//printk("aml_pcm_prepare SNDRV_PCM_STREAM_CAPTURE: dma_addr=%x, dma_bytes=%x\n", runtime->dma_addr, runtime->dma_bytes);
+			audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes*2,audioin_mode);
+			memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
+            {
+			  int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
+			  ppp[0] = 0x78787878;
+			  ppp[1] = 0x78787878;
+            }
+	}
+    if( IEC958_MODE == AIU_958_MODE_PCM_RAW){
+		if(IEC958_mode_codec == 4 ){ // need Over clock for dd+
+		    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2);	// 4x than i2s
+		    audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS, substream);
+		}else if(IEC958_mode_codec == 3 ||IEC958_mode_codec == 1 ){ // no-over clock for dts pcm mode
+		    audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DTS, substream);
+		}
+		else  //dd
+			audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_AC_3, substream);
+
+    }else if(IEC958_mode_codec == 1){
+        audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DTS, substream);
+    }else{
+				audio_notify_hdmi_info(AOUT_EVENT_IEC_60958_PCM, substream);
+    }
+
+#if 0
+	printk("Audio Parameters:\n");
+	printk("\tsample rate: %d\n", runtime->rate);
+	printk("\tchannel: %d\n", runtime->channels);
+	printk("\tsample bits: %d\n", runtime->sample_bits);
+  printk("\tformat: %s\n", snd_pcm_format_name(runtime->format));
+	printk("\tperiod size: %ld\n", runtime->period_size);
+	printk("\tperiods: %d\n", runtime->periods);
+  printk("\tiec958 mode: %d, raw=%d, codec=%d\n", IEC958_MODE, IEC958_mode_raw, IEC958_mode_codec);
+#endif
+
+	return 0;
+}
+
+static int aml_pcm_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct aml_runtime_data *prtd = rtd->private_data;
+	audio_stream_t *s = &prtd->s;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	 //witch_mod_gate_by_type(MOD_AUDIO, 1);
+#endif
+
+#if USE_HRTIMER == 0
+	  del_timer_sync(&prtd->timer);
+#endif      
+	  spin_lock(&s->lock);
+#if USE_HRTIMER == 0
+	  prtd->timer.expires = jiffies + 1;
+	  del_timer(&prtd->timer);
+	  add_timer(&prtd->timer);
+#endif
+	  // TODO
+	  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+	        //printk("aml_pcm_trigger: playback start\n");
+			//clock_gating_status |= clock_gating_playback;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+		    audio_enable_ouput(1);
+	  }else{
+	  		//printk("aml_pcm_trigger: capture start\n");
+			//clock_gating_status |= clock_gating_capture;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+			audio_in_i2s_enable(1);
+	      {
+		  int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+		  ppp[0] = 0x78787878;
+		  ppp[1] = 0x78787878;
+	      }
+
+	  }
+
+	  s->active = 1;
+	  spin_unlock(&s->lock);
+	  break;		/* SNDRV_PCM_TRIGGER_START */
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		// TODO
+	    spin_lock(&s->lock);
+	    s->active = 0;
+	    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+            //printk("aml_pcm_trigger: playback stop\n");
+	  		audio_enable_ouput(0);
+		//	clock_gating_status &= ~clock_gating_playback;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+	    }else{
+            //printk("aml_pcm_trigger: capture stop\n");
+		//	clock_gating_status &= ~clock_gating_capture;
+
+			audio_in_i2s_enable(0);
+	    }
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	//  switch_mod_gate_by_type(MOD_AUDIO, 0);
+#endif
+
+	    spin_unlock(&s->lock);
+	    break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		// TODO
+	    spin_lock(&s->lock);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	  //switch_mod_gate_by_type(MOD_AUDIO, 1);
+#endif
+	    s->active = 1;
+	    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+            //printk("aml_pcm_trigger: playback resume\n");
+			audio_enable_ouput(1);
+		//	clock_gating_status |= clock_gating_playback;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+	    }else{
+            //printk("aml_pcm_trigger: capture resume\n");
+	        audio_in_i2s_enable(1);
+		//	clock_gating_status |= clock_gating_capture;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+		{
+		    int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+		    ppp[0] = 0x78787878;
+		    ppp[1] = 0x78787878;
+	        }
+	    }
+	    spin_unlock(&s->lock);
+	    break;
+	default:
+		ret = -EINVAL;
+	}
+/*	if(clock_gating_status&clock_gating_playback){
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			aml_pcm_work.substream = substream;
+	}
+	else
+		aml_pcm_work.substream = substream;
+
+
+	if(clock_gating_status)
+	{
+		schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	}
+	*/
+	//schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_pcm_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+
+	unsigned int addr, ptr;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+			ptr = read_i2s_rd_ptr();
+	    addr = ptr - s->I2S_addr;
+	    return bytes_to_frames(runtime, addr);
+	}else{
+			ptr = audio_in_i2s_wr_ptr();
+			addr = ptr - s->I2S_addr;
+			return bytes_to_frames(runtime, addr)/2;
+	}
+
+	return 0;
+}
+
+static enum hrtimer_restart aml_pcm_hrtimer_callback(struct hrtimer* timer)
+{
+  struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
+  audio_stream_t* s = &prtd->s;
+  struct snd_pcm_substream* substream = prtd->substream;
+  struct snd_pcm_runtime* runtime= substream->runtime;
+  
+  unsigned int last_ptr, size;
+  unsigned long flag;
+  //printk("------------->hrtimer start\n");
+  if(s->active == 0){
+    hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+    return HRTIMER_RESTART;
+  }
+  //spin_lock_irqsave(&s->lock, flag);
+
+  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+      last_ptr = read_i2s_rd_ptr();
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(substream->runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }else{
+      last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) /2;
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }
+  //spin_unlock_irqrestore(&s->lock, flag);
+  hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+  return HRTIMER_RESTART;
+}
+
+static void aml_pcm_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = runtime->private_data;
+		audio_stream_t *s = &prtd->s;
+
+    unsigned int last_ptr, size;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				if(s->active == 1){
+						spin_lock(&s->lock);
+						last_ptr = read_i2s_rd_ptr();
+						if (last_ptr < s->last_ptr) {
+				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
+				    } else {
+				        size = last_ptr - (s->last_ptr);
+				    }
+    				s->last_ptr = last_ptr;
+    				s->size += bytes_to_frames(substream->runtime, size);
+    				if (s->size >= runtime->period_size) {
+				        s->size %= runtime->period_size;
+				        spin_unlock(&s->lock);
+				        snd_pcm_period_elapsed(substream);
+				        spin_lock(&s->lock);
+				    }
+				    mod_timer(&prtd->timer, jiffies + 1);
+					//codec_power = 1;
+   					spin_unlock(&s->lock);
+				}else{
+
+						 mod_timer(&prtd->timer, jiffies + 1);
+						// codec_power = 0;
+
+				}
+
+		}else{
+				if(s->active == 1){
+						spin_lock(&s->lock);
+						last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) / 2;
+						if (last_ptr < s->last_ptr) {
+				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
+				    } else {
+				        size = last_ptr - (s->last_ptr);
+				    }
+    				s->last_ptr = last_ptr;
+    				s->size += bytes_to_frames(substream->runtime, size);
+    				if (s->size >= runtime->period_size) {
+				        s->size %= runtime->period_size;
+				        spin_unlock(&s->lock);
+				        snd_pcm_period_elapsed(substream);
+				        spin_lock(&s->lock);
+				    }
+				    mod_timer(&prtd->timer, jiffies + 1);
+   					spin_unlock(&s->lock);
+				}else{
+						 mod_timer(&prtd->timer, jiffies + 1);
+				}
+		}
+	/*	if((codec_power==0) && (num==500))
+		{
+			num=0;
+	   		flag=1;
+			schedule_work(&aml_pcm_work.aml_codec_workqueue);
+		}
+	   else if((codec_power==1) && (num <= 500))
+	   	{
+	   		num=0;
+			flag = 0;
+	   	}
+	   else if((codec_power==0) && (num<500))
+	   	{
+	   	    if(flag==1)
+	   	    {}
+			else
+			{
+				num++;
+			}
+	   	} */
+}
+
+
+static int aml_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd;
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		playback_substream_handle = (unsigned long)substream;
+		snd_soc_set_runtime_hwparams(substream, &aml_pcm_hardware);
+	}else{
+		snd_soc_set_runtime_hwparams(substream, &aml_pcm_capture);
+	}
+	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);			
+	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
+
+    /* ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0)
+	{
+		printk("set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+						SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+	{
+		printk("set period error\n");
+		goto out;
+	}
+
+	prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		printk("alloc aml_runtime_data error\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	prtd->substream = substream;
+#if USE_HRTIMER == 0    
+	prtd->timer.function = &aml_pcm_timer_callback;
+	prtd->timer.data = (unsigned long)substream;
+	init_timer(&prtd->timer);
+#else
+    hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    prtd->hrtimer.function = aml_pcm_hrtimer_callback;
+    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
+
+
+    printk("hrtimer inited..\n");
+#endif
+	runtime->private_data = prtd;
+
+	spin_lock_init(&prtd->s.lock);
+ out:
+	return ret;
+}
+
+static int aml_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+
+#if USE_HRTIMER == 0
+	del_timer_sync(&prtd->timer);
+#else
+    hrtimer_cancel(&prtd->hrtimer);
+#endif
+	kfree(prtd);
+
+	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);			
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		playback_substream_handle = 0;
+	return 0;
+}
+
+
+static int aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    int res = 0;
+    int n;
+    int i = 0, j = 0;
+    int  align = runtime->channels * 32 / runtime->byte_align;
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    n = frames_to_bytes(runtime, count);
+    if(aml_pcm_playback_enable == 0)
+      return res;
+    if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))){
+	  if(runtime->format == SNDRV_PCM_FORMAT_S16_LE && I2S_MODE == AIU_I2S_MODE_PCM16){
+        int16_t * tfrom, *to, *left, *right;
+        tfrom = (int16_t*)buf;
+        to = (int16_t*)hwbuf;
+
+        left = to;
+		right = to + 16;
+		if (pos % align) {
+		    printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+		}
+		for (j = 0; j < n; j += 64) {
+		    for (i = 0; i < 16; i++) {
+	          *left++ = (*tfrom++) ;
+	          *right++ = (*tfrom++);
+		    }
+		    left += 16;
+		    right += 16;
+		 }
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++);
+            *right++  = (*tfrom ++);
+          }
+          left += 8;
+          right += 8;
+        }
+
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S32_LE && I2S_MODE == AIU_I2S_MODE_PCM32){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+		
+		if(runtime->channels == 8){
+			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+			lf  = to;
+			cf  = to + 8*1;
+			rf  = to + 8*2;
+			ls  = to + 8*3;
+			rs  = to + 8*4;
+			lef = to + 8*5;
+			sbl = to + 8*6;
+			sbr = to + 8*7;
+			for (j = 0; j < n; j += 256) {
+		    	for (i = 0; i < 8; i++) {
+	         		*lf++  = (*tfrom ++)>>8;
+	          		*cf++  = (*tfrom ++)>>8;
+					*rf++  = (*tfrom ++)>>8;
+					*ls++  = (*tfrom ++)>>8;
+					*rs++  = (*tfrom ++)>>8;
+					*lef++ = (*tfrom ++)>>8;
+					*sbl++ = (*tfrom ++)>>8;
+					*sbr++ = (*tfrom ++)>>8;
+		    	}
+		    	lf  += 7*8;
+		    	cf  += 7*8;
+				rf  += 7*8;
+				ls  += 7*8;
+				rs  += 7*8;
+				lef += 7*8;
+				sbl += 7*8;
+				sbr += 7*8;
+		 	}
+		}
+		else {
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++)>>8;
+            *right++  = (*tfrom ++)>>8;
+          }
+          left += 8;
+          right += 8;
+        }
+      	}
+      }
+
+	}else{
+	  res = -EFAULT;
+	}
+
+	return res;
+}
+
+
+static int aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+		unsigned int *tfrom, *left, *right;
+		unsigned short *to;
+		int res = 0;
+		int n;
+    int i = 0, j = 0;
+    unsigned int t1, t2;
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
+    unsigned char r_shift = 8;	
+    if(audioin_mode&SPDIFIN_MODE) //spdif in
+    {
+    	r_shift = 12;
+    }
+    to = (unsigned short *)snd_pcm_tmp;//buf;
+    tfrom = (unsigned int *)hwbuf;	// 32bit buffer
+    n = frames_to_bytes(runtime, count);
+    if(n > 32*1024){
+      printk("Too many datas to read\n");
+      return -EINVAL;
+    }
+
+		if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count))){
+				left = tfrom;
+		    right = tfrom + 8;
+		    if (pos % 8) {
+		        printk("audio data unligned\n");
+		    }
+		    if((n*2)%64){
+		    		printk("audio data unaligned 64 bytes\n");
+		    }
+		    for (j = 0; j < n*2 ; j += 64) {
+		        for (i = 0; i < 8; i++) {
+		        	t1 = (*left++);
+		        	t2 = (*right++);
+		        	//printk("%08x,%08x,", t1, t2);
+	              *to++ = (unsigned short)((t1>>r_shift)&0xffff);
+	           //   *to++ = (unsigned short)((t1>>8)&0xffff);//copy left channel to right
+	              *to++ = (unsigned short)((t2>>r_shift)&0xffff);
+		         }
+		         //printk("\n");
+		        left += 8;
+		        right += 8;
+		    }
+		}
+        res = copy_to_user(buf, snd_pcm_tmp,n);
+		return res;
+}
+
+static int aml_pcm_copy(struct snd_pcm_substream *substream, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+ 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+ 		ret = aml_pcm_copy_playback(runtime, channel,pos, buf, count);
+ 	}else{
+ 		ret = aml_pcm_copy_capture(runtime, channel,pos, buf, count);
+ 	}
+    return ret;
+}
+
+int aml_pcm_silence(struct snd_pcm_substream *substream, int channel,
+		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+		char* ppos;
+		int n;
+		struct snd_pcm_runtime *runtime = substream->runtime;
+
+		n = frames_to_bytes(runtime, count);
+		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+		memset(ppos, 0, n);
+		return 0;
+}
+
+static struct snd_pcm_ops aml_pcm_ops = {
+	.open		= aml_pcm_open,
+	.close		= aml_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_pcm_hw_params,
+	.hw_free	= aml_pcm_hw_free,
+	.prepare	= aml_pcm_prepare,
+	.trigger	= aml_pcm_trigger,
+	.pointer	= aml_pcm_pointer,
+	.copy 		= aml_pcm_copy,
+	.silence	=	aml_pcm_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+static u64 aml_pcm_dmamask = 0xffffffff;
+
+static int aml_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		pr_debug("aml-pcm:"
+				"Allocating PCM capture DMA buffer\n");
+		ret = aml_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	return ret;
+}
+
+static void aml_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+		buf->area = NULL;
+	}
+    aml_pcm_playback_start_addr = 0;
+    aml_pcm_capture_start_addr  = 0;
+
+    if(aml_iec958_playback_start_addr){
+      dma_free_coherent(pcm->card->dev, aml_iec958_playback_size, ( void *)aml_iec958_playback_start_addr, aml_iec958_playback_start_phy);
+      aml_iec958_playback_start_addr = 0;
+    }
+}
+
+#ifdef CONFIG_PM
+static int aml_pcm_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_pcm_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* disable the PDC and save the PDC registers */
+	// TODO
+	printk("aml pcm suspend\n");
+
+	return 0;
+}
+
+static int aml_pcm_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_pcm_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* restore the PDC registers and enable the PDC */
+	// TODO
+	printk("aml pcm resume\n");
+	return 0;
+}
+#else
+#define aml_pcm_suspend	NULL
+#define aml_pcm_resume	NULL
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+
+static struct dentry *debugfs_root;
+static struct dentry *debugfs_regs;
+static struct dentry *debugfs_mems;
+
+static int regs_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/**
+ *	cat regs
+ */
+static ssize_t regs_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo base reg val >regs\t(set the register)\n"
+										 "	echo base reg >regs\t(show the register)\n"
+										 "	base -> c(cbus), x(aix), p(apb), h(ahb) \n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static int read_regs(char base, int reg)
+{
+	int val = 0;
+	switch(base){
+		case 'c':
+			val = READ_CBUS_REG(reg);
+			break;
+		case 'x':
+			val = READ_AXI_REG(reg);
+			break;
+		case 'p':
+			val = READ_APB_REG(reg);
+			break;
+		case 'h':
+			//val = READ_AHB_REG(reg);
+			break;
+		default:
+			break;
+	};
+	printk("\tReg %x = %x\n", reg, val);
+	return val;
+}
+
+static void write_regs(char base, int reg, int val)
+{
+	switch(base){
+		case 'c':
+			WRITE_CBUS_REG(reg, val);
+			break;
+		case 'x':
+			WRITE_AXI_REG(reg, val);
+			break;
+		case 'p':
+			WRITE_APB_REG(reg, val);
+			break;
+		case 'h':
+			//WRITE_AHB_REG(reg, val);
+			break;
+		default:
+			break;
+	};
+	printk("Write reg:%x = %x\n", reg, val);
+}
+static ssize_t regs_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long reg, value;
+	char base;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+	while (*start == ' ')
+		start++;
+
+	base = *start;
+	start ++;
+	if(!(base =='c' || base == 'x' || base == 'p' || base == 'h')){
+		return -EINVAL;
+	}
+
+	while (*start == ' ')
+		start++;
+
+	reg = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			read_regs(base, reg);
+			return -EINVAL;
+	}
+
+	write_regs(base, reg, value);
+
+	return buf_size;
+}
+
+static const struct file_operations regs_fops = {
+	.open = regs_open_file,
+	.read = regs_read_file,
+	.write = regs_write_file,
+};
+
+static int mems_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t mems_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo vmem >mems\t(read 64 bytes from vmem)\n"
+										 "	echo vmem val >mems (write int value to vmem\n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t mems_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[256];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long mem, value;
+	int i=0;
+	unsigned* addr = 0;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	while (*start == ' ')
+		start++;
+
+	mem = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			addr = (unsigned*)mem;
+			printk("%p: ", addr);
+			for(i = 0; i< 8; i++){
+				printk("%08x, ", addr[i]);
+			}
+			printk("\n");
+			return -EINVAL;
+	}
+	addr = (unsigned*)mem;
+	printk("%p: %08x\n", addr, *addr);
+	*addr = value;
+	printk("%p: %08x^\n", addr, *addr);
+
+	return buf_size;
+}
+static const struct file_operations mems_fops={
+	.open = mems_open_file,
+	.read = mems_read_file,
+	.write = mems_write_file,
+};
+
+static void aml_pcm_init_debugfs(void)
+{
+		debugfs_root = debugfs_create_dir("aml",NULL);
+		if (IS_ERR(debugfs_root) || !debugfs_root) {
+			printk("aml: Failed to create debugfs directory\n");
+			debugfs_root = NULL;
+		}
+
+		debugfs_regs = debugfs_create_file("regs", 0644, debugfs_root, NULL, &regs_fops);
+		if(!debugfs_regs){
+			printk("aml: Failed to create debugfs file\n");
+		}
+
+		debugfs_mems = debugfs_create_file("mems", 0644, debugfs_root, NULL, &mems_fops);
+		if(!debugfs_mems){
+			printk("aml: Failed to create debugfs file\n");
+		}
+}
+static void aml_pcm_cleanup_debugfs(void)
+{
+	debugfs_remove_recursive(debugfs_root);
+}
+#else
+static void aml_pcm_init_debugfs(void)
+{
+}
+static void aml_pcm_cleanup_debugfs(void)
+{
+}
+#endif
+
+struct aml_audio_interface aml_i2s_interface = {
+    .id = AML_AUDIO_I2S,
+    .name = "I2S",
+    .pcm_ops = &aml_pcm_ops,
+    .pcm_new = aml_pcm_new,
+    .pcm_free =  aml_pcm_free_dma_buffers,
+};
+#if 0
+struct snd_soc_platform_driver aml_soc_platform = {
+	.ops 	= &aml_pcm_ops,
+	.pcm_new	= aml_pcm_new,
+	.pcm_free	= aml_pcm_free_dma_buffers,
+	.suspend	= aml_pcm_suspend,
+	.resume		= aml_pcm_resume,
+};
+
+EXPORT_SYMBOL_GPL(aml_soc_platform);
+
+static int aml_soc_platform_probe(struct platform_device *pdev)
+{
+	INIT_WORK(&aml_pcm_work.aml_codec_workqueue, aml_codec_power_switch_queue);
+	/* get audioin cfg data from board */
+	if(pdev->dev.platform_data){
+		audioin_mode = *(unsigned *)pdev->dev.platform_data;
+		printk("AML soc audio in mode =============   %d \n",audioin_mode);
+	}	
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
+}
+
+static int aml_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-audio",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_pcm_driver = {
+	.driver = {
+			.name = "aml-audio",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,
+	},
+
+	.probe = aml_soc_platform_probe,
+	.remove = aml_soc_platform_remove,
+};
+
+static int __init aml_alsa_audio_init(void)
+{
+	aml_pcm_init_debugfs();
+	return platform_driver_register(&aml_pcm_driver);
+}
+
+static void __exit aml_alsa_audio_exit(void)
+{
+	aml_pcm_cleanup_debugfs();
+    platform_driver_unregister(&aml_pcm_driver);
+}
+
+module_init(aml_alsa_audio_init);
+module_exit(aml_alsa_audio_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
+#endif
diff --git a/sound/soc/aml/aml_pcm.h b/sound/soc/aml/aml_pcm.h
new file mode 100755
index 000000000000..bb4e2b16d8b9
--- /dev/null
+++ b/sound/soc/aml/aml_pcm.h
@@ -0,0 +1,75 @@
+#ifndef __AML_PCM_H__
+#define __AML_PCM_H__
+
+//#define debug_printk
+#ifdef debug_printk
+#define dug_printk(fmt, args...)  printk (fmt, ## args)
+#else
+#define dug_printk(fmt, args...)
+#endif
+
+typedef struct audio_stream {
+    int stream_id;
+    int active;
+    unsigned int last_ptr;
+    unsigned int size;
+    unsigned int sample_rate;
+    unsigned int I2S_addr;
+    spinlock_t lock;
+    struct snd_pcm_substream *stream;
+	unsigned i2s_mode; //0:master, 1:slave,
+} audio_stream_t;
+
+typedef struct aml_audio {
+    struct snd_card *card;
+    struct snd_pcm *pcm;
+    audio_stream_t s[2];
+} aml_audio_t;
+
+typedef struct audio_mixer_control {
+    int output_devide;
+    int input_device;
+    int direction;
+    int input_volume;
+    int output_volume;
+} audio_mixer_control_t;
+
+typedef struct audio_tone_control {
+    unsigned short * tone_source;
+    unsigned short * tone_data;
+    int tone_data_len;
+    int tone_count;
+    int tone_flag;
+}audio_tone_control_t;
+
+struct aml_pcm_dma_params{
+		char *name;			/* stream identifier */
+		struct snd_pcm_substream *substream;
+		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
+	
+};
+typedef struct aml_dai_info {
+	unsigned i2s_mode; //0:master, 1:slave,
+} aml_dai_info_t;
+enum {
+	I2S_MASTER_MODE = 0,
+	I2S_SLAVE_MODE,	
+};
+/*--------------------------------------------------------------------------*\
+ * Data types
+\*--------------------------------------------------------------------------*/
+struct aml_runtime_data {
+	struct aml_pcm_dma_params *params;
+	dma_addr_t dma_buffer;		/* physical address of dma buffer */
+	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
+
+	struct snd_pcm_substream *substream;
+	audio_stream_t s;	
+	struct timer_list timer;	// timeer for playback and capture
+    struct hrtimer hrtimer;
+};
+
+extern struct snd_soc_platform_driver aml_soc_platform;
+extern struct aml_audio_interface aml_i2s_interface;
+
+#endif
diff --git a/sound/soc/aml/aml_platform.c b/sound/soc/aml/aml_platform.c
new file mode 100755
index 000000000000..5dace9fc1b5a
--- /dev/null
+++ b/sound/soc/aml/aml_platform.c
@@ -0,0 +1,573 @@
+/*
+ * aml_platform.c  --  ALSA audio platform interface for the AML Meson SoC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#include "aml_platform_pcm2bt.h"
+#include "aml_pcm.h"
+#include "aml_platform.h"
+#include <linux/of.h>
+
+#ifndef ARRY_SIZE
+#define ARRY_SIZE(A)    (sizeof(A) /sizeof(A[0]))
+#endif
+
+static LIST_HEAD(stream_list);
+static DEFINE_SPINLOCK(platform_lock);
+    
+struct aml_platform_stream{
+    struct list_head list;
+    struct aml_audio_interface *interface;
+    struct snd_pcm_substream *substream;
+};
+
+static struct aml_audio_interface *audio_interfaces[] = {
+    &aml_i2s_interface,
+    &aml_pcm_interface,
+};
+
+static inline struct aml_audio_interface *find_audio_interface(int id)
+{
+    struct aml_audio_interface *interface = NULL;
+    int i = 0;
+
+    for (i=0; i<ARRAY_SIZE(audio_interfaces); i++) {
+        if (audio_interfaces[i]->id == id) {
+            interface = audio_interfaces[i];
+            break;
+        }
+    }
+
+    return interface;
+}
+
+static inline struct aml_platform_stream *find_platform_stream(struct snd_pcm_substream *substream)
+{
+    struct aml_platform_stream *plat_stream = NULL;
+    struct list_head *entry = NULL;
+
+    list_for_each(entry, &stream_list) {
+        plat_stream = list_entry(entry, struct aml_platform_stream, list);
+        if (plat_stream->substream == substream) {
+            return plat_stream;
+        }
+    }
+
+    return NULL;
+}
+
+static void dump_platform_stream(void)
+{
+    struct aml_platform_stream *plat_stream = NULL;
+    struct list_head *entry = NULL;
+    int n = 0;
+
+    list_for_each(entry, &stream_list) {
+        plat_stream = list_entry(entry, struct aml_platform_stream, list);
+        printk(KERN_INFO "substream#%d ptr: %p type: %s name: %s interface: %s\n",
+                        n,
+                        plat_stream->substream,
+                        (plat_stream->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture",
+                        plat_stream->substream->name,
+                        plat_stream->interface->name);
+        n++;
+    }
+}
+
+static int aml_platform_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    aud_interface = find_audio_interface(cpu_dai->id);
+    if (unlikely(NULL == aud_interface)) {
+        printk(KERN_ERR "aml-platform: no such audio interface!");
+        ret = -ENODEV;
+        goto out;
+    }
+
+    BUG_ON(aud_interface->pcm_ops->open == NULL);
+
+	plat_stream = kzalloc(sizeof(struct aml_platform_stream), GFP_KERNEL);
+	if (unlikely(plat_stream == NULL)) {
+        printk(KERN_ERR "aml-platform: out of memory!");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+    ret = aud_interface->pcm_ops->open(substream);
+    if (ret >= 0) {
+        INIT_LIST_HEAD(&plat_stream->list);
+        plat_stream->substream = substream;
+        plat_stream->interface = aud_interface;
+
+        spin_lock(&platform_lock);
+        list_add_tail(&plat_stream->list, &stream_list);
+        spin_unlock(&platform_lock);
+
+        dump_platform_stream();
+    } else {
+        printk(KERN_ERR "aml-platform: open pcm substream failed ret: %d!", ret);
+    }
+
+out:
+    return ret;
+}
+
+static int aml_platform_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->close == NULL);
+
+        ret = aud_interface->pcm_ops->close(substream);
+        if (ret >= 0) {
+            spin_lock(&platform_lock);
+            list_del(&plat_stream->list);
+            spin_unlock(&platform_lock);
+            kfree(plat_stream);
+        } else {
+            printk(KERN_ERR "aml-platform: close pcm substream failed ret: %d!", ret);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_ioctl(struct snd_pcm_substream * substream,
+                unsigned int cmd, void *arg)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->ioctl) {
+            ret = aud_interface->pcm_ops->ioctl(substream, cmd, arg);
+        } else {
+            ret = snd_pcm_lib_ioctl(substream, cmd, arg);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_hw_params(struct snd_pcm_substream *substream,
+		 struct snd_pcm_hw_params *params)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->hw_params == NULL);
+
+        ret = aud_interface->pcm_ops->hw_params(substream, params);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_hw_free(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->hw_free == NULL);
+
+        ret = aud_interface->pcm_ops->hw_free(substream);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_prepare(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->prepare == NULL);
+
+        ret = aud_interface->pcm_ops->prepare(substream);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->trigger == NULL);
+        ret = aud_interface->pcm_ops->trigger(substream, cmd);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static snd_pcm_uframes_t aml_platform_pointer(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    snd_pcm_uframes_t ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->pointer == NULL);    
+        ret = aud_interface->pcm_ops->pointer(substream);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+
+static int aml_platform_copy(struct snd_pcm_substream *substream, int channel,
+        	    snd_pcm_uframes_t pos,
+        	    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->copy == NULL);
+
+        ret = aud_interface->pcm_ops->copy(substream, channel, pos, buf, count);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_silence(struct snd_pcm_substream *substream, int channel, 
+                snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    unsigned char* ppos = NULL;
+    ssize_t n = 0;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->silence) {
+            ret = aud_interface->pcm_ops->silence(substream, channel, pos, count);
+        } else {
+            n = frames_to_bytes(runtime, count);
+            ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+            memset(ppos, 0, n);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static struct page *aml_platform_page(struct snd_pcm_substream *substream,
+                        unsigned long offset)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    struct page *ret = NULL;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->page) {
+            ret = aud_interface->pcm_ops->page(substream, offset);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+
+static int aml_platform_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->mmap) {
+            ret = aud_interface->pcm_ops->mmap(substream, vma);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+
+static int aml_platform_ack(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->ack) {
+            ret = aud_interface->pcm_ops->ack(substream);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+    
+static struct snd_pcm_ops aml_platform_ops = {
+	.open		= aml_platform_open,
+	.close		= aml_platform_close,
+	.ioctl		= aml_platform_ioctl,
+	.hw_params	= aml_platform_hw_params,
+	.hw_free	= aml_platform_hw_free,
+	.prepare	= aml_platform_prepare,
+	.trigger	= aml_platform_trigger,
+	.pointer	= aml_platform_pointer,
+	.copy       = aml_platform_copy,
+	.silence    = aml_platform_silence,
+	.page       = aml_platform_page,
+	.mmap       = aml_platform_mmap,
+	.ack        = aml_platform_ack,
+};
+
+static int aml_platform_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+    printk("rtd %x \n",	(unsigned)rtd);
+	
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    printk("cpu_dai %x \n",	(unsigned)cpu_dai);
+	
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    printk("codec_dai %x \n",	(unsigned)codec_dai);
+	
+    struct aml_audio_interface *aud_interface = NULL;
+    struct snd_pcm *pcm =rtd->pcm ;
+    struct snd_soc_card *card = rtd->card;
+	
+	int ret = 0;
+
+    printk(KERN_DEBUG"enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    aud_interface = find_audio_interface(cpu_dai->id);
+    if (unlikely(NULL == aud_interface)) {
+        printk(KERN_ERR "aml-platform: no such audio interface!");
+        ret = -ENODEV;
+        goto out;
+    }
+
+    BUG_ON(aud_interface->pcm_new == NULL);
+    ret = aud_interface->pcm_new(rtd);
+out:
+	return ret;
+}
+
+static void aml_platform_pcm_free(struct snd_pcm *pcm)
+{
+    struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct aml_audio_interface *aud_interface = NULL;
+
+    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    aud_interface = find_audio_interface(cpu_dai->id);
+    if (unlikely(NULL == aud_interface)) {
+        printk(KERN_ERR "aml-platform: no such audio interface!");
+        return;
+    }
+
+    BUG_ON(aud_interface->pcm_free == NULL);
+    aud_interface->pcm_free(pcm);
+
+	return;
+}
+
+static int aml_platform_suspend(struct snd_soc_dai *dai)
+{
+
+	/* disable the PDC and save the PDC registers */
+	// TODO
+	printk("aml pcm suspend\n");	
+
+	return 0;
+}
+
+static int aml_platform_resume(struct snd_soc_dai *dai)
+{
+	/* restore the PDC registers and enable the PDC */
+	// TODO
+	printk("aml pcm resume\n");
+	return 0;
+}
+
+struct snd_soc_platform_driver aml_soc_platform2 = {
+	.ops 	= &aml_platform_ops,
+	.pcm_new	= aml_platform_pcm_new,
+	.pcm_free	= aml_platform_pcm_free,
+
+	.suspend	= aml_platform_suspend,
+	.resume		= aml_platform_resume,
+};
+
+static int  aml_soc_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform2);
+}
+
+static int  aml_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-audio",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_soc_platform_driver = {
+	.driver = {
+			.name = "aml-audio",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,			
+	},
+
+	.probe = aml_soc_platform_probe,
+	.remove = aml_soc_platform_remove,
+};
+
+static int __init aml_soc_platform_init(void)
+{
+	return platform_driver_register(&aml_soc_platform_driver);
+}
+
+static void __exit aml_soc_platform_exit(void)
+{
+    platform_driver_unregister(&aml_soc_platform_driver);
+}
+
+module_init(aml_soc_platform_init);
+
+module_exit(aml_soc_platform_exit);
+
+MODULE_AUTHOR("Amlogic, Inc.");
+MODULE_DESCRIPTION("Amlogic ASoC platform driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/aml/aml_platform.h b/sound/soc/aml/aml_platform.h
new file mode 100755
index 000000000000..d51694d2f0d9
--- /dev/null
+++ b/sound/soc/aml/aml_platform.h
@@ -0,0 +1,36 @@
+/*
+ * aml_platform.h  --  ALSA audio platform interface for the AML Meson SoC
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#ifndef _AML_PLATFORM_H
+#define _AML_PLATFORM_H
+
+#define AML_AUDIO_I2S       0
+#define AML_AUDIO_PCM       1
+
+struct aml_audio_interface
+{
+    unsigned int id;
+    char    *name;
+    struct  snd_pcm_ops *pcm_ops;
+
+	int     (*pcm_new)(struct snd_soc_pcm_runtime *rtd);
+	void    (*pcm_free)(struct snd_pcm *);
+};
+
+#endif /* _AML_PLATFORM_H */
diff --git a/sound/soc/aml/aml_platform_pcm2bt.c b/sound/soc/aml/aml_platform_pcm2bt.c
new file mode 100755
index 000000000000..39475697d9ba
--- /dev/null
+++ b/sound/soc/aml/aml_platform_pcm2bt.c
@@ -0,0 +1,687 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include "aml_platform_pcm2bt.h"
+#include "aml_audio_hw_pcm2bt.h"
+#include "aml_pcm.h"
+#include "aml_platform.h"
+
+//#define PCM_DEBUG
+
+#ifdef PCM_DEBUG
+#define pcm_debug(fmt, args...)  printk (fmt, ## args)
+#else
+#define pcm_debug(fmt, args...)
+#endif
+
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+				  		    SNDRV_PCM_INFO_PAUSE,
+				  		
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8*1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+	
+	.rate_min = 8000,
+    .rate_max = 8000,
+    .channels_min = 1,
+    .channels_max = 1,
+};
+
+struct aml_pcm_runtime_data {
+	spinlock_t			lock;
+
+    dma_addr_t          buffer_start;
+    unsigned int        buffer_size;
+
+    unsigned int        buffer_offset;
+
+    unsigned int        data_size;
+
+    unsigned int        running;
+    unsigned int        timer_period;
+    unsigned int        peroid_elapsed;
+
+    struct timer_list   timer;
+    struct snd_pcm_substream *substream;
+};
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+unsigned int aml_pcm2bt_playback_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_buffer_size = 0;
+
+unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
+
+static void aml_pcm_config_tx(u32 addr, u32 size)
+{
+    pcm_debug(KERN_DEBUG "%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_out_set_buf(addr, size);
+}
+
+static void aml_pcm_config_rx(u32 addr, u32 size)
+{
+    pcm_debug(KERN_DEBUG "%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_in_set_buf(addr, size);
+}
+
+static void aml_pcm_start_tx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_out_enable(1);
+}
+
+static void aml_pcm_start_rx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_in_enable(1);
+}
+
+static void aml_pcm_stop_tx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_out_enable(0);
+}
+
+static void aml_pcm_stop_rx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_in_enable(0);
+}
+
+static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_out_rd_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_in_wr_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
+{
+    struct snd_pcm_substream *substream = prtd->substream;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned int offset = 0;
+    unsigned int size = 0;
+    
+    if (prtd->running && snd_pcm_running(substream)) {
+    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    		offset = aml_pcm_offset_tx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+    	} else {
+            int rx_overflow = 0;
+    		offset = aml_pcm_offset_rx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+            rx_overflow = pcm_in_fifo_int() & (1 << 2);
+            if (rx_overflow) {
+                printk(KERN_WARNING "%s AUDIN_FIFO overflow !!\n", __FUNCTION__);
+            }
+    	}
+    }
+
+    prtd->buffer_offset = offset;
+    prtd->data_size += size;
+    if (prtd->data_size >= frames_to_bytes(runtime, runtime->period_size)) {
+        prtd->peroid_elapsed++;
+    }
+
+    pcm_debug(KERN_DEBUG "%s buffer offset: %d data size: %d peroid size: %d peroid elapsed: %d\n",
+                __FUNCTION__, prtd->buffer_offset, prtd->data_size, frames_to_bytes(runtime, runtime->period_size), prtd->peroid_elapsed);
+}
+
+static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
+{
+    prtd->timer.expires = jiffies + prtd->timer_period;
+	add_timer(&prtd->timer);
+}
+
+static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+	aml_pcm2bt_timer_rearm(prtd);
+    prtd->running = 1;
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+    prtd->running = 0;
+	del_timer(&prtd->timer);
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+
+static void aml_pcm2bt_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	unsigned long flags;
+	unsigned int elapsed = 0;
+    unsigned int datasize = 0;
+	
+	spin_lock_irqsave(&prtd->lock, flags);
+    aml_pcm2bt_timer_update(prtd);
+    aml_pcm2bt_timer_rearm(prtd);
+	elapsed = prtd->peroid_elapsed;
+    datasize = prtd->data_size;
+    if (elapsed) {
+        prtd->peroid_elapsed--;
+        prtd->data_size -= frames_to_bytes(runtime, runtime->period_size);
+    }
+	spin_unlock_irqrestore(&prtd->lock, flags);
+	if (elapsed) {
+        if (elapsed > 1) {
+            printk(KERN_WARNING "PCM timer callback not fast enough (elapsed periods: %d data_bytes: %d period_bytes: %d)!",
+                    elapsed, datasize, frames_to_bytes(runtime, runtime->period_size));
+        }
+		snd_pcm_period_elapsed(prtd->substream);
+    }
+}
+
+static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	init_timer(&prtd->timer);
+    prtd->timer_period = 1;
+	prtd->timer.data = (unsigned long)substream;
+	prtd->timer.function = aml_pcm2bt_timer_callback;
+    prtd->running = 0;
+	return 0;
+}
+
+static int aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	size_t size = params_buffer_bytes(params);
+    int ret = 0;
+
+	ret = snd_pcm_lib_malloc_pages(substream, size);
+    if (ret < 0) {
+        printk(KERN_ERR "%s snd_pcm_lib_malloc_pages return: %d\n", __FUNCTION__, ret);
+    } else {
+        prtd->buffer_start = runtime->dma_addr;
+        prtd->buffer_size = runtime->dma_bytes;
+        pcm_debug(KERN_DEBUG "%s dma_addr: 0x%08x dma_bytes: 0x%x\n", __FUNCTION__, runtime->dma_addr, runtime->dma_bytes);
+
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_playback_phy_buffer_size = runtime->dma_bytes;
+        } else {
+            aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
+        }
+    }
+
+    return ret;
+}
+
+static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	snd_pcm_lib_free_pages(substream);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        aml_pcm2bt_playback_phy_buffer_addr = 0;
+        aml_pcm2bt_playback_phy_buffer_size = 0;
+    } else {
+        aml_pcm2bt_capture_phy_buffer_addr = 0;
+        aml_pcm2bt_capture_phy_buffer_size = 0;
+    }
+
+    return 0;
+}
+
+static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        pcm_debug(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_tx(prtd->buffer_start, prtd->buffer_size);
+        aml_pcm2bt_playback_buffer_addr = (unsigned int)runtime->dma_area;
+        aml_pcm2bt_playback_buffer_size = runtime->dma_bytes;
+	} else {
+	    pcm_debug(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_rx(prtd->buffer_start, prtd->buffer_size);
+        aml_pcm2bt_capture_buffer_addr = (unsigned int)runtime->dma_area;
+        aml_pcm2bt_capture_buffer_size = runtime->dma_bytes;
+	}
+
+    memset(runtime->dma_area, 0, runtime->dma_bytes);
+    prtd->buffer_offset = 0;
+    prtd->data_size = 0;
+    prtd->peroid_elapsed = 0;
+
+	return 0;
+}
+
+static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+    	case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_RESUME:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_start_tx();
+    		else
+    			aml_pcm_start_rx();
+            aml_pcm2bt_timer_start(prtd);
+    		break;
+    	case SNDRV_PCM_TRIGGER_STOP:
+    	case SNDRV_PCM_TRIGGER_SUSPEND:
+    	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            aml_pcm2bt_timer_stop(prtd);
+    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_stop_tx();
+    		else
+    			aml_pcm_stop_rx();
+    		break;
+    	default:
+    		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    snd_pcm_uframes_t frames;
+        
+	pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    frames = bytes_to_frames(runtime, (ssize_t)prtd->buffer_offset);
+
+	return frames;
+}
+
+static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
+
+    /* Ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0) {
+		printk(KERN_ERR "set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* Ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+        printk(KERN_ERR "set periods constraint error\n");
+		goto out;
+    }
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+        printk(KERN_ERR "out of memory\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+    runtime->private_data = prtd;
+    aml_pcm2bt_timer_create(substream);
+    prtd->substream = substream;
+	spin_lock_init(&prtd->lock);
+
+    return 0;
+out:
+	return ret;
+}
+
+
+static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+   
+    printk(KERN_INFO "enter %s type: %d\n", __FUNCTION__, substream->stream);
+    if (prtd)
+	    kfree(runtime->private_data);
+	return 0;
+}
+
+
+static int aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    unsigned char* hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    unsigned int wrptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy from user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        wrptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (wrptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            wrptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_out_set_wr_ptr(wrptr);
+    }
+
+    return ret;
+}
+
+	
+
+
+static int aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    signed short *hwbuf = (signed short*)(runtime->dma_area + frames_to_bytes(runtime, pos));
+    unsigned int rdptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy to user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        //memset(hwbuf, 0xff, frames_to_bytes(runtime, count));
+        rdptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (rdptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            rdptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_in_set_rd_ptr(rdptr);
+    }
+    return ret;
+}
+
+static int aml_pcm2bt_copy(struct snd_pcm_substream *substream, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        ret = aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
+    } else {
+        ret = aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
+    }
+
+    return ret;
+}
+
+
+static int aml_pcm2bt_silence(struct snd_pcm_substream *substream, int channel, 
+    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned char* ppos = NULL;
+    ssize_t n;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    n = frames_to_bytes(runtime, count);
+    ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+    memset(ppos, 0, n);
+
+    return 0;
+}
+                        
+static struct snd_pcm_ops aml_pcm2bt_ops = {
+	.open		= aml_pcm2bt_open,
+	.close		= aml_pcm2bt_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_pcm2bt_hw_params,
+	.hw_free	= aml_pcm2bt_hw_free,
+	.prepare	= aml_pcm2bt_prepare,
+	.trigger	= aml_pcm2bt_trigger,
+	.pointer	= aml_pcm2bt_pointer,
+	.copy 		= aml_pcm2bt_copy,
+	.silence	= aml_pcm2bt_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+
+static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
+
+static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
+
+    printk(KERN_DEBUG "enter %s stream: %d\n", __FUNCTION__, stream);
+    
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area) {
+        printk(KERN_ERR "%s dma_alloc_coherent failed (size: %d)!\n", __FUNCTION__, size);
+		return -ENOMEM;
+    }
+
+	buf->bytes = size;
+    printk(KERN_INFO "%s allcoate buf->area: %p buf->addr: 0x%x buf->bytes: %d\n",
+                __FUNCTION__, buf->area, buf->addr, buf->bytes);
+	return 0;
+}
+
+static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
+       pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
+    
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_pcm2bt_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void aml_pcm2bt_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+struct aml_audio_interface aml_pcm_interface = {
+    .id = AML_AUDIO_PCM,
+    .name = "PCM",
+    .pcm_ops = &aml_pcm2bt_ops,
+    .pcm_new = aml_pcm2bt_new,
+    .pcm_free =  aml_pcm2bt_free,
+};
+
+
+#if 0
+struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
+	.ops 	= &aml_pcm2bt_ops,
+	.pcm_new	= aml_pcm2bt_new,
+	.pcm_free	= aml_pcm2bt_free,
+	//.suspend	= aml_pcm_suspend,
+	//.resume		= aml_pcm_resume,
+};
+EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
+
+static int __devinit aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
+{
+	//INIT_WORK(&aml_pcm_work.aml_codec_workqueue, aml_codec_power_switch_queue);
+	printk("shaoshuai, snd_soc_register_platform\n");
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
+}
+
+static int __devexit aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver aml_platform_pcm2bt_driver = {
+	.driver = {
+			.name = "aml-bt",
+			.owner = THIS_MODULE,
+	},
+
+	.probe = aml_soc_platform_pcm2bt_probe,
+	.remove = __devexit_p(aml_soc_platform_pcm2bt_remove),
+};
+
+static int __init aml_alsa_bt_init(void)
+{
+	//aml_pcm_init_debugfs();		
+	return platform_driver_register(&aml_platform_pcm2bt_driver);
+}
+
+static void __exit aml_alsa_bt_exit(void)
+{
+	//aml_pcm_cleanup_debugfs();
+    platform_driver_unregister(&aml_platform_pcm2bt_driver);
+}
+
+module_init(aml_alsa_bt_init);
+module_exit(aml_alsa_bt_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
+#endif
diff --git a/sound/soc/aml/aml_platform_pcm2bt.h b/sound/soc/aml/aml_platform_pcm2bt.h
new file mode 100755
index 000000000000..233f906574c6
--- /dev/null
+++ b/sound/soc/aml/aml_platform_pcm2bt.h
@@ -0,0 +1,6 @@
+#ifndef __AML_PCM_BT_H__
+#define __AML_PCM_BT_H__
+
+extern struct aml_audio_interface aml_pcm_interface;
+
+#endif
diff --git a/sound/soc/aml/aml_syno9629_codec.c b/sound/soc/aml/aml_syno9629_codec.c
new file mode 100644
index 000000000000..88911db98db2
--- /dev/null
+++ b/sound/soc/aml/aml_syno9629_codec.c
@@ -0,0 +1,1213 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <mach/am_regs.h>
+#include "aml_audio_hw.h"
+#include "aml_syno9629_codec.h"
+
+#define CODEC_DEBUG  printk
+#define stimulus_print  //printk
+#define Wr WRITE_MPEG_REG
+#define Rd  READ_MPEG_REG
+static struct snd_soc_codec *aml_syno9629_codec;
+
+static int (*is_hp_pluged)(void) = NULL;
+static void (*mute_spk)(struct snd_soc_codec* codec, int flag) = NULL;
+static void latch (void);
+static void acodec_delay_us (int us);
+
+/* codec private data */
+struct aml_syno9629_codec_priv {
+	struct snd_soc_codec codec;
+	u16 reg_cache[ADAC_MAXREG];
+	unsigned int sysclk;
+};
+
+u16 aml_syno9629_reg[ADAC_MAXREG] = {0};
+static const unsigned int linein_values[] = {
+    1|(1<<(1-1)),
+    1|(1<<(2-1)),
+    1|(1<<(3-1)),
+    1|(1<<(4-1)),
+    1|(1<<(5-1)),
+    1|(1<<(6-1)),
+    1|(1<<(7-1)),
+    1|(1<<(8-1))
+    };
+
+unsigned long aml_rate_table[] = {
+    8000, 11025, 12000, 16000, 22050, 24000, 32000, 
+    44100, 48000, 88200, 96000, 192000
+};
+static unsigned int acodec_regbank[ADAC_MAXREG] = {
+									0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg   0 -   9
+                                    0x00, 0x00, 0x08, 0x08, 0x01, 0x00, 0x00, 0xae, 0x00, 0x00, // Reg  10 -  19
+                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg  20 -  29
+                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x04, 0x04, // Reg  30 -  39
+                                    0x12, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg  40 -  49
+                                    0x00, 0x00, 0x54, 0x54, 0xff, 0xff, 0x28, 0x28, 0xff, 0xff, // Reg  50 -  59
+                                    0x28, 0x28, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg  60 -  69
+                                    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, // Reg  70 -  79
+                                    0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x01, 0x01, 0x02, // Reg  80 -  89
+                                    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, // Reg  90 -  99
+                                    0x00, 0x12, 0x12, 0x3c, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, // Reg 100 - 109
+                                    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2e, 0x2e, // Reg 110 - 119
+                                    0xff, 0xff, 0x2e, 0x2e, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg 120 - 129
+                                    0x00, 0x00, 0x04, 0x04, 0x12, 0x12, 0xff, 0xff, 0xff, 0xff, // Reg 130 - 139
+                                    0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x28, 0x28, // Reg 140 - 149
+                                    0xff, 0xff, 0x28, 0x28, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg 150 - 159
+                                    0x00, 0x00, 0x03, 0xf3, 0x00, 0x04, 0x03, 0x08, 0x00, 0x0c, // Reg 160 - 169
+                                    0x00, 0x10, 0x00, 0x14, 0x00, 0x18, 0x01, 0x1c, 0x00, 0x20, // Reg 170 - 179
+                                    0x00, 0x24, 0x00, 0x28, 0x7f, 0x2c, 0x24, 0x2c, 0x56, 0x30, // Reg 180 - 189
+                                    0x00, 0x34, 0x37, 0x38, 0x7f, 0x3c, 0x01, 0x01, 0x00, 0x00, // Reg 190 - 199
+                                    0x00, 0x06, 0x00, 0x06, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg 200 - 209
+                                    0x00, 0x00, 0x00, 0x03, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg 210 - 219
+                                    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x40, 0x01, 0x00, 0x00, // Reg 220 - 229
+                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg 230 - 239
+                                    0x02, 0x02, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x49, 0xfc, // Reg 240 - 249
+                                    0x50, 0x84, 0x00, 0x00, 0x00, 0x00 							// Reg 250 - 255
+                                   };
+
+typedef enum  {
+    AML_PWR_DOWN,
+    AML_PWR_UP,
+    AML_PWR_KEEP,
+} AML_PATH_SET_TYPE;
+
+static void set_acodec_source (unsigned int src)
+{
+    unsigned long data32;
+    unsigned int i;
+    
+    // Disable acodec clock input and its DAC input
+    data32  = 0;
+    data32 |= 0     << 4;   // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= 0     << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
+
+    // Enable acodec clock from the selected source
+    data32  = 0;
+    data32 |= 0      << 4;  // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= src   << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
+    
+    // Wait until clock change is settled
+    i = 0;
+    while ( (((Rd(AIU_CODEC_CLK_DATA_CTRL)) >> 8) & 0x3) != src ) {
+        if (i > 255) {
+            stimulus_print("[TEST.C] Error: set_acodec_source timeout!\n");
+           // stimulus_finish_fail(10);
+        }
+        i ++;
+    }
+
+    // Enable acodec DAC input from the selected source
+    data32  = 0;
+    data32 |= src   << 4;   // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= src   << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
+
+    // Wait until data change is settled
+    while ( (((Rd(AIU_CODEC_CLK_DATA_CTRL)) >> 12) & 0x3) != src) {}
+} /* set_acodec_source */
+
+static void adac_wr_reg (unsigned long addr, unsigned long data)
+{
+    WRITE_APB_REG((APB_BASE+(addr<<2)), data);
+    acodec_regbank[addr] = data;
+} /* adac_wr_reg */
+
+static unsigned long adac_rd_reg (unsigned long addr)
+{
+    unsigned long data;
+    data = READ_APB_REG((APB_BASE+(addr<<2)));
+    return (data);
+} /* adac_rd_reg */
+
+static void adac_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask)
+{
+    unsigned long rd_data;
+    rd_data = adac_rd_reg(addr);
+    if ((rd_data | mask) != (exp_data | mask)) {
+        stimulus_print("[TEST.C] Error: audio CODEC register read data mismatch!\n");
+        stimulus_print("addr=0x%x ,",addr);
+        stimulus_print(" rd_data=0x%x ,",rd_data);
+        stimulus_print(" exp_data=0x%x\n",exp_data);
+    }
+} /* adac_rd_check_reg */
+
+static void acodec_startup_sequence (void)
+{
+    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- Begin\n");
+/*  
+1.	select the master clock mode mclksel[3:0] bit
+2.	start the master clock
+3.	set pdz bit to high
+4.	select the sampling rate
+5.	reset the signal path (rstdpz pin to low and back to high after 100ns)
+6.	start the individual codec blocks
+
+	7.1.1	Pop free start up recommendations
+	To obtain a pop-free start-up for the playback channel, the corresponding 
+	blocks in the desired playback signal path must also be enable when setting
+	the master power up control active, as per the start-up sequence step 3 
+	(above).
+
+	For example, when setting pdz bit to high, pddacl/rz bit, pdhsdrvl/rz bit 
+	and/or pdauxdrvl/rz bit should also be set to high at the same time to
+	obtain a clean, pop-free start up.
+	By using the latch signal properly, it is possible to guarantee that all the
+	required power control, signals are loaded to the Audio Codec IP
+	simultaneously.*/
+
+	// Init at zero (In power Down and In Reset)
+    //data32  = 0;
+    //data32 |= 1     << 15;  // [15]     audac_soft_reset_n
+    //data32 |= 1     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
+    //data32 |= 0     << 9;   // [9]      delay_rd_en
+    //data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
+    //data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
+    //data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
+    Wr(AIU_AUDAC_CTRL0, Rd(AIU_AUDAC_CTRL0) | (1<<15) | (1<<14));
+//    adac_wr_reg(0x15, 0x00);
+//    latch();
+    acodec_delay_us(3000);
+    
+    // Disable system reset (In power Down and Out of Reset)
+    Wr(AIU_AUDAC_CTRL0, Rd(AIU_AUDAC_CTRL0) & (~(1<<15)));
+    acodec_delay_us(3000);
+    
+    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- End\n");
+} /* acodec_startup_sequence */
+
+static void acodec_config (unsigned long mclkseladc,   // [3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+                    unsigned long mclkseldac,   // [3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+                    unsigned long i2sfsadc,     // [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+                    unsigned long i2sfsdac,     // [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+                    unsigned long i2smsmode,    // 0=slave mode; 1=master mode.
+                    unsigned long i2smode,      // [2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
+                    unsigned long pgamute,      // [1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
+                    unsigned long recmute,      // [1:0]: [0] Recording left channel digital mute; [1] Recording right channel digital mute. 0=un-mute; 1=mute.
+                    unsigned long hs1mute,      // [1:0]: [0] Headset left channel analog mute; [1] Headset right channel analog mute. 0=un-mute; 1=mute.
+                    unsigned long lmmute,       // [1:0]: [0] Playback left channel digital mute; [1] Playback right channel digital mute. 0=un-mute; 1=mute.
+                    unsigned long ldr1outmute,  // [1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
+                    unsigned long recvol,       // [15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0x14=0dB.
+                    unsigned long pgavol,       // [15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x04=0dB.
+                    unsigned long lmvol,        // [15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0x54=0dB.
+                    unsigned long hs1vol,       // [15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x28=0dB.
+                    unsigned long pgasel,       // [15:0]: Left PGA input selection. [7:0] Left; [15:8] Right. 0x01=Input1, 0x03=Input2, 0x05=Input3, 0x09=Input4, 0x11=Input5, 0x21=Input6, 0x41=Input7, 0x81=Input8, others=Rsrv.
+                    unsigned long ldr1sel,      // [15:0]: Playback analog mixer input selection. [7:0] Left; [15:8] Right. [0]:1=Enable left DAC output; [1]:1=Enable left PGA; [2]:1=Enable right DAC output.
+                    unsigned long ctr,          // [1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
+                    unsigned long recmix,       // [1:0]: Record digital mixer sel.
+                    unsigned long enhp,         // Record channel high pass filter enable.
+                    unsigned long lmmix)        // [1:0]: Playback digital mixer sel.
+{
+    stimulus_print("[TEST.C] audio CODEC register config -- Begin\n");
+    adac_wr_reg(ADC_MCLK_SEL, mclkseladc);
+    adac_wr_reg(DAC_MCLK_SEL, mclkseldac); //256fs
+    adac_wr_reg(ADC_I2S_FS_SEL, i2sfsadc);
+    adac_wr_reg(DAC_I2S_FS_SEL, i2sfsdac); //48k
+    adac_wr_reg(ADAC_I2S_MODE_SEL, (i2smsmode<<3) | i2smode); //slave mode ,i2s 
+    adac_wr_reg(ADAC_MUTE_CTRL0, (pgamute<<2) | recmute); //un mute
+    adac_wr_reg(ADAC_MUTE_CTRL2, (hs1mute<<4) | lmmute);  //un mute
+    adac_wr_reg(ADAC_MUTE_CTRL4, (ldr1outmute<<2));
+    adac_wr_reg(ADC_REC_MVOL_LSB_CTRL, recvol&0xff);
+    adac_wr_reg(ADC_REC_MVOL_MSB_CTRL, recvol>>8);
+    adac_wr_reg(ADC_PGA_VOL_LSB_CTRL, pgavol&0xff);
+    adac_wr_reg(ADC_PGA_VOL_MSB_CTRL, pgavol>>8);
+    adac_wr_reg(DAC_PLYBACK_MVOL_LSB_CTRL, lmvol&0xff);
+    adac_wr_reg(DAC_PLYBACK_MVOL_MSB_CTRL, lmvol>>8);
+    adac_wr_reg(DAC_HS_VOL_LSB_CTRL, hs1vol&0xff);
+    adac_wr_reg(DAC_HS_VOL_MSB_CTRL, hs1vol>>8);
+    adac_wr_reg(ADC_REC_INPUT_CH_LSB_SEL, pgasel&0xff);
+    adac_wr_reg(ADC_REC_INPUT_CH_MSB_SEL, pgasel>>8);
+    adac_wr_reg(DAC_PLYBACK_MIXER_LSB_CTRL, ldr1sel&0xff);
+    adac_wr_reg(DAC_PLYBACK_MIXER_MSB_CTRL, ldr1sel>>8);
+    adac_wr_reg(ADAC_DIGITAL_TEST_MODE_SEL, ctr);
+    adac_wr_reg(ADC_REC_PATH_MIXER_SEL, (enhp<<2) | recmix);
+    adac_wr_reg(DAC_PLYBACK_DIG_MIXER_SEL, lmmix);
+    latch();
+    stimulus_print("[TEST.C] audio CODEC register config -- End\n");
+}
+
+static void acodec_prepare_register (void)
+{
+    stimulus_print("[TEST.C] acodec_prepare_register -- Begin\n");
+    adac_wr_reg(ADAC_POWER_CTRL0, 0xfe);
+    adac_wr_reg(ADAC_POWER_CTRL1, 0xff);
+    //adac_wr_reg(0x17, 0xff);
+    adac_wr_reg(ADAC_POWER_CTRL3, 0xff);
+  //  adac_wr_reg(0x19, 0xff);
+    // Config the not power down
+   // adac_wr_reg(0x11, 0x80); // configure the bypass prechage
+
+    // Setup the lssel to 11, enable the line output
+    //adac_wr_reg(0x55, 0x01);
+    //adac_wr_reg(0x56, 0x01);
+    //latch();
+    //acodec_delay_us(4000); // wait for 4 ms.
+
+    // Set bias current to 1/40 of the nominal current
+    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x0b); 
+    latch();
+    stimulus_print("[TEST.C] acodec_prepare_register -- End\n");
+} /* acodec_prepare_register */
+
+void acodec_powerup_fastcharge (void)
+{
+    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- Begin\n");
+
+    // Disable the bypass fast charger
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG2, 0x00);
+    // test1 register, bit[2:1] to configure the charge time for VCM, when 0 100ms, when 1, 1s
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG1, 0x00);
+    // Enable the new FSM for power up, bit[7] for enable the original FSM
+    // Configure the vcmok, bit[1:0] for vcm ok configuration, when 11, 1.65v, when 01, lower
+    adac_wr_reg(ADAC_VCM_RAMP_CTRL, 0x83);
+    latch();
+    acodec_delay_us(4000); // wait for 4 ms
+
+    // reset data path
+    adac_wr_reg(ADAC_RESET, 0x00);
+    latch();
+    adac_wr_reg(ADAC_RESET, 0x03);
+    latch();
+    // Out of power Down and Out of Reset
+    adac_wr_reg(ADAC_POWER_CTRL0, 0x05);
+    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x05);
+    latch();
+
+    acodec_delay_us(1050000); // wait for 1.05 sec
+    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- End\n");
+} /* acodec_powerup_fastcharge */
+static void acodec_powerup_bypassfastcharge (void)
+{
+    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- Begin\n");
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG1, 0x00);
+    // Bypass power up sequence
+    // [0]--bypasspwrseq
+    // [1]--cfgprechanaref
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG2, 0x01);
+    // Disable soft ramping
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG4, 0x80);
+
+    // [7]--enprechanaref
+    adac_wr_reg(ADAC_ANALOG_TEST_REG3, 0x84);
+    // Enable the new FSM for power up, bit[7] for enable the original FSM
+    // Configure the vcmok, bit[1:0] for vcm ok configuration, when 11, 1.65v, when 01, lower
+    adac_wr_reg(ADAC_VCM_RAMP_CTRL, 0x83);
+
+    // Power up block and bias generator
+    latch();
+
+
+    // reset data path
+    adac_wr_reg(ADAC_RESET, 0x00);
+    latch();
+    adac_wr_reg(ADAC_RESET, 0x03);
+    latch();	
+    //acodec_delay_us(4000); // wait for 4 ms.
+    adac_wr_reg(ADAC_POWER_CTRL0, 0x0f);
+    latch();
+
+    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x05);
+    latch();
+    acodec_delay_us(5000);
+    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- End\n");
+} /* acodec_powerup_bypassfastcharge */
+
+static void latch (void)
+{
+    int latch;
+    latch = 1;
+    adac_wr_reg(ADAC_LATCH, latch);
+    adac_rd_check_reg(ADAC_LATCH, latch, 0);
+    latch = 0;
+    adac_wr_reg(ADAC_LATCH, latch);
+    adac_rd_check_reg(ADAC_LATCH, latch, 0);
+} /* latch */
+static void latch_ (struct snd_soc_codec* codec)
+{
+    int latch;
+    latch = 1;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+    latch = 0;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+}
+static void acodec_delay_us (int us)
+{
+	msleep(us/1000);
+} /* acodec_delay_us */
+
+static void aml_reset_path(struct snd_soc_codec* codec, AML_PATH_SET_TYPE type)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+
+    return ;
+#if 0	
+    unsigned int pwr_reg2 = snd_soc_read(codec, ADAC_POWER_CTRL_REG2);
+    latch_(codec);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
+    latch_(codec);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2|(1<<7));
+    latch_(codec);
+     
+    if (AML_PWR_DOWN == type)
+    {
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
+        latch_(codec);
+    }
+    
+    if (AML_PWR_KEEP == type)
+    {
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2);
+        latch_(codec);
+    }
+#endif	
+}
+
+static void aml_syno9629_reset(struct snd_soc_codec* codec, bool first_time)
+{
+	unsigned long   data32;
+	int i;
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	if (first_time)
+	{
+		CODEC_DEBUG( " first time enter %s\n", __func__);
+	
+		audio_set_clk(AUDIO_CLK_FREQ_48,0);
+		set_acodec_source(2);
+		WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+		//msleep(100);
+		data32  = 0;
+		// --------------------------------------------------------
+		// Configure audio DAC control interface
+		// --------------------------------------------------------
+		data32  = 0;
+		data32 |= 0     << 15;  // [15]     audac_soft_reset_n
+		data32 |= 1     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
+		data32 |= 0     << 9;   // [9]      delay_rd_en
+		data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
+		data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
+		data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
+		Wr(AIU_AUDAC_CTRL0, data32);
+		// Enable APB3 fail on error
+		data32  = 0;
+		data32 |= 1     << 15;  // [15]     err_en
+		data32 |= 255   << 0;   // [11:0]   max_err
+		Wr(AIU_AUDAC_CTRL1, data32);
+		// Check read back data
+		data32 = Rd(AIU_AUDAC_CTRL0);
+		if (data32 != ((1<<14) | (0x55<<1))) {
+			stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL0 read data mismatch!");
+			//stimulus_finish_fail(10);
+		}
+		data32 = Rd(AIU_AUDAC_CTRL1);
+		if (data32 != 0x80ff) {
+			stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL1 read data mismatch!");
+			//stimulus_finish_fail(10);
+		}
+
+		// Check audio CODEC default register default values
+		stimulus_print("[TEST.C] Checking audio CODEC default register default values ...\n");
+		for (i = 0; i < 252; i ++) {
+			adac_rd_check_reg(i, acodec_regbank[i], 0);
+		}
+		stimulus_print("[TEST.C] ... Done checking audio CODEC default register values\n");
+
+		// --------------------------------------
+		// Setup Audio CODEC
+		// --------------------------------------
+		stimulus_print("[TEST.C] Setup audio CODEC ...\n");
+
+		acodec_startup_sequence(); //reset rstz  ?
+
+		acodec_config(  0,      // mclkseladc[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+		    0,      // mclkseldac[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+		    8,     // i2sfsadc[3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+		    8,      // i2sfsdac[3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+		    0,      // i2smsmode: 0=slave mode; 1=master mode.
+		    1,      // i2smode[2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
+		    0,      // pgamute[1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
+		    0,      // recmute[1:0]: [0] Recording left channel digital mute; [1] Recording right channel digital mute. 0=un-mute; 1=mute.
+		    0,      // hs1mute[1:0]: [0] Headset left channel analog mute; [1] Headset right channel analog mute. 0=un-mute; 1=mute.
+		    0,      // lmmute[1:0]: [0] Playback left channel digital mute; [1] Playback right channel digital mute. 0=un-mute; 1=mute.
+		    0,      // ldr1outmute[1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
+		    0x1414, // recvol[15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0x14=0dB.
+		    0x0404, // pgavol[15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x04=0dB.
+		    0x5454, // lmvol[15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0x54=0dB.
+		    0x2828, // hs1vol[15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x28=0dB.
+		    0x0909, // pgasel[15:0]: Left PGA input selection. [7:0] Left; [15:8] Right. 0x01=Input1, 0x03=Input2, 0x05=Input3, 0x09=Input4, 0x11=Input5, 0x21=Input6, 0x41=Input7, 0x81=Input8, others=Rsrv.
+		    0x0202, // ldr1sel[15:0]: Playback analog mixer input selection. [7:0] Left; [15:8] Right. [0]:1=Enable left DAC output; [1]:1=Enable left PGA; [2]:1=Enable right DAC output.
+		    0,      // ctr[1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
+		    0,      // recmix[1:0]: Record digital mixer sel.
+		    0,      // enhp: Record channel high pass filter enable.
+		    0);     // lmmix[1:0]: Playback digital mixer sel.
+		acodec_prepare_register();
+
+		acodec_powerup_bypassfastcharge();
+		//acodec_powerup_fastcharge();	
+		// Check audio DAC register read-back values
+		stimulus_print("[TEST.C] Checking audio DAC register read-back values ...\n");
+		for (i = 0; i < 252; i ++) {
+			adac_rd_check_reg(i, acodec_regbank[i], 0);
+		}
+#if 0		
+		adac_wr_reg(0,  0); //rstadzpdz,rstdaczpdz  low
+		latch();
+		adac_wr_reg(0, 3);//rstadzpdz,rstdaczpdz  high
+		latch();
+#endif		
+		stimulus_print("[TEST.C] ... Done audio CODEC power-up bypass fast charge\n");
+	}
+	if (0)
+	{
+		CODEC_DEBUG( "  enter %s\n", __func__);	
+	//	snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
+	//	snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
+		aml_reset_path(codec, AML_PWR_UP);
+
+		latch_(codec);
+		snd_soc_write(codec, ADAC_RESET, (0<<1));
+		latch_(codec);
+		latch_(codec);
+		latch_(codec);
+		snd_soc_write(codec, ADAC_RESET, (1<<1));
+		latch_(codec);
+		latch_(codec);
+	}
+
+	//msleep(200);
+}
+
+
+static int audio_dac_set(unsigned freq)
+{
+	return 0;
+}
+
+static int post_reset(struct snd_soc_dapm_widget *w,
+	    struct snd_kcontrol *kcontrol, int event)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = w->codec;
+
+	if (SND_SOC_DAPM_POST_PMU == event)
+	{
+		aml_syno9629_reset(codec,false);
+	}
+	else if (SND_SOC_DAPM_POST_PMD == event && codec->active == 0)
+		aml_reset_path(codec, AML_PWR_DOWN);
+	return 0;
+}
+
+static int aml_switch_get_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+#if 0
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct snd_soc_dapm_widget *w;
+	//struct snd_soc_dapm_context * dapm = &codec->dapm;
+	char *lname = NULL;
+	char *rname = NULL;
+
+    switch (e->reg)
+    {
+    case ADAC_POWER_CTRL_REG1:
+        if (6 == e->shift_l)
+        {
+            lname = "LINEOUTL";
+            rname = "LINEOUTR";
+        }
+        else if (4 == e->shift_l)
+        {
+            lname = "HP_L";
+            rname = "HP_R";
+        }
+        else if (2 == e->shift_l)
+        {
+            lname = "SPEAKER";
+        }
+    break;
+    case ADAC_POWER_CTRL_REG2:
+        if (2 == e->shift_l)
+        {
+            lname = "LINEINL";
+            rname = "LINEINR";
+        }
+    break;
+    default:
+    break;
+    }
+    
+	list_for_each_entry(w, &codec->card->widgets, list) {
+        if (lname && !strcmp(lname, w->name))
+            ucontrol->value.enumerated.item[0] = w->connected;
+        if (rname && !strcmp(rname, w->name))
+            ucontrol->value.enumerated.item[0] = w->connected;
+	}
+#endif
+	return 0;
+}
+
+static int aml_switch_put_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+#if 0
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    struct snd_soc_dapm_widget *w;
+    char *lname = NULL;
+    char *rname = NULL;
+    unsigned int pwr_reg;
+
+    switch (e->reg)
+    {
+    case ADAC_POWER_CTRL_REG1:
+        if (6 == e->shift_l)
+        {
+            lname = "LINEOUTL";
+            rname = "LINEOUTR";
+        }
+        else if (4 == e->shift_l)
+        {
+            lname = "HP_L";
+            rname = "HP_R";
+        }
+        else if (2 == e->shift_l)
+        {
+            lname = "SPEAKER";
+        }
+    break;
+    case ADAC_POWER_CTRL_REG2:
+        if (2 == e->shift_l)
+        {
+            lname = "LINEINL";
+            rname = "LINEINR";
+        }
+    break;
+    default:
+    break;
+    }
+
+    pwr_reg = snd_soc_read(codec, e->reg);
+    if(ucontrol->value.enumerated.item[0] == 0){
+    snd_soc_write(codec, e->reg, (pwr_reg&(~(0x1<<(e->shift_l)|0x1<<(e->shift_r)))));
+    }
+    else{
+    snd_soc_write(codec, e->reg, (pwr_reg|(0x1<<(e->shift_l)|0x1<<(e->shift_r))));
+    }
+
+	list_for_each_entry(w, &codec->card->widgets, list) {
+        if (lname && !strcmp(lname, w->name))
+        {
+            w->connected = ucontrol->value.enumerated.item[0];
+            CODEC_DEBUG("%s:connect=%d\n",w->name,w->connected);
+        }
+        if (rname && !strcmp(rname, w->name))
+        {
+            w->connected = ucontrol->value.enumerated.item[0];
+            CODEC_DEBUG("%s:connect=%d\n",w->name,w->connected);
+        }
+	}
+#endif
+	return 0;
+}
+
+static int aml_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    int err = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+    if (err < 0)
+        return err;
+
+    aml_reset_path(codec, AML_PWR_KEEP);
+    return 0;
+}
+
+static int aml_ai_source_get_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    //struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 0)
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+    
+    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 1) 
+        ucontrol->value.enumerated.item[0] = 0;// linein
+    else
+        ucontrol->value.enumerated.item[0] = 1;//hdmi
+        
+    return 0;
+}
+
+static int aml_ai_source_put_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    
+    if (ucontrol->value.enumerated.item[0] == 0)
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+    else{
+  	 WRITE_MPEG_REG(AUDIN_SOURCE_SEL,(0  <<12)   | // [14:12]cntl_hdmirx_chsts_sel: 0=Report chan1 status; 1=Report chan2 status; ...; 
+
+                                            (0xf<<8)    | // [11:8] cntl_hdmirx_chsts_en
+
+                                            (1  <<4)    | // [5:4]  spdif_src_sel: 1=Select HDMIRX SPDIF output as AUDIN source
+
+                                            (2 << 0));    // [1:0]  i2sin_src_sel: 2=Select HDMIRX I2S output as AUDIN source
+
+    }    
+	// reset adc data path
+    snd_soc_write(codec, ADAC_RESET, 1);
+    snd_soc_write(codec, ADAC_RESET, 3);
+    
+    return 0;
+}
+
+
+
+static const DECLARE_TLV_DB_SCALE(lineout_volume, -12600, 150, 0);
+static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
+static const DECLARE_TLV_DB_SCALE(linein_volume, -9600, 150, 0);
+
+static const char *left_linein_texts[] = {
+	"Left Line In 1", "Left Line In 2", "Left Line In 3", "Left Line In 4",
+	"Left Line In 5", "Left Line In 6", "Left Line In 7", "Left Line In 8"
+	};
+
+static const char *right_linein_texts[] = {
+	"Right Line In 1", "Right Line In 2", "Right Line In 3", "Right Line In 4",
+	"Right Line In 5", "Right Line In 6", "Right Line In 7", "Right Line In 8"
+	};
+
+
+
+static const char *iis_split_texts[] = {
+	"iis_not_split", "iis_split"
+	};
+
+static const unsigned int iis_split_values[] = {
+	0,
+	1
+    };
+
+
+static const SOC_VALUE_ENUM_SINGLE_DECL(left_linein_select, ADAC_REC_CH_SEL_LSB,
+		0, 0xff, left_linein_texts, linein_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(right_linein_select, ADAC_REC_CH_SEL_MSB,
+		0, 0xff, right_linein_texts, linein_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(iis_split_select, DAC_I2S_FS_SEL,
+		3, 0xff, iis_split_texts, iis_split_values);
+
+static const char *switch_op_modes_texts[] = {
+	"OFF", "ON"
+};
+//Left/Right DAC power-down/up
+static const struct soc_enum lineout_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 0, 1,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+//left/Right headset power-down signal
+static const struct soc_enum hp_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 4, 5,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+//Left/Right PGA power-down signal
+static const struct soc_enum linein_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL1, 2,3,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+//
+static const struct soc_enum sp_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 0, 1,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+
+static const char *audio_in_source_texts[] = {
+	"LINEIN", "HDMI"
+};
+static const struct soc_enum audio_in_source_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
+			ARRAY_SIZE(audio_in_source_texts),
+			audio_in_source_texts);
+
+
+static const struct snd_kcontrol_new amlsyno9629_snd_controls[] = {
+	SOC_DOUBLE_R_EXT_TLV("LINEOUT Playback Volume", DAC_PLYBACK_MVOL_LSB_CTRL, DAC_PLYBACK_MVOL_MSB_CTRL,
+	       0, 84, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, lineout_volume),
+	      
+	 SOC_DOUBLE_R_EXT_TLV("HeadSet Playback Volume", DAC_HS_VOL_LSB_CTRL, DAC_HS_VOL_MSB_CTRL,
+	       0, 46, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, hs_volume),
+
+    SOC_DOUBLE_R_EXT_TLV("LINEIN Capture Volume", ADC_REC_MVOL_LSB_CTRL, ADC_REC_MVOL_MSB_CTRL,
+	       0, 84, 1, snd_soc_get_volsw_2r, aml_put_volsw_2r, linein_volume),
+
+	SOC_VALUE_ENUM("Left LINEIN Select",left_linein_select),
+	SOC_VALUE_ENUM("Right LINEIN Select",right_linein_select),
+	SOC_VALUE_ENUM("IIS Split Select", iis_split_select),
+
+    SOC_ENUM_EXT("LOUT Playback Switch", lineout_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+    SOC_ENUM_EXT("HP Playback Switch", hp_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+	SOC_ENUM_EXT("LIN Capture Switch", linein_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+	SOC_ENUM_EXT("SP Playback Switch", sp_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+
+    SOC_ENUM_EXT("Audio In Source", audio_in_source_enum,
+        aml_ai_source_get_enum,aml_ai_source_put_enum),
+
+};
+#if 0
+static const struct snd_kcontrol_new lineoutl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 0, 1, 1);
+static const struct snd_kcontrol_new lineoutr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 1, 1, 1);
+static const struct snd_kcontrol_new hsl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 6, 1, 1);
+static const struct snd_kcontrol_new hsr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 7, 1, 1);
+static const struct snd_kcontrol_new spk_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 2, 1, 1);
+
+static const struct snd_kcontrol_new lineinl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 4, 1, 1);
+static const struct snd_kcontrol_new lineinr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 5, 1, 1);
+
+static const struct snd_soc_dapm_widget aml_syno9629_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+	SND_SOC_DAPM_OUTPUT("HP_L"),
+	SND_SOC_DAPM_OUTPUT("HP_R"),
+	SND_SOC_DAPM_OUTPUT("SPEAKER"),
+
+	SND_SOC_DAPM_INPUT("LINEINL"),
+	SND_SOC_DAPM_INPUT("LINEINR"),
+	
+	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
+	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
+	SND_SOC_DAPM_ADC("ADCL", "Left ADC Capture", ADAC_POWER_CTRL_REG2, 0, 0),
+	SND_SOC_DAPM_ADC("ADCR", "Right ADC Capture", ADAC_POWER_CTRL_REG2, 1, 0),
+
+	SND_SOC_DAPM_SWITCH("LINEOUTL Switch", ADAC_POWER_CTRL_REG1, 6, 0,
+			    &lineoutl_switch_controls),
+	SND_SOC_DAPM_SWITCH("LINEOUTR Switch", ADAC_POWER_CTRL_REG1, 7, 0,
+			    &lineoutr_switch_controls),
+	SND_SOC_DAPM_SWITCH("HP_L Switch", ADAC_POWER_CTRL_REG1, 4, 0,
+			    &hsl_switch_controls),
+	SND_SOC_DAPM_SWITCH("HP_R Switch", ADAC_POWER_CTRL_REG1, 5, 0,
+			    &hsr_switch_controls),
+	SND_SOC_DAPM_SWITCH("SPEAKER Switch", ADAC_POWER_CTRL_REG1, 2, 0,
+			    &spk_switch_controls),
+
+	SND_SOC_DAPM_SWITCH("LINEINL Switch", ADAC_POWER_CTRL_REG2, 2, 0,
+			    &lineinl_switch_controls),
+	SND_SOC_DAPM_SWITCH("LINEINR Switch", ADAC_POWER_CTRL_REG2, 3, 0,
+			    &lineinr_switch_controls),
+
+       SND_SOC_DAPM_POST("RESET", post_reset),
+	
+	//SND_SOC_DAPM_PGA("HSL", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
+	//SND_SOC_DAPM_PGA("HSR", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
+	
+	//SND_SOC_DAPM_PGA("PDZ", ADAC_POWER_CTRL_REG2, 7, 0, NULL, 0),
+	SND_SOC_DAPM_MICBIAS("MICBIAS", ADAC_POWER_CTRL_REG2, 5, 0)
+};
+
+/* Target, Path, Source */
+
+static const struct snd_soc_dapm_route aml_syno9629_audio_map[] = {
+	{"LINEOUTL", NULL, "LINEOUTL Switch"},
+	{"LINEOUTL Switch", NULL, "DACL"},
+	{"LINEOUTR", NULL, "LINEOUTR Switch"},
+	{"LINEOUTR Switch", NULL, "DACR"},
+	
+	{"HP_L", NULL, "HP_L Switch"},
+	{"HP_L Switch", NULL, "DACL"},
+	{"HP_R", NULL, "HP_R Switch"},
+	{"HP_R Switch", NULL, "DACR"},
+
+	{"SPEAKER", NULL, "SPEAKER Switch"},
+	{"SPEAKER Switch", NULL, "DACL"},
+	{"SPEAKER Switch", NULL, "DACR"},
+
+       {"ADCL", NULL, "LINEINL Switch"},
+       {"LINEINL Switch", NULL, "LINEINL"},
+	{"ADCR", NULL, "LINEINR Switch"},
+	{"LINEINR Switch", NULL, "LINEINR"},
+};
+#endif
+static int aml_syno9629_write(struct snd_soc_codec *codec, unsigned int reg,
+							unsigned int value)
+{
+       u16 *reg_cache = codec->reg_cache;
+	CODEC_DEBUG("***Entered %s:%s:\nWriting reg is %#x; value=%#x\n",__FILE__,__func__, reg, value);
+	if (reg >= codec->reg_size/sizeof(u16))
+		return -EINVAL;
+	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
+	reg_cache[reg] = value;
+	latch();
+
+      CODEC_DEBUG("Read back reg is %#x value=%#x\n", reg, READ_APB_REG(APB_BASE+(reg<<2)));
+
+	return 0;
+}
+
+static unsigned int aml_syno9629_read(struct snd_soc_codec *codec,
+							unsigned int reg)
+{
+	//u16 *reg_cache = codec->reg_cache;
+	if (reg >= codec->reg_size/sizeof(u16))
+		return -EINVAL;
+	
+	return READ_APB_REG(APB_BASE+(reg<<2));
+	//return reg_cache[reg];
+}
+
+static int aml_syno9629_codec_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned int i2sfs;
+	unsigned long rate = params_rate(params);
+	int rate_idx = 0;
+
+	for (rate_idx = 0; rate_idx < ARRAY_SIZE(aml_rate_table); rate_idx++){
+		if (aml_rate_table[rate_idx] == rate)
+			break;
+	}	
+	if (ARRAY_SIZE(aml_rate_table) == rate_idx){
+		printk(" sample rate not supported by codec \n");
+		rate_idx = 0x8; //48k
+	}	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_write(codec, DAC_I2S_FS_SEL, rate_idx);
+	else
+		snd_soc_write(codec, ADC_I2S_FS_SEL, rate_idx);
+//	aml_reset_path(codec, AML_PWR_KEEP);
+	return 0;
+}
+
+
+static int aml_syno9629_codec_pcm_prepare(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	//struct snd_soc_codec *codec = dai->codec;
+	/* set active */
+	
+	// TODO
+
+	return 0;
+}
+
+static void aml_syno9629_codec_shutdown(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = dai->codec;
+	/* deactivate */
+	if (!codec->active) {
+		udelay(50);
+		
+		// TODO
+	}
+}
+
+static int aml_syno9629_codec_mute(struct snd_soc_dai *dai, int mute)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = dai->codec;
+	u16 reg;
+	// TODO
+
+	reg = snd_soc_read(codec, ADAC_MUTE_CTRL4);
+	if(mute){
+		reg |= 3<<2;
+	}
+	else{
+		reg &= ~(3<<2);
+	}
+	CODEC_DEBUG("aml_syno9629_codec_mute mute=%d\n",mute);
+	snd_soc_write(codec, ADAC_MUTE_CTRL4, reg);
+	return 0;
+}
+
+static int aml_syno9629_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	//struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned long data = 0;
+	
+	switch (freq) {
+	case 32000:
+		data = 6;
+		break;
+	case 44100:
+		data = 7;
+		break;
+	case 48000:
+		data = 8;
+		break;
+	case 96000:
+		data = 10;
+		break;
+	default:
+		data = 6;
+		break;
+	}
+	//snd_soc_write(codec,ADAC_CLOCK, 0);
+	//snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, data);
+	return 0;
+}
+
+
+static int aml_syno9629_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	//struct snd_soc_codec *codec = codec_dai->codec;
+	u16 iface = 0;
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set iface */
+	
+	// TODO
+	
+	return 0;
+}
+
+#define AML_RATES SNDRV_PCM_RATE_8000_96000
+
+#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+
+static struct snd_soc_dai_ops aml_syno9629_codec_dai_ops = {
+	.prepare	= aml_syno9629_codec_pcm_prepare,
+	.hw_params	= aml_syno9629_codec_hw_params,
+	.shutdown	= aml_syno9629_codec_shutdown,
+	.digital_mute	= aml_syno9629_codec_mute,
+	.set_sysclk	= aml_syno9629_codec_set_dai_sysclk,
+	.set_fmt	= aml_syno9629_codec_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver aml_syno9629_codec_dai = {
+	.name = "syno9629-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.ops = &aml_syno9629_codec_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL_GPL(aml_syno9629_codec_dai);
+
+static int aml_syno9629_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		break;
+	case SND_SOC_BIAS_OFF:
+	    break;
+	default:
+	    break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static int aml_syno9629_soc_probe(struct snd_soc_codec *codec){
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	CODEC_DEBUG( "enter %s\n", __func__);	
+	aml_syno9629_reset(codec, true);
+	aml_syno9629_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	
+	snd_soc_add_controls(codec, amlsyno9629_snd_controls,
+				ARRAY_SIZE(amlsyno9629_snd_controls));
+#if 0	
+	snd_soc_dapm_new_controls(dapm, aml_syno9629_dapm_widgets,
+				  ARRAY_SIZE(aml_syno9629_dapm_widgets));
+
+	snd_soc_dapm_add_routes(dapm, aml_syno9629_audio_map, ARRAY_SIZE(aml_syno9629_audio_map));
+#endif	
+      aml_syno9629_codec = codec;                
+    return 0;
+}
+static int aml_syno9629_soc_remove(struct snd_soc_codec *codec){
+	return 0;
+}
+static int aml_syno9629_soc_suspend(struct snd_soc_codec *codec,	pm_message_t state){
+	CODEC_DEBUG( "enter %s\n", __func__);
+	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)&~(1 << 2));
+	aml_reset_path(codec, AML_PWR_DOWN);	
+	return 0;
+}
+
+static int aml_syno9629_soc_resume(struct snd_soc_codec *codec){
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)|(1 << 2));
+	aml_syno9629_reset(codec, true);	
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_syno9629 = {
+	.probe = 	aml_syno9629_soc_probe,
+	.remove = 	aml_syno9629_soc_remove,
+	.suspend =	aml_syno9629_soc_suspend,
+	.resume = 	aml_syno9629_soc_resume,
+	.read = aml_syno9629_read,
+	.write = aml_syno9629_write,
+	.set_bias_level = aml_syno9629_set_bias_level,
+	.reg_cache_size = ARRAY_SIZE(aml_syno9629_reg),
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 1,
+	.reg_cache_default = aml_syno9629_reg,
+	.dapm_widgets = 0,//aml_syno9629_dapm_widgets,
+	.num_dapm_widgets = 0,//ARRAY_SIZE(aml_syno9629_dapm_widgets),
+	.dapm_routes =  0,//aml_syno9629_audio_map,
+	.num_dapm_routes = 0,//ARRAY_SIZE(aml_syno9629_audio_map),
+};
+
+static int aml_syno9629_codec_platform_probe(struct platform_device *pdev)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+	return snd_soc_register_codec(&pdev->dev, 
+		&soc_codec_dev_syno9629, &aml_syno9629_codec_dai, 1);
+}
+
+static int __exit aml_syno9629_codec_platform_remove(struct platform_device *pdev)
+{	
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver aml_syno9629_codec_platform_driver = {
+	.driver = {
+		.name = "syno9629",
+		.owner = THIS_MODULE,
+		},
+	.probe = aml_syno9629_codec_platform_probe,
+	.remove = __exit_p(aml_syno9629_codec_platform_remove),
+};
+
+static int __init aml_syno9629_codec_modinit(void)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	return platform_driver_register(&aml_syno9629_codec_platform_driver);
+}
+
+static void __exit aml_syno9629_codec_exit(void)
+{
+		platform_driver_unregister(&aml_syno9629_codec_platform_driver);
+}
+
+module_init(aml_syno9629_codec_modinit);
+module_exit(aml_syno9629_codec_exit);
+
+
+MODULE_DESCRIPTION("ASoC AML synopsys 9629  codec driver");
+MODULE_AUTHOR("jian.xu@amlogic.com AMLogic Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_syno9629_codec.h b/sound/soc/aml/aml_syno9629_codec.h
new file mode 100644
index 000000000000..b3e9940a2487
--- /dev/null
+++ b/sound/soc/aml/aml_syno9629_codec.h
@@ -0,0 +1,215 @@
+#ifndef _AML_SYNO9629_CODEC_H
+#define _AML_SYNO9629_CODEC_H
+
+#define APB_BASE					0x4000
+
+// data path reset register. bit 0 rstdacdpz,bit 1  rstadcdpz  
+// when i2s reconfiguration, reset data path recommanded
+#define ADAC_RESET                		0x00
+//bit 0 latch
+#define ADAC_LATCH                		0x01
+/* 
+[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 
+		8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+*/
+#define ADC_MCLK_SEL                		0x02
+#define DAC_MCLK_SEL                		0x03
+//
+// [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+#define ADC_I2S_FS_SEL      				0x0c
+#define DAC_I2S_FS_SEL      				0x0d
+/*
+i2smode[2:0]:default:1h
+Data format select:
+000: Right justified
+001: I2S justified
+010: Left justified
+011: Burst 1 format
+100: Burst 2 format
+101: Mono Burst 1 format
+110: Mono Burst 2 format
+111: Reserved
+i2smsmode[3] default:0
+I2S slave/master:
+0: slave mode
+1: master mode
+*/
+#define ADAC_I2S_MODE_SEL   			0x0e
+
+/*
+acodec standby/sleep control. [0] ensleep .default:0xAEh
+*/
+#define ADAC_STAND_SLEEP_CTRL      		0x11
+/*
+Power consumption management;cfgiref[3:0] default:0
+*/
+#define ADAC_POWER_CUM_CTRL     		0x12
+/*
+[0] pdz Overall power-down signal
+[2] pdmbias1z Microphone Bias 1 power-down signal
+*/
+#define ADAC_POWER_CTRL0				0x15
+/*
+[0] pdadclz Left ADC power-down signal
+[1] pdadcrz Right ADC power-down signal
+[2]pdpgalz Left PGA power-down signal
+[3] pdpgarz Right PGA power-down signal
+*/
+#define ADAC_POWER_CTRL1				0x16
+/*
+R24 (18h) 0 pddaclz Left DAC power-down signal 0h
+R24 (18h) 1 pddacrz Right DAC power-down signal 0h
+R24 (18h) 4 pdhs1rz Right headset power-down signal 0h
+R24 (18h) 5 pdhs1lz Left headset power-down signal 0h
+R24 (18h) 6 pdldr1rz Right single-end line driver 1 power-down signal 0h
+R24 (18h) 7 pdldr1lz Left single-end line driver 1 power-down signal
+*/
+#define ADAC_POWER_CTRL3				0x18
+
+/*
+R29 (1Dh)
+[0]
+recmute[0]
+Recording left channel digital mute:
+0: un-mute
+1: mute
+0h
+R29 (1Dh)
+[1]
+recmute[1]
+Recording right channel digital mute:
+0: un-mute
+1: mute
+*/
+#define ADAC_MUTE_CTRL0       		        0x1d
+/*
+R31 (1Fh)
+[4]
+hs1mute[0]
+Headset left channel analog mute:
+0: un-mute
+1: mute
+0h
+R31 (1Fh)
+[5]
+hs1mute[1]
+Headset right channel analog mute:
+0: un-mute
+1: mute
+*/
+#define ADAC_MUTE_CTRL2			        0x1f
+/*
+R33 (21h)
+[2]
+ldr1outmute[0]
+Playback left channel analog mute:
+0: un-mute
+1: mute
+0h
+R33 (21h)
+[3]
+ldr1outmute[1]
+Playback right channel analog mute:
+0: un-mute
+1: mute
+*/
+#define ADAC_MUTE_CTRL4        		        0x21
+/*
+Recording digital master volume control:
+The least significant 8 bits control the left channel:
+00000000: 30dB
+00000001 to 0010011: 28.5dB to 1.5dB
+00010100: 0dB
+00010101 to 1010011: -1.5dB to C94.5dB
+01010100: -96dB
+01010101 to 01111111: Reserved
+The most significant 8 bits control the right channel:
+00000000: 30dB
+00000001 to 0010011: 28.5dB to 1.5dB
+00010100: 0dB
+00010101 to 1010011: -1.5dB to C94.5dB
+01010100: -96dB
+01010101 to 1111111: Reserved
+*/
+#define ADC_REC_MVOL_LSB_CTRL  		0x24
+#define ADC_REC_MVOL_MSB_CTRL  		0x25
+/*
+Input PGA volume control:
+The least significant 8 bits control the left channel:
+00000000: -6 dB
+00000001: -4.5 dB
+K: K
+00000100: 0 dB
+K: K
+00010001: 19.5 dB
+00010010: 21 dB
+d00010011: Reserved
+The most significant 8 bits control the right channel:
+00000000: -6 dB
+00000001: -4.5 dB
+K: K
+00000100: 0 dB
+K: K
+00010001: 19.5 dB
+00010010: 21 dB
+d00010011: Reserved
+*/
+#define ADC_PGA_VOL_LSB_CTRL  			0x26
+#define ADC_PGA_VOL_MSB_CTRL  		0x27
+
+#define DAC_PLYBACK_MVOL_LSB_CTRL  	0x34
+#define DAC_PLYBACK_MVOL_MSB_CTRL  	0x35
+#define DAC_HS_VOL_LSB_CTRL  			0x38
+#define DAC_HS_VOL_MSB_CTRL  			0x39
+#define ADC_REC_INPUT_CH_LSB_SEL			0x47
+#define ADC_REC_INPUT_CH_MSB_SEL			0x48
+#define DAC_PLYBACK_MIXER_LSB_CTRL		0x59
+#define DAC_PLYBACK_MIXER_MSB_CTRL		0x5a
+
+#define ADAC_REC_CH_SEL_LSB			0x47
+#define ADAC_REC_CH_SEL_MSB			0x48
+#define ADAC_DIGITAL_TEST_MODE_SEL 	0xd2
+#define ADC_REC_PATH_MIXER_SEL 		0xd3 
+#define DAC_PLYBACK_DIG_MIXER_SEL 	0xd4
+/*
+VCM ramp up settle register
+*/
+ #define ADAC_VCM_RAMP_CTRL      		0xa2
+/*
+VCM pre-charge time control definition
+*/
+#define ADAC_DIG_ASS_TEST_REG1      				0xf0
+/*
+Digital-assisted analog test reg. Bypass power up/down sequences
+*/
+#define ADAC_DIG_ASS_TEST_REG2  	     				0xf1
+#define ADAC_DIG_ASS_TEST_REG3  	     				0xf2
+
+
+/*
+Digital-assisted analog test reg. 4
+*/
+#define ADAC_DIG_ASS_TEST_REG4  					0xf3
+#define ADAC_DIG_ASS_TEST_REG5  					0xf3
+/*
+Pure analog test reg. 3
+*/
+#define ADAC_ANALOG_TEST_REG3 					0xfb
+
+#define ADAC_VCM_REG1		0x80
+#define ADAC_VCM_REG2		0x81
+
+#define ADAC_TEST_REG1	0xe0
+#define ADAC_TEST_REG2	0xe1
+#define ADAC_TEST_REG3	0xe2
+#define ADAC_TEST_REG4	0xe3
+
+#define ADAC_MAXREG	256
+
+#define NO_CLOCK_TO_CODEC   0
+#define PCMOUT_TO_DAC           1
+#define AIU_I2SOUT_TO_DAC    2
+
+
+
+#endif
-- 
2.19.0

