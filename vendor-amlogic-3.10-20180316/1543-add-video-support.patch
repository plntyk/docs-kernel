From b002047f6bf52eb903f8cf10f7e3772caba4894d Mon Sep 17 00:00:00 2001
From: "yun.cai" <yun.cai@amlogic.com>
Date: Fri, 25 Oct 2013 19:53:55 +0800
Subject: [PATCH 1543/5965] add video support

---
 arch/arm/configs/meson8_defconfig             |  20 +-
 drivers/amlogic/Kconfig                       |  34 +-
 drivers/amlogic/Makefile                      |   4 +-
 drivers/amlogic/amports/encoder.c             | 178 ++---
 drivers/amlogic/deinterlace/deinterlace.c     | 644 +++++++--------
 drivers/amlogic/deinterlace/deinterlace_hw.c  | 114 +--
 drivers/amlogic/deinterlace/deinterlace_pd.c  | 116 +--
 drivers/amlogic/ppmgr/ppmgr_3d.c              |  26 +-
 drivers/amlogic/ppmgr/ppmgr_3d_tv.c           |  26 +-
 drivers/amlogic/ppmgr/ppmgr_dev.h             |   2 +-
 drivers/amlogic/ppmgr/ppmgr_drv.c             |  22 +-
 drivers/amlogic/ppmgr/ppmgr_vpp.c             |  56 +-
 drivers/amlogic/tvin/bt656/bt656_601_in.c     |  10 +-
 drivers/amlogic/tvin/bt656/bt656_601_in.h     |   2 +-
 drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c      |   2 +-
 drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c |   2 +-
 drivers/amlogic/tvin/hdmirx/hdmirx_drv.c      |  10 +-
 drivers/amlogic/tvin/hdmirx/hdmirx_drv.h      |   2 +-
 drivers/amlogic/tvin/hdmirx/hdmirx_test.c     |   2 +-
 drivers/amlogic/tvin/isp/isp_drv.c            |   2 +-
 drivers/amlogic/tvin/isp/isp_drv.h            |   2 +-
 drivers/amlogic/tvin/isp/isp_hw.c             |   2 +-
 drivers/amlogic/tvin/isp/isp_parm.c           |   4 +-
 drivers/amlogic/tvin/isp/isp_sm.c             |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe.c            |   6 +-
 drivers/amlogic/tvin/tvafe/tvafe.h            |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe_adc.c        |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe_adc.h        |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe_cvd.c        |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe_cvd.h        |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe_general.c    |   2 +-
 drivers/amlogic/tvin/tvafe/tvafe_general.h    |   2 +-
 drivers/amlogic/tvin/tvin_format_table.h      |   2 +-
 drivers/amlogic/tvin/tvin_frontend.c          |   2 +-
 drivers/amlogic/tvin/tvin_frontend.h          |   4 +-
 drivers/amlogic/tvin/tvin_global.c            |   2 +-
 drivers/amlogic/tvin/tvin_global.h            |   2 +-
 drivers/amlogic/tvin/vdin/vdin_canvas.c       |   4 +-
 drivers/amlogic/tvin/vdin/vdin_canvas.h       |   4 +-
 drivers/amlogic/tvin/vdin/vdin_ctl.c          |   6 +-
 drivers/amlogic/tvin/vdin/vdin_ctl.h          |   2 +-
 drivers/amlogic/tvin/vdin/vdin_drv.c          |  16 +-
 drivers/amlogic/tvin/vdin/vdin_drv.h          |   6 +-
 drivers/amlogic/tvin/vdin/vdin_sm.c           |   2 +-
 drivers/amlogic/tvin/vdin/vdin_vf.c           |   2 +-
 drivers/amlogic/tvin/vdin/vdin_vf.h           |   4 +-
 drivers/amlogic/tvin/viu/viuin.c              |  12 +-
 drivers/amlogic/tvin_v4l2/vdin_v4l2.c         |   4 +-
 drivers/amlogic/video_dev/amlvideo.c          |  14 +-
 drivers/amlogic/video_dev/amlvideo2.c         |  19 +-
 drivers/amlogic/video_dev/common/vfp-queue.h  |   2 +-
 drivers/amlogic/video_dev/common/vfutil.c     |  16 +-
 include/linux/amlogic/ppmgr/ppmgr.h           | 171 ++++
 include/linux/amlogic/ppmgr/ppmgr_status.h    |  22 +
 include/linux/amlogic/tvin/tvin_v4l2.h        | 740 ++++++++++++++++++
 include/media/videobuf-res.h                  |  39 +
 56 files changed, 1695 insertions(+), 706 deletions(-)
 mode change 100644 => 100755 drivers/amlogic/tvin/hdmirx/hdmirx_test.c
 create mode 100755 include/linux/amlogic/ppmgr/ppmgr.h
 create mode 100755 include/linux/amlogic/ppmgr/ppmgr_status.h
 create mode 100755 include/linux/amlogic/tvin/tvin_v4l2.h
 create mode 100755 include/media/videobuf-res.h

diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index e38681154366..e5d20111e769 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -140,9 +140,12 @@ CONFIG_NEW_AM_REMOTE=y
 # CONFIG_MESON_INPUT_KEYBOARD is not set
 CONFIG_AML_PMU_ALGORITHM_SUPPORT=y
 CONFIG_EFUSE=y
+
 CONFIG_MMC_AML=y
 # CONFIG_AMAUDIO is not set
+CONFIG_VSYNC_RDMA=y
 CONFIG_AM_VIDEO=y
+CONFIG_AM_ENCODER=y
 CONFIG_AM_TV_OUTPUT2=y
 CONFIG_FB_AM=y
 CONFIG_FB_OSD2_CURSOR=y
@@ -154,6 +157,13 @@ CONFIG_AMLOGIC_BACKLIGHT=y
 CONFIG_AML_NEXT_GEN_NAND=y
 CONFIG_AM_GE2D=y
 CONFIG_AM_LOGO=y
+CONFIG_TVIN=y
+CONFIG_TVIN_VDIN=y
+CONFIG_VIUIN=y
+CONFIG_TVIN_ISP=y
+CONFIG_POST_PROCESS_MANAGER=y
+CONFIG_POST_PROCESS_MANAGER_PPSCALER=y
+CONFIG_DEINTERLACE=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
@@ -190,9 +200,13 @@ CONFIG_SND_SOC=y
 CONFIG_SND_AML_SOC=y
 CONFIG_SND_AML_M_DUMMY_CODEC=y
 CONFIG_SND_AML_M8=y
-# CONFIG_HID is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_MMC=y
+CONFIG_USB=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_ETH=m
 CONFIG_MMC_DEBUG=y
 CONFIG_UIO=y
 CONFIG_UIO_PDRV=y
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index 1ef2e136bae5..01b8b1d9a2ca 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -19,8 +19,8 @@ source "drivers/amlogic/input/Kconfig"
 source "drivers/amlogic/gpio/Kconfig"
 source "drivers/amlogic/pinctrl/Kconfig"
 source "drivers/amlogic/power/Kconfig"
-#source "drivers/amlogic/securitykeys/Kconfig"
-#source "drivers/amlogic/keymanage/Kconfig"
+source "drivers/amlogic/securitykeys/Kconfig"
+source "drivers/amlogic/keymanage/Kconfig"
 #source "drivers/amlogic/extern_io/Kconfig"
 #source "drivers/amlogic/minilvds/Kconfig"
 source "drivers/amlogic/efuse/Kconfig"
@@ -39,45 +39,45 @@ source "drivers/amlogic/efuse/Kconfig"
 source "drivers/amlogic/usb/Kconfig"
 #source "drivers/amlogic/cardreader/Kconfig"
 source "drivers/amlogic/mmc/Kconfig"
-#source "drivers/amlogic/spi_nor/Kconfig"
+source "drivers/amlogic/spi_nor/Kconfig"
 #source "drivers/amlogic/nand/Kconfig"
 source "drivers/amlogic/amlnf/Kconfig"
 
 #
 #	Network devices
 #
-#comment "Network devices"
-#source "drivers/amlogic/ethernet/Kconfig"
-#source "drivers/amlogic/wifi/Kconfig"
-#source "drivers/amlogic/bluetooth/Kconfig"
+comment "Network devices"
+source "drivers/amlogic/ethernet/Kconfig"
+source "drivers/amlogic/wifi/Kconfig"
+source "drivers/amlogic/bluetooth/Kconfig"
 #3G module power manager
 #source "drivers/amlogic/modem/Kconfig"
 
 #
 #  Audio
 #
-#comment "Audio devices"
+comment "Audio devices"
 source "drivers/amlogic/amaudio/Kconfig"
 source "drivers/amlogic/audiodsp/Kconfig"
 
 #
 #  Video
 #
-#comment "Video devices"
+comment "Video devices"
 source "drivers/amlogic/amports/Kconfig"
 source "drivers/amlogic/canvas/Kconfig"
 source "drivers/amlogic/display/Kconfig"
 source "drivers/amlogic/hdmi/Kconfig"
-#source "drivers/amlogic/tvin/Kconfig"
+source "drivers/amlogic/tvin/Kconfig"
 #source "drivers/amlogic/cmem/Kconfig"
 #source "drivers/amlogic/jpeglogo/Kconfig"
 #source "drivers/amlogic/dvb/Kconfig"
-#source "drivers/amlogic/ppmgr/Kconfig"
-#source "drivers/amlogic/camera/Kconfig"
-#source "drivers/amlogic/video_dev/Kconfig"
-#source "drivers/amlogic/deinterlace/Kconfig"
+source "drivers/amlogic/ppmgr/Kconfig"
+source "drivers/amlogic/camera/Kconfig"
+source "drivers/amlogic/video_dev/Kconfig"
+source "drivers/amlogic/deinterlace/Kconfig"
 #source "drivers/amlogic/freescale/Kconfig"
-#source "drivers/amlogic/mipi/Kconfig"
+source "drivers/amlogic/mipi/Kconfig"
 #source "drivers/amlogic/d2d3/Kconfig"
 #source "drivers/amlogic/amvecm/Kconfig"
 
@@ -87,7 +87,7 @@ source "drivers/amlogic/hdmi/Kconfig"
 #
 #	GPU
 #
-#comment "GPU (ARM Mali)"
+comment "GPU (ARM Mali)"
 #isource "drivers/amlogic/ump/Kconfig"
 #isource "drivers/amlogic/mali/Kconfig"
 #comment "GPU (ARM Mali (external))"
@@ -98,6 +98,6 @@ source "drivers/amlogic/ion_dev/Kconfig"
 #
 # crypto
 #
-#source "drivers/amlogic/crypto/Kconfig"
+source "drivers/amlogic/crypto/Kconfig"
 
 endmenu
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 7c6610fe579f..08bc19491ecf 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -70,8 +70,8 @@ obj-y += power/
 
 #obj-$(CONFIG_AM_GPIO) +=gpio/
 
-#obj-y += tvin_v4l2/
-#obj-y += tvin/
+obj-y += tvin_v4l2/
+obj-y += tvin/
 
 obj-$(CONFIG_EFUSE)+=efuse/
 
diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index 7a4c8f4d529c..21a7538f6a2e 100755
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -46,7 +46,7 @@
 #define LOG_LEVEL_INFO      1
 #define LOG_LEVEL_DESC  "0:ERROR, 1:INFO"
 #endif
-#include <linux/amlog.h>
+#include <linux/amlogic/amlog.h>
 MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
 
 #include "encoder.h"
@@ -68,15 +68,15 @@ static struct device *amvenc_avc_dev;
 
 /*output buffer define*/
 static unsigned BitstreamStart;
-static unsigned BitstreamEnd;  
-//static unsigned BitstreamIntAddr;   
+static unsigned BitstreamEnd;
+//static unsigned BitstreamIntAddr;
 /*input buffer define*/
-static unsigned dct_buff_start_addr;  
+static unsigned dct_buff_start_addr;
 static unsigned dct_buff_end_addr;
 
 /*deblock buffer define*/
-//static unsigned dblk_buf_addr;    
-static unsigned dblk_buf_canvas;	
+//static unsigned dblk_buf_addr;
+static unsigned dblk_buf_canvas;
 
 /*reference buffer define*/
 //static unsigned ref_buf_addr ; //192
@@ -87,7 +87,7 @@ static unsigned assit_buffer_offset;
 //static struct dec_sysinfo avc_amstream_dec_info;
 
 static u32 stat;
-//static u32 cur_stage;          
+//static u32 cur_stage;
 static u32 frame_start;//0: processing 1:restart
 static u32 quant = 28;
 static u32 encoder_width = 1280;
@@ -249,7 +249,7 @@ typedef struct
 {
     u32 buf_start;
     u32 buf_size;
-    u8 cur_buf_lev; 
+    u8 cur_buf_lev;
     BuffInfo_t* bufspec;
 } EncBuffer_t;
 
@@ -278,11 +278,11 @@ int avc_dec_status(struct vdec_status *vstatus)
 
 /*output stream buffer setting*/
 static void avc_init_output_buffer(void)
-{	
+{
 	WRITE_HREG(VLC_VB_MEM_CTL ,((1<<31)|(0x3f<<24)|(0x20<<16)|(2<<0)) );
 	WRITE_HREG(VLC_VB_START_PTR, BitstreamStart);
 	WRITE_HREG(VLC_VB_WR_PTR, BitstreamStart);
-	WRITE_HREG(VLC_VB_SW_RD_PTR, BitstreamStart);	
+	WRITE_HREG(VLC_VB_SW_RD_PTR, BitstreamStart);
 	WRITE_HREG(VLC_VB_END_PTR, BitstreamEnd);
 	WRITE_HREG(VLC_VB_CONTROL, 1);
 	WRITE_HREG(VLC_VB_CONTROL, ((0<<14)|(7<<3)|(1<<1)|(0<<0)));
@@ -290,17 +290,17 @@ static void avc_init_output_buffer(void)
 
 /*input dct buffer setting*/
 static void avc_init_input_buffer(void)
-{	
+{
 	WRITE_HREG(QDCT_MB_START_PTR ,dct_buff_start_addr );
 	WRITE_HREG(QDCT_MB_END_PTR, dct_buff_end_addr);
 	WRITE_HREG(QDCT_MB_WR_PTR, dct_buff_start_addr);
-	WRITE_HREG(QDCT_MB_RD_PTR, dct_buff_start_addr);	
+	WRITE_HREG(QDCT_MB_RD_PTR, dct_buff_start_addr);
 	WRITE_HREG(QDCT_MB_BUFF, 0);
 }
 
 /*input reference buffer setting*/
 static void avc_init_reference_buffer(int canvas)
-{	
+{
 	WRITE_HREG(HCODEC_ANC0_CANVAS_ADDR ,canvas);
 	WRITE_HREG(VLC_HCMD_CONFIG ,0);
 }
@@ -321,22 +321,22 @@ static void avc_init_dblk_buffer(int canvas)
 /*same as INIT_ENCODER*/
 static void avc_init_encoder(void)
 {
-	WRITE_HREG(VLC_TOTAL_BYTES, 0); 
-	WRITE_HREG(VLC_CONFIG, 0x07);   
-	WRITE_HREG(VLC_INT_CONTROL, 0);   
+	WRITE_HREG(VLC_TOTAL_BYTES, 0);
+	WRITE_HREG(VLC_CONFIG, 0x07);
+	WRITE_HREG(VLC_INT_CONTROL, 0);
 	//WRITE_HREG(ENCODER_STATUS,ENCODER_IDLE);
-	WRITE_HREG(HCODEC_ASSIST_AMR1_INT0, 0x15);  
+	WRITE_HREG(HCODEC_ASSIST_AMR1_INT0, 0x15);
 	WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x8);
 	WRITE_HREG(HCODEC_ASSIST_AMR1_INT3, 0x14);
 	WRITE_HREG(IDR_PIC_ID ,idr_pic_id);
 	WRITE_HREG(FRAME_NUMBER ,frame_number);
 	WRITE_HREG(PIC_ORDER_CNT_LSB,pic_order_cnt_lsb);
-	log2_max_pic_order_cnt_lsb= 4;     
+	log2_max_pic_order_cnt_lsb= 4;
 	log2_max_frame_num = 4;
 	WRITE_HREG(LOG2_MAX_PIC_ORDER_CNT_LSB ,  log2_max_pic_order_cnt_lsb);
 	WRITE_HREG(LOG2_MAX_FRAME_NUM , log2_max_frame_num);
 	WRITE_HREG(ANC0_BUFFER_ID, anc0_buffer_id);
-	WRITE_HREG(QPPICTURE, qppicture);	
+	WRITE_HREG(QPPICTURE, qppicture);
 }
 
 /****************************************/
@@ -348,7 +348,7 @@ static void avc_canvas_init(void)
     canvas_width = ((encoder_width+15)>>4)<<4;
     canvas_height = ((encoder_height+15)>>4)<<4;
 
-	/*input dct buffer config */ 
+	/*input dct buffer config */
     dct_buff_start_addr = start_addr+gAmvencbuff.bufspec->dct.buf_start;   //(w>>4)*(h>>4)*864
     dct_buff_end_addr = dct_buff_start_addr + gAmvencbuff.bufspec->dct.buf_size -1 ;
     debug_level(0,"dct_buff_start_addr is %x \n",dct_buff_start_addr);
@@ -361,7 +361,7 @@ static void avc_canvas_init(void)
         start_addr + gAmvencbuff.bufspec->dec0_uv.buf_start,
         canvas_width , canvas_height/2,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-    /*here the third plane use the same address as the second plane*/                      
+    /*here the third plane use the same address as the second plane*/
     canvas_config(2 + ENC_CANVAS_OFFSET,
         start_addr + gAmvencbuff.bufspec->dec0_uv.buf_start,
         canvas_width , canvas_height/2,
@@ -375,7 +375,7 @@ static void avc_canvas_init(void)
         start_addr + gAmvencbuff.bufspec->dec1_uv.buf_start,
         canvas_width , canvas_height/2,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-    /*here the third plane use the same address as the second plane*/                      
+    /*here the third plane use the same address as the second plane*/
     canvas_config(5 + ENC_CANVAS_OFFSET,
         start_addr + gAmvencbuff.bufspec->dec1_uv.buf_start,
         canvas_width , canvas_height/2,
@@ -386,7 +386,7 @@ static void avc_canvas_init(void)
 	/*output stream buffer config*/
     BitstreamStart  = start_addr + gAmvencbuff.bufspec->bitstream.buf_start;
     BitstreamEnd  =  BitstreamStart + gAmvencbuff.bufspec->bitstream.buf_size -1;
-    debug_level(0,"BitstreamStart is %x \n",BitstreamStart);    
+    debug_level(0,"BitstreamStart is %x \n",BitstreamStart);
 
     dblk_buf_canvas = ((ENC_CANVAS_OFFSET+2) <<16)|((ENC_CANVAS_OFFSET + 1) <<8)|(ENC_CANVAS_OFFSET);
     ref_buf_canvas = ((ENC_CANVAS_OFFSET +5) <<16)|((ENC_CANVAS_OFFSET + 4) <<8)|(ENC_CANVAS_OFFSET +3);
@@ -435,10 +435,10 @@ static void mfdin_basic (unsigned input, unsigned char iformat, unsigned char of
     interp_en = ((ifmt422 && (oformat==2)) || (ifmt420 && (oformat!=0))) ? 1 : 0;
     y_size = (oformat!=0) ? 1 : 0;
     r2y_mode = (r2y_en == 1)?1:0; // Fixed to 1 (TODO)
-    canv_idx0_bppx = (iformat==1) ? 3 : (iformat==0) ? 2 : 1; 
-    canv_idx1_bppx = (iformat==4) ? 0 : 1; 
-    canv_idx0_bppy = 1; 
-    canv_idx1_bppy = (iformat==5) ? 1 : 0; 
+    canv_idx0_bppx = (iformat==1) ? 3 : (iformat==0) ? 2 : 1;
+    canv_idx1_bppx = (iformat==4) ? 0 : 1;
+    canv_idx0_bppy = 1;
+    canv_idx1_bppy = (iformat==5) ? 1 : 0;
     if((iformat==8) || (iformat==9) || (iformat==12)){
         linear_bytes4p = 3;
     }else if(iformat == 10){
@@ -512,15 +512,15 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
         }else if(fmt == FMT_YUV444_SINGLE){
             iformat = 1;
             canvas_config(ENC_CANVAS_OFFSET+6,
-                input, 
-                picsize_x*3, picsize_y, 
+                input,
+                picsize_x*3, picsize_y,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
            input = ENC_CANVAS_OFFSET+6;
         }else if((fmt == FMT_NV21)||(fmt == FMT_NV12)){
             iformat = (fmt == FMT_NV21)?2:3;
             canvas_config(ENC_CANVAS_OFFSET+6,
-                input, 
-                picsize_x, picsize_y, 
+                input,
+                picsize_x, picsize_y,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             canvas_config(ENC_CANVAS_OFFSET+7,
                 input + picsize_x*picsize_y,
@@ -530,8 +530,8 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
         }else if(fmt == FMT_YUV420){
             iformat = 4;
             canvas_config(ENC_CANVAS_OFFSET+6,
-                input, 
-                picsize_x, picsize_y, 
+                input,
+                picsize_x, picsize_y,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             canvas_config(ENC_CANVAS_OFFSET+7,
                 input + picsize_x*picsize_y,
@@ -545,8 +545,8 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
         }else if(fmt == FMT_YUV444_PLANE){
             iformat = 5;
             canvas_config(ENC_CANVAS_OFFSET+6,
-                input, 
-                picsize_x, picsize_y, 
+                input,
+                picsize_x, picsize_y,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             canvas_config(ENC_CANVAS_OFFSET+7,
                 input + picsize_x*picsize_y,
@@ -619,10 +619,10 @@ static irqreturn_t enc_isr(int irq, void *dev_id)
 	||(encoder_status == ENCODER_NON_IDR_DONE))&&(!process_irq)){
 		temp_canvas = dblk_buf_canvas;
 		dblk_buf_canvas = ref_buf_canvas;
-		ref_buf_canvas = temp_canvas;   //current dblk buffer as next reference buffer		
+		ref_buf_canvas = temp_canvas;   //current dblk buffer as next reference buffer
 		frame_start = 1;
 		frame_number ++;
-		pic_order_cnt_lsb += 2;		
+		pic_order_cnt_lsb += 2;
 		process_irq = 1;
 		debug_level(0,"encoder is done %d\n",encoder_status);
 	}
@@ -639,14 +639,14 @@ static void avc_prot_init(void)
 	int i_pic_qp, p_pic_qp;
 
 	int i_pic_qp_c, p_pic_qp_c;
-	pic_width  = encoder_width; 
-	pic_height = encoder_height; 
-	pic_mb_nr  = 0; 
-	pic_mbx    = 0; 
-	pic_mby    = 0; 
-	i_pic_qp   = quant; 
-	p_pic_qp   = quant; 
-	WRITE_HREG(VLC_PIC_SIZE, pic_width | (pic_height<<16));	
+	pic_width  = encoder_width;
+	pic_height = encoder_height;
+	pic_mb_nr  = 0;
+	pic_mbx    = 0;
+	pic_mby    = 0;
+	i_pic_qp   = quant;
+	p_pic_qp   = quant;
+	WRITE_HREG(VLC_PIC_SIZE, pic_width | (pic_height<<16));
 	WRITE_HREG(VLC_PIC_POSITION, (pic_mb_nr<<16) | (pic_mby << 8) |  (pic_mbx <<0));	//start mb
 
     switch (i_pic_qp) {    // synopsys parallel_case full_case
@@ -759,18 +759,18 @@ static void avc_prot_init(void)
     default : p_pic_qp_c = 39; break; // should only be 51 or more (when index_offset)
     }
     WRITE_HREG(QDCT_Q_QUANT_I,
-                (i_pic_qp_c<<22) | 
-                (i_pic_qp<<16) | 
-                ((i_pic_qp_c%6)<<12)|((i_pic_qp_c/6)<<8)|((i_pic_qp%6)<<4)|((i_pic_qp/6)<<0));	
+                (i_pic_qp_c<<22) |
+                (i_pic_qp<<16) |
+                ((i_pic_qp_c%6)<<12)|((i_pic_qp_c/6)<<8)|((i_pic_qp%6)<<4)|((i_pic_qp/6)<<0));
 
-   WRITE_HREG(QDCT_Q_QUANT_P,                
-                (p_pic_qp_c<<22) | 
-                (p_pic_qp<<16) | 
-                ((p_pic_qp_c%6)<<12)|((p_pic_qp_c/6)<<8)|((p_pic_qp%6)<<4)|((p_pic_qp/6)<<0));	
+   WRITE_HREG(QDCT_Q_QUANT_P,
+                (p_pic_qp_c<<22) |
+                (p_pic_qp<<16) |
+                ((p_pic_qp_c%6)<<12)|((p_pic_qp_c/6)<<8)|((p_pic_qp%6)<<4)|((p_pic_qp/6)<<0));
 
    //avc_init_input_buffer();
 
-   WRITE_HREG(IGNORE_CONFIG , 
+   WRITE_HREG(IGNORE_CONFIG ,
                 (1<<31) | // ignore_lac_coeff_en
                 (1<<26) | // ignore_lac_coeff_else (<1)
                 (1<<21) | // ignore_lac_coeff_2 (<1)
@@ -829,13 +829,13 @@ static void avc_prot_init(void)
 
     WRITE_HREG(IE_RESULT_BUFFER, 0);
 
-    WRITE_HREG(SAD_CONTROL,  
+    WRITE_HREG(SAD_CONTROL,
               (1<<3) | // ie_result_buff_enable
               (0<<2) | // ie_result_buff_soft_reset
               (1<<1) | // sad_enable
               (0<<0));   // sad soft reset
 
-    WRITE_HREG(IE_CONTROL, 
+    WRITE_HREG(IE_CONTROL,
               (0<<1) | // ie_enable
               (1<<0));   // ie soft reset
 
@@ -849,17 +849,17 @@ static void avc_prot_init(void)
               (0<<12) | // me_sad_enough_1
               (0<<0));   // me_sad_enough_0
 
-    WRITE_HREG(ME_SAD_ENOUGH_23, 
+    WRITE_HREG(ME_SAD_ENOUGH_23,
               (0x20<<0) | // me_sad_enough_2
               (0<<12) | // me_sad_enough_3
               (0<<0));   // me_sad_enough_2
 
-    WRITE_HREG(ME_STEP0_CLOSE_MV, 
+    WRITE_HREG(ME_STEP0_CLOSE_MV,
               (0x100 << 10) | // me_step0_big_sad -- two MV sad diff bigger will use use 1
               (2<<5) | // me_step0_close_mv_y
               (2<<0));   // me_step0_close_mv_x
 
-    WRITE_HREG(ME_SKIP_LINE, 
+    WRITE_HREG(ME_SKIP_LINE,
               ( 4 << 24) |  // step_3_skip_line
               ( 4 << 18) |  // step_2_skip_line
               ( 2 << 12) |  // step_1_skip_line
@@ -867,13 +867,13 @@ static void avc_prot_init(void)
               //(8 <<0); // read 8*2 less line to save bandwidth
               (0 <<0)); // read 8*2 less line to save bandwidth
 
-    WRITE_HREG(ME_F_SKIP_SAD, 
+    WRITE_HREG(ME_F_SKIP_SAD,
               ( 0x40 << 24) |  // force_skip_sad_3
               ( 0x40 << 16) |  // force_skip_sad_2
               ( 0x30 << 8)  |  // force_skip_sad_1
               ( 0x10 << 0));    // force_skip_sad_0
 
-    WRITE_HREG(ME_F_SKIP_WEIGHT, 
+    WRITE_HREG(ME_F_SKIP_WEIGHT,
               ( 0x18 << 24) |  // force_skip_weight_3
               ( 0x18 << 16) |  // force_skip_weight_2
               ( 0x18 << 8)  |  // force_skip_weight_1
@@ -886,14 +886,14 @@ static void avc_prot_init(void)
     //debug_level(0,"current endian is %d \n" , avc_endian);
     data32 = READ_HREG(VLC_CONFIG);
     data32 = data32 | (1<<0); // set pop_coeff_even_all_zero
-    WRITE_HREG(VLC_CONFIG , data32);	
-    
+    WRITE_HREG(VLC_CONFIG , data32);
+
         /* clear mailbox interrupt */
     WRITE_HREG(HCODEC_ASSIST_MBOX2_CLR_REG, 1);
 
     /* enable mailbox interrupt */
     WRITE_HREG(HCODEC_ASSIST_MBOX2_MASK, 1);
-    
+
 }
 
 void amvenc_reset(void)
@@ -955,7 +955,7 @@ s32 amvenc_loadmc(const u32 *p)
 {
     ulong timeout;
     s32 ret = 0 ;
-    
+
     mc_addr_map = assit_buffer_offset;
     mc_addr = ioremap_wc(mc_addr_map,MC_SIZE);
     memcpy(mc_addr, p, MC_SIZE);
@@ -986,7 +986,7 @@ s32 amvenc_loadmc(const u32 *p)
         }
     }
     iounmap(mc_addr);
-    mc_addr=NULL;	
+    mc_addr=NULL;
 
     return ret;
 }
@@ -1011,7 +1011,7 @@ static s32 avc_poweron(void)
 	udelay(10);
 	// Powerup HCODEC
 	data32 = READ_AOREG(AO_RTI_GEN_PWR_SLEEP0); // [1:0] HCODEC
-	data32 = data32 & (~0x3); 
+	data32 = data32 & (~0x3);
 	WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, data32);
 	udelay(10);
 #endif
@@ -1019,7 +1019,7 @@ static s32 avc_poweron(void)
 	hvdec_clock_enable();
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	// Remove HCODEC ISO
-	data32 = READ_AOREG(AO_RTI_GEN_PWR_ISO0); 
+	data32 = READ_AOREG(AO_RTI_GEN_PWR_ISO0);
 	data32 = data32 & (~(0x30));
 	WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, data32);
 	udelay(10);
@@ -1055,7 +1055,7 @@ static s32 avc_poweroff(void)
 
 static s32 avc_init(void)
 {
-    int r;   
+    int r;
     avc_poweron();
     avc_canvas_init();
     WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
@@ -1063,17 +1063,17 @@ static s32 avc_init(void)
     if (amvenc_loadmc(encoder_mc) < 0) {
         //amvdec_disable();
         return -EBUSY;
-    }	
+    }
     debug_level(1,"succeed to load microcode\n");
     //avc_canvas_init();
     frame_start = 0;
-    idr_pic_id = 0 ;	
+    idr_pic_id = 0 ;
     frame_number = 0 ;
     process_irq = 0;
     pic_order_cnt_lsb = 0 ;
     encoder_status = ENCODER_IDLE ;
     amvenc_reset();
-    avc_init_encoder(); 
+    avc_init_encoder();
     avc_init_input_buffer();  //dct buffer setting
     avc_init_output_buffer();  //output stream buffer
     avc_prot_init();
@@ -1093,7 +1093,7 @@ static s32 avc_init(void)
 void amvenc_avc_start_cmd(int cmd, unsigned* input_info)
 {
 	if((cmd == ENCODER_IDR)||(cmd == ENCODER_SEQUENCE)){
-		pic_order_cnt_lsb = 0;	
+		pic_order_cnt_lsb = 0;
 		frame_number = 0;
 	}
 
@@ -1108,7 +1108,7 @@ void amvenc_avc_start_cmd(int cmd, unsigned* input_info)
 	if(frame_start){
 		frame_start = 0;
 		encoder_status = ENCODER_IDLE ;
-		//WRITE_HREG(HENC_SCRATCH_3,0);  //mb count 
+		//WRITE_HREG(HENC_SCRATCH_3,0);  //mb count
 		//WRITE_HREG(VLC_TOTAL_BYTES ,0); //offset in bitstream buffer
 		amvenc_reset();
 		avc_init_encoder();
@@ -1119,13 +1119,13 @@ void amvenc_avc_start_cmd(int cmd, unsigned* input_info)
 			idr_pic_id = 0;
 		}
 		avc_init_input_buffer();
-		avc_init_output_buffer();		
+		avc_init_output_buffer();
 		avc_prot_init();
-		avc_init_assit_buffer(); 
+		avc_init_assit_buffer();
 		debug_level(0,"begin to new frame\n");
 	}
-	avc_init_dblk_buffer(dblk_buf_canvas);   
-	avc_init_reference_buffer(ref_buf_canvas); 
+	avc_init_dblk_buffer(dblk_buf_canvas);
+	avc_init_reference_buffer(ref_buf_canvas);
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	if((cmd == ENCODER_IDR)||(cmd == ENCODER_NON_IDR)){
 		set_input_format((amvenc_mem_type)input_info[0], (amvenc_frame_fmt)input_info[1], input_info[2], input_info[3], input_info[4],(unsigned char)input_info[5]);
@@ -1142,7 +1142,7 @@ void amvenc_avc_start_cmd(int cmd, unsigned* input_info)
 
 void amvenc_avc_stop(void)
 {
-	//WRITE_HREG(HCODEC_MPSR, 0);	
+	//WRITE_HREG(HCODEC_MPSR, 0);
 	amvenc_stop();
 	avc_poweroff();
 	debug_level(1,"amvenc_avc_stop\n");
@@ -1204,13 +1204,13 @@ static long amvenc_avc_ioctl(struct file *file,
 		if((ref_buf_canvas & 0xff) == (ENC_CANVAS_OFFSET)){
 			 *((unsigned*)arg)  = 1;
 		}else{
-			 *((unsigned*)arg)  = 2;	
+			 *((unsigned*)arg)  = 2;
 		}
 		break;
 	case AMVENC_AVC_IOC_INPUT_UPDATE:
 		offset  = (unsigned*)arg ;
 		WRITE_HREG(QDCT_MB_WR_PTR, (dct_buff_start_addr+ *offset));
-		break;    
+		break;
 	case AMVENC_AVC_IOC_NEW_CMD:
 		amrisc_cmd = *((unsigned*)arg) ;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
@@ -1222,8 +1222,8 @@ static long amvenc_avc_ioctl(struct file *file,
 		break;
 	case AMVENC_AVC_IOC_GET_STAGE:
 		*((unsigned*)arg)  = encoder_status;
-		break; 
-	case AMVENC_AVC_IOC_GET_OUTPUT_SIZE:	
+		break;
+	case AMVENC_AVC_IOC_GET_OUTPUT_SIZE:
 		*((unsigned*)arg) = READ_HREG(VLC_TOTAL_BYTES);
 		break;
 	case AMVENC_AVC_IOC_SET_QUANT:
@@ -1240,10 +1240,10 @@ static long amvenc_avc_ioctl(struct file *file,
 		    *((unsigned*)arg) = gAmvencbuff.bufspec->max_height;
 		else
 		    encoder_height = *((unsigned*)arg) ;
-		break;	
+		break;
 	case AMVENC_AVC_IOC_CONFIG_INIT:
 		avc_init();
-		break;		
+		break;
 	case AMVENC_AVC_IOC_FLUSH_CACHE:
 		addr_info  = (unsigned*)arg ;
 		switch(addr_info[0]){
@@ -1283,7 +1283,7 @@ static long amvenc_avc_ioctl(struct file *file,
 			default:
 			buf_start = dct_buff_start_addr;
 			break;
-		}	    
+		}
 		cache_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
 		break;
 	case AMVENC_AVC_IOC_GET_BUFFINFO:
@@ -1356,13 +1356,13 @@ int  init_avc_device(void)
 {
     int  r =0;
     r =register_chrdev(0,DEVICE_NAME,&amvenc_avc_fops);
-    if(r<=0) 
+    if(r<=0)
     {
         amlog_level(LOG_LEVEL_HIGH,"register amvenc_avc device error\r\n");
         return  r  ;
     }
     avc_device_major= r ;
-    
+
     amvenc_avc_class = class_create(THIS_MODULE, DEVICE_NAME);
 
     amvenc_avc_dev = device_create(amvenc_avc_class, NULL,
@@ -1376,7 +1376,7 @@ int uninit_avc_device(void)
 
     class_destroy(amvenc_avc_class);
 
-    unregister_chrdev(avc_device_major, DEVICE_NAME);	
+    unregister_chrdev(avc_device_major, DEVICE_NAME);
     return 0;
 }
 
@@ -1461,7 +1461,7 @@ static int __init amvenc_avc_driver_init_module(void)
 static void __exit amvenc_avc_driver_remove_module(void)
 {
     amlog_level(LOG_LEVEL_INFO, "amvenc_avc module remove.\n");
-	
+
     platform_driver_unregister(&amvenc_avc_driver);
 }
 
diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 1441d03cb284..9fb58b77b95b 100755
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -42,11 +42,11 @@
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
-#include <linux/osd/osd_dev.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/canvas.h>
 #include "deinterlace.h"
 #include "deinterlace_module.h"
 
@@ -89,7 +89,7 @@
 #include <plat/fiq_bridge.h>
 //#include <linux/fiq_bridge.h>
 static DEFINE_SPINLOCK(di_lock2);
-#ifdef FIQ_IRQ_ON_MULTI_CORE 
+#ifdef FIQ_IRQ_ON_MULTI_CORE
 /* mutil-core */
 #define di_lock_irqfiq_save(irq_flag, fiq_flag) \
                 if(receiver_is_amvideo){\
@@ -97,8 +97,8 @@ static DEFINE_SPINLOCK(di_lock2);
                     local_fiq_disable(); \
                 }\
                 spin_lock_irqsave(&di_lock2, irq_flag);
-                    
-                
+
+
 #define di_unlock_irqfiq_restore(irq_flag, fiq_flag) \
                 spin_unlock_irqrestore(&di_lock2, irq_flag);\
                 if(receiver_is_amvideo){\
@@ -115,7 +115,7 @@ static DEFINE_SPINLOCK(di_lock2);
                 else{\
                     spin_lock_irqsave(&di_lock2, irq_flag);\
                 }
-                
+
 #define di_unlock_irqfiq_restore(irq_flag, fiq_flag) \
                 if(receiver_is_amvideo){\
                     raw_local_irq_restore(fiq_flag);\
@@ -133,13 +133,13 @@ static DEFINE_SPINLOCK(di_lock2);
 static DEFINE_SPINLOCK(di_lock2);
 #define di_lock_irqfiq_save(irq_flag, fiq_flag) \
                 spin_lock_irqsave(&di_lock2, irq_flag);
-                
+
 #define di_unlock_irqfiq_restore(irq_flag, fiq_flag) \
                 spin_unlock_irqrestore(&di_lock2, irq_flag);
 
 #else
 #define di_lock_irqfiq_save(irq_flag, fiq_flag)
-#define di_unlock_irqfiq_restore(irq_flag, fiq_flag) 
+#define di_unlock_irqfiq_restore(irq_flag, fiq_flag)
 #endif
 
 #endif
@@ -205,7 +205,7 @@ static int bypass_get_buf_threshold = 4;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 static int post_hold_line = 20;
 static int force_update_post_reg = 0x10;/* bit[4], 1 call process_fun every vsync; 0 call process_fun when toggle frame (early_process_fun is called)
-                                        bit[3:0] set force_update_post_reg = 1: only update post reg in vsync for one time 
+                                        bit[3:0] set force_update_post_reg = 1: only update post reg in vsync for one time
                                          set force_update_post_reg = 2: always update post reg in vsync
                                       */
 #else
@@ -239,9 +239,9 @@ int di_vscale_skip_enable = 1;
     di_receiver_event_fun() run in task or irq
 
 */
-/* 
+/*
     important:
-     to set input2pre, VFRAME_EVENT_PROVIDER_VFRAME_READY of vdin should be sent in irq 
+     to set input2pre, VFRAME_EVENT_PROVIDER_VFRAME_READY of vdin should be sent in irq
 */
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
 #undef CHECK_DI_DONE
@@ -268,15 +268,15 @@ static int input2pre_miss_policy = 0; /* 0, do not force pre_de_busy to 0, use d
                                                    1 use post_di module for blending
                                                    2 debug mode, bob with top field
                                                    3 debug mode, bot with bot field
-        bit[0]: 
+        bit[0]:
          0 "prog vdin" use two field buffers, 1 "prog vdin" use single frame buffer
-                                                   
-        bit[4]: 
+
+        bit[4]:
          0 "prog frame from decoder" use two field buffers, 1 use single frame buffer
-        
+
         bit[5]:
          when two field buffers are used for decoder (bit[4] is 0): 0, use process_count; 1, handle prog frame as two interlace frames
-                                                   
+
     */
 static int prog_proc_config = (1<<1)|1; /*
                                             for source include both progressive and interlace pictures,
@@ -284,7 +284,7 @@ static int prog_proc_config = (1<<1)|1; /*
                                          */
 
 #define is_handle_prog_frame_as_interlace(vframe)  (((prog_proc_config&0x30)==0x20)&&((vframe->type & VIDTYPE_VIU_422)==0))
-                                         
+
 static int pulldown_detect = 0x10;
 static int skip_wrong_field = 1;
 static int frame_count = 0;
@@ -314,7 +314,7 @@ static unsigned int det3d_mode = 0;
 
 int force_duration_0 = 0;
 
-#ifdef NEW_DI 
+#ifdef NEW_DI
 static unsigned int di_new_mode_mask = 0xffff;
 static unsigned int di_new_mode = 0x1;
 static int use_reg_cfg = 1;
@@ -447,7 +447,7 @@ void trigger_pre_di_process(char idx)
         /* trigger di_reg_process and di_unreg_process */
         up(&di_sema);
     }
-//#endif    
+//#endif
 #elif (defined RUN_DI_PROCESS_IN_TIMER_IRQ)
     if((idx != 'p')&&(idx != 'i')){
         /* trigger di_reg_process and di_unreg_process */
@@ -496,14 +496,14 @@ static void set_output_mode_info(void)
         else{
             interlace_output_flag = 0;
         }
-    }    
-}    
+    }
+}
 
 static int display_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
 {
     if (cmd != VOUT_EVENT_MODE_CHANGE)
         return 0;
-    
+
     set_output_mode_info();
     return 0;
 }
@@ -616,13 +616,13 @@ static int __init di_read_canvas_reverse(char *str)
         pr_info("%s: bootargs is %s.\n",__func__,str);
         if(strstr(ptr,"1")){
                 invert_top_bot |= 0x1;
-                overturn = true;                
+                overturn = true;
         }
         else{
                 invert_top_bot &= (~0x1) ;
                 overturn = false;
         }
-        
+
         return 0;
 }
 __setup("panel_reverse=",di_read_canvas_reverse);
@@ -634,7 +634,7 @@ static unsigned int di_log_rd_pos=0;
 static unsigned int di_log_buf_size=0;
 static unsigned int di_printk_flag=0;
 unsigned int di_log_flag=0;
-unsigned int buf_state_log_threshold = 16; 
+unsigned int buf_state_log_threshold = 16;
 unsigned int buf_state_log_start = 0; /*  set to 1 by condition of "post_ready count < buf_state_log_threshold",
 																					reset to 0 by set buf_state_log_threshold as 0 */
 
@@ -684,7 +684,7 @@ int di_print(const char *fmt, ...)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
             printk("%u:", (unsigned int)Rd(ISA_TIMERE));
 #endif
-        }            
+        }
         va_start(args, fmt);
         vprintk(fmt, args);
         va_end(args);
@@ -709,7 +709,7 @@ int di_print(const char *fmt, ...)
             printk("Deinterlace: Init 100us TimerB\n");
         }
         len += snprintf(buf+len, avail-len, "%u:", (unsigned int)(0x10000-Rd(ISA_TIMERB)));
-#endif        
+#endif
     }
     va_start(args, fmt);
     len += vsnprintf(buf+len, avail-len, fmt, args);
@@ -760,8 +760,8 @@ char log_tmp_buf[PAGE_SIZE];
 static void dump_log(void)
 {
     while(read_log(log_tmp_buf)>0){
-        printk("%s", log_tmp_buf);    
-    }    
+        printk("%s", log_tmp_buf);
+    }
 }
 #endif
 
@@ -1172,7 +1172,7 @@ static void queue_init(int local_buffer_num)
     list_head_array[QUEUE_RECYCLE] = &recycle_list_head;
     list_head_array[QUEUE_DISPLAY] = &display_list_head;
     list_head_array[QUEUE_TMP] = &post_ready_list_head;
-        
+
 }
 
 static bool queue_empty(queue_idx)
@@ -1201,7 +1201,7 @@ static int list_count(int queue_idx)
 }
 
 #define queue_for_each_entry(di_buf, ptm, queue_idx, list)  \
-    list_for_each_entry_safe(di_buf, ptmp, list_head_array[queue_idx], list) 
+    list_for_each_entry_safe(di_buf, ptmp, list_head_array[queue_idx], list)
 
 #else
 #define MAX_QUEUE_POOL_SIZE   256
@@ -1216,12 +1216,12 @@ static queue_t queue[QUEUE_NUM];
 
 struct di_buf_pool_s{
     di_buf_t* di_buf_ptr;
-    unsigned int size;    
+    unsigned int size;
 }di_buf_pool[VFRAME_TYPE_NUM];
 
 #define queue_for_each_entry(di_buf, ptm, queue_idx, list)  \
     for(itmp=0; ((di_buf = get_di_buf(queue_idx, &itmp))!=NULL); )
-        
+
 static void queue_init(int local_buffer_num)
 {
     int i, j;
@@ -1229,7 +1229,7 @@ static void queue_init(int local_buffer_num)
         queue_t* q = &queue[i];
         for(j=0; j<MAX_QUEUE_POOL_SIZE; j++){
             q->pool[j] = 0;
-        } 
+        }
         q->in_idx = 0;
         q->out_idx = 0;
         q->num = 0;
@@ -1241,14 +1241,14 @@ static void queue_init(int local_buffer_num)
     if(local_buffer_num > 0){
         di_buf_pool[VFRAME_TYPE_IN-1].di_buf_ptr = &di_buf_in[0];
         di_buf_pool[VFRAME_TYPE_IN-1].size = MAX_IN_BUF_NUM;
-    
+
         di_buf_pool[VFRAME_TYPE_LOCAL-1].di_buf_ptr = &di_buf_local[0];
         di_buf_pool[VFRAME_TYPE_LOCAL-1].size = local_buffer_num;
-    
+
         di_buf_pool[VFRAME_TYPE_POST-1].di_buf_ptr = &di_buf_post[0];
         di_buf_pool[VFRAME_TYPE_POST-1].size = MAX_POST_BUF_NUM;
     }
-    
+
 }
 
 static di_buf_t* get_di_buf(int queue_idx, int* start_pos)
@@ -1258,22 +1258,22 @@ static di_buf_t* get_di_buf(int queue_idx, int* start_pos)
     unsigned int pool_idx, di_buf_idx;
     di_buf_t* di_buf = NULL;
     int start_pos_init = *start_pos;
-    
+
 #ifdef DI_DEBUG
     if(di_log_flag&DI_LOG_QUEUE){
         di_print("%s:<%d:%d,%d,%d> %d\n", __func__, queue_idx, q->num, q->in_idx, q->out_idx, *start_pos);
     }
-#endif    
+#endif
     if(q->type==0){
         if((*start_pos) < q->num){
-            idx = q->out_idx + (*start_pos);    
+            idx = q->out_idx + (*start_pos);
             if(idx >= MAX_QUEUE_POOL_SIZE){
                 idx-=MAX_QUEUE_POOL_SIZE;
             }
             (*start_pos)++;
         }
         else{
-            idx = MAX_QUEUE_POOL_SIZE; 
+            idx = MAX_QUEUE_POOL_SIZE;
         }
     }
     else{
@@ -1282,7 +1282,7 @@ static di_buf_t* get_di_buf(int queue_idx, int* start_pos)
                 *start_pos = idx+1;
                 break;
             }
-        }    
+        }
     }
     if(idx<MAX_QUEUE_POOL_SIZE){
         pool_idx = ((q->pool[idx]>>8)&0xff)-1;
@@ -1290,7 +1290,7 @@ static di_buf_t* get_di_buf(int queue_idx, int* start_pos)
         if(pool_idx < VFRAME_TYPE_NUM){
             if(di_buf_idx < di_buf_pool[pool_idx].size){
                 di_buf = &(di_buf_pool[pool_idx].di_buf_ptr[di_buf_idx]);
-            }      
+            }
         }
     }
 
@@ -1306,7 +1306,7 @@ static di_buf_t* get_di_buf(int queue_idx, int* start_pos)
         recovery_flag++;
         di_buf = NULL;
     }
-    
+
 #ifdef DI_DEBUG
     if(di_log_flag&DI_LOG_QUEUE){
         if(di_buf){
@@ -1316,7 +1316,7 @@ static di_buf_t* get_di_buf(int queue_idx, int* start_pos)
             di_print("%s: %x\n", __func__, di_buf);
         }
     }
-#endif    
+#endif
     return di_buf;
 }
 
@@ -1331,17 +1331,17 @@ static di_buf_t* get_di_buf_head(int queue_idx)
     if(di_log_flag&DI_LOG_QUEUE){
         di_print("%s:<%d:%d,%d,%d>\n", __func__,queue_idx,q->num, q->in_idx, q->out_idx);
     }
-#endif    
+#endif
     if(q->num > 0){
         if(q->type==0){
-            idx = q->out_idx;    
+            idx = q->out_idx;
         }
         else{
             for(idx=0; idx<MAX_QUEUE_POOL_SIZE; idx++){
                 if(q->pool[idx]!=0){
                     break;
                 }
-            }    
+            }
         }
         if(idx<MAX_QUEUE_POOL_SIZE){
             pool_idx = ((q->pool[idx]>>8)&0xff)-1;
@@ -1349,7 +1349,7 @@ static di_buf_t* get_di_buf_head(int queue_idx)
             if(pool_idx < VFRAME_TYPE_NUM){
                 if(di_buf_idx < di_buf_pool[pool_idx].size){
                     di_buf = &(di_buf_pool[pool_idx].di_buf_ptr[di_buf_idx]);
-                }      
+                }
             }
         }
     }
@@ -1366,7 +1366,7 @@ static di_buf_t* get_di_buf_head(int queue_idx)
         recovery_flag++;
         di_buf = NULL;
     }
-    
+
 #ifdef DI_DEBUG
     if(di_log_flag&DI_LOG_QUEUE){
         if(di_buf){
@@ -1376,9 +1376,9 @@ static di_buf_t* get_di_buf_head(int queue_idx)
             di_print("%s: %x\n", __func__, di_buf);
         }
     }
-#endif    
+#endif
     return di_buf;
-        
+
 }
 
 static void queue_out(di_buf_t* di_buf)
@@ -1386,13 +1386,13 @@ static void queue_out(di_buf_t* di_buf)
     int i;
     if(di_buf == NULL){
 #ifdef DI_DEBUG
-        printk("%s:Error\n", __func__);  
+        printk("%s:Error\n", __func__);
 #endif
         if(recovery_flag==0){
             recovery_log_reason = 3;
         }
         recovery_flag++;
-        return;  
+        return;
     }
     if(di_buf->queue_index>=0 && di_buf->queue_index<QUEUE_NUM){
         queue_t* q = &(queue[di_buf->queue_index]);
@@ -1400,7 +1400,7 @@ static void queue_out(di_buf_t* di_buf)
         if(di_log_flag&DI_LOG_QUEUE){
             di_print("%s:<%d:%d,%d,%d> %x\n", __func__, di_buf->queue_index, q->num, q->in_idx, q->out_idx, di_buf);
         }
-#endif    
+#endif
         if(q->num > 0){
             if(q->type==0){
                 if(q->pool[q->out_idx] == ((di_buf->type<<8)|(di_buf->index))){
@@ -1408,7 +1408,7 @@ static void queue_out(di_buf_t* di_buf)
                     q->pool[q->out_idx] = 0;
                     q->out_idx++;
                     if(q->out_idx>=MAX_QUEUE_POOL_SIZE){
-                        q->out_idx = 0;    
+                        q->out_idx = 0;
                     }
                     di_buf->queue_index = -1;
                 }
@@ -1432,8 +1432,8 @@ static void queue_out(di_buf_t* di_buf)
                         q->pool[i]=0;
                         di_buf->queue_index = -1;
                         break;
-                    }    
-                }    
+                    }
+                }
                 if(i==MAX_QUEUE_POOL_SIZE){
 #ifdef DI_DEBUG
                     printk("%s: Error\n", __func__);
@@ -1457,20 +1457,20 @@ static void queue_out(di_buf_t* di_buf)
             recovery_log_queue_idx = 0;
             recovery_log_di_buf = di_buf;
         }
-        recovery_flag++;    
+        recovery_flag++;
     }
 #ifdef DI_DEBUG
     if(di_log_flag&DI_LOG_QUEUE){
         di_print("%s done\n",__func__);
     }
-#endif        
+#endif
 }
 
 static void queue_in(di_buf_t* di_buf, int queue_idx)
 {
     if(di_buf == NULL){
 #ifdef DI_DEBUG
-        printk("%s:Error\n", __func__);    
+        printk("%s:Error\n", __func__);
 #endif
         if(recovery_flag==0){
             recovery_log_reason = 7;
@@ -1482,7 +1482,7 @@ static void queue_in(di_buf_t* di_buf, int queue_idx)
     }
     if(di_buf->queue_index != -1){
 #ifdef DI_DEBUG
-        printk("%s:Error, queue_index(%d) is not -1\n", __func__, di_buf->queue_index);    
+        printk("%s:Error, queue_index(%d) is not -1\n", __func__, di_buf->queue_index);
 #endif
         if(recovery_flag==0){
             recovery_log_reason = 8;
@@ -1497,7 +1497,7 @@ static void queue_in(di_buf_t* di_buf, int queue_idx)
     if(di_log_flag&DI_LOG_QUEUE){
         di_print("%s:<%d:%d,%d,%d> %x\n", __func__,queue_idx, q->num, q->in_idx, q->out_idx,di_buf);
     }
-#endif    
+#endif
     if(q->type==0){
         q->pool[q->in_idx] = (di_buf->type<<8)|(di_buf->index);
         di_buf->queue_index = queue_idx;
@@ -1515,8 +1515,8 @@ static void queue_in(di_buf_t* di_buf, int queue_idx)
                 di_buf->queue_index = queue_idx;
                 q->num++;
                 break;
-            }    
-        }    
+            }
+        }
         if(i==MAX_QUEUE_POOL_SIZE){
 #ifdef DI_DEBUG
             printk("%s: Error\n", __func__);
@@ -1532,7 +1532,7 @@ static void queue_in(di_buf_t* di_buf, int queue_idx)
     if(di_log_flag&DI_LOG_QUEUE){
         di_print("%s done\n",__func__);
     }
-#endif    
+#endif
 }
 
 static int list_count(int queue_idx)
@@ -1577,14 +1577,14 @@ typedef struct{
     DI_SIM_MIF_t di_contp2rd_mif;
     DI_SIM_MIF_t di_contprd_mif;
     DI_SIM_MIF_t di_contwr_mif;
-    int field_count_for_cont;  
+    int field_count_for_cont;
                     /*
                      0 (f0,null,f0)->nr0,
                      1 (f1,nr0,f1)->nr1_cnt,
                      2 (f2,nr1_cnt,nr0)->nr2_cnt
                      3 (f3,nr2_cnt,nr1_cnt)->nr3_cnt
                      */
-#endif    
+#endif
     /* pre state */
     int in_seq;
     int recycle_seq;
@@ -1593,7 +1593,7 @@ typedef struct{
     int pre_de_busy; /* 1 if pre_de is not done */
     int pre_de_busy_timer_count;
     int pre_de_process_done; /* flag when irq done */
-    int pre_de_clear_flag; 
+    int pre_de_clear_flag;
     int unreg_req_flag; /* flag is set when VFRAME_EVENT_PROVIDER_UNREG*/
     int unreg_req_flag2;
     int reg_flag;
@@ -1621,7 +1621,7 @@ typedef struct{
 #ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
     enum tvin_trans_fmt source_trans_fmt;
     enum tvin_trans_fmt det3d_trans_fmt;
-#endif    
+#endif
 #ifdef DET3D
     int vframe_interleave_flag;
 #endif
@@ -1832,7 +1832,7 @@ static void di_apply_reg_cfg(unsigned char pre_post_type)
                     else if((di_pre_stru.cur_sig_fmt >= ((reg_cfg->sig_fmt_range[ii]>>16)&0xffff))&&
                         (di_pre_stru.cur_sig_fmt <= (reg_cfg->sig_fmt_range[ii]&0xffff))){
                         set_flag = 1;
-                        break;        
+                        break;
                     }
                 }
             }
@@ -1840,23 +1840,23 @@ static void di_apply_reg_cfg(unsigned char pre_post_type)
                 for(ii=0; ii<REG_SET_MAX_NUM; ii++){
                     if(reg_cfg->reg_set[ii].adr){
                         if(pre_post_type)
-                            VSYNC_WR_MPEG_REG_BITS(reg_cfg->reg_set[ii].adr, reg_cfg->reg_set[ii].val, 
-                                reg_cfg->reg_set[ii].start, reg_cfg->reg_set[ii].len);    
-                        else    
-                            Wr_reg_bits(reg_cfg->reg_set[ii].adr, reg_cfg->reg_set[ii].val, 
-                                reg_cfg->reg_set[ii].start, reg_cfg->reg_set[ii].len);    
+                            VSYNC_WR_MPEG_REG_BITS(reg_cfg->reg_set[ii].adr, reg_cfg->reg_set[ii].val,
+                                reg_cfg->reg_set[ii].start, reg_cfg->reg_set[ii].len);
+                        else
+                            Wr_reg_bits(reg_cfg->reg_set[ii].adr, reg_cfg->reg_set[ii].val,
+                                reg_cfg->reg_set[ii].start, reg_cfg->reg_set[ii].len);
                     }
                     else{
                         break;
-                    }    
-                }    
+                    }
+                }
                 break;
             }
             reg_cfg = reg_cfg->next;
         }
     }
 
-}        
+}
 #endif
 
 
@@ -1869,7 +1869,7 @@ static void dis2_di(void)
                 //vf_unreg_provider(&di_vf_prov);
                 vf_light_unreg_provider(&di_vf_prov);
                 di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-    
+
                 spin_lock_irqsave(&plist_lock, flags);
                 di_lock_irqfiq_save(irq_flag2, fiq_flag);
 
@@ -1886,7 +1886,7 @@ static void dis2_di(void)
                 }
                 di_uninit_buf();
                 di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-                spin_unlock_irqrestore(&plist_lock, flags);            
+                spin_unlock_irqrestore(&plist_lock, flags);
 }
 
 static ssize_t store_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
@@ -1899,16 +1899,16 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
             di_pre_stru.disable_req_flag = 1;
             provider_vframe_level = 0;
             bypass_dynamic_flag = 0;
-            post_ready_empty_count = 0; 
+            post_ready_empty_count = 0;
 
             trigger_pre_di_process('d');
             while(di_pre_stru.disable_req_flag){
-                msleep(1);    
+                msleep(1);
             }
         }
     }
     else if(strncmp(buf, "dis2", 4)==0){
-        dis2_di();    
+        dis2_di();
     }
     return count;
 }
@@ -1947,7 +1947,7 @@ static unsigned char is_vframe_type_change(vframe_t* vframe)
         return 1;
     }
     return 0;
-}    
+}
 
 static int trick_mode;
 static unsigned char is_bypass(void)
@@ -1955,10 +1955,10 @@ static unsigned char is_bypass(void)
     if(di_debug_flag&0x10000){ //for debugging
         return (di_debug_flag>>17)&0x1;
     }
-    
+
     if(bypass_interlace_output && interlace_output_flag)
         return 1;
-        
+
     if(bypass_all)
         return 1;
     if(di_pre_stru.cur_prog_flag&&
@@ -1971,13 +1971,13 @@ static unsigned char is_bypass(void)
 		(di_pre_stru.cur_width==1920)&&(di_pre_stru.cur_height==1080)
         &&(bypass_1080p)
         )
-        return 1;	
+        return 1;
 
     if(di_pre_stru.cur_prog_flag&&
 		(di_pre_stru.cur_width>720)&&(di_pre_stru.cur_height>576)
         &&(bypass_hd_prog)
         )
-        return 1;	
+        return 1;
 
     if(bypass_hd&&
         ((di_pre_stru.cur_width>720)||(di_pre_stru.cur_height>576))
@@ -2014,11 +2014,11 @@ static unsigned char is_bypass_post(void)
     if(di_debug_flag&0x40000){ //for debugging
         return (di_debug_flag>>19)&0x1;
     }
-    
+
     if((bypass_post)||(bypass_dynamic_flag&1)){
         return 1;
     }
-    
+
 #ifdef DET3D
     if(det3d_en){
         return 1;
@@ -2027,9 +2027,9 @@ static unsigned char is_bypass_post(void)
     if(di_pre_stru.vframe_interleave_flag!=0){
         return 1;
     }
-#endif    
-    return 0;            
-}    
+#endif
+    return 0;
+}
 
 #ifdef RUN_DI_PROCESS_IN_IRQ
 static unsigned char is_input2pre(void)
@@ -2047,7 +2047,7 @@ static unsigned char is_input2pre(void)
     pre_urgent = 0;
 #endif
     return 0;
-}    
+}
 #endif
 
 #ifndef DI_USE_FIXED_CANVAS_IDX
@@ -2072,7 +2072,7 @@ static void config_canvas_idx(di_buf_t* di_buf, int nr_canvas_idx, int mtn_canva
         if(di_buf->canvas_config_flag == 1){
             if(nr_canvas_idx>=0){
                 di_buf->nr_canvas_idx = nr_canvas_idx;
-                canvas_config(nr_canvas_idx, di_buf->nr_adr, width*2, canvas_height, 0, 0);            
+                canvas_config(nr_canvas_idx, di_buf->nr_adr, width*2, canvas_height, 0, 0);
             }
         }
         else if(di_buf->canvas_config_flag == 2){
@@ -2090,7 +2090,7 @@ static void config_canvas_idx(di_buf_t* di_buf, int nr_canvas_idx, int mtn_canva
             di_buf->vframe->canvas1Addr = di_buf->nr_canvas_idx;
         }
     }
-}    
+}
 
 #ifdef NEW_DI
 static void config_cnt_canvas_idx(di_buf_t* di_buf, int cnt_canvas_idx)
@@ -2098,7 +2098,7 @@ static void config_cnt_canvas_idx(di_buf_t* di_buf, int cnt_canvas_idx)
     if(di_buf){
         int width = (di_buf->canvas_config_size>>16)&0xffff;
         int canvas_height = (di_buf->canvas_config_size)&0xffff;
-        di_buf->cnt_canvas_idx = cnt_canvas_idx;    
+        di_buf->cnt_canvas_idx = cnt_canvas_idx;
         canvas_config(cnt_canvas_idx, di_buf->cnt_adr, width/2, canvas_height/2, 0, 0);
     }
 }
@@ -2112,7 +2112,7 @@ static void config_canvas(di_buf_t* di_buf)
         int width = (di_buf->canvas_config_size>>16)&0xffff;
         int canvas_height = (di_buf->canvas_config_size)&0xffff;
         if(di_buf->canvas_config_flag == 1){
-            canvas_config(di_buf->nr_canvas_idx, di_buf->nr_adr, width*2, canvas_height, 0, 0);            
+            canvas_config(di_buf->nr_canvas_idx, di_buf->nr_adr, width*2, canvas_height, 0, 0);
             di_buf->canvas_config_flag = 0;
         }
         else if(di_buf->canvas_config_flag == 2){
@@ -2120,12 +2120,12 @@ static void config_canvas(di_buf_t* di_buf)
 	          canvas_config(di_buf->mtn_canvas_idx, di_buf->mtn_adr, width/2, canvas_height/2, 0, 0);
             di_buf->canvas_config_flag = 0;
         }
-        
+
     }
 }
-    
+
 #endif
-    
+
 static int di_init_buf(int width, int height, unsigned char prog_flag)
 {
     int i, local_buf_num_available, local_buf_num_valid;
@@ -2172,10 +2172,10 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 #ifdef NEW_DI
             local_buf_num = di_mem_size/((width*canvas_height*6/4)+dp_buf_size);
             dp_mem_start = di_mem_start + (width*canvas_height*6/4)*local_buf_num;
-#else            
+#else
             local_buf_num = di_mem_size/((width*canvas_height*5/4)+dp_buf_size);
             dp_mem_start = di_mem_start + (width*canvas_height*5/4)*local_buf_num;
-#endif            
+#endif
         }
         else
 #endif
@@ -2183,7 +2183,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
         local_buf_num = di_mem_size/(width*canvas_height*6/4);
 #else
         local_buf_num = di_mem_size/(width*canvas_height*5/4);
-#endif        
+#endif
         local_buf_num_available = local_buf_num;
         if(local_buf_num > MAX_LOCAL_BUF_NUM){
             local_buf_num = MAX_LOCAL_BUF_NUM;
@@ -2205,8 +2205,8 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
     for(i=0; i<local_buf_num; i++){
         di_buf_t* di_buf = &(di_buf_local[i]);
         int ii = USED_LOCAL_BUF_MAX;
-        if(new_keep_last_frame_enable){ 
-            for(ii=0; ii<USED_LOCAL_BUF_MAX; ii++){ 
+        if(new_keep_last_frame_enable){
+            for(ii=0; ii<USED_LOCAL_BUF_MAX; ii++){
                 //printk("%s %d %d\n", __func__, di_buf->index, used_local_buf_index[ii]);
                 if(i == used_local_buf_index[ii]){
                     di_print("%s skip %d\n", __func__, i);
@@ -2214,7 +2214,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
                 }
             }
             if(ii<USED_LOCAL_BUF_MAX){
-                local_buf_num_valid--;    
+                local_buf_num_valid--;
             }
         }
 
@@ -2236,14 +2236,14 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
                     di_buf->dp_buf_adr = dp_mem_start + (i*dp_buf_size);
                     di_buf->dp_buf_size = dp_buf_size;
                 }
-#endif                
+#endif
             }
             else{
 #ifdef NEW_DI
                 di_buf->nr_adr = di_mem_start + (width*canvas_height*6/4)*i;
 #else
                 di_buf->nr_adr = di_mem_start + (width*canvas_height*5/4)*i;
-#endif                
+#endif
 #ifndef DI_USE_FIXED_CANVAS_IDX
     	          di_buf->nr_canvas_idx = DEINTERLACE_CANVAS_BASE_INDEX+i*2;
 #endif
@@ -2253,7 +2253,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
                 di_buf->cnt_adr = di_mem_start + (width*canvas_height*6/4)*i + (width*canvas_height)*5/4;
 #else
                 di_buf->mtn_adr = di_mem_start + (width*canvas_height*5/4)*i + (width*canvas_height);
-#endif                
+#endif
 #ifndef DI_USE_FIXED_CANVAS_IDX
     	          di_buf->mtn_canvas_idx = DEINTERLACE_CANVAS_BASE_INDEX+i*2+1;
 #endif
@@ -2265,7 +2265,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
                     di_buf->dp_buf_adr = dp_mem_start + (i*dp_buf_size);
                     di_buf->dp_buf_size = dp_buf_size;
                 }
-#endif                
+#endif
             }
             di_buf->index = i;
             di_buf->vframe = &(vframe_local[i]);
@@ -2322,7 +2322,7 @@ static void di_uninit_buf(void)
     di_buf_t *p = NULL, *ptmp;
     int i, ii=0;
 		int itmp;
-    
+
     vframe_t* cur_vf = get_cur_dispbuf();
 
 		for(i=0; i<USED_LOCAL_BUF_MAX; i++){
@@ -2354,8 +2354,8 @@ static void di_uninit_buf(void)
 	        	    ii++;
                 }
 	        }
-#endif	        
-	            printk("%s keep cur di_buf %d (%d %d %d)\n", 
+#endif
+	            printk("%s keep cur di_buf %d (%d %d %d)\n",
 	                __func__, used_post_buf_index, used_local_buf_index[0],
 	                used_local_buf_index[1],used_local_buf_index[2]);
 	            break;
@@ -2363,10 +2363,10 @@ static void di_uninit_buf(void)
 	      }
 	      if(ii>=USED_LOCAL_BUF_MAX){
 	      	break;
-	      }	
+	      }
     }
-    
-#ifdef USE_LIST    
+
+#ifdef USE_LIST
     list_for_each_entry_safe(p, ptmp, &local_free_list_head, list) {
         list_del(&p->list);
     }
@@ -2389,8 +2389,8 @@ static void di_uninit_buf(void)
         list_del(&p->list);
     }
 #else
-    queue_init(0);    
-#endif    
+    queue_init(0);
+#endif
     for(i=0; i<MAX_IN_BUF_NUM; i++){
 			vframe_in[i]=NULL;
 		}
@@ -2415,7 +2415,7 @@ static void di_clean_in_buf(void)
         recycle_vframe_type_post_print(di_buf, __func__);
 #endif
     }
-    
+
     if(di_pre_stru.di_mem_buf_dup_p){
         di_pre_stru.di_mem_buf_dup_p->pre_ref_count = 0;
         di_pre_stru.di_mem_buf_dup_p = NULL;
@@ -2477,7 +2477,7 @@ static void di_clean_in_buf(void)
     for(i=0; i<MAX_IN_BUF_NUM; i++){
 			vframe_in[i]=NULL;
 		}
-    
+
 }
 
 static void log_buffer_state(unsigned char* tag)
@@ -2526,14 +2526,14 @@ static void log_buffer_state(unsigned char* tag)
             di_inp++;
         if(di_pre_stru.di_wr_buf)
             di_wr++;
-				
+
 				if(buf_state_log_threshold == 0){
 					  buf_state_log_start = 0;
 				}
 				else if(post_ready < buf_state_log_threshold){
-			  		buf_state_log_start = 1;	
+			  		buf_state_log_start = 1;
 				}
-				if(buf_state_log_start){	
+				if(buf_state_log_start){
 	        di_print("[%s]i %d, i_f %d/%d, l_f %d/%d, pre_r %d, post_f %d/%d, post_r (%d:%d), disp (%d:%d),rec %d, di_i %d, di_w %d\r\n",
 	            tag,
 	            provider_vframe_level,
@@ -2558,17 +2558,17 @@ static void dump_di_buf(di_buf_t* di_buf)
 {
     printk("di_buf 0x%x vframe 0x%x:\n", di_buf, di_buf->vframe);
     printk("index %d, post_proc_flag %d, new_format_flag %d, type %d, seq %d, pre_ref_count %d, post_ref_count %d, queue_index %d pulldown_mode %d process_fun_index %d\n",
-        di_buf->index, di_buf->post_proc_flag, di_buf->new_format_flag, di_buf->type, di_buf->seq, di_buf->pre_ref_count, 
+        di_buf->index, di_buf->post_proc_flag, di_buf->new_format_flag, di_buf->type, di_buf->seq, di_buf->pre_ref_count,
         di_buf->post_ref_count, di_buf->queue_index, di_buf->pulldown_mode, di_buf->process_fun_index);
     printk("di_buf: 0x%x, 0x%x, di_buf_dup_p: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",
         di_buf->di_buf[0],di_buf->di_buf[1],di_buf->di_buf_dup_p[0],di_buf->di_buf_dup_p[1],di_buf->di_buf_dup_p[2],di_buf->di_buf_dup_p[3],di_buf->di_buf_dup_p[4]);
     printk("nr_adr 0x%x, nr_canvas_idx 0x%x, mtn_adr 0x%x, mtn_canvas_idx 0x%x",
         di_buf->nr_adr, di_buf->nr_canvas_idx, di_buf->mtn_adr, di_buf->mtn_canvas_idx);
-#ifdef NEW_DI    
+#ifdef NEW_DI
     printk("cnt_adr 0x%x, cnt_canvas_idx 0x%x\n",
         di_buf->cnt_adr, di_buf->cnt_canvas_idx);
-#endif    
-}    
+#endif
+}
 
 static void dump_pool(int index)
 {
@@ -2581,9 +2581,9 @@ static void dump_pool(int index)
         if(((j+1)%16)==0){
             printk("\n");
         }
-    } 
+    }
     printk("\n");
-}    
+}
 
 static void dump_vframe(vframe_t* vf)
 {
@@ -2594,14 +2594,14 @@ static void dump_vframe(vframe_t* vf)
             vf->canvas0Addr, vf->canvas1Addr, vf->bufWidth, vf->width, vf->height, vf->ratio_control, vf->orientation,
             vf->source_type, vf->phase, vf->source_mode, vf->sig_fmt);
 #ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-    printk("trans_fmt 0x%x, left_eye(%d %d %d %d), right_eye(%d %d %d %d)\n", 
+    printk("trans_fmt 0x%x, left_eye(%d %d %d %d), right_eye(%d %d %d %d)\n",
             vf->trans_fmt, vf->left_eye.start_x, vf->left_eye.start_y, vf->left_eye.width, vf->left_eye.height,
             vf->right_eye.start_x, vf->right_eye.start_y, vf->right_eye.width, vf->right_eye.height);
 #endif
     printk("mode_3d_enable %d, early_process_fun 0x%x, process_fun 0x%x, private_data 0x%x\n",
             vf->mode_3d_enable, vf->early_process_fun, vf->process_fun, vf->private_data);
     printk("pixel_ratio %d list 0x%x\n",
-            vf->pixel_ratio, vf->list); 
+            vf->pixel_ratio, vf->list);
 
 }
 
@@ -2609,32 +2609,32 @@ static void print_di_buf(di_buf_t* di_buf, int format)
 {
     if(format == 1){
         if(di_buf){
-            printk("    +index %d, 0x%x, type %d, vframetype 0x%x, trans_fmt %u\n", di_buf->index, (unsigned int)di_buf, di_buf->type, 
+            printk("    +index %d, 0x%x, type %d, vframetype 0x%x, trans_fmt %u\n", di_buf->index, (unsigned int)di_buf, di_buf->type,
                         di_buf->vframe->type,
 #ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
                         di_buf->vframe->trans_fmt
 #else
                         0
-#endif                        
+#endif
                         );
         }
-        
+
     }
     else if(format == 2){
         if(di_buf){
-            printk("index %d, 0x%x(vframe 0x%x), type %d, vframetype 0x%x, trans_fmt %u,duration %d pts %d\n", 
-                    di_buf->index, (unsigned int)di_buf, di_buf->vframe, di_buf->type, di_buf->vframe->type, 
+            printk("index %d, 0x%x(vframe 0x%x), type %d, vframetype 0x%x, trans_fmt %u,duration %d pts %d\n",
+                    di_buf->index, (unsigned int)di_buf, di_buf->vframe, di_buf->type, di_buf->vframe->type,
 #ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
                         di_buf->vframe->trans_fmt,
 #else
                         0,
-#endif                        
+#endif
                         di_buf->vframe->duration, di_buf->vframe->pts);
         }
-        
-    }   
-     
-}    
+
+    }
+
+}
 
 static void dump_state(void)
 {
@@ -2642,7 +2642,7 @@ static void dump_state(void)
     int itmp;
     int i;
     dump_state_flag = 1;
-    printk("version %s, provider vframe level %d, init_flag %d, is_bypass %d, receiver_is_amvideo %d\n", 
+    printk("version %s, provider vframe level %d, init_flag %d, is_bypass %d, receiver_is_amvideo %d\n",
         version_s, provider_vframe_level, init_flag, is_bypass(), receiver_is_amvideo);
     printk("recovery_flag = %d, recovery_log_reason=%d, recovery_log_queue_idx=%d, recovery_log_di_buf=0x%x\n",
         recovery_flag, recovery_log_reason, recovery_log_queue_idx, recovery_log_di_buf);
@@ -2650,7 +2650,7 @@ static void dump_state(void)
     printk("new_keep_last_frame_enable %d, used_post_buf_index %d(0x%x), used_local_buf_index:\n", new_keep_last_frame_enable,
         used_post_buf_index, (used_post_buf_index==-1)?NULL:&(di_buf_post[used_post_buf_index]));
 		for(i=0; i<USED_LOCAL_BUF_MAX; i++){
-		    int tmp = used_local_buf_index[i]; 
+		    int tmp = used_local_buf_index[i];
     	    printk("%d(0x%x) ",tmp, (tmp==-1)?NULL:&(di_buf_local[tmp]));
 		}
 
@@ -2703,7 +2703,7 @@ static void dump_state(void)
     printk("vf_peek()=>%x\n",vf_peek(VFM_NAME));
     printk("di_process_cnt = %d, video_peek_cnt = %d, force_trig_cnt = %d\n", di_process_cnt, video_peek_cnt, force_trig_cnt);
     dump_state_flag = 0;
-    
+
 }
 
 static unsigned char check_di_buf(di_buf_t* di_buf, int reason)
@@ -2733,7 +2733,7 @@ static unsigned char check_di_buf(di_buf_t* di_buf, int reason)
                 error = 1;
             }
 
-            if(error){                        
+            if(error){
                 printk("%s: Error %d, di_buf wrong\n", __func__, reason);
                 if(recovery_flag==0){
                     recovery_log_reason = reason;
@@ -2867,7 +2867,7 @@ static void config_di_mif(DI_MIF_t* di_mif, di_buf_t*di_buf)
 			    di_mif->set_separate_en = 2;
 			}
 			else
-#endif			
+#endif
 			{
 			    di_mif->set_separate_en = 1;
 			}
@@ -2878,7 +2878,7 @@ static void config_di_mif(DI_MIF_t* di_mif, di_buf_t*di_buf)
       if(is_progressive(di_buf->vframe)&&(di_pre_stru.prog_proc_type)){
 			        di_mif->src_field_mode = 0;
     			    di_mif->output_field_num = 0;    									// top
-    
+
         			di_mif->luma_x_start0 	= 0;
         			di_mif->luma_x_end0 		= di_buf->vframe->width - 1;
         			di_mif->luma_y_start0 	= 0;
@@ -2893,7 +2893,7 @@ static void config_di_mif(DI_MIF_t* di_mif, di_buf_t*di_buf)
           if(((di_buf->vframe->type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP)
             ||(di_pre_stru.process_count>0)){
     			    di_mif->output_field_num = 0;    									// top
-    
+
         			di_mif->luma_x_start0 	= 0;
         			di_mif->luma_x_end0 		= di_buf->vframe->width - 1;
         			di_mif->luma_y_start0 	= 0;
@@ -2905,7 +2905,7 @@ static void config_di_mif(DI_MIF_t* di_mif, di_buf_t*di_buf)
     			}
           else{
     			    di_mif->output_field_num = 1;    									// bottom
-    
+
         			di_mif->luma_x_start0 	= 0;
         			di_mif->luma_x_end0 		= di_buf->vframe->width - 1;
         			di_mif->luma_y_start0 	= 1;
@@ -2938,13 +2938,13 @@ static void pre_de_process(void)
         config_canvas_idx(di_pre_stru.di_mem_buf_dup_p, DI_PRE_MEM_NR_CANVAS_IDX, -1);
 #ifdef NEW_DI
         config_cnt_canvas_idx(di_pre_stru.di_mem_buf_dup_p, DI_CONTP2RD_CANVAS_IDX);
-#endif    
+#endif
     }
     if(di_pre_stru.di_chan2_buf_dup_p!=NULL){
         config_canvas_idx(di_pre_stru.di_chan2_buf_dup_p, DI_PRE_CHAN2_NR_CANVAS_IDX, -1);
 #ifdef NEW_DI
         config_cnt_canvas_idx(di_pre_stru.di_chan2_buf_dup_p, DI_CONTPRD_CANVAS_IDX);
-#endif    
+#endif
     }
     config_canvas_idx(di_pre_stru.di_wr_buf, DI_PRE_WR_NR_CANVAS_IDX, DI_PRE_WR_MTN_CANVAS_IDX);
 #ifdef NEW_DI
@@ -2960,7 +2960,7 @@ static void pre_de_process(void)
     config_di_cnt_mif(&di_pre_stru.di_contp2rd_mif, di_pre_stru.di_mem_buf_dup_p);
     config_di_cnt_mif(&di_pre_stru.di_contprd_mif, di_pre_stru.di_chan2_buf_dup_p);
     config_di_cnt_mif(&di_pre_stru.di_contwr_mif, di_pre_stru.di_wr_buf);
-#endif    
+#endif
 
     if((di_pre_stru.di_chan2_buf_dup_p)&&
         ((di_pre_stru.di_chan2_buf_dup_p->vframe->type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP)){
@@ -3028,14 +3028,14 @@ static void pre_de_process(void)
                &di_pre_stru.di_contp2rd_mif,
                &di_pre_stru.di_contprd_mif,
                &di_pre_stru.di_contwr_mif,
-#endif               
+#endif
                1,                      // nr enable
                di_pre_stru.enable_mtnwr,                      // mtn enable
                di_pre_stru.enable_pulldown_check,                                 // pd32 check_en
                di_pre_stru.enable_pulldown_check,                                  // pd22 check_en
 #if defined(CONFIG_ARCH_MESON)
 			         1,                      											// hist check_en
-#else 
+#else
 			         0,                      											// hist check_en
 #endif
                chan2_field_num,                      //  field num for chan2. 1 bottom, 0 top.
@@ -3043,7 +3043,7 @@ static void pre_de_process(void)
                pre_hold_line,                     //hold line.
                pre_urgent
              );
-		Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL)|(0x3 << 30)); //add for M6, reset 
+		Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL)|(0x3 << 30)); //add for M6, reset
 #ifdef NEW_DI
     if(get_new_mode_flag() == 1){
     if (di_pre_stru.cur_prog_flag == 1) {
@@ -3076,11 +3076,11 @@ static void pre_de_process(void)
     }
 	Wr(DI_MTN_1_CTRL1, di_mtn_1_ctrl1);
 	//Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL)|(1<<25));
-#endif		
+#endif
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV)
     di_apply_reg_cfg(0);
 #endif
-	
+
 }
 
 static void pre_de_done_buf_clear(void)
@@ -3093,10 +3093,10 @@ static void pre_de_done_buf_clear(void)
     }
     if(di_pre_stru.di_inp_buf){
         if(di_pre_stru.di_mem_buf_dup_p == di_pre_stru.di_inp_buf){
-            di_pre_stru.di_mem_buf_dup_p = NULL; 
+            di_pre_stru.di_mem_buf_dup_p = NULL;
         }
         queue_in(di_pre_stru.di_inp_buf, QUEUE_RECYCLE);
-        di_pre_stru.di_inp_buf = NULL;                        
+        di_pre_stru.di_inp_buf = NULL;
     }
 }
 
@@ -3172,10 +3172,10 @@ static void pre_de_done_buf_config(void)
                 di_pre_stru.di_wr_buf->new_format_flag = 0;
             }
             if(bypass_state == 1){
-                di_pre_stru.di_wr_buf->new_format_flag = 1; 
-                bypass_state = 0;   
+                di_pre_stru.di_wr_buf->new_format_flag = 1;
+                bypass_state = 0;
 //#ifdef DI_DEBUG
-     						di_print("%s:bypass_state change to 0, is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);        
+     						di_print("%s:bypass_state change to 0, is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);
 //#endif
             }
 #ifdef CONFIG_VSYNC_RDMA
@@ -3233,17 +3233,17 @@ static void pre_de_done_buf_config(void)
                 di_pre_stru.di_wr_buf->new_format_flag = 0;
             }
             if(bypass_state == 1){
-                di_pre_stru.di_wr_buf->new_format_flag = 1; 
-                bypass_state = 0;   
+                di_pre_stru.di_wr_buf->new_format_flag = 1;
+                bypass_state = 0;
 //#ifdef DI_DEBUG
-        						di_print("%s:bypass_state change to 0, is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);        
+        						di_print("%s:bypass_state change to 0, is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);
 //#endif
             }
 #ifdef CONFIG_VSYNC_RDMA
 			if((di_debug_flag&0x10)==0){
                 enable_rdma(1);
             }
-#endif            
+#endif
             //top_bot_config(di_pre_stru.di_wr_buf);
             queue_in(di_pre_stru.di_wr_buf, QUEUE_PRE_READY);
 
@@ -3255,7 +3255,7 @@ static void pre_de_done_buf_config(void)
 
         }
     }
-    
+
     if((di_pre_stru.process_count==0)&&(di_pre_stru.di_inp_buf)){
 #ifdef DI_DEBUG
         di_print("%s: %s[%d] => recycle_list\n",
@@ -3301,7 +3301,7 @@ static void di_set_para_by_tvinfo(vframe_t* vframe)
                       (10 << 16) |       				// close1
                       (10 << 8 ) |       				// far2
                        93;             				// far1
- #ifdef NEW_DI                          
+ #ifdef NEW_DI
     #if defined(CONFIG_MESON_M6C_ENHANCEMENT)
             ei_ctrl3 = 0x80000013;
     #else
@@ -3334,7 +3334,7 @@ static void di_set_para_by_tvinfo(vframe_t* vframe)
                       (255 << 16) |       				// close1
                       (10 << 8 ) |       				// far2
                        255;             				// far1
- #ifdef NEW_DI                            
+ #ifdef NEW_DI
     #if defined(CONFIG_MESON_M6C_ENHANCEMENT)
         ei_ctrl3 = 0x80000013;
     #else
@@ -3387,7 +3387,7 @@ static unsigned char pre_de_buf_config(void)
         if(in_buf_num>bypass_get_buf_threshold
 #ifdef DET3D
             && (di_pre_stru.vframe_interleave_flag == 0)
-#endif            
+#endif
             ){
             return 0;
         }
@@ -3398,7 +3398,7 @@ static unsigned char pre_de_buf_config(void)
         di_pre_stru.di_inp_buf_next = NULL;
 #ifdef DI_DEBUG
         di_print("%s: di_inp_buf_next %s[%d] => di_inp_buf\n", __func__, vframe_type_name[di_pre_stru.di_inp_buf->type], di_pre_stru.di_inp_buf->index);
-#endif            
+#endif
         if(di_pre_stru.di_mem_buf_dup_p == NULL){//use n
             di_pre_stru.di_mem_buf_dup_p = di_pre_stru.di_inp_buf;
 #ifdef DI_DEBUG
@@ -3415,7 +3415,7 @@ static unsigned char pre_de_buf_config(void)
 #ifdef CHECK_VDIN_BUF_ERROR
 #define WR_CANVAS_BIT                   0
 #define WR_CANVAS_WID                   8
-        
+
         vframe = vf_peek(VFM_NAME);
 
         if(vframe&&is_from_vdin(vframe)){
@@ -3443,7 +3443,7 @@ static unsigned char pre_de_buf_config(void)
         di_pre_stru.source_trans_fmt = vframe->trans_fmt;
 	di_pre_stru.left_right = di_pre_stru.left_right?0:1;
 #endif
-        
+
         if(((invert_top_bot&0x2)!=0) && (!is_progressive(vframe))){
             if((vframe->type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP){
                 vframe->type&=(~VIDTYPE_TYPEMASK);
@@ -3460,14 +3460,14 @@ static unsigned char pre_de_buf_config(void)
         }
         if(force_height){
             vframe->height = force_height;
-        }    
+        }
 
 #ifdef DI_DEBUG
         di_print("%s: vf_get => %x\n", __func__, vframe);
 #endif
         provider_vframe_level--;
         di_buf = get_di_buf_head(QUEUE_IN_FREE);
-        
+
         if(check_di_buf(di_buf, 10)){
             return 0;
         }
@@ -3476,13 +3476,13 @@ static unsigned char pre_de_buf_config(void)
             dump_vframe(vframe);
         }
         memcpy(di_buf->vframe, vframe, sizeof(vframe_t));
-        
+
         di_buf->vframe->private_data = di_buf;
         vframe_in[di_buf->index] = vframe;
         di_buf->seq = di_pre_stru.in_seq;
         di_pre_stru.in_seq++;
         queue_out(di_buf);
-            
+
         if(is_source_change(vframe)){ /* source change*/
             if(di_pre_stru.di_mem_buf_dup_p){
                 di_pre_stru.di_mem_buf_dup_p->pre_ref_count = 0;
@@ -3556,7 +3556,7 @@ static unsigned char pre_de_buf_config(void)
                 else{
                     di_buf->new_format_flag = 0;
                 }
-                
+
                 if(bypass_state == 0){
 	                if(di_pre_stru.di_mem_buf_dup_p){
 	                    di_pre_stru.di_mem_buf_dup_p->pre_ref_count = 0;
@@ -3566,18 +3566,18 @@ static unsigned char pre_de_buf_config(void)
 	                    di_pre_stru.di_chan2_buf_dup_p->pre_ref_count = 0;
 	                    di_pre_stru.di_chan2_buf_dup_p = NULL;
 	                }
-	                
+
 	    			if(di_pre_stru.di_wr_buf){
                   ulong fiq_flag, irq_flag2;
 			            di_pre_stru.process_count = 0;
-			
+
 			            di_pre_stru.di_wr_buf->pre_ref_count = 0;
 			            di_pre_stru.di_wr_buf->post_ref_count = 0;
 
                   di_lock_irqfiq_save(irq_flag2, fiq_flag);
 			            queue_in(di_pre_stru.di_wr_buf, QUEUE_RECYCLE);
                   di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-			            
+
 #ifdef DI_DEBUG
 			            di_print("%s: %s[%d] => recycle_list\n",
 			                __func__, vframe_type_name[di_pre_stru.di_wr_buf->type], di_pre_stru.di_wr_buf->index);
@@ -3585,18 +3585,18 @@ static unsigned char pre_de_buf_config(void)
 			            di_pre_stru.di_wr_buf = NULL;
 	        		}
 
-                    di_buf->new_format_flag = 1; 
-                    bypass_state = 1;   
+                    di_buf->new_format_flag = 1;
+                    bypass_state = 1;
 #ifdef CONFIG_VSYNC_RDMA
 			        if((di_debug_flag&0x10)==0){
                         enable_rdma(0);
                     }
 #endif
 //#ifdef DI_DEBUG
-        						di_print("%s:bypass_state change to 1, is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);        
+        						di_print("%s:bypass_state change to 1, is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);
 //#endif
                 }
-                
+
                 top_bot_config(di_buf);
                 queue_in(di_buf, QUEUE_PRE_READY);
                 di_buf->post_proc_flag = 0;
@@ -3613,7 +3613,7 @@ static unsigned char pre_de_buf_config(void)
                     di_buf->vframe->type|=VIDTYPE_INTERLACE_TOP;
                     di_buf->vframe->duration >= 1;
                     di_buf->post_proc_flag = 0;
-                    
+
                     di_buf_tmp = get_di_buf_head(QUEUE_IN_FREE);
                     di_buf_tmp->vframe->private_data = di_buf_tmp;
                     di_buf_tmp->seq = di_pre_stru.in_seq;
@@ -3629,7 +3629,7 @@ static unsigned char pre_de_buf_config(void)
 
                     di_pre_stru.di_inp_buf = di_buf;
 #ifdef DI_DEBUG
-                    di_print("%s: %s[%d] => di_inp_buf; %s[%d] => di_inp_buf_next\n", 
+                    di_print("%s: %s[%d] => di_inp_buf; %s[%d] => di_inp_buf_next\n",
                         __func__, vframe_type_name[di_buf->type], di_buf->index,
                         vframe_type_name[di_buf_tmp->type], di_buf_tmp->index);
 #endif
@@ -3675,7 +3675,7 @@ static unsigned char pre_de_buf_config(void)
                     #endif
                 }
             }
-#endif            
+#endif
             //n
             di_buf->post_proc_flag = 1;
             di_pre_stru.di_inp_buf = di_buf;
@@ -3696,11 +3696,11 @@ static unsigned char pre_de_buf_config(void)
      di_buf= get_di_buf_head(QUEUE_LOCAL_FREE);
 #ifndef DI_USE_FIXED_CANVAS_IDX
      config_canvas(di_buf);
-#endif      
+#endif
      if(check_di_buf(di_buf, 11)){
         return 0;
      }
-     
+
      queue_out(di_buf);
      di_pre_stru.di_wr_buf = di_buf;
      di_pre_stru.di_wr_buf->pre_ref_count = 1;
@@ -3733,17 +3733,17 @@ static unsigned char pre_de_buf_config(void)
     /* */
     if(is_bypass_post()){
         if(bypass_post_state == 0){
-            di_pre_stru.source_change_flag = 1;    
+            di_pre_stru.source_change_flag = 1;
         }
         bypass_post_state = 1;
     }
     else{
         if(bypass_post_state){
-            di_pre_stru.source_change_flag = 1;    
+            di_pre_stru.source_change_flag = 1;
         }
         bypass_post_state = 0;
-    }       
-    
+    }
+
     //if(is_progressive(di_pre_stru.di_inp_buf->vframe)){
     if(di_pre_stru.di_inp_buf->post_proc_flag==0){
         di_pre_stru.enable_mtnwr = 0;
@@ -3767,8 +3767,8 @@ static unsigned char pre_de_buf_config(void)
             di_buf->post_proc_flag = 1;
         }
     }
-    
-#ifndef USE_LIST    
+
+#ifndef USE_LIST
     if((di_pre_stru.di_mem_buf_dup_p == di_pre_stru.di_wr_buf)||
         (di_pre_stru.di_chan2_buf_dup_p == di_pre_stru.di_wr_buf)){
         printk("+++++++++++++++++++++++\n");
@@ -3776,9 +3776,9 @@ static unsigned char pre_de_buf_config(void)
             recovery_log_reason = 12;
         }
         recovery_flag++;
-        return 0;        
+        return 0;
     }
-#endif    
+#endif
     return 1;
 
 }
@@ -3860,7 +3860,7 @@ static void set3d_view(enum tvin_trans_fmt trans_fmt, struct vframe_s *vf)
             right_eye->start_x   = 0;
             right_eye->start_y   = 0;
             right_eye->width     = vf->width;
-            right_eye->height    = vf->height >> 1;        
+            right_eye->height    = vf->height >> 1;
             break;
         case TVIN_TFMT_3D_DET_CHESSBOARD:
             /***
@@ -3901,7 +3901,7 @@ static int get_3d_info(struct vframe_s *vf)
 static irqreturn_t det3d_irq(int irq, void *dev_instance)
 {
    unsigned int data32 = 0;
-	
+
     if (det3d_en){
         data32 = det3d_fmt_detect();
         if (det3d_mode != data32) {
@@ -3960,7 +3960,7 @@ di post process
 static void inc_post_ref_count(di_buf_t* di_buf)
 {
     int post_blend_mode;
-    
+
     if(di_buf == NULL){
 #ifdef DI_DEBUG
         printk("%s: Error\n", __func__);
@@ -3970,7 +3970,7 @@ static void inc_post_ref_count(di_buf_t* di_buf)
         }
         recovery_flag++;
     }
-    
+
     if(di_buf->pulldown_mode == 0)
         post_blend_mode = 0;
     else if(di_buf->pulldown_mode == 1)
@@ -4032,7 +4032,7 @@ static void process_vscale_skip(di_buf_t* di_buf, vframe_t* disp_vf)
 {
     vframe_t* di_post_vf = di_buf->vframe;
     di_buf_t* di_buf_i = NULL;
-    if(di_buf->di_buf[0]!=NULL && 
+    if(di_buf->di_buf[0]!=NULL &&
         di_buf->process_fun_index!=PROCESS_FUN_NULL){ //di post is enabled
         di_vscale_skip_count = get_current_vscale_skip_count(disp_vf);
         if(((di_vscale_skip_count>0)&&(di_vscale_skip_enable&0x1))||(di_vscale_skip_enable>>16)||(bypass_dynamic_flag&0x2)){
@@ -4060,14 +4060,14 @@ static void process_vscale_skip(di_buf_t* di_buf, vframe_t* disp_vf)
             disp_vf->height = di_buf_i->vframe->height;
             disp_vf->duration = di_buf_i->vframe->duration;
             disp_vf->pts = di_buf_i->vframe->pts;
-            disp_vf->canvas0Addr = di_post_buf0_canvas_idx[di_post_stru.canvas_id]; 
-            disp_vf->canvas1Addr = di_post_buf0_canvas_idx[di_post_stru.canvas_id]; 
+            disp_vf->canvas0Addr = di_post_buf0_canvas_idx[di_post_stru.canvas_id];
+            disp_vf->canvas1Addr = di_post_buf0_canvas_idx[di_post_stru.canvas_id];
             canvas_config(di_post_buf0_canvas_idx[di_post_stru.canvas_id], di_buf_i->nr_adr, width*2, canvas_height, 0, 0);
             disable_post_deinterlace_2();
             di_post_stru.vscale_skip_flag = true;
         }
     }
-}    
+}
 
 static int de_post_disable_fun(void* arg, vframe_t* disp_vf)
 {
@@ -4120,10 +4120,10 @@ static int do_pre_only_fun(void* arg, vframe_t* disp_vf)
                 di_post_stru.canvas_id = 0;
                 di_post_stru.next_canvas_id = 1;
         }
-#endif        			
-    
+#endif
+
         canvas_config(di_post_buf0_canvas_idx[di_post_stru.canvas_id], di_buf->di_buf[0]->nr_adr, width*2, canvas_height, 0, 0);
-                    
+
         vf->canvas0Addr = di_post_buf0_canvas_idx[di_post_stru.canvas_id];
         vf->canvas1Addr = di_post_buf0_canvas_idx[di_post_stru.canvas_id];
 #ifdef DET3D
@@ -4132,7 +4132,7 @@ static int do_pre_only_fun(void* arg, vframe_t* disp_vf)
             vf->canvas1Addr = di_post_buf1_canvas_idx[di_post_stru.canvas_id];
 	    vf->duration <<= 1;
         }
-#endif  
+#endif
         di_post_stru.next_canvas_id = di_post_stru.canvas_id?0:1;
 
         if(di_buf->process_fun_index == PROCESS_FUN_NULL){
@@ -4145,13 +4145,13 @@ static int do_pre_only_fun(void* arg, vframe_t* disp_vf)
     }
 #endif
 
-    return 0;    
-}    
+    return 0;
+}
 
 static int get_vscale_skip_count(unsigned par)
 {
-    di_vscale_skip_count_real = (par >> 24)&0xff;        
-}    
+    di_vscale_skip_count_real = (par >> 24)&0xff;
+}
 
 #define get_vpp_reg_update_flag(par) ((par>>16)&0x1)
 
@@ -4164,7 +4164,7 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
    	int post_blend_en, post_blend_mode;
 
     get_vscale_skip_count(zoom_start_x_lines);
-    
+
     if(di_post_stru.vscale_skip_flag){
         return 0;
     }
@@ -4175,10 +4175,10 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
     if(di_post_stru.toggle_flag)
 	top_bot_config(di_buf->di_buf_dup_p[1]);
 
-    di_post_stru.toggle_flag = false; 
-        
+    di_post_stru.toggle_flag = false;
+
     di_post_stru.cur_disp_index = di_buf->index;
-    
+
     if((di_post_stru.post_process_fun_index != 1)||((force_update_post_reg&0xf)!=0)){
         force_update_post_reg &= ~0x1;
         di_post_stru.post_process_fun_index = 1;
@@ -4189,12 +4189,12 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 	    	di_post_stru.update_post_reg_flag = update_post_reg_count;
 	    	//printk("%s set update_post_reg_flag to %d\n", __func__, di_post_stru.update_post_reg_flag);
 	  }
-      
+
     zoom_start_x_lines = zoom_start_x_lines&0xffff;
     zoom_end_x_lines = zoom_end_x_lines&0xffff;
     zoom_start_y_lines = zoom_start_y_lines&0xffff;
     zoom_end_y_lines = zoom_end_y_lines&0xffff;
-    
+
     if(di_buf->pulldown_mode == 0)
         post_blend_mode = 0;
     else if(di_buf->pulldown_mode == 1)
@@ -4247,7 +4247,7 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
                 di_post_stru.canvas_id = 0;
                 di_post_stru.next_canvas_id = 1;
         }
-#endif        			
+#endif
 
       config_canvas_idx(di_buf->di_buf_dup_p[1], di_post_buf0_canvas_idx[di_post_stru.canvas_id], -1);
 	    if ( post_blend_mode == 1 )
@@ -4271,13 +4271,13 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
     	post_blend_en = 1;
 #ifdef NEW_DI
     if(get_new_mode_flag() == 1){
-        blend_ctrl |= (1<<31); 
+        blend_ctrl |= (1<<31);
     }
     else if(get_new_mode_flag()==0){
-        blend_ctrl &= (~(1<<31)); 
+        blend_ctrl &= (~(1<<31));
     }
-#endif    	
-    
+#endif
+
     if((di_post_stru.update_post_reg_flag)&&((force_update_post_reg&0x80)==0))
 	    enable_di_post_2 (
 	    		&di_post_stru.di_buf0_mif,
@@ -4314,11 +4314,11 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 	    		post_urgent,
 	    		reg_mtn_info
 	    	);
-	    
+
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV)
     if(di_post_stru.update_post_reg_flag)
         di_apply_reg_cfg(1);
-	
+
     di_post_read_reverse_irq(overturn);
 #endif
 
@@ -4347,7 +4347,7 @@ static int de_post_process_pd(void* arg, unsigned zoom_start_x_lines,
     if(di_post_stru.toggle_flag)
 	top_bot_config(di_buf->di_buf_dup_p[1]);
 
-    di_post_stru.toggle_flag = false; 
+    di_post_stru.toggle_flag = false;
 
     di_post_stru.cur_disp_index = di_buf->index;
 
@@ -4360,7 +4360,7 @@ static int de_post_process_pd(void* arg, unsigned zoom_start_x_lines,
     if(get_vpp_reg_update_flag(zoom_start_x_lines)){
 	    	di_post_stru.update_post_reg_flag = update_post_reg_count;
 	    	//printk("%s set update_post_reg_flag to %d\n", __func__, di_post_stru.update_post_reg_flag);
-    }	    	
+    }
 
     zoom_start_x_lines = zoom_start_x_lines&0xffff;
     zoom_end_x_lines = zoom_end_x_lines&0xffff;
@@ -4415,7 +4415,7 @@ static int de_post_process_pd(void* arg, unsigned zoom_start_x_lines,
                 di_post_stru.canvas_id = 0;
                 di_post_stru.next_canvas_id = 1;
         }
-#endif        			
+#endif
 
       config_canvas_idx(di_buf->di_buf_dup_p[1], di_post_buf0_canvas_idx[di_post_stru.canvas_id], -1);
 	    if ( post_blend_mode == 1 )
@@ -4499,7 +4499,7 @@ static int de_post_process_prog(void* arg, unsigned zoom_start_x_lines,
     if(di_post_stru.toggle_flag)
 	top_bot_config(di_buf->di_buf_dup_p[0]);
 
-    di_post_stru.toggle_flag = false; 
+    di_post_stru.toggle_flag = false;
 
     di_post_stru.cur_disp_index = di_buf->index;
 
@@ -4565,7 +4565,7 @@ static int de_post_process_prog(void* arg, unsigned zoom_start_x_lines,
         	di_post_stru.canvas_id = 0;
         	di_post_stru.next_canvas_id = 1;
         }
-#endif        			
+#endif
 
       config_canvas_idx(di_buf->di_buf_dup_p[0], di_post_buf0_canvas_idx[di_post_stru.canvas_id], di_post_mtncrd_canvas_idx[di_post_stru.canvas_id]);
       config_canvas_idx(di_buf->di_buf_dup_p[1], di_post_buf1_canvas_idx[di_post_stru.canvas_id], di_post_mtnprd_canvas_idx[di_post_stru.canvas_id]);
@@ -4593,7 +4593,7 @@ static int de_post_process_prog(void* arg, unsigned zoom_start_x_lines,
 	    		hold_line,
 	    		post_urgent
 	    	);
-	    else 
+	    else
 	      di_post_switch_buffer_pd (
 	    		&di_post_stru.di_buf0_mif,
 	    		&di_post_stru.di_buf1_mif,
@@ -4613,7 +4613,7 @@ static int de_post_process_prog(void* arg, unsigned zoom_start_x_lines,
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV)
     di_post_read_reverse_irq(overturn);
 #endif
-	  
+
     if(di_post_stru.update_post_reg_flag>0)
 	    di_post_stru.update_post_reg_flag--;
     return 0;
@@ -4642,7 +4642,7 @@ static void recycle_vframe_type_post(di_buf_t* di_buf)
             recovery_log_reason = 15;
         }
         recovery_flag++;
-        return;    
+        return;
     }
     if( di_buf->process_fun_index == PROCESS_FUN_PD
         || di_buf->process_fun_index == PROCESS_FUN_DI
@@ -4888,7 +4888,7 @@ static int pulldown_process(di_buf_t* di_buf, int buffer_count)
     }
     return pulldown_mode_ret;
 }
-    
+
 static void force_bob_vframe(di_buf_t* di_buf)
 {
 #ifdef FORCE_BOB_SUPPORT
@@ -4919,7 +4919,7 @@ static void force_bob_vframe(di_buf_t* di_buf)
             && ((force_bob_flag&1)==0)) ||
        (((di_buf->di_buf_dup_p[1]->vframe->type & VIDTYPE_TYPEMASK)==VIDTYPE_INTERLACE_BOTTOM)
             && ((force_bob_flag&2)==0))) {
-        
+
         queue_in(di_buf, QUEUE_TMP);
         recycle_vframe_type_post(di_buf);
 #ifdef DI_DEBUG
@@ -4929,7 +4929,7 @@ static void force_bob_vframe(di_buf_t* di_buf)
         queue_in(di_buf, QUEUE_POST_READY);
     }
     di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-#endif        
+#endif
 }
 
 static int process_post_vframe(void)
@@ -4956,7 +4956,7 @@ static int process_post_vframe(void)
         ready_di_buf = get_di_buf_head(QUEUE_PRE_READY);
         if((ready_di_buf == NULL)||(ready_di_buf->vframe == NULL)){
 #ifdef DI_DEBUG
-            printk("%s:Error1\n", __func__);    
+            printk("%s:Error1\n", __func__);
 #endif
             if(recovery_flag==0){
                 recovery_log_reason = 16;
@@ -4970,8 +4970,8 @@ static int process_post_vframe(void)
             queue_for_each_entry(p, ptmp, QUEUE_PRE_READY, list) {
                 //if(p->post_proc_flag == 0){
                 if(p->type == VFRAME_TYPE_IN){
-                    ready_di_buf->post_proc_flag = -1; 
-                    ready_di_buf->new_format_flag = 1;   
+                    ready_di_buf->post_proc_flag = -1;
+                    ready_di_buf->new_format_flag = 1;
                 }
                 i++;
                 if(i>2)break;
@@ -5002,7 +5002,7 @@ static int process_post_vframe(void)
                         recovery_log_reason = 18;
                     }
                     recovery_flag++;
-                    return 0;    
+                    return 0;
                 }
 
                 memcpy(di_buf->vframe, di_buf->di_buf_dup_p[1]->vframe, sizeof(vframe_t));
@@ -5016,7 +5016,7 @@ static int process_post_vframe(void)
                     di_buf->dp_buf_adr = 0;
                     di_buf->dp_buf_size = 0;
                 }
-#endif                
+#endif
                 if(di_buf->di_buf_dup_p[1]->post_proc_flag == 3){//dummy, not for display
                     di_buf->di_buf[0] = di_buf->di_buf_dup_p[0];
                     di_buf->di_buf[1] = NULL;
@@ -5062,7 +5062,7 @@ static int process_post_vframe(void)
                         else{
                             di_buf->vframe->early_process_fun = do_nothing_fun;
                         }
-                        
+
                         if(di_buf->di_buf_dup_p[1]->type == VFRAME_TYPE_IN){ /* next will be bypass */
                             di_buf->vframe->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_422 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
                             di_buf->vframe->height >>= 1;
@@ -5084,7 +5084,7 @@ static int process_post_vframe(void)
                         di_buf->di_buf[0] = di_buf->di_buf_dup_p[0];
                         di_buf->di_buf[1] = NULL;
                         queue_out(di_buf->di_buf[0]);
-    
+
                         di_lock_irqfiq_save(irq_flag2, fiq_flag);
                         if((frame_count<start_frame_drop_count)||
                             (di_buf->di_buf_dup_p[0]->throw_flag)||(di_buf->di_buf_dup_p[1]->throw_flag)||
@@ -5122,16 +5122,16 @@ static int process_post_vframe(void)
             if(is_progressive(ready_di_buf->vframe)||
                 ready_di_buf->type == VFRAME_TYPE_IN ||
                 ready_di_buf->post_proc_flag <0 ||
-                bypass_post_state 
+                bypass_post_state
                 ){
                 int vframe_process_count = 1;
 #ifdef DET3D
-                int dual_vframe_flag = 0;                
+                int dual_vframe_flag = 0;
                 if((di_pre_stru.vframe_interleave_flag && ready_di_buf->left_right)||(bypass_post&0x100)){
                     dual_vframe_flag = 1;
                     vframe_process_count = 2;
                 }
-#endif                
+#endif
                 if(skip_top_bot && (!is_progressive(ready_di_buf->vframe))){
                     vframe_process_count = 2;
                 }
@@ -5146,7 +5146,7 @@ static int process_post_vframe(void)
                     }
                     queue_out(di_buf);
                     di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-    
+
                     i = 0;
                     queue_for_each_entry(p, ptmp, QUEUE_PRE_READY, list) {
                         di_buf->di_buf_dup_p[i++] = p;
@@ -5161,21 +5161,21 @@ static int process_post_vframe(void)
                             recovery_log_reason = 22;
                         }
                         recovery_flag++;
-                        return 0;    
+                        return 0;
                     }
 
                     di_buf_i = di_buf->di_buf_dup_p[0];
                     if(!is_progressive(ready_di_buf->vframe)){
                         if(skip_top_bot == 1){
-    	    		                di_buf_i = (di_buf->di_buf_dup_p[1]->vframe->type & VIDTYPE_TYPEMASK)==VIDTYPE_INTERLACE_TOP 
+    	    		                di_buf_i = (di_buf->di_buf_dup_p[1]->vframe->type & VIDTYPE_TYPEMASK)==VIDTYPE_INTERLACE_TOP
     	    		                        ? di_buf->di_buf_dup_p[1] : di_buf->di_buf_dup_p[0];
                         }
                         else if(skip_top_bot == 2){
-    	    		                di_buf_i = (di_buf->di_buf_dup_p[1]->vframe->type & VIDTYPE_TYPEMASK)==VIDTYPE_INTERLACE_BOTTOM 
+    	    		                di_buf_i = (di_buf->di_buf_dup_p[1]->vframe->type & VIDTYPE_TYPEMASK)==VIDTYPE_INTERLACE_BOTTOM
     	    		                        ? di_buf->di_buf_dup_p[1] : di_buf->di_buf_dup_p[0];
                         }
                     }
-    
+
                     memcpy(di_buf->vframe, di_buf_i->vframe, sizeof(vframe_t));
                     di_buf->vframe->private_data = di_buf;
 #ifdef D2D3_SUPPORT
@@ -5187,8 +5187,8 @@ static int process_post_vframe(void)
                         di_buf->dp_buf_adr = ready_di_buf->dp_buf_adr;
                         di_buf->dp_buf_size = ready_di_buf->dp_buf_size;
                     }
-#endif                
-    
+#endif
+
                     if(frame_packing_mode == 1){
 #if defined(CONFIG_ARCH_MESON2)
                         if(di_buf->vframe->trans_fmt == TVIN_TFMT_3D_FP){
@@ -5222,11 +5222,11 @@ static int process_post_vframe(void)
                     queue_out(ready_di_buf);
 
 #ifdef DET3D
-                    if(dual_vframe_flag){                    
+                    if(dual_vframe_flag){
                         di_buf->di_buf[1] = di_buf->di_buf_dup_p[1];
                         queue_out(di_buf->di_buf[1]);
                     }
-#endif    
+#endif
                     di_lock_irqfiq_save(irq_flag2, fiq_flag);
                     if((frame_count<start_frame_drop_count)||
                         (di_buf->di_buf[0]->throw_flag)){
@@ -5240,7 +5240,7 @@ static int process_post_vframe(void)
                     }
                     frame_count++;
                     di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-    
+
 #ifdef DI_DEBUG
                     di_print("%s <prog by frame>: ", __func__);
 #endif
@@ -5274,7 +5274,7 @@ static int process_post_vframe(void)
                         recovery_log_reason = 21;
                     }
                     recovery_flag++;
-                    return 0;    
+                    return 0;
                 }
 
                 memcpy(di_buf->vframe, di_buf->di_buf_dup_p[0]->vframe, sizeof(vframe_t));
@@ -5288,7 +5288,7 @@ static int process_post_vframe(void)
                     di_buf->dp_buf_adr = 0;
                     di_buf->dp_buf_size = 0;
                 }
-#endif                
+#endif
 		/*separate one progressive frame as two interlace fields*/
                 if(prog_tb_field_proc_type == 1){
 					//do weave by di post
@@ -5397,7 +5397,7 @@ static void di_unreg_process(void)
             //printk("===unreg_req_flag\n");
 #ifdef RUN_REG_IN_IRQ
             if(init_flag){
-                init_flag = 0;                
+                init_flag = 0;
                 vf_unreg_provider(&di_vf_prov);
                 di_pre_stru.unreg_req_flag2 = 1;
                 trigger_pre_di_process('u');
@@ -5407,11 +5407,11 @@ static void di_unreg_process(void)
                 di_pre_stru.disable_req_flag = 0;
                 recovery_flag = 0;
                 di_pre_stru.unreg_req_flag = 0;
-                di_pre_stru.unreg_req_flag2 = 0;            
+                di_pre_stru.unreg_req_flag2 = 0;
             }
 #else
 /* !RUN_REG_IN_IRQ*/
-            
+
             if(di_pre_stru.force_unreg_req_flag||di_pre_stru.disable_req_flag){
 #ifdef DI_DEBUG
                 di_print("%s: force_unreg\n", __func__);
@@ -5420,7 +5420,7 @@ static void di_unreg_process(void)
                 goto unreg;
             }
             else{
-unreg:                
+unreg:
                 if(init_flag){
                 init_flag = 0;
                 di_lock_irqfiq_save(irq_flag2, fiq_flag);
@@ -5446,10 +5446,10 @@ unreg:
             }
             di_pre_stru.unreg_req_flag = 0;
             di_pre_stru.unreg_req_flag2 = 0;
-            
-#endif            
+
+#endif
         }
-    
+
 
 }
 
@@ -5505,7 +5505,7 @@ static void di_reg_process(void)
         }
         if(pre_run_flag == DI_RUN_FLAG_STEP)
             pre_run_flag = DI_RUN_FLAG_STEP_DONE;
-        
+
         vframe = vf_peek(VFM_NAME);
 
         if(vframe){
@@ -5576,7 +5576,7 @@ static int dynamic_bypass_process(void)
 	                post_ready_empty_count++;
                     }
                     else{
-		                bypass_dynamic_flag = bypass_dynamic;	
+		                bypass_dynamic_flag = bypass_dynamic;
                         post_ready_empty_count = 30;
                     }
                 }
@@ -5591,7 +5591,7 @@ static int dynamic_bypass_process(void)
                 }
                 else post_ready_empty_count = 60;
             }
-        }   
+        }
 }
 
 
@@ -5606,10 +5606,10 @@ static void di_process(void)
         if((init_flag)&&(recovery_flag == 0)&&(dump_state_flag == 0)){
             if(bypass_dynamic!=0){
 			    dynamic_bypass_process();
-            }                      
+            }
 #if (!(defined RUN_DI_PROCESS_IN_IRQ))||(defined ENABLE_SPIN_LOCK_ALWAYS)
             spin_lock_irqsave(&plist_lock, flags);
-#endif            
+#endif
             if(di_pre_stru.pre_de_busy == 0){
                 if(di_pre_stru.pre_de_process_done){
 #ifdef CHECK_DI_DONE
@@ -5617,7 +5617,7 @@ static void di_process(void)
                     unsigned int data32 = Rd(DI_INTR_CTRL); /*
                                                                 DI_INTR_CTRL[bit 0], NRWR_done, set by hardware when NRWR is done, clear by write 1 by code;
                                                                             [bit 1] MTNWR_done, set by hardware when MTNWR is done, clear by write 1 by code;
-                                                                these two bits have nothing to do with DI_INTR_CTRL[16](NRW irq mask, 0 to enable irq) 
+                                                                these two bits have nothing to do with DI_INTR_CTRL[16](NRW irq mask, 0 to enable irq)
                                                                     and DI_INTR_CTRL[17](MTN irq mask, 0 to enable irq).
                                                                     two interrupts are raised if both DI_INTR_CTRL[16] and DI_INTR_CTRL[17] are 0
                                                             */
@@ -5627,17 +5627,17 @@ static void di_process(void)
 #endif
                         pre_process_time = di_pre_stru.pre_de_busy_timer_count;
                         pre_de_done_buf_config();
-            
+
                         di_pre_stru.pre_de_process_done = 0;
                         di_pre_stru.pre_de_clear_flag = 0;
                         //Wr(DI_PRE_CTRL, 0x3 << 30|Rd(DI_PRE_CTRL) & 0x14); //disable, and reset
 #ifdef CHECK_DI_DONE
                     }
-#endif                        
+#endif
                 }
                 else if(di_pre_stru.pre_de_clear_flag==1){
                     di_lock_irqfiq_save(irq_flag2, fiq_flag);
-                    pre_de_done_buf_clear();    
+                    pre_de_done_buf_clear();
                     di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 
                     di_pre_stru.pre_de_process_done = 0;
@@ -5659,7 +5659,7 @@ static void di_process(void)
                	if(d2d3_enable){
                     vf_notify_receiver_by_name("d2d3",VFRAME_EVENT_PROVIDER_DPBUF_CONFIG, di_pre_stru.di_wr_buf->vframe);
                 }
-#endif               	
+#endif
                 pre_de_process();
             }
                 }
@@ -5672,7 +5672,7 @@ static void di_process(void)
 
 #if (!(defined RUN_DI_PROCESS_IN_IRQ))||(defined ENABLE_SPIN_LOCK_ALWAYS)
             spin_unlock_irqrestore(&plist_lock, flags);
-#endif            
+#endif
         }
 }
 
@@ -5722,7 +5722,7 @@ void di_timer_handle(struct work_struct *work)
     }
 #endif
 
-    //if(force_trig){    
+    //if(force_trig){
        force_trig_cnt++;
        trigger_pre_di_process('t');
     //}
@@ -5752,9 +5752,9 @@ static int di_task_handle(void *data)
             di_unreg_process();
             di_reg_process();
 #else
-            di_unreg_process();                        
+            di_unreg_process();
             if(di_pre_stru.reg_flag){
-                di_reg_process_2();                       
+                di_reg_process_2();
                 di_pre_stru.reg_flag = 0;
             }
 #endif
@@ -5762,7 +5762,7 @@ static int di_task_handle(void *data)
 #if (!(defined RUN_DI_PROCESS_IN_IRQ))&&(!(defined RUN_DI_PROCESS_IN_TIMER_IRQ))
             di_process();
             log_buffer_state("pro");
-#endif            
+#endif
         }
     }
 
@@ -5779,11 +5779,11 @@ static irqreturn_t timer_irq(int irq, void *dev_instance)
         di_pre_stru.pre_de_busy_timer_count++;
 
         if(pre_process_time_force){
-            if(di_pre_stru.pre_de_busy_timer_count >= pre_process_time_force){ 
+            if(di_pre_stru.pre_de_busy_timer_count >= pre_process_time_force){
                 di_pre_stru.pre_de_process_done = 1;
                 di_pre_stru.pre_de_busy = 0;
             }
-        }        
+        }
     }
 #endif
 
@@ -5818,11 +5818,11 @@ static int di_receiver_event_fun(int type, void* data, void* arg)
     }
     else if(type == VFRAME_EVENT_PROVIDER_UNREG){
 #ifdef DI_DEBUG
-        di_print("%s , is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);        
-#endif        
+        di_print("%s , is_bypass() %d trick_mode %d bypass_all %d\n", __func__, is_bypass(), trick_mode, bypass_all);
+#endif
         if((Rd(DI_IF1_GEN_REG)&0x1)==0){
             //post di is disabled, so can call vf_keep_current() to keep displayed vframe
-            //vf_keep_current(); 
+            //vf_keep_current();
         }
 #ifdef DI_DEBUG
         di_print("%s: vf_notify_receiver unreg\n", __func__);
@@ -5830,7 +5830,7 @@ static int di_receiver_event_fun(int type, void* data, void* arg)
         di_pre_stru.unreg_req_flag = 1;
         provider_vframe_level = 0;
         bypass_dynamic_flag = 0;
-        post_ready_empty_count = 0; 
+        post_ready_empty_count = 0;
 
         trigger_pre_di_process('n');
         while(di_pre_stru.unreg_req_flag){
@@ -5841,7 +5841,7 @@ static int di_receiver_event_fun(int type, void* data, void* arg)
         if(vdin_source_flag){
             Wr_reg_bits(VDIN_WR_CTRL, 0x3, 24, 3);
         }
-#endif        
+#endif
     }
     else if(type == VFRAME_EVENT_PROVIDER_RESET){
 #ifdef DI_DEBUG
@@ -5856,13 +5856,13 @@ static int di_receiver_event_fun(int type, void* data, void* arg)
 light_unreg:
         provider_vframe_level = 0;
         bypass_dynamic_flag = 0;
-        post_ready_empty_count = 0; 
+        post_ready_empty_count = 0;
 
        spin_lock_irqsave(&plist_lock, flags);
         for(i=0; i<MAX_IN_BUF_NUM; i++){
 #ifdef DI_DEBUG
             if(vframe_in[i]){
-                printk("DI:clear vframe_in[%d]\n", i);    
+                printk("DI:clear vframe_in[%d]\n", i);
             }
 #endif
             vframe_in[i] = NULL;
@@ -5876,15 +5876,15 @@ light_unreg:
 #endif
         provider_vframe_level = 0;
         bypass_dynamic_flag = 0;
-        post_ready_empty_count = 0; 
+        post_ready_empty_count = 0;
 
-        DisableVideoLayer(); //do not display garbage when 2d->3d or 3d->2d 
+        DisableVideoLayer(); //do not display garbage when 2d->3d or 3d->2d
        spin_lock_irqsave(&plist_lock, flags);
         for(i=0; i<MAX_IN_BUF_NUM; i++){
             if(vframe_in[i]){
                 vf_put(vframe_in[i], VFM_NAME);
 #ifdef DI_DEBUG
-                printk("DI:clear vframe_in[%d]\n", i);    
+                printk("DI:clear vframe_in[%d]\n", i);
 #endif
                 vf_put_flag = 1;
             }
@@ -5921,10 +5921,10 @@ light_unreg:
                 di_pre_stru.bypass_start_count = 0;
                 if((di_pre_stru.pre_de_busy!=0)&&(input2pre_miss_policy==1 && frame_count<30 )){
                     di_pre_stru.pre_de_clear_flag = 1;
-                    di_pre_stru.pre_de_busy = 0;  
+                    di_pre_stru.pre_de_busy = 0;
                     input2pre_buf_miss_count++;
                 }
-                
+
                 if(di_pre_stru.pre_de_busy==0){
                     Wr_reg_bits(VDIN_WR_CTRL, 0x5, 24, 3);
                     di_pre_stru.vdin2nr = 1;
@@ -5953,14 +5953,14 @@ light_unreg:
                 di_pre_stru.bypass_start_count = INPUT2PRE_2_BYPASS_SKIP_COUNT;
             }
         }
-#endif        
+#endif
     }
     else if(type == VFRAME_EVENT_PROVIDER_QUREY_STATE){
         int in_buf_num = 0;
         if(recovery_flag){
             return RECEIVER_INACTIVE;
         }
-        
+
         for(i=0; i<MAX_IN_BUF_NUM; i++){
             if(vframe_in[i]!=NULL){
                 in_buf_num++;
@@ -5989,7 +5989,7 @@ light_unreg:
         Wr_reg_bits(ISA_TIMER_MUX,0,4,2);// 1us
         Wr_reg_bits(ISA_TIMER_MUX,1,18,1);// enable timer c
         Wr(ISA_TIMERC, 1);
-#endif        
+#endif
         if(strncmp(provider_name, "vdin", 4)==0){
             vdin_source_flag = 1;
         }
@@ -6007,15 +6007,15 @@ light_unreg:
             di_post_stru.run_early_proc_fun_flag = 0;
             receiver_is_amvideo = 1;
         }
-#endif        
+#endif
     }
 #ifdef DET3D
     else if(type == VFRAME_EVENT_PROVIDER_SET_3D_VFRAME_INTERLEAVE){
         int flag = (int)data;
-        di_pre_stru.vframe_interleave_flag = flag;    
+        di_pre_stru.vframe_interleave_flag = flag;
     }
 #endif
-    
+
     return 0;
 }
 
@@ -6027,7 +6027,7 @@ static void fast_process(void)
         if(vf_peek(VFM_NAME)==NULL){
        	    return;
        	}
-				for(i=0; i<2; i++){            
+				for(i=0; i<2; i++){
             spin_lock_irqsave(&plist_lock, flags);
             if(di_pre_stru.pre_de_process_done){
                 pre_de_done_buf_config();
@@ -6049,7 +6049,7 @@ static void fast_process(void)
                	        if(d2d3_enable){
                             vf_notify_receiver_by_name("d2d3",VFRAME_EVENT_PROVIDER_DPBUF_CONFIG, di_pre_stru.di_wr_buf->vframe);
                         }
-#endif               	
+#endif
                         pre_de_process();
                     }
                 }
@@ -6061,7 +6061,7 @@ static void fast_process(void)
             spin_unlock_irqrestore(&plist_lock, flags);
 
        }
-        
+
    }
 }
 
@@ -6090,7 +6090,7 @@ static vframe_t *di_vf_peek(void* arg)
     }
     }
     else
-#endif        
+#endif
     {
     if(!queue_empty(QUEUE_POST_READY)){
        di_buf = get_di_buf_head(QUEUE_POST_READY);
@@ -6130,8 +6130,8 @@ static vframe_t *di_vf_get(void* arg)
             goto get_vframe;
         }
     }
-    else 
-#endif        
+    else
+#endif
     if (!queue_empty(QUEUE_POST_READY)){
 get_vframe:
         log_buffer_state("ge_");
@@ -6217,14 +6217,14 @@ static int di_event_cb(int type, void *data, void *private_data)
         di_pre_stru.force_unreg_req_flag = 1;
         provider_vframe_level = 0;
         bypass_dynamic_flag = 0;
-        post_ready_empty_count = 0; 
+        post_ready_empty_count = 0;
 
         trigger_pre_di_process('f');
         while(di_pre_stru.force_unreg_req_flag){
-            msleep(1);    
+            msleep(1);
         }
     }
-    return 0;        
+    return 0;
 }
 
 /*****************************
@@ -6274,7 +6274,7 @@ const static struct file_operations di_fops = {
     .release  = di_release,
 #if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
     .ioctl    = di_ioctl,
-#endif    
+#endif
 };
 
 static int di_probe(struct platform_device *pdev)
@@ -6388,13 +6388,13 @@ static int di_probe(struct platform_device *pdev)
     Wr(SYS_CPU_0_IRQ_IN1_INTR_MASK, Rd(SYS_CPU_0_IRQ_IN1_INTR_MASK)|(1<<14));
 #else
     Wr(A9_0_IRQ_IN1_INTR_MASK, Rd(A9_0_IRQ_IN1_INTR_MASK)|(1<<14));
-#endif    
+#endif
 #endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
     sema_init(&di_sema,1);
 #else
     init_MUTEX(&di_sema);
-#endif    
+#endif
     di_sema_init_flag=1;
 #ifdef FIQ_VSYNC
 	fiq_handle_item.handle=di_vf_put_isr;
@@ -6475,7 +6475,7 @@ static int di_suspend(struct platform_device *pdev,pm_message_t state)
 {
 #if (defined RUN_DI_PROCESS_IN_IRQ)&&(!(defined FIQ_VSYNC))
     Wr_reg_bits(ISA_TIMER_MUX,0,18,1);// disable timer c
-#endif    
+#endif
     pr_info("di: di_suspend\n");
     return 0;
 }
@@ -6487,7 +6487,7 @@ static int di_resume(struct platform_device *pdev)
     Wr_reg_bits(ISA_TIMER_MUX,0,4,2);// 1us
     Wr_reg_bits(ISA_TIMER_MUX,1,18,1);// enable timer c
     Wr(ISA_TIMERC, 1);
-#endif        
+#endif
     pr_info("di_hdmirx: resume module\n");
     return 0;
 }
@@ -6513,7 +6513,7 @@ static struct platform_driver di_driver = {
     .driver     = {
         .name   = DEVICE_NAME,
 		    .owner	= THIS_MODULE,
-        .of_match_table = amlogic_deinterlace_dt_match,	
+        .of_match_table = amlogic_deinterlace_dt_match,
     }
 };
 
diff --git a/drivers/amlogic/deinterlace/deinterlace_hw.c b/drivers/amlogic/deinterlace/deinterlace_hw.c
index 5811f1c3da44..65888277f153 100755
--- a/drivers/amlogic/deinterlace/deinterlace_hw.c
+++ b/drivers/amlogic/deinterlace/deinterlace_hw.c
@@ -5,9 +5,9 @@
 #include <linux/module.h>
 
 #include <mach/am_regs.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
 //#include <linux/iw7023.h>
 #include "deinterlace.h"
 #ifdef DET3D
@@ -97,25 +97,25 @@ static unsigned int det3d_cfg = 0;
 static void init_pd_para(void)
 {
     int i;
-    pd_detect_threshold_t field_pd_th_tmp = 
+    pd_detect_threshold_t field_pd_th_tmp =
         {.frame_diff_chg_th = 2,
          .frame_diff_num_chg_th = 50,
          .field_diff_chg_th = 2,
-         .field_diff_num_chg_th = 2, 
+         .field_diff_num_chg_th = 2,
          .frame_diff_skew_th = 5,  /*10*/
          .frame_diff_num_skew_th = 5,  /*10*/
          .field_diff_num_th = 0
-        }; 
+        };
     /* win, only check diff_num */
-    pd_detect_threshold_t win_pd_th_tmp = 
+    pd_detect_threshold_t win_pd_th_tmp =
         {.frame_diff_chg_th = 0,
          .frame_diff_num_chg_th = 50,
          .field_diff_chg_th = 0,
-         .field_diff_num_chg_th = 2, 
+         .field_diff_num_chg_th = 2,
          .frame_diff_skew_th = 0,
          .frame_diff_num_skew_th = 0,
          .field_diff_num_th = 5
-        }; 
+        };
     /**/
     field_32lvl = 16;
     field_22lvl = 256;
@@ -136,9 +136,9 @@ static void init_pd_para(void)
 	win_pd_th[i].field_diff_num_th= win_pd_th_tmp.field_diff_num_th <<1;
 	}
     }
-    
-} 
-    
+
+}
+
 void reset_di_para(void)
 {
   	int nr_zone_0 = 4, nr_zone_1 = 8, nr_zone_2 = 12;
@@ -373,7 +373,7 @@ void enable_di_pre_aml (
    DI_SIM_MIF_t    *di_contp2rd_mif,
    DI_SIM_MIF_t    *di_contprd_mif,
    DI_SIM_MIF_t    *di_contwr_mif,
-#endif   
+#endif
    int nr_en, int mtn_en, int pd32_check_en, int pd22_check_en, int hist_check_en,
    int pre_field_num, int pre_viu_link, int hold_line, int urgent)
 {
@@ -403,7 +403,7 @@ void enable_di_pre_aml (
      	Wr(DI_NRWR_CTRL, di_nrwr_mif->canvas_num |                                  // canvas index
                        (urgent<<16));     						        // urgent bit 16
 #else
-     	Wr(DI_NRWR_CTRL, di_nrwr_mif->canvas_num );     						// canvas index. 
+     	Wr(DI_NRWR_CTRL, di_nrwr_mif->canvas_num );     						// canvas index.
      	                                                                    // urgent bit 8
 #endif
 #if !defined(CONFIG_ARCH_MESON)
@@ -440,9 +440,9 @@ void enable_di_pre_aml (
 #else
                           (1 << 16)                             |          // urgent
 #endif
-                           di_contp2rd_mif->canvas_num );                    // current field mtn canvas index.        	
+                           di_contp2rd_mif->canvas_num );                    // current field mtn canvas index.
 
-#endif       	
+#endif
        	Wr(DI_MTNWR_X, (di_mtnwr_mif->start_x <<16) | (di_mtnwr_mif->end_x));   	// start_x 0 end_x 719.
        	Wr(DI_MTNWR_Y, (di_mtnwr_mif->start_y <<16) | (di_mtnwr_mif->end_y));   	// start_y 0 end_y 239.
        	Wr(DI_MTNWR_CTRL, di_mtnwr_mif->canvas_num |  								// canvas index.
@@ -460,7 +460,7 @@ void enable_di_pre_aml (
     }
 
 #ifdef NEW_DI
-        Wr(NR2_FRM_SIZE,((di_nrwr_mif->end_y - di_nrwr_mif->start_y + 1) <<16) | 
+        Wr(NR2_FRM_SIZE,((di_nrwr_mif->end_y - di_nrwr_mif->start_y + 1) <<16) |
                                           (di_nrwr_mif->end_x - di_nrwr_mif->start_x + 1));
         Wr_reg_bits(NR2_SW_EN,nr2_en,4,1);
 #endif
@@ -486,7 +486,7 @@ void enable_di_pre_aml (
                     (pre_field_num << 29) |        					// pre field number.
                     (0x1 << 30 )      								// pre soft rst, pre frame rst.
                    );
-#else 
+#else
   	Wr(DI_PRE_CTRL, nr_en |        						// NR enable
                     (mtn_en << 1 ) |        						// MTN_EN
                     (pd32_check_en << 2 ) |        					// check 3:2 pulldown
@@ -675,7 +675,7 @@ static void set_di_inp_mif ( DI_MIF_t *mif, int urgent,int hold_line)
     else{
         Wr_reg_bits(DI_INP_GEN_REG2, 0, 0, 1);
     }
-#endif     
+#endif
 
     // ----------------------
     // Canvas
@@ -1060,7 +1060,7 @@ static void set_di_if1_mif ( DI_MIF_t *mif, int urgent, int hold_line)
       	    chroma0_rpt_loop_pat = vpat[di_vscale_skip_count]<<4; //0x00;
       	}
       	else
-#endif      	    
+#endif
       	{
           	luma0_rpt_loop_start = 0;
           	luma0_rpt_loop_end = 0;
@@ -1073,11 +1073,11 @@ static void set_di_if1_mif ( DI_MIF_t *mif, int urgent, int hold_line)
 
 #ifdef DI_POST_SKIP_LINE
     if(di_vscale_skip_mode == 2){ //force pat, for debugging
-        luma0_rpt_loop_start = l_luma0_rpt_loop_start;   
-        luma0_rpt_loop_end = l_luma0_rpt_loop_end;     
-        chroma0_rpt_loop_start = l_chroma0_rpt_loop_start; 
-        chroma0_rpt_loop_end = l_chroma0_rpt_loop_end;   
-        luma0_rpt_loop_pat = l_luma0_rpt_loop_pat;  
+        luma0_rpt_loop_start = l_luma0_rpt_loop_start;
+        luma0_rpt_loop_end = l_luma0_rpt_loop_end;
+        chroma0_rpt_loop_start = l_chroma0_rpt_loop_start;
+        chroma0_rpt_loop_end = l_chroma0_rpt_loop_end;
+        luma0_rpt_loop_pat = l_luma0_rpt_loop_pat;
         chroma0_rpt_loop_pat = l_chroma0_rpt_loop_pat;
     }
 #endif
@@ -1090,7 +1090,7 @@ static void set_di_if1_mif ( DI_MIF_t *mif, int urgent, int hold_line)
     // General register
     // ----------------------
 
-    VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, (1 << 29)    |     //reset on go field 
+    VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, (1 << 29)    |     //reset on go field
                                 (urgent << 28)      		|   // urgent
                                 (urgent << 27)        		|  	// luma urgent
                                 (1 << 25)       			| 	// no dummy data.
@@ -1281,7 +1281,7 @@ static void set_di_chan2_mif ( DI_MIF_t *mif, int urgent, int hold_line)
                         0 );                 										// hz repeat.
     }
 #endif
-    
+
 }
 
 static void set_di_if0_mif ( DI_MIF_t *mif, int urgent, int hold_line)
@@ -1338,7 +1338,7 @@ static void set_di_if0_mif ( DI_MIF_t *mif, int urgent, int hold_line)
           	chroma0_rpt_loop_pat = vpat[di_vscale_skip_count]<<4; //0x00;
       	}
       	else
-#endif      	    
+#endif
         {
           	chro_rpt_lastl_ctrl =0;
           	luma0_rpt_loop_start = 0;
@@ -1349,14 +1349,14 @@ static void set_di_if0_mif ( DI_MIF_t *mif, int urgent, int hold_line)
       	    chroma0_rpt_loop_pat = 0x00;
         }
     }
-    
+
 #ifdef DI_POST_SKIP_LINE
     if(di_vscale_skip_mode == 2){ //force pat, for debugging
-        luma0_rpt_loop_start = l_luma0_rpt_loop_start;   
-        luma0_rpt_loop_end = l_luma0_rpt_loop_end;     
-        chroma0_rpt_loop_start = l_chroma0_rpt_loop_start; 
-        chroma0_rpt_loop_end = l_chroma0_rpt_loop_end;   
-        luma0_rpt_loop_pat = l_luma0_rpt_loop_pat;  
+        luma0_rpt_loop_start = l_luma0_rpt_loop_start;
+        luma0_rpt_loop_end = l_luma0_rpt_loop_end;
+        chroma0_rpt_loop_start = l_chroma0_rpt_loop_start;
+        chroma0_rpt_loop_end = l_chroma0_rpt_loop_end;
+        luma0_rpt_loop_pat = l_luma0_rpt_loop_pat;
         chroma0_rpt_loop_pat = l_chroma0_rpt_loop_pat;
     }
 #endif
@@ -1368,7 +1368,7 @@ static void set_di_if0_mif ( DI_MIF_t *mif, int urgent, int hold_line)
     // General register
     // ----------------------
 
-    VSYNC_WR_MPEG_REG(VD1_IF0_GEN_REG, (1 << 29) |              //reset on go field 
+    VSYNC_WR_MPEG_REG(VD1_IF0_GEN_REG, (1 << 29) |              //reset on go field
                                 (urgent << 28)      	|   	// urgent
                                 (urgent << 27)          	|  		// luma urgent
                                 (1 << 25)					| 		// no dummy data.
@@ -1474,7 +1474,7 @@ void initial_di_pre_aml ( int hsize_pre, int vsize_pre, int hold_line )
                     (1 << 2 ) |        			// check 3:2 pulldown
 #else
                     (0 << 2 ) |        			// check 3:2 pulldown
-#endif                 
+#endif
 					(0 << 3 ) |        			// check 2:2 pulldown
                     (0 << 4 ) |        			// 2:2 check mid pixel come from next field after MTN.
                     (0 << 5 ) |        			// hist check enable
@@ -1561,11 +1561,11 @@ void di_post_switch_buffer (
    	// motion for current display field.
     if ( blend_mtn_en )
     {
-        
+
         VSYNC_WR_MPEG_REG(DI_MTNRD_CTRL, (di_mtnprd_mif->canvas_num <<8 )|//mtnp canvas index.
 					 (urgent << 16) |// urgent
 					 di_mtncrd_mif->canvas_num ); // current field mtn canvas index.
-		              									
+
     }
 
     if ( di_ddr_en )
@@ -1587,7 +1587,7 @@ void di_post_switch_buffer (
                               (blend_mode << 20)    														// motion adaptive blend.
                );
 #else
- 
+
 	//VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&(~(3<<20))&~(0xff))|(blend_mode<<20)|kdeint);
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&0xffffff00)| kdeint0);
     //if (di_pre_stru.di_wr_buf->mtn_info[4] > di_pre_stru.di_wr_buf->mtn_info[3] & di_pre_stru.di_wr_buf->mtn_info[3] > di_pre_stru.di_wr_buf->mtn_info[2])
@@ -1601,7 +1601,7 @@ void di_post_switch_buffer (
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL2,   (blend_ctrl2_black_level<< 8 ) |     (blend_ctrl2_mtn_no_mov)  );
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
 //    VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)&(~(1<<31)));
-#endif    
+#endif
 #endif
    	}
 
@@ -1677,7 +1677,7 @@ void enable_di_post_2 (
                               (blend_mode << 20)    														// motion adaptive blend.
                );
 #else
- 
+
 	//VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&(~(3<<20))&~(0xff))|(blend_mode<<20)|kdeint);
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&0xffffff00)| kdeint0);
     //if (di_pre_stru.di_wr_buf->mtn_info[4] > di_pre_stru.di_wr_buf->mtn_info[3] & di_pre_stru.di_wr_buf->mtn_info[3] > di_pre_stru.di_wr_buf->mtn_info[2])
@@ -1691,7 +1691,7 @@ void enable_di_post_2 (
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL2,   (blend_ctrl2_black_level<< 8 ) |     (blend_ctrl2_mtn_no_mov)  );
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
 //    VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)&(~(1<<31)));
-#endif    
+#endif
 #endif
    	}
 
@@ -1713,7 +1713,7 @@ void enable_di_post_2 (
                       (post_field_num << 29) |        				// post field number.
                       (0x1 << 30 )       							// post soft rst  post frame rst.
         );
-#else 
+#else
    	VSYNC_WR_MPEG_REG(DI_POST_CTRL, ((ei_en | blend_en) << 0 ) | 		// line buffer 0 enable
                       (0 << 1)  |        							// line buffer 1 enable
                       (ei_en << 2) |        						// ei  enable
@@ -1907,7 +1907,7 @@ void enable_di_post_pd(
                    (post_field_num << 29) |                      // post field number.
                    (0x1 << 30)                                   // post soft rst  post frame rst.
                   );
-#else 
+#else
     VSYNC_WR_MPEG_REG(DI_POST_CTRL, ((ei_en | blend_en) << 0) |        // line buffer 0 enable
                    (0 << 1)  |                                   // line buffer 1 enable
                    (ei_en << 2) |                                // ei  enable
@@ -1948,7 +1948,7 @@ void enable_di_mode_check_2( int win0_start_x, int win0_end_x, int win0_start_y,
     pd_win_prop[2].pixels_num = (win2_end_x-win2_start_x)*(win2_end_y-win2_start_y);
     pd_win_prop[3].pixels_num = (win3_end_x-win3_start_x)*(win3_end_y-win3_start_y);
     pd_win_prop[4].pixels_num = (win4_end_x-win4_start_x)*(win4_end_y-win4_start_y);
-    
+
     Wr(DI_MC_REG0_X, (win0_start_x <<16) |     		// start_x
                        win0_end_x );       						// end_x
     Wr(DI_MC_REG0_Y, (win0_start_y <<16) |     		// start_y
@@ -1988,7 +1988,7 @@ void enable_di_mode_check_2( int win0_start_x, int win0_end_x, int win0_start_y,
 }
 
 static int fdn[5] = {0};
-void read_pulldown_info(pulldown_detect_info_t* field_pd_info, 
+void read_pulldown_info(pulldown_detect_info_t* field_pd_info,
                         pulldown_detect_info_t* win_pd_info)
 {
     int i;
@@ -2034,21 +2034,21 @@ void read_pulldown_info(pulldown_detect_info_t* field_pd_info,
         memset(&(win_pd_info[i]), 0, sizeof(pulldown_detect_info_t));
     }
     for(i = 0; i< MAX_WIN_NUM; i++){
-        win_pd_info[i].frame_diff = Rd(DI_INFO_DATA);    
+        win_pd_info[i].frame_diff = Rd(DI_INFO_DATA);
     }
     for(i = 0; i< MAX_WIN_NUM; i++){
-        win_pd_info[i].field_diff = Rd(DI_INFO_DATA);    
+        win_pd_info[i].field_diff = Rd(DI_INFO_DATA);
     }
     for(i = 0; i< MAX_WIN_NUM; i++){
         tmp = Rd(DI_INFO_DATA); /* luma */
     }
     for(i = 0; i< MAX_WIN_NUM; i++){
-        win_pd_info[i].frame_diff_num = Rd(DI_INFO_DATA)&0xffffff;    
+        win_pd_info[i].frame_diff_num = Rd(DI_INFO_DATA)&0xffffff;
     }
     for(i = 0; i< MAX_WIN_NUM; i++){
-        win_pd_info[i].field_diff_num = (Rd(DI_INFO_DATA)&0xfffff)<<4;    
+        win_pd_info[i].field_diff_num = (Rd(DI_INFO_DATA)&0xfffff)<<4;
     }
-}                            
+}
 
 
 void read_mtn_info(unsigned long* mtn_info, unsigned long * reg_mtn_info)
@@ -2068,13 +2068,13 @@ void read_mtn_info(unsigned long* mtn_info, unsigned long * reg_mtn_info)
 	reg_mtn_info[2] = mtn_info[2];
 	reg_mtn_info[3] = mtn_info[3];
 	reg_mtn_info[4] = mtn_info[4];
-	
+
     Wr(DI_INFO_ADDR, 0 );
     reg_mtn_info[5] = Rd(DI_INFO_DATA);
 	reg_mtn_info[6] = Rd(DI_INFO_DATA);
 
-	
-	
+
+
     return;
 }
 void di_post_read_reverse(bool reverse)
@@ -2082,7 +2082,7 @@ void di_post_read_reverse(bool reverse)
     if(reverse) {
         Wr_reg_bits(DI_IF1_GEN_REG2,    3, 2, 2);
         Wr_reg_bits(VD1_IF0_GEN_REG2, 0xf, 2, 4);
-        Wr_reg_bits(VD2_IF0_GEN_REG2, 0xf, 2, 4); 
+        Wr_reg_bits(VD2_IF0_GEN_REG2, 0xf, 2, 4);
     } else {
         Wr_reg_bits(DI_IF1_GEN_REG2,  0, 2, 2);
 	Wr_reg_bits(VD1_IF0_GEN_REG2, 0, 2, 4);
@@ -2094,8 +2094,8 @@ void di_post_read_reverse_irq(bool reverse)
     if(reverse) {
         VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,    3, 2, 2);
         VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0xf, 2, 4);
-        VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0xf, 2, 4); 
-	VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0xf, 17,4); 			   
+        VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0xf, 2, 4);
+	VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0xf, 17,4);
     } else {
         VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,  0, 2, 2);
 	VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0, 2, 4);
diff --git a/drivers/amlogic/deinterlace/deinterlace_pd.c b/drivers/amlogic/deinterlace/deinterlace_pd.c
index 7754167b44da..ab61f5f8f094 100755
--- a/drivers/amlogic/deinterlace/deinterlace_pd.c
+++ b/drivers/amlogic/deinterlace/deinterlace_pd.c
@@ -39,11 +39,11 @@
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
-#include <linux/osd/osd_dev.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/canvas.h>
 #include "deinterlace.h"
 #include "deinterlace_module.h"
 /*for hisense patch*/
@@ -102,12 +102,12 @@ void reset_pulldown_state(void)
 void cal_pd_parameters(pulldown_detect_info_t* cur_info, pulldown_detect_info_t* pre_info, pulldown_detect_info_t* next_info,
                     pd_detect_threshold_t* pd_th)
 {
-    cur_info->frame_diff_skew = 
-        cur_info->frame_diff>pre_info->frame_diff ? cur_info->frame_diff-pre_info->frame_diff : 
-            pre_info->frame_diff-cur_info->frame_diff;  
-    cur_info->frame_diff_num_skew = 
+    cur_info->frame_diff_skew =
+        cur_info->frame_diff>pre_info->frame_diff ? cur_info->frame_diff-pre_info->frame_diff :
+            pre_info->frame_diff-cur_info->frame_diff;
+    cur_info->frame_diff_num_skew =
         cur_info->frame_diff_num>pre_info->frame_diff_num ? cur_info->frame_diff_num-pre_info->frame_diff_num :
-            pre_info->frame_diff_num-cur_info->frame_diff_num;  
+            pre_info->frame_diff_num-cur_info->frame_diff_num;
 
     cur_info->field_diff_by_pre = (cur_info->field_diff==0)?0xff:pre_info->field_diff/cur_info->field_diff;
     cur_info->field_diff_by_next = (cur_info->field_diff==0)?0xff:next_info->field_diff/cur_info->field_diff;
@@ -117,16 +117,16 @@ void cal_pd_parameters(pulldown_detect_info_t* cur_info, pulldown_detect_info_t*
     cur_info->frame_diff_num_by_pre = (cur_info->frame_diff_num==0)?0xff:pre_info->frame_diff_num/cur_info->frame_diff_num;
     cur_info->frame_diff_skew_ratio = (cur_info->frame_diff_skew==0)?0xff:cur_info->frame_diff/cur_info->frame_diff_skew;
     cur_info->frame_diff_num_skew_ratio = (cur_info->frame_diff_num_skew==0)?0xff:cur_info->frame_diff_num/cur_info->frame_diff_num_skew;
-    
-    if( cur_info->field_diff_by_pre         > 0xff) cur_info->field_diff_by_pre         = 0xff; 
-    if( cur_info->field_diff_by_next        > 0xff) cur_info->field_diff_by_next        = 0xff; 
-    if( cur_info->field_diff_num_by_pre     > 0xff) cur_info->field_diff_num_by_pre     = 0xff; 
-    if( cur_info->field_diff_num_by_next    > 0xff) cur_info->field_diff_num_by_next    = 0xff; 
-    if( cur_info->frame_diff_by_pre         > 0xff) cur_info->frame_diff_by_pre         = 0xff; 
-    if( cur_info->frame_diff_num_by_pre     > 0xff) cur_info->frame_diff_num_by_pre     = 0xff; 
-    if( cur_info->frame_diff_skew_ratio     > 0xff) cur_info->frame_diff_skew_ratio     = 0xff; 
-    if( cur_info->frame_diff_num_skew_ratio > 0xff) cur_info->frame_diff_num_skew_ratio = 0xff;  
-        
+
+    if( cur_info->field_diff_by_pre         > 0xff) cur_info->field_diff_by_pre         = 0xff;
+    if( cur_info->field_diff_by_next        > 0xff) cur_info->field_diff_by_next        = 0xff;
+    if( cur_info->field_diff_num_by_pre     > 0xff) cur_info->field_diff_num_by_pre     = 0xff;
+    if( cur_info->field_diff_num_by_next    > 0xff) cur_info->field_diff_num_by_next    = 0xff;
+    if( cur_info->frame_diff_by_pre         > 0xff) cur_info->frame_diff_by_pre         = 0xff;
+    if( cur_info->frame_diff_num_by_pre     > 0xff) cur_info->frame_diff_num_by_pre     = 0xff;
+    if( cur_info->frame_diff_skew_ratio     > 0xff) cur_info->frame_diff_skew_ratio     = 0xff;
+    if( cur_info->frame_diff_num_skew_ratio > 0xff) cur_info->frame_diff_num_skew_ratio = 0xff;
+
     cur_info->field_diff_pattern = pre_info->field_diff_pattern<<1;
     cur_info->field_diff_num_pattern = pre_info->field_diff_num_pattern<<1;
     cur_info->frame_diff_pattern = pre_info->frame_diff_pattern<<1;
@@ -147,7 +147,7 @@ void cal_pd_parameters(pulldown_detect_info_t* cur_info, pulldown_detect_info_t*
     if( cur_info->frame_diff_num_by_pre > pd_th->frame_diff_num_chg_th){
         cur_info->frame_diff_num_pattern |= 1;
     }
-        
+
 }
 
 static int check_p32_p22(pulldown_detect_info_t* cur_info, pulldown_detect_info_t* pre_info, pulldown_detect_info_t* pre2_info,
@@ -159,21 +159,21 @@ static int check_p32_p22(pulldown_detect_info_t* cur_info, pulldown_detect_info_
  	di_p32_info[idx] = di_p32_info[idx] << 1;
  	di_p32_info_2[idx] = di_p32_info_2[idx] << 1;
 
-	if ( cur_info->field_diff*pd_th->field_diff_chg_th <= pre_info->field_diff && 
-	        pre2_info->field_diff*pd_th->field_diff_chg_th <= pre_info->field_diff && 
-	        cur_info->field_diff_num*pd_th->field_diff_num_chg_th <= pre_info->field_diff_num && 
+	if ( cur_info->field_diff*pd_th->field_diff_chg_th <= pre_info->field_diff &&
+	        pre2_info->field_diff*pd_th->field_diff_chg_th <= pre_info->field_diff &&
+	        cur_info->field_diff_num*pd_th->field_diff_num_chg_th <= pre_info->field_diff_num &&
 	        pre2_info->field_diff_num*pd_th->field_diff_num_chg_th <= pre_info->field_diff_num ){
 		di_p22_info[idx] |= 1;
   }
 
-	if ( (di_p22_info[idx] & 0x1) && cur_info->frame_diff_skew*pd_th->frame_diff_skew_th <= cur_info->frame_diff 
+	if ( (di_p22_info[idx] & 0x1) && cur_info->frame_diff_skew*pd_th->frame_diff_skew_th <= cur_info->frame_diff
 	    && cur_info->frame_diff_num_skew*pd_th->frame_diff_num_skew_th <= cur_info->frame_diff_num ){
 		di_p22_info_2[idx] |= 1;
   }
 
 	if ( di_p32_counter[idx] > 0 || di_p32_info[idx] == 0 )
 	{
-		if ( cur_info->frame_diff*pd_th->frame_diff_chg_th <= pre_info->frame_diff && 
+		if ( cur_info->frame_diff*pd_th->frame_diff_chg_th <= pre_info->frame_diff &&
 		        cur_info->frame_diff_num*pd_th->frame_diff_num_chg_th <= pre_info->frame_diff_num )
 		{
 			di_p32_info[idx] |= 1;
@@ -186,14 +186,14 @@ static int check_p32_p22(pulldown_detect_info_t* cur_info, pulldown_detect_info_
 			last_big_frame_diff[idx] = 0;
 			last_big_frame_diff_num[idx] = 0;
 
-			if ( (di_p32_counter[idx] & 0x1) && cur_info->frame_diff_skew*pd_th->frame_diff_skew_th <= cur_info->frame_diff 
+			if ( (di_p32_counter[idx] & 0x1) && cur_info->frame_diff_skew*pd_th->frame_diff_skew_th <= cur_info->frame_diff
 			    && cur_info->frame_diff_num_skew*pd_th->frame_diff_num_skew_th <= cur_info->frame_diff_num )
 				di_p32_info_2[idx] |= 1;
 		}
 	}
 	else
 	{
-		if ( cur_info->frame_diff*pd_th->frame_diff_chg_th <= last_big_frame_diff[idx] && 
+		if ( cur_info->frame_diff*pd_th->frame_diff_chg_th <= last_big_frame_diff[idx] &&
 		    cur_info->frame_diff_num*pd_th->frame_diff_num_chg_th <= last_big_frame_diff_num[idx] )
 		{
 			di_p32_info[idx] |= 1;
@@ -204,14 +204,14 @@ static int check_p32_p22(pulldown_detect_info_t* cur_info, pulldown_detect_info_
 	di_p32_counter[idx]++;
 
 
-	return 0; 
+	return 0;
 }
 
 
 void pattern_check_pre_2(int idx, pulldown_detect_info_t* cur_info, pulldown_detect_info_t* pre_info, pulldown_detect_info_t* pre2_info,
                     int* pre_pulldown_mode, int* pre2_pulldown_mode, int* type,
                     pd_detect_threshold_t* pd_th)
-{ 
+{
 
 		check_p32_p22(cur_info, pre_info, pre2_info, pd_th, idx);
 
@@ -332,7 +332,7 @@ typedef struct{
     unsigned field_diff_num;
 }pd_his_t;
 
-static pd_his_t pd_his_pool[PD_HIS_NUM*2]; 
+static pd_his_t pd_his_pool[PD_HIS_NUM*2];
 static unsigned pd_his_wr_pos = 0;
 static unsigned pd_his_size = 0;
 
@@ -340,10 +340,10 @@ static unsigned pd_his_size = 0;
 
 void reset_pd_his(void)
 {
-    pd_his_wr_pos = 0;    
+    pd_his_wr_pos = 0;
     pd_his_size = 0;
 }
-    
+
 void insert_pd_his(pulldown_detect_info_t* pd_info)
 {
     pd_his_t* phis = &pd_his_pool[pd_his_wr_pos];
@@ -353,17 +353,17 @@ void insert_pd_his(pulldown_detect_info_t* pd_info)
     phis->field_diff_num = (phis+PD_HIS_NUM)->field_diff_num = pd_info->field_diff_num;
     pd_his_wr_pos++;
     if(pd_his_wr_pos >= PD_HIS_NUM){
-        pd_his_wr_pos = 0;    
-    } 
+        pd_his_wr_pos = 0;
+    }
     if(pd_his_size < PD_HIS_NUM){
         pd_his_size++;
     }
 }
 
 /* algorithm to detect pd32 */
-unsigned int pd32_match_num=0x10; 
+unsigned int pd32_match_num=0x10;
 unsigned int pd32_diff_num_0_th=1;
-unsigned int pd32_match_num_th; 
+unsigned int pd32_match_num_th;
 unsigned int pd32_debug_th =0;
 unsigned int pd22_th = 0x3;
 unsigned int pd22_num_th = 0x5;
@@ -372,7 +372,7 @@ unsigned int pd22_match_num = 0x5;
        A-odd
        A-even
        A-odd              cur_pd32_status = 1
-       B-even             cur_pd32_status = 2 
+       B-even             cur_pd32_status = 2
        B-odd              cur_pd32_status = 3
        C-even             cur_pd32_status = 4
        C-odd              cur_pd32_status = 5
@@ -380,7 +380,7 @@ unsigned int pd22_match_num = 0x5;
        D-odd
        D-even
     ...
-*/    
+*/
 static int cur_pd22_status = 0;
 
 static int cur_pd32_status = 0;
@@ -391,16 +391,16 @@ static unsigned int pd22_num = 0 ;
 void reset_pd32_status(void)
 {
     cur_pd22_status = 0;
-    cur_pd32_status = 0; 
+    cur_pd32_status = 0;
     last_small_frame_diff_num = 0;
     pattern_match_count = 0;
     pd32_diff_num_0_count = 0;
     /**/
-    pd32_match_num_th = pd32_match_num;    
-}    
+    pd32_match_num_th = pd32_match_num;
+}
 
 int detect_pd32(void)
-{ 
+{
     int blend_mode = -1;
     int i, ii;
     int  pd_pd1field = 0;
@@ -422,7 +422,7 @@ int detect_pd32(void)
 		    	(((phis_22-2*ii-1)->field_diff_num *pd22_th) > (phis_22-2*(ii+1))->field_diff_num))	{
 			blend_mode = -1;
 			break;
-			} 	                 	
+			}
 	        }
 	    }
 	    else if ((phis_22->field_diff_num*pd22_th) <=(phis_22-1)->field_diff_num)
@@ -433,10 +433,10 @@ int detect_pd32(void)
 		    	(((phis_22-2*ii-1)->field_diff_num) <=(( phis_22-2*ii-2)->field_diff_num * pd22_th)))	{
 			blend_mode = -1;
 			break;
-			} 	                 	
+			}
 	        }
 	     }
-            else 
+            else
             {
 	   	blend_mode = -1;
 */
@@ -465,7 +465,7 @@ int detect_pd32(void)
                 }
                 if(ii<5){
                     pattern_match_count--;
-                }            
+                }
             }
 
             tmp_count=phis->frame_diff_num;
@@ -475,7 +475,7 @@ int detect_pd32(void)
                 tmp_count+=(phis-ii)->frame_diff_num;
             }
             if((tmp_count==0)&&(ii==5)){
-                pd32_diff_num_0_count++;    
+                pd32_diff_num_0_count++;
                 if(pd32_diff_num_0_count>pd32_match_num){
                     pd32_diff_num_0_count=pd32_match_num;
                 }
@@ -494,20 +494,20 @@ int detect_pd32(void)
                     pattern_match_count=pd32_match_num;
                 }
             }
-            
+
             if((pattern_match_count<pd32_match_num_th)
                 ||(pd32_diff_num_0_count>pd32_diff_num_0_th)){
                 reset_pd32_status();
             }
             if(cur_pd32_status>0){
-                last_small_frame_diff_num = phis->frame_diff_num;    
+                last_small_frame_diff_num = phis->frame_diff_num;
             }
         }
     }
     if((cur_pd32_status==0)&&(pd_his_size>=pd32_pattern_len)){
         phis = pd_his(0,pd32_pattern_len);
         pd32_diff_num_0_count = 0;
-        pattern_match_count=0;        
+        pattern_match_count=0;
         for( i=0; i<pd32_pattern_len; i+=5){
             unsigned tmp_count=(phis+4)->frame_diff_num;
             for(ii=0;ii<4;ii++){
@@ -516,7 +516,7 @@ int detect_pd32(void)
                 tmp_count+=(phis+ii)->frame_diff_num;
             }
             if((tmp_count==0)&&(ii==4)){
-                pd32_diff_num_0_count++;    
+                pd32_diff_num_0_count++;
             }
             if(ii==4){
                 if((i+5)<pd32_pattern_len){
@@ -526,7 +526,7 @@ int detect_pd32(void)
                     }
                     if(ii==4){
                         pattern_match_count++;
-                    }    
+                    }
                 }
                 else{
                     pattern_match_count++;
@@ -536,7 +536,7 @@ int detect_pd32(void)
         }
         if((pattern_match_count>=pd32_match_num_th)
             &&(pd32_diff_num_0_count<=pd32_diff_num_0_th)){
-            cur_pd32_status = 1;  
+            cur_pd32_status = 1;
             last_small_frame_diff_num = pd_his(pd32_pattern_len-1,pd32_pattern_len)->frame_diff_num;
         }
     }
@@ -550,7 +550,7 @@ int detect_pd32(void)
     }
     /*for hisense static 1 filed output*/
     if ((blend_mode == -1) && pd_enable){
-        phis = pd_his(pd_pd1field_num-1,pd_pd1field_num);	    
+        phis = pd_his(pd_pd1field_num-1,pd_pd1field_num);
         cur_pd1field_status = 1;
         blend_mode = 2;
         if (cur_pd1field_status){
@@ -566,7 +566,7 @@ int detect_pd32(void)
         }
         else{
 	    pd_pd1field = 1;
-	    for (ii = 0; ii < pd_pd1field_num -1;ii ++){  
+	    for (ii = 0; ii < pd_pd1field_num -1;ii ++){
   	        if (((phis+ii)->field_diff_num > field_diff_thresh) && ((phis+ii)->frame_diff_num > frame_diff_thresh)){
 		  pd_pd1field = 0;
 		  break;
@@ -584,7 +584,7 @@ int detect_pd32(void)
                 cur_pd1field_status,blend_mode,(phis+ii)->field_diff_num,(phis+ii)->frame_diff_num);
         }
     }
-    
+
     return blend_mode;
-}    
+}
 
diff --git a/drivers/amlogic/ppmgr/ppmgr_3d.c b/drivers/amlogic/ppmgr/ppmgr_3d.c
index e7d021b7d776..b522a908be18 100755
--- a/drivers/amlogic/ppmgr/ppmgr_3d.c
+++ b/drivers/amlogic/ppmgr/ppmgr_3d.c
@@ -3,19 +3,19 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/timer.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vout_notify.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #include <linux/platform_device.h>
-#include <linux/amports/timestamp.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vfp.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vfp.h>
 #include <mach/am_regs.h>
-#include <linux/amlog.h>
-#include <linux/ge2d/ge2d.h>
-#include <linux/ge2d/ge2d_wq.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/ge2d/ge2d_wq.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/semaphore.h>
@@ -23,8 +23,8 @@
 #include "ppmgr_log.h"
 #include "ppmgr_pri.h"
 #include "ppmgr_dev.h"
-#include <linux/ppmgr/ppmgr.h>
-#include <linux/ppmgr/ppmgr_status.h>
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
 #include <linux/io.h>
 
 #define VF_POOL_SIZE 4
diff --git a/drivers/amlogic/ppmgr/ppmgr_3d_tv.c b/drivers/amlogic/ppmgr/ppmgr_3d_tv.c
index 9b3b3148aa20..999b3e333284 100755
--- a/drivers/amlogic/ppmgr/ppmgr_3d_tv.c
+++ b/drivers/amlogic/ppmgr/ppmgr_3d_tv.c
@@ -3,19 +3,19 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/timer.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vout_notify.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #include <linux/platform_device.h>
-#include <linux/amports/timestamp.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vfp.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vfp.h>
 #include <mach/am_regs.h>
-#include <linux/amlog.h>
-#include <linux/ge2d/ge2d.h>
-#include <linux/ge2d/ge2d_wq.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/ge2d/ge2d_wq.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/semaphore.h>
@@ -23,8 +23,8 @@
 #include "ppmgr_log.h"
 #include "ppmgr_pri.h"
 #include "ppmgr_dev.h"
-#include <linux/ppmgr/ppmgr.h>
-#include <linux/ppmgr/ppmgr_status.h>
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
 #include <linux/io.h>
 #define RECEIVER_NAME "ppmgr"
 #define PROVIDER_NAME   "ppmgr"
diff --git a/drivers/amlogic/ppmgr/ppmgr_dev.h b/drivers/amlogic/ppmgr/ppmgr_dev.h
index 2b5d544aff1d..c45ea7df6a94 100755
--- a/drivers/amlogic/ppmgr/ppmgr_dev.h
+++ b/drivers/amlogic/ppmgr/ppmgr_dev.h
@@ -1,6 +1,6 @@
 #ifndef PPMGR_DEV_INCLUDE_H
 #define PPMGR_DEV_INCLUDE_H
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/vframe.h>
 typedef  struct {
 	struct class 		*cla;
 	struct device		*dev;
diff --git a/drivers/amlogic/ppmgr/ppmgr_drv.c b/drivers/amlogic/ppmgr/ppmgr_drv.c
index cda7e572d5e3..d945deb2ed98 100755
--- a/drivers/amlogic/ppmgr/ppmgr_drv.c
+++ b/drivers/amlogic/ppmgr/ppmgr_drv.c
@@ -8,25 +8,25 @@
  *  Created: 2010/4/1   19:46
  *
  *******************************************************************/
-#include <linux/ppmgr/ppmgr.h>
-#include <linux/ppmgr/ppmgr_status.h>
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
 #include <linux/platform_device.h>
-#include <linux/ge2d/ge2d_main.h>
-#include <linux/ge2d/ge2d.h>
-#include <linux/amlog.h>
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/amlog.h>
 #include <linux/ctype.h>
-#include <linux/vout/vout_notify.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
 
 
 
 #include "ppmgr_log.h"
 #include "ppmgr_pri.h"
 #include "ppmgr_dev.h"
-#include <linux/ppmgr/ppmgr.h>
-#include <linux/ppmgr/ppmgr_status.h>
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
 
 /***********************************************************************
 *
diff --git a/drivers/amlogic/ppmgr/ppmgr_vpp.c b/drivers/amlogic/ppmgr/ppmgr_vpp.c
index 2abb3635798d..1a4f19d1583b 100755
--- a/drivers/amlogic/ppmgr/ppmgr_vpp.c
+++ b/drivers/amlogic/ppmgr/ppmgr_vpp.c
@@ -9,27 +9,27 @@
 #include <linux/timer.h>
 #include <linux/platform_device.h>
 #include <mach/am_regs.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/canvas.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vout_notify.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vfp.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/amlog.h>
-#include <linux/ge2d/ge2d_main.h>
-#include <linux/ge2d/ge2d.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vfp.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/semaphore.h>
-#include <linux/sched.h>
+#include <linux/sched/rt.h>
 #include "ppmgr_log.h"
 #include "ppmgr_pri.h"
 #include "ppmgr_dev.h"
 #include <linux/mm.h>
-#include <linux/ppmgr/ppmgr.h>
-#include <linux/ppmgr/ppmgr_status.h>
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
@@ -92,7 +92,7 @@ static struct vframe_s *vfp_pool_free[VF_POOL_SIZE+1];
 static struct vframe_s *vfp_pool_ready[VF_POOL_SIZE+1];
 typedef struct buf_status_s{
 	int index;
-	int dirty; 
+	int dirty;
 }buf_status_t;
 static struct buf_status_s buf_status[VF_POOL_SIZE];
 
@@ -251,7 +251,7 @@ static int get_input_format(vframe_t* vf)
 {
     int format= GE2D_FORMAT_M24_YUV420;
     if(vf->type&VIDTYPE_VIU_422){
-#if 0    	
+#if 0
         if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
             format =  GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422B & (3<<3));
         }else if(vf->type &VIDTYPE_INTERLACE_TOP){
@@ -266,9 +266,9 @@ static int get_input_format(vframe_t* vf)
 			format = GE2D_FORMAT_S16_YUV422;
 		}else{
 			format = GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422T & (3<<3));
-		} 
+		}
 #endif
-        
+
     }else if(vf->type&VIDTYPE_VIU_NV21){
         if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
             format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21B & (3<<3));
@@ -447,8 +447,8 @@ void vf_local_init(void)
 
     for(i =0 ; i < VF_POOL_SIZE ;i++ ){
     	buf_status[i].index = ppmgr_canvas_tab[i];
-    	buf_status[i].dirty = 1;	
-    }  
+    	buf_status[i].dirty = 1;
+    }
     sema_init(&thread_sem,1);
 }
 
@@ -1354,7 +1354,7 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
             scaler_h = rect_h;
             for(i =0 ; i < VF_POOL_SIZE ;i++ ){
             	buf_status[i].index = ppmgr_canvas_tab[i];
-            	buf_status[i].dirty = 1;	
+            	buf_status[i].dirty = 1;
             }
             //printk("--ppmgr new rect x:%d, y:%d, w:%d, h:%d.\n", rect_x, rect_y, rect_w, rect_h);
         }
@@ -1374,13 +1374,13 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
     }
 
     memset(ge2d_config,0,sizeof(config_para_ex_t));
-    
-    for(i =0 ; i < VF_POOL_SIZE ;i++ ){    	
+
+    for(i =0 ; i < VF_POOL_SIZE ;i++ ){
     	if(buf_status[i].index == new_vf->canvas0Addr){
     		break;
     	}
-    } 
-    
+    }
+
     if(buf_status[i].dirty == 1){
     	buf_status[i].dirty = 0;
     	//printk("--scale_clear_count is %d ------new_vf->canvas0Addr is %d ----------x:%d, y:%d, w:%d, h:%d.\n",scale_clear_count,new_vf->canvas0Addr, rect_x, rect_y, rect_w, rect_h);
@@ -1998,8 +1998,8 @@ static int process_vf_adjust(vframe_t *vf, ge2d_context_t *context, config_para_
     scale_clear_count = VF_POOL_SIZE;
     for(i =0 ; i < VF_POOL_SIZE ;i++ ){
     	buf_status[i].index = ppmgr_canvas_tab[i];
-    	buf_status[i].dirty = 1;	
-    }    
+    	buf_status[i].dirty = 1;
+    }
     scaler_x = rect_x;
     scaler_y = rect_y;
     scaler_w = rect_w;
@@ -2513,7 +2513,7 @@ int ppmgr_buffer_init(int vout_mode)
 	    if (ppmgr_device.disp_height == 0)
 	        ppmgr_device.disp_height = ppmgr_device.vinfo->height;
             if (get_platform_type() == PLATFORM_MID_VERTICAL) {
-                int DISP_SIZE = ppmgr_device.disp_width > ppmgr_device.disp_height ? 
+                int DISP_SIZE = ppmgr_device.disp_width > ppmgr_device.disp_height ?
                         ppmgr_device.disp_width : ppmgr_device.disp_height;
                 canvas_width = (DISP_SIZE + 0x1f) & ~0x1f;
                 canvas_height = (DISP_SIZE + 0x1f) & ~0x1f;
diff --git a/drivers/amlogic/tvin/bt656/bt656_601_in.c b/drivers/amlogic/tvin/bt656/bt656_601_in.c
index 1775f5fedfc7..23f2bd449bd2 100755
--- a/drivers/amlogic/tvin/bt656/bt656_601_in.c
+++ b/drivers/amlogic/tvin/bt656/bt656_601_in.c
@@ -29,11 +29,11 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 
-#include <linux/amports/amstream.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
 #include <mach/am_regs.h>
 #include <mach/mod_gate.h>
 
diff --git a/drivers/amlogic/tvin/bt656/bt656_601_in.h b/drivers/amlogic/tvin/bt656/bt656_601_in.h
index 73e6f74ee305..fffbae415859 100755
--- a/drivers/amlogic/tvin/bt656/bt656_601_in.h
+++ b/drivers/amlogic/tvin/bt656/bt656_601_in.h
@@ -14,7 +14,7 @@
 #ifndef __BT656_601_INPUT_H
 #define __BT656_601_INPUT_H
 #include <linux/cdev.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <mach/pinmux.h>
 #include "../tvin_frontend.h"
 #include "../tvin_global.h"
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
index 024965c7b276..82e6b35adf4b 100755
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
@@ -40,7 +40,7 @@
 #include <mach/register.h>
 #include <mach/power_gate.h>
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 /* Local include */
 #include "hdmirx_drv.h"
 #include "hdmi_rx_reg.h"
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
index 6c6c79799719..6c490526fd04 100755
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
@@ -40,7 +40,7 @@
 #include <mach/power_gate.h>
 
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 /* Local include */
 #include "hdmirx_drv.h"
 #include "hdmi_rx_reg.h"
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
index 498423413325..370816f06105 100755
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
@@ -28,12 +28,12 @@
 #include <linux/mutex.h>
 
 /* Amlogic headers */
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/tvin/tvin.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/tvin/tvin.h>
+#include <linux/amlogic/amports/canvas.h>
 #include <mach/am_regs.h>
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/vframe.h>
 
 /* Local include */
 #include "../tvin_frontend.h"
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
index 35c19e541202..2d38a4920bf8 100755
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
+++ b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
@@ -15,7 +15,7 @@
 #define _TVHDMI_H
 
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "../tvin_global.h"
 #include "../tvin_format_table.h"
 
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_test.c b/drivers/amlogic/tvin/hdmirx/hdmirx_test.c
old mode 100644
new mode 100755
index ced36c1138de..ec8606696af3
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_test.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmirx_test.c
@@ -40,7 +40,7 @@
 #include <mach/register.h>
 #include <mach/power_gate.h>
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 /* Local include */
 #include "hdmirx_drv.h"
 #include "hdmi_rx_reg.h"
diff --git a/drivers/amlogic/tvin/isp/isp_drv.c b/drivers/amlogic/tvin/isp/isp_drv.c
index dd9d2b3a870e..8f7f06d48afe 100755
--- a/drivers/amlogic/tvin/isp/isp_drv.c
+++ b/drivers/amlogic/tvin/isp/isp_drv.c
@@ -26,7 +26,7 @@
 #include <linux/kthread.h>
 #include <linux/delay.h>
 /* Amlogic Headers */
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <mach/am_regs.h>
 
 /* Local Headers */
diff --git a/drivers/amlogic/tvin/isp/isp_drv.h b/drivers/amlogic/tvin/isp/isp_drv.h
index 4102e55f94e6..6f7504961a4f 100755
--- a/drivers/amlogic/tvin/isp/isp_drv.h
+++ b/drivers/amlogic/tvin/isp/isp_drv.h
@@ -24,7 +24,7 @@
 #include <linux/time.h>
 #include <linux/device.h>
 
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include "isp_hw.h"
 #include "../tvin_frontend.h"
 
diff --git a/drivers/amlogic/tvin/isp/isp_hw.c b/drivers/amlogic/tvin/isp/isp_hw.c
index 1994e896ec04..d0279e1ac7ff 100755
--- a/drivers/amlogic/tvin/isp/isp_hw.c
+++ b/drivers/amlogic/tvin/isp/isp_hw.c
@@ -11,7 +11,7 @@
  */
 #include <mach/am_regs.h>
 #include <linux/kernel.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include "isp_regs.h"
 #include "isp_hw.h"
 
diff --git a/drivers/amlogic/tvin/isp/isp_parm.c b/drivers/amlogic/tvin/isp/isp_parm.c
index 3d3d0cecaa99..10a45993c6a3 100755
--- a/drivers/amlogic/tvin/isp/isp_parm.c
+++ b/drivers/amlogic/tvin/isp/isp_parm.c
@@ -21,7 +21,7 @@
 #include <linux/fs.h>
 
 /* Amlogic Headers */
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 
 #include "isp_drv.h"  
 
@@ -208,6 +208,7 @@ void set_af_parm(xml_algorithm_af_t *af_sw,char **parm)
 {
 	int len = AF_PARM_NUM;		
 	isp_param_t af[AF_PARM_NUM]={
+        #if 0
 		{"f0_coef0",      &af_sw->f0_coef0,      1, ISP_U32},
 		{"f0_coef1",      &af_sw->f0_coef1,      1, ISP_U32},
 		{"f0_coef2",      &af_sw->f0_coef2,      1, ISP_U32},
@@ -227,6 +228,7 @@ void set_af_parm(xml_algorithm_af_t *af_sw,char **parm)
 		{"f0_coef",       &af_sw->f0_coef,       1, ISP_U32},
 		{"f1_coef",       &af_sw->f1_coef,       1, ISP_U32},		
 		{"adapting_time", &af_sw->adapting_time, 1, ISP_U32},
+        #endif 
 	};
 	
 	if(!strcmp(parm[0],"show")){
diff --git a/drivers/amlogic/tvin/isp/isp_sm.c b/drivers/amlogic/tvin/isp/isp_sm.c
index 5d1d97380ef2..6e9e10281530 100755
--- a/drivers/amlogic/tvin/isp/isp_sm.c
+++ b/drivers/amlogic/tvin/isp/isp_sm.c
@@ -9,7 +9,7 @@
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <linux/module.h>
 
 #include "isp_drv.h"
diff --git a/drivers/amlogic/tvin/tvafe/tvafe.c b/drivers/amlogic/tvin/tvafe/tvafe.c
index eef5fc3fd1e9..61f565ac87f7 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe.c
@@ -27,12 +27,12 @@
 #include <linux/mm.h>
 
 /* Amlogic headers */
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/amports/canvas.h>
 #include <mach/am_regs.h>
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/vframe.h>
 
 /* Local include */
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "../tvin_frontend.h"
 #include "../tvin_global.h"
 #include "../tvin_format_table.h"
diff --git a/drivers/amlogic/tvin/tvafe/tvafe.h b/drivers/amlogic/tvin/tvafe/tvafe.h
index 2a70af6890de..a304cc8d72d7 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe.h
+++ b/drivers/amlogic/tvin/tvafe/tvafe.h
@@ -12,7 +12,7 @@
 #include <linux/timer.h>
 #include <linux/mutex.h>
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "../tvin_global.h"
 #include "../tvin_frontend.h"
 #include "tvafe_general.h"   /* For Kernel used only */
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_adc.c b/drivers/amlogic/tvin/tvafe/tvafe_adc.c
index 158b6094ecc7..18ee02fbe0a7 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe_adc.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe_adc.c
@@ -18,7 +18,7 @@
 
 #include <mach/am_regs.h>
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "../vdin/vdin_regs.h"
 #include "../tvin_global.h"
 #include "../tvin_format_table.h"
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_adc.h b/drivers/amlogic/tvin/tvafe/tvafe_adc.h
index b99d3a60875d..b956a52313ba 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe_adc.h
+++ b/drivers/amlogic/tvin/tvafe/tvafe_adc.h
@@ -6,7 +6,7 @@
 #ifndef _TVAFE_ADC_H
 #define _TVAFE_ADC_H
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 //#define TVAFE_DEBUG_PIN_ENABLE
 #define TVAFE_ADC_CONFIGURE_INIT     1
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_cvd.c b/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
index 08fea39661c5..5ae54704deb5 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
@@ -18,7 +18,7 @@
 
 #include <mach/am_regs.h>
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "../tvin_global.h"
 #include "../tvin_format_table.h"
 #include "tvafe_regs.h"
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_cvd.h b/drivers/amlogic/tvin/tvafe/tvafe_cvd.h
index bb18079309c6..2508d26ee030 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe_cvd.h
+++ b/drivers/amlogic/tvin/tvafe/tvafe_cvd.h
@@ -6,7 +6,7 @@
 #ifndef _TVAFE_CVD_H
 #define _TVAFE_CVD_H
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 /***************************Local defines**********************************/
 /* cvd2 memory size defines */
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_general.c b/drivers/amlogic/tvin/tvafe/tvafe_general.c
index 267d5bcc89e3..20ac82f19086 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe_general.c
+++ b/drivers/amlogic/tvin/tvafe/tvafe_general.c
@@ -5,7 +5,7 @@
 
 #include <mach/am_regs.h>
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "../tvin_global.h"
 #include "../tvin_format_table.h"
 #include "tvafe_regs.h"
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_general.h b/drivers/amlogic/tvin/tvafe/tvafe_general.h
index f14f04ea89c9..d048847428dd 100755
--- a/drivers/amlogic/tvin/tvafe/tvafe_general.h
+++ b/drivers/amlogic/tvin/tvafe/tvafe_general.h
@@ -1,7 +1,7 @@
 #ifndef _TVAFE_GENERAL_H
 #define _TVAFE_GENERAL_H
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "tvafe_cvd.h"
 
 // ***************************************************************************
diff --git a/drivers/amlogic/tvin/tvin_format_table.h b/drivers/amlogic/tvin/tvin_format_table.h
index 883ceb14100b..6a88e2623eb7 100755
--- a/drivers/amlogic/tvin/tvin_format_table.h
+++ b/drivers/amlogic/tvin/tvin_format_table.h
@@ -15,7 +15,7 @@
 #ifndef __TVIN_FORMAT_TABLE_H
 #define __TVIN_FORMAT_TABLE_H
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 #include "tvin_global.h"
 extern const char * tvin_sig_fmt_str(enum tvin_sig_fmt_e fmt);
diff --git a/drivers/amlogic/tvin/tvin_frontend.c b/drivers/amlogic/tvin/tvin_frontend.c
index c53a2fc1708d..8ff96abad63e 100755
--- a/drivers/amlogic/tvin/tvin_frontend.c
+++ b/drivers/amlogic/tvin/tvin_frontend.c
@@ -19,7 +19,7 @@
 #include <linux/spinlock.h>
 #include <linux/device.h>
 /* Amlogic headers */
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/vframe.h>
 
 /* Local headers */
 #include "tvin_frontend.h"
diff --git a/drivers/amlogic/tvin/tvin_frontend.h b/drivers/amlogic/tvin/tvin_frontend.h
index 6ab1631e4348..71f5e853195f 100755
--- a/drivers/amlogic/tvin/tvin_frontend.h
+++ b/drivers/amlogic/tvin/tvin_frontend.h
@@ -19,8 +19,8 @@
 #include <linux/list.h>
 
 /* Amlogic Headers */
-#include <linux/amports/vframe.h>
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 /* Local Headers */
 #include "tvin_global.h"
diff --git a/drivers/amlogic/tvin/tvin_global.c b/drivers/amlogic/tvin/tvin_global.c
index a9fe18a903cb..04a8d9e02655 100755
--- a/drivers/amlogic/tvin/tvin_global.c
+++ b/drivers/amlogic/tvin/tvin_global.c
@@ -13,7 +13,7 @@
  */
 
 #include <linux/module.h>
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 #include "tvin_global.h"
 
 
diff --git a/drivers/amlogic/tvin/tvin_global.h b/drivers/amlogic/tvin/tvin_global.h
index 740bbfc468b9..44c492585859 100755
--- a/drivers/amlogic/tvin/tvin_global.h
+++ b/drivers/amlogic/tvin/tvin_global.h
@@ -16,7 +16,7 @@
 #ifndef __TVIN_GLOBAL_H
 #define __TVIN_GLOBAL_H
 
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 // ***************************************************************************
 // *** enum definitions *********************************************
diff --git a/drivers/amlogic/tvin/vdin/vdin_canvas.c b/drivers/amlogic/tvin/vdin/vdin_canvas.c
index f75ae3c65774..83d8b26b80ba 100755
--- a/drivers/amlogic/tvin/vdin/vdin_canvas.c
+++ b/drivers/amlogic/tvin/vdin/vdin_canvas.c
@@ -11,8 +11,8 @@
  */
 
 //#include <mach/dmc.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
 #include <linux/mm.h>
 
 #include "../tvin_format_table.h"
diff --git a/drivers/amlogic/tvin/vdin/vdin_canvas.h b/drivers/amlogic/tvin/vdin/vdin_canvas.h
index 06b18acfa954..87f99582b121 100755
--- a/drivers/amlogic/tvin/vdin/vdin_canvas.h
+++ b/drivers/amlogic/tvin/vdin/vdin_canvas.h
@@ -16,8 +16,8 @@
 
 #include <asm/sizes.h>
 
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
 
 #define VDIN_CANVAS_MAX_WIDTH			1920
 #define VDIN_CANVAS_MAX_HEIGH			2228
diff --git a/drivers/amlogic/tvin/vdin/vdin_ctl.c b/drivers/amlogic/tvin/vdin/vdin_ctl.c
index 44f9eb5b3acb..240c09396e3f 100755
--- a/drivers/amlogic/tvin/vdin/vdin_ctl.c
+++ b/drivers/amlogic/tvin/vdin/vdin_ctl.c
@@ -15,9 +15,9 @@
 #include <mach/am_regs.h>
 #include <mach/register.h>
 #include <mach/cpu.h>
-#include <linux/amports/canvas.h>
-#include <linux/tvin/tvin.h>
-#include <linux/aml_common.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/tvin/tvin.h>
+#include <linux/amlogic/aml_common.h>
 
 #include "../tvin_global.h"
 #include "../tvin_format_table.h"
diff --git a/drivers/amlogic/tvin/vdin/vdin_ctl.h b/drivers/amlogic/tvin/vdin/vdin_ctl.h
index 8a837b001235..10d4303e4f59 100755
--- a/drivers/amlogic/tvin/vdin/vdin_ctl.h
+++ b/drivers/amlogic/tvin/vdin/vdin_ctl.h
@@ -16,7 +16,7 @@
 #define __TVIN_VDIN_CTL_H
 
 
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/vframe.h>
 
 #include "vdin_drv.h"
 
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.c b/drivers/amlogic/tvin/vdin/vdin_drv.c
index 5a6b22d76060..d034ccf1a1f0 100755
--- a/drivers/amlogic/tvin/vdin/vdin_drv.c
+++ b/drivers/amlogic/tvin/vdin/vdin_drv.c
@@ -35,15 +35,15 @@
 #include <asm/div64.h>
 #include <linux/of.h>
 /* Amlogic Headers */
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/amports/canvas.h>
 #include <mach/am_regs.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/amports/timestamp.h>
-#include <linux/amports/tsync.h>
-#include <linux/tvin/tvin_v4l2.h>
-#include <linux/aml_common.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/tsync.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include <linux/amlogic/aml_common.h>
 #include <mach/irqs.h>
 #include <mach/mod_gate.h>
 /* Local Headers */
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.h b/drivers/amlogic/tvin/vdin/vdin_drv.h
index 372eb395c192..a87db0b54a20 100755
--- a/drivers/amlogic/tvin/vdin/vdin_drv.h
+++ b/drivers/amlogic/tvin/vdin/vdin_drv.h
@@ -25,9 +25,9 @@
 #include <linux/time.h>
 
 /* Amlogic Headers */
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 
 /* Local Headers */
 #include "../tvin_global.h"
diff --git a/drivers/amlogic/tvin/vdin/vdin_sm.c b/drivers/amlogic/tvin/vdin/vdin_sm.c
index 8569f49dd894..3f20bff6ecd3 100755
--- a/drivers/amlogic/tvin/vdin/vdin_sm.c
+++ b/drivers/amlogic/tvin/vdin/vdin_sm.c
@@ -17,7 +17,7 @@
 #include <linux/moduleparam.h>
 
 /* Amlogic Headers */
-#include <linux/tvin/tvin.h>
+#include <linux/amlogic/tvin/tvin.h>
 
 /* Local Headers */
 #include "../tvin_frontend.h"
diff --git a/drivers/amlogic/tvin/vdin/vdin_vf.c b/drivers/amlogic/tvin/vdin/vdin_vf.c
index 22e303ae108c..4ffde9bae8fd 100755
--- a/drivers/amlogic/tvin/vdin/vdin_vf.c
+++ b/drivers/amlogic/tvin/vdin/vdin_vf.c
@@ -25,7 +25,7 @@
 
 
 /* Amlogic Headers */
-#include <linux/amports/vframe.h>
+#include <linux/amlogic/amports/vframe.h>
 
 /* Local Headers */
 #include "vdin_vf.h"
diff --git a/drivers/amlogic/tvin/vdin/vdin_vf.h b/drivers/amlogic/tvin/vdin/vdin_vf.h
index 460e4e6667dc..a95be4e7b7b9 100755
--- a/drivers/amlogic/tvin/vdin/vdin_vf.h
+++ b/drivers/amlogic/tvin/vdin/vdin_vf.h
@@ -22,8 +22,8 @@
 #include <linux/list.h>
 
 /* Amlogic Linux Headers */
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
 #define VF_LOG_EN
 
 #ifdef VF_LOG_EN
diff --git a/drivers/amlogic/tvin/viu/viuin.c b/drivers/amlogic/tvin/viu/viuin.c
index f5a49cf008f3..39a515c6ecc8 100755
--- a/drivers/amlogic/tvin/viu/viuin.c
+++ b/drivers/amlogic/tvin/viu/viuin.c
@@ -26,12 +26,12 @@
 #include <asm/atomic.h>
 #include <linux/module.h>
 
-#include <linux/amports/amstream.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <mach/am_regs.h>
 #ifdef CONFIG_GAMMA_AUTO_TUNE
 #include <linux/amlogic/vout/lcdoutc.h>
diff --git a/drivers/amlogic/tvin_v4l2/vdin_v4l2.c b/drivers/amlogic/tvin_v4l2/vdin_v4l2.c
index 6bb53c47365e..d80aa4a7fc8f 100755
--- a/drivers/amlogic/tvin_v4l2/vdin_v4l2.c
+++ b/drivers/amlogic/tvin_v4l2/vdin_v4l2.c
@@ -4,7 +4,7 @@
 #include <linux/interrupt.h>
 #include <linux/mm.h>
 
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 
 static struct vdin_v4l2_ops_s ops = {NULL};
 
@@ -16,7 +16,7 @@ int vdin_reg_v4l2(vdin_v4l2_ops_t *v4l2_ops)
         ret = memcpy(&ops,v4l2_ops,sizeof(vdin_v4l2_ops_t));
         if(ret)
                 return 0;
-        return -1;        
+        return -1;
 }
 EXPORT_SYMBOL(vdin_reg_v4l2);
 
diff --git a/drivers/amlogic/video_dev/amlvideo.c b/drivers/amlogic/video_dev/amlvideo.c
index 5fedcefb5fa6..66d7c8920aaa 100755
--- a/drivers/amlogic/video_dev/amlvideo.c
+++ b/drivers/amlogic/video_dev/amlvideo.c
@@ -32,14 +32,14 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <linux/types.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/ge2d/ge2d.h>
-#include <linux/amports/timestamp.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/amports/timestamp.h>
 #include <linux/kernel.h>
-#include <linux/amports/tsync.h>
+#include <linux/amlogic/amports/tsync.h>
 
 #define AVMLVIDEO_MODULE_NAME "amlvideo"
 
diff --git a/drivers/amlogic/video_dev/amlvideo2.c b/drivers/amlogic/video_dev/amlvideo2.c
index 723e0f6e8572..dac585a40f87 100755
--- a/drivers/amlogic/video_dev/amlvideo2.c
+++ b/drivers/amlogic/video_dev/amlvideo2.c
@@ -27,21 +27,22 @@
 #include <linux/kthread.h>
 #include <linux/highmem.h>
 #include <linux/freezer.h>
+#include <linux/platform_device.h>
 #include <media/videobuf-res.h>
 #include <media/videobuf-core.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <linux/types.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
-#include <linux/ge2d/ge2d.h>
-#include <linux/amports/timestamp.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/amports/timestamp.h>
 #include <linux/kernel.h>
-#include <linux/tvin/tvin_v4l2.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vout_notify.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
diff --git a/drivers/amlogic/video_dev/common/vfp-queue.h b/drivers/amlogic/video_dev/common/vfp-queue.h
index a74253989871..3da45090217f 100755
--- a/drivers/amlogic/video_dev/common/vfp-queue.h
+++ b/drivers/amlogic/video_dev/common/vfp-queue.h
@@ -1,6 +1,6 @@
 #ifndef __VFP_QUEUE_H__
 #define __VFP_QUEUE_H__
-#include <linux/amports/vfp.h>
+#include <linux/amlogic/amports/vfp.h>
 
 static inline bool vfq_full(vfq_t *q)
 {
diff --git a/drivers/amlogic/video_dev/common/vfutil.c b/drivers/amlogic/video_dev/common/vfutil.c
index 8e6e7882a6d3..f29ef8419963 100755
--- a/drivers/amlogic/video_dev/common/vfutil.c
+++ b/drivers/amlogic/video_dev/common/vfutil.c
@@ -19,14 +19,14 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/ctype.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/timestamp.h>
-#include <linux/amports/tsync.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/amstream.h>
-#include <linux/vout/vout_notify.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/tsync.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #include <linux/sched.h>
 #include <linux/poll.h>
 #include <linux/clk.h>
diff --git a/include/linux/amlogic/ppmgr/ppmgr.h b/include/linux/amlogic/ppmgr/ppmgr.h
new file mode 100755
index 000000000000..8a01a320ab48
--- /dev/null
+++ b/include/linux/amlogic/ppmgr/ppmgr.h
@@ -0,0 +1,171 @@
+#ifndef  _PPMGR_MAIN_H
+#define  _PPMGR_MAIN_H
+#include <linux/interrupt.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
+#include <linux/sysfs.h>
+#include  <linux/spinlock.h>
+#include <linux/kthread.h>
+
+
+/**************************************************************
+**																	 **
+**	macro define		 												 **
+**																	 **
+***************************************************************/
+
+#define PPMGR_IOC_MAGIC  'P'
+#define PPMGR_IOC_2OSD0		_IOW(PPMGR_IOC_MAGIC, 0x00, unsigned int)
+#define PPMGR_IOC_ENABLE_PP _IOW(PPMGR_IOC_MAGIC,0X01,unsigned int)
+#define PPMGR_IOC_CONFIG_FRAME  _IOW(PPMGR_IOC_MAGIC,0X02,unsigned int)
+#define PPMGR_IOC_GET_ANGLE  _IOR(PPMGR_IOC_MAGIC,0X03,unsigned int)
+#define PPMGR_IOC_SET_ANGLE  _IOW(PPMGR_IOC_MAGIC,0X04,unsigned int)
+
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+#define PPMGR_IOC_VIEW_MODE  _IOW(PPMGR_IOC_MAGIC,0X05,unsigned int)
+#define PPMGR_IOC_HOR_VER_DOUBLE  _IOW(PPMGR_IOC_MAGIC,0X06,unsigned int)
+#define PPMGR_IOC_SWITCHMODE  _IOW(PPMGR_IOC_MAGIC,0X07,unsigned int)
+#define PPMGR_IOC_3D_DIRECTION  _IOW(PPMGR_IOC_MAGIC,0X08,unsigned int)
+#define PPMGR_IOC_3D_SCALE_DOWN  _IOW(PPMGR_IOC_MAGIC,0X09,unsigned int)
+#endif
+/**************************************************************
+**																	 **
+**	type  define		 												 **
+**																	 **
+***************************************************************/
+
+typedef struct {
+    int width;
+    int height;
+    int bpp;
+    int angle;
+    int format;
+} frame_info_t;
+
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+//mode: bit0-7, process type: disable, 3d, 2d->3d, 3d->2d
+#define PPMGR_3D_PROCESS_MODE_MASK                    0xff
+#define PPMGR_3D_PROCESS_MODE_SHIFT                   0
+#define PPMGR_3D_PROCESS_MODE_DISABLE                 0
+#define PPMGR_3D_PROCESS_MODE_3D_ENABLE               1
+#define PPMGR_3D_PROCESS_MODE_3D_TO_2D                2
+#define PPMGR_3D_PROCESS_MODE_2D_TO_3D                3
+
+//mode: bit 8-9, detect src format: 0-auto check, 1- lr format, 2-tb format
+#define PPMGR_3D_PROCESS_SRC_FOMRAT_MASK              0x00000300
+#define PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT             8
+#define PPMGR_3D_PROCESS_SRC_FOMRAT_AUTO              0
+#define PPMGR_3D_PROCESS_SRC_FOMRAT_LR                1
+#define PPMGR_3D_PROCESS_SRC_FOMRAT_TB                2
+
+//mode: bit 10, L-R/T-B switch flag: 0-no switch, 1-switch
+#define PPMGR_3D_PROCESS_SWITCH_FLAG                  0x00000400
+
+//mode: bit 11, 3D->2D, use L/T frame : 0-L/T, 1-R/B
+#define PPMGR_3D_PROCESS_3D_TO_2D_SRC_FRAME           0x00000800
+
+//mode: bit 12-13, horizontal/vertical double mode, for full/half format 3d src: 0-none, 1-hor double, 2-ver double
+#define PPMGR_3D_PROCESS_DOUBLE_TYPE                  0x00003000
+#define PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT            12
+#define PPMGR_3D_PROCESS_DOUBLE_TYPE_NONE             0
+#define PPMGR_3D_PROCESS_DOUBLE_TYPE_HOR              1
+#define PPMGR_3D_PROCESS_DOUBLE_TYPE_VER              2
+
+//mode: bit 14-15 2d to 3d control
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_MASK        0x0000c000
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_SHIFT       14
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_NONE        0
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_LEFT_MOVE   1
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_RIGHT_MOVE  2
+
+//mode: bit 16-19, 2D->3D function: 0-normal, 1- field depth
+#define PPMGR_3D_PROCESS_2D_TO_3D_MASK                0x000f0000
+#define PPMGR_3D_PROCESS_2D_TO_3D_SHIFT               16
+#define PPMGR_3D_PROCESS_2D_TO_3D_NORMAL              0
+#define PPMGR_3D_PROCESS_2D_TO_3D_FIELD_DEPTH         1
+
+//mode: bit 20-27 2d to 3d control value
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_VALUE_MASK  0x0ff00000
+#define PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_VAULE_SHIFT 20
+
+//mode: bit 28-29 3d rotate direction control
+//#define PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK        0x30000000
+//#define PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT 28
+
+//mode bit:30-31 not used
+
+#define EXTERNAL_MODE_3D_DISABLE         PPMGR_3D_PROCESS_MODE_DISABLE  //0x00000000
+
+#define EXTERNAL_MODE_3D_AUTO            PPMGR_3D_PROCESS_MODE_3D_ENABLE|(PPMGR_3D_PROCESS_SRC_FOMRAT_AUTO<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT) //0x00000001
+#define EXTERNAL_MODE_3D_AUTO_SWITCH     PPMGR_3D_PROCESS_MODE_3D_ENABLE|(PPMGR_3D_PROCESS_SRC_FOMRAT_AUTO<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT)|PPMGR_3D_PROCESS_SWITCH_FLAG //0x00000401
+#define EXTERNAL_MODE_3D_LR              PPMGR_3D_PROCESS_MODE_3D_ENABLE|(PPMGR_3D_PROCESS_SRC_FOMRAT_LR<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT) //0x00000101
+#define EXTERNAL_MODE_3D_LR_SWITCH       PPMGR_3D_PROCESS_MODE_3D_ENABLE|(PPMGR_3D_PROCESS_SRC_FOMRAT_LR<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT)|PPMGR_3D_PROCESS_SWITCH_FLAG //0x00000501
+#define EXTERNAL_MODE_3D_TB              PPMGR_3D_PROCESS_MODE_3D_ENABLE|(PPMGR_3D_PROCESS_SRC_FOMRAT_TB<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT) //0x00000201
+#define EXTERNAL_MODE_3D_TB_SWITCH       PPMGR_3D_PROCESS_MODE_3D_ENABLE|(PPMGR_3D_PROCESS_SRC_FOMRAT_TB<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT)|PPMGR_3D_PROCESS_SWITCH_FLAG //0x00000601
+
+#define EXTERNAL_MODE_3D_TO_2D_AUTO_1    PPMGR_3D_PROCESS_MODE_3D_TO_2D|(PPMGR_3D_PROCESS_SRC_FOMRAT_AUTO<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT) //0x00000002
+#define EXTERNAL_MODE_3D_TO_2D_AUTO_2    PPMGR_3D_PROCESS_MODE_3D_TO_2D|(PPMGR_3D_PROCESS_SRC_FOMRAT_AUTO<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT)|PPMGR_3D_PROCESS_3D_TO_2D_SRC_FRAME //0x00000802
+#define EXTERNAL_MODE_3D_TO_2D_L         PPMGR_3D_PROCESS_MODE_3D_TO_2D|(PPMGR_3D_PROCESS_SRC_FOMRAT_LR<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT) //0x00000102
+#define EXTERNAL_MODE_3D_TO_2D_R         PPMGR_3D_PROCESS_MODE_3D_TO_2D|(PPMGR_3D_PROCESS_SRC_FOMRAT_LR<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT)|PPMGR_3D_PROCESS_3D_TO_2D_SRC_FRAME  //0x00000902
+#define EXTERNAL_MODE_3D_TO_2D_T         PPMGR_3D_PROCESS_MODE_3D_TO_2D|(PPMGR_3D_PROCESS_SRC_FOMRAT_TB<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT) //0x00000202
+#define EXTERNAL_MODE_3D_TO_2D_B         PPMGR_3D_PROCESS_MODE_3D_TO_2D|(PPMGR_3D_PROCESS_SRC_FOMRAT_TB<<PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT)|PPMGR_3D_PROCESS_3D_TO_2D_SRC_FRAME //0x00000a02
+
+#define EXTERNAL_MODE_2D_TO_3D           PPMGR_3D_PROCESS_MODE_2D_TO_3D|(PPMGR_3D_PROCESS_2D_TO_3D_NORMAL<<PPMGR_3D_PROCESS_2D_TO_3D_SHIFT)  //0x00000003
+#define EXTERNAL_MODE_FIELD_DEPTH        PPMGR_3D_PROCESS_MODE_2D_TO_3D|(PPMGR_3D_PROCESS_2D_TO_3D_FIELD_DEPTH<<PPMGR_3D_PROCESS_2D_TO_3D_SHIFT) //0x00010003
+
+#define TYPE_NONE           0
+#define TYPE_2D_TO_3D       1
+#define TYPE_3D_LR          2
+#define TYPE_3D_TB          3
+#define TYPE_3D_TO_2D_LR    4
+#define TYPE_3D_TO_2D_TB    5
+
+typedef enum {
+    VIEWMODE_NORMAL  = 0,
+    VIEWMODE_FULL,
+    VIEWMODE_4_3,
+    VIEWMODE_16_9,
+    VIEWMODE_1_1,
+    VIEWMODE_MAX
+} view_mode_t;
+#endif
+
+
+
+/*TV 3D mode*/
+#define MODE_3D_ENABLE      0x00000001
+#define MODE_AUTO           0x00000002
+#define MODE_2D_TO_3D       0x00000004
+#define MODE_LR             0x00000008
+#define MODE_BT             0x00000010
+#define MODE_LR_SWITCH      0x00000020
+#define MODE_FIELD_DEPTH    0x00000040
+#define MODE_3D_TO_2D_L     0x00000080
+#define MODE_3D_TO_2D_R     0x00000100
+
+#define LR_FORMAT_INDICATOR   0x00000200
+#define BT_FORMAT_INDICATOR   0x00000400
+
+#define TYPE_NONE           0
+#define TYPE_2D_TO_3D       1
+#define TYPE_LR             2
+#define TYPE_BT             3
+#define TYPE_LR_SWITCH      4
+#define TYPE_FILED_DEPTH    5
+#define TYPE_3D_TO_2D_L     6
+#define TYPE_3D_TO_2D_R     7
+
+
+typedef enum {
+    PLATFORM_MID  = 0,
+    PLATFORM_MBX,
+    PLATFORM_TV,
+    PLATFORM_MID_VERTICAL
+} platform_type_t;
+//#endif
+
+
+#endif
diff --git a/include/linux/amlogic/ppmgr/ppmgr_status.h b/include/linux/amlogic/ppmgr/ppmgr_status.h
new file mode 100755
index 000000000000..9a6c818e6649
--- /dev/null
+++ b/include/linux/amlogic/ppmgr/ppmgr_status.h
@@ -0,0 +1,22 @@
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+extern int get_ppmgr_status(void);
+extern void set_ppmgr_status(int flag);
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+extern unsigned get_ppmgr_3dmode(void);
+extern void set_ppmgr_3dmode(unsigned mode);
+extern unsigned get_ppmgr_viewmode(void);
+extern void set_ppmgr_viewmode(unsigned mode);
+extern unsigned get_ppmgr_scaledown(void);
+extern void set_ppmgr_scaledown(unsigned scale_down);
+extern unsigned get_ppmgr_direction3d(void);
+extern void set_ppmgr_direction3d(unsigned angle);
+#endif
diff --git a/include/linux/amlogic/tvin/tvin_v4l2.h b/include/linux/amlogic/tvin/tvin_v4l2.h
new file mode 100755
index 000000000000..90d0b577ce7f
--- /dev/null
+++ b/include/linux/amlogic/tvin/tvin_v4l2.h
@@ -0,0 +1,740 @@
+/*
+ * TVIN Modules Exported Header File
+ *
+ * Author: kele bai <kele.bai@amlogic.com>
+ *       
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __TVIN_V4L2_H
+#define __TVIN_V4L2_H
+#include "tvin.h"
+/*
+   below macro defined applied to camera driver
+ */
+typedef enum camera_light_mode_e {
+        ADVANCED_AWB = 0,
+        SIMPLE_AWB,
+        MANUAL_DAY,
+        MANUAL_A,
+        MANUAL_CWF,
+        MANUAL_CLOUDY,
+}camera_light_mode_t;
+
+typedef enum camera_saturation_e {
+        SATURATION_N4_STEP = 0,
+        SATURATION_N3_STEP,
+        SATURATION_N2_STEP,
+        SATURATION_N1_STEP,
+        SATURATION_0_STEP,
+        SATURATION_P1_STEP,
+        SATURATION_P2_STEP,
+        SATURATION_P3_STEP,
+        SATURATION_P4_STEP,
+}camera_saturation_t;
+
+
+typedef enum camera_brightness_e {
+        BRIGHTNESS_N4_STEP = 0,
+        BRIGHTNESS_N3_STEP,
+        BRIGHTNESS_N2_STEP,
+        BRIGHTNESS_N1_STEP,
+        BRIGHTNESS_0_STEP,
+        BRIGHTNESS_P1_STEP,
+        BRIGHTNESS_P2_STEP,
+        BRIGHTNESS_P3_STEP,
+        BRIGHTNESS_P4_STEP,
+}camera_brightness_t;
+
+typedef enum camera_contrast_e {
+        CONTRAST_N4_STEP = 0,
+        CONTRAST_N3_STEP,
+        CONTRAST_N2_STEP,
+        CONTRAST_N1_STEP,
+        CONTRAST_0_STEP,
+        CONTRAST_P1_STEP,
+        CONTRAST_P2_STEP,
+        CONTRAST_P3_STEP,
+        CONTRAST_P4_STEP,
+}camera_contrast_t;
+
+typedef enum camera_hue_e {
+        HUE_N180_DEGREE = 0,
+        HUE_N150_DEGREE,
+        HUE_N120_DEGREE,
+        HUE_N90_DEGREE,
+        HUE_N60_DEGREE,
+        HUE_N30_DEGREE,
+        HUE_0_DEGREE,
+        HUE_P30_DEGREE,
+        HUE_P60_DEGREE,
+        HUE_P90_DEGREE,
+        HUE_P120_DEGREE,
+        HUE_P150_DEGREE,
+}camera_hue_t;
+
+typedef enum camera_special_effect_e {
+        SPECIAL_EFFECT_NORMAL = 0,
+        SPECIAL_EFFECT_BW,
+        SPECIAL_EFFECT_BLUISH,
+        SPECIAL_EFFECT_SEPIA,
+        SPECIAL_EFFECT_REDDISH,
+        SPECIAL_EFFECT_GREENISH,
+        SPECIAL_EFFECT_NEGATIVE,
+}camera_special_effect_t;
+
+typedef enum camera_exposure_e {
+        EXPOSURE_N4_STEP = 0,
+        EXPOSURE_N3_STEP,
+        EXPOSURE_N2_STEP,
+        EXPOSURE_N1_STEP,
+        EXPOSURE_0_STEP,
+        EXPOSURE_P1_STEP,
+        EXPOSURE_P2_STEP,
+        EXPOSURE_P3_STEP,
+        EXPOSURE_P4_STEP,
+}camera_exposure_t;
+
+
+typedef enum camera_sharpness_e {
+        SHARPNESS_1_STEP = 0,
+        SHARPNESS_2_STEP,
+        SHARPNESS_3_STEP,
+        SHARPNESS_4_STEP,
+        SHARPNESS_5_STEP,
+        SHARPNESS_6_STEP,
+        SHARPNESS_7_STEP,
+        SHARPNESS_8_STEP,
+        SHARPNESS_AUTO_STEP,
+}camera_sharpness_t;
+
+typedef enum camera_mirror_flip_e {
+        MF_NORMAL = 0,
+        MF_MIRROR,
+        MF_FLIP,
+        MF_MIRROR_FLIP,
+}camera_mirror_flip_t;
+
+
+typedef enum camera_wb_flip_e {
+        CAM_WB_AUTO = 0,
+        CAM_WB_CLOUD,
+        CAM_WB_DAYLIGHT,
+        CAM_WB_INCANDESCENCE,
+        CAM_WB_TUNGSTEN,
+        CAM_WB_FLUORESCENT,
+        CAM_WB_MANUAL,
+        CAM_WB_SHADE,
+        CAM_WB_TWILIGHT,
+        CAM_WB_WARM_FLUORESCENT,
+}camera_wb_flip_t;
+
+typedef enum camera_focus_mode_e {
+        CAM_FOCUS_MODE_RELEASE = 0,
+        CAM_FOCUS_MODE_FIXED,
+        CAM_FOCUS_MODE_INFINITY,
+        CAM_FOCUS_MODE_AUTO,
+        CAM_FOCUS_MODE_MACRO,
+        CAM_FOCUS_MODE_EDOF,
+        CAM_FOCUS_MODE_CONTI_VID,
+        CAM_FOCUS_MODE_CONTI_PIC,
+}camera_focus_mode_t;
+
+//removed this when move to new v4l2
+#define V4L2_CID_AUTO_FOCUS_START               (V4L2_CID_CAMERA_CLASS_BASE+28)
+#define V4L2_CID_AUTO_FOCUS_STOP                (V4L2_CID_CAMERA_CLASS_BASE+29)
+#define V4L2_CID_AUTO_FOCUS_STATUS              (V4L2_CID_CAMERA_CLASS_BASE+30)
+#define V4L2_AUTO_FOCUS_STATUS_IDLE             (0 << 0)
+#define V4L2_AUTO_FOCUS_STATUS_BUSY             (1 << 0)
+#define V4L2_AUTO_FOCUS_STATUS_REACHED          (1 << 1)
+#define V4L2_AUTO_FOCUS_STATUS_FAILED           (1 << 2)
+//removed this when move to new v4l2
+
+typedef enum camera_night_mode_flip_e {
+        CAM_NM_AUTO = 0,
+        CAM_NM_ENABLE,
+}camera_night_mode_flip_t;
+
+typedef enum camera_effect_flip_e {
+        CAM_EFFECT_ENC_NORMAL = 0,
+        CAM_EFFECT_ENC_GRAYSCALE,
+        CAM_EFFECT_ENC_SEPIA,
+        CAM_EFFECT_ENC_SEPIAGREEN,
+        CAM_EFFECT_ENC_SEPIABLUE,
+        CAM_EFFECT_ENC_COLORINV,
+}camera_effect_flip_t;
+
+typedef enum camera_banding_flip_e {
+        CAM_BANDING_DISABLED = 0,
+        CAM_BANDING_50HZ,
+        CAM_BANDING_60HZ,
+        CAM_BANDING_AUTO,
+        CAM_BANDING_OFF,
+}camera_banding_flip_t;
+
+typedef struct camera_info_s {
+        const char * camera_name;
+        enum camera_saturation_e saturation;
+        enum camera_brightness_e brighrness;
+        enum camera_contrast_e contrast;
+        enum camera_hue_e hue;
+        //  enum camera_special_effect_e special_effect;
+        enum camera_exposure_e exposure;
+        enum camera_sharpness_e sharpness;
+        enum camera_mirror_flip_e mirro_flip;
+        enum tvin_sig_fmt_e resolution;
+        enum camera_wb_flip_e white_balance;
+        enum camera_night_mode_flip_e night_mode;
+        enum camera_effect_flip_e effect;
+        int qulity;
+}camera_info_t;
+
+/* ---------- enum ---------- */
+
+// LPF responding time: cycles to reach 90% target
+typedef enum xml_resp_s {
+        XML_RESP_0 = 0, // immediately
+        XML_RESP_1,     // 10 cycles
+        XML_RESP_2,     // 20 cycles
+        XML_RESP_3,     // 50 cycles
+        XML_RESP_4,     // 100 cycles
+        XML_RESP_5,     // 200 cycles
+        XML_RESP_6,     // 400 cycles
+        XML_RESP_7,     // 800 cycles
+        XML_RESP_8,     // 1600 cycles
+        XML_RESP_9,     // 3200 cycles
+} xml_resp_t;
+
+typedef enum cam_scanmode_e {
+        CAM_SCANMODE_NULL = 0,//turn off af
+        CAM_SCANMODE_PROBE,
+        CAM_SCANMODE_FULL,
+} cam_scanmode_t;
+
+typedef enum cam_command_e {
+        // common
+        CAM_COMMAND_INIT = 0,
+        //CAM_COMMAND_FORMAT,
+        CAM_COMMAND_SCENES,
+        CAM_COMMAND_EFFECT,
+        CAM_COMMAND_AWB,
+        CAM_COMMAND_MWB,
+        CAM_COMMAND_SET_WORK_MODE,
+        // ae related
+        CAM_COMMAND_AE_ON,
+        CAM_COMMAND_AE_OFF,
+        //CAM_COMMAND_EXPOSURE,
+        //CAM_COMMAND_ISO_ANALOG,
+        //CAM_COMMAND_ISO_DIGITAL,
+        // af related
+        CAM_COMMAND_AF,
+        CAM_COMMAND_FULLSCAN,
+        CAM_COMMAND_TOUCH_WINDOW,
+        CAM_COMMAND_TOUCH_FOCUS_ON,
+        CAM_COMMAND_TOUCH_FOCUS_OFF,
+        CAM_COMMAND_CONTINUOUS_FOCUS_ON,
+        CAM_COMMAND_CONTINUOUS_FOCUS_OFF,
+        CAM_COMMAND_BACKGROUND_FOCUS_ON,
+        CAM_COMMAND_BACKGROUND_FOCUS_OFF,  
+        // flash related
+        CAM_COMMAND_SET_FLASH_MODE,
+        // torch related
+        CAM_COMMAND_TORCH,
+} cam_command_t;
+extern const char *cam_cmd_to_str(cam_command_t cmd);
+
+/* ---------- xml struct ---------- */
+
+
+// all "0" means no vcm
+typedef struct xml_vcm_s {
+        unsigned short vcm_max;
+        unsigned short vcm_min;
+        unsigned short vcm_reseponding_time; // in the unit of mS, responding_cycle = responding_time/sensor_frame_rate + 1, 1 for IIC and so on
+} xml_vcm_t;
+
+//"0" means no flash
+typedef enum flash_mode_s {
+	FLASH_MODE_NULL = 0,//no use flash
+	FLASH_MODE_ON,
+	FLASH_MODE_OFF,
+	FLASH_MODE_AUTO,
+}flash_mode_t;
+
+#define WAVE_PARM_NUM		12
+typedef struct wave_s {
+	unsigned int torch_rising_time; 
+	unsigned int flash_rising_time; 
+	unsigned int torch_flash_ratio; 
+    unsigned int wave_clock_div;     // u16
+    unsigned int pulse_init_time;    // u11
+    unsigned int pulse_high_time;    // u11
+    unsigned int pulse_low_time;     // u11
+    unsigned int time_to_latch;      // u26
+    unsigned int latch_time;         // u26
+    unsigned int latch_time_timeout; // u26
+    unsigned int time_to_off;        // u11
+    unsigned int pulse_qty_max;      // u8
+} wave_t;
+
+
+typedef struct xml_window_s {
+        unsigned char ratio_x0; // 0 ~ 255, x0 = (format.h * ratio_x0) >> 8
+        unsigned char ratio_y0; // 0 ~ 255, y0 = (format.v * ratio_y0) >> 8
+        unsigned char ratio_x1; // 0 ~ 255, x1 = (format.h * ratio_x1) >> 8
+        unsigned char ratio_y1; // 0 ~ 255, y1 = (format.v * ratio_y1) >> 8
+} xml_window_t;
+
+#define AE_PARM_NUM			55
+typedef struct xml_algorithm_ae_s {
+        unsigned int  ae_algorithm;       //0:basic;    1:enhanced
+        unsigned int  ae_statistics[3];   //0: false, 1: true
+        unsigned int  ae_exp[3];          //0: false, 1: true
+        unsigned int  ae_ag[3];           //0: false, 1: true
+		unsigned int  ae_skip[3];         //0: false, 1: true
+        unsigned int  alert_mode;  //0: disable, 1: enable
+        unsigned int  tune_mode;  //0: average mode, 1: blind up mode
+        unsigned int  ratio_r;  // 0 ~ 255
+        unsigned int  ratio_g;  // 0 ~ 255
+        unsigned int  ratio_b;  // 0 ~ 255
+        unsigned int  stepdnr;    // 0 ~ 255
+        unsigned int  stepdng;    // 0 ~ 255
+        unsigned int  stepdnb;    // 0 ~ 255
+        unsigned int  stepup;     // 0 ~ 255
+        unsigned int  slow_lpfcoef;   // 0 ~ 255
+        unsigned int  fast_lpfcoef;   // 0 ~ 255
+        unsigned int  coef_cur[16];  // 0 ~ 1023
+        unsigned int  coef_env[16];  // 0 ~ 1023
+        unsigned int  env_hign;     // 0 ~ 255
+        unsigned int  env_hign2mid;  // 0 ~ 255
+        unsigned int  env_low2mid;    // 0 ~ 255
+        unsigned int  env_low;    // 0 ~ 255
+        unsigned int  thr_r_high; //0 ~ 255
+        unsigned int  thr_r_mid; //0 ~ 255
+        unsigned int  thr_r_low; //0 ~ 255
+        unsigned int  thr_g_high; //0 ~ 255
+        unsigned int  thr_g_mid; //0 ~ 255
+        unsigned int  thr_g_low; //0 ~ 255
+        unsigned int  thr_b_high; //0 ~ 255
+        unsigned int  thr_b_mid; //0 ~ 255
+        unsigned int  thr_b_low; //0 ~ 255
+        unsigned int  lpftype_high; //0 ~ 255
+        unsigned int  lpftype_mid; //0 ~ 255
+        unsigned int  lpftype_low; //0 ~ 255
+        unsigned int  targethigh;  // 0 ~ 255
+        unsigned int  targetmid;  // 0 ~ 255
+        unsigned int  targetlow;  // 0 ~ 255
+        unsigned int  radium_inner_h;  // 0 ~ 255
+        unsigned int  radium_outer_h;  // 0 ~ 255
+        unsigned int  radium_inner_m;  // 0 ~ 255
+        unsigned int  radium_outer_m;  // 0 ~ 255
+        unsigned int  radium_inner_l;  // 0 ~ 255
+        unsigned int  radium_outer_l;  // 0 ~ 255
+        unsigned int  flash_thr;       // 0 ~ 255 
+
+    /***********************AE_ENH********************************/
+	                
+        unsigned int           ratio_histr;          // 0 ~1023 
+        unsigned int           ratio_histg;          // 0 ~1023 
+        unsigned int           ratio_histb;          // 0 ~1023 
+        unsigned int           target_r;             // 0 ~ 255 
+        unsigned int           target_g;             // 0 ~ 255 
+        unsigned int           target_b;             // 0 ~ 255 
+        unsigned int           maxrate_inner;        // 0 ~1023 
+        unsigned int           maxrate_outer;        // 0 ~1023 
+        unsigned int           slow_lpfcoef_enh;     // 0 ~ 255 
+        unsigned int           fast_lpfcoef_enh;     // 0 ~ 255 
+        unsigned int           flash_thr_enh;	     // 0 ~ 255                 
+} xml_algorithm_ae_t;
+
+#define AWB_PARM_NUM			53
+typedef struct xml_algorithm_awb_s {
+        unsigned int           awb_algorithm;       //0:basic;    1:enhanced
+        unsigned int  	       ratio_rgb;             // 0 ~ 255 
+        unsigned int           ratio_yh;              // 0 ~ 255 
+        unsigned int 	       ratio_ym;              // 0 ~ 255 
+        unsigned int 	       ratio_yl;              // 0 ~ 255 
+        unsigned int 	       yyh;                   // 0 ~ 255 
+        unsigned int 	       yym;                   // 0 ~ 255 
+        unsigned int 	       yyl;                   // 0 ~ 255 
+        unsigned int 	       coef_r[4];             // 0 ~ 255 
+        unsigned int 	       coef_g[4];             // 0 ~ 255 
+        unsigned int 	       coef_b[4];             // 0 ~ 255 
+        unsigned int 	       inner_rg;          // 0 ~ 1023 
+        unsigned int 	       outer_rg;          // 0 ~ 1023
+        unsigned int 	       inner_bg;          // 0 ~ 1023
+        unsigned int 	       outer_bg;          // 0 ~ 1023
+        unsigned int           r_max;             // 0 ~ 4095    
+        unsigned int           r_min;             // 0 ~ 4095
+        unsigned int           b_max;             // 0 ~ 4095    
+        unsigned int           b_min;             // 0 ~ 4095
+        unsigned int           thr_gb_h;          // 0 ~ 255
+        unsigned int           thr_gb_m;          // 0 ~ 255
+        unsigned int           thr_gb_l;          // 0 ~ 255
+        unsigned int           thr_gr_h;          // 0 ~ 255
+        unsigned int           thr_gr_m;          // 0 ~ 255
+        unsigned int           thr_gr_l;          // 0 ~ 255
+        unsigned int           thr_br_h;          // 0 ~ 255
+        unsigned int           thr_br_m;          // 0 ~ 255
+        unsigned int           thr_br_l;          // 0 ~ 255
+        unsigned int           thr_du_h;          // 0 ~ 255
+        unsigned int           thr_du_m;          // 0 ~ 255
+        unsigned int           thr_du_l;          // 0 ~ 255
+        unsigned int           thr_dv_h;          // 0 ~ 255
+        unsigned int           thr_dv_m;          // 0 ~ 255
+        unsigned int           thr_dv_l;          // 0 ~ 255
+        unsigned int           thr_yh_h;          // 0 ~ 255
+        unsigned int           thr_yh_m;          // 0 ~ 255
+        unsigned int           thr_yh_l;          // 0 ~ 255
+        unsigned int           thr_yl_h;          // 0 ~ 255
+        unsigned int           thr_yl_m;          // 0 ~ 255
+        unsigned int           thr_yl_l;          // 0 ~ 255
+		/*********************awb_enh****************/
+    	unsigned int           ratio_yuv;    
+        unsigned int           slow_lpfcoef;    // 0 ~ 255
+        unsigned int           fast_lpfcoef;    // 0 ~ 255
+        unsigned int           outer;           // 0 ~ 1023
+        unsigned int           inner;           // 0 ~ 1023
+        unsigned int           rw_limith;       // 0 ~ 4095
+        unsigned int           rw_limitl;       // 0 ~ 4095
+        unsigned int           gw_limith;       // 0 ~ 4095
+        unsigned int           gw_limitl;       // 0 ~ 4095
+        unsigned int           bw_limith;       // 0 ~ 4095
+        unsigned int           bw_limitl;       // 0 ~ 4095
+        unsigned int           thr_u[20];       // 0 ~ 255
+        unsigned int           thr_v[20];       // 0 ~ 255
+} xml_algorithm_awb_t;
+
+#define AF_PARM_NUM			19
+
+#define FOCUS_GRIDS 16
+
+typedef struct xml_algorithm_af_s {
+    // normalization: f0_coef0+...+f0_coef7 = 256
+    /*for climbing algorithm*/
+	unsigned int step[FOCUS_GRIDS];
+	unsigned int		   step_min;
+	unsigned int		   step_max;
+	unsigned int           f_thr_p;
+	unsigned int 		   f_thr_n;
+	unsigned int 	       step_coarse;
+	unsigned int	       step_fine;
+	unsigned int           stable_timeout;//ms
+} xml_algorithm_af_t;
+
+#define XML_LUT_LS 1024 // 32*32 32-bit
+typedef struct xml_lut_ls_s {
+        unsigned int reg_map[XML_LUT_LS];
+} xml_lut_ls_t;
+
+
+#define XML_LUT_GC 257 // 257*3 10-bit
+typedef struct xml_lut_gc_s {
+        unsigned short gamma_r[XML_LUT_GC];
+	unsigned short gamma_g[XML_LUT_GC];
+	unsigned short gamma_b[XML_LUT_GC];
+} xml_lut_gc_t;
+
+#define XML_TOP 9 // top
+typedef struct xml_top_s {
+        unsigned int reg_map[XML_TOP];
+} xml_top_t;
+
+#define XML_TP 24 // test pattern
+typedef struct xml_tp_s {
+        unsigned int reg_map[XML_TP];
+} xml_tp_t;
+
+#define XML_CG 6 // clamp & gain
+typedef struct xml_cg_s {
+        unsigned int reg_map[XML_CG];
+} xml_cg_t;
+
+#define XML_LS 5 // lens shielding
+typedef struct xml_ls_s {
+        unsigned int reg_map[XML_LS];
+} xml_ls_t;
+
+#define XML_GC 1 // gamma curve
+typedef struct xml_gc_s {
+        unsigned int reg_map[XML_GC];
+} xml_gc_t;
+
+#define XML_DP 11 // defect pixel
+typedef struct xml_dp_s {
+        unsigned int reg_map[XML_DP];
+} xml_dp_t;
+
+#define XML_DM 2 // demosaicing
+typedef struct xml_dm_s {
+        unsigned int reg_map[XML_DM];
+} xml_dm_t;
+
+#define XML_CSC 9 // colr space convertion
+typedef struct xml_csc_s {
+        unsigned int reg_map[XML_CSC<<1];//sd/hd sensitive
+} xml_csc_t;
+
+#define XML_NR 13 // noise reduction
+typedef struct xml_nr_s {
+        unsigned int reg_map[XML_NR];
+} xml_nr_t;
+
+#define XML_SH 33 // shanrpness
+typedef struct xml_sharp_s {
+        unsigned int reg_map[XML_SH];
+} xml_sharp_t;
+
+#define XML_DBG 2 // debug
+typedef struct xml_dbg_s {
+        unsigned int reg_map[XML_DBG];
+} xml_dbg_t;
+
+#define XML_BN 3 // black level & noise meter
+typedef struct xml_bn_s {
+        unsigned int reg_map[XML_BN];
+} xml_bn_t;
+
+#define XML_AE 6 // auto explosure statistics
+typedef struct xml_ae_s {
+        unsigned int reg_map[XML_AE];
+} xml_ae_t;
+
+#define XML_AWB 5 // auto white balance statistics
+typedef struct xml_awb_s {
+        unsigned int reg_map[XML_AWB];
+} xml_awb_t;
+
+#define XML_AF 17 // auto focus statistics
+typedef struct xml_af_s {
+        unsigned int reg_map[XML_AF];
+} xml_af_t;
+/*
+#define XML_WAVE 1 // wave generatore
+typedef struct xml_wave_s {
+        unsigned int reg_map[XML_WAVE];
+} xml_wave_t;
+*/
+typedef struct xml_peripheral_s {
+        //struct xml_sensor_s sensor;
+        //struct xml_ae_level_s  ae_level;
+        struct xml_vcm_s       vcm;
+} xml_peripheral_t;
+
+typedef struct xml_default_regs_s {
+        struct xml_top_s          top;    
+        struct xml_tp_s           tp;     // disable
+        struct xml_cg_s           cg;     // straight
+        struct xml_ls_s           ls;
+        struct xml_gc_s           gc;
+        struct xml_dp_s           dp;     // w/o static lut
+        struct xml_dm_s           dm;
+        struct xml_csc_s          csc;    // RGB->YUV
+        struct xml_nr_s           nr;     // disable
+        struct xml_sharp_s        sharp;  // disable
+        struct xml_dbg_s          dbg;    // disable
+        struct xml_bn_s           bn;     // disable
+        struct xml_ae_s           ae_reg;
+        struct xml_awb_s          awb_reg;
+        struct xml_af_s           af_reg;
+	struct xml_lut_ls_s	  lnsd;
+	struct xml_lut_gc_s	  lut_gc;				  
+} xml_default_regs_t;
+
+typedef struct xml_scenes_s {
+        struct xml_algorithm_ae_s  ae;
+        struct xml_algorithm_awb_s awb;
+        struct xml_algorithm_af_s  af;
+} xml_scenes_t;
+/*only G0 R1 B2 G3*/
+typedef struct xml_wb_manual_s {        
+        unsigned int reg_map[2];
+} xml_wb_manual_t;
+
+typedef struct xml_effect_manual_s {
+        struct xml_csc_s csc; // RGB->YUV with effect: r, g, b, brightness, contrast, hue, saturation, y_mirror, ...
+} xml_effect_manual_t;
+
+/* ---------- camera struct ---------- */
+//start tvin service will get format information
+/*typedef struct cam_format_s {
+    unsigned short h;
+    unsigned short v;
+    unsigned short frame_time; // in the unit of uS, for example, frame_time = 40(mS) means 25Hz format.
+} cam_format_t;
+*/
+typedef struct cam_function_s {
+	bool (*set_af_new_step)(unsigned int af_debug_control);    
+	unsigned int (*get_aet_current_step)(void);
+	short (*get_aet_current_gain)(void);
+	short (*get_aet_min_gain)(void);
+	short (*get_aet_max_gain)(void);
+	unsigned int (*get_aet_max_step)(void);
+	short (*get_aet_gain_by_step)(unsigned int new_step);
+	bool (*set_aet_new_step)(unsigned int new_step, bool exp_mode, bool ag_mode);
+	bool (*check_mains_freq)(void);
+} cam_function_t;
+
+
+typedef struct cam_manual_s {
+        unsigned short ae_step;
+        unsigned short focus;
+        unsigned short torch;
+} cam_manual_t;
+
+typedef struct cam_window_s {
+        unsigned short x0;
+        unsigned short y0;
+        unsigned short x1;
+        unsigned short y1;
+} cam_window_t;
+
+#define CAP_PARM_NUM			9
+typedef struct xml_capture_s {
+	unsigned int ae_en;
+	unsigned int awb_en;
+	cam_scanmode_t af_mode;
+	unsigned int sigle_count;
+	unsigned int skip_step;
+	unsigned int multi_capture_num;
+	unsigned int eyetime;//ms
+	unsigned int pretime;//ms
+	unsigned int postime;//ms
+} xml_capture_t;
+/*for isp work mode*/
+typedef enum camera_mode_e {
+	CAMERA_PREVIEW,
+	CAMERA_CAPTURE,
+	CAMERA_RECORD,
+} camera_mode_t;
+
+/*this parameter must be passed to vdin when stream on*/
+typedef struct cam_parameter_s {
+        enum cam_command_e          cam_command;
+        enum cam_scanmode_e         cam_scanmode;
+        struct cam_function_s       cam_function;
+        struct cam_manual_s         cam_manual;
+        struct cam_window_s         cam_touch_window;
+        struct xml_peripheral_s    *xml_peripheral;
+        struct xml_scenes_s   	   *xml_scenes;
+        struct xml_default_regs_s  *xml_regs_map;
+        struct xml_effect_manual_s *xml_effect_manual;
+        struct xml_wb_manual_s     *xml_wb_manual;
+	struct xml_capture_s	   *xml_capture;
+	struct wave_s		   *xml_wave;
+	unsigned int 		    level;//the torch light level 
+	flash_mode_t                flash_mode;//the flash mode
+	camera_mode_t		    cam_mode;//set the isp work mode
+} cam_parameter_t;
+
+typedef struct isp_status_s {
+        unsigned short focus;
+        bool           fullscan_done;
+} isp_status_t;
+
+typedef enum vdin_format_convert_e {
+	VDIN_MATRIX_XXX_YUV_BLACK = 0,
+	VDIN_FORMAT_CONVERT_YUV_YUV422,
+	VDIN_FORMAT_CONVERT_YUV_YUV444,
+	VDIN_FORMAT_CONVERT_YUV_RGB,
+	VDIN_FORMAT_CONVERT_YUV_GBR,
+	VDIN_FORMAT_CONVERT_YUV_BRG,
+	VDIN_FORMAT_CONVERT_RGB_YUV422,
+	VDIN_FORMAT_CONVERT_GBR_YUV422,
+	VDIN_FORMAT_CONVERT_BRG_YUV422,
+	VDIN_FORMAT_CONVERT_RGB_YUV444,
+	VDIN_FORMAT_CONVERT_RGB_RGB,
+	VDIN_FORMAT_CONVERT_YUV_NV12,
+	VDIN_FORMAT_CONVERT_YUV_NV21,
+	VDIN_FORMAT_CONVERT_RGB_NV12,
+	VDIN_FORMAT_CONVERT_RGB_NV21,	
+} vdin_format_convert_t;
+
+typedef enum vdin_cmd_e {
+	VDIN_CMD_NULL = 0,
+	VDIN_CMD_SET_CSC,
+} vdin_cmd_t;
+
+typedef struct vdin_arg_s {
+	vdin_cmd_t cmd;
+	unsigned char matrix_id;
+	vdin_format_convert_t color_convert;
+	unsigned int  private;
+} vdin_arg_t;
+
+typedef enum bt_path_e {
+	BT_PATH_GPIO=0,
+	BT_PATH_CSI2,
+} bt_path_t;
+
+// ***************************************************************************
+// *** IOCTL command definitions *****************************************
+// ***************************************************************************
+
+#define CAMERA_IOC_MAGIC 'C'
+
+
+#define CAMERA_IOC_START        _IOW(CAMERA_IOC_MAGIC, 0x01, struct camera_info_s)
+#define CAMERA_IOC_STOP         _IO(CAMERA_IOC_MAGIC, 0x02)
+#define CAMERA_IOC_SET_PARA     _IOW(CAMERA_IOC_MAGIC, 0x03, struct camera_info_s)
+#define CAMERA_IOC_GET_PARA     _IOR(CAMERA_IOC_MAGIC, 0x04, struct camera_info_s)
+#define CAMERA_IOC_START_CAPTURE_PARA     _IOR(CAMERA_IOC_MAGIC, 0x05, struct camera_info_s)
+#define CAMERA_IOC_STOP_CAPTURE_PARA     _IOR(CAMERA_IOC_MAGIC, 0x06, struct camera_info_s)
+
+
+
+//add for vdin called by backend driver
+typedef struct vdin_parm_s {
+        enum tvin_port_e     port;
+        enum tvin_sig_fmt_e  fmt;//>max:use the information from parameter rather than format table
+        enum tvin_color_fmt_e cfmt;//for camera input mainly,the data sequence is different
+        enum tvin_scan_mode_e scan_mode;//1: progressive 2:interlaced
+        unsigned short  h_active;
+        unsigned short  v_active;
+        unsigned short  frame_rate;
+        /*for bt656*/
+        enum bt_path_e  bt_path;//0:from gpio,1:from csi2 
+        unsigned char   hsync_phase;//1: inverted 0: original
+        unsigned char   vsync_phase;//1: inverted 0: origianl
+        unsigned short  hs_bp;//the horizontal start postion of bt656 window
+        unsigned short  vs_bp;//the vertical start postion of bt656 window
+        /*for isp tell different frontends such as bt656/mipi*/
+	enum tvin_port_e	 isp_fe_port;
+	/*for vdin cfmt convert & scale&skip*/
+        enum tvin_color_fmt_e dfmt;//vdin will convert color space accroding to dfmt
+	unsigned short  dest_hactive;//for vdin scale down
+	unsigned short  dest_vactive;
+	unsigned short	skip_count;//for skip frame
+	/*for reserved*/
+        unsigned int    reserved;
+} vdin_parm_t;
+
+typedef struct fe_arg_s {
+	enum tvin_port_e     port;
+	int 		     index;
+	void                 *arg;
+} fe_arg_t;
+
+typedef struct vdin_v4l2_ops_s {
+        int  (*start_tvin_service)(int no ,vdin_parm_t *para);
+        int  (*stop_tvin_service)(int no);
+        void (*set_tvin_canvas_info)(int start , int num);
+        void (*get_tvin_canvas_info)(int* start , int* num);
+	int  (*tvin_fe_func)(int no, fe_arg_t *arg);//for isp command
+	int  (*tvin_vdin_func)(int no, vdin_arg_t *arg);
+        void *private;
+} vdin_v4l2_ops_t;
+
+/*
+   macro defined applied to camera driver is ending
+ */
+extern int v4l2_vdin_ops_init(vdin_v4l2_ops_t* vdin_v4l2p);
+extern vdin_v4l2_ops_t *get_vdin_v4l2_ops(void);
+extern int vdin_reg_v4l2(vdin_v4l2_ops_t *ops);
+#endif
diff --git a/include/media/videobuf-res.h b/include/media/videobuf-res.h
new file mode 100755
index 000000000000..02c68d30d3e4
--- /dev/null
+++ b/include/media/videobuf-res.h
@@ -0,0 +1,39 @@
+/*******************************************************************
+ *
+ *  Copyright C 2012 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *
+ *  Author: Amlogic Software
+ *  Created: 2012/9/6   16:46
+ *
+ *******************************************************************/
+ 
+#ifndef _VIDEOBUF_RES_H
+#define _VIDEOBUF_RES_H
+
+#include <media/videobuf-core.h>
+
+struct videobuf_res_privdata {
+	//const* char dev_name;
+	u32 magic;
+	resource_size_t start;
+	resource_size_t end;
+	void* priv;
+};
+
+void videobuf_queue_res_init(struct videobuf_queue *q,
+				    const struct videobuf_queue_ops *ops,
+				    struct device *dev,
+				    spinlock_t *irqlock,
+				    enum v4l2_buf_type type,
+				    enum v4l2_field field,
+				    unsigned int msize,
+				    void *priv,
+				    struct mutex *ext_lock);
+
+resource_size_t videobuf_to_res(struct videobuf_buffer *buf);
+void videobuf_res_free(struct videobuf_queue *q,
+			      struct videobuf_buffer *buf);
+
+#endif /* _VIDEOBUF_RES_H */
-- 
2.19.0

