From c7e1703504eeaaae1aefdd915a677b0e759c208f Mon Sep 17 00:00:00 2001
From: "Chris.Sun" <qiuwei.sun@amlogic.com>
Date: Wed, 30 Oct 2013 18:04:40 +0800
Subject: [PATCH 1552/5965] Add support for sensors.

---
 arch/arm/configs/meson8_defconfig           |   21 +
 drivers/amlogic/input/sensor/Kconfig        |   26 +
 drivers/amlogic/input/sensor/Makefile       |    9 +-
 drivers/amlogic/input/sensor/bma222.c       |   39 -
 drivers/amlogic/input/sensor/bma250.c       |   39 -
 drivers/amlogic/input/sensor/cm3232.c       |   51 +-
 drivers/amlogic/input/sensor/cm36283.c      |   39 -
 drivers/amlogic/input/sensor/dmard06.c      |   39 -
 drivers/amlogic/input/sensor/dmt10.c        |   40 -
 drivers/amlogic/input/sensor/elan_epl6814.c |   37 -
 drivers/amlogic/input/sensor/kionix_accel.c |   48 -
 drivers/amlogic/input/sensor/lis3dh_acc.c   |   38 +-
 drivers/amlogic/input/sensor/lsm303d.c      |   37 -
 drivers/amlogic/input/sensor/ltr501_als.c   |   38 -
 drivers/amlogic/input/sensor/mc32x0.c       |   38 -
 drivers/amlogic/input/sensor/mm3a310.c      | 2543 ++++++++++++++++++
 drivers/amlogic/input/sensor/mma8452.c      |    2 +-
 drivers/amlogic/input/sensor/mxc622x.c      |  826 ++++++
 drivers/amlogic/input/sensor/stk220x_poll.c |  708 +++++
 drivers/amlogic/input/sensor/stk831x.c      | 2616 ++++++++++++++-----
 include/linux/sensor/cm3232.h               |   60 +
 include/linux/sensor/dmard06.h              |  159 ++
 include/linux/sensor/dmt10.h                |  174 ++
 include/linux/sensor/elan_interface.h       |  180 ++
 include/linux/sensor/kionix_accel.h         |   84 +
 include/linux/sensor/lis3dh.h               |  103 +
 include/linux/sensor/lsm303d.h              |  128 +
 include/linux/sensor/mm3a310.h              |  177 ++
 include/linux/sensor/mma8452.h              |   70 +
 include/linux/sensor/mxc622x.h              |   57 +
 include/linux/sensor/sensor_common.h        |    8 +
 include/linux/sensor/stk220x.h              |   87 +
 include/linux/sensor/stk8312.h              |   72 +
 include/linux/sensor/stk8313.h              |   73 +
 include/linux/sensor/stk_defines.h          |   50 +
 include/linux/sensor/stk_lk_defs.h          |   56 +
 36 files changed, 7577 insertions(+), 1195 deletions(-)
 create mode 100644 drivers/amlogic/input/sensor/mm3a310.c
 create mode 100644 drivers/amlogic/input/sensor/mxc622x.c
 create mode 100644 drivers/amlogic/input/sensor/stk220x_poll.c
 create mode 100644 include/linux/sensor/cm3232.h
 create mode 100644 include/linux/sensor/dmard06.h
 create mode 100644 include/linux/sensor/dmt10.h
 create mode 100644 include/linux/sensor/elan_interface.h
 create mode 100644 include/linux/sensor/kionix_accel.h
 create mode 100644 include/linux/sensor/lis3dh.h
 create mode 100644 include/linux/sensor/lsm303d.h
 create mode 100644 include/linux/sensor/mm3a310.h
 create mode 100644 include/linux/sensor/mma8452.h
 create mode 100644 include/linux/sensor/mxc622x.h
 create mode 100644 include/linux/sensor/sensor_common.h
 create mode 100644 include/linux/sensor/stk220x.h
 create mode 100644 include/linux/sensor/stk8312.h
 create mode 100644 include/linux/sensor/stk8313.h
 create mode 100644 include/linux/sensor/stk_defines.h
 create mode 100644 include/linux/sensor/stk_lk_defs.h

diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 096fc70bc7ca..7b886f839223 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -258,3 +258,24 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
 CONFIG_AVERAGE=y
+CONFIG_SENSOR_DEVICES=y
+CONFIG_GRAVITY_BMA250=y
+CONFIG_GRAVITY_BMA222=y
+CONFIG_GRAVITY_MMA7660=y
+CONFIG_GRAVITY_LIS3DH=y
+CONFIG_GRAVITY_MMA8452=y
+CONFIG_GRAVITY_MC32X0=y
+CONFIG_GRAVITY_DMARD06=y
+CONFIG_GRAVITY_MMA865X=y
+CONFIG_GRAVITY_STK8312=y
+CONFIG_GRAVITY_LSM303D=y
+CONFIG_GRAVITY_DMARD10=y
+CONFIG_GRAVITY_KXTJ9=y
+CONFIG_GRAVITY_MM3A310=y
+CONFIG_GRAVITY_MXC622X=y
+CONFIG_LIGHT_CM36283=y
+CONFIG_LIGHT_CM3232=y
+CONFIG_LIGHT_LTR501=y
+CONFIG_LIGHT_EPL6814=y
+CONFIG_LIGHT_STK220X=y
+
diff --git a/drivers/amlogic/input/sensor/Kconfig b/drivers/amlogic/input/sensor/Kconfig
index 499a04812f4a..099d60ffa5d1 100644
--- a/drivers/amlogic/input/sensor/Kconfig
+++ b/drivers/amlogic/input/sensor/Kconfig
@@ -92,6 +92,19 @@ config GRAVITY_STK8312
 	  Say yes here to support Sensortek's STK8312 accelerometer sensor
 endif
 
+config GRAVITY_MM3A310
+ 		tristate "MM3A310 GSENSOR support"
+ 		---help---
+ 		  Choose this option.
+ 		  If you say yes here you get support for MiraMEM's accelerometer
+ 		  sensor MM3A310.
+
+config GRAVITY_MXC622X
+	tristate "MXC622X 2-Axis acceleration sensor driver"
+	depends on I2C=y
+	help
+	  If you say yes here you get support for Memsic's 2-Axis
+	  acceleration sensors MXC622X.
 
 config LIGHT_CM36283
 	tristate "CM36283 light sensor driver"
@@ -118,4 +131,17 @@ config LIGHT_EPL6814
 	help
 	   Say Y here to enable the EPL6814.
 
+config LIGHT_ISL29023
+	tristate "ISL29023 light sensor driver"
+	depends on I2C
+	help
+	   Say Y here to enable Intersil's light sensor ISL29023.
+
+config LIGHT_STK220X
+	bool "STK2203 light sensor in polling mode"
+	help
+	    Say Y here to enable SensorTek's STK2203 using polling mode.
+
+
+
 endif # SENSOR_DEVICES 
diff --git a/drivers/amlogic/input/sensor/Makefile b/drivers/amlogic/input/sensor/Makefile
index ac5bb1a6ac3f..90c5afb55d82 100644
--- a/drivers/amlogic/input/sensor/Makefile
+++ b/drivers/amlogic/input/sensor/Makefile
@@ -22,9 +22,12 @@ obj-$(CONFIG_GRAVITY_KXTJ9)	+= kionix_accel.o
 obj-$(CONFIG_GRAVITY_STK8313)	+= stk831x.o
 obj-$(CONFIG_GRAVITY_STK8312)	+= stk831x.o
 
+obj-$(CONFIG_GRAVITY_MXC622X)     += mxc622x.o
+
 #Light
 
-obj-$(CONFIG_SENSORS_CM36283)	+= cm36283.o
-obj-$(CONFIG_SENSORS_CM3232)	+= cm3232.o
+obj-$(CONFIG_LIGHT_CM36283)	+= cm36283.o
+obj-$(CONFIG_LIGHT_CM3232)	+= cm3232.o
 obj-$(CONFIG_LIGHT_EPL6814)+= elan_epl6814.o
-obj-$(CONFIG_SENSORS_LTR501)	+= ltr501_als.o
+obj-$(CONFIG_LIGHT_LTR501)	+= ltr501_als.o
+obj-$(CONFIG_LIGHT_STK220X) += stk220x_poll.o
diff --git a/drivers/amlogic/input/sensor/bma222.c b/drivers/amlogic/input/sensor/bma222.c
index 5f26e470afa0..73345a5f197e 100644
--- a/drivers/amlogic/input/sensor/bma222.c
+++ b/drivers/amlogic/input/sensor/bma222.c
@@ -3760,55 +3760,16 @@ static struct i2c_driver bma222_driver = {
 
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("bma222", 0x08),
-};
-
-#endif
-
 
 static int __init BMA222_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&bma222_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&bma222_driver);
-#endif
 }
 
 static void __exit BMA222_exit(void)
 {
 	i2c_del_driver(&bma222_driver);
 
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 }
 
 MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
diff --git a/drivers/amlogic/input/sensor/bma250.c b/drivers/amlogic/input/sensor/bma250.c
index b69055f4833a..7f725290d04c 100644
--- a/drivers/amlogic/input/sensor/bma250.c
+++ b/drivers/amlogic/input/sensor/bma250.c
@@ -3708,55 +3708,16 @@ static struct i2c_driver bma250_driver = {
 };
 
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("bma250", 0x18),
-};
-
-#endif
-
-
 
 static int __init BMA250_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&bma250_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&bma250_driver);
-#endif
 }
 
 static void __exit BMA250_exit(void)
 {
 	i2c_del_driver(&bma250_driver);
 
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
 }
 
 MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
diff --git a/drivers/amlogic/input/sensor/cm3232.c b/drivers/amlogic/input/sensor/cm3232.c
index cc9aa5ffa6b6..bac38faeba82 100644
--- a/drivers/amlogic/input/sensor/cm3232.c
+++ b/drivers/amlogic/input/sensor/cm3232.c
@@ -26,11 +26,11 @@
 #include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/miscdevice.h>
-#include <linux/lightsensor.h>
+//#include <linux/lightsensor.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
 #include <asm/mach-types.h>
-#include <linux/cm3232.h>
+#include <linux/sensor/cm3232.h>
 #include <asm/setup.h>
 #include <linux/jiffies.h>
 
@@ -51,8 +51,9 @@ struct cm3232_info {
 	struct input_dev *ls_input_dev;
 	atomic_t delay;
 	atomic_t enable;
-	
+#ifdef CONFIG_HAS_EARLYSUSPEND	
 	struct early_suspend early_suspend;
+#endif
 	struct i2c_client *i2c_client;
 	struct workqueue_struct *lp_wq;
 	struct delayed_work work;
@@ -870,6 +871,7 @@ static int cm3232_setup(struct cm3232_info *lpi)
 	return ret;
 }
 
+#ifdef CONFIG_HAS_EARLYSUSPEND	
 static void cm3232_early_suspend(struct early_suspend *h)
 {
 	struct cm3232_info *lpi = lp_info;
@@ -889,7 +891,7 @@ static void cm3232_late_resume(struct early_suspend *h)
 	if (!lpi->als_enable)
 		lightsensor_enable(lpi);
 }
-
+#endif
 static int cm3232_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
@@ -986,13 +988,13 @@ static int cm3232_probe(struct i2c_client *client,
 		pr_err("[LS][CM3232 error]%s: could not create sysfs group\n", __func__);
 		goto err_sysfs_create_group_light;
 	}
-
+#ifdef CONFIG_HAS_EARLYSUSPEND
 	lpi->early_suspend.level =
 			EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	lpi->early_suspend.suspend = cm3232_early_suspend;
 	lpi->early_suspend.resume = cm3232_late_resume;
 	register_early_suspend(&lpi->early_suspend);
-
+#endif
        lpi->als_enable=0;
 	D("[CM3232] %s: Probe success!\n", __func__);
 	
@@ -1035,53 +1037,16 @@ static struct i2c_driver cm3232_driver = {
 	},
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("cm3232", 0x10),
-};
-
-#endif
-
 
 static int __init cm3232_init(void)
 {
-#ifdef CONFIG_OF
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&cm3232_driver);
-    }
-
-    return -1;
-#else
 
 	return i2c_add_driver(&cm3232_driver);
-#endif
 }
 
 static void __exit cm3232_exit(void)
 {
 	i2c_del_driver(&cm3232_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
 }
 
 module_init(cm3232_init);
diff --git a/drivers/amlogic/input/sensor/cm36283.c b/drivers/amlogic/input/sensor/cm36283.c
index 4e5775c100c3..0f6ea8f7d5df 100644
--- a/drivers/amlogic/input/sensor/cm36283.c
+++ b/drivers/amlogic/input/sensor/cm36283.c
@@ -695,54 +695,15 @@ static struct i2c_driver CM36283_driver = {
 	.remove		= CM36283_remove,
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("cm36283", 0x60),
-};
-
-#endif
-
-
 
 static int __init CM36283_init(void)
 {
-#ifdef CONFIG_OF
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&CM36283_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&CM36283_driver);
-#endif
 }
 
 static void __exit CM36283_exit(void)
 {
 	i2c_del_driver(&CM36283_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
-
 }
 
 MODULE_AUTHOR("Thundersoft");
diff --git a/drivers/amlogic/input/sensor/dmard06.c b/drivers/amlogic/input/sensor/dmard06.c
index 49475c67f26d..e521c36e531a 100644
--- a/drivers/amlogic/input/sensor/dmard06.c
+++ b/drivers/amlogic/input/sensor/dmard06.c
@@ -805,54 +805,15 @@ exit_alloc_data_failed:
 	return err;
 }
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("dmard06", 0x1c),
-};
-
-#endif
-
-
 
 static int __init dmard06_i2c_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&dmard06_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&dmard06_driver);
-#endif
 }
 
 static void __exit dmard06_i2c_exit(void)
 {
 	i2c_del_driver(&dmard06_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 
 }
 
diff --git a/drivers/amlogic/input/sensor/dmt10.c b/drivers/amlogic/input/sensor/dmt10.c
index eeeea74e4ac3..a3420e3e8440 100644
--- a/drivers/amlogic/input/sensor/dmt10.c
+++ b/drivers/amlogic/input/sensor/dmt10.c
@@ -774,43 +774,11 @@ static int device_i2c_probe(struct i2c_client *client,const struct i2c_device_id
     return 0;
 }
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("dmard10", 0x18),
-};
-
-#endif
-
-
 
 
 static int __init device_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&device_i2c_driver);
-    }
-
-    return -1;
-#else
-
 	return i2c_add_driver(&device_i2c_driver);
-#endif
 }
 
 
@@ -824,14 +792,6 @@ static void __exit device_exit(void)
 	class_destroy(devdata.class);
 	i2c_del_driver(&device_i2c_driver);
 
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 }
 
 void gsensor_write_offset_to_file(void)
diff --git a/drivers/amlogic/input/sensor/elan_epl6814.c b/drivers/amlogic/input/sensor/elan_epl6814.c
index 4097068523a6..99822ea1d2ba 100644
--- a/drivers/amlogic/input/sensor/elan_epl6814.c
+++ b/drivers/amlogic/input/sensor/elan_epl6814.c
@@ -1229,53 +1229,16 @@ static struct i2c_driver elan_sensor_driver =
 #endif
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("elan_epl6814", 0x92),
-};
-
-#endif
-
 
 
 static int __init elan_sensor_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&elan_sensor_driver);
-    }
-
-    return -1;
-#else
     return i2c_add_driver(&elan_sensor_driver);
-#endif
 }
 
 static void __exit  elan_sensor_exit(void)
 {
     i2c_del_driver(&elan_sensor_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
 }
 
 module_init(elan_sensor_init);
diff --git a/drivers/amlogic/input/sensor/kionix_accel.c b/drivers/amlogic/input/sensor/kionix_accel.c
index 5ba6fbcd0b41..0e985e0f6ac6 100644
--- a/drivers/amlogic/input/sensor/kionix_accel.c
+++ b/drivers/amlogic/input/sensor/kionix_accel.c
@@ -1240,7 +1240,6 @@ static int kionix_accel_probe(struct i2c_client *client,
 	const struct kionix_accel_platform_data *accel_pdata = client->dev.platform_data;
 	struct kionix_accel_driver *acceld;
 	int err;
-	struct proc_dir_entry *proc_dir, *proc_entry;
 
 	if (!i2c_check_functionality(client->adapter,
 				I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE_DATA)) {
@@ -1361,15 +1360,6 @@ static int kionix_accel_probe(struct i2c_client *client,
 	acceld->kionix_accel_update_odr(acceld, acceld->poll_interval);
 	kionix_accel_update_direction(acceld);
 
-	proc_dir = proc_mkdir("sensors", NULL);
-	if (proc_dir == NULL)
-		KMSGERR(&client->dev, "failed to create /proc/sensors\n");
-	else {
-		proc_entry = create_proc_entry( "accelinfo", 0644, proc_dir);
-		if (proc_entry == NULL)
-			KMSGERR(&client->dev, "failed to create /proc/cpu/accelinfo\n");
-	}
-
 	acceld->accel_workqueue = create_workqueue("Kionix Accel Workqueue");
 	INIT_DELAYED_WORK(&acceld->accel_work, kionix_accel_work);
 	init_waitqueue_head(&acceld->wqh_suspend);
@@ -1466,55 +1456,17 @@ static struct i2c_driver kionix_accel_driver = {
 };
 
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("kionix_accel", 0x0f),
-};
-
-#endif
-
 
 
 static int __init kionix_accel_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&kionix_accel_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&kionix_accel_driver);
-#endif
 }
 module_init(kionix_accel_init);
 
 static void __exit kionix_accel_exit(void)
 {
 	i2c_del_driver(&kionix_accel_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 }
 module_exit(kionix_accel_exit);
 
diff --git a/drivers/amlogic/input/sensor/lis3dh_acc.c b/drivers/amlogic/input/sensor/lis3dh_acc.c
index 209f1d2e8c97..a8f1778a7d33 100644
--- a/drivers/amlogic/input/sensor/lis3dh_acc.c
+++ b/drivers/amlogic/input/sensor/lis3dh_acc.c
@@ -1637,40 +1637,12 @@ static struct i2c_driver lis3dh_acc_driver = {
 	.id_table = lis3dh_acc_id,
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("lis3dh_acc", 0x28),
-};
-
-#endif
-
 
 
 static int __init lis3dh_acc_init(void)
 {
-#ifdef CONFIG_OF
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-       return i2c_add_driver(&lis3dh_acc_driver);
-    }
-
-    return -1;
-#else
-    
+   
 	return i2c_add_driver(&lis3dh_acc_driver);
-#endif
 }
 
 static void __exit lis3dh_acc_exit(void)
@@ -1681,14 +1653,6 @@ static void __exit lis3dh_acc_exit(void)
      
 	i2c_del_driver(&lis3dh_acc_driver);
 
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 	return;
 }
 
diff --git a/drivers/amlogic/input/sensor/lsm303d.c b/drivers/amlogic/input/sensor/lsm303d.c
index 11ca9fd312aa..5b4f9d9029ad 100644
--- a/drivers/amlogic/input/sensor/lsm303d.c
+++ b/drivers/amlogic/input/sensor/lsm303d.c
@@ -2010,39 +2010,10 @@ static struct i2c_driver lsm303d_driver = {
 };
 
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("lsm303d", 0x1d),
-};
-
-#endif
-
 
 static int __init lsm303d_init(void)
 {
-#ifdef CONFIG_OF
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&lsm303d_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&lsm303d_driver);
-#endif
 }
 
 static void __exit lsm303d_exit(void)
@@ -2050,14 +2021,6 @@ static void __exit lsm303d_exit(void)
 	pr_info("%s driver exit\n", LSM303D_DEV_NAME);
 	i2c_del_driver(&lsm303d_driver);
 
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 }
 
 module_init(lsm303d_init);
diff --git a/drivers/amlogic/input/sensor/ltr501_als.c b/drivers/amlogic/input/sensor/ltr501_als.c
index 45a04b1e3d06..0c93c3c2d945 100644
--- a/drivers/amlogic/input/sensor/ltr501_als.c
+++ b/drivers/amlogic/input/sensor/ltr501_als.c
@@ -731,54 +731,16 @@ static struct i2c_driver ltr501_driver = {
 	.resume	= ltr501_resume,
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("LTR501", 0x23),
-};
-
-#endif
-
 
 static int __init ltr501_driver_init(void)
 {
-#ifdef CONFIG_OF
-    
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&ltr501_driver);
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&ltr501_driver);
-#endif
 }
 
 
 static void __exit ltr501_driver_exit(void)
 {
 	i2c_del_driver(&ltr501_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
-
 	printk(KERN_ALERT ">>> %s: LTR501-ALS Driver Module REMOVED <<<\n", __func__);
 }
 
diff --git a/drivers/amlogic/input/sensor/mc32x0.c b/drivers/amlogic/input/sensor/mc32x0.c
index 546ea61a3584..3a25c31aaca5 100644
--- a/drivers/amlogic/input/sensor/mc32x0.c
+++ b/drivers/amlogic/input/sensor/mc32x0.c
@@ -584,55 +584,17 @@ static struct i2c_driver mc32x0_driver = {
 	.id_table = mc32x0_id,
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("mc32x0", 0x4c),
-};
-
-#endif
-
 
 
 
 static int __init mc32x0_init(void)
 {
-#ifdef CONFIG_OF
-
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-
-        return i2c_add_driver(&mc32x0_driver);
-
-    }
-
-    return -1;
-#else
 	return i2c_add_driver(&mc32x0_driver);
-#endif
 }
 
 static void __exit mc32x0_exit(void)
 {
 	i2c_del_driver(&mc32x0_driver);
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
 }
 
 MODULE_DESCRIPTION("MC32X0 3-Axis Orientation/Motion Detection Sensor driver");
diff --git a/drivers/amlogic/input/sensor/mm3a310.c b/drivers/amlogic/input/sensor/mm3a310.c
new file mode 100644
index 000000000000..94ae61f45d99
--- /dev/null
+++ b/drivers/amlogic/input/sensor/mm3a310.c
@@ -0,0 +1,2543 @@
+//$VER$  v1.4.0
+//$TIME$ 2013-08-23-15:33:46
+//$------------------$
+
+
+
+
+
+
+/*
+ *  mm3a310.c - Linux kernel modules for 3-Axis Accelerometer
+ *
+ *  Copyright (C) 2011-2012 MiraMEMS Sensing Technology Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/input-polldev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/syscalls.h>
+#include <asm/uaccess.h>
+#include <linux/kernel.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include        <linux/earlysuspend.h>
+#endif
+
+#include <linux/mm3a310.h>
+
+
+/* driver version info*/
+#define DRIVER_VERSION "2013-08-23-15:33:46_v1.4.0"
+
+/* Debug Function */
+#define MI_TAG                  "[mm3a310] "
+enum{
+	DEBUG_ERR=1,
+	DEBUG_MSG=1<<1,
+	DEBUG_FUNC=1<<2,
+	DEBUG_DATA=1<<3,
+};
+
+/* this level can be modified while runtime through system attribute */
+static int Log_level = 0; //|DEBUG_MSG|DEBUG_FUNC|DEBUG_DATA; 
+
+#define MI_DATA(format, ...)  if(DEBUG_DATA&Log_level){printk(KERN_ERR MI_TAG "[DATA_S] " format " [DATA_E]" "\n", ## __VA_ARGS__);}
+#define MI_MSG(format, ...)   if(DEBUG_MSG&Log_level){printk(KERN_ERR MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_ERR(format, ...)   if(DEBUG_ERR&Log_level){printk(KERN_ERR MI_TAG format " in function %s  is called, line: %d\n", ## __VA_ARGS__, __FUNCTION__,__LINE__);}
+#define MI_FUN                      if(DEBUG_FUNC&Log_level){printk(KERN_ERR MI_TAG "%s  is called, line: %d\n", __FUNCTION__,__LINE__);}
+#define MI_ASSERT(expr)\
+	if (!(expr)) {\
+		printk(KERN_ERR "Assertion failed! %s,%d,%s,%s\n",\
+			__FILE__, __LINE__, __func__, #expr);\
+	}
+
+
+/* DO NOT TRY TO MODIFY FOLLOWING DEFINE */
+#define PLATFORM_QUACOMM 0
+#define PLATFORM_SPRD    1
+#define PLATFORM_ELSE    8
+
+#define DEVICE_CREATE_BYSELF 0   // 1 means define device in this driver
+#define DEVICE_CREATE_BYPLATFORM 2  // 2 means define device in system file 
+/* --- DO NOT TRY TO MODIFY FOLLOWING DEFINE */
+
+
+/* chip related function configure */
+#define FILTER_AVERAGE_ENHANCE                    1
+//only take effect when FILTER_AVERAGE_ENHANCE open
+#define FILTER_AVERAGE_EX                         1 
+#define MM3A310_OFFSET_TEMP_SOLUTION              1
+// whether to suppot auto calibrate while driver insatll, only take effect when MM3A310_OFFSET_TEMP_SOLUTION open
+#define MM3A310_AUTO_CALIBRAE					  0
+#define MM3A310_STK_TEMP_SOLUTION                 1
+//if corwork with miramems' msensor, this compiler option should be set to 1, and a special IOCTL will be supported
+#define COWORK_WITH_DM211                         0 	                    
+
+#define TARGET_PLATFORM					PLATFORM_ELSE//PLATFORM_QUACOMM//PLATFORM_SPRD
+#define DEVICE_CREATE_MODE				DEVICE_CREATE_BYPLATFORM//DEVICE_CREATE_BYSELF //DEVICE_CREATE_BYPLATFORM
+                                                                        
+                                                                            
+/* --- chip related function configure */
+
+#if COWORK_WITH_DM211
+#define GSENSOR						   	0x85
+#define GSENSOR_IOCTL_READ_SENSORDATA       _IOR(GSENSOR, 0x03, int)
+static int gx, gy, gz;
+#endif    
+/*
+ * Defines       
+ */
+
+#if TARGET_PLATFORM == PLATFORM_QUACOMM
+    #define MM3A310_INPUT_DEV_NAME "acc"  //this name should be compatible with the define in HAL
+#else
+    #define MM3A310_INPUT_DEV_NAME "accelerometer"  //this name should be compatible with the define in HAL
+#endif
+
+#define MM3A310_MISC_NAME   MM3A310_DRV_NAME
+#define MM3A310_ID                 0x13 /* WHO AM I*/
+
+#define GRAVITY_EARTH                   9806550
+#define ABSMIN_2G                       (-GRAVITY_EARTH * 2)
+#define ABSMAX_2G                       (GRAVITY_EARTH * 2)
+
+#define POLL_INTERVAL_MAX   500
+#define POLL_INTERVAL       35 
+#define INPUT_FUZZ          32
+#define INPUT_FLAT          32
+static int delayMs = 50;
+
+#if  DEVICE_CREATE_MODE == DEVICE_CREATE_BYSELF
+//#error "please confirm the I2C bus number and chip's slave address"
+#define I2C_STATIC_BUS_NUM        (0) //define which I2C bus to connect
+#define MM3A310_I2C_ADDR    0x26 /* When SA0=1 then 27. When SA0=0 then 26*/
+static struct i2c_board_info mm3a310_i2c_boardinfo = {
+    I2C_BOARD_INFO(MM3A310_DRV_NAME, MM3A310_I2C_ADDR),
+};
+#endif
+
+#define PAGE_ADDR(reg)      ((reg >> 8) & 0xFF)
+#define REG_ADDR(reg)       (reg & 0x00FF)
+
+/* register enum for MM3A310 registers */
+enum {
+    
+    MM3A310_PAGE_NO = 0x00,
+    MM3A310_OSC_REG,
+    MM3A310_TEST_REG1,
+    MM3A310_TEST_REG2,
+    MM3A310_OTP_PG,
+    MM3A310_OTP_PTM,
+    MM3A310_LDO_REG,
+
+    MM3A310_TEMP_OUT_L = 0x0d,
+    MM3A310_TEMP_OUT_H,
+    MM3A310_WHO_AM_I,
+
+    MM3A310_OVRN_DURATION = 0x1e,
+    MM3A310_TEMP_CFG_REG,
+
+    MM3A310_CTRL_REG1,
+    MM3A310_CTRL_REG2,
+    MM3A310_CTRL_REG3,
+    MM3A310_CTRL_REG4,
+    MM3A310_CTRL_REG5,
+    MM3A310_CTRL_REG6,
+
+    MM3A310_REFERENCE,
+    MM3A310_STATUS_REG,
+
+    MM3A310_OUT_X_L,
+    MM3A310_OUT_X_H,
+    MM3A310_OUT_Y_L,
+    MM3A310_OUT_Y_H,
+    MM3A310_OUT_Z_L,
+    MM3A310_OUT_Z_H,
+
+    MM3A310_FIFO_CTRL_REG,
+    MM3A310_FIFO_SRC,
+    
+    MM3A310_INT1_CFG,
+    MM3A310_INT1_SRC,
+    MM3A310_INT1_THS,
+    MM3A310_INT1_DURATION,
+
+    MM3A310_INT2_CFG,
+    MM3A310_INT2_SRC,
+    MM3A310_INT2_THS,
+    MM3A310_INT2_DURATION,
+
+    MM3A310_CLICK_CFG,
+    MM3A310_CLICK_SRC,
+    MM3A310_CLICK_THS,
+
+    MM3A310_TIME_LIMIT,
+    MM3A310_TIME_LATENCY,
+    MM3A310_TIME_WINDOW = 0x3d,
+    
+    MM3A310_SOFT_RESET = 0x0105,
+
+    MM3A310_OTP_FLAG = 0x0109,
+
+    MM3A310_OTP_XOFF_L = 0x0110,
+    MM3A310_OTP_XOFF_H,
+    MM3A310_OTP_YOFF_L,
+    MM3A310_OTP_YOFF_H,
+    MM3A310_OTP_ZOFF_L,
+    MM3A310_OTP_ZOFF_H,
+    MM3A310_OTP_XSO,
+    MM3A310_OTP_YSO,
+    MM3A310_OTP_ZSO,
+    MM3A310_OTP_TRIM_THERM_L,
+    MM3A310_OTP_TRIM_THERM_H,
+    MM3A310_OTP_TRIM_OSC,
+
+    MM3A310_LPF_ABSOLUTE,
+    MM3A310_LPF_COEF_A1_L,
+    MM3A310_LPF_COEF_A1_H,
+    MM3A310_LPF_COEF_A2_L,
+    MM3A310_LPF_COEF_A2_H,
+    MM3A310_LPF_COEF_B0_L,
+    MM3A310_LPF_COEF_B0_H,
+    MM3A310_LPF_COEF_B1_L,
+    MM3A310_LPF_COEF_B1_H,
+    MM3A310_LPF_COEF_B2_L,
+    MM3A310_LPF_COEF_B2_H,
+    
+    MM3A310_TEMP_OFF1,
+    MM3A310_TEMP_OFF2,
+    MM3A310_TEMP_OFF3,
+
+    MM3A310_OTP_SO_COEFF = 0x012a
+};
+
+/* MM3A310 G range */
+enum {
+    MODE_2G = 0x00,
+    MODE_4G = 0x10,
+    MODE_8G = 0x20,
+    MODE_16G = 0x30,
+};
+
+/* MM3A310 Status */
+struct mm3a310_status {
+    u8 mode; /* Full Scale */
+    u8 ctl_reg1; /* ODR */
+    u8 temp_cfg_reg; /* Power down mode */
+    
+    /* OTP Offset */
+    u8 otp_xoff_l;
+    u8 otp_xoff_h;
+    u8 otp_yoff_l;
+    u8 otp_yoff_h;
+    u8 otp_zoff_l;
+    u8 otp_zoff_h;
+};
+
+
+/*
+ * ===========================================
+ *  gLobal Variable DEFINE
+ * ===========================================
+ */
+static struct mm3a310_status mm3a_status = {
+    .mode     = 0x00,
+    .ctl_reg1    = 0x08,
+    .temp_cfg_reg = 0x28,
+    /* OTP Offset */
+    .otp_xoff_l = 0x00,
+    .otp_xoff_h = 0x20,
+    .otp_yoff_l = 0x00,
+    .otp_yoff_h = 0x20,
+    .otp_zoff_l = 0x00,
+    .otp_zoff_h = 0x20,
+};
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+static int bCaliResult;
+#define MM3A310_LSB_TO_MG       20
+#define THRESHOLD                10
+#define OFFSET_VAL_LEN          15
+static int mm3a310_write_offset_to_file(unsigned short x, unsigned short y, unsigned short z);
+static int mm3a310_read_offset_from_file(unsigned short *x, unsigned short *y, unsigned short *z);
+static void manual_load_cali_file(void);
+static char OffsetFileName[] = "/data/mm3a310_offset.txt";
+
+struct work_info
+{
+       char tst1[20];
+	int    len;
+	char buffer[OFFSET_VAL_LEN];
+       int    rst; // result of the operation
+	struct workqueue_struct *wq;
+	struct delayed_work read_work;
+	struct delayed_work write_work;
+	struct completion completion;
+       char tst2[20];
+};
+static struct work_info m_work_info = {{0}};
+
+
+static int is_cali = 0;
+static int check_linearity_offset(void);
+static int mm3a310_calibrate(struct mm3a310_cali_s *mm3a310_cali_data);
+
+#endif /* !MM3A310_OFFSET_TEMP_SOLUTION */
+
+static struct input_polled_dev *mm3a310_idev;
+//static struct device *hwmon_dev;
+static struct i2c_client *mm3a310_i2c_client;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend early_suspend;
+#endif
+
+//static void mm3a310_write_offset(unsigned short x, unsigned short y, unsigned short z);
+static int mm3a310_read_data(short *x, short *y, short *z);
+static int mm3a310_preset_register(struct i2c_client *client);
+/* wrapped for MM3A310 REV2 */
+static int mm3a310_read_register(struct i2c_client *client, u16 reg);
+static int mm3a310_write_register(struct i2c_client *client, u16 reg, u8 data);
+static int mm3a310_read_register_continuously(struct i2c_client *client, u16 base_reg, u8 count, u8 *data);
+
+static DEFINE_MUTEX(mm3a310_rw_lock);
+
+#if MM3A310_STK_TEMP_SOLUTION
+#define STICK_LSB 2000
+#define AIX_HISTORY_SIZE 3
+static short aixHistort[AIX_HISTORY_SIZE*3] = {0};
+static short aixHistoryIndex = 0;
+static bool bxstk = false;
+static bool bystk = false;
+static bool bzstk = false;
+
+static void addAixHistory(short x,short y,short z){
+    aixHistort[aixHistoryIndex++] = x;
+    aixHistort[aixHistoryIndex++] = y;
+    aixHistort[aixHistoryIndex++] = z;    
+    aixHistoryIndex = (aixHistoryIndex)%(AIX_HISTORY_SIZE*3);
+}
+
+
+static bool isXStick(void){
+    int i;
+    for (i = 0; i < AIX_HISTORY_SIZE; i++){
+        if (aixHistort[i*AIX_HISTORY_SIZE] < STICK_LSB && aixHistort[aixHistoryIndex] > (0-STICK_LSB)){
+            break;
+        }
+    }
+    
+    return i == AIX_HISTORY_SIZE; 
+}
+
+static bool isYStick(void){
+    int i;
+    for (i = 0; i < AIX_HISTORY_SIZE; i++){
+        if (aixHistort[i*AIX_HISTORY_SIZE+1] < STICK_LSB && aixHistort[aixHistoryIndex+1] > (0-STICK_LSB)){
+            break;
+        }
+    }
+    
+    return i == AIX_HISTORY_SIZE;
+}
+
+static bool isZStick(void){
+    int i;
+    for (i = 0; i < AIX_HISTORY_SIZE; i++){
+        if (aixHistort[i*AIX_HISTORY_SIZE+2] < STICK_LSB && aixHistort[aixHistoryIndex+2] > (0-STICK_LSB)){
+            break;
+        }
+    }
+    
+    return i == AIX_HISTORY_SIZE; 
+}
+
+static int squareRoot(int val){
+    int r = 0;
+    int shift;
+    
+    if (val < 0){
+        return 0;
+    }
+    
+    for(shift=0;shift<32;shift+=2)
+    { 
+        int x=0x40000000l >> shift;
+        if(x + r <= val)
+        { 
+            val -= x + r;
+            r = (r >> 1) | x;
+        } else{ 
+            r = r >> 1;
+        }
+    }
+    
+    return r;
+}
+#endif /* ! MM3A310_STK_TEMP_SOLUTION */
+
+
+#if FILTER_AVERAGE_ENHANCE
+#ifdef FILTER_AVERAGE_EX
+#define         PEAK_LVL        800
+#endif
+
+typedef struct FilterAverageContextTag{
+    int sample_l;
+    int sample_h;
+    int filter_param_l;
+    int filter_param_h;
+    int filter_threhold;
+
+    int refN_l;
+    int refN_h;
+        
+}FilterAverageContext;
+
+static FilterAverageContext tFac[3]={{0}};
+
+static short filter_average(short preAve, short sample, int paramN, int* refNum)
+{
+ #if FILTER_AVERAGE_EX
+    if( abs(sample-preAve) > PEAK_LVL  && *refNum < 3  ){ 
+         MI_DATA("Hit, sample = %d, preAve = %d, refN =%d\n", sample, preAve, *refNum);
+         sample = preAve;
+         (*refNum) ++;
+    }else{
+         if (*refNum == 3){
+                preAve = sample;
+         }
+         
+         *refNum  = 0;
+    }
+#endif
+
+    //paramN = abs(sample) < 80 ? 16 : paramN;
+    return preAve + (sample - preAve)/paramN;
+}
+
+static int filter_average_enhance(FilterAverageContext* fac, short sample)
+{
+    if (fac == NULL){
+        MI_ERR("NULL parameter fac");
+        return 0;
+    }
+
+    if (fac->filter_param_l == fac->filter_param_h){
+        fac->sample_l = fac->sample_h = filter_average(fac->sample_l, sample, fac->filter_param_l, &fac->refN_l);
+    }else{
+        fac->sample_l = filter_average(fac->sample_l, sample, fac->filter_param_l,  &fac->refN_l);
+        fac->sample_h= filter_average(fac->sample_h, sample, fac->filter_param_h, &fac->refN_h);  
+        if (abs(fac->sample_l- fac->sample_h) > fac->filter_threhold){
+            MI_DATA("adjust, fac->sample_l = %d, fac->sample_h = %d\n", fac->sample_l, fac->sample_h); 
+            fac->sample_h = fac->sample_l;            
+        }
+     }
+
+    return fac->sample_h;    
+}
+
+#endif /* ! FILTER_AVERAGE_ENHANCE */
+
+/*
+ * ===========================================
+ *  COMMON UTITILT FUNCTION
+ * ===========================================
+ */
+
+static int mm3a310_read_register(struct i2c_client *client, u16 reg)
+{
+    int ret = 0; 
+    int val; 
+
+    mutex_lock(&mm3a310_rw_lock);
+
+    /* Get current page NO. */
+    val = i2c_smbus_read_byte_data(client, MM3A310_PAGE_NO);
+    if(val < 0)
+        ret = -1;
+    /* verify page No. */
+    else if(val != PAGE_ADDR(reg))
+        ret = i2c_smbus_write_byte_data(client, MM3A310_PAGE_NO, PAGE_ADDR(reg));
+    if(!ret)
+        val = i2c_smbus_read_byte_data(client, REG_ADDR(reg));
+    mutex_unlock(&mm3a310_rw_lock);
+    return (ret == 0 ? val : ret); 
+}
+
+static int mm3a310_write_register(struct i2c_client *client, u16 reg, u8 data)
+{   
+    int ret = 0;
+    int val;
+
+    mutex_lock(&mm3a310_rw_lock);
+
+    /* Get current page NO. */
+    val = i2c_smbus_read_byte_data(client, MM3A310_PAGE_NO);
+    if(val < 0)
+        ret = -1;
+    /* verify page No. */
+    else if(val != PAGE_ADDR(reg))
+        ret = i2c_smbus_write_byte_data(client, MM3A310_PAGE_NO, PAGE_ADDR(reg));
+
+    if(!ret)
+        ret = i2c_smbus_write_byte_data(client, REG_ADDR(reg), data);
+
+    mutex_unlock(&mm3a310_rw_lock);
+    return (ret == 0 ? 0 : -1);
+
+}
+
+static int mm3a310_read_register_continuously(struct i2c_client *client, u16 base_reg, u8 count, u8 *data)
+{
+    int ret = 0;
+    int val;
+
+    mutex_lock(&mm3a310_rw_lock);
+
+    /* Get current page NO. */
+    val = i2c_smbus_read_byte_data(client, MM3A310_PAGE_NO);
+    if(val < 0)
+        ret = -1;
+    /* verify page No. */
+    else if(val != PAGE_ADDR(base_reg))
+        ret = i2c_smbus_write_byte_data(client, MM3A310_PAGE_NO, PAGE_ADDR(base_reg));
+
+    if(!ret)
+    {
+        base_reg |= 0x80;
+        if(i2c_smbus_read_i2c_block_data(client, REG_ADDR(base_reg), count, data) != count)
+            ret = -1;
+    }
+    mutex_unlock(&mm3a310_rw_lock);
+    return (ret == 0 ? count : 0);
+}
+
+static int mm3a310_set_enable(bool bEnable){
+    struct i2c_client *client;
+    int ret,rst;
+    u8  val;           
+    
+    client = mm3a310_i2c_client;
+    rst = 0;    
+    MI_MSG(">>> mm3a310_set_enable(), bEnable = %d \n", bEnable);
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+    manual_load_cali_file();
+#endif
+    
+    val = mm3a310_read_register(client, MM3A310_TEMP_CFG_REG);
+    if (val < 0){
+        rst = -1; // write error
+    }else{
+        if(bEnable)
+        {  
+            ret = mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, val&0xDF); 
+        }else{        
+            ret = mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, val|0x20);
+        }
+        
+        rst = (ret == 0?0:-1);
+    }
+    
+    MI_MSG ("<<< mm3a310_set_enable(), rst = %d \n", rst);    
+    return rst;
+}
+
+static int mm3a310_get_enable(bool* bEnable){
+    struct i2c_client *client;
+    u8 val;
+    int rst;
+        
+    MI_MSG (">>> mm3a310_get_enable()\n");
+    
+    if (bEnable == NULL){
+        return -1;
+    }
+    
+    client = mm3a310_i2c_client;
+    
+    val = mm3a310_read_register(client, MM3A310_TEMP_CFG_REG); 
+    if (val < 0){
+        rst = -1; // read error
+    }else{
+        *bEnable = (val&0x20)?0:1;
+        rst = 0;
+    }     
+
+    MI_MSG ("<<< mm3a310_get_enable(), rst = %d, *bEnable = %d \n", rst, *bEnable);
+    return rst;
+}
+
+
+static int mm3a310_set_odr(int odr){
+    struct i2c_client *client;
+    int ret;
+    u8  val;
+    int rst;
+    
+    client = mm3a310_i2c_client;
+    MI_MSG (">>> mm3a310_set_odr(), odr =%d\n", odr);
+    
+    // check odr param
+    if (odr > 9 || odr < 0){
+        return -1;
+    }
+    
+    val = mm3a310_read_register(client, MM3A310_CTRL_REG1);
+    if (val < 0){
+        rst = -1;
+    }else{
+        ret = mm3a310_write_register(client, MM3A310_CTRL_REG1, (val&0x0F)|(odr<<4));  
+        rst = (ret == 0?0:-1);    
+    }   
+    
+    MI_MSG ("<<< mm3a310_set_odr(), rst =%d\n", rst);
+    return rst;
+}
+
+static int mm3a310_get_odr(int* odr){
+    int rst;
+    struct i2c_client *client;
+    
+    MI_MSG (">>> mm3a310_get_odr()\n");
+    if (odr == NULL){
+        return -1;
+    }
+    client = mm3a310_i2c_client;
+    
+    *odr = mm3a310_read_register(client, MM3A310_CTRL_REG1);
+    if (*odr < 0){
+        rst = -1;
+    }else{
+        *odr = ((*odr)>>4)&0x0F;
+        rst = 0;
+    } 
+
+    MI_MSG ("<<< mm3a310_get_odr(), rst = %d, *odr = %d\n", rst, *odr);
+    return rst;
+}
+
+static int mm3a310_set_grange(int newrange){
+    int ret;
+    struct i2c_client *client;
+    short range;
+    int rst;
+    
+    MI_MSG (">>> mm3a310_set_grange(), newrange = %d\n", newrange);
+    client = mm3a310_i2c_client;
+    
+    range = mm3a310_read_register(client, MM3A310_CTRL_REG4);
+    MI_MSG("range 1 = %d\n", range);
+    if (range < 0){
+        rst = -1;
+    }else{
+        range = (range&0xCF)|((newrange&0x03)<<4);
+        
+        MI_MSG("range 2 = %d\n", range);
+        ret = mm3a310_write_register(client, MM3A310_CTRL_REG4, range);
+        rst = (ret == 0?0:-1);
+    }
+    
+    MI_MSG("<<< mm3a310_set_grange(), rst = %d\n", rst);
+    return rst;
+}
+
+static int mm3a310_get_grange(int* range){
+    struct i2c_client *client;
+    int rst;
+    
+    MI_MSG(">>> mm3a310_get_grange() \n");
+    if (range == NULL){
+        return -1;
+    }    
+    client = mm3a310_i2c_client;
+    
+    *range = mm3a310_read_register(client, MM3A310_CTRL_REG4);
+    MI_MSG("range 1 = %d\n", *range);
+    if (*range < 0){
+        rst = -1;
+    }else{
+        *range = (*range>>4)&0x03;
+        MI_MSG("range 2 = %d\n", *range);
+        rst = 0;
+    }
+
+    MI_MSG("<<< mm3a310_get_grange(), rst = %d, *range = %d\n", rst, *range);
+    return rst;
+}
+
+
+
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+static void sensor_write_work( struct work_struct *work )
+{
+#if 0
+	int fd = sys_open ( OffsetFileName, O_CREAT | O_RDWR, 0600 );////0770;0777;
+	if ( fd < 0 ){
+		printk( "sys_open %s error!!.\n", "/data/battery.txt" );
+	}else{
+		sys_write( fd, m_work_info.buffer, m_work_info.len );
+		sys_close( fd );
+	}
+#else    
+    unsigned int orgfs;
+    struct file *filep;
+    int ret;   
+    struct work_info* pWorkInfo;
+
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+
+    pWorkInfo = container_of((struct delayed_work*)work, struct work_info, write_work);
+    if (pWorkInfo == NULL){            
+            MI_ERR("get pWorkInfo failed!");       
+            return;
+    }
+    
+    filep = filp_open(OffsetFileName, O_RDWR|O_CREAT, 0600);
+    if (IS_ERR(filep))
+    {
+        MI_ERR("write, sys_open %s error!!.\n", OffsetFileName);
+        ret =  -1;
+    }
+    else
+    {   
+        MI_DATA("@@@@@@@@@@@@@@tst1 = %s\n", pWorkInfo->tst1);
+        MI_DATA("@@@@@@@@@@@@@@tst2 = %s\n", pWorkInfo->tst2);
+        filep->f_op->write(filep, pWorkInfo->buffer, pWorkInfo->len, &filep->f_pos);
+        filp_close(filep, NULL);
+        ret = 0;        
+    }
+    
+    set_fs(orgfs);   
+    pWorkInfo->rst = ret;
+    complete( &pWorkInfo->completion );
+#endif
+}
+
+static void sensor_read_work( struct work_struct *work )
+{
+#if 0
+	int fd = sys_open ( OffsetFileName, O_RDONLY, 0600 );////0770;0777;
+	if ( fd < 0 ){
+		printk( "sys_open %s error!!.\n", "/data/battery.txt" );
+	}else{
+		m_work_info.len = sys_read( fd, m_work_info.buffer, sizeof(m_work_info.buffer) );
+		sys_close( fd );
+	}
+	complete( &m_work_info.completion );
+#else
+    unsigned int orgfs;
+    struct file *filep;
+     int ret; 
+     struct work_info* pWorkInfo;
+        
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+
+    pWorkInfo = container_of((struct delayed_work*)work, struct work_info, read_work);
+    if (pWorkInfo == NULL){            
+            MI_ERR("get pWorkInfo failed!");       
+            return;
+    }
+    
+    filep = filp_open(OffsetFileName, O_RDONLY, 0600);
+    if (IS_ERR(filep)){
+        MI_ERR("read, sys_open %s error!!.\n",OffsetFileName);
+        set_fs(orgfs);
+        ret =  -1;
+    }else{
+    
+        filep->f_op->read(filep, pWorkInfo->buffer,  sizeof(pWorkInfo->buffer), &filep->f_pos);
+        filp_close(filep, NULL);    
+        set_fs(orgfs);
+        ret = 0;
+    }
+
+    MI_DATA("@@@@@@@@@@@@@@tst1 = %s\n", pWorkInfo->tst1);
+    MI_DATA("@@@@@@@@@@@@@@tst2 = %s\n", pWorkInfo->tst2);
+    pWorkInfo->rst = ret;
+    MI_MSG("pWorkInfo->rst = %d\n", pWorkInfo->rst );
+    complete( &(pWorkInfo->completion) );
+#endif
+}
+
+static int sensor_sync_read( unsigned short *x, unsigned short *y, unsigned short *z )
+{
+	int err;
+       struct work_info* pWorkInfo = &m_work_info;
+       
+	init_completion( &pWorkInfo->completion );
+
+	queue_delayed_work( pWorkInfo->wq, &(pWorkInfo->read_work), msecs_to_jiffies(0) );
+	err = wait_for_completion_timeout( &(pWorkInfo->completion), msecs_to_jiffies( 2000 ) );
+	if ( err == 0 ){
+              MI_ERR("wait_for_completion_timeout TIMEOUT");
+		return -1;
+	}
+
+       if (pWorkInfo->rst != 0){
+              MI_ERR("work_info.rst  not equal 0");
+              return pWorkInfo->rst;
+       }
+    
+       if ( sscanf( m_work_info.buffer, "%hu %hu %hu", x, y, z ) != 3 ){
+      	        MI_ERR("Get offset from file failed !\n");
+      	        return -1;
+       }
+       
+	return 0;
+}
+
+static int sensor_sync_write( unsigned short x, unsigned short y, unsigned short z )
+{
+	int err;
+       char data[OFFSET_VAL_LEN];
+       struct work_info* pWorkInfo = &m_work_info;
+       
+	init_completion( &pWorkInfo->completion );
+      sprintf(data,"%4d %4d %4d", x, y, z);
+      memcpy( pWorkInfo->buffer, data, OFFSET_VAL_LEN ); 
+      pWorkInfo->len = OFFSET_VAL_LEN;
+        
+	queue_delayed_work( pWorkInfo->wq, &pWorkInfo->write_work, msecs_to_jiffies(0) );
+	err = wait_for_completion_timeout( &pWorkInfo->completion, msecs_to_jiffies( 2000 ) );
+	if ( err == 0 ){
+              MI_ERR("wait_for_completion_timeout TIMEOUT");
+		return -1;
+	}
+
+       if (pWorkInfo->rst != 0){
+              MI_ERR("work_info.rst  not equal 0");
+              return pWorkInfo->rst;
+       }
+    
+      if (sscanf( pWorkInfo->buffer, "%hu %hu %hu", &x, &y, &z ) != 3 ){
+          	MI_ERR("Get offset from file failed !\n");
+          	return -1;
+      }
+	return 0;
+}
+
+static int mm3a310_write_offset_to_file(unsigned short x, unsigned short y, unsigned short z)
+{
+#if 1
+   return sensor_sync_write(x, y, z);
+#else
+    char data[OFFSET_VAL_LEN];
+    unsigned int orgfs;
+    struct file *filep;
+    int ret;
+
+    sprintf(data,"%4d %4d %4d", x, y, z);
+
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    filep = filp_open(OffsetFileName, O_WRONLY|O_CREAT, 0777);
+    if (IS_ERR(filep))
+    {
+        MI_ERR("sys_open %s error!!.\n", OffsetFileName);
+        ret =  -1;
+    }
+    else
+    {
+        filep->f_op->write(filep, data, OFFSET_VAL_LEN, &filep->f_pos);
+        filp_close(filep, NULL);
+        ret = 0;
+    }
+    
+    set_fs(orgfs);
+    return ret;
+#endif
+}
+
+static int mm3a310_read_offset_from_file(unsigned short *x, unsigned short *y, unsigned short *z)
+{
+#if 1
+    return sensor_sync_read(x, y, z);
+
+#else
+    unsigned int orgfs;
+    char data[OFFSET_VAL_LEN];
+    struct file *filep;
+
+
+        
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+
+    filep = filp_open(OffsetFileName, O_RDONLY, 0);
+    if (IS_ERR(filep)){
+        MI_ERR("sys_open %s error!!.\n",OffsetFileName);
+        set_fs(orgfs);
+        return -1;
+    }
+    
+    filep->f_op->read(filep, data, OFFSET_VAL_LEN, &filep->f_pos);
+    filp_close(filep, NULL);
+
+    if(sscanf(data, "%hu %hu %hu", x, y, z) != 3)
+    {
+        set_fs(orgfs);
+        MI_ERR("Get offset from file failed !\n");
+        return -1;
+    }    
+
+    MI_MSG("x_off = 0x%X, y_off = 0x%X, z_off = 0x%X\n", *x, *y, *z);
+    
+    set_fs(orgfs);
+
+    return 0;
+#endif
+}
+
+static void mm3a310_write_offset(unsigned short x, unsigned short y, unsigned short z)
+{
+    u8  xl,xh,yl,yh,zl,zh;
+    int result=0;
+
+    struct i2c_client *client = mm3a310_i2c_client;
+
+    xl = x & 0xff;
+    xh = x >> 8;
+    yl = y & 0xff;
+    yh = y >> 8;
+    zl = z & 0xff;
+    zh = z >> 8;
+    result = mm3a310_write_register(client, MM3A310_OTP_XOFF_L, xl);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_XOFF_H, xh);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_YOFF_L, yl);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_YOFF_H, yh);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_L, zl);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_H, zh);
+    MI_ASSERT(result==0);
+}
+
+static void manual_load_cali_file(void){
+	static bool bLoad = false;
+	
+	unsigned short  offset[3];
+	
+	if (!bLoad){
+           MI_DATA("==== manual_load_cali_file(), bLoad = %d\n", bLoad); 
+	    if(!mm3a310_read_offset_from_file(&offset[0], &offset[1], &offset[2]))
+	    {
+	        mm3a310_write_offset(offset[0], offset[1], offset[2]);
+		 bLoad = true;
+	    }
+	}
+}
+
+#if MM3A310_AUTO_CALIBRAE
+static bool check_califile_exist(void){
+    unsigned int orgfs=0;
+    bool ret=true;	
+    struct file *filep;
+        
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+
+    filep = filp_open(OffsetFileName, O_RDONLY, 0600);
+    if (IS_ERR(filep)){
+        MI_ERR("%s read, sys_open %s error!!.\n",__func__,OffsetFileName);
+        set_fs(orgfs);
+        ret = false;
+    }else{ 
+        MI_MSG("check_califile_exist 1");
+        filp_close(filep, NULL);    
+        set_fs(orgfs);	
+    }
+    
+    MI_MSG("check_califile_exist 2");
+    return ret;
+}
+
+static int auto_calibrate(void){
+
+    struct mm3a310_cali_s mm3a310_cali_data;
+
+    int ret =0;		
+    
+    memset(&mm3a310_cali_data, 0, sizeof(mm3a310_cali_data));
+
+    mm3a310_cali_data.z_dir =0;
+    MI_MSG("auto_calibrate z_dir  = %d !\n", mm3a310_cali_data.z_dir );
+
+    if(mm3a310_calibrate(&mm3a310_cali_data))
+    {
+	MI_ERR(" ----- auto_calibrate  failed !\n");
+	ret =-1;
+    }
+
+    return ret;	
+
+}
+#endif
+
+/**
+  * @brief  read X Y Z aixs by mg, but actually it is 1000/1024 mg
+  * @retval result of the initailzation, 0 means successful; else failed
+  */
+static int cycle_read_xyz(int* x, int* y, int*z, int ncycle){
+    u8      tmp_data[6];
+    int j;
+    
+
+	*x = 0;
+	*y = 0;
+	*z = 0; 
+	for (j = 0; j < ncycle; j++)
+	{
+		mdelay(10);
+		if (mm3a310_read_register_continuously(mm3a310_i2c_client,MM3A310_OUT_X_L,6,tmp_data) < 6)
+		{
+			MI_ERR("i2c block read failed\n");
+			return -1;
+		}
+		(*x) += ((short)((tmp_data[1] << 8)|tmp_data[0])>> 4);
+		(*y) += ((short)((tmp_data[3] << 8)|tmp_data[2])>> 4);
+		(*z) += ((short)((tmp_data[5] << 8)|tmp_data[4])>> 4);
+	}
+	(*x) /= ncycle;
+	(*y) /= ncycle;
+	(*z) /= ncycle;
+
+        switch (mm3a_status.mode)
+        {
+            case MODE_2G:
+                break;
+            case MODE_4G: 
+                (*x)=(*x)<<1;
+                (*y)=(*y)<<1;
+                (*z)=(*z)<<1;
+                break;
+            case MODE_8G: 
+                (*x)=(*x)<<2;
+                (*y)=(*y)<<2;
+                (*z)=(*z)<<2;
+                break;
+            case MODE_16G: 
+                (*x)=(*x)<<3;
+                (*y)=(*y)<<3;
+                (*z)=(*z)<<3;
+                break;
+            default:
+                return -1;
+        }
+
+
+	return 0;
+}
+
+
+static int check_linearity_offset(void){
+      unsigned short i;
+      int result = 0;
+      struct i2c_client *client = mm3a310_i2c_client;
+       int     x = 0, y = 0, z = 0;
+
+      for (i = 0; i <= 0x3ff; i++){
+                result |= mm3a310_write_register(client, MM3A310_OTP_XOFF_L, i & 0xFF);
+                result |= mm3a310_write_register(client, MM3A310_OTP_XOFF_H, (i & 0xFF00) >> 8);
+                result |= mm3a310_write_register(client, MM3A310_OTP_YOFF_L, i & 0xFF);
+                result |= mm3a310_write_register(client, MM3A310_OTP_YOFF_H, (i & 0xFF00) >> 8);
+                result |= mm3a310_write_register(client, MM3A310_OTP_ZOFF_L, i & 0xFF);
+                result |= mm3a310_write_register(client, MM3A310_OTP_ZOFF_H, (i & 0xFF00) >> 8);
+                result |= cycle_read_xyz(&x, &y, &z, 5);
+
+                 MI_MSG ("linearity_offset: i = %d, x = %d, y = %d, z= %d \n", i, x, y, z); 
+
+                 if (result){
+                       MI_MSG ("linearity_offset: chip op failed, result = %d \n", result); 
+                       return result;
+                 }
+      }
+
+    return result;
+}
+
+
+typedef struct  linearitydata{
+    unsigned short  off;
+    int                    val; 
+
+}LinearityData;
+
+static int detect_linearity_ratio(int* xr, int* yr, int* zr){
+
+      unsigned short i;
+      int result = 0;
+      struct i2c_client *client = mm3a310_i2c_client;
+      int     x = 0, y = 0, z = 0;
+
+      LinearityData xdata[2] = {{0}};
+      u8              xdata_count = 0;
+      LinearityData ydata[2] = {{0}};
+      u8              ydata_count = 0;
+      LinearityData zdata[2] = {{0}};
+      u8              zdata_count = 0;  
+
+      for (i = 10; i <= 0x3ff; i+= 50){
+                result |= mm3a310_write_register(client, MM3A310_OTP_XOFF_L, i & 0xFF);
+                result |= mm3a310_write_register(client, MM3A310_OTP_XOFF_H, (i & 0xFF00) >> 8);
+                result |= mm3a310_write_register(client, MM3A310_OTP_YOFF_L, i & 0xFF);
+                result |= mm3a310_write_register(client, MM3A310_OTP_YOFF_H, (i & 0xFF00) >> 8);
+                result |= mm3a310_write_register(client, MM3A310_OTP_ZOFF_L, i & 0xFF);
+                result |= mm3a310_write_register(client, MM3A310_OTP_ZOFF_H, (i & 0xFF00) >> 8);
+                result |= cycle_read_xyz(&x, &y, &z, 20);
+
+                 MI_MSG ("detect_linearity_ratio: i = %d, x = %d, y = %d, z= %d \n", i, x, y, z); 
+
+                 if (result){
+                       MI_MSG ("detect_linearity_ratio: chip op failed, result = %d \n", result); 
+                       return result;
+                 }
+
+                 if (abs(x) < 1800 && xdata_count < 2){
+                        MI_MSG("detect linearity ratio: xdata_count = %d, x = %d i = %d\n", xdata_count, x, i);
+                        
+                        xdata[xdata_count].val = x;  
+                        xdata[xdata_count].off = i;    
+                        xdata_count ++;
+                 }
+
+                 if (abs(y) < 1800 && ydata_count < 2){
+                        MI_MSG("detect linearity ratio: ydata_count = %d, y = %d i = %d\n", ydata_count, y, i);
+                        ydata[ydata_count].val = y;  
+                        ydata[ydata_count].off = i;    
+                        ydata_count ++;                       
+                 }
+
+                  if (abs(z) < 1800 && zdata_count < 2){
+                        MI_MSG("detect linearity ratio: zdata_count = %d, z = %d i = %d\n", zdata_count, z, i);
+                        zdata[zdata_count].val = z;  
+                        zdata[zdata_count].off = i;    
+                        zdata_count ++;                       
+                 }
+
+                  if (xdata_count == 2 && ydata_count == 2 && zdata_count == 2 ){
+                         MI_MSG ("all linearity_ratio found!");
+                         *xr = (xdata[1].val - xdata[0].val)/(xdata[1].off - xdata[0].off);
+                         *yr = (ydata[1].val - ydata[0].val)/(ydata[1].off - ydata[0].off);
+                         *zr = (zdata[1].val - zdata[0].val)/(zdata[1].off - zdata[0].off);
+
+                         MI_MSG ("all linearity_ratio found! xr = %d, yr = %d, zr = %d\n", *xr, *yr, *zr);
+
+                         return 0;
+                  }
+      }
+
+      MI_MSG("detect linearity ratio failed!");
+      return -1;
+
+}
+
+
+static int mm3a310_calibrate(struct mm3a310_cali_s *mm3a310_cali_data)
+{
+    short   i;
+    u8      tmp_data[6];
+    int     x = 0, y = 0, z = 0;
+    int    xLine =0, yLine=0, zLine=0;
+    short     tmp_off = 0, tmp_off2 = 0 ;
+    u8      ncycle = 50;
+
+#if MM3A310_STK_TEMP_SOLUTION   
+    short   x_off_original = 0;
+    short   y_off_original = 0;
+    short   z_off_original = 0;
+#endif
+
+    int result;
+
+    struct i2c_client *client = mm3a310_i2c_client;
+
+    if( is_cali )
+        return -1;
+
+    is_cali = 1;
+
+    /* decide the z direction, if 0 which means auto */
+    if (mm3a310_cali_data->z_dir == 0){
+       result = cycle_read_xyz(&x, &y, &z, 5);
+       if (result != 0){
+            MI_ERR("check z direction failed\n");
+            goto fail_exit;
+       }
+
+       if (z > 0){
+            mm3a310_cali_data->z_dir = 1;
+       }else{
+            mm3a310_cali_data->z_dir = -1;
+       }
+    }
+
+    if(mm3a310_read_register_continuously(client, MM3A310_OTP_XOFF_L, 6, tmp_data) != 6)
+    {
+        MI_ERR("i2c block read failed\n");
+        goto fail_exit;
+    }
+
+    mm3a310_cali_data->x_off = (tmp_data[1] << 8) | tmp_data[0] ;
+    mm3a310_cali_data->y_off = (tmp_data[3] << 8) | tmp_data[2] ;
+    mm3a310_cali_data->z_off = (tmp_data[5] << 8) | tmp_data[4] ;
+
+#if MM3A310_STK_TEMP_SOLUTION 
+    x_off_original = mm3a310_cali_data->x_off;
+    y_off_original = mm3a310_cali_data->y_off;
+    z_off_original = mm3a310_cali_data->z_off;
+#endif
+
+
+   if (0 != detect_linearity_ratio(&xLine, &yLine, &zLine)){
+        xLine = yLine = zLine = -20;
+    }   
+    result = mm3a310_write_register(client, MM3A310_OTP_XOFF_L, mm3a310_cali_data->x_off & 0xFF);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_XOFF_H, (mm3a310_cali_data->x_off & 0xFF00) >> 8);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_YOFF_L, mm3a310_cali_data->y_off & 0xFF);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_YOFF_H, (mm3a310_cali_data->y_off & 0xFF00) >> 8);
+    MI_ASSERT(result==0);        
+    result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_L, mm3a310_cali_data->z_off & 0xFF);
+    MI_ASSERT(result==0);
+    result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_H, (mm3a310_cali_data->z_off & 0xFF00) >> 8);
+    MI_ASSERT(result==0);
+
+
+    MI_MSG("---Start Calibrate, z direction = %d---\n", mm3a310_cali_data->z_dir);
+
+    for (i = 0; i < 20 ; i++)
+    {
+        x = y = z = 0;
+        
+       result = cycle_read_xyz(&x, &y, &z, ncycle);
+       if (result != 0){
+            MI_ERR("i2c block read failed\n");
+            goto fail_exit;
+       }
+
+        MI_MSG("----loop %d: x = %d, y = %d, z = %d; x_off = 0x%x, y_off = 0x%x, z_off = 0x%x\n", i, x, y, z, mm3a310_cali_data->x_off, mm3a310_cali_data->y_off, mm3a310_cali_data->z_off);
+
+        if (! mm3a310_cali_data->x_ok)
+        {
+            if ( abs(x) <= THRESHOLD )
+            {
+                mm3a310_cali_data->x_ok = 1 ;
+                MI_MSG("------X is OK, 0x%X-------\n", mm3a310_cali_data->x_off); 
+            }
+            else
+            {
+                tmp_off = x/xLine;                
+
+                tmp_off2 = (short)mm3a310_cali_data->x_off - tmp_off;
+                if (tmp_off2 > 0x3ff){
+                     tmp_off2 = 0x3ff;
+                }else if (tmp_off2 < 0){
+                    tmp_off2 = 0x01;
+                }
+                
+                mm3a310_cali_data->x_off = (unsigned short)tmp_off2;
+                MI_MSG("tmp_off = %d, tmp_off2 = %d,  mm3a310_cali_data->x_off = %d\n", tmp_off, tmp_off2,  mm3a310_cali_data->x_off);
+               
+
+                result = mm3a310_write_register(client, MM3A310_OTP_XOFF_L, mm3a310_cali_data->x_off & 0xFF);
+                MI_ASSERT(result==0);
+                result = mm3a310_write_register(client, MM3A310_OTP_XOFF_H, (mm3a310_cali_data->x_off & 0xFF00) >> 8);
+                MI_ASSERT(result==0);
+            }
+            
+        }
+
+        if (! mm3a310_cali_data->y_ok)
+        {
+            if ( abs(y) <= THRESHOLD )
+            {
+                mm3a310_cali_data->y_ok = 1 ;
+                MI_MSG("------Y is OK, 0x%X-------\n", mm3a310_cali_data->y_off); 
+            }
+            else
+            {
+                 tmp_off = y/yLine;                
+
+                tmp_off2 = (short)mm3a310_cali_data->y_off - tmp_off;
+                if (tmp_off2 > 0x3ff){
+                     tmp_off2 = 0x3ff;
+                }else if (tmp_off2 < 0){
+                    tmp_off2 = 0x01;
+                }
+                
+                mm3a310_cali_data->y_off = (unsigned short)tmp_off2;
+                MI_MSG("tmp_off = %d, tmp_off2 = %d,  mm3a310_cali_data->y_off = %d\n", tmp_off, tmp_off2,  mm3a310_cali_data->y_off);
+
+                result = mm3a310_write_register(client, MM3A310_OTP_YOFF_L, mm3a310_cali_data->y_off & 0xFF);
+                MI_ASSERT(result==0);
+                result = mm3a310_write_register(client, MM3A310_OTP_YOFF_H, (mm3a310_cali_data->y_off & 0xFF00) >> 8);
+                MI_ASSERT(result==0);
+            }
+            
+        }
+
+        if (! mm3a310_cali_data->z_ok)
+        {
+            if ( abs(z - (mm3a310_cali_data->z_dir > 0 ? 1024 : -1024)) <= THRESHOLD )
+            {
+                mm3a310_cali_data->z_ok = 1 ;
+                MI_MSG("------Z is OK, 0x%X-------\n", mm3a310_cali_data->z_off); 
+            }
+            else
+            {
+                tmp_off = (z - (mm3a310_cali_data->z_dir > 0 ? 1024 : -1024)) /zLine;                
+
+                tmp_off2 = (short)mm3a310_cali_data->z_off - tmp_off;
+                if (tmp_off2 > 0x3ff){
+                     tmp_off2 = 0x3ff;
+                }else if (tmp_off2 < 0){
+                    tmp_off2 = 0x01;
+                }
+                
+                mm3a310_cali_data->z_off = (unsigned short)tmp_off2;
+                MI_MSG("tmp_off = %d, tmp_off2 = %d,  mm3a310_cali_data->z_off = %d\n", tmp_off, tmp_off2,  mm3a310_cali_data->y_off);
+                
+
+                result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_L, mm3a310_cali_data->z_off & 0xFF);
+                MI_ASSERT(result==0);
+                result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_H, (mm3a310_cali_data->z_off & 0xFF00) >> 8);
+                MI_ASSERT(result==0);
+            }
+            
+        }
+
+        if(mm3a310_cali_data->x_ok && mm3a310_cali_data->y_ok && mm3a310_cali_data->z_ok )
+        {
+            MI_MSG("--- Calibrate done ---\n");
+            goto success_exit;
+        }
+    }
+
+#if MM3A310_STK_TEMP_SOLUTION   
+     if(mm3a310_cali_data->x_ok + mm3a310_cali_data->y_ok + mm3a310_cali_data->z_ok  == 2){
+
+       if(mm3a310_cali_data->x_ok == 0){
+        mm3a310_cali_data->x_off = x_off_original;
+        result = mm3a310_write_register(client, MM3A310_OTP_XOFF_L, mm3a310_cali_data->x_off & 0xFF);
+        MI_ASSERT(result==0);
+        result = mm3a310_write_register(client, MM3A310_OTP_XOFF_H, (mm3a310_cali_data->x_off & 0xFF00) >> 8);
+        MI_ASSERT(result==0);
+
+        MI_MSG("--- Calibrate done but x skipped---\n");    
+
+       }else 
+       if(mm3a310_cali_data->y_ok == 0){
+           
+        mm3a310_cali_data->y_off = y_off_original;
+        result = mm3a310_write_register(client, MM3A310_OTP_YOFF_L, mm3a310_cali_data->y_off & 0xFF);
+        MI_ASSERT(result==0);
+        result = mm3a310_write_register(client, MM3A310_OTP_YOFF_H, (mm3a310_cali_data->y_off & 0xFF00) >> 8);
+        MI_ASSERT(result==0);
+
+        MI_MSG("--- Calibrate done but y skipped---\n");    
+
+       }else
+        if(mm3a310_cali_data->z_ok == 0){
+
+        mm3a310_cali_data->z_off = z_off_original;
+        result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_L, mm3a310_cali_data->z_off & 0xFF);
+        MI_ASSERT(result==0);
+        result = mm3a310_write_register(client, MM3A310_OTP_ZOFF_H, (mm3a310_cali_data->z_off & 0xFF00) >> 8);
+        MI_ASSERT(result==0);
+
+        MI_MSG("--- Calibrate done but z skipped---\n");    
+        }
+
+         goto success_exit;
+        }
+#endif
+
+fail_exit:
+    is_cali = 0;
+    return -1;
+
+success_exit:
+    is_cali = 0;
+    return mm3a310_write_offset_to_file(mm3a310_cali_data->x_off, mm3a310_cali_data->y_off, mm3a310_cali_data->z_off);
+}
+#endif /* !MM3A310_OFFSET_TEMP_SOLUTION */
+
+/***************************************************************
+*
+* Initialization function
+*
+***************************************************************/
+static int mm3a310_preset_register(struct i2c_client *client){
+    int result = 0;
+
+    /* Full scale: 2G */
+    result |= mm3a310_write_register(client, MM3A310_CTRL_REG4, MODE_2G);
+    /* ODR=100Hz, X,Y,Z axis enable */
+    result |= mm3a310_write_register(client, MM3A310_CTRL_REG1, 0x6f);
+    /* Power on, DATA measurement enable, lDO swtich all on */
+    result |= mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, 0x88);
+    result |= mm3a310_write_register(client, MM3A310_LDO_REG, 0x02);
+    result |= mm3a310_write_register(client, MM3A310_OTP_TRIM_OSC, 0x27);   
+    result |= mm3a310_write_register(client, MM3A310_LPF_ABSOLUTE, 0x30);   
+    result |= mm3a310_write_register(client, MM3A310_TEMP_OFF1, 0x3f);   
+    result |= mm3a310_write_register(client, MM3A310_TEMP_OFF2, 0xff);   
+    result |= mm3a310_write_register(client, MM3A310_TEMP_OFF3, 0x0f);
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+
+#if MM3A310_AUTO_CALIBRAE
+	if(check_califile_exist()){
+		manual_load_cali_file();         	
+	}else{
+    		auto_calibrate();
+	}
+#else
+    manual_load_cali_file();
+#endif
+
+#endif
+
+    return result;
+}
+
+static int mm3a310_otp(struct i2c_client * client){
+    int result;
+    
+    result = mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, 0x08);
+    MI_ASSERT(result==0);
+    if (result != 0){
+        return result;
+    }
+    
+    result = mm3a310_write_register(client, MM3A310_CTRL_REG5, 0x80);
+    MI_ASSERT(result==0);
+    if (result != 0){
+        return result;
+    }
+    
+    return result;
+}
+
+static int mm3a310_init_client(struct i2c_client *client)
+{
+    int result=0;   
+
+    MI_FUN;
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+    m_work_info.wq = create_singlethread_workqueue( "oo" );
+    
+    INIT_DELAYED_WORK( &m_work_info.read_work, sensor_read_work );
+    INIT_DELAYED_WORK( &m_work_info.write_work, sensor_write_work );
+#endif
+
+    /* soft reset */
+    result |= mm3a310_write_register(client, MM3A310_SOFT_RESET, 0xAA);   
+    mdelay(5);
+    result |= mm3a310_write_register(client, MM3A310_SOFT_RESET, 0x00);   
+    mdelay(10);
+
+    result |= mm3a310_otp(client);
+    result |= mm3a310_preset_register(client);
+
+    MI_MSG("mm3a310_init_client ok reuslt:%d\n", result); 
+    return result;
+}
+
+/***************************************************************
+*
+* Read sensor data from MM3A310
+*
+***************************************************************/             
+static int mm3a310_read_data(short *x, short *y, short *z)
+{
+    u8    tmp_data[6];
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+	manual_load_cali_file();
+#endif
+
+    if (mm3a310_read_register_continuously(mm3a310_i2c_client, MM3A310_OUT_X_L, 6, tmp_data) < 6) {
+        MI_ERR("i2c block read failed\n");
+        return -3;
+    }
+
+    *x = ((short)((tmp_data[1] << 8))>> 4);
+    *y = ((short)((tmp_data[3] << 8))>> 4);
+    *z = ((short)((tmp_data[5] << 8))>> 4);
+
+    switch (mm3a_status.mode)
+    {
+        case MODE_2G:
+            break;
+        case MODE_4G: 
+            (*x)=(*x)<<1;
+            (*y)=(*y)<<1;
+            (*z)=(*z)<<1;
+            break;
+        case MODE_8G: 
+            (*x)=(*x)<<2;
+            (*y)=(*y)<<2;
+            (*z)=(*z)<<2;
+            break;
+        case MODE_16G: 
+            (*x)=(*x)<<3;
+            (*y)=(*y)<<3;
+            (*z)=(*z)<<3;
+            break;
+        default:return -1;
+    }
+
+    MI_DATA("mm3a310_raw: x=%d, y=%d, z=%d",  *x, *y, *z);
+
+#if MM3A310_STK_TEMP_SOLUTION   
+
+    addAixHistory(*x,*y,*z);
+
+    bxstk = isXStick();
+    bystk = isYStick();
+    bzstk = isZStick();
+
+   if ((bxstk + bystk+ bzstk) < 2){
+       if(bxstk)
+        *x = squareRoot(1024*1024 - (*y)*(*y) - (*z)*(*z));
+    if(bystk)
+        *y = squareRoot(1024*1024 - (*x)*(*x) - (*z)*(*z));
+    if(bzstk)
+        *z = squareRoot(1024*1024 - (*x)*(*x) - (*y)*(*y));
+   }else{
+
+    	 MI_ERR( "CHIP ERR !MORE STK!\n"); 
+    
+    return 0;
+    }
+#endif
+
+
+#if FILTER_AVERAGE_ENHANCE
+        *x = filter_average_enhance(&tFac[0], *x);
+        *y = filter_average_enhance(&tFac[1], *y);
+        *z = filter_average_enhance(&tFac[2], *z);
+#endif  
+
+
+    MI_DATA("mm3a310_filt: x=%d, y=%d, z=%d",  *x, *y, *z); 
+
+    return 0;
+}
+
+static void report_abs(void)
+{
+    short x=0,y=0,z=0;
+    int result=0;
+
+    /* check if any new data ready */
+    result=mm3a310_read_register(mm3a310_i2c_client, MM3A310_STATUS_REG); 
+    if(!(result & 0x08)){
+        return ; 
+    }
+        
+    if (mm3a310_read_data(&x,&y,&z) != 0) {
+        MI_ERR("MM3A310 data read failed!\n");
+        return;
+    }
+    
+    /* adjust direction */
+#if TARGET_PLATFORM == PLATFORM_QUACOMM	
+    input_report_rel(mm3a310_idev->input, REL_RX, x);
+    input_report_rel(mm3a310_idev->input, REL_RY, y);
+    input_report_rel(mm3a310_idev->input, REL_RZ, z);
+    input_sync(mm3a310_idev->input);
+
+#else
+   input_report_abs(mm3a310_idev->input, ABS_X, x);
+    input_report_abs(mm3a310_idev->input, ABS_Y, y);
+    input_report_abs(mm3a310_idev->input, ABS_Z, z);
+    input_sync(mm3a310_idev->input); //Synchronous
+
+#endif
+
+#if COWORK_WITH_DM211
+   gx = x;
+   gy = y;
+   gz = z;
+#endif    
+}
+
+static void mm3a310_dev_poll(struct input_polled_dev *dev)
+{
+#if MM3A310_OFFSET_TEMP_SOLUTION
+    if(is_cali)
+        return;
+#endif
+
+    dev->poll_interval = delayMs;
+    report_abs();
+}
+
+////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////
+
+/*
+ * ============================================
+ *      IOCTRL interface
+ * ============================================
+ */
+static long mm3a310_misc_ioctl( struct file *file,unsigned int cmd, unsigned long arg)
+{
+    void __user *argp = (void __user *)arg;
+    int err = 0;
+    int interval;
+    bool bEnable;
+    int range;
+    short  xyz[3];
+    struct mm3a310_cali_s mm3a310_cali_data;
+
+    memset(&mm3a310_cali_data, 0, sizeof(struct mm3a310_cali_s));
+
+    if(_IOC_DIR(cmd) & _IOC_READ)
+    {
+        err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+    }
+    else if(_IOC_DIR(cmd) & _IOC_WRITE)
+    {
+        err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+    }
+
+    if(err)
+    {
+        return -EFAULT;
+    }
+
+    switch (cmd) {
+#if COWORK_WITH_DM211
+    case GSENSOR_IOCTL_READ_SENSORDATA:           
+            {
+            void *data = (void __user *) arg;
+            char strbuf[256];
+            MI_MSG("IOCTRL --- GSENSOR_IOCTL_READ_SENSORDATA\n");
+
+            if(data == NULL)
+            {
+                err = -EINVAL;
+                break;      
+            }
+ 
+            sprintf(strbuf, "%04x %04x %04x", gx, gy, -gz);
+            
+           
+            if(copy_to_user(data, strbuf, strlen(strbuf)+1))
+            {
+                err = -EFAULT;
+                break;      
+            }
+        }
+            break;
+#endif
+            
+    case MM3A310_ACC_IOCTL_GET_DELAY:
+        interval = POLL_INTERVAL;
+        if (copy_to_user(argp, &interval, sizeof(interval)))
+            return -EFAULT;
+        break;
+
+    case MM3A310_ACC_IOCTL_SET_DELAY:
+        if (copy_from_user(&interval, argp, sizeof(interval)))
+            return -EFAULT;
+        if (interval < 0 || interval > 1000)
+            return -EINVAL;
+        if((interval <=30)&&(interval > 10))
+        {
+            interval = 10;
+        }
+        delayMs = interval;
+        break;
+
+    case MM3A310_ACC_IOCTL_SET_ENABLE:
+        if (copy_from_user(&bEnable, argp, sizeof(bEnable)))
+            return -EFAULT;
+
+	 MI_MSG(" ----- MM3A310_ACC_IOCTL_SET_ENABLE ! bEnable == %d\n", bEnable);
+        err = mm3a310_set_enable(bEnable);
+        if (err < 0)
+            return EINVAL;
+        break;
+
+    case MM3A310_ACC_IOCTL_GET_ENABLE:        
+        err = mm3a310_get_enable(&bEnable);
+        if (err < 0){
+            return -EINVAL;
+        }
+
+        if (copy_to_user(argp, &bEnable, sizeof(EINVAL)))
+                return -EINVAL;            
+        break;
+    case MM3A310_ACC_IOCTL_SET_G_RANGE:
+        if (copy_from_user(&range, argp, sizeof(range)))
+            return -EFAULT;            
+        err = mm3a310_set_grange(range);
+        if (err < 0)
+            return EINVAL;
+        break;
+        
+    case MM3A310_ACC_IOCTL_GET_G_RANGE:        
+        err = mm3a310_get_grange(&range);
+        if (err < 0){
+           return -EINVAL;
+        }else{
+            if (copy_to_user(argp, &range, sizeof(range)))
+                return -EINVAL;
+        }
+        break;
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+    case MM3A310_ACC_IOCTL_CALIBRATION:
+        if(copy_from_user(&mm3a310_cali_data, (struct mm3a310_cali_s *)arg, sizeof(struct mm3a310_cali_s)))
+            return -EFAULT;
+        
+        if(mm3a310_calibrate(&mm3a310_cali_data))
+        {
+            MI_ERR(" ----- mm3a310 calibrate failed !\n");
+            return -EFAULT;
+        } 
+
+        if(copy_to_user((struct mm3a310_cali_s *)arg, &mm3a310_cali_data, sizeof(struct mm3a310_cali_s)))
+            return -EFAULT;
+        break;        
+
+    case MM3A310_ACC_IOCTL_UPDATE_OFFSET:
+
+        if(mm3a310_read_offset_from_file(&mm3a310_cali_data.x_off, &mm3a310_cali_data.y_off, &mm3a310_cali_data.z_off))
+            return -EFAULT;
+        /* update offset */
+        mm3a310_write_offset(mm3a310_cali_data.x_off, mm3a310_cali_data.y_off, mm3a310_cali_data.z_off);
+        break;
+#endif /* !MM3A310_OFFSET_TEMP_SOLUTION */ 
+     
+
+    case MM3A310_ACC_IOCTL_GET_COOR_XYZ:
+
+        if(mm3a310_read_data(&xyz[0],&xyz[1],&xyz[2]))
+            return -EFAULT;        
+
+        if(copy_to_user((void __user *)arg, xyz, sizeof(xyz)))
+            return -EFAULT;
+        break;
+
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/* Misc device interface*/
+static const struct file_operations mm3a310_misc_fops = {
+        .owner = THIS_MODULE,
+        //.open = mm3a310_misc_open,
+        //.ioctl = mm3a310_misc_ioctl,
+        .unlocked_ioctl = mm3a310_misc_ioctl,
+};
+
+static struct miscdevice misc_mm3a310 = {
+        .minor = MISC_DYNAMIC_MINOR,
+        .name = MM3A310_MISC_NAME,
+        .fops = &mm3a310_misc_fops,
+};
+
+
+/*
+ * ============================================
+ *      DEVICE ATTRIBUTE interface
+ * ============================================
+ */
+static ssize_t mm3a310_enable_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int ret;
+    bool bEnable;
+    
+    MI_MSG(">>> mm3a310_enable_show() \n");
+    ret = mm3a310_get_enable(&bEnable);    
+    if (ret < 0){
+        ret = -EINVAL;
+    }else{
+        ret = sprintf(buf, "%d\n", bEnable);
+    }
+    MI_MSG("<<< mm3a310_enable_show(), ret = %d, bEnable = %d\n", ret, bEnable);
+    return ret;
+}
+
+static ssize_t mm3a310_enable_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    int ret;
+    bool bEnable;
+    unsigned long enable;
+
+    MI_MSG(">>> mm3a310_enable_store() \n");    
+
+    if (buf == NULL){
+        MI_ERR("error:buf == NULL\n"); 
+        return -1;
+    }
+    MI_MSG(">>> mm3a310_enable_store() 1, buf = %s\n", buf); 
+    enable = simple_strtoul(buf, NULL, 10);    
+    bEnable = (enable > 0) ? true : false;
+
+    MI_MSG(">>> mm3a310_enable_store() 2\n"); 
+    ret = mm3a310_set_enable (bEnable);
+    if (ret < 0){
+        ret = -EINVAL;
+    }else{
+        ret = count;
+    }
+    
+    MI_MSG("<<< mm3a310_enable_store(), ret = %d, bEanble=%d \n", ret, bEnable);
+    return ret;
+}
+
+static ssize_t mm3a310_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
+{    
+    MI_MSG(">>> mm3a310_delay_show() \n");
+    return sprintf(buf, "%d\n", delayMs);
+}
+
+static ssize_t mm3a310_delay_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    //int ret = 0;
+    int interval = 0;
+
+    MI_MSG(">>> mm3a310_delay_store() \n");    
+
+    interval = simple_strtoul(buf, NULL, 10);    
+    
+     if (interval < 0 || interval > 1000)
+            return -EINVAL;
+     if((interval <=30)&&(interval > 10))
+     {
+            interval = 10;
+     }
+     delayMs = interval;
+        
+    return count;
+}
+
+static ssize_t mm3a310_offset_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int count;
+    u8 off[6];
+    struct i2c_client *client;
+    
+    client = mm3a310_i2c_client;
+
+    mm3a310_read_register_continuously(client, MM3A310_OTP_XOFF_L, 6, off);        
+
+    count = sprintf(buf, "%d,%d,%d,%d,%d,%d\n", off[0],off[1],off[2],off[3],off[4],off[5]);
+    
+    return count;
+}
+
+static ssize_t mm3a310_offset_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    u8 off[6];
+    int i;
+    int result;
+    struct i2c_client *client = mm3a310_i2c_client;
+
+    sscanf(buf, "%c,%c,%c,%c,%c,%c\n", &off[0], &off[1], &off[2], &off[3], &off[4], &off[5]);
+    for (i = 0; i < 6; i++){
+        result = mm3a310_write_register(client, MM3A310_OTP_XOFF_L + i, off[i]);
+        MI_ASSERT(result==0);
+    }
+    return count;
+}
+
+
+#if FILTER_AVERAGE_ENHANCE
+static ssize_t mm3a310_average_enhance_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int ret;
+
+    ret = sprintf(buf, "%d %d %d\n", tFac[0].filter_param_l, tFac[0].filter_param_h, tFac[0].filter_threhold);
+    
+    MI_MSG("filter_param_l = %d, filter_param_h = %d, filter_threhold = %d\n", 
+        tFac[0].filter_param_l, tFac[0].filter_param_h, tFac[0].filter_threhold);
+
+    return ret;
+}
+
+static ssize_t mm3a310_average_enhance_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{
+    //nAverageFilterSample = simple_strtoul(buf, NULL, 10);    
+
+    sscanf(buf, "%d %d %d\n", &(tFac[0].filter_param_l), &(tFac[0].filter_param_h), &(tFac[0].filter_threhold));
+
+    tFac[1].filter_param_l = tFac[2].filter_param_l = tFac[0].filter_param_l;
+    tFac[1].filter_param_h = tFac[2].filter_param_h = tFac[0].filter_param_h;
+    tFac[1].filter_threhold = tFac[2].filter_threhold =tFac[0].filter_threhold;
+    
+    MI_MSG("filter_param_l = %d, filter_param_h = %d, filter_threhold = %d\n", 
+    tFac[0].filter_param_l, tFac[0].filter_param_h, tFac[0].filter_threhold);
+    
+    MI_MSG("filter_param_l = %d, filter_param_h = %d, filter_threhold = %d\n", 
+    tFac[1].filter_param_l, tFac[1].filter_param_h, tFac[1].filter_threhold);
+    
+    MI_MSG("filter_param_l = %d, filter_param_h = %d, filter_threhold = %d\n", 
+    tFac[2].filter_param_l, tFac[2].filter_param_h, tFac[2].filter_threhold);
+
+    return count;
+}
+#endif //FILTER_AVERAGE_ENHANCE
+
+#if MM3A310_OFFSET_TEMP_SOLUTION
+static ssize_t mm3a310_calibrate_show(struct device *dev,struct device_attribute *attr,char *buf)
+{
+    int ret;       
+    MI_MSG(">>> mm3a310_calibrate_show() \n");   
+    ret = sprintf(buf, "%d\n", bCaliResult);   
+    MI_MSG("<<< mm3a310_calibrate_show(), ret = %d, bCaliResult = %d\n", ret, bCaliResult);
+    return ret;
+}
+
+static ssize_t mm3a310_calibrate_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    struct mm3a310_cali_s mm3a310_cali_data;
+
+    bCaliResult = 0;
+    
+    memset(&mm3a310_cali_data, 0, sizeof(mm3a310_cali_data));
+
+    mm3a310_cali_data.z_dir = simple_strtol(buf, NULL, 10);
+    MI_MSG("mm3a310_cali_data.z_dir  = %d !\n", mm3a310_cali_data.z_dir );
+    bCaliResult = mm3a310_calibrate(&mm3a310_cali_data);
+    return count;
+}
+
+
+static ssize_t mm3a310_linearity_show(struct device *dev,
+                   struct device_attribute *attr, char *buf){    
+
+	return sprintf(buf, "%s\n", "--help\n \
+                                    linearity data will be output by printk, so cat //proc//kmsg \n  \
+                                    and write 1 to linearity means offset linearity check\n");
+
+}
+
+static ssize_t mm3a310_linearity_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    int type = simple_strtoul(buf, NULL, 10);
+
+    if (type == 1){
+        check_linearity_offset();
+    }
+
+    return count;
+}
+#endif
+
+static ssize_t mm3a310_aix_data_show(struct device *dev,
+           struct device_attribute *attr, char *buf)
+{
+    int result;
+    short x,y,z;
+    int count = 0;
+
+    result = mm3a310_read_data(&x, &y, &z);
+    if (result == 0)
+        count += sprintf(buf+count, "x= %d;y=%d;z=%d", x,y,z);
+    else
+        count += sprintf(buf+count, "reading failed!");
+
+    return count;
+}
+
+static ssize_t mm3a310_reg_data_store(struct device *dev,
+           struct device_attribute *attr, const char *buf, size_t count)
+{
+    int addr, data;
+    int result;
+    struct i2c_client *client;
+    
+    client = mm3a310_i2c_client;
+    
+    sscanf(buf, "0x%x, 0x%x\n", &addr, &data);
+    result = mm3a310_write_register(client, addr, data);
+    MI_ASSERT(result==0);
+
+    MI_MSG("0x%x <-- 0x%x\n", addr, data);
+
+    return count;
+}
+
+static ssize_t mm3a310_reg_data_show(struct device *dev,
+           struct device_attribute *attr, char *buf)
+{
+    int count = 0;
+    int i;
+    short val;
+    struct i2c_client *client;
+    
+    client = mm3a310_i2c_client;
+    
+    count += sprintf(buf+count, "---------page 0---------");
+    for (i = 0; i <= 0x003d; i++){
+        if(i%16 == 0)
+            count += sprintf(buf+count, "\n%02x\t", i);
+        val = mm3a310_read_register(client, i); 
+        count += sprintf(buf+count, "%02X ", val);
+    }
+
+    count += sprintf(buf+count, "\n---------page 1---------");
+    for (i = 0x0100; i <= 0x012a; i++){
+        if((i&0xff)%16 == 0)
+            count += sprintf(buf+count, "\n%02x\t", (i & 0xff));
+        val = mm3a310_read_register(client, i); 
+        count += sprintf(buf+count, "%02X ", val);
+        
+    }
+    count += sprintf(buf+count, "\n---------end---------\n");
+    
+    return count;
+}
+
+static ssize_t mm3a310_grange_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int ret;
+    int range;
+    
+    ret = mm3a310_get_grange(&range);
+    
+    if (ret == 0){
+        ret = sprintf(buf, "%d\n", range);
+    }else{
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static ssize_t mm3a310_grange_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    int ret;
+    int newrange;
+    
+    sscanf(buf, "%d\n", &newrange);
+    
+    ret = mm3a310_set_grange(newrange);
+    
+    if (ret == 0){
+        ret = count;
+    }else{
+        ret = -EINVAL;
+    }    
+    
+    return ret;
+}
+
+static ssize_t mm3a310_odr_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int ret;
+    int odr; 
+    
+    ret = mm3a310_get_odr(&odr);
+    if (ret < 0){
+        ret = -EINVAL;
+    }else{
+        ret = sprintf(buf, "%d\n", odr);
+    }
+    
+    return ret;
+}
+
+static ssize_t mm3a310_odr_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{
+    int ret;
+    int odr;
+    
+    sscanf(buf, "%d\n", &odr);
+    
+    ret = mm3a310_set_odr(odr);
+    if (ret < 0){
+        ret = -EINVAL;
+    }else{
+        ret = count;
+    }
+    
+    return ret;
+}
+
+static ssize_t mm3a310_log_level_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int ret;
+
+    ret = sprintf(buf, "%d\n", Log_level);
+
+    return ret;
+}
+
+static ssize_t mm3a310_log_level_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    Log_level = simple_strtoul(buf, NULL, 10);    
+
+    return count;
+}
+
+
+static ssize_t mm3a310_version_show(struct device *dev,
+                   struct device_attribute *attr, char *buf){    
+
+	return sprintf(buf, "%s\n", DRIVER_VERSION);
+
+}
+
+
+
+static DEVICE_ATTR(enable,      S_IRUGO | S_IWUGO,  mm3a310_enable_show, mm3a310_enable_store);
+static DEVICE_ATTR(delay,      S_IRUGO | S_IWUGO,  mm3a310_delay_show, mm3a310_delay_store);
+static DEVICE_ATTR(poll_delay,      S_IRUGO | S_IWUGO,  mm3a310_delay_show, mm3a310_delay_store);
+static DEVICE_ATTR(offset,      S_IWUGO | S_IRUGO,  mm3a310_offset_show, mm3a310_offset_store);
+static DEVICE_ATTR(aix_data,    S_IRUGO,            mm3a310_aix_data_show, NULL);
+static DEVICE_ATTR(reg_data,    S_IWUGO | S_IRUGO,  mm3a310_reg_data_show, mm3a310_reg_data_store);
+static DEVICE_ATTR(grange,      S_IWUGO | S_IRUGO,  mm3a310_grange_show, mm3a310_grange_store);
+static DEVICE_ATTR(odr,         S_IWUGO | S_IRUGO,  mm3a310_odr_show, mm3a310_odr_store);
+#if MM3A310_OFFSET_TEMP_SOLUTION
+static DEVICE_ATTR(calibrate,   S_IWUGO | S_IRUGO,            mm3a310_calibrate_show, mm3a310_calibrate_store);
+static DEVICE_ATTR(linearity,  0660,  mm3a310_linearity_show, mm3a310_linearity_store);
+#endif
+#if FILTER_AVERAGE_ENHANCE
+static DEVICE_ATTR(average_enhance,   S_IWUGO|S_IRUGO, mm3a310_average_enhance_show, mm3a310_average_enhance_store);
+#endif /* ! FILTER_AVERAGE_ENHANCE */
+
+static DEVICE_ATTR(log_level,  0660,  mm3a310_log_level_show, mm3a310_log_level_store);
+static DEVICE_ATTR(version,  0660,  mm3a310_version_show, NULL);  
+
+
+static struct attribute *mm3a310_attributes[] = { 
+    &dev_attr_enable.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_poll_delay.attr, //add for quacomm platform
+    &dev_attr_offset.attr,
+    &dev_attr_aix_data.attr,
+    &dev_attr_reg_data.attr,
+    &dev_attr_grange.attr,
+    &dev_attr_odr.attr,
+#if MM3A310_OFFSET_TEMP_SOLUTION    
+    &dev_attr_calibrate.attr,
+    &dev_attr_linearity.attr,
+#endif
+#if FILTER_AVERAGE_ENHANCE
+    &dev_attr_average_enhance.attr,
+#endif /* ! FILTER_AVERAGE_ENHANCE */
+    &dev_attr_log_level.attr,
+    &dev_attr_version.attr,
+    NULL
+};
+
+#if 0
+	static struct device_attribute* mm3a310_device_attributes[] = { 
+        &dev_attr_enable,
+        &dev_attr_delay,
+	 &dev_attr_poll_delay,
+	    &dev_attr_offset,
+	    &dev_attr_aix_data,
+	    &dev_attr_reg_data,
+	    &dev_attr_grange,
+	    &dev_attr_odr,
+	    #if MM3A310_OFFSET_TEMP_SOLUTION   
+	    &dev_attr_calibrate_mm3a310,
+	            &dev_attr_linearity,
+	            #endif
+
+	 #if FILTER_AVERAGE_ENHANCE
+        &dev_attr_average_enhance,
+       #endif
+
+        &dev_attr_log_level,
+        &dev_attr_version,
+
+	    NULL
+	};
+#endif
+
+static const struct attribute_group mm3a310_attr_group = {
+    //.name   = "mm3a310",
+    .attrs  = mm3a310_attributes,
+};
+
+/*
+ * I2C init/probing/exit functions
+ */
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mm3a310_early_suspend(struct early_suspend* es);
+static void mm3a310_early_resume(struct early_suspend* es);
+#endif
+
+static int __devinit mm3a310_probe(struct i2c_client *client,
+                   const struct i2c_device_id *id)
+{
+    int result;
+    struct input_dev *idev;
+    struct i2c_adapter *adapter;
+ 
+    mm3a310_i2c_client = client;
+    adapter = to_i2c_adapter(client->dev.parent);
+    result = i2c_check_functionality(adapter,
+                     I2C_FUNC_SMBUS_BYTE |
+                     I2C_FUNC_SMBUS_BYTE_DATA);
+    MI_ASSERT(result);
+    MI_FUN;
+
+
+    MI_MSG("check MM3A310 chip ID\n");
+    result = mm3a310_read_register(client, MM3A310_WHO_AM_I);
+
+    if (MM3A310_ID != (result)) {    //compare the address value 
+        MI_ERR("read chip ID 0x%x is not equal to 0x%x!", result,MM3A310_ID);
+        result = -EINVAL;
+        goto err_detach_client;
+    }
+
+    /* Initialize the MM3A310 chip */
+    result = mm3a310_init_client(client);
+    if(result != 0){
+        MI_ERR("chip init failed, result = %d!", result);
+        goto err_detach_client;        
+    }
+
+    /* input poll device register */
+    mm3a310_idev = input_allocate_polled_device();
+    if (!mm3a310_idev) {
+        MI_ERR("alloc poll device failed!\n");
+        result = -ENOMEM;
+        goto err_hwmon_device_unregister;
+    }
+    mm3a310_idev->poll = mm3a310_dev_poll;
+    mm3a310_idev->poll_interval = POLL_INTERVAL;
+    delayMs = POLL_INTERVAL;
+    mm3a310_idev->poll_interval_max = POLL_INTERVAL_MAX;
+    idev = mm3a310_idev->input;
+
+    idev->name = MM3A310_DRV_NAME;   
+    idev->id.bustype = BUS_I2C;
+    idev->evbit[0] = BIT_MASK(EV_ABS);
+
+#if TARGET_PLATFORM == PLATFORM_QUACOMM
+	/* X */
+	input_set_capability(idev, EV_REL, REL_RX);
+	input_set_abs_params(idev, REL_RX, ABSMIN_2G, ABSMAX_2G, 0, 0);
+	/* Y */
+	input_set_capability(idev, EV_REL, REL_RY);
+	input_set_abs_params(idev, REL_RY, ABSMIN_2G, ABSMAX_2G, 0, 0);
+	/* Z */
+	input_set_capability(idev, EV_REL, REL_RZ);
+	input_set_abs_params(idev, REL_RZ, ABSMIN_2G, ABSMAX_2G, 0, 0);
+
+#else
+    input_set_abs_params(idev, ABS_X, -16384, 16383, INPUT_FUZZ, INPUT_FLAT);
+    input_set_abs_params(idev, ABS_Y, -16384, 16383, INPUT_FUZZ, INPUT_FLAT);
+    input_set_abs_params(idev, ABS_Z, -16384, 16383, INPUT_FUZZ, INPUT_FLAT);
+
+#endif    
+
+    result = input_register_polled_device(mm3a310_idev);
+    if (result) {
+        MI_ERR("register poll device failed!\n");
+        goto err_free_polled_device; 
+    }
+
+    /* Sys Attribute Register */
+    result = sysfs_create_group(&idev->dev.kobj, &mm3a310_attr_group);
+    if (result) {
+        MI_ERR("create device file failed!\n");
+        result = -EINVAL;
+        goto err_unregister_polled_device;
+    }
+    
+    /* Misc device interface Register */
+    result = misc_register(&misc_mm3a310);
+    if (result) {
+        MI_ERR("%s: mm3a310_dev register failed", __func__);
+        goto err_remove_sysfs_group;
+    }
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND    
+    early_suspend.suspend = mm3a310_early_suspend;
+    early_suspend.resume  = mm3a310_early_resume;
+    early_suspend.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+    register_early_suspend(&early_suspend);
+#endif
+
+    return result;
+
+err_remove_sysfs_group:
+    sysfs_remove_group(&idev->dev.kobj, &mm3a310_attr_group);
+err_unregister_polled_device:
+    input_unregister_polled_device(mm3a310_idev);
+err_free_polled_device:
+    input_free_polled_device(mm3a310_idev);
+err_hwmon_device_unregister:
+    //hwmon_device_unregister(&client->dev);    
+err_detach_client:
+    return result;
+}
+
+static int __devexit mm3a310_remove(struct i2c_client *client)
+{
+    int result;
+    mm3a_status.temp_cfg_reg = mm3a310_read_register(client, MM3A310_TEMP_CFG_REG);
+    result = mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, mm3a_status.temp_cfg_reg | 0x20); /* Power down enable */
+    MI_ASSERT(result==0);
+
+    misc_deregister(&misc_mm3a310);
+    
+    sysfs_remove_group(&mm3a310_idev->input->dev.kobj, &mm3a310_attr_group);
+    
+    input_unregister_polled_device(mm3a310_idev);
+    
+    input_free_polled_device(mm3a310_idev);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND  
+    unregister_early_suspend(&early_suspend);
+#endif
+
+    return result;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mm3a310_early_suspend(struct early_suspend* es)
+{
+    int result;
+	MI_MSG("mm3a310 guodm ealy suspend 11\n");	
+    if(is_cali)
+	return 0;
+    MI_MSG("mm3a310 guodm ealy suspend 22\n");	
+    mm3a_status.temp_cfg_reg = mm3a310_read_register(mm3a310_i2c_client, MM3A310_TEMP_CFG_REG);
+    result = mm3a310_write_register(mm3a310_i2c_client, MM3A310_TEMP_CFG_REG, mm3a_status.temp_cfg_reg | 0x20); /* Power down enable */
+    MI_ASSERT(result==0);
+    return result;
+}
+
+static void mm3a310_early_resume(struct early_suspend* es)
+{
+    int result;
+	
+	MI_MSG("mm3a310 guodm ealy resume 11 \n");	
+    if(is_cali)
+	return 0;
+
+	MI_MSG("mm3a310 guodm ealy resume 22\n");
+    result = mm3a310_write_register(mm3a310_i2c_client, MM3A310_TEMP_CFG_REG, mm3a_status.temp_cfg_reg);
+    MI_ASSERT(result==0);
+    return result;
+}
+#endif
+
+static int mm3a310_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+    int result;
+    mm3a_status.temp_cfg_reg = mm3a310_read_register(client, MM3A310_TEMP_CFG_REG);
+    result = mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, mm3a_status.temp_cfg_reg | 0x20); /* Power down enable */
+    MI_ASSERT(result==0);
+    return result;
+}
+
+static int mm3a310_resume(struct i2c_client *client)
+{
+    int result;
+    result = mm3a310_write_register(client, MM3A310_TEMP_CFG_REG, mm3a_status.temp_cfg_reg);
+    MI_ASSERT(result==0);
+    return result;
+}
+
+static int mm3a310_detect(struct i2c_client *new_client,
+		       struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = new_client->adapter;
+	//int address = new_client->addr;
+	//const char *name = NULL;
+	//int man_id, chip_id, reg_config1, reg_convrate;
+
+      MI_MSG("adapter->NR = %d\n", adapter->nr);
+      MI_MSG(">>> mm3a310_detect, new_client->addr = 0x%x\n", new_client->addr);
+
+      if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+       MI_MSG("info.type 1 = %s\n", info->type);
+       strlcpy(info->type, "da311", I2C_NAME_SIZE);
+       //strlcpy(info->type, MM3A310_DRV_NAME, I2C_NAME_SIZE);
+
+       MI_MSG("info.type 2 = %s\n", info->type);
+       return 0;
+}
+
+static const struct i2c_device_id mm3a310_id[] = {
+    { MM3A310_DRV_NAME, 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, mm3a310_id);
+
+
+static const unsigned short normal_i2c[] = {
+	0x27,  0x26,I2C_CLIENT_END };
+
+static struct i2c_driver mm3a310_driver = {
+    //.class		= I2C_CLASS_HWMON,
+    .driver = {
+        .name    = MM3A310_DRV_NAME,
+        .owner    = THIS_MODULE,
+    },
+#ifndef CONFIG_HAS_EARLYSUSPEND
+    .suspend = mm3a310_suspend,
+    .resume    = mm3a310_resume,
+#endif
+    .probe    = mm3a310_probe,
+    .remove    = __devexit_p(mm3a310_remove),
+    .id_table = mm3a310_id,
+
+   // .detect		= mm3a310_detect,
+    //.address_list	= normal_i2c,
+};
+
+/* comment this if you register this in board info */
+#if  DEVICE_CREATE_MODE == DEVICE_CREATE_BYSELF
+int i2c_static_add_device(struct i2c_board_info *info)
+{
+    struct i2c_adapter *adapter;
+    struct i2c_client  *client;
+    int    ret;
+
+    adapter = i2c_get_adapter(I2C_STATIC_BUS_NUM);
+    if (!adapter) {
+        MI_ERR("%s: can't get i2c adapter\n", __func__);
+        ret = -ENODEV;
+        goto i2c_err;
+    }
+
+    client = i2c_new_device(adapter, info);
+    if (!client) {
+        MI_ERR("%s:  can't add i2c device at 0x%x\n",
+                __FUNCTION__, (unsigned int)info->addr);
+        ret = -ENODEV;
+        goto i2c_err;
+    }
+
+    i2c_put_adapter(adapter);
+
+    return 0;
+
+i2c_err:
+    return ret;
+}
+#endif /* MODULE */ 
+
+static int __init mm3a310_init(void)
+{    
+    int res;
+
+#if FILTER_AVERAGE_ENHANCE 
+    /* configure default filter param */
+    int i;
+    for (i = 0; i < 3;i++){     
+        tFac[i].filter_param_l = 2;
+        tFac[i].filter_param_h = 8;
+        tFac[i].filter_threhold = 60;
+
+        tFac[i].refN_l = 0;
+        tFac[i].refN_h = 0;
+    }    
+#endif
+
+/* comment this if you register this in board info */
+#if  DEVICE_CREATE_MODE == DEVICE_CREATE_BYSELF
+    res = i2c_static_add_device(&mm3a310_i2c_boardinfo);
+    //res = i2c_register_board_info(I2C_STATIC_BUS_NUM, &mm3a310_i2c_boardinfo, 1);
+    if (res < 0) 
+    {
+        MI_ERR("%s: add i2c device error %d\n", __func__, res);
+        return (res);
+    }
+#endif 
+
+    res = i2c_add_driver(&mm3a310_driver);
+    if (res < 0){
+        MI_ERR("add mm3a310 i2c driver failed\n");
+        return -ENODEV;
+    }
+    MI_MSG("add mm3a310 i2c driver\n");
+    return (res);
+}
+
+static void __exit mm3a310_exit(void)
+{
+#if  DEVICE_CREATE_MODE == DEVICE_CREATE_BYSELF
+    MI_MSG("unregister i2c device.\n");
+    i2c_unregister_device(mm3a310_i2c_client);
+#endif
+    MI_MSG("remove mm3a310 i2c driver.\n");
+    i2c_del_driver(&mm3a310_driver);
+}
+
+
+MODULE_AUTHOR("MiraMEMS <chqian@miramems.com>");
+MODULE_DESCRIPTION("MM3A310 3-Axis Accelerometer driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+module_init(mm3a310_init);
+module_exit(mm3a310_exit);
diff --git a/drivers/amlogic/input/sensor/mma8452.c b/drivers/amlogic/input/sensor/mma8452.c
index e05208359da6..14db267f12e0 100644
--- a/drivers/amlogic/input/sensor/mma8452.c
+++ b/drivers/amlogic/input/sensor/mma8452.c
@@ -58,7 +58,7 @@
 
 #define MMA8452_MAX_DELAY		200
 #define MODE_CHANGE_DELAY_MS	100
-#define MMA8452_DELAY_PWRON		300	/* ms, >= 300 ms */
+#define MMA8452_DELAY_PWRON		10	
 #define MMA8452_DELAY_PWRDN		1	/* ms */
 #define MMA8452_DELAY_SETDETECTION	MMA8452_DELAY_PWRON
 
diff --git a/drivers/amlogic/input/sensor/mxc622x.c b/drivers/amlogic/input/sensor/mxc622x.c
new file mode 100644
index 000000000000..1c261a3d7bab
--- /dev/null
+++ b/drivers/amlogic/input/sensor/mxc622x.c
@@ -0,0 +1,826 @@
+/*
+ * Copyright (C) 2012 MEMSIC, Inc.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include	<linux/err.h>
+#include	<linux/errno.h>
+#include	<linux/delay.h>
+#include	<linux/fs.h>
+#include	<linux/i2c.h>
+#include	<linux/input.h>
+#include	<linux/input-polldev.h>
+#include	<linux/miscdevice.h>
+#include	<linux/uaccess.h>
+#include	<linux/slab.h>
+
+#include       <linux/module.h>
+
+#include	<linux/workqueue.h>
+#include	<linux/irq.h>
+#include	<linux/gpio.h>
+#include	<linux/interrupt.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include        <linux/earlysuspend.h>
+#endif
+
+#include <linux/sensor/mxc622x.h>
+
+#define WHOAMI_MXC622X_ACC	0x25	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x08	/*	WhoAmI register		*/
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+/* RESUME STATE INDICES */
+
+#define	RESUME_ENTRIES		20
+#define DEVICE_INFO         "Memsic, MXC622X"
+#define DEVICE_INFO_LEN     32
+
+/* end RESUME STATE INDICES */
+/*
+#define DEBUG
+#define MXC622X_DEBUG
+*/
+
+#define	MIN_INTERVAL	10
+#define	MAX_INTERVAL	100
+#define	POLL_INTERVAL	20
+
+struct mxc622x_acc_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+    
+	struct mutex lock;
+	struct delayed_work input_work;
+
+       int poll_interval;
+       int min_interval;
+       int max_interval;
+       
+	int hw_initialized;/* hw_initialized =1 meas init succefull */
+	/* hw_working=0 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+        struct early_suspend early_suspend;
+#endif
+};
+
+/*
+ * Because misc devices can not carry a pointer from driver register to
+ * open, we keep this global.  This limits the driver to a single instance.
+ */
+struct mxc622x_acc_data *mxc622x_acc_misc_data;
+struct i2c_client      *mxc622x_i2c_client;
+
+static int mxc622x_acc_i2c_read(struct mxc622x_acc_data *acc, u8 * buf, int len)
+{
+	int err;
+	int tries = 0;
+
+	struct i2c_msg	msgs[] = {
+		{
+			.addr = acc->client->addr,
+			.flags = acc->client->flags & I2C_M_TEN,
+			.len = 1,
+			.buf = buf, },
+		{
+			.addr = acc->client->addr,
+			.flags = (acc->client->flags & I2C_M_TEN) | I2C_M_RD,
+			.len = len,
+			.buf = buf, },
+	};
+
+	do {
+		err = i2c_transfer(acc->client->adapter, msgs, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	if (err != 2) {
+		dev_err(&acc->client->dev, "read transfer error\n");
+		err = -EIO;
+	} else {
+		err = 0;
+	}
+
+	return err;
+}
+
+static int mxc622x_acc_i2c_write(struct mxc622x_acc_data *acc, u8 * buf, int len)
+{
+	int err;
+	int tries = 0;
+
+	struct i2c_msg msgs[] = { { .addr = acc->client->addr,
+			.flags = acc->client->flags & I2C_M_TEN,
+			.len = len + 1, .buf = buf, }, };
+	do {
+		err = i2c_transfer(acc->client->adapter, msgs, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1) {
+		dev_err(&acc->client->dev, "write transfer error\n");
+		err = -EIO;
+	} else {
+		err = 0;
+	}
+
+	return err;
+}
+
+static int mxc622x_acc_hw_init(struct mxc622x_acc_data *acc)
+{
+	int err = -1;
+	u8 buf[7];
+
+	printk(KERN_INFO "%s: hw init start\n", MXC622X_ACC_DEV_NAME);
+
+	buf[0] = WHO_AM_I;
+	err = mxc622x_acc_i2c_read(acc, buf, 1);
+	if (err < 0)
+		goto error_firstread;
+	else
+		acc->hw_working = 1;
+	if ((buf[0] & 0x3F) != WHOAMI_MXC622X_ACC) {
+		err = -1; /* choose the right coded error */
+		goto error_unknown_device;
+	}
+
+	acc->hw_initialized = 1;
+	printk(KERN_INFO "%s: hw init done\n", MXC622X_ACC_DEV_NAME);
+	return 0;
+
+error_firstread:
+	acc->hw_working = 0;
+	dev_warn(&acc->client->dev, "Error reading WHO_AM_I: is device "
+		"available/working?\n");
+	goto error1;
+error_unknown_device:
+	dev_err(&acc->client->dev,
+		"device unknown. Expected: 0x%x,"
+		" Replies: 0x%x\n", WHOAMI_MXC622X_ACC, buf[0]);
+error1:
+	acc->hw_initialized = 0;
+	dev_err(&acc->client->dev, "hw init error 0x%x,0x%x: %d\n", buf[0],
+			buf[1], err);
+	return err;
+}
+
+static void mxc622x_acc_device_power_off(struct mxc622x_acc_data *acc)
+{
+	int err;
+	u8 buf[2] = { MXC622X_REG_CTRL, MXC622X_CTRL_PWRDN };
+
+	err = mxc622x_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		dev_err(&acc->client->dev, "soft power off failed: %d\n", err);
+}
+
+static int mxc622x_acc_device_power_on(struct mxc622x_acc_data *acc)
+{
+	int err = -1;
+	u8 buf[2] = { MXC622X_REG_CTRL, MXC622X_CTRL_PWRON };
+
+	err = mxc622x_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		dev_err(&acc->client->dev, "soft power on failed: %d\n", err);
+
+	if (!acc->hw_initialized) {
+		err = mxc622x_acc_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			mxc622x_acc_device_power_off(acc);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+
+
+static int mxc622x_acc_register_read(struct mxc622x_acc_data *acc, u8 *buf,
+		u8 reg_address)
+{
+
+	int err = -1;
+	buf[0] = (reg_address);
+	err = mxc622x_acc_i2c_read(acc, buf, 1);
+	return err;
+}
+
+
+
+static int mxc622x_acc_get_acceleration_data(struct mxc622x_acc_data *acc,
+		int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware x, y */
+	u8 acc_data[2];
+
+	acc_data[0] = MXC622X_REG_DATA;
+	err = mxc622x_acc_i2c_read(acc, acc_data, 2);
+
+	if (err < 0)
+        {
+                #ifdef DEBUG
+                printk(KERN_INFO "%s I2C read error %d\n", MXC622X_ACC_I2C_NAME, err);
+                #endif
+		return err;
+        }
+
+	xyz[0] = (signed char)acc_data[0];
+	xyz[1] = (signed char)acc_data[1];
+	xyz[2] = 64;
+
+      #ifdef MXC622X_DEBUG
+      printk("x = %d, y = %d\n", xyz[0], xyz[1]);
+      #endif
+
+      #ifdef MXC622X_DEBUG
+
+		printk(KERN_INFO "%s read x=%d, y=%d, z=%d\n",
+			MXC622X_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+		printk(KERN_INFO "%s poll interval %d\n", MXC622X_ACC_DEV_NAME, acc->poll_interval);
+
+	#endif
+	return err;
+}
+
+static void mxc622x_acc_report_values(struct mxc622x_acc_data *acc, int *xyz)
+{
+	input_report_abs(acc->input_dev, ABS_X, xyz[0]);
+	input_report_abs(acc->input_dev, ABS_Y, xyz[1]);
+	input_report_abs(acc->input_dev, ABS_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static int mxc622x_acc_enable(struct mxc622x_acc_data *acc)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		err = mxc622x_acc_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+
+		schedule_delayed_work(&acc->input_work, msecs_to_jiffies(
+				acc->poll_interval));
+	}
+
+	return 0;
+}
+
+static int mxc622x_acc_disable(struct mxc622x_acc_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&acc->input_work);
+		mxc622x_acc_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static int mxc622x_acc_misc_open(struct inode *inode, struct file *file)
+{
+	int err;
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+
+	file->private_data = mxc622x_acc_misc_data;
+
+	return 0;
+}
+
+static long mxc622x_acc_misc_ioctl(struct file *file,unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	//u8 buf[4];
+	//u8 mask;
+	//u8 reg_address;
+	//u8 bit_values;
+	int err;
+	int interval;
+        int xyz[3] = {0};
+	struct mxc622x_acc_data *acc = file->private_data;
+
+//	printk(KERN_INFO "%s: %s call with cmd 0x%x and arg 0x%x\n",
+//			MXC622X_ACC_DEV_NAME, __func__, cmd, (unsigned int)arg);
+
+	switch (cmd) {
+	case MXC622X_ACC_IOCTL_GET_DELAY:
+		interval = acc->poll_interval;
+		if (copy_to_user(argp, &interval, sizeof(interval)))
+			return -EFAULT;
+		break;
+
+	case MXC622X_ACC_IOCTL_SET_DELAY:
+		if (copy_from_user(&interval, argp, sizeof(interval)))
+			return -EFAULT;
+		if (interval < 0 || interval > 1000)
+			return -EINVAL;
+		if(interval > acc->max_interval)
+			interval = acc->max_interval;
+		acc->poll_interval = max(interval,
+				acc->min_interval);
+		break;
+
+	case MXC622X_ACC_IOCTL_SET_ENABLE:
+		if (copy_from_user(&interval, argp, sizeof(interval)))
+			return -EFAULT;
+		if (interval > 1)
+			return -EINVAL;
+		if (interval)
+			err = mxc622x_acc_enable(acc);
+		else
+			err = mxc622x_acc_disable(acc);
+		return err;
+		break;
+
+	case MXC622X_ACC_IOCTL_GET_ENABLE:
+		interval = atomic_read(&acc->enabled);
+		if (copy_to_user(argp, &interval, sizeof(interval)))
+			return -EINVAL;
+		break;
+	case MXC622X_ACC_IOCTL_GET_COOR_XYZ:
+		err = mxc622x_acc_get_acceleration_data(acc, xyz);
+		if (err < 0)
+			return err;
+		#ifdef DEBUG
+		//   printk(KERN_ALERT "%s Get coordinate xyz:[%d, %d, %d]\n",
+		//      __func__, xyz[0], xyz[1], xyz[2]);
+		#endif
+		if (copy_to_user(argp, xyz, sizeof(xyz))) {
+			printk(KERN_ERR " %s %d error in copy_to_user \n",
+				__func__, __LINE__);
+			return -EINVAL;
+			}
+		break;
+	case MXC622X_ACC_IOCTL_GET_CHIP_ID:
+	{
+		u8 devid = 0;
+		u8 devinfo[DEVICE_INFO_LEN] = {0};
+		err = mxc622x_acc_register_read(acc, &devid, WHO_AM_I);
+		if (err < 0) {
+			printk("%s, error read register WHO_AM_I\n", __func__);
+			return -EAGAIN;
+		}
+		sprintf(devinfo, "%s, %#x", DEVICE_INFO, devid);
+
+		if (copy_to_user(argp, devinfo, sizeof(devinfo))) {
+			printk("%s error in copy_to_user(IOCTL_GET_CHIP_ID)\n", __func__);
+			return -EINVAL;
+		}
+	}
+            break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct file_operations mxc622x_acc_misc_fops = {
+        .owner = THIS_MODULE,
+        .open = mxc622x_acc_misc_open,
+        .unlocked_ioctl = mxc622x_acc_misc_ioctl,
+};
+
+static struct miscdevice mxc622x_acc_misc_device = {
+        .minor = MISC_DYNAMIC_MINOR,
+        .name = MXC622X_ACC_DEV_NAME,
+        .fops = &mxc622x_acc_misc_fops,
+};/* misc deive valite*/
+
+
+static ssize_t mxc622x_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+
+	return scnprintf(buf, PAGE_SIZE,  "%d\n", atomic_read(&acc->enabled));
+}
+
+static ssize_t mxc622x_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+    	if (error) {
+            printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+            return error;
+	}
+       data = !!data;
+	if (data) 
+            mxc622x_acc_enable(acc);
+       else
+            mxc622x_acc_disable(acc);
+
+	return count;
+}
+
+static ssize_t mxc622x_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+
+	return scnprintf(buf, PAGE_SIZE,  "%d\n", acc->poll_interval);
+}
+
+static ssize_t mxc622x_delay_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long delay;
+	int error;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &delay);
+	if (error) {
+            printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+            return error;
+	}
+
+	acc->poll_interval = (delay > acc->max_interval) ? acc->max_interval : delay;
+       acc->poll_interval = max(acc->poll_interval, acc->min_interval);
+    
+	return count;
+}
+
+static DEVICE_ATTR(enable, 0666, mxc622x_enable_show, mxc622x_enable_store);
+static DEVICE_ATTR(delay, 0666, mxc622x_delay_show, mxc622x_delay_store);
+
+static struct attribute *mxc622x_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_delay.attr,
+	NULL
+};
+
+static struct attribute_group mxc622x_attribute_group = {
+	.attrs = mxc622x_attributes,
+};
+
+static void mxc622x_acc_input_work_func(struct work_struct *work)
+{
+	struct mxc622x_acc_data *acc;
+
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			struct mxc622x_acc_data,	input_work);
+
+	mutex_lock(&acc->lock);
+	err = mxc622x_acc_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(&acc->client->dev, "get_acceleration_data failed\n");
+	else
+		mxc622x_acc_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work, msecs_to_jiffies(
+			acc->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+#ifdef MXC622X_OPEN_ENABLE
+int mxc622x_acc_input_open(struct input_dev *input)
+{
+	struct mxc622x_acc_data *acc = input_get_drvdata(input);
+
+	return mxc622x_acc_enable(acc);
+}
+
+void mxc622x_acc_input_close(struct input_dev *dev)
+{
+	struct mxc622x_acc_data *acc = input_get_drvdata(dev);
+
+	mxc622x_acc_disable(acc);
+}
+#endif
+
+
+static int mxc622x_acc_input_init(struct mxc622x_acc_data *acc)
+{
+	int err;
+    // Polling rx data when the interrupt is not used.
+    if (1/*acc->irq1 == 0 && acc->irq1 == 0*/) {
+		INIT_DELAYED_WORK(&acc->input_work, mxc622x_acc_input_work_func);
+    }
+
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(&acc->client->dev, "input device allocate failed\n");
+		goto err0;
+	}
+
+#ifdef MXC622X_ACC_OPEN_ENABLE
+	acc->input_dev->open = mxc622x_acc_input_open;
+	acc->input_dev->close = mxc622x_acc_input_close;
+#endif
+
+	input_set_drvdata(acc->input_dev, acc);
+
+	set_bit(EV_ABS, acc->input_dev->evbit);
+
+	input_set_abs_params(acc->input_dev, ABS_X, -32768*4, 32768*4, 0, 0);
+	input_set_abs_params(acc->input_dev, ABS_Y, -32768*4, 32768*4, 0, 0);
+	input_set_abs_params(acc->input_dev, ABS_Z, -32768*4, 32768*4, 0, 0);
+
+	acc->input_dev->name = MXC622X_ACC_DEV_NAME;
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(&acc->client->dev,
+				"unable to register input polled device %s\n",
+				acc->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(acc->input_dev);
+err0:
+	return err;
+}
+
+static void mxc622x_acc_input_cleanup(struct mxc622x_acc_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mxc622x_early_suspend (struct early_suspend* es);
+static void mxc622x_early_resume (struct early_suspend* es);
+#endif
+
+static int mxc622x_acc_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+
+	struct mxc622x_acc_data *acc;
+
+	int err = -1;
+	int result = -1;
+	int tempvalue;
+
+	pr_info("%s: probe start.\n", MXC622X_ACC_DEV_NAME);
+
+	struct i2c_adapter *adapter;
+	adapter = to_i2c_adapter(client->dev.parent);
+	result = i2c_check_functionality(adapter,
+					 I2C_FUNC_SMBUS_BYTE |
+					 I2C_FUNC_SMBUS_BYTE_DATA);
+	if (!result)
+		goto exit_check_functionality_failed;
+	/*
+	 * OK. From now, we presume we have a valid client. We now create the
+	 * client structure, even though we cannot fill it completely yet.
+	 */
+
+	acc = kzalloc(sizeof(struct mxc622x_acc_data), GFP_KERNEL);
+	if (acc == NULL) {
+		err = -ENOMEM;
+		dev_err(&client->dev,
+				"failed to allocate memory for module data: "
+					"%d\n", err);
+		goto exit_alloc_data_failed;
+	}
+
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+
+	acc->client = client;
+       mxc622x_i2c_client = client;
+	i2c_set_clientdata(client, acc);
+
+	/* read chip id */
+	tempvalue = i2c_smbus_read_word_data(client, WHO_AM_I);
+
+	if ((tempvalue & 0x003F) == WHOAMI_MXC622X_ACC) {
+		printk(KERN_INFO "%s I2C driver registered!\n",
+							MXC622X_ACC_DEV_NAME);
+	} else {
+		acc->client = NULL;
+		printk(KERN_INFO "I2C driver not registered!"
+				" Device unknown 0x%x\n", tempvalue);
+		goto err_mutexunlockfreedata;
+	}
+
+       acc->min_interval = MIN_INTERVAL;
+       acc->max_interval = MAX_INTERVAL;
+       acc->poll_interval = POLL_INTERVAL;
+	acc->hw_initialized = 0;
+       acc->hw_working = 0;
+
+	err = mxc622x_acc_device_power_on(acc);
+	if (err < 0) {
+		dev_err(&client->dev, "power on failed: %d\n", err);
+		goto err_mutexunlockfreedata;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = mxc622x_acc_input_init(acc);
+	if (err < 0) {
+		dev_err(&client->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	mxc622x_acc_misc_data = acc;
+	err = misc_register(&mxc622x_acc_misc_device);/* regist misc*/
+	if (err < 0) {
+		dev_err(&client->dev,
+				"misc MXC622X_ACC_DEV_NAME register failed\n");
+		goto err_input_cleanup;
+	}
+
+	mxc622x_acc_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+    
+	err = sysfs_create_group(&acc->input_dev->dev.kobj, &mxc622x_attribute_group);
+	if (err) {
+		printk(KERN_ERR "%s: sysfs_create_group failed\n", __func__);
+		goto err_misc_unregister;
+	}
+
+       acc->on_before_suspend = 0;
+
+ #ifdef CONFIG_HAS_EARLYSUSPEND
+       acc->early_suspend.suspend = mxc622x_early_suspend;
+       acc->early_suspend.resume  = mxc622x_early_resume;
+       acc->early_suspend.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+       register_early_suspend(&acc->early_suspend);
+#endif
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(&client->dev, "%s: probed\n", MXC622X_ACC_DEV_NAME);
+
+	return 0;
+
+err_misc_unregister:
+        misc_deregister(&mxc622x_acc_misc_device);
+err_input_cleanup:
+	mxc622x_acc_input_cleanup(acc);
+err_power_off:
+	mxc622x_acc_device_power_off(acc);
+err_mutexunlockfreedata:
+	kfree(acc);
+	mutex_unlock(&acc->lock);
+	i2c_set_clientdata(client, NULL);
+       mxc622x_acc_misc_data = NULL;
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	printk(KERN_ERR "%s: Driver Init failed\n", MXC622X_ACC_DEV_NAME);
+	return err;
+}
+
+static int mxc622x_acc_remove(struct i2c_client *client)
+{
+	/* TODO: revisit ordering here once _probe order is finalized */
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+
+       misc_deregister(&mxc622x_acc_misc_device);/* unregist misc */
+       mxc622x_acc_input_cleanup(acc);
+       mxc622x_acc_device_power_off(acc);
+       kfree(acc);
+
+	return 0;
+}
+
+static int mxc622x_acc_resume(struct i2c_client *client)
+{
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+#ifdef MXC622X_DEBUG
+    printk("%s.\n", __func__);
+#endif
+
+	if (acc != NULL && acc->on_before_suspend) {
+		acc->on_before_suspend = 0;
+		return mxc622x_acc_enable(acc);
+	}
+
+	return 0;
+}
+
+static int mxc622x_acc_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct mxc622x_acc_data *acc = i2c_get_clientdata(client);
+#ifdef MXC622X_DEBUG
+    printk("%s.\n", __func__);
+#endif
+    if (acc != NULL) {
+        if (atomic_read(&acc->enabled)) {
+		acc->on_before_suspend = 1;
+		return mxc622x_acc_disable(acc);
+        }
+    }
+    return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+static void mxc622x_early_suspend (struct early_suspend* es)
+{
+#ifdef MXC622X_DEBUG
+    printk("%s.\n", __func__);
+#endif
+    mxc622x_acc_suspend(mxc622x_i2c_client,
+         (pm_message_t){.event=0});
+}
+
+static void mxc622x_early_resume (struct early_suspend* es)
+{
+#ifdef MXC622X_DEBUG
+    printk("%s.\n", __func__);
+#endif
+    mxc622x_acc_resume(mxc622x_i2c_client);
+}
+
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+static const struct i2c_device_id mxc622x_acc_id[]
+				= { { MXC622X_ACC_DEV_NAME, 0 }, { }, };
+
+MODULE_DEVICE_TABLE(i2c, mxc622x_acc_id);
+
+static struct i2c_driver mxc622x_acc_driver = {
+	.driver = {
+            .owner = THIS_MODULE,
+            .name = MXC622X_ACC_I2C_NAME,
+        },
+	.probe = mxc622x_acc_probe,
+	.remove = mxc622x_acc_remove,
+	.resume = mxc622x_acc_resume,
+	.suspend = mxc622x_acc_suspend,
+	.id_table = mxc622x_acc_id,
+};
+
+
+
+static int __init mxc622x_acc_init(void)
+{
+	int  ret = 0;
+
+	printk(KERN_INFO "%s accelerometer driver: init\n", MXC622X_ACC_I2C_NAME);
+
+	return i2c_add_driver(&mxc622x_acc_driver);
+
+	return ret;
+}
+
+static void __exit mxc622x_acc_exit(void)
+{
+	printk(KERN_INFO "%s accelerometer driver exit\n", MXC622X_ACC_DEV_NAME);
+	i2c_del_driver(&mxc622x_acc_driver);
+}
+
+MODULE_DESCRIPTION("mxc622x accelerometer misc driver");
+MODULE_AUTHOR("Memsic");
+MODULE_LICENSE("GPL");
+
+module_init(mxc622x_acc_init);
+module_exit(mxc622x_acc_exit);
diff --git a/drivers/amlogic/input/sensor/stk220x_poll.c b/drivers/amlogic/input/sensor/stk220x_poll.c
new file mode 100644
index 000000000000..464d82ce8a07
--- /dev/null
+++ b/drivers/amlogic/input/sensor/stk220x_poll.c
@@ -0,0 +1,708 @@
+/*
+ *  stk220x_poll.c - Linux kernel modules for ambient light sensor
+ *
+ *  Copyright (C) 2010 Patrick Chang / SenseTek <patrick_chang@sitronix.com.tw>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/kthread.h>
+#include "linux/sensor/stk_defines.h"
+#include "linux/sensor/stk_lk_defs.h"
+#include "linux/sensor/stk220x.h"
+
+#define STKALS_DRV_NAME	"stk220x"
+#define DEVICE_NAME		"stk220x"
+#define DRIVER_VERSION  STK_DRIVER_VER
+#define ID_STKALS 9999
+
+#define ODR_DELAY 400
+
+#define stk_writeb(x,y) i2c_smbus_write_byte_data(pStkAlsData->client,x,y)
+#define stk_readb(x) i2c_smbus_read_byte_data(pStkAlsData->client,x)
+
+
+#define ABS(x) ((x)>=0? (x):(-x))
+
+#define STK_LOCK0 mutex_unlock(&stkals_io_lock)
+#define STK_LOCK1 mutex_lock(&stkals_io_lock)
+
+static int32_t init_all_setting(void);
+static int32_t get_lux(void);
+#if 0
+static int32_t get_it(void);
+static int32_t get_gain(void);
+#endif
+static int32_t set_it(uint32_t it);
+static int32_t set_gain(uint32_t gain);
+static int32_t enable_als(uint32_t enable);
+static int32_t set_power_state(uint32_t nShutdown);
+
+/*define for polling thread*/
+static int polling_function(void* arg);
+static struct task_struct *polling_tsk;
+
+
+static struct mutex stkals_io_lock;
+static struct completion thread_completion;
+
+
+struct stkals_data* pStkAlsData = NULL;
+
+#ifdef CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+static int32_t als_transmittance = CONFIG_STK_ALS_TRANSMITTANCE;
+#endif //CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+
+
+inline void report_event(struct input_dev* dev,int32_t report_value)
+{
+	input_report_abs(dev, ABS_MISC, report_value);
+	input_sync(dev);
+	INFO("STK ALS : als input event %d lux\n",report_value);
+}
+
+inline void update_and_check_report_als(int32_t lux)
+{
+    int32_t lux_last;
+    lux_last = pStkAlsData->als_lux_last;
+
+    if (unlikely(abs(lux - lux_last)>=CONFIG_STK_ALS_CHANGE_THRESHOLD))
+    {
+        pStkAlsData->als_lux_last = lux;
+        report_event(pStkAlsData->input_dev,lux);
+    }
+}
+static int polling_function(void* arg)
+{
+	uint32_t lux;
+	uint32_t delay;
+	init_completion(&thread_completion);
+
+	while (1)
+	{
+		STK_LOCK(1);
+		delay = pStkAlsData->als_delay;
+		lux = get_lux();
+        update_and_check_report_als(lux);
+		if (pStkAlsData->bThreadRunning == 0)
+			break;
+		STK_LOCK(0);
+		msleep(delay);
+
+	};
+
+    STK_LOCK(0);
+    complete(&thread_completion);
+	return 0;
+}
+
+inline int32_t get_reading(void)
+{
+	return STK_ALS_DATA(stk_readb(STK_ALS_DT1_REG),stk_readb(STK_ALS_DT2_REG));
+}
+
+inline int32_t alscode2lux(int32_t alscode)
+{
+    //R-set Def --> 500KOhm ==> x 5
+    //IT --> x1
+    //Gain --> x2
+    // Total x 10
+
+    alscode<<=10; // x 1024
+    // Org : 1 code (100KOhm, IT = x1 , Gain = x1) ~ 1 lux
+    // x10 x1024 ==> 10240 code = 1 lux
+#ifdef CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+    return alscode/als_transmittance;
+#else
+    return alscode/CONFIG_STK_ALS_TRANSMITTANCE;
+#endif //CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+}
+
+static int32_t get_lux()
+{
+    return  alscode2lux(get_reading());
+}
+#if 0
+static int32_t get_it()
+{
+	int32_t val;
+	val = stk_readb(STK_ALS_CMD_REG);
+	val = (val &STK_ALS_CMD_IT_MASK)>>STK_ALS_CMD_IT_SHIFT;
+    return val;
+}
+static int32_t get_gain()
+{
+	int32_t val;
+	val = stk_readb(STK_ALS_CMD_REG);
+	val = (val &STK_ALS_CMD_GAIN_MASK)>>STK_ALS_CMD_GAIN_SHIFT;
+    return val;
+}
+#endif
+static int32_t set_it(uint32_t it)
+{
+	int32_t val;
+	val = stk_readb(STK_ALS_CMD_REG);
+	val &= (~STK_ALS_CMD_IT_MASK);
+	val |= STK_ALS_CMD_IT(it);
+	return stk_writeb(STK_ALS_CMD_REG,val);
+}
+
+static int32_t set_gain(uint32_t gain)
+{
+	int32_t val;
+	val = stk_readb(STK_ALS_CMD_REG);
+	val &= (~STK_ALS_CMD_GAIN_MASK);
+	val |= STK_ALS_CMD_GAIN(gain);
+	return stk_writeb(STK_ALS_CMD_REG,val);
+}
+
+static int32_t set_power_state(uint32_t nShutdown)
+{
+	int32_t val;
+	val = stk_readb(STK_ALS_CMD_REG);
+	val &= (~STK_ALS_CMD_SD_MASK);
+	val |= STK_ALS_CMD_SD(nShutdown);
+	return stk_writeb(STK_ALS_CMD_REG,val);
+}
+
+
+static int32_t enable_als(uint32_t enable)
+{
+	int32_t ret;
+	ret = set_power_state(enable?0:1);
+	if (enable)
+	{
+
+		if (pStkAlsData->bThreadRunning == 0)
+		{
+			pStkAlsData->als_lux_last = 0;
+			pStkAlsData->bThreadRunning = 1;
+			polling_tsk = kthread_run(polling_function,NULL,"als_polling");
+		}
+		else
+		{
+		    WARNING("STK_ALS : thread has running\n");
+        }
+	}
+	else
+	{
+		if (pStkAlsData->bThreadRunning)
+		{
+			pStkAlsData->bThreadRunning = 0;
+			STK_LOCK(0);
+			wait_for_completion(&thread_completion);
+			STK_LOCK(1);
+			polling_tsk = NULL;
+		}
+	}
+	return ret;
+}
+
+
+static int32_t init_all_setting()
+{
+	uint32_t val;
+	enable_als(0);
+	pStkAlsData->bThreadRunning = 0;
+	set_gain(1); //x2
+	set_it(1); //x1
+	val = stk_readb(STK_ALS_CMD_REG);
+	INFO("Init ALS Setting --> CMDREG = 0x%x\n",val);
+    return 0; // OK
+}
+
+
+
+
+static ssize_t help_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+     return sprintf(buf, "Usage : cat xxxx\nor echo val > xxxx\
+     \nWhere xxxx = lux : RO (0~by your setting)\
+     \nals_enable : RW (0~1)\nals_transmittance : RW (1~10000)\n");
+
+}
+
+static ssize_t lux_range_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+    return sprintf(buf, "%d\n", alscode2lux((1<<12) -1));//full code
+
+}
+
+
+static ssize_t als_enable_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+    int32_t enable;
+    STK_LOCK(1);
+    enable = pStkAlsData->bThreadRunning;
+    STK_LOCK(0);
+    return sprintf(buf, "%d\n", enable);
+}
+
+
+static ssize_t als_enable_store(struct kobject *kobj,
+                                struct kobj_attribute *attr,
+                                const char *buf, size_t len)
+{
+    uint32_t value = simple_strtoul(buf, NULL, 10);
+    INFO("STK ALS Driver : Enable ALS : %d\n",value);
+    STK_LOCK(1);
+    enable_als(value);
+    STK_LOCK(0);
+    return len;
+}
+
+
+static ssize_t lux_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+    int32_t lux;
+    STK_LOCK(1);
+    lux = pStkAlsData->als_lux_last;
+    STK_LOCK(0);
+    return sprintf(buf, "%d lux\n", lux);
+}
+static ssize_t lux_store(struct kobject *kobj,
+                                struct kobj_attribute *attr,
+                                const char *buf, size_t len)
+{
+    unsigned long value = simple_strtoul(buf, NULL, 10);
+    STK_LOCK(1);
+    report_event(pStkAlsData->input_dev,value);
+    STK_LOCK(0);
+    return len;
+}
+static ssize_t lux_res_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+    return sprintf(buf, "1\n");
+}
+static ssize_t driver_version_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+    return sprintf(buf,"%s\n",STK_DRIVER_VER);
+}
+
+
+#define __DEBUG_SYSFS_BIN 1
+
+ssize_t stk_bin_sysfs_read(als_lux_range)
+{
+    uint32_t* pDst = (uint32_t*)buffer;
+#if __DEBUG_SYSFS_BIN
+    if (count != sizeof(uint32_t))
+    {
+        WARNING("STK ALS Driver : Error --> Read Lux Range(bin) size !=4\n");
+        return 0;
+    }
+#endif
+
+    *pDst = alscode2lux((1<<12)-1);
+    return sizeof(uint32_t);
+}
+
+ssize_t stk_bin_sysfs_read(als_lux_resolution)
+{
+    uint32_t* pDst = (uint32_t*)buffer;
+#if __DEBUG_SYSFS_BIN
+    if (count != sizeof(uint32_t))
+    {
+        WARNING("STK ALS Driver : Error --> Read Distance Range(bin) size !=4\n");
+        return 0;
+    }
+#endif
+   // means 1 lux for Android
+  *pDst = 1;
+  return sizeof(uint32_t);
+}
+
+ssize_t stk_bin_sysfs_read(lux_bin)
+{
+
+    int32_t *pDst = (int32_t*)buffer;
+
+#if __DEBUG_SYSFS_BIN
+    if (count != sizeof(uint32_t))
+    {
+        WARNING("STK ALS Driver : Error --> Read Lux(bin) size !=4\n");
+        return 0;
+    }
+#endif
+    STK_LOCK(1);
+    *pDst = pStkAlsData->als_lux_last;
+    STK_LOCK(0);
+    return sizeof(uint32_t);
+}
+
+
+ssize_t stk_bin_sysfs_read(als_enable)
+{
+#if __DEBUG_SYSFS_BIN
+    if (count != sizeof(uint8_t))
+    {
+        WARNING("STK ALS Driver : Error --> Read als_enable_bin size !=1\n");
+        return 0;
+    }
+#endif
+    STK_LOCK(1);
+    buffer[0] = pStkAlsData->bThreadRunning?1:0;
+    STK_LOCK(0);
+    return sizeof(uint8_t);
+}
+
+ssize_t  stk_bin_sysfs_write(als_enable)
+{
+#if __DEBUG_SYSFS_BIN
+    INFO("STK ALS Driver : Enable ALS : %d\n",(int32_t)(buffer[0]));
+#endif
+    STK_LOCK(1);
+    enable_als(buffer[0]);
+    STK_LOCK(0);
+    return count;
+}
+
+ssize_t stk_bin_sysfs_read(als_delay)
+{
+#if __DEBUG_SYSFS_BIN
+    if (count != sizeof(uint32_t))
+    {
+        WARNING("STK ALS Driver : Error --> Read als_delay size !=4\n");
+        return 0;
+    }
+#endif
+    STK_LOCK(1);
+    *((uint32_t*)buffer) = pStkAlsData->als_delay;
+    STK_LOCK(0);
+    return sizeof(uint32_t);
+}
+
+ssize_t stk_bin_sysfs_write(als_delay)
+{
+    uint32_t delay;
+#if __DEBUG_SYSFS_BIN
+    INFO("STK ALS Driver : Set ALS Delay: %d\n",*((int32_t*)buffer));
+#endif
+    delay = *((uint32_t*)buffer);
+    if (delay<ALS_MIN_DELAY)
+        delay = ALS_MIN_DELAY;
+    STK_LOCK(1);
+    pStkAlsData->als_delay = delay;
+    STK_LOCK(0);
+    return count;
+}
+
+ssize_t stk_bin_sysfs_read(als_min_delay)
+{
+#if __DEBUG_SYSFS_BIN
+    if (count != sizeof(uint32_t))
+    {
+        WARNING("STK ALS Driver : Error --> Read als_min_delay size !=4\n");
+        return 0;
+    }
+#endif
+    *((uint32_t*)buffer) = ALS_MIN_DELAY;
+    return sizeof(uint32_t);
+}
+
+#ifdef CONFIG_STK_SYSFS_DBG
+static struct kobj_attribute help_attribute = (struct kobj_attribute)__ATTR_RO(help);
+static struct kobj_attribute driver_version_attribute = (struct kobj_attribute)__ATTR_RO(driver_version);
+#endif //CONFIG_STK_SYSFS_DBG
+static struct kobj_attribute lux_range_attribute = (struct kobj_attribute)__ATTR_RO(lux_range);
+static struct kobj_attribute lux_attribute = (struct kobj_attribute)__ATTR_RW(lux);
+static struct kobj_attribute als_enable_attribute = (struct kobj_attribute)__ATTR_RW(als_enable);
+static struct kobj_attribute als_lux_res_attribute = (struct kobj_attribute)__ATTR_RO(lux_res);
+
+static struct bin_attribute als_lux_range_bin_attribute = __ATTR_BIN_RO(lux_range_bin,als_lux_range_read,sizeof(uint32_t));
+static struct bin_attribute als_lux_bin_attribute = __ATTR_BIN_RO(lux_bin,lux_bin_read,sizeof(uint32_t));
+static struct bin_attribute als_lux_res_bin_attribute = __ATTR_BIN_RO(lux_resolution_bin,als_lux_resolution_read,sizeof(uint32_t));
+static struct bin_attribute als_enable_bin_attribute = __ATTR_BIN_RW(als_enable_bin,als_enable_read,als_enable_write,sizeof(uint8_t));
+/* <---DEPRECATED */
+static struct bin_attribute als_delay_bin_attribute = __ATTR_BIN_RW(als_delay_bin,als_delay_read,als_delay_write,sizeof(uint32_t));
+static struct bin_attribute als_min_delay_bin_attribute = __ATTR_BIN_RO(als_min_delay_bin,als_min_delay_read,sizeof(uint32_t));
+/* DEPRECATED---> */
+
+#ifdef CONFIG_STK_SYSFS_DBG
+
+#ifdef CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+static ssize_t als_transmittance_show(struct kobject * kobj, struct kobj_attribute * attr, char * buf)
+{
+    int32_t transmittance;
+    STK_LOCK(1);
+    transmittance = als_transmittance;
+    STK_LOCK(0);
+    return sprintf(buf, "%d\n", transmittance);
+}
+
+static ssize_t als_transmittance_store(struct kobject *kobj,
+                                       struct kobj_attribute *attr,
+                                       const char *buf, size_t len)
+{
+    unsigned long value = simple_strtoul(buf, NULL, 10);
+    STK_LOCK(1);
+    als_transmittance = value;
+    STK_LOCK(0);
+    return len;
+}
+
+static struct kobj_attribute als_transmittance_attribute = (struct kobj_attribute)__ATTR_RW(als_transmittance);
+#endif // CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+
+
+#endif //CONFIG_STK_SYSFS_DBG
+
+static struct attribute* sensetek_optical_sensors_attrs [] =
+{
+    &lux_range_attribute.attr,
+    &lux_attribute.attr,
+    &als_enable_attribute.attr,
+    &als_lux_res_attribute.attr,
+    NULL,
+};
+
+#ifdef CONFIG_STK_SYSFS_DBG
+static struct attribute* sensetek_optical_sensors_dbg_attrs [] =
+{
+    &help_attribute.attr,
+    &lux_range_attribute.attr,
+    &lux_attribute.attr,
+    &als_enable_attribute.attr,
+    &als_lux_res_attribute.attr,
+    &driver_version_attribute.attr,
+#ifdef CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+    &als_transmittance_attribute.attr,
+#endif
+    NULL,
+};
+// those attributes are only for engineer test/debug
+static struct attribute_group sensetek_optics_sensors_attrs_group =
+{
+    .name = "DBG",
+    .attrs = sensetek_optical_sensors_dbg_attrs,
+};
+#endif //CONFIG_STK_SYSFS_DBG
+
+
+static struct bin_attribute* sensetek_optical_sensors_bin_attrs[] =
+{
+    &als_lux_range_bin_attribute,
+    &als_lux_bin_attribute,
+    &als_lux_res_bin_attribute,
+    &als_enable_bin_attribute,
+    &als_delay_bin_attribute,
+    &als_min_delay_bin_attribute,
+    NULL,
+};
+
+
+static struct platform_device *stk_oss_dev = NULL; /* Device structure */
+
+static int stk_sysfs_create_files(struct kobject *kobj,struct attribute** attrs)
+{
+    int err;
+    while(*attrs!=NULL)
+    {
+        err = sysfs_create_file(kobj,*attrs);
+        if (err)
+            return err;
+        attrs++;
+    }
+    return 0;
+}
+static int stk_sysfs_create_bin_files(struct kobject *kobj,struct bin_attribute** bin_attrs)
+{
+    int err;
+    while(*bin_attrs!=NULL)
+    {
+        err = sysfs_create_bin_file(kobj,*bin_attrs);
+        if (err)
+            return err;
+        bin_attrs++;
+    }
+    return 0;
+}
+/*
+//DEPRECATED
+static void stk_sysfs_remove_bin_files(struct kobject *kobj,struct bin_attribute** bin_attrs)
+{
+    while(*bin_attrs!=NULL)
+    {
+        sysfs_remove_bin_file(kobj,*bin_attrs);
+        bin_attrs++;
+    }
+}
+//DEPRECATED
+*/
+
+
+/*
+ * Called when a stk als device is matched with this driver
+ */
+static int stk_als_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+    int32_t err;
+	struct stkals_data*  als_data;
+	if (i2c_smbus_read_byte_data(client,STK_ALS_CMD_REG)<0)
+	{
+		ERR("STKALS : no device found\n");
+		return -ENODEV;
+	}
+	INFO("STK ALS : als i2c slave address = 0x%x\n",client->addr);
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+	{
+		ERR("STKALS -- No Support for I2C_FUNC_SMBUS_BYTE_DATA\n");
+		return -ENODEV;
+	}
+	als_data = kzalloc(sizeof(struct stkals_data),GFP_KERNEL);
+    if (unlikely(als_data == 0))
+    {
+		ERR("STKALS -- No enough memory\n");
+		return -ENOMEM;
+	}
+	als_data->client = client;
+	i2c_set_clientdata(client,als_data);
+	mutex_init(&stkals_io_lock);
+
+	pStkAlsData = als_data;
+	als_data->als_delay = ODR_DELAY;
+#ifdef CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+	als_transmittance = CONFIG_STK_ALS_TRANSMITTANCE;
+#endif
+	init_all_setting();
+
+    pStkAlsData->input_dev = input_allocate_device();
+	if (pStkAlsData->input_dev==NULL)
+	{
+	    mutex_destroy(&stkals_io_lock);
+	    kfree(pStkAlsData);
+	    pStkAlsData = NULL;
+	    return -ENOMEM;
+    }
+    pStkAlsData->input_dev->name = ALS_NAME;
+	set_bit(EV_ABS, pStkAlsData->input_dev->evbit);
+    input_set_abs_params(pStkAlsData->input_dev, ABS_MISC, 0, alscode2lux((1<<12)-1), 0, 0);
+    err = input_register_device(pStkAlsData->input_dev);
+    if (err<0)
+    {
+        ERR("STK ALS : can not register als input device\n");
+        mutex_destroy(&stkals_io_lock);
+        input_free_device(pStkAlsData->input_dev);
+        kfree(pStkAlsData);
+        pStkAlsData = NULL;
+        return err;
+    }
+    INFO("STK ALS : register als input device OK\n");
+
+    err = stk_sysfs_create_bin_files(&(pStkAlsData->input_dev->dev.kobj),sensetek_optical_sensors_bin_attrs);
+    if (err)
+    {
+ 
+        return -ENOMEM;
+    }
+    err = stk_sysfs_create_files(&(pStkAlsData->input_dev->dev.kobj),sensetek_optical_sensors_attrs);
+    if (err)
+    {
+
+        return -ENOMEM;
+    }
+#ifdef CONFIG_STK_SYSFS_DBG
+    err = sysfs_create_group(&(pStkAlsData->input_dev->dev.kobj), &sensetek_optics_sensors_attrs_group);
+    if (err)
+    {
+
+        return -ENOMEM;
+    }
+#endif
+
+	return 0;
+}
+
+static int stk_als_remove(struct i2c_client *client)
+{
+    platform_device_put(stk_oss_dev);
+	mutex_destroy(&stkals_io_lock);
+	if (pStkAlsData)
+	{
+        input_unregister_device(pStkAlsData->input_dev);
+        input_free_device(pStkAlsData->input_dev);
+		kfree(pStkAlsData);
+		pStkAlsData = 0;
+	}
+	return 0;
+}
+
+static const struct i2c_device_id stk_als_id[] = {
+	{ "stk220x", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, stk_als_id);
+
+static struct i2c_driver stk_als_driver = {
+	.driver = {
+		.name = STKALS_DRV_NAME,
+	},
+	.probe = stk_als_probe,
+	.remove = stk_als_remove,
+	.id_table = stk_als_id,
+};
+
+static int __init stk_i2c_als_init(void)
+{
+    int ret;
+    ret = i2c_add_driver(&stk_als_driver);
+    if (ret)
+        return ret;
+#if 0
+    if (pStkAlsData == NULL)
+        return -EINVAL;
+    stk_oss_dev = platform_device_alloc(DEVICE_NAME,-1);
+    if (!stk_oss_dev)
+    {
+       i2c_del_driver(&stk_als_driver);
+       return -ENOMEM;
+    }
+    if (platform_device_add(stk_oss_dev))
+    {
+       i2c_del_driver(&stk_als_driver);
+       return -ENOMEM;
+    }
+	INFO("STK ALS Module initialized.\n");
+#endif
+	return 0;
+}
+
+static void __exit stk_i2c_als_exit(void)
+{
+	i2c_del_driver(&stk_als_driver);
+}
+
+MODULE_AUTHOR("Patrick Chang <patrick_chang@sitronix.com>");
+MODULE_DESCRIPTION("SenseTek Ambient Light Sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(stk_i2c_als_init);
+module_exit(stk_i2c_als_exit);
diff --git a/drivers/amlogic/input/sensor/stk831x.c b/drivers/amlogic/input/sensor/stk831x.c
index bd70af09d105..8c4931da57d1 100644
--- a/drivers/amlogic/input/sensor/stk831x.c
+++ b/drivers/amlogic/input/sensor/stk831x.c
@@ -1,8 +1,7 @@
 /*
  *  stk831x.c - Linux kernel modules for sensortek stk8311/stk8312/stk8313 accelerometer
  *
- *  Copyright (C) 2011~2012 Lex Hsieh / sensortek 
- * <lex_hsieh@sitronix.com.tw>  or <lex_hsieh@sensortek.com.tw>
+ *  Copyright (C) 2011~2013 Lex Hsieh / sensortek <lex_hsieh@sensortek.com.tw>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -17,7 +16,8 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */   
+ */
+
 #include <linux/module.h>
 #include <linux/i2c.h>
 #include <linux/slab.h>
@@ -32,34 +32,92 @@
 #include <linux/kthread.h>
 #include <linux/version.h>
 #include <linux/pm_runtime.h>
-#include   <linux/fs.h>   
-#include  <asm/uaccess.h>
-//#define STK_PERMISSION_THREAD
-#ifdef STK_PERMISSION_THREAD
+#include <linux/fs.h>   
+#include <linux/workqueue.h>
 #include <linux/fcntl.h>
 #include <linux/syscalls.h>
-#endif 	//	#ifdef STK_PERMISSION_THREAD
+//#include <linux/time.h>
 
-#include <linux/sensor/sensor_common.h>
+//#define CONFIG_GRAVITY_STK8312
+//#define CONFIG_GRAVITY_STK8313
 
-#ifdef CONFIG_GRAVITY_STK8313
-	#include <linux/sensor/stk8313.h>
-#elif defined CONFIG_GRAVITY_STK8312
-	#include <linux/sensor/stk8312.h>
-#else
-	#error "What's your stk accelerometer?"
-#endif
+//#define STK_ALLWINNER_PLATFORM
+//#define STK_ALLWINNER_A13
+//#define STK_ALLWINNER_A20_A31
+//#define STK_ROCKCHIP_PLATFORM
 
-#define STK_ACC_DRIVER_VERSION	"1.5.6"
+#define STK_ACC_DRIVER_VERSION	"1.8.0"
 /*choose polling or interrupt mode*/
 #define STK_ACC_POLLING_MODE	1
 #if (!STK_ACC_POLLING_MODE)
 	#define ADDITIONAL_GPIO_CFG 1
 	#define STK_INT_PIN	39
 #endif
+//#define STK_PERMISSION_THREAD
+#define STK_RESUME_RE_INIT	
+//#define STK_DEBUG_PRINT
+//#define STK_DEBUG_RAWDATA
+//#define STK_LOWPASS
+#define STK_FIR_LEN	4
+
+#define STK_ZG_FILTER
+#ifdef CONFIG_GRAVITY_STK8312
+	#define STK_ZG_COUNT	1
+#elif defined (CONFIG_GRAVITY_STK8313)
+	#define STK_ZG_COUNT	4
+#endif
+
+#define STK_TUNE
+#ifdef CONFIG_GRAVITY_STK8312
+	#define STK_TUNE_XYOFFSET 3
+	#define STK_TUNE_ZOFFSET 6
+	#define STK_TUNE_NOISE 5
+#elif defined (CONFIG_GRAVITY_STK8313)
+	#define STK_TUNE_XYOFFSET 35
+	#define STK_TUNE_ZOFFSET 75
+	#define STK_TUNE_NOISE 20	
+#endif
+#define STK_TUNE_NUM 125
+#define STK_TUNE_DELAY 125
+
+#ifndef STK_ALLWINNER_PLATFORM
+	#ifdef CONFIG_GRAVITY_STK8313
+		#include <linux/sensor/stk8313.h>
+	#elif defined CONFIG_GRAVITY_STK8312
+		#include <linux/sensor/stk8312.h>
+	#else
+		#error "What's your stk accelerometer?"
+	#endif
+#else
+	#ifdef CONFIG_GRAVITY_STK8313
+		#include "stk8313.h"
+	#elif defined CONFIG_GRAVITY_STK8312
+		#include "stk8312.h"
+	#else
+		#error "What's your stk accelerometer?"
+	#endif
+#endif	/* #ifndef STK_ALLWINNER_PLATFORM */
+
+#ifdef STK_ALLWINNER_PLATFORM
+	#include <mach/system.h>
+	#include <mach/hardware.h>
+	#include <mach/sys_config.h>
+#endif
+
+//SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, mode_t, mode);
 
 static struct i2c_client *this_client;
 
+#if defined(STK_LOWPASS)
+#define MAX_FIR_LEN 32
+struct data_filter {
+    s16 raw[MAX_FIR_LEN][3];
+    int sum[3];
+    int num;
+    int idx;
+};
+#endif
+
 struct stk831x_data 
 {
 	struct input_dev *input_dev;
@@ -68,33 +126,87 @@ struct stk831x_data
 	int raw_data[3]; 
 	atomic_t enabled;
 	unsigned char delay;	
-	struct mutex read_lock;
+	struct mutex write_lock;
 	bool first_enable;
+	bool re_enable;
+	char recv_reg;
 #if STK_ACC_POLLING_MODE
-	atomic_t run_thread;
+	struct hrtimer acc_timer;	
+    struct work_struct stk_acc_work;
+	struct workqueue_struct *stk_acc_wq;	
+	ktime_t acc_poll_delay;		
 #endif	//#if STK_ACC_POLLING_MODE
+	atomic_t cali_status;
+#if defined(STK_LOWPASS)
+	atomic_t                firlength;
+	atomic_t                fir_en;
+	struct data_filter      fir;
+#endif 		
+};
+
+#ifdef CONFIG_GRAVITY_STK8313
+struct stk831x_range {
+    char rng;               // RNG[1:0]
+    int range;             // g*2
+    int resolution;      // bit data output
+}stk8313_range[4] = {
+    {0,  2*2,   10},
+    {1,  4*2,   11},
+    {2,  8*2,   12},
+    {3,  16*2, 12},
+};
+#elif defined(CONFIG_GRAVITY_STK8312)
+struct stk831x_range {
+    char rng;
+    int range;
+    int resolution;
+}stk8312_range[3] = {
+    {0,  3,       6},      /* 1.5*2 */
+    {1,  6*2,    8},
+    {2,  16*2,  8},
 };
+#endif
 
-const static int STK831X_SAMPLE_TIME[6] = {2500, 5000, 10000, 20000, 40000, 80000};
+//#define STK831X_HOLD_ODR
+#define STK831X_INIT_ODR		2		//2:100Hz, 3:50Hz, 4:25Hz
+#define STK831X_SAMPLE_TIME_MIN_NO		2
+#define STK831X_SAMPLE_TIME_NO		5
+const static int STK831X_SAMPLE_TIME[STK831X_SAMPLE_TIME_NO] = {2500, 5000, 10000, 20000, 40000};
 static struct stk831x_data *stk831x_data_ptr;
-static unsigned char event_since_en = 0;
-static char cali_offset[3] = {0};
-#if STK_ACC_POLLING_MODE
-static struct completion acc_thread_completion;
-static struct task_struct *acc_polling_tsk=NULL;
-static int stk_acc_polling_function(void *arg);
-#else
+static int event_since_en = 0;
+static int event_since_en_limit = 20;
+#if (!STK_ACC_POLLING_MODE)
 static struct workqueue_struct *stk_mems_work_queue = NULL;
 #endif	//#if STK_ACC_POLLING_MODE
 
-//#define STK_DEBUG_CALI
-#define STK_SAMPLE_NO	10
-//#define STORE_OFFSET_IN_FILE
-#define STORE_OFFSET_IN_IC
+#define STK_DEBUG_CALI
+#define STK_SAMPLE_NO				10
 #define STK_ACC_CALI_VER0			0x3D
 #define STK_ACC_CALI_VER1			0x01
-#define STK_ACC_CALI_FILE "/data/misc/stk_acc_cali.conf"
-#define STK_ACC_CALI_FILE_SIZE 6
+#define STK_ACC_CALI_FILE 			"/data/misc/stkacccali.conf"
+#define STK_ACC_CALI_FILE_SIZE 		10
+
+#define STK_K_SUCCESS_TUNE			0x04
+#define STK_K_SUCCESS_FT2			0x03
+#define STK_K_SUCCESS_FT1			0x02
+#define STK_K_SUCCESS_FILE			0x01
+#define STK_K_NO_CALI				0xFF
+#define STK_K_RUNNING				0xFE
+#define STK_K_FAIL_LRG_DIFF			0xFD
+#define STK_K_FAIL_OPEN_FILE			0xFC
+#define STK_K_FAIL_W_FILE				0xFB
+#define STK_K_FAIL_R_BACK				0xFA
+#define STK_K_FAIL_R_BACK_COMP		0xF9
+#define STK_K_FAIL_I2C				0xF8
+#define STK_K_FAIL_K_PARA				0xF7
+#define STK_K_FAIL_OTP_OUT_RG		0xF6
+#define STK_K_FAIL_ENG_I2C			0xF5
+#define STK_K_FAIL_FT1_USD			0xF4
+#define STK_K_FAIL_FT2_USD			0xF3
+#define STK_K_FAIL_WRITE_NOFST		0xF2
+#define STK_K_FAIL_OTP_5T				0xF1
+#define STK_K_FAIL_PLACEMENT			0xF0
+
 
 #define POSITIVE_Z_UP		0
 #define NEGATIVE_Z_UP	1
@@ -103,35 +215,259 @@ static struct workqueue_struct *stk_mems_work_queue = NULL;
 #define POSITIVE_Y_UP		4
 #define NEGATIVE_Y_UP	5
 static unsigned char stk831x_placement = POSITIVE_Z_UP;
+#ifdef STK_TUNE
+static char stk_tune_offset_record[3] = {0};
+static int stk_tune_offset[3] = {0};
+static int stk_tune_sum[3] = {0};
+static int stk_tune_max[3] = {0};
+static int stk_tune_min[3] = {0};
+static int stk_tune_index = 0;
+static int stk_tune_done = 0;
+#endif
 
-static int stk_store_in_ic( struct stk831x_data *stk, char offset[], char otp_offset[], char FT_index, unsigned char stk831x_placement);
+static int stk_store_in_ic( struct stk831x_data *stk, char otp_offset[], char FT_index, uint32_t delay_ms);
 static int32_t stk_get_file_content(char * r_buf, int8_t buf_size);
-static int stk_store_in_file(char offset[]);
+static int stk_store_in_file(char offset[], char mode);
+static int STK831x_ReadByteOTP(char rReg, char *value);
+static int STK831x_SetEnable(struct stk831x_data *stk, char en);
+static int STK831x_SetCali(struct stk831x_data *stk, char sstate);
+static int32_t stk_get_ic_content(struct stk831x_data *stk);
+static int STK831x_SetOffset(char buf[]);
+static void stk_handle_first_en(struct stk831x_data *stk);
+static int STK831x_GetDelay(struct stk831x_data *stk, uint32_t* gdelay_ns);
+static int STK831x_SetDelay(struct stk831x_data *stk, uint32_t sdelay_ns);
+
+#ifdef STK_ALLWINNER_PLATFORM
+static int gsensor_direct_x = 0;
+static int gsensor_direct_y = 0;
+static int gsensor_direct_z = 0;
+static int gsensor_xy_revert = 0;
+
+enum {
+	DEBUG_INIT              = 1U << 0,
+	DEBUG_CONTROL_INFO      = 1U << 1,
+	DEBUG_DATA_INFO         = 1U << 2,
+	DEBUG_SUSPEND           = 1U << 3,
+};
+static u32 debug_mask = 0;
+#define dprintk(level_mask, fmt, arg...)	if (unlikely(debug_mask & level_mask)) \
+	printk(KERN_DEBUG fmt , ## arg)
+
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#endif /* #ifdef STK_ALLWINNER_PLATFORM */
+
+#ifdef STK_ALLWINNER_PLATFORM
+/* Addresses to scan */
+static union
+{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+static __u32 twi_id = 1;
+#endif	/* #ifdef STK_ALLWINNER_PLATFORM */
+
+/**
+ * gsensor_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+#ifdef STK_ALLWINNER_A20_A31
+static int gsensor_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	script_item_u	val;
+	script_item_value_type_e  type;	
+			
+	dprintk(DEBUG_INIT, "========%s===================\n", __func__);
+		
+	type = script_get_item("gsensor_para", "gsensor_used", &val);
+	 
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		pr_err("%s: type err  device_used = %d. \n", __func__, val.val);
+		goto script_get_err;
+	}
+	device_used = val.val;
+		
+	if (1 == device_used) {
+		type = script_get_item("gsensor_para", "gsensor_twi_id", &val); 
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != type){
+			pr_err("%s: type err twi_id = %d. \n", __func__, val.val);
+			goto script_get_err;
+		}
+		twi_id = val.val;
+			
+		dprintk(DEBUG_INIT, "%s: twi_id is %d. \n", __func__, twi_id);
+
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("gsensor_para", "gsensor_direct_x", &val)){
+			pr_err("%s: line: %d: script_get_item err. \n", __FILE__, __LINE__);
+			goto script_get_err;
+		}
+		gsensor_direct_x = val.val;
+
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("gsensor_para", "gsensor_direct_y", &val)){
+			pr_err("%s: line: %d: script_get_item err. \n", __FILE__, __LINE__);
+			goto script_get_err;
+		}
+		gsensor_direct_y = val.val;
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("gsensor_para", "gsensor_direct_z", &val)){
+			pr_err("%s: line: %d: script_get_item err. \n", __FILE__, __LINE__);
+			goto script_get_err;
+		}
+		gsensor_direct_z = val.val;
+
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("gsensor_para", "gsensor_xy_revert", &val)){
+			pr_err("%s: line: %d: script_get_item err. \n", __FILE__, __LINE__);
+			goto script_get_err;
+		}
+		gsensor_xy_revert = val.val;
+
+		ret = 0;
+			
+	} else {
+		pr_err("%s: gsensor_unused. \n",  __func__);
+		ret = -1;
+	}
+	
+	return ret;
+	
+script_get_err:
+	pr_notice("=========script_get_err============\n");
+	return ret;
+}	
+#endif /* #ifdef STK_ALLWINNER_A20_A31 */
+
+#ifdef STK_ALLWINNER_A13	
+static int gsensor_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	
+	printk("========%s===================\n", __func__);
+	
+	if(SCRIPT_PARSER_OK != (ret = script_parser_fetch("gsensor_para", "gsensor_used", &device_used, 1))){
+		pr_err("%s: script_parser_fetch err.ret = %d. \n", __func__, ret);
+		goto script_parser_fetch_err;
+	}
+	if(1 == device_used){
+		if(SCRIPT_PARSER_OK != script_parser_fetch("gsensor_para", "gsensor_twi_id", &twi_id, 1)){
+			pr_err("%s: script_parser_fetch err. \n",__func__);
+			goto script_parser_fetch_err;
+		}
+		printk("%s: twi_id is %d. \n", __func__, twi_id);
+		
+		stk8313_pin_hd = gpio_request_ex("gsensor_para",NULL);
+		if (stk8313_pin_hd==-1) {
+			printk("stk8313_pin_hd pin request error!\n");
+		}
+		ret = 0;
+		
+		}else{
+		pr_err("%s: gsensor_unused. \n",  __func__);
+		ret = -1;
+	}
+	
+	return ret;
+	
+	script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+}	
+#endif	/* #ifdef STK_ALLWINNER_A13 */
+	
+
 
 static int STK_i2c_Rx(char *rxData, int length)
 {
-	if( i2c_master_send(this_client, rxData, 1) < 0)
-		return -EIO;
+	uint8_t retry;	
+#ifdef STK_ROCKCHIP_PLATFORM	
+	int scl_clk_rate = 100 * 1000;
+#endif	
+	struct i2c_msg msgs[] = 
+	{
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+#ifdef STK_ROCKCHIP_PLATFORM				
+			.scl_rate = scl_clk_rate,
+#endif			
+		},
+		{
+			.addr = this_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+#ifdef STK_ROCKCHIP_PLATFORM				
+			.scl_rate = scl_clk_rate,			
+#endif			
+		},
+	};
+	
+	for (retry = 0; retry <= 3; retry++) 
+	{
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0)
+			break;
+		else
+			mdelay(10);
+	}
 	
-	if (i2c_master_recv(this_client, rxData, length) < 0)
+	if (retry > 3) 
+	{
+		printk(KERN_ERR "%s: i2c error, retry over 3\n", __func__);
 		return -EIO;
-
-	return 0;
+	} 
+	else
+		return 0;	
 }
 
 static int STK_i2c_Tx(char *txData, int length)
 {
-	unsigned char w_twice = 0;
-	if(*txData >= 0x21 && *txData <= 0x3F)
-		w_twice = 1;
-	if(i2c_master_send(this_client, txData, length) < 0)
-		return -EIO;
-	if(w_twice)
+	int retry;
+#ifdef STK_ROCKCHIP_PLATFORM	
+	int scl_clk_rate = 100 * 1000;
+#endif		
+	struct i2c_msg msg[] = 
 	{
-		if(i2c_master_send(this_client, txData, length) < 0)
-			return -EIO;		
-	}		
-	return 0;	
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+#ifdef STK_ROCKCHIP_PLATFORM				
+			.scl_rate = scl_clk_rate,			
+#endif				
+		},
+	};
+	
+	for (retry = 0; retry <= 3; retry++) 
+	{
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0)
+			break;
+		else
+			mdelay(10);
+	}
+	
+	if(*txData >= 0x21 && *txData <= 0x3E)
+	{
+		for (retry = 0; retry <= 3; retry++) 
+		{
+			if (i2c_transfer(this_client->adapter, msg, 1) > 0)
+				break;
+			else
+				mdelay(10);
+		}		
+	}
+	
+	if (retry > 3) 
+	{
+		printk(KERN_ERR "%s: i2c error, retry over 3\n", __func__);
+		return -EIO;
+	}
+	else
+		return 0;	
 }
 
 
@@ -140,48 +476,20 @@ static int STK831X_SetVD(struct stk831x_data *stk)
 	int result;
 	char buffer[2] = "";
 	char reg24;
-	unsigned char retry;
-		
-	for(retry=0;retry<5;retry++)
+	
+	msleep(2);
+	result = STK831x_ReadByteOTP(0x70, &reg24);
+	if(result < 0)
 	{
-		buffer[0] = 0x3D;
-		buffer[1] = 0x70;
-		result = STK_i2c_Tx(buffer, 2);
-		if (result < 0) 
-		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
-		}	
-
-		buffer[0] = 0x3F;
-		buffer[1] = 0x02;
-		result = STK_i2c_Tx(buffer, 2);
-		if (result < 0) 
-		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
-		}	
-			
-		buffer[0] = 0x3E;
-		result = STK_i2c_Rx(buffer, 2);	
-		if (result < 0) 
-		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
-		}		
-		
-		if(buffer[1]>>7 == 0)
-			msleep(1);		
-		else
-			break;
+		printk(KERN_ERR "%s: read back error, result=%d\n", __func__, result);
+		return result;
 	}
-	reg24 = buffer[0];
 	
 	if(reg24 != 0)
 	{
 		buffer[0] = 0x24;
 		buffer[1] = reg24;
-		//printk(KERN_INFO "%s:write 0x%x to 0x24\n",  __func__, buffer[1]);
+		printk(KERN_INFO "%s:write 0x%x to 0x24\n",  __func__, buffer[1]);
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
@@ -191,7 +499,7 @@ static int STK831X_SetVD(struct stk831x_data *stk)
 	}	
 	else
 	{
-		//printk(KERN_INFO "%s: reg24=0, do nothing\n", __func__);
+		printk(KERN_INFO "%s: reg24=0, do nothing\n", __func__);
 		return 0;
 	}
 	
@@ -207,89 +515,439 @@ static int STK831X_SetVD(struct stk831x_data *stk)
 		printk(KERN_ERR "%s: error, reg24=0x%x, read=0x%x\n", __func__, reg24, buffer[0]);
 		return -1;
 	}
-	//printk(KERN_INFO "%s: successfully", __func__);
+	printk(KERN_INFO "%s: successfully", __func__);
 	return 0;
 }
 
+#ifdef STK_TUNE
+static void STK831x_ResetPara(void)
+{
+	int ii;
+	for(ii=0;ii<3;ii++)
+	{
+		stk_tune_sum[ii] = 0;
+		stk_tune_min[ii] = 4096;
+		stk_tune_max[ii] = -4096;
+	}
+	return;
+}
+
+static void STK831x_Tune(struct stk831x_data *stk, int acc[])
+{	
+	int ii;
+	char offset[3];		
+	char mode_reg;
+	int result;
+	char buffer[2] = "";
+	
+	if (stk_tune_done==0)
+	{	
+		if( event_since_en >= STK_TUNE_DELAY)
+		{	
+			if ((abs(acc[0]) <= STK_TUNE_XYOFFSET) && (abs(acc[1]) <= STK_TUNE_XYOFFSET)
+				&& (abs(abs(acc[2])-STK_LSB_1G) <= STK_TUNE_ZOFFSET))				
+				stk_tune_index++;
+			else
+				stk_tune_index = 0;
+
+			if (stk_tune_index==0)			
+				STK831x_ResetPara();			
+			else
+			{
+				for(ii=0;ii<3;ii++)
+				{
+					stk_tune_sum[ii] += acc[ii];
+					if(acc[ii] > stk_tune_max[ii])
+						stk_tune_max[ii] = acc[ii];
+					if(acc[ii] < stk_tune_min[ii])
+						stk_tune_min[ii] = acc[ii];						
+				}	
+			}			
+
+			if(stk_tune_index == STK_TUNE_NUM)
+			{
+				for(ii=0;ii<3;ii++)
+				{
+					if((stk_tune_max[ii] - stk_tune_min[ii]) > STK_TUNE_NOISE)
+					{
+						stk_tune_index = 0;
+						STK831x_ResetPara();
+						return;
+					}
+				}
+				buffer[0] = STK831X_MODE;
+				result = STK_i2c_Rx(buffer, 1);	
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);
+					return;
+				}
+				mode_reg = buffer[0];
+				buffer[1] = mode_reg & 0xF8;
+				buffer[0] = STK831X_MODE;	
+				result = STK_i2c_Tx(buffer, 2);
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+					return;
+				}				
+				
+				stk_tune_offset[0] = stk_tune_sum[0]/STK_TUNE_NUM;
+				stk_tune_offset[1] = stk_tune_sum[1]/STK_TUNE_NUM;
+				if (acc[2] > 0)
+					stk_tune_offset[2] = stk_tune_sum[2]/STK_TUNE_NUM - STK_LSB_1G;
+				else
+					stk_tune_offset[2] = stk_tune_sum[2]/STK_TUNE_NUM - (-STK_LSB_1G);				
+				
+				offset[0] = (char) (-stk_tune_offset[0]);
+				offset[1] = (char) (-stk_tune_offset[1]);
+				offset[2] = (char) (-stk_tune_offset[2]);
+				STK831x_SetOffset(offset);
+				stk_tune_offset_record[0] = offset[0];
+				stk_tune_offset_record[1] = offset[1];
+				stk_tune_offset_record[2] = offset[2];
+				
+				buffer[1] = mode_reg | 0x1;
+				buffer[0] = STK831X_MODE;	
+				result = STK_i2c_Tx(buffer, 2);
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+					return;
+				}
+				
+				STK831X_SetVD(stk);			
+				stk_store_in_file(offset, STK_K_SUCCESS_TUNE);		
+				stk_tune_done = 1;				
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_TUNE);				
+				event_since_en = 0;				
+				printk(KERN_INFO "%s:TUNE done, %d,%d,%d\n", __func__, 
+					offset[0], offset[1],offset[2]);		
+			}	
+		}		
+	}
+
+	return;
+}
+#endif
 
 #ifdef CONFIG_GRAVITY_STK8312
+static int STK831x_CheckReading(int acc[], bool clear)
+{	
+	static int check_result = 0;
+	
+	if(acc[0] == 127 || acc[0] == -128 || acc[1] == 127 || acc[1] == -128 || 
+			acc[2] == 127 || acc[2] == -128)
+	{
+		printk(KERN_INFO "%s: acc:%o,%o,%o\n", __func__, acc[0], acc[1], acc[2]);
+		check_result++;		
+	}	
+	if(clear)
+	{
+		if(check_result == 3)
+		{
+			event_since_en_limit = 10000;
+			printk(KERN_INFO "%s: incorrect reading\n", __func__);		
+			check_result = 0;
+			return 1;
+		}
+		check_result = 0;
+	}
+	return 0;		
+}
+
 static int STK831x_ReadSensorData(struct stk831x_data *stk)
 {	
 	int result;
 	char buffer[3] = "";
+	int acc_xyz[3] = {0};
+#ifdef STK_ZG_FILTER	
+	s16 zero_fir = 0;	
+#endif	
+#ifdef STK_LOWPASS
+	int idx, firlength = atomic_read(&stk->firlength);   
+#endif	
+	int k_status = atomic_read(&stk->cali_status);
 	memset(buffer, 0, 3);
 	
 	buffer[0] = STK831X_XOUT;
 	result = STK_i2c_Rx(buffer, 3);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:i2c transfer error", __func__);
+		printk(KERN_ERR "%s:i2c transfer error\n", __func__);
 		return result;
 	}	
-	mutex_lock(&stk->read_lock);
+
 	if (buffer[0] & 0x80)
-		stk->raw_data[0] = buffer[0] - 256;
+		acc_xyz[0] = buffer[0] - 256;
 	else
-		stk->raw_data[0] = buffer[0];
+		acc_xyz[0] = buffer[0];
 	if (buffer[1] & 0x80)
-		stk->raw_data[1] = buffer[1] - 256;
+		acc_xyz[1] = buffer[1] - 256;
 	else
-		stk->raw_data[1] = buffer[1];
+		acc_xyz[1] = buffer[1];
 	if (buffer[2] & 0x80)
-		stk->raw_data[2] = buffer[2] - 256;
+		acc_xyz[2] = buffer[2] - 256;
 	else
-		stk->raw_data[2] = buffer[2];
-	mutex_unlock(&stk->read_lock);
+		acc_xyz[2] = buffer[2];
+
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:RAW  %4d,%4d,%4d\n", __func__, acc_xyz[0],	acc_xyz[1], 
+			acc_xyz[2]);	
+#endif
+
+	if(event_since_en == 16 || event_since_en == 17)
+		STK831x_CheckReading(acc_xyz, false);
+	else if(event_since_en == 18)
+		STK831x_CheckReading(acc_xyz, true);
+	
+	if(k_status == STK_K_RUNNING)
+	{
+		stk->raw_data[0] = acc_xyz[0];
+		stk->raw_data[1] = acc_xyz[1];
+		stk->raw_data[2] = acc_xyz[2];	
+		return 0;
+	}		
+		
+	
+#ifdef STK_LOWPASS
+	if(atomic_read(&stk->fir_en))
+	{
+		if(stk->fir.num < firlength)
+		{                
+			stk->fir.raw[stk->fir.num][0] = acc_xyz[0];
+			stk->fir.raw[stk->fir.num][1] = acc_xyz[1];
+			stk->fir.raw[stk->fir.num][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.num++;
+			stk->fir.idx++;
+		}
+		else
+		{
+			idx = stk->fir.idx % firlength;
+			stk->fir.sum[0] -= stk->fir.raw[idx][0];
+			stk->fir.sum[1] -= stk->fir.raw[idx][1];
+			stk->fir.sum[2] -= stk->fir.raw[idx][2];
+			stk->fir.raw[idx][0] = acc_xyz[0];
+			stk->fir.raw[idx][1] = acc_xyz[1];
+			stk->fir.raw[idx][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.idx++;	
+			acc_xyz[0] = stk->fir.sum[0]/firlength;
+			acc_xyz[1] = stk->fir.sum[1]/firlength;
+			acc_xyz[2] = stk->fir.sum[2]/firlength;					
+		}
+	}
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:After FIR  %4d,%4d,%4d\n", __func__, acc_xyz[0], 
+		acc_xyz[1], acc_xyz[2]);	
+#endif
+
+#endif  	/* #ifdef STK_LOWPASS */
+		
+#ifdef STK_TUNE
+	if((k_status&0xF0) != 0)
+		STK831x_Tune(stk, acc_xyz);		
+#endif					
+
+#ifdef STK_ZG_FILTER
+	if( abs(acc_xyz[0]) <= STK_ZG_COUNT)	
+		acc_xyz[0] = (acc_xyz[0]*zero_fir);	
+	if( abs(acc_xyz[1]) <= STK_ZG_COUNT)
+		acc_xyz[1] = (acc_xyz[1]*zero_fir);
+	if( abs(acc_xyz[2]) <= STK_ZG_COUNT)
+		acc_xyz[2] = (acc_xyz[2]*zero_fir);
+#endif 	/* #ifdef STK_ZG_FILTER */	
+
+	stk->raw_data[0] = acc_xyz[0];
+	stk->raw_data[1] = acc_xyz[1];
+	stk->raw_data[2] = acc_xyz[2];
 	
 	return 0;	
 }
+
 #elif defined CONFIG_GRAVITY_STK8313
+static int STK831x_CheckReading(int acc[], bool clear)
+{
+	static int check_result = 0;
+	
+	if(acc[0] == 2047 || acc[0] == -2048 || acc[1] == 2047 || acc[1] == -2048 || 
+			acc[2] == 2047 || acc[2] == -2048)
+	{
+		printk(KERN_INFO "%s: acc:%o,%o,%o\n", __func__, acc[0], acc[1], acc[2]);
+		check_result++;		
+	}	
+	if(clear)
+	{
+		if(check_result == 3)
+		{
+			event_since_en_limit = 10000;
+			printk(KERN_INFO "%s: incorrect reading\n", __func__);		
+			check_result = 0;
+			return 1;
+		}
+		check_result = 0;
+	}
+	return 0;
+}
+
 static int STK831x_ReadSensorData(struct stk831x_data *stk)
 {	
 	int result;
 	char buffer[6] = "";
-	memset(buffer, 0, 6);
+	int acc_xyz[3] = {0};	
+#ifdef STK_ZG_FILTER	
+	s16 zero_fir = 0;	
+#endif	
+#ifdef STK_LOWPASS
+	int idx, firlength = atomic_read(&stk->firlength);   
+#endif	
+	int k_status = atomic_read(&stk->cali_status);
 	
+	memset(buffer, 0, 6);	
 	buffer[0] = STK831X_XOUT;
 	result = STK_i2c_Rx(buffer, 6);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:i2c transfer error", __func__);
+		printk(KERN_ERR "%s:i2c transfer error\n", __func__);
 		return result;
 	}			
-	mutex_lock(&stk->read_lock);		
+		
 	if (buffer[0] & 0x80)
-		stk->raw_data[0] = ((int)buffer[0]<<4) + (buffer[1]>>4) - 4096;
+		acc_xyz[0] = ((int)buffer[0]<<4) + (buffer[1]>>4) - 4096;
 	else
-		stk->raw_data[0] = ((int)buffer[0]<<4) + (buffer[1]>>4);
+		acc_xyz[0] = ((int)buffer[0]<<4) + (buffer[1]>>4);
 	if (buffer[2] & 0x80)
-		stk->raw_data[1] = ((int)buffer[2]<<4) + (buffer[3]>>4) - 4096;
+		acc_xyz[1] = ((int)buffer[2]<<4) + (buffer[3]>>4) - 4096;
 	else
-		stk->raw_data[1] = ((int)buffer[2]<<4) + (buffer[3]>>4);
+		acc_xyz[1] = ((int)buffer[2]<<4) + (buffer[3]>>4);
 	if (buffer[4] & 0x80)
-		stk->raw_data[2] = ((int)buffer[4]<<4) + (buffer[5]>>4) - 4096;
+		acc_xyz[2] = ((int)buffer[4]<<4) + (buffer[5]>>4) - 4096;
 	else
-		stk->raw_data[2] = ((int)buffer[4]<<4) + (buffer[5]>>4);
-	mutex_unlock(&stk->read_lock);
+		acc_xyz[2] = ((int)buffer[4]<<4) + (buffer[5]>>4);
+
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:RAW  %4d,%4d,%4d\n", __func__, acc_xyz[0], 
+		acc_xyz[1], acc_xyz[2]);	
+#endif
 	
+	if(event_since_en == 16 || event_since_en == 17)
+		STK831x_CheckReading(acc_xyz, false);
+	else if(event_since_en == 18)
+		STK831x_CheckReading(acc_xyz, true);
+	if(k_status == STK_K_RUNNING)
+	{
+		stk->raw_data[0] = acc_xyz[0];
+		stk->raw_data[1] = acc_xyz[1];
+		stk->raw_data[2] = acc_xyz[2];	
+		return 0;
+	}
+	
+	
+#ifdef STK_LOWPASS
+	if(atomic_read(&stk->fir_en))
+	{
+		if(stk->fir.num < firlength)
+		{                
+			stk->fir.raw[stk->fir.num][0] = acc_xyz[0];
+			stk->fir.raw[stk->fir.num][1] = acc_xyz[1];
+			stk->fir.raw[stk->fir.num][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.num++;
+			stk->fir.idx++;
+		}
+		else
+		{
+			idx = stk->fir.idx % firlength;
+			stk->fir.sum[0] -= stk->fir.raw[idx][0];
+			stk->fir.sum[1] -= stk->fir.raw[idx][1];
+			stk->fir.sum[2] -= stk->fir.raw[idx][2];
+			stk->fir.raw[idx][0] = acc_xyz[0];
+			stk->fir.raw[idx][1] = acc_xyz[1];
+			stk->fir.raw[idx][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.idx++;	
+			acc_xyz[0] = stk->fir.sum[0]/firlength;
+			acc_xyz[1] = stk->fir.sum[1]/firlength;
+			acc_xyz[2] = stk->fir.sum[2]/firlength;					
+		}
+	}
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:After FIR  %4d,%4d,%4d\n", __func__, acc_xyz[0], 
+		acc_xyz[1], acc_xyz[2]);	
+#endif
+	
+#endif  	/* #ifdef STK_LOWPASS */
+			
+		
+#ifdef STK_TUNE
+	if((k_status&0xF0) != 0)
+		STK831x_Tune(stk, acc_xyz);		
+#endif					
+
+#ifdef STK_ZG_FILTER
+	if( abs(acc_xyz[0]) <= STK_ZG_COUNT)	
+		acc_xyz[0] = (acc_xyz[0]*zero_fir);	
+	if( abs(acc_xyz[1]) <= STK_ZG_COUNT)
+		acc_xyz[1] = (acc_xyz[1]*zero_fir);
+	if( abs(acc_xyz[2]) <= STK_ZG_COUNT)
+		acc_xyz[2] = (acc_xyz[2]*zero_fir);
+#endif 	/* #ifdef STK_ZG_FILTER */	
+
+	stk->raw_data[0] = acc_xyz[0];
+	stk->raw_data[1] = acc_xyz[1];
+	stk->raw_data[2] = acc_xyz[2];
+
 	return 0;	
 }
 #endif
 
 static int STK831x_ReportValue(struct stk831x_data *stk)
-{
-	if(event_since_en < 12)
+{ 
+#ifdef STK_ALLWINNER_PLATFORM	
+	int tmp;
+#endif	
+	if(event_since_en < 1200)
+		event_since_en++;	
+	
+	if(event_since_en < event_since_en_limit)
+		return 0;		
+#ifdef STK_ALLWINNER_PLATFORM	
+	//gsensor_direct_x = 0;
+	if (gsensor_direct_x == 1)
+		stk->raw_data[0] = -stk->raw_data[0];
+
+	//gsensor_direct_y = 1;
+	if (gsensor_direct_y == 1)
+		stk->raw_data[1] = -stk->raw_data[1];
+
+	gsensor_direct_z = 1;
+	if (gsensor_direct_z == 1)
+		stk->raw_data[2] = -stk->raw_data[2];
+
+	if (gsensor_xy_revert == 1)
 	{
-		event_since_en++;
-		return 0;
+		tmp = stk->raw_data[0];
+		stk->raw_data[0] = stk->raw_data[1];
+		stk->raw_data[1] = tmp;
 	}
-	
-	mutex_lock(&stk->read_lock);
-	//printk(KERN_INFO "%s:%4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif /* #ifdef STK_ALLWINNER_PLATFORM */
+		
+#ifdef STK_DEBUG_PRINT	
+	printk(KERN_INFO "%s:%4d,%4d,%4d\n", __func__, stk->raw_data[0], 
+		stk->raw_data[1], stk->raw_data[2]);	
+#endif	
 	input_report_abs(stk->input_dev, ABS_X, stk->raw_data[0]);  
 	input_report_abs(stk->input_dev, ABS_Y, stk->raw_data[1]);
 	input_report_abs(stk->input_dev, ABS_Z, stk->raw_data[2]);
-	mutex_unlock(&stk->read_lock);
 	input_sync(stk->input_dev);
 	return 0;
 }
@@ -306,7 +964,7 @@ static int STK831x_SetOffset(char buf[])
 	result = STK_i2c_Tx(buffer, 4);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
+		printk(KERN_ERR "%s:failed\n", __func__);
 		return result;
 	}	
 	return 0;
@@ -335,97 +993,81 @@ static int STK831x_SetEnable(struct stk831x_data *stk, char en)
 	int result;
 	char buffer[2] = "";
 	int new_enabled = (en)?1:0; 
-	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
-	char offset[3];	
-	if(stk->first_enable)
-	{
-		stk->first_enable = false;		
-		if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
-		{
-			if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
-			{
-				offset[0] = r_buf[2];
-				offset[1] = r_buf[3];
-				offset[2] = r_buf[4];
-				cali_offset[0] = offset[0];
-				cali_offset[1] = offset[1];
-				cali_offset[2] = offset[2];
-				STK831x_SetOffset(offset);
-				printk(KERN_INFO "%s: set offset:%d,%d,%d\n", __func__, offset[0], offset[1], offset[2]);
-			}
-			else
-			{
-				printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x\n", 
-					__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3]);						
-				return -EINVAL;
-			}
-		}
-		else
-		{
-			offset[0] = offset[1] = offset[2] = 0;
-			stk_store_in_file(offset);
-		}
-	}
+	int k_status = atomic_read(&stk->cali_status);
 	
 	if(new_enabled == atomic_read(&stk->enabled))
 		return 0;
 	printk(KERN_INFO "%s:%x\n", __func__, en);
 
-
-	if(en)
-	{
-#if STK_ACC_POLLING_MODE
-		atomic_set(&stk->run_thread, 1);
-		if(acc_polling_tsk == NULL)
-			acc_polling_tsk = kthread_run(stk_acc_polling_function, stk, "stk_acc_polling");		
-#else
-		enable_irq((unsigned int)stk->irq);	
-#endif	//#if STK_ACC_POLLING_MODE	
-	}
-	else
-	{
-#if STK_ACC_POLLING_MODE
-		atomic_set(&stk->run_thread, 0);
-		wait_for_completion(&acc_thread_completion);
-		acc_polling_tsk = NULL;
-#else
-		disable_irq((unsigned int)stk->irq);	
-#endif	//#if STK_ACC_POLLING_MODE
-	}
+	if(stk->first_enable && k_status != STK_K_RUNNING)			
+		stk_handle_first_en(stk);
 	
+       mutex_lock(&stk->write_lock);
 	buffer[0] = STK831X_MODE;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto e_err_i2c;
 	}			
 	if(en)
 	{
 		buffer[1] = (buffer[0] & 0xF8) | 0x01;
 		event_since_en = 0;
+#ifdef STK_TUNE		
+		if((k_status&0xF0) != 0 && stk_tune_done == 0)
+		{
+			stk_tune_index = 0;
+			STK831x_ResetPara();
+		}
+#endif		
 	}
 	else
 		buffer[1] = (buffer[0] & 0xF8);
+		
 	buffer[0] = STK831X_MODE;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
-		return result;
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto e_err_i2c;
 	}
+      mutex_unlock(&stk->write_lock);
+	
+	if(stk->first_enable && k_status != STK_K_RUNNING)
+	{
+		stk->first_enable = false;	
+		msleep(2);
+		result = stk_get_ic_content(stk);			
+	}	
 	if(en)
 	{
-		msleep(1);
-		STK831X_SetVD(stk);
-	}
+		STK831X_SetVD(stk);		
+#if STK_ACC_POLLING_MODE
+		hrtimer_start(&stk->acc_timer, stk->acc_poll_delay, HRTIMER_MODE_REL);			
+#else
+		enable_irq((unsigned int)stk->irq);	
+#endif	//#if STK_ACC_POLLING_MODE	
+	}			
+	else
+	{
+#if STK_ACC_POLLING_MODE
+		hrtimer_cancel(&stk->acc_timer);
+		cancel_work_sync(&stk->stk_acc_work);
+#else
+		disable_irq((unsigned int)stk->irq);	
+#endif	//#if STK_ACC_POLLING_MODE
+	}	
 	atomic_set(&stk->enabled, new_enabled);
 	return 0;
+	
+e_err_i2c:
+       mutex_unlock(&stk->write_lock);
+	return result;
 }
 
 static int STK831x_GetEnable(struct stk831x_data *stk, char* gState)
 {
-
 	*gState = atomic_read(&stk->enabled);
 	return 0;
 }
@@ -436,40 +1078,84 @@ static int STK831x_SetDelay(struct stk831x_data *stk, uint32_t sdelay_ns)
 	int result;
 	char buffer[2] = "";
 	uint32_t sdelay_us = sdelay_ns / 1000;
-	
-	printk(KERN_INFO "%s:sdelay_us=%d\n", __func__, sdelay_us);
-	for(sr_no=5;sr_no>0;sr_no--)
+
+	for(sr_no=(STK831X_SAMPLE_TIME_NO-1);sr_no>0;sr_no--)
 	{
 		if(sdelay_us >= STK831X_SAMPLE_TIME[sr_no])	
 			break;		
 	}	
+	if(sr_no < STK831X_SAMPLE_TIME_MIN_NO)
+		sr_no = STK831X_SAMPLE_TIME_MIN_NO;
+	
+#ifdef STK831X_HOLD_ODR
+	sr_no = STK831X_INIT_ODR;
+#endif	
+	
+#ifdef STK_DEBUG_PRINT		
+#ifdef STK831X_HOLD_ODR
+	printk(KERN_INFO "%s:sdelay_us=%d, Hold delay = %d\n", __func__, sdelay_us, STK831X_SAMPLE_TIME[STK831X_INIT_ODR]);
+#else
+	printk(KERN_INFO "%s:sdelay_us=%d\n", __func__, sdelay_us);
+#endif	
+#endif	
+	mutex_lock(&stk->write_lock);
 	if(stk->delay == sr_no)
+	{
+		mutex_unlock(&stk->write_lock);	
 		return 0;
-
+	}
 	buffer[0] = STK831X_SR;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto d_err_i2c;
 	}			
 	
-	buffer[1] = (buffer[0] & 0xF8) | (sr_no & 0x07);
+	buffer[1] = (buffer[0] & 0xF8) | ((sr_no & 0x07));
 	buffer[0] = STK831X_SR;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
-		return result;
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto d_err_i2c;
 	}	
 	stk->delay = sr_no;
+#if STK_ACC_POLLING_MODE	
+	stk->acc_poll_delay = ns_to_ktime(STK831X_SAMPLE_TIME[sr_no]*USEC_PER_MSEC);	
+#endif
 	
-	return 0;	
+#if defined(STK_LOWPASS)
+	stk->fir.num = 0;
+	stk->fir.idx = 0;
+	stk->fir.sum[0] = 0;
+	stk->fir.sum[1] = 0;
+	stk->fir.sum[2] = 0;
+#endif		
+	mutex_unlock(&stk->write_lock);	
+	
+	return 0;
+d_err_i2c:
+	mutex_unlock(&stk->write_lock);	
+	return result;
 }
 
-static int STK831x_GetDelay(struct stk831x_data *stk, uint32_t* gdelay_ns)
+static int STK831x_GetDelay(struct stk831x_data *stk, uint32_t *gdelay_ns)
 {
-	*gdelay_ns = (uint32_t) STK831X_SAMPLE_TIME[stk->delay] * 1000;
+	int result;
+	char buffer[2] = "";
+	
+	mutex_lock(&stk->write_lock);
+	buffer[0] = STK831X_SR;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		mutex_unlock(&stk->write_lock);	
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}	
+	mutex_unlock(&stk->write_lock);	
+	*gdelay_ns = (uint32_t) STK831X_SAMPLE_TIME[(int)buffer[0]] * 1000;
 	return 0;	
 }
 
@@ -478,7 +1164,16 @@ static int STK831x_SetRange(char srange)
 {
 	int result;
 	char buffer[2] = "";
+#ifdef STK_DEBUG_PRINT	
 	printk(KERN_INFO "%s:range=0x%x\n", __func__, srange);
+#endif	
+	
+	if(srange >= 3)
+	{
+		printk(KERN_ERR "%s:parameter out of range\n", __func__);
+		return -1;
+	}
+	
 	buffer[0] = STK831X_STH;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
@@ -487,21 +1182,15 @@ static int STK831x_SetRange(char srange)
 		return result;
 	}	
 	
-	if(srange >= 3)
-	{
-		printk(KERN_ERR "%s:parameter out of range\n", __func__);
-		return -1;
-	}
-	
 	buffer[1] = (buffer[0] & 0x3F) | srange<<6;
 	buffer[0] = STK831X_STH;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
+		printk(KERN_ERR "%s:failed\n", __func__);
 		return result;
 	}	
-	return 0;	
+	return 0;		
 }
 
 static int STK831x_GetRange(char* grange)
@@ -520,124 +1209,6 @@ static int STK831x_GetRange(char* grange)
 	return 0;
 }
 
-#ifdef STK_DEBUG_CALI		
-static int STK831x_ReadOTP(char addr)
-{
-	int result, redo, i;
-	char buffer[2] = "";
-	char regR[20] = "";
-	char piAddr;
-	for( i=0; i<3; i++)
-	{
-		redo = 0;
-
-		do {
-
-			redo++;
-
-			buffer[0] = 0x3D;
-			buffer[1] = addr+i;
-			result = STK_i2c_Tx(buffer, 2);
-			if (result < 0) 
-			{
-				printk(KERN_ERR "%s:failed\n", __func__);
-				return result;
-			}
-			
-			buffer[0] = 0x3F;
-			buffer[1] = 0x02;
-			result = STK_i2c_Tx(buffer, 2);
-			if (result < 0) 
-			{
-				printk(KERN_ERR "%s:failed\n", __func__);
-				return result;
-			}
-			
-			for(piAddr=0x3D; piAddr<0x40; piAddr++)
-			{		
-				buffer[0] = piAddr;
-				result = STK_i2c_Rx(buffer, 1);	
-				if (result < 0) 
-				{
-					printk(KERN_ERR "%s:failed\n", __func__);
-					return result;
-				}
-				else
-				{
-					regR[piAddr-0x3D+i*3] = buffer[0];
-					
-				}
-			}
-		}
-		while((regR[2+i*3]>>7) != 1 && redo < 10);
-
-		if((regR[2+i*3]>>7) == 0 && redo == 10)
-		{
-			printk(KERN_ERR "%s:OTP repeat read 3 times! Failed!\n", __func__);
-			return -1;
-		}
-	}
-	printk(KERN_INFO "%s: OTP x%x=0x%x\n", __func__, addr, regR[1+0]);
-	printk(KERN_INFO "%s: OTP x%x=0x%x\n", __func__, addr+1, regR[1+3]);
-	printk(KERN_INFO "%s: OTP x%x=0x%x\n", __func__, addr+2, regR[1+6]);
-	
-	return 0;
-}
-
-static int STK831x_ReadAllOTP( void )
-{
-	int result, i;
-	char buffer[2] = "";
-	char mode; 
-	
-	buffer[0] = STK831X_MODE;
-	result = STK_i2c_Rx(buffer, 1);	
-	if (result < 0) 
-	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
-	}
-	mode = buffer[0];
-	buffer[1] = (mode | 0x01);
-	buffer[0] = STK831X_MODE;	
-	result = STK_i2c_Tx(buffer, 2);
-	if (result < 0) 
-	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
-	}
-	msleep(1);
-	
-	for(i=0;i<3;i++)
-	{
-		buffer[0] = 0x2A+i*4;
-		result = STK_i2c_Rx(buffer, 1);	
-		if (result < 0) 
-		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
-		}
-		printk(KERN_INFO "%s: REG 0x%x=0x%x\n", __func__, 0x2A+i*4, buffer[0]);
-		buffer[0] = 0x2B+i*4;
-		result = STK_i2c_Rx(buffer, 1);	
-		if (result < 0) 
-		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
-		}
-		printk(KERN_INFO "%s: REG 0x%x=0x%x\n", __func__, 0x2B+i*4, buffer[0]);
-	}
-	STK831x_ReadOTP(0x30);
-	STK831x_ReadOTP(0x40);
-	STK831x_ReadOTP(0x43);
-	STK831x_ReadOTP(0x46);
-	STK831x_ReadOTP(0x50);
-	STK831x_ReadOTP(0x53);
-	STK831x_ReadOTP(0x56);
-	return 0;
-}
-#endif
-
 static int STK831x_ReadByteOTP(char rReg, char *value)
 {
 	int redo = 0;
@@ -651,7 +1222,7 @@ static int STK831x_ReadByteOTP(char rReg, char *value)
 	if (result < 0) 
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto eng_i2c_r_err;
 	}
 	buffer[0] = 0x3F;
 	buffer[1] = 0x02;
@@ -659,159 +1230,172 @@ static int STK831x_ReadByteOTP(char rReg, char *value)
 	if (result < 0) 
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto eng_i2c_r_err;
 	}
 	
-	msleep(1);	
 	do {
+		msleep(2);
 		buffer[0] = 0x3F;
 		result = STK_i2c_Rx(buffer, 1);	
 		if (result < 0) 
 		{
 			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
+			goto eng_i2c_r_err;
 		}
 		if(buffer[0]& 0x80)
 		{
 			break;
 		}		
-		msleep(1);
 		redo++;
-	}while(redo < 5);
-		
-	if(redo == 5)
+	}while(redo < 10);
+	
+	if(redo == 10)
 	{
-		printk(KERN_ERR "%s:OTP read repeat read 5 times! Failed!\n", __func__);
-		return -1;
+		printk(KERN_ERR "%s:OTP read repeat read 10 times! Failed!\n", __func__);
+		return -STK_K_FAIL_OTP_5T;
 	}	
 	buffer[0] = 0x3E;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto eng_i2c_r_err;
 	}	
 	*value = buffer[0];
 #ifdef STK_DEBUG_CALI		
-	printk(KERN_INFO "%s: read 0x%x=0x%x", __func__, rReg, *value);
+	printk(KERN_INFO "%s: read 0x%x=0x%x\n", __func__, rReg, *value);
 #endif	
 	return 0;
+	
+eng_i2c_r_err:	
+	return -STK_K_FAIL_ENG_I2C;	
 }
 
 static int STK831x_WriteByteOTP(char wReg, char value)
 {
-	int redo = 0;
+	int finish_w_check = 0;
 	int result;
 	char buffer[2] = "";
-	char read_back;
+	char read_back, value_xor = value;
+	int re_write = 0;
 	
-	redo = 0;
-	do {
-		redo++;
-		
+	do
+	{
+		finish_w_check = 0;
 		buffer[0] = 0x3D;
 		buffer[1] = wReg;
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);
+			goto eng_i2c_w_err;
 		}
 		buffer[0] = 0x3E;
-		buffer[1] = value;
+		buffer[1] = value_xor;
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);
+			goto eng_i2c_w_err;
 		}				
 		buffer[0] = 0x3F;
 		buffer[1] = 0x01;
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);			
+			goto eng_i2c_w_err;
 		}				
-		msleep(1);
 		
-		buffer[0] = 0x3F;
-		result = STK_i2c_Rx(buffer, 1);	
-		if (result < 0) 
-		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
-		}
-		if(buffer[0]& 0x80)
+		do 
 		{
-			result = STK831x_ReadByteOTP(wReg, &read_back);
-			if(result < 0)
+			msleep(1);
+			buffer[0] = 0x3F;
+			result = STK_i2c_Rx(buffer, 1);	
+			if (result < 0) 
 			{
-				printk(KERN_ERR "%s: read back error, result=%d", __func__, result);
-				return result;
+				printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);			
+				goto eng_i2c_w_err;
 			}
-			
-			if(read_back == value)
+			if(buffer[0]& 0x80)
 			{
+				result = STK831x_ReadByteOTP(wReg, &read_back);
+				if(result < 0)
+				{
+					printk(KERN_ERR "%s: read back error, result=%d\n", __func__, result);
+					goto eng_i2c_w_err;
+				}
+				
+				if(read_back == value)				
+				{
 #ifdef STK_DEBUG_CALI					
-				printk(KERN_INFO "%s: write 0x%x=0x%x successfully\n", __func__, wReg, value);
-#endif				
-				break;
+					printk(KERN_INFO "%s: write 0x%x=0x%x successfully\n", __func__, wReg, value);
+#endif			
+					re_write = 0xFF;
+					break;
+				}
+				else
+				{
+					printk(KERN_ERR "%s: write 0x%x=0x%x, read 0x%x=0x%x, try again\n", __func__, wReg, value_xor, wReg, read_back);
+					value_xor = read_back ^ value;
+					re_write++;
+					break;
+				}
 			}
-			else
-				printk(KERN_ERR "%s: read back mismatch, write 0x%x=0x%x, read 0x%x=0x%x, try again\n", __func__, wReg, value, wReg, read_back);
-		}
-		msleep(1);
-	}while(redo < 5);
+			finish_w_check++;		
+		} while (finish_w_check < 5);
+	} while(re_write < 10);
 	
-	if(redo == 5)
+	if(re_write == 10)
 	{
-		printk(KERN_ERR "%s:OTP write 0x%x repeat read 5 times! Failed!\n", __func__, wReg);
-		return -1;
-	}		
+		printk(KERN_ERR "%s: write 0x%x fail, read=0x%x, write=0x%x, target=0x%x\n", __func__, wReg, read_back, value_xor, value);
+		return -STK_K_FAIL_OTP_5T;
+	}	
+	
 	return 0;
+
+eng_i2c_w_err:	
+	return -STK_K_FAIL_ENG_I2C;
 }
 
 static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetData[])
 {
-	char regR[6];
+	char regR[6], reg_comp[3];
 	char mode; 
 	int result;
 	char buffer[2] = "";
+	int ft_pre_trim = 0;
 	
-//Check FT1
 	if(FT==1)
 	{
 		result = STK831x_ReadByteOTP(0x7F, &regR[0]);
 		if(result < 0)
-			return -1;
+			goto eng_i2c_err;
 		
 		if(regR[0]&0x10)
 		{
 			printk(KERN_ERR "%s: 0x7F=0x%x\n", __func__, regR[0]);
-			return -2;
+			return -STK_K_FAIL_FT1_USD;
 		}
 	}
 	else if (FT == 2)
 	{
 		result = STK831x_ReadByteOTP(0x7F, &regR[0]);
 		if(result < 0)
-		return -1;
-		
+			goto eng_i2c_err;
+			
 		if(regR[0]&0x20)
 		{
 			printk(KERN_ERR "%s: 0x7F=0x%x\n", __func__, regR[0]);
-			return -2;
+			return -STK_K_FAIL_FT2_USD;
 		}		
 	}
-//Check End
 	
 	buffer[0] = STK831X_MODE;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	mode = buffer[0];
 	buffer[1] = (mode | 0x01);
@@ -819,44 +1403,78 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
-	msleep(1);
-	
-	result = STK831x_ReadByteOTP(0x30, &regR[0]);
-	if(result < 0)
-		return -1;
-	result = STK831x_ReadByteOTP(0x31, &regR[1]);
-	if(result < 0)
-		return -1;
-	result = STK831x_ReadByteOTP(0x32, &regR[2]);
-	if(result < 0)
-		return -1;
-	
+	msleep(2);
+
+
 	if(FT == 1)
 	{
-		result = STK831x_WriteByteOTP(0x40, regR[0]);
+		result = STK831x_ReadByteOTP(0x40, &reg_comp[0]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x41, regR[1]);
+			goto eng_i2c_err;
+		result = STK831x_ReadByteOTP(0x41, &reg_comp[1]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x42, regR[2]);
+			goto eng_i2c_err;
+		result = STK831x_ReadByteOTP(0x42, &reg_comp[2]);
 		if(result < 0)
-			return -1;	
+			goto eng_i2c_err;	
 	}
 	else if (FT == 2)
 	{
-		result = STK831x_WriteByteOTP(0x50, regR[0]);
+		result = STK831x_ReadByteOTP(0x50, &reg_comp[0]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x51, regR[1]);
+			goto eng_i2c_err;
+		result = STK831x_ReadByteOTP(0x51, &reg_comp[1]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x52, regR[2]);
+			goto eng_i2c_err;
+		result = STK831x_ReadByteOTP(0x52, &reg_comp[2]);
 		if(result < 0)
-			return -1;			
+			goto eng_i2c_err;					
+	}
+
+	result = STK831x_ReadByteOTP(0x30, &regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+	result = STK831x_ReadByteOTP(0x31, &regR[1]);
+	if(result < 0)
+		goto eng_i2c_err;
+	result = STK831x_ReadByteOTP(0x32, &regR[2]);
+	if(result < 0)
+		goto eng_i2c_err;
+		
+	if(reg_comp[0] == regR[0] && reg_comp[1] == regR[1] && reg_comp[2] == regR[2])
+	{
+		printk(KERN_INFO "%s: ft pre-trimmed\n", __func__);
+		ft_pre_trim = 1;
+	}
+	
+	if(!ft_pre_trim)
+	{
+		if(FT == 1)
+		{		
+			result = STK831x_WriteByteOTP(0x40, regR[0]);
+			if(result < 0)
+				goto eng_i2c_err;
+			result = STK831x_WriteByteOTP(0x41, regR[1]);
+			if(result < 0)
+				goto eng_i2c_err;		
+			result = STK831x_WriteByteOTP(0x42, regR[2]);
+			if(result < 0)
+				goto eng_i2c_err;		
+		}
+		else if (FT == 2)
+		{
+			result = STK831x_WriteByteOTP(0x50, regR[0]);
+			if(result < 0)
+				goto eng_i2c_err;
+			result = STK831x_WriteByteOTP(0x51, regR[1]);
+			if(result < 0)
+				goto eng_i2c_err;		
+			result = STK831x_WriteByteOTP(0x52, regR[2]);
+			if(result < 0)
+				goto eng_i2c_err;		
+		}
 	}
 #ifdef STK_DEBUG_CALI
 	printk(KERN_INFO "%s:OTP step1 Success!\n", __func__);
@@ -865,8 +1483,7 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	else
 	{
@@ -876,8 +1493,7 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	else
 	{
@@ -887,8 +1503,7 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	else
 	{
@@ -898,8 +1513,7 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	else
 	{
@@ -909,8 +1523,7 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	else
 	{
@@ -920,8 +1533,7 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto common_i2c_error;
 	}
 	else
 	{
@@ -933,52 +1545,60 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 	regR[5] = offsetData[1];
 	if(FT==1)
 	{
-		result = STK831x_WriteByteOTP(0x43, regR[0]);
-		if(result < 0)
-			return -1;	
 		result = STK831x_WriteByteOTP(0x44, regR[1]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x45, regR[2]);
-		if(result < 0)
-			return -1;	
+			goto eng_i2c_err;		
 		result = STK831x_WriteByteOTP(0x46, regR[3]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x47, regR[4]);
-		if(result < 0)
-			return -1;	
+			goto eng_i2c_err;				
 		result = STK831x_WriteByteOTP(0x48, regR[5]);
 		if(result < 0)
-			return -1;			
+			goto eng_i2c_err;				
+		
+		if(!ft_pre_trim)
+		{
+			result = STK831x_WriteByteOTP(0x43, regR[0]);
+			if(result < 0)
+				goto eng_i2c_err;		
+			result = STK831x_WriteByteOTP(0x45, regR[2]);
+			if(result < 0)
+				goto eng_i2c_err;				
+			result = STK831x_WriteByteOTP(0x47, regR[4]);
+			if(result < 0)
+				goto eng_i2c_err;				
+		}
 	}
 	else if (FT == 2)
 	{
-		result = STK831x_WriteByteOTP(0x53, regR[0]);
-		if(result < 0)
-			return -1;	
 		result = STK831x_WriteByteOTP(0x54, regR[1]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x55, regR[2]);
-		if(result < 0)
-			return -1;	
+			goto eng_i2c_err;
 		result = STK831x_WriteByteOTP(0x56, regR[3]);
 		if(result < 0)
-			return -1;	
-		result = STK831x_WriteByteOTP(0x57, regR[4]);
-		if(result < 0)
-			return -1;	
+			goto eng_i2c_err;				
 		result = STK831x_WriteByteOTP(0x58, regR[5]);
 		if(result < 0)
-			return -1;			
+			goto eng_i2c_err;				
+
+		if(!ft_pre_trim)
+		{		
+			result = STK831x_WriteByteOTP(0x53, regR[0]);
+			if(result < 0)
+				goto eng_i2c_err;								
+			result = STK831x_WriteByteOTP(0x55, regR[2]);
+			if(result < 0)
+				goto eng_i2c_err;				
+			result = STK831x_WriteByteOTP(0x57, regR[4]);
+			if(result < 0)
+				goto eng_i2c_err;				
+		}
 	}
 #ifdef STK_DEBUG_CALI	
 	printk(KERN_INFO "%s:OTP step2 Success!\n", __func__);
 #endif
 	result = STK831x_ReadByteOTP(0x7F, &regR[0]);
 	if(result < 0)
-		return -1;	
+		goto eng_i2c_err;
 	
 	if(FT==1)
 		regR[0] = regR[0]|0x10;
@@ -987,18 +1607,31 @@ static int STK831x_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetD
 
 	result = STK831x_WriteByteOTP(0x7F, regR[0]);
 	if(result < 0)
-		return -1;	
+		goto eng_i2c_err;
 #ifdef STK_DEBUG_CALI	
 	printk(KERN_INFO "%s:OTP step3 Success!\n", __func__);
 #endif	
 	return 0;
+	
+eng_i2c_err:
+	printk(KERN_ERR "%s: read/write eng i2c error, result=0x%x\n", __func__, result);	
+	return result;
+	
+common_i2c_error:
+	printk(KERN_ERR "%s: read/write common i2c error, result=0x%x\n", __func__, result);
+	return result;	
 }
 
-static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis)
+static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis, uint32_t delay_ms)
 {
 	unsigned char axis, state;	
 	int acc_ave[3] = {0, 0, 0};
-	const unsigned char verify_sample_no = 2, verify_diff = 2;	
+	const unsigned char verify_sample_no = 3;		
+#ifdef CONFIG_GRAVITY_STK8313
+	const unsigned char verify_diff = 25;	
+#elif defined CONFIG_GRAVITY_STK8312
+	const unsigned char verify_diff = 2;		
+#endif		
 	int result;
 	char buffer[2] = "";
 	int ret = 0;
@@ -1010,33 +1643,30 @@ static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis)
 		result = STK_i2c_Rx(buffer, 1);	
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);
+			return -STK_K_FAIL_I2C;
 		}			
 		buffer[1] = (buffer[0] & 0xF8) | 0x01;
 		buffer[0] = STK831X_MODE;	
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
 		}
-		msleep(1);
 		STK831X_SetVD(stk);			
-		msleep(150);	
+		msleep(delay_ms*15);	
 	}
 	
 	for(state=0;state<verify_sample_no;state++)
 	{
 		STK831x_ReadSensorData(stk);
-		mutex_lock(&stk->read_lock);
 		for(axis=0;axis<3;axis++)			
 			acc_ave[axis] += stk->raw_data[axis];	
 #ifdef STK_DEBUG_CALI				
 		printk(KERN_INFO "%s: acc=%d,%d,%d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
 #endif
-		mutex_unlock(&stk->read_lock);
-		msleep(10);		
+		msleep(delay_ms);		
 	}		
 	
 	for(axis=0;axis<3;axis++)
@@ -1063,15 +1693,15 @@ static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis)
 		acc_ave[2] += STK_LSB_1G;
 		break;
 	default:
-		printk("%s: invalid stk831x_placement=%d", __func__, stk831x_placement);
-		ret = -1;
+		printk("%s: invalid stk831x_placement=%d\n", __func__, stk831x_placement);
+		ret = -STK_K_FAIL_PLACEMENT;
 		break;
 	}	
 	if(abs(acc_ave[0]) > verify_diff || abs(acc_ave[1]) > verify_diff || abs(acc_ave[2]) > verify_diff)
 	{
 		printk(KERN_INFO "%s:Check data x:%d, y:%d, z:%d\n", __func__,acc_ave[0],acc_ave[1],acc_ave[2]);		
 		printk(KERN_ERR "%s:Check Fail, Calibration Fail\n", __func__);
-		ret = -2;
+		ret = -STK_K_FAIL_LRG_DIFF;
 	}	
 #ifdef STK_DEBUG_CALI
 	else
@@ -1083,16 +1713,16 @@ static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis)
 		result = STK_i2c_Rx(buffer, 1);	
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed\n", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
 		}			
 		buffer[1] = (buffer[0] & 0xF8);
 		buffer[0] = STK831X_MODE;	
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed", __func__);
-			return result;
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
 		}		
 	}	
 	
@@ -1104,48 +1734,54 @@ static int STK831x_SetCali(struct stk831x_data *stk, char sstate)
 {
 	char org_enable;
 	int acc_ave[3] = {0, 0, 0};
-	int state, axis, i;
-	char new_offset[3],  otp_offset[3] = {0};
+	int state, axis;
+	int new_offset[3];
+	char char_offset[3] = {0};
 	int result;
 	char buffer[2] = "";
 	char reg_offset[3] = {0};
 	char store_location = sstate;
-
+	uint32_t gdelay_ns, real_delay_ms;
+	char offset[3];	
+	
+	atomic_set(&stk->cali_status, STK_K_RUNNING);	
 	//sstate=1, STORE_OFFSET_IN_FILE
 	//sstate=2, STORE_OFFSET_IN_IC		
 #ifdef STK_DEBUG_CALI		
-	printk(KERN_INFO "%s:store_location=%d, stk831x_placement=%d\n", __func__, store_location, stk831x_placement);
+	printk(KERN_INFO "%s:store_location=%d\n", __func__, store_location);
 #endif	
 	if((store_location != 3 && store_location != 2 && store_location != 1) || (stk831x_placement < 0 || stk831x_placement > 5) )
 	{
-		printk(KERN_ERR "%s, erro invalid parameters\n", __func__);
-		return -EINVAL;
+		printk(KERN_ERR "%s, invalid parameters\n", __func__);
+		atomic_set(&stk->cali_status, STK_K_FAIL_K_PARA);	
+		return -STK_K_FAIL_K_PARA;
 	}	
-	
+	STK831x_GetDelay(stk, &gdelay_ns);
 	STK831x_GetEnable(stk, &org_enable);
 	if(org_enable)
 		STK831x_SetEnable(stk, 0);
 	STK831x_SetDelay(stk, 10000000);
-	STK831x_SetRange(1);				
+	msleep(1);
+	STK831x_GetDelay(stk, &real_delay_ms);
+	real_delay_ms = (real_delay_ms + (NSEC_PER_MSEC / 2)) / NSEC_PER_MSEC;
+	printk(KERN_INFO "%s: delay =%d ms\n", __func__, real_delay_ms);
+	
 	STK831x_SetOffset(reg_offset);
 	buffer[0] = STK831X_MODE;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto err_i2c_rw;
 	}			
 	buffer[1] = (buffer[0] & 0xF8) | 0x01;
 	buffer[0] = STK831X_MODE;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
-		return result;
+		goto err_i2c_rw;
 	}
-	msleep(1);
-	STK831X_SetVD(stk);
 
+	STK831X_SetVD(stk);
 	if(store_location >= 2)
 	{
 		buffer[0] = 0x2B;	
@@ -1153,64 +1789,65 @@ static int STK831x_SetCali(struct stk831x_data *stk, char sstate)
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed", __func__);
-			return result;
+			goto err_i2c_rw;
 		}
 		buffer[0] = 0x2F;	
 		buffer[1] = 0x0;
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed", __func__);
-			return result;
+			goto err_i2c_rw;
 		}
 		buffer[0] = 0x33;	
 		buffer[1] = 0x0;
 		result = STK_i2c_Tx(buffer, 2);
 		if (result < 0) 
 		{
-			printk(KERN_ERR "%s:failed", __func__);
-			return result;
+			goto err_i2c_rw;
 		}
-	}		
-	
-	msleep(150);				
+	}	
+				
+	msleep(real_delay_ms*20);				
 	for(state=0;state<STK_SAMPLE_NO;state++)
 	{
 		STK831x_ReadSensorData(stk);
-		mutex_lock(&stk->read_lock);
 		for(axis=0;axis<3;axis++)			
 			acc_ave[axis] += stk->raw_data[axis];	
 #ifdef STK_DEBUG_CALI				
 		printk(KERN_INFO "%s: acc=%d,%d,%d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
 #endif		
-		mutex_unlock(&stk->read_lock);
-		msleep(10);		
+		msleep(real_delay_ms);		
 	}		
 	buffer[0] = STK831X_MODE;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto err_i2c_rw;
 	}			
 	buffer[1] = (buffer[0] & 0xF8);
 	buffer[0] = STK831X_MODE;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
-		return result;
+		goto err_i2c_rw;
 	}	
 	
 	for(axis=0;axis<3;axis++)
-		acc_ave[axis] /= STK_SAMPLE_NO;
+	{
+		if(acc_ave[axis] >= 0)
+			acc_ave[axis] = (acc_ave[axis] + STK_SAMPLE_NO / 2) / STK_SAMPLE_NO;
+		else
+			acc_ave[axis] = (acc_ave[axis] - STK_SAMPLE_NO / 2) / STK_SAMPLE_NO;
 	
-	if(acc_ave[2]<=0)
+	}
+	if(acc_ave[2] <= -1)
 		stk831x_placement = NEGATIVE_Z_UP;
-	else
+	else if((acc_ave[2] >= 1))
 		stk831x_placement = POSITIVE_Z_UP;
-
+#ifdef STK_DEBUG_CALI		
+	printk(KERN_INFO "%s:stk831x_placement=%d\n", __func__, stk831x_placement);
+#endif	
+	
 	switch(stk831x_placement)
 	{
 	case POSITIVE_X_UP:
@@ -1232,87 +1869,197 @@ static int STK831x_SetCali(struct stk831x_data *stk, char sstate)
 		acc_ave[2] += STK_LSB_1G;
 		break;
 	default:
-		printk("%s: invalid stk831x_placement=%d", __func__, stk831x_placement);
-		return -1;
+		printk("%s: invalid stk831x_placement=%d\n", __func__, stk831x_placement);
+		atomic_set(&stk->cali_status, STK_K_FAIL_PLACEMENT);	
+		return -STK_K_FAIL_K_PARA;
 		break;
 	}		
+	
 	for(axis=0;axis<3;axis++)
 	{
 		acc_ave[axis] = -acc_ave[axis];
-		new_offset[axis] = (char)acc_ave[axis];
+		new_offset[axis] = acc_ave[axis];
+		char_offset[axis] = new_offset[axis];
 	}				
 #ifdef STK_DEBUG_CALI	
 	printk(KERN_INFO "%s: New offset:%d,%d,%d\n", __func__, new_offset[0], new_offset[1], new_offset[2]);	
 #endif	
 	if(store_location == 1)
 	{
-		cali_offset[0] = new_offset[0];
-		cali_offset[1] = new_offset[1];
-		cali_offset[2] = new_offset[2];
-		STK831x_SetOffset(new_offset);
+		STK831x_SetOffset(char_offset);
 		msleep(1);
 		STK831x_GetOffset(reg_offset);
 		for(axis=0;axis<3;axis++)
 		{
-			if(new_offset[axis] != reg_offset[axis])		
+			if(char_offset[axis] != reg_offset[axis])		
 			{
-				printk(KERN_ERR "%s: set offset to register fail!, new_offset[%d]=%d,reg_offset[%d]=%d\n",
-					__func__, axis,new_offset[axis], axis, reg_offset[axis]);
-							
-				return -2;
+				printk(KERN_ERR "%s: set offset to register fail!, char_offset[%d]=%d,reg_offset[%d]=%d\n", 
+					__func__, axis,char_offset[axis], axis, reg_offset[axis]);
+				atomic_set(&stk->cali_status, STK_K_FAIL_WRITE_NOFST);				
+				return -STK_K_FAIL_WRITE_NOFST;
 			}
 		}
-	
-		result = STK831X_VerifyCali(stk, 1);
+		
+		
+		result = STK831X_VerifyCali(stk, 1, real_delay_ms);
 		if(result)
-			printk(KERN_ERR "%s: calibration check fail\n", __func__);
+		{
+			printk(KERN_ERR "%s: calibration check fail, result=0x%x\n", __func__, result);
+			atomic_set(&stk->cali_status, -result);
+		}
 		else
 		{
-			stk_store_in_file(new_offset);
-			printk(KERN_INFO "%s successfully\n", __func__);	
+			result = stk_store_in_file(char_offset, STK_K_SUCCESS_FILE);
+			if(result)
+			{
+				printk(KERN_INFO "%s:write calibration failed\n", __func__);
+				atomic_set(&stk->cali_status, -result);				
+			}
+			else
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FILE);
+			}		
+			
 		}
 	}
 	else if(store_location >= 2)
 	{
-		for(i=0; i<3; i++)
+		for(axis=0; axis<3; axis++)
 		{
-			if( (new_offset[i]>>7)==0)
+#ifdef CONFIG_GRAVITY_STK8313
+			new_offset[axis]>>=2;
+#endif				
+			char_offset[axis] = (char)new_offset[axis];
+			if( (char_offset[axis]>>7)==0)
 			{
-				if(new_offset[i] >= 0x20 )
+				if(char_offset[axis] >= 0x20 )
 				{
-					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x1f", __func__, i, new_offset[i] );
-					otp_offset[i] = 0x1f;
+					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x1f\n", 
+									__func__, axis, char_offset[axis] );
+					char_offset[axis] = 0x1F;
+					//atomic_set(&stk->cali_status, STK_K_FAIL_OTP_OUT_RG);						
+					//return -STK_K_FAIL_OTP_OUT_RG;
 				}
-				else 
-					otp_offset[i] = new_offset[i];
 			}	
 			else
 			{
-				if(new_offset[i] <= 0xDF)
+				if(char_offset[axis] <= 0xDF)
 				{
-					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x20", __func__, i, new_offset[i]);				
-					otp_offset[i] = 0x20;
+					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x20\n", 
+									__func__, axis, char_offset[axis]);				
+					char_offset[axis] = 0x20;
+					//atomic_set(&stk->cali_status, STK_K_FAIL_OTP_OUT_RG);			
+					//return -STK_K_FAIL_OTP_OUT_RG;					
 				}
 				else
-					otp_offset[i] = new_offset[i] & 0x3f;
-			}
+					char_offset[axis] = char_offset[axis] & 0x3f;
+			}			
 		}
 
-		printk(KERN_INFO "%s: OTP offset:0x%x,0x%x,0x%x\n", __func__, otp_offset[0], otp_offset[1], otp_offset[2]);
+		printk(KERN_INFO "%s: OTP offset:0x%x,0x%x,0x%x\n", __func__, char_offset[0], char_offset[1], char_offset[2]);
 		if(store_location == 2)
-			result = stk_store_in_ic( stk, new_offset, otp_offset, 1, stk831x_placement);
+		{
+			result = stk_store_in_ic( stk, char_offset, 1, real_delay_ms);
+			if(result == 0)
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FT1);
+			}
+			else
+			{
+				printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
+			}
+		}
 		else if(store_location == 3)
-			result = stk_store_in_ic( stk, new_offset, otp_offset, 2, stk831x_placement);
-		
-		if(result == 0)
-			printk(KERN_INFO "%s successfully\n", __func__);
-		else
-			printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
-	}
+		{
+			result = stk_store_in_ic( stk, char_offset, 2, real_delay_ms);
+			if(result == 0)
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FT2);
+			}
+			else
+			{
+				printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
+			}
+		}
+		offset[0] = offset[1] = offset[2] = 0;
+		stk_store_in_file(offset, store_location);				
+	}
+#ifdef STK_TUNE	
+	stk_tune_offset_record[0] = 0;
+	stk_tune_offset_record[1] = 0;
+	stk_tune_offset_record[2] = 0;
+	stk_tune_done = 1;
+#endif	
 	stk->first_enable = false;		
+	STK831x_SetDelay(stk, gdelay_ns);
+	
 	if(org_enable)
 		STK831x_SetEnable(stk, 1);		
+	return 0;
+	
+err_i2c_rw:
+	stk->first_enable = false;		
+	if(org_enable)
+		STK831x_SetEnable(stk, 1);				
+	printk(KERN_ERR "%s: i2c read/write error, err=0x%x\n", __func__, result);
+	atomic_set(&stk->cali_status, STK_K_FAIL_I2C);	
+	return result;
+}
+
 
+static int STK831x_GetCali(struct stk831x_data *stk)
+{
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char offset[3], mode;	
+	int cnt, result;
+	char regR[6];
+	
+#ifdef STK_TUNE		
+	printk(KERN_INFO "%s: stk_tune_done=%d, stk_tune_index=%d, stk_tune_offset=%d,%d,%d\n", __func__, 
+		stk_tune_done, stk_tune_index, stk_tune_offset_record[0], stk_tune_offset_record[1], 
+		stk_tune_offset_record[2]);
+#endif		
+	if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+	{
+		if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
+		{
+			offset[0] = r_buf[2];
+			offset[1] = r_buf[3];
+			offset[2] = r_buf[4];
+			mode = r_buf[5];
+			printk(KERN_INFO "%s:file offset:%#02x,%#02x,%#02x,%#02x\n", 
+				__func__, offset[0], offset[1], offset[2], mode);							
+		}
+		else
+		{
+			printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x,0x%x\n", 
+				__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3], r_buf[4]);						
+		}
+	}
+	else
+		printk(KERN_INFO "%s: No file offset\n", __func__);
+	
+	for(cnt=0x43;cnt<0x49;cnt++)
+	{
+		result = STK831x_ReadByteOTP(cnt, &(regR[cnt-0x43]));
+		if(result < 0)
+			printk(KERN_ERR "%s: STK831x_ReadByteOTP failed, ret=%d\n", __func__, result);		
+	}
+	printk(KERN_INFO "%s: OTP 0x43-0x49:%#02x,%#02x,%#02x,%#02x,%#02x,%#02x\n", __func__, regR[0], 
+		regR[1], regR[2],regR[3], regR[4], regR[5]);
+		
+	for(cnt=0x53;cnt<0x59;cnt++)
+	{
+		result = STK831x_ReadByteOTP(cnt, &(regR[cnt-0x53]));
+		if(result < 0)
+			printk(KERN_ERR "%s: STK831x_ReadByteOTP failed, ret=%d\n", __func__, result);
+	}
+	printk(KERN_INFO "%s: OTP 0x53-0x59:%#02x,%#02x,%#02x,%#02x,%#02x,%#02x\n", __func__, regR[0], 
+		regR[1], regR[2],regR[3], regR[4], regR[5]);
+	
 	return 0;
 }
 
@@ -1335,7 +2082,8 @@ static int STK831x_Init(struct stk831x_data *stk, struct i2c_client *client)
 		printk(KERN_ERR "%s:failed\n", __func__);
 		return result;
 	}		
-
+	
+	/* int pin is active high, psuh-pull */
 	buffer[0] = STK831X_MODE;
 	buffer[1] = 0xC0;
 	result = STK_i2c_Tx(buffer, 2);
@@ -1343,19 +2091,21 @@ static int STK831x_Init(struct stk831x_data *stk, struct i2c_client *client)
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
 		return result;
-	}		
+	}			
 	
+	/* 50 Hz ODR */
+	stk->delay = STK831X_INIT_ODR;
 	buffer[0] = STK831X_SR;
-	buffer[1] = 0x04;	
+	buffer[1] = stk->delay;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
 		printk(KERN_ERR "%s:failed\n", __func__);
 		return result;
 	}	
-	stk->delay = 0x04;
 
 #if (!STK_ACC_POLLING_MODE)
+	/* enable GINT, int after every measurement */
 	buffer[0] = STK831X_INTSU;
 	buffer[1] = 0x10;
 	result = STK_i2c_Tx(buffer, 2);
@@ -1365,11 +2115,12 @@ static int STK831x_Init(struct stk831x_data *stk, struct i2c_client *client)
 		return result;
 	}	
 #endif 
-
 	buffer[0] = STK831X_STH;
 #ifdef CONFIG_GRAVITY_STK8312	
+	/* +- 6g mode */
 	buffer[1] = 0x42;
 #elif defined CONFIG_GRAVITY_STK8313
+	/* +- 8g mode */
 	buffer[1] = 0x82;
 #endif	
 	result = STK_i2c_Tx(buffer, 2);
@@ -1379,15 +2130,102 @@ static int STK831x_Init(struct stk831x_data *stk, struct i2c_client *client)
 		return result;
 	}	
 	
-//	atomic_set(&stk->enabled, 0);	
-#if STK_ACC_POLLING_MODE
-	atomic_set(&stk->run_thread, 0);
-#endif	//#if STK_ACC_POLLING_MODE				
+	atomic_set(&stk->enabled, 0);				
 	event_since_en = 0;
+
+#ifdef STK_LOWPASS
+	memset(&stk->fir, 0x00, sizeof(stk->fir));  
+	atomic_set(&stk->firlength, STK_FIR_LEN);
+	atomic_set(&stk->fir_en, 1);
+#endif	
+
+#ifdef STK_TUNE	
+	stk_tune_offset[0] = 0;
+	stk_tune_offset[1] = 0;
+	stk_tune_offset[2] = 0;	
+	stk_tune_done = 0;
+#endif	
+	return 0;
+}
+
+static void stk_handle_first_en(struct stk831x_data *stk)
+{
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char offset[3];	
+	char mode;
+
+	if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+	{
+		if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
+		{
+			offset[0] = r_buf[2];
+			offset[1] = r_buf[3];
+			offset[2] = r_buf[4];
+			mode = r_buf[5];
+			STK831x_SetOffset(offset);
+#ifdef STK_TUNE			
+			stk_tune_offset_record[0] = offset[0];
+			stk_tune_offset_record[1] = offset[1];
+			stk_tune_offset_record[2] = offset[2];
+#endif 			
+			printk(KERN_INFO "%s: set offset:%d,%d,%d, mode=%d\n", __func__, offset[0], offset[1], offset[2], mode);
+			atomic_set(&stk->cali_status, mode);								
+		}
+		else
+		{
+			printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x,0x%x\n", 
+				__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3], r_buf[4]);						
+			//return -EINVAL;
+		}
+	}
+#ifdef STK_TUNE		
+	else if(stk_tune_offset_record[0]!=0 || stk_tune_offset_record[1]!=0 || stk_tune_offset_record[2]!=0)
+	{
+		STK831x_SetOffset(stk_tune_offset_record);
+		stk_tune_done = 1;				
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_TUNE);	
+		printk(KERN_INFO "%s: set offset:%d,%d,%d\n", __func__, stk_tune_offset_record[0], 
+			stk_tune_offset_record[1],stk_tune_offset_record[2]);	
+	}	
+#endif	
+	else
+	{
+		offset[0] = offset[1] = offset[2] = 0;
+		stk_store_in_file(offset, STK_K_NO_CALI);
+		atomic_set(&stk->cali_status, STK_K_NO_CALI);			
+	}
+	printk(KERN_INFO "%s: finish, cali_status = 0x%x\n", __func__, atomic_read(&stk->cali_status));	
+	return;
+}
+
+static int32_t stk_get_ic_content(struct stk831x_data *stk)
+{
+	int result;
+	char regR;
+		
+	result = STK831x_ReadByteOTP(0x7F, &regR);
+	if(result < 0)
+	{
+		printk(KERN_ERR "%s: read/write eng i2c error, result=0x%x\n", __func__, result);	
+		return result;
+	}
+	
+	if(regR&0x20)
+	{
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_FT2);	
+		printk(KERN_INFO "%s: OTP 2 used\n", __func__);
+		return 2;	
+	}
+	if(regR&0x10)	
+	{
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_FT1);	
+		printk(KERN_INFO "%s: OTP 1 used\n", __func__);		
+		return 1;	
+	}
 	return 0;
 }
 
-static int stk_store_in_ic( struct stk831x_data *stk, char offset[], char otp_offset[], char FT_index, unsigned char stk831x_placement)
+static int stk_store_in_ic( struct stk831x_data *stk, char otp_offset[], char FT_index, uint32_t delay_ms)
 {
 	int result;
 	char buffer[2] = "";
@@ -1396,107 +2234,107 @@ static int stk_store_in_ic( struct stk831x_data *stk, char offset[], char otp_of
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}			
 	buffer[1] = (buffer[0] & 0xF8) | 0x01;
 	buffer[0] = STK831X_MODE;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}		
-
-	msleep(1);
 	STK831X_SetVD(stk);
 	
 	buffer[0] = 0x2B;	
-	buffer[1] = offset[0];
+	buffer[1] = otp_offset[0];
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}
 	buffer[0] = 0x2F;	
-	buffer[1] = offset[2];
+	buffer[1] = otp_offset[2];
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}
 	buffer[0] = 0x33;	
-	buffer[1] = offset[1];
+	buffer[1] = otp_offset[1];
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}		
+	
 
 #ifdef STK_DEBUG_CALI	
-	printk(KERN_INFO "%s:Check All OTP Data after write 0x2B 0x2F 0x33\n", __func__);
-	STK831x_ReadAllOTP();
+	//printk(KERN_INFO "%s:Check All OTP Data after write 0x2B 0x2F 0x33\n", __func__);
+	//STK831x_ReadAllOTP();
 #endif	
 	
-	msleep(150);		
-	result = STK831X_VerifyCali(stk, 0);
+	msleep(delay_ms*15);		
+	result = STK831X_VerifyCali(stk, 0, 0);
 	if(result)
 	{
-		printk(KERN_ERR "%s: calibration check1 fail, FT_index=%d\n", __func__, FT_index);		
-		return -1;
+		printk(KERN_ERR "%s: calibration check1 fail, FT_index=%d\n", __func__, FT_index);				
+		goto ic_err_misc;
 	}
 #ifdef STK_DEBUG_CALI		
-	printk(KERN_INFO "\n%s:Check All OTP Data before write OTP\n", __func__);
-	STK831x_ReadAllOTP();
+	//printk(KERN_INFO "\n%s:Check All OTP Data before write OTP\n", __func__);
+	//STK831x_ReadAllOTP();
 
+#endif	
 	//Write OTP	
 	printk(KERN_INFO "\n%s:Write offset data to FT%d OTP\n", __func__, FT_index);
-#endif	
 	result = STK831x_WriteOffsetOTP(stk, FT_index, otp_offset);
-	if(result == -2)
-	{
-		printk(KERN_INFO "%s: write OTP fail, OTP%d has been used\n", __func__, FT_index);
-		return -2;
-	}
-	else if(result < 0)
+	if(result < 0)
 	{
 		printk(KERN_INFO "%s: write OTP%d fail\n", __func__, FT_index);
-		return -1;
+		goto ic_err_misc;
 	}
 	
 	buffer[0] = STK831X_MODE;
 	result = STK_i2c_Rx(buffer, 1);	
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed\n", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}			
 	buffer[1] = (buffer[0] & 0xF8);
 	buffer[0] = STK831X_MODE;	
 	result = STK_i2c_Tx(buffer, 2);
 	if (result < 0) 
 	{
-		printk(KERN_ERR "%s:failed", __func__);
-		return result;
+		goto ic_err_i2c_rw;
 	}	
 	
 	msleep(1);
 	STK831x_Init(stk, this_client);
 #ifdef STK_DEBUG_CALI		
-	printk(KERN_INFO "\n%s:Check All OTP Data after write OTP and reset\n", __func__);
-	STK831x_ReadAllOTP();
+	//printk(KERN_INFO "\n%s:Check All OTP Data after write OTP and reset\n", __func__);
+	//STK831x_ReadAllOTP();
 #endif
 		
-	result = STK831X_VerifyCali(stk, 1);
+	result = STK831X_VerifyCali(stk, 1, delay_ms);
 	if(result)
 	{
 		printk(KERN_ERR "%s: calibration check2 fail\n", __func__);
-		return result;
+		goto ic_err_misc;
 	}
 	return 0;
+
+ic_err_misc:
+	STK831x_Init(stk, this_client);	
+	msleep(1);
+	atomic_set(&stk->cali_status, -result);	
+	return result;
+	
+ic_err_i2c_rw:	
+	printk(KERN_ERR "%s: i2c read/write error, err=0x%x\n", __func__, result);
+	msleep(1);
+	STK831x_Init(stk, this_client);	
+	atomic_set(&stk->cali_status, STK_K_FAIL_I2C);	
+	return result;	
 }
 
 static int32_t stk_get_file_content(char * r_buf, int8_t buf_size)
@@ -1505,7 +2343,7 @@ static int32_t stk_get_file_content(char * r_buf, int8_t buf_size)
 	mm_segment_t fs;	
 	ssize_t ret;
 	
-    cali_file = filp_open(STK_ACC_CALI_FILE, O_RDWR,0);
+    cali_file = filp_open(STK_ACC_CALI_FILE, O_RDONLY,0);
     if(IS_ERR(cali_file))
 	{
         printk(KERN_ERR "%s: filp_open error, no offset file!\n", __func__);
@@ -1530,7 +2368,6 @@ static int32_t stk_get_file_content(char * r_buf, int8_t buf_size)
 }
 
 #ifdef STK_PERMISSION_THREAD
-SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename, mode_t, mode);
 static struct task_struct *STKPermissionThread = NULL;
 
 static int stk_permission_thread(void *data)
@@ -1542,7 +2379,18 @@ static int stk_permission_thread(void *data)
 	msleep(20000);
 	do{
 		msleep(5000);
-		ret = sys_fchmodat(AT_FDCWD, "/data/misc/stk_acc_cali.conf" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input0/driver/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input1/driver/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input2/driver/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input3/driver/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input4/driver/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input0/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input1/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input2/cali" , 0666);
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input3/cali" , 0666);		
+		ret = sys_fchmodat(AT_FDCWD, "/sys/class/input/input4/cali" , 0666);
+		ret = sys_chmod(STK_ACC_CALI_FILE , 0666);	
+		ret = sys_fchmodat(AT_FDCWD, STK_ACC_CALI_FILE , 0666);
 		//if(ret < 0)
 		//	printk("fail to execute sys_fchmodat, ret = %d\n", ret);
 		if(retry++ > 10)
@@ -1553,7 +2401,8 @@ static int stk_permission_thread(void *data)
 	return 0;
 }
 #endif	/*	#ifdef STK_PERMISSION_THREAD	*/
-static int stk_store_in_file(char offset[])
+
+static int stk_store_in_file(char offset[], char mode)
 {
 	struct file  *cali_file;
 	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
@@ -1567,13 +2416,14 @@ static int stk_store_in_file(char offset[])
 	w_buf[2] = offset[0];
 	w_buf[3] = offset[1];
 	w_buf[4] = offset[2];
+	w_buf[5] = mode;
 	
     cali_file = filp_open(STK_ACC_CALI_FILE, O_CREAT | O_RDWR,0666);
 	
     if(IS_ERR(cali_file))
 	{
         printk(KERN_ERR "%s: filp_open error!\n", __func__);
-        return -ENOENT;
+        return -STK_K_FAIL_OPEN_FILE;
 	}
 	else
 	{
@@ -1585,7 +2435,7 @@ static int stk_store_in_file(char offset[])
 		{
 			printk(KERN_ERR "%s: write error!\n", __func__);
 			filp_close(cali_file,NULL);
-			return -EIO;
+			return -STK_K_FAIL_W_FILE;
 		}
 		cali_file->f_pos=0x00;
 		ret = cali_file->f_op->read(cali_file,r_buf, STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
@@ -1593,11 +2443,11 @@ static int stk_store_in_file(char offset[])
 		{
 			printk(KERN_ERR "%s: read error!\n", __func__);
 			filp_close(cali_file,NULL);
-			return -EIO;
+			return -STK_K_FAIL_R_BACK;
 		}		
 		set_fs(fs);
 		
-		//printk(KERN_INFO "%s: read ret=%d!", __func__, ret);
+		//printk(KERN_INFO "%s: read ret=%d!\n", __func__, ret);
 		for(i=0;i<STK_ACC_CALI_FILE_SIZE;i++)
 		{
 			if(r_buf[i] != w_buf[i])
@@ -1605,11 +2455,19 @@ static int stk_store_in_file(char offset[])
 				printk(KERN_ERR "%s: read back error, r_buf[%x](0x%x) != w_buf[%x](0x%x)\n", 
 					__func__, i, r_buf[i], i, w_buf[i]);				
 				filp_close(cali_file,NULL);
-				return -EIO;
+				return -STK_K_FAIL_R_BACK_COMP;
 			}
 		}
     }
     filp_close(cali_file,NULL);	
+	
+#ifdef STK_PERMISSION_THREAD
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_chmod(STK_ACC_CALI_FILE , 0666);
+	ret = sys_fchmodat(AT_FDCWD, STK_ACC_CALI_FILE , 0666);
+	set_fs(fs);		
+#endif
 	//printk(KERN_INFO "%s successfully\n", __func__);
 	return 0;		
 }
@@ -1709,11 +2567,9 @@ static int stk_ioctl(struct inode *inode, struct file *file, unsigned int cmd, u
 		break;
 	case STK_IOCTL_GET_ACCELERATION:		
 		STK831x_ReadSensorData(stk);
-		mutex_lock(&stk->read_lock);
 		int3_buffer[0] = stk->raw_data[0];
 		int3_buffer[1] = stk->raw_data[1];
 		int3_buffer[2] = stk->raw_data[2];			
-		mutex_unlock(&stk->read_lock);	
 		break;
 	case STK_IOCTL_SET_ENABLE:
 		STK831x_SetEnable(stk, state);
@@ -1790,24 +2646,20 @@ static struct miscdevice stk_device = {
 
 
 #if STK_ACC_POLLING_MODE
+static enum hrtimer_restart stk_acc_timer_func(struct hrtimer *timer)
+{
+	struct stk831x_data *stk = container_of(timer, struct stk831x_data, acc_timer);
+	queue_work(stk->stk_acc_wq, &stk->stk_acc_work);
+	hrtimer_forward_now(&stk->acc_timer, stk->acc_poll_delay);
+	return HRTIMER_RESTART;		
+}
 
-static int stk_acc_polling_function(void *arg)
+static void stk_acc_poll_work_func(struct work_struct *work)
 {
-	struct stk831x_data *stk = arg;	
-    uint32_t ndelay;
-    init_completion(&acc_thread_completion);
-	
-    while (1)
-    {
-        STK831x_GetDelay(stk, &ndelay);
-        STK831x_ReadSensorData(stk);
-		STK831x_ReportValue(stk);
-        if (atomic_read(&stk->run_thread) == 0)
-            break;
-        msleep(ndelay/1000000);
-    };
-    complete(&acc_thread_completion);
-    return 0;
+	struct stk831x_data *stk = container_of(work, struct stk831x_data, stk_acc_work);	
+	STK831x_ReadSensorData(stk);
+	STK831x_ReportValue(stk);
+	return;
 }
 
 #else
@@ -1823,14 +2675,12 @@ static irqreturn_t stk_mems_irq_handler(int irq, void *data)
 
 static void stk_mems_wq_function(struct work_struct *work)
 {
-	struct stk831x_data *stk = container_of(work, struct stk831x_data, stk_work);				
+	struct stk831x_data *stk = container_of(work, struct stk831x_data, stk_work);					
 	STK831x_ReadSensorData(stk);
 	STK831x_ReportValue(stk);
 	enable_irq(stk->irq);
 }
 
-
-
 static int stk831x_irq_setup(struct i2c_client *client, struct stk831x_data *stk_int)
 {
 	int error;
@@ -1871,8 +2721,7 @@ static ssize_t stk831x_enable_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct stk831x_data *stk = i2c_get_clientdata(this_client);
-
-	return sprintf(buf, "%d\n", atomic_read(&stk->enabled));
+	return scnprintf(buf, PAGE_SIZE,  "%d\n", atomic_read(&stk->enabled));
 }
 
 static ssize_t stk831x_enable_store(struct device *dev,
@@ -1886,12 +2735,12 @@ static ssize_t stk831x_enable_store(struct device *dev,
 
 	error = strict_strtoul(buf, 10, &data);
 	if (error)
-		return error;
-
-	if ((data == 0)||(data==1)) 
 	{
-		STK831x_SetEnable(stk,data);
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
 	}
+	if ((data == 0)||(data==1)) 
+		STK831x_SetEnable(stk,data);	
 	else
 		printk(KERN_ERR "%s: invalud argument, data=%ld\n", __func__, data);
 	return count;
@@ -1902,13 +2751,13 @@ static ssize_t stk831x_value_show(struct device *dev,
 {
 	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
 	int ddata[3];
+
+	printk(KERN_INFO "driver version:%s\n",STK_ACC_DRIVER_VERSION);	
 	STK831x_ReadSensorData(stk);
-	mutex_lock(&stk->read_lock);
 	ddata[0]= stk->raw_data[0];
 	ddata[1]= stk->raw_data[1];
 	ddata[2]= stk->raw_data[2];
-	mutex_unlock(&stk->read_lock);
-	return sprintf(buf, "%d %d %d\n", ddata[0], ddata[1], ddata[2]);
+	return scnprintf(buf, PAGE_SIZE,  "%d %d %d\n", ddata[0], ddata[1], ddata[2]);
 }
 
 static ssize_t stk831x_delay_show(struct device *dev,
@@ -1918,7 +2767,7 @@ static ssize_t stk831x_delay_show(struct device *dev,
 	uint32_t gdelay_ns;
 	
 	STK831x_GetDelay(stk, &gdelay_ns);
-	return sprintf(buf, "%d\n", gdelay_ns/1000000);
+	return scnprintf(buf, PAGE_SIZE,  "%d\n", gdelay_ns/1000000);
 }
 
 static ssize_t stk831x_delay_store(struct device *dev,
@@ -1928,19 +2777,35 @@ static ssize_t stk831x_delay_store(struct device *dev,
 	unsigned long data;
 	int error;
 	struct stk831x_data *stk = i2c_get_clientdata(this_client);
-
+	char restore_state = 0;
+	
 	error = strict_strtoul(buf, 10, &data);
 	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
 		return error;
+	}
 
+	STK831x_GetEnable(stk, &restore_state);
+	if(restore_state)
+		STK831x_SetEnable(stk, 0);
+	
 	STK831x_SetDelay(stk, data*1000000);	// ms to ns
+	
+	if(restore_state)
+		STK831x_SetEnable(stk, restore_state);	
 	return count;
 }
 
 static ssize_t stk831x_cali_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return 0;	
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	int status = atomic_read(&stk->cali_status);
+	
+	if(status != STK_K_RUNNING)
+		STK831x_GetCali(stk);
+	return scnprintf(buf, PAGE_SIZE,  "%02x\n", status);	
 }
 
 static ssize_t stk831x_cali_store(struct device *dev,
@@ -1952,27 +2817,332 @@ static ssize_t stk831x_cali_store(struct device *dev,
 	struct stk831x_data *stk = i2c_get_clientdata(this_client);
 	error = strict_strtoul(buf, 10, &data);
 	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
 		return error;
-	
+	}
 	STK831x_SetCali(stk, data);
 	return count;
 }
 
-static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR | S_IWGRP, stk831x_enable_show, stk831x_enable_store);
-static DEVICE_ATTR(value, S_IRUGO, stk831x_value_show, NULL);
-static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP, stk831x_delay_show, stk831x_delay_store);
-static DEVICE_ATTR(cali, S_IRUGO|S_IWUSR|S_IWGRP, stk831x_cali_show, stk831x_cali_store);
+static ssize_t stk831x_send_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int error, i;
+	char *token[2];	
+	int w_reg[2];
+	char buffer[2] = "";
+	
+	for (i = 0; i < 2; i++)
+		token[i] = strsep((char **)&buf, " ");
+	if((error = strict_strtoul(token[0], 16, (unsigned long *)&(w_reg[0]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	if((error = strict_strtoul(token[1], 16, (unsigned long *)&(w_reg[1]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, w_reg[0], w_reg[1]);	
+	buffer[0] = w_reg[0];
+	buffer[1] = w_reg[1];
+	error = STK_i2c_Tx(buffer, 2);
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	return count;
+}
+
+static ssize_t stk831x_recv_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	return scnprintf(buf, PAGE_SIZE,  "%02x\n", stk->recv_reg);	
+}
+
+static ssize_t stk831x_recv_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	char buffer[2] = "";
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	error = strict_strtoul(buf, 16, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	
+	buffer[0] = data;
+	error = STK_i2c_Rx(buffer, 2);	
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	stk->recv_reg = buffer[0];
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, (int)data , (int)buffer[0]);		
+	return count;
+}
+
+static ssize_t stk831x_allreg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int error;	
+	char buffer[16] = "";
+	char show_buffer[14] = "";
+	int aa,bb, no, show_no = 0;
+	
+	for(bb=0;bb<4;bb++)
+	{
+		buffer[0] = bb * 0x10;
+		error = STK_i2c_Rx(buffer, 16);	
+		if (error < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return error;
+		}
+		for(aa=0;aa<16;aa++)
+		{
+			no = bb*0x10+aa;
+			printk(KERN_INFO "stk reg[0x%x]=0x%x\n", no, buffer[aa]);
+			switch(no)
+			{
+			case 0x0:	
+			case 0x1:	
+			case 0x2:	
+			case 0x3:	
+			case 0x4:	
+			case 0x5:	
+			case STK831X_INTSU:	
+			case STK831X_MODE:	
+			case STK831X_SR:	
+			case STK831X_OFSX:	
+			case STK831X_OFSY:	
+			case STK831X_OFSZ:	
+			case STK831X_STH:	
+			case 0x24:	
+				show_buffer[show_no] = buffer[aa];
+				show_no++;
+				break;
+			default:
+				break;
+			}
+		}
+	}	
+	return scnprintf(buf, PAGE_SIZE,  "0x0=%02x,0x1=%02x,0x2=%02x,0x3=%02x,0x4=%02x,0x5=%02x,INTSU=%02x,MODE=%02x,SR=%02x,OFSX=%02x,OFSY=%02x,OFSZ=%02x,STH=%02x,0x24=%02x\n", 
+		show_buffer[0], show_buffer[1], show_buffer[2], show_buffer[3], show_buffer[4], 
+		show_buffer[5], show_buffer[6], show_buffer[7], show_buffer[8], show_buffer[9], 
+		show_buffer[10], show_buffer[11], show_buffer[12], show_buffer[13]);		
+}
+
+static ssize_t stk831x_sendo_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int error, i;
+	char *token[2];	
+	int w_reg[2];
+	char buffer[2] = "";
+	
+	for (i = 0; i < 2; i++)
+		token[i] = strsep((char **)&buf, " ");
+	if((error = strict_strtoul(token[0], 16, (unsigned long *)&(w_reg[0]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	if((error = strict_strtoul(token[1], 16, (unsigned long *)&(w_reg[1]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, w_reg[0], w_reg[1]);	
+
+	buffer[0] = w_reg[0];
+	buffer[1] = w_reg[1];
+	error = STK831x_WriteByteOTP(buffer[0], buffer[1]);
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	return count;
+}
+
+
+static ssize_t stk831x_recvo_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	char buffer[2] = "";
+	unsigned long data;
+	int error;
+	
+	error = strict_strtoul(buf, 16, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	
+	buffer[0] = data;
+	error = STK831x_ReadByteOTP(buffer[0], &buffer[1]);	
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, buffer[0] , buffer[1]);		
+	return count;
+}
+
+static ssize_t stk831x_firlen_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+#ifdef STK_LOWPASS
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int len = atomic_read(&stk->firlength);
+	
+	if(atomic_read(&stk->firlength))
+	{
+		printk(KERN_INFO "len = %2d, idx = %2d\n", stk->fir.num, stk->fir.idx);			
+		printk(KERN_INFO "sum = [%5d %5d %5d]\n", stk->fir.sum[0], stk->fir.sum[1], stk->fir.sum[2]);
+		printk(KERN_INFO "avg = [%5d %5d %5d]\n", stk->fir.sum[0]/len, stk->fir.sum[1]/len, stk->fir.sum[2]/len);
+	}
+	return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&stk->firlength));
+#else
+	return snprintf(buf, PAGE_SIZE, "not support\n");
+#endif	
+}
+
+static ssize_t stk831x_firlen_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+#ifdef STK_LOWPASS
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int error;
+	unsigned long data;
+	
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=%d\n", __func__, error);
+		return error;
+	}			
+	
+	if(data > MAX_FIR_LEN)
+	{
+		printk(KERN_ERR "%s: firlen exceed maximum filter length\n", __func__);
+	}
+	else if (data < 1)
+	{
+		atomic_set(&stk->firlength, 1);
+		atomic_set(&stk->fir_en, 0);	
+		memset(&stk->fir, 0x00, sizeof(stk->fir));
+	}
+	else
+	{ 
+		atomic_set(&stk->firlength, data);
+		memset(&stk->fir, 0x00, sizeof(stk->fir));
+		atomic_set(&stk->fir_en, 1);	
+	}
+#else
+	printk(KERN_ERR "%s: firlen is not supported\n", __func__);
+#endif    
+	return count;	
+}
+
+static ssize_t stk831x_range_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	char grange = 0;
+       int range = 0;
+
+#ifdef CONFIG_GRAVITY_STK8313
+       range = stk8313_range[2].range;
+       if(!STK831x_GetRange(&grange)) {
+            if(grange <= 0x3)
+                range = stk8313_range[grange].range;
+       }
+	return sprintf(buf, "%d\n", range);
+#elif defined(CONFIG_GRAVITY_STK8312)
+       range = stk8312_range[1].range;
+       if(!STK831x_GetRange(&grange)) {
+            if(grange <= 0x2)
+                range= stk8312_range[grange].range;
+       }
+       return sprintf(buf, "%d\n", range);
+#endif
+}
+
+static ssize_t stk831x_resolution_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	char grange = 0;
+       int resolution = 0;
+	
+#ifdef CONFIG_GRAVITY_STK8313
+       resolution = stk8313_range[2].resolution;
+       if(!STK831x_GetRange(&grange)) {
+            if(grange <= 0x3)
+                resolution = stk8313_range[grange].resolution;
+       }
+#elif defined(CONFIG_GRAVITY_STK8312)
+       resolution = stk8312_range[1].resolution;
+       if(!STK831x_GetRange(&grange)) {
+            if(grange <= 0x2)
+                resolution = stk8312_range[grange].resolution;
+       }
+#endif
+
+	return sprintf(buf, "%d\n", resolution);
+}
 
+static DEVICE_ATTR(enable, 0666, stk831x_enable_show, stk831x_enable_store);
+static DEVICE_ATTR(value, 0444, stk831x_value_show, NULL);
+static DEVICE_ATTR(delay, 0666, stk831x_delay_show, stk831x_delay_store);
+static DEVICE_ATTR(cali, 0666, stk831x_cali_show, stk831x_cali_store);
+static DEVICE_ATTR(send, 0222, NULL, stk831x_send_store);
+static DEVICE_ATTR(recv, 0666, stk831x_recv_show, stk831x_recv_store);
+static DEVICE_ATTR(allreg, 0444, stk831x_allreg_show, NULL);
+static DEVICE_ATTR(sendo, 0222, NULL, stk831x_sendo_store);
+static DEVICE_ATTR(recvo, 0222, NULL, stk831x_recvo_store);
+static DEVICE_ATTR(firlen, 0666, stk831x_firlen_show, stk831x_firlen_store);
+static DEVICE_ATTR(range, 0444, stk831x_range_show, NULL);
+static DEVICE_ATTR(resolution, 0444, stk831x_resolution_show, NULL);
 
 static struct attribute *stk831x_attributes[] = {
 	&dev_attr_enable.attr,
 	&dev_attr_value.attr,
 	&dev_attr_delay.attr,
 	&dev_attr_cali.attr,
+	&dev_attr_send.attr,
+	&dev_attr_recv.attr,
+	&dev_attr_allreg.attr,
+	&dev_attr_sendo.attr,
+	&dev_attr_recvo.attr,
+	&dev_attr_firlen.attr,
+	&dev_attr_range.attr,
+	&dev_attr_resolution.attr,
 	NULL
 };
 
 static struct attribute_group stk831x_attribute_group = {
+//#ifndef STK_ALLWINNER_PLATFORM	
+//	.name = "driver",
+//#endif	
 	.attrs = stk831x_attributes,
 };
 static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *id)
@@ -1980,9 +3150,6 @@ static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *
 	int error;
 	struct stk831x_data *stk;
 
-
-	printk("!!!!!!!!!!probing stk831x_probe: driver version:%s\n",STK_ACC_DRIVER_VERSION);	
-
 	printk(KERN_INFO "stk831x_probe: driver version:%s\n",STK_ACC_DRIVER_VERSION);	
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
 	{
@@ -1999,9 +3166,15 @@ static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *
 		goto exit_kzalloc_error;
 	}
 	stk831x_data_ptr = stk;
-	mutex_init(&stk->read_lock);
-
-#if (!STK_ACC_POLLING_MODE)	
+	mutex_init(&stk->write_lock);
+	
+#if (STK_ACC_POLLING_MODE)	
+	stk->stk_acc_wq = create_singlethread_workqueue("stk_acc_wq");
+	INIT_WORK(&stk->stk_acc_work, stk_acc_poll_work_func);
+	hrtimer_init(&stk->acc_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stk->acc_poll_delay = ns_to_ktime(STK831X_SAMPLE_TIME[STK831X_INIT_ODR]*USEC_PER_MSEC);
+	stk->acc_timer.function = stk_acc_timer_func;
+#else	
 	stk_mems_work_queue = create_workqueue("stk_mems_wq");
 	if(stk_mems_work_queue)
 		INIT_WORK(&stk->stk_work, stk_mems_wq_function);
@@ -2021,13 +3194,17 @@ static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *
 	
 	i2c_set_clientdata(client, stk);	
 	this_client = client;
-	stk->first_enable = true;
+	
 	error = STK831x_Init(stk, client);
 	if (error) 
 	{		
 		printk(KERN_ERR "%s:stk831x initialization failed\n", __func__);	
 		goto exit_stk_init_error;
 	}
+	atomic_set(&stk->cali_status, STK_K_NO_CALI);	
+	stk->first_enable = true;
+	stk->re_enable = false;
+	event_since_en_limit = 20;
 	
 	stk->input_dev = input_allocate_device();
 	if (!stk->input_dev) 
@@ -2037,23 +3214,18 @@ static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *
 		goto exit_input_dev_alloc_error;
 	}
 	
-	stk->input_dev->name = ACC_IDEVICE_NAME;
+	stk->input_dev->name = STK831X_I2C_NAME;
 	set_bit(EV_ABS, stk->input_dev->evbit);	
 #ifdef CONFIG_GRAVITY_STK8312
 	input_set_abs_params(stk->input_dev, ABS_X, -128, 127, 0, 0);
 	input_set_abs_params(stk->input_dev, ABS_Y, -128, 127, 0, 0);
-	input_set_abs_params(stk->input_dev, ABS_Z, -128, 127, 0, 0);	
+	input_set_abs_params(stk->input_dev, ABS_Z, -128, 127, 0, 0);
 #elif defined CONFIG_GRAVITY_STK8313
 	input_set_abs_params(stk->input_dev, ABS_X, -512, 511, 0, 0);
 	input_set_abs_params(stk->input_dev, ABS_Y, -512, 511, 0, 0);
 	input_set_abs_params(stk->input_dev, ABS_Z, -512, 511, 0, 0);	
 #endif
 
-	cali_offset[0] = 0;
-	cali_offset[1] = 0;
-	cali_offset[2] = 0;
-	atomic_set(&stk->enabled, 0);
-
 	error = input_register_device(stk->input_dev);
 	if (error) 
 	{
@@ -2073,6 +3245,7 @@ static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *
 		printk(KERN_ERR "%s: sysfs_create_group failed\n", __func__);
 		goto exit_sysfs_create_group_error;
 	}		
+	
 	printk(KERN_INFO "%s successfully\n", __func__);
 	return 0;
 exit_sysfs_create_group_error:
@@ -2083,7 +3256,10 @@ exit_input_register_device_error:
 	input_unregister_device(stk->input_dev);	
 exit_input_dev_alloc_error:	
 exit_stk_init_error:	
-#if (!STK_ACC_POLLING_MODE)
+#if (STK_ACC_POLLING_MODE)
+	hrtimer_try_to_cancel(&stk->acc_timer);	
+	destroy_workqueue(stk->stk_acc_wq);	
+#else	
 	free_irq(client->irq, stk);
 #if ADDITIONAL_GPIO_CFG 
 exit_irq_setup_error:
@@ -2092,7 +3268,7 @@ exit_irq_setup_error:
 	destroy_workqueue(stk_mems_work_queue);		
 exit_create_workqueue_error:	
 #endif 	//#if (!STK_ACC_POLLING_MODE)	
-	mutex_destroy(&stk->read_lock);
+	mutex_destroy(&stk->write_lock);
 	kfree(stk);	
 	stk = NULL;	
 exit_kzalloc_error:	
@@ -2108,15 +3284,18 @@ static int stk831x_remove(struct i2c_client *client)
 	misc_deregister(&stk_device);
 	input_unregister_device(stk->input_dev);	
 	cancel_work_sync(&stk->stk_work);	
+#if (STK_ACC_POLLING_MODE)
+	hrtimer_try_to_cancel(&stk->acc_timer);	
+	destroy_workqueue(stk->stk_acc_wq);	
+#else		
 	free_irq(client->irq, stk);
-#if (!STK_ACC_POLLING_MODE)
 #if ADDITIONAL_GPIO_CFG
 	gpio_free( STK_INT_PIN );
 #endif //#if ADDITIONAL_GPIO_CFG 		
 	if (stk_mems_work_queue)
 		destroy_workqueue(stk_mems_work_queue);	
 #endif	//#if (!STK_ACC_POLLING_MODE)	
-	mutex_destroy(&stk->read_lock);	
+	mutex_destroy(&stk->write_lock);	
 	kfree(stk);
 	stk = NULL;		
 	return 0;
@@ -2127,34 +3306,16 @@ static const struct i2c_device_id stk831x[] = {
 	{ }
 };
 
-
-/*
-static int stk831x_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-	struct stk831x_data *stk = i2c_get_clientdata(client);
-	if(atomic_read(&stk->enabled))
-		STK831x_SetEnable(stk, 0);
-	return 0;
-}
-
-static int stk831x_resume(struct i2c_client *client)
-{
-	struct stk831x_data *stk = i2c_get_clientdata(client);
-	if(atomic_read(&stk->enabled))	
-		STK831x_SetEnable(stk, 1);
-	return 0;
-}
-*/
-
 #ifdef CONFIG_PM_SLEEP
 static int stk831x_suspend(struct device *dev)
 {
 	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
 	struct stk831x_data *stk = i2c_get_clientdata(client);
+	printk(KERN_INFO "%s\n", __func__);
 	if(atomic_read(&stk->enabled))
 	{
 		STK831x_SetEnable(stk, 0);
-		atomic_set(&stk->enabled, 1);	
+		stk->re_enable = true;	
 	}
 	return 0;
 }
@@ -2164,15 +3325,25 @@ static int stk831x_resume(struct device *dev)
 {
 	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
 	struct stk831x_data *stk = i2c_get_clientdata(client);
-	int error = 0;
-	error = STK831x_Init(stk, client);
+#ifdef STK_RESUME_RE_INIT
+	int error;
+#endif
+	
+	printk(KERN_INFO "%s\n", __func__);
+#ifdef STK_RESUME_RE_INIT
+	error = STK831x_Init(stk, this_client);
 	if (error) 
 	{		
-		printk(KERN_ERR "%s:stk831x resume initialization failed\n", __func__);	
-	}
-	STK831x_SetOffset(cali_offset);
-	if(atomic_read(&stk->enabled))	
+		printk(KERN_ERR "%s:stk831x initialization failed\n", __func__);	
+		return error;
+	}	
+	stk->first_enable = true;
+#endif
+	if(stk->re_enable)	
+	{
+		stk->re_enable = false;
 		STK831x_SetEnable(stk, 1);
+	}
 	return 0;		
 }
 #endif /* CONFIG_PM_SLEEP */
@@ -2183,10 +3354,11 @@ static int stk831x_runtime_suspend(struct device *dev)
 {
 	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
 	struct stk831x_data *stk = i2c_get_clientdata(client);
+	printk(KERN_INFO "%s\n", __func__);
 	if(atomic_read(&stk->enabled))
 	{
 		STK831x_SetEnable(stk, 0);
-		atomic_set(&stk->enabled, 1);			
+		stk->re_enable = true;		
 	}
 	return 0;
 }
@@ -2196,15 +3368,13 @@ static int stk831x_runtime_resume(struct device *dev)
 {
 	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
 	struct stk831x_data *stk = i2c_get_clientdata(client);
-	int error = 0;
-	error = STK831x_Init(stk, client);
-	if (error) 
-	{		
-		printk(KERN_ERR "%s:stk831x resume initialization failed\n", __func__);	
-	}
-	STK831x_SetOffset(cali_offset);
-	if(atomic_read(&stk->enabled))	
+	printk(KERN_INFO "%s\n", __func__);
+	stk->first_enable = true;
+	if(stk->re_enable)	
+	{
+		stk->re_enable = false;
 		STK831x_SetEnable(stk, 1);
+	}
 	return 0;		
 }
 #endif /* CONFIG_PM_RUNTIME */
@@ -2214,9 +3384,28 @@ static const struct dev_pm_ops stk831x_pm_ops = {
 	SET_RUNTIME_PM_OPS(stk831x_runtime_suspend, stk831x_runtime_resume, NULL)
 };
 
+#ifdef STK_ALLWINNER_PLATFORM
+static int gsensor_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	printk("======stk831x init detect======\n");
+	if(twi_id == adapter->nr){
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, STK831X_I2C_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, STK831X_I2C_NAME, sizeof(STK831X_I2C_NAME)+1);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+#endif
 
 
 static struct i2c_driver stk831x_driver = {
+#ifdef STK_ALLWINNER_PLATFORM
+	.class = I2C_CLASS_HWMON,	
+#endif	
 	.probe = stk831x_probe,
 	.remove = stk831x_remove,
 	.id_table	= stk831x,
@@ -2226,49 +3415,50 @@ static struct i2c_driver stk831x_driver = {
 		   .name = STK831X_I2C_NAME,
 		   .pm = &stk831x_pm_ops,
 	},
+#ifdef STK_ALLWINNER_PLATFORM	
+	.address_list	= u_i2c_addr.normal_i2c,	
+#endif	
 };
 
-#if CONFIG_OF
-
-static struct i2c_client *g_i2c_client;
-static struct i2c_board_info i2c_info =
-{
-    I2C_BOARD_INFO("stk831x", 0x3d),
-};
-
-#endif
-
 static int __init stk831x_init(void)
 {
 	int ret;
-
-#ifdef CONFIG_OF
-	struct i2c_adapter *adapter;
-    int i2c_bus_nr; 
-
-    if(sensor_setup_i2c_dev(&i2c_info, &i2c_bus_nr, 0) >= 0)
-    {
-        adapter = i2c_get_adapter(i2c_bus_nr);
-        if(!adapter)
-           return -1;
-
-        g_i2c_client = i2c_new_device(adapter, &i2c_info);
-        if(!g_i2c_client)
-            return -1;
-        return i2c_add_driver(&stk831x_driver);
-    }
-
-    return -1;
-#else
-	return i2c_add_driver(&stk831x_driver);
+	printk("%s\n", __func__);
+#ifdef STK_ALLWINNER_PLATFORM	
+	#ifdef CONFIG_GRAVITY_STK8312
+		printk("======stk831x(8312) init======\n");
+		u_i2c_addr.dirty_addr_buf[0] = 0x3d;
+	#elif defined CONFIG_GRAVITY_STK8313
+		printk("======stk831x(8313) init======\n");
+		u_i2c_addr.dirty_addr_buf[0] = 0x22;
+	#endif	
+	
+	u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+	stk831x_driver.detect = gsensor_detect;	
+#endif	/* #ifdef STK_ALLWINNER_PLATFORM */
+
+#ifdef STK_ALLWINNER_PLATFORM	
+	if(gsensor_fetch_sysconfig_para()){
+		printk("%s:gsensor_fetch_sysconfig_para  err.\n", __func__);
+		return -1;
+	}
 #endif
-
+	ret = i2c_add_driver(&stk831x_driver);
+	if (ret!=0)
+	{
+		printk("======stk831x init fail, ret=0x%x======\n", ret);
+		i2c_del_driver(&stk831x_driver);
+		return ret;
+	}
 #ifdef STK_PERMISSION_THREAD
 	STKPermissionThread = kthread_run(stk_permission_thread,"stk","Permissionthread");
 	if(IS_ERR(STKPermissionThread))
 		STKPermissionThread = NULL;
-#endif // STK_PERMISSION_THREAD		
-
+#endif // STK_PERMISSION_THREAD	
+#ifdef STK_ALLWINNER_PLATFORM
+	printk("======stk831x init ok======\n");	
+#endif	/* #ifdef STK_ALLWINNER_PLATFORM */	
+	return ret; 
 }
 
 static void __exit stk831x_exit(void)
@@ -2278,14 +3468,6 @@ static void __exit stk831x_exit(void)
 	if(STKPermissionThread)
 		STKPermissionThread = NULL;
 #endif // STK_PERMISSION_THREAD		
-
-#ifdef CONFIG_OF
-    if(g_i2c_client)
-    {
-        i2c_unregister_device(g_i2c_client);
-        g_i2c_client = 0;
-    }
-#endif
 }
 
 module_init(stk831x_init);
diff --git a/include/linux/sensor/cm3232.h b/include/linux/sensor/cm3232.h
new file mode 100644
index 000000000000..ae5a5299e224
--- /dev/null
+++ b/include/linux/sensor/cm3232.h
@@ -0,0 +1,60 @@
+/* include/linux/cm3232.h
+ *
+ * Copyright (C) 2011 Capella Microsystems Inc.
+ * Author: Frank Hsieh <pengyueh@gmail.com>  
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_CM3232_H
+#define __LINUX_CM3232_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define LIGHTSENSOR_IOCTL_MAGIC 'l'
+
+#define LIGHTSENSOR_IOCTL_GET_ENABLED _IOR(LIGHTSENSOR_IOCTL_MAGIC, 1, int *)
+#define LIGHTSENSOR_IOCTL_ENABLE _IOW(LIGHTSENSOR_IOCTL_MAGIC, 2, int *)
+
+#define CM3232_I2C_NAME "cm3232"
+
+#define	CM3232_SLAVE_addr	0x20>>1
+
+#define ALS_CALIBRATED		0x6EE3
+
+/*cm3232*/
+#define CM3232_ALS_COMMAND_CODE 	       0
+#define CM3232_ALS_READ_COMMAND_CODE 	0x50
+
+/*for ALS command*/
+#define CM3232_ALS_RESET 	    (1 << 6)
+#define CM3232_ALS_IT_100ms 	(0 << 2)
+#define CM3232_ALS_IT_200ms 	(1 << 2)
+#define CM3232_ALS_IT_400ms 	(2 << 2)
+#define CM3232_ALS_IT_800ms 	(3 << 2)
+#define CM3232_ALS_IT_1600ms 	(4 << 2)
+#define CM3232_ALS_IT_3200ms 	(5 << 2)
+
+#define CM3232_ALS_HS_HIGH 	  (1 << 1)
+#define CM3232_ALS_SD		      (1 << 0)
+
+#define LS_PWR_ON					(1 << 0)
+#define PS_PWR_ON					(1 << 1)
+
+struct cm3232_platform_data {
+	uint16_t levels[10];
+	uint16_t golden_adc;
+	int (*power)(int, uint8_t); /* power to the chip */
+	uint16_t ALS_slave_address;
+};
+
+#endif
diff --git a/include/linux/sensor/dmard06.h b/include/linux/sensor/dmard06.h
new file mode 100644
index 000000000000..9dd5304e9b7c
--- /dev/null
+++ b/include/linux/sensor/dmard06.h
@@ -0,0 +1,159 @@
+/*
+ * @file include/linux/dmard06.h
+ * @brief DMARD06 g-sensor Linux device driver
+ * @author Domintech Technology Co., Ltd (http://www.domintech.com.tw)
+ * @version 1.2
+ * @date 2011/11/14
+ *
+ * @section LICENSE
+ *
+ *  Copyright 2011 Domintech Technology Co., Ltd
+ *
+ * 	This software is licensed under the terms of the GNU General Public
+ * 	License version 2, as published by the Free Software Foundation, and
+ * 	may be copied, distributed, and modified under those terms.
+ *
+ * 	This program is distributed in the hope that it will be useful,
+ * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * 	GNU General Public License for more details.
+ *
+ *
+ */
+#ifndef DMARD05_H
+#define DMARD05_H
+
+#define DEVICE_I2C_NAME "dmard06"
+
+#define DMT_DEBUG_DATA	0
+//#define DMT_DEBUG_DATA 		0
+
+//g-senor layout configuration, choose one of the following configuration
+//#define CONFIG_GSEN_LAYOUT_PAT_1
+//#define CONFIG_GSEN_LAYOUT_PAT_2
+//#define CONFIG_GSEN_LAYOUT_PAT_3
+//#define CONFIG_GSEN_LAYOUT_PAT_4
+#define CONFIG_GSEN_LAYOUT_PAT_5
+//#define CONFIG_GSEN_LAYOUT_PAT_6
+//#define CONFIG_GSEN_LAYOUT_PAT_7
+//#define CONFIG_GSEN_LAYOUT_PAT_8
+
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Z_NEGATIVE 1
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Z_POSITIVE 2
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Y_NEGATIVE 3
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Y_POSITIVE 4
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_X_NEGATIVE 5
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_X_POSITIVE 6
+
+#define AVG_NUM 16
+#define DEFAULT_SENSITIVITY 64
+
+#define X_OUT 		0x41
+#define SW_RESET 	0x53
+#define WHO_AM_I 	0x0f
+#define WHO_AM_I_VALUE 	0x06
+
+#if DMT_DEBUG_DATA
+#define IN_FUNC_MSG printk(KERN_INFO "@DMT@ In %s\n", __func__)
+#define PRINT_X_Y_Z(x, y, z) printk(KERN_INFO "@DMT@ X/Y/Z axis: %04d , %04d , %04d\n", (x), (y), (z))
+#define PRINT_OFFSET(x, y, z) printk(KERN_INFO "@offset@  X/Y/Z axis: %04d , %04d , %04d\n",offset.x,offset.y,offset.z);
+#else
+#define IN_FUNC_MSG
+#define PRINT_X_Y_Z(x, y, z)
+#define PRINT_OFFSET(x, y, z)
+#endif
+
+#define IOCTL_MAGIC  0x09
+#define SENSOR_DATA_SIZE 3                           
+
+#define SENSOR_RESET    		_IO(IOCTL_MAGIC, 0)
+#define SENSOR_CALIBRATION   	_IOWR(IOCTL_MAGIC,  1, int[SENSOR_DATA_SIZE])
+#define SENSOR_GET_OFFSET  		_IOR(IOCTL_MAGIC,  2, int[SENSOR_DATA_SIZE])
+#define SENSOR_SET_OFFSET  		_IOWR(IOCTL_MAGIC,  3, int[SENSOR_DATA_SIZE])
+#define SENSOR_READ_ACCEL_XYZ  	_IOR(IOCTL_MAGIC,  4, int[SENSOR_DATA_SIZE])
+
+#define SENSOR_MAXNR 4
+
+
+#define MMAIO				0xA1
+
+/* IOCTLs for MMA7660 library */
+#define MMA_IOCTL_INIT                  _IO(MMAIO, 0x01)
+#define MMA_IOCTL_RESET      	          _IO(MMAIO, 0x04)
+#define MMA_IOCTL_CLOSE		           _IO(MMAIO, 0x02)
+#define MMA_IOCTL_START		             _IO(MMAIO, 0x03)
+#define MMA_IOCTL_GETDATA               _IOR(MMAIO, 0x08, char[RBUFF_SIZE+1])
+
+/* IOCTLs for APPs */
+#define MMA_IOCTL_APP_SET_RATE		_IOW(MMAIO, 0x10, char)
+
+
+#define DMARD06_RATE_SHIFT  3
+
+#define DMARD06_REG_WHO_AM_I 0x0f
+#define DMARD06_DEVID		0x06
+
+/*status*/
+#define DMARD06_OPEN		   1
+#define DMARD06_CLOSE		   0
+
+#define DMARD06_REG_NORMAL 0x44
+#define DMARD06_REG_MODE 0x45
+#define DMARD06_REG_FLITER 0x46
+#define DMARD06_REG_INT 0x47
+#define DMARD06_REG_NA 0x48
+#define DMARD06_REG_EVENT 0x4a
+#define DMARD06_REG_Threshold 0x4c
+#define DMARD06_REG_Duration 0x4d
+
+#define DMARD06_RATE_1P56 		3
+#define DMARD06_RATE_6P25		2
+#define DMARD06_RATE_12P5 		1
+#define DMARD06_RATE_50		0
+
+#define MMA8452_RATE_1P56  DMARD06_RATE_1P56
+#define MMA8452_RATE_6P25  DMARD06_RATE_6P25
+#define MMA8452_RATE_12P5  DMARD06_RATE_12P5
+#define MMA8452_RATE_50      DMARD06_RATE_50
+
+
+
+#define DMARD06_REG_INTSU   0x47
+
+#define DMARD06_IIC_ADDR		0x38  
+#define DMARD06_GRAVITY_STEP	32
+#define DMARD06_PRECISION		7
+#define DMARD06_BOUNDARY  (0x1 << (DMARD06_PRECISION - 1))
+
+#define DMARD06_REG_X_OUT		0x41
+#define DMARD06_REG_Y_OUT		0x42
+#define DMARD06_REG_Z_OUT		0x43
+
+
+
+
+
+
+
+
+#define RBUFF_SIZE 12
+
+struct dmard06_data {
+	char  status;
+	char  curr_tate;
+	struct input_dev *input_dev;
+	struct i2c_client *client;
+	struct work_struct work;
+	struct delayed_work delaywork;	/*report second event*/
+	unsigned int delay;
+};
+
+struct dmard06_axis {
+	int x;
+	int y;
+	int z;
+};
+
+
+#endif
+
diff --git a/include/linux/sensor/dmt10.h b/include/linux/sensor/dmt10.h
new file mode 100644
index 000000000000..67bfa4c55c16
--- /dev/null
+++ b/include/linux/sensor/dmt10.h
@@ -0,0 +1,174 @@
+/*
+ * @file include/linux/dmt10.h
+ * @brief DMT g-sensor Linux device driver
+ * @author Domintech Technology Co., Ltd (http://www.domintech.com.tw)
+ * @version 1.00
+ * @date 2012/9/21
+ *
+ * @section LICENSE
+ *
+ *  Copyright 2012 Domintech Technology Co., Ltd
+ *
+ * 	This software is licensed under the terms of the GNU General Public
+ * 	License version 2, as published by the Free Software Foundation, and
+ * 	may be copied, distributed, and modified under those terms.
+ *
+ * 	This program is distributed in the hope that it will be useful,
+ * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * 	GNU General Public License for more details.
+ *
+ *
+ */
+#ifndef DMT10_H
+#define DMT10_H
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include <linux/syscalls.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+
+#define AUTO_CALIBRATION	0
+//#define DMT_DEBUG_DATA
+#ifdef DMT_DEBUG_DATA
+#define dmtprintk(x...) printk(x)
+#define INFUN printk(KERN_DEBUG "@DMT@ In %s: %s: %i\n", __FILE__, __func__, __LINE__)
+#define PRINT_X_Y_Z(x, y, z) printk(KERN_INFO "@DMT@ X/Y/Z axis: %04d , %04d , %04d\n", (x), (y), (z))
+#define PRINT_OFFSET(x, y, z) printk(KERN_INFO "@offset@  X/Y/Z axis: %04d , %04d , %04d\n",offset.x,offset.y,offset.z)
+#define DMT_DATA(dev, ...) dev_dbg((dev), ##__VA_ARGS__)
+#else
+#define dmtprintk(x...)
+#define INFUN
+#define PRINT_X_Y_Z(x, y, z)
+#define PRINT_OFFSET(x, y, z)
+#define DMT_DATA(dev, ...)
+#endif
+
+#define INPUT_NAME_ACC			"DMT_accel"	/* Input Device Name  */
+#define DEVICE_I2C_NAME 		"dmard10"		/* Device name for DMARD10 misc. device */
+#define REG_ACTR 				0x00
+#define REG_TAPNS				0x0f
+#define REG_MISC2				0x1f
+#define REG_AFEM 				0x0c
+#define REG_CKSEL 				0x0d
+#define REG_INTC 				0x0e
+#define REG_STADR 				0x12
+#define REG_STAINT 				0x1C
+#define REG_PD					0x21
+#define REG_X_OUT 				0x41
+
+#define MODE_Off				0x00
+#define MODE_ResetAtOff			0x01
+#define MODE_Standby			0x02
+#define MODE_ResetAtStandby		0x03
+#define MODE_Active				0x06
+#define MODE_Trigger			0x0a
+#define MODE_ReadOTP			0x12
+#define MODE_WriteOTP			0x22
+#define MODE_ResetDataPath		0x82
+
+#define VALUE_STADR				0x55
+#define VALUE_STAINT 			0xAA
+#define VALUE_AFEM_AFEN_Normal	0x8f	// AFEN set 1 , ATM[2:0]=b'000(normal),EN_Z/Y/X/T=1
+#define VALUE_AFEM_Normal		0x0f	// AFEN set 0 , ATM[2:0]=b'000(normal),EN_Z/Y/X/T=1
+#define VALUE_INTC				0x00	// INTC[6:5]=b'00 
+#define VALUE_INTC_Interrupt_En	0x20	// INTC[6:5]=b'01 (Data ready interrupt enable, active high at INT0)
+#define VALUE_CKSEL_ODR_0		0x05	// ODR[3:0]=b'0000 (0.78125Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_1		0x15	// ODR[3:0]=b'0001 (1.5625Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_3		0x25	// ODR[3:0]=b'0010 (3.125Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_6		0x35	// ODR[3:0]=b'0011 (6.25Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_12		0x45	// ODR[3:0]=b'0100 (12.5Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_25		0x55	// ODR[3:0]=b'0101 (25Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_50		0x65	// ODR[3:0]=b'0110 (50Hz), CCK[3:0]=b'0000 (102.4kHZ)
+#define VALUE_CKSEL_ODR_100		0x75	// ODR[3:0]=b'0111 (100Hz), CCK[3:0]=b'0101(102.4kHZ)
+#define VALUE_TAPNS_NoFilter	0x00	// TAP1/TAP2	NO FILTER
+#define VALUE_TAPNS_Ave_2		0x11	// TAP1/TAP2	Average 2
+#define VALUE_TAPNS_Ave_4		0x22	// TAP1/TAP2	Average 4
+#define VALUE_TAPNS_Ave_8		0x33	// TAP1/TAP2	Average 8
+#define VALUE_TAPNS_Ave_16		0x44	// TAP1/TAP2	Average 16
+#define VALUE_TAPNS_Ave_32		0x55	// TAP1/TAP2	Average 32
+#define VALUE_MISC2_OSCA_EN		0x08
+#define VALUE_PD_RST			0x52
+
+//g-senor layout configuration, choose one of the following configuration
+/*
+#define CONFIG_GSEN_LAYOUT_PAT_1	1
+#define CONFIG_GSEN_LAYOUT_PAT_2	0
+#define CONFIG_GSEN_LAYOUT_PAT_3	0
+#define CONFIG_GSEN_LAYOUT_PAT_4	0
+#define CONFIG_GSEN_LAYOUT_PAT_5	0
+#define CONFIG_GSEN_LAYOUT_PAT_6	0
+#define CONFIG_GSEN_LAYOUT_PAT_7	0
+#define CONFIG_GSEN_LAYOUT_PAT_8	0
+//*/
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Z_NEGATIVE 1
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Z_POSITIVE 2
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Y_NEGATIVE 3
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_Y_POSITIVE 4
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_X_NEGATIVE 5
+#define CONFIG_GSEN_CALIBRATION_GRAVITY_ON_X_POSITIVE 6
+
+#define AVG_NUM 				16
+#define SENSOR_DATA_SIZE 		3 
+#define DEFAULT_SENSITIVITY 	1024
+
+#define IOCTL_MAGIC  0x09
+#define SENSOR_RESET    		_IO(IOCTL_MAGIC, 0)
+#define SENSOR_CALIBRATION   	_IOWR(IOCTL_MAGIC,  1, int[SENSOR_DATA_SIZE])
+#define SENSOR_GET_OFFSET  		_IOR(IOCTL_MAGIC,  2, int[SENSOR_DATA_SIZE])
+#define SENSOR_SET_OFFSET  		_IOWR(IOCTL_MAGIC,  3, int[SENSOR_DATA_SIZE])
+#define SENSOR_READ_ACCEL_XYZ  	_IOR(IOCTL_MAGIC,  4, int[SENSOR_DATA_SIZE])
+#define SENSOR_SETYPR  			_IOW(IOCTL_MAGIC,  5, int[SENSOR_DATA_SIZE])
+#define SENSOR_GET_OPEN_STATUS	_IO(IOCTL_MAGIC,  6)
+#define SENSOR_GET_CLOSE_STATUS	_IO(IOCTL_MAGIC,  7)
+#define SENSOR_GET_DELAY		_IOR(IOCTL_MAGIC,  8, unsigned int*)
+#define SENSOR_MAXNR 8
+/*
+s16 sensorlayout[3][3] = {
+#if CONFIG_GSEN_LAYOUT_PAT_1
+    { 1, 0, 0},	{ 0, 1,	0}, { 0, 0, 1},
+#elif CONFIG_GSEN_LAYOUT_PAT_2
+    { 0, 1, 0}, {-1, 0,	0}, { 0, 0, 1},
+#elif CONFIG_GSEN_LAYOUT_PAT_3
+    {-1, 0, 0},	{ 0,-1,	0}, { 0, 0, 1},
+#elif CONFIG_GSEN_LAYOUT_PAT_4
+    { 0,-1, 0},	{ 1, 0,	0}, { 0, 0, 1},
+#elif CONFIG_GSEN_LAYOUT_PAT_5
+    {-1, 0, 0},	{ 0, 1,	0}, { 0, 0,-1},
+#elif CONFIG_GSEN_LAYOUT_PAT_6
+    { 0,-1, 0}, {-1, 0,	0}, { 0, 0,-1},
+#elif CONFIG_GSEN_LAYOUT_PAT_7
+    { 1, 0, 0},	{ 0,-1,	0}, { 0, 0,-1},
+#elif CONFIG_GSEN_LAYOUT_PAT_8
+    { 0, 1, 0},	{ 1, 0,	0}, { 0, 0,-1},
+#endif
+};
+//*/
+typedef union {
+	struct {
+		s16	x;
+		s16	y;
+		s16	z;
+	} u;
+	s16	v[SENSOR_DATA_SIZE];
+} raw_data;
+
+struct dev_data {
+	dev_t 					devno;
+	struct cdev 			cdev;
+  	struct class 			*class;
+  	struct input_dev 		*input;
+	struct i2c_client 		*client;
+	struct delayed_work 	delaywork;	//work;
+	struct work_struct 		work;	//irq_work;
+	struct mutex 			DMT_mutex;
+	wait_queue_head_t		open_wq;
+	atomic_t				active;
+	atomic_t 				delay;
+	atomic_t 				enable;
+};
+
+#endif               
diff --git a/include/linux/sensor/elan_interface.h b/include/linux/sensor/elan_interface.h
new file mode 100644
index 000000000000..7a7293bfd749
--- /dev/null
+++ b/include/linux/sensor/elan_interface.h
@@ -0,0 +1,180 @@
+#ifndef __ELAN_TP_H__
+#define __ELAN_TP_H__
+
+#include <linux/input.h>
+
+#define ELAN_LS_6801 "elan-epl6801"
+#define ELAN_LS_6803 "elan-epl6803"
+#define ELAN_LS_6804 "elan-epl6804"
+#define ELAN_LS_6814 "elan_epl6814"
+#define ELAN_LS_6881 "elan-epl6881"
+
+#define ELAN_8232_I2C_NAME "elan-touch"
+#define ELAN_FS_8713 "elan-forcesensor" 
+#define ELAN_EKTF2000_NAME "elan-ektf-touchpad"
+#define ELAN_OFN_8713 "elan-ofn-sensor"
+#define ELAN_TP_1058 "elan-ekt1058-touchpad"
+#define ELAN_TP_2154 "elan-ekt2154-touchpad"
+#define ELAN_USB_FS "elan-usb-fs"
+#define ELAN_USB_COMBO "elan-usb-combo"
+
+#define ELAN_IOCTL_MAGIC 'c'
+#define ELAN_EKT8713_IOCTL_GET_AFLAG _IOR(ELAN_IOCTL_MAGIC, 1, int *)
+#define ELAN_EKT8713_IOCTL_GET_OFLAG _IOR(ELAN_IOCTL_MAGIC, 2, int *)
+#define ELAN_EKT8713_IOCTL_ENABLE_AFLAG _IOW(ELAN_IOCTL_MAGIC, 3, int *)
+#define ELAN_EKT8713_IOCTL_ENABLE_OFLAG _IOW(ELAN_IOCTL_MAGIC, 4, int *)
+#define ELAN_EKT8713_IOCTL_GETDATA _IOR(ELAN_IOCTL_MAGIC, 5, int *)
+
+#define ELAN_EPL6801_IOCTL_GET_PFLAG _IOR(ELAN_IOCTL_MAGIC, 1, int *)
+#define ELAN_EPL6801_IOCTL_GET_LFLAG _IOR(ELAN_IOCTL_MAGIC, 2, int *)
+#define ELAN_EPL6801_IOCTL_ENABLE_PFLAG _IOW(ELAN_IOCTL_MAGIC, 3, int *)
+#define ELAN_EPL6801_IOCTL_ENABLE_LFLAG _IOW(ELAN_IOCTL_MAGIC, 4, int *)
+#define ELAN_EPL6801_IOCTL_GETDATA _IOR(ELAN_IOCTL_MAGIC, 5, int *)
+
+#define ELAN_EPL6800_IOCTL_GET_PFLAG _IOR(ELAN_IOCTL_MAGIC, 1, int *)
+#define ELAN_EPL6800_IOCTL_GET_LFLAG _IOR(ELAN_IOCTL_MAGIC, 2, int *)
+#define ELAN_EPL6800_IOCTL_ENABLE_PFLAG _IOW(ELAN_IOCTL_MAGIC, 3, int *)
+#define ELAN_EPL6800_IOCTL_ENABLE_LFLAG _IOW(ELAN_IOCTL_MAGIC, 4, int *)
+#define ELAN_EPL6800_IOCTL_GETDATA _IOR(ELAN_IOCTL_MAGIC, 5, int *)
+
+/*for epl6801 command */
+#define REG_0			0X00
+#define REG_1			0X01
+#define REG_2			0X02
+#define REG_3			0X03
+#define REG_4			0X04
+#define REG_5			0X05
+#define REG_6			0X06
+#define REG_7			0X07
+#define REG_8			0X08
+#define REG_9			0X09
+#define REG_10			0X0A
+#define REG_11			0X0B
+#define REG_12			0X0C
+#define REG_13			0X0D
+#define REG_14			0X0E
+#define REG_15			0X0F
+#define REG_16			0X10
+#define REG_17			0X11
+#define REG_18			0X12
+#define REG_19			0X13
+#define REG_20			0X14
+#define REG_21			0X15
+
+#define W_SINGLE_BYTE		0X00
+#define W_TWO_BYTE		0X01
+#define W_THREE_BYTE		0X02
+#define W_FOUR_BYTE		0X03
+#define W_FIVE_BYTE		0X04
+#define W_SIX_BYTE		0X05
+#define W_SEVEN_BYTE		0X06
+#define W_EIGHT_BYTE		0X07
+
+#define R_SINGLE_BYTE		0X00
+#define R_TWO_BYTE		0X01
+#define R_THREE_BYTE		0X02
+#define R_FOUR_BYTE		0X03
+#define R_FIVE_BYTE		0X04
+#define R_SIX_BYTE		0X05
+#define R_SEVEN_BYTE		0X06
+#define R_EIGHT_BYTE		0X07
+
+#define EPL_SENSING_1_TIME	(0 << 5) 
+#define EPL_SENSING_2_TIME	(1 << 5)
+#define EPL_SENSING_4_TIME	(2 << 5)
+#define EPL_SENSING_8_TIME	(3 << 5)
+#define EPL_SENSING_16_TIME	(4 << 5)
+#define EPL_SENSING_32_TIME	(5 << 5)
+#define EPL_SENSING_64_TIME	(6 << 5)
+#define EPL_SENSING_128_TIME	(7 << 5)
+#define EPL_C_SENSING_MODE	(0 << 4)
+#define EPL_S_SENSING_MODE	(1 << 4)
+#define EPL_ALS_MODE		(0 << 2)
+#define EPL_PS_MODE		(1 << 2)
+#define EPL_TEMP_MODE 		(2 << 2)
+#define EPL_H_GAIN		(0)
+#define EPL_M_GAIN		(1)
+#define EPL_L_GAIN		(3)
+#define EPL_AUTO_GAIN		(2)
+
+
+#define EPL_8BIT_ADC		0
+#define EPL_10BIT_ADC		1
+#define EPL_12BIT_ADC		2
+#define EPL_14BIT_ADC		3
+
+
+#define EPL_C_RESET				0x00
+#define EPL_C_START_RUN		0x04
+#define EPL_C_P_UP				0x04
+#define EPL_C_P_DOWN			0x06
+#define EPL_DATA_LOCK_ONLY		0x01
+#define EPL_DATA_LOCK			0x05
+#define EPL_DATA_UNLOCK		0x04
+
+#define EPL_GO_MID				0x3E
+#define EPL_GO_LOW				0x3E
+
+
+#define EPL_INT_BINARY			0
+#define EPL_INT_DISABLE			2
+#define EPL_INT_ACTIVE_LOW		3
+#define EPL_INT_FRAME_ENABLE		4
+
+#define EPL_PST_1_TIME		(0 << 2)
+#define EPL_PST_4_TIME		(1 << 2)
+#define EPL_PST_8_TIME		(2 << 2)
+#define EPL_PST_16_TIME		(3 << 2)
+
+
+
+
+
+
+struct elan_forcesensor_platform_data 
+{
+	uint16_t version;
+	int abs_x_min;
+	int abs_x_max;
+	int abs_y_min;
+	int abs_y_max;
+	int intr_gpio;
+	int (*power)(int on);
+};
+
+struct elan_touchpad_platform_Data
+{
+	int trackid_min;
+	int trackid_max;
+	int abs_x_min;
+	int abs_x_max;
+	int abs_y_min;
+	int abs_y_max;
+	int intr_gpio;
+};
+
+
+struct elan_epl_platform_data 
+{
+	int intr_gpio;
+	int (*power)(int on);
+	//int (*power)(int, uint8_t);
+};
+
+
+void elan_fs_set_display_resolution(int width,int height);
+void elan_fs_do_forcesensor(int mode,int x, int y, int z,int ck, struct input_dev *input);
+void elan_fs_HandleEvent(int index,char mode,int dx,int dy,int dz,int ck,struct input_dev *input,int gsensorflag,int *changemodeflag,int *zaxis_forcevalue,int *zaxis_forcewindow_flag);
+
+void elan_tp_set_touchpad_resource(long width,long height);
+void elan_tp_do_touchpad(struct input_dev *input,struct input_dev *input_touch,long currentfingercnt,long* x,long* y);
+void elan_tp_virtualwindow_size(long lefttop_x,long lefttop_y,long rightbottom_x,long rightbottom_y);
+long elan_tp_get_virtualwindow_zoom(void);
+void elan_tp_clear_virtualwindow_zoom(void);
+long elan_tp_EnableTriggerGesture(void);
+long elan_tp_get_changemode(void);
+void elan_tp_clear_changemode(void);
+void elan_tp_initialize(void);
+void elan_tp_setmode(long mode);
+long elan_tp_getmode(void);
+#endif
diff --git a/include/linux/sensor/kionix_accel.h b/include/linux/sensor/kionix_accel.h
new file mode 100644
index 000000000000..7a6467330bcc
--- /dev/null
+++ b/include/linux/sensor/kionix_accel.h
@@ -0,0 +1,84 @@
+/* include/linux/input/kionix_accel.h - Kionix accelerometer driver
+ *
+ * Copyright (C) 2012 Kionix, Inc.
+ * Written by Kuching Tan <kuchingtan@kionix.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __KIONIX_ACCEL_H__
+#define __KIONIX_ACCEL_H__
+
+#define KIONIX_ACCEL_I2C_ADDR		0x0F
+#define KIONIX_ACCEL_NAME			"kionix_accel"
+
+struct kionix_accel_platform_data {
+	/* Although the accelerometer can perform at high ODR,
+	 * there is a need to keep the maximum ODR to a lower
+	 * value due to power consumption or other concern.
+	 * Use this variable to set the minimum allowable
+	 * interval for data to be reported from the
+	 * accelerometer. Unit is measured in milli-
+	 * seconds. Recommended value is 5ms. */
+	unsigned int min_interval;
+	/* Use this variable to set the default interval for
+	 * data to be reported from the accelerometer. This
+	 * value will be used during driver setup process,
+	 * but can be changed by the system during runtime via
+	 * sysfs control. Recommended value is 200ms.*/
+	unsigned int poll_interval;
+
+	/* This variable controls the corresponding direction
+	 * of the accelerometer that is mounted on the board
+	 * of the device. Refer to the porting guide for
+	 * details. Valid value is 1 to 8. */
+	u8 accel_direction;
+
+	/* Use this variable to choose whether or not to use
+	 * DRDY hardware interrupt mode to trigger a data
+	 * report event instead of using software polling.
+	 * Note that for those accelerometer model that does
+	 * not support DRDY hardware interrupt, the driver
+	 * will revert to software polling mode automatically.
+	 * Valid value is 0 or 1.*/
+	bool accel_irq_use_drdy;
+
+	/* Use this variable to control the number of
+	 * effective bits of the accelerometer output.
+	 * Use the macro definition to select the desired
+	 * number of effective bits. */
+	#define KIONIX_ACCEL_RES_12BIT	0
+	#define KIONIX_ACCEL_RES_8BIT	1
+	#define KIONIX_ACCEL_RES_6BIT	2
+	u8 accel_res;
+
+	/* Use this variable to control the G range of
+	 * the accelerometer output. Use the macro definition
+	 * to select the desired G range.*/
+	#define KIONIX_ACCEL_G_2G		0
+	#define KIONIX_ACCEL_G_4G		1
+	#define KIONIX_ACCEL_G_6G		2
+	#define KIONIX_ACCEL_G_8G		3
+	u8 accel_g_range;
+
+	/* Optional callback functions that can be implemented
+	 * on per product basis. If these callbacks are defined,
+	 * they will be called by the driver. */
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+#endif  /* __KXTIK_H__ */
diff --git a/include/linux/sensor/lis3dh.h b/include/linux/sensor/lis3dh.h
new file mode 100644
index 000000000000..a3c1b37a6dce
--- /dev/null
+++ b/include/linux/sensor/lis3dh.h
@@ -0,0 +1,103 @@
+
+/******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+*
+* File Name	: lis3dh_acc_sysfs.h
+* Authors	: MH - C&I BU - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+* Version	: V.1.0.12
+* Date		: 2012/Feb/29
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.10: 2011/Aug/16
+
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+  renamed field g_range to fs_range in lis3dh_acc_platform_data;
+  replaced defines SA0L and SA0H with LIS3DH_SAD0x
+*******************************************************************************/
+
+#ifndef	__LIS3DH_H__
+#define	__LIS3DH_H__
+
+
+#define	LIS3DH_ACC_DEV_NAME		"lis3dh_acc"
+
+#define	LIS3DH_ACC_MIN_POLL_PERIOD_MS	1
+
+
+#ifdef __KERNEL__
+
+#define LIS3DH_SAD0L				(0x00)
+#define LIS3DH_SAD0H				(0x01)
+#define LIS3DH_ACC_I2C_SADROOT		(0x0C)
+
+/* I2C address if acc SA0 pin to GND */
+#define LIS3DH_ACC_I2C_SAD_L		((LIS3DH_ACC_I2C_SADROOT<<1)| \
+						LIS3DH_SAD0L)
+
+/* I2C address if acc SA0 pin to Vdd */
+#define LIS3DH_ACC_I2C_SAD_H		((LIS3DH_ACC_I2C_SADROOT<<1)| \
+						LIS3DH_SAD0H)
+
+#define LIS3DH_ACC_DEFAULT_INT1_GPIO		(-EINVAL)
+#define LIS3DH_ACC_DEFAULT_INT2_GPIO		(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS3DH_ACC_FS_MASK		(0x30)
+#define LIS3DH_ACC_G_2G		(0x00)
+#define LIS3DH_ACC_G_4G		(0x10)
+#define LIS3DH_ACC_G_8G		(0x20)
+#define LIS3DH_ACC_G_16G		(0x30)
+
+struct lis3dh_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LIS3DH_H__ */
+
+
+
diff --git a/include/linux/sensor/lsm303d.h b/include/linux/sensor/lsm303d.h
new file mode 100644
index 000000000000..44899917fdd7
--- /dev/null
+++ b/include/linux/sensor/lsm303d.h
@@ -0,0 +1,128 @@
+/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************
+*
+* File Name          : lsm303d.h
+* Authors            : MSH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+* Version            : V.2.0.1
+* Date               : 2012/May/07
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+Version History.
+
+Revision 2-0-0 2012/05/04
+ first revision
+Revision 2-0-1 2012/05/07
+ New sysfs architecture
+ Support antialiasing filter
+*******************************************************************************/
+
+#ifndef	__LSM303D_H__
+#define	__LSM303D_H__
+
+#define	LSM303D_DEV_NAME	"lsm303d"
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	LSM303D_ACC_FS_MASK	(0x18)
+#define LSM303D_ACC_FS_2G 	(0x00)	/* Full scale 2g */
+#define LSM303D_ACC_FS_4G 	(0x08)	/* Full scale 4g */
+#define LSM303D_ACC_FS_8G 	(0x10)	/* Full scale 8g */
+#define LSM303D_ACC_FS_16G	(0x18)	/* Full scale 16g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define ANTI_ALIASING_773	(0X00)
+#define ANTI_ALIASING_362	(0X40)
+#define ANTI_ALIASING_194	(0X80)
+#define ANTI_ALIASING_50	(0XC0)
+
+/************************************************/
+/* 	Magnetometer section defines	 	*/
+/************************************************/
+
+/* Magnetometer Sensor Full Scale */
+#define LSM303D_MAG_FS_MASK	(0x60)
+#define LSM303D_MAG_FS_2G	(0x00)	/* Full scale 2 gauss */
+#define LSM303D_MAG_FS_4G	(0x20)	/* Full scale 4 gauss */
+#define LSM303D_MAG_FS_8G	(0x40)	/* Full scale 8 gauss */
+#define LSM303D_MAG_FS_12G	(0x60)	/* Full scale 12 gauss */
+
+
+#ifdef	__KERNEL__
+
+#define	LSM303D_ACC_DEV_NAME	"lsm303d_acc"	/* Input file name */
+#define	LSM303D_MAG_DEV_NAME	"lsm303d_mag"	/* Input file name */
+
+#define	LSM303D_ACC_MIN_POLL_PERIOD_US	1
+#define LSM303D_MAG_MIN_POLL_PERIOD_US	5
+
+struct lsm303d_acc_platform_data {
+	
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	u8 aa_filter_bandwidth;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm303d_mag_platform_data {
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm303d_main_platform_data {
+	
+	struct lsm303d_acc_platform_data *pdata_acc;
+	struct lsm303d_acc_platform_data *pdata_mag;
+};
+
+#endif	/* __KERNEL__ */
+#endif	/* __LSM303DC_H__ */
diff --git a/include/linux/sensor/mm3a310.h b/include/linux/sensor/mm3a310.h
new file mode 100644
index 000000000000..d57cf92229a3
--- /dev/null
+++ b/include/linux/sensor/mm3a310.h
@@ -0,0 +1,177 @@
+//$VER$  v1.4.0
+//$TIME$ 2013-08-23-15:33:46
+//$------------------$
+
+
+
+
+
+
+/*
+ *  mm3a310.h - Linux kernel modules for 3-Axis Accelerometer
+ *
+ *  Copyright (C) 2011-2012 MiraMEMS Sensing Technology Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+#ifndef    __MM3A310_H__
+#define    __MM3A310_H__
+
+#include    <linux/ioctl.h>    /* For IOCTL macros */
+#include    <linux/input.h>
+
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+struct mm3a310_cali_s {
+
+    unsigned char x_ok;
+    unsigned short x_off;
+
+    unsigned char y_ok;
+    unsigned short y_off;
+
+    unsigned char z_ok;
+    unsigned short z_off;
+    short           z_dir;
+};
+
+/* Don't change the value or index unless you know what you do */
+
+#define SAD0L                       0x00
+#define SAD0H                       0x01
+#define MM3A310_ACC_I2C_SADROOT     0x0C
+#define MM3A310_ACC_I2C_SAD_L       ((MM3A310_ACC_I2C_SADROOT<<1)|SAD0L)
+#define MM3A310_ACC_I2C_SAD_H       ((MM3A310_ACC_I2C_SADROOT<<1)|SAD0H)
+#define MM3A310_ACC_DEV_NAME        "mm3a310_acc"
+
+#define MM3A310_DRV_NAME    "mm3a310"
+
+#define MM3A310_DRV_ADDR    0x26 /* When SA0=1 then 27. When SA0=0 then 26*/
+
+
+/* SAO pad is connected to GND, set LSB of SAD '0' */
+#define MM3A310_ACC_I2C_ADDR        MM3A310_ACC_I2C_SAD_L
+#define MM3A310_ACC_I2C_NAME        MM3A310_ACC_DEV_NAME
+
+#define MM3A310_RANGE               1000000
+#define MM3A310_PRECISION           12
+#define MM3A310_BOUNDARY            (0x1 << (MM3A310_PRECISION - 1))
+#define MM3A310_GRAVITY_STEP        (MM3A310_RANGE/MM3A310_BOUNDARY)
+
+#ifdef RK3066_ANDROID_4P1
+
+#define MM3A310_ACC_IOCTL_BASE      77
+#define IOCTL_INDEX_BASE            0x80
+
+#define MM3A310_DISABLE 0x7F
+#define MM3A310_ENABLE (1 << 7)
+
+#else
+
+#define MM3A310_ACC_IOCTL_BASE      88
+#define IOCTL_INDEX_BASE            0x00
+
+#endif
+
+/* The following define the IOCTL command values via the ioctl macros */
+#define MM3A310_ACC_IOCTL_SET_DELAY             _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE, int)
+#define MM3A310_ACC_IOCTL_GET_DELAY             _IOR(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+1, int)
+#define MM3A310_ACC_IOCTL_SET_ENABLE            _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+2, int)
+#define MM3A310_ACC_IOCTL_GET_ENABLE            _IOR(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+3, int)
+#define MM3A310_ACC_IOCTL_SET_FULLSCALE         _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+4, int)
+#define MM3A310_ACC_IOCTL_SET_G_RANGE           MM3A310_ACC_IOCTL_SET_FULLSCALE
+#define MM3A310_ACC_IOCTL_GET_G_RANGE           _IOR(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+5, int)
+
+#define MM3A310_ACC_IOCTL_SET_CTRL_REG3         _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+6, int)
+#define MM3A310_ACC_IOCTL_SET_CTRL_REG6         _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+7, int)
+#define MM3A310_ACC_IOCTL_SET_DURATION1         _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+8, int)
+#define MM3A310_ACC_IOCTL_SET_THRESHOLD1        _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+9, int)
+#define MM3A310_ACC_IOCTL_SET_CONFIG1           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+10, int)
+
+#define MM3A310_ACC_IOCTL_SET_DURATION2         _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+11, int)
+#define MM3A310_ACC_IOCTL_SET_THRESHOLD2        _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+12, int)
+#define MM3A310_ACC_IOCTL_SET_CONFIG2           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+13, int)
+
+#define MM3A310_ACC_IOCTL_GET_SOURCE1           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+14, int)
+#define MM3A310_ACC_IOCTL_GET_SOURCE2           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+15, int)
+
+#define MM3A310_ACC_IOCTL_GET_TAP_SOURCE        _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+16, int)
+
+#define MM3A310_ACC_IOCTL_SET_TAP_TW            _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+17, int)
+#define MM3A310_ACC_IOCTL_SET_TAP_CFG           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+18, int)
+#define MM3A310_ACC_IOCTL_SET_TAP_TLIM          _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+19, int)
+#define MM3A310_ACC_IOCTL_SET_TAP_THS           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+20, int)
+#define MM3A310_ACC_IOCTL_SET_TAP_TLAT          _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+21, int)
+
+#define MM3A310_ACC_IOCTL_GET_COOR_XYZ          _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+22, int)
+#define MM3A310_ACC_IOCTL_CALIBRATION           _IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+23, int)
+#define MM3A310_ACC_IOCTL_UPDATE_OFFSET     	_IOW(MM3A310_ACC_IOCTL_BASE, IOCTL_INDEX_BASE+24, int)
+
+
+/* Accelerometer Sensor Full Scale */
+#define MM3A310_ACC_FS_MASK         0x30
+#define MM3A310_ACC_G_2G            0x00
+#define MM3A310_ACC_G_4G            0x10
+#define MM3A310_ACC_G_8G            0x20
+#define MM3A310_ACC_G_16G           0x30
+
+
+/* Accelerometer Sensor Operating Mode */
+#define MM3A310_ACC_ENABLE          0x01
+#define MM3A310_ACC_DISABLE         0x00
+
+//#if defined(CONFIG_MACH_SP6810A)
+#define I2C_BUS_NUM_STATIC_ALLOC
+//#define I2C_STATIC_BUS_NUM        (0)
+//#endif
+
+#ifdef    __KERNEL__
+struct mm3a310_acc_platform_data {
+    int poll_interval;
+    int min_interval;
+
+    u8 g_range;
+
+    u8 axis_map_x;
+    u8 axis_map_y;
+    u8 axis_map_z;
+
+    u8 negate_x;
+    u8 negate_y;
+    u8 negate_z;
+
+    int (*init)(void);
+    void (*exit)(void);
+    int (*power_on)(void);
+    int (*power_off)(void);
+
+    int gpio_int1;
+    int gpio_int2;
+};
+#endif    /* __KERNEL__ */
+
+#define MM3A310_SUCCESS                     0
+#define MM3A310_ERR_I2C                     -1
+#define MM3A310_ERR_STATUS                  -3
+#define MM3A310_ERR_SETUP_FAILURE           -4
+#define MM3A310_ERR_GETGSENSORDATA          -5
+#define MM3A310_ERR_IDENTIFICATION          -6
+
+extern struct acc_hw* mm3a310_get_cust_acc_hw(void);
+#define MM3A310_BUFSIZE                     256
+
+#define MM3A310_DISABLE 0x7F
+#define MM3A310_ENABLE (1 << 7)
+#endif    /* __MM3A310_H__ */
diff --git a/include/linux/sensor/mma8452.h b/include/linux/sensor/mma8452.h
new file mode 100644
index 000000000000..a0336a1d5153
--- /dev/null
+++ b/include/linux/sensor/mma8452.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Definitions for mma8452 accelorometer sensor chip.
+ */
+#ifndef __MMA8452_H__
+#define __MMA8452_H__
+
+#include <linux/ioctl.h>
+
+#define MMA8452_I2C_NAME		"mma8452"
+
+/*
+ * This address comes must match the part# on your target.
+ * Address to the sensor part# support as following list:
+ *   MMA8452	- 0x1C
+ * Please refer to sensor datasheet for detail.
+ */
+#define MMA8452_I2C_ADDR		0x1c
+
+/* MMA8452 register address */
+#define MMA8452_REG_CTRL		0x2a
+#define MMA8452_REG_DATA		0x01
+#define MMA8452_XYZ_DATA_CFG		0x0e
+/* MMA8452 control bit */
+#define MMA8452_CTRL_PWRON_1		0x20	/* acceleration samples 20ms */
+#define MMA8452_CTRL_PWRON_2		0x28	/* acceleration samples 80ms */
+#define MMA8452_CTRL_PWRON_3		0x30	/* acceleration samples 160ms */
+#define MMA8452_CTRL_PWRON_4		0x38	/* acceleration samples 640ms */
+#define MMA8452_CTRL_PWRDN		0x80	/* power donw */
+
+#define MMA8452_CTRL_MODE_2G		0x00
+#define MMA8452_CTRL_MODE_4G		0x01
+#define MMA8452_CTRL_MODE_8G		0x02
+#define MMA8452_CTRL_ACTIVE		0x01	/* ACTIVE */
+
+
+
+/* Use 'm' as magic number */
+#define MMA8452_IOM			'm'
+
+/* IOCTLs for MMA8452 device */
+#define MMA8452_IOC_PWRON		_IO (MMA8452_IOM, 0x00)
+#define MMA8452_IOC_PWRDN		_IO (MMA8452_IOM, 0x01)
+#define MMA8452_IOC_READXYZ		_IOR(MMA8452_IOM, 0x05, int[3])
+#define MMA8452_IOC_READSTATUS		_IOR(MMA8452_IOM, 0x07, int[3])
+#define MMA8452_IOC_SETDETECTION	_IOW(MMA8452_IOM, 0x08, unsigned char)
+
+#endif /* __MMA8452_H__ */
+
diff --git a/include/linux/sensor/mxc622x.h b/include/linux/sensor/mxc622x.h
new file mode 100644
index 000000000000..775b4a67d1cb
--- /dev/null
+++ b/include/linux/sensor/mxc622x.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 MEMSIC, Inc.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+#ifndef	__MXC622X_H__
+#define	__MXC622X_H__
+
+#include	<linux/ioctl.h>	/* For IOCTL macros */
+#include	<linux/input.h>
+
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+#define	MXC622X_ACC_IOCTL_BASE 77
+/** The following define the IOCTL command values via the ioctl macros */
+#define	MXC622X_ACC_IOCTL_SET_DELAY		_IOW(MXC622X_ACC_IOCTL_BASE, 0, int)
+#define	MXC622X_ACC_IOCTL_GET_DELAY		_IOR(MXC622X_ACC_IOCTL_BASE, 1, int)
+#define	MXC622X_ACC_IOCTL_SET_ENABLE	_IOW(MXC622X_ACC_IOCTL_BASE, 2, int)
+#define	MXC622X_ACC_IOCTL_GET_ENABLE	_IOR(MXC622X_ACC_IOCTL_BASE, 3, int)
+#define	MXC622X_ACC_IOCTL_GET_COOR_XYZ  _IOW(MXC622X_ACC_IOCTL_BASE, 22, int)
+#define	MXC622X_ACC_IOCTL_GET_CHIP_ID   _IOR(MXC622X_ACC_IOCTL_BASE, 255, char[32])
+
+/************************************************/
+/* 	Accelerometer defines section	 	*/
+/************************************************/
+#define MXC622X_ACC_DEV_NAME		"mxc622x" /* use miscdevice name */
+#define MXC622X_ACC_INPUT_NAME	"accelerometer" /*  use input report  name */
+#define MXC622X_ACC_I2C_ADDR     	0x15 /* no use */
+#define MXC622X_ACC_I2C_NAME     	MXC622X_ACC_DEV_NAME /*use i2c_driver name*/
+
+/* MXC622X register address */
+#define MXC622X_REG_CTRL		        0x04 /* 0x04 register for control power on or off */
+#define MXC622X_REG_DATA		        0x00 /* 0x00 register for read x,y data*/
+
+/* MXC622X control bit */
+#define MXC622X_CTRL_PWRON		0x00	/* power on */
+#define MXC622X_CTRL_PWRDN		0x80	/* power donw */
+
+#endif	/* __MXC622X_H__ */
diff --git a/include/linux/sensor/sensor_common.h b/include/linux/sensor/sensor_common.h
new file mode 100644
index 000000000000..96c30e73f66f
--- /dev/null
+++ b/include/linux/sensor/sensor_common.h
@@ -0,0 +1,8 @@
+#ifndef SENSOR_COMMON_H
+#define SENSOR_COMMON_H
+
+#include <linux/i2c.h>
+
+int sensor_setup_i2c_dev(struct i2c_board_info *i2c_info, int *i2c_bus_nr, int *gpio);
+
+#endif
diff --git a/include/linux/sensor/stk220x.h b/include/linux/sensor/stk220x.h
new file mode 100644
index 000000000000..c6b5863df1bc
--- /dev/null
+++ b/include/linux/sensor/stk220x.h
@@ -0,0 +1,87 @@
+/*
+ * drivers/i2c/chips/SenseTek/stk220x.h
+ *
+ * $Id: stk_i2c_als.h,v 1.0 2010/08/09 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2010 Patrick Chang <patrick_chang@sitronix.com.tw>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	SenseTek/Sitronix Ambient Light Sensor Driver
+ *	based on stk220x.c
+ */
+
+#ifndef __STK_I2C_ALS220XGENERIC_H
+#define __STK_I2C_ALS220XGENERIC_H
+
+/* Driver Settings */
+#define CONFIG_STK_ALS_CHANGE_THRESHOLD	20
+#define CONFIG_STK_ALS_TRANSMITTANCE	500
+#define CONFIG_STK_SYSFS_DBG
+#define CONFIG_STK_ALS_TRANSMITTANCE_TUNING
+
+
+/* Define Reg Address */
+#define STK_ALS_CMD_REG 0x01
+#define STK_ALS_DT1_REG 0x02
+#define STK_ALS_DT2_REG 0x03
+#define STK_ALS_INT_REG 0x04
+
+
+/* Define CMD */
+#define STK_ALS_CMD_GAIN_SHIFT 6
+#define STK_ALS_CMD_IT_SHIFT 2
+#define STK_ALS_CMD_SD_SHIFT 0
+
+#define STK_ALS_CMD_GAIN(x) ((x)<<STK_ALS_CMD_GAIN_SHIFT)
+#define STK_ALS_CMD_IT(x) ((x)<<STK_ALS_CMD_IT_SHIFT)
+#define STK_ALS_CMD_SD(x) ((x)<<STK_ALS_CMD_SD_SHIFT)
+
+#define STK_ALS_CMD_GAIN_MASK 0xC0
+#define STK_ALS_CMD_IT_MASK 0x0C
+#define STK_ALS_CMD_SD_MASK 0x1
+
+
+/* Define Data */
+#define STK_ALS_DATA(DT1,DT2) ((DT1<<4)|(DT2)>>4)
+
+/*Define Interrupt */
+#define STK_ALS_INT_THD(x) ((x)<<6)
+#define STK_ALS_INT_PRST(x) ((x)<<4)
+#define STK_ALS_INT_FLAG(x) ((x)<<3)
+#define STK_ALS_INT_DN(x) ((x)<<2)
+#define STK_ALS_INT_SFQ(x) ((x)<<1)
+#define STK_ALS_INT_ENF(x) ((x)<<0)
+
+#define STK_ALS_INT_THD_MASK 0xC0
+#define STK_ALS_INT_PRST_MASK 0x30
+#define STK_ALS_INT_FLAG_MASK 0x08
+#define STK_ALS_INT_DN_MASK 0x04
+#define STK_ALS_INT_SFQ_MASK 0x02
+#define STK_ALS_INT_ENF_MASK 0x01
+
+struct stkals_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+#ifdef CONFIG_STK220X_INT_MODE
+    struct work_struct work;
+    int32_t irq;
+	uint8_t enable_als_irq;
+#else	
+	uint8_t bThreadRunning;
+#endif	//#ifdef CONFIG_STK220X_INT_MODE
+	int32_t als_lux_last;
+	uint32_t als_delay;
+};
+#define ALS_MIN_DELAY 250
+
+struct stk220x_platform_data {
+	int32_t als_transmittance;
+	uint8_t als_cmd;
+	int 	int_pin;
+};
+	
+
+#endif /*__STK_I2C_ALS220XGENERIC_H*/
diff --git a/include/linux/sensor/stk8312.h b/include/linux/sensor/stk8312.h
new file mode 100644
index 000000000000..e2671d7cc8ec
--- /dev/null
+++ b/include/linux/sensor/stk8312.h
@@ -0,0 +1,72 @@
+/*
+ *  stk8312.h - Linux kernel driver definition for stk8312 accelerometer
+ *
+ *  Copyright (C) 2011~2013 Lex Hsieh / sensortek <lex_hsieh@sensortek.com.tw>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _STK831X_H_
+#define _STK831X_H_
+
+#include <linux/ioctl.h>
+#define STK831X_I2C_NAME		"stk831x"
+#ifdef STK_ALLWINNER_PLATFORM
+	#define ACC_IDEVICE_NAME		"stk8312"
+#else
+	#define ACC_IDEVICE_NAME		"accelerometer"
+#endif
+#define STKDIR				0x3D
+#define STK_LSB_1G		       21
+/* registers for stk8312 registers */
+
+#define	STK831X_XOUT	0x00	/* x-axis acceleration*/
+#define	STK831X_YOUT	0x01	/* y-axis acceleration*/
+#define	STK831X_ZOUT	0x02	/* z-axis acceleration*/
+#define	STK831X_TILT	 	0x03	/* Tilt Status */
+#define	STK831X_SRST	0x04	/* Sampling Rate Status */
+#define	STK831X_SPCNT	0x05	/* Sleep Count */
+#define	STK831X_INTSU	0x06	/* Interrupt setup*/
+#define	STK831X_MODE	0x07
+#define	STK831X_SR		0x08	/* Sample rate */
+#define	STK831X_PDET	0x09	/* Tap Detection */
+#define	STK831X_DEVID	0x0B	/* Device ID */
+#define	STK831X_OFSX	0x0C	/* X-Axis offset */
+#define	STK831X_OFSY	0x0D	/* Y-Axis offset */
+#define	STK831X_OFSZ	0x0E	/* Z-Axis offset */
+#define	STK831X_PLAT	0x0F	/* Tap Latency */
+#define	STK831X_PWIN	0x10	/* Tap Window */	
+#define	STK831X_FTH		0x11	/* Free-Fall Threshold */
+#define	STK831X_FTM	0x12	/* Free-Fall Time */
+#define	STK831X_STH	0x13	/* Shake Threshold */
+#define	STK831X_CTRL	0x14	/* Control Register */
+#define	STK831X_RESET	0x20	/*software reset*/
+
+/* IOCTLs*/
+#define STK_IOCTL_WRITE				_IOW(STKDIR, 0x01, char[8])
+#define STK_IOCTL_READ				_IOWR(STKDIR, 0x02, char[8])
+#define STK_IOCTL_SET_ENABLE			_IOW(STKDIR, 0x03, char)
+#define STK_IOCTL_GET_ENABLE			_IOR(STKDIR, 0x04, char)
+#define STK_IOCTL_SET_DELAY			_IOW(STKDIR, 0x05, char)
+#define STK_IOCTL_GET_DELAY			_IOR(STKDIR, 0x06, char)
+#define STK_IOCTL_SET_OFFSET			_IOW(STKDIR, 0x07, char[3])
+#define STK_IOCTL_GET_OFFSET			_IOR(STKDIR, 0x08, char[3])
+#define STK_IOCTL_GET_ACCELERATION	_IOR(STKDIR, 0x09, int[3])
+#define STK_IOCTL_SET_RANGE			_IOW(STKDIR, 0x10, char)
+#define STK_IOCTL_GET_RANGE			_IOR(STKDIR, 0x11, char)
+#define STK_IOCTL_SET_CALI			_IOW(STKDIR, 0x12, char)
+
+
+#endif
\ No newline at end of file
diff --git a/include/linux/sensor/stk8313.h b/include/linux/sensor/stk8313.h
new file mode 100644
index 000000000000..2b72ad7df183
--- /dev/null
+++ b/include/linux/sensor/stk8313.h
@@ -0,0 +1,73 @@
+/*
+ *  stk8313.h - Linux kernel driver definition for stk8313 accelerometer
+ *
+ *  Copyright (C) 2011~2013 Lex Hsieh / sensortek <lex_hsieh@sensortek.com.tw>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _STK831X_H_
+#define _STK831X_H_
+
+#include <linux/ioctl.h>
+#define STK831X_I2C_NAME		"stk831x"
+#ifdef STK_ALLWINNER_PLATFORM
+	#define ACC_IDEVICE_NAME		"stk8313"
+#else
+	#define ACC_IDEVICE_NAME		"accelerometer"
+#endif
+#define STKDIR				0x3D
+#define STK_LSB_1G			256
+/* register for stk8313 registers */
+
+#define	STK831X_XOUT	0x00
+#define	STK831X_YOUT	0x02
+#define	STK831X_ZOUT	0x04
+#define	STK831X_TILT		0x06	/* Tilt Status */
+#define	STK831X_SRST	0x07	/* Sampling Rate Status */
+#define	STK831X_SPCNT	0x08	/* Sleep Count */
+#define	STK831X_INTSU	0x09	/* Interrupt setup*/
+#define	STK831X_MODE	0x0A
+#define	STK831X_SR		0x0B	/* Sample rate */
+#define	STK831X_PDET	0x0C	/* Tap Detection */
+#define	STK831X_DEVID	0x0E	/* Device ID */
+#define	STK831X_OFSX	0x0F	/* X-Axis offset */
+#define	STK831X_OFSY	0x10	/* Y-Axis offset */
+#define	STK831X_OFSZ	0x11	/* Z-Axis offset */
+#define	STK831X_PLAT	0x12	/* Tap Latency */
+#define	STK831X_PWIN	0x13	/* Tap Window */	
+#define	STK831X_FTH		0x14	/* Fre	e-Fall Threshold */
+#define	STK831X_FTM	0x15	/* Free-Fall Time */
+#define	STK831X_STH	0x16	/* Shake Threshold */
+#define	STK831X_ISTMP	0x17	/* Interrupt Setup */
+#define 	STK831X_INTMAP	0x18	/*Interrupt Map*/
+#define	STK831X_RESET	0x20	/*software reset*/
+
+/* IOCTLs*/
+#define STK_IOCTL_WRITE				_IOW(STKDIR, 0x01, char[8])
+#define STK_IOCTL_READ				_IOWR(STKDIR, 0x02, char[8])
+#define STK_IOCTL_SET_ENABLE			_IOW(STKDIR, 0x03, char)
+#define STK_IOCTL_GET_ENABLE			_IOR(STKDIR, 0x04, char)
+#define STK_IOCTL_SET_DELAY			_IOW(STKDIR, 0x05, char)
+#define STK_IOCTL_GET_DELAY			_IOR(STKDIR, 0x06, char)
+#define STK_IOCTL_SET_OFFSET			_IOW(STKDIR, 0x07, char[3])
+#define STK_IOCTL_GET_OFFSET			_IOR(STKDIR, 0x08, char[3])
+#define STK_IOCTL_GET_ACCELERATION	_IOR(STKDIR, 0x09, int[3])
+#define STK_IOCTL_SET_RANGE			_IOW(STKDIR, 0x10, char)
+#define STK_IOCTL_GET_RANGE			_IOR(STKDIR, 0x11, char)
+#define STK_IOCTL_SET_CALI			_IOW(STKDIR, 0x12, char)
+
+
+#endif
\ No newline at end of file
diff --git a/include/linux/sensor/stk_defines.h b/include/linux/sensor/stk_defines.h
new file mode 100644
index 000000000000..0b6201e12799
--- /dev/null
+++ b/include/linux/sensor/stk_defines.h
@@ -0,0 +1,50 @@
+/*
+ *
+ * $Id: stk_defines.h,v 1.0 2011/03/05 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2011 Patrick Chang <patrick_chang@sitronix.com.tw>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	SenseTek/Sitronix Proximity / Ambient Light  Sensor Driver
+ */
+
+/*
+-------------------------------------------------------------------------
+	root@android:/sys/devices/platform/stk-oss # ls -al
+	ls -al
+	drwxr-xr-x root     root              1970-01-01 00:00 DBG
+	-rwxrwxrwx root     root         4096 1970-01-01 00:00 als_enable
+	-r--r--r-- root     root         4096 1970-01-02 00:00 dist_mode
+	-r--r--r-- root     root         4096 1970-01-02 00:00 dist_res
+	-rw-rw-rw- root     root         4096 1970-01-02 00:00 distance
+	-r--r--r-- root     root         4096 1970-01-02 00:00 distance_range
+	-rw-rw-rw- root     root         4096 1970-01-02 00:00 lux
+	-r--r--r-- root     root         4096 1970-01-02 00:00 lux_range
+	-r--r--r-- root     root         4096 1970-01-02 00:00 lux_res
+	-rw-rw-rw- root     root         4096 1970-01-02 00:00 ps_cali
+	-rwxrwxrwx root     root         4096 1970-01-01 00:00 ps_enable
+
+-------------------------------------------------------------------------
+*/
+#ifndef __STK_DEFINES_H
+#define __STK_DEFINES_H
+
+#define ALS_NAME "stk220x"
+#define PS_NAME "proximity"
+
+#define ps_enable_path              "/sys/devices/platform/stk-oss/ps_enable"
+#define als_enable_path             "/sys/devices/platform/stk-oss/als_enable"
+#define ps_distance_mode_path       "/sys/devices/platform/stk-oss/dist_mode"
+#define ps_distance_range_path      "/sys/devices/platform/stk-oss/distance_range"
+#define als_lux_range_path          "/sys/devices/platform/stk-oss/lux_range"
+
+#define STK_DRIVER_VER          	"1.74"
+
+
+#define EVENT_TYPE_PROXIMITY        ABS_DISTANCE
+#define EVENT_TYPE_LIGHT            ABS_MISC
+
+#endif // __STK_DEFINE_H
diff --git a/include/linux/sensor/stk_lk_defs.h b/include/linux/sensor/stk_lk_defs.h
new file mode 100644
index 000000000000..060247405ff3
--- /dev/null
+++ b/include/linux/sensor/stk_lk_defs.h
@@ -0,0 +1,56 @@
+/*
+ * drivers/i2c/chips/SenseTek/stk_lk_defs.h
+ * Basic Defines for Linux Kernel Driver
+ *
+ */
+
+#ifndef __STK__LK_DEFS_H
+#define __STK__LK_DEFS_H
+
+#define CONFIG_STK_SHOW_INFO
+
+#define ERR(format, args...) \
+	printk(KERN_ERR "%s: " format, DEVICE_NAME, ## args)
+#define WARNING(format, args...) \
+	printk(KERN_WARNING "%s: " format, DEVICE_NAME, ## args)
+#ifdef CONFIG_STK_SHOW_INFO
+#define INFO(format, args...) \
+	printk(KERN_INFO "%s: " format, DEVICE_NAME, ## args)
+#else
+#define INFO(format,args...)
+#endif
+
+#define __ATTR_BIN(_name,_mode,_read,_write,_size) { \
+	.attr = {.name = __stringify(_name), .mode = _mode },	\
+	.read	= _read,					\
+	.write	= _write,					\
+	.size = _size,                      \
+}
+
+#define __ATTR_BIN_RO(_name,_read,_size) __ATTR_BIN(_name,0444,_read,NULL,_size)
+#ifdef CONFIG_STK_SYSFS_DBG
+#define __ATTR_BIN_RW(_name,_read,_write,_size) __ATTR_BIN(_name,0666,_read,_write,_size)
+#else
+#define __ATTR_BIN_RW(_name,_read,_write,_size) __ATTR_BIN(_name,0644,_read,_write,_size)
+#endif
+
+#ifdef CONFIG_STK_SYSFS_DBG
+#define __ATTR_RW(_name) __ATTR(_name,0666,_name##_show,_name##_store)
+#else
+#define __ATTR_RW(_name) __ATTR(_name,0666,_name##_show,_name##_store)
+#endif
+
+#define STK_LOCK(x) STK_LOCK##x
+
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+#define stk_bin_sysfs_read(name) name##_read(struct file *fptr,struct kobject *kobj, struct bin_attribute *bin_attr,	char * buffer, loff_t offset, size_t count)
+#define stk_bin_sysfs_write(name) name##_write(struct file *fptr,struct kobject *kobj, struct bin_attribute *bin_attr,char * buffer, loff_t offset, size_t count)
+#else
+#define stk_bin_sysfs_read(name) name##_read(struct kobject *kobj, struct bin_attribute *bin_attr,	char * buffer, loff_t offset, size_t count)
+#define stk_bin_sysfs_write(name) name##_write(struct kobject *kobj, struct bin_attribute *bin_attr,char * buffer, loff_t offset, size_t count)
+#endif
+
+
+#endif // __STK__LK_DEFS_H
-- 
2.19.0

