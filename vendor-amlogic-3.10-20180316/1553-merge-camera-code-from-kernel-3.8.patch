From 7acfedec3df67d69906757dfdca5092db8f9515f Mon Sep 17 00:00:00 2001
From: "zhenfei.li" <zhenfei.li@amlogic>
Date: Wed, 30 Oct 2013 18:38:58 +0800
Subject: [PATCH 1553/5965] merge camera code from kernel 3.8

---
 arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd  |    7 +-
 arch/arm/configs/meson8_defconfig             |   11 +
 drivers/amlogic/camera/Kconfig                |    7 -
 drivers/amlogic/camera/common/cam_prober.c    |  263 +++-
 drivers/amlogic/camera/common/config_parser.c |  178 ++-
 drivers/amlogic/camera/common/config_parser.h |   13 +-
 drivers/amlogic/camera/common/plat_ctrl.c     |    2 +-
 drivers/amlogic/camera/common/plat_ctrl.h     |    2 +-
 drivers/amlogic/camera/common/vm.c            |  108 +-
 drivers/amlogic/camera/common/vm.h            |    2 +-
 drivers/amlogic/camera/common/vmapi.h         |    8 +
 drivers/amlogic/camera/gc0307.c               |  116 +-
 drivers/amlogic/camera/gc0308.c               |   43 +-
 drivers/amlogic/camera/gc0328.c               |   38 +-
 drivers/amlogic/camera/gc0329.c               |   92 +-
 drivers/amlogic/camera/gc2015.c               |   62 +-
 drivers/amlogic/camera/gc2035.c               |  121 +-
 drivers/amlogic/camera/gt2005.c               |   63 +-
 drivers/amlogic/camera/hi2056.c               |   21 +-
 drivers/amlogic/camera/hi253.c                |  139 +-
 drivers/amlogic/camera/hi704.c                |   99 +-
 drivers/amlogic/camera/nt99250.c              |  144 +-
 drivers/amlogic/camera/nt99252.c              |  222 +--
 drivers/amlogic/camera/nt99340.c              |  215 +--
 drivers/amlogic/camera/ov2655.c               |  233 ++-
 drivers/amlogic/camera/ov3660.c               |   85 +-
 drivers/amlogic/camera/ov5640.c               | 1352 ++++++++++++++++-
 drivers/amlogic/camera/ov5642.c               |  101 +-
 drivers/amlogic/camera/ov5647.c               |  336 ++--
 drivers/amlogic/camera/ov7675.c               |   64 +-
 drivers/amlogic/camera/sp0838.c               |  140 +-
 drivers/amlogic/camera/sp2518.c               |  122 +-
 drivers/i2c/i2c-core.c                        |   60 +
 include/linux/amlogic/camera/aml_cam_info.h   |   19 +-
 include/linux/amlogic/camera/flashlight.h     |   28 +
 include/linux/amlogic/tvin/tvin_v4l2.h        |    8 +
 include/media/v4l2-chip-ident.h               |   45 +
 37 files changed, 2965 insertions(+), 1604 deletions(-)
 mode change 100644 => 100755 drivers/i2c/i2c-core.c
 create mode 100755 include/linux/amlogic/camera/flashlight.h
 mode change 100644 => 100755 include/media/v4l2-chip-ident.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
index 22423e74f630..89a12dfcf9d7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
@@ -77,8 +77,8 @@ void root_func(){
 	memory{
 		device_type = "memory";
 		aml_reserved_start = <0x05000000>; /**reserved memory start */
-		aml_reserved_end = <0x173fffff>;/**reserved memory end */
-		linux,usable-memory = <0x00000000 0x04000000 0x17400000 0x28c00000>;
+		aml_reserved_end = <0x187fffff>;/**reserved memory end */
+		linux,usable-memory = <0x00000000 0x04000000 0x18800000 0x27800000>;
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -245,7 +245,8 @@ void root_func(){
     vm{
 		compatible = "amlogic,vm";
 		dev_name = "vm.0";
-		status = "okay";
+		//status = "okay";
+		reg = <0x17400000 0x01400000>;
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index d9f03b4d9f9f..4c69a3cb9cb1 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -255,3 +255,14 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
 CONFIG_AVERAGE=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE=y
+CONFIG_AMLOGIC_CAPTURE_FRAME_ROTATE=y
+CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0308=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0328=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GC2035=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GT2005=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5640=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5647=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_HI253=y
+CONFIG_TVIN_ISP=y
diff --git a/drivers/amlogic/camera/Kconfig b/drivers/amlogic/camera/Kconfig
index 39a9e799f1aa..f61d85acee3e 100755
--- a/drivers/amlogic/camera/Kconfig
+++ b/drivers/amlogic/camera/Kconfig
@@ -42,13 +42,6 @@ config AMLCAP_LOG_TIME_USEFORFRAMES
 	---help---
 	  Print out the time used for process a frame, only for developers.
 
-config VIDEO_AMLOGIC_FLASHLIGHT
-	tristate "Amlogic Platform Flashlight Driver"
-	depends on VIDEO_AMLOGIC_CAPTURE
-	default n
-	---help---
-	  Amlogic flashlight driver.
-	  Say Y here if you want this driver.
 config VIDEO_AMLOGIC_CAPTURE_GT2005
 	tristate "Amlogic Platform Capture Driver for GT2005"
 	depends on VIDEO_AMLOGIC_CAPTURE
diff --git a/drivers/amlogic/camera/common/cam_prober.c b/drivers/amlogic/camera/common/cam_prober.c
index efa12d9db53d..6a328e91d0b7 100755
--- a/drivers/amlogic/camera/common/cam_prober.c
+++ b/drivers/amlogic/camera/common/cam_prober.c
@@ -28,7 +28,7 @@
 //extern int amlogic_gpio_name_map_num(const char *name);
 //extern int32_t gpio_out(uint32_t pin,bool high);
 
-static int __init aml_camera_read_buff(struct i2c_adapter *adapter, 
+static int aml_camera_read_buff(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, char *buf, int addr_len, int data_len)
 {
 	int  i2c_flag = -1;
@@ -51,7 +51,7 @@ static int __init aml_camera_read_buff(struct i2c_adapter *adapter,
 	return i2c_flag;
 }
 
-static int __init aml_camera_write_buff(struct i2c_adapter *adapter, 
+static int aml_camera_write_buff(struct i2c_adapter *adapter, 
 				unsigned short dev_addr, char *buf, int len)
 {
 	struct i2c_msg msg[] = {
@@ -69,7 +69,7 @@ static int __init aml_camera_write_buff(struct i2c_adapter *adapter,
 		return 0;
 }
 
-static int __init aml_i2c_get_byte(struct i2c_adapter *adapter, 
+static int aml_i2c_get_byte(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr)
 {
 	unsigned char buff[4];
@@ -81,7 +81,7 @@ static int __init aml_i2c_get_byte(struct i2c_adapter *adapter,
 	return buff[0];
 }
 
-static int __init aml_i2c_get_byte_add8(struct i2c_adapter *adapter, 
+static int aml_i2c_get_byte_add8(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr)
 {
 	unsigned char buff[4];
@@ -92,7 +92,7 @@ static int __init aml_i2c_get_byte_add8(struct i2c_adapter *adapter,
 	return buff[0];
 }
 
-static int __init aml_i2c_put_byte(struct i2c_adapter *adapter, 
+static int aml_i2c_put_byte(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr, unsigned char data)
 {
 	unsigned char buff[4];
@@ -104,7 +104,7 @@ static int __init aml_i2c_put_byte(struct i2c_adapter *adapter,
 	return  0;
 }
 
-static int __init aml_i2c_put_word(struct i2c_adapter *adapter, 
+/*static int aml_i2c_put_word(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr, unsigned short data)
 {
 	unsigned char buff[4];
@@ -115,9 +115,9 @@ static int __init aml_i2c_put_word(struct i2c_adapter *adapter,
 	if (aml_camera_write_buff(adapter, dev_addr, buff, 4) <0)
 		return -1;
 	return 0;
-}
+}*/
 
-static int __init aml_i2c_put_byte_add8(struct i2c_adapter *adapter, 
+static int aml_i2c_put_byte_add8(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned char addr, unsigned char data)
 {
 	unsigned char buff[4];
@@ -133,7 +133,7 @@ i2c_new_existing_device(struct i2c_adapter *adap,
 			struct i2c_board_info const *info);
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0307
-int __init gc0307_v4l2_probe(struct i2c_adapter *adapter)
+int gc0307_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;  
@@ -145,7 +145,7 @@ int __init gc0307_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0308
-int __init gc0308_v4l2_probe(struct i2c_adapter *adapter)
+int gc0308_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;   
@@ -157,7 +157,7 @@ int __init gc0308_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0328
-int __init gc0328_v4l2_probe(struct i2c_adapter *adapter)
+int gc0328_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;   
@@ -169,7 +169,7 @@ int __init gc0328_v4l2_probe(struct i2c_adapter *adapter)
 #endif 
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0329
-int __init gc0329_v4l2_probe(struct i2c_adapter *adapter)
+int gc0329_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;  
@@ -182,7 +182,7 @@ int __init gc0329_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC2015
-int __init gc2015_v4l2_probe(struct i2c_adapter *adapter)
+int gc2015_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];  
@@ -195,7 +195,7 @@ int __init gc2015_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC2035
-int __init gc2035_v4l2_probe(struct i2c_adapter *adapter)
+int gc2035_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];  
@@ -208,7 +208,7 @@ int __init gc2035_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GT2005
-int __init gt2005_v4l2_probe(struct i2c_adapter *adapter)
+int gt2005_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];
@@ -221,7 +221,7 @@ int __init gt2005_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV2659
-int __init ov2659_v4l2_probe(struct i2c_adapter *adapter)
+int ov2659_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];   
@@ -234,7 +234,7 @@ int __init ov2659_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV3640
-int __init ov3640_v4l2_probe(struct i2c_adapter *adapter)
+int ov3640_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];  
@@ -247,7 +247,7 @@ int __init ov3640_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV3660
-int __init ov3660_v4l2_probe(struct i2c_adapter *adapter)
+int ov3660_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];  
@@ -260,7 +260,7 @@ int __init ov3660_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5640
-int __init ov5640_v4l2_probe(struct i2c_adapter *adapter)
+int ov5640_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];   
@@ -273,7 +273,7 @@ int __init ov5640_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5642
-int __init ov5642_v4l2_probe(struct i2c_adapter *adapter)
+int ov5642_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];  
@@ -286,7 +286,7 @@ int __init ov5642_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV7675
-int __init ov7675_v4l2_probe(struct i2c_adapter *adapter)
+int ov7675_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];   
@@ -299,11 +299,11 @@ int __init ov7675_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_SP0838
-int __init sp0838_v4l2_probe(struct i2c_adapter *adapter)
+int sp0838_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;    
-	reg = aml_i2c_get_byte_add8(adapter, 0x30, 0x02);
+	reg = aml_i2c_get_byte_add8(adapter, 0x18, 0x02);
 	if (reg == 0x27)
 		ret = 1;
 	return ret;
@@ -311,7 +311,7 @@ int __init sp0838_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_HI253
-int __init hi253_v4l2_probe(struct i2c_adapter *adapter)
+int hi253_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;   
@@ -323,7 +323,7 @@ int __init hi253_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_HM5065
-int __init hm5065_v4l2_probe(struct i2c_adapter *adapter)
+int hm5065_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];   
@@ -336,7 +336,7 @@ int __init hm5065_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_HI2056
-int __init hi2056_v4l2_probe(struct i2c_adapter *adapter)
+int hi2056_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg;   
@@ -349,9 +349,9 @@ int __init hi2056_v4l2_probe(struct i2c_adapter *adapter)
 #endif
 
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5647
-int __init ov5647_v4l2_probe(struct i2c_adapter *adapter)
+int ov5647_v4l2_probe(struct i2c_adapter *adapter)
 {
-  int ret = 0;
+ 	int ret = 0;
 	unsigned char reg[2];  
 	reg[0] = aml_i2c_get_byte(adapter, 0x36, 0x300a);
 	reg[1] = aml_i2c_get_byte(adapter, 0x36, 0x300b);
@@ -371,7 +371,7 @@ typedef struct {
 	aml_cam_probe_fun_t probe_func;
 }aml_cam_dev_info_t;
 
-static aml_cam_dev_info_t __initdata cam_devs[] = {
+static aml_cam_dev_info_t cam_devs[] = {
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0307
 	{
 		.addr = 0x21,
@@ -500,7 +500,7 @@ static aml_cam_dev_info_t __initdata cam_devs[] = {
 #endif
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_SP0838
 	{
-		.addr = 0x30,
+		.addr = 0x18,
 		.name = "sp0838",
 		.pwdn = 1,
 		.max_cap_size = SIZE_640X480,
@@ -536,7 +536,7 @@ static aml_cam_dev_info_t __initdata cam_devs[] = {
 #endif
 };
 
-static aml_cam_dev_info_t* get_cam_info_by_name(char* name)
+static aml_cam_dev_info_t* get_cam_info_by_name(const char* name)
 {
 	int i;
 	if (!name)
@@ -602,7 +602,7 @@ struct res_item res_item_array[] = {
 };
 
 
-static resulution_size_t get_res_size(char* res_str)
+static resulution_size_t get_res_size(const char* res_str)
 {
 	resulution_size_t ret = SIZE_NULL;
 	struct res_item* item;
@@ -654,13 +654,14 @@ static struct platform_device* cam_pdev = NULL;
 
 void aml_cam_init(aml_cam_info_t* cam_dev)
 {
+	 struct pinctrl* pin_ctrl;
 	//pinmux_set;
 	if (cam_dev->bt_path == BT_PATH_GPIO)
-		pinctrl_get_select(&cam_pdev->dev, "gpio");
+		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "gpio");
 	else if (cam_dev->bt_path == BT_PATH_CSI2)
-		pinctrl_get_select(&cam_pdev->dev, "csi");
+		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "csi");
 	else
-		pinctrl_get_select(&cam_pdev->dev, "gpio");
+		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "gpio");
 
 	//select XTAL as camera clock
 	cam_enable_clk();
@@ -713,7 +714,7 @@ void aml_cam_flash(aml_cam_info_t* cam_dev, int is_on)
 	}
 }
 
-static struct list_head __initdata cam_head = LIST_HEAD_INIT(cam_head);
+static struct list_head cam_head = LIST_HEAD_INIT(cam_head);
 
 #define DEBUG_DUMP_CAM_INFO
 
@@ -824,7 +825,7 @@ static int fill_cam_dev(struct device_node* p_node, aml_cam_info_t* cam_dev)
 		printk("failed to read bt_path\n");
 		cam_dev->bt_path = BT_PATH_GPIO;
 	} else {
-		printk("bt_path :%s\n", cam_dev->bt_path);
+		printk("bt_path :%s\n", (char*)cam_dev->bt_path);
 		if (strncmp("csi", str, 3) == 0) 
 			cam_dev->bt_path = BT_PATH_CSI2;
 		else
@@ -862,6 +863,175 @@ err_out:
 	return ret;	
 }
 
+static int  do_read_work(char argn ,char **argv)
+{
+	unsigned int dev_addr, reg_addr, result;     
+	unsigned int i2c_bus;    
+	struct i2c_adapter *adapter;   
+
+	if (argn < 4){
+		printk("args num error");
+		return -1;
+	}
+	
+	
+	if (!strncmp(argv[1], "i2c_bus_ao", 9))
+		i2c_bus = AML_I2C_MASTER_AO;
+	else if (!strncmp(argv[1], "i2c_bus_a", 9))
+		i2c_bus = AML_I2C_MASTER_A;
+	else if (!strncmp(argv[1], "i2c_bus_b", 9))
+		i2c_bus = AML_I2C_MASTER_B;
+	else if (!strncmp(argv[1], "i2c_bus_c", 9))
+		i2c_bus = AML_I2C_MASTER_C;
+	else if (!strncmp(argv[1], "i2c_bus_d", 9))
+		i2c_bus = AML_I2C_MASTER_D;
+	else {
+		printk("bus name error!\n");
+		return -1;
+	}
+	
+        adapter = i2c_get_adapter(i2c_bus);
+        
+        if (adapter == NULL) {
+        	printk("no adapter!\n");
+		return -1;
+	}
+        
+	dev_addr = simple_strtol(argv[2],NULL,16);
+	reg_addr = simple_strtol(argv[3],NULL,16);
+	
+	
+	if (reg_addr > 256) {
+		result = aml_i2c_get_byte(adapter, dev_addr, reg_addr);
+		printk("register [0x%04x]=0x%02x\n", reg_addr, result);
+	} else {
+		result = aml_i2c_get_byte_add8(adapter, dev_addr, reg_addr);
+		printk("register [0x%02x]=0x%02x\n", reg_addr, result);
+	}
+		
+	return 0;
+}
+
+static int do_write_work(char argn ,char **argv)
+{
+	unsigned int dev_addr, reg_addr, reg_val, ret = 0;     
+	unsigned int i2c_bus;    
+	struct i2c_adapter *adapter;   
+
+
+	/*if (argn < 5){
+		printk("args num error");
+		return -1;
+	}*/
+	
+	if (!strncmp(argv[1], "i2c_bus_ao", 9))
+		i2c_bus = AML_I2C_MASTER_AO;
+	else if (!strncmp(argv[1], "i2c_bus_a", 9))
+		i2c_bus = AML_I2C_MASTER_A;
+	else if (!strncmp(argv[1], "i2c_bus_b", 9))
+		i2c_bus = AML_I2C_MASTER_B;
+	else if (!strncmp(argv[1], "i2c_bus_c", 9))
+		i2c_bus = AML_I2C_MASTER_C;
+	else if (!strncmp(argv[1], "i2c_bus_d", 9))
+		i2c_bus = AML_I2C_MASTER_D;
+	else {
+		printk("bus name error!\n");
+		return -1;
+	}
+	
+        adapter = i2c_get_adapter(i2c_bus);
+        
+        if (adapter == NULL) {
+        	printk("no adapter!\n");
+		return -1;
+	}
+        
+	dev_addr = simple_strtol(argv[2],NULL,16);
+	reg_addr = simple_strtol(argv[3],NULL,16);
+	reg_val = simple_strtol(argv[4],NULL,16);
+	if (reg_addr > 256) {
+		if(aml_i2c_put_byte(adapter, dev_addr, reg_addr, reg_val) < 0) {
+			printk("write error\n");
+			ret = -1;
+		} else {
+			printk("write ok\n");
+			ret = 0;
+		}
+		
+	} else {
+		if (aml_i2c_put_byte_add8(adapter, dev_addr, reg_addr, reg_val) < 0){
+			printk("write error\n");
+			ret = -1;
+		} else {
+			printk("write ok\n");
+			ret = 0;
+		}
+	}
+		
+	return ret;
+}
+
+static struct class* cam_clsp;
+
+
+static ssize_t show_help(struct class* class, struct class_attribute* attr,
+	char* buf)
+{
+	ssize_t size = 0;
+	printk( "echo [read | write] i2c_bus_type device_address register_address [value] > i2c_debug\n"
+		"i2c_bus_type are: i2c_bus_ao, i2c_bus_a, i2c_bus_b, i2c_bus_c, i2c_bus_d\n"
+		"e.g.: echo read i2c_bus_ao 0x3c 0x18\n"
+		"      echo write i2c_bus_ao 0x3c 0x18 0x24\n");
+	return size;
+}
+
+static ssize_t store_i2c_debug(struct class* class, struct class_attribute* attr,
+   const char* buf, size_t count )
+{
+	int argn;
+	char * buf_work,*p,*para;
+	char cmd;
+	char * argv[4];
+	
+	buf_work = kstrdup(buf, GFP_KERNEL);
+	p = buf_work;
+	
+	for(argn = 0; argn < 5; argn++){
+		para = strsep(&p," ");
+		if(para == NULL)
+			break;
+		argv[argn] = para;
+		//printk("argv[%d] = %s\n",argn,para);
+	}
+	
+	if(argn < 4 || argn > 5)
+		goto end;
+		
+	cmd = argv[0][0];
+	switch (cmd){
+	case 'r':
+	case 'R':
+		do_read_work(argn,argv);
+		break;
+	case 'w':
+	case 'W':
+		do_write_work(argn,argv);
+		break;
+	}
+	return count;
+end:
+	printk("error command!\n");
+	kfree(buf_work);
+	return -EINVAL;	
+}
+
+
+static struct class_attribute aml_cam_attrs[]={
+	__ATTR(i2c_debug,  S_IRUGO | S_IWUSR, show_help, store_i2c_debug),
+	__ATTR(help,  S_IRUGO | S_IWUSR, show_help, NULL),
+	__ATTR_NULL,
+};
+
 static int aml_cams_probe(struct platform_device *pdev)
 {
 	//printk("##############aml_cams_probe start############\n");
@@ -870,6 +1040,7 @@ static int aml_cams_probe(struct platform_device *pdev)
 	struct device_node* child;
 	struct i2c_board_info board_info;
 	struct i2c_adapter *adapter;
+	int i;
 	aml_cam_info_t temp_cam;
 	cam_pdev = pdev;
 	for_each_child_of_node(cams_node, child) {
@@ -895,13 +1066,18 @@ static int aml_cams_probe(struct platform_device *pdev)
 		printk("new i2c device\n");
 		i2c_new_existing_device(adapter, &board_info);	
 	}
-	printk("aml probe finish\n");
+	//printk("aml probe finish\n");
+	cam_clsp = class_create(THIS_MODULE, "aml_camera");
+	for(i = 0; aml_cam_attrs[i].attr.name; i++){
+		if(class_create_file(cam_clsp, &aml_cam_attrs[i]) < 0)
+			return -1;
+	}
 	return 0;
 }
 
 static int aml_cams_remove(struct platform_device *pdev)
 {
-
+	return 0;
 }
 
 static const struct of_device_id cams_prober_dt_match[]={
@@ -923,15 +1099,12 @@ static  struct platform_driver aml_cams_prober_driver = {
 
 static int __init aml_cams_prober_init(void)
 {
-	int ret;
-
-	ret = platform_driver_register(&aml_cams_prober_driver);
-	if (ret){
+	if (platform_driver_register(&aml_cams_prober_driver)){
 		printk(KERN_ERR"aml_cams_probre_driver register failed\n");
-		return ret;
+		return -ENODEV;
 	}
 
-	return ret;
+	return 0;
 }
 
 static void __exit aml_cams_prober_exit(void)
diff --git a/drivers/amlogic/camera/common/config_parser.c b/drivers/amlogic/camera/common/config_parser.c
index 30b79618179c..5938466f48e7 100755
--- a/drivers/amlogic/camera/common/config_parser.c
+++ b/drivers/amlogic/camera/common/config_parser.c
@@ -19,6 +19,7 @@ char *scenes_key = "scenes_start";
 char *wb_key = "wb_start";
 char *wave_key = "wave_start";
 char *lenc_key = "lenc_start";
+char *gamma_key = "gamma_start";
 
 typedef struct{
 	char *buffer;
@@ -823,6 +824,41 @@ int parse_lenc(buffer_para_t *buf_para,int *remained,int *offset){
      return 0;
 }
 
+int parse_gamma(buffer_para_t *buf_para,int *remained,int *offset){
+    int i;
+    char *iter;
+
+    iter = search_string(buf_para,offset,remained,"gamma_start","gamma_end");
+    if(iter == NULL){
+        return -WRONG_FORMAT;
+    }
+    /***parser head***/
+    iter = strstr(iter,"export");
+    iter += 7;
+    for(i=0;i<GAMMA_MAX;i++){
+        sscanf(iter,"%x",&(cf->gamma.gamma_r[i]));
+        iter = strstr(iter,",");
+        if(iter == NULL)
+            break;
+        iter += 1;
+    }
+    for(i=0;i<GAMMA_MAX;i++){
+        sscanf(iter,"%x",&(cf->gamma.gamma_g[i]));
+        iter = strstr(iter,",");
+        if(iter == NULL)
+            break;
+        iter += 1;
+    }
+    for(i=0;i<GAMMA_MAX;i++){
+        sscanf(iter,"%x",&(cf->gamma.gamma_b[i]));
+        iter = strstr(iter,",");
+        if(iter == NULL)
+            break;
+        iter += 1;
+    }
+    return 0;
+}
+
 int parse_config(char *path){
     char *buffer,*iter;
     int file_size;
@@ -951,7 +987,7 @@ int parse_config(char *path){
                     buf_para.data_start += strlen(capture_key);
                 }
                 break;		
-						case 'l':
+            case 'l':
                 if(memcmp(iter,lenc_key,strlen(lenc_key)) == 0){
                     cf->lenc_valid = 1;
                     if((ret = parse_lenc(&buf_para,&remained_size,&read_offset)) != 0){
@@ -962,6 +998,17 @@ int parse_config(char *path){
                     buf_para.data_start += strlen(lenc_key);
                 }
                 break;
+            case 'g':
+                if(memcmp(iter,gamma_key,strlen(gamma_key)) == 0){
+                    cf->gamma_valid = 1;
+                    if((ret = parse_gamma(&buf_para,&remained_size,&read_offset)) != 0){
+                        cf->gamma_valid = 0;
+                        printk("gamma invalid :%d\n",ret);									
+                    }
+                }else{
+                    buf_para.data_start += strlen(gamma_key);
+                }
+                break;             
             default:
                 buf_para.data_start += 1;
                 break;		
@@ -1065,19 +1112,18 @@ int generate_para(cam_parameter_t *para,para_index_t pindex){
     xml_wb_manual_t *wb;
     xml_capture_t *capture;
     wave_t *wave;
-    
-   	//memset(para,0,sizeof(*para));
+
     /**init callback func**/
     para->cam_function.set_af_new_step = NULL;
     if(cf->aet_valid == 1){
-	    para->cam_function.get_aet_current_step = get_aet_current_step;
-	    para->cam_function.get_aet_max_step = get_aet_max_step;
-	    para->cam_function.get_aet_current_gain = get_aet_current_gain;
-	    para->cam_function.get_aet_min_gain = get_aet_min_gain;
-	    para->cam_function.get_aet_max_gain = get_aet_max_gain;
-	    para->cam_function.get_aet_gain_by_step = get_aet_new_gain;
-
-   }
+        para->cam_function.get_aet_current_step = get_aet_current_step;
+        para->cam_function.get_aet_max_step = get_aet_max_step;
+        para->cam_function.get_aet_current_gain = get_aet_current_gain;
+        para->cam_function.get_aet_min_gain = get_aet_min_gain;
+        para->cam_function.get_aet_max_gain = get_aet_max_gain;
+        para->cam_function.get_aet_gain_by_step = get_aet_new_gain;
+
+    }
     /**init scenes**/
     if(cf->scene_valid == 1){
         if((para->xml_scenes = kmalloc(sizeof(xml_scenes_t),0)) == NULL){
@@ -1092,37 +1138,51 @@ int generate_para(cam_parameter_t *para,para_index_t pindex){
         para->xml_scenes = NULL;
     }
 
-     /**init hw**/
+    /**init hw**/
     if(cf->hw_valid == 1){
-    	if((para->xml_regs_map = kmalloc(sizeof(xml_default_regs_t),0)) == NULL){
-    		printk("alloc mem failed\n");
-    		return 	-ENOMEM;
-    	}
-	    reg = para->xml_regs_map;
-	    init_hw_para(reg);
-	    for(i = 0; i < cf->hw.sum; i++){
-	        if((strcmp(hw_para[i].name,cf->hw.hw[i].name)) == 0){
-	            for(j = 0; j < hw_para[i].size; j++){
-	                hw_para[i].array[j] = cf->hw.hw[i].export[j];
-	            }
-	        }				
-	    }
-	   
-  }else{
-      para->xml_regs_map = NULL;
-  }
-  /** init lenc **/
-  if(cf->lenc_valid == 1){
-  	if(para->xml_regs_map == NULL){
-    	if((para->xml_regs_map = kmalloc(sizeof(xml_default_regs_t),0)) == NULL){
-    		printk("alloc mem failed\n");
-    		return 	-ENOMEM;
-    	}
+        if((para->xml_regs_map = kmalloc(sizeof(xml_default_regs_t),0)) == NULL){
+            printk("alloc mem failed\n");
+            return 	-ENOMEM;
+        }
+        reg = para->xml_regs_map;
+        init_hw_para(reg);
+        for(i = 0; i < cf->hw.sum; i++){
+            if((strcmp(hw_para[i].name,cf->hw.hw[i].name)) == 0){
+                for(j = 0; j < hw_para[i].size; j++){
+                    hw_para[i].array[j] = cf->hw.hw[i].export[j];
+                }
+            }				
+        }
+
+    }else{
+        para->xml_regs_map = NULL;
     }
-	  reg = para->xml_regs_map;
-	  memcpy(reg->lnsd.reg_map,cf->lenc.export,1024*sizeof(unsigned int));
-	   
-  }
+    /** init lenc **/
+    if(cf->lenc_valid == 1){
+        if(para->xml_regs_map == NULL){
+            if((para->xml_regs_map = kmalloc(sizeof(xml_default_regs_t),0)) == NULL){
+                printk("alloc mem failed\n");
+                return 	-ENOMEM;
+            }
+        }
+        reg = para->xml_regs_map;
+        memcpy(reg->lnsd.reg_map,cf->lenc.export,1024*sizeof(unsigned int));
+
+    }
+
+    /** init lenc **/
+    if(cf->gamma_valid == 1){
+        if(para->xml_regs_map == NULL){
+            if((para->xml_regs_map = kmalloc(sizeof(xml_default_regs_t),0)) == NULL){
+                printk("alloc mem failed\n");
+                return 	-ENOMEM;
+            }
+        }
+        reg = para->xml_regs_map;
+        memcpy(reg->lut_gc.gamma_r,cf->gamma.gamma_r,GAMMA_MAX*sizeof(unsigned short));
+        memcpy(reg->lut_gc.gamma_g,cf->gamma.gamma_g,GAMMA_MAX*sizeof(unsigned short));
+        memcpy(reg->lut_gc.gamma_b,cf->gamma.gamma_b,GAMMA_MAX*sizeof(unsigned short)); 
+    } 
     /**init effect**/
     if(cf->effect_valid == 1){
         if((para->xml_effect_manual = kmalloc(sizeof(xml_effect_manual_t),0)) == NULL){
@@ -1145,25 +1205,25 @@ int generate_para(cam_parameter_t *para,para_index_t pindex){
     }else{
         para->xml_wb_manual = NULL;
     }
-    
+
     /**init capture**/
-     if(cf->capture_valid == 1){
-  		if((para->xml_capture = kmalloc(sizeof(xml_capture_t),0)) == NULL){
-	  		printk("alloc mem failed\n");
-	  		return 	-ENOMEM;
-    	}
-    	capture = para->xml_capture;
-    	capture->ae_en = (unsigned int)(cf->capture.capture[pindex.capture_index].export[0]);
-    	capture->awb_en = (unsigned int)(cf->capture.capture[pindex.capture_index].export[1]);
-    	capture->af_mode = (cam_scanmode_t)(cf->capture.capture[pindex.capture_index].export[2]);
-    	capture->sigle_count = (unsigned int)(cf->capture.capture[pindex.capture_index].export[3]);
-    	capture->skip_step = (unsigned int)(cf->capture.capture[pindex.capture_index].export[4]);
-    	capture->multi_capture_num = (unsigned int)(cf->capture.capture[pindex.capture_index].export[5]);
-    	capture->eyetime = (unsigned int)(cf->capture.capture[pindex.capture_index].export[6]);
-    	capture->pretime = (unsigned int)(cf->capture.capture[pindex.capture_index].export[7]);
-    	capture->postime = (unsigned int)(cf->capture.capture[pindex.capture_index].export[8]);
+    if(cf->capture_valid == 1){
+        if((para->xml_capture = kmalloc(sizeof(xml_capture_t),0)) == NULL){
+            printk("alloc mem failed\n");
+            return 	-ENOMEM;
+        }
+        capture = para->xml_capture;
+        capture->ae_en = (unsigned int)(cf->capture.capture[pindex.capture_index].export[0]);
+        capture->awb_en = (unsigned int)(cf->capture.capture[pindex.capture_index].export[1]);
+        capture->af_mode = (cam_scanmode_t)(cf->capture.capture[pindex.capture_index].export[2]);
+        capture->sigle_count = (unsigned int)(cf->capture.capture[pindex.capture_index].export[3]);
+        capture->skip_step = (unsigned int)(cf->capture.capture[pindex.capture_index].export[4]);
+        capture->multi_capture_num = (unsigned int)(cf->capture.capture[pindex.capture_index].export[5]);
+        capture->eyetime = (unsigned int)(cf->capture.capture[pindex.capture_index].export[6]);
+        capture->pretime = (unsigned int)(cf->capture.capture[pindex.capture_index].export[7]);
+        capture->postime = (unsigned int)(cf->capture.capture[pindex.capture_index].export[8]);
     }else{
-    	para->xml_capture = NULL;
+        para->xml_capture = NULL;
     }
     /**init wave**/
     if(cf->wave_valid == 1){
@@ -1175,9 +1235,7 @@ int generate_para(cam_parameter_t *para,para_index_t pindex){
         memcpy(wave,cf->wave.export,12*sizeof(unsigned int));
     }else{
         para->xml_wave = NULL;
-    }
-    
-    
+    }  
     return 0;
 }
 
diff --git a/drivers/amlogic/camera/common/config_parser.h b/drivers/amlogic/camera/common/config_parser.h
index e41369e37eac..818972a603a0 100755
--- a/drivers/amlogic/camera/common/config_parser.h
+++ b/drivers/amlogic/camera/common/config_parser.h
@@ -6,13 +6,14 @@
 #include <linux/mm.h>
 #include <linux/i2c.h>
 #include <linux/string.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 
 #define EFFECT_MAX 16
 #define AET_MAX 16
 #define HW_MAX 16
 #define WB_MAX 9
 #define CAPTURE_MAX 5
+#define GAMMA_MAX 257
 #define BUFFER_SIZE 1024
 
 enum error_code {
@@ -131,6 +132,12 @@ typedef struct{
 	int export[1024];
 }lenc_struct;
 
+typedef struct{
+	unsigned short gamma_r[GAMMA_MAX];
+	unsigned short gamma_g[GAMMA_MAX];
+	unsigned short gamma_b[GAMMA_MAX];
+}gamma_struct;
+
 typedef struct{
     effect_struct eff;
     int effect_valid;
@@ -147,7 +154,9 @@ typedef struct{
     wave_struct wave;
     int wave_valid;
     lenc_struct lenc;
-    int lenc_valid;    
+    int lenc_valid;
+    gamma_struct gamma;
+    int gamma_valid;  
 }configure;
 
 typedef struct{
diff --git a/drivers/amlogic/camera/common/plat_ctrl.c b/drivers/amlogic/camera/common/plat_ctrl.c
index 26f757ba5bf9..e8290d7637cd 100755
--- a/drivers/amlogic/camera/common/plat_ctrl.c
+++ b/drivers/amlogic/camera/common/plat_ctrl.c
@@ -89,7 +89,7 @@ int i2c_get_byte(struct i2c_client *client,unsigned short addr)
 	return buff[0];
 }
 
-int i2c_get_byte_add8(struct i2c_client *client,unsigned short addr)
+int i2c_get_byte_add8(struct i2c_client *client,unsigned char addr)
 {
 	unsigned char buff[4];
     buff[0] = (unsigned char)(addr & 0xff);
diff --git a/drivers/amlogic/camera/common/plat_ctrl.h b/drivers/amlogic/camera/common/plat_ctrl.h
index 8bbb6fa2872d..67b6487a86f5 100755
--- a/drivers/amlogic/camera/common/plat_ctrl.h
+++ b/drivers/amlogic/camera/common/plat_ctrl.h
@@ -3,7 +3,7 @@
 
 extern int i2c_get_byte(struct i2c_client *client,unsigned short addr);
 extern int i2c_get_word(struct i2c_client *client,unsigned short addr);
-extern int i2c_get_byte_add8(struct i2c_client *client,unsigned short addr);
+extern int i2c_get_byte_add8(struct i2c_client *client, unsigned char addr);
 extern int i2c_put_byte(struct i2c_client *client, unsigned short addr, unsigned char data);
 extern int i2c_put_word(struct i2c_client *client, unsigned short addr, unsigned short data);
 extern int i2c_put_byte_add8_new(struct i2c_client *client, unsigned char addr, unsigned char data);
diff --git a/drivers/amlogic/camera/common/vm.c b/drivers/amlogic/camera/common/vm.c
index a7298c103049..484cd9fa4dac 100755
--- a/drivers/amlogic/camera/common/vm.c
+++ b/drivers/amlogic/camera/common/vm.c
@@ -15,28 +15,27 @@
 #include <linux/interrupt.h>
 #include <linux/timer.h>
 #include <linux/time.h>
-#include <linux/vout/vinfo.h>
-#include <linux/vout/vout_notify.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
 #include <linux/platform_device.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/amports/canvas.h>
-#include <linux/amports/vframe.h>
-#include <linux/amports/vframe_provider.h>
-#include <linux/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
 #include <mach/am_regs.h>
-#include <linux/amlog.h>
-#include <linux/ge2d/ge2d_main.h>
-#include <linux/ge2d/ge2d.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/semaphore.h>
-#include <linux/sched.h>
+#include <linux/sched/rt.h>
 #include <linux/platform_device.h>
-#include <linux/ge2d/ge2d_main.h>
-#include <linux/ge2d/ge2d.h>
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include <linux/amlogic/ge2d/ge2d.h>
 #include "vm_log.h"
 #include "vm.h"
-#include <linux/amlog.h>
 #include <linux/ctype.h>
 #include <linux/videodev2.h>
 #include <media/videobuf-core.h>
@@ -45,9 +44,12 @@
 #include <media/videobuf-dma-sg.h>
 #include <media/videobuf-res.h>
 
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <linux/ctype.h>
 #include <linux/of.h>
+
+#include <linux/sizes.h>
+#include <linux/dma-mapping.h>
 
 /*class property info.*/
 #include "vmcls.h"
@@ -171,8 +173,66 @@ static inline void ptr_atomic_wrap_inc(u32 *ptr)
 }
 #endif
 
+
+
+#ifdef CONFIG_CMA
+
+void set_vm_buf_info(resource_size_t start,unsigned int size);
+void unset_vm_buf_info();
+
+static dma_addr_t vm_buf_phys = ~0;
+static void *vm_buf_virt;
+static size_t vm_buf_size;
+
+int vm_init_buf(size_t size)
+{
+
+    if(size ==0)
+        return;
+
+    if(vm_buf_phys != ~0)
+    {
+        pr_info("phys already in use phys %p, virt %p\n", vm_buf_phys, vm_buf_virt);
+        dma_free_coherent(NULL, vm_buf_size, vm_buf_virt, vm_buf_phys); 
+    }
+
+    //pr_info("... allocating ...\n");
+    vm_buf_virt = dma_alloc_coherent(NULL, size, &vm_buf_phys, GFP_KERNEL);
+
+    //pr_info("chris allocating virt %p, phys %p\n", vm_buf_virt, vm_buf_phys);
+    if(vm_buf_virt == 0)
+        return -1;
+        //goto tryagain;
+    else
+        set_vm_buf_info(vm_buf_phys, size);
+
+    vm_buf_size = size;
+    return 0;
+}
+
+EXPORT_SYMBOL(vm_init_buf);
+
+void vm_deinit_buf()
+{
+    if(0 == vm_buf_size)
+        return;
+
+    unset_vm_buf_info();
+    if(vm_buf_phys != ~0)
+    {
+        dma_free_coherent(NULL, vm_buf_size, vm_buf_virt, vm_buf_phys); 
+        vm_buf_phys = ~0;
+        vm_buf_virt = 0;
+        vm_buf_size = 0;
+    }
+}
+
+EXPORT_SYMBOL(vm_deinit_buf);
+#endif
+
 int start_vm_task(void) ;
 int start_simulate_task(void);
+
 
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 static struct vframe_s vfpool[MAX_VF_POOL_SIZE];
@@ -1528,6 +1588,7 @@ typedef  struct {
 }vm_device_t;
 
 static vm_device_t  vm_device;
+
 void set_vm_buf_info(resource_size_t start,unsigned int size) {
 	vm_device.buffer_start=start;
 	vm_device.buffer_size=size;
@@ -1535,6 +1596,18 @@ void set_vm_buf_info(resource_size_t start,unsigned int size) {
 	amlog_level(LOG_LEVEL_HIGH,"#############%p\n",vm_device.mapping);
 }
 
+
+void unset_vm_buf_info()
+{
+    if(vm_device.mapping)
+    {
+        io_mapping_free( vm_device.mapping);
+        vm_device.mapping = 0;
+        vm_device.buffer_start=0;
+        vm_device.buffer_size=0;
+    }
+}
+
 void get_vm_buf_info(resource_size_t* start,unsigned int* size,struct io_mapping **mapping) {
 	if(start)
 		*start = vm_device.buffer_start;
@@ -1670,6 +1743,9 @@ static int vm_driver_probe(struct platform_device *pdev)
 	unsigned int buf_size;
 	struct resource *mem;
 
+
+#ifndef CONFIG_CMA
+
 	if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)))
 	{
 		buf_start = 0;
@@ -1679,6 +1755,8 @@ static int vm_driver_probe(struct platform_device *pdev)
 		buf_size = mem->end - mem->start + 1;
 	}
 	set_vm_buf_info(mem->start,buf_size);
+#endif
+
 	init_vm_device();
 	return 0;
 }
diff --git a/drivers/amlogic/camera/common/vm.h b/drivers/amlogic/camera/common/vm.h
index a357b4f99ab5..aa11225ef84c 100755
--- a/drivers/amlogic/camera/common/vm.h
+++ b/drivers/amlogic/camera/common/vm.h
@@ -3,7 +3,7 @@
 
 #include <linux/interrupt.h>
 #include <mach/am_regs.h>
-#include <linux/amports/canvas.h>
+#include <linux/amlogic/amports/canvas.h>
 #include <linux/fb.h>
 #include <linux/list.h>
 #include <asm/uaccess.h>
diff --git a/drivers/amlogic/camera/common/vmapi.h b/drivers/amlogic/camera/common/vmapi.h
index f85617d37533..7c247582dfa5 100755
--- a/drivers/amlogic/camera/common/vmapi.h
+++ b/drivers/amlogic/camera/common/vmapi.h
@@ -15,4 +15,12 @@ typedef struct vm_output_para{
 }vm_output_para_t;
 
 extern int vm_fill_buffer(struct videobuf_buffer* vb, vm_output_para_t* para);
+
+#ifdef CONFIG_CMA
+
+int vm_init_buf(size_t size);
+void vm_deinit_buf(void);
+
+#endif
+
 #endif /* VM_API_INCLUDE_ */
diff --git a/drivers/amlogic/camera/gc0307.c b/drivers/amlogic/camera/gc0307.c
index 62d2ab6505fa..f4729d9bb09b 100755
--- a/drivers/amlogic/camera/gc0307.c
+++ b/drivers/amlogic/camera/gc0307.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -36,22 +37,16 @@
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend gc0307_early_suspend;
-#endif
 
 #define GC0307_CAMERA_MODULE_NAME "gc0307"
 
@@ -351,10 +346,10 @@ struct gc0307_fh {
 	unsigned int f_flags;
 };
 
-static inline struct gc0307_fh *to_fh(struct gc0307_device *dev)
+/*static inline struct gc0307_fh *to_fh(struct gc0307_device *dev)
 {
 	return container_of(dev, struct gc0307_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gc0307_prev_resolution[2]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -1062,7 +1057,7 @@ void set_GC0307_param_wb(struct gc0307_device *dev,enum  camera_wb_flip_e para)
 	unsigned char  temp_reg;
 	//temp_reg=gc0307_read_byte(0x22);
 	buf[0]=0x41;
-	temp_reg=i2c_get_byte_add8(client,buf);
+	temp_reg=i2c_get_byte_add8(client,buf[0]);
 
 	printk(" camera set_GC0307_param_wb=%d. \n ",para);
 	
@@ -1185,31 +1180,18 @@ void set_GC0307_param_wb(struct gc0307_device *dev,enum  camera_wb_flip_e para)
 *************************************************************************/
 void GC0307_night_mode(struct gc0307_device *dev,enum  camera_night_mode_flip_e enable)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
 
-	unsigned char  temp_reg;
-	//temp_reg=gc0307_read_byte(0x22);
-	//buf[0]=0x20;
-	//temp_reg=i2c_get_byte_add8(client,buf);
-	//temp_reg=0xff;
-
-    if(enable)
-    {
+	if(enable) {
 		buf[0]=0xdd;
 		buf[1]=0x32;
-		i2c_put_byte_add8(client,buf,2);
-	
-     }
-    else
-     {
+		i2c_put_byte_add8(client,buf,2);	
+	} else {
 		buf[0]=0xdd;
 		buf[1]=0x12;
 		i2c_put_byte_add8(client,buf,2);
-
-
 	}
-
 }
 /*************************************************************************
 * FUNCTION
@@ -1228,7 +1210,7 @@ void GC0307_night_mode(struct gc0307_device *dev,enum  camera_night_mode_flip_e
 *
 *************************************************************************/
 
-void GC0307_set_param_banding(struct gc0307_device *dev,enum  camera_night_mode_flip_e banding)
+void GC0307_set_param_banding(struct gc0307_device *dev,enum  camera_banding_flip_e banding)
 {
     struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     unsigned char buf[4];
@@ -1309,6 +1291,8 @@ void GC0307_set_param_banding(struct gc0307_device *dev,enum  camera_night_mode_
             buf[1]=0xb0;
             i2c_put_byte_add8(client,buf,2);
             break;
+        default:
+            break;
     }
 }
 
@@ -1419,15 +1403,17 @@ void set_GC0307_param_exposure(struct gc0307_device *dev,enum camera_exposure_e
 * RETURNS
 *	None
 *
-* GLOBALS AFFECTED  效虏媒***********************************************************************/
-void set_GC0307_param_effect(struct gc0307_device *dev,enum camera_effect_flip_e para)//效
+* GLOBALS AFFECTED  特效参数
+*
+*************************************************************************/
+void set_GC0307_param_effect(struct gc0307_device *dev,enum camera_effect_flip_e para)//特效设置
 {
     struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
 	unsigned char  temp_reg;
 	
 	buf[0]=0x47;
-	temp_reg=i2c_get_byte_add8(client,buf);
+	temp_reg = i2c_get_byte_add8(client, buf[0]);
 
 	if((para == CAM_EFFECT_ENC_NORMAL) || (para == CAM_EFFECT_ENC_COLORINV))        
 	{
@@ -1849,48 +1835,7 @@ unsigned char v4l_2_gc0307(int val)
 static int gc0307_setting(struct gc0307_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
-#if 0
-	case V4L2_CID_BRIGHTNESS:
-		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_gc0307(value));
-		ret=i2c_put_byte(client,0x0201,v4l_2_gc0307(value));
-		break;
-	case V4L2_CID_CONTRAST:
-		ret=i2c_put_byte(client,0x0200, value);
-		break;
-	case V4L2_CID_SATURATION:
-		ret=i2c_put_byte(client,0x0202, value);
-		break;
-	case V4L2_CID_HFLIP:    /* set flip on H. */
-		ret=i2c_get_byte(client,0x0101);
-		if(ret>0) {
-			cur_val=(char)ret;
-			if(value!=0)
-				cur_val=cur_val|0x1;
-			else
-				cur_val=cur_val&0xFE;
-			ret=i2c_put_byte(client,0x0101,cur_val);
-			if(ret<0) dprintk(dev, 1, "V4L2_CID_HFLIP setting error\n");
-		}  else {
-			dprintk(dev, 1, "vertical read error\n");
-		}
-		break;
-	case V4L2_CID_VFLIP:    /* set flip on V. */
-		ret=i2c_get_byte(client,0x0101);
-		if(ret>0) {
-			cur_val=(char)ret;
-			if(value!=0)
-				cur_val=cur_val|0x10;
-			else
-				cur_val=cur_val&0xFD;
-			ret=i2c_put_byte(client,0x0101,cur_val);
-		} else {
-			dprintk(dev, 1, "vertical read error\n");
-		}
-		break;
-#endif
 	case V4L2_CID_DO_WHITE_BALANCE:
 		if(gc0307_qctrl[0].default_value!=value){
 			gc0307_qctrl[0].default_value=value;
@@ -1955,7 +1900,7 @@ static int gc0307_setting(struct gc0307_device *dev,int PROP_ID,int value )
 
 }
 
-static void power_down_gc0307(struct gc0307_device *dev)
+/*static void power_down_gc0307(struct gc0307_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
@@ -1968,7 +1913,7 @@ static void power_down_gc0307(struct gc0307_device *dev)
 	
 	msleep(5);
 	return;
-}
+}*/
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -2283,7 +2228,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
 					struct v4l2_frmivalenum *fival)
 {
-	struct gc0307_fmt *fmt;
 	unsigned int k;
 	
 	if(fival->index > ARRAY_SIZE(gc0307_frmivalenum))
@@ -2403,8 +2347,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct gc0307_fh *fh = priv;
 	struct gc0307_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
 	
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2482,7 +2424,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	para.bt_path = dev->cam_info.bt_path;
 	printk("0307,h=%d, v=%d, frame_rate=%d\n", 
 		gc0307_h_active, gc0307_v_active, para.frame_rate);
@@ -2651,6 +2593,13 @@ static int gc0307_open(struct file *file)
 	struct gc0307_fh *fh = NULL;
 	int retval = 0;
 	gc0307_have_open=1;
+
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
+
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2783,6 +2732,11 @@ static int gc0307_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
+
 	return 0;
 }
 
@@ -2941,9 +2895,13 @@ static const struct i2c_device_id gc0307_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gc0307_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gc0307",
+static struct i2c_driver gc0307_i2c_driver = {
+	.driver = {
+		.name = "gc0307",
+	},
 	.probe = gc0307_probe,
 	.remove = gc0307_remove,
 	.id_table = gc0307_id,
 };
+
+module_i2c_driver(gc0307_i2c_driver);
diff --git a/drivers/amlogic/camera/gc0308.c b/drivers/amlogic/camera/gc0308.c
index 5416a383bc21..6b5b58d8148e 100755
--- a/drivers/amlogic/camera/gc0308.c
+++ b/drivers/amlogic/camera/gc0308.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,24 +36,17 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
-#include <media/amlogic/aml_camera.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
 //#include <mach/gpio_data.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend gc0308_early_suspend;
-#endif
 
 #define GC0308_CAMERA_MODULE_NAME "gc0308"
 
@@ -81,8 +75,6 @@ static unsigned int vid_limit = 16;
 //module_param(vid_limit, uint, 0644);
 //MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
 
-static int gc0308_have_open=0;
-
 static int gc0308_h_active=320;
 static int gc0308_v_active=240;
 static struct v4l2_fract gc0308_frmintervals_active = {
@@ -445,10 +437,10 @@ struct gc0308_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct gc0308_fh *to_fh(struct gc0308_device *dev)
+/*static inline struct gc0308_fh *to_fh(struct gc0308_device *dev)
 {
 	return container_of(dev, struct gc0308_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gc0308_prev_resolution[3]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -952,7 +944,6 @@ void GC0308_init_regs(struct gc0308_device *dev)
 	int i=0;//,j;
 	unsigned char buf[2];
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	aml_camera_i2c_fig1_t*	custom_script;
 	
 	while (1) {
 		buf[0] = GC0308_script[i].addr;
@@ -1031,8 +1022,9 @@ static int set_flip(struct gc0308_device *dev)
 	buf[1] = temp;
 	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
             printk("fail in setting sensor orientation\n");
-            return;
+            return -1;
         }
+        return 0;
 }
 
 
@@ -1810,7 +1802,7 @@ static int gc0308_setting(struct gc0308_device *dev,int PROP_ID,int value )
 
 }
 
-static void power_down_gc0308(struct gc0308_device *dev)
+/*static void power_down_gc0308(struct gc0308_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
@@ -1823,7 +1815,7 @@ static void power_down_gc0308(struct gc0308_device *dev)
 	
 	msleep(5);
 	return;
-}
+}*/
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -2137,7 +2129,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
                 struct v4l2_frmivalenum *fival)
 {
-        struct gc0308_fmt *fmt;
         unsigned int k;
 
         if(fival->index > ARRAY_SIZE(gc0308_frmivalenum))
@@ -2258,8 +2249,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
         struct gc0308_fh *fh = priv;
         struct gc0308_device *dev = fh->dev;
         struct v4l2_captureparm *cp = &parms->parm.capture;
-        int ret;
-        int i;
 
         dprintk(dev,3,"vidioc_g_parm\n");
         if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2335,7 +2324,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	printk("0308,h=%d, v=%d, frame_rate=%d\n",
 		gc0308_h_active, gc0308_v_active, gc0308_frmintervals_active.denominator);
 	ret =  videobuf_streamon(&fh->vb_vidq);
@@ -2503,6 +2492,11 @@ static int gc0308_open(struct file *file)
 	struct gc0308_device *dev = video_drvdata(file);
 	struct gc0308_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2635,6 +2629,9 @@ static int gc0308_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2792,10 +2789,14 @@ static const struct i2c_device_id gc0308_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gc0308_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gc0308",
+static struct i2c_driver gc0308_i2c_driver = {
+	.driver = {
+		.name = "gc0308",
+	},
 	.probe = gc0308_probe,
 	.remove = gc0308_remove,
 	.id_table = gc0308_id,
 };
 
+module_i2c_driver(gc0308_i2c_driver);
+
diff --git a/drivers/amlogic/camera/gc0328.c b/drivers/amlogic/camera/gc0328.c
index 80dd06d272b2..be0e41e398b3 100755
--- a/drivers/amlogic/camera/gc0328.c
+++ b/drivers/amlogic/camera/gc0328.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,14 +36,11 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
@@ -429,10 +427,10 @@ struct gc0328_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct gc0328_fh *to_fh(struct gc0328_device *dev)
+/*static inline struct gc0328_fh *to_fh(struct gc0328_device *dev)
 {
 	return container_of(dev, struct gc0328_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gc0328_prev_resolution[3]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -796,8 +794,6 @@ void GC0328_init_regs(struct gc0328_device *dev)
     int i=0;//,j;
     unsigned char buf[2];
     struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-    aml_camera_i2c_fig1_t*	custom_script;
-    aml_cam_info_t* plat_dat = NULL;
 
     while(1)
     {
@@ -850,8 +846,9 @@ static int set_flip(struct gc0328_device *dev)
 	buf[1] = temp;
 	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
             printk("fail in setting sensor orientation\n");
-            return;
+            return -1;
         }
+        return 0;
 }
 
 static void gc0328_set_resolution(struct gc0328_device *dev,int height,int width)
@@ -1056,7 +1053,7 @@ void GC0328_night_mode(struct gc0328_device *dev,enum  camera_night_mode_flip_e
 	unsigned char  temp_reg;
 	//temp_reg=gc0328_read_byte(0x22);
 	buf[0]=0x40;
-	temp_reg=i2c_get_byte_add8(client,buf);
+	temp_reg=i2c_get_byte_add8(client,buf[0]);
 	temp_reg=0xff;
 
     if(enable)
@@ -1623,6 +1620,7 @@ static int gc0328_setting(struct gc0328_device *dev,int PROP_ID,int value )
 
 }
 
+#if 0
 static void power_down_gc0328(struct gc0328_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
@@ -1638,6 +1636,7 @@ static void power_down_gc0328(struct gc0328_device *dev)
 	msleep(5);
 	return;
 }
+#endif
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -1949,7 +1948,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct gc0328_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(gc0328_frmivalenum))
@@ -2069,8 +2067,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct gc0328_fh *fh = priv;
     struct gc0328_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2146,7 +2142,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
         vops->start_tvin_service(0,&para);
@@ -2312,6 +2308,11 @@ static int gc0328_open(struct file *file)
 	struct gc0328_device *dev = video_drvdata(file);
 	struct gc0328_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	gc0328_have_open=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2445,6 +2446,9 @@ static int gc0328_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2600,10 +2604,14 @@ static const struct i2c_device_id gc0328_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gc0328_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gc0328",
+static struct i2c_driver gc0328_i2c_driver = {
+	.driver = {
+		.name = "gc0328",
+	},
 	.probe = gc0328_probe,
 	.remove = gc0328_remove,
 	.id_table = gc0328_id,
 };
 
+module_i2c_driver(gc0328_i2c_driver);
+
diff --git a/drivers/amlogic/camera/gc0329.c b/drivers/amlogic/camera/gc0329.c
index 40e44ce02277..fc7119fdb57a 100755
--- a/drivers/amlogic/camera/gc0329.c
+++ b/drivers/amlogic/camera/gc0329.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,23 +36,16 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend gc0329_early_suspend;
-#endif
 
 #define GC0329_CAMERA_MODULE_NAME "gc0329"
 
@@ -404,10 +398,10 @@ struct gc0329_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct gc0329_fh *to_fh(struct gc0329_device *dev)
+/*static inline struct gc0329_fh *to_fh(struct gc0329_device *dev)
 {
 	return container_of(dev, struct gc0329_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gc0329_prev_resolution[3]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -1166,7 +1160,7 @@ void GC0329GammaSelect(struct gc0329_device *dev, GC0329_GAMMA_TAG GammaLvl)
 
 void GC0329write_more_registers(struct gc0329_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
 	GC0329GammaSelect(dev,0);// GC0329_RGB_Gamma_m3);	
 }
 
@@ -1304,11 +1298,11 @@ void GC0329_night_mode(struct gc0329_device *dev,enum  camera_night_mode_flip_e
 *
 *************************************************************************/
 
-void GC0329_set_param_banding(struct gc0329_device *dev,enum  camera_night_mode_flip_e banding)
+void GC0329_set_param_banding(struct gc0329_device *dev,enum  camera_banding_flip_e banding)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(banding){
-	case CAM_BANDING_60HZ:
+        case CAM_BANDING_60HZ:
 		i2c_put_byte_add8_new(client,0x05, 0x02); 	
 		i2c_put_byte_add8_new(client,0x06, 0x4c); 
 		i2c_put_byte_add8_new(client,0x07, 0x00);
@@ -1327,9 +1321,12 @@ void GC0329_set_param_banding(struct gc0329_device *dev,enum  camera_night_mode_
 		i2c_put_byte_add8_new(client,0x31, 0x05);   //exp level 0  7.05fps
 		i2c_put_byte_add8_new(client,0x32, 0x2e); 
 		i2c_put_byte_add8_new(client,0xfe, 0x00);
-		
+
 		break;
-	case CAM_BANDING_50HZ:
+        case CAM_BANDING_50HZ:
+
+
+
 		i2c_put_byte_add8_new(client,0x05, 0x02); 	
 		i2c_put_byte_add8_new(client,0x06, 0x2c); 
 		i2c_put_byte_add8_new(client,0x07, 0x00);
@@ -1349,26 +1346,28 @@ void GC0329_set_param_banding(struct gc0329_device *dev,enum  camera_night_mode_
 		i2c_put_byte_add8_new(client,0x32, 0x40); 
 		i2c_put_byte_add8_new(client,0xfe, 0x00);
 /*
-		i2c_put_byte_add8_new(client,0x05, 0x03); 	
-		i2c_put_byte_add8_new(client,0x06, 0x26); 
-		i2c_put_byte_add8_new(client,0x07, 0x00);
-		i2c_put_byte_add8_new(client,0x08, 0x48);
-		
-		i2c_put_byte_add8_new(client, 0xfe, 0x01);
-		i2c_put_byte_add8_new(client,0x29, 0x00);   //anti-flicker step [11:8]
-		i2c_put_byte_add8_new(client,0x2a, 0x50);   //anti-flicker step [7:0]
-		
-		i2c_put_byte_add8_new(client,0x2b, 0x02);   //exp level 0  14.28fps
-		i2c_put_byte_add8_new(client,0x2c, 0x30); 
-		i2c_put_byte_add8_new(client,0x2d, 0x02);   //exp level 1  12.50fps
-		i2c_put_byte_add8_new(client,0x2e, 0x80); 
-		i2c_put_byte_add8_new(client,0x2f, 0x03);   //exp level 2  10.00fps
-		i2c_put_byte_add8_new(client,0x30, 0x20); 
-		i2c_put_byte_add8_new(client,0x31, 0x06);   //exp level 3  7.14fps
-		i2c_put_byte_add8_new(client,0x32, 0x40); 
-		i2c_put_byte_add8_new(client,0xfe, 0x00);
+			i2c_put_byte_add8_new(client,0x05, 0x03); 	
+			i2c_put_byte_add8_new(client,0x06, 0x26); 
+			i2c_put_byte_add8_new(client,0x07, 0x00);
+			i2c_put_byte_add8_new(client,0x08, 0x48);
+
+			i2c_put_byte_add8_new(client, 0xfe, 0x01);
+			i2c_put_byte_add8_new(client,0x29, 0x00);   //anti-flicker step [11:8]
+			i2c_put_byte_add8_new(client,0x2a, 0x50);   //anti-flicker step [7:0]
+			
+			i2c_put_byte_add8_new(client,0x2b, 0x02);   //exp level 0  14.28fps
+			i2c_put_byte_add8_new(client,0x2c, 0x30); 
+			i2c_put_byte_add8_new(client,0x2d, 0x02);   //exp level 1  12.50fps
+			i2c_put_byte_add8_new(client,0x2e, 0x80); 
+			i2c_put_byte_add8_new(client,0x2f, 0x03);   //exp level 2  10.00fps
+			i2c_put_byte_add8_new(client,0x30, 0x20); 
+			i2c_put_byte_add8_new(client,0x31, 0x06);   //exp level 3  7.14fps
+			i2c_put_byte_add8_new(client,0x32, 0x40); 
+			i2c_put_byte_add8_new(client,0xfe, 0x00);
 			*/
 		break;
+        default:
+		break;
 	}
 }
 
@@ -1531,8 +1530,8 @@ unsigned char v4l_2_gc0329(int val)
 static int gc0329_setting(struct gc0329_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_DO_WHITE_BALANCE:
 		if(gc0329_qctrl[0].default_value!=value){
@@ -1598,14 +1597,14 @@ static int gc0329_setting(struct gc0329_device *dev,int PROP_ID,int value )
 
 }
 
-static void power_down_gc0329(struct gc0329_device *dev)
+/*static void power_down_gc0329(struct gc0329_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
 	return;
 	msleep(5);
 	return;
-}
+}*/
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -1917,7 +1916,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-	struct gc0329_fmt *fmt;
 	unsigned int k;
 	
 	if(fival->index > ARRAY_SIZE(gc0329_frmivalenum))
@@ -1958,8 +1956,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct gc0329_fh *fh = priv;
 	struct gc0329_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
 	
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2111,7 +2107,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	para.bt_path = dev->cam_info.bt_path;
 	printk("gc0329,h=%d, v=%d, frame_rate=%d\n", 
 		gc0329_h_active, gc0329_v_active, gc0329_frmintervals_active.denominator);
@@ -2280,6 +2276,11 @@ static int gc0329_open(struct file *file)
 	struct gc0329_device *dev = video_drvdata(file);
 	struct gc0329_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2410,6 +2411,9 @@ static int gc0329_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2567,10 +2571,14 @@ static const struct i2c_device_id gc0329_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gc0329_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gc0329",
+static struct i2c_driver gc0329_i2c_driver = {
+	.driver = {
+		.name = "gc0329",
+	},
 	.probe = gc0329_probe,
 	.remove = gc0329_remove,
 	.id_table = gc0329_id,
 };
 
+module_i2c_driver(gc0329_i2c_driver);
+
diff --git a/drivers/amlogic/camera/gc2015.c b/drivers/amlogic/camera/gc2015.c
index 750cc6e0b46d..a62428a8ae31 100755
--- a/drivers/amlogic/camera/gc2015.c
+++ b/drivers/amlogic/camera/gc2015.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,33 +36,20 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
 
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend gc2015_early_suspend;
-#endif
 
 #define gc2015_CAMERA_MODULE_NAME "gc2015"
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -360,10 +348,10 @@ struct gc2015_fh {
 	unsigned int f_flags;
 };
 
-static inline struct gc2015_fh *to_fh(struct gc2015_device *dev)
+/*static inline struct gc2015_fh *to_fh(struct gc2015_device *dev)
 {
 	return container_of(dev, struct gc2015_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gc2015_prev_resolution[2]= //should include 352x288 and 640x480, those two size are used for recording
 {
@@ -972,6 +960,9 @@ void gc2015_set_param_wb(struct gc2015_device *dev,enum  camera_wb_flip_e para)/
 	case CAM_WB_MANUAL:
 	    	                      // TODO
 		break;
+			
+		default:
+			break;
 	}
 
 } /* gc2015_set_param_wb */
@@ -1198,8 +1189,8 @@ void gc2015_set_param_exposure(struct gc2015_device *dev,enum camera_exposure_e
 *************************************************************************/
 void gc2015_set_param_effect(struct gc2015_device *dev,enum camera_effect_flip_e para)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
 /*
 
     switch (para)
@@ -1348,8 +1339,8 @@ void gc2015_set_param_effect(struct gc2015_device *dev,enum camera_effect_flip_e
 *************************************************************************/
 void gc2015_set_night_mode(struct gc2015_device *dev,enum  camera_night_mode_flip_e enable)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
 /*
 	if (enable)
 	{
@@ -1381,7 +1372,7 @@ void gc2015_set_night_mode(struct gc2015_device *dev,enum  camera_night_mode_fli
 	}
 */
 }    /* gc2015_NightMode */
-void gc2015_set_param_banding(struct gc2015_device *dev,enum  camera_night_mode_flip_e banding)
+void gc2015_set_param_banding(struct gc2015_device *dev,enum  camera_banding_flip_e banding)
 {
     struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
@@ -1530,6 +1521,8 @@ void gc2015_set_param_banding(struct gc2015_device *dev,enum  camera_night_mode_
 			i2c_put_byte_add8(client,buf,2);
 	             			
 			break;
+		    default:
+		    	break;
 
 		}
 	#endif	
@@ -1562,12 +1555,10 @@ static int set_flip(struct gc2015_device *dev)
 void gc2015_set_resolution(struct gc2015_device *dev,int height,int width)
 {
 #if 1
-	int ret;
 	unsigned char buf[4];
-	int ret1=0;
 	unsigned  int value;
 	unsigned   int pid=0,shutter;
-	unsigned int  hb_ori, hb_total=298;
+	unsigned int  hb_total=298;
 	unsigned int  temp_reg;
 	static unsigned int shutter_l = 0;
 	static unsigned int shutter_h = 0;
@@ -1812,8 +1803,8 @@ unsigned char v4l_2_gc2015(int val)
 static int gc2015_setting(struct gc2015_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
 	
 	switch(PROP_ID)  {
@@ -2227,7 +2218,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
 					struct v4l2_frmivalenum *fival)
 {
-	struct gc2015_fmt *fmt;
 	unsigned int k;
 	
 	if(fival->index > ARRAY_SIZE(gc2015_frmivalenum))
@@ -2271,8 +2261,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct gc2015_fh *fh = priv;
 	struct gc2015_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
 	
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2430,7 +2418,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	para.bt_path = dev->cam_info.bt_path;
 	printk("gc2015,h=%d, v=%d, frame_rate=%d\n", 
 		gc2015_h_active, gc2015_v_active, para.frame_rate);
@@ -2600,6 +2588,11 @@ static int gc2015_open(struct file *file)
 	struct gc2015_device *dev = video_drvdata(file);
 	struct gc2015_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2735,6 +2728,9 @@ static int gc2015_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2886,10 +2882,14 @@ static const struct i2c_device_id gc2015_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gc2015_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gc2015_i2c",
+static struct i2c_driver gc2015_i2c_driver = {
+	.driver = {
+		.name = "gc2015",
+	},
 	.probe = gc2015_probe,
 	.remove = gc2015_remove,
 	.id_table = gc2015_id,
 };
 
+module_i2c_driver(gc2015_i2c_driver);
+
diff --git a/drivers/amlogic/camera/gc2035.c b/drivers/amlogic/camera/gc2035.c
index e662c2bd6f86..937dd8042d60 100755
--- a/drivers/amlogic/camera/gc2035.c
+++ b/drivers/amlogic/camera/gc2035.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,21 +36,14 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #include <mach/mod_gate.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend gc2035_early_suspend;
-#endif
 
 #define gc2035_CAMERA_MODULE_NAME "gc2035"
 
@@ -78,18 +72,12 @@ static unsigned int vid_limit = 16;
 //module_param(vid_limit, uint, 0644);
 //MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
 
-static int vidio_set_fmt_ticks=0;
-
 static int GC2035_h_active=640;
 static int GC2035_v_active=480;
 static struct v4l2_fract gc2035_frmintervals_active = {
     .numerator = 1,
     .denominator = 15,
 };
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-
-#endif
 
 static struct vdin_v4l2_ops_s *vops;
 
@@ -167,6 +155,15 @@ static struct v4l2_queryctrl gc2035_qctrl[] = {
 		.step          = 20,
 		.default_value = 100,
 		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id		= V4L2_CID_ROTATE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotate",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
 	}
 };
 
@@ -315,10 +312,10 @@ struct gc2035_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct gc2035_fh *to_fh(struct gc2035_device *dev)
+/*static inline struct gc2035_fh *to_fh(struct gc2035_device *dev)
 {
 	return container_of(dev, struct gc2035_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gc2035_prev_resolution[]= //should include 352x288 and 640x480, those two size are used for recording
 {
@@ -1056,7 +1053,7 @@ static void gc2035_init_regs(struct gc2035_device *dev)
 	    	}
 		i++;	
 	}
-	msleep(200);
+	msleep(20);
 	return;
 }
 static struct v4l2_frmivalenum gc2035_frmivalenum[] = {
@@ -1266,6 +1263,9 @@ void gc2035_set_param_wb(struct gc2035_device *dev,enum  camera_wb_flip_e para)/
 		case CAM_WB_MANUAL:
 		    	                      // TODO
 			break;
+			
+		default:
+			break;
 	}
 
 } /* gc2035_set_param_wb */
@@ -1484,7 +1484,7 @@ void gc2035_set_param_exposure(struct gc2035_device *dev,enum camera_exposure_e
 
 	}
 	
-	mdelay(150);
+	mdelay(20);
 
 } /* gc2035_set_param_exposure */
 /*************************************************************************
@@ -1505,8 +1505,8 @@ void gc2035_set_param_exposure(struct gc2035_device *dev,enum camera_exposure_e
 *************************************************************************/
 void gc2035_set_param_effect(struct gc2035_device *dev,enum camera_effect_flip_e para)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
 /*
 
     switch (para)
@@ -1655,8 +1655,8 @@ void gc2035_set_param_effect(struct gc2035_device *dev,enum camera_effect_flip_e
 *************************************************************************/
 void gc2035_set_night_mode(struct gc2035_device *dev,enum  camera_night_mode_flip_e enable)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
 /*
 	if (enable)
 	{
@@ -1688,9 +1688,9 @@ void gc2035_set_night_mode(struct gc2035_device *dev,enum  camera_night_mode_fli
 	}
 */
 }    /* gc2035_NightMode */
-void gc2035_set_param_banding(struct gc2035_device *dev,enum  camera_night_mode_flip_e banding)
+void gc2035_set_param_banding(struct gc2035_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
 	#if 1
 	switch(banding)
@@ -1838,6 +1838,8 @@ void gc2035_set_param_banding(struct gc2035_device *dev,enum  camera_night_mode_
 			i2c_put_byte_add8(client,buf,2);
 	             			
 			break;
+		    default:
+		    	break;
 
 		}
 	#endif	
@@ -1875,24 +1877,17 @@ static int set_flip(struct gc2035_device *dev)
 
 void gc2035_set_resolution(struct gc2035_device *dev,int height,int width)
 {
-	int ret;
 	unsigned char buf[4];
-	int ret1=0;
 	unsigned  int value;
 	unsigned   int pid=0,shutter;
-
-	unsigned int  temp_reg;
 	static unsigned int shutter_l = 0;
 	static unsigned int shutter_h = 0;
-
-	//return;
-
-	printk( KERN_INFO" set camera  GC2035_set_resolution=width =0x%d \n ",width);
-	printk( KERN_INFO" set camera  GC2035_set_resolution=height =0x%d \n ",height);
-
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
+	//printk( KERN_INFO" set camera  GC2035_set_resolution=width =0x%d \n ",width);
+	//printk( KERN_INFO" set camera  GC2035_set_resolution=height =0x%d \n ",height);
 
-	if((width<1600)&&(height<1200))
+	if((width*height<1600*1200))
 	{
 		//800*600 
 		buf[0]=0xfe;
@@ -1993,8 +1988,8 @@ void gc2035_set_resolution(struct gc2035_device *dev,int height,int width)
 		gc2035_frmintervals_active.denominator = 15;
 		GC2035_h_active=800;
 		GC2035_v_active=600;
-		mdelay(200);
-	} else if(width>=1600&&height>=1200 ) {
+		mdelay(50);
+	} else if(width*height>=1200*1600 ) {
 		#if  1
 		buf[0]=0xfe;
 		buf[1]=0x00;
@@ -2096,7 +2091,7 @@ void gc2035_set_resolution(struct gc2035_device *dev,int height,int width)
 		buf[1]=0x00;
 		i2c_put_byte_add8(client,buf,2);
 		
-		mdelay(30);
+		//mdelay(20);
 		
 		#if  1
 		shutter= shutter /2;
@@ -2120,7 +2115,7 @@ void gc2035_set_resolution(struct gc2035_device *dev,int height,int width)
 		GC2035_h_active=1600;
 		GC2035_v_active=1200;
 
-		mdelay(280);
+		mdelay(130);
 	}
 	printk(KERN_INFO " set camera  GC2035_set_resolution=w=%d,h=%d. \n ",width,height);
 	set_flip(dev);	
@@ -2140,8 +2135,8 @@ static int gc2035_setting(struct gc2035_device *dev,int PROP_ID,int value )
 	//printk("----------- %s \n",__func__);
 
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
 	
 	switch(PROP_ID)  {
@@ -2210,6 +2205,13 @@ static int gc2035_setting(struct gc2035_device *dev,int PROP_ID,int value )
 			//printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
         	}
 		break;
+	case V4L2_CID_ROTATE:
+	    printk(" set camera111  rotate =%d. \n ",value);
+		if(gc2035_qctrl[8].default_value!=value){
+			gc2035_qctrl[8].default_value=value;
+			printk(" set camera  rotate =%d. \n ",value);
+		}
+		break;
 	default:
 		ret=-1;
 		break;
@@ -2222,8 +2224,8 @@ static int gc2035_setting(struct gc2035_device *dev,int PROP_ID,int value )
 
 static void power_down_gc2035(struct gc2035_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
 			//buf[0]=0x45;
 			//buf[1]=0x00;
 			//i2c_put_byte_add8(client,buf,2);
@@ -2253,6 +2255,7 @@ static void gc2035_fillbuff(struct gc2035_fh *fh, struct gc2035_buffer *buf)
 	para.v4l2_format = fh->fmt->fourcc;
 	para.v4l2_memory = 0x18221223;
 	para.zoom = gc2035_qctrl[7].default_value;
+	para.angle = gc2035_qctrl[8].default_value;
 	para.vaddr = (unsigned)vbuf;
 	vm_fill_buffer(&buf->vb,&para);
 	buf->vb.state = VIDEOBUF_DONE;
@@ -2441,7 +2444,6 @@ static void free_buffer(struct videobuf_queue *vq, struct gc2035_buffer *buf)
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct gc2035_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(gc2035_frmivalenum))
@@ -2607,8 +2609,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct gc2035_fh *fh = priv;
     struct gc2035_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2754,11 +2754,12 @@ static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
 
 static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 {
-	printk(KERN_INFO " vidioc_streamon+++ \n ");
-	struct gc2035_fh  *fh = priv;
+	struct gc2035_fh *fh = priv;
 	struct gc2035_device *dev = fh->dev;
 	vdin_parm_t para;
 	int ret = 0 ;
+	printk(KERN_INFO " vidioc_streamon+++ \n ");
+	
 	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
 	if (i != fh->type)
@@ -2775,7 +2776,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count = 4; //skip_num
 	para.bt_path = dev->cam_info.bt_path;
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
@@ -2957,12 +2958,18 @@ static int gc2035_open(struct file *file)
 	struct gc2035_device *dev = video_drvdata(file);
 	struct gc2035_fh *fh = NULL;
 	int retval = 0;
+
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
+
 #ifdef CONFIG_ARCH_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
 	aml_cam_init(&dev->cam_info);
 	gc2035_init_regs(dev);
-	msleep(40);
 	mutex_lock(&dev->mutex);
 	dev->users++;
 	if (dev->users > 1) {
@@ -3014,7 +3021,7 @@ static int gc2035_open(struct file *file)
 			sizeof(struct gc2035_buffer), fh,NULL);
 
 	gc2035_start_thread(fh);
-    	msleep(200);  // added james
+    //msleep(50);  // added james
 	return 0;
 }
 
@@ -3078,6 +3085,7 @@ static int gc2035_close(struct file *file)
 
 	gc2035_qctrl[5].default_value=0;
 	gc2035_qctrl[7].default_value=100;
+	gc2035_qctrl[8].default_value=0;
 	gc2035_frmintervals_active.numerator = 1;
 	gc2035_frmintervals_active.denominator = 15;
 	power_down_gc2035(dev);
@@ -3087,6 +3095,10 @@ static int gc2035_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -3239,10 +3251,15 @@ static const struct i2c_device_id gc2035_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gc2035_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gc2035",
+static struct i2c_driver gc2035_i2c_driver = {
+	.driver = {
+		.name = "gc2035",
+	},
 	.probe = gc2035_probe,
 	.remove = gc2035_remove,
 	.id_table = gc2035_id,
 };
 
+module_i2c_driver(gc2035_i2c_driver);
+
+
diff --git a/drivers/amlogic/camera/gt2005.c b/drivers/amlogic/camera/gt2005.c
index 5c960e052545..0391b906bf71 100755
--- a/drivers/amlogic/camera/gt2005.c
+++ b/drivers/amlogic/camera/gt2005.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,8 +36,6 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 
 #include <linux/amlogic/camera/aml_cam_info.h>
 
@@ -44,25 +43,14 @@
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
 //#include <mach/gpio_data.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend gt2005_early_suspend;
-#endif
 
 #define GT2005_CAMERA_MODULE_NAME "gt2005"
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -91,8 +79,6 @@ static unsigned int vid_limit = 16;
 //module_param(vid_limit, uint, 0644);
 //MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
 
-static int vidio_set_fmt_ticks=0;
-
 extern int disable_gt2005;
 
 static int gt2005_h_active=800;
@@ -440,10 +426,10 @@ struct gt2005_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct gt2005_fh *to_fh(struct gt2005_device *dev)
+/*static inline struct gt2005_fh *to_fh(struct gt2005_device *dev)
 {
 	return container_of(dev, struct gt2005_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete gt2005_prev_resolution[]= //should include 352x288 and 640x480, those two size are used for recording
 {
@@ -1131,9 +1117,7 @@ struct aml_camera_i2c_fig_s GT2005_script[] = {
 void GT2005_init_regs(struct gt2005_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	aml_camera_i2c_fig_t*  custom_script;
         int i=0;
-	aml_plat_cam_data_t* plat_dat = NULL;
 
 	while (1) {
 		if (GT2005_script[i].val==0xff&&GT2005_script[i].addr==0xffff)
@@ -1452,8 +1436,9 @@ static int set_flip(struct gt2005_device *dev)
 	//printk("dst temp is 0x%x\n", temp);
 	if((i2c_put_byte(client, 0x0101, temp)) < 0) {
             printk("fail in setting sensor orientation \n");
-            return;
+            return -1;
         }
+        return 0;
 }
 
 void GT2005_set_resolution(struct gt2005_device *dev,int height,int width)
@@ -1971,7 +1956,6 @@ static struct videobuf_queue_ops gt2005_video_qops = {
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct gt2005_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(gt2005_frmivalenum))
@@ -2110,19 +2094,6 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	} else{
 		GT2005_set_resolution(dev,fh->height,fh->width);
 	}
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT	
-	if (dev->platform_dev_data.flash_support) {
-		if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
-			if (get_flashlightflag() == FLASHLIGHT_ON) {
-				set_flashlight(true);
-			}
-		} else if(f->fmt.pix.pixelformat == V4L2_PIX_FMT_NV21){
-			if (get_flashlightflag() != FLASHLIGHT_TORCH) {
-				set_flashlight(false);
-			}		
-		}
-	}
-#endif	
 
 	ret = 0;
 out:
@@ -2137,8 +2108,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct gt2005_fh *fh = priv;
     struct gt2005_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2214,7 +2183,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
     printk("gt2005,h=%d, v=%d, frame_rate=%d\n", 
 		gt2005_h_active, gt2005_v_active, gt2005_frmintervals_active.denominator);
 	ret =  videobuf_streamon(&fh->vb_vidq);
@@ -2383,6 +2352,11 @@ static int gt2005_open(struct file *file)
 	struct gt2005_device *dev = video_drvdata(file);
 	struct gt2005_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2519,6 +2493,9 @@ static int gt2005_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2610,7 +2587,7 @@ static int gt2005_probe(struct i2c_client *client,
 	struct gt2005_device *t;
 	struct v4l2_subdev *sd;
 	aml_cam_info_t* plat_dat;
-    vops = get_vdin_v4l2_ops();
+	vops = get_vdin_v4l2_ops();
 	v4l_info(client, "chip found @ 0x%x (%s)\n",
 			client->addr << 1, client->adapter->name);
 	t = kzalloc(sizeof(*t), GFP_KERNEL);
@@ -2619,7 +2596,7 @@ static int gt2005_probe(struct i2c_client *client,
 	sd = &t->sd;
 	v4l2_i2c_subdev_init(sd, client, &gt2005_ops);
 
-	plat_dat= (aml_plat_cam_data_t*)client->dev.platform_data;
+	plat_dat= (aml_cam_info_t*)client->dev.platform_data;
 
 	/* Now create a video4linux device */
 	mutex_init(&t->mutex);
@@ -2676,10 +2653,14 @@ static const struct i2c_device_id gt2005_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, gt2005_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "gt2005",
+static struct i2c_driver gt2005_i2c_driver = {
+	.driver = {
+		.name = "gt2005",
+	},
 	.probe = gt2005_probe,
 	.remove = gt2005_remove,
 	.id_table = gt2005_id,
 };
 
+module_i2c_driver(gt2005_i2c_driver);
+
diff --git a/drivers/amlogic/camera/hi2056.c b/drivers/amlogic/camera/hi2056.c
index 9c3ffa6efea7..6e28c3634b45 100755
--- a/drivers/amlogic/camera/hi2056.c
+++ b/drivers/amlogic/camera/hi2056.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -38,7 +39,7 @@
 #include <media/v4l2-i2c-drv.h>
 #include <media/amlogic/aml_camera.h>
 #include <linux/mipi/am_mipi_csi2.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include "common/plat_ctrl.h"
@@ -2094,6 +2095,11 @@ static int hi2056_open(struct file *file)
 	struct hi2056_device *dev = video_drvdata(file);
 	struct hi2056_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 	switch_mod_gate_by_name("mipi", 1);
@@ -2236,6 +2242,9 @@ static int hi2056_close(struct file *file)
 	switch_mod_gate_by_name("mipi", 0);
 #endif
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2377,15 +2386,19 @@ static int hi2056_remove(struct i2c_client *client)
 }
 
 static const struct i2c_device_id hi2056_id[] = {
-	{ "hi2056_i2c", 0 },
+	{ "hi2056", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, hi2056_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "mipi-hi2056",
+static struct i2c_driver hi2056_i2c_driver = {
+	.driver = {
+		.name = "mipi-hi2056",
+	},
 	.probe = hi2056_probe,
 	.remove = hi2056_remove,
 	.id_table = hi2056_id,
 };
 
+module_i2c_driver(hi2056_i2c_driver);
+
diff --git a/drivers/amlogic/camera/hi253.c b/drivers/amlogic/camera/hi253.c
index 612c1b3908ba..ec472145ce53 100755
--- a/drivers/amlogic/camera/hi253.c
+++ b/drivers/amlogic/camera/hi253.c
@@ -8,6 +8,7 @@
  * License, or (at your option) any later version
  */
  //20110916_Amlogic_8726m1+HI253_Brian_V1.0
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -36,33 +37,20 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
 
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend hi253_early_suspend;
-#endif
 
 #define HI253_CAMERA_MODULE_NAME "hi253"
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -74,9 +62,6 @@ extern int set_flashlight(bool mode);
 #define HI253_CAMERA_VERSION \
 	KERNEL_VERSION(HI253_CAMERA_MAJOR_VERSION, HI253_CAMERA_MINOR_VERSION, HI253_CAMERA_RELEASE)
 
-static unsigned short DGain_shutter,AGain_shutter,DGain_shutterH,DGain_shutterL,AGain_shutterH,AGain_shutterL,shutterH,shutterL,shutter;
-static unsigned short UXGA_Cap = 0;
-
 MODULE_DESCRIPTION("hi253 On Board");
 MODULE_AUTHOR("amlogic-sh");
 MODULE_LICENSE("GPL v2");
@@ -99,7 +84,7 @@ static int vidio_set_fmt_ticks=0;
 static int hi253_h_active=800;
 static int hi253_v_active=600;
 
-static int hi253_have_open=0;
+//static int hi253_have_open=0;
 
 /* supported controls */
 static struct v4l2_queryctrl hi253_qctrl[] = {
@@ -332,10 +317,10 @@ struct hi253_fh {
 	int  stream_on;
 };
 
-static inline struct hi253_fh *to_fh(struct hi253_device *dev)
+/*static inline struct hi253_fh *to_fh(struct hi253_device *dev)
 {
 	return container_of(dev, struct hi253_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete hi253_prev_resolution[2]= //should include 352x288 and 640x480, those two size are used for recording
 {
@@ -1466,6 +1451,8 @@ void HI253_set_param_wb(struct hi253_device *dev,enum  camera_wb_flip_e para)//w
 		case CAM_WB_MANUAL:
 		    	// TODO
 			break;
+		default:
+			break;
 	}
 	
 #endif
@@ -1894,34 +1881,31 @@ void HI253_set_param_effect(struct hi253_device *dev,enum camera_effect_flip_e p
 *************************************************************************/
 void HI253_set_night_mode(struct hi253_device *dev,enum  camera_night_mode_flip_e enable)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-
-	if (enable)
-	{
-		//i2c_put_byte(client,0x0312 , 0xc8); //Camera Enable night mode  1/5 Frame rate
-	}
-	else
-	{
-		//i2c_put_byte(client,0x0312 , 0x08); //Disable night mode  1/2 Frame rate
-	}
 
 }    /* HI253_NightMode */
 
-void HI253_set_param_banding(struct hi253_device *dev,enum  camera_night_mode_flip_e banding)
+static struct aml_camera_i2c_fig_s HI253_50HZ_scrip[] = {
+	{0x03 , 0x20},
+	{0x10 , 0x9c},
+	{0xff , 0xff},
+};
+
+static struct aml_camera_i2c_fig_s HI253_60HZ_scrip[] = {
+	{0x03 , 0x20},
+	{0x10 , 0x8c},
+	{0xff , 0xff},
+};
+
+void HI253_set_param_banding(struct hi253_device *dev,enum  camera_banding_flip_e banding)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[2];
-	int i=0;
-
+	unsigned char buf[4];
+	int i;
+	struct aml_camera_i2c_fig_s* regs;
 	switch(banding){
 	case CAM_BANDING_50HZ:
 		{
-		struct aml_camera_i2c_fig_s regs[]=
-			{
-				{0x03 , 0x20},
-				{0x10 , 0x9c},
-				{0xff , 0xff},
-			};
+		regs = HI253_50HZ_scrip;		
 		i=0;
 		while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 		{
@@ -1934,12 +1918,7 @@ void HI253_set_param_banding(struct hi253_device *dev,enum  camera_night_mode_fl
 		break;		
 	case CAM_BANDING_60HZ:
 		{
-		struct aml_camera_i2c_fig_s regs[]=
-			{
-				{0x03 , 0x20},
-				{0x10 , 0x8c},
-				{0xff , 0xff},
-			};
+		regs = HI253_60HZ_scrip;
 		i=0;
 		while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 		{
@@ -1981,23 +1960,33 @@ static int set_flip(struct hi253_device *dev)
         return 0;
 }
 
+static struct aml_camera_i2c_fig_s res_800x600_scripts[] = {
+	{0x03 , 0x00},
+	{0x10 , 0x11},					
+	{0xff , 0xff},
+};
+
+static struct aml_camera_i2c_fig_s res_1600x1200_scripts[] = {
+	{0x03 , 0x00},
+	{0x10 , 0x00},				
+	{0xff , 0xff},
+};
+
 void HI253_set_resolution(struct hi253_device *dev,int height,int width)
 {	
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	 
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct aml_camera_i2c_fig_s* regs;
+	int i;
+	unsigned char buf[2];	 
 	if(height&&width&&(height<=1200)&&(width<=1600))
 	{		
 		if((height<=600)&&(width<=800))
 		{
 			#if 1
 			printk(KERN_INFO " set camera  HI253_set_resolution1111=w=%d,h=%d. \n ",width,height);
-			struct aml_camera_i2c_fig_s regs[]=
-				{
-					{0x03 , 0x00},
-					{0x10 , 0x11},//0x11					
-					{0xff , 0xff},
-				};
-			int i=0;
-			unsigned char buf[2];
+			regs = res_800x600_scripts;
+					
+			i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -2011,14 +2000,8 @@ void HI253_set_resolution(struct hi253_device *dev,int height,int width)
 			hi253_v_active=600;
 		} else {
 			//1600x1200
-			struct aml_camera_i2c_fig_s regs[]=
-				{
-					{0x03 , 0x00},
-					{0x10 , 0x00},
-					{0xff , 0xff},
-				};
-			int i=0;
-			unsigned char buf[2];
+			regs = res_1600x1200_scripts;
+			i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -2084,8 +2067,7 @@ unsigned char v4l_2_hi253(int val)
 static int hi253_setting(struct hi253_device *dev,int PROP_ID,int value ) 
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
 		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_hi253(value));
@@ -2163,9 +2145,7 @@ static int hi253_setting(struct hi253_device *dev,int PROP_ID,int value )
 
 static void power_down_hi253(struct hi253_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	//i2c_put_byte(client,0x0104, 0x00);
-	//i2c_put_byte(client,0x0100, 0x00);
+
 }
 
 /* ------------------------------------------------------------------
@@ -2215,7 +2195,7 @@ static void hi253_thread_tick(struct hi253_fh *fh)
 	buf = list_entry(dma_q->active.next,
 			 struct hi253_buffer, vb.queue);
     dprintk(dev, 1, "%s\n", __func__);
-    dprintk(dev, 1, "list entry get buf is %x\n",buf);
+	dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
 
 	/* Nobody is waiting on this buffer, return */
 	if (!waitqueue_active(&buf->vb.done))
@@ -2246,7 +2226,6 @@ static void hi253_sleep(struct hi253_fh *fh)
 	struct hi253_device *dev = fh->dev;
 	struct hi253_dmaqueue *dma_q = &dev->vidq;
 
-	int timeout;
 	DECLARE_WAITQUEUE(wait, current);
 
 	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
@@ -2257,7 +2236,6 @@ static void hi253_sleep(struct hi253_fh *fh)
 		goto stop_task;
 
 	/* Calculate time to wake up */
-	//timeout = msecs_to_jiffies(frames_to_ms(1));
 
 	hi253_thread_tick(fh);
 
@@ -2630,7 +2608,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
-	para.reserved = 2;//skip num
+	para.skip_count =  2;//skip num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
             vops->start_tvin_service(0,&para);
@@ -2796,6 +2774,11 @@ static int hi253_open(struct file *file)
 	struct hi253_device *dev = video_drvdata(file);
 	struct hi253_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2926,6 +2909,9 @@ static int hi253_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -3011,7 +2997,6 @@ static int hi253_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
 	aml_cam_info_t* plat_dat;
-	int pgbuf;
 	int err;
 	struct hi253_device *t;
 	struct v4l2_subdev *sd;
@@ -3077,10 +3062,14 @@ static const struct i2c_device_id hi253_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, hi253_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "hi253",
+static struct i2c_driver hi253_i2c_driver = {
+	.driver = {
+		.name = "hi253",
+	},
 	.probe = hi253_probe,
-	.remove = hi253_remove,	
+	.remove = hi253_remove,
 	.id_table = hi253_id,
 };
 
+module_i2c_driver(hi253_i2c_driver);
+
diff --git a/drivers/amlogic/camera/hi704.c b/drivers/amlogic/camera/hi704.c
index 72e54a7dc4f2..344019e9a190 100755
--- a/drivers/amlogic/camera/hi704.c
+++ b/drivers/amlogic/camera/hi704.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,25 +36,17 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend HI704_early_suspend;
-#endif
-
 #define HI704_CAMERA_MODULE_NAME "HI704"
 
 /* Wake up at about 30 fps */
@@ -348,10 +341,10 @@ struct HI704_fh {
 	unsigned int f_flags;
 };
 
-static inline struct HI704_fh *to_fh(struct HI704_device *dev)
+/*static inline struct HI704_fh *to_fh(struct HI704_device *dev)
 {
 	return container_of(dev, struct HI704_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete HI704_prev_resolution[2]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -873,8 +866,9 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
 	unsigned char buf[4];
+	int i=0;
 
-	unsigned char  temp_reg;
+	//unsigned char  temp_reg;
 	//temp_reg=HI704_read_byte(0x22);
 	//buf[0]=0x22;
 	//temp_reg=i2c_get_byte_add8(client,buf);
@@ -898,8 +892,7 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 					{0x86 , 0x25},
 					{0xff , 0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -926,8 +919,7 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 					{0x86, 0x1c},   
 					{0xff, 0xff}    
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -954,8 +946,7 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 					{0x86, 0x1c},   
 					{0xff, 0xff}    
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -983,8 +974,7 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 					{0x86, 0x35}, 
 					{0xff, 0xff}    
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1010,8 +1000,7 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 					{0x86, 0x3d},   
 					{0xff, 0xff}    
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1037,8 +1026,7 @@ void set_HI704_param_wb(struct HI704_device *dev,enum  camera_wb_flip_e para)
 					{0x86, 0x10},   
 					{0xff, 0xff}  
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1079,8 +1067,9 @@ void HI704_night_mode(struct HI704_device *dev,enum  camera_night_mode_flip_e en
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
+	int i=0;
 
-	unsigned char  temp_reg;
+	//unsigned char  temp_reg;
 	//temp_reg=HI704_read_byte(0x22);
 	//buf[0]=0x20;
 	//temp_reg=i2c_get_byte_add8(client,buf);
@@ -1110,10 +1099,8 @@ void HI704_night_mode(struct HI704_device *dev,enum  camera_night_mode_flip_e en
 		
 				{0xff , 0xff},
 			};
-		int i=0;
-		unsigned char buf[2];
-		while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
-		{
+		i=0;
+		while (regs[i].addr!= 0xff && regs[i].val!= 0xff) {
 			buf[0]=regs[i].addr;
 			buf[1]=regs[i].val;
 			i2c_put_byte_add8(client,buf, 2);
@@ -1144,10 +1131,8 @@ void HI704_night_mode(struct HI704_device *dev,enum  camera_night_mode_flip_e en
 				{0x9f, 0xfa}, 
 				{0xff , 0xff},
 			};
-		int i=0;
-		unsigned char buf[2];
-		while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
-		{
+		i=0;
+		while (regs[i].addr!= 0xff && regs[i].val!= 0xff) {
 			buf[0]=regs[i].addr;
 			buf[1]=regs[i].val;
 			i2c_put_byte_add8(client,buf, 2);
@@ -1220,7 +1205,7 @@ struct aml_camera_i2c_fig_s regs50hz[]=
 	{0xff , 0xff},
 };
 
-void HI704_set_param_banding(struct HI704_device *dev,enum  camera_night_mode_flip_e banding)
+void HI704_set_param_banding(struct HI704_device *dev,enum  camera_banding_flip_e banding)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int i;
@@ -1247,6 +1232,8 @@ void HI704_set_param_banding(struct HI704_device *dev,enum  camera_night_mode_fl
 			i++;
 		}
 		break;
+	default:
+		break;
 
 	}
 	#endif
@@ -1364,6 +1351,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
+	int i;
 	#if 1
 	switch (para) {
 	case CAM_EFFECT_ENC_NORMAL:
@@ -1379,8 +1367,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 					{0x47,0x7f}, 
 					{0xff,0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1404,8 +1391,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 					{0x45 , 0x80},
 					{0xff , 0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1430,8 +1416,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 					{0x45 , 0x98},
 					{0xff , 0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1453,8 +1438,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 					{0x14 , 0x00},
 					{0xff , 0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1478,8 +1462,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 					{0x45 , 0x50},
 					{0xff , 0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1502,8 +1485,7 @@ void set_HI704_param_effect(struct HI704_device *dev,enum camera_effect_flip_e p
 					{0x45 , 0x40},
 					{0xff , 0xff},
 				};
-			int i=0;
-			unsigned char buf[2];
+				i=0;
 			while (regs[i].addr!= 0xff && regs[i].val!= 0xff)
 			{
 				buf[0]=regs[i].addr;
@@ -1531,7 +1513,7 @@ unsigned char v4l_2_HI704(int val)
 static int HI704_setting(struct HI704_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
+	//unsigned char cur_val;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -1639,7 +1621,7 @@ static int HI704_setting(struct HI704_device *dev,int PROP_ID,int value )
 	return ret;
 }
 
-static void power_down_HI704(struct HI704_device *dev)
+/*static void power_down_HI704(struct HI704_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
@@ -1649,7 +1631,7 @@ static void power_down_HI704(struct HI704_device *dev)
 
 	msleep(5);
 	return;
-}
+}*/
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -1964,7 +1946,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
 					struct v4l2_frmivalenum *fival)
 {
-	struct hi704_fmt *fmt;
 	unsigned int k;
 	
 	if(fival->index > ARRAY_SIZE(hi704_frmivalenum))
@@ -2007,8 +1988,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct HI704_fh *fh = priv;
 	struct HI704_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
 	
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2181,7 +2160,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2;//skip num
+	para.skip_count =  2;//skip num
 	para.bt_path = dev->cam_info.bt_path;
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
@@ -2348,6 +2327,11 @@ static int HI704_open(struct file *file)
 	struct HI704_device *dev = video_drvdata(file);
 	struct HI704_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2479,6 +2463,9 @@ static int HI704_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2634,10 +2621,14 @@ static const struct i2c_device_id HI704_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, HI704_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "HI704",
+static struct i2c_driver HI704_i2c_driver = {
+	.driver = {
+		.name = "HI704",
+	},
 	.probe = HI704_probe,
 	.remove = HI704_remove,
 	.id_table = HI704_id,
 };
 
+module_i2c_driver(HI704_i2c_driver);
+
diff --git a/drivers/amlogic/camera/nt99250.c b/drivers/amlogic/camera/nt99250.c
index edf66d6a7a46..5e1941f9b23a 100755
--- a/drivers/amlogic/camera/nt99250.c
+++ b/drivers/amlogic/camera/nt99250.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,14 +36,11 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 
@@ -50,19 +48,8 @@
 #include <mach/mod_gate.h>
 #endif
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend nt99250_early_suspend;
-#endif
-
 #define NT99250_CAMERA_MODULE_NAME "nt99250"		// NTK 2012-05-08
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -110,57 +97,11 @@ static struct v4l2_fract nt99250_frmintervals_active = {
 	.denominator = 15,
 };
 
-static int nt99250_have_opened = 0;
 static struct i2c_client *this_client;
 
 /* supported controls */
 static struct v4l2_queryctrl nt99250_qctrl[] = {
-	/*{
-		.id            = V4L2_CID_BRIGHTNESS,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Brightness",
-		.minimum       = 0,
-		.maximum       = 255,
-		.step          = 1,
-		.default_value = 127,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_CONTRAST,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Contrast",
-		.minimum       = 0x10,
-		.maximum       = 0x60,
-		.step          = 0xa,
-		.default_value = 0x30,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_SATURATION,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Saturation",
-		.minimum       = 0x28,
-		.maximum       = 0x60,
-		.step          = 0x8,
-		.default_value = 0x48,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_HFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on horizontal",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	} ,{
-		.id            = V4L2_CID_VFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on vertical",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},*/{
+	{
 		.id            = V4L2_CID_DO_WHITE_BALANCE,
 		.type          = V4L2_CTRL_TYPE_INTEGER,
 		.name          = "white balance",
@@ -416,10 +357,10 @@ struct nt99250_fh {
 	unsigned int f_flags;
 };
 
-static inline struct nt99250_fh *to_fh(struct nt99250_device *dev)
+/*static inline struct nt99250_fh *to_fh(struct nt99250_device *dev)
 {
 	return container_of(dev, struct nt99250_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete nt99250_prev_resolution[]=
 {
@@ -1214,7 +1155,7 @@ int NT99250_preview(struct nt99250_device *dev)
 {
 	// set NT99250 to preview mode
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int temp;
+	int temp_reg;
 	int i=0;
 	int regPreview[] =
 	{
@@ -1356,8 +1297,6 @@ int NT99250_preview(struct nt99250_device *dev)
 	i2c_put_byte(client,regPreview[i], regPreview[i+1]);
 	}
 	
-	int temp_reg;
-	
 	temp_reg=i2c_get_byte(client,0x3201);
 	//printk("NT99250_preview(CCCCC): NT99250_get_AE_AWB_3201=%x\n",temp_reg);
     //printk("wb mode: camera_wb_state=%d .\n",camera_wb_state);
@@ -1737,24 +1676,25 @@ void NT99250_set_night_mode(struct nt99250_device *dev,enum  camera_night_mode_f
 	}
 
 }    /* NT99250_NightMode */
-void NT99250_set_param_banding(struct nt99250_device *dev,enum  camera_night_mode_flip_e banding)
+void NT99250_set_param_banding(struct nt99250_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
 	int temp;
-	switch(banding)
-	{
-		case CAM_BANDING_50HZ:			
-			temp = i2c_get_byte(client, 0x32bb);
-			temp = temp | 0x8; // banding 50, bit[3] = 1
-			i2c_put_byte(client, 0x32bb, temp);				
-			printk(KERN_INFO "banding 50 in\n");			
-			break;
-		case CAM_BANDING_60HZ:			
-			temp = i2c_get_byte(client, 0x32bb);
-			temp = temp & 0xf7; // banding 60, bit[3] = 0
-			i2c_put_byte(client, 0x32bb, temp);									
-			printk(KERN_INFO " banding 60 in\n ");				
-			break;
+	switch(banding){
+	case CAM_BANDING_50HZ:			
+		temp = i2c_get_byte(client, 0x32bb);
+		temp = temp | 0x8; // banding 50, bit[3] = 1
+		i2c_put_byte(client, 0x32bb, temp);				
+		printk(KERN_INFO "banding 50 in\n");			
+		break;
+	case CAM_BANDING_60HZ:			
+		temp = i2c_get_byte(client, 0x32bb);
+		temp = temp & 0xf7; // banding 60, bit[3] = 0
+		i2c_put_byte(client, 0x32bb, temp);									
+		printk(KERN_INFO " banding 60 in\n ");				
+		break;
+	default:
+		break;
 	}
 }
 
@@ -1762,7 +1702,6 @@ static int set_flip(struct nt99250_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char temp;
-	unsigned char buf[2];
 	temp = i2c_get_byte(client, 0x3022);
 	temp &= 0xfc;
 	temp |= dev->cam_info.m_flip << 1;
@@ -1777,7 +1716,7 @@ static int set_flip(struct nt99250_device *dev)
 void NT99250_set_resolution(struct nt99250_device *dev,int height,int width)
 {
 
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
     #if 1	 
 	if(height&&width&&(height<=1200)&&(width<=1600))
@@ -1824,8 +1763,8 @@ unsigned char v4l_2_nt99250(int val)
 static int nt99250_setting(struct nt99250_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
 		//dprintk(dev, 1, "setting brightned:%d\n",v4l_2_NT99250(value));
@@ -1936,9 +1875,9 @@ static int nt99250_setting(struct nt99250_device *dev,int PROP_ID,int value )
 
 static void power_down_nt99250(struct nt99250_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//i2c_put_byte(client,0x3012, 0x80);
-	msleep(5);
+	//msleep(5);
 	//i2c_put_byte(client,0x30ab, 0x00);
 	//i2c_put_byte(client,0x30ad, 0x0a);
 	//i2c_put_byte(client,0x30ae, 0x27);
@@ -2258,7 +2197,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
 					struct v4l2_frmivalenum *fival)
 {
-	struct nt99250_fmt *fmt;
 	unsigned int k;
 	
 	if(fival->index > ARRAY_SIZE(nt99250_frmivalenum))
@@ -2301,9 +2239,7 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct nt99250_fh *fh = priv;
 	struct nt99250_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
-	
+
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
@@ -2459,7 +2395,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2;//skip num
+	para.skip_count =  2;//skip num
 	para.bt_path = dev->cam_info.bt_path;
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
@@ -2621,18 +2557,23 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 /* ------------------------------------------------------------------
 	File operations for the device
    ------------------------------------------------------------------*/
-void NT99250_get_AE_AWB_3201(struct nt99250_device *dev)		//_GJL_
+/*void NT99250_get_AE_AWB_3201(struct nt99250_device *dev)		//_GJL_
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int temp_reg=i2c_get_byte(client,0x3201);
 	//dprintk("_GJL_  NT99250_get_AE_AWB_3201=%x\n",temp_reg);
-}
+}*/
 
 static int nt99250_open(struct file *file)
 {
 	struct nt99250_device *dev = video_drvdata(file);
 	struct nt99250_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2769,6 +2710,9 @@ static int nt99250_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2897,6 +2841,7 @@ static int nt99250_probe(struct i2c_client *client,
 	int err;
 	struct nt99250_device *t;
 	struct v4l2_subdev *sd;
+	int ret;
 	aml_cam_info_t* plat_dat;
 	vops = get_vdin_v4l2_ops();
 	v4l_info(client, "chip found @ 0x%x (%s)\n",
@@ -2952,7 +2897,6 @@ static int nt99250_probe(struct i2c_client *client,
 		return err;
 	}
 
-	int ret;
 	ret = class_register(&camera_ctrl_class);
 	if(ret){
 		printk("class register camera_ctrl_class fail!\n");
@@ -2978,10 +2922,14 @@ static const struct i2c_device_id nt99250_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, nt99250_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "nt99250",
+static struct i2c_driver nt99250_i2c_driver = {
+	.driver = {
+		.name = "nt99250",
+	},
 	.probe = nt99250_probe,
 	.remove = nt99250_remove,
 	.id_table = nt99250_id,
 };
 
+module_i2c_driver(nt99250_i2c_driver);
+
diff --git a/drivers/amlogic/camera/nt99252.c b/drivers/amlogic/camera/nt99252.c
index b42b502b3454..a112f447eaed 100755
--- a/drivers/amlogic/camera/nt99252.c
+++ b/drivers/amlogic/camera/nt99252.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,32 +36,19 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 #include <mach/gpio.h>
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend nt99252_early_suspend;
-#endif
 
 #define NT99252_CAMERA_MODULE_NAME "nt99252"
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -125,52 +113,7 @@ static struct i2c_client *this_client;
 static struct vdin_v4l2_ops_s *vops;
 /* supported controls */
 static struct v4l2_queryctrl nt99252_qctrl[] = {
-	/*{
-		.id            = V4L2_CID_BRIGHTNESS,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Brightness",
-		.minimum       = 0,
-		.maximum       = 255,
-		.step          = 1,
-		.default_value = 127,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_CONTRAST,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Contrast",
-		.minimum       = 0x10,
-		.maximum       = 0x60,
-		.step          = 0xa,
-		.default_value = 0x30,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_SATURATION,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Saturation",
-		.minimum       = 0x28,
-		.maximum       = 0x60,
-		.step          = 0x8,
-		.default_value = 0x48,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_HFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on horizontal",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	} ,{
-		.id            = V4L2_CID_VFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on vertical",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},*/{
+	{
 		.id            = V4L2_CID_DO_WHITE_BALANCE,
 		.type          = V4L2_CTRL_TYPE_INTEGER,
 		.name          = "white balance",
@@ -425,10 +368,10 @@ struct nt99252_fh {
 	unsigned int   f_flags;
 };
 
-static inline struct nt99252_fh *to_fh(struct nt99252_device *dev)
+/*static inline struct nt99252_fh *to_fh(struct nt99252_device *dev)
 {
 	return container_of(dev, struct nt99252_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete nt99252_prev_resolution[]=
 {
@@ -450,10 +393,9 @@ static struct v4l2_frmsize_discrete nt99252_pic_resolution[]=
 struct aml_camera_i2c_fig_s NT99252_script[] = {
 	//NT99252 initial
 	{0x32F0, 0x03}, // Output Format
-	///*
 	{0x3069, 0x00}, //data & v/s(sync)
 	{0x306A, 0x01}, //pclk
-	/*//*
+	/*
 	{0x3069, 0x01}, //data & v/s(sync)
 	{0x306A, 0x01}, //pclk
 	*/
@@ -1104,62 +1046,60 @@ void NT99252_set_param_effect(struct nt99252_device *dev,enum camera_effect_flip
 void NT99252_set_night_mode(struct nt99252_device *dev,enum  camera_night_mode_flip_e enable)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int temp;
-	if (enable)
-	{
+	//int temp;
+	if (enable) {
 	     i2c_put_byte(client, 0x302A,0x04);		
-	}
-	else
-	{
+	} else {
 	     i2c_put_byte(client, 0x302A,0x00);	
 	}
 
 }    /* NT99252_NightMode */
-void NT99252_set_param_banding(struct nt99252_device *dev,enum  camera_night_mode_flip_e banding)
+void NT99252_set_param_banding(struct nt99252_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
-	int temp;
-	switch(banding)
-	{
-		case CAM_BANDING_50HZ:			
-			i2c_put_byte(client, 0x32BF, 0x60);
-			i2c_put_byte(client, 0x32C0, 0x78);
-			i2c_put_byte(client, 0x32C1, 0x78);
-			i2c_put_byte(client, 0x32C2, 0x78);
-			i2c_put_byte(client, 0x32C3, 0x00);
-			i2c_put_byte(client, 0x32C4, 0x28);
-			i2c_put_byte(client, 0x32C5, 0x28);
-			i2c_put_byte(client, 0x32C6, 0x28);
-			i2c_put_byte(client, 0x32C7, 0x00);
-			i2c_put_byte(client, 0x32C8, 0xB9);
-			i2c_put_byte(client, 0x32C9, 0x78);
-			i2c_put_byte(client, 0x32CA, 0x98);
-			i2c_put_byte(client, 0x32CB, 0x98);
-			i2c_put_byte(client, 0x32CC, 0x98);
-			i2c_put_byte(client, 0x32CD, 0x98);
-			i2c_put_byte(client, 0x32DB, 0x77);
-		
-			printk(KERN_INFO "banding 50 in\n");			
-			break;
-		case CAM_BANDING_60HZ:			
-			i2c_put_byte(client, 0x32BF, 0x60);
-			i2c_put_byte(client, 0x32C0, 0x7C);
-			i2c_put_byte(client, 0x32C1, 0x7C);
-			i2c_put_byte(client, 0x32C2, 0x7C);
-			i2c_put_byte(client, 0x32C3, 0x00);
-			i2c_put_byte(client, 0x32C4, 0x28);
-			i2c_put_byte(client, 0x32C5, 0x28);
-			i2c_put_byte(client, 0x32C6, 0x28);
-			i2c_put_byte(client, 0x32C7, 0x00);
-			i2c_put_byte(client, 0x32C8, 0x9A);
-			i2c_put_byte(client, 0x32C9, 0x7C);
-			i2c_put_byte(client, 0x32CA, 0x9C);
-			i2c_put_byte(client, 0x32CB, 0x9C);
-			i2c_put_byte(client, 0x32CC, 0x9C);
-			i2c_put_byte(client, 0x32CD, 0x9C);
-			i2c_put_byte(client, 0x32DB, 0x73);							
-			printk(KERN_INFO " banding 60 in\n ");				
-			break;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
+	//int temp;
+	switch(banding) {
+	case CAM_BANDING_50HZ:			
+		i2c_put_byte(client, 0x32BF, 0x60);
+		i2c_put_byte(client, 0x32C0, 0x78);
+		i2c_put_byte(client, 0x32C1, 0x78);
+		i2c_put_byte(client, 0x32C2, 0x78);
+		i2c_put_byte(client, 0x32C3, 0x00);
+		i2c_put_byte(client, 0x32C4, 0x28);
+		i2c_put_byte(client, 0x32C5, 0x28);
+		i2c_put_byte(client, 0x32C6, 0x28);
+		i2c_put_byte(client, 0x32C7, 0x00);
+		i2c_put_byte(client, 0x32C8, 0xB9);
+		i2c_put_byte(client, 0x32C9, 0x78);
+		i2c_put_byte(client, 0x32CA, 0x98);
+		i2c_put_byte(client, 0x32CB, 0x98);
+		i2c_put_byte(client, 0x32CC, 0x98);
+		i2c_put_byte(client, 0x32CD, 0x98);
+		i2c_put_byte(client, 0x32DB, 0x77);
+	
+		printk(KERN_INFO "banding 50 in\n");			
+		break;
+	case CAM_BANDING_60HZ:			
+		i2c_put_byte(client, 0x32BF, 0x60);
+		i2c_put_byte(client, 0x32C0, 0x7C);
+		i2c_put_byte(client, 0x32C1, 0x7C);
+		i2c_put_byte(client, 0x32C2, 0x7C);
+		i2c_put_byte(client, 0x32C3, 0x00);
+		i2c_put_byte(client, 0x32C4, 0x28);
+		i2c_put_byte(client, 0x32C5, 0x28);
+		i2c_put_byte(client, 0x32C6, 0x28);
+		i2c_put_byte(client, 0x32C7, 0x00);
+		i2c_put_byte(client, 0x32C8, 0x9A);
+		i2c_put_byte(client, 0x32C9, 0x7C);
+		i2c_put_byte(client, 0x32CA, 0x9C);
+		i2c_put_byte(client, 0x32CB, 0x9C);
+		i2c_put_byte(client, 0x32CC, 0x9C);
+		i2c_put_byte(client, 0x32CD, 0x9C);
+		i2c_put_byte(client, 0x32DB, 0x73);							
+		printk(KERN_INFO " banding 60 in\n ");				
+		break;
+	default:
+		break;
 	}
 }
 
@@ -1167,10 +1107,7 @@ static int set_flip(struct nt99252_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char temp;
-	unsigned char buf[2];
-	buf[0]=0x3021;
-	buf[1]=0x60;
-	i2c_put_byte(client,buf[0],buf[1]);
+	i2c_put_byte(client,0x3021,0x60);
 	temp = i2c_get_byte(client, 0x3022);
 	temp &= 0xfc;
 	temp |= dev->cam_info.m_flip << 1;
@@ -1186,8 +1123,8 @@ static int set_flip(struct nt99252_device *dev)
 void NT99252_set_resolution(struct nt99252_device *dev,int height,int width)
 {
 
-	int ret;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//int ret;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
 #if 1	 
 	if(height&&width&&(height<=1200)&&(width<=1600))
@@ -1234,8 +1171,8 @@ unsigned char v4l_2_nt99252(int val)
 static int nt99252_setting(struct nt99252_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
 		//dprintk(dev, 1, "setting brightned:%d\n",v4l_2_NT99252(value));
@@ -1346,7 +1283,7 @@ static int nt99252_setting(struct nt99252_device *dev,int PROP_ID,int value )
 
 static void power_down_nt99252(struct nt99252_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//i2c_put_byte(client,0x3012, 0x80);
 	msleep(5);
 	//i2c_put_byte(client,0x30ab, 0x00);
@@ -1665,7 +1602,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct nt99252_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(nt99252_frmivalenum))
@@ -1709,8 +1645,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct nt99252_fh *fh = priv;
     struct nt99252_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -1796,19 +1730,6 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	} else if (vidio_set_fmt_ticks==1) {
 		NT99252_set_resolution(dev,fh->height,fh->width);
 		}
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT	
-	if (dev->platform_dev_data.flash_support) {
-		if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
-			if (get_flashlightflag() == FLASHLIGHT_ON) {
-				set_flashlight(true);
-			}
-		} else if(f->fmt.pix.pixelformat == V4L2_PIX_FMT_NV21){
-			if (get_flashlightflag() != FLASHLIGHT_TORCH) {
-				set_flashlight(false);
-			}		
-		}
-	}
-#endif	
 
 	ret = 0;
 out:
@@ -1878,7 +1799,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2;//skip num
+	para.skip_count =  2;//skip num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
             vops->start_tvin_service(0,&para);
@@ -2039,17 +1960,22 @@ static int vidioc_s_ctrl(struct file *file, void *priv,
 /* ------------------------------------------------------------------
 	File operations for the device
    ------------------------------------------------------------------*/
-void NT99252_get_AE_AWB_3201(struct nt99252_device *dev)		//_GJL_
+/*void NT99252_get_AE_AWB_3201(struct nt99252_device *dev)		//_GJL_
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int temp_reg=i2c_get_byte(client,0x3201);
 	//dprintk("_GJL_  NT99252_get_AE_AWB_3201=%x\n",temp_reg);
-}
+}*/
 static int nt99252_open(struct file *file)
 {
 	struct nt99252_device *dev = video_drvdata(file);
 	struct nt99252_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2181,6 +2107,9 @@ static int nt99252_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2309,8 +2238,10 @@ static int nt99252_probe(struct i2c_client *client,
 	int err;
 	struct nt99252_device *t;
 	struct v4l2_subdev *sd;
+	int ret;
 	aml_cam_info_t* plat_dat;
 	vops = get_vdin_v4l2_ops();
+	
 	v4l_info(client, "chip found @ 0x%x (%s)\n",
 			client->addr << 1, client->adapter->name);
 	t = kzalloc(sizeof(*t), GFP_KERNEL);
@@ -2352,7 +2283,6 @@ static int nt99252_probe(struct i2c_client *client,
 		return err;
 	}
 
-	int ret;
 	ret = class_register(&camera_ctrl_class);
 	if(ret){
 		printk(" class register camera_ctrl_class fail!\n");
@@ -2378,11 +2308,15 @@ static const struct i2c_device_id nt99252_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, nt99252_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "nt99252",
+static struct i2c_driver nt99252_i2c_driver = {
+	.driver = {
+		.name = "nt99252",
+	},
 	.probe = nt99252_probe,
 	.remove = nt99252_remove,
 	.id_table = nt99252_id,
 };
 
+module_i2c_driver(nt99252_i2c_driver);
+
 
diff --git a/drivers/amlogic/camera/nt99340.c b/drivers/amlogic/camera/nt99340.c
index 609f8f469c5f..e48f207bd604 100755
--- a/drivers/amlogic/camera/nt99340.c
+++ b/drivers/amlogic/camera/nt99340.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,32 +36,19 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <mach/gpio.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend nt99340_early_suspend;
-#endif
 
 #define NT99340_CAMERA_MODULE_NAME "nt99340"
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -101,52 +89,7 @@ static struct v4l2_fract nt99340_frmintervals_active = {
 static struct vdin_v4l2_ops_s *vops;
 /* supported controls */
 static struct v4l2_queryctrl nt99340_qctrl[] = {
-	/*{
-		.id            = V4L2_CID_BRIGHTNESS,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Brightness",
-		.minimum       = 0,
-		.maximum       = 255,
-		.step          = 1,
-		.default_value = 127,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_CONTRAST,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Contrast",
-		.minimum       = 0x10,
-		.maximum       = 0x60,
-		.step          = 0xa,
-		.default_value = 0x30,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_SATURATION,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Saturation",
-		.minimum       = 0x28,
-		.maximum       = 0x60,
-		.step          = 0x8,
-		.default_value = 0x48,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.id            = V4L2_CID_HFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on horizontal",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	} ,{
-		.id            = V4L2_CID_VFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on vertical",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},*/{
+	{
 		.id            = V4L2_CID_DO_WHITE_BALANCE,
 		.type          = V4L2_CTRL_TYPE_INTEGER,
 		.name          = "white balance",
@@ -413,10 +356,10 @@ struct nt99340_fh {
 	unsigned int   f_flags;
 };
 
-static inline struct nt99340_fh *to_fh(struct nt99340_device *dev)
+/*static inline struct nt99340_fh *to_fh(struct nt99340_device *dev)
 {
 	return container_of(dev, struct nt99340_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete nt99340_prev_resolution[]=
 {
@@ -1097,64 +1040,62 @@ void NT99340_set_param_effect(struct nt99340_device *dev,enum camera_effect_flip
 void NT99340_set_night_mode(struct nt99340_device *dev,enum  camera_night_mode_flip_e enable)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int temp;
-	if (enable)
-	{
+	//int temp;
+	if (enable) {
 		i2c_put_byte(client, 0x32C4, 0x28);
 		i2c_put_byte(client, 0x302A, 0x04);
-	}
-	else
-	{
+	} else {
 		i2c_put_byte(client, 0x32C4, 0x20);
 		i2c_put_byte(client, 0x302A, 0x00);
 	}
 
 }    /* NT99340_NightMode */
-void NT99340_set_param_banding(struct nt99340_device *dev,enum  camera_night_mode_flip_e banding)
+void NT99340_set_param_banding(struct nt99340_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
-	int temp;
-	switch(banding)
-	{
-		case CAM_BANDING_50HZ:			
-			i2c_put_byte(client, 0x32BF, 0x60);
-			i2c_put_byte(client, 0x32C0, 0x78);
-			i2c_put_byte(client, 0x32C1, 0x78);
-			i2c_put_byte(client, 0x32C2, 0x78);
-			i2c_put_byte(client, 0x32C3, 0x00);
-			i2c_put_byte(client, 0x32C4, 0x20);
-			i2c_put_byte(client, 0x32C5, 0x20);
-			i2c_put_byte(client, 0x32C6, 0x20);
-			i2c_put_byte(client, 0x32C7, 0x00);
-			i2c_put_byte(client, 0x32C8, 0x78);
-			i2c_put_byte(client, 0x32C9, 0x78);
-			i2c_put_byte(client, 0x32CA, 0x98);
-			i2c_put_byte(client, 0x32CB, 0x98);
-			i2c_put_byte(client, 0x32CC, 0x98);
-			i2c_put_byte(client, 0x32CD, 0x98);
-			i2c_put_byte(client, 0x32DB, 0x6E);
-			i2c_put_byte(client, 0x32D0, 0x01);
-			printk(KERN_INFO "banding 50 in\n");			
-			break;
-		case CAM_BANDING_60HZ:			
-			i2c_put_byte(client, 0x32BF, 0x60);
-			i2c_put_byte(client, 0x32C0, 0x7C);
-			i2c_put_byte(client, 0x32C1, 0x7C);
-			i2c_put_byte(client, 0x32C2, 0x7C);
-			i2c_put_byte(client, 0x32C3, 0x00);
-			i2c_put_byte(client, 0x32C4, 0x20);
-			i2c_put_byte(client, 0x32C5, 0x20);
-			i2c_put_byte(client, 0x32C6, 0x20);
-			i2c_put_byte(client, 0x32C7, 0x00);
-			i2c_put_byte(client, 0x32C8, 0x64);
-			i2c_put_byte(client, 0x32C9, 0x7C);
-			i2c_put_byte(client, 0x32CA, 0x9C);
-			i2c_put_byte(client, 0x32CB, 0x9C);
-			i2c_put_byte(client, 0x32CC, 0x9C);
-			i2c_put_byte(client, 0x32CD, 0x9C);
-			i2c_put_byte(client, 0x32DB, 0x68);
-			i2c_put_byte(client, 0x32D0, 0x01);
-			printk(KERN_INFO " banding 60 in\n ");				
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
+	//int temp;
+	switch(banding) {
+	case CAM_BANDING_50HZ:			
+		i2c_put_byte(client, 0x32BF, 0x60);
+		i2c_put_byte(client, 0x32C0, 0x78);
+		i2c_put_byte(client, 0x32C1, 0x78);
+		i2c_put_byte(client, 0x32C2, 0x78);
+		i2c_put_byte(client, 0x32C3, 0x00);
+		i2c_put_byte(client, 0x32C4, 0x20);
+		i2c_put_byte(client, 0x32C5, 0x20);
+		i2c_put_byte(client, 0x32C6, 0x20);
+		i2c_put_byte(client, 0x32C7, 0x00);
+		i2c_put_byte(client, 0x32C8, 0x78);
+		i2c_put_byte(client, 0x32C9, 0x78);
+		i2c_put_byte(client, 0x32CA, 0x98);
+		i2c_put_byte(client, 0x32CB, 0x98);
+		i2c_put_byte(client, 0x32CC, 0x98);
+		i2c_put_byte(client, 0x32CD, 0x98);
+		i2c_put_byte(client, 0x32DB, 0x6E);
+		i2c_put_byte(client, 0x32D0, 0x01);
+		printk(KERN_INFO "banding 50 in\n");			
+		break;
+	case CAM_BANDING_60HZ:			
+		i2c_put_byte(client, 0x32BF, 0x60);
+		i2c_put_byte(client, 0x32C0, 0x7C);
+		i2c_put_byte(client, 0x32C1, 0x7C);
+		i2c_put_byte(client, 0x32C2, 0x7C);
+		i2c_put_byte(client, 0x32C3, 0x00);
+		i2c_put_byte(client, 0x32C4, 0x20);
+		i2c_put_byte(client, 0x32C5, 0x20);
+		i2c_put_byte(client, 0x32C6, 0x20);
+		i2c_put_byte(client, 0x32C7, 0x00);
+		i2c_put_byte(client, 0x32C8, 0x64);
+		i2c_put_byte(client, 0x32C9, 0x7C);
+		i2c_put_byte(client, 0x32CA, 0x9C);
+		i2c_put_byte(client, 0x32CB, 0x9C);
+		i2c_put_byte(client, 0x32CC, 0x9C);
+		i2c_put_byte(client, 0x32CD, 0x9C);
+		i2c_put_byte(client, 0x32DB, 0x68);
+		i2c_put_byte(client, 0x32D0, 0x01);
+		printk(KERN_INFO " banding 60 in\n ");				
+		break;
+	default:
 			break;
 	}
 }
@@ -1163,10 +1104,7 @@ static int set_flip(struct nt99340_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char temp;
-	unsigned char buf[2];
-        buf[0]=0x3021;
-        buf[1]=0x60;
-	i2c_put_byte(client,buf[0],buf[1]);
+	i2c_put_byte(client, 0x3021, 0x60);
 	temp = i2c_get_byte(client, 0x3022);
 	temp &= 0xfc;
 	temp |= dev->cam_info.m_flip << 1;
@@ -1181,8 +1119,8 @@ static int set_flip(struct nt99340_device *dev)
 void NT99340_set_resolution(struct nt99340_device *dev,int height,int width)
 {
 
-	int ret;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//int ret;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
 #if 1	 
 	if(height&&width&&(height<=1536)&&(width<=2048))
@@ -1229,8 +1167,8 @@ unsigned char v4l_2_nt99340(int val)
 static int nt99340_setting(struct nt99340_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
 		//dprintk(dev, 1, "setting brightned:%d\n",v4l_2_NT99340(value));
@@ -1341,7 +1279,7 @@ static int nt99340_setting(struct nt99340_device *dev,int PROP_ID,int value )
 
 static void power_down_nt99340(struct nt99340_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//i2c_put_byte(client,0x3012, 0x80);
 	msleep(5);
 	//i2c_put_byte(client,0x30ab, 0x00);
@@ -1659,7 +1597,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct nt99340_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(nt99340_frmivalenum))
@@ -1767,19 +1704,6 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	} else if (vidio_set_fmt_ticks==1) {
 		NT99340_set_resolution(dev,fh->height,fh->width);
 	}
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT	
-	if (dev->platform_dev_data.flash_support) {
-		if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
-			if (get_flashlightflag() == FLASHLIGHT_ON) {
-				set_flashlight(true);
-			}
-		} else if(f->fmt.pix.pixelformat == V4L2_PIX_FMT_NV21){
-			if (get_flashlightflag() != FLASHLIGHT_TORCH) {
-				set_flashlight(false);
-			}		
-		}
-	}
-#endif	
 
 	ret = 0;
 out:
@@ -1793,8 +1717,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct nt99340_fh *fh = priv;
     struct nt99340_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -1870,7 +1792,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2;//skip num
+	para.skip_count =  2;//skip num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
             vops->start_tvin_service(0,&para);
@@ -2036,6 +1958,11 @@ static int nt99340_open(struct file *file)
 	struct nt99340_device *dev = video_drvdata(file);
 	struct nt99340_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2167,6 +2094,9 @@ static int nt99340_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2295,6 +2225,7 @@ static int nt99340_probe(struct i2c_client *client,
 	int err;
 	struct nt99340_device *t;
 	struct v4l2_subdev *sd;
+	int ret;
         aml_cam_info_t* plat_dat;
         vops = get_vdin_v4l2_ops();
 	v4l_info(client, "chip found @ 0x%x (%s)\n",
@@ -2337,7 +2268,7 @@ static int nt99340_probe(struct i2c_client *client,
 		return err;
 	}
 
-	int ret;
+	
 	ret = class_register(&camera_ctrl_class);
 	if(ret){
 		printk(" class register camera_ctrl_class fail!\n");
@@ -2363,10 +2294,14 @@ static const struct i2c_device_id nt99340_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, nt99340_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "nt99340",
+static struct i2c_driver nt99340_i2c_driver = {
+	.driver = {
+		.name = "nt99340",
+	},
 	.probe = nt99340_probe,
 	.remove = nt99340_remove,
 	.id_table = nt99340_id,
 };
 
+module_i2c_driver(nt99340_i2c_driver);
+
diff --git a/drivers/amlogic/camera/ov2655.c b/drivers/amlogic/camera/ov2655.c
index 060db748dc70..c5c70606c600 100755
--- a/drivers/amlogic/camera/ov2655.c
+++ b/drivers/amlogic/camera/ov2655.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,13 +36,10 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <mach/gpio.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 
@@ -49,19 +47,8 @@
 #include <mach/mod_gate.h>
 #endif
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend ov2655_early_suspend;
-#endif
-
 #define OV2655_CAMERA_MODULE_NAME "ov2655"
 
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -73,8 +60,6 @@ extern int set_flashlight(bool mode);
 #define OV2655_CAMERA_VERSION \
 	KERNEL_VERSION(OV2655_CAMERA_MAJOR_VERSION, OV2655_CAMERA_MINOR_VERSION, OV2655_CAMERA_RELEASE)
 
-static unsigned short DGain_shutter,AGain_shutter,DGain_shutterH,DGain_shutterL,AGain_shutterH,AGain_shutterL,shutterH,shutterL,shutter;
-static unsigned short UXGA_Cap = 0;
 
 MODULE_DESCRIPTION("ov2655 On Board");
 MODULE_AUTHOR("amlogic-sh");
@@ -357,10 +342,10 @@ struct ov2655_fh {
 	int  stream_on;
 };
 
-static inline struct ov2655_fh *to_fh(struct ov2655_device *dev)
+/*static inline struct ov2655_fh *to_fh(struct ov2655_device *dev)
 {
 	return container_of(dev, struct ov2655_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete ov2655_prev_resolution[2]=
 {
@@ -1275,57 +1260,57 @@ void OV2655_set_param_wb(struct ov2655_device *dev,enum  camera_wb_flip_e para)/
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int temp_reg=i2c_get_byte(client,0x3306);
 
-    switch (para)
-	{
-
-		case CAM_WB_AUTO://auto
-			i2c_put_byte(client,0x3306, temp_reg&~0x2);   // select Auto WB
-			break;
+	switch (para) {
+	case CAM_WB_AUTO://auto
+		i2c_put_byte(client,0x3306, temp_reg&~0x2);   // select Auto WB
+		break;
 
-		case CAM_WB_CLOUD: //cloud
+	case CAM_WB_CLOUD: //cloud
 
-			i2c_put_byte(client,0x3306, temp_reg|0x2);  // select manual WB
-			i2c_put_byte(client,0x3337, 0x68); //manual R G B
-			i2c_put_byte(client,0x3338, 0x40);
-			i2c_put_byte(client,0x3339, 0x4e);
-			break;
+		i2c_put_byte(client,0x3306, temp_reg|0x2);  // select manual WB
+		i2c_put_byte(client,0x3337, 0x68); //manual R G B
+		i2c_put_byte(client,0x3338, 0x40);
+		i2c_put_byte(client,0x3339, 0x4e);
+		break;
 
-		case CAM_WB_DAYLIGHT: //
+	case CAM_WB_DAYLIGHT: //
 
-			i2c_put_byte(client,0x3306, temp_reg|0x2);  // Disable AWB
-			i2c_put_byte(client,0x3337, 0x5e);
-			i2c_put_byte(client,0x3338, 0x40);
-			i2c_put_byte(client,0x3339, 0x46);
-			break;
+		i2c_put_byte(client,0x3306, temp_reg|0x2);  // Disable AWB
+		i2c_put_byte(client,0x3337, 0x5e);
+		i2c_put_byte(client,0x3338, 0x40);
+		i2c_put_byte(client,0x3339, 0x46);
+		break;
 
-		case CAM_WB_INCANDESCENCE:
+	case CAM_WB_INCANDESCENCE:
 
-			i2c_put_byte(client,0x3306, temp_reg|0x2);  // Disable AWB
-			i2c_put_byte(client,0x3337, 0x5e);
-			i2c_put_byte(client,0x3338, 0x40);
-			i2c_put_byte(client,0x3339, 0x58);
-			break;
+		i2c_put_byte(client,0x3306, temp_reg|0x2);  // Disable AWB
+		i2c_put_byte(client,0x3337, 0x5e);
+		i2c_put_byte(client,0x3338, 0x40);
+		i2c_put_byte(client,0x3339, 0x58);
+		break;
 
-		case CAM_WB_TUNGSTEN:
+	case CAM_WB_TUNGSTEN:
 
-			i2c_put_byte(client,0x13, temp_reg|0x2);	// Disable AWB
-			i2c_put_byte(client,0x3337, 0x54);
-			i2c_put_byte(client,0x3338, 0x40);
-			i2c_put_byte(client,0x3339, 0x70);
-			break;
+		i2c_put_byte(client,0x13, temp_reg|0x2);	// Disable AWB
+		i2c_put_byte(client,0x3337, 0x54);
+		i2c_put_byte(client,0x3338, 0x40);
+		i2c_put_byte(client,0x3339, 0x70);
+		break;
 
-      	case CAM_WB_FLUORESCENT:
+	case CAM_WB_FLUORESCENT:
 
-			i2c_put_byte(client,0x3306, temp_reg|0x2); // Disable AWB
-			i2c_put_byte(client,0x3337, 0x65);
-			i2c_put_byte(client,0x3338, 0x40);
-			i2c_put_byte(client,0x3339, 0x41);
+		i2c_put_byte(client,0x3306, temp_reg|0x2); // Disable AWB
+		i2c_put_byte(client,0x3337, 0x65);
+		i2c_put_byte(client,0x3338, 0x40);
+		i2c_put_byte(client,0x3339, 0x41);
 
-			break;
+		break;
 
-		case CAM_WB_MANUAL:
-		    	// TODO
-			break;
+	case CAM_WB_MANUAL:
+	    	// TODO
+		break;
+	default:
+		break;
 	}
 
 
@@ -1606,85 +1591,59 @@ void OV2655_set_night_mode(struct ov2655_device *dev,enum  camera_night_mode_fli
 	}
 
 }    /* OV2655_NightMode */
-void OV2655_set_param_banding(struct ov2655_device *dev,enum  camera_night_mode_flip_e banding)
+void OV2655_set_param_banding(struct ov2655_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
-	int temp,temp1,temp2,temp3,temp4;
-	switch(banding)
-		{
-		case CAM_BANDING_50HZ:
-			temp = i2c_get_byte(client, 0x3014);
-			temp = temp | 0x80; // banding 50, bit[3] = 1
-			i2c_put_byte(client, 0x3014, temp);
-
-			i2c_put_byte(client, 0x3070, 0x58);
-			i2c_put_byte(client, 0x3071, 0x00);
-			i2c_put_byte(client, 0x301c, 0x06);
-
-//			temp1 = i2c_get_byte(client, 0x3070);
-//			temp2 = i2c_get_byte(client, 0x301c);
-//			temp3 = i2c_get_byte(client, 0x302a);
-//			temp4 = i2c_get_byte(client, 0x302b);
-//			//printk(KERN_INFO "band_step50	=%x\n",band_step50);
-//			printk(KERN_INFO "	0x3070	=%x\n",temp1);
-//			printk(KERN_INFO "	0x301c	=%x\n",temp2);
-//			printk(KERN_INFO "	0x302a	=%x\n",temp3);
-//			printk(KERN_INFO "	0x302b	=%x\n",temp4);
-
-			//i2c_put_byte(client,0x0315,0x16);
-			printk(KERN_INFO "banding 50 in\n");
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int temp;
+	switch(banding) {
+	case CAM_BANDING_50HZ:
+		temp = i2c_get_byte(client, 0x3014);
+		temp = temp | 0x80; // banding 50, bit[3] = 1
+		i2c_put_byte(client, 0x3014, temp);
 
-			break;
-		case CAM_BANDING_60HZ:
-			temp = i2c_get_byte(client, 0x3014);
-			temp = temp & 0x7f; // night mode on, bit[3] = 1
-			i2c_put_byte(client, 0x3014, temp);
-			//i2c_put_byte(client,0x0315,0x56);
-
-			i2c_put_byte(client, 0x3072, 0x49);
-			i2c_put_byte(client, 0x3073, 0x00);
-			i2c_put_byte(client, 0x301d, 0x07);
-//
-//			temp1 = i2c_get_byte(client, 0x3072);
-//			temp2 = i2c_get_byte(client, 0x301d);
-//			temp3 = i2c_get_byte(client, 0x302a);
-//			temp4 = i2c_get_byte(client, 0x302b);
-//			//printk(KERN_INFO "band_step50	=%x\n",band_step50);
-//			printk(KERN_INFO "	0x3072	=%x\n",temp1);
-//			printk(KERN_INFO "	0x301d	=%x\n",temp2);
-//			printk(KERN_INFO "	0x302a	=%x\n",temp3);
-//			printk(KERN_INFO "	0x302b	=%x\n",temp4);
-
-			printk(KERN_INFO " banding 60 in\n ");
-			break;
+		i2c_put_byte(client, 0x3070, 0x58);
+		i2c_put_byte(client, 0x3071, 0x00);
+		i2c_put_byte(client, 0x301c, 0x06);
 
-		}
+		printk(KERN_INFO "banding 50 in\n");
+
+		break;
+	case CAM_BANDING_60HZ:
+		temp = i2c_get_byte(client, 0x3014);
+		temp = temp & 0x7f; // night mode on, bit[3] = 1
+		i2c_put_byte(client, 0x3014, temp);
+		//i2c_put_byte(client,0x0315,0x56);
+
+		i2c_put_byte(client, 0x3072, 0x49);
+		i2c_put_byte(client, 0x3073, 0x00);
+		i2c_put_byte(client, 0x301d, 0x07);
+
+		printk(KERN_INFO " banding 60 in\n ");
+		break;
+	default:
+		break;
+
+	}
 
 }
 static int set_flip(struct ov2655_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char temp = 0;
-	unsigned char buf[2];
 	temp = i2c_get_byte(client, 0x307c);
 	temp &=0xfc;
 	temp |= dev->cam_info.m_flip << 0;
 	temp |= dev->cam_info.v_flip << 1;
-	buf[0] = 0x307c;
-	buf[1] = temp;
-       if((i2c_put_byte(client,buf[0], buf[1])) < 0) {
-           printk("fail in setting sensor orientation\n");
-           return -1;
-       }
-       return 0;
+	if((i2c_put_byte(client, 0x307c, temp)) < 0) {
+		printk("fail in setting sensor orientation\n");
+		return -1;
+	}
+	return 0;
 }
 
 void OV2655_set_resolution(struct ov2655_device *dev,int height,int width)
 {
-
-	int ret;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
     #if 1
 	if(height&&width&&(height<=1200)&&(width<=1600))
@@ -1732,7 +1691,7 @@ unsigned char v4l_2_ov2655(int val)
 static int ov2655_setting(struct ov2655_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
+	//unsigned char cur_val;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -2155,7 +2114,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct ov2655_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(ov2655_frmivalenum))
@@ -2266,19 +2224,6 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 		OV2655_set_resolution(dev,fh->height,fh->width);
 		}
 	#endif
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT	
-	if (dev->platform_dev_data.flash_support) {
-		if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
-			if (get_flashlightflag() == FLASHLIGHT_ON) {
-				set_flashlight(true);
-			}
-		} else if(f->fmt.pix.pixelformat == V4L2_PIX_FMT_NV21){
-			if (get_flashlightflag() != FLASHLIGHT_TORCH) {
-				set_flashlight(false);
-			}		
-		}
-	}
-#endif	
 	ret = 0;
 out:
 	mutex_unlock(&q->vb_lock);
@@ -2291,8 +2236,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct ov2655_fh *fh = priv;
     struct ov2655_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2368,7 +2311,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
             vops->start_tvin_service(0,&para);
@@ -2535,6 +2478,11 @@ static int ov2655_open(struct file *file)
 	struct ov2655_device *dev = video_drvdata(file);
 	struct ov2655_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	ov2655_have_opened=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2668,6 +2616,9 @@ static int ov2655_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2819,10 +2770,14 @@ static const struct i2c_device_id ov2655_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov2655_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "ov2655",
+static struct i2c_driver ov2655_i2c_driver = {
+	.driver = {
+		.name = "ov2655",
+	},
 	.probe = ov2655_probe,
 	.remove = ov2655_remove,
 	.id_table = ov2655_id,
 };
 
+module_i2c_driver(ov2655_i2c_driver);
+
diff --git a/drivers/amlogic/camera/ov3660.c b/drivers/amlogic/camera/ov3660.c
index a379a68552ad..673752f0a37f 100755
--- a/drivers/amlogic/camera/ov3660.c
+++ b/drivers/amlogic/camera/ov3660.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,21 +36,16 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 #include <mach/gpio.h>
 #include <mach/am_regs.h>
 //#include <mach/am_eth_pinmux.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #include <mach/mod_gate.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend ov3660_early_suspend;
-#endif
+
+static struct vdin_v4l2_ops_s *vops;
 
 #define OV3660_CAMERA_MODULE_NAME "ov3660"
 #define TEST_I2C   1
@@ -89,12 +85,6 @@ static struct v4l2_fract ov3660_frmintervals_active = {
 
 #define EMDOOR_DEBUG_OV3660        1
 static struct i2c_client *ov3660_client;
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT
-#include <media/amlogic/flashlight.h>
-extern aml_plat_flashlight_status_t get_flashlightflag(void);
-extern int set_flashlight(bool mode);
-#endif
-static struct vdin_v4l2_ops_s *vops;
 /* supported controls */
 static struct v4l2_queryctrl ov3660_qctrl[] = {
 	{
@@ -334,10 +324,10 @@ struct ov3660_fh {
 	int  stream_on;
 	unsigned int		f_flags;
 };
-static inline struct ov3660_fh *to_fh(struct ov3660_device *dev)
+/*static inline struct ov3660_fh *to_fh(struct ov3660_device *dev)
 {
 	return container_of(dev, struct ov3660_fh, dev);
-}
+}*/
 static struct v4l2_frmsize_discrete ov3660_prev_resolution[]= //should include 352x288 and 640x480, those two size are used for recording
 {
 	{320,240},
@@ -1080,14 +1070,14 @@ void OV3660_set_param_effect(struct ov3660_device *dev,enum camera_effect_flip_e
 				
 		case CAM_EFFECT_ENC_SEPIAGREEN://复古绿
 			temp = i2c_get_byte(client, 0x5580);
-			i2c_put_byte(client,0x5580,temp & 0xbf | 0x18);
+			i2c_put_byte(client, 0x5580, ((temp & 0xbf )| 0x18));
 			i2c_put_byte(client,0x5583,0x60);
 			i2c_put_byte(client,0x5584,0x60);
 			break;					
 
 		case CAM_EFFECT_ENC_SEPIABLUE://复古蓝
 			temp = i2c_get_byte(client, 0x5580);
-			i2c_put_byte(client,0x5580,temp & 0xbf | 0x18);
+			i2c_put_byte(client,0x5580, ((temp & 0xbf) | 0x18));
 			i2c_put_byte(client,0x5583,0xa0);
 			i2c_put_byte(client,0x5584,0x40);
 			break;								
@@ -1148,9 +1138,9 @@ unsigned char v4l_2_ov3660(int val)
 static int ov3660_setting(struct ov3660_device *dev,int PROP_ID,int value ) 
 {
 	int ret=0;
-	unsigned char cur_val;
-	unsigned char reg_3820, reg_3821, reg_4515;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//unsigned char reg_3820, reg_3821, reg_4515;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
 		if(ov3660_qctrl[0].default_value!=value){
@@ -1224,7 +1214,7 @@ static int ov3660_setting(struct ov3660_device *dev,int PROP_ID,int value )
 
 static void power_down_ov3660(struct ov3660_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	/*i2c_put_byte(client,0x0104, 0x00);
 	i2c_put_byte(client,0x0100, 0x00);*/
 }
@@ -1313,7 +1303,7 @@ static void ov3660_sleep(struct ov3660_fh *fh)
 	struct ov3660_device *dev = fh->dev;
 	struct ov3660_dmaqueue *dma_q = &dev->vidq;
 
-	int timeout;
+	//int timeout;
 	DECLARE_WAITQUEUE(wait, current);
 
 	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
@@ -1665,6 +1655,7 @@ static struct aml_camera_i2c_fig_s pic2048x1536[]={
 #endif
 	{0xffff, 0xff},
 };
+#if 0
 static struct aml_camera_i2c_fig_s pic1600x1200[]={
 	{0x5001,0x23},
 	{0x3800,0x00},
@@ -1709,6 +1700,7 @@ static struct aml_camera_i2c_fig_s pic1600x1200[]={
 	
 	{0xffff, 0xff},
 };
+#endif
 
 static struct aml_camera_i2c_fig_s pic800x600[]={
 	{0x5001,0x23},
@@ -1750,6 +1742,7 @@ static struct aml_camera_i2c_fig_s pic800x600[]={
 	{0xffff, 0xff},
 };
 
+#if 0
 static struct aml_camera_i2c_fig_s pic640x480[]={
 	{0x3008, 0x42},
 	{0x303c, 0x11},//12
@@ -1815,7 +1808,9 @@ static struct aml_camera_i2c_fig_s pic640x480[]={
 	
 	{0xffff, 0xff},
 };
+#endif
 
+#if 0
 static struct aml_camera_i2c_fig_s pic320x240[]={
 	{0x5001,0x23},
 	{0x3503,0x00},
@@ -1855,6 +1850,7 @@ static struct aml_camera_i2c_fig_s pic320x240[]={
 	
 	{0xffff, 0xff},
 };
+#endif
 
 static void pic_set_size(struct ov3660_device *dev, struct aml_camera_i2c_fig_s* size)
 {
@@ -1877,7 +1873,6 @@ static int set_flip(struct ov3660_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char temp;
-	unsigned char buf[2];
 	temp = i2c_get_byte(client, 0x3821);
 	temp &= 0xfc;
 	temp |= dev->cam_info.m_flip << 0;
@@ -1897,8 +1892,6 @@ static int set_flip(struct ov3660_device *dev)
 
 void OV3660_set_resolution(struct ov3660_device *dev,int height,int width)
 {
-	int ret;
-	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	printk("<========%s w:%d, h:%d\n", __func__, width, height);
 	if((width<1600)&&(height<1200)){
 		//800*600
@@ -1957,17 +1950,17 @@ static int Get_preview_exposure_gain(struct ov3660_device *dev)
 	ov3660_preview_exposure = (ret_h << 12) + (ret_m << 4) + (ret_l >> 4);
 	ret_h = ret_m = ret_l = 0;
 	ov3660_preview_exposure = ov3660_preview_exposure + (ov3660_preview_extra_lines)/16;
-	printk("preview_exposure=%d\n", ov3660_preview_exposure);
+	//printk("preview_exposure=%d\n", ov3660_preview_exposure);
 	ret_h = ret_m = ret_l = 0;
 	ov3660_preview_maxlines = 0;
 	ret_h = i2c_get_byte(client, 0x380e);
 	ret_l = i2c_get_byte(client, 0x380f);
 	ov3660_preview_maxlines = (ret_h << 8) + ret_l;
-	printk("Preview_Maxlines=%d\n", ov3660_preview_maxlines);
+	//printk("Preview_Maxlines=%d\n", ov3660_preview_maxlines);
 	//Read back AGC Gain for preview
 	ov3660_gain = 0;
 	ov3660_gain = i2c_get_byte(client, 0x350b);
-	printk("Gain,0x350b=0x%x\n", ov3660_gain);
+	//printk("Gain,0x350b=0x%x\n", ov3660_gain);
 
 	return rc;
 }
@@ -2087,19 +2080,6 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 		OV3660_set_resolution(dev,fh->height,fh->width);
 	}
 	#endif
-#ifdef CONFIG_VIDEO_AMLOGIC_FLASHLIGHT	
-	if (dev->platform_dev_data.flash_support) {
-		if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
-			if (get_flashlightflag() == FLASHLIGHT_ON) {
-				set_flashlight(true);
-			}
-		} else if(f->fmt.pix.pixelformat == V4L2_PIX_FMT_NV21){
-			if (get_flashlightflag() != FLASHLIGHT_TORCH) {
-				set_flashlight(false);
-			}		
-		}
-	}
-#endif	
 	ret = 0;
 out:
 	mutex_unlock(&q->vb_lock);
@@ -2200,7 +2180,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 0;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
             vops->start_tvin_service(0,&para);
@@ -2366,6 +2346,11 @@ static int ov3660_open(struct file *file)
 	struct ov3660_device *dev = video_drvdata(file);
 	struct ov3660_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2492,6 +2477,9 @@ static int ov3660_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2624,12 +2612,11 @@ static const struct attribute_group ov3660_group =
 static int ov3660_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
-	int pgbuf;
 	int err;
 	aml_cam_info_t* plat_dat;
-	vops = get_vdin_v4l2_ops();
 	struct ov3660_device *t;
 	struct v4l2_subdev *sd;
+	vops = get_vdin_v4l2_ops();
 	v4l_info(client, "chip found @ 0x%x (%s)\n",
 			client->addr << 1, client->adapter->name);
 	t = kzalloc(sizeof(*t), GFP_KERNEL);
@@ -2670,7 +2657,7 @@ static int ov3660_probe(struct i2c_client *client,
 #ifdef EMDOOR_DEBUG_OV3660
 	//add by emdoor jf.s for debug ov3660
 	ov3660_client = client;
-	sysfs_create_group(&client->dev.kobj, &ov3660_group);
+	err = sysfs_create_group(&client->dev.kobj, &ov3660_group);
 #endif
 	return 0;
 }
@@ -2693,9 +2680,13 @@ static const struct i2c_device_id ov3660_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov3660_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "ov3660",
+static struct i2c_driver ov3660_i2c_driver = {
+	.driver = {
+		.name = "ov3660",
+	},
 	.probe = ov3660_probe,
 	.remove = ov3660_remove,
 	.id_table = ov3660_id,
 };
+
+module_i2c_driver(ov3660_i2c_driver);
diff --git a/drivers/amlogic/camera/ov5640.c b/drivers/amlogic/camera/ov5640.c
index ead2426842a5..cd2b1e52847c 100755
--- a/drivers/amlogic/camera/ov5640.c
+++ b/drivers/amlogic/camera/ov5640.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,8 +36,6 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
@@ -44,7 +43,6 @@
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
 
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #include "ov5640_firmware.h"
@@ -54,8 +52,6 @@
 #endif
 #define OV5640_CAMERA_MODULE_NAME "ov5640"
 
-#include <media/amlogic/flashlight.h>
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -84,7 +80,6 @@ static unsigned int vid_limit = 16;
 
 //extern int disable_ov5640;
 static int ov5640_have_opened = 0;
-static struct i2c_client *this_client;
 
 static void do_download(struct work_struct *work);
 static DECLARE_DELAYED_WORK(dl_work, do_download);
@@ -108,7 +103,31 @@ static struct v4l2_frmivalenum ov5640_frmivalenum[]={
 		{
 			.discrete ={
 				.numerator = 1,
-				.denominator = 25,
+				.denominator = 30,
+			}
+		}
+	},{
+		.index = 0,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 1024,
+		.height = 768,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 30,
+			}
+		}
+	},{
+		.index = 0,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 1280,
+		.height = 720,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 30,
 			}
 		}
 	},{
@@ -190,7 +209,7 @@ static struct v4l2_queryctrl ov5640_qctrl[] = {
 		.flags         = V4L2_CTRL_FLAG_DISABLED,
 	},{
 		.id            = V4L2_CID_DO_WHITE_BALANCE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.type          = V4L2_CTRL_TYPE_MENU,
 		.name          = "white balance",
 		.minimum       = 0,
 		.maximum       = 6,
@@ -324,6 +343,40 @@ struct v4l2_querymenu ov5640_qmenu_flashmode[] = {
 	}
 };
 
+struct v4l2_querymenu ov5640_qmenu_wbmode[] = {
+    {
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_CLOUD,
+        .name       = "cloudy-daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_INCANDESCENCE,
+        .name       = "incandescent",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_DAYLIGHT,
+        .name       = "daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "fluorescent", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "warm-fluorescent", 
+        .reserved   = 0,
+    },
+};
+
 typedef struct {
 	__u32   id;
 	int     num;
@@ -339,7 +392,11 @@ ov5640_qmenu_set_t ov5640_qmenu_set[] = {
 		.id             = V4L2_CID_BACKLIGHT_COMPENSATION,
 		.num            = ARRAY_SIZE(ov5640_qmenu_flashmode),
 		.ov5640_qmenu   = ov5640_qmenu_flashmode,
-	}
+	},{
+        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .num            = ARRAY_SIZE(ov5640_qmenu_wbmode),
+        .ov5640_qmenu   = ov5640_qmenu_wbmode,
+    }
 };
 
 #define dprintk(dev, level, fmt, arg...) \
@@ -498,15 +555,16 @@ struct ov5640_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct ov5640_fh *to_fh(struct ov5640_device *dev)
+/*static inline struct ov5640_fh *to_fh(struct ov5640_device *dev)
 {
 	return container_of(dev, struct ov5640_fh, dev);
-}
+}*/
 
 /* ------------------------------------------------------------------
 	reg spec of OV5640
    ------------------------------------------------------------------*/
 static struct aml_camera_i2c_fig_s OV5640_script[] = {
+#if 0
 //15fps YUV mode
 	{0x3103, 0x11},//
 	{0x3008, 0x42},//
@@ -908,6 +966,343 @@ static struct aml_camera_i2c_fig_s OV5640_script[] = {
 	{0x5585, 0x10},
 	{0x5588, 0x41},
 	*/
+#endif
+
+#if 1
+	{0x3103, 0x11}, 
+	{0x3008, 0x82},         
+	{0x4202, 0x0f}, 
+	{0x3103, 0x03}, 
+	{0x3017, 0x7f}, 
+	{0x3018, 0xff},   //{0x3031,0x00; //inner regulator
+	{0x302c, 0x42},   
+	{0x3108, 0x01}, 
+	{0x3630, 0x36}, 
+	{0x3631, 0x0e}, 
+	{0x3632, 0xe2}, 
+	{0x3633, 0x12}, 
+	{0x3621, 0xe0}, 
+	{0x3704, 0xa0}, 
+	{0x3703, 0x5a}, 
+	{0x3715, 0x78}, 
+	{0x3717, 0x01}, 
+	{0x370b, 0x60}, 
+	{0x3705, 0x1a}, 
+	{0x3905, 0x02}, 
+	{0x3906, 0x10}, 
+	{0x3901, 0x0a}, 
+	{0x3731, 0x12}, 
+	{0x3600, 0x08}, 
+	{0x3601, 0x33}, 
+	{0x302d, 0x60}, 
+	{0x3620, 0x52}, 
+	{0x371b, 0x20}, 
+	{0x471c, 0x50}, 
+	{0x3a13, 0x43}, 
+	{0x3a18, 0x00}, 
+	{0x3a19, 0xf8}, 
+	{0x3635, 0x13}, 
+	{0x3636, 0x03}, 
+	{0x3634, 0x40}, 
+	{0x3622, 0x01}, 
+	{0x3c04, 0x28}, 
+	{0x3c05, 0x98}, 
+	{0x3c06, 0x00}, 
+	{0x3c07, 0x08}, 
+	{0x3c08, 0x00}, 
+	{0x3c09, 0x1c}, 
+	{0x3c0a, 0x9c}, 
+	{0x3c0b, 0x40},  
+	{0x3820, 0x41}, 
+	{0x3821, 0x07},  
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x04}, 
+	{0x3804, 0x0a}, 
+	{0x3805, 0x3f}, 
+	{0x3806, 0x07}, 
+	{0x3807, 0x9b}, 
+	{0x3808, 0x03}, 
+	{0x3809, 0x20}, 
+	{0x380a, 0x02}, 
+	{0x380b, 0x58}, 
+	{0x3810, 0x00}, 
+	{0x3811, 0x10}, 
+	{0x3812, 0x00}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x31}, 
+	{0x3815, 0x31},   
+	{0x3034, 0x1a}, 
+	{0x3035, 0x11}, 
+	{0x3036, 0x46}, 
+	{0x3037, 0x13},   
+	{0x380c, 0x07}, 
+	{0x380d, 0x68}, 
+	{0x380e, 0x03}, 
+	{0x380f, 0xd8},   
+	{0x3c01, 0xb4}, 
+	{0x3c00, 0x04}, 
+	{0x3a08, 0x01}, 
+	{0x3a09, 0x27}, 
+	{0x3a0e, 0x03}, 
+	{0x3a0a, 0x00}, 
+	{0x3a0b, 0xf6},  
+	{0x3a0d, 0x04},   
+	{0x3a00, 0x38}, //30fps-20fps
+	{0x3a02, 0x05}, 
+	{0x3a03, 0xc4},         
+	{0x3a14, 0x05}, 
+	{0x3a15, 0xc4},  
+	{0x3618, 0x00}, 
+	{0x3612, 0x29}, 
+	{0x3708, 0x64}, 
+	{0x3709, 0x52}, 
+	{0x370c, 0x03},  
+	{0x4001, 0x02}, 
+	{0x4004, 0x02}, 
+	{0x3000, 0x00}, 
+	{0x3002, 0x1c}, 
+	{0x3004, 0xff}, 
+	{0x3006, 0xc3}, 
+	{0x300e, 0x58}, 
+	{0x302e, 0x00}, 
+	{0x4300, 0x31}, 
+	{0x501f, 0x00}, 
+	{0x4713, 0x03}, 
+	{0x4407, 0x04}, 
+	{0x440e, 0x00}, 
+	{0x460b, 0x35}, 
+	{0x460c, 0x22}, 
+	{0x4837, 0x22}, 
+	{0x3824, 0x02}, 
+	{0x5001, 0xa3}, 
+	{0x5180, 0xff}, 
+	{0x5181, 0xf2}, 
+	{0x5182, 0x00}, 
+	{0x5183, 0x14}, 
+	{0x5184, 0x25}, 
+	{0x5185, 0x24}, 
+	{0x5186, 0x16},  
+	{0x5187, 0x16},  
+	{0x5188, 0x16},  
+	{0x5189, 0x72},  
+	{0x518a, 0x68},   
+	{0x518b, 0xe0},  
+	{0x518c, 0xb2},  
+	{0x518d, 0x42},  
+	{0x518e, 0x3e},  
+	{0x518f, 0x4c},  
+	{0x5190, 0x56},  
+	{0x5191, 0xf8}, 
+	{0x5192, 0x04}, 
+	{0x5193, 0x70}, 
+	{0x5194, 0xf0}, 
+	{0x5195, 0xf0}, 
+	{0x5196, 0x03}, 
+	{0x5197, 0x01}, 
+	{0x5198, 0x04}, 
+	{0x5199, 0x12}, 
+	{0x519a, 0x04}, 
+	{0x519b, 0x00}, 
+	{0x519c, 0x06}, 
+	{0x519d, 0x82}, 
+	{0x519e, 0x38}, 
+	{0x5381, 0x1e}, 
+	{0x5382, 0x5b}, 
+	{0x5383, 0x12},  
+	{0x5384, 0x07},  
+	{0x5385, 0x7f},  
+	{0x5386, 0x86},  
+	{0x5387, 0x8a},  
+	{0x5388, 0x75},  
+	{0x5389, 0x15},  
+	{0x538a, 0x01}, 
+	{0x538b, 0x98}, 
+	{0x5480, 0x01},  
+	{0x5481, 0x06},  
+	{0x5482, 0x12},  
+	{0x5483, 0x1e},  
+	{0x5484, 0x4a},  
+	{0x5485, 0x58},  
+	{0x5486, 0x65},  
+	{0x5487, 0x72},  
+	{0x5488, 0x7d},  
+	{0x5489, 0x88},  
+	{0x548a, 0x92},  
+	{0x548b, 0xa3},  
+	{0x548c, 0xb2},  
+	{0x548d, 0xc8},  
+	{0x548e, 0xdd},  
+	{0x548f, 0xf0},  
+	{0x5490, 0x15},       
+	{0x5300, 0x08}, 
+	{0x5301, 0x30},       
+	{0x5302, 0x38},  
+	{0x5303, 0x10},  
+	{0x5304, 0x08},  
+	{0x5305, 0x30},  
+	{0x5306, 0x08},  
+	{0x5307, 0x18},  
+	{0x5309, 0x08},  
+	{0x530a, 0x30},  
+	{0x530b, 0x04},  
+	{0x530c, 0x06},     
+	{0x5580, 0x06},  
+	{0x5583, 0x40}, 
+	{0x5584, 0x10}, 
+	{0x5589, 0x10}, 
+	{0x558a, 0x00}, 
+	{0x558b, 0xf8},  
+	{0x5000, 0xa7},  
+	{0x5800, 0x20},  
+	{0x5801, 0x19},  
+	{0x5802, 0x17},  
+	{0x5803, 0x16},  
+	{0x5804, 0x18},  
+	{0x5805, 0x21},  
+	{0x5806, 0x0F},  
+	{0x5807, 0x0A},  
+	{0x5808, 0x07},  
+	{0x5809, 0x07},  
+	{0x580a, 0x0A},  
+	{0x580b, 0x0C},  
+	{0x580c, 0x0A},  
+	{0x580d, 0x03},  
+	{0x580e, 0x01},  
+	{0x580f, 0x01},  
+	{0x5810, 0x03},  
+	{0x5811, 0x09},  
+	{0x5812, 0x0A},  
+	{0x5813, 0x03}, 
+	{0x5814, 0x01},  
+	{0x5815, 0x01},  
+	{0x5816, 0x03},  
+	{0x5817, 0x08},  
+	{0x5818, 0x10},  
+	{0x5819, 0x0A},  
+	{0x581a, 0x06},  
+	{0x581b, 0x06},  
+	{0x581c, 0x08},  
+	{0x581d, 0x0E},  
+	{0x581e, 0x22},  
+	{0x581f, 0x18},  
+	{0x5820, 0x13},  
+	{0x5821, 0x12},  
+	{0x5822, 0x16},  
+	{0x5823, 0x1E},  
+	{0x5824, 0x64},  
+	{0x5825, 0x2A},  
+	{0x5826, 0x2C},  
+	{0x5827, 0x2A},  
+	{0x5828, 0x46},  
+	{0x5829, 0x2A},  
+	{0x582a, 0x26},  
+	{0x582b, 0x24},  
+	{0x582c, 0x26},  
+	{0x582d, 0x2A},  
+	{0x582e, 0x28},  
+	{0x582f, 0x42},  
+	{0x5830, 0x40},  
+	{0x5831, 0x42},  
+	{0x5832, 0x08},  
+	{0x5833, 0x28},  
+	{0x5834, 0x26},  
+	{0x5835, 0x24},  
+	{0x5836, 0x26},  
+	{0x5837, 0x2A},  
+	{0x5838, 0x44},  
+	{0x5839, 0x4A},  
+	{0x583a, 0x2C},  
+	{0x583b, 0x2a},  
+	{0x583c, 0x46},  
+	{0x583d, 0xCE},   
+	{0x5688, 0x22}, 
+	{0x5689, 0x22}, 
+	{0x568a, 0x42}, 
+	{0x568b, 0x24}, 
+	{0x568c, 0x42}, 
+	{0x568d, 0x24}, 
+	{0x568e, 0x22}, 
+	{0x568f, 0x22},    
+	{0x5025, 0x00},  
+	{0x3a0f, 0x30}, 
+	{0x3a10, 0x28}, 
+	{0x3a11, 0x61}, 
+	{0x3a1b, 0x30}, 
+	{0x3a1e, 0x28}, 
+	{0x3a1f, 0x10}, 
+	{0x4005, 0x1a},   
+	{0x4740, 0x20}, 
+	{0x3503, 0x00}, 
+	{0x4202, 0x00},  
+	{0x4202, 0x0f}, 
+	{0x3c07, 0x08},  
+	{0x5189, 0x72}, 
+	{0x3503, 0x00},  
+	{0x3a00, 0x38}, //30fps-20fps //0x3c 1018-zhenfei
+	{0x3a02, 0x07}, 
+	{0x3a03, 0xb0},         
+	{0x3a14, 0x07}, 
+	{0x3a15, 0xb0}, 
+	{0x5302, 0x30},  
+	{0x5303, 0x10},  
+	{0x5306, 0x0e},  
+	{0x5307, 0x1e},  
+	{0x3820, 0x41},  
+	{0x3821, 0x07},  
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x04}, 
+	{0x3804, 0x0a}, 
+	{0x3805, 0x3f}, 
+	{0x3806, 0x07}, 
+	{0x3807, 0x9b}, 
+	{0x3808, 0x05}, 
+	{0x3809, 0x00}, 
+	{0x380a, 0x03}, 
+	{0x380b, 0xc0}, 
+	{0x3810, 0x00}, 
+	{0x3811, 0x10}, 
+	{0x3812, 0x00}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x31}, 
+	{0x3815, 0x31},            
+	{0x3034, 0x1a},                 
+	{0x3035, 0x11},                 
+	{0x3036, 0x46},                 
+	{0x3037, 0x13},            
+	{0x380c, 0x07},      
+	{0x380d, 0x68},     
+	{0x380e, 0x03},      
+	{0x380f, 0xd8},      
+	{0x3a08, 0x01}, 
+	{0x3a09, 0x27},  
+	{0x3a0e, 0x03}, 
+	{0x3a0a, 0x00},  
+	{0x3a0b, 0xf6},   
+	{0x3a0d, 0x04},  
+	{0x3618, 0x00},       
+	{0x3612, 0x29},       
+	{0x3709, 0x52},       
+	{0x370c, 0x03},  
+	{0x4004, 0x02},    
+	{0x3002, 0x1c},   
+	{0x3006, 0xc3},       
+	{0x3824, 0x02},                 
+	{0x5001, 0xa3},          
+	{0x4713, 0x03},  
+	{0x4407, 0x04},  
+	{0x460b, 0x35},  
+	{0x460c, 0x20},  
+	{0x4837, 0x22},    
+	{0x4202, 0x00}, 
+	{0x3023, 0x01},   
+	{0x3022, 0x04},
+	
+#endif
+
 	{0xffff, 0xff}
 };
 
@@ -959,6 +1354,7 @@ static struct aml_camera_i2c_fig_s OV5640_preview_VGA_script[] = {
 	{0xffff, 0xff}
 };
 
+#if 0
 static struct aml_camera_i2c_fig_s OV5640_preview_1080P_script[] = {
 	{0x3103, 0x11},
 	//{0x3008, 0x82},
@@ -1223,8 +1619,682 @@ static struct aml_camera_i2c_fig_s OV5640_preview_1080P_script[] = {
 	
 	{0xffff, 0xff}
 };
+#endif
+
+static struct aml_camera_i2c_fig_s OV5640_preview_960P_script[] = {
+#if 0
+	{0x3103, 0x11}, 
+	{0x3008, 0x82}, 	
+	{0x4202, 0x0f}, 
+	{0x3103, 0x03}, 
+	{0x3017, 0x7f}, 
+	{0x3018, 0xff},   //{0x3031,0x00; //inner regulator
+	{0x302c, 0x42},   
+	{0x3108, 0x01}, 
+	{0x3630, 0x36}, 
+	{0x3631, 0x0e}, 
+	{0x3632, 0xe2}, 
+	{0x3633, 0x12}, 
+	{0x3621, 0xe0}, 
+	{0x3704, 0xa0}, 
+	{0x3703, 0x5a}, 
+	{0x3715, 0x78}, 
+	{0x3717, 0x01}, 
+	{0x370b, 0x60}, 
+	{0x3705, 0x1a}, 
+	{0x3905, 0x02}, 
+	{0x3906, 0x10}, 
+	{0x3901, 0x0a}, 
+	{0x3731, 0x12}, 
+	{0x3600, 0x08}, 
+	{0x3601, 0x33}, 
+	{0x302d, 0x60}, 
+	{0x3620, 0x52}, 
+	{0x371b, 0x20}, 
+	{0x471c, 0x50}, 
+	{0x3a13, 0x43}, 
+	{0x3a18, 0x00}, 
+	{0x3a19, 0xf8}, 
+	{0x3635, 0x13}, 
+	{0x3636, 0x03}, 
+	{0x3634, 0x40}, 
+	{0x3622, 0x01}, 
+	{0x3c04, 0x28}, 
+	{0x3c05, 0x98}, 
+	{0x3c06, 0x00}, 
+	{0x3c07, 0x08}, 
+	{0x3c08, 0x00}, 
+	{0x3c09, 0x1c}, 
+	{0x3c0a, 0x9c}, 
+	{0x3c0b, 0x40},  
+	{0x3820, 0x41}, 
+	{0x3821, 0x07},  
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x04}, 
+	{0x3804, 0x0a}, 
+	{0x3805, 0x3f}, 
+	{0x3806, 0x07}, 
+	{0x3807, 0x9b}, 
+	{0x3808, 0x03}, 
+	{0x3809, 0x20}, 
+	{0x380a, 0x02}, 
+	{0x380b, 0x58}, 
+	{0x3810, 0x00}, 
+	{0x3811, 0x10}, 
+	{0x3812, 0x00}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x31}, 
+	{0x3815, 0x31},   
+	{0x3034, 0x1a}, 
+	{0x3035, 0x11}, 
+	{0x3036, 0x69}, 
+	{0x3037, 0x13},   
+	{0x380c, 0x07}, 
+	{0x380d, 0x68}, 
+	{0x380e, 0x03}, 
+	{0x380f, 0xd8},   
+	{0x3c01, 0xb4}, 
+	{0x3c00, 0x04}, 
+	{0x3a08, 0x01}, 
+	{0x3a09, 0x27}, 
+	{0x3a0e, 0x03}, 
+	{0x3a0a, 0x00}, 
+	{0x3a0b, 0xf6},  
+	{0x3a0d, 0x04},   
+	{0x3a00, 0x3c}, //30fps-20fps
+	{0x3a02, 0x05}, 
+	{0x3a03, 0xc4},         
+	{0x3a14, 0x05}, 
+	{0x3a15, 0xc4},  
+	{0x3618, 0x00}, 
+	{0x3612, 0x29}, 
+	{0x3708, 0x64}, 
+	{0x3709, 0x52}, 
+	{0x370c, 0x03},  
+	{0x4001, 0x02}, 
+	{0x4004, 0x02}, 
+	{0x3000, 0x00}, 
+	{0x3002, 0x1c}, 
+	{0x3004, 0xff}, 
+	{0x3006, 0xc3}, 
+	{0x300e, 0x58}, 
+	{0x302e, 0x00}, 
+	{0x4300, 0x31}, 
+	{0x501f, 0x00}, 
+	{0x4713, 0x03}, 
+	{0x4407, 0x04}, 
+	{0x440e, 0x00}, 
+	{0x460b, 0x35}, 
+	{0x460c, 0x22}, 
+	{0x4837, 0x22}, 
+	{0x3824, 0x02}, 
+	{0x5001, 0xa3}, 
+	{0x5180, 0xff}, 
+	{0x5181, 0xf2}, 
+	{0x5182, 0x00}, 
+	{0x5183, 0x14}, 
+	{0x5184, 0x25}, 
+	{0x5185, 0x24}, 
+	{0x5186, 0x16},  
+	{0x5187, 0x16},  
+	{0x5188, 0x16},  
+	{0x5189, 0x72},  
+	{0x518a, 0x68},   
+	{0x518b, 0xe0},  
+	{0x518c, 0xb2},  
+	{0x518d, 0x42},  
+	{0x518e, 0x3e},  
+	{0x518f, 0x4c},  
+	{0x5190, 0x56},  
+	{0x5191, 0xf8}, 
+	{0x5192, 0x04}, 
+	{0x5193, 0x70}, 
+	{0x5194, 0xf0}, 
+	{0x5195, 0xf0}, 
+	{0x5196, 0x03}, 
+	{0x5197, 0x01}, 
+	{0x5198, 0x04}, 
+	{0x5199, 0x12}, 
+	{0x519a, 0x04}, 
+	{0x519b, 0x00}, 
+	{0x519c, 0x06}, 
+	{0x519d, 0x82}, 
+	{0x519e, 0x38}, 
+	{0x5381, 0x1e}, 
+	{0x5382, 0x5b}, 
+	{0x5383, 0x12},  
+	{0x5384, 0x07},  
+	{0x5385, 0x7f},  
+	{0x5386, 0x86},  
+	{0x5387, 0x8a},  
+	{0x5388, 0x75},  
+	{0x5389, 0x15},  
+	{0x538a, 0x01}, 
+	{0x538b, 0x98}, 
+	{0x5480, 0x01},  
+	{0x5481, 0x06},  
+	{0x5482, 0x12},  
+	{0x5483, 0x1e},  
+	{0x5484, 0x4a},  
+	{0x5485, 0x58},  
+	{0x5486, 0x65},  
+	{0x5487, 0x72},  
+	{0x5488, 0x7d},  
+	{0x5489, 0x88},  
+	{0x548a, 0x92},  
+	{0x548b, 0xa3},  
+	{0x548c, 0xb2},  
+	{0x548d, 0xc8},  
+	{0x548e, 0xdd},  
+	{0x548f, 0xf0},  
+	{0x5490, 0x15},       
+	{0x5300, 0x08}, 
+	{0x5301, 0x30},       
+	{0x5302, 0x38},  
+	{0x5303, 0x10},  
+	{0x5304, 0x08},  
+	{0x5305, 0x30},  
+	{0x5306, 0x08},  
+	{0x5307, 0x18},  
+	{0x5309, 0x08},  
+	{0x530a, 0x30},  
+	{0x530b, 0x04},  
+	{0x530c, 0x06},     
+	{0x5580, 0x06},  
+	{0x5583, 0x40}, 
+	{0x5584, 0x10}, 
+	{0x5589, 0x10}, 
+	{0x558a, 0x00}, 
+	{0x558b, 0xf8},  
+	{0x5000, 0xa7},  
+	{0x5800, 0x20},  
+	{0x5801, 0x19},  
+	{0x5802, 0x17},  
+	{0x5803, 0x16},  
+	{0x5804, 0x18},  
+	{0x5805, 0x21},  
+	{0x5806, 0x0F},  
+	{0x5807, 0x0A},  
+	{0x5808, 0x07},  
+	{0x5809, 0x07},  
+	{0x580a, 0x0A},  
+	{0x580b, 0x0C},  
+	{0x580c, 0x0A},  
+	{0x580d, 0x03},  
+	{0x580e, 0x01},  
+	{0x580f, 0x01},  
+	{0x5810, 0x03},  
+	{0x5811, 0x09},  
+	{0x5812, 0x0A},  
+	{0x5813, 0x03}, 
+	{0x5814, 0x01},  
+	{0x5815, 0x01},  
+	{0x5816, 0x03},  
+	{0x5817, 0x08},  
+	{0x5818, 0x10},  
+	{0x5819, 0x0A},  
+	{0x581a, 0x06},  
+	{0x581b, 0x06},  
+	{0x581c, 0x08},  
+	{0x581d, 0x0E},  
+	{0x581e, 0x22},  
+	{0x581f, 0x18},  
+	{0x5820, 0x13},  
+	{0x5821, 0x12},  
+	{0x5822, 0x16},  
+	{0x5823, 0x1E},  
+	{0x5824, 0x64},  
+	{0x5825, 0x2A},  
+	{0x5826, 0x2C},  
+	{0x5827, 0x2A},  
+	{0x5828, 0x46},  
+	{0x5829, 0x2A},  
+	{0x582a, 0x26},  
+	{0x582b, 0x24},  
+	{0x582c, 0x26},  
+	{0x582d, 0x2A},  
+	{0x582e, 0x28},  
+	{0x582f, 0x42},  
+	{0x5830, 0x40},  
+	{0x5831, 0x42},  
+	{0x5832, 0x08},  
+	{0x5833, 0x28},  
+	{0x5834, 0x26},  
+	{0x5835, 0x24},  
+	{0x5836, 0x26},  
+	{0x5837, 0x2A},  
+	{0x5838, 0x44},  
+	{0x5839, 0x4A},  
+	{0x583a, 0x2C},  
+	{0x583b, 0x2a},  
+	{0x583c, 0x46},  
+	{0x583d, 0xCE},   
+	{0x5688, 0x22}, 
+	{0x5689, 0x22}, 
+	{0x568a, 0x42}, 
+	{0x568b, 0x24}, 
+	{0x568c, 0x42}, 
+	{0x568d, 0x24}, 
+	{0x568e, 0x22}, 
+	{0x568f, 0x22},    
+	{0x5025, 0x00},  
+	{0x3a0f, 0x30}, 
+	{0x3a10, 0x28}, 
+	{0x3a11, 0x61}, 
+	{0x3a1b, 0x30}, 
+	{0x3a1e, 0x28}, 
+	{0x3a1f, 0x10}, 
+	{0x4005, 0x1a},   
+	{0x4740, 0x20}, 
+	{0x3503, 0x00}, 
+	{0x4202, 0x00},  
+	{0x4202, 0x0f}, 
+	{0x3c07, 0x08},  
+	{0x5189, 0x72}, 
+	{0x3503, 0x00},  
+	{0x3a00, 0x3c}, //30fps-20fps
+	{0x3a02, 0x07}, 
+	{0x3a03, 0xb0},         
+	{0x3a14, 0x07}, 
+	{0x3a15, 0xb0}, 
+	{0x5302, 0x30},  
+	{0x5303, 0x10},  
+	{0x5306, 0x0e},  
+	{0x5307, 0x1e},  
+	{0x3820, 0x41},  
+	{0x3821, 0x07},  
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x04}, 
+	{0x3804, 0x0a}, 
+	{0x3805, 0x3f}, 
+	{0x3806, 0x07}, 
+	{0x3807, 0x9b}, 
+	{0x3808, 0x05}, 
+	{0x3809, 0x00}, 
+	{0x380a, 0x03}, 
+	{0x380b, 0xc0}, 
+	{0x3810, 0x00}, 
+	{0x3811, 0x10}, 
+	{0x3812, 0x00}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x31}, 
+	{0x3815, 0x31},            
+	{0x3034, 0x1a},                 
+	{0x3035, 0x11},                 
+	{0x3036, 0x69},                 
+	{0x3037, 0x13},            
+	{0x380c, 0x07},      
+	{0x380d, 0x68},     
+	{0x380e, 0x03},      
+	{0x380f, 0xd8},      
+	{0x3a08, 0x01}, 
+	{0x3a09, 0x27},  
+	{0x3a0e, 0x03}, 
+	{0x3a0a, 0x00},  
+	{0x3a0b, 0xf6},   
+	{0x3a0d, 0x04},  
+	{0x3618, 0x00},       
+	{0x3612, 0x29},       
+	{0x3709, 0x52},       
+	{0x370c, 0x03},  
+	{0x4004, 0x02},    
+	{0x3002, 0x1c},   
+	{0x3006, 0xc3},       
+	{0x3824, 0x02},                 
+	{0x5001, 0xa3},          
+	{0x4713, 0x03},  
+	{0x4407, 0x04},  
+	{0x460b, 0x35},  
+	{0x460c, 0x20},  
+	{0x4837, 0x22},    
+	{0x4202, 0x00}, 
+	{0x3023, 0x01},   
+	{0x3022, 0x04},
+#endif
+
+#if 1   //1021 danny zhang
+	{0x3103, 0x11}, 
+	{0x3008, 0x82},      
+	{0x4202, 0x0f}, 
+	{0x3103, 0x03}, 
+	{0x3017, 0x7f}, 
+	{0x3018, 0xff},   //{0x3031,0x00; //inner regulator
+	{0x302c, 0x42},   
+	{0x3108, 0x01}, 
+	{0x3630, 0x36}, 
+	{0x3631, 0x0e}, 
+	{0x3632, 0xe2}, 
+	{0x3633, 0x12}, 
+	{0x3621, 0xe0}, 
+	{0x3704, 0xa0}, 
+	{0x3703, 0x5a}, 
+	{0x3715, 0x78}, 
+	{0x3717, 0x01}, 
+	{0x370b, 0x60}, 
+	{0x3705, 0x1a}, 
+	{0x3905, 0x02}, 
+	{0x3906, 0x10}, 
+	{0x3901, 0x0a}, 
+	{0x3731, 0x12}, 
+	{0x3600, 0x08}, 
+	{0x3601, 0x33}, 
+	{0x302d, 0x60}, 
+	{0x3620, 0x52}, 
+	{0x371b, 0x20}, 
+	{0x471c, 0x50}, 
+	{0x3a13, 0x43}, 
+	{0x3a18, 0x00}, 
+	{0x3a19, 0xf8}, 
+	{0x3635, 0x13}, 
+	{0x3636, 0x03}, 
+	{0x3634, 0x40}, 
+	{0x3622, 0x01}, 
+	{0x3c04, 0x28}, 
+	{0x3c05, 0x98}, 
+	{0x3c06, 0x00}, 
+	{0x3c07, 0x08}, 
+	{0x3c08, 0x00}, 
+	{0x3c09, 0x1c}, 
+	{0x3c0a, 0x9c}, 
+	{0x3c0b, 0x40},  
+	{0x3820, 0x41}, 
+	{0x3821, 0x07},  
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x04}, 
+	{0x3804, 0x0a}, 
+	{0x3805, 0x3f}, 
+	{0x3806, 0x07}, 
+	{0x3807, 0x9b}, 
+	{0x3808, 0x03}, 
+	{0x3809, 0x20}, 
+	{0x380a, 0x02}, 
+	{0x380b, 0x58}, 
+	{0x3810, 0x00}, 
+	{0x3811, 0x10}, 
+	{0x3812, 0x00}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x31}, 
+	{0x3815, 0x31},   
+	{0x3034, 0x1a}, 
+	{0x3035, 0x11}, 
+	{0x3036, 0x46}, 
+	{0x3037, 0x13},   
+	{0x380c, 0x07}, 
+	{0x380d, 0x68}, 
+	{0x380e, 0x03}, 
+	{0x380f, 0xd8},   
+	{0x3c01, 0xb4}, 
+	{0x3c00, 0x04}, 
+	{0x3a08, 0x01}, 
+	{0x3a09, 0x27}, 
+	{0x3a0e, 0x03}, 
+	{0x3a0a, 0x00}, 
+	{0x3a0b, 0xf6},  
+	{0x3a0d, 0x04},   
+	{0x3a00, 0x3c}, //30fps-20fps
+	{0x3a02, 0x05}, 
+	{0x3a03, 0xc4},         
+	{0x3a14, 0x05}, 
+	{0x3a15, 0xc4},  
+	{0x3618, 0x00}, 
+	{0x3612, 0x29}, 
+	{0x3708, 0x64}, 
+	{0x3709, 0x52}, 
+	{0x370c, 0x03},  
+	{0x4001, 0x02}, 
+	{0x4004, 0x02}, 
+	{0x3000, 0x00}, 
+	{0x3002, 0x1c}, 
+	{0x3004, 0xff}, 
+	{0x3006, 0xc3}, 
+	{0x300e, 0x58}, 
+	{0x302e, 0x00}, 
+	{0x4300, 0x31}, 
+	{0x501f, 0x00}, 
+	{0x4713, 0x03}, 
+	{0x4407, 0x04}, 
+	{0x440e, 0x00}, 
+	{0x460b, 0x35}, 
+	{0x460c, 0x22}, 
+	{0x4837, 0x22}, 
+	{0x3824, 0x02}, 
+	{0x5001, 0xa3}, 
+	{0x5180, 0xff}, 
+	{0x5181, 0xf2}, 
+	{0x5182, 0x00}, 
+	{0x5183, 0x14}, 
+	{0x5184, 0x25}, 
+	{0x5185, 0x24}, 
+	{0x5186, 0x16},  
+	{0x5187, 0x16},  
+	{0x5188, 0x16},  
+	{0x5189, 0x72},  
+	{0x518a, 0x68},   
+	{0x518b, 0xe0},  
+	{0x518c, 0xb2},  
+	{0x518d, 0x42},  
+	{0x518e, 0x3e},  
+	{0x518f, 0x4c},  
+	{0x5190, 0x56},  
+	{0x5191, 0xf8}, 
+	{0x5192, 0x04}, 
+	{0x5193, 0x70}, 
+	{0x5194, 0xf0}, 
+	{0x5195, 0xf0}, 
+	{0x5196, 0x03}, 
+	{0x5197, 0x01}, 
+	{0x5198, 0x04}, 
+	{0x5199, 0x12}, 
+	{0x519a, 0x04}, 
+	{0x519b, 0x00}, 
+	{0x519c, 0x06}, 
+	{0x519d, 0x82}, 
+	{0x519e, 0x38}, 
+	{0x5381, 0x1e}, 
+	{0x5382, 0x5b}, 
+	{0x5383, 0x12},  
+	{0x5384, 0x07},  
+	{0x5385, 0x7f},  
+	{0x5386, 0x86},  
+	{0x5387, 0x8a},  
+	{0x5388, 0x75},  
+	{0x5389, 0x15},  
+	{0x538a, 0x01}, 
+	{0x538b, 0x98}, 
+	{0x5480, 0x01},  
+	{0x5481, 0x06},  
+	{0x5482, 0x12},  
+	{0x5483, 0x1e},  
+	{0x5484, 0x4a},  
+	{0x5485, 0x58},  
+	{0x5486, 0x65},  
+	{0x5487, 0x72},  
+	{0x5488, 0x7d},  
+	{0x5489, 0x88},  
+	{0x548a, 0x92},  
+	{0x548b, 0xa3},  
+	{0x548c, 0xb2},  
+	{0x548d, 0xc8},  
+	{0x548e, 0xdd},  
+	{0x548f, 0xf0},  
+	{0x5490, 0x15},       
+	{0x5300, 0x08}, 
+	{0x5301, 0x30},       
+	{0x5302, 0x38},  
+	{0x5303, 0x10},  
+	{0x5304, 0x08},  
+	{0x5305, 0x30},  
+	{0x5306, 0x08},  
+	{0x5307, 0x18},  
+	{0x5309, 0x08},  
+	{0x530a, 0x30},  
+	{0x530b, 0x04},  
+	{0x530c, 0x06},     
+	{0x5580, 0x06},  
+	{0x5583, 0x40}, 
+	{0x5584, 0x10}, 
+	{0x5589, 0x10}, 
+	{0x558a, 0x00}, 
+	{0x558b, 0xf8},  
+	{0x5000, 0xa7},  
+	{0x5800, 0x20},  
+	{0x5801, 0x19},  
+	{0x5802, 0x17},  
+	{0x5803, 0x16},  
+	{0x5804, 0x18},  
+	{0x5805, 0x21},  
+	{0x5806, 0x0F},  
+	{0x5807, 0x0A},  
+	{0x5808, 0x07},  
+	{0x5809, 0x07},  
+	{0x580a, 0x0A},  
+	{0x580b, 0x0C},  
+	{0x580c, 0x0A},  
+	{0x580d, 0x03},  
+	{0x580e, 0x01},  
+	{0x580f, 0x01},  
+	{0x5810, 0x03},  
+	{0x5811, 0x09},  
+	{0x5812, 0x0A},  
+	{0x5813, 0x03}, 
+	{0x5814, 0x01},  
+	{0x5815, 0x01},  
+	{0x5816, 0x03},  
+	{0x5817, 0x08},  
+	{0x5818, 0x10},  
+	{0x5819, 0x0A},  
+	{0x581a, 0x06},  
+	{0x581b, 0x06},  
+	{0x581c, 0x08},  
+	{0x581d, 0x0E},  
+	{0x581e, 0x22},  
+	{0x581f, 0x18},  
+	{0x5820, 0x13},  
+	{0x5821, 0x12},  
+	{0x5822, 0x16},  
+	{0x5823, 0x1E},  
+	{0x5824, 0x64},  
+	{0x5825, 0x2A},  
+	{0x5826, 0x2C},  
+	{0x5827, 0x2A},  
+	{0x5828, 0x46},  
+	{0x5829, 0x2A},  
+	{0x582a, 0x26},  
+	{0x582b, 0x24},  
+	{0x582c, 0x26},  
+	{0x582d, 0x2A},  
+	{0x582e, 0x28},  
+	{0x582f, 0x42},  
+	{0x5830, 0x40},  
+	{0x5831, 0x42},  
+	{0x5832, 0x08},  
+	{0x5833, 0x28},  
+	{0x5834, 0x26},  
+	{0x5835, 0x24},  
+	{0x5836, 0x26},  
+	{0x5837, 0x2A},  
+	{0x5838, 0x44},  
+	{0x5839, 0x4A},  
+	{0x583a, 0x2C},  
+	{0x583b, 0x2a},  
+	{0x583c, 0x46},  
+	{0x583d, 0xCE},   
+	{0x5688, 0x22}, 
+	{0x5689, 0x22}, 
+	{0x568a, 0x42}, 
+	{0x568b, 0x24}, 
+	{0x568c, 0x42}, 
+	{0x568d, 0x24}, 
+	{0x568e, 0x22}, 
+	{0x568f, 0x22},    
+	{0x5025, 0x00},  
+	{0x3a0f, 0x30}, 
+	{0x3a10, 0x28}, 
+	{0x3a11, 0x61}, 
+	{0x3a1b, 0x30}, 
+	{0x3a1e, 0x28}, 
+	{0x3a1f, 0x10}, 
+	{0x4005, 0x1a},   
+	{0x4740, 0x20}, 
+	{0x3503, 0x00}, 
+	{0x4202, 0x00},  
+	{0x4202, 0x0f}, 
+	{0x3c07, 0x08},  
+	{0x5189, 0x72}, 
+	{0x3503, 0x00},  
+	{0x3a00, 0x38}, //30fps-20fps
+	{0x3a02, 0x07}, 
+	{0x3a03, 0xb0},         
+	{0x3a14, 0x07}, 
+	{0x3a15, 0xb0}, 
+	{0x5302, 0x30},  
+	{0x5303, 0x10},  
+	{0x5306, 0x0e},  
+	{0x5307, 0x1e},  
+	{0x3820, 0x41},  
+	{0x3821, 0x07},  
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x04}, 
+	{0x3804, 0x0a}, 
+	{0x3805, 0x3f}, 
+	{0x3806, 0x07}, 
+	{0x3807, 0x9b}, 
+	{0x3808, 0x05}, 
+	{0x3809, 0x00}, 
+	{0x380a, 0x03}, 
+	{0x380b, 0xc0}, 
+	{0x3810, 0x00}, 
+	{0x3811, 0x10}, 
+	{0x3812, 0x00}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x31}, 
+	{0x3815, 0x31},            
+	{0x3034, 0x1a},                 
+	{0x3035, 0x11},                 
+	{0x3036, 0x46},                 
+	{0x3037, 0x13},            
+	{0x380c, 0x07},      
+	{0x380d, 0x68},     
+	{0x380e, 0x03},      
+	{0x380f, 0xd8},      
+	{0x3a08, 0x01}, 
+	{0x3a09, 0x27},  
+	{0x3a0e, 0x03}, 
+	{0x3a0a, 0x00},  
+	{0x3a0b, 0xf6},   
+	{0x3a0d, 0x04},  
+	{0x3618, 0x00},       
+	{0x3612, 0x29},       
+	{0x3709, 0x52},       
+	{0x370c, 0x03},  
+	{0x4004, 0x02},    
+	{0x3002, 0x1c},   
+	{0x3006, 0xc3},       
+	{0x3824, 0x02},                 
+	{0x5001, 0xa3},          
+	{0x4713, 0x03},  
+	{0x4407, 0x04},  
+	{0x460b, 0x35},  
+	{0x460c, 0x20},  
+	{0x4837, 0x22},    
+	{0x4202, 0x00}, 
+	{0x3023, 0x01},   
+	{0x3022, 0x04},
+#endif
+	
+	{0xffff, 0xff}
+};
 
 static struct aml_camera_i2c_fig_s OV5640_preview_720P_script[] = {
+#if 0
 	{0x3103, 0x11},
 //	{0x3008, 0x82},
 	{0x3008, 0x42},
@@ -1486,10 +2556,68 @@ static struct aml_camera_i2c_fig_s OV5640_preview_720P_script[] = {
 	{0x3035, 0x21},
 	{0x3c01, 0xb4},
 	{0x3c00, 0x04},
+#endif
+
+#if 1
+	{0x3035, 0x21}, // PLL
+	{0x3036, 0x69}, // PLL
+	{0x3c07, 0x07}, // lightmeter 1 threshold[7:0]
+	{0x3820, 0x41}, // flip
+	{0x3821, 0x07}, // mirror
+	{0x3814, 0x31}, // timing X inc
+	{0x3815, 0x31}, // timing Y inc
+	{0x3800, 0x00}, // HS
+	{0x3801, 0x00}, // HS
+	{0x3802, 0x00}, // VS
+	{0x3803, 0xfa}, // VS
+	{0x3804, 0x0a}, // HW (HE)
+	{0x3805, 0x3f}, // HW (HE)
+	{0x3806, 0x06}, // VH (VE)
+	{0x3807, 0xa9}, // VH (VE)
+	{0x3808, 0x05}, // DVPHO
+	{0x3809, 0x00}, // DVPHO
+	{0x380a, 0x02}, // DVPVO
+	{0x380b, 0xd0}, // DVPVO
+	{0x380c, 0x07}, // HTS
+	{0x380d, 0x64}, // HTS
+	{0x380e, 0x02}, // VTS
+	{0x380f, 0xe4}, // VTS
+	{0x3813, 0x04}, // timing V offset
+	{0x3618, 0x00},
+	{0x3612, 0x29},
+	{0x3709, 0x52},
+	{0x370c, 0x03},
+	{0x3a02, 0x02}, // 60Hz max exposure
+	{0x3a03, 0xe0}, // 60Hz max exposure
+	{0x3a14, 0x02}, // 50Hz max exposure
+	{0x3a15, 0xe0}, // 50Hz max exposure
+	{0x4004, 0x02}, // BLC line number
+	{0x3002, 0x1c}, // reset JFIFO, SFIFO, JPG
+	{0x3006, 0xc3}, // disable clock of JPEG2x, JPEG
+	{0x4713, 0x03}, // JPEG mode 3
+	{0x4407, 0x04}, // Quantization scale
+	{0x460b, 0x37},
+	{0x460c, 0x20},
+	{0x4837, 0x16}, // MIPI global timing
+	{0x3824, 0x04}, // PCLK manual divider
+	{0x5001, 0x83}, // SDE on, CMX on, AWB on
+	{0x3503, 0x00}, // AEC/AGC on
 	
+#if 1	
+	{0x3a08, 0x00},
+	{0x3a09, 0xdd},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0xb8},
+	{0x3a0e, 0x03},
+	{0x3a0d, 0x04},
+#endif
+
+#endif
+
 	{0xffff, 0xff},
 };
 
+#if 0
 static struct aml_camera_i2c_fig_s OV5640_preview_XGA_script[] = {
 	{0x3503, 0x07},
 	{0x3a00, 0x78},
@@ -1540,7 +2668,9 @@ static struct aml_camera_i2c_fig_s OV5640_preview_XGA_script[] = {
 	
 	{0xffff, 0xff}
 };
+#endif
 
+#if 0
 static struct aml_camera_i2c_fig_s OV5640_preview_SVGA_script[] = { //SVGA: 800*600
 	{0x3800, 0x00},
 	{0x3801, 0x00},
@@ -1558,6 +2688,7 @@ static struct aml_camera_i2c_fig_s OV5640_preview_SVGA_script[] = { //SVGA: 800*
 	{0x380d, 0x68},
 	{0x380e, 0x03},
 };
+#endif
 
 static struct aml_camera_i2c_fig_s OV5640_preview_QVGA_script[] = {
 	{0x3503, 0x00},
@@ -1608,6 +2739,8 @@ static struct aml_camera_i2c_fig_s OV5640_preview_QVGA_script[] = {
 };
 
 static struct aml_camera_i2c_fig_s OV5640_capture_5M_script[] = {
+
+#if 0
 	{0x3035, 0x31},
 	{0x3036, 0x69},
 	{0x3c07, 0x07},
@@ -1658,6 +2791,51 @@ static struct aml_camera_i2c_fig_s OV5640_capture_5M_script[] = {
 	{0x3820, 0x41},  // #3 ck. 0x47,
 	{0x3821, 0x07},  // #3 ck. 0x01, 
 	{0xffff, 0xff}
+#endif
+
+#if 1
+{0x3035, 0x21}, // PLL
+//{0x3036, 0x69}, // PLL fps=7.5
+{0x3036, 0x46},
+{0x3c07, 0x07}, // lightm eter 1 threshold[7:0]
+{0x3820, 0x40}, // flip
+{0x3821, 0x06}, // mirror
+{0x3814, 0x11}, // timing X inc
+{0x3815, 0x11}, // timing Y inc
+{0x3800, 0x00}, // HS
+{0x3801, 0x00}, // HS
+{0x3802, 0x00}, // VS
+{0x3803, 0x00}, // VS
+{0x3804, 0x0a}, // HW (HE)
+{0x3805, 0x3f}, // HW (HE)
+{0x3806, 0x07}, // VH (VE)
+{0x3807, 0x9f}, // VH (VE)
+{0x3808, 0x0a}, // DVPHO
+{0x3809, 0x20}, // DVPHO
+{0x380a, 0x07}, // DVPVO
+{0x380b, 0x98}, // DVPVO
+{0x380c, 0x0b}, // HTS
+{0x380d, 0x1c}, // HTS
+{0x380e, 0x07}, // VTS
+{0x380f, 0xb0}, // VTS
+{0x3813, 0x04}, // timing V offset
+{0x3618, 0x04},
+{0x3612, 0x2b},
+{0x3709, 0x12},
+{0x370c, 0x00},
+{0x4004, 0x06}, // BLC line number
+{0x3002, 0x1c}, // reset JFIFO, SFIFO, JPG
+{0x3006, 0xc3}, // disable clock of JPEG2x, JPEG
+{0x4713, 0x02}, // JPEG mode 3
+{0x4407, 0x0c}, // Quantization sacle
+{0x460b, 0x37},
+{0x460c, 0x20},
+{0x4837, 0x2c}, // MIPI global timing
+{0x3824, 0x01}, // PCLK manual divider
+{0x5001, 0x83}, // SDE on, CMX on, AWB on
+{0x3503, 0x03},
+#endif
+{0xffff, 0xff}
 };
 
 static struct aml_camera_i2c_fig_s OV5640_capture_3M_script[] = {
@@ -1760,45 +2938,35 @@ static struct aml_camera_i2c_fig_s OV5640_capture_2M_script[] = {
 	{0xffff, 0xff}
 };
 
-static int exposure_500m_setting(struct ov5640_device *dev);
-
 static resolution_param_t  prev_resolution_array[] = {
-	/*{
+	{
 		.frmsize			= {1920, 1080},
-		.active_frmsize			= {1920, 1080},
+		.active_frmsize			= {1280, 718},
 		.active_fps			= 30,
 		.size_type			= SIZE_1920X1080,
-		.reg_script			= OV5640_preview_1080P_script,
-	},*/{
+		.reg_script			= OV5640_preview_720P_script,
+	},{
 		.frmsize			= {1280, 720},
-		.active_frmsize			= {1280, 720},
+		.active_frmsize			= {1280, 718},
 		.active_fps			= 30,
 		.size_type			= SIZE_1280X720,
 		.reg_script			= OV5640_preview_720P_script,
-	},/*{
+	},{
 		.frmsize			= {1024, 768},
-		.active_frmsize			= {640, 480},
+		.active_frmsize			= {1280, 958},
 		.active_fps			= 30,
 		.size_type			= SIZE_1024X768,
-		.reg_script			= OV5640_preview_VGA_script,
-		//.reg_script			= OV5640_preview_720P_script,
-		//.reg_script			= OV5640_preview_1080P_script,
+		.reg_script			= OV5640_preview_960P_script,
 	},{
-		.frmsize			= {800, 600},
-		.active_frmsize			= {800, 600},
-		.active_fps			= 30,
-		.size_type			= SIZE_800X600,
-		.reg_script			= OV5640_preview_SVGA_script,
-	},*/{
 		.frmsize			= {640, 480},
-		.active_frmsize			= {640, 480},
-		.active_fps			= 23,
+		.active_frmsize			= {640, 478},
+		.active_fps			= 30,
 		.size_type			= SIZE_640X480,
 		.reg_script			= OV5640_preview_VGA_script,
 	},{
 		.frmsize			= {320, 240},
 		.active_frmsize			= {320, 240},
-		.active_fps			= 23,
+		.active_fps			= 30,
 		.size_type			= SIZE_320X240,
 		.reg_script			= OV5640_preview_QVGA_script,
 	},
@@ -1901,7 +3069,7 @@ static void do_download(struct work_struct *work)
 {
 	struct ov5640_device *dev = container_of(work, struct ov5640_device, dl_work);
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int mcu_on = 0, afc_on = 0;
+	//int mcu_on = 0, afc_on = 0;
 	int ret;
 	int i = 10;
 	mutex_lock(&firmware_mutex);
@@ -1911,7 +3079,7 @@ static void do_download(struct work_struct *work)
 				ret = i2c_get_byte(client, 0x3029);
 				if (ret == 0x70)
 				break;
-				else if(ret = -1)
+				else if (ret == -1)
 					continue;
 				msleep(5);
 			}
@@ -1932,6 +3100,7 @@ void OV5640_init_regs(struct ov5640_device *dev)
 
 	while (1) {
 		if (OV5640_script[i].val==0xff&&OV5640_script[i].addr==0xffff) {
+		//if (OV5640_preview_960P_script[i].val==0xff&&OV5640_preview_960P_script[i].addr==0xffff) {
 			printk("success in initial OV5640.\n");
 			break;
 		}
@@ -2091,7 +3260,7 @@ static int Get_preview_exposure_gain(struct ov5640_device *dev)
 	ret_h = i2c_get_byte(client, 0x350c);
 	ret_l = i2c_get_byte(client,0x350d);
 	ov5640_preview_extra_lines = ((ret_h << 8) + ret_l);
-	i2c_put_byte(client,0x3503, 0x03);//stop aec/agc
+	i2c_put_byte(client,0x3503, 0x07);//stop aec/agc
 	//get preview exp & gain
 	ret_h = ret_m = ret_l = 0;
 	ov5640_preview_exposure = 0;
@@ -2101,27 +3270,22 @@ static int Get_preview_exposure_gain(struct ov5640_device *dev)
 	ov5640_preview_exposure = (ret_h << 12) + (ret_m << 4) + (ret_l >> 4);
 	ret_h = ret_m = ret_l = 0;
 	ov5640_preview_exposure = ov5640_preview_exposure + (ov5640_preview_extra_lines)/16;
-	printk("preview_exposure=%d\n", ov5640_preview_exposure);
+	//printk("preview_exposure=%d\n", ov5640_preview_exposure);
 	ret_h = ret_m = ret_l = 0;
 	ov5640_preview_maxlines = 0;
 	ret_h = i2c_get_byte(client, 0x380e);
 	ret_l = i2c_get_byte(client, 0x380f);
 	ov5640_preview_maxlines = (ret_h << 8) + ret_l;
-	printk("Preview_Maxlines=%d\n", ov5640_preview_maxlines);
+	//printk("Preview_Maxlines=%d\n", ov5640_preview_maxlines);
 	//Read back AGC Gain for preview
 	ov5640_gain = 0;
 	ov5640_gain = i2c_get_byte(client, 0x350b);
-	printk("Gain,0x350b=0x%x\n", ov5640_gain);
+	//printk("Gain,0x350b=0x%x\n", ov5640_gain);
 
 	return rc;
 }
 
-//#define CAPTURE_FRAMERATE 750
-//#define PREVIEW_FRAMERATE 1500
-
-#define CAPTURE_FRAMERATE 750
-#define PREVIEW_FRAMERATE 2250
-static int cal_exposure(struct ov5640_device *dev)
+static int cal_exposure(struct ov5640_device *dev, int pre_fps, int cap_fps)
 {
 	int rc = 0;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
@@ -2137,15 +3301,15 @@ static int cal_exposure(struct ov5640_device *dev)
 	Capture_MaxLines = Capture_MaxLines + (ov5640_preview_extra_lines)/16;
 	printk("Capture_MaxLines=%d\n", Capture_MaxLines);
 	if(ov5640_qctrl[7].default_value == CAM_BANDING_60HZ) { //60Hz
-		Lines_10ms = CAPTURE_FRAMERATE * Capture_MaxLines/12000;
+		Lines_10ms = cap_fps * Capture_MaxLines/12000;
 	} else {
-		Lines_10ms = CAPTURE_FRAMERATE * Capture_MaxLines/10000;
+		Lines_10ms = cap_fps * Capture_MaxLines/10000;
 	}
 	if(ov5640_preview_maxlines == 0) {
 		ov5640_preview_maxlines = 1;
 	}
-	ulCapture_Exposure = (ov5640_preview_exposure*(CAPTURE_FRAMERATE)*(Capture_MaxLines))/
-	(((ov5640_preview_maxlines)*(PREVIEW_FRAMERATE)));
+	ulCapture_Exposure = (ov5640_preview_exposure*(cap_fps)*(Capture_MaxLines))/
+	(((ov5640_preview_maxlines)*(pre_fps)));
 	iCapture_Gain = ov5640_gain;
 	ulCapture_Exposure_Gain = ulCapture_Exposure * iCapture_Gain;
 	if(ulCapture_Exposure_Gain < Capture_MaxLines*16) {
@@ -2288,6 +3452,8 @@ void OV5640_set_param_wb(struct ov5640_device *dev,enum  camera_wb_flip_e para)/
 	case CAM_WB_MANUAL:
 	        // TODO
 		break;
+        default:
+        	break;
 	}
 } /* OV5640_set_param_wb */
 /*************************************************************************
@@ -2480,7 +3646,7 @@ void OV5640_set_param_effect(struct ov5640_device *dev,enum camera_effect_flip_e
 static void OV5640_set_param_banding(struct ov5640_device *dev,enum  camera_banding_flip_e banding)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//unsigned char buf[4];
 	switch(banding){
 	case CAM_BANDING_60HZ:
 		printk("set banding 60Hz\n");
@@ -2499,7 +3665,7 @@ static int OV5640_AutoFocus(struct ov5640_device *dev, int focus_mode)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int ret = 0;
-	int i = 0;
+	//int i = 0;
     
 	switch (focus_mode) {
 	case CAM_FOCUS_MODE_AUTO:
@@ -2548,9 +3714,8 @@ static int OV5640_AutoFocus(struct ov5640_device *dev, int focus_mode)
 
 static int OV5640_FlashCtrl(struct ov5640_device *dev, int flash_mode)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int ret = 0;
-	int i = 0;
     
 	switch (flash_mode) {
 	case FLASHLIGHT_ON:
@@ -2581,6 +3746,8 @@ static resulution_size_t get_size_type(int width, int height)
 		rv = SIZE_1920X1080;
 	else if (width * height >= 1600 * 1200)
 		rv = SIZE_1600X1200;
+	else if (width * height >= 1280 * 960)
+		rv = SIZE_1280X960;
 	else if (width * height >= 1280 * 720)
 		rv = SIZE_1280X720;
 	else if (width * height >= 1024 * 768)
@@ -2598,7 +3765,6 @@ static int set_flip(struct ov5640_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char temp;
-	unsigned char buf[2];
 	temp = i2c_get_byte(client, 0x3821);
 	temp &= 0xf9;
 	temp |= dev->cam_info.m_flip << 1 | dev->cam_info.m_flip << 2;
@@ -2629,8 +3795,6 @@ static resolution_param_t* get_resolution_param(struct ov5640_device *dev, int i
 	if (is_capture) {
 		tmp_resolution_param = capture_resolution_array;
 		arry_size = sizeof(capture_resolution_array);
-		ov5640_frmintervals_active.denominator = 5;
-		ov5640_frmintervals_active.numerator = 1;
 	} else {
 		tmp_resolution_param = prev_resolution_array;
 		arry_size = sizeof(prev_resolution_array);
@@ -2639,8 +3803,11 @@ static resolution_param_t* get_resolution_param(struct ov5640_device *dev, int i
 	}
 	
 	for (i = 0; i < arry_size; i++) {
-		if (tmp_resolution_param[i].size_type == res_type)
+		if (tmp_resolution_param[i].size_type == res_type) {
+			ov5640_frmintervals_active.denominator = tmp_resolution_param[i].active_fps;
+			ov5640_frmintervals_active.numerator = 1;
 			return &tmp_resolution_param[i];
+		}
 	}
 	return NULL;
 }
@@ -2648,12 +3815,12 @@ static resolution_param_t* get_resolution_param(struct ov5640_device *dev, int i
 static int set_resolution_param(struct ov5640_device *dev, resolution_param_t* res_param)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int rc = -1;
+	int i=0;
+	//int rc = -1;
 	if (!res_param->reg_script) {
 		printk("error, resolution reg script is NULL\n");
 		return -1;
 	}
-	int i=0;
 	while(1) {
 		if (res_param->reg_script[i].val==0xff&&res_param->reg_script[i].addr==0xffff) {
 			printk("setting resolutin param complete\n");
@@ -2667,6 +3834,8 @@ static int set_resolution_param(struct ov5640_device *dev, resolution_param_t* r
 	}
 	dev->cur_resolution_param = res_param;
 	set_flip(dev);
+	
+	return 0;
 }
 
 static int set_focus_zone(struct ov5640_device *dev, int value)
@@ -2705,7 +3874,7 @@ unsigned char v4l_2_ov5640(int val)
 static int ov5640_setting(struct ov5640_device *dev,int PROP_ID,int value ) 
 {
 	int ret=0;
-	unsigned char cur_val;
+	//unsigned char cur_val;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -2874,7 +4043,7 @@ static void ov5640_thread_tick(struct ov5640_fh *fh)
 	buf = list_entry(dma_q->active.next,
  			struct ov5640_buffer, vb.queue);
 	dprintk(dev, 1, "%s\n", __func__);
-	dprintk(dev, 1, "list entry get buf is %x\n",buf);
+	dprintk(dev, 1, "list entry get buf is %x\n", (unsigned)buf);
 
 
 	if(!(fh->f_flags & O_NONBLOCK)){
@@ -2906,7 +4075,7 @@ static void ov5640_sleep(struct ov5640_fh *fh)
 	struct ov5640_device *dev = fh->dev;
 	struct ov5640_dmaqueue *dma_q = &dev->vidq;
 
-	int timeout;
+	//int timeout;
 	DECLARE_WAITQUEUE(wait, current);
 
 	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
@@ -2917,11 +4086,11 @@ static void ov5640_sleep(struct ov5640_fh *fh)
     	goto stop_task;
 
 	/* Calculate time to wake up */
-	timeout = msecs_to_jiffies(2);
+	//timeout = msecs_to_jiffies(1);
 
 	ov5640_thread_tick(fh);
 
-	schedule_timeout_interruptible(timeout);
+	schedule_timeout_interruptible(1);
 
 stop_task:
 	remove_wait_queue(&dma_q->wq, &wait);
@@ -3153,7 +4322,6 @@ static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
 					struct v4l2_frmivalenum *fival)
 {
-	struct ov5640_fmt *fmt;
 	unsigned int k;
 	
 	if(fival->index > ARRAY_SIZE(ov5640_frmivalenum))
@@ -3211,6 +4379,8 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 	return 0;
 }
 
+static resolution_param_t* prev_res = NULL;
+
 /*FIXME: This seems to be generic enough to be at videodev2 */
 static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
                 	struct v4l2_format *f)
@@ -3219,8 +4389,9 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	struct videobuf_queue *q = &fh->vb_vidq;
 	struct ov5640_device *dev = fh->dev;
 	resolution_param_t* res_param = NULL;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char gain = 0, exposurelow = 0, exposuremid = 0, exposurehigh = 0;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char gain = 0, exposurelow = 0, exposuremid = 0, exposurehigh = 0;
+	int cap_fps, pre_fps;
 
 	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
 	if (ret < 0)
@@ -3254,7 +4425,20 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 		Get_preview_exposure_gain(dev);
 		set_resolution_param(dev, res_param);
 		//set_exposure_param_500m(dev, gain, exposurelow, exposuremid, exposurehigh);
-		cal_exposure(dev);
+		if (prev_res && (prev_res->size_type == SIZE_1280X960 
+				|| prev_res->size_type == SIZE_1024X768)) {
+			pre_fps = 3000;
+		} else {
+			pre_fps = 2250;
+		} 
+		if (res_param && res_param->size_type == SIZE_2592X1944 ) {
+			//cap_fps = 750;
+			cap_fps = 500;
+		} else {
+			cap_fps = 750;
+		} 
+		cal_exposure(dev, pre_fps, cap_fps);
+		printk("pre_fps=%d,cap_fps=%d\n", pre_fps, cap_fps);
 	} else {
 		res_param = get_resolution_param(dev, 0, fh->width,fh->height);
 		if (!res_param) {
@@ -3262,6 +4446,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 			goto out;
 		}
 		set_resolution_param(dev, res_param);
+		prev_res = res_param;
 	}
     
 #endif
@@ -3278,8 +4463,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct ov5640_fh *fh = priv;
 	struct ov5640_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
 	
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -3347,7 +4530,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 
         memset( &para, 0, sizeof( para ));
         para.port  = TVIN_PORT_CAMERA;
-        para.fmt = TVIN_SIG_FMT_MAX;//TVIN_SIG_FMT_MAX+1;;TVIN_SIG_FMT_CAMERA_1280X720P_30Hz
+        para.fmt = TVIN_SIG_FMT_MAX;//TVIN_SIG_FMT_MAX+1;;TVIN_SIG_FMT_CAMERA_1280x720P_30Hz
         if (fh->dev->cur_resolution_param) {
                 para.frame_rate = ov5640_frmintervals_active.denominator;
                 para.h_active = fh->dev->cur_resolution_param->active_frmsize.width;
@@ -3370,13 +4553,14 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
                         para.h_active, para.v_active, para.frame_rate);
         para.hsync_phase = 1;
         para.vsync_phase  = 1;    
-        para.reserved =  2;
+        para.skip_count =  2;
         para.bt_path = dev->cam_info.bt_path;
         ret =  videobuf_streamon(&fh->vb_vidq);
         if(ret == 0){
                 vops->start_tvin_service(0,&para);
                 fh->stream_on = 1;
         }
+		OV5640_set_param_wb(dev,ov5640_qctrl[4].default_value);
         return ret;
 }
 
@@ -3601,10 +4785,15 @@ static int ov5640_open(struct file *file)
 {
 	struct ov5640_device *dev = video_drvdata(file);
 	struct ov5640_fh *fh = NULL;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int retval = 0;
-	int reg_val;
-	int i = 0;
+	//int reg_val;
+	//int i = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	mutex_lock(&firmware_mutex);
 	ov5640_have_opened=1;
 	mutex_unlock(&firmware_mutex);
@@ -3672,7 +4861,6 @@ static int ov5640_open(struct file *file)
         	sizeof(struct ov5640_buffer), fh, NULL);
 	bDoingAutoFocusMode=false;
 	ov5640_start_thread(fh);
-
 	return 0;
 }
 
@@ -3746,6 +4934,9 @@ static int ov5640_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -3834,7 +5025,6 @@ static int ov5640_probe(struct i2c_client *client,
         	const struct i2c_device_id *id)
 {
 	aml_cam_info_t* plat_dat;
-	int pgbuf;
 	int err;
 	struct ov5640_device *t;
 	struct v4l2_subdev *sd;
@@ -3843,7 +5033,7 @@ static int ov5640_probe(struct i2c_client *client,
         	client->addr << 1, client->adapter->name);
 	t = kzalloc(sizeof(*t), GFP_KERNEL);
 	if (t == NULL)
-    	return -ENOMEM;
+    		return -ENOMEM;
 	sd = &t->sd;
 	v4l2_i2c_subdev_init(sd, client, &ov5640_ops);
 	mutex_init(&t->mutex);
@@ -3901,10 +5091,14 @@ static const struct i2c_device_id ov5640_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov5640_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "ov5640",
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.name = "ov5640",
+	},
 	.probe = ov5640_probe,
 	.remove = ov5640_remove,
 	.id_table = ov5640_id,
 };
 
+module_i2c_driver(ov5640_i2c_driver);
+
diff --git a/drivers/amlogic/camera/ov5642.c b/drivers/amlogic/camera/ov5642.c
index 62f63836d986..29cffa23d794 100755
--- a/drivers/amlogic/camera/ov5642.c
+++ b/drivers/amlogic/camera/ov5642.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -36,8 +37,6 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 
 #include <mach/am_regs.h>
@@ -45,7 +44,6 @@
 #include <mach/pinmux.h>
 #include <mach/gpio.h>
 
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #include "ov5642_firmware.h"
@@ -55,8 +53,6 @@
 #endif
 #define OV5642_CAMERA_MODULE_NAME "ov5642"
 
-#include <media/amlogic/flashlight.h>
-
 /* Wake up at about 30 fps */
 #define WAKE_NUMERATOR 30
 #define WAKE_DENOMINATOR 1001
@@ -85,7 +81,6 @@ static unsigned int vid_limit = 16;
 
 //extern int disable_ov5642;
 static int ov5642_have_opened = 0;
-static struct i2c_client *this_client;
 
 static void do_download(struct work_struct *work);
 static DECLARE_DELAYED_WORK(dl_work, do_download);
@@ -474,10 +469,10 @@ struct ov5642_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct ov5642_fh *to_fh(struct ov5642_device *dev)
+/*static inline struct ov5642_fh *to_fh(struct ov5642_device *dev)
 {
 	return container_of(dev, struct ov5642_fh, dev);
-}
+}*/
 
 
 
@@ -1398,8 +1393,6 @@ struct aml_camera_i2c_fig_s OV5642_capture_2M_script[] = {
 	{0xffff, 0xff}
 };
 
-static int exposure_500m_setting(struct ov5642_device *dev);
-
 static resolution_param_t  prev_resolution_array[] = {
 	{
 		.frmsize			= {640, 480},
@@ -1498,7 +1491,7 @@ static void do_download(struct work_struct *work)
 {
 	struct ov5642_device *dev = container_of(work, struct ov5642_device, dl_work);
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int mcu_on = 0, afc_on = 0;
+	//int mcu_on = 0, afc_on = 0;
 	int ret;
 	int i = 10;
 	mutex_lock(&firmware_mutex);
@@ -1541,7 +1534,6 @@ void OV5642_init_regs(struct ov5642_device *dev)
 }
 
 static unsigned long ov5642_preview_exposure;
-static unsigned long ov5642_preview_extra_lines;
 static unsigned long ov5642_gain;
 static unsigned long ov5642_preview_maxlines;
 
@@ -1553,8 +1545,8 @@ static unsigned char preview_reg350b;
 
 static int rewrite_preview_gain_exposure(struct ov5642_device *dev)
 {
-	int rc = 0;
-	unsigned char reg_l, reg_m, reg_h;
+	//int rc = 0;
+	//unsigned char reg_l, reg_m, reg_h;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	
 	i2c_put_byte(client, 0x3500, preview_reg3500);
@@ -1562,6 +1554,7 @@ static int rewrite_preview_gain_exposure(struct ov5642_device *dev)
 	i2c_put_byte(client, 0x3502, preview_reg3502);
 	
 	i2c_put_byte(client, 0x350b, preview_reg350b);
+	return 0;
 }
 	
 
@@ -1580,19 +1573,19 @@ static int get_preview_exposure_gain(struct ov5642_device *dev)
 	preview_reg3501 = ret_m = i2c_get_byte(client,0x3501);
 	preview_reg3502 = ret_l = i2c_get_byte(client,0x3502);
 	ov5642_preview_exposure = (ret_h << 12) + (ret_m << 4) + (ret_l >> 4);
-	printk("preview_exposure=%d\n", ov5642_preview_exposure);
+	//printk("preview_exposure=%d\n", ov5642_preview_exposure);
 	
 	ret_h = ret_m = ret_l = 0;
 	ov5642_preview_maxlines = 0;
 	ret_h = i2c_get_byte(client, 0x380e);
 	ret_l = i2c_get_byte(client, 0x380f);
 	ov5642_preview_maxlines = (ret_h << 8) + ret_l;
-	printk("Preview_Maxlines=%d\n", ov5642_preview_maxlines);
+	//printk("Preview_Maxlines=%d\n", ov5642_preview_maxlines);
 	
 	//Read back AGC Gain for preview
 	ov5642_gain = 0;
 	preview_reg350b = ov5642_gain = i2c_get_byte(client, 0x350b);
-	printk("Gain,0x350b=0x%x\n", ov5642_gain);
+	//printk("Gain,0x350b=0x%x\n", ov5642_gain);
 
 	return rc;
 }
@@ -1609,7 +1602,7 @@ static int cal_exposure(struct ov5642_device *dev)
 	int rc = 0;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//calculate capture exp & gain
-	unsigned char ExposureLow,ExposureMid,ExposureHigh,Capture_MaxLines_High,Capture_MaxLines_Low;
+	unsigned char ExposureLow,ExposureMid,ExposureHigh;
 	unsigned int ret_l,ret_m,ret_h,Lines_10ms;
 	unsigned short ulCapture_Exposure,iCapture_Gain;
 	unsigned int ulCapture_Exposure_Gain,Capture_MaxLines;
@@ -1705,7 +1698,7 @@ static int cal_exposure(struct ov5642_device *dev)
 	i2c_put_byte(client, 0x3501, ExposureMid);
 	i2c_put_byte(client, 0x3500, ExposureHigh);
 	
-	printk("ov5642_gain=%d\n", ov5642_gain);
+	//printk("ov5642_gain=%d\n", ov5642_gain);
 	printk("ExposureLow=%d\n", ExposureLow);
 	printk("ExposureMid=%d\n", ExposureMid);
 	printk("ExposureHigh=%d\n", ExposureHigh);
@@ -1817,6 +1810,8 @@ void OV5642_set_param_wb(struct ov5642_device *dev,enum  camera_wb_flip_e para)/
     	case CAM_WB_MANUAL:
                 // TODO
         	break;
+        default:
+        	break;
 	}
     
 
@@ -2010,10 +2005,10 @@ void OV5642_set_param_effect(struct ov5642_device *dev,enum camera_effect_flip_e
 * GLOBALS AFFECTED
 *
 *************************************************************************/
-static void OV5642_set_param_banding(struct ov5642_device *dev,enum  camera_night_mode_flip_e banding)
+static void OV5642_set_param_banding(struct ov5642_device *dev,enum  camera_banding_flip_e banding)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
+	//unsigned char buf[4];
 	switch(banding){
 	case CAM_BANDING_60HZ:
 		printk("set banding 60Hz\n");
@@ -2032,7 +2027,7 @@ static int OV5642_AutoFocus(struct ov5642_device *dev, int focus_mode)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int ret = 0;
-	int i = 0;
+	//int i = 0;
     
 	switch (focus_mode) {
 	case CAM_FOCUS_MODE_AUTO:
@@ -2083,9 +2078,9 @@ static int OV5642_AutoFocus(struct ov5642_device *dev, int focus_mode)
 
 static int OV5642_FlashCtrl(struct ov5642_device *dev, int flash_mode)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int ret = 0;
-	int i = 0;
+	//int i = 0;
     
 	switch (flash_mode) {
 	case FLASHLIGHT_ON:
@@ -2137,6 +2132,8 @@ static int set_flip(struct ov5642_device *dev)
 	temp |= dev->cam_info.m_flip << 5;
 	i2c_put_byte(client, 0x3621, temp);
 	printk("0x3621 dst is %x\n", temp);
+	
+	return 0;
 }
 		
 static resolution_param_t* 
@@ -2169,12 +2166,12 @@ static int
 set_resolution_param(struct ov5642_device *dev, resolution_param_t* res_param)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int rc = -1;
+	//int rc = -1;
+	int i=0;
 	if (!res_param->reg_script) {
 		printk("error, resolution reg script is NULL\n");
 		return -1;
 	}
-	int i=0;
 	while(1) {
 		if (res_param->reg_script[i].val==0xff
 				&&res_param->reg_script[i].addr==0xffff) {
@@ -2192,6 +2189,7 @@ set_resolution_param(struct ov5642_device *dev, resolution_param_t* res_param)
 	ov5642_frmintervals_active.denominator = 15;//res_param->active_fps/10;
 	ov5642_frmintervals_active.numerator  = 1;
 	set_flip(dev);
+	return 0;
 }
 
 unsigned char v4l_2_ov5642(int val)
@@ -2230,18 +2228,24 @@ static int set_focus_zone(struct ov5642_device *dev, int value)
 static int ov5642_setting(struct ov5642_device *dev,int PROP_ID,int value ) 
 {
 	int ret=0;
-	unsigned char cur_val;
+	//unsigned char cur_val;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
+		mutex_lock(&firmware_mutex);
 		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_ov5642(value));
 		ret=i2c_put_byte(client,0x0201,v4l_2_ov5642(value));
+		mutex_unlock(&firmware_mutex);
 		break;
 	case V4L2_CID_CONTRAST:
+		mutex_lock(&firmware_mutex);
 		ret=i2c_put_byte(client,0x0200, value);
+		mutex_unlock(&firmware_mutex);
 		break;    
 	case V4L2_CID_SATURATION:
+		mutex_lock(&firmware_mutex);
 		ret=i2c_put_byte(client,0x0202, value);
+		mutex_unlock(&firmware_mutex);
 		break;
 	case V4L2_CID_HFLIP:    /* set flip on H. */
 		value = value & 0x3;
@@ -2253,32 +2257,40 @@ static int ov5642_setting(struct ov5642_device *dev,int PROP_ID,int value )
 	case V4L2_CID_VFLIP:    /* set flip on V. */
 		break;    
 	case V4L2_CID_DO_WHITE_BALANCE:
+		mutex_lock(&firmware_mutex);
 		if(ov5642_qctrl[4].default_value!=value){
 			ov5642_qctrl[4].default_value=value;
 			OV5642_set_param_wb(dev,value);
 			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
 		}
+		mutex_unlock(&firmware_mutex);
 		break;
 	case V4L2_CID_EXPOSURE:
+		mutex_lock(&firmware_mutex);
 		if(ov5642_qctrl[5].default_value!=value){
 			ov5642_qctrl[5].default_value=value;
 			OV5642_set_param_exposure(dev,value);
 			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
 		}
+		mutex_unlock(&firmware_mutex);
 		break;
 	case V4L2_CID_COLORFX:
+		mutex_lock(&firmware_mutex);
 		if(ov5642_qctrl[6].default_value!=value){
 			ov5642_qctrl[6].default_value=value;
 			OV5642_set_param_effect(dev,value);
 			printk(KERN_INFO " set camera  effect=%d. \n ",value);
 		}
+		mutex_unlock(&firmware_mutex);
 		break;
 	case V4L2_CID_WHITENESS:
+		mutex_lock(&firmware_mutex);
 		if(ov5642_qctrl[7].default_value!=value){
 			ov5642_qctrl[7].default_value=value;
 			OV5642_set_param_banding(dev,value);
 			printk(KERN_INFO " set camera  banding=%d. \n ",value);
 		}
+		mutex_unlock(&firmware_mutex);
 		break;
 	case V4L2_CID_FOCUS_AUTO:
 		mutex_lock(&firmware_mutex);
@@ -2385,7 +2397,7 @@ static void ov5642_thread_tick(struct ov5642_fh *fh)
 	buf = list_entry(dma_q->active.next,
              struct ov5642_buffer, vb.queue);
     dprintk(dev, 1, "%s\n", __func__);
-    dprintk(dev, 1, "list entry get buf is %x\n",buf);
+	dprintk(dev, 1, "list entry get buf is %x\n", (unsigned)buf);
 
     /* Nobody is waiting on this buffer, return */
     /*
@@ -2716,7 +2728,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	struct ov5642_device *dev = fh->dev;
 	resolution_param_t* res_param = NULL;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char gain = 0, exposurelow = 0, exposuremid = 0, exposurehigh = 0;
+	//unsigned char gain = 0, exposurelow = 0, exposuremid = 0, exposurehigh = 0;
 
 	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
 	if (ret < 0)
@@ -2793,8 +2805,8 @@ static int vidioc_g_parm(struct file *file, void *priv,
 	struct ov5642_fh *fh = priv;	
 	struct ov5642_device *dev = fh->dev;
 	struct v4l2_captureparm *cp = &parms->parm.capture;
-	int ret;
-	int i;
+	//int ret;
+	//int i;
 
 	dprintk(dev,3,"vidioc_g_parm\n");
 	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2811,7 +2823,7 @@ static int vidioc_g_parm(struct file *file, void *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
 				   struct v4l2_frmivalenum *fival)
 {
-	struct ov5642_fmt *fmt;
+	//struct ov5642_fmt *fmt;
 	unsigned int k;
 
 	if(fival->index > ARRAY_SIZE(ov5642_frmivalenum))
@@ -2906,7 +2918,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
                         para.h_active, para.v_active, para.frame_rate);
         para.hsync_phase = 1;
         para.vsync_phase  = 1;
-        para.reserved =  2;
+        para.skip_count =  2;
         ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
 		vops->start_tvin_service(0,&para);
@@ -3135,10 +3147,15 @@ static int ov5642_open(struct file *file)
 {
 	struct ov5642_device *dev = video_drvdata(file);
 	struct ov5642_fh *fh = NULL;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int retval = 0;
-	int reg_val;
-	int i = 0;
+	//int reg_val;
+	//int i = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	ov5642_have_opened=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -3273,6 +3290,9 @@ static int ov5642_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -3360,7 +3380,6 @@ static const struct v4l2_subdev_ops ov5642_ops = {
 static int ov5642_probe(struct i2c_client *client,
         	const struct i2c_device_id *id)
 {
-	int pgbuf;
 	int err;
 	struct ov5642_device *t;
 	struct v4l2_subdev *sd;
@@ -3427,10 +3446,14 @@ static const struct i2c_device_id ov5642_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov5642_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "ov5642",
+static struct i2c_driver ov5642_i2c_driver = {
+	.driver = {
+		.name = "ov5642",
+	},
 	.probe = ov5642_probe,
 	.remove = ov5642_remove,
 	.id_table = ov5642_id,
 };
 
+module_i2c_driver(ov5642_i2c_driver);
+
diff --git a/drivers/amlogic/camera/ov5647.c b/drivers/amlogic/camera/ov5647.c
index 79a7ed79322b..73eecde6a4c1 100755
--- a/drivers/amlogic/camera/ov5647.c
+++ b/drivers/amlogic/camera/ov5647.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,8 +36,6 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 
 #include <linux/amlogic/camera/aml_cam_info.h>
 
@@ -46,7 +45,6 @@
 //#include <media/amlogic/656in.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
-#include <linux/tvin/tvin_v4l2.h>
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
@@ -110,14 +108,15 @@ extern unsigned int sensor_aet_step;
 static unsigned int exp_mode;
 static unsigned int change_cnt;
 static unsigned int current_fmt;
-static unsigned int current_fr;
+static unsigned int current_fr = 0;//50 hz
 static unsigned int aet_index;
+static unsigned int last_af_step = 0;
 
 static struct file *debug_file;
 static struct ov5647_device *debug_dev;
 static struct ov5647_fh *debug_fh;
 
-static int i_index = 3;
+static int i_index = 4;
 static int t_index = -1;
 static int dest_hactive = 640;
 static int dest_vactive = 480;
@@ -230,8 +229,7 @@ static struct v4l2_queryctrl ov5647_qctrl[] = {
 		.maximum	= 270,
 		.step		= 90,
 		.default_value	= 0,
-		//.flags         = V4L2_CTRL_FLAG_SLIDER,
-		.flags         = V4L2_CTRL_FLAG_DISABLED,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
 	},{
         .id            = V4L2_CID_AUTO_FOCUS_STATUS,
         .type          = 8,//V4L2_CTRL_TYPE_BITMASK,
@@ -513,9 +511,10 @@ struct ov5647_dmaqueue {
 
 typedef enum resulution_size_type{
 	//SIZE_NULL = 0,
-	SIZE_QVGA_320X240,
+	SIZE_CIF_352X288,
 	SIZE_VGA_640X480,
 	SIZE_720P_1280X720,
+	SIZE_960P_1280X960,
 	SIZE_1080P_1920X1080,
 	SIZE_H1080P_2592X1944
 } resulution_size_type_t;
@@ -1403,8 +1402,13 @@ struct aml_camera_i2c_fig_s OV5647_capture_5M_script[] = {
 };
 
 static resolution_param_t  prev_resolution_array[] = {
-	#if 1
 	{
+		.frmsize			= {640, 480},
+		.active_frmsize		= {352, 288},
+		.active_fps			= 30,
+		.size_type			= SIZE_CIF_352X288,
+		.reg_script			= OV5647_preview_VGA_script,
+	}, {
 		.frmsize			= {640, 480},
 		.active_frmsize		= {640, 480},
 		.active_fps			= 30,
@@ -1418,9 +1422,9 @@ static resolution_param_t  prev_resolution_array[] = {
 		.reg_script			= OV5647_preview_720P_script,
 	}, {
 		.frmsize			= {1280, 960},
-		.active_frmsize		= {1280, 960},
+		.active_frmsize		= {1280, 720},
 		.active_fps			= 30,
-		.size_type			= SIZE_720P_1280X720,
+		.size_type			= SIZE_960P_1280X960,
 		.reg_script			= OV5647_preview_960P_script,
 	}, {
 		.frmsize			= {1920, 1080},
@@ -1435,36 +1439,17 @@ static resolution_param_t  prev_resolution_array[] = {
 		.size_type			= SIZE_H1080P_2592X1944,
 		.reg_script			= OV5647_capture_5M_script,
 	},
-	#else
-	 {
-		.frmsize			= {1280, 720},
-		.active_frmsize		= {1280, 720},
-		.active_fps			= 30,
-		.size_type			= SIZE_720P_1280X720,
-		.reg_script			= OV5647_preview_720P_script,
-	}
-	#endif
 };
 	
 
 static resolution_param_t  capture_resolution_array[] = {
-	#if 1
-	 {
-		.frmsize			= {640, 480},
-		.active_frmsize		= {640, 480},
-		.active_fps			= 30,
-		.size_type			= SIZE_VGA_640X480,
-		.reg_script			= OV5647_preview_VGA_script,
-	}, 
-#else
 	{
 		.frmsize			= {2592, 1944},
-		.active_frmsize		= {2592, 1942},
+		.active_frmsize		= {2592, 1944},
 		.active_fps			= 7.5,
 		.size_type			= SIZE_H1080P_2592X1944,
 		.reg_script			= OV5647_capture_5M_script,
 	},
-	#endif
 };
 
 
@@ -1558,12 +1543,12 @@ static bool OV5647_set_aet_new_step(unsigned int new_step, bool exp_mode, bool a
 
 static bool OV5647_check_mains_freq(void){// when the fr change,we need to change the aet table
     int detection; 
-		struct i2c_adapter *adapter;
-		
+    struct i2c_adapter *adapter;
+#if 0		
     if(exp_mode != 2)//if current is not auto mode ,return
         return false;
 
-    detection = my_i2c_get_byte(adapter,0x36,0x3c0c);
+    detection = my_i2c_get_byte(adapter,0x36,0x3c0c) & 1;
     if(current_fr != detection){
         change_cnt++;
         if(change_cnt > 5){
@@ -1579,43 +1564,62 @@ static bool OV5647_check_mains_freq(void){// when the fr change,we need to chang
         change_cnt = 0;	
     }
     return false;
+#endif
+    return true;
 }
 
-bool OV5647_set_af_new_step(unsigned int af_control){
-	struct i2c_adapter *adapter;
-	char buf[3];
-	unsigned char byte_h  = (af_control>>8)&0x000000ff;
-	unsigned char byte_l  = (af_control>>0)&0x000000ff;
-	
-	buf[0] = byte_h;
-	buf[1] = byte_l;
-	adapter = i2c_get_adapter(4);
-	my_i2c_put_byte_add8(adapter,0x0c,buf,2);
-	return true;
+bool OV5647_set_af_new_step(unsigned int af_step){
+    struct i2c_adapter *adapter;
+    char buf[3];
+    unsigned int diff = 0;
+    int codes;
+    unsigned int vcm_data = 0;
+    unsigned char byte_h, byte_l;
+    if(af_step == last_af_step)
+        return true;
+    diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
+    last_af_step = af_step;
+    if(diff < 256){
+        codes = 1;
+    }else if(diff < 512){
+        codes = 2;	
+    }else
+        codes = 3;
+    vcm_data |= (codes << 2); // bit[3:2]
+    vcm_data |= (last_af_step << 4);  // bit[4:13]
+    byte_h  = (vcm_data >> 8) & 0x000000ff;
+    byte_l  = (vcm_data >> 0) & 0x000000ff;
+
+    buf[0] = byte_h;
+    buf[1] = byte_l;
+    adapter = i2c_get_adapter(4);
+    my_i2c_put_byte_add8(adapter,0x0c,buf,2);
+    return true;
 
 }
 
 
 
 void OV5647_set_new_format(int width,int height,int fr){
-		int index = 0;
-		current_fr = fr;
-		printk("sum:%d,is_capture:%d,fr:%d\n",cf->aet.sum,is_capture,fr);
-		while(index < cf->aet.sum){
-			if(width == cf->aet.aet[index].info->fmt_hactive && height == cf->aet.aet[index].info->fmt_vactive \
-				&& fr == cf->aet.aet[index].info->fmt_main_fr && is_capture == cf->aet.aet[index].info->fmt_capture){
-					break;	
-				}
-			index++;	
-		}
-		if(index >= cf->aet.sum){
-			printk("use default value\n");
-			index = 0;	
-		}
-		sensor_aet_info = cf->aet.aet[index].info;
-		sensor_aet_table = cf->aet.aet[index].aet_table;
-		sensor_aet_step = sensor_aet_info->tbl_rated_step;
-		OV5647_set_aet_new_step(sensor_aet_step,1,1);
+    int index = 0;
+    current_fr = fr;
+    printk("sum:%d,is_capture:%d,fr:%d\n",cf->aet.sum,is_capture,fr);
+    while(index < cf->aet.sum){
+        if(width == cf->aet.aet[index].info->fmt_hactive && height == cf->aet.aet[index].info->fmt_vactive \
+                && fr == cf->aet.aet[index].info->fmt_main_fr && is_capture == cf->aet.aet[index].info->fmt_capture){
+            break;	
+        }
+        index++;	
+    }
+    if(index >= cf->aet.sum){
+        printk("use default value\n");
+        index = 0;	
+    }
+    printk("current aet index :%d\n",index);
+    sensor_aet_info = cf->aet.aet[index].info;
+    sensor_aet_table = cf->aet.aet[index].aet_table;
+    sensor_aet_step = sensor_aet_info->tbl_rated_step;
+    OV5647_set_aet_new_step(sensor_aet_step,1,1);
 }
 
 
@@ -1750,17 +1754,31 @@ static ssize_t vcm_manual_store(struct class *cls,struct class_attribute *attr,
 {
 	struct i2c_adapter *adapter;
 	char buff[3];
-	unsigned int af_control = 0;
-	sscanf(buf,"%x",&af_control);
-	
-	unsigned char byte_h  = (af_control>>8)&0x000000ff;
-	unsigned char byte_l  = (af_control>>0)&0x000000ff;
-	
-	buff[0] = byte_h;
-	buff[1] = byte_l;
-	adapter = i2c_get_adapter(4);
-	my_i2c_put_byte_add8(adapter,0x0c,buff,2);
-	return len;
+	unsigned int af_step = 0;
+	unsigned int diff = 0;
+	int codes,vcm_data;
+	unsigned char byte_h, byte_l;
+	sscanf(buf,"%d",&af_step);
+    if(af_step == last_af_step)
+        return len;
+    diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
+    last_af_step = af_step;
+    if(diff < 256){
+        codes = 1;
+    }else if(diff < 512){
+        codes = 2;	
+    }else
+        codes = 3;
+    vcm_data |= (codes << 2); // bit[3:2]
+    vcm_data |= (last_af_step << 4);  // bit[4:13]
+    printk("set vcm step :%x\n",vcm_data);   
+    byte_h  = (vcm_data >> 8) & 0x000000ff;
+    byte_l  = (vcm_data >> 0) & 0x000000ff;
+    buff[0] = byte_h;
+    buff[1] = byte_l;
+    adapter = i2c_get_adapter(4);
+    my_i2c_put_byte_add8(adapter,0x0c,buff,2);
+    return len;
 }
 
 static ssize_t vcm_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
@@ -1770,12 +1788,30 @@ static ssize_t vcm_manual_show(struct class *cls,struct class_attribute *attr, c
 	unsigned int af;
 	adapter = i2c_get_adapter(4);
 	af = my_i2c_get_word(adapter,0x0c);
-	printk("af:%x\n",af);
+	printk("current vcm step :%x\n",af);
 	return len;
 }
 
 static CLASS_ATTR(vcm_debug, 0664, vcm_manual_show, vcm_manual_store);
 
+static ssize_t light_source_freq_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	int freq;
+	sscanf(buf,"%d",&freq);
+	current_fr = freq ? 1 : 0;
+	printk("set current light soure frequency :%d\n",freq);
+	return len;
+}
+
+static ssize_t light_source_freq_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	printk("light source frequence :%d\n",current_fr);
+	return len;
+}
+
+static CLASS_ATTR(light_source_debug, 0664, light_source_freq_manual_show, light_source_freq_manual_store);
+
 //load OV5647 parameters
 void OV5647_init_regs(struct ov5647_device *dev)
 {
@@ -2117,12 +2153,14 @@ static resulution_size_type_t get_size_type(int width, int height)
         rv = SIZE_H1080P_2592X1944;
     else if (width * height >= 1900 * 1000)
         rv = SIZE_1080P_1920X1080;
+    else if (width * height >= 1200 * 900)
+        rv = SIZE_960P_1280X960;
     else if (width * height >= 1200 * 700)
         rv = SIZE_720P_1280X720;
     else if (width * height >= 600 * 400)
         rv = SIZE_VGA_640X480;
-    else if (width * height >= 300 * 200)
-        rv = SIZE_QVGA_320X240;
+    else 
+        rv = SIZE_CIF_352X288;
     return rv;
 }
 
@@ -2202,9 +2240,9 @@ void set_resolution_param(struct ov5647_device *dev, resolution_param_t* res_par
     }
     ov5647_frmintervals_active.numerator = 1;
     ov5647_frmintervals_active.denominator = res_param->active_fps;
-    ov5647_h_active = res_param->active_frmsize.width;
-	ov5647_v_active = res_param->active_frmsize.height;
-	OV5647_set_new_format(ov5647_h_active,ov5647_v_active,0);// should set new para
+    ov5647_h_active = res_param->frmsize.width;
+    ov5647_v_active = res_param->frmsize.height;
+    OV5647_set_new_format(ov5647_h_active,ov5647_v_active,current_fr);// should set new para
 }    /* OV5647_set_resolution */
 
 unsigned char v4l_2_ov5647(int val)
@@ -2219,7 +2257,6 @@ static int ov5647_setting(struct ov5647_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-    printk("ov5647_setting:%x,value:%x,base:%x\n",PROP_ID,value,V4L2_CID_BASE);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
 		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_ov5647(value));
@@ -2514,15 +2551,6 @@ buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
 
 	/* These properties only change when queue is idle, see s_fmt */
 	buf->fmt       = fh->fmt;
-	#if 0
-	if(t_index != -1){
-		buf->vb.width = dest_hactive;
-		buf->vb.height = dest_vactive;		
-	}else{
-		buf->vb.width  = fh->width;
-		buf->vb.height = fh->height;
-	}
-	#endif
 	buf->vb.width  = fh->width;
 	buf->vb.height = fh->height;
 	buf->vb.field  = field;
@@ -2711,44 +2739,29 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	fh->height        = f->fmt.pix.height;
 	fh->vb_vidq.field = f->fmt.pix.field;
 	fh->type          = f->type;
-	 if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
-	 		is_capture = 1;
-    	res_param = get_resolution_param(dev, 1, fh->width,fh->height);
-    	if (!res_param) {
-    		printk("error, resolution param not get\n");
-    		goto out;
-   		}
-    	/*get_exposure_param(dev, &gain, &exposurelow, &exposuremid, &exposurehigh);
-    	printk("gain=0x%x, exposurelow=0x%x, exposuremid=0x%x, exposurehigh=0x%x\n",
-    			 gain, exposurelow, exposuremid, exposurehigh);
-    	*/
-    	//Get_preview_exposure_gain(dev);
-    	/** set target ***/
-    	if(t_index == -1){
-    		dest_hactive = res_param->active_frmsize.width;
-				dest_vactive = res_param->active_frmsize.height;
-			}
-    	set_resolution_param(dev, res_param);
-    	//set_exposure_param_500m(dev, gain, exposurelow, exposuremid, exposurehigh);
-    	//cal_exposure(dev);
+    if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
+        is_capture = 1;
+        res_param = get_resolution_param(dev, 1, fh->width,fh->height);
+        if (!res_param) {
+            printk("error, resolution param not get\n");
+            goto out;
+        }
+        set_resolution_param(dev, res_param);
     }
     else {
-			is_capture = 0;
-			res_param = get_resolution_param(dev, 0, fh->width,fh->height);
-			if (!res_param) {
-			printk("error, resolution param not get\n");
-			goto out;
-			}
-   		    	/** set target ***/
-			if(t_index == -1){
-    		dest_hactive = res_param->active_frmsize.width;
-				dest_vactive = res_param->active_frmsize.height;
-			}
-   		set_resolution_param(dev, res_param);
+        is_capture = 0;
+        res_param = get_resolution_param(dev, 0, fh->width,fh->height);
+        if (!res_param) {
+            printk("error, resolution param not get\n");
+            goto out;
+        }
+        /** set target ***/
+        if(t_index == -1){
+            dest_hactive = res_param->active_frmsize.width;
+            dest_vactive = res_param->active_frmsize.height;
+        }
+        set_resolution_param(dev, res_param);
     }
-    //OV5647_set_new_format(ov5647_h_active,ov5647_v_activ,current_fr);
-	// here we can set flash	
-
 	ret = 0;
 out:
 	mutex_unlock(&q->vb_lock);
@@ -2835,8 +2848,14 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
     para.frame_rate = ov5647_frmintervals_active.denominator;
     para.h_active = ov5647_h_active;
     para.v_active = ov5647_v_active;
-   	para.dest_hactive = dest_hactive;
-   	para.dest_vactive = dest_vactive;
+    if(is_capture == 0){
+   		para.dest_hactive = dest_hactive;
+   		para.dest_vactive = dest_vactive;
+   	}else{
+        para.skip_count = 2;
+   		para.dest_hactive = 0;
+   		para.dest_vactive = 0;	
+   	}
     para.hsync_phase = 1;
     para.vsync_phase  = 1;
     para.hs_bp = 0;
@@ -2844,7 +2863,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
     para.cfmt = TVIN_YUV422;
     para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
     para.bt_path = dev->cam_info.bt_path;
-    current_fmt = 0; 
+    current_fmt = 0;
     if(dev->cam_para == NULL)
     	return -EINVAL;
     if(generate_para(dev->cam_para,dev->pindex) == 0){
@@ -2854,25 +2873,21 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
         para.reserved = 0;
     }
     dev->cam_para->cam_function.set_aet_new_step = OV5647_set_aet_new_step;
- 		dev->cam_para->cam_function.check_mains_freq = OV5647_check_mains_freq;
- 		dev->cam_para->cam_function.set_af_new_step = OV5647_set_af_new_step;
-		if(is_capture == 1){
-	    		dev->cam_para->cam_mode = CAMERA_PREVIEW;
-	    }else{
-	    		dev->cam_para->cam_mode = CAMERA_PREVIEW;	
-		}
-    
+    dev->cam_para->cam_function.check_mains_freq = OV5647_check_mains_freq;
+    dev->cam_para->cam_function.set_af_new_step = OV5647_set_af_new_step;
+    dev->cam_para->cam_mode = CAMERA_PREVIEW;	
+
     printk("ov5647,h=%d, v=%d, frame_rate=%d\n", 
             ov5647_h_active, ov5647_v_active, ov5647_frmintervals_active.denominator);
     ret =  videobuf_streamon(&fh->vb_vidq);
     if(ret == 0){
         dev->vops->start_tvin_service(0,&para);
-	    fh->stream_on        = 1;
-		}
-		OV5647_set_param_wb(fh->dev,ov5647_qctrl[4].default_value);
-		OV5647_set_param_exposure(fh->dev,ov5647_qctrl[5].default_value);
-		OV5647_set_param_effect(fh->dev,ov5647_qctrl[6].default_value);
-		return ret;
+        fh->stream_on        = 1;
+    }
+    OV5647_set_param_wb(fh->dev,ov5647_qctrl[4].default_value);
+    OV5647_set_param_exposure(fh->dev,ov5647_qctrl[5].default_value);
+    OV5647_set_param_effect(fh->dev,ov5647_qctrl[6].default_value);
+    return ret;
 }
 
 static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
@@ -2894,6 +2909,7 @@ static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
 }
 
 char *res_size[]={
+	"cif",
 	"480p",
 	"720p",
 	"960p",
@@ -2939,19 +2955,8 @@ static ssize_t manual_format_store(struct class *cls,struct class_attribute *att
 	}
 	res_param = &prev_resolution_array[t_index];	
 	dest_hactive = res_param->active_frmsize.width;
-	dest_vactive = res_param->active_frmsize.height;
-	#if 0
-	res_param = &prev_resolution_array[i_index];		
-	
-	vidioc_streamoff(debug_file,debug_fh,1);
-	set_resolution_param(debug_dev,res_param);
-	res_param = &prev_resolution_array[t_index];	
-	ov5647_h_active = res_param->active_frmsize.width;
-	ov5647_v_active = res_param->active_frmsize.height;
-	printk("h:%d,v:%d\n",ov5647_h_active,ov5647_v_active);
-	vidioc_streamon(debug_file,debug_fh,1);
-	#endif
-	return len;
+    dest_vactive = res_param->active_frmsize.height;
+    return len;
 }
 
 static ssize_t manual_format_show(struct class *cls,struct class_attribute *attr, char* buf)
@@ -3106,6 +3111,11 @@ static int ov5647_open(struct file *file)
     struct ov5647_device *dev = video_drvdata(file);
     struct ov5647_fh *fh = NULL;
     int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
     switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -3179,7 +3189,6 @@ static int ov5647_open(struct file *file)
     dev->pindex.scenes_index = 0;
     dev->pindex.wb_index = 0;
     dev->pindex.capture_index = 0;
-    current_fr = 0;
     /**creat class file**/		
     cam_class = class_create(THIS_MODULE,"camera"); 
     if(IS_ERR(cam_class)){
@@ -3191,6 +3200,7 @@ static int ov5647_open(struct file *file)
     retval = class_create_file(cam_class,&class_attr_dg_debug);
     retval = class_create_file(cam_class,&class_attr_vcm_debug);
     retval = class_create_file(cam_class,&class_attr_resolution_debug);
+    retval = class_create_file(cam_class,&class_attr_light_source_debug);
     printk("open successfully\n");
     dev->vops = get_vdin_v4l2_ops();
 
@@ -3299,8 +3309,12 @@ static int ov5647_close(struct file *file)
     class_remove_file(cam_class,&class_attr_dg_debug);
     class_remove_file(cam_class,&class_attr_vcm_debug);
     class_remove_file(cam_class,&class_attr_resolution_debug);
+    class_remove_file(cam_class,&class_attr_light_source_debug);
     class_destroy(cam_class);
     printk("close success\n");
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
     return 0;
 }
 
@@ -3400,7 +3414,7 @@ static int ov5647_probe(struct i2c_client *client,
 	sd = &t->sd;
 	v4l2_i2c_subdev_init(sd, client, &ov5647_ops);
 
-	plat_dat = (aml_plat_cam_data_t*)client->dev.platform_data;
+	plat_dat = (aml_cam_info_t*)client->dev.platform_data;
 
 	/* Now create a video4linux device */
 	mutex_init(&t->mutex);
@@ -3455,10 +3469,14 @@ static const struct i2c_device_id ov5647_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov5647_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "ov5647",
+static struct i2c_driver ov5647_i2c_driver = {
+	.driver = {
+		.name = "ov5647",
+	},
 	.probe = ov5647_probe,
 	.remove = ov5647_remove,
 	.id_table = ov5647_id,
 };
 
+module_i2c_driver(ov5647_i2c_driver);
+
diff --git a/drivers/amlogic/camera/ov7675.c b/drivers/amlogic/camera/ov7675.c
index 8a74fecf28d0..6a79302818cc 100755
--- a/drivers/amlogic/camera/ov7675.c
+++ b/drivers/amlogic/camera/ov7675.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,13 +36,10 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 #include <mach/gpio.h>
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 
@@ -49,11 +47,6 @@
 #include <mach/mod_gate.h>
 #endif
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend ov7675_early_suspend;
-#endif
-
 #define OV7675_CAMERA_MODULE_NAME "ov7675"
 
 /* Wake up at about 30 fps */
@@ -339,10 +332,10 @@ struct ov7675_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct ov7675_fh *to_fh(struct ov7675_device *dev)
+/*static inline struct ov7675_fh *to_fh(struct ov7675_device *dev)
 {
 	return container_of(dev, struct ov7675_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete ov7675_prev_resolution[2]=
 {
@@ -557,10 +550,11 @@ static int set_flip(struct ov7675_device *dev)
 	temp |= dev->cam_info.v_flip << 4;
 	buf[0] = 0x1e;
 	buf[1] = temp;
-       if((i2c_put_byte_add8(client,buf, 2)) < 0) {
-          printk("fail in setting sensor orientation\n");
-          return;
-       }
+	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
+		printk("fail in setting sensor orientation\n");
+		return -1;
+	}
+	return 0;
 }
 
 //load GT2005 parameters
@@ -678,7 +672,7 @@ void set_OV7675_param_wb(struct ov7675_device *dev,enum  camera_wb_flip_e para)
 	//temp_reg=ov7675_read_byte(0x22);
 	buf[0]=0x13;
 	buf[1]=0;
-	temp_reg=i2c_get_byte_add8(client,buf);
+	temp_reg=i2c_get_byte_add8(client, buf[0]);
 	temp_reg=0xe7;
 	printk(" camera set_OV7675_param_wb=%d. \n ",temp_reg);
 	switch (para)
@@ -852,11 +846,11 @@ void OV7675_night_mode(struct ov7675_device *dev,enum  camera_night_mode_flip_e
 *
 *************************************************************************/
 
-void OV7675_set_param_banding(struct ov7675_device *dev,enum  camera_night_mode_flip_e banding)
+void OV7675_set_param_banding(struct ov7675_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
-	int temp;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
+	//int temp;
 	switch(banding)
 		{
 		case CAM_BANDING_60HZ:
@@ -877,6 +871,8 @@ void OV7675_set_param_banding(struct ov7675_device *dev,enum  camera_night_mode_
 			i2c_put_byte_add8(client,0xab,0x05);
 			*/
 			break;
+		default:
+			break;
 
 		}
 
@@ -1068,7 +1064,7 @@ unsigned char v4l_2_ov7675(int val)
 static int ov7675_setting(struct ov7675_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
+	//unsigned char cur_val;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -1463,7 +1459,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct ov7675_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(ov7675_frmivalenum))
@@ -1578,8 +1573,6 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct ov7675_fh *fh = priv;
     struct ov7675_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -1656,7 +1649,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
@@ -1696,7 +1689,11 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	}
 	if (fmt == NULL)
 		return -EINVAL;
-	if (fmt->fourcc == V4L2_PIX_FMT_NV21){
+	if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+		||(fmt->fourcc == V4L2_PIX_FMT_NV12)
+		||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
+		||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
+		){
 		if (fsize->index >= ARRAY_SIZE(ov7675_prev_resolution))
 			return -EINVAL;
 		frmsize = &ov7675_prev_resolution[fsize->index];
@@ -1819,6 +1816,12 @@ static int ov7675_open(struct file *file)
 	struct ov7675_device *dev = video_drvdata(file);
 	struct ov7675_fh *fh = NULL;
 	int retval = 0;
+
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	ov7675_have_opened=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -1949,6 +1952,9 @@ static int ov7675_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2102,10 +2108,14 @@ static const struct i2c_device_id ov7675_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov7675_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "ov7675",
+static struct i2c_driver ov7675_i2c_driver = {
+	.driver = {
+		.name = "ov7675",
+	},
 	.probe = ov7675_probe,
 	.remove = ov7675_remove,
 	.id_table = ov7675_id,
 };
 
+module_i2c_driver(ov7675_i2c_driver);
+
diff --git a/drivers/amlogic/camera/sp0838.c b/drivers/amlogic/camera/sp0838.c
index 0848c902704b..a31ab2aabcbc 100755
--- a/drivers/amlogic/camera/sp0838.c
+++ b/drivers/amlogic/camera/sp0838.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -36,13 +37,10 @@
 #include <mach/gpio.h>
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 
 #include <mach/am_regs.h>
 //#include <mach/am_eth_pinmux.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 
@@ -50,11 +48,6 @@
 #include <mach/mod_gate.h>
 #endif
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend sp0838_early_suspend;
-#endif
-
 #define SP0838_CAMERA_MODULE_NAME "sp0838"
 
 /* Wake up at about 30 fps */
@@ -442,10 +435,10 @@ struct sp0838_fh {
 	int  stream_on;
 };
 
-static inline struct sp0838_fh *to_fh(struct sp0838_device *dev)
+/*static inline struct sp0838_fh *to_fh(struct sp0838_device *dev)
 {
 	return container_of(dev, struct sp0838_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete sp0838_prev_resolution[3]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -782,8 +775,9 @@ static int set_flip(struct sp0838_device *dev)
 	buf[1] = temp;
 	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
             printk("fail in setting sensor orientation\n");
-            return;
+            return -1;
         }
+        return 0;
 }	 	
 static void sp0838_set_resolution(struct sp0838_device *dev,int height,int width)
 {
@@ -1095,7 +1089,7 @@ return; // superpix fcs test
 
 void SP0838write_more_registers(struct sp0838_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
 	SP0838GammaSelect(dev,0);// SP0838_RGB_Gamma_m3);	
 }
 
@@ -1405,19 +1399,21 @@ void SP0838_night_mode(struct sp0838_device *dev,enum  camera_night_mode_flip_e
 *
 *************************************************************************/
 
-void SP0838_set_param_banding(struct sp0838_device *dev,enum  camera_night_mode_flip_e banding)
+void SP0838_set_param_banding(struct sp0838_device *dev, enum  camera_banding_flip_e banding)
 {     
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     switch(banding) {
         case CAM_BANDING_60HZ:
-			SP0838Sensor.BandingFreq = CAM_BANDING_50HZ;
-			sp0838_banding_60HZ = 1;
+		SP0838Sensor.BandingFreq = CAM_BANDING_50HZ;
+		sp0838_banding_60HZ = 1;
             break;
         case CAM_BANDING_50HZ:
-			SP0838Sensor.BandingFreq = CAM_BANDING_60HZ;
-			sp0838_banding_60HZ = 0;
+		SP0838Sensor.BandingFreq = CAM_BANDING_60HZ;
+		sp0838_banding_60HZ = 0;
             break;
-    }
+        default:
+            break;
+	}
 	
 	SP0838_BANDING_NIGHT_MODE(client);
 }
@@ -1444,7 +1440,7 @@ void set_SP0838_param_exposure(struct sp0838_device *dev,enum camera_exposure_e
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
 
-	unsigned char value_luma, value_Y;
+	//unsigned char value_luma, value_Y;
 
 //	return;
 	/*switch night or normal mode*/
@@ -1571,13 +1567,14 @@ unsigned char v4l_2_sp0838(int val)
 	if(ret<4) return ret*0x20+0x80;
 	else if(ret<8) return ret*0x20+0x20;
 	else return 0;*/
+	return 0;
 }
 
 static int sp0838_setting(struct sp0838_device *dev,int PROP_ID,int value ) 
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_DO_WHITE_BALANCE:
 		if(sp0838_qctrl[0].default_value!=value){
@@ -1643,14 +1640,14 @@ static int sp0838_setting(struct sp0838_device *dev,int PROP_ID,int value )
 	
 }
 
-static void power_down_sp0838(struct sp0838_device *dev)
+/*static void power_down_sp0838(struct sp0838_device *dev)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	unsigned char buf[4];
 	return;
 	msleep(5);
 	return;
-}
+}*/
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -1961,7 +1958,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct sp0838_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(sp0838_frmivalenum))
@@ -2081,9 +2077,7 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct sp0838_fh *fh = priv;
     struct sp0838_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
-
+    
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
         return -EINVAL;
@@ -2166,7 +2160,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_UYVY422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
             vops->start_tvin_service(0,&para);
@@ -2332,6 +2326,11 @@ static int sp0838_open(struct file *file)
 	struct sp0838_device *dev = video_drvdata(file);
 	struct sp0838_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	sp0838_have_open=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2464,6 +2463,9 @@ static int sp0838_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2548,41 +2550,16 @@ static const struct v4l2_subdev_ops sp0838_ops = {
 };
 static struct i2c_client *this_client;
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void aml_sp0838_early_suspend(struct early_suspend *h)
-{
-	printk("enter -----> %s \n",__FUNCTION__);
-	if(h && h->param && sp0838_have_open) {
-		aml_plat_cam_data_t* plat_dat= (aml_plat_cam_data_t*)h->param;
-		if (plat_dat && plat_dat->early_suspend) {
-			plat_dat->early_suspend();
-		}
-	}
-}
-
-static void aml_sp0838_late_resume(struct early_suspend *h)
-{
-	aml_plat_cam_data_t* plat_dat;
-	if(sp0838_have_open){
-	    printk("enter -----> %s \n",__FUNCTION__);
-	    if(h && h->param) {
-		    plat_dat= (aml_plat_cam_data_t*)h->param;
-		    if (plat_dat && plat_dat->late_resume) {
-			    plat_dat->late_resume();
-		    }
-	    }
-	}
-}
-#endif
-
 static int sp0838_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
 	aml_cam_info_t* plat_dat;
-	vops = get_vdin_v4l2_ops();
 	int err;
 	struct sp0838_device *t;
 	struct v4l2_subdev *sd;
+	
+	vops = get_vdin_v4l2_ops();
+	
 	v4l_info(client, "chip found @ 0x%x (%s)\n",
 			client->addr << 1, client->adapter->name);
 	t = kzalloc(sizeof(*t), GFP_KERNEL);
@@ -2641,14 +2618,6 @@ static int sp0838_probe(struct i2c_client *client,
 	}
 	g_dev = t;
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-        sp0838_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
-	sp0838_early_suspend.suspend = aml_sp0838_early_suspend;
-	sp0838_early_suspend.resume = aml_sp0838_late_resume;
-	sp0838_early_suspend.param = plat_dat;
-	register_early_suspend(&sp0838_early_suspend);
-#endif
-
 	return 0;
 }
 
@@ -2663,37 +2632,6 @@ static int sp0838_remove(struct i2c_client *client)
 	kfree(t);
 	return 0;
 }
-static int sp0838_suspend(struct i2c_client *client, pm_message_t state)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct sp0838_device *t = to_dev(sd);	
-	struct sp0838_fh  *fh = to_fh(t);
-	if (sp0838_have_open) {
-	    if(fh->stream_on == 1){
-		    vops->stop_tvin_service(0);
-	    }
-	    power_down_sp0838(t);
-	}
-	return 0;
-}
-
-static int sp0838_resume(struct i2c_client *client)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct sp0838_device *t = to_dev(sd);
-        struct sp0838_fh  *fh = to_fh(t);
-        vdin_parm_t para;
-        if (sp0838_have_open) {
-            para.port  = TVIN_PORT_CAMERA;
-            para.fmt = TVIN_SIG_FMT_MAX;
-            SP0838_init_regs(t);
-	if(fh->stream_on == 1){
-            vops->start_tvin_service(0,&para);
-	}
-    }
-    return 0;
-}
-
 
 static const struct i2c_device_id sp0838_id[] = {
 	{ "sp0838", 0 },
@@ -2701,12 +2639,14 @@ static const struct i2c_device_id sp0838_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, sp0838_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "sp0838",
+static struct i2c_driver sp0838_i2c_driver = {
+	.driver = {
+		.name = "sp0838",
+	},
 	.probe = sp0838_probe,
 	.remove = sp0838_remove,
-	.suspend = sp0838_suspend,
-	.resume = sp0838_resume,		
 	.id_table = sp0838_id,
 };
 
+module_i2c_driver(sp0838_i2c_driver);
+
diff --git a/drivers/amlogic/camera/sp2518.c b/drivers/amlogic/camera/sp2518.c
index b020ac0defec..179a8d271bbb 100755
--- a/drivers/amlogic/camera/sp2518.c
+++ b/drivers/amlogic/camera/sp2518.c
@@ -7,6 +7,7 @@
  * as published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version
  */
+#include <linux/sizes.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -35,22 +36,15 @@
 
 #include <linux/i2c.h>
 #include <media/v4l2-chip-ident.h>
-#include <media/v4l2-i2c-drv.h>
-#include <media/amlogic/aml_camera.h>
 #include <linux/amlogic/camera/aml_cam_info.h>
 #include <mach/gpio.h>
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
-#include <linux/tvin/tvin_v4l2.h>
 #include "common/plat_ctrl.h"
 #include "common/vmapi.h"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
 #endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend sp2518_early_suspend;
-#endif
 
 #define SP2518_CAMERA_MODULE_NAME "sp2518"
 
@@ -441,10 +435,10 @@ struct sp2518_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct sp2518_fh *to_fh(struct sp2518_device *dev)
+/*static inline struct sp2518_fh *to_fh(struct sp2518_device *dev)
 {
 	return container_of(dev, struct sp2518_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete sp2518_prev_resolution[2]= //should include 352x288 and 640x480, those two size are used for recording
 {
@@ -966,7 +960,7 @@ void SP2518_set_param_wb(struct sp2518_device *dev,enum  camera_wb_flip_e para)/
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
-    switch (para)
+	switch (para)
 	{
 
 		case CAM_WB_AUTO://auto
@@ -1009,7 +1003,7 @@ void SP2518_set_param_wb(struct sp2518_device *dev,enum  camera_wb_flip_e para)/
 			i2c_put_byte_add8_new(client,0x29,0xcc);
 			break;
 
-      	case CAM_WB_FLUORESCENT:
+		case CAM_WB_FLUORESCENT:
 			i2c_put_byte_add8_new(client,0xfd,0x00);
 			i2c_put_byte_add8_new(client,0x32,0x05);
 			i2c_put_byte_add8_new(client,0xfd,0x01);
@@ -1020,6 +1014,8 @@ void SP2518_set_param_wb(struct sp2518_device *dev,enum  camera_wb_flip_e para)/
 		case CAM_WB_MANUAL:
 		    	// TODO
 			break;
+		default:
+			break;
 	}
 
 
@@ -1512,70 +1508,24 @@ void SP2518_set_night_mode(struct sp2518_device *dev,enum  camera_night_mode_fli
 	i2c_put_byte_add8_new(client,0xfd,0x00);	//enable AE,add by sp_yjp,20120905
 	i2c_put_byte_add8_new(client,0x32,0x0d);
 }    /* SP2518_NightMode */
-void SP2518_set_param_banding(struct sp2518_device *dev,enum  camera_night_mode_flip_e banding)
+void SP2518_set_param_banding(struct sp2518_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char buf[4];
-	
-	  switch(banding)
-	
-	 {
-	
-		 case CAM_BANDING_50HZ: 		
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char buf[4];
 	
+	switch(banding) {
+	case CAM_BANDING_50HZ: 		
 		Antiflicker = DCAMERA_FLICKER_50HZ;
-	
 		printk( " set_SP2518_anti_flicker  50hz \r\n" );
-	
 		break;
-	
-			 
-	
-		 case CAM_BANDING_60HZ:
-	
+	case CAM_BANDING_60HZ:
 		Antiflicker = DCAMERA_FLICKER_60HZ;
-	
 		printk( " set_SP2518_anti_flicker  60hz \r\n" );
-	
 		break;
-	
-			 
-	
-		 //default:
-	
-			 break;
-	
-	 }
-	
-	  
-	
-	// return 0;
-
-
-
-
-#if 0
-	switch(banding)
-		{
-		case CAM_BANDING_50HZ:
-
-
-
-
-			
-			//i2c_put_byte_add8_new(client,);//zyy test
-			break;
-		case CAM_BANDING_60HZ:
-
-
-
-
-			
-			//i2c_put_byte_add8_new(client,);
-			break;
+	default:
+		break;
+	}
 
-		}
-#endif
 }
 
 static int set_flip(struct sp2518_device *dev)
@@ -1591,14 +1541,16 @@ static int set_flip(struct sp2518_device *dev)
 	buf[1] = temp;
 	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
             printk("fail in setting sensor orientation\n");
-            return;
-       }
+            return -1;
+	}
+       
+	return 0;
 }	
 
 void SP2518_set_resolution(struct sp2518_device *dev,int height,int width)
 {
 
-	int ret;
+	//int ret;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	printk("---------- %s : height %d  width  %d \n " , __FUNCTION__,height,width);
 	if((width<1600)&&(height<1198)){
@@ -1709,7 +1661,7 @@ static int sp2518_setting(struct sp2518_device *dev,int PROP_ID,int value )
 {
 #if 1 //zyy test
 	int ret=0;
-	unsigned char cur_val;
+	//unsigned char cur_val;
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -1822,9 +1774,7 @@ static int sp2518_setting(struct sp2518_device *dev,int PROP_ID,int value )
 
 static void power_down_sp2518(struct sp2518_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	//i2c_put_byte_add8_new(client,0x0104, 0x00); //zyy test
-	//i2c_put_byte_add8_new(client,0x0100, 0x00);
+
 }
 
 /* ------------------------------------------------------------------
@@ -2137,7 +2087,6 @@ static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
-    struct sp2518_fmt *fmt;
     unsigned int k;
 
     if(fival->index > ARRAY_SIZE(sp2518_frmivalenum))
@@ -2261,8 +2210,7 @@ static int vidioc_g_parm(struct file *file, void *priv,
     struct sp2518_fh *fh = priv;
     struct sp2518_device *dev = fh->dev;
     struct v4l2_captureparm *cp = &parms->parm.capture;
-    int ret;
-    int i;
+    //int ret;
 
     dprintk(dev,3,"vidioc_g_parm\n");
     if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -2340,7 +2288,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	para.vs_bp = 2;
 	para.cfmt = TVIN_YUV422;
 	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.reserved = 2; //skip_num
+	para.skip_count =  2; //skip_num
 
 	ret =  videobuf_streamon(&fh->vb_vidq);
 	if(ret == 0){
@@ -2508,6 +2456,11 @@ static int sp2518_open(struct file *file)
 	struct sp2518_device *dev = video_drvdata(file);
 	struct sp2518_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2639,6 +2592,9 @@ static int sp2518_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
@@ -2725,7 +2681,7 @@ static const struct v4l2_subdev_ops sp2518_ops = {
 
 static ssize_t sp2518_show(struct device *dev, struct device_attribute *attr, char *_buf)
 {
-	return sprintf("0x%02x=0x%02x\n", cur_reg, cur_val);
+	return sprintf(_buf, "0x%02x=0x%02x\n", cur_reg, cur_val);
 }
 
 static u32 strtol(const char *nptr, int base)
@@ -2925,7 +2881,7 @@ static int sp2518_probe(struct i2c_client *client,
 	
 #ifdef EMDOOR_DEBUG_SP2518
 	sp2518_client = client;
-	sysfs_create_group(&client->dev.kobj, &sp2518_group);
+	err = sysfs_create_group(&client->dev.kobj, &sp2518_group);
 #endif	
 
     return 0;
@@ -2950,10 +2906,14 @@ static const struct i2c_device_id sp2518_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, sp2518_id);
 
-static struct v4l2_i2c_driver_data v4l2_i2c_data = {
-	.name = "sp2518",
+static struct i2c_driver sp2518_i2c_driver = {
+	.driver = {
+		.name = "sp2518",
+	},
 	.probe = sp2518_probe,
 	.remove = sp2518_remove,
 	.id_table = sp2518_id,
 };
 
+module_i2c_driver(sp2518_i2c_driver);
+
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
old mode 100644
new mode 100755
index 48e31ed69dbf..874776be92bb
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -689,6 +689,66 @@ out_err_silent:
 }
 EXPORT_SYMBOL_GPL(i2c_new_device);
 
+struct i2c_client *
+i2c_new_existing_device(struct i2c_adapter *adap, 
+			struct i2c_board_info const *info)
+{
+	struct i2c_client	*client;
+	int			status;
+	int			nr = 0;
+
+	client = kzalloc(sizeof *client, GFP_KERNEL);
+	if (!client)
+		return NULL;
+
+	client->adapter = adap;
+
+	client->dev.platform_data = info->platform_data;
+
+	if (info->archdata)
+		client->dev.archdata = *info->archdata;
+
+	client->flags = info->flags;
+	client->addr = info->addr;
+	client->irq = info->irq;
+
+	strlcpy(client->name, info->type, sizeof(client->name));
+
+	client->dev.parent = &client->adapter->dev;
+	client->dev.bus = &i2c_bus_type;
+	client->dev.type = &i2c_client_type;
+	client->dev.of_node = info->of_node;
+
+	do {
+		struct device *dev;
+		char dev_name[32] = {0};
+		sprintf(dev_name, "%d-%04x-%d", i2c_adapter_id(adap),
+		     			client->addr, nr);
+		dev = bus_find_device_by_name(&i2c_bus_type, NULL, dev_name);
+		if (!dev){	
+			//printk("try to register dev %s\n", dev_name);
+			dev_set_name(&client->dev, "%d-%04x-%d", i2c_adapter_id(adap),
+		     			client->addr, nr);
+			status = device_register(&client->dev);
+		} else {
+			//printk("file %s have existed\n", dev_name);
+			status = -1;
+		}
+		nr++;
+	} while(status);
+
+	dev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",
+		client->name, dev_name(&client->dev));
+
+	return client;
+
+out_err:
+	dev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "
+		"(%d)\n", client->name, client->addr, status);
+out_err_silent:
+	kfree(client);
+	return NULL;
+}
 
 /**
  * i2c_unregister_device - reverse effect of i2c_new_device()
diff --git a/include/linux/amlogic/camera/aml_cam_info.h b/include/linux/amlogic/camera/aml_cam_info.h
index 4a84e69d4601..7cd0af731ca9 100755
--- a/include/linux/amlogic/camera/aml_cam_info.h
+++ b/include/linux/amlogic/camera/aml_cam_info.h
@@ -1,11 +1,11 @@
 #ifndef __AML_CAM_DEV__
 #define __AML_CAM_DEV__
 #include <linux/list.h>
-//#include <media/amlogic/aml_camera.h>
 #include <linux/i2c.h>
 #include <linux/i2c-aml.h>
 #include <mach/gpio.h>
-#include <linux/tvin/tvin_v4l2.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include <linux/amlogic/camera/flashlight.h>
 
 //#define AML_I2C_BUS_A 0
 //#define AML_I2C_BUS_B 1
@@ -83,6 +83,21 @@ typedef struct {
 	char* config;
 }aml_cam_info_t;
 
+typedef struct aml_camera_i2c_fig_s{
+    unsigned short   addr;
+    unsigned char    val;
+} aml_camera_i2c_fig_t;
+
+typedef struct aml_camera_i2c_fig0_s{
+    unsigned short   addr;
+    unsigned short    val;
+} aml_camera_i2c_fig0_t;
+
+typedef struct aml_camera_i2c_fig1_s{
+    unsigned char   addr;
+    unsigned char    val;
+} aml_camera_i2c_fig1_t;
+
 extern void aml_cam_init(aml_cam_info_t* cam_dev);
 extern void aml_cam_uninit(aml_cam_info_t* cam_dev);
 extern void aml_cam_flash(aml_cam_info_t* cam_dev, int is_on);
diff --git a/include/linux/amlogic/camera/flashlight.h b/include/linux/amlogic/camera/flashlight.h
new file mode 100755
index 000000000000..7cb6c72db89a
--- /dev/null
+++ b/include/linux/amlogic/camera/flashlight.h
@@ -0,0 +1,28 @@
+/*******************************************************************
+ *
+ *  Copyright C 2011 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *
+ *  Author: Amlogic Software
+ *  Created: 2011/8/26   19:46
+ *
+ *******************************************************************/
+#ifndef _VIDEO_AMLOGIC_FLASHLIGHT_INCLUDE_
+#define _VIDEO_AMLOGIC_FLASHLIGHT_INCLUDE_
+typedef struct {
+	void (*flashlight_on)(void);
+	void (*flashlight_off)(void);
+}aml_plat_flashlight_data_t;
+
+typedef enum {
+	FLASHLIGHT_AUTO = 0,
+	FLASHLIGHT_ON,
+	FLASHLIGHT_OFF,
+	FLASHLIGHT_TORCH,
+	FLASHLIGHT_RED_EYE,
+}aml_plat_flashlight_status_t;
+
+#endif
+
+
diff --git a/include/linux/amlogic/tvin/tvin_v4l2.h b/include/linux/amlogic/tvin/tvin_v4l2.h
index 90d0b577ce7f..c863cbdd1c6a 100755
--- a/include/linux/amlogic/tvin/tvin_v4l2.h
+++ b/include/linux/amlogic/tvin/tvin_v4l2.h
@@ -298,6 +298,10 @@ typedef struct xml_algorithm_ae_s {
         unsigned int  ae_exp[3];          //0: false, 1: true
         unsigned int  ae_ag[3];           //0: false, 1: true
 		unsigned int  ae_skip[3];         //0: false, 1: true
+        unsigned int  ratio_winl;      //0 ~ 1024
+        unsigned int  ratio_winr;      //0 ~ 1024
+        unsigned int  ratio_wint;      //0 ~ 1024
+        unsigned int  ratio_winb;      //0 ~ 1024
         unsigned int  alert_mode;  //0: disable, 1: enable
         unsigned int  tune_mode;  //0: average mode, 1: blind up mode
         unsigned int  ratio_r;  // 0 ~ 255
@@ -356,6 +360,10 @@ typedef struct xml_algorithm_ae_s {
 #define AWB_PARM_NUM			53
 typedef struct xml_algorithm_awb_s {
         unsigned int           awb_algorithm;       //0:basic;    1:enhanced
+        unsigned int           ratio_winl;            //0 ~ 1024
+        unsigned int           ratio_winr;            //0 ~ 1024
+        unsigned int           ratio_wint;            //0 ~ 1024
+        unsigned int           ratio_winb;            //0 ~ 1024
         unsigned int  	       ratio_rgb;             // 0 ~ 255 
         unsigned int           ratio_yh;              // 0 ~ 255 
         unsigned int 	       ratio_ym;              // 0 ~ 255 
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
old mode 100644
new mode 100755
index c259b36bf1e9..f14b5f63559f
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -35,6 +35,46 @@ enum {
 	V4L2_IDENT_AMBIGUOUS = 1,       /* Match too general, multiple chips matched */
 	V4L2_IDENT_UNKNOWN   = 2,       /* Chip found, but cannot identify */
 
+
+	/* GT2005, 0x5138= 20792  */
+	V4L2_IDENT_GT2005 =  20,
+
+	/* GC0308, 0x5138= 20792  */
+	V4L2_IDENT_GC0308 =  21,
+	
+	/* SP0838,   */
+	V4L2_IDENT_SP0838 =  23,
+
+    /* HI253,   */
+	V4L2_IDENT_HI253 =  26,
+
+    /* HI704,   */
+	V4L2_IDENT_HI704 =  27,
+	
+	/* HI2056,   */
+	V4L2_IDENT_HI2056 =  28,
+
+	/* GC0307,   */
+	V4L2_IDENT_GC0307 =  29,
+	
+	/* GC0329,   */
+	V4L2_IDENT_GC0329 =  31,
+	
+	/* NT99250,   */
+	V4L2_IDENT_NT99250 = 32,
+
+	/* NT99252,  */
+	V4L2_IDENT_NT99252 = 33,
+	
+	/* NT99340,  */
+	V4L2_IDENT_NT99340 = 34,
+	
+	/* NT99340,  */
+	V4L2_IDENT_SP2518 = 35,
+
+	/* GC0328  */
+        V4L2_IDENT_GC0328 = 38,
+
 	/* module tvaudio: reserved range 50-99 */
 	V4L2_IDENT_TVAUDIO = 50,	/* A tvaudio chip, unknown which it is exactly */
 
@@ -77,6 +117,11 @@ enum {
 	V4L2_IDENT_OV2640 = 259,
 	V4L2_IDENT_OV9740 = 260,
 	V4L2_IDENT_OV5642 = 261,
+	V4L2_IDENT_OV5640 = 262,
+	V4L2_IDENT_OV7675 = 263,
+	V4L2_IDENT_OV2655 = 264,
+	V4L2_IDENT_OV3660 = 265,
+	V4L2_IDENT_OV5647 = 266,
 
 	/* module saa7146: reserved range 300-309 */
 	V4L2_IDENT_SAA7146 = 300,
-- 
2.19.0

