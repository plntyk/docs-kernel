From d65f915c70eebf4523dd330edd849e7af3d338b9 Mon Sep 17 00:00:00 2001
From: "jian.xu" <jian.xu@amlogic.com>
Date: Fri, 1 Nov 2013 16:10:16 +0800
Subject: [PATCH 1611/5965] merge audio code to 3.10

---
 arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd |  17 +-
 arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd |  17 +-
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd |  16 +-
 arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd |  16 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd     |  17 +-
 sound/soc/aml/Kconfig                        |   4 +
 sound/soc/aml/Makefile                       |   6 +
 sound/soc/aml/aml_audio_hw.c                 | 118 ++--
 sound/soc/aml/aml_audio_hw.h                 |  81 +--
 sound/soc/aml/aml_dai.c                      | 169 ++++-
 sound/soc/aml/aml_m8.c                       |  13 +-
 sound/soc/aml/aml_pcm.c                      | 694 +++----------------
 sound/soc/aml/aml_pcm.h                      |   2 +
 sound/soc/aml/aml_spdif_codec.c              | 101 +++
 sound/soc/aml/aml_spdif_dai.c                | 427 ++++++++++++
 sound/soc/aml/aml_spdif_dai.h                |  16 +
 16 files changed, 975 insertions(+), 739 deletions(-)
 create mode 100755 sound/soc/aml/aml_spdif_codec.c
 create mode 100755 sound/soc/aml/aml_spdif_dai.c
 create mode 100755 sound/soc/aml/aml_spdif_dai.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
index 2a23757ccb7f..787113f51075 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
@@ -1206,8 +1206,19 @@ sdio{
 //$$ DEVICE="audio_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
-        compatible = "amlogic,aml-dai";
-        dev_name = "aml-dai.0";
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
+        status = "okay";
+    };
+
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
         status = "okay";
     };
 
@@ -1229,7 +1240,7 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8";
+        aml,codec_dai = "AML-M8","dit-hifi";
         aml,audio-routing =
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
index 1bcaa92ca617..03d4eac1c55a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
@@ -1211,8 +1211,19 @@ sdio{
 //$$ DEVICE="audio_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
-        compatible = "amlogic,aml-dai";
-        dev_name = "aml-dai.0";
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
+        status = "okay";
+    };
+
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
         status = "okay";
     };
 
@@ -1234,7 +1245,7 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8";
+        aml,codec_dai = "AML-M8","dit-hifi";
         aml,audio-routing =
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index efc0c550a1f0..3308f8fedc2c 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -926,11 +926,21 @@ interrupts = <0     137     0x04
 //$$ DEVICE="audio_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
-        compatible = "amlogic,aml-dai";
-        dev_name = "aml-dai.0";
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
         status = "okay";
     };
 
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
+        status = "okay";
+    };
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
@@ -951,7 +961,7 @@ interrupts = <0     137     0x04
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8";
+        aml,codec_dai = "AML-M8","dit-hifi";
         aml,audio-routing =
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
index 658bca07fa74..cf9931397a42 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
@@ -927,11 +927,21 @@ sdio{
 //$$ DEVICE="audio_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
-        compatible = "amlogic,aml-dai";
-        dev_name = "aml-dai.0";
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
         status = "okay";
     };
 
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
+        status = "okay";
+    };
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
@@ -952,7 +962,7 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8";
+        aml,codec_dai = "AML-M8","dit-hifi";
         aml,audio-routing =
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index 8e1b17844e45..334191912d6e 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -913,8 +913,19 @@ void root_func(){
 //$$ DEVICE="audio_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
-        compatible = "amlogic,aml-dai";
-        dev_name = "aml-dai.0";
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
+        status = "okay";
+    };
+
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
         status = "okay";
     };
 
@@ -938,7 +949,7 @@ void root_func(){
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8";
+        aml,codec_dai = "AML-M8","dit-hifi";
         aml,audio-routing =
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
diff --git a/sound/soc/aml/Kconfig b/sound/soc/aml/Kconfig
index 4d2658a6de1a..2322623b408e 100755
--- a/sound/soc/aml/Kconfig
+++ b/sound/soc/aml/Kconfig
@@ -109,6 +109,10 @@ config TAS5707_2_SUBWOOFER_CHANNEL
 endchoice
 endif
 
+#config  SND_AML_SPDIF
+#	tristate "Amlogic S/PDIF codec support"
+#	depends on SND_AML_SOC
+#	select SND_SOC_AML_SPDIF_CODEC if SND_AML_SPDIF
 config SND_AML_M8
 	tristate "AML-SND-M8 Board"
 	depends on SND_AML_SOC && SWITCH
diff --git a/sound/soc/aml/Makefile b/sound/soc/aml/Makefile
index 2aeeb5a62d52..11319961183d 100755
--- a/sound/soc/aml/Makefile
+++ b/sound/soc/aml/Makefile
@@ -6,6 +6,7 @@ snd-soc-aml-hw-objs  := aml_audio_hw.o
 snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
 snd-soc-aml-platform-objs := aml_platform.o
 
+snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-pcm.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-dai.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw.o
@@ -14,6 +15,7 @@ obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform-pcm2bt.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw-pcm2bt.o
 
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-spdif-dai.o
 #AML M1 Machine support
 
 snd-soc-aml-m1-objs := aml_m1.o
@@ -75,6 +77,10 @@ snd-soc-aml-syno9629-codec-objs := aml_syno9629_codec.o
 obj-$(CONFIG_SND_AML_M6TV_AUDIO_CODEC) += snd-soc-aml-m6tv-audio.o
 obj-$(CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC) += snd-soc-aml-syno9629-codec.o
 
+#AML spdif codec support
+snd-soc-aml-spdif-codec-objs := aml_spdif_codec.o
+#obj-$(CONFIG_SND_SOC_AML_SPDIF_CODEC) += snd-soc-aml-spdif-codec.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-spdif-codec.o
 #AML M8 Machine support
 snd-soc-aml-m8-objs := aml_m8.o
 obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
diff --git a/sound/soc/aml/aml_audio_hw.c b/sound/soc/aml/aml_audio_hw.c
index 90df8bc52a8d..0ebc825f88c8 100755
--- a/sound/soc/aml/aml_audio_hw.c
+++ b/sound/soc/aml/aml_audio_hw.c
@@ -304,40 +304,36 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,u32 i2s_mode)
 static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 {
 	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffffff);
-	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
-	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
-	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
-	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
-    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
-								|(0<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	WRITE_MPEG_REG(AUDIN_FIFO1_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO1_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1<<AUDIN_FIFO1_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO1_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(0<<AUDIN_FIFO1_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
 	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
 									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
-								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
-								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+								|(4<<AUDIN_FIFO1_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO1_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
 		    						|(0<<16)	//to DDR
-                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(1<<AUDIN_FIFO1_UG)    // Urgent request.  DDR SDRAM urgent request enable.
                                                        |(0<<17)    // Overflow Interrupt mask
                                                        |(0<<18)    // Audio in INT
 			                                	//|(1<<19)	//hold 0 enable
-								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
+								|(0<<AUDIN_FIFO1_UG)	// hold0 to aififo
 				  );
-	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,0xc);
+	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1,0xc);
 }
 void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode)
 {
-	if(i2s_mode&SPDIFIN_MODE){ //spdif in ,use fifo1
-		printk("spdifin_fifo1_set_buf \n");			
-		spdifin_fifo1_set_buf(addr,size);
-	}
-	else{
-		printk("i2sin_fifo0_set_buf \n");		
-		i2sin_fifo0_set_buf(addr,size,i2s_mode);
-	}	
-       audio_in_buf_ready = 1;
-
+	printk("i2sin_fifo0_set_buf \n");		
+	i2sin_fifo0_set_buf(addr,size,i2s_mode);
+	audio_in_buf_ready = 1;
 }
 void audio_in_spdif_set_buf(u32 addr, u32 size)
 {
+	printk("spdifin_fifo1_set_buf \n");			
+	spdifin_fifo1_set_buf(addr,size);
+	
 }
 //extern void audio_in_enabled(int flag);
 
@@ -355,23 +351,13 @@ reset_again:
               printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
               goto reset_again;
             }
-		if(audioin_mode == 	SPDIFIN_MODE)
-			WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));
-		else
 			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 1, I2SIN_EN, 1);
 
 	}else{
-		if(audioin_mode == 	SPDIFIN_MODE)	
-			WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));
-		else
 			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 0, I2SIN_EN, 1);
 	}
 }
 
-int if_audio_in_i2s_enable()
-{
-	return READ_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, I2SIN_EN, 1);
-}
 
 void audio_in_spdif_enable(int flag)
 {
@@ -379,7 +365,6 @@ void audio_in_spdif_enable(int flag)
 
 	if(flag){
 reset_again:
-#if 0	
 	     WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1); // reset FIFO 0
             WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
             rd = READ_MPEG_REG(AUDIN_FIFO1_PTR);
@@ -388,12 +373,19 @@ reset_again:
               printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
               goto reset_again;
             }
-#endif			
 		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));		
 	}else{
 		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));				
 	}
 }
+int if_audio_in_i2s_enable()
+{
+	return READ_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, I2SIN_EN, 1);
+}
+int if_audio_in_spdif_enable()
+{
+	return READ_MPEG_REG_BITS(AUDIN_SPDIF_MODE, 31, 1);
+}
 unsigned int audio_in_i2s_rd_ptr(void)
 {
 	unsigned int val;
@@ -401,6 +393,13 @@ unsigned int audio_in_i2s_rd_ptr(void)
 	printk("audio in i2s rd ptr: %x\n", val);
 	return val;
 }
+unsigned int audio_in_spdif_rd_ptr(void)
+{
+	unsigned int val;
+	val = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+	printk("audio in spdif rd ptr: %x\n", val);
+	return val;
+}
 unsigned int audio_in_i2s_wr_ptr(void)
 {
 	unsigned int val;
@@ -409,11 +408,21 @@ unsigned int audio_in_i2s_wr_ptr(void)
 	return (val)&(~0x3F);
 	//return val&(~0x7);
 }
+unsigned int audio_in_spdif_wr_ptr(void)
+{
+	unsigned int val;
+      WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
+	val = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+	return (val)&(~0x3F);
+}
 void audio_in_i2s_set_wrptr(unsigned int val)
 {
 	WRITE_MPEG_REG(AUDIN_FIFO0_RDPTR, val);
 }
-
+void audio_in_spdif_set_wrptr(unsigned int val)
+{
+	WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, val);
+}
 void audio_set_i2s_mode(u32 mode)
 {
     const unsigned short mask[4] = {
@@ -987,7 +996,7 @@ void audio_enable_ouput(int flag)
         READ_MPEG_REG(AIU_I2S_SYNC);
         WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
 
-        if (ENABLE_IEC958) {
+        if (0/*ENABLE_IEC958*/) {
             if(IEC958_MODE == AIU_958_MODE_RAW)
             {
               //audio_hw_958_raw();
@@ -1006,7 +1015,7 @@ void audio_enable_ouput(int flag)
     } else {
         WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
 
-        if (ENABLE_IEC958) {
+        if (0/*ENABLE_IEC958*/) {
             WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
             WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
         }
@@ -1027,7 +1036,12 @@ unsigned int read_i2s_rd_ptr(void)
     val = READ_MPEG_REG(AIU_MEM_I2S_RD_PTR);
     return val;
 }
-
+unsigned int read_iec958_rd_ptr(void)
+{
+    unsigned int val;
+    val = READ_MPEG_REG(AIU_MEM_IEC958_RD_PTR);
+    return val;
+}
 void audio_i2s_unmute(void)
 {
     WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0, 8, 8);
@@ -1160,13 +1174,35 @@ void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set)
 
     WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 1);
 }
+void audio_out_i2s_enable(unsigned flag)
+{
+    if (flag) {
+        WRITE_MPEG_REG(AIU_RST_SOFT, 0x05);
+        READ_MPEG_REG(AIU_I2S_SYNC);
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
+        // Maybe cause POP noise
+        // audio_i2s_unmute();
+    } else {
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
 
+        // Maybe cause POP noise
+        // audio_i2s_mute();
+    }
+    //audio_out_enabled(flag);
+}
 void audio_hw_958_enable(unsigned flag)
 {
-    if (ENABLE_IEC958) {
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 2, 1);
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 1, 1);
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 0, 1);
+    if (ENABLE_IEC958)
+    {
+    		if(flag){
+	              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
+	              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+	              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+    		}
+		else{
+	             WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
+	             WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);			
+		}	
     }
 }
 
diff --git a/sound/soc/aml/aml_audio_hw.h b/sound/soc/aml/aml_audio_hw.h
index 378b36feb745..03f67846c7e0 100755
--- a/sound/soc/aml/aml_audio_hw.h
+++ b/sound/soc/aml/aml_audio_hw.h
@@ -1,73 +1,6 @@
 #ifndef __AML_AUDIO_HW_H__
 #define __AML_AUDIO_HW_H__
 
-#if defined (CONFIG_ARCH_MESON) || defined (CONFIG_ARCH_MESON2) || defined (CONFIG_ARCH_MESON3)
-
-
-/* assumming PLL source is 24M */
-
-#define AUDIO_384FS_PLL_192K        0x507d  /* 36.864M */
-#define AUDIO_384FS_PLL_192K_MUX    12
-#define AUDIO_384FS_CLK_192K        0x5eb
-
-#define AUDIO_384FS_PLL_176K        0x0e7c  /* 33.8688M */
-#define AUDIO_384FS_PLL_176K_MUX    25
-#define AUDIO_384FS_CLK_176K        0x5eb
-
-#define AUDIO_384FS_PLL_96K         0x507d  /* 36.864M */
-#define AUDIO_384FS_PLL_96K_MUX     12
-#define AUDIO_384FS_CLK_96K         0x5ef
-
-#define AUDIO_384FS_PLL_88K         0x0e7c  /* 33.8688M */
-#define AUDIO_384FS_PLL_88K_MUX     25
-#define AUDIO_384FS_CLK_88K         0x5ef
-
-#define AUDIO_384FS_PLL_48K         0x487d  /* 18.432M */
-#define AUDIO_384FS_PLL_48K_MUX     12
-#define AUDIO_384FS_CLK_48K_AC3     0x5ed
-#define AUDIO_384FS_CLK_48K         0x5ef
-
-#define AUDIO_384FS_PLL_44K         0x0aa3  /* 16.9344M */
-#define AUDIO_384FS_PLL_44K_MUX     23
-#define AUDIO_384FS_CLK_44K         0x5ef
-
-#define AUDIO_384FS_PLL_32K         0x1480  /* 12.288M */
-#define AUDIO_384FS_PLL_32K_MUX     24
-#define AUDIO_384FS_CLK_32K         0x5ef
-
-#define AUDIO_384FS_DAC_CFG         0x6
-
-#define AUDIO_256FS_PLL_192K        0x0a53  /* 24.576M */
-#define AUDIO_256FS_PLL_192K_MUX    17
-#define AUDIO_256FS_CLK_192K        0x5c7
-
-#define AUDIO_256FS_PLL_176K        0x0eba  /* 22.5792M */
-#define AUDIO_256FS_PLL_176K_MUX    25
-#define AUDIO_256FS_CLK_176K        0x5c7
-
-#define AUDIO_256FS_PLL_96K         0x0a53  /* 24.576M */
-#define AUDIO_256FS_PLL_96K_MUX     17
-#define AUDIO_256FS_CLK_96K         0x5db
-
-#define AUDIO_256FS_PLL_88K         0x0eba  /* 22.5792M */
-#define AUDIO_256FS_PLL_88K_MUX     25
-#define AUDIO_256FS_CLK_88K         0x5db
-
-#define AUDIO_256FS_PLL_48K         0x08d3  /* 12.288M */
-#define AUDIO_256FS_PLL_48K_MUX     27
-#define AUDIO_256FS_CLK_48K_AC3     0x5d9
-#define AUDIO_256FS_CLK_48K         0x5db
-
-#define AUDIO_256FS_PLL_44K         0x06b9  /* 11.2896M */
-#define AUDIO_256FS_PLL_44K_MUX     29
-#define AUDIO_256FS_CLK_44K         0x5db
-
-#define AUDIO_256FS_PLL_32K         0x4252  /* 8.192M */
-#define AUDIO_256FS_PLL_32K_MUX     14
-#define AUDIO_256FS_CLK_32K         0x5db
-#define AUDIO_256FS_DAC_CFG         0x7
-
-#endif
 
 typedef struct {
     unsigned short pll;
@@ -118,6 +51,15 @@ enum {
 	I2SIN_SLAVE_MODE  =   1<<0,
 	SPDIFIN_MODE   = 1<<1,
 };
+enum {
+	AML_AUDIO_NA = 0,	
+	AML_AUDIO_SPDIFIN = 1<<0,
+	AML_AUDIO_SPDIFOUT = 1<<1,
+	AML_AUDIO_I2SIN = 1<<2,
+	AML_AUDIO_I2SOUT = 1<<3,
+	AML_AUDIO_PCMIN = 1<<4,
+	AML_AUDIO_PCMOUT = 1<<5,				
+};
 #define AUDIO_CLK_256FS             0
 #define AUDIO_CLK_384FS             1
 
@@ -162,6 +104,7 @@ void audio_in_i2s_enable(int flag);
 void audio_in_spdif_enable(int flag);
 unsigned int audio_in_i2s_rd_ptr(void);
 unsigned int audio_in_i2s_wr_ptr(void);
+unsigned int audio_in_spdif_wr_ptr(void);
 void audio_set_i2s_mode(u32 mode);
 void audio_set_clk(unsigned freq, unsigned fs_config);
 void audio_set_i2s_clk(unsigned freq, unsigned fs_config);
@@ -178,10 +121,14 @@ unsigned int read_i2s_mute_swap_reg(void);
 void audio_i2s_swap_left_right(unsigned int flag);
 int if_audio_out_enable(void);
 int if_audio_in_i2s_enable(void);
+int if_audio_in_spdif_enable(void);
+void audio_out_i2s_enable(unsigned flag);
 void audio_hw_958_enable(unsigned flag);
 void audio_out_enabled(int flag);
 void audio_util_set_dac_format(unsigned format);
 unsigned int audio_hdmi_init_ready(void);
+unsigned int read_iec958_rd_ptr(void);
+void audio_in_spdif_enable(int flag);
 
 #include "mach/cpu.h"
 
diff --git a/sound/soc/aml/aml_dai.c b/sound/soc/aml/aml_dai.c
index b9d372552d1a..4da31a1c6248 100755
--- a/sound/soc/aml/aml_dai.c
+++ b/sound/soc/aml/aml_dai.c
@@ -15,13 +15,48 @@
 
 #include "aml_dai.h"
 #include "aml_pcm.h"
+#include <aml_audio_hw.h>
 #include <linux/of.h>
 
 static aml_dai_info_t dai_info[3] = {{0}};
-//#define AML_DAI_DEBUG
+#define AML_DAI_DEBUG
 
-#define AML_DAI_PCM_SUPPORT
 
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
+#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-i2s-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+
+/*
+the I2S hw  and IEC958 PCM output initation,958 initation here,
+for the case that only use our ALSA driver for PCM s/pdif output.
+*/
+static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
+{
+
+		unsigned i2s_mode;
+		switch(runtime->format){
+		case SNDRV_PCM_FORMAT_S32_LE:
+			i2s_mode = AIU_I2S_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			i2s_mode = AIU_I2S_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16_LE:
+			i2s_mode = AIU_I2S_MODE_PCM16;
+			break;
+		}
+		audio_set_i2s_mode(i2s_mode);
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,runtime->channels);
+		ALSA_PRINT("i2s dma %x,phy addr %x \n",(unsigned)runtime->dma_area,(unsigned)runtime->dma_addr);
+		//memset((void*)runtime->dma_area,0,runtime->dma_bytes);
+		ALSA_PRINT("I2S hw init,i2s mode %d\n",i2s_mode);
+
+}
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {	  	
@@ -38,15 +73,119 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 	printk("***Entered %s:%s\n", __FILE__,__func__);
 #endif
 }
-
+static unsigned set_clock = 0;
 static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {
 #ifdef AML_DAI_DEBUG
 	printk("***Entered %s:%s\n", __FILE__,__func__);
 #endif
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	unsigned sample_rate = AUDIO_CLK_FREQ_48;
+	audio_stream_t *s = &prtd->s;	
+	switch(runtime->rate){
+		case 192000:
+			sample_rate	=	AUDIO_CLK_FREQ_192;
+			break;
+		case 176400:
+			sample_rate	=	AUDIO_CLK_FREQ_1764;
+			break;
+		case 96000:
+			sample_rate	=	AUDIO_CLK_FREQ_96;
+			break;
+		case 88200:
+			sample_rate	=	AUDIO_CLK_FREQ_882;
+			break;
+		case 48000:
+			sample_rate	=	AUDIO_CLK_FREQ_48;
+			break;
+		case 44100:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+		case 32000:
+			sample_rate	=	AUDIO_CLK_FREQ_32;
+			break;
+		case 8000:
+			sample_rate	=	AUDIO_CLK_FREQ_8;
+			break;
+		case 11025:
+			sample_rate	=	AUDIO_CLK_FREQ_11;
+			break;
+		case 16000:
+			sample_rate	=	AUDIO_CLK_FREQ_16;
+			break;
+		case 22050:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		case 12000:
+			sample_rate	=	AUDIO_CLK_FREQ_12;
+			break;
+		case 24000:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		default:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+	};
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	{
+		s->i2s_mode = dai_info[dai->id].i2s_mode;
+		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes*2,0);
+		memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
+		{
+			int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
+		}
+		s->device_type = AML_AUDIO_I2SIN;		
+	}
+	else{
+		audio_set_i2s_clk(sample_rate, AUDIO_CLK_256FS);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);	
+		
+		s->device_type = AML_AUDIO_I2SOUT;
+		aml_hw_i2s_init(runtime);
+	}
 	return 0;
 }
+static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    printk("****aml_dai_i2s_trigger******\n");
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			// TODO
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu i2s playback enable\n\n");
+				audio_out_i2s_enable(1);
+			}else{
+				audio_in_i2s_enable(1);
+				int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+				ppp[0] = 0x78787878;
+				ppp[1] = 0x78787878;
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu i2s playback disable\n\n");
+				audio_out_i2s_enable(0);
+			}else{
+				audio_in_i2s_enable(0);
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}	
 
 static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
 					struct snd_pcm_hw_params *params,
@@ -55,14 +194,8 @@ static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
 #ifdef AML_DAI_DEBUG
 	printk("***Entered %s:%s\n", __FILE__,__func__);
 #endif
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;
-
-	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-	{
-		s->i2s_mode = dai_info[dai->id].i2s_mode;
-	}
+	
+		
 	return 0;
 }
 
@@ -178,8 +311,8 @@ static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
 }
 
 #else /* CONFIG_PM */
-#  define aml_dai_pcm_suspend	NULL
-#  define aml_dai_pcm_resume	NULL
+#  define aml_dai_i2s_suspend	NULL
+#  define aml_dai_i2s_resume	NULL
 #endif /* CONFIG_PM */
 
 #endif
@@ -196,6 +329,7 @@ static struct snd_soc_dai_ops aml_dai_i2s_ops = {
 	.startup	= aml_dai_i2s_startup,
 	.shutdown	= aml_dai_i2s_shutdown,
 	.prepare	= aml_dai_i2s_prepare,
+	.trigger = aml_dai_i2s_trigger,
 	.hw_params	= aml_dai_i2s_hw_params,
 	.set_fmt	= aml_dai_set_i2s_fmt,
 	.set_sysclk	= aml_dai_set_i2s_sysclk,
@@ -213,7 +347,7 @@ static struct snd_soc_dai_ops aml_dai_pcm_ops = {
 #endif
 
 struct snd_soc_dai_driver aml_dai[] = {
-	{	.name = "aml-dai0",
+	{	.name = "aml-i2s-dai",
 		.id = 0,
 		.suspend = aml_dai_i2s_suspend,
 		.resume = aml_dai_i2s_resume,
@@ -252,9 +386,8 @@ struct snd_soc_dai_driver aml_dai[] = {
 EXPORT_SYMBOL_GPL(aml_dai);
 
 static const struct snd_soc_component_driver aml_component= {
-	.name		= "aml-dai",
+	.name		= "aml-i2s-dai",
 };
-
 static int aml_dai_probe(struct platform_device *pdev)
 {
 	printk(KERN_DEBUG "enter %s\n", __func__);
@@ -276,7 +409,7 @@ static int aml_dai_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_USE_OF
 static const struct of_device_id amlogic_dai_dt_match[]={
-	{	.compatible = "amlogic,aml-dai",
+	{	.compatible = "amlogic,aml-i2s-dai",
 	},
 	{},
 };
@@ -286,7 +419,7 @@ static const struct of_device_id amlogic_dai_dt_match[]={
 
 static struct platform_driver aml_dai_driver = {
 	.driver = {
-		.name = "aml-dai",
+		.name = "aml-i2s-dai",
 		.owner = THIS_MODULE,
 		.of_match_table = amlogic_dai_dt_match,
 	},
diff --git a/sound/soc/aml/aml_m8.c b/sound/soc/aml/aml_m8.c
index 2ecedb1fae70..7135290920d0 100755
--- a/sound/soc/aml/aml_m8.c
+++ b/sound/soc/aml/aml_m8.c
@@ -461,12 +461,23 @@ static struct snd_soc_dai_link aml_codec_dai_link[] = {
     {
         .name = "SND_M8",
         .stream_name = "AML PCM",
-        .cpu_dai_name = "aml-dai0",
+        .cpu_dai_name = "aml-i2s-dai.0",
         .init = aml_asoc_init,
         .platform_name = "aml-audio.0",
         .codec_name = "aml_m8_codec.0",
         .ops = &aml_asoc_ops,
     },
+
+    {
+        .name = "AML-SPDIF",
+        .stream_name = "SPDIF PCM",
+        .cpu_dai_name = "aml-spdif-dai.0",
+        .codec_dai_name = "dit-hifi",
+        .init = NULL,
+        .platform_name = "aml-audio.0",
+        .codec_name = "spdif-dit.0",
+        .ops = NULL,      
+    }, 
 };
 
 static struct snd_soc_card aml_snd_soc_card = {
diff --git a/sound/soc/aml/aml_pcm.c b/sound/soc/aml/aml_pcm.c
index 2c6c748e42ae..2d8a11bbc528 100755
--- a/sound/soc/aml/aml_pcm.c
+++ b/sound/soc/aml/aml_pcm.c
@@ -32,32 +32,19 @@
 #include "aml_audio_hw.h"
 #include "aml_platform.h"
 
-//#define _AML_PCM_DEBUG_
-//
-
 #define USE_HRTIMER 0
 #define HRTIMER_PERIOD (1000000000UL/48000)
+#define DEBUG_ALSA_PLATFRORM
+
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-pcm]" fmt,##args)
+#ifdef DEBUG_ALSA_PLATFRORM
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-pcm]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-pcm] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
 
-#define AOUT_EVENT_IEC_60958_PCM                0x1
-#define AOUT_EVENT_RAWDATA_AC_3                 0x2
-#define AOUT_EVENT_RAWDATA_MPEG1                0x3
-#define AOUT_EVENT_RAWDATA_MP3                  0x4
-#define AOUT_EVENT_RAWDATA_MPEG2                0x5
-#define AOUT_EVENT_RAWDATA_AAC                  0x6
-#define AOUT_EVENT_RAWDATA_DTS                  0x7
-#define AOUT_EVENT_RAWDATA_ATRAC                0x8
-#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
-#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
-#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
-#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
-#define AOUT_EVENT_RAWDATA_DST                  0xD
-#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
-
-extern int aout_notifier_call_chain(unsigned long val, void *v);
-extern void	aml_alsa_hw_reprepare(void);
-
-extern unsigned IEC958_mode_raw;
-extern unsigned IEC958_mode_codec;
 
 unsigned int aml_pcm_playback_start_addr = 0;
 unsigned int aml_pcm_capture_start_addr  = 0;
@@ -78,44 +65,18 @@ unsigned int aml_iec958_playback_start_addr = 0;
 unsigned int aml_iec958_playback_start_phy = 0;
 unsigned int aml_iec958_playback_size = 0;  // in bytes
 
-static  unsigned  playback_substream_handle = 0 ;
-/*to keep the pcm status for clockgating*/
-static unsigned clock_gating_status = 0;
-static unsigned clock_gating_playback = 1;
-static unsigned clock_gating_capture = 2;
+
 static int audio_type_info = -1;
 static int audio_sr_info = -1;
 extern unsigned audioin_mode;
 
 
-static int audio_ch_info = -1;
-
-//static struct rt5631_platform_data *rt5631_snd_pdata = NULL;
-static struct aml_pcm_work_t{
-	struct snd_pcm_substream *substream;
-	struct work_struct aml_codec_workqueue;
-}aml_pcm_work;
-
-int codec_power=1;
-unsigned int flag=0;
-static int num=0;
-
-static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int status);
 
 EXPORT_SYMBOL(aml_pcm_playback_start_addr);
 EXPORT_SYMBOL(aml_pcm_capture_start_addr);
 EXPORT_SYMBOL(aml_pcm_playback_off);
 EXPORT_SYMBOL(aml_pcm_playback_enable);
 
-static void aml_codec_power_switch_queue(struct work_struct* work)
-{
-
-#ifdef _AML_PCM_DEBUG_
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	// disable power down/up, which caused pop noise
-	//codec_power_switch(substream, clock_gating_status);
-}
 
 /*--------------------------------------------------------------------------*\
  * Hardware definition
@@ -175,93 +136,18 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 	.mask = 0
 };
 
-/*--------------------------------------------------------------------------*\
- * audio clock gating
-\*--------------------------------------------------------------------------*/
-#if 0
-static void aml_audio_clock_gating_disable(void)
-{
-#ifdef _AML_PCM_DEBUG_
-			printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-/*
-	aml_clr_reg32_mask(P_HHI_GCLK_MPEG0, (1<<18));
-	aml_clr_reg32_mask(P_HHI_GCLK_MPEG1, (1<<2)
-										|(0xba<<6)
-								    	);
-	aml_clr_reg32_mask(P_HHI_GCLK_OTHER, (1<<18)
-										|(0x6<<14)
-								    	);
- */   aml_clr_reg32_mask( P_HHI_AUD_CLK_CNTL, (1 << 8));
-
-	//printk("P_HHI_GCLK_MPEG0=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG0));
-	//printk("P_HHI_GCLK_MPEG1=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG1));
-	//printk("P_HHI_GCLK_OTHER=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_OTHER));
-}
-
-static void aml_audio_clock_gating_enable(void)
-{
-#ifdef _AML_PCM_DEBUG_
-			printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-/*	aml_set_reg32_mask(P_HHI_GCLK_MPEG0, (1<<18));
-	aml_set_reg32_mask(P_HHI_GCLK_MPEG1, (1<<2)
-								    	|(0xba<<6)
-								   		 );
-	aml_set_reg32_mask(P_HHI_GCLK_OTHER, (1<<18)
-								    	|(0x6<<14)
-								    	);
-*/    aml_set_reg32_mask( P_HHI_AUD_CLK_CNTL, (1 << 8));
-	//printk("P_HHI_GCLK_MPEG0=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG0));
-	//printk("P_HHI_GCLK_MPEG1=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG1));
-	//printk("P_HHI_GCLK_OTHER=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_OTHER));
-}
-#endif
-
-#if 0
-static void aml_clock_gating(unsigned int status)
-{
-//printk("-----status=%d\n\n",status);
-	if(status){
-		aml_audio_clock_gating_enable();
-	}
-	else{
-		aml_audio_clock_gating_disable();
-	}
-}
-#endif
-/*--------------------------------------------------------------------------*\
- * audio codec power management
-\*--------------------------------------------------------------------------*/
-#if 0
-static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int status)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-#ifdef _AML_PCM_DEBUG_
-			printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	if(status && codec_dai->driver->ops->startup)
-			codec_dai->driver->ops->startup(substream, codec_dai);
-
-	if((flag)&& (!status) && (codec_dai->driver->ops->shutdown))
-			codec_dai->driver->ops->shutdown(substream, codec_dai);
-	return 0;
-}
-#endif
+/*--------------------------------------------------------------------------*/
 /*--------------------------------------------------------------------------*\
  * Helper functions
 \*--------------------------------------------------------------------------*/
 static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 	int stream)
 {
+	ALSA_TRACE();
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 
 	size_t size = 0;
-
-    if(pcm->device == 0)
-    {
 	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		    size = aml_pcm_hardware.buffer_bytes_max;
 		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
@@ -275,25 +161,8 @@ static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 		    (void *) buf->area,
 		    (void *) buf->addr,
 		    size);
+        }else{
 
-            /* alloc iec958 buffer */
-
-            aml_pcm_playback_start_addr = (unsigned int)buf->area;
-		    aml_pcm_playback_end_addr = (unsigned int)buf->area + size;
-
-		aml_pcm_playback_phy_start_addr = buf->addr;
-		aml_pcm_playback_phy_end_addr = buf->addr+size;
-
-        /* alloc iec958 buffer */
-        aml_iec958_playback_start_addr = (unsigned int)dma_alloc_coherent(pcm->card->dev, size*4,
-           (dma_addr_t *)(&aml_iec958_playback_start_phy), GFP_KERNEL);
-        if(aml_iec958_playback_start_addr == 0){
-          printk("aml-pcm %d: alloc iec958 buffer failed\n", stream);
-          return -ENOMEM;
-        }
-        aml_iec958_playback_size = size*4;
-        printk("iec958 %d: preallocate dma buffer start=%p, size=%x\n", stream, (void*)aml_iec958_playback_start_addr, size*4);
-	}else{
 		size = aml_pcm_capture.buffer_bytes_max;
 		buf->dev.type = SNDRV_DMA_TYPE_DEV;
 		buf->dev.dev = pcm->card->dev;
@@ -305,62 +174,14 @@ static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 		    (void *) buf->area,
 		    (void *) buf->addr,
 		    size);
-
-            aml_pcm_capture_start_addr = (unsigned int)buf->area;
-		    aml_pcm_capture_end_addr = (unsigned int)buf->area+size;
-		    aml_pcm_capture_start_phy = buf->addr;
-		    aml_pcm_capture_buf_size = size;
-		    aml_pcm_capture_phy_start_addr = buf->addr;
-		    aml_pcm_capture_phy_end_addr = buf->addr+size;
 	    }
 
 	    if (!buf->area)
 		    return -ENOMEM;
-
-	    buf->bytes = size;
-	    return 0;
-    }
-    else
-    {
-	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		    size = aml_pcm_hardware.buffer_bytes_max;
-		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		    buf->dev.dev = pcm->card->dev;
-		    buf->private_data = NULL;
-            /* one size for i2s output, another for 958, and 128 for alignment */
-		    //buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
-					  //&buf->addr, GFP_KERNEL);
-            buf->area = aml_pcm_playback_start_addr;
-            buf->addr = aml_pcm_playback_phy_start_addr;
-		    printk("aml-pcm %d:"
-		    "dev>0 playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
-		    (void *) buf->area,
-		    (void *) buf->addr,
-		    size);
-
-        }else{
-		    size = aml_pcm_capture.buffer_bytes_max;
-		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		    buf->dev.dev = pcm->card->dev;
-		    buf->private_data = NULL;
-		    //buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
-		    //			  &buf->addr, GFP_KERNEL);
-		    buf->area = aml_pcm_capture_start_addr;
-            buf->addr = aml_pcm_capture_phy_start_addr;
-		    printk("aml-pcm %d:"
-		    "dev>0 capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
-		    (void *) buf->area,
-		    (void *) buf->addr,
-		    size);
-	    }
-
-	    if (!buf->area)
-		    return -ENOMEM;
-
+    
 	    buf->bytes = size;
 	    return 0;
 
-    }
 }
 /*--------------------------------------------------------------------------*\
  * ISR
@@ -383,8 +204,7 @@ static int aml_pcm_hw_params(struct snd_pcm_substream *substream,
 
 	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
 	runtime->dma_bytes = params_buffer_bytes(params);
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		aml_iec958_playback_size = runtime->dma_bytes*4;
+	ALSA_PRINT("runtime dma_bytes %d,stream type \n",runtime->dma_bytes,substream->stream);
 	s->I2S_addr = runtime->dma_addr;
 
     /*
@@ -413,268 +233,18 @@ static int aml_pcm_hw_free(struct snd_pcm_substream *substream)
 
 	return 0;
 }
-/*
-the I2S hw  and IEC958 PCM output initation,958 initation here,
-for the case that only use our ALSA driver for PCM s/pdif output.
-*/
-static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
-{
-
-
-		switch(runtime->format){
-		case SNDRV_PCM_FORMAT_S32_LE:
-			I2S_MODE = AIU_I2S_MODE_PCM32;
-		// IEC958_MODE = AIU_958_MODE_PCM32;
-			break;
-		case SNDRV_PCM_FORMAT_S24_LE:
-			I2S_MODE = AIU_I2S_MODE_PCM24;
-		// IEC958_MODE = AIU_958_MODE_PCM24;
-			break;
-		case SNDRV_PCM_FORMAT_S16_LE:
-			I2S_MODE = AIU_I2S_MODE_PCM16;
-		// IEC958_MODE = AIU_958_MODE_PCM16;
-			break;
-		}
-		audio_set_i2s_mode(I2S_MODE);
-		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, runtime->channels);
-		memset((void*)runtime->dma_area,0,runtime->dma_bytes + 4096);
-		/* update the i2s hw buffer end addr as android may update that */
-		aml_pcm_playback_phy_end_addr = aml_pcm_playback_phy_start_addr+runtime->dma_bytes;
-		printk("I2S hw init,i2s mode %d\n",I2S_MODE);
-
-}
-/*add audio_hdmi_init_ready check ,as hdmi audio may init fails:
-AIU_HDMI_CLK_DATA_CTRL can be writen sucessfully when audio PLL OFF.
-so notify HDMI to set audio parameter every time when HDMI AUDIO not ready
-*/
-
-static int audio_notify_hdmi_info(int audio_type, void *v){
-    	struct snd_pcm_substream *substream =(struct snd_pcm_substream*)v;
-	if(substream->runtime->rate != audio_sr_info || audio_type_info != audio_type || !audio_hdmi_init_ready()
-		|| substream->runtime->channels != audio_ch_info)
-	{
-		printk("audio info changed.notify to hdmi: type %d,sr %d,ch %d\n",audio_type,substream->runtime->rate,
-			substream->runtime->channels);
-		aout_notifier_call_chain(audio_type,v);
-	}
-	audio_sr_info = substream->runtime->rate;
-	audio_ch_info = substream->runtime->channels;
-	audio_type_info = audio_type;
-
-}
-static void iec958_notify_hdmi_info(void)
-{
-	unsigned audio_type = AOUT_EVENT_IEC_60958_PCM;
-	if(playback_substream_handle){
-		if(IEC958_mode_codec == 2) //dd
-			audio_type = AOUT_EVENT_RAWDATA_AC_3;
-		else if(IEC958_mode_codec == 4)//dd+
-			audio_type = AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS;
-		else if(IEC958_mode_codec == 1|| IEC958_mode_codec == 3)//dts
-			audio_type = AOUT_EVENT_RAWDATA_DTS;
-		else
-			audio_type = AOUT_EVENT_IEC_60958_PCM;
-		printk("iec958 nodify hdmi audio type %d\n",	audio_type);
-		audio_notify_hdmi_info(audio_type, (struct snd_pcm_substream *)playback_substream_handle);
-	}
-	else{
-		printk("substream for playback NULL\n");
-	}
-
-}
-/*
-special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
-1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
-2)PCM  output for  all audio, when pcm mode is selected by user .
-3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
-*/
-static void aml_hw_iec958_init(void)
-{
-    _aiu_958_raw_setting_t set;
-    _aiu_958_channel_status_t chstat;
-    unsigned start,size;
-	memset((void*)(&set), 0, sizeof(set));
-	memset((void*)(&chstat), 0, sizeof(chstat));
-	set.chan_stat = &chstat;
-   	/* case 1,raw mode enabled */
-	if(IEC958_mode_codec){
-	  if(IEC958_mode_codec == 1){ //dts, use raw sync-word mode
-	    	IEC958_MODE = AIU_958_MODE_RAW;
-		printk("iec958 mode RAW\n");
-	  }
-	  else{ //ac3,use the same pcm mode as i2s configuration
-		IEC958_MODE = AIU_958_MODE_PCM_RAW;
-		printk("iec958 mode %s\n",(I2S_MODE == AIU_I2S_MODE_PCM32)?"PCM32_RAW":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24_RAW":"PCM16_RAW"));
-	  }
-	}else{	/* case 2,3 */
-	  if(I2S_MODE == AIU_I2S_MODE_PCM32)
-	  	IEC958_MODE = AIU_958_MODE_PCM32;
-	  else if(I2S_MODE == AIU_I2S_MODE_PCM24)
-	  	IEC958_MODE = AIU_958_MODE_PCM24;
-	  else
-	  	IEC958_MODE = AIU_958_MODE_PCM16;
-  	  printk("iec958 mode %s\n",(I2S_MODE == AIU_I2S_MODE_PCM32)?"PCM32":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24":"PCM16"));
-	}
-
-	if(IEC958_MODE == AIU_958_MODE_PCM16 || IEC958_MODE == AIU_958_MODE_PCM24 ||
-	  IEC958_MODE == AIU_958_MODE_PCM32){
-	    set.chan_stat->chstat0_l = 0x0100;
-		set.chan_stat->chstat0_r = 0x0100;
-		set.chan_stat->chstat1_l = 0X200;
-		set.chan_stat->chstat1_r = 0X200;
-        start = (aml_pcm_playback_phy_start_addr);
-        size = aml_pcm_playback_phy_end_addr - aml_pcm_playback_phy_start_addr;
-		audio_set_958outbuf(start, size, 0);
-	  }else{
-		set.chan_stat->chstat0_l = 0x1902;//NONE-PCM
-		set.chan_stat->chstat0_r = 0x1902;
-		set.chan_stat->chstat1_l = 0X200;
-		set.chan_stat->chstat1_r = 0X200;
-        // start = ((aml_pcm_playback_phy_end_addr + 4096)&(~127));
-        // size  = aml_pcm_playback_phy_end_addr - aml_pcm_playback_phy_start_addr;
-        start = aml_iec958_playback_start_phy;
-        size = aml_iec958_playback_size;
-		audio_set_958outbuf(start, size, (IEC958_MODE == AIU_958_MODE_RAW)?1:0);
-		memset((void*)aml_iec958_playback_start_addr,0,size);
-
-	}
-	audio_set_958_mode(IEC958_MODE, &set);
-	if(IEC958_mode_codec == 4)  //dd+
-		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2); // 4x than i2s
-	else
-#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1
-		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);//512fs divide 4 == 128fs
-#else
-		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 4, 2); //256fs divide 2 == 128fs
-#endif
-	iec958_notify_hdmi_info();
-
-
-}
-
-void	aml_alsa_hw_reprepare(void)
-{
-	/* diable 958 module before call initiation */
-	audio_hw_958_enable(0);
-  aml_hw_iec958_init();
 
-}
 
 static int aml_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;
-    int iec958 = 0;
-
-	if(prtd == 0)
-		return 0;
-
-	switch(runtime->rate){
-		case 192000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_192;
-			break;
-		case 176400:
-			s->sample_rate	=	AUDIO_CLK_FREQ_1764;
-			break;
-		case 96000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_96;
-			break;
-		case 88200:
-			s->sample_rate	=	AUDIO_CLK_FREQ_882;
-			break;
-		case 48000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_48;
-            iec958 = 2;
-			break;
-		case 44100:
-			s->sample_rate	=	AUDIO_CLK_FREQ_441;
-            iec958 = 0;
-			break;
-		case 32000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_32;
-            iec958 = 3;
-			break;
-		case 8000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_8;
-			break;
-		case 11025:
-			s->sample_rate	=	AUDIO_CLK_FREQ_11;
-			break;
-		case 16000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_16;
-			break;
-		case 22050:
-			s->sample_rate	=	AUDIO_CLK_FREQ_22;
-			break;
-		case 12000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_12;
-			break;
-		case 24000:
-			s->sample_rate	=	AUDIO_CLK_FREQ_22;
-			break;
-		default:
-			s->sample_rate	=	AUDIO_CLK_FREQ_441;
-			break;
-	};
-	// iec958 and i2s clock are separated after M6TV
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6TV
-	audio_set_clk(s->sample_rate, AUDIO_CLK_256FS);
-	audio_util_set_dac_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-#else
-	audio_set_i2s_clk(s->sample_rate, AUDIO_CLK_256FS);
-	audio_set_958_clk(s->sample_rate, AUDIO_CLK_256FS);
-	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-#endif
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-			aml_hw_i2s_init(runtime);
-		  aml_hw_iec958_init();
-	}
-	else{
-			//printk("aml_pcm_prepare SNDRV_PCM_STREAM_CAPTURE: dma_addr=%x, dma_bytes=%x\n", runtime->dma_addr, runtime->dma_bytes);
-			audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes*2,audioin_mode);
-			memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
-            {
-			  int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
-			  ppp[0] = 0x78787878;
-			  ppp[1] = 0x78787878;
-            }
-	}
-    if( IEC958_MODE == AIU_958_MODE_PCM_RAW){
-		if(IEC958_mode_codec == 4 ){ // need Over clock for dd+
-		    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2);	// 4x than i2s
-		    audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS, substream);
-		}else if(IEC958_mode_codec == 3 ||IEC958_mode_codec == 1 ){ // no-over clock for dts pcm mode
-		    audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DTS, substream);
-		}
-		else  //dd
-			audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_AC_3, substream);
-
-    }else if(IEC958_mode_codec == 1){
-        audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DTS, substream);
-    }else{
-				audio_notify_hdmi_info(AOUT_EVENT_IEC_60958_PCM, substream);
-    }
-
-#if 0
-	printk("Audio Parameters:\n");
-	printk("\tsample rate: %d\n", runtime->rate);
-	printk("\tchannel: %d\n", runtime->channels);
-	printk("\tsample bits: %d\n", runtime->sample_bits);
-  printk("\tformat: %s\n", snd_pcm_format_name(runtime->format));
-	printk("\tperiod size: %ld\n", runtime->period_size);
-	printk("\tperiods: %d\n", runtime->periods);
-  printk("\tiec958 mode: %d, raw=%d, codec=%d\n", IEC958_MODE, IEC958_mode_raw, IEC958_mode_codec);
-#endif
-
+	ALSA_TRACE();
 	return 0;
 }
 
 static int aml_pcm_trigger(struct snd_pcm_substream *substream,
 	int cmd)
 {
+	ALSA_TRACE();
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	struct aml_runtime_data *prtd = rtd->private_data;
 	audio_stream_t *s = &prtd->s;
@@ -682,39 +252,18 @@ static int aml_pcm_trigger(struct snd_pcm_substream *substream,
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	 //witch_mod_gate_by_type(MOD_AUDIO, 1);
-#endif
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:		
 
 #if USE_HRTIMER == 0
 	  del_timer_sync(&prtd->timer);
-#endif
+#endif      
 	  spin_lock(&s->lock);
 #if USE_HRTIMER == 0
 	  prtd->timer.expires = jiffies + 1;
 	  del_timer(&prtd->timer);
 	  add_timer(&prtd->timer);
 #endif
-	  // TODO
-	  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-	        //printk("aml_pcm_trigger: playback start\n");
-			//clock_gating_status |= clock_gating_playback;
-			//aml_clock_gating(clock_gating_status);
-			//codec_power_switch(substream, clock_gating_status);
-		    audio_enable_ouput(1);
-	  }else{
-	  		//printk("aml_pcm_trigger: capture start\n");
-			//clock_gating_status |= clock_gating_capture;
-			//aml_clock_gating(clock_gating_status);
-			//codec_power_switch(substream, clock_gating_status);
-			audio_in_i2s_enable(1);
-	      {
-		  int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
-		  ppp[0] = 0x78787878;
-		  ppp[1] = 0x78787878;
-	      }
-
-	  }
 
 	  s->active = 1;
 	  spin_unlock(&s->lock);
@@ -725,51 +274,6 @@ static int aml_pcm_trigger(struct snd_pcm_substream *substream,
 		// TODO
 	    spin_lock(&s->lock);
 	    s->active = 0;
-	    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-            //printk("aml_pcm_trigger: playback stop\n");
-	  		audio_enable_ouput(0);
-		//	clock_gating_status &= ~clock_gating_playback;
-			//aml_clock_gating(clock_gating_status);
-			//codec_power_switch(substream, clock_gating_status);
-	    }else{
-            //printk("aml_pcm_trigger: capture stop\n");
-		//	clock_gating_status &= ~clock_gating_capture;
-
-			audio_in_i2s_enable(0);
-	    }
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	//  switch_mod_gate_by_type(MOD_AUDIO, 0);
-#endif
-
-	    spin_unlock(&s->lock);
-	    break;
-
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		// TODO
-	    spin_lock(&s->lock);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	  //switch_mod_gate_by_type(MOD_AUDIO, 1);
-#endif
-	    s->active = 1;
-	    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-            //printk("aml_pcm_trigger: playback resume\n");
-			audio_enable_ouput(1);
-		//	clock_gating_status |= clock_gating_playback;
-			//aml_clock_gating(clock_gating_status);
-			//codec_power_switch(substream, clock_gating_status);
-	    }else{
-            //printk("aml_pcm_trigger: capture resume\n");
-	        audio_in_i2s_enable(1);
-		//	clock_gating_status |= clock_gating_capture;
-			//aml_clock_gating(clock_gating_status);
-			//codec_power_switch(substream, clock_gating_status);
-		{
-		    int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
-		    ppp[0] = 0x78787878;
-		    ppp[1] = 0x78787878;
-	        }
-	    }
 	    spin_unlock(&s->lock);
 	    break;
 	default:
@@ -802,25 +306,30 @@ static snd_pcm_uframes_t aml_pcm_pointer(
 	unsigned int addr, ptr;
 
 	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		if(s->device_type == AML_AUDIO_I2SOUT)
 			ptr = read_i2s_rd_ptr();
+		else
+			ptr = read_iec958_rd_ptr();
 	    addr = ptr - s->I2S_addr;
 	    return bytes_to_frames(runtime, addr);
 	}else{
+		if(s->device_type == AML_AUDIO_I2SIN)
 			ptr = audio_in_i2s_wr_ptr();
+		else
+			ptr = audio_in_spdif_wr_ptr();				
 			addr = ptr - s->I2S_addr;
 			return bytes_to_frames(runtime, addr)/2;
 	}
 
 	return 0;
-}
-
+}	
 static enum hrtimer_restart aml_pcm_hrtimer_callback(struct hrtimer* timer)
 {
   struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
   audio_stream_t* s = &prtd->s;
   struct snd_pcm_substream* substream = prtd->substream;
   struct snd_pcm_runtime* runtime= substream->runtime;
-
+  
   unsigned int last_ptr, size;
   unsigned long flag;
   //printk("------------->hrtimer start\n");
@@ -870,37 +379,15 @@ static void aml_pcm_timer_callback(unsigned long data)
 		audio_stream_t *s = &prtd->s;
 
     unsigned int last_ptr, size;
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-				if(s->active == 1){
-						spin_lock(&s->lock);
-						last_ptr = read_i2s_rd_ptr();
-						if (last_ptr < s->last_ptr) {
-				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
-				    } else {
-				        size = last_ptr - (s->last_ptr);
-				    }
-    				s->last_ptr = last_ptr;
-    				s->size += bytes_to_frames(substream->runtime, size);
-    				if (s->size >= runtime->period_size) {
-				        s->size %= runtime->period_size;
-				        spin_unlock(&s->lock);
-				        snd_pcm_period_elapsed(substream);
-				        spin_lock(&s->lock);
-				    }
-				    mod_timer(&prtd->timer, jiffies + 1);
-					//codec_power = 1;
-   					spin_unlock(&s->lock);
-				}else{
-
-						 mod_timer(&prtd->timer, jiffies + 1);
-						// codec_power = 0;
-
-				}
-
-		}else{
-				if(s->active == 1){
-						spin_lock(&s->lock);
-						last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) / 2;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		if(s->active == 1)
+		{
+			spin_lock(&s->lock);
+			if(s->device_type == AML_AUDIO_I2SOUT)
+				last_ptr = read_i2s_rd_ptr();
+			else
+				last_ptr = read_iec958_rd_ptr();							
 						if (last_ptr < s->last_ptr) {
 				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
 				    } else {
@@ -920,43 +407,50 @@ static void aml_pcm_timer_callback(unsigned long data)
 						 mod_timer(&prtd->timer, jiffies + 1);
 				}
 		}
-	/*	if((codec_power==0) && (num==500))
+	else
+	{
+		if(s->active == 1)
 		{
-			num=0;
-	   		flag=1;
-			schedule_work(&aml_pcm_work.aml_codec_workqueue);
-		}
-	   else if((codec_power==1) && (num <= 500))
-	   	{
-	   		num=0;
-			flag = 0;
-	   	}
-	   else if((codec_power==0) && (num<500))
-	   	{
-	   	    if(flag==1)
-	   	    {}
+			spin_lock(&s->lock);
+			if(s->device_type == AML_AUDIO_I2SIN)			
+				last_ptr = audio_in_i2s_wr_ptr() ;
 			else
-			{
-				num++;
+				last_ptr = audio_in_spdif_wr_ptr();				
+			if (last_ptr < s->last_ptr) {
+				size = runtime->dma_bytes + (last_ptr - (s->last_ptr))/2;
+			} else {
+				size = (last_ptr - (s->last_ptr))/2;
+			}
+			s->last_ptr = last_ptr;
+			s->size += bytes_to_frames(substream->runtime, size);
+			if (s->size >= runtime->period_size) {
+				s->size %= runtime->period_size;
+				spin_unlock(&s->lock);
+				snd_pcm_period_elapsed(substream);
+				spin_lock(&s->lock);
 			}
-	   	} */
+			mod_timer(&prtd->timer, jiffies + 1);
+			spin_unlock(&s->lock);
+		}
+		else
+		{
+			mod_timer(&prtd->timer, jiffies + 1);
+		}
+	}
 }
 
 
 static int aml_pcm_open(struct snd_pcm_substream *substream)
 {
+	ALSA_TRACE();
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd;
 	int ret = 0;
-
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		playback_substream_handle = (unsigned long)substream;
 		snd_soc_set_runtime_hwparams(substream, &aml_pcm_hardware);
 	}else{
 		snd_soc_set_runtime_hwparams(substream, &aml_pcm_capture);
 	}
-	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);
-	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
 
     /* ensure that peroid size is a multiple of 32bytes */
 	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
@@ -982,15 +476,17 @@ static int aml_pcm_open(struct snd_pcm_substream *substream)
 		goto out;
 	}
 
+	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);			
+	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
 	prtd->substream = substream;
-#if USE_HRTIMER == 0
+#if USE_HRTIMER == 0    
 	prtd->timer.function = &aml_pcm_timer_callback;
 	prtd->timer.data = (unsigned long)substream;
 	init_timer(&prtd->timer);
 #else
     hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
     prtd->hrtimer.function = aml_pcm_hrtimer_callback;
-    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL);
+    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
 
 
     printk("hrtimer inited..\n");
@@ -1005,17 +501,16 @@ static int aml_pcm_open(struct snd_pcm_substream *substream)
 static int aml_pcm_close(struct snd_pcm_substream *substream)
 {
 	struct aml_runtime_data *prtd = substream->runtime->private_data;
-
+	audio_stream_t *s = &prtd->s;	
+	ALSA_TRACE();
+	if(s->device_type == AML_AUDIO_SPDIFOUT)
+		WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);			
 #if USE_HRTIMER == 0
 	del_timer_sync(&prtd->timer);
 #else
     hrtimer_cancel(&prtd->hrtimer);
 #endif
 	kfree(prtd);
-
-	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		playback_substream_handle = 0;
 	return 0;
 }
 
@@ -1032,8 +527,10 @@ static int aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
     n = frames_to_bytes(runtime, count);
     if(aml_pcm_playback_enable == 0)
       return res;
-    if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))){
-	  if(runtime->format == SNDRV_PCM_FORMAT_S16_LE && I2S_MODE == AIU_I2S_MODE_PCM16){
+	if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count)))
+	{
+		if(1/*runtime->channels == 2*/){
+			if(runtime->format == SNDRV_PCM_FORMAT_S16_LE ){
         int16_t * tfrom, *to, *left, *right;
         tfrom = (int16_t*)buf;
         to = (int16_t*)hwbuf;
@@ -1082,7 +579,7 @@ static int aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
         if(pos % align){
           printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
         }
-
+		
 		if(runtime->channels == 8){
 			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
 			lf  = to;
@@ -1131,6 +628,7 @@ static int aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	}
 
 	return res;
+    }
 }
 
 
@@ -1144,9 +642,11 @@ static int aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 		int n;
     int i = 0, j = 0;
     unsigned int t1, t2;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;	   
     char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
-    unsigned char r_shift = 8;
-    if(audioin_mode&SPDIFIN_MODE) //spdif in
+    unsigned char r_shift = 8;	
+	if(s->device_type == AML_AUDIO_SPDIFIN) //spdif in
     {
     	r_shift = 12;
     }
@@ -1154,11 +654,12 @@ static int aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
     tfrom = (unsigned int *)hwbuf;	// 32bit buffer
     n = frames_to_bytes(runtime, count);
     if(n > 32*1024){
-      printk("Too many datas to read\n");
+		printk("Too many datas to read,please enlarge the snd_pcm_tmp buffer size\n");
       return -EINVAL;
     }
-
-		if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count))){
+	if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count)))
+	{
+		if(runtime->channels == 2){
 				left = tfrom;
 		    right = tfrom + 8;
 		    if (pos % 8) {
@@ -1179,6 +680,9 @@ static int aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 		         //printk("\n");
 		        left += 8;
 		        right += 8;
+			}
+		}
+		else{
 		    }
 		}
         res = copy_to_user(buf, snd_pcm_tmp,n);
@@ -1203,6 +707,7 @@ static int aml_pcm_copy(struct snd_pcm_substream *substream, int channel,
 int aml_pcm_silence(struct snd_pcm_substream *substream, int channel,
 		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
 {
+	ALSA_TRACE();
 		char* ppos;
 		int n;
 		struct snd_pcm_runtime *runtime = substream->runtime;
@@ -1234,9 +739,10 @@ static u64 aml_pcm_dmamask = 0xffffffff;
 
 static int aml_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
+	ALSA_TRACE();
 	int ret = 0;
        struct snd_soc_card *card = rtd->card;
-       struct snd_pcm *pcm =rtd->pcm ;
+       struct snd_pcm *pcm =rtd->pcm ;  
 	if (!card->dev->dma_mask)
 		card->dev->dma_mask = &aml_pcm_dmamask;
 	if (!card->dev->coherent_dma_mask)
@@ -1264,6 +770,7 @@ static int aml_pcm_new(struct snd_soc_pcm_runtime *rtd)
 
 static void aml_pcm_free_dma_buffers(struct snd_pcm *pcm)
 {
+	ALSA_TRACE();
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	int stream;
@@ -1279,13 +786,6 @@ static void aml_pcm_free_dma_buffers(struct snd_pcm *pcm)
 				  buf->area, buf->addr);
 		buf->area = NULL;
 	}
-    aml_pcm_playback_start_addr = 0;
-    aml_pcm_capture_start_addr  = 0;
-
-    if(aml_iec958_playback_start_addr){
-      dma_free_coherent(pcm->card->dev, aml_iec958_playback_size, ( void *)aml_iec958_playback_start_addr, aml_iec958_playback_start_phy);
-      aml_iec958_playback_start_addr = 0;
-    }
 }
 
 #ifdef CONFIG_PM
@@ -1527,7 +1027,7 @@ static const struct file_operations mems_fops={
 
 static void aml_pcm_init_debugfs(void)
 {
-		debugfs_root = debugfs_create_dir("aml",NULL);
+	    debugfs_root = debugfs_create_dir("aml",NULL);
 		if (IS_ERR(debugfs_root) || !debugfs_root) {
 			printk("aml: Failed to create debugfs directory\n");
 			debugfs_root = NULL;
@@ -1581,7 +1081,7 @@ static int aml_soc_platform_probe(struct platform_device *pdev)
 	if(pdev->dev.platform_data){
 		audioin_mode = *(unsigned *)pdev->dev.platform_data;
 		printk("AML soc audio in mode =============   %d \n",audioin_mode);
-	}
+	}	
 	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
 }
 
diff --git a/sound/soc/aml/aml_pcm.h b/sound/soc/aml/aml_pcm.h
index bb4e2b16d8b9..5be7b6d188c9 100755
--- a/sound/soc/aml/aml_pcm.h
+++ b/sound/soc/aml/aml_pcm.h
@@ -18,6 +18,7 @@ typedef struct audio_stream {
     spinlock_t lock;
     struct snd_pcm_substream *stream;
 	unsigned i2s_mode; //0:master, 1:slave,
+    unsigned device_type;
 } audio_stream_t;
 
 typedef struct aml_audio {
@@ -63,6 +64,7 @@ struct aml_runtime_data {
 	dma_addr_t dma_buffer;		/* physical address of dma buffer */
 	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
 
+	struct snd_pcm *pcm;
 	struct snd_pcm_substream *substream;
 	audio_stream_t s;	
 	struct timer_list timer;	// timeer for playback and capture
diff --git a/sound/soc/aml/aml_spdif_codec.c b/sound/soc/aml/aml_spdif_codec.c
new file mode 100755
index 000000000000..b0253d4a0f51
--- /dev/null
+++ b/sound/soc/aml/aml_spdif_codec.c
@@ -0,0 +1,101 @@
+/*
+ * ALSA SoC SPDIF CODEC driver
+ *
+ *  This driver is used by controllers which can operate in DIT (SPDI/F) where
+ *  no codec is needed.  This file provides stub codec that can be used
+ *  in these configurations. TI DaVinci Audio controller uses this driver.
+ *
+ * Author:      Steve Chen,  <schen@mvista.com>
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+
+
+#define DRV_NAME "spdif-dit"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
+
+
+static struct snd_soc_codec_driver soc_codec_spdif_dit;
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dit-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+	.capture 	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},	
+};
+
+static int spdif_dit_probe(struct platform_device *pdev)
+{
+	printk("enter spdif_dit_probe \n");
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
+			&dit_stub_dai, 1);
+}
+static int spdif_dit_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_spdif_codec_dt_match[]={
+	{	.compatible = "amlogic,aml-spdif-codec",
+	},
+	{},
+};
+#else
+#define amlogic_spdif_codec_dt_match NULL
+#endif
+
+
+static struct platform_driver spdif_dit_driver = {
+	.probe		= spdif_dit_probe,
+	.remove		= spdif_dit_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = amlogic_spdif_codec_dt_match,
+	},
+};
+static int __init spdif_codec_init(void)
+{
+	return platform_driver_register(&spdif_dit_driver);
+}
+
+static void __exit spdif_codec_exit(void)
+{
+	platform_driver_unregister(&spdif_dit_driver);
+}
+
+module_init(spdif_codec_init);
+module_exit(spdif_codec_exit);
+
+MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
+MODULE_DESCRIPTION("SPDIF dummy codec driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+
diff --git a/sound/soc/aml/aml_spdif_dai.c b/sound/soc/aml/aml_spdif_dai.c
new file mode 100755
index 000000000000..bfcb898ed1cd
--- /dev/null
+++ b/sound/soc/aml/aml_spdif_dai.c
@@ -0,0 +1,427 @@
+/*
+	Amlogic S/PDIF(HDMI)  Soc dai driver
+	author:jian.xu@amlogic.com
+*/
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+#include "aml_audio_hw.h"
+#include "aml_spdif_dai.h"
+#include "aml_pcm.h"
+#include <linux/of.h>
+
+#define DEBUG_ALSA_SPDIF_DAI
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
+#ifdef DEBUG_ALSA_SPDIF_DAI
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-spdif-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+extern int aout_notifier_call_chain(unsigned long val, void *v);
+static  unsigned  playback_substream_handle = 0 ;
+extern unsigned int IEC958_mode_codec;
+static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
+				int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	struct snd_soc_pcm_runtime *rtd = NULL;
+	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if(substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
+				ALSA_PRINT("aiu 958 playback enable\n");
+				audio_hw_958_enable(1);
+			}
+			else{
+				ALSA_PRINT("spdif in capture enable\n");				
+				audio_in_spdif_enable(1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if(substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
+				ALSA_PRINT("aiu 958 playback disable \n");				
+				audio_hw_958_enable(0);
+			}
+			else{
+				ALSA_PRINT("spdif in capture disable\n");												
+				audio_in_spdif_enable(0);
+			}	
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+/*
+special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
+1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
+2)PCM  output for  all audio, when pcm mode is selected by user .
+3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
+*/
+static void aml_hw_iec958_init(struct snd_pcm_substream *substream)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	_aiu_958_raw_setting_t set;
+	_aiu_958_channel_status_t chstat;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;	
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    if(buf==NULL && runtime==NULL){
+        printk("buf/0x%x runtime/0x%x\n",(unsigned )buf,(unsigned )runtime);
+        return;
+    }
+	unsigned i2s_mode,iec958_mode;	
+	unsigned start,size,sample_rate;
+	sample_rate = AUDIO_CLK_FREQ_48;
+	memset((void*)(&set), 0, sizeof(set));
+	memset((void*)(&chstat), 0, sizeof(chstat));
+	set.chan_stat = &chstat;
+	switch(runtime->rate){
+		case 192000:
+			sample_rate	=	AUDIO_CLK_FREQ_192;
+			break;
+		case 176400:
+			sample_rate	=	AUDIO_CLK_FREQ_1764;
+			break;
+		case 96000:
+			sample_rate	=	AUDIO_CLK_FREQ_96;
+			break;
+		case 88200:
+			sample_rate	=	AUDIO_CLK_FREQ_882;
+			break;
+		case 48000:
+			sample_rate	=	AUDIO_CLK_FREQ_48;
+			break;
+		case 44100:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+		case 32000:
+			sample_rate	=	AUDIO_CLK_FREQ_32;
+			break;
+		case 8000:
+			sample_rate	=	AUDIO_CLK_FREQ_8;
+			break;
+		case 11025:
+			sample_rate	=	AUDIO_CLK_FREQ_11;
+			break;
+		case 16000:
+			sample_rate	=	AUDIO_CLK_FREQ_16;
+			break;
+		case 22050:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		case 12000:
+			sample_rate	=	AUDIO_CLK_FREQ_12;
+			break;
+		case 24000:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		default:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+	};		
+	//audio_set_clk(sample_rate, AUDIO_CLK_256FS);
+	//audio_util_set_dac_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);	
+	//audio_set_i2s_clk(sample_rate, AUDIO_CLK_256FS);
+	audio_set_958_clk(sample_rate, AUDIO_CLK_256FS);
+	//audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+
+	switch(runtime->format){
+	case SNDRV_PCM_FORMAT_S32_LE:
+		i2s_mode = AIU_I2S_MODE_PCM32;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s_mode = AIU_I2S_MODE_PCM24;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		i2s_mode = AIU_I2S_MODE_PCM16;
+		break;
+	}	
+	printk("DEBUG-->call audio_set_i2s_mode()\n");
+	//audio_set_i2s_mode(i2s_mode);
+	/* case 1,raw mode enabled */
+	if(IEC958_mode_codec){
+		if(IEC958_mode_codec == 1){ //dts, use raw sync-word mode
+			iec958_mode = AIU_958_MODE_RAW;
+			printk("iec958 mode RAW\n");
+		}
+		else{ //ac3,use the same pcm mode as i2s configuration
+			iec958_mode = AIU_958_MODE_PCM_RAW;
+			printk("iec958 mode %s\n",(i2s_mode == AIU_I2S_MODE_PCM32)?"PCM32_RAW":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24_RAW":"PCM16_RAW"));
+		}
+	}
+	else{
+		if(i2s_mode == AIU_I2S_MODE_PCM32)
+				iec958_mode = AIU_958_MODE_PCM32;
+		else if(i2s_mode == AIU_I2S_MODE_PCM24)
+				iec958_mode = AIU_958_MODE_PCM24;
+		else
+				iec958_mode = AIU_958_MODE_PCM16;
+		printk("iec958 mode %s\n",(i2s_mode == AIU_I2S_MODE_PCM32)?"PCM32":((i2s_mode == AIU_I2S_MODE_PCM24)?"PCM24":"PCM16"));
+	}
+	if(iec958_mode == AIU_958_MODE_PCM16 || iec958_mode == AIU_958_MODE_PCM24 ||
+		iec958_mode == AIU_958_MODE_PCM32){
+		set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		start = buf->addr;
+		size = snd_pcm_lib_buffer_bytes(substream);
+		audio_set_958outbuf(start, size, 0);
+		//audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
+		//audio_set_aiubuf(start, size);		
+	}else{
+		set.chan_stat->chstat0_l = 0x1902;//NONE-PCM
+		set.chan_stat->chstat0_r = 0x1902;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		start = buf->addr;
+		size = snd_pcm_lib_buffer_bytes(substream);;
+		audio_set_958outbuf(start, size, (iec958_mode == AIU_958_MODE_RAW)?1:0);
+		memset((void*)buf->area,0,size);
+	}
+	printk("aiu 958 pcm buffer size %d \n",size);	
+	audio_set_958_mode(iec958_mode, &set);
+	if(IEC958_mode_codec == 4)  //dd+
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2); // 4x than i2s
+	else
+#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1	
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);//512fs divide 4 == 128fs
+#else
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 4, 2); //256fs divide 2 == 128fs
+#endif
+        if(IEC958_mode_codec == 2){
+                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3,substream);
+        }
+        else if(IEC958_mode_codec == 3){
+                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD,substream);
+        }
+        else if(IEC958_mode_codec == 4){
+                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,substream);
+        }
+        else{
+	        aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,substream);
+        }
+}
+/*
+special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
+1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
+2)PCM  output for  all audio, when pcm mode is selected by user .
+3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
+*/
+
+
+void	aml_alsa_hw_reprepare(void)
+{
+    ALSA_TRACE();
+	/* diable 958 module before call initiation */
+	audio_hw_958_enable(0);
+   if(playback_substream_handle!=0)
+  	aml_hw_iec958_init((struct snd_pcm_substream *)playback_substream_handle);
+}
+static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+
+
+static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;	
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		s->device_type = AML_AUDIO_SPDIFOUT;
+		if(playback_substream_handle != (unsigned)substream)
+			playback_substream_handle = (unsigned)substream;
+		aml_hw_iec958_init((struct snd_pcm_substream *)playback_substream_handle);		
+	}	
+	else{
+		audio_in_spdif_set_buf(runtime->dma_addr, runtime->dma_bytes*2);
+		memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
+		{
+			int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
+		}		
+		s->device_type = AML_AUDIO_SPDIFIN;
+	}	
+
+	return 0;
+}
+static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *socdai)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+	return 0;
+}
+
+static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;	
+		
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		memset((void*)runtime->dma_area,0,snd_pcm_lib_buffer_bytes(substream));
+	}
+	
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_spdif_suspend(struct snd_soc_dai *cpu_dai)
+{
+
+	return 0;
+}
+
+static int aml_dai_spdif_resume(struct snd_soc_dai *cpu_dai)
+{
+
+
+	return 0;
+}
+#else
+#define aml_spdif_suspend NULL
+#define aml_spdif_resume NULL
+#endif
+
+static struct snd_soc_dai_ops spdif_dai_ops = {
+	.set_sysclk	= aml_dai_spdif_set_sysclk,
+	.trigger	= aml_dai_spdif_trigger,
+	.prepare = aml_dai_spdif_prepare,
+	.hw_params	= aml_dai_spdif_hw_params,
+	.shutdown	= aml_dai_spdif_shutdown,
+};
+
+static struct snd_soc_dai_driver aml_spdif_dai[] = {
+	{
+		.name = "aml-spdif-dai",
+		.playback = {
+			.stream_name = "S/PDIF Playback",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = (
+					SNDRV_PCM_RATE_32000 |
+					SNDRV_PCM_RATE_44100 |
+					SNDRV_PCM_RATE_48000 |
+					SNDRV_PCM_RATE_96000),
+			.formats = SNDRV_PCM_FMTBIT_S16_LE, },
+		.capture = {
+			.stream_name = "S/PDIF Capture",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = (SNDRV_PCM_RATE_32000 |
+					SNDRV_PCM_RATE_44100 |
+					SNDRV_PCM_RATE_48000 |
+					SNDRV_PCM_RATE_96000),
+			.formats = SNDRV_PCM_FMTBIT_S16_LE, },			
+		.ops = &spdif_dai_ops,
+		.suspend = aml_dai_spdif_suspend,
+		.resume = aml_dai_spdif_resume,
+	}	
+};
+static const struct snd_soc_component_driver aml_component= {
+	.name		= "aml-spdif-dai",
+};
+static  int aml_dai_spdif_probe(struct platform_device *pdev)
+{
+	printk("aml_spdif_probe \n");
+	return snd_soc_register_component(&pdev->dev, &aml_component,
+					 aml_spdif_dai, ARRAY_SIZE(aml_spdif_dai));}
+
+static  int aml_dai_spdif_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_spdif_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-spdif-dai",
+	},
+	{},
+};
+#else
+#define amlogic_spdif_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_spdif_dai_driver = {
+	.probe	= aml_dai_spdif_probe,
+	.remove	= aml_dai_spdif_remove,
+	.driver	= {
+		.name	= "aml-spdif-dai",
+		.owner	= THIS_MODULE,
+		.of_match_table = amlogic_spdif_dai_dt_match,
+	},
+};
+
+static int __init aml_dai_spdif_init(void)
+{
+	printk("enter aml_dai_spdif_init \n");
+	return platform_driver_register(&aml_spdif_dai_driver);
+}
+module_init(aml_dai_spdif_init);
+
+static void __exit aml_dai_spdif_exit(void)
+{
+	platform_driver_unregister(&aml_spdif_dai_driver);
+}
+module_exit(aml_dai_spdif_exit);
+
+MODULE_AUTHOR("jian.xu, <jian.xu@amlogic.com>");
+MODULE_DESCRIPTION("Amlogic S/PDIF<HDMI> Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:aml-spdif");
+
+
diff --git a/sound/soc/aml/aml_spdif_dai.h b/sound/soc/aml/aml_spdif_dai.h
new file mode 100755
index 000000000000..ee5c08a5c58c
--- /dev/null
+++ b/sound/soc/aml/aml_spdif_dai.h
@@ -0,0 +1,16 @@
+/* HDMI audio stream type ID */
+#define AOUT_EVENT_IEC_60958_PCM                0x1
+#define AOUT_EVENT_RAWDATA_AC_3                 0x2
+#define AOUT_EVENT_RAWDATA_MPEG1                0x3
+#define AOUT_EVENT_RAWDATA_MP3                  0x4
+#define AOUT_EVENT_RAWDATA_MPEG2                0x5
+#define AOUT_EVENT_RAWDATA_AAC                  0x6
+#define AOUT_EVENT_RAWDATA_DTS                  0x7
+#define AOUT_EVENT_RAWDATA_ATRAC                0x8
+#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
+#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
+#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
+#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
+#define AOUT_EVENT_RAWDATA_DST                  0xD
+#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
+
-- 
2.19.0

