From 08984da80dcb0fe214e925ab5866fa86bc6549c9 Mon Sep 17 00:00:00 2001
From: xu xing <xing.xu@amlogic.com>
Date: Wed, 6 Nov 2013 10:31:12 +0800
Subject: [PATCH 1723/5965] PINCTRL:USE 3.8 subsystem.

---
 drivers/amlogic/i2c/aml_i2c.c           |   4 +-
 drivers/base/dd.c                       |   6 +-
 drivers/gpio/gpiolib-of.c               |   7 +-
 drivers/pinctrl/core.c                  | 467 ++++++++----------------
 drivers/pinctrl/core.h                  |  37 +-
 drivers/pinctrl/devicetree.c            |  24 +-
 drivers/pinctrl/pinconf-generic.c       |  24 +-
 drivers/pinctrl/pinconf.c               | 270 +-------------
 drivers/pinctrl/pinconf.h               |  10 +-
 include/linux/pinctrl/consumer.h        |   9 +-
 include/linux/pinctrl/pinconf-generic.h |   5 +-
 include/linux/pinctrl/pinconf.h         |   5 -
 include/linux/pinctrl/pinctrl.h         |   6 +-
 13 files changed, 219 insertions(+), 655 deletions(-)
 mode change 100644 => 100755 drivers/base/dd.c
 mode change 100644 => 100755 drivers/gpio/gpiolib-of.c
 mode change 100644 => 100755 drivers/pinctrl/core.c
 mode change 100644 => 100755 include/linux/pinctrl/consumer.h
 mode change 100644 => 100755 include/linux/pinctrl/pinconf-generic.h

diff --git a/drivers/amlogic/i2c/aml_i2c.c b/drivers/amlogic/i2c/aml_i2c.c
index 13d3a4fcc6ef..161372b805b8 100755
--- a/drivers/amlogic/i2c/aml_i2c.c
+++ b/drivers/amlogic/i2c/aml_i2c.c
@@ -110,6 +110,7 @@ static void aml_i2c_pinmux_master(struct aml_i2c *i2c)
 	i2c->p=devm_pinctrl_get_select(i2c->dev,i2c->master_state_name);
 	if(IS_ERR(i2c->p)){
 		printk("set i2c pinmux error\n");
+		i2c->p=NULL;
 	}
 #else
 	pinmux_set(&i2c->master_pinmux);
@@ -120,7 +121,8 @@ static void aml_i2c_pinmux_master(struct aml_i2c *i2c)
 static void aml_i2c_clr_pinmux(struct aml_i2c *i2c)
 {
 #ifdef CONFIG_OF
-	devm_pinctrl_put(i2c->p);
+	if(i2c->p)
+		devm_pinctrl_put(i2c->p);
 #else
     pinmux_clr(&i2c->master_pinmux);
 #endif
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
old mode 100644
new mode 100755
index 35fa36898916..2599229f445a
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -274,9 +274,9 @@ static int really_probe(struct device *dev, struct device_driver *drv)
 	dev->driver = drv;
 
 	/* If using pinctrl, bind pins now before probing */
-	ret = pinctrl_bind_pins(dev);
-	if (ret)
-		goto probe_failed;
+	//ret = pinctrl_bind_pins(dev);
+	//if (ret)
+		//goto probe_failed;
 
 	if (driver_sysfs_add(dev)) {
 		printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",
diff --git a/drivers/gpio/gpiolib-of.c b/drivers/gpio/gpiolib-of.c
old mode 100644
new mode 100755
index 665f9530c950..2960baefc3f8
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -203,12 +203,15 @@ static void of_gpiochip_add_pin_range(struct gpio_chip *chip)
 		if (!pctldev)
 			break;
 
+
+#if 0
 		ret = gpiochip_add_pin_range(chip,
-					     pinctrl_dev_get_devname(pctldev),
+					     pinctrl_dev_get_name(pctldev),
+					     0, /* offset in gpiochip */
 					     pinspec.args[0],
 					     pinspec.args[1],
 					     pinspec.args[2]);
-
+#endif
 		if (ret)
 			break;
 	}
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
old mode 100644
new mode 100755
index 5327f35d9b5c..6d777d4e920e
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -14,7 +14,6 @@
 #define pr_fmt(fmt) "pinctrl core: " fmt
 
 #include <linux/kernel.h>
-#include <linux/kref.h>
 #include <linux/export.h>
 #include <linux/init.h>
 #include <linux/device.h>
@@ -27,37 +26,42 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/pinctrl/machine.h>
-
-#ifdef CONFIG_GPIOLIB
-#include <asm-generic/gpio.h>
-#endif
-
 #include "core.h"
 #include "devicetree.h"
 #include "pinmux.h"
 #include "pinconf.h"
 
+/**
+ * struct pinctrl_maps - a list item containing part of the mapping table
+ * @node: mapping table list node
+ * @maps: array of mapping table entries
+ * @num_maps: the number of entries in @maps
+ */
+struct pinctrl_maps {
+	struct list_head node;
+	struct pinctrl_map const *maps;
+	unsigned num_maps;
+};
 
 static bool pinctrl_dummy_state;
 
-/* Mutex taken to protect pinctrl_list */
-DEFINE_MUTEX(pinctrl_list_mutex);
-
-/* Mutex taken to protect pinctrl_maps */
-DEFINE_MUTEX(pinctrl_maps_mutex);
-
-/* Mutex taken to protect pinctrldev_list */
-DEFINE_MUTEX(pinctrldev_list_mutex);
+/* Mutex taken by all entry points */
+DEFINE_MUTEX(pinctrl_mutex);
 
 /* Global list of pin control devices (struct pinctrl_dev) */
-static LIST_HEAD(pinctrldev_list);
+LIST_HEAD(pinctrldev_list);
 
 /* List of pin controller handles (struct pinctrl) */
 static LIST_HEAD(pinctrl_list);
 
 /* List of pinctrl maps (struct pinctrl_maps) */
-LIST_HEAD(pinctrl_maps);
+static LIST_HEAD(pinctrl_maps);
 
+#define for_each_maps(_maps_node_, _i_, _map_) \
+	list_for_each_entry(_maps_node_, &pinctrl_maps, node) \
+		for (_i_ = 0, _map_ = &_maps_node_->maps[_i_]; \
+			_i_ < _maps_node_->num_maps; \
+			_i_++, _map_ = &_maps_node_->maps[_i_])
 
 /**
  * pinctrl_provide_dummies() - indicate if pinctrl provides dummy state support
@@ -79,12 +83,6 @@ const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev)
 }
 EXPORT_SYMBOL_GPL(pinctrl_dev_get_name);
 
-const char *pinctrl_dev_get_devname(struct pinctrl_dev *pctldev)
-{
-	return dev_name(pctldev->dev);
-}
-EXPORT_SYMBOL_GPL(pinctrl_dev_get_devname);
-
 void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev)
 {
 	return pctldev->driver_data;
@@ -117,23 +115,6 @@ struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *devname)
 	return found ? pctldev : NULL;
 }
 
-struct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np)
-{
-	struct pinctrl_dev *pctldev;
-
-	mutex_lock(&pinctrldev_list_mutex);
-
-	list_for_each_entry(pctldev, &pinctrldev_list, node)
-		if (pctldev->dev->of_node == np) {
-			mutex_unlock(&pinctrldev_list_mutex);
-			return pctldev;
-		}
-
-	mutex_unlock(&pinctrldev_list_mutex);
-
-	return NULL;
-}
-
 /**
  * pin_get_from_name() - look up a pin number from a name
  * @pctldev: the pin control device to lookup the pin on
@@ -193,9 +174,9 @@ bool pin_is_valid(struct pinctrl_dev *pctldev, int pin)
 	if (pin < 0)
 		return false;
 
-	mutex_lock(&pctldev->mutex);
+	mutex_lock(&pinctrl_mutex);
 	pindesc = pin_desc_get(pctldev, pin);
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return pindesc != NULL;
 }
@@ -292,56 +273,17 @@ pinctrl_match_gpio_range(struct pinctrl_dev *pctldev, unsigned gpio)
 {
 	struct pinctrl_gpio_range *range = NULL;
 
-	mutex_lock(&pctldev->mutex);
 	/* Loop over the ranges */
 	list_for_each_entry(range, &pctldev->gpio_ranges, node) {
 		/* Check if we're in the valid range */
 		if (gpio >= range->base &&
 		    gpio < range->base + range->npins) {
-			mutex_unlock(&pctldev->mutex);
 			return range;
 		}
 	}
-	mutex_unlock(&pctldev->mutex);
-	return NULL;
-}
-
-/**
- * pinctrl_ready_for_gpio_range() - check if other GPIO pins of
- * the same GPIO chip are in range
- * @gpio: gpio pin to check taken from the global GPIO pin space
- *
- * This function is complement of pinctrl_match_gpio_range(). If the return
- * value of pinctrl_match_gpio_range() is NULL, this function could be used
- * to check whether pinctrl device is ready or not. Maybe some GPIO pins
- * of the same GPIO chip don't have back-end pinctrl interface.
- * If the return value is true, it means that pinctrl device is ready & the
- * certain GPIO pin doesn't have back-end pinctrl device. If the return value
- * is false, it means that pinctrl device may not be ready.
- */
-#ifdef CONFIG_GPIOLIB
-static bool pinctrl_ready_for_gpio_range(unsigned gpio)
-{
-	struct pinctrl_dev *pctldev;
-	struct pinctrl_gpio_range *range = NULL;
-	struct gpio_chip *chip = gpio_to_chip(gpio);
 
-	/* Loop over the pin controllers */
-	list_for_each_entry(pctldev, &pinctrldev_list, node) {
-		/* Loop over the ranges */
-		list_for_each_entry(range, &pctldev->gpio_ranges, node) {
-			/* Check if any gpio range overlapped with gpio chip */
-			if (range->base + range->npins - 1 < chip->base ||
-			    range->base > chip->base + chip->ngpio - 1)
-				continue;
-			return true;
-		}
-	}
-	return false;
+	return NULL;
 }
-#else
-static bool pinctrl_ready_for_gpio_range(unsigned gpio) { return true; }
-#endif
 
 /**
  * pinctrl_get_device_gpio_range() - find device for GPIO range
@@ -386,9 +328,9 @@ static int pinctrl_get_device_gpio_range(unsigned gpio,
 void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 			    struct pinctrl_gpio_range *range)
 {
-	mutex_lock(&pctldev->mutex);
+	mutex_lock(&pinctrl_mutex);
 	list_add_tail(&range->node, &pctldev->gpio_ranges);
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 }
 EXPORT_SYMBOL_GPL(pinctrl_add_gpio_range);
 
@@ -406,25 +348,17 @@ EXPORT_SYMBOL_GPL(pinctrl_add_gpio_ranges);
 struct pinctrl_dev *pinctrl_find_and_add_gpio_range(const char *devname,
 		struct pinctrl_gpio_range *range)
 {
-	struct pinctrl_dev *pctldev;
-
-	mutex_lock(&pinctrldev_list_mutex);
-
-	pctldev = get_pinctrl_dev_from_devname(devname);
+	struct pinctrl_dev *pctldev = get_pinctrl_dev_from_devname(devname);
 
 	/*
 	 * If we can't find this device, let's assume that is because
 	 * it has not probed yet, so the driver trying to register this
 	 * range need to defer probing.
 	 */
-	if (!pctldev) {
-		mutex_unlock(&pinctrldev_list_mutex);
+	if (!pctldev)
 		return ERR_PTR(-EPROBE_DEFER);
-	}
-	pinctrl_add_gpio_range(pctldev, range);
-
-	mutex_unlock(&pinctrldev_list_mutex);
 
+	pinctrl_add_gpio_range(pctldev, range);
 	return pctldev;
 }
 EXPORT_SYMBOL_GPL(pinctrl_find_and_add_gpio_range);
@@ -440,17 +374,14 @@ pinctrl_find_gpio_range_from_pin(struct pinctrl_dev *pctldev,
 {
 	struct pinctrl_gpio_range *range = NULL;
 
-	mutex_lock(&pctldev->mutex);
 	/* Loop over the ranges */
 	list_for_each_entry(range, &pctldev->gpio_ranges, node) {
 		/* Check if we're in the valid range */
 		if (pin >= range->pin_base &&
 		    pin < range->pin_base + range->npins) {
-			mutex_unlock(&pctldev->mutex);
 			return range;
 		}
 	}
-	mutex_unlock(&pctldev->mutex);
 
 	return NULL;
 }
@@ -464,9 +395,9 @@ EXPORT_SYMBOL_GPL(pinctrl_find_gpio_range_from_pin);
 void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
 			       struct pinctrl_gpio_range *range)
 {
-	mutex_lock(&pctldev->mutex);
+	mutex_lock(&pinctrl_mutex);
 	list_del(&range->node);
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 }
 EXPORT_SYMBOL_GPL(pinctrl_remove_gpio_range);
 
@@ -517,13 +448,11 @@ int pinctrl_request_gpio(unsigned gpio)
 	int ret;
 	int pin;
 
-	mutex_lock(&pinctrldev_list_mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret) {
-		if (pinctrl_ready_for_gpio_range(gpio))
-			ret = 0;
-		mutex_unlock(&pinctrldev_list_mutex);
+		mutex_unlock(&pinctrl_mutex);
 		return ret;
 	}
 
@@ -532,7 +461,7 @@ int pinctrl_request_gpio(unsigned gpio)
 
 	ret = pinmux_request_gpio(pctldev, range, pin, gpio);
 
-	mutex_unlock(&pinctrldev_list_mutex);
+	mutex_unlock(&pinctrl_mutex);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(pinctrl_request_gpio);
@@ -552,22 +481,20 @@ void pinctrl_free_gpio(unsigned gpio)
 	int ret;
 	int pin;
 
-	mutex_lock(&pinctrldev_list_mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret) {
-		mutex_unlock(&pinctrldev_list_mutex);
+		mutex_unlock(&pinctrl_mutex);
 		return;
 	}
-	mutex_lock(&pctldev->mutex);
 
 	/* Convert to the pin controllers number space */
 	pin = gpio - range->base + range->pin_base;
 
 	pinmux_free_gpio(pctldev, pin, range);
 
-	mutex_unlock(&pctldev->mutex);
-	mutex_unlock(&pinctrldev_list_mutex);
+	mutex_unlock(&pinctrl_mutex);
 }
 EXPORT_SYMBOL_GPL(pinctrl_free_gpio);
 
@@ -578,24 +505,14 @@ static int pinctrl_gpio_direction(unsigned gpio, bool input)
 	int ret;
 	int pin;
 
-	mutex_lock(&pinctrldev_list_mutex);
-
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
-	if (ret) {
-		mutex_unlock(&pinctrldev_list_mutex);
+	if (ret)
 		return ret;
-	}
-
-	mutex_lock(&pctldev->mutex);
 
 	/* Convert to the pin controllers number space */
 	pin = gpio - range->base + range->pin_base;
-	ret = pinmux_gpio_direction(pctldev, range, pin, input);
-
-	mutex_unlock(&pctldev->mutex);
-	mutex_unlock(&pinctrldev_list_mutex);
 
-	return ret;
+	return pinmux_gpio_direction(pctldev, range, pin, input);
 }
 
 /**
@@ -608,7 +525,11 @@ static int pinctrl_gpio_direction(unsigned gpio, bool input)
  */
 int pinctrl_gpio_direction_input(unsigned gpio)
 {
-	return pinctrl_gpio_direction(gpio, true);
+	int ret;
+	mutex_lock(&pinctrl_mutex);
+	ret = pinctrl_gpio_direction(gpio, true);
+	mutex_unlock(&pinctrl_mutex);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);
 
@@ -622,7 +543,11 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);
  */
 int pinctrl_gpio_direction_output(unsigned gpio)
 {
-	return pinctrl_gpio_direction(gpio, false);
+	int ret;
+	mutex_lock(&pinctrl_mutex);
+	ret = pinctrl_gpio_direction(gpio, false);
+	mutex_unlock(&pinctrl_mutex);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
 
@@ -684,16 +609,13 @@ static int add_setting(struct pinctrl *p, struct pinctrl_map const *map)
 
 	setting->pctldev = get_pinctrl_dev_from_devname(map->ctrl_dev_name);
 	if (setting->pctldev == NULL) {
+		dev_info(p->dev, "unknown pinctrl device %s in map entry, deferring probe",
+			map->ctrl_dev_name);
 		kfree(setting);
-		/* Do not defer probing of hogs (circular loop) */
-		if (!strcmp(map->ctrl_dev_name, map->dev_name))
-			return -ENODEV;
 		/*
 		 * OK let us guess that the driver is not there yet, and
 		 * let's defer obtaining this pinctrl handle to later...
 		 */
-		dev_info(p->dev, "unknown pinctrl device %s in map entry, deferring probe",
-			map->ctrl_dev_name);
 		return -EPROBE_DEFER;
 	}
 
@@ -725,18 +647,14 @@ static struct pinctrl *find_pinctrl(struct device *dev)
 {
 	struct pinctrl *p;
 
-	mutex_lock(&pinctrl_list_mutex);
 	list_for_each_entry(p, &pinctrl_list, node)
-		if (p->dev == dev) {
-			mutex_unlock(&pinctrl_list_mutex);
+		if (p->dev == dev)
 			return p;
-		}
 
-	mutex_unlock(&pinctrl_list_mutex);
 	return NULL;
 }
 
-static void pinctrl_free(struct pinctrl *p, bool inlist);
+static void pinctrl_put_locked(struct pinctrl *p, bool inlist);
 
 static struct pinctrl *create_pinctrl(struct device *dev)
 {
@@ -769,7 +687,6 @@ static struct pinctrl *create_pinctrl(struct device *dev)
 
 	devname = dev_name(dev);
 
-	mutex_lock(&pinctrl_maps_mutex);
 	/* Iterate over the pin control maps to locate the right ones */
 	for_each_maps(maps_node, i, map) {
 		/* Map must be for this device */
@@ -777,34 +694,11 @@ static struct pinctrl *create_pinctrl(struct device *dev)
 			continue;
 
 		ret = add_setting(p, map);
-		/*
-		 * At this point the adding of a setting may:
-		 *
-		 * - Defer, if the pinctrl device is not yet available
-		 * - Fail, if the pinctrl device is not yet available,
-		 *   AND the setting is a hog. We cannot defer that, since
-		 *   the hog will kick in immediately after the device
-		 *   is registered.
-		 *
-		 * If the error returned was not -EPROBE_DEFER then we
-		 * accumulate the errors to see if we end up with
-		 * an -EPROBE_DEFER later, as that is the worst case.
-		 */
-		if (ret == -EPROBE_DEFER) {
-			pinctrl_free(p, false);
-			mutex_unlock(&pinctrl_maps_mutex);
+		if (ret < 0) {
+			pinctrl_put_locked(p, false);
 			return ERR_PTR(ret);
 		}
 	}
-	mutex_unlock(&pinctrl_maps_mutex);
-
-	if (ret < 0) {
-		/* If some other error than deferral occured, return here */
-		pinctrl_free(p, false);
-		return ERR_PTR(ret);
-	}
-
-	kref_init(&p->users);
 
 	/* Add the pinctrl handle to the global list */
 	list_add_tail(&p->node, &pinctrl_list);
@@ -812,60 +706,57 @@ static struct pinctrl *create_pinctrl(struct device *dev)
 	return p;
 }
 
-/**
- * pinctrl_get() - retrieves the pinctrl handle for a device
- * @dev: the device to obtain the handle for
- */
-struct pinctrl *pinctrl_get(struct device *dev)
+static struct pinctrl *pinctrl_get_locked(struct device *dev)
 {
 	struct pinctrl *p;
 
 	if (WARN_ON(!dev))
 		return ERR_PTR(-EINVAL);
 
-	/*
-	 * See if somebody else (such as the device core) has already
-	 * obtained a handle to the pinctrl for this device. In that case,
-	 * return another pointer to it.
-	 */
 	p = find_pinctrl(dev);
 	if (p != NULL) {
-		dev_dbg(dev, "obtain a copy of previously claimed pinctrl\n");
-		kref_get(&p->users);
-		return p;
+		return ERR_PTR(-EBUSY);
 	}
 
 	return create_pinctrl(dev);
 }
-EXPORT_SYMBOL_GPL(pinctrl_get);
 
-static void pinctrl_free_setting(bool disable_setting,
-				 struct pinctrl_setting *setting)
+/**
+ * pinctrl_get() - retrieves the pinctrl handle for a device
+ * @dev: the device to obtain the handle for
+ */
+struct pinctrl *pinctrl_get(struct device *dev)
 {
-	switch (setting->type) {
-	case PIN_MAP_TYPE_MUX_GROUP:
-		if (disable_setting)
-			pinmux_disable_setting(setting);
-		pinmux_free_setting(setting);
-		break;
-	case PIN_MAP_TYPE_CONFIGS_PIN:
-	case PIN_MAP_TYPE_CONFIGS_GROUP:
-		pinconf_free_setting(setting);
-		break;
-	default:
-		break;
-	}
+	struct pinctrl *p;
+
+	mutex_lock(&pinctrl_mutex);
+	p = pinctrl_get_locked(dev);
+	mutex_unlock(&pinctrl_mutex);
+
+	return p;
 }
+EXPORT_SYMBOL_GPL(pinctrl_get);
 
-static void pinctrl_free(struct pinctrl *p, bool inlist)
+static void pinctrl_put_locked(struct pinctrl *p, bool inlist)
 {
 	struct pinctrl_state *state, *n1;
 	struct pinctrl_setting *setting, *n2;
 
-	mutex_lock(&pinctrl_list_mutex);
 	list_for_each_entry_safe(state, n1, &p->states, node) {
 		list_for_each_entry_safe(setting, n2, &state->settings, node) {
-			pinctrl_free_setting(state == p->state, setting);
+			switch (setting->type) {
+			case PIN_MAP_TYPE_MUX_GROUP:
+				if (state == p->state)
+					pinmux_disable_setting(setting);
+				pinmux_free_setting(setting);
+				break;
+			case PIN_MAP_TYPE_CONFIGS_PIN:
+			case PIN_MAP_TYPE_CONFIGS_GROUP:
+				pinconf_free_setting(setting);
+				break;
+			default:
+				break;
+			}
 			list_del(&setting->node);
 			kfree(setting);
 		}
@@ -878,37 +769,22 @@ static void pinctrl_free(struct pinctrl *p, bool inlist)
 	if (inlist)
 		list_del(&p->node);
 	kfree(p);
-	mutex_unlock(&pinctrl_list_mutex);
-}
-
-/**
- * pinctrl_release() - release the pinctrl handle
- * @kref: the kref in the pinctrl being released
- */
-static void pinctrl_release(struct kref *kref)
-{
-	struct pinctrl *p = container_of(kref, struct pinctrl, users);
-
-	pinctrl_free(p, true);
 }
 
 /**
- * pinctrl_put() - decrease use count on a previously claimed pinctrl handle
+ * pinctrl_put() - release a previously claimed pinctrl handle
  * @p: the pinctrl handle to release
  */
 void pinctrl_put(struct pinctrl *p)
 {
-	kref_put(&p->users, pinctrl_release);
+	mutex_lock(&pinctrl_mutex);
+	pinctrl_put_locked(p, true);
+	mutex_unlock(&pinctrl_mutex);
 }
 EXPORT_SYMBOL_GPL(pinctrl_put);
 
-/**
- * pinctrl_lookup_state() - retrieves a state handle from a pinctrl handle
- * @p: the pinctrl handle to retrieve the state from
- * @name: the state name to retrieve
- */
-struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p,
-						 const char *name)
+static struct pinctrl_state *pinctrl_lookup_state_locked(struct pinctrl *p,
+							 const char *name)
 {
 	struct pinctrl_state *state;
 
@@ -925,17 +801,28 @@ struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p,
 
 	return state;
 }
-EXPORT_SYMBOL_GPL(pinctrl_lookup_state);
 
 /**
- * pinctrl_select_state() - select/activate/program a pinctrl state to HW
- * @p: the pinctrl handle for the device that requests configuration
- * @state: the state handle to select/activate/program
+ * pinctrl_lookup_state() - retrieves a state handle from a pinctrl handle
+ * @p: the pinctrl handle to retrieve the state from
+ * @name: the state name to retrieve
  */
-int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
+struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p, const char *name)
+{
+	struct pinctrl_state *s;
+
+	mutex_lock(&pinctrl_mutex);
+	s = pinctrl_lookup_state_locked(p, name);
+	mutex_unlock(&pinctrl_mutex);
+
+	return s;
+}
+EXPORT_SYMBOL_GPL(pinctrl_lookup_state);
+
+static int pinctrl_select_state_locked(struct pinctrl *p,
+				       struct pinctrl_state *state)
 {
 	struct pinctrl_setting *setting, *setting2;
-	struct pinctrl_state *old_state = p->state;
 	int ret;
 
 	if (p->state == state)
@@ -969,7 +856,7 @@ int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
 		}
 	}
 
-	p->state = NULL;
+	p->state = state;
 
 	/* Apply all the settings for the new state */
 	list_for_each_entry(setting, &state->settings, node) {
@@ -985,36 +872,27 @@ int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
 			ret = -EINVAL;
 			break;
 		}
-
 		if (ret < 0) {
-			goto unapply_new_state;
+			/* FIXME: Difficult to return to prev state */
+			return ret;
 		}
 	}
 
-	p->state = state;
-
 	return 0;
+}
 
-unapply_new_state:
-	dev_err(p->dev, "Error applying setting, reverse things back\n");
-
-	list_for_each_entry(setting2, &state->settings, node) {
-		if (&setting2->node == &setting->node)
-			break;
-		/*
-		 * All we can do here is pinmux_disable_setting.
-		 * That means that some pins are muxed differently now
-		 * than they were before applying the setting (We can't
-		 * "unmux a pin"!), but it's not a big deal since the pins
-		 * are free to be muxed by another apply_setting.
-		 */
-		if (setting2->type == PIN_MAP_TYPE_MUX_GROUP)
-			pinmux_disable_setting(setting2);
-	}
+/**
+ * pinctrl_select() - select/activate/program a pinctrl state to HW
+ * @p: the pinctrl handle for the device that requests configuratio
+ * @state: the state handle to select/activate/program
+ */
+int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
+{
+	int ret;
 
-	/* There's no infinite recursive loop here because p->state is NULL */
-	if (old_state)
-		pinctrl_select_state(p, old_state);
+	mutex_lock(&pinctrl_mutex);
+	ret = pinctrl_select_state_locked(p, state);
+	mutex_unlock(&pinctrl_mutex);
 
 	return ret;
 }
@@ -1069,8 +947,9 @@ static int devm_pinctrl_match(struct device *dev, void *res, void *data)
  */
 void devm_pinctrl_put(struct pinctrl *p)
 {
-	WARN_ON(devres_release(p->dev, devm_pinctrl_release,
+	WARN_ON(devres_destroy(p->dev, devm_pinctrl_release,
 			       devm_pinctrl_match, p));
+	pinctrl_put(p);
 }
 EXPORT_SYMBOL_GPL(devm_pinctrl_put);
 
@@ -1144,10 +1023,10 @@ int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
 	}
 
 	if (!locked)
-		mutex_lock(&pinctrl_maps_mutex);
+		mutex_lock(&pinctrl_mutex);
 	list_add_tail(&maps_node->node, &pinctrl_maps);
 	if (!locked)
-		mutex_unlock(&pinctrl_maps_mutex);
+		mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1169,41 +1048,15 @@ void pinctrl_unregister_map(struct pinctrl_map const *map)
 {
 	struct pinctrl_maps *maps_node;
 
-	mutex_lock(&pinctrl_maps_mutex);
 	list_for_each_entry(maps_node, &pinctrl_maps, node) {
 		if (maps_node->maps == map) {
 			list_del(&maps_node->node);
-			mutex_unlock(&pinctrl_maps_mutex);
+			kfree(maps_node);
 			return;
 		}
 	}
-	mutex_unlock(&pinctrl_maps_mutex);
 }
 
-/**
- * pinctrl_force_sleep() - turn a given controller device into sleep state
- * @pctldev: pin controller device
- */
-int pinctrl_force_sleep(struct pinctrl_dev *pctldev)
-{
-	if (!IS_ERR(pctldev->p) && !IS_ERR(pctldev->hog_sleep))
-		return pinctrl_select_state(pctldev->p, pctldev->hog_sleep);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(pinctrl_force_sleep);
-
-/**
- * pinctrl_force_default() - turn a given controller device into default state
- * @pctldev: pin controller device
- */
-int pinctrl_force_default(struct pinctrl_dev *pctldev)
-{
-	if (!IS_ERR(pctldev->p) && !IS_ERR(pctldev->hog_default))
-		return pinctrl_select_state(pctldev->p, pctldev->hog_default);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(pinctrl_force_default);
-
 #ifdef CONFIG_DEBUG_FS
 
 static int pinctrl_pins_show(struct seq_file *s, void *what)
@@ -1214,7 +1067,7 @@ static int pinctrl_pins_show(struct seq_file *s, void *what)
 
 	seq_printf(s, "registered pins: %d\n", pctldev->desc->npins);
 
-	mutex_lock(&pctldev->mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
@@ -1236,7 +1089,7 @@ static int pinctrl_pins_show(struct seq_file *s, void *what)
 		seq_puts(s, "\n");
 	}
 
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1247,9 +1100,8 @@ static int pinctrl_groups_show(struct seq_file *s, void *what)
 	const struct pinctrl_ops *ops = pctldev->desc->pctlops;
 	unsigned ngroups, selector = 0;
 
-	mutex_lock(&pctldev->mutex);
-
 	ngroups = ops->get_groups_count(pctldev);
+	mutex_lock(&pinctrl_mutex);
 
 	seq_puts(s, "registered pin groups:\n");
 	while (selector < ngroups) {
@@ -1270,7 +1122,7 @@ static int pinctrl_groups_show(struct seq_file *s, void *what)
 			for (i = 0; i < num_pins; i++) {
 				pname = pin_get_name(pctldev, pins[i]);
 				if (WARN_ON(!pname)) {
-					mutex_unlock(&pctldev->mutex);
+					mutex_unlock(&pinctrl_mutex);
 					return -EINVAL;
 				}
 				seq_printf(s, "pin %d (%s)\n", pins[i], pname);
@@ -1280,7 +1132,7 @@ static int pinctrl_groups_show(struct seq_file *s, void *what)
 		selector++;
 	}
 
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1292,7 +1144,7 @@ static int pinctrl_gpioranges_show(struct seq_file *s, void *what)
 
 	seq_puts(s, "GPIO ranges handled:\n");
 
-	mutex_lock(&pctldev->mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	/* Loop over the ranges */
 	list_for_each_entry(range, &pctldev->gpio_ranges, node) {
@@ -1303,7 +1155,7 @@ static int pinctrl_gpioranges_show(struct seq_file *s, void *what)
 			   (range->pin_base + range->npins - 1));
 	}
 
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1314,7 +1166,7 @@ static int pinctrl_devices_show(struct seq_file *s, void *what)
 
 	seq_puts(s, "name [pinmux] [pinconf]\n");
 
-	mutex_lock(&pinctrldev_list_mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	list_for_each_entry(pctldev, &pinctrldev_list, node) {
 		seq_printf(s, "%s ", pctldev->desc->name);
@@ -1329,7 +1181,7 @@ static int pinctrl_devices_show(struct seq_file *s, void *what)
 		seq_puts(s, "\n");
 	}
 
-	mutex_unlock(&pinctrldev_list_mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1358,7 +1210,8 @@ static int pinctrl_maps_show(struct seq_file *s, void *what)
 
 	seq_puts(s, "Pinctrl maps:\n");
 
-	mutex_lock(&pinctrl_maps_mutex);
+	mutex_lock(&pinctrl_mutex);
+
 	for_each_maps(maps_node, i, map) {
 		seq_printf(s, "device %s\nstate %s\ntype %s (%d)\n",
 			   map->dev_name, map->name, map_type(map->type),
@@ -1382,7 +1235,8 @@ static int pinctrl_maps_show(struct seq_file *s, void *what)
 
 		seq_printf(s, "\n");
 	}
-	mutex_unlock(&pinctrl_maps_mutex);
+
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1395,7 +1249,7 @@ static int pinctrl_show(struct seq_file *s, void *what)
 
 	seq_puts(s, "Requested pin control handlers their pinmux maps:\n");
 
-	mutex_lock(&pinctrl_list_mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	list_for_each_entry(p, &pinctrl_list, node) {
 		seq_printf(s, "device: %s current state: %s\n",
@@ -1427,7 +1281,7 @@ static int pinctrl_show(struct seq_file *s, void *what)
 		}
 	}
 
-	mutex_unlock(&pinctrl_list_mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -1613,7 +1467,6 @@ struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
 	INIT_RADIX_TREE(&pctldev->pin_desc_tree, GFP_KERNEL);
 	INIT_LIST_HEAD(&pctldev->gpio_ranges);
 	pctldev->dev = dev;
-	mutex_init(&pctldev->mutex);
 
 	/* check core ops for sanity */
 	if (pinctrl_check_ops(pctldev)) {
@@ -1643,37 +1496,31 @@ struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
 		goto out_err;
 	}
 
-	mutex_lock(&pinctrldev_list_mutex);
-	list_add_tail(&pctldev->node, &pinctrldev_list);
-	mutex_unlock(&pinctrldev_list_mutex);
+	mutex_lock(&pinctrl_mutex);
 
-	pctldev->p = pinctrl_get(pctldev->dev);
+	list_add_tail(&pctldev->node, &pinctrldev_list);
 
+	pctldev->p = pinctrl_get_locked(pctldev->dev);
 	if (!IS_ERR(pctldev->p)) {
-		pctldev->hog_default =
-			pinctrl_lookup_state(pctldev->p, PINCTRL_STATE_DEFAULT);
-		if (IS_ERR(pctldev->hog_default)) {
+		struct pinctrl_state *s =
+			pinctrl_lookup_state_locked(pctldev->p,
+						    PINCTRL_STATE_DEFAULT);
+		if (IS_ERR(s)) {
 			dev_dbg(dev, "failed to lookup the default state\n");
 		} else {
-			if (pinctrl_select_state(pctldev->p,
-						pctldev->hog_default))
+			if (pinctrl_select_state_locked(pctldev->p, s))
 				dev_err(dev,
 					"failed to select default state\n");
 		}
-
-		pctldev->hog_sleep =
-			pinctrl_lookup_state(pctldev->p,
-						    PINCTRL_STATE_SLEEP);
-		if (IS_ERR(pctldev->hog_sleep))
-			dev_dbg(dev, "failed to lookup the sleep state\n");
 	}
 
+	mutex_unlock(&pinctrl_mutex);
+
 	pinctrl_init_device_debugfs(pctldev);
 
 	return pctldev;
 
 out_err:
-	mutex_destroy(&pctldev->mutex);
 	kfree(pctldev);
 	return NULL;
 }
@@ -1691,13 +1538,12 @@ void pinctrl_unregister(struct pinctrl_dev *pctldev)
 	if (pctldev == NULL)
 		return;
 
-	mutex_lock(&pinctrldev_list_mutex);
-	mutex_lock(&pctldev->mutex);
-
 	pinctrl_remove_device_debugfs(pctldev);
 
+	mutex_lock(&pinctrl_mutex);
+
 	if (!IS_ERR(pctldev->p))
-		pinctrl_put(pctldev->p);
+		pinctrl_put_locked(pctldev->p, true);
 
 	/* TODO: check that no pinmuxes are still active? */
 	list_del(&pctldev->node);
@@ -1708,10 +1554,9 @@ void pinctrl_unregister(struct pinctrl_dev *pctldev)
 	list_for_each_entry_safe(range, n, &pctldev->gpio_ranges, node)
 		list_del(&range->node);
 
-	mutex_unlock(&pctldev->mutex);
-	mutex_destroy(&pctldev->mutex);
 	kfree(pctldev);
-	mutex_unlock(&pinctrldev_list_mutex);
+
+	mutex_unlock(&pinctrl_mutex);
 }
 EXPORT_SYMBOL_GPL(pinctrl_unregister);
 
diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 75476b3d87da..12f5694f3d5d 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -9,7 +9,6 @@
  * License terms: GNU General Public License (GPL) version 2
  */
 
-#include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/radix-tree.h>
 #include <linux/pinctrl/pinconf.h>
@@ -31,9 +30,6 @@ struct pinctrl_gpio_range;
  * @driver_data: driver data for drivers registering to the pin controller
  *	subsystem
  * @p: result of pinctrl_get() for this device
- * @hog_default: default state for pins hogged by this device
- * @hog_sleep: sleep state for pins hogged by this device
- * @mutex: mutex taken on each pin controller specific action
  * @device_root: debugfs root for this device
  */
 struct pinctrl_dev {
@@ -45,9 +41,6 @@ struct pinctrl_dev {
 	struct module *owner;
 	void *driver_data;
 	struct pinctrl *p;
-	struct pinctrl_state *hog_default;
-	struct pinctrl_state *hog_sleep;
-	struct mutex mutex;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *device_root;
 #endif
@@ -61,7 +54,6 @@ struct pinctrl_dev {
  * @state: the current state
  * @dt_maps: the mapping table chunks dynamically parsed from device tree for
  *	this device, if any
- * @users: reference count
  */
 struct pinctrl {
 	struct list_head node;
@@ -69,12 +61,11 @@ struct pinctrl {
 	struct list_head states;
 	struct pinctrl_state *state;
 	struct list_head dt_maps;
-	struct kref users;
 };
 
 /**
  * struct pinctrl_state - a pinctrl state for a device
- * @node: list node for struct pinctrl's @states field
+ * @node: list not for struct pinctrl's @states field
  * @name: the name of this state
  * @settings: a list of settings for this state
  */
@@ -157,20 +148,7 @@ struct pin_desc {
 #endif
 };
 
-/**
- * struct pinctrl_maps - a list item containing part of the mapping table
- * @node: mapping table list node
- * @maps: array of mapping table entries
- * @num_maps: the number of entries in @maps
- */
-struct pinctrl_maps {
-	struct list_head node;
-	struct pinctrl_map const *maps;
-	unsigned num_maps;
-};
-
 struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *dev_name);
-struct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np);
 int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name);
 const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin);
 int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
@@ -186,14 +164,5 @@ int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
 			 bool dup, bool locked);
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
-extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
-extern int pinctrl_force_default(struct pinctrl_dev *pctldev);
-
-extern struct mutex pinctrl_maps_mutex;
-extern struct list_head pinctrl_maps;
-
-#define for_each_maps(_maps_node_, _i_, _map_) \
-	list_for_each_entry(_maps_node_, &pinctrl_maps, node) \
-		for (_i_ = 0, _map_ = &_maps_node_->maps[_i_]; \
-			_i_ < _maps_node_->num_maps; \
-			_i_++, _map_ = &_maps_node_->maps[_i_])
+extern struct mutex pinctrl_mutex;
+extern struct list_head pinctrldev_list;
diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 340fb4e6c600..fe2d1af7cfa0 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -41,7 +41,7 @@ static void dt_free_map(struct pinctrl_dev *pctldev,
 		     struct pinctrl_map *map, unsigned num_maps)
 {
 	if (pctldev) {
-		const struct pinctrl_ops *ops = pctldev->desc->pctlops;
+		struct pinctrl_ops *ops = pctldev->desc->pctlops;
 		ops->dt_free_map(pctldev, map, num_maps);
 	} else {
 		/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */
@@ -95,11 +95,22 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	return pinctrl_register_map(map, num_maps, false, true);
 }
 
+static struct pinctrl_dev *find_pinctrl_by_of_node(struct device_node *np)
+{
+	struct pinctrl_dev *pctldev;
+
+	list_for_each_entry(pctldev, &pinctrldev_list, node)
+		if (pctldev->dev->of_node == np)
+			return pctldev;
+
+	return NULL;
+}
+
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 {
 	struct pinctrl_dev *pctldev;
 
-	pctldev = get_pinctrl_dev_from_of_node(np);
+	pctldev = find_pinctrl_by_of_node(np);
 	if (!pctldev)
 		return NULL;
 
@@ -111,7 +122,7 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 {
 	struct device_node *np_pctldev;
 	struct pinctrl_dev *pctldev;
-	const struct pinctrl_ops *ops;
+	struct pinctrl_ops *ops;
 	int ret;
 	struct pinctrl_map *map;
 	unsigned num_maps;
@@ -127,14 +138,9 @@ static int dt_to_map_one_config(struct pinctrl *p, const char *statename,
 			/* OK let's just assume this will appear later then */
 			return -EPROBE_DEFER;
 		}
-		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
+		pctldev = find_pinctrl_by_of_node(np_pctldev);
 		if (pctldev)
 			break;
-		/* Do not defer probing of hogs (circular loop) */
-		if (np_pctldev == p->dev->of_node) {
-			of_node_put(np_pctldev);
-			return -ENODEV;
-		}
 	}
 	of_node_put(np_pctldev);
 
diff --git a/drivers/pinctrl/pinconf-generic.c b/drivers/pinctrl/pinconf-generic.c
index 2ad5a8d337b5..833a36458157 100644
--- a/drivers/pinctrl/pinconf-generic.c
+++ b/drivers/pinctrl/pinconf-generic.c
@@ -12,7 +12,6 @@
 #define pr_fmt(fmt) "generic pinconfig core: " fmt
 
 #include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/slab.h>
@@ -34,7 +33,7 @@ struct pin_config_item {
 
 #define PCONFDUMP(a, b, c) { .param = a, .display = b, .format = c }
 
-static struct pin_config_item conf_items[] = {
+struct pin_config_item conf_items[] = {
 	PCONFDUMP(PIN_CONFIG_BIAS_DISABLE, "input bias disabled", NULL),
 	PCONFDUMP(PIN_CONFIG_BIAS_HIGH_IMPEDANCE, "input bias high impedance", NULL),
 	PCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, "input bias pull up", NULL),
@@ -42,13 +41,11 @@ static struct pin_config_item conf_items[] = {
 	PCONFDUMP(PIN_CONFIG_DRIVE_PUSH_PULL, "output drive push pull", NULL),
 	PCONFDUMP(PIN_CONFIG_DRIVE_OPEN_DRAIN, "output drive open drain", NULL),
 	PCONFDUMP(PIN_CONFIG_DRIVE_OPEN_SOURCE, "output drive open source", NULL),
-	PCONFDUMP(PIN_CONFIG_INPUT_SCHMITT_ENABLE, "input schmitt enabled", NULL),
+	PCONFDUMP(PIN_CONFIG_INPUT_SCHMITT_DISABLE, "input schmitt disabled", NULL),
 	PCONFDUMP(PIN_CONFIG_INPUT_SCHMITT, "input schmitt trigger", NULL),
 	PCONFDUMP(PIN_CONFIG_INPUT_DEBOUNCE, "input debounce", "time units"),
 	PCONFDUMP(PIN_CONFIG_POWER_SOURCE, "pin power source", "selector"),
-	PCONFDUMP(PIN_CONFIG_SLEW_RATE, "slew rate", NULL),
 	PCONFDUMP(PIN_CONFIG_LOW_POWER_MODE, "pin low power", "mode"),
-	PCONFDUMP(PIN_CONFIG_OUTPUT, "pin output", "level"),
 };
 
 void pinconf_generic_dump_pin(struct pinctrl_dev *pctldev,
@@ -60,7 +57,7 @@ void pinconf_generic_dump_pin(struct pinctrl_dev *pctldev,
 	if (!ops->is_generic)
 		return;
 
-	for (i = 0; i < ARRAY_SIZE(conf_items); i++) {
+	for(i = 0; i < ARRAY_SIZE(conf_items); i++) {
 		unsigned long config;
 		int ret;
 
@@ -95,7 +92,7 @@ void pinconf_generic_dump_group(struct pinctrl_dev *pctldev,
 	if (!ops->is_generic)
 		return;
 
-	for (i = 0; i < ARRAY_SIZE(conf_items); i++) {
+	for(i = 0; i < ARRAY_SIZE(conf_items); i++) {
 		unsigned long config;
 		int ret;
 
@@ -121,17 +118,4 @@ void pinconf_generic_dump_group(struct pinctrl_dev *pctldev,
 	}
 }
 
-void pinconf_generic_dump_config(struct pinctrl_dev *pctldev,
-				 struct seq_file *s, unsigned long config)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(conf_items); i++) {
-		if (pinconf_to_config_param(config) != conf_items[i].param)
-			continue;
-		seq_printf(s, "%s: 0x%x", conf_items[i].display,
-			   pinconf_to_config_argument(config));
-	}
-}
-EXPORT_SYMBOL_GPL(pinconf_generic_dump_config);
 #endif
diff --git a/drivers/pinctrl/pinconf.c b/drivers/pinctrl/pinconf.c
index 694c3ace4520..baee2cc46a17 100644
--- a/drivers/pinctrl/pinconf.c
+++ b/drivers/pinctrl/pinconf.c
@@ -17,7 +17,6 @@
 #include <linux/slab.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#include <linux/uaccess.h>
 #include <linux/pinctrl/machine.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/pinctrl/pinconf.h>
@@ -89,14 +88,14 @@ int pin_config_get(const char *dev_name, const char *name,
 	struct pinctrl_dev *pctldev;
 	int pin;
 
+	mutex_lock(&pinctrl_mutex);
+
 	pctldev = get_pinctrl_dev_from_devname(dev_name);
 	if (!pctldev) {
 		pin = -EINVAL;
-		return pin;
+		goto unlock;
 	}
 
-	mutex_lock(&pctldev->mutex);
-
 	pin = pin_get_from_name(pctldev, name);
 	if (pin < 0)
 		goto unlock;
@@ -104,7 +103,7 @@ int pin_config_get(const char *dev_name, const char *name,
 	pin = pin_config_get_for_pin(pctldev, pin, config);
 
 unlock:
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 	return pin;
 }
 EXPORT_SYMBOL(pin_config_get);
@@ -145,14 +144,14 @@ int pin_config_set(const char *dev_name, const char *name,
 	struct pinctrl_dev *pctldev;
 	int pin, ret;
 
+	mutex_lock(&pinctrl_mutex);
+
 	pctldev = get_pinctrl_dev_from_devname(dev_name);
 	if (!pctldev) {
 		ret = -EINVAL;
-		return ret;
+		goto unlock;
 	}
 
-	mutex_lock(&pctldev->mutex);
-
 	pin = pin_get_from_name(pctldev, name);
 	if (pin < 0) {
 		ret = pin;
@@ -162,7 +161,7 @@ int pin_config_set(const char *dev_name, const char *name,
 	ret = pin_config_set_for_pin(pctldev, pin, config);
 
 unlock:
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 	return ret;
 }
 EXPORT_SYMBOL(pin_config_set);
@@ -174,14 +173,13 @@ int pin_config_group_get(const char *dev_name, const char *pin_group,
 	const struct pinconf_ops *ops;
 	int selector, ret;
 
+	mutex_lock(&pinctrl_mutex);
+
 	pctldev = get_pinctrl_dev_from_devname(dev_name);
 	if (!pctldev) {
 		ret = -EINVAL;
-		return ret;
+		goto unlock;
 	}
-
-	mutex_lock(&pctldev->mutex);
-
 	ops = pctldev->desc->confops;
 
 	if (!ops || !ops->pin_config_group_get) {
@@ -201,7 +199,7 @@ int pin_config_group_get(const char *dev_name, const char *pin_group,
 	ret = ops->pin_config_group_get(pctldev, selector, config);
 
 unlock:
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 	return ret;
 }
 EXPORT_SYMBOL(pin_config_group_get);
@@ -218,14 +216,13 @@ int pin_config_group_set(const char *dev_name, const char *pin_group,
 	int ret;
 	int i;
 
+	mutex_lock(&pinctrl_mutex);
+
 	pctldev = get_pinctrl_dev_from_devname(dev_name);
 	if (!pctldev) {
 		ret = -EINVAL;
-		return ret;
+		goto unlock;
 	}
-
-	mutex_lock(&pctldev->mutex);
-
 	ops = pctldev->desc->confops;
 	pctlops = pctldev->desc->pctlops;
 
@@ -281,7 +278,7 @@ int pin_config_group_set(const char *dev_name, const char *pin_group,
 	ret = 0;
 
 unlock:
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return ret;
 }
@@ -489,7 +486,7 @@ static int pinconf_pins_show(struct seq_file *s, void *what)
 	seq_puts(s, "Pin config settings per pin\n");
 	seq_puts(s, "Format: pin (name): configs\n");
 
-	mutex_lock(&pctldev->mutex);
+	mutex_lock(&pinctrl_mutex);
 
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
@@ -509,7 +506,7 @@ static int pinconf_pins_show(struct seq_file *s, void *what)
 		seq_printf(s, "\n");
 	}
 
-	mutex_unlock(&pctldev->mutex);
+	mutex_unlock(&pinctrl_mutex);
 
 	return 0;
 }
@@ -577,235 +574,6 @@ static const struct file_operations pinconf_groups_ops = {
 	.release	= single_release,
 };
 
-#define MAX_NAME_LEN 15
-
-struct dbg_cfg {
-	enum pinctrl_map_type map_type;
-	char dev_name[MAX_NAME_LEN+1];
-	char state_name[MAX_NAME_LEN+1];
-	char pin_name[MAX_NAME_LEN+1];
-};
-
-/*
- * Goal is to keep this structure as global in order to simply read the
- * pinconf-config file after a write to check config is as expected
- */
-static struct dbg_cfg pinconf_dbg_conf;
-
-/**
- * pinconf_dbg_config_print() - display the pinctrl config from the pinctrl
- * map, of the dev/pin/state that was last written to pinconf-config file.
- * @s: string filled in  with config description
- * @d: not used
- */
-static int pinconf_dbg_config_print(struct seq_file *s, void *d)
-{
-	struct pinctrl_maps *maps_node;
-	const struct pinctrl_map *map;
-	struct pinctrl_dev *pctldev = NULL;
-	const struct pinconf_ops *confops = NULL;
-	const struct pinctrl_map_configs *configs;
-	struct dbg_cfg *dbg = &pinconf_dbg_conf;
-	int i, j;
-	bool found = false;
-	unsigned long config;
-
-	mutex_lock(&pinctrl_maps_mutex);
-
-	/* Parse the pinctrl map and look for the elected pin/state */
-	for_each_maps(maps_node, i, map) {
-		if (map->type != dbg->map_type)
-			continue;
-		if (strcmp(map->dev_name, dbg->dev_name))
-			continue;
-		if (strcmp(map->name, dbg->state_name))
-			continue;
-
-		for (j = 0; j < map->data.configs.num_configs; j++) {
-			if (!strcmp(map->data.configs.group_or_pin,
-					dbg->pin_name)) {
-				/*
-				 * We found the right pin / state, read the
-				 * config and he pctldev for later use
-				 */
-				configs = &map->data.configs;
-				pctldev = get_pinctrl_dev_from_devname
-					(map->ctrl_dev_name);
-				found = true;
-				break;
-			}
-		}
-	}
-
-	if (!found) {
-		seq_printf(s, "No config found for dev/state/pin, expected:\n");
-		seq_printf(s, "Searched dev:%s\n", dbg->dev_name);
-		seq_printf(s, "Searched state:%s\n", dbg->state_name);
-		seq_printf(s, "Searched pin:%s\n", dbg->pin_name);
-		seq_printf(s, "Use: modify config_pin <devname> "\
-				"<state> <pinname> <value>\n");
-		goto exit;
-	}
-
-	config = *(configs->configs);
-	seq_printf(s, "Dev %s has config of %s in state %s: 0x%08lX\n",
-			dbg->dev_name, dbg->pin_name,
-			dbg->state_name, config);
-
-	if (pctldev)
-		confops = pctldev->desc->confops;
-
-	if (confops && confops->pin_config_config_dbg_show)
-		confops->pin_config_config_dbg_show(pctldev, s, config);
-
-exit:
-	mutex_unlock(&pinctrl_maps_mutex);
-
-	return 0;
-}
-
-/**
- * pinconf_dbg_config_write() - modify the pinctrl config in the pinctrl
- * map, of a dev/pin/state entry based on user entries to pinconf-config
- * @user_buf: contains the modification request with expected format:
- *     modify config_pin <devicename> <state> <pinname> <newvalue>
- * modify is literal string, alternatives like add/delete not supported yet
- * config_pin is literal, alternatives like config_mux not supported yet
- * <devicename> <state> <pinname> are values that should match the pinctrl-maps
- * <newvalue> reflects the new config and is driver dependant
- */
-static int pinconf_dbg_config_write(struct file *file,
-	const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	struct pinctrl_maps *maps_node;
-	const struct pinctrl_map *map;
-	struct pinctrl_dev *pctldev = NULL;
-	const struct pinconf_ops *confops = NULL;
-	struct dbg_cfg *dbg = &pinconf_dbg_conf;
-	const struct pinctrl_map_configs *configs;
-	char config[MAX_NAME_LEN+1];
-	bool found = false;
-	char buf[128];
-	char *b = &buf[0];
-	int buf_size;
-	char *token;
-	int i;
-
-	/* Get userspace string and assure termination */
-	buf_size = min(count, (sizeof(buf)-1));
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	/*
-	 * need to parse entry and extract parameters:
-	 * modify configs_pin devicename state pinname newvalue
-	 */
-
-	/* Get arg: 'modify' */
-	token = strsep(&b, " ");
-	if (!token)
-		return -EINVAL;
-	if (strcmp(token, "modify"))
-		return -EINVAL;
-
-	/* Get arg type: "config_pin" type supported so far */
-	token = strsep(&b, " ");
-	if (!token)
-		return -EINVAL;
-	if (strcmp(token, "config_pin"))
-		return -EINVAL;
-	dbg->map_type = PIN_MAP_TYPE_CONFIGS_PIN;
-
-	/* get arg 'device_name' */
-	token = strsep(&b, " ");
-	if (token == NULL)
-		return -EINVAL;
-	if (strlen(token) >= MAX_NAME_LEN)
-		return -EINVAL;
-	strncpy(dbg->dev_name, token, MAX_NAME_LEN);
-
-	/* get arg 'state_name' */
-	token = strsep(&b, " ");
-	if (token == NULL)
-		return -EINVAL;
-	if (strlen(token) >= MAX_NAME_LEN)
-		return -EINVAL;
-	strncpy(dbg->state_name, token, MAX_NAME_LEN);
-
-	/* get arg 'pin_name' */
-	token = strsep(&b, " ");
-	if (token == NULL)
-		return -EINVAL;
-	if (strlen(token) >= MAX_NAME_LEN)
-		return -EINVAL;
-	strncpy(dbg->pin_name, token, MAX_NAME_LEN);
-
-	/* get new_value of config' */
-	token = strsep(&b, " ");
-	if (token == NULL)
-		return -EINVAL;
-	if (strlen(token) >= MAX_NAME_LEN)
-		return -EINVAL;
-	strncpy(config, token, MAX_NAME_LEN);
-
-	mutex_lock(&pinctrl_maps_mutex);
-
-	/* Parse the pinctrl map and look for the selected dev/state/pin */
-	for_each_maps(maps_node, i, map) {
-		if (strcmp(map->dev_name, dbg->dev_name))
-			continue;
-		if (map->type != dbg->map_type)
-			continue;
-		if (strcmp(map->name, dbg->state_name))
-			continue;
-
-		/*  we found the right pin / state, so overwrite config */
-		if (!strcmp(map->data.configs.group_or_pin, dbg->pin_name)) {
-			found = true;
-			pctldev = get_pinctrl_dev_from_devname(
-					map->ctrl_dev_name);
-			configs = &map->data.configs;
-			break;
-		}
-	}
-
-	if (!found) {
-		count = -EINVAL;
-		goto exit;
-	}
-
-	if (pctldev)
-		confops = pctldev->desc->confops;
-
-	if (confops && confops->pin_config_dbg_parse_modify) {
-		for (i = 0; i < configs->num_configs; i++) {
-			confops->pin_config_dbg_parse_modify(pctldev,
-						     config,
-						     &configs->configs[i]);
-		}
-	}
-
-exit:
-	mutex_unlock(&pinctrl_maps_mutex);
-
-	return count;
-}
-
-static int pinconf_dbg_config_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, pinconf_dbg_config_print, inode->i_private);
-}
-
-static const struct file_operations pinconf_dbg_pinconfig_fops = {
-	.open = pinconf_dbg_config_open,
-	.write = pinconf_dbg_config_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-	.owner = THIS_MODULE,
-};
-
 void pinconf_init_device_debugfs(struct dentry *devroot,
 			 struct pinctrl_dev *pctldev)
 {
@@ -813,8 +581,6 @@ void pinconf_init_device_debugfs(struct dentry *devroot,
 			    devroot, pctldev, &pinconf_pins_ops);
 	debugfs_create_file("pinconf-groups", S_IFREG | S_IRUGO,
 			    devroot, pctldev, &pinconf_groups_ops);
-	debugfs_create_file("pinconf-config",  (S_IRUGO | S_IWUSR | S_IWGRP),
-			    devroot, pctldev, &pinconf_dbg_pinconfig_fops);
 }
 
 #endif
diff --git a/drivers/pinctrl/pinconf.h b/drivers/pinctrl/pinconf.h
index 92c7267244d2..e3ed8cb072a5 100644
--- a/drivers/pinctrl/pinconf.h
+++ b/drivers/pinctrl/pinconf.h
@@ -90,7 +90,7 @@ static inline void pinconf_init_device_debugfs(struct dentry *devroot,
  * pin config.
  */
 
-#if defined(CONFIG_GENERIC_PINCONF) && defined(CONFIG_DEBUG_FS)
+#ifdef CONFIG_GENERIC_PINCONF
 
 void pinconf_generic_dump_pin(struct pinctrl_dev *pctldev,
 			      struct seq_file *s, unsigned pin);
@@ -98,8 +98,6 @@ void pinconf_generic_dump_pin(struct pinctrl_dev *pctldev,
 void pinconf_generic_dump_group(struct pinctrl_dev *pctldev,
 			      struct seq_file *s, const char *gname);
 
-void pinconf_generic_dump_config(struct pinctrl_dev *pctldev,
-				 struct seq_file *s, unsigned long config);
 #else
 
 static inline void pinconf_generic_dump_pin(struct pinctrl_dev *pctldev,
@@ -116,10 +114,4 @@ static inline void pinconf_generic_dump_group(struct pinctrl_dev *pctldev,
 	return;
 }
 
-static inline void pinconf_generic_dump_config(struct pinctrl_dev *pctldev,
-					       struct seq_file *s,
-					       unsigned long config)
-{
-	return;
-}
 #endif
diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
old mode 100644
new mode 100755
index 4aad3cea69ae..c0bfb82e9eef
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -16,7 +16,7 @@
 #include <linux/list.h>
 #include <linux/seq_file.h>
 #include <linux/pinctrl/pinctrl-state.h>
-
+#include <linux/pinctrl/machine.h>
 /* This struct is private to the core and should be regarded as a cookie */
 struct pinctrl;
 struct pinctrl_state;
@@ -39,7 +39,12 @@ extern int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *s);
 
 extern struct pinctrl * __must_check devm_pinctrl_get(struct device *dev);
 extern void devm_pinctrl_put(struct pinctrl *p);
-
+extern struct pinctrl_map * amlogic_register_mux_map(struct device *dev,const char *state_name,
+					const char *func,const char *group);
+extern void amlogic_unregister_mux_map(struct pinctrl_map *map);
+extern struct pinctrl_map * amlogic_register_config_map(struct device *dev,const char *state_name,const char *group,
+					unsigned long *configs,unsigned int num_configs);
+extern void amlogic_unregister_config_map(struct pinctrl_map *map);
 #else /* !CONFIG_PINCTRL */
 
 static inline int pinctrl_request_gpio(unsigned gpio)
diff --git a/include/linux/pinctrl/pinconf-generic.h b/include/linux/pinctrl/pinconf-generic.h
old mode 100644
new mode 100755
index 6aa238096622..1eb97f0a8ec5
--- a/include/linux/pinctrl/pinconf-generic.h
+++ b/include/linux/pinctrl/pinconf-generic.h
@@ -83,14 +83,11 @@ enum pin_config_param {
 	PIN_CONFIG_DRIVE_PUSH_PULL,
 	PIN_CONFIG_DRIVE_OPEN_DRAIN,
 	PIN_CONFIG_DRIVE_OPEN_SOURCE,
-	PIN_CONFIG_DRIVE_STRENGTH,
-	PIN_CONFIG_INPUT_SCHMITT_ENABLE,
+	PIN_CONFIG_INPUT_SCHMITT_DISABLE,
 	PIN_CONFIG_INPUT_SCHMITT,
 	PIN_CONFIG_INPUT_DEBOUNCE,
 	PIN_CONFIG_POWER_SOURCE,
-	PIN_CONFIG_SLEW_RATE,
 	PIN_CONFIG_LOW_POWER_MODE,
-	PIN_CONFIG_OUTPUT,
 	PIN_CONFIG_END = 0x7FFF,
 };
 
diff --git a/include/linux/pinctrl/pinconf.h b/include/linux/pinctrl/pinconf.h
index 95f031c8fd64..fd973ee2c658 100755
--- a/include/linux/pinctrl/pinconf.h
+++ b/include/linux/pinctrl/pinconf.h
@@ -37,8 +37,6 @@ struct cfg_param {
 
 #ifdef CONFIG_PINCONF
 
-#include <linux/pinctrl/machine.h>
-
 struct pinctrl_dev;
 struct seq_file;
 
@@ -77,9 +75,6 @@ struct pinconf_ops {
 	int (*pin_config_group_set) (struct pinctrl_dev *pctldev,
 				     unsigned selector,
 				     unsigned long config);
-	int (*pin_config_dbg_parse_modify) (struct pinctrl_dev *pctldev,
-					   const char *arg,
-					   unsigned long *config);
 	void (*pin_config_dbg_show) (struct pinctrl_dev *pctldev,
 				     struct seq_file *s,
 				     unsigned offset);
diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 2c2a9e8d8578..778804df293f 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -118,9 +118,9 @@ struct pinctrl_desc {
 	const char *name;
 	struct pinctrl_pin_desc const *pins;
 	unsigned int npins;
-	const struct pinctrl_ops *pctlops;
-	const struct pinmux_ops *pmxops;
-	const struct pinconf_ops *confops;
+	struct pinctrl_ops *pctlops;
+	struct pinmux_ops *pmxops;
+	struct pinconf_ops *confops;
 	struct module *owner;
 };
 
-- 
2.19.0

