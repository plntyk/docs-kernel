From a26dd9348df4940743e8037cd1a7a83e85006179 Mon Sep 17 00:00:00 2001
From: "shuai.cao" <shuai.cao@amlogic.com>
Date: Wed, 20 Nov 2013 11:21:25 +0800
Subject: [PATCH 1985/5965] add ionvideo module, for native window video
 display and camera.

---
 drivers/amlogic/Kconfig                  |   1 +
 drivers/amlogic/Makefile                 |   1 +
 drivers/amlogic/ionvideo/Kconfig         |  14 +
 drivers/amlogic/ionvideo/Makefile        |   3 +
 drivers/amlogic/ionvideo/ion_priv.h      | 270 +++++++
 drivers/amlogic/ionvideo/ionvideo.c      | 947 +++++++++++++++++++++++
 drivers/amlogic/ionvideo/ionvideo.h      | 188 +++++
 drivers/amlogic/ionvideo/ppmgr2.c        | 382 +++++++++
 drivers/amlogic/ionvideo/videobuf2-ion.c | 276 +++++++
 drivers/amlogic/ionvideo/videobuf2-ion.h |  20 +
 10 files changed, 2102 insertions(+)
 create mode 100755 drivers/amlogic/ionvideo/Kconfig
 create mode 100755 drivers/amlogic/ionvideo/Makefile
 create mode 100755 drivers/amlogic/ionvideo/ion_priv.h
 create mode 100755 drivers/amlogic/ionvideo/ionvideo.c
 create mode 100755 drivers/amlogic/ionvideo/ionvideo.h
 create mode 100755 drivers/amlogic/ionvideo/ppmgr2.c
 create mode 100755 drivers/amlogic/ionvideo/videobuf2-ion.c
 create mode 100755 drivers/amlogic/ionvideo/videobuf2-ion.h

diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index bd8d2a295a79..da52095238f6 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -81,6 +81,7 @@ source "drivers/amlogic/tvin/Kconfig"
 source "drivers/amlogic/ppmgr/Kconfig"
 source "drivers/amlogic/camera/Kconfig"
 source "drivers/amlogic/video_dev/Kconfig"
+source "drivers/amlogic/ionvideo/Kconfig"
 source "drivers/amlogic/deinterlace/Kconfig"
 #source "drivers/amlogic/freescale/Kconfig"
 source "drivers/amlogic/mipi/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 1767839efdc3..1abc50d68a7f 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_POST_PROCESS_MANAGER) += ppmgr/
 
 obj-$(CONFIG_V4L_AMLOGIC_VIDEO) += video_dev/
 obj-$(CONFIG_V4L_AMLOGIC_VIDEO2) += video_dev/
+obj-$(CONFIG_AMLOGIC_IONVIDEO) += ionvideo/
 
 obj-$(CONFIG_DEINTERLACE) += deinterlace/
 
diff --git a/drivers/amlogic/ionvideo/Kconfig b/drivers/amlogic/ionvideo/Kconfig
new file mode 100755
index 000000000000..140b5cf34552
--- /dev/null
+++ b/drivers/amlogic/ionvideo/Kconfig
@@ -0,0 +1,14 @@
+menu "Amlogic ion video support"
+
+config AMLOGIC_IONVIDEO
+	tristate "Amlogic ion video device support"
+	select VIDEO_DEV
+	select VIDEO_V4L2
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_MEMOPS
+	select DMA_SHARED_BUFFER
+	default n
+
+	---help---
+	capture ion video to user
+endmenu
diff --git a/drivers/amlogic/ionvideo/Makefile b/drivers/amlogic/ionvideo/Makefile
new file mode 100755
index 000000000000..0d286d6a1c22
--- /dev/null
+++ b/drivers/amlogic/ionvideo/Makefile
@@ -0,0 +1,3 @@
+EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
+
+obj-$(CONFIG_AMLOGIC_IONVIDEO) += ionvideo.o ppmgr2.o videobuf2-ion.o
diff --git a/drivers/amlogic/ionvideo/ion_priv.h b/drivers/amlogic/ionvideo/ion_priv.h
new file mode 100755
index 000000000000..c11692165194
--- /dev/null
+++ b/drivers/amlogic/ionvideo/ion_priv.h
@@ -0,0 +1,270 @@
+/*
+ * drivers/gpu/ion/ion_priv.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ION_PRIV_H
+#define _ION_PRIV_H
+
+#include <linux/ion.h>
+#include <linux/kref.h>
+#include <linux/mm_types.h>
+#include <linux/mutex.h>
+#include <linux/rbtree.h>
+#include <linux/sched.h>
+#include <linux/shrinker.h>
+#include <linux/types.h>
+
+struct ion_buffer *ion_handle_buffer(struct ion_handle *handle);
+
+/**
+ * struct ion_buffer - metadata for a particular buffer
+ * @ref:		refernce count
+ * @node:		node in the ion_device buffers tree
+ * @dev:		back pointer to the ion_device
+ * @heap:		back pointer to the heap the buffer came from
+ * @flags:		buffer specific flags
+ * @size:		size of the buffer
+ * @priv_virt:		private data to the buffer representable as
+ *			a void *
+ * @priv_phys:		private data to the buffer representable as
+ *			an ion_phys_addr_t (and someday a phys_addr_t)
+ * @lock:		protects the buffers cnt fields
+ * @kmap_cnt:		number of times the buffer is mapped to the kernel
+ * @vaddr:		the kenrel mapping if kmap_cnt is not zero
+ * @dmap_cnt:		number of times the buffer is mapped for dma
+ * @sg_table:		the sg table for the buffer if dmap_cnt is not zero
+ * @dirty:		bitmask representing which pages of this buffer have
+ *			been dirtied by the cpu and need cache maintenance
+ *			before dma
+ * @vmas:		list of vma's mapping this buffer
+ * @handle_count:	count of handles referencing this buffer
+ * @task_comm:		taskcomm of last client to reference this buffer in a
+ *			handle, used for debugging
+ * @pid:		pid of last client to reference this buffer in a
+ *			handle, used for debugging
+*/
+struct ion_buffer {
+	struct kref ref;
+	struct rb_node node;
+	struct ion_device *dev;
+	struct ion_heap *heap;
+	unsigned long flags;
+	size_t size;
+	union {
+		void *priv_virt;
+		ion_phys_addr_t priv_phys;
+	};
+	struct mutex lock;
+	int kmap_cnt;
+	void *vaddr;
+	int dmap_cnt;
+	struct sg_table *sg_table;
+	unsigned long *dirty;
+	struct list_head vmas;
+	/* used to track orphaned buffers */
+	int handle_count;
+	char task_comm[TASK_COMM_LEN];
+	pid_t pid;
+};
+
+/**
+ * struct ion_heap_ops - ops to operate on a given heap
+ * @allocate:		allocate memory
+ * @free:		free memory
+ * @phys		get physical address of a buffer (only define on
+ *			physically contiguous heaps)
+ * @map_dma		map the memory for dma to a scatterlist
+ * @unmap_dma		unmap the memory for dma
+ * @map_kernel		map memory to the kernel
+ * @unmap_kernel	unmap memory to the kernel
+ * @map_user		map memory to userspace
+ */
+struct ion_heap_ops {
+	int (*allocate) (struct ion_heap *heap,
+			 struct ion_buffer *buffer, unsigned long len,
+			 unsigned long align, unsigned long flags);
+	void (*free) (struct ion_buffer *buffer);
+	int (*phys) (struct ion_heap *heap, struct ion_buffer *buffer,
+		     ion_phys_addr_t *addr, size_t *len);
+	struct sg_table *(*map_dma) (struct ion_heap *heap,
+					struct ion_buffer *buffer);
+	void (*unmap_dma) (struct ion_heap *heap, struct ion_buffer *buffer);
+	void * (*map_kernel) (struct ion_heap *heap, struct ion_buffer *buffer);
+	void (*unmap_kernel) (struct ion_heap *heap, struct ion_buffer *buffer);
+	int (*map_user) (struct ion_heap *mapper, struct ion_buffer *buffer,
+			 struct vm_area_struct *vma);
+};
+
+/**
+ * struct ion_heap - represents a heap in the system
+ * @node:		rb node to put the heap on the device's tree of heaps
+ * @dev:		back pointer to the ion_device
+ * @type:		type of heap
+ * @ops:		ops struct as above
+ * @id:			id of heap, also indicates priority of this heap when
+ *			allocating.  These are specified by platform data and
+ *			MUST be unique
+ * @name:		used for debugging
+ * @debug_show:		called when heap debug file is read to add any
+ *			heap specific debug info to output
+ *
+ * Represents a pool of memory from which buffers can be made.  In some
+ * systems the only heap is regular system memory allocated via vmalloc.
+ * On others, some blocks might require large physically contiguous buffers
+ * that are allocated from a specially reserved heap.
+ */
+struct ion_heap {
+	struct plist_node node;
+	struct ion_device *dev;
+	enum ion_heap_type type;
+	struct ion_heap_ops *ops;
+	unsigned int id;
+	const char *name;
+	int (*debug_show)(struct ion_heap *heap, struct seq_file *, void *);
+};
+
+/**
+ * ion_buffer_cached - this ion buffer is cached
+ * @buffer:		buffer
+ *
+ * indicates whether this ion buffer is cached
+ */
+bool ion_buffer_cached(struct ion_buffer *buffer);
+
+/**
+ * ion_buffer_fault_user_mappings - fault in user mappings of this buffer
+ * @buffer:		buffer
+ *
+ * indicates whether userspace mappings of this buffer will be faulted
+ * in, this can affect how buffers are allocated from the heap.
+ */
+bool ion_buffer_fault_user_mappings(struct ion_buffer *buffer);
+
+/**
+ * ion_device_create - allocates and returns an ion device
+ * @custom_ioctl:	arch specific ioctl function if applicable
+ *
+ * returns a valid device or -PTR_ERR
+ */
+struct ion_device *ion_device_create(long (*custom_ioctl)
+				     (struct ion_client *client,
+				      unsigned int cmd,
+				      unsigned long arg));
+
+/**
+ * ion_device_destroy - free and device and it's resource
+ * @dev:		the device
+ */
+void ion_device_destroy(struct ion_device *dev);
+
+/**
+ * ion_device_add_heap - adds a heap to the ion device
+ * @dev:		the device
+ * @heap:		the heap to add
+ */
+void ion_device_add_heap(struct ion_device *dev, struct ion_heap *heap);
+
+/**
+ * some helpers for common operations on buffers using the sg_table
+ * and vaddr fields
+ */
+void *ion_heap_map_kernel(struct ion_heap *, struct ion_buffer *);
+void ion_heap_unmap_kernel(struct ion_heap *, struct ion_buffer *);
+int ion_heap_map_user(struct ion_heap *, struct ion_buffer *,
+			struct vm_area_struct *);
+int ion_heap_buffer_zero(struct ion_buffer *buffer);
+
+
+/**
+ * functions for creating and destroying the built in ion heaps.
+ * architectures can add their own custom architecture specific
+ * heaps as appropriate.
+ */
+
+struct ion_heap *ion_heap_create(struct ion_platform_heap *);
+void ion_heap_destroy(struct ion_heap *);
+struct ion_heap *ion_system_heap_create(struct ion_platform_heap *);
+void ion_system_heap_destroy(struct ion_heap *);
+
+struct ion_heap *ion_system_contig_heap_create(struct ion_platform_heap *);
+void ion_system_contig_heap_destroy(struct ion_heap *);
+
+struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *);
+void ion_carveout_heap_destroy(struct ion_heap *);
+
+struct ion_heap *ion_chunk_heap_create(struct ion_platform_heap *);
+void ion_chunk_heap_destroy(struct ion_heap *);
+/**
+ * kernel api to allocate/free from carveout -- used when carveout is
+ * used to back an architecture specific custom heap
+ */
+ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap, unsigned long size,
+				      unsigned long align);
+void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr,
+		       unsigned long size);
+/**
+ * The carveout heap returns physical addresses, since 0 may be a valid
+ * physical address, this is used to indicate allocation failed
+ */
+#define ION_CARVEOUT_ALLOCATE_FAIL -1
+
+/**
+ * functions for creating and destroying a heap pool -- allows you
+ * to keep a pool of pre allocated memory to use from your heap.  Keeping
+ * a pool of memory that is ready for dma, ie any cached mapping have been
+ * invalidated from the cache, provides a significant peformance benefit on
+ * many systems */
+
+/**
+ * struct ion_page_pool - pagepool struct
+ * @high_count:		number of highmem items in the pool
+ * @low_count:		number of lowmem items in the pool
+ * @high_items:		list of highmem items
+ * @low_items:		list of lowmem items
+ * @shrinker:		a shrinker for the items
+ * @mutex:		lock protecting this struct and especially the count
+ *			item list
+ * @alloc:		function to be used to allocate pageory when the pool
+ *			is empty
+ * @free:		function to be used to free pageory back to the system
+ *			when the shrinker fires
+ * @gfp_mask:		gfp_mask to use from alloc
+ * @order:		order of pages in the pool
+ * @list:		plist node for list of pools
+ *
+ * Allows you to keep a pool of pre allocated pages to use from your heap.
+ * Keeping a pool of pages that is ready for dma, ie any cached mapping have
+ * been invalidated from the cache, provides a significant peformance benefit
+ * on many systems
+ */
+struct ion_page_pool {
+	int high_count;
+	int low_count;
+	struct list_head high_items;
+	struct list_head low_items;
+	struct mutex mutex;
+	void *(*alloc)(struct ion_page_pool *pool);
+	void (*free)(struct ion_page_pool *pool, struct page *page);
+	gfp_t gfp_mask;
+	unsigned int order;
+	struct plist_node list;
+};
+
+struct ion_page_pool *ion_page_pool_create(gfp_t gfp_mask, unsigned int order);
+void ion_page_pool_destroy(struct ion_page_pool *);
+void *ion_page_pool_alloc(struct ion_page_pool *);
+void ion_page_pool_free(struct ion_page_pool *, struct page *);
+
+#endif /* _ION_PRIV_H */
diff --git a/drivers/amlogic/ionvideo/ionvideo.c b/drivers/amlogic/ionvideo/ionvideo.c
new file mode 100755
index 000000000000..78edb7701fe0
--- /dev/null
+++ b/drivers/amlogic/ionvideo/ionvideo.c
@@ -0,0 +1,947 @@
+/*
+ * Ion Video driver - This code emulates a real video device with v4l2 api,
+ * used for surface video display.
+ *
+ *Author: Shuai Cao <shuai.cao@amlogic.com>
+ *
+ */
+#include "ionvideo.h"
+
+#define IONVIDEO_MODULE_NAME "ionvideo"
+
+#define IONVIDEO_VERSION "3.0"
+#define RECEIVER_NAME "ionvideo"
+
+static int is_actived = 0;
+
+static unsigned video_nr = 13;
+module_param(video_nr, uint, 0644);
+MODULE_PARM_DESC(video_nr, "videoX start number, 13 is autodetect");
+
+static unsigned n_devs = 1;
+module_param(n_devs, uint, 0644);
+MODULE_PARM_DESC(n_devs, "number of video devices to create");
+
+static unsigned debug = 0;
+module_param(debug, uint, 0644);
+MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 16;
+module_param(vid_limit, uint, 0644);
+MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+
+static struct ionvideo_fmt formats[] = {
+    {
+        .name = "RGB32 (LE)",
+        .fourcc = V4L2_PIX_FMT_RGB32, /* argb */
+        .depth = 32,
+    },
+    {
+        .name = "RGB565 (LE)",
+        .fourcc = V4L2_PIX_FMT_RGB565, /* gggbbbbb rrrrrggg */
+        .depth = 16,
+    },
+    {
+        .name = "RGB24 (LE)",
+        .fourcc = V4L2_PIX_FMT_RGB24, /* rgb */
+        .depth = 24,
+    },
+    {
+        .name = "RGB24 (BE)",
+        .fourcc = V4L2_PIX_FMT_BGR24, /* bgr */
+        .depth = 24,
+    },
+    {
+        .name = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV12,
+        .depth    = 12,
+    },
+    {
+        .name     = "12  Y/CrCb 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV21,
+        .depth    = 12,
+    },
+    {
+        .name     = "YUV420P",
+        .fourcc   = V4L2_PIX_FMT_YUV420,
+        .depth    = 12,
+    },
+    {
+        .name     = "YVU420P",
+        .fourcc   = V4L2_PIX_FMT_YVU420,
+        .depth    = 12,
+    }
+};
+
+static struct ionvideo_fmt *get_format(struct v4l2_format *f) {
+    struct ionvideo_fmt *fmt;
+    unsigned int k;
+
+    for (k = 0; k < ARRAY_SIZE(formats); k++) {
+        fmt = &formats[k];
+        if (fmt->fourcc == f->fmt.pix.pixelformat)
+            break;
+    }
+
+    if (k == ARRAY_SIZE(formats))
+        return NULL;
+
+    return &formats[k];
+}
+
+static LIST_HEAD (ionvideo_devlist);
+
+/* ------------------------------------------------------------------
+ DMA and thread functions
+ ------------------------------------------------------------------*/
+unsigned get_ionvideo_debug(void) {
+    return debug;
+}
+EXPORT_SYMBOL(get_ionvideo_debug);
+
+int is_ionvideo_active(void) {
+    return is_actived;
+}
+EXPORT_SYMBOL(is_ionvideo_active);
+
+static void videoc_compute_pts(struct ionvideo_dev *dev, struct vframe_s* vf) {
+    if (vf->pts) {
+        timestamp_vpts_set(vf->pts);
+        dev->receiver_register = 0;
+    } else if (dev->receiver_register){
+        timestamp_vpts_set(timestamp_pcrscr_get());
+        dev->receiver_register = 0;
+    } else {
+        timestamp_vpts_inc(DUR2PTS(vf->duration));
+    }
+    dev->pts = vf->pts_us64;
+}
+
+static int ionvideo_fillbuff(struct ionvideo_dev *dev, struct ionvideo_buffer *buf) {
+
+    struct vframe_s* vf;
+    struct vb2_buffer *vb = &(buf->vb);
+    int ret = 0;
+
+//-------------------------------------------------------
+    vf = vf_get(RECEIVER_NAME);
+    ret = ppmgr2_process(vf, &dev->ppmgr2_dev, vb->v4l2_buf.index);
+    if (ret != 0) {
+        vf_put(vf, RECEIVER_NAME);
+        return ret;
+    }
+    videoc_compute_pts(dev, vf);
+    vf_put(vf, RECEIVER_NAME);
+//-------------------------------------------------------
+    buf->vb.v4l2_buf.timestamp.tv_sec = 0;
+    buf->vb.v4l2_buf.timestamp.tv_usec = dev->pts;
+
+    return 0;
+}
+
+static void ionvideo_thread_tick(struct ionvideo_dev *dev) {
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+    struct ionvideo_buffer *buf;
+    unsigned long flags = 0;
+
+    dprintk(dev, 4, "Thread tick\n");
+    /* video seekTo clear list */
+
+    if (!vf_peek(RECEIVER_NAME)) {
+        return;
+    }
+    spin_lock_irqsave(&dev->slock, flags);
+    if (list_empty(&dma_q->active)) {
+        dprintk(dev, 3, "No active queue to serve\n");
+        spin_unlock_irqrestore(&dev->slock, flags);
+        return;
+    }
+    buf = list_entry(dma_q->active.next, struct ionvideo_buffer, list);
+    spin_unlock_irqrestore(&dev->slock, flags);
+
+    /* Fill buffer */
+    if (ionvideo_fillbuff(dev, buf)) {
+        return;
+    }
+    spin_lock_irqsave(&dev->slock, flags);
+    list_del(&buf->list);
+    spin_unlock_irqrestore(&dev->slock, flags);
+    vb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);
+    dprintk(dev, 4, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
+}
+
+#define frames_to_ms(frames)					\
+    ((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+
+static void ionvideo_sleep(struct ionvideo_dev *dev) {
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+    int timeout;
+    DECLARE_WAITQUEUE(wait, current);
+
+    dprintk(dev, 4, "%s dma_q=0x%08lx\n", __func__, (unsigned long)dma_q);
+
+    add_wait_queue(&dma_q->wq, &wait);
+    if (kthread_should_stop())
+        goto stop_task;
+
+    /* Calculate time to wake up */
+    //timeout = msecs_to_jiffies(frames_to_ms(1));
+
+    ionvideo_thread_tick(dev);
+
+    //schedule_timeout_interruptible(timeout);
+
+stop_task:
+    remove_wait_queue(&dma_q->wq, &wait);
+    try_to_freeze();
+}
+
+static int ionvideo_thread(void *data) {
+    struct ionvideo_dev *dev = data;
+
+    dprintk(dev, 2, "thread started\n");
+
+    set_freezable();
+
+    for (;;) {
+        ionvideo_sleep(dev);
+
+        if (kthread_should_stop())
+            break;
+    }
+    dprintk(dev, 2, "thread: exit\n");
+    return 0;
+}
+
+static int ionvideo_start_generating(struct ionvideo_dev *dev) {
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+
+    dprintk(dev, 2, "%s\n", __func__);
+
+    /* Resets frame counters */
+    dev->ms = 0;
+    dev->mv_count = 0;
+    //dev->jiffies = jiffies;
+
+    dma_q->frame = 0;
+    //dma_q->ini_jiffies = jiffies;
+    dma_q->kthread = kthread_run(ionvideo_thread, dev, dev->v4l2_dev.name);
+
+    if (IS_ERR(dma_q->kthread)) {
+        v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+        return PTR_ERR(dma_q->kthread);
+    }
+    /* Wakes thread */
+    wake_up_interruptible(&dma_q->wq);
+
+    dprintk(dev, 2, "returning from %s\n", __func__);
+    return 0;
+}
+
+static void ionvideo_stop_generating(struct ionvideo_dev *dev) {
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+
+    dprintk(dev, 2, "%s\n", __func__);
+
+    /* shutdown control thread */
+    if (dma_q->kthread) {
+        kthread_stop(dma_q->kthread);
+        dma_q->kthread = NULL;
+    }
+
+    /*
+     * Typical driver might need to wait here until dma engine stops.
+     * In this case we can abort imiedetly, so it's just a noop.
+     */
+
+    /* Release all active buffers */
+    while (!list_empty(&dma_q->active)) {
+        struct ionvideo_buffer *buf;
+        buf = list_entry(dma_q->active.next, struct ionvideo_buffer, list);
+        list_del(&buf->list);
+        vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+        dprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
+    }
+}
+/* ------------------------------------------------------------------
+ Videobuf operations
+ ------------------------------------------------------------------*/
+static int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt, unsigned int *nbuffers, unsigned int *nplanes, unsigned int sizes[], void *alloc_ctxs[]) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    unsigned long size;
+
+    if (fmt)
+        size = fmt->fmt.pix.sizeimage;
+    else
+        size = (dev->width * dev->height * dev->pixelsize) >> 3;
+
+    if (size == 0)
+        return -EINVAL;
+
+    if (0 == *nbuffers)
+        *nbuffers = 32;
+
+    while (size * *nbuffers > vid_limit * 1024 * 1024)
+        (*nbuffers)--;
+
+    *nplanes = 1;
+
+    sizes[0] = size;
+
+    /*
+     * videobuf2-vmalloc allocator is context-less so no need to set
+     * alloc_ctxs array.
+     */
+
+    dprintk(dev, 2, "%s, count=%d, size=%ld\n", __func__, *nbuffers, size);
+
+    return 0;
+}
+
+static int buffer_prepare(struct vb2_buffer *vb) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
+    struct ionvideo_buffer
+    *buf = container_of(vb, struct ionvideo_buffer, vb);
+    unsigned long size;
+
+    dprintk(dev, 2, "%s, field=%d\n", __func__, vb->v4l2_buf.field);
+
+    BUG_ON(NULL == dev->fmt);
+
+    /*
+     * Theses properties only change when queue is idle, see s_fmt.
+     * The below checks should not be performed here, on each
+     * buffer_prepare (i.e. on each qbuf). Most of the code in this function
+     * should thus be moved to buffer_init and s_fmt.
+     */
+    if (dev->width < 48 || dev->width > MAX_WIDTH || dev->height < 32 || dev->height > MAX_HEIGHT)
+        return -EINVAL;
+
+    size = (dev->width * dev->height * dev->pixelsize) >> 3;
+    if (vb2_plane_size(vb, 0) < size) {
+        dprintk(dev, 1, "%s data will not fit into plane (%lu < %lu)\n", __func__, vb2_plane_size(vb, 0), size);
+        return -EINVAL;
+    }
+
+    vb2_set_plane_payload(&buf->vb, 0, size);
+
+    buf->fmt = dev->fmt;
+
+    //precalculate_bars(dev);
+    //precalculate_line(dev);
+
+    return 0;
+}
+
+static void buffer_queue(struct vb2_buffer *vb) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
+    struct ionvideo_buffer
+    *buf = container_of(vb, struct ionvideo_buffer, vb);
+    struct ionvideo_dmaqueue *vidq = &dev->vidq;
+    unsigned long flags = 0;
+
+    dprintk(dev, 2, "%s\n", __func__);
+
+    spin_lock_irqsave(&dev->slock, flags);
+    list_add_tail(&buf->list, &vidq->active);
+    spin_unlock_irqrestore(&dev->slock, flags);
+}
+
+static int start_streaming(struct vb2_queue *vq, unsigned int count) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    is_actived = 1;
+    dprintk(dev, 2, "%s\n", __func__);
+    return ionvideo_start_generating(dev);
+}
+
+/* abort streaming and wait for last buffer */
+static int stop_streaming(struct vb2_queue *vq) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    is_actived = 0;
+    dprintk(dev, 2, "%s\n", __func__);
+    ionvideo_stop_generating(dev);
+    return 0;
+}
+
+static void ionvideo_lock(struct vb2_queue *vq) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    mutex_lock(&dev->mutex);
+}
+
+static void ionvideo_unlock(struct vb2_queue *vq) {
+    struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    mutex_unlock(&dev->mutex);
+}
+
+static struct vb2_ops ionvideo_video_qops = {
+    .queue_setup = queue_setup,
+    .buf_prepare = buffer_prepare,
+    .buf_queue = buffer_queue,
+    .start_streaming = start_streaming,
+    .stop_streaming = stop_streaming,
+    .wait_prepare = ionvideo_unlock,
+    .wait_finish = ionvideo_lock,
+};
+
+/* ------------------------------------------------------------------
+ IOCTL vidioc handling
+ ------------------------------------------------------------------*/
+static int vidioc_open(struct file *file) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+    if (ppmgr2_init(&(dev->ppmgr2_dev)) < 0) {
+        return -EBUSY;
+    }
+    dev->pts = 0;
+    dprintk(dev, 2, "vidioc_open\n");
+    return v4l2_fh_open(file);
+}
+
+static int vidioc_release(struct file *file) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+    ppmgr2_release(&(dev->ppmgr2_dev));
+    dprintk(dev, 2, "vidioc_release\n");
+    return vb2_fop_release(file);
+}
+
+static int vidioc_querycap(struct file *file, void *priv, struct v4l2_capability *cap) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+
+    strcpy(cap->driver, "ionvideo");
+    strcpy(cap->card, "ionvideo");
+    snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s", dev->v4l2_dev.name);
+    cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
+    cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+    return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv, struct v4l2_fmtdesc *f) {
+    struct ionvideo_fmt *fmt;
+
+    if (f->index >= ARRAY_SIZE(formats))
+        return -EINVAL;
+
+    fmt = &formats[f->index];
+
+    strlcpy(f->description, fmt->name, sizeof(f->description));
+    f->pixelformat = fmt->fourcc;
+    return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+
+    f->fmt.pix.width = dev->width;
+    f->fmt.pix.height = dev->height;
+    f->fmt.pix.field = V4L2_FIELD_INTERLACED;
+    f->fmt.pix.pixelformat = dev->fmt->fourcc;
+    f->fmt.pix.bytesperline = (f->fmt.pix.width * dev->fmt->depth) >> 3;
+    f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
+    if (dev->fmt->is_yuv)
+        f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
+    else
+        f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+    return 0;
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+    struct ionvideo_fmt *fmt;
+
+    fmt = get_format(f);
+    if (!fmt) {
+        dprintk(dev, 1, "Fourcc format (0x%08x) unknown.\n", f->fmt.pix.pixelformat);
+        return -EINVAL;
+    }
+
+    f->fmt.pix.field = V4L2_FIELD_INTERLACED;
+    v4l_bound_align_image(&f->fmt.pix.width, 48, MAX_WIDTH, 16, &f->fmt.pix.height, 32, MAX_HEIGHT, 0, 0);
+    f->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;
+    f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
+    if (fmt->is_yuv)
+        f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
+    else
+        f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+    f->fmt.pix.priv = 0;
+    return 0;
+}
+
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *f) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+    struct vb2_queue *q = &dev->vb_vidq;
+
+    int ret = vidioc_try_fmt_vid_cap(file, priv, f);
+    if (ret < 0)
+        return ret;
+
+    if (vb2_is_busy(q)) {
+        dprintk(dev, 1, "%s device busy\n", __func__);
+        return -EBUSY;
+    }
+    dev->fmt = get_format(f);
+    dev->pixelsize = dev->fmt->depth;
+    dev->width = f->fmt.pix.width;
+    dev->height = f->fmt.pix.height;
+
+    return 0;
+}
+
+static int vidioc_enum_framesizes(struct file *file, void *fh, struct v4l2_frmsizeenum *fsize) {
+    static const struct v4l2_frmsize_stepwise sizes = { 48, MAX_WIDTH, 4, 32, MAX_HEIGHT, 1 };
+    int i;
+
+    if (fsize->index)
+        return -EINVAL;
+    for (i = 0; i < ARRAY_SIZE(formats); i++)
+        if (formats[i].fourcc == fsize->pixel_format)
+            break;
+    if (i == ARRAY_SIZE(formats))
+        return -EINVAL;
+    fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+    fsize->stepwise = sizes;
+    return 0;
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p) {
+
+    struct ionvideo_dev *dev = video_drvdata(file);
+    struct vb2_queue *q;
+    struct ppmgr2_device* ppmgr2_dev = &(dev->ppmgr2_dev);
+    int ret = 0;
+
+    ret = vb2_ioctl_qbuf(file, priv, p);
+    if (ret != 0) { return ret; }
+
+    q = dev->vdev.queue;
+    if (ppmgr2_dev->inited_canvas < q->num_buffers){
+        struct vb2_buffer *vb;
+        vb = q->bufs[p->index];
+        void* phy_addr = vb2_plane_cookie(vb, 0);
+        if (phy_addr && !ppmgr2_canvas_config(ppmgr2_dev, dev->width, dev->height, dev->fmt->fourcc, phy_addr, p->index)) {
+            ppmgr2_dev->inited_canvas += 1;
+        } else {
+            return -ENOMEM;
+        }
+    }
+
+    return 0;
+}
+
+#define NUM_INPUTS 10
+/* only one input in this sample driver */
+static int vidioc_enum_input(struct file *file, void *priv, struct v4l2_input *inp) {
+    if (inp->index >= NUM_INPUTS)
+        return -EINVAL;
+
+    inp->type = V4L2_INPUT_TYPE_CAMERA;
+    sprintf(inp->name, "Camera %u", inp->index);
+    return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+
+    *i = dev->input;
+    return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i) {
+    struct ionvideo_dev *dev = video_drvdata(file);
+
+    if (i >= NUM_INPUTS)
+        return -EINVAL;
+
+    if (i == dev->input)
+        return 0;
+
+    dev->input = i;
+    //precalculate_bars(dev);
+    //precalculate_line(dev);
+    return 0;
+}
+
+/* --- controls ---------------------------------------------- */
+
+static int ionvideo_g_volatile_ctrl(struct v4l2_ctrl *ctrl) {
+    struct ionvideo_dev
+    *dev = container_of(ctrl->handler, struct ionvideo_dev, ctrl_handler);
+
+    //if (ctrl == dev->autogain)
+    //    dev->gain->val = jiffies & 0xff;
+    return 0;
+}
+
+
+#define IONVIDEO_CID_CUSTOM_BASE    (V4L2_CID_USER_BASE | 0xf000)
+
+static int ionvideo_s_ctrl(struct v4l2_ctrl *ctrl) {
+    struct ionvideo_dev
+    *dev = container_of(ctrl->handler, struct ionvideo_dev, ctrl_handler);
+
+    switch (ctrl->id) {
+    case V4L2_CID_ALPHA_COMPONENT:
+        dev->alpha_component = ctrl->val;
+        break;
+    default:
+        if (ctrl == dev->button)
+            dev->button_pressed = 30;
+        break;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------
+ File operations for the device
+ ------------------------------------------------------------------*/
+
+static const struct v4l2_ctrl_ops ionvideo_ctrl_ops = {
+    .g_volatile_ctrl = ionvideo_g_volatile_ctrl,
+    .s_ctrl = ionvideo_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_button = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 0,
+    .name = "Button",
+    .type = V4L2_CTRL_TYPE_BUTTON,
+};
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_boolean = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 1,
+    .name = "Boolean",
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 1,
+};
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_int32 = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 2,
+    .name = "Integer 32 Bits",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .min = 0x80000000,
+    .max = 0x7fffffff,
+    .step = 1,
+};
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_int64 = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 3,
+    .name = "Integer 64 Bits",
+    .type = V4L2_CTRL_TYPE_INTEGER64,
+};
+
+static const char * const ionvideo_ctrl_menu_strings[] = { "Menu Item 0 (Skipped)", "Menu Item 1", "Menu Item 2 (Skipped)", "Menu Item 3", "Menu Item 4", "Menu Item 5 (Skipped)", NULL, };
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_menu = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 4,
+    .name = "Menu",
+    .type = V4L2_CTRL_TYPE_MENU,
+    .min = 1,
+    .max = 4,
+    .def = 3,
+    .menu_skip_mask = 0x04,
+    .qmenu = ionvideo_ctrl_menu_strings,
+};
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_string = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 5,
+    .name = "String",
+    .type = V4L2_CTRL_TYPE_STRING,
+    .min = 2,
+    .max = 4,
+    .step = 1,
+};
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_bitmask = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 6,
+    .name = "Bitmask",
+    .type = V4L2_CTRL_TYPE_BITMASK,
+    .def = 0x80002000,
+    .min = 0,
+    .max = 0x80402010,
+    .step = 0,
+};
+
+static const s64 ionvideo_ctrl_int_menu_values[] = { 1, 1, 2, 3, 5, 8, 13, 21, 42, };
+
+static const struct v4l2_ctrl_config ionvideo_ctrl_int_menu = {
+    .ops = &ionvideo_ctrl_ops,
+    .id = IONVIDEO_CID_CUSTOM_BASE + 7,
+    .name = "Integer menu",
+    .type = V4L2_CTRL_TYPE_INTEGER_MENU,
+    .min = 1,
+    .max = 8,
+    .def = 4,
+    .menu_skip_mask = 0x02,
+    .qmenu_int = ionvideo_ctrl_int_menu_values,
+};
+
+static const struct v4l2_file_operations ionvideo_fops = {
+    .owner = THIS_MODULE,
+    .open = vidioc_open,
+    .release = vidioc_release,
+    .read = vb2_fop_read,
+    .poll = vb2_fop_poll,
+    .unlocked_ioctl = video_ioctl2, /* V4L2 ioctl handler */
+    .mmap = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops ionvideo_ioctl_ops = {
+    .vidioc_querycap = vidioc_querycap,
+    .vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,
+    .vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap,
+    .vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap,
+    .vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap,
+    .vidioc_enum_framesizes = vidioc_enum_framesizes,
+    .vidioc_reqbufs = vb2_ioctl_reqbufs,
+    .vidioc_create_bufs = vb2_ioctl_create_bufs,
+    .vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+    .vidioc_querybuf = vb2_ioctl_querybuf,
+    .vidioc_qbuf = vidioc_qbuf,
+    .vidioc_dqbuf = vb2_ioctl_dqbuf,
+    .vidioc_enum_input = vidioc_enum_input,
+    .vidioc_g_input = vidioc_g_input,
+    .vidioc_s_input = vidioc_s_input,
+    .vidioc_streamon = vb2_ioctl_streamon,
+    .vidioc_streamoff = vb2_ioctl_streamoff,
+    .vidioc_log_status = v4l2_ctrl_log_status,
+    .vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+    .vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static struct video_device ionvideo_template = {
+    .name = "ionvideo",
+    .fops = &ionvideo_fops,
+    .ioctl_ops = &ionvideo_ioctl_ops,
+    .release = video_device_release_empty,
+};
+
+/* -----------------------------------------------------------------
+ Initialization and module stuff
+ ------------------------------------------------------------------*/
+//struct vb2_dc_conf * ionvideo_dma_ctx = NULL;
+static int ionvideo_release(void) {
+    struct ionvideo_dev *dev;
+    struct list_head *list;
+
+    while (!list_empty(&ionvideo_devlist)) {
+        list = ionvideo_devlist.next;
+        list_del(list);
+        dev = list_entry(list, struct ionvideo_dev, ionvideo_devlist);
+
+        v4l2_info(&dev->v4l2_dev, "unregistering %s\n", video_device_node_name(&dev->vdev));
+        video_unregister_device(&dev->vdev);
+        v4l2_device_unregister(&dev->v4l2_dev);
+        v4l2_ctrl_handler_free(&dev->ctrl_handler);
+        kfree(dev);
+    }
+    //vb2_dma_contig_cleanup_ctx(ionvideo_dma_ctx);
+
+    return 0;
+}
+
+static void vidioc_unregister(struct ionvideo_dev *dev) {
+
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+    unsigned long flags = 0;
+
+    /* Release all active buffers */
+    while (!list_empty(&dma_q->active)) {
+        struct ionvideo_buffer *buf;
+
+        spin_lock_irqsave(&dev->slock, flags);
+        buf = list_entry(dma_q->active.next, struct ionvideo_buffer, list);
+        list_del(&buf->list);
+        spin_unlock_irqrestore(&dev->slock, flags);
+
+        buf->vb.v4l2_buf.timestamp.tv_sec = 0;
+        buf->vb.v4l2_buf.timestamp.tv_usec = dev->pts;
+        vb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);
+        dprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
+    }
+}
+
+static int video_receiver_event_fun(int type, void* data, void* private_data) {
+    struct ionvideo_dev *dev = (struct ionvideo_dev *) private_data;
+
+    if (type == VFRAME_EVENT_PROVIDER_UNREG) {
+        dev->receiver_register = 0;
+        printk("unreg:ionvideo\n");
+    }else if (type == VFRAME_EVENT_PROVIDER_REG) {
+        dev->receiver_register = 1;
+        printk("reg:ionvideo\n");
+    }
+    return 0;
+}
+
+static const struct vframe_receiver_op_s video_vf_receiver = { .event_cb = video_receiver_event_fun };
+
+static int __init ionvideo_create_instance(int inst)
+{
+    struct ionvideo_dev *dev;
+    struct video_device *vfd;
+    struct v4l2_ctrl_handler *hdl;
+    struct vb2_queue *q;
+    int ret;
+
+    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+    if (!dev)
+    return -ENOMEM;
+
+    snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),
+            "%s-%03d", IONVIDEO_MODULE_NAME, inst);
+    ret = v4l2_device_register(NULL, &dev->v4l2_dev);
+    if (ret)
+    goto free_dev;
+
+    dev->fmt = &formats[0];
+    dev->width = 640;
+    dev->height = 480;
+    dev->pixelsize = dev->fmt->depth;
+    hdl = &dev->ctrl_handler;
+    v4l2_ctrl_handler_init(hdl, 11);
+    dev->volume = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_AUDIO_VOLUME, 0, 255, 1, 200);
+    dev->brightness = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_BRIGHTNESS, 0, 255, 1, 127);
+    dev->contrast = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_CONTRAST, 0, 255, 1, 16);
+    dev->saturation = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_SATURATION, 0, 255, 1, 127);
+    dev->hue = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_HUE, -128, 127, 1, 0);
+    dev->autogain = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
+    dev->gain = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_GAIN, 0, 255, 1, 100);
+    dev->alpha = v4l2_ctrl_new_std(hdl, &ionvideo_ctrl_ops,
+            V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);
+    dev->button = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_button, NULL);
+    dev->int32 = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_int32, NULL);
+    dev->int64 = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_int64, NULL);
+    dev->boolean = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_boolean, NULL);
+    dev->menu = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_menu, NULL);
+    dev->string = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_string, NULL);
+    dev->bitmask = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_bitmask, NULL);
+    dev->int_menu = v4l2_ctrl_new_custom(hdl, &ionvideo_ctrl_int_menu, NULL);
+    if (hdl->error) {
+        ret = hdl->error;
+        goto unreg_dev;
+    }
+    v4l2_ctrl_auto_cluster(2, &dev->autogain, 0, true);
+    dev->v4l2_dev.ctrl_handler = hdl;
+
+    /* initialize locks */
+    spin_lock_init(&dev->slock);
+
+    /* initialize queue */
+    q = &dev->vb_vidq;
+    q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;
+    q->drv_priv = dev;
+    q->buf_struct_size = sizeof(struct ionvideo_buffer);
+    q->ops = &ionvideo_video_qops;
+    q->mem_ops = &vb2_ion_memops; //vb2_dma_contig_memops;//vb2_vmalloc_memops;
+    //ionvideo_dma_ctx = vb2_dma_contig_init_ctx(dev);
+    //q->mem_ops = &vb2_dma_contig_memops;
+
+    ret = vb2_queue_init(q);
+    if (ret)
+    goto unreg_dev;
+
+    mutex_init(&dev->mutex);
+
+    /* init video dma queues */
+    INIT_LIST_HEAD(&dev->vidq.active);
+    init_waitqueue_head(&dev->vidq.wq);
+
+    vfd = &dev->vdev;
+    *vfd = ionvideo_template;
+    vfd->debug = debug;
+    vfd->v4l2_dev = &dev->v4l2_dev;
+    vfd->queue = q;
+    set_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);
+
+    /*
+     * Provide a mutex to v4l2 core. It will be used to protect
+     * all fops and v4l2 ioctls.
+     */
+    vfd->lock = &dev->mutex;
+    video_set_drvdata(vfd, dev);
+
+    ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+    if (ret < 0)
+        goto unreg_dev;
+
+    /* Now that everything is fine, let's add it to device list */
+    list_add_tail(&dev->ionvideo_devlist, &ionvideo_devlist);
+    vf_receiver_init(&dev->video_vf_receiver, RECEIVER_NAME, &video_vf_receiver, &dev );
+    vf_reg_receiver(&dev->video_vf_receiver);
+    v4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",
+            video_device_node_name(vfd));
+    return 0;
+
+unreg_dev:
+    v4l2_ctrl_handler_free(hdl);
+    v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+    kfree(dev);
+    return ret;
+}
+
+/* This routine allocates from 1 to n_devs virtual drivers.
+
+ The real maximum number of virtual drivers will depend on how many drivers
+ will succeed. This is limited to the maximum number of devices that
+ videodev supports, which is equal to VIDEO_NUM_DEVICES.
+ */
+static int __init ionvideo_init(void)
+{
+    int ret = 0, i;
+
+    if (n_devs <= 0)
+    n_devs = 1;
+
+    for (i = 0; i < n_devs; i++) {
+        ret = ionvideo_create_instance(i);
+        if (ret) {
+            /* If some instantiations succeeded, keep driver */
+            if (i)
+            ret = 0;
+            break;
+        }
+    }
+
+    if (ret < 0) {
+        printk(KERN_ERR "ionvideo: error %d while loading driver\n", ret);
+        return ret;
+    }
+
+    printk(KERN_INFO "Video Technology Magazine Ion Video "
+            "Capture Board ver %s successfully loaded.\n",
+            IONVIDEO_VERSION);
+
+    /* n_devs will reflect the actual number of allocated devices */
+    n_devs = i;
+
+    return ret;
+}
+
+static void __exit ionvideo_exit(void)
+{
+    ionvideo_release();
+}
+
+MODULE_DESCRIPTION("Video Technology Magazine Ion Video Capture Board");
+MODULE_AUTHOR("Amlogic, Shuai Cao<shuai.cao@amlogic.com>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION(IONVIDEO_VERSION);
+
+module_init (ionvideo_init);
+module_exit (ionvideo_exit);
diff --git a/drivers/amlogic/ionvideo/ionvideo.h b/drivers/amlogic/ionvideo/ionvideo.h
new file mode 100755
index 000000000000..fdcdf99f95e7
--- /dev/null
+++ b/drivers/amlogic/ionvideo/ionvideo.h
@@ -0,0 +1,188 @@
+#ifndef _IONVIDEO_H
+#define _IONVIDEO_H
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-common.h>
+
+#include <linux/mm.h>
+#include <mach/mod_gate.h>
+
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/canvas.h>
+
+#include <linux/amlogic/vout/vout_notify.h>
+
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/tsync.h>
+#include "videobuf2-ion.h"
+
+
+/* Wake up at about 30 fps */
+#define WAKE_NUMERATOR 30
+#define WAKE_DENOMINATOR 1001
+
+#define MAX_WIDTH 3840
+#define MAX_HEIGHT 2160
+
+#define PPMGR2_MAX_CANVAS 8
+#define PPMGR2_CANVAS_INDEX 0x70
+
+#define DUR2PTS(x) ((x) - ((x) >> 4))
+
+#define dprintk(dev, level, fmt, arg...)                    \
+    v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+
+#define ppmgr2_printk(level, fmt, arg...)                   \
+    do {                                                    \
+        if (get_ionvideo_debug() >= level)                  \
+            printk(KERN_DEBUG "ppmgr2-dev: " fmt, ## arg);  \
+    } while (0)
+
+/* ------------------------------------------------------------------
+ Basic structures
+ ------------------------------------------------------------------*/
+
+struct ionvideo_fmt {
+    char *name;
+    u32 fourcc; /* v4l2 format id */
+    u8 depth;
+    bool is_yuv;
+};
+
+/* buffer for one video frame */
+struct ionvideo_buffer {
+    /* common v4l buffer stuff -- must be first */
+    struct vb2_buffer vb;
+    struct list_head list;
+    struct ionvideo_fmt *fmt;
+};
+
+struct ionvideo_dmaqueue {
+    struct list_head active;
+
+    /* thread for generating video stream*/
+    struct task_struct *kthread;
+    wait_queue_head_t wq;
+    /* Counters to control fps rate */
+    int frame;
+    int ini_jiffies;
+};
+
+struct ppmgr2_device {
+    int dst_width;
+    int dst_height;
+    int ge2d_fmt;
+    int canvas_id[PPMGR2_MAX_CANVAS];
+    void* phy_addr[PPMGR2_MAX_CANVAS];
+    int phy_size;
+    int inited_canvas;
+
+    ge2d_context_t* context;
+    config_para_ex_t ge2d_config;
+
+    int angle;
+    int mirror;
+    int paint_mode;
+};
+
+struct ionvideo_dev {
+    struct list_head ionvideo_devlist;
+    struct v4l2_device v4l2_dev;
+    struct v4l2_ctrl_handler ctrl_handler;
+    struct video_device vdev;
+
+    /* controls */
+    struct v4l2_ctrl *brightness;
+    struct v4l2_ctrl *contrast;
+    struct v4l2_ctrl *saturation;
+    struct v4l2_ctrl *hue;
+    struct {
+        /* autogain/gain cluster */
+        struct v4l2_ctrl *autogain;
+        struct v4l2_ctrl *gain;
+    };
+    struct v4l2_ctrl *volume;
+    struct v4l2_ctrl *alpha;
+    struct v4l2_ctrl *button;
+    struct v4l2_ctrl *boolean;
+    struct v4l2_ctrl *int32;
+    struct v4l2_ctrl *int64;
+    struct v4l2_ctrl *menu;
+    struct v4l2_ctrl *string;
+    struct v4l2_ctrl *bitmask;
+    struct v4l2_ctrl *int_menu;
+
+    spinlock_t slock;
+    struct mutex mutex;
+
+    struct ionvideo_dmaqueue vidq;
+
+    /* Several counters */
+    unsigned ms;
+    unsigned long jiffies;
+    unsigned button_pressed;
+
+    int mv_count; /* Controls bars movement */
+
+    /* Input Number */
+    int input;
+
+    /* video capture */
+    struct ionvideo_fmt *fmt;
+    unsigned int width, height;
+    struct vb2_queue vb_vidq;
+    unsigned int field_count;
+
+    u8 bars[9][3];
+    u8 line[MAX_WIDTH * 8];
+    unsigned int pixelsize;
+    u8 alpha_component;
+
+    struct ppmgr2_device ppmgr2_dev;
+    struct vframe_receiver_s video_vf_receiver;
+    u8 clear_list;
+    u64 pts;
+    u8 receiver_register;
+};
+
+int is_ionvideo_active(void);
+unsigned get_ionvideo_debug(void);
+
+int ppmgr2_init(struct ppmgr2_device *ppd);
+int ppmgr2_canvas_config(struct ppmgr2_device *ppd, int dst_width, int dst_height, int dst_fmt, void* phy_addr, int index);
+int ppmgr2_process(struct vframe_s* vf, struct ppmgr2_device *ppd, int index);
+int ppmgr2_top_process(struct vframe_s* vf, struct ppmgr2_device *ppd, int index);
+int ppmgr2_bottom_process(struct vframe_s* vf, struct ppmgr2_device *ppd, int index);
+void ppmgr2_release(struct ppmgr2_device *ppd);
+void ppmgr2_set_angle(struct ppmgr2_device *ppd, int angle);
+void ppmgr2_set_mirror(struct ppmgr2_device *ppd, int mirror);
+void ppmgr2_set_paint_mode(struct ppmgr2_device *ppd, int paint_mode);
+int v4l_to_ge2d_format(int v4l2_format);
+
+static inline void paint_mode_convert(int paint_mode, int* src_position, int* dst_paint_position, int* dst_plane_position);
+static inline void ge2d_src_config(struct vframe_s* vf, config_para_ex_t* ge2d_config);
+static inline void ge2d_mirror_config(int dst_mirror, config_para_ex_t* ge2d_config);
+static inline void ge2d_angle_config(int dst_angle, config_para_ex_t* ge2d_config);
+static int get_input_format(struct vframe_s* vf);
+static int ge2d_paint_dst(ge2d_context_t *context, config_para_ex_t* ge2d_config, int dst_canvas_id, int dst_pixel_format, int* src_position, int* dst_paint_position, int* dst_plane_position);
+
+
+#endif
diff --git a/drivers/amlogic/ionvideo/ppmgr2.c b/drivers/amlogic/ionvideo/ppmgr2.c
new file mode 100755
index 000000000000..31a9bd1a69f3
--- /dev/null
+++ b/drivers/amlogic/ionvideo/ppmgr2.c
@@ -0,0 +1,382 @@
+/*
+ * GE2D PROCESS --- For video scale and colorspace transform.
+ *
+ * input is vframes, output is physic buffers.
+ *
+ * Author: Shuai Cao <shuai.cao@amlogic.com>
+ */
+
+#include "ionvideo.h"
+
+static inline void paint_mode_convert(int paint_mode, int* src_position, int* dst_paint_position, int* dst_plane_position) {
+
+    if (paint_mode == 0) { //stretch full
+        dst_paint_position[0] = dst_plane_position[0];
+        dst_paint_position[1] = dst_plane_position[1];
+        dst_paint_position[2] = dst_plane_position[2];
+        dst_paint_position[3] = dst_plane_position[3];
+    } else if (paint_mode == 1) { //keep size
+        dst_paint_position[0] = dst_plane_position[2] - src_position[2] >> 1;
+        dst_paint_position[1] = dst_plane_position[3] - src_position[3] >> 1;
+        dst_paint_position[2] = src_position[2];
+        dst_paint_position[3] = src_position[3];
+    } else if (paint_mode == 2) {
+        int dw = 0, dh = 0;
+        if (src_position[2] * dst_plane_position[3] >= dst_plane_position[2] * src_position[3]) { //crop full
+            dh = dst_plane_position[3];
+            dw = dh * src_position[2] / src_position[3];
+        } else {
+            dw = dst_plane_position[2];
+            dh = dw * src_position[3] / src_position[2];
+        }
+        dst_paint_position[0] = dst_plane_position[2] - dw >> 1;
+        dst_paint_position[1] = dst_plane_position[3] - dh >> 1;
+        dst_paint_position[2] = dw;
+        dst_paint_position[3] = dh;
+    } else if (paint_mode == 3) { //keep ration black
+        int dw = 0, dh = 0;
+        if (src_position[2] * dst_plane_position[3] >= dst_plane_position[2] * src_position[3]) {
+            dw = dst_plane_position[2];
+            dh = dw * src_position[3] / src_position[2];
+        } else {
+            dh = dst_plane_position[3];
+            dw = dh * src_position[2] / src_position[3];
+        }
+        dst_paint_position[0] = dst_plane_position[2] - dw >> 1;
+        dst_paint_position[1] = dst_plane_position[3] - dh >> 1;
+        dst_paint_position[2] = dw;
+        dst_paint_position[3] = dh;
+    } else if (paint_mode == 4) {
+
+    }
+}
+
+static inline void ge2d_src_config(struct vframe_s* vf, config_para_ex_t* ge2d_config) {
+    canvas_t src_cs0, src_cs1, src_cs2;
+    struct vframe_s* src_vf = vf;
+
+    /* data operating. */
+    ge2d_config->alu_const_color = 0; //0x000000ff;
+    ge2d_config->bitmask_en = 0;
+    ge2d_config->src1_gb_alpha = 0; //0xff;
+
+    canvas_read(src_vf->canvas0Addr & 0xff, &src_cs0);
+    canvas_read(src_vf->canvas0Addr >> 8 & 0xff, &src_cs1);
+    canvas_read(src_vf->canvas0Addr >> 16 & 0xff, &src_cs2);
+    ge2d_config->src_planes[0].addr = src_cs0.addr;
+    ge2d_config->src_planes[0].w = src_cs0.width;
+    ge2d_config->src_planes[0].h = src_cs0.height;
+    ge2d_config->src_planes[1].addr = src_cs1.addr;
+    ge2d_config->src_planes[1].w = src_cs1.width;
+    ge2d_config->src_planes[1].h = src_cs1.height;
+    ge2d_config->src_planes[2].addr = src_cs2.addr;
+    ge2d_config->src_planes[2].w = src_cs2.width;
+    ge2d_config->src_planes[2].h = src_cs2.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index = src_vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(src_vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = src_vf->width;
+    if (vf->type & VIDTYPE_INTERLACE) {
+        ge2d_config->src_para.height = src_vf->height >> 1;
+    } else {
+        ge2d_config->src_para.height = src_vf->height;
+    }
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ppmgr2_printk(2, "vf_width is %d , vf_height is %d type:%p\n", vf->width, vf->height, vf->type);
+}
+
+static int ge2d_paint_dst(ge2d_context_t *context, config_para_ex_t* ge2d_config, int dst_canvas_id, int dst_pixel_format, int* src_position, int* dst_paint_position, int* dst_plane_position) {
+    canvas_t dst_cd;
+
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = dst_plane_position[0];
+    ge2d_config->dst_para.left = dst_plane_position[1];
+    ge2d_config->dst_para.width = dst_plane_position[2];
+    ge2d_config->dst_para.height = dst_plane_position[3];
+
+    if (dst_pixel_format == GE2D_FORMAT_S8_Y) {
+        canvas_read(dst_canvas_id & 0xff, &dst_cd);
+        ge2d_config->dst_planes[0].addr = dst_cd.addr;
+        ge2d_config->dst_planes[0].w = dst_cd.width;
+        ge2d_config->dst_planes[0].h = dst_cd.height;
+        ge2d_config->dst_para.canvas_index = dst_canvas_id & 0xff;
+        ge2d_config->dst_para.format = dst_pixel_format | GE2D_LITTLE_ENDIAN;
+
+        if (ge2d_context_config_ex(context, ge2d_config) < 0) {
+            ppmgr2_printk(1, "Ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context, src_position[0], src_position[1], src_position[2], src_position[3], dst_paint_position[0], dst_paint_position[1], dst_paint_position[2], dst_paint_position[3]);
+        canvas_read(dst_canvas_id >> 8 & 0xff, &dst_cd);
+        ge2d_config->dst_planes[0].addr = dst_cd.addr;
+        ge2d_config->dst_planes[0].w = dst_cd.width;
+        ge2d_config->dst_planes[0].h = dst_cd.height;
+        ge2d_config->dst_para.canvas_index = dst_canvas_id >> 8 & 0xff;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S8_CB | GE2D_LITTLE_ENDIAN;
+        ge2d_config->dst_para.width = dst_paint_position[2] >> 1;
+        ge2d_config->dst_para.height = dst_paint_position[3] >> 1;
+
+        if (ge2d_context_config_ex(context, ge2d_config) < 0) {
+            ppmgr2_printk(1, "Ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context, src_position[0], src_position[1], src_position[2], src_position[3], dst_paint_position[0], dst_paint_position[1], dst_paint_position[2], dst_paint_position[3]);
+
+        canvas_read(dst_canvas_id >> 16 & 0xff, &dst_cd);
+        ge2d_config->dst_planes[0].addr = dst_cd.addr;
+        ge2d_config->dst_planes[0].w = dst_cd.width;
+        ge2d_config->dst_planes[0].h = dst_cd.height;
+        ge2d_config->dst_para.canvas_index = dst_canvas_id >> 16 & 0xff;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S8_CR | GE2D_LITTLE_ENDIAN;
+
+        if (ge2d_context_config_ex(context, ge2d_config) < 0) {
+            ppmgr2_printk(1, "Ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context, src_position[0], src_position[1], src_position[2], src_position[3], dst_paint_position[0], dst_paint_position[1], dst_paint_position[2], dst_paint_position[3]);
+    } else {
+        canvas_read(dst_canvas_id & 0xff, &dst_cd);
+        ge2d_config->dst_planes[0].addr = dst_cd.addr;
+        ge2d_config->dst_planes[0].w = dst_cd.width;
+        ge2d_config->dst_planes[0].h = dst_cd.height;
+        ge2d_config->dst_para.format = dst_pixel_format | GE2D_LITTLE_ENDIAN;
+        ge2d_config->dst_para.canvas_index = dst_canvas_id;
+
+        if (ge2d_context_config_ex(context, ge2d_config) < 0) {
+            ppmgr2_printk(1, "Ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context, src_position[0], src_position[1], src_position[2], src_position[3], dst_paint_position[0], dst_paint_position[1], dst_paint_position[2], dst_paint_position[3]);
+    }
+    ppmgr2_printk(2, "dst addr:%p w:%d h:%d canvas_id:%p format:%p\n", dst_cd.addr, dst_cd.width, dst_cd.height, dst_canvas_id, ge2d_config->dst_para.format);
+    ppmgr2_printk(2, "dst plane w:%d h:%d paint w:%d h:%d\n", dst_plane_position[2], dst_plane_position[3], dst_paint_position[2], dst_paint_position[3]);
+
+    return 0;
+}
+
+static inline void ge2d_mirror_config(int dst_mirror, config_para_ex_t* ge2d_config) {
+    if (dst_mirror == 1) {
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev = 0;
+    } else if (dst_mirror == 2) {
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 1;
+    } else {
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+    }
+}
+
+static inline void ge2d_angle_config(int dst_angle, config_para_ex_t* ge2d_config) {
+    if (dst_angle == 1) {
+        ge2d_config->dst_xy_swap = 1;
+        ge2d_config->dst_para.x_rev ^= 1;
+    } else if (dst_angle == 2) {
+        ge2d_config->dst_para.x_rev ^= 1;
+        ge2d_config->dst_para.y_rev ^= 1;
+    } else if (dst_angle == 3) {
+        ge2d_config->dst_xy_swap = 1;
+        ge2d_config->dst_para.y_rev ^= 1;
+    } else {
+        ge2d_config->dst_xy_swap = 0;
+    }
+}
+
+static int get_input_format(struct vframe_s* vf) {
+    int format = GE2D_FORMAT_M24_NV21;
+
+    if (vf->type & VIDTYPE_VIU_422) {
+        if ((vf->type & 3) == VIDTYPE_INTERLACE_BOTTOM) {
+            format = GE2D_FORMAT_S16_YUV422 | (GE2D_FORMAT_S16_YUV422B & (3 << 3));
+        } else if ((vf->type & 3) == VIDTYPE_INTERLACE_TOP) {
+            format = GE2D_FORMAT_S16_YUV422 | (GE2D_FORMAT_S16_YUV422T & (3 << 3));
+        } else {
+            format = GE2D_FORMAT_S16_YUV422;
+        }
+    } else if (vf->type & VIDTYPE_VIU_NV21) {
+        if ((vf->type & 3) == VIDTYPE_INTERLACE_BOTTOM) {
+            format = GE2D_FORMAT_M24_NV21 | (GE2D_FORMAT_M24_NV21B & (3 << 3));
+        } else if ((vf->type & 3) == VIDTYPE_INTERLACE_TOP) {
+            format = GE2D_FORMAT_M24_NV21 | (GE2D_FORMAT_M24_NV21T & (3 << 3));
+        } else {
+            format = GE2D_FORMAT_M24_NV21;
+        }
+    } else {
+        if ((vf->type & 3) == VIDTYPE_INTERLACE_BOTTOM) {
+            format = GE2D_FORMAT_M24_YUV420 | (GE2D_FMT_M24_YUV420B & (3 << 3));
+        } else if ((vf->type & 3) == VIDTYPE_INTERLACE_TOP) {
+            format = GE2D_FORMAT_M24_YUV420 | (GE2D_FORMAT_M24_YUV420T & (3 << 3));
+        } else {
+            format = GE2D_FORMAT_M24_YUV420;
+        }
+    }
+    return format;
+}
+
+/*
+ * use ppmgr2 need to init ge2d_context_t, pixel_format, canvas_width, canvas_height,
+ * phy_addr, buffer_size, canvas_number.
+ */
+int ppmgr2_init(struct ppmgr2_device *ppd) {
+    switch_mod_gate_by_name("ge2d", 1);
+    ppd->context = create_ge2d_work_queue();
+    if (!ppd->context) {
+        ppmgr2_printk(1, "create ge2d work queue error!\n");
+        return -1;
+    }
+    ppmgr2_printk(2, "ppmgr2_init!\n");
+    ppd->paint_mode = 0;
+    ppd->angle = 0;
+    ppd->mirror = 0;
+    ppd->inited_canvas = 0;
+    return 0;
+}
+
+int ppmgr2_canvas_config(struct ppmgr2_device *ppd, int dst_width, int dst_height, int dst_fmt, void* phy_addr, int index) {
+    int canvas_width = dst_width;
+    int canvas_height = dst_height;
+
+    if (!ppd->phy_addr) {
+        ppmgr2_printk(1, "NULL physical address!\n");
+        return -1;
+    }
+    ppd->ge2d_fmt = v4l_to_ge2d_format(dst_fmt);
+    ppd->dst_width = dst_width;
+    ppd->dst_height = dst_height;
+    ppd->phy_addr[index] = phy_addr;
+
+    if (ppd->ge2d_fmt == GE2D_FORMAT_M24_NV21 || ppd->ge2d_fmt == GE2D_FORMAT_M24_NV12) {
+        canvas_config(PPMGR2_CANVAS_INDEX + index * 2, (ulong) phy_addr, canvas_width, canvas_height, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config(PPMGR2_CANVAS_INDEX + index * 2 + 1, (ulong)(phy_addr + (canvas_width * canvas_height)), canvas_width, canvas_height >> 1, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        ppd->canvas_id[index] = (PPMGR2_CANVAS_INDEX + index * 2) | (PPMGR2_CANVAS_INDEX + index * 2 + 1 << 8);
+    } else if (ppd->ge2d_fmt == GE2D_FORMAT_S8_Y) {
+        canvas_config(PPMGR2_CANVAS_INDEX + index * 3, (ulong) phy_addr, canvas_width, canvas_height, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config(PPMGR2_CANVAS_INDEX + index * 3 + 1, (ulong)(phy_addr + canvas_width * canvas_height), canvas_width >> 1, canvas_height >> 1, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config(PPMGR2_CANVAS_INDEX + index * 3 + 2, (ulong)(phy_addr + (canvas_width * canvas_height * 5 >> 2)), canvas_width >> 1, canvas_height >> 1, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        ppd->canvas_id[index] = (PPMGR2_CANVAS_INDEX + index * 3) | (PPMGR2_CANVAS_INDEX + index * 3 + 1 << 8) | (PPMGR2_CANVAS_INDEX + index * 3 + 2 << 16);
+    } else {
+        int bpp = 0;
+        if (ppd->ge2d_fmt == GE2D_FORMAT_S32_ABGR) {
+            bpp = 4;
+        } else if (ppd->ge2d_fmt == GE2D_FORMAT_S24_BGR || ppd->ge2d_fmt == GE2D_FORMAT_S24_RGB) {
+            bpp = 3;
+        } else if (ppd->ge2d_fmt == GE2D_FORMAT_S16_RGB_565) {
+            bpp = 2;
+        } else {
+            ppmgr2_printk(1, "Not support format!\n");
+            return -1;
+        }
+        canvas_config(PPMGR2_CANVAS_INDEX + index, (ulong)phy_addr, canvas_width * bpp, canvas_height, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        ppd->canvas_id[index] = PPMGR2_CANVAS_INDEX + index;
+
+    }
+    ppmgr2_printk(2, "canvas[%d] phy_addr:%p width:%d height:%d\n", index, phy_addr, canvas_width, canvas_height);
+
+    return 0;
+}
+
+void ppmgr2_set_angle(struct ppmgr2_device *ppd, int angle) {
+    ppd->angle = angle;
+}
+
+void ppmgr2_set_mirror(struct ppmgr2_device *ppd, int mirror) {
+    ppd->mirror = mirror;
+}
+
+void ppmgr2_set_paint_mode(struct ppmgr2_device *ppd, int paint_mode) {
+    ppd->paint_mode = paint_mode;
+}
+
+int ppmgr2_process(struct vframe_s* vf, struct ppmgr2_device *ppd, int index) {
+    int ret = 0;
+    struct vframe_s* src_vf = vf;
+    int src_position[4];
+    int dst_paint_position[4], dst_plane_position[4];
+    int dst_canvas_id = ppd->canvas_id[index];
+    int dst_pixel_format = ppd->ge2d_fmt;
+    ge2d_context_t *context = ppd->context;
+    config_para_ex_t* ge2d_config = &(ppd->ge2d_config);
+
+    src_position[0] = 0;
+    src_position[1] = 0;
+    src_position[2] = src_vf->width;
+    src_position[3] = src_vf->height;
+    if (src_position[2] == 0 || src_position[3] == 0) {
+        ppmgr2_printk(1, "Source frame error!\n");
+        return -1;
+    }
+    dst_plane_position[0] = 0;
+    dst_plane_position[1] = 0;
+    dst_plane_position[2] = ppd->dst_width;
+    dst_plane_position[3] = ppd->dst_height;
+
+    ge2d_src_config(src_vf, ge2d_config);
+
+    ge2d_mirror_config(ppd->mirror, ge2d_config);
+    ge2d_angle_config(ppd->angle, ge2d_config);
+    paint_mode_convert(ppd->paint_mode, src_position, dst_paint_position, dst_plane_position);
+
+    if(src_vf->type & VIDTYPE_INTERLACE) {
+        src_position[3] = src_vf->height >> 1;
+    }
+    ret = ge2d_paint_dst(context, ge2d_config, dst_canvas_id, dst_pixel_format, src_position, dst_paint_position, dst_plane_position);
+
+    if (!ret && (src_vf->type & 3) == VIDTYPE_INTERLACE_TOP) {
+        ret = -EAGAIN;
+    }
+    return ret;
+}
+
+void ppmgr2_release(struct ppmgr2_device *ppd) {
+    if (ppd->context) {
+        destroy_ge2d_work_queue(ppd->context);
+    }
+    switch_mod_gate_by_name("ge2d", 0);
+    ppmgr2_printk(2, "ppmgr2_release!\n");
+}
+
+int v4l_to_ge2d_format(int v4l2_format) {
+    int format = GE2D_FORMAT_M24_NV21;
+
+    switch (v4l2_format) {
+    case V4L2_PIX_FMT_RGB32:
+        format = GE2D_FORMAT_S32_ABGR;
+        break;
+    case V4L2_PIX_FMT_RGB565:
+        format = GE2D_FORMAT_S16_RGB_565;
+        break;
+    case V4L2_PIX_FMT_BGR24:
+        format = GE2D_FORMAT_S24_RGB;
+        break;
+    case V4L2_PIX_FMT_RGB24:
+        format = GE2D_FORMAT_S24_BGR;
+        break;
+    case V4L2_PIX_FMT_NV12:
+        format = GE2D_FORMAT_M24_NV12;
+        break;
+    case V4L2_PIX_FMT_NV21:
+        format = GE2D_FORMAT_M24_NV21;
+        break;
+    case V4L2_PIX_FMT_YUV420:
+    case V4L2_PIX_FMT_YVU420:
+        format = GE2D_FORMAT_S8_Y;
+        break;
+    default:
+        break;
+    }
+    return format;
+}
diff --git a/drivers/amlogic/ionvideo/videobuf2-ion.c b/drivers/amlogic/ionvideo/videobuf2-ion.c
new file mode 100755
index 000000000000..92706e316be1
--- /dev/null
+++ b/drivers/amlogic/ionvideo/videobuf2-ion.c
@@ -0,0 +1,276 @@
+/*
+ * videobuf2-ion.c - ion carveout memory allocator for videobuf2
+ *
+ * Author: Shuai Cao <shuai.cao@amlogic.com>
+ *
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-memops.h>
+
+#include <asm/mach/map.h>
+#include <linux/ion.h>
+#include "ion_priv.h"
+#include "videobuf2-ion.h"
+
+struct vb2_ion_buf {
+    void *vaddr;
+    struct page **pages;
+    struct vm_area_struct *vma;
+    int write;
+    unsigned long size;
+    unsigned int n_pages;
+    atomic_t refcount;
+    struct vb2_vmarea_handler handler;
+    struct dma_buf *dbuf;
+};
+
+static void vb2_ion_put(void *buf_priv);
+
+static void *vb2_ion_alloc(void *alloc_ctx, unsigned long size) {
+    struct vb2_ion_buf *buf;
+
+    buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+    if (!buf)
+        return NULL;
+
+    buf->size = size;
+    buf->vaddr = vmalloc_user(buf->size);
+    buf->handler.refcount = &buf->refcount;
+    buf->handler.put = vb2_ion_put;
+    buf->handler.arg = buf;
+
+    if (!buf->vaddr) {
+        pr_debug("ion of size %ld failed\n", buf->size);
+        kfree(buf);
+        return NULL;
+    }
+
+    atomic_inc(&buf->refcount);
+
+    return buf;
+}
+
+static void vb2_ion_put(void *buf_priv) {
+    struct vb2_ion_buf *buf = buf_priv;
+
+    if (atomic_dec_and_test(&buf->refcount)) {
+        vfree(buf->vaddr);
+        kfree(buf);
+    }
+}
+
+static void *vb2_ion_get_userptr(void *alloc_ctx, unsigned long vaddr, unsigned long size, int write) {
+    struct vb2_ion_buf *buf;
+    unsigned long first, last;
+    int n_pages, offset;
+    struct vm_area_struct *vma;
+    dma_addr_t physp;
+
+    buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+    if (!buf)
+        return NULL;
+
+    buf->write = write;
+    offset = vaddr & ~PAGE_MASK;
+    buf->size = size;
+
+    vma = find_vma(current->mm, vaddr);
+    if (vma && (vma->vm_flags & VM_PFNMAP) && (vma->vm_pgoff)) {
+        if (vb2_get_contig_userptr(vaddr, size, &vma, &physp))
+            goto fail_pages_array_alloc;
+        buf->vma = vma;
+        buf->vaddr = ioremap_nocache(physp, size);
+        if (!buf->vaddr)
+            goto fail_pages_array_alloc;
+    } else {
+        first = vaddr >> PAGE_SHIFT;
+        last = (vaddr + size - 1) >> PAGE_SHIFT;
+        buf->n_pages = last - first + 1;
+        buf->pages = kzalloc(buf->n_pages * sizeof(struct page *), GFP_KERNEL);
+        if (!buf->pages)
+            goto fail_pages_array_alloc;
+
+        /* current->mm->mmap_sem is taken by videobuf2 core */
+        n_pages = get_user_pages(current, current->mm, vaddr & PAGE_MASK, buf->n_pages, write, 1, /* force */
+        buf->pages, NULL);
+        if (n_pages != buf->n_pages)
+            goto fail_get_user_pages;
+
+        buf->vaddr = vm_map_ram(buf->pages, buf->n_pages, -1, PAGE_KERNEL);
+        if (!buf->vaddr)
+            goto fail_get_user_pages;
+    }
+
+    buf->vaddr += offset;
+    return buf;
+
+fail_get_user_pages:
+    pr_debug("get_user_pages requested/got: %d/%d]\n", n_pages, buf->n_pages);
+    while (--n_pages >= 0)
+        put_page(buf->pages[n_pages]);
+    kfree(buf->pages);
+
+    fail_pages_array_alloc: kfree(buf);
+
+    return NULL;
+}
+
+static void vb2_ion_put_userptr(void *buf_priv) {
+    struct vb2_ion_buf *buf = buf_priv;
+    unsigned long vaddr = (unsigned long) buf->vaddr & PAGE_MASK;
+    unsigned int i;
+
+    if (buf->pages) {
+        if (vaddr)
+            vm_unmap_ram((void *) vaddr, buf->n_pages);
+        for (i = 0; i < buf->n_pages; ++i) {
+            if (buf->write)
+                set_page_dirty_lock(buf->pages[i]);
+            put_page(buf->pages[i]);
+        }
+        kfree(buf->pages);
+    } else {
+        if (buf->vma)
+            vb2_put_vma(buf->vma);
+        iounmap(buf->vaddr);
+    }
+    kfree(buf);
+}
+
+static void *vb2_ion_vaddr(void *buf_priv) {
+    struct vb2_ion_buf *buf = buf_priv;
+
+    if (!buf->vaddr) {
+        pr_err("Address of an unallocated plane requested "
+                "or cannot map user pointer\n");
+        return NULL;
+    }
+
+    return buf->vaddr;
+}
+
+static unsigned int vb2_ion_num_users(void *buf_priv) {
+    struct vb2_ion_buf *buf = buf_priv;
+    return atomic_read(&buf->refcount);
+}
+
+static int vb2_ion_mmap(void *buf_priv, struct vm_area_struct *vma) {
+    struct vb2_ion_buf *buf = buf_priv;
+    int ret;
+    printk("11vb2_ion_mmap\n");
+    if (!buf) {
+        pr_err("No memory to map\n");
+        return -EINVAL;
+    }
+
+    ret = remap_vmalloc_range(vma, buf->vaddr, 0);
+    if (ret) {
+        pr_err("Remapping ion memory, error: %d\n", ret);
+        return ret;
+    }
+
+    /*
+     * Make sure that vm_areas for 2 buffers won't be merged together
+     */
+    vma->vm_flags |= VM_DONTEXPAND;
+
+    /*
+     * Use common vm_area operations to track buffer refcount.
+     */
+    vma->vm_private_data = &buf->handler;
+    vma->vm_ops = &vb2_common_vm_ops;
+
+    vma->vm_ops->open(vma);
+    printk("22vb2_ion_mmap\n");
+    return 0;
+}
+
+/*********************************************/
+/*       callbacks for DMABUF buffers        */
+/*********************************************/
+
+static int vb2_ion_map_dmabuf(void *mem_priv) {
+    struct vb2_ion_buf *buf = mem_priv;
+
+    struct ion_buffer *buffer = buf->dbuf->priv;
+    int mtype = MT_MEMORY_NONCACHED;
+
+    if (buffer->flags & ION_FLAG_CACHED)
+        mtype = MT_MEMORY;
+    buf->vaddr = __arm_ioremap(buffer->priv_phys, buffer->size, mtype);
+
+    return buf->vaddr ? 0 : -EFAULT;
+}
+
+static void vb2_ion_unmap_dmabuf(void *mem_priv) {
+    struct vb2_ion_buf *buf = mem_priv;
+    struct ion_buffer *buffer = buf->dbuf->priv;
+
+    __arm_iounmap(buf->vaddr);
+
+    buf->vaddr = NULL;
+}
+
+static void vb2_ion_detach_dmabuf(void *mem_priv) {
+    struct vb2_ion_buf *buf = mem_priv;
+
+    if (buf->vaddr)
+        dma_buf_vunmap(buf->dbuf, buf->vaddr);
+
+    kfree(buf);
+}
+
+static void *vb2_ion_attach_dmabuf(void *alloc_ctx, struct dma_buf *dbuf, unsigned long size, int write) {
+    struct vb2_ion_buf *buf;
+
+    if (dbuf->size < size)
+        return ERR_PTR(-EFAULT);
+
+    buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+    if (!buf)
+        return ERR_PTR(-ENOMEM);
+
+    buf->dbuf = dbuf;
+    buf->write = write;
+    buf->size = size;
+
+    return buf;
+}
+
+static void *vb2_ion_cookie(void *buf_priv)
+{
+    struct vb2_ion_buf *buf = buf_priv;
+
+    struct ion_buffer *buffer = buf->dbuf->priv;
+
+    return buffer->priv_phys;
+}
+
+const struct vb2_mem_ops vb2_ion_memops = {
+    .alloc = vb2_ion_alloc,
+    .put = vb2_ion_put,
+    .get_userptr = vb2_ion_get_userptr,
+    .put_userptr = vb2_ion_put_userptr,
+    .map_dmabuf = vb2_ion_map_dmabuf,
+    .unmap_dmabuf = vb2_ion_unmap_dmabuf,
+    .attach_dmabuf = vb2_ion_attach_dmabuf,
+    .detach_dmabuf = vb2_ion_detach_dmabuf,
+    .vaddr = vb2_ion_vaddr,
+    .mmap = vb2_ion_mmap,
+    .num_users = vb2_ion_num_users,
+    .cookie     = vb2_ion_cookie,
+};
+EXPORT_SYMBOL_GPL (vb2_ion_memops);
+
+MODULE_DESCRIPTION("ion memory handling routines for videobuf2");
+MODULE_AUTHOR("Shuai Cao <shuai.cao@amlogic.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/ionvideo/videobuf2-ion.h b/drivers/amlogic/ionvideo/videobuf2-ion.h
new file mode 100755
index 000000000000..28008c477e40
--- /dev/null
+++ b/drivers/amlogic/ionvideo/videobuf2-ion.h
@@ -0,0 +1,20 @@
+/*
+ * videobuf2-vmalloc.h - vmalloc memory allocator for videobuf2
+ *
+ * Copyright (C) 2010 Samsung Electronics
+ *
+ * Author: Pawel Osciak <pawel@osciak.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef _MEDIA_VIDEOBUF2_ION_H
+#define _MEDIA_VIDEOBUF2_ION_H
+
+#include <media/videobuf2-core.h>
+
+extern const struct vb2_mem_ops vb2_ion_memops;
+
+#endif
-- 
2.19.0

