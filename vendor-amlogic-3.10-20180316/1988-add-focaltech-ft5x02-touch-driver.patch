From f6d672a5a4f4c04a208ef7aeaffe0ff1d32f0be6 Mon Sep 17 00:00:00 2001
From: "chunxue.yu" <chunxue.yu@amlogic.com>
Date: Wed, 20 Nov 2013 11:41:37 +0800
Subject: [PATCH 1988/5965] add focaltech ft5x02 touch driver

---
 .../amlogic/input/touchscreen/ft5x02/Makefile |    6 +
 .../input/touchscreen/ft5x02/ft5x02_config.c  | 1542 +++++++++++++++++
 .../input/touchscreen/ft5x02/ft5x02_config.h  |   68 +
 .../input/touchscreen/ft5x02/ft5x02_ts.c      |  957 ++++++++++
 .../input/touchscreen/ft5x02/ft5x02_ts.h      |   65 +
 5 files changed, 2638 insertions(+)
 create mode 100755 drivers/amlogic/input/touchscreen/ft5x02/Makefile
 create mode 100755 drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.c
 create mode 100755 drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.h
 create mode 100755 drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c
 create mode 100755 drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.h

diff --git a/drivers/amlogic/input/touchscreen/ft5x02/Makefile b/drivers/amlogic/input/touchscreen/ft5x02/Makefile
new file mode 100755
index 000000000000..10ed95b7f861
--- /dev/null
+++ b/drivers/amlogic/input/touchscreen/ft5x02/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the touchscreen drivers.
+#
+
+# Each configuration option enables a list of files.
+obj-$(CONFIG_FT5X02_CAPACITIVE_TOUCHSCREEN)	+= ft5x02_config.o ft5x02_ts.o
\ No newline at end of file
diff --git a/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.c b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.c
new file mode 100755
index 000000000000..eeb696cc79b7
--- /dev/null
+++ b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.c
@@ -0,0 +1,1542 @@
+#include "ft5x02_config.h"
+#include "ft5x02_ts.h"
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <mach/irqs.h>
+
+#include <linux/syscalls.h>
+#include <asm/unistd.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+
+
+/*Init param register address*/
+/*factory mode register*/
+#define FT5x02_REG_TX_NUM				0x03
+#define FT5x02_REG_RX_NUM				0x04
+#define FT5x02_REG_VOLTAGE				0x05
+#define FT5x02_REG_RX_START			0x06
+#define FT5x02_REG_GAIN					0x07
+#define FT5X02_REG_SCAN_SELECT		0xe8
+#define FT5x02_REG_TX_ORDER_START		0x50
+#define FT5x02_REG_TX_CAP_START		0x78
+#define FT5x02_REG_TX_OFFSET_START	0xBF
+#define FT5x02_REG_RX_ORDER_START		0xea
+#define FT5x02_REG_RX_CAP_START		0xA0
+#define FT5x02_REG_RX_OFFSET_START	0xD3
+
+#define FT5x02_REG_DEVICE_MODE		0x00
+
+/*work mode register*/
+#define FT5X02_REG_THGROUP						(0x00+0x80)
+#define FT5X02_REG_THPEAK 						(0x01+0x80)
+#define FT5X02_REG_THCAL 						(0x02+0x80)
+#define FT5X02_REG_THWATER 					(0x03+0x80)
+#define FT5X02_REG_THFALSE_TOUCH_PEAK 		(0x04+0x80)
+#define FT5X02_REG_THDIFF						(0x05+0x80)
+#define FT5X02_REG_CTRL							(0x06+0x80)
+#define FT5X02_REG_TIMEENTERMONITOR 			(0x07+0x80)
+#define FT5X02_REG_PERIODACTIVE				(0x08+0x80)
+#define FT5X02_REG_PERIODMONITOR 				(0x09+0x80)
+#define FT5x02_REG_RESOLUTION_X_H				(0x18+0x80)
+#define FT5x02_REG_RESOLUTION_X_L				(0x19+0x80)
+#define FT5x02_REG_RESOLUTION_Y_H				(0x1a+0x80)
+#define FT5x02_REG_RESOLUTION_Y_L				(0x1b+0x80)
+#define FT5X02_REG_KX_H						(0x1c+0x80)
+#define FT5X02_REG_KX_L							(0x1d+0x80)
+#define FT5X02_REG_KY_H						0x9e
+#define FT5X02_REG_KY_L							(0x1f+0x80)
+#define FT5X02_REG_AUTO_CLB_MODE				(0x20+0x80)
+#define FT5X02_REG_LIB_VERSION_H				(0x21+0x80)
+#define FT5X02_REG_LIB_VERSION_L				(0x22+0x80)
+#define FT5X02_REG_CIPHER						(0x23+0x80)
+#define FT5X02_REG_MODE						(0x24+0x80)
+#define FT5X02_REG_PMODE						(0x25+0x80)
+#define FT5X02_REG_FIRMID						(0x26+0x80)
+#define FT5X02_REG_STATE						(0x27+0x80)
+#define FT5X02_REG_STATIC_TH					(0x2b+0x80)
+#define FT5X02_REG_DRAW_LINE_TH				0xae
+#define FT5X02_REG_FACE_DEC_MODE				(0x33+0x80)
+#define FT5X02_REG_MAX_TOUCH_VALUE_HIGH		(0x34+0x80)
+#define FT5X02_REG_MAX_TOUCH_VALUE_LOW		(0x35+0x80)
+
+#define FT5X02_REG_POS_X						(0x40+0x80)
+#define FT5X02_REG_LEMDA_X						(0x41+0x80)
+#define FT5X02_REG_LEMDA_Y						(0x42+0x80)
+#define FT5X02_REG_STATISTICS_TX_NUM			(0x43+0x80)
+#define FT5X02_REG_FACE_DETECT_PRE_VALUE		(0x44+0x80)
+#define FT5X02_REG_FACE_DETECT_NUM			(0x45+0x80)
+#define FT5X02_REG_FACE_DETECT_LAST_TIME_H	(0x46+0x80)
+#define FT5X02_REG_FACE_DETECT_LAST_TIME_L	(0x47+0x80)
+#define FT5X02_REG_FACE_DETECT_ON				(0x48+0x80)
+#define FT5X02_REG_FACE_DETECT_OFF			(0x49+0x80)
+#define FT5X02_REG_PEAK_VALUE_MIN				(0x4a+0x80)
+#define FT5X02_REG_DIFF_VALUE_OVER_NUM		(0x4b+0x80)
+//#define FT5X02_REG_DIFF_VALUE_PERCENT		
+#define FT5X02_REG_POINT_AUTO_CLEAR_TIME_H	(0x4c+0x80)
+#define FT5X02_REG_POINT_AUTO_CLEAR_TIME_L	(0x4d+0x80)
+#define FT5X02_REG_DIFFDATA_HADDLE_VALUE       0xce//(0x4e+0x80)
+
+
+/**/
+#define FT5x02_REG_TEST_MODE			0x04
+#define FT5x02_REG_TEST_MODE_2		0x05
+#define FT5x02_TX_TEST_MODE_1			0x28
+#define FT5x02_RX_TEST_MODE_1			0x1E
+#define FT5x02_FACTORYMODE_VALUE		0x40
+#define FT5x02_WORKMODE_VALUE		0x00
+
+/*set tx order
+*@txNO:		offset from tx order start
+*@txNO1:	tx NO.
+*/
+static int ft5x02_set_tx_order(struct i2c_client * client, u8 txNO, u8 txNO1)
+{
+	unsigned char ReCode = 0;
+	if (txNO < FT5x02_TX_TEST_MODE_1)
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_TX_ORDER_START + txNO,
+						txNO1);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0)
+			ReCode = ft5x02_write_reg(client,
+					FT5x02_REG_TX_ORDER_START + txNO - FT5x02_TX_TEST_MODE_1,
+					txNO1);
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	return ReCode;
+}
+
+/*set tx order
+*@txNO:		offset from tx order start
+*@pTxNo:	return value of tx NO.
+*/
+static int ft5x02_get_tx_order(struct i2c_client * client, u8 txNO, u8 *pTxNo)
+{
+	unsigned char ReCode = 0;
+	if (txNO < FT5x02_TX_TEST_MODE_1)
+		ReCode = ft5x02_read_reg(client, FT5x02_REG_TX_ORDER_START + txNO,
+						pTxNo);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if(ReCode >= 0)
+			ReCode =  ft5x02_read_reg(client,
+					FT5x02_REG_TX_ORDER_START + txNO - FT5x02_TX_TEST_MODE_1,
+					pTxNo);	
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	return ReCode;
+}
+
+/*set tx cap
+*@txNO: 	tx NO.
+*@cap_value:	value of cap
+*/
+static int ft5x02_set_tx_cap(struct i2c_client * client, u8 txNO, u8 cap_value)
+{
+	unsigned char ReCode = 0;
+	if (txNO < FT5x02_TX_TEST_MODE_1)
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_TX_CAP_START + txNO,
+						cap_value);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0)
+			ReCode = ft5x02_write_reg(client,
+					FT5x02_REG_TX_CAP_START + txNO - FT5x02_TX_TEST_MODE_1,
+					cap_value);
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	return ReCode;
+}
+
+/*get tx cap*/
+static int ft5x02_get_tx_cap(struct i2c_client * client, u8 txNO, u8 *pCap)
+{
+	unsigned char ReCode = 0;
+	if (txNO < FT5x02_TX_TEST_MODE_1)
+		ReCode =  ft5x02_read_reg(client, FT5x02_REG_TX_CAP_START + txNO,
+					pCap);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0)
+			ReCode = ft5x02_read_reg(client,
+					FT5x02_REG_TX_CAP_START + txNO - FT5x02_TX_TEST_MODE_1,
+					pCap);
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	return ReCode;
+}
+
+/*set tx offset*/
+static int ft5x02_set_tx_offset(struct i2c_client * client, u8 txNO, u8 offset_value)
+{
+	unsigned char temp=0;
+	unsigned char ReCode = 0;
+	if (txNO < FT5x02_TX_TEST_MODE_1) {
+		ReCode = ft5x02_read_reg(client,
+				FT5x02_REG_TX_OFFSET_START + (txNO>>1), &temp);
+		if (ReCode >= 0) {
+			if (txNO%2 == 0)
+				ReCode = ft5x02_write_reg(client,
+							FT5x02_REG_TX_OFFSET_START + (txNO>>1),
+							(temp&0xf0) + (offset_value&0x0f));	
+			else
+				ReCode = ft5x02_write_reg(client,
+							FT5x02_REG_TX_OFFSET_START + (txNO>>1),
+							(temp&0x0f) + (offset_value<<4));	
+		}
+	} else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0) {
+			ReCode = ft5x02_read_reg(client,
+				FT5x02_REG_DEVICE_MODE+((txNO-FT5x02_TX_TEST_MODE_1)>>1),
+				&temp);	/*enter Test mode 2*/
+			if (ReCode >= 0) {
+				if(txNO%2 == 0)
+					ReCode = ft5x02_write_reg(client,
+						FT5x02_REG_TX_OFFSET_START+((txNO-FT5x02_TX_TEST_MODE_1)>>1),
+						(temp&0xf0)+(offset_value&0x0f));	
+				else
+					ReCode = ft5x02_write_reg(client,
+						FT5x02_REG_TX_OFFSET_START+((txNO-FT5x02_TX_TEST_MODE_1)>>1),
+						(temp&0xf0)+(offset_value<<4));	
+			}
+		}
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	
+	return ReCode;
+}
+
+/*get tx offset*/
+static int ft5x02_get_tx_offset(struct i2c_client * client, u8 txNO, u8 *pOffset)
+{
+	unsigned char temp=0;
+	unsigned char ReCode = 0;
+	if (txNO < FT5x02_TX_TEST_MODE_1)
+		ReCode = ft5x02_read_reg(client,
+				FT5x02_REG_TX_OFFSET_START + (txNO>>1), &temp);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0)
+			ReCode = ft5x02_read_reg(client,
+						FT5x02_REG_TX_OFFSET_START+((txNO-FT5x02_TX_TEST_MODE_1)>>1),
+						&temp);
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+
+	if (ReCode >= 0)
+		(txNO%2 == 0) ? (*pOffset = (temp&0x0f)) : (*pOffset = (temp>>4));
+	return ReCode;
+}
+
+/*set rx order*/
+static int ft5x02_set_rx_order(struct i2c_client * client, u8 rxNO, u8 rxNO1)
+{
+	unsigned char ReCode = 0;
+	ReCode = ft5x02_write_reg(client, FT5x02_REG_RX_ORDER_START + rxNO,
+						rxNO1);
+	return ReCode;
+}
+
+/*get rx order*/
+static int ft5x02_get_rx_order(struct i2c_client * client, u8 rxNO, u8 *prxNO1)
+{
+	unsigned char ReCode = 0;
+	ReCode = ft5x02_read_reg(client, FT5x02_REG_RX_ORDER_START + rxNO,
+						prxNO1);
+	return ReCode;
+}
+
+/*set rx cap*/
+static int ft5x02_set_rx_cap(struct i2c_client * client, u8 rxNO, u8 cap_value)
+{
+	unsigned char ReCode = 0;
+	if (rxNO < FT5x02_RX_TEST_MODE_1)
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_RX_CAP_START + rxNO,
+						cap_value);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if(ReCode >= 0)
+			ReCode = ft5x02_write_reg(client,
+					FT5x02_REG_RX_CAP_START + rxNO - FT5x02_RX_TEST_MODE_1,
+					cap_value);
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	
+	return ReCode;
+}
+
+/*get rx cap*/
+static int ft5x02_get_rx_cap(struct i2c_client * client, u8 rxNO, u8 *pCap)
+{
+	unsigned char ReCode = 0;
+	if (rxNO < FT5x02_RX_TEST_MODE_1)
+		ReCode = ft5x02_read_reg(client, FT5x02_REG_RX_CAP_START + rxNO,
+						pCap);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if(ReCode >= 0)
+			ReCode = ft5x02_read_reg(client,
+					FT5x02_REG_RX_CAP_START + rxNO - FT5x02_RX_TEST_MODE_1,
+					pCap);
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	
+	return ReCode;
+}
+
+/*set rx offset*/
+static int ft5x02_set_rx_offset(struct i2c_client * client, u8 rxNO, u8 offset_value)
+{
+	unsigned char temp=0;
+	unsigned char ReCode = 0;
+	if (rxNO < FT5x02_RX_TEST_MODE_1) {
+		ReCode = ft5x02_read_reg(client,
+				FT5x02_REG_RX_OFFSET_START + (rxNO>>1), &temp);
+		if (ReCode >= 0) {
+			if (rxNO%2 == 0)
+				ReCode = ft5x02_write_reg(client,
+							FT5x02_REG_RX_OFFSET_START + (rxNO>>1),
+							(temp&0xf0) + (offset_value&0x0f));	
+			else
+				ReCode = ft5x02_write_reg(client,
+							FT5x02_REG_RX_OFFSET_START + (rxNO>>1),
+							(temp&0x0f) + (offset_value<<4));	
+		}
+	}
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0) {
+			ReCode = ft5x02_read_reg(client,
+				FT5x02_REG_DEVICE_MODE+((rxNO-FT5x02_RX_TEST_MODE_1)>>1),
+				&temp);	/*enter Test mode 2*/
+			if (ReCode >= 0) {
+				if (rxNO%2 == 0)
+					ReCode = ft5x02_write_reg(client,
+						FT5x02_REG_RX_OFFSET_START+((rxNO-FT5x02_RX_TEST_MODE_1)>>1),
+						(temp&0xf0)+(offset_value&0x0f));	
+				else
+					ReCode = ft5x02_write_reg(client,
+						FT5x02_REG_RX_OFFSET_START+((rxNO-FT5x02_RX_TEST_MODE_1)>>1),
+						(temp&0xf0)+(offset_value<<4));	
+			}
+		}
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+	
+	return ReCode;
+}
+
+/*get rx offset*/
+static int ft5x02_get_rx_offset(struct i2c_client * client, u8 rxNO, u8 *pOffset)
+{
+	unsigned char temp = 0;
+	unsigned char ReCode = 0;
+	if (rxNO < FT5x02_RX_TEST_MODE_1)
+		ReCode = ft5x02_read_reg(client,
+				FT5x02_REG_RX_OFFSET_START + (rxNO>>1), &temp);
+	else {
+		ReCode = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+						FT5x02_REG_TEST_MODE_2<<4);	/*enter Test mode 2*/
+		if (ReCode >= 0)
+			ReCode = ft5x02_read_reg(client,
+						FT5x02_REG_RX_OFFSET_START+((rxNO-FT5x02_RX_TEST_MODE_1)>>1),
+						&temp);
+		
+		ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE,
+			FT5x02_REG_TEST_MODE<<4);	/*enter Test mode*/
+	}
+
+	if (ReCode >= 0) {
+		if (0 == (rxNO%2))
+			*pOffset = (temp&0x0f);
+		else
+			*pOffset = (temp>>4);
+	}
+	
+	return ReCode;
+}
+
+/*set tx num*/
+static int ft5x02_set_tx_num(struct i2c_client *client, u8 txnum)
+{
+	return ft5x02_write_reg(client, FT5x02_REG_TX_NUM, txnum);
+}
+
+/*get tx num*/
+static int ft5x02_get_tx_num(struct i2c_client *client, u8 *ptxnum)
+{
+	return ft5x02_read_reg(client, FT5x02_REG_TX_NUM, ptxnum);
+}
+
+/*set rx num*/
+static int ft5x02_set_rx_num(struct i2c_client *client, u8 rxnum)
+{
+	return ft5x02_write_reg(client, FT5x02_REG_RX_NUM, rxnum);
+}
+
+/*get rx num*/
+static int ft5x02_get_rx_num(struct i2c_client *client, u8 *prxnum)
+{
+	return ft5x02_read_reg(client, FT5x02_REG_RX_NUM, prxnum);
+}
+
+/*set resolution*/
+static int ft5x02_set_Resolution(struct i2c_client *client, u16 x, u16 y)
+{
+	unsigned char cRet = 0;
+	cRet &= ft5x02_write_reg(client,
+			FT5x02_REG_RESOLUTION_X_H, ((unsigned char)(x>>8)));
+	cRet &= ft5x02_write_reg(client,
+			FT5x02_REG_RESOLUTION_X_L, ((unsigned char)(x&0x00ff)));
+
+	cRet &= ft5x02_write_reg(client,
+			FT5x02_REG_RESOLUTION_Y_H, ((unsigned char)(y>>8)));
+	cRet &= ft5x02_write_reg(client,
+			FT5x02_REG_RESOLUTION_Y_L, ((unsigned char)(y&0x00ff)));
+
+	return cRet;
+}
+
+/*get resolution*/
+static int ft5x02_get_Resolution(struct i2c_client *client,
+			u16 *px, u16 *py)
+{
+	unsigned char cRet = 0, temp1 = 0, temp2 = 0;
+	cRet &= ft5x02_read_reg(client,
+			FT5x02_REG_RESOLUTION_X_H, &temp1);
+	cRet &= ft5x02_read_reg(client,
+			FT5x02_REG_RESOLUTION_X_L, &temp2);
+	(*px) = (((u16)temp1) << 8) | ((u16)temp2);
+
+	cRet &= ft5x02_read_reg(client,
+			FT5x02_REG_RESOLUTION_Y_H, &temp1);
+	cRet &= ft5x02_read_reg(client,
+			FT5x02_REG_RESOLUTION_Y_L, &temp2);
+	(*py) = (((u16)temp1) << 8) | ((u16)temp2);
+
+	return cRet;
+}
+
+
+/*set voltage*/
+static int ft5x02_set_vol(struct i2c_client *client, u8 Vol)
+{
+	return  ft5x02_write_reg(client, FT5x02_REG_VOLTAGE, Vol);
+}
+
+/*get voltage*/
+static int ft5x02_get_vol(struct i2c_client *client, u8 *pVol)
+{
+	return ft5x02_read_reg(client, FT5x02_REG_VOLTAGE, pVol);
+}
+
+/*set gain*/
+static int ft5x02_set_gain(struct i2c_client *client, u8 Gain)
+{
+	return ft5x02_write_reg(client, FT5x02_REG_GAIN, Gain);
+}
+
+/*get gain*/
+static int ft5x02_get_gain(struct i2c_client *client, u8 *pGain)
+{
+	return ft5x02_read_reg(client, FT5x02_REG_GAIN, pGain);
+}
+#if 0
+static int ft5x02_set_statistics_tx_num(struct i2c_client *client, u8 txnum)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_STATISTICS_TX_NUM,
+			txnum);
+}
+
+static int ft5x02_get_statistics_tx_num(struct i2c_client *client, u8 *ptxnum)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_STATISTICS_TX_NUM,
+			ptxnum);
+}
+#endif
+static int ft5x02_set_face_detect_pre_value(struct i2c_client *client, u8 prevalue)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_FACE_DETECT_PRE_VALUE,
+			prevalue);
+}
+
+static int ft5x02_get_face_detect_pre_value(struct i2c_client *client, u8 *pprevalue)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_FACE_DETECT_PRE_VALUE,
+			pprevalue);
+}
+
+static int ft5x02_set_face_detect_num(struct i2c_client *client, u8 num)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_FACE_DETECT_NUM,
+			num);
+}
+
+static int ft5x02_get_face_detect_num(struct i2c_client *client, u8 *pnum)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_FACE_DETECT_NUM,
+			pnum);
+}
+
+static int ft5x02_set_face_detect_last_time(struct i2c_client *client, u16 lasttime)
+{
+	int err = 0;
+	u8 temp1 = 0, temp2 = 0;
+
+	temp1 = lasttime >> 8;
+	temp2 = lasttime;
+	err = ft5x02_write_reg(client, FT5X02_REG_FACE_DETECT_LAST_TIME_H,
+			temp1);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not write face detect last time high.\n",
+			__func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_FACE_DETECT_LAST_TIME_L,
+			temp2);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not write face detect last time low.\n",
+			__func__);
+		return err;
+	}
+	return err;
+}
+static int ft5x02_get_face_detect_last_time(struct i2c_client *client, u16 *plasttime)
+{
+	int err = 0;
+	u8 temp1 = 0, temp2 = 0;
+	err = ft5x02_read_reg(client, FT5X02_REG_FACE_DETECT_LAST_TIME_H,
+			&temp1);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not read face detect last time high.\n",
+			__func__);
+		return err;
+	}
+	err = ft5x02_read_reg(client, FT5X02_REG_FACE_DETECT_LAST_TIME_L,
+			&temp2);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not read face detect last time low.\n",
+			__func__);
+		return err;
+	}
+	*plasttime = ((u16)temp1<<8) + (u16)temp2;
+
+	return err;
+}
+
+static int ft5x02_set_face_detect_on(struct i2c_client *client, u8 on)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_FACE_DETECT_ON,
+			on);
+}
+
+static int ft5x02_get_face_detect_on(struct i2c_client *client, u8 *pon)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_FACE_DETECT_ON,
+			pon);
+}
+
+static int ft5x02_set_face_detect_off(struct i2c_client *client, u8 off)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_FACE_DETECT_OFF,
+			off);
+}
+static int ft5x02_get_face_detect_off(struct i2c_client *client, u8 *poff)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_FACE_DETECT_OFF,
+			poff);
+}
+
+static int ft5x02_set_peak_value_min(struct i2c_client *client, u8 min)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_PEAK_VALUE_MIN,
+			min);
+}
+
+static int ft5x02_get_peak_value_min(struct i2c_client *client, u8 *pmin)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_PEAK_VALUE_MIN,
+			pmin);
+}
+
+static int ft5x02_set_diff_value_over_num(struct i2c_client *client, u8 num)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_DIFF_VALUE_OVER_NUM,
+			num);
+}
+static int ft5x02_get_diff_value_over_num(struct i2c_client *client, u8 *pnum)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_DIFF_VALUE_OVER_NUM,
+			pnum);
+}
+
+static int ft5x02_set_diff_value_percent(struct i2c_client *client, u8 value)
+{
+	
+//	return ft5x02_write_reg(client, FT5X02_REG_DIFF_VALUE_PERCENT,
+//			value);
+return 0;
+}
+static int ft5x02_get_diff_value_percent(struct i2c_client *client, u8 *pvalue)
+{
+//	return ft5x02_read_reg(client, FT5X02_REG_DIFF_VALUE_PERCENT,
+//			pvalue);
+return 0;
+}
+
+static int ft5x02_set_point_auto_clear_time(struct i2c_client *client, u16 value)
+{
+	int err = 0;
+	u8 temp1 = 0, temp2 = 0;
+
+	temp1 = value >> 8;
+	temp2 = value;
+	err = ft5x02_write_reg(client, FT5X02_REG_POINT_AUTO_CLEAR_TIME_H,
+			temp1);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not write point auot clean time high.\n",
+			__func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_POINT_AUTO_CLEAR_TIME_L,
+			temp2);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not write point auot clean time low.\n",
+			__func__);
+		return err;
+	}
+	return err;
+}
+static int ft5x02_get_point_auto_clear_time(struct i2c_client *client, u16 *pvalue)
+{
+	int err = 0;
+	u8 temp1 = 0, temp2 = 0;
+	err = ft5x02_read_reg(client, FT5X02_REG_POINT_AUTO_CLEAR_TIME_H,
+			&temp1);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not write point auot clean time high.\n",
+			__func__);
+		return err;
+	}
+	err = ft5x02_read_reg(client, FT5X02_REG_POINT_AUTO_CLEAR_TIME_L,
+			&temp2);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not write point auot clean time low.\n",
+			__func__);
+		return err;
+	}
+	*pvalue = ((u16)temp1<<8) + (u16)temp2;
+	return err;
+
+}
+
+static int ft5x02_set_kx(struct i2c_client *client, u16 value)
+{
+	int err = 0;
+	err = ft5x02_write_reg(client, FT5X02_REG_KX_H,
+			value >> 8);
+	if (err < 0)
+		dev_err(&client->dev, "%s:set kx high failed\n",
+				__func__);
+	err = ft5x02_write_reg(client, FT5X02_REG_KX_L,
+			value);
+	if (err < 0)
+		dev_err(&client->dev, "%s:set kx low failed\n",
+				__func__);
+
+	return err;
+}
+
+static int ft5x02_get_kx(struct i2c_client *client, u16 *pvalue)
+{
+	int err = 0;
+	u8 tmp1, tmp2;
+	err = ft5x02_read_reg(client, FT5X02_REG_KX_H,
+			&tmp1);
+	if (err < 0)
+		dev_err(&client->dev, "%s:get kx high failed\n",
+				__func__);
+	err = ft5x02_read_reg(client, FT5X02_REG_KX_L,
+			&tmp2);
+	if (err < 0)
+		dev_err(&client->dev, "%s:get kx low failed\n",
+				__func__);
+
+	*pvalue = ((u16)tmp1<<8) + (u16)tmp2;
+	return err;
+}
+static int ft5x02_set_ky(struct i2c_client *client, u16 value)
+{
+	int err = 0;
+	err = ft5x02_write_reg(client, FT5X02_REG_KY_H,
+			value >> 8);
+	if (err < 0)
+		dev_err(&client->dev, "%s:set ky high failed\n",
+				__func__);
+	err = ft5x02_write_reg(client, FT5X02_REG_KY_L,
+			value);
+	if (err < 0)
+		dev_err(&client->dev, "%s:set ky low failed\n",
+				__func__);
+
+	return err;
+}
+
+static int ft5x02_get_ky(struct i2c_client *client, u16 *pvalue)
+{
+	int err = 0;
+	u8 tmp1, tmp2;
+	err = ft5x02_read_reg(client, FT5X02_REG_KY_H,
+			&tmp1);
+	if (err < 0)
+		dev_err(&client->dev, "%s:get ky high failed\n",
+				__func__);
+	err = ft5x02_read_reg(client, FT5X02_REG_KY_L,
+			&tmp2);
+	if (err < 0)
+		dev_err(&client->dev, "%s:get ky low failed\n",
+				__func__);
+
+	*pvalue = ((u16)tmp1<<8) + (u16)tmp2;
+	return err;
+}
+static int ft5x02_set_lemda_x(struct i2c_client *client, u8 value)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_LEMDA_X,
+			value);
+}
+
+static int ft5x02_get_lemda_x(struct i2c_client *client, u8 *pvalue)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_LEMDA_X,
+			pvalue);
+}
+static int ft5x02_set_lemda_y(struct i2c_client *client, u8 value)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_LEMDA_Y,
+			value);
+}
+
+static int ft5x02_get_lemda_y(struct i2c_client *client, u8 *pvalue)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_LEMDA_Y,
+			pvalue);
+}
+static int ft5x02_set_pos_x(struct i2c_client *client, u8 value)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_POS_X,
+			value);
+}
+
+static int ft5x02_get_pos_x(struct i2c_client *client, u8 *pvalue)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_POS_X,
+			pvalue);
+}
+
+static int ft5x02_set_scan_select(struct i2c_client *client, u8 value)
+{
+	return ft5x02_write_reg(client, FT5X02_REG_SCAN_SELECT,
+			value);
+}
+
+static int ft5x02_get_scan_select(struct i2c_client *client, u8 *pvalue)
+{
+	return ft5x02_read_reg(client, FT5X02_REG_SCAN_SELECT,
+			pvalue);
+}
+
+static int ft5x02_set_other_param(struct i2c_client *client)
+{
+	int err = 0;
+	err = ft5x02_write_reg(client, FT5X02_REG_THGROUP, (u8)(FT5X02_THGROUP>>2));
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THGROUP failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_THPEAK, FT5X02_THPEAK);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THPEAK failed.\n",
+				__func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_THCAL, FT5X02_THCAL);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THCAL failed.\n",
+				__func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_THWATER, FT5X02_THWATER);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THWATER failed.\n",
+				__func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_THFALSE_TOUCH_PEAK,
+			FT5X02_THFALSE_TOUCH_PEAK);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THFALSE_TOUCH_PEAK failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_THDIFF, FT5X02_THDIFF);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THDIFF failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_CTRL, FT5X02_CTRL);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write CTRL failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_TIMEENTERMONITOR,
+			FT5X02_TIMEENTERMONITOR);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write TIMEENTERMONITOR failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_PERIODACTIVE,
+			FT5X02_PERIODACTIVE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write PERIODACTIVE failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_PERIODMONITOR,
+			FT5X02_PERIODMONITOR);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write PERIODMONITOR failed.\n", __func__);
+		return err;
+	}
+	
+	err = ft5x02_write_reg(client, FT5X02_REG_AUTO_CLB_MODE,
+			FT5X02_AUTO_CLB_MODE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write AUTO_CLB_MODE failed.\n", __func__);
+		return err;
+	}
+
+	err = ft5x02_write_reg(client, FT5X02_REG_MODE, FT5X02_MODE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write MODE failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_PMODE, FT5X02_PMODE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write PMODE failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_FIRMID, FT5X02_FIRMID);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write FIRMID failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_STATE, FT5X02_STATE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write STATE failed.\n", __func__);
+		return err;
+	}
+	
+	err = ft5x02_write_reg(client, FT5X02_REG_MAX_TOUCH_VALUE_HIGH,
+			FT5X02_MAX_TOUCH_VALUE_HIGH);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write MAX_TOUCH_VALUE_HIGH failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_MAX_TOUCH_VALUE_LOW,
+			FT5X02_MAX_TOUCH_VALUE_LOW);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write MAX_TOUCH_VALUE_LOW failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_FACE_DEC_MODE,
+			FT5X02_FACE_DEC_MODE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write FACE_DEC_MODE failed.\n", __func__);
+		return err;
+	}
+	err = ft5x02_write_reg(client, FT5X02_REG_DRAW_LINE_TH,
+			FT5X02_DRAW_LINE_TH);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write DRAW_LINE_TH failed.\n", __func__);
+		return err;
+	}
+
+	err = ft5x02_write_reg(client, FT5X02_REG_DIFFDATA_HADDLE_VALUE,
+			FT5X02_DIFFDATA_HADDLE_VALUE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write DIFFDATA_HADDLE_VALUE failed.\n", __func__);
+		return err;
+	}
+	return err;
+}
+
+static int ft5x02_get_other_param(struct i2c_client *client)
+{
+	int err = 0;
+	u8 value = 0x00;
+	err = ft5x02_read_reg(client, FT5X02_REG_THGROUP, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THGROUP failed.\n", __func__);
+		return err;
+	} else 
+		DBG("THGROUP=%02x\n", value<<2);
+	err = ft5x02_read_reg(client, FT5X02_REG_THPEAK, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THPEAK failed.\n",
+				__func__);
+		return err;
+	} else 
+		DBG("THPEAK=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_THCAL, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THCAL failed.\n",
+				__func__);
+		return err;
+	} else 
+		DBG("THCAL=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_THWATER, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THWATER failed.\n",
+				__func__);
+		return err;
+	} else 
+		DBG("THWATER=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_THFALSE_TOUCH_PEAK,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THFALSE_TOUCH_PEAK failed.\n", __func__);
+		return err;
+	} else 
+		DBG("THFALSE_TOUCH_PEAK=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_THDIFF, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write THDIFF failed.\n", __func__);
+		return err;
+	} else 
+		DBG("THDIFF=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_CTRL, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write CTRL failed.\n", __func__);
+		return err;
+	} else 
+		DBG("CTRL=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_TIMEENTERMONITOR,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write TIMEENTERMONITOR failed.\n", __func__);
+		return err;
+	} else 
+		DBG("TIMEENTERMONITOR=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_PERIODACTIVE,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write PERIODACTIVE failed.\n", __func__);
+		return err;
+	} else 
+		DBG("PERIODACTIVE=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_PERIODMONITOR,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write PERIODMONITOR failed.\n", __func__);
+		return err;
+	} else 
+		DBG("PERIODMONITOR=%02x\n", value);
+	
+	err = ft5x02_read_reg(client, FT5X02_REG_CIPHER,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write CIPHER failed.\n", __func__);
+		return err;
+	} else 
+		DBG("CIPHER=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_MODE, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write MODE failed.\n", __func__);
+		return err;
+	} else 
+		DBG("MODE=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_PMODE, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write PMODE failed.\n", __func__);
+		return err;
+	} else 
+		DBG("PMODE=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_FIRMID, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write FIRMID failed.\n", __func__);
+		return err;
+	} else 
+		DBG("FIRMID=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_STATE, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write STATE failed.\n", __func__);
+		return err;
+	} else 
+		DBG("STATE=%02x\n", value);
+	
+	err = ft5x02_read_reg(client, FT5X02_REG_MAX_TOUCH_VALUE_HIGH,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write MAX_TOUCH_VALUE_HIGH failed.\n", __func__);
+		return err;
+	} else 
+		DBG("MAX_TOUCH_VALUE_HIGH=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_MAX_TOUCH_VALUE_LOW,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write MAX_TOUCH_VALUE_LOW failed.\n", __func__);
+		return err;
+	} else 
+		DBG("MAX_TOUCH_VALUE_LOW=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_FACE_DEC_MODE,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write FACE_DEC_MODE failed.\n", __func__);
+		return err;
+	} else 
+		DBG("FACE_DEC_MODE=%02x\n", value);
+	err = ft5x02_read_reg(client, FT5X02_REG_DRAW_LINE_TH,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write DRAW_LINE_TH failed.\n", __func__);
+		return err;
+	} else 
+		DBG("DRAW_LINE_TH=%02x\n", value);
+	
+	err = ft5x02_read_reg(client, FT5X02_REG_DIFFDATA_HADDLE_VALUE,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:write DIFFDATA_HADDLE_VALUE failed.\n", __func__);
+		return err;
+	} else 
+		DBG("DIFFDATA_HADDLE_VALUE=%02x\n", value);
+	return err;
+}
+int ft5x02_get_ic_param(struct i2c_client *client)
+{
+	int err = 0;
+	int i = 0;
+	u8 value = 0x00;
+	u16 xvalue = 0x0000, yvalue = 0x0000;
+	
+	/*enter factory mode*/
+	err = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE, FT5x02_FACTORYMODE_VALUE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:enter factory mode failed.\n", __func__);
+		goto RETURN_WORK;
+	}
+	
+	for (i = 0; i < g_ft5x02_tx_num; i++) {
+		DBG("tx%d:", i);
+		/*get tx order*/
+		err = ft5x02_get_tx_order(client, i, &value);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not get tx%d order.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+		DBG("order=%d ", value);
+		/*get tx cap*/
+		err = ft5x02_get_tx_cap(client, i, &value);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not get tx%d cap.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+		DBG("cap=%02x\n", value);
+	}
+	/*get tx offset*/
+	err = ft5x02_get_tx_offset(client, 0, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get tx 0 offset.\n",
+				__func__);
+		goto RETURN_WORK;
+	} else
+		DBG("tx offset = %02x\n", value);
+
+	/*get rx offset and cap*/
+	for (i = 0; i < g_ft5x02_rx_num; i++) {
+		/*get rx order*/
+		DBG("rx%d:", i);
+		err = ft5x02_get_rx_order(client, i, &value);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not get rx%d order.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+		DBG("order=%d ", value);
+		/*get rx cap*/
+		err = ft5x02_get_rx_cap(client, i, &value);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not get rx%d cap.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+		DBG("cap=%02x ", value);
+		err = ft5x02_get_rx_offset(client, i, &value);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not get rx offset.\n",
+				__func__);
+			goto RETURN_WORK;
+		}
+		DBG("offset=%02x\n", value);
+	}
+
+	/*get scan select*/
+	err = ft5x02_get_scan_select(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get scan select.\n",
+			__func__);
+		goto RETURN_WORK;
+	} else
+		DBG("scan select = %02x\n", value);
+	
+	/*get tx number*/
+	err = ft5x02_get_tx_num(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get tx num.\n",
+			__func__);
+		goto RETURN_WORK;
+	} else
+		DBG("tx num = %02x\n", value);
+	/*get rx number*/
+	err = ft5x02_get_rx_num(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get rx num.\n",
+			__func__);
+		goto RETURN_WORK;
+	} else
+		DBG("rx num = %02x\n", value);
+	
+	/*get gain*/
+	err = ft5x02_get_gain(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get gain.\n",
+			__func__);
+		goto RETURN_WORK;
+	} else
+		DBG("gain = %02x\n", value);
+	/*get voltage*/
+	err = ft5x02_get_vol(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get voltage.\n",
+			__func__);
+		goto RETURN_WORK;
+	} else
+		DBG("voltage = %02x\n", value);
+RETURN_WORK:	
+	/*enter work mode*/
+	err = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE, FT5x02_WORKMODE_VALUE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:enter work mode failed.\n", __func__);
+		goto ERR_EXIT;
+	}
+
+	/*get resolution*/
+	err = ft5x02_get_Resolution(client, &xvalue, &yvalue);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get resolution.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("resolution X = %d Y = %d\n", xvalue, yvalue);
+	/*get face detect pre value*/
+	err = ft5x02_get_face_detect_pre_value(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev,
+				"%s:could not get face detect pre value.\n",
+				__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("detect pre value = %02x\n", value);
+	/*get face detect num*/
+	err = ft5x02_get_face_detect_num(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get face detect num.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("face detect num = %02x\n", value);
+	/*get face detect last time*/
+	err = ft5x02_get_face_detect_last_time(client,
+			&xvalue);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"%s:could not get face detect last time.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("face detect last time = %d\n", xvalue);
+	/*get face detect on*/
+	err = ft5x02_get_face_detect_on(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get face detect on.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("face detect on = %02x\n", value);
+	/*get face detect on*/
+	err = ft5x02_get_face_detect_off(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get face detect off.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("face detect off = %02x\n", value);
+	/*get min peak value*/
+	err = ft5x02_get_peak_value_min(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get min peak value.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("peak value min = %02x\n", value);
+	/*get diff value over num*/
+	err = ft5x02_get_diff_value_over_num(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get diff value over num.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("diff value over num = %02x\n", value);
+	/*get diff value percent*/
+	err = ft5x02_get_diff_value_percent(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get diff value percent.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("diff value percent = %02x\n", value);
+	/*get point auto clear time*/
+	err = ft5x02_get_point_auto_clear_time(client,
+			&xvalue);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get point auto clear time.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("point auto clear time = %d\n", xvalue);
+
+	/*get kx*/
+	err = ft5x02_get_kx(client, &xvalue);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get kx.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("kx = %02x\n", xvalue);
+	/*get ky*/
+	err = ft5x02_get_ky(client, &xvalue);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get ky.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("ky = %02x\n", xvalue);
+	/*get lemda x*/
+	err = ft5x02_get_lemda_x(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get lemda x.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("lemda x = %02x\n", value);
+	/*get lemda y*/
+	err = ft5x02_get_lemda_y(client,
+			&value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get lemda y.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("lemda y = %02x\n", value);
+	/*get pos x*/
+	err = ft5x02_get_pos_x(client, &value);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not get pos x.\n",
+			__func__);
+		goto ERR_EXIT;
+	} else
+		DBG("pos x = %02x\n", value);
+
+	err = ft5x02_get_other_param(client);
+	
+ERR_EXIT:
+	return err;
+}
+
+int ft5x02_Init_IC_Param(struct i2c_client *client)
+{
+	int err = 0;
+	int i = 0;
+	
+	/*enter factory mode*/
+	err = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE, FT5x02_FACTORYMODE_VALUE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:enter factory mode failed.\n", __func__);
+		goto RETURN_WORK;
+	}
+	
+	for (i = 0; i < g_ft5x02_tx_num; i++) {
+		if (g_ft5x02_tx_order[i] != 0xFF) {
+			/*set tx order*/
+			err = ft5x02_set_tx_order(client, i, g_ft5x02_tx_order[i]);
+			if (err < 0) {
+				dev_err(&client->dev, "%s:could not set tx%d order.\n",
+						__func__, i);
+				goto RETURN_WORK;
+			}
+		}
+		/*set tx cap*/
+		err = ft5x02_set_tx_cap(client, i, g_ft5x02_tx_cap[i]);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not set tx%d cap.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+	}
+	/*set tx offset*/
+	err = ft5x02_set_tx_offset(client, 0, g_ft5x02_tx_offset);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set tx 0 offset.\n",
+				__func__);
+		goto RETURN_WORK;
+	}
+
+	/*set rx offset and cap*/
+	for (i = 0; i < g_ft5x02_rx_num; i++) {
+		/*set rx order*/
+		err = ft5x02_set_rx_order(client, i, g_ft5x02_rx_order[i]);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not set rx%d order.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+		/*set rx cap*/
+		err = ft5x02_set_rx_cap(client, i, g_ft5x02_rx_cap[i]);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not set rx%d cap.\n",
+					__func__, i);
+			goto RETURN_WORK;
+		}
+	}
+	for (i = 0; i < g_ft5x02_rx_num/2; i++) {
+		err = ft5x02_set_rx_offset(client, i*2, g_ft5x02_rx_offset[i]>>4);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not set rx offset.\n",
+				__func__);
+			goto RETURN_WORK;
+		}
+		err = ft5x02_set_rx_offset(client, i*2+1, g_ft5x02_rx_offset[i]&0x0F);
+		if (err < 0) {
+			dev_err(&client->dev, "%s:could not set rx offset.\n",
+				__func__);
+			goto RETURN_WORK;
+		}
+	}
+
+	/*set scan select*/
+	err = ft5x02_set_scan_select(client, g_ft5x02_scanselect);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set scan select.\n",
+			__func__);
+		goto RETURN_WORK;
+	}
+	
+	/*set tx number*/
+	err = ft5x02_set_tx_num(client, g_ft5x02_tx_num);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set tx num.\n",
+			__func__);
+		goto RETURN_WORK;
+	}
+	/*set rx number*/
+	err = ft5x02_set_rx_num(client, g_ft5x02_rx_num);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set rx num.\n",
+			__func__);
+		goto RETURN_WORK;
+	}
+	
+	/*set gain*/
+	err = ft5x02_set_gain(client, g_ft5x02_gain);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set gain.\n",
+			__func__);
+		goto RETURN_WORK;
+	}
+	/*set voltage*/
+	err = ft5x02_set_vol(client, g_ft5x02_voltage);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set voltage.\n",
+			__func__);
+		goto RETURN_WORK;
+	}
+RETURN_WORK:	
+	/*enter work mode*/
+	err = ft5x02_write_reg(client, FT5x02_REG_DEVICE_MODE, FT5x02_WORKMODE_VALUE);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:enter work mode failed.\n", __func__);
+		goto ERR_EXIT;
+	}
+
+	/*set resolution*/
+	err = ft5x02_set_Resolution(client, FT5X02_RESOLUTION_X,
+				FT5X02_RESOLUTION_Y);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set resolution.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set face detect pre value*/
+	err = ft5x02_set_face_detect_pre_value(client,
+			FT5X02_FACE_DETECT_PRE_VALUE);
+	if (err < 0) {
+		dev_err(&client->dev,
+				"%s:could not set face detect pre value.\n",
+				__func__);
+		goto ERR_EXIT;
+	}
+	/*set face detect num*/
+	err = ft5x02_set_face_detect_num(client,
+			FT5X02_FACE_DETECT_NUM);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set face detect num.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set face detect last time*/
+	err = ft5x02_set_face_detect_last_time(client,
+			FT5X02_FACE_DETECT_LAST_TIME);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"%s:could not set face detect last time.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set face detect on*/
+	err = ft5x02_set_face_detect_on(client,
+			FT5X02_FACE_DETECT_ON);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set face detect on.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set face detect on*/
+	err = ft5x02_set_face_detect_off(client,
+			FT5X02_FACE_DETECT_OFF);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set face detect off.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set min peak value*/
+	err = ft5x02_set_peak_value_min(client,
+			FT5X02_PEAK_VALUE_MIN);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set min peak value.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set diff value over num*/
+	err = ft5x02_set_diff_value_over_num(client,
+			FT5X02_DIFF_VALUE_OVER_NUM);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set diff value over num.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set diff value percent*/
+	err = ft5x02_set_diff_value_percent(client,
+			FT5X02_DIFF_VALUE_PERCENT);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set diff value percent.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set point auto clear time*/
+	err = ft5x02_set_point_auto_clear_time(client,
+			FT5X02_POINT_AUTO_CLEAR_TIME);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set point auto clear time.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+
+	/*set kx*/
+	err = ft5x02_set_kx(client, FT5X02_KX);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set kx.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set ky*/
+	err = ft5x02_set_ky(client, FT5X02_KY);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set ky.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set lemda x*/
+	err = ft5x02_set_lemda_x(client,
+			FT5X02_LEMDA_X);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set lemda x.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set lemda y*/
+	err = ft5x02_set_lemda_y(client,
+			FT5X02_LEMDA_Y);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set lemda y.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+	/*set pos x*/
+	err = ft5x02_set_pos_x(client, FT5X02_POS_X);
+	if (err < 0) {
+		dev_err(&client->dev, "%s:could not set pos x.\n",
+			__func__);
+		goto ERR_EXIT;
+	}
+
+	err = ft5x02_set_other_param(client);
+	
+ERR_EXIT:
+	return err;
+}
+
diff --git a/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.h b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.h
new file mode 100755
index 000000000000..655bdca24da2
--- /dev/null
+++ b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_config.h
@@ -0,0 +1,68 @@
+#ifndef __FT5X02_CONFIG_H__
+#define __FT5X02_CONFIG_H__
+/*ft5x02 config*/
+
+#define FT5X02_KX				142
+#define FT5X02_KY				160
+#define FT5X02_LEMDA_X			0
+#define FT5X02_LEMDA_Y			0
+#define FT5X02_RESOLUTION_X	320
+#define FT5X02_RESOLUTION_Y	480
+#define FT5X02_POS_X			0	/*0-tx is X direct. 1-rx is X direct.*/
+
+/**/
+#define FT5X02_STATISTICS_TX_NUM		3
+#define FT5X02_FACE_DETECT_PRE_VALUE	20
+#define FT5X02_FACE_DETECT_NUM		10
+#define FT5X02_FACE_DETECT_LAST_TIME	1000
+#define FT5X02_FACE_DETECT_ON			0xc0
+#define FT5X02_FACE_DETECT_OFF		0xe0
+#define FT5X02_PEAK_VALUE_MIN			150/*The min value to be decided as the big point*/
+#define FT5X02_DIFF_VALUE_OVER_NUM	30/*The min big points of the big area*/
+#define FT5X02_DIFF_VALUE_PERCENT		7/*reserve for future use*/
+#define FT5X02_POINT_AUTO_CLEAR_TIME	3000/*3000ms*/
+#define FT5X02_FACE_DETECT_LAST_TIME_HIGH	0x03
+#define FT5X02_FACE_DETECT_LAST_TIME_LOW		0xe8
+#define FT5X02_MODE					0x01
+#define FT5X02_PMODE					0x00
+#define FT5X02_FIRMID					0x05
+#define FT5X02_STATE					0x01
+#define FT5X02_FT5201ID					0x79
+#define FT5X02_PERIODACTIVE			0x06
+
+#define FT5X02_THGROUP					120
+#define FT5X02_THPEAK					60
+#define FT5X02_FACE_DEC_MODE				0x00/*close*/
+#define FT5X02_MAX_TOUCH_VALUE_HIGH		0x04
+#define FT5X02_MAX_TOUCH_VALUE_LOW		0xb0
+
+
+#define FT5X02_THCAL 						16	
+#define FT5X02_THWATER 					(-60)
+#define FT5X02_THFALSE_TOUCH_PEAK 		255
+#define FT5X02_THDIFF						160
+#define FT5X02_CTRL							1
+#define FT5X02_TIMEENTERMONITOR 			10
+#define FT5X02_PERIODMONITOR 				16
+#define FT5X02_AUTO_CLB_MODE				0xFF
+#define FT5X02_DRAW_LINE_TH				250
+#define FT5X02_DIFFDATA_HADDLE_VALUE		100
+
+/**/
+
+unsigned char g_ft5x02_tx_num = 12;
+unsigned char g_ft5x02_rx_num = 9;
+unsigned char g_ft5x02_gain = 0x0a;
+unsigned char g_ft5x02_voltage = 0x00;
+unsigned char g_ft5x02_scanselect = 2;/*1-3M	2-4.5M 3-6.75M*/
+
+unsigned char g_ft5x02_tx_order[] = {11,10,9,8,7,6,5,4,3,2,1,0};
+unsigned char g_ft5x02_tx_offset = 0x01;
+unsigned char g_ft5x02_tx_cap[] = {40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40};
+
+unsigned char g_ft5x02_rx_order[] = {0,1,2,3,4,5,6,7,8};
+unsigned char g_ft5x02_rx_offset[] = {0x77,0x77,0x77,0x77,0x77,0x77};
+unsigned char g_ft5x02_rx_cap[] = {80,80,80,80,80,80,80,80,80,80,80,80};
+
+
+#endif
diff --git a/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c
new file mode 100755
index 000000000000..7923ccb8b61a
--- /dev/null
+++ b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c
@@ -0,0 +1,957 @@
+/* 
+ * drivers/input/touchscreen/ft5x02_ts.c
+ *
+ * FocalTech ft5x02 TouchScreen driver. 
+ *
+ * Copyright (c) 2012  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "ft5x02_ts.h"
+#include <linux/earlysuspend.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>   
+#include <mach/irqs.h>
+#include <linux/kernel.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/syscalls.h>
+#include <asm/unistd.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include "linux/amlogic/input/common.h"
+extern struct touch_pdata *ts_com;
+struct ts_event {
+	u16 au16_x[CFG_MAX_TOUCH_POINTS];	/*x coordinate */
+	u16 au16_y[CFG_MAX_TOUCH_POINTS];	/*y coordinate */
+	u8 au8_touch_event[CFG_MAX_TOUCH_POINTS];	/*touch event:
+					0 -- down; 1-- contact; 2 -- contact */
+	u8 au8_finger_id[CFG_MAX_TOUCH_POINTS];	/*touch ID */
+	u16 pressure;
+	u8 touch_point;
+};
+
+struct ft5x02_ts_data {
+	unsigned int irq;
+	unsigned int x_max;
+	unsigned int y_max;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event event;
+#ifdef CONFIG_OF
+	struct touch_pdata *pdata;
+#else
+	struct ft5x02_platform_data *pdata;
+#endif	
+//	struct delayed_work dwork;
+#ifdef CONFIG_PM
+	struct early_suspend *early_suspend;
+#endif
+};
+
+#if CFG_SUPPORT_TOUCH_KEY
+int tsp_keycodes[CFG_NUMOFKEYS] ={
+        KEY_MENU,
+        KEY_HOME,
+        KEY_BACK,
+        KEY_SEARCH
+};
+char *tsp_keyname[CFG_NUMOFKEYS] ={
+        "Menu",
+        "Home",
+        "Back",
+        "Search"
+};
+static bool tsp_keystatus[CFG_NUMOFKEYS];
+#endif
+
+static u8 CTPM_FW[] = 
+{
+	//#include "ft5x02_app.i"
+};
+
+extern int ft5x02_Init_IC_Param(struct i2c_client * client);
+extern int ft5x02_get_ic_param(struct i2c_client * client);
+
+
+#define SYSFS_DEBUG
+#ifdef SYSFS_DEBUG
+static struct mutex g_device_mutex;
+static int ft5x02_create_sysfs_debug(struct i2c_client *client);
+#endif
+/*
+*ft5x02_i2c_Read-read data and write data by i2c
+*@client: handle of i2c
+*@writebuf: Data that will be written to the slave
+*@writelen: How many bytes to write
+*@readbuf: Where to store data read from slave
+*@readlen: How many bytes to read
+*
+*Returns negative errno, else the number of messages executed
+*
+*
+*/
+int ft5x02_i2c_Read(struct i2c_client *client,  char * writebuf, int writelen, 
+							char *readbuf, int readlen)
+{
+	int ret;
+
+	if(writelen > 0)
+	{
+		struct i2c_msg msgs[] = {
+			{
+				.addr	= client->addr,
+				.flags	= 0,
+				.len	= writelen,
+				.buf	= writebuf,
+			},
+			{
+				.addr	= client->addr,
+				.flags	= I2C_M_RD,
+				.len	= readlen,
+				.buf	= readbuf,
+			},
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			pr_err("function:%s. i2c read error: %d\n", __func__, ret);
+	}
+	else
+	{
+		struct i2c_msg msgs[] = {
+			{
+				.addr	= client->addr,
+				.flags	= I2C_M_RD,
+				.len	= readlen,
+				.buf	= readbuf,
+			},
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			pr_err("function:%s. i2c read error: %d\n", __func__, ret);
+	}
+	return ret;
+}
+/*
+*write data by i2c 
+*/
+int ft5x02_i2c_Write(struct i2c_client *client, char *writebuf, int writelen)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= writelen,
+			.buf	= writebuf,
+		},
+	};
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static void delay_qt_ms(unsigned long  w_ms)
+{
+	unsigned long i;
+	unsigned long j;
+
+	for (i = 0; i < w_ms; i++)
+	{
+		for (j = 0; j < 1000; j++)
+		{
+			 udelay(1);
+		}
+	}
+}
+
+/*release the point*/
+static void ft5x02_ts_release(struct ft5x02_ts_data *data)
+{
+	input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+	input_sync(data->input_dev);
+}
+
+int ft5x02_write_reg(struct i2c_client * client, u8 regaddr, u8 regvalue)
+{
+	unsigned char buf[2] = {0};
+	buf[0] = regaddr;
+	buf[1] = regvalue;
+
+	return ft5x02_i2c_Write(client, buf, sizeof(buf));
+}
+
+int ft5x02_read_reg(struct i2c_client * client, u8 regaddr, u8 * regvalue)
+{
+	return ft5x02_i2c_Read(client, &regaddr, 1, regvalue, 1);
+}
+
+void ft5x02_upgrade_send_head(struct i2c_client * client)
+{
+	u8 ret = 0;
+	u8 headbuf[2];
+	headbuf[0] = 0xFA;
+	headbuf[1] = 0xFA;
+
+	ret = ft5x02_i2c_Write(client, headbuf, 2);
+	if(ret < 0)
+		dev_err(&client->dev, "[FTS]--upgrading, send head error\n");
+}
+/*
+*/
+#define FTS_PACKET_LENGTH 128
+static int  ft5x02_ctpm_fw_upgrade(struct i2c_client * client, u8* pbt_buf, u32 dw_lenth)
+{
+	
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+
+	u32  packet_number;
+	u32  j;
+	u32  temp;
+	u32  lenght;
+	u8	packet_buf[FTS_PACKET_LENGTH + 6];
+	u8	auc_i2c_write_buf[10];
+	u8	bt_ecc;
+//	int 	 i_ret;
+	struct timeval begin_tv, end_tv;
+	do_gettimeofday(&begin_tv);
+
+	/*********Step 1:Reset	CTPM *****/
+	/*write 0xaa to register 0x3c*/
+	ft5x02_write_reg(client, 0xfc, 0xaa);
+	//delay_qt_ms(58);
+	msleep(30);
+	//do_gettimeofday(&end_tv);
+	//DBG("cost time=%lu.%lu\n", begin_tv.tv_sec-end_tv.tv_sec, 
+	//		begin_tv.tv_usec-end_tv.tv_usec);
+	 /*write 0x55 to register 0x3c*/
+	ft5x02_write_reg(client, 0xfc, 0x55);
+	//delay_qt_ms(18);
+	delay_qt_ms(25);
+
+	/*********Step 2:Enter upgrade mode *****/
+	#if 0
+	auc_i2c_write_buf[0] = 0x55;
+	auc_i2c_write_buf[1] = 0xaa;
+	do
+	{
+		i ++;
+		i_ret = ft5x02_i2c_Write(client, auc_i2c_write_buf, 2);
+		delay_qt_ms(5);
+	}while(i_ret <= 0 && i < 5 );
+	#else
+	auc_i2c_write_buf[0] = 0x55;
+	ft5x02_i2c_Write(client, auc_i2c_write_buf, 1);
+	delay_qt_ms(1);
+	auc_i2c_write_buf[0] = 0xaa;
+	ft5x02_i2c_Write(client, auc_i2c_write_buf, 1);
+	#endif
+
+	/*********Step 3:check READ-ID***********************/	 
+	delay_qt_ms(10);
+	for (i=0; i<3; i++) {
+		ft5x02_upgrade_send_head(client);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] = 0x00;
+
+		ft5x02_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+		
+		if (reg_val[0] == 0x79 
+			&& reg_val[1] == 0x02) {
+			//dev_dbg(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+			pr_info("[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+			delay_qt_ms(100);
+		}
+	}
+	if (i >= 3)
+		return -EIO;
+	/********Step 4:enable write function*/
+	ft5x02_upgrade_send_head(client);
+	auc_i2c_write_buf[0] = 0x06;
+	ft5x02_i2c_Write(client, auc_i2c_write_buf, 1);
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+
+	dw_lenth = dw_lenth - 6;
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+	for (j=0; j<packet_number; j++) {
+		temp = j * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8)(temp>>8);
+		packet_buf[3] = (u8)temp;
+		lenght = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8)(lenght>>8);
+		packet_buf[5] = (u8)lenght;
+
+		for (i=0; i<FTS_PACKET_LENGTH; i++) {
+			packet_buf[6+i] = pbt_buf[j*FTS_PACKET_LENGTH + i]; 
+			bt_ecc ^= packet_buf[6+i];
+		}
+		ft5x02_upgrade_send_head(client);
+		ft5x02_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH+6);
+		delay_qt_ms(1);
+	}
+
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
+		temp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8)(temp>>8);
+		packet_buf[3] = (u8)temp;
+
+		temp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8)(temp>>8);
+		packet_buf[5] = (u8)temp;
+
+		for (i=0; i<temp; i++) {
+			packet_buf[6+i] = pbt_buf[ packet_number*FTS_PACKET_LENGTH + i]; 
+			bt_ecc ^= packet_buf[6+i];
+		}
+		ft5x02_upgrade_send_head(client);
+		ft5x02_i2c_Write(client, packet_buf, temp+6);
+		delay_qt_ms(1);
+	}
+
+	/*send the last six byte*/
+	for (i = 0; i<6; i++) {
+		temp = 0x6ffa + i;
+		packet_buf[2] = (u8)(temp>>8);
+		packet_buf[3] = (u8)temp;
+		temp =1;
+		packet_buf[4] = (u8)(temp>>8);
+		packet_buf[5] = (u8)temp;
+		packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+		bt_ecc ^= packet_buf[6];
+
+		ft5x02_upgrade_send_head(client);
+		ft5x02_i2c_Write(client, packet_buf, 7);
+		delay_qt_ms(1);
+	}
+
+	/********Disable write function*/
+	ft5x02_upgrade_send_head(client);
+	auc_i2c_write_buf[0] = 0x04;
+	ft5x02_i2c_Write(client, auc_i2c_write_buf, 1);
+	/*********Step 6: read out checksum***********************/
+	ft5x02_upgrade_send_head(client);
+	auc_i2c_write_buf[0] = 0xcc;
+	ft5x02_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1); 
+
+	if (reg_val[0] != bt_ecc) {
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n", reg_val[0], bt_ecc);
+		return -EIO;
+	}
+
+	/*********Step 7: reset the new FW***********************/
+	ft5x02_upgrade_send_head(client);
+	auc_i2c_write_buf[0] = 0x07;
+	ft5x02_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(200);  /*make sure CTP startup normally*/
+	//DBG("-------upgrade successful-----\n");
+
+	do_gettimeofday(&end_tv);
+	DBG("cost time=%lu.%lu\n", end_tv.tv_sec-begin_tv.tv_sec, 
+			end_tv.tv_usec-begin_tv.tv_usec);
+	
+	return 0;
+}
+
+/*
+upgrade with *.i file
+*/
+#define READ_COUNT 5
+static int fts_ctpm_fw_upgrade_with_i_file(struct i2c_client * client)
+{
+	u8 *pbt_buf = NULL;
+	int i_ret;
+	int fw_len = 0;
+	
+#ifdef CONFIG_OF	
+	int file_size;
+	u8 tmp[READ_COUNT];
+	u8 check_dot[2];
+ 	u32 offset = 0;
+ 
+	file_size = touch_open_fw(ts_com->fw_file);
+	if(file_size < 0)
+	{
+		printk("%s: no fw file\n", ts_com->owner);
+		return -EIO;
+	}
+	pbt_buf = vmalloc(200*1024*sizeof(*pbt_buf));
+	
+	while (offset < file_size) {
+		touch_read_fw(offset, READ_COUNT, &tmp[0]);
+		i_ret = sscanf(&tmp[0],"0x%c%c",&check_dot[0],&check_dot[1]);
+		if (i_ret == 2) {
+		  if (check_dot[1] == ',')
+				sscanf(&tmp[0],"0x%x, ",(uint *)&pbt_buf[fw_len]);
+		  else
+				sscanf(&tmp[0],"0x%x,",(uint *)&pbt_buf[fw_len]);
+			fw_len++;	
+		}
+		offset++;
+	}
+#else
+	fw_len = sizeof(CTPM_FW);
+	pbt_buf = CTPM_FW;	
+#endif
+	/*judge the fw that will be upgraded
+	 * if illegal, then stop upgrade and return.
+	*/
+	if (fw_len<8 || fw_len>32*1024) {
+		dev_err(&client->dev, "[FTS]----FW length error\n");
+#ifdef CONFIG_OF	
+		vfree(pbt_buf);
+#endif
+		return -EIO;
+	}	
+//	if((CTPM_FW[fw_len-8]^CTPM_FW[fw_len-6])==0xFF
+//		&& (CTPM_FW[fw_len-7]^CTPM_FW[fw_len-5])==0xFF
+//		&& (CTPM_FW[fw_len-3]^CTPM_FW[fw_len-4])==0xFF)
+	{
+		/*FW upgrade*/
+		//pbt_buf = CTPM_FW;
+		/*call the upgrade function*/
+		i_ret =  ft5x02_ctpm_fw_upgrade(client, pbt_buf, fw_len);
+#ifdef CONFIG_OF	
+		vfree(pbt_buf);
+#endif
+		if (i_ret != 0)
+			dev_err(&client->dev, "[FTS]---- upgrade failed. err=%d.\n", i_ret);
+		else
+			dev_dbg(&client->dev, "[FTS]----upgrade successful\n");
+	}
+//	else
+//	{
+//		dev_err(&client->dev, "[FTS]----FW format error\n");
+//		return -EBADFD;
+//	}
+	return i_ret;
+}
+
+
+
+/* 
+*Read touch point information when the interrupt  is asserted.
+*/
+static int ft5x02_read_Touchdata(struct ft5x02_ts_data *data)
+{
+	struct ts_event *event = &data->event;
+	u8 buf[POINT_READ_BUF] = { 0 };
+	int ret = -1;
+	int i = 0;
+	u8 pointid = FT_MAX_ID;
+
+	ret = ft5x02_i2c_Read(data->client, buf, 1, buf, POINT_READ_BUF);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "%s read touchdata failed.\n",
+			__func__);
+		return ret;
+	}
+	memset(event, 0, sizeof(struct ts_event));
+
+	event->touch_point = 0;
+	for (i = 0; i < CFG_MAX_TOUCH_POINTS; i++) {
+		pointid = (buf[FT_TOUCH_ID_POS + FT_TOUCH_STEP * i]) >> 4;
+		if (pointid >= FT_MAX_ID)
+			break;
+		else
+			event->touch_point++;
+		event->au16_x[i] =
+		    (s16) (buf[FT_TOUCH_X_H_POS + FT_TOUCH_STEP * i] & 0x0F) <<
+		    8 | (s16) buf[FT_TOUCH_X_L_POS + FT_TOUCH_STEP * i];
+		event->au16_y[i] =
+		    (s16) (buf[FT_TOUCH_Y_H_POS + FT_TOUCH_STEP * i] & 0x0F) <<
+		    8 | (s16) buf[FT_TOUCH_Y_L_POS + FT_TOUCH_STEP * i];
+		event->au8_touch_event[i] =
+		    buf[FT_TOUCH_EVENT_POS + FT_TOUCH_STEP * i] >> 6;
+		event->au8_finger_id[i] =
+		    (buf[FT_TOUCH_ID_POS + FT_TOUCH_STEP * i]) >> 4;
+	}
+
+	event->pressure = FT_PRESS;
+
+	return 0;
+}
+
+#if CFG_SUPPORT_TOUCH_KEY
+/* 
+*Processes the key message when the CFG_SUPPORT_TOUCH_KEY has defined
+*/
+int ft5x02_touch_key_process(struct input_dev *dev, int x, int y, int touch_event)
+{
+	int i;
+	int key_id;
+
+	if ( y < 517&&y > 497)
+	{
+		key_id = 1;
+	}
+	else if ( y < 367&&y > 347)
+	{
+		key_id = 0;
+	}
+
+	else if ( y < 217&&y > 197)
+	{
+		key_id = 2;
+	}  
+	else if (y < 67&&y > 47)
+	{
+		key_id = 3;
+	}
+	else
+	{
+		key_id = 0xf;
+	}
+    
+	for(i = 0; i <CFG_NUMOFKEYS; i++ )
+	{
+		if(tsp_keystatus[i])
+		{
+			if(touch_event == 1)
+			{
+				input_report_key(dev, tsp_keycodes[i], 0);
+				tsp_keystatus[i] = KEY_RELEASE;
+			}
+		}
+		else if( key_id == i )
+		{
+			if( touch_event == 0)                                  // detect
+			{
+				input_report_key(dev, tsp_keycodes[i], 1);
+				tsp_keystatus[i] = KEY_PRESS;
+			}
+		}
+	}
+	return 0;
+    
+}    
+#endif
+
+/*
+*report the point information
+*/
+static void ft5x02_report_value(struct ft5x02_ts_data *data)
+{
+	struct ts_event *event = &data->event;
+	int i;
+
+	for (i  = 0; i < event->touch_point; i++)
+	{
+		// LCD view area
+	    	if (event->au16_x[i] < data->x_max && event->au16_y[i] < data->y_max)
+	    	{
+	        	input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->au16_x[i]);
+    			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->au16_y[i]);
+    			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+    			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->au8_finger_id[i]);
+    			if (event->au8_touch_event[i]== 0 || event->au8_touch_event[i] == 2)
+    			{
+    		    		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+    			}
+    			else
+    			{
+    		    		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+    			}
+	    	}
+	    	else /*maybe the touch key area*/
+	    	{
+#if CFG_SUPPORT_TOUCH_KEY
+            		if (event->au16_x[i] >= data->x_max)
+            		{
+                		ft5x02_touch_key_process(data->input_dev, event->au16_x[i], event->au16_y[i], event->au8_touch_event[i]);
+            		}
+#endif
+	    	}
+	    
+			
+		input_mt_sync(data->input_dev);
+	}
+	input_sync(data->input_dev);
+
+    	if (event->touch_point == 0) {
+        	ft5x02_ts_release(data);
+    	}
+}	/*end ft5x02_report_value*/
+
+#if 0
+static  void ft5x02_ts_worker(struct work_struct *work)
+{
+	struct ft5x02_ts_data *ft5x02_ts;
+	int ret = 0;
+	ft5x02_ts = container_of(work, struct ft5x02_ts_data, dwork.work);
+	
+	//disable_irq(ft5x02_ts->irq);
+	ret = ft5x02_read_Touchdata(ft5x02_ts);
+	if (ret == 0)
+		ft5x02_report_value(ft5x02_ts);
+}
+#endif
+/*
+ * The ft5x02 device will signal the host about TRIGGER_FALLING. 
+ */
+
+static irqreturn_t ft5x02_ts_interrupt(int irq, void *dev_id)
+{
+	struct ft5x02_ts_data *ft5x02_ts = dev_id;
+	int ret = 0;
+	disable_irq_nosync(ft5x02_ts->irq);
+#if 1
+	ret = ft5x02_read_Touchdata(ft5x02_ts);
+	if (ret == 0)
+		ft5x02_report_value(ft5x02_ts);
+#else
+	cancel_delayed_work(&ft5x02_ts->dwork);
+	schedule_delayed_work(&ft5x02_ts->dwork, 0);
+#endif
+	enable_irq(ft5x02_ts->irq);
+	return IRQ_HANDLED;
+}
+
+static int ft5x02_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ft5x02_ts_data *ft5x02_ts;
+	struct input_dev *input_dev;
+	int err = 0;
+//	unsigned char uc_reg_value; 
+//	unsigned char uc_reg_addr;
+#ifdef CONFIG_OF
+	struct touch_pdata *pdata = (struct touch_pdata *)client->dev.platform_data;
+	if (ts_com->owner != NULL) return -ENODEV;
+	memset(ts_com, 0 ,sizeof(struct touch_pdata));
+	ts_com = pdata;
+	printk("ts_com->owner = %s\n", ts_com->owner);
+	if (request_touch_gpio(ts_com) != ERR_NO)
+		goto exit_get_dt_failed;
+	aml_gpio_direction_output(ts_com->gpio_reset, 0);
+	msleep(20);
+	//gpio_set_value(ts->pdata->reset, 1);
+	aml_gpio_direction_output(ts_com->gpio_reset, 1);
+#else
+	struct ft5x02_platform_data *pdata = (struct ft5x02_platform_data *)client->dev.platform_data;
+#endif
+#if CFG_SUPPORT_TOUCH_KEY
+    	int i;
+#endif
+	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	ft5x02_ts = kzalloc(sizeof(struct ft5x02_ts_data), GFP_KERNEL);
+
+	if (!ft5x02_ts)	{
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	i2c_set_clientdata(client, ft5x02_ts);
+	ft5x02_ts->irq = client->irq;
+	ft5x02_ts->client = client;
+	ft5x02_ts->pdata = pdata;
+#ifdef CONFIG_OF
+	ft5x02_ts->x_max = pdata->xres - 1;
+	ft5x02_ts->y_max = pdata->yres - 1;
+#else	
+	ft5x02_ts->x_max = pdata->x_max - 1;
+	ft5x02_ts->y_max = pdata->y_max - 1;
+#endif	
+
+//	INIT_DELAYED_WORK(&ft5x02_ts->dwork, ft5x02_ts_worker);
+#ifdef CONFIG_PM
+//	err = gpio_request(pdata->reset, "ft5x02 reset");
+//	if (err < 0) {
+//		dev_err(&client->dev, "%s:failed to set gpio reset.\n",
+//			__func__);
+//		goto exit_request_reset;
+//	}
+#endif
+	//aml_gpio_direction_input(ts_com->gpio_interrupt);
+  //aml_gpio_to_irq(ts_com->gpio_interrupt, ts_com->irq-INT_GPIO_0, ts_com->irq_edge);
+	err = request_threaded_irq(client->irq, ft5x02_ts_interrupt, NULL,
+				   IRQF_DISABLED, client->dev.driver->name,
+				   ft5x02_ts);
+	if (err < 0) {
+		dev_err(&client->dev, "ft5x02_probe: request irq failed\n");
+		goto exit_irq_request_failed;
+	}
+	disable_irq(client->irq);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+	
+	ft5x02_ts->input_dev = input_dev;
+
+	set_bit(ABS_MT_TOUCH_MAJOR, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_X, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
+	set_bit(ABS_MT_WIDTH_MAJOR, input_dev->absbit);
+
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_X, 0, ft5x02_ts->x_max, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_Y, 0, ft5x02_ts->y_max, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_TOUCH_MAJOR, 0, PRESS_MAX, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);
+    	input_set_abs_params(input_dev,
+			     ABS_MT_TRACKING_ID, 0, CFG_MAX_TOUCH_POINTS, 0, 0);
+
+
+    	set_bit(EV_KEY, input_dev->evbit);
+    	set_bit(EV_ABS, input_dev->evbit);
+
+#if CFG_SUPPORT_TOUCH_KEY
+    	/*setup key code area*/
+    	set_bit(EV_SYN, input_dev->evbit);
+    	set_bit(BTN_TOUCH, input_dev->keybit);
+    	input_dev->keycode = tsp_keycodes;
+    	for(i = 0; i < CFG_NUMOFKEYS; i++)
+    	{
+        	input_set_capability(input_dev, EV_KEY, ((int*)input_dev->keycode)[i]);
+        	tsp_keystatus[i] = KEY_RELEASE;
+    	}
+#endif
+
+	input_dev->name		= FT5X02_NAME;
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+				"ft5x02_ts_probe: failed to register input device: %s\n",
+				dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+   	 msleep(150);  /*make sure CTP already finish startup process*/
+#if 1
+	/*upgrade for program the app to RAM*/
+	dev_dbg(&client->dev, "[FTS]----ready for upgrading---\n");
+	if (fts_ctpm_fw_upgrade_with_i_file(client) < 0) {
+		dev_err(&client->dev, "[FTS]-----upgrade failed!----\n");
+	}
+	else
+		dev_dbg(&client->dev, "[FTS]-----upgrade successful!----\n");
+//#else
+
+	//ft5x02_get_ic_param(client);
+	ft5x02_Init_IC_Param(client);
+	//DBG("----------get after param---------------\n");
+	//ft5x02_get_ic_param(client);
+#endif
+
+#ifdef SYSFS_DEBUG
+	ft5x02_create_sysfs_debug(client);
+#endif
+//	cancel_delayed_work(&ft5x02_ts->dwork);
+//	schedule_delayed_work(&ft5x02_ts->dwork, 0);
+	enable_irq(client->irq);
+    	return 0;
+
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+	
+exit_input_dev_alloc_failed:
+	free_irq(client->irq, ft5x02_ts);
+#ifdef CONFIG_PM
+exit_request_reset:
+	//gpio_free(ft5x02_ts->pdata->reset);
+#endif	
+exit_irq_request_failed:
+	i2c_set_clientdata(client, NULL);
+	kfree(ft5x02_ts);
+
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+exit_get_dt_failed:
+	free_touch_gpio(ts_com);
+	ts_com->owner = NULL;
+	printk("%s: probe failed!\n", __FUNCTION__);	
+	return err;
+}
+
+#ifdef CONFIG_PM
+static void ft5x02_ts_suspend(struct early_suspend *handler)
+{
+	struct ft5x02_ts_data *ts = container_of(handler, struct ft5x02_ts_data,
+						early_suspend);
+
+	dev_dbg(&ts->client->dev, "[FTS]ft5x02 suspend\n");
+	disable_irq(ts->pdata->irq);
+}
+
+static void ft5x02_ts_resume(struct early_suspend *handler)
+{
+	struct ft5x02_ts_data *ts = container_of(handler, struct ft5x02_ts_data,
+						early_suspend);
+
+	dev_dbg(&ts->client->dev, "[FTS]ft5x02 resume.\n");
+	//gpio_set_value(ts->pdata->reset, 0);
+	aml_gpio_direction_output(ts_com->gpio_reset, 0);
+	msleep(20);
+	//gpio_set_value(ts->pdata->reset, 1);
+	aml_gpio_direction_output(ts_com->gpio_reset, 1);
+	enable_irq(ts->pdata->irq);
+}
+#else
+#define ft5x02_ts_suspend	NULL
+#define ft5x02_ts_resume		NULL
+#endif
+
+
+#ifdef SYSFS_DEBUG
+static ssize_t ft5x02_initparam_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	ssize_t num_read_chars = 0;
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+
+	mutex_lock(&g_device_mutex);
+	if (ft5x02_Init_IC_Param(client) >= 0)
+		num_read_chars = sprintf(buf, "%s",
+			"ft5x02 init param successful\r\n");
+	else
+		num_read_chars = sprintf(buf, "%s",
+			"ft5x02 init param failed!\r\n");
+	//ft5x02_get_ic_param(client);
+	mutex_unlock(&g_device_mutex);
+	
+	return num_read_chars;
+}
+
+
+static ssize_t ft5x02_initparam_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	/*place holder for future use*/
+	return -EPERM;
+}
+
+static DEVICE_ATTR(ft5x02initparam, S_IRUGO | S_IWUSR, ft5x02_initparam_show,
+		   ft5x02_initparam_store);
+
+/*add your attr in here*/
+static struct attribute *ft5x02_attributes[] = {
+	&dev_attr_ft5x02initparam.attr,
+	NULL
+};
+static struct attribute_group ft5x02_attribute_group = {
+	.attrs = ft5x02_attributes
+};
+static int ft5x02_create_sysfs_debug(struct i2c_client *client)
+{
+	int err = 0;
+	err = sysfs_create_group(&client->dev.kobj, &ft5x02_attribute_group);
+	if (0 != err) {
+		dev_err(&client->dev,
+					 "%s() - ERROR: sysfs_create_group() failed.\n",
+					 __func__);
+		sysfs_remove_group(&client->dev.kobj, &ft5x02_attribute_group);
+		return -EIO;
+	} else {
+		mutex_init(&g_device_mutex);
+		pr_info("ft5x0x:%s() - sysfs_create_group() succeeded.\n",
+				__func__);
+	}
+	return err;
+}
+#endif
+
+static int ft5x02_ts_remove(struct i2c_client *client)
+{
+	struct ft5x02_ts_data *ft5x02_ts;
+	ft5x02_ts = i2c_get_clientdata(client);
+	input_unregister_device(ft5x02_ts->input_dev);
+	free_touch_gpio(ts_com);
+	#ifdef CONFIG_PM
+	//gpio_free(ft5x02_ts->pdata->reset);
+	#endif
+	#ifdef SYSFS_DEBUG
+	mutex_destroy(&g_device_mutex);
+	sysfs_remove_group(&client->dev.kobj, &ft5x02_attribute_group);
+	#endif
+	//cancel_delayed_work_sync(&ft5x02_ts->dwork);
+	free_irq(client->irq, ft5x02_ts);
+	kfree(ft5x02_ts);
+	i2c_set_clientdata(client, NULL); 	
+	return 0;
+}
+
+
+static const struct i2c_device_id ft5x02_ts_id[] = {
+	{ FT5X02_NAME, 0 },{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ft5x02_ts_id);
+
+static struct i2c_driver ft5x02_ts_driver = {
+	.probe		= ft5x02_ts_probe,
+	.remove		= ft5x02_ts_remove,
+	.id_table	= ft5x02_ts_id,
+	.suspend = ft5x02_ts_suspend,
+	.resume = ft5x02_ts_resume,
+	.driver	= {
+		.name	= FT5X02_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ft5x02_ts_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&ft5x02_ts_driver);
+	if (ret) {
+		printk(KERN_WARNING "Adding ft5x02 driver failed "
+		       "(errno = %d)\n", ret);
+	} else {
+		pr_info("Successfully added driver %s\n",
+			  ft5x02_ts_driver.driver.name);
+	}
+	return ret;
+}
+
+static void __exit ft5x02_ts_exit(void)
+{
+	i2c_del_driver(&ft5x02_ts_driver);
+}
+
+module_init(ft5x02_ts_init);
+module_exit(ft5x02_ts_exit);
+
+MODULE_AUTHOR("<luowj>");
+MODULE_DESCRIPTION("FocalTech ft5x02 TouchScreen driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.h b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.h
new file mode 100755
index 000000000000..196e748521ea
--- /dev/null
+++ b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.h
@@ -0,0 +1,65 @@
+#ifndef __LINUX_FT5X02_TS_H__
+#define __LINUX_FT5X02_TS_H__
+
+/*linux/i2c/ft5x02_ts.h*/
+#include <linux/i2c.h>
+
+
+/* -- dirver configure -- */
+#define CFG_SUPPORT_TOUCH_KEY  1    /*touch key, HOME, SEARCH, RETURN etc*/
+
+#define CFG_MAX_TOUCH_POINTS  5
+
+#define PRESS_MAX       255
+#define FT_PRESS		127
+
+#define FT_MAX_ID	0x0F
+#define FT_TOUCH_STEP	6
+#define FT_TOUCH_X_H_POS		3
+#define FT_TOUCH_X_L_POS		4
+#define FT_TOUCH_Y_H_POS		5
+#define FT_TOUCH_Y_L_POS		6
+#define FT_TOUCH_EVENT_POS		3
+#define FT_TOUCH_ID_POS			5
+
+
+#define POINT_READ_BUF  (3 + 6 * CFG_MAX_TOUCH_POINTS) /*standard iic protocol*/
+
+#define FT5X02_NAME		"ft5x02"
+
+#if CFG_SUPPORT_TOUCH_KEY
+#define KEY_PRESS       1
+#define KEY_RELEASE     0
+#define CFG_NUMOFKEYS 4   
+#endif
+
+
+/*register address*/
+
+#define FTS_DBG
+#ifdef FTS_DBG
+#define DBG(fmt, args...) printk("[FTS]" fmt, ## args)
+#else
+#define DBG(fmt, args...) do{}while(0)
+#endif
+
+
+/* The platform data for the Focaltech ft5x0x touchscreen driver */
+struct ft5x02_platform_data {
+	unsigned int x_max;
+	unsigned int y_max;
+	unsigned long irqflags;/*default:IRQF_TRIGGER_FALLING*/
+	unsigned int irq;
+	unsigned int reset;
+};
+
+int ft5x02_i2c_Read(struct i2c_client *client, char *writebuf, int writelen,
+		    char *readbuf, int readlen);
+int ft5x02_i2c_Write(struct i2c_client *client, char *writebuf, int writelen);
+
+int ft5x02_write_reg(struct i2c_client * client, u8 regaddr, u8 regvalue);
+
+int ft5x02_read_reg(struct i2c_client * client, u8 regaddr, u8 *regvalue);
+
+
+#endif
-- 
2.19.0

