From 583c450d76b80f6f7d4b4ac73c31ef3bb5448dbf Mon Sep 17 00:00:00 2001
From: "simon.zheng" <simon@ubuntu.(none)>
Date: Wed, 20 Nov 2013 18:45:20 +0800
Subject: [PATCH 2000/5965] add jpeg encoder driver

---
 drivers/amlogic/amports/Kconfig               |    7 +
 drivers/amlogic/amports/Makefile              |    1 +
 drivers/amlogic/amports/jpegenc.c             | 1654 +++++++++++++++++
 drivers/amlogic/amports/jpegenc.h             |  693 +++++++
 drivers/amlogic/amports/jpegenc_mc.h          |   13 +
 .../amlogic/amports/m8/ucode/jpegenc/Makefile |    2 +
 .../amports/m8/ucode/jpegenc/Makefile.bak     |    2 +
 .../m8/ucode/jpegenc/jpeg_encoder_mc.c        |   46 +
 .../m8/ucode/jpegenc/jpeg_encoder_mc.c.bak    |   44 +
 9 files changed, 2462 insertions(+)
 create mode 100644 drivers/amlogic/amports/jpegenc.c
 create mode 100644 drivers/amlogic/amports/jpegenc.h
 create mode 100644 drivers/amlogic/amports/jpegenc_mc.h
 create mode 100644 drivers/amlogic/amports/m8/ucode/jpegenc/Makefile
 create mode 100755 drivers/amlogic/amports/m8/ucode/jpegenc/Makefile.bak
 create mode 100644 drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c
 create mode 100644 drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c.bak

diff --git a/drivers/amlogic/amports/Kconfig b/drivers/amlogic/amports/Kconfig
index e6c7e665faa2..0151965fa1fe 100755
--- a/drivers/amlogic/amports/Kconfig
+++ b/drivers/amlogic/amports/Kconfig
@@ -108,6 +108,13 @@ config AM_ENCODER
 	select AM_PTSSERVER
 	help
 	  Driver for avc encoder.
+config AM_JPEG_ENCODER
+	tristate "Amlogic jpeg encoder"
+	default n
+	
+	select AM_PTSSERVER
+	help
+	  Driver for jpeg encoder.	  
 config AM_VDEC_REAL
 	tristate "Amlogic Real Video Decoder"
     default y
diff --git a/drivers/amlogic/amports/Makefile b/drivers/amlogic/amports/Makefile
index 5bfa0dd92da8..2e60d3540da9 100755
--- a/drivers/amlogic/amports/Makefile
+++ b/drivers/amlogic/amports/Makefile
@@ -79,6 +79,7 @@ amvdec_real-y    := vreal.o
 obj-$(CONFIG_AM_JPEGDEC) += jpegdec.o
 
 obj-$(CONFIG_AM_ENCODER) += encoder.o
+obj-$(CONFIG_AM_JPEG_ENCODER) += jpegenc.o
 obj-$(CONFIG_AM_VIDEO) += amvideo.o
 amvideo-objs := video.o vpp.o video_prot.o
 amvideo-y    := video.o vpp.o video_prot.o
diff --git a/drivers/amlogic/amports/jpegenc.c b/drivers/amlogic/amports/jpegenc.c
new file mode 100644
index 000000000000..e33bf7ef3f07
--- /dev/null
+++ b/drivers/amlogic/amports/jpegenc.c
@@ -0,0 +1,1654 @@
+/*
+ * AMLOGIC JPEG Encoder driver.
+ *
+ *
+ * Author:  Simon Zheng <simon.zheng@amlogic.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <mach/am_regs.h>
+#include <plat/io.h>
+#include <linux/ctype.h>
+#include <linux/amports/ptsserv.h>
+#include <linux/amports/amstream.h>
+#include <linux/amports/canvas.h>
+#include <linux/amports/vframe.h>
+#include <linux/amports/vframe_provider.h>
+#include <linux/amports/vframe_receiver.h>
+#include "vdec_reg.h"
+#include <linux/delay.h>
+
+#define ENC_CANVAS_OFFSET  AMVENC_CANVAS_INDEX
+
+#define LOG_LEVEL_VAR 0
+
+#define PUT_INTERVAL        (HZ/100)
+#ifdef CONFIG_AM_VDEC_MJPEG_LOG
+#define AMLOG
+#define LOG_LEVEL_VAR       debug_level_avc
+#define LOG_MASK_VAR        amlog_mask_avc
+#define 2     0
+#define 1      1
+#define LOG_LEVEL_DESC  "0:ERROR, 1:INFO"
+#endif
+#define debug_level(level, x...) \
+	do { \
+		if (level >= LOG_LEVEL_VAR) \
+			printk(x); \
+	} while (0);
+
+#include <linux/amlog.h>
+MODULE_AMLOG(2, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
+
+#include "jpegenc.h"
+#include "amvdec.h"
+#include "jpegenc_mc.h"
+static int jpegenc_device_major = 0;
+static struct class *jpegenc_class;
+static struct device *jpegenc_dev;
+#define DRIVER_NAME "jpegenc"
+#define MODULE_NAME "jpegenc"
+#define DEVICE_NAME "jpegenc"
+
+/* protocol register usage
+	#define ENCODER_STATUS            HENC_SCRATCH_0    : encode stage
+	#define MEM_OFFSET_REG            HENC_SCRATCH_1    : assit buffer physical address
+	#define DEBUG_REG  				  HENC_SCRATCH_2    : debug register
+	#define MB_COUNT				  HENC_SCRATCH_3	: MB encoding number
+*/
+
+/*output buffer define*/
+static unsigned BitstreamStart;
+static unsigned BitstreamEnd;  
+
+static unsigned* BitstreamStartVirtAddr;
+static unsigned dct_buff_start_addr;  
+static unsigned dct_buff_end_addr;
+
+
+static u32 stat;
+
+static u32 encoder_width = 1280;
+static u32 encoder_height = 720;
+static jpegenc_frame_fmt input_format;
+static jpegenc_frame_fmt output_format;
+
+
+static s32 jpegenc_poweron(void);
+static void dma_flush(unsigned buf_start , unsigned buf_size );
+static u32 qppicture  =26;
+static u32 process_irq = 0;
+
+static int encode_inited = 0;
+static int encode_opened = 0;
+
+static const char jpeg_enc_id[] = "jpegenc-dev";
+
+#define AMVENC_BUFFER_LEVEL_480P   0
+#define AMVENC_BUFFER_LEVEL_720P   1
+#define AMVENC_BUFFER_LEVEL_1080P 2
+
+typedef struct
+{
+    u32 buf_start;
+    u32 buf_size;
+} Buff_t;
+
+typedef struct
+{
+    u32 lev_id;
+    u32 max_width;
+    u32 max_height;
+    u32 dec0_y;
+    u32 dec0_uv;
+    u32 bitstream;
+} BuffInfo_t;
+
+const static BuffInfo_t jpegenc_buffspec={0,10000,10000,0,0,0};
+
+
+typedef struct
+{
+    u32 buf_start;
+    u32 buf_size;
+    u8 cur_buf_lev; 
+    BuffInfo_t* bufspec;
+} EncBuffer_t;
+
+static EncBuffer_t gJpegEncBuff = {0,0,0,NULL};
+
+static void jpegenc_canvas_init(void);
+
+void jpegenc_reset(void);
+void init_jpeg_encoder(void);
+void write_jpeg_quant_lut(int table_num);
+void write_jpeg_huffman_lut_dc(int table_num);
+void write_jpeg_huffman_lut_ac(int table_num);
+int  zigzag(int i);
+
+
+void push_word(int* offset , unsigned word)
+{
+	unsigned char* ptr;
+	int i;
+	int bytes = (word >> 24)&0xff;
+	for(i = bytes-1 ;i >= 0;i--){
+		ptr = (unsigned char*)(BitstreamStartVirtAddr ) + *offset;
+		(*offset)++;	
+		if(i ==0){
+			*ptr = word&0xff;		
+		}else if(i ==1){
+			*ptr = (word >>8)&0xff;
+		}else if(i == 2 ){
+			*ptr = (word >>16)&0xff;
+		}
+	}	
+}
+
+
+void prepare_jpeg_header(void)
+{
+	int pic_format; 
+	int pic_width, pic_height;
+	int q_sel_comp0, q_sel_comp1, q_sel_comp2;
+    int dc_huff_sel_comp0, dc_huff_sel_comp1, dc_huff_sel_comp2;
+    int ac_huff_sel_comp0, ac_huff_sel_comp1, ac_huff_sel_comp2;
+    int lastcoeff_sel;
+    int jdct_intr_sel;
+    int h_factor_comp0, v_factor_comp0;
+    int h_factor_comp1, v_factor_comp1;
+    int h_factor_comp2, v_factor_comp2;
+    int q_num;
+    int tq[2];
+    int dc_huff_num, ac_huff_num;
+    int dc_th[2], ac_th[2];
+	int header_bytes = 0 ;
+	int bak_header_bytes = 0;
+	int i ,j ;
+	
+	if(output_format >= MAX_FRAME_FMT){
+		debug_level(0,"Input format is wrong!!!!\n");
+	}
+	switch(output_format){
+		case FMT_NV21:
+		case FMT_NV12:
+		case FMT_YUV420:
+			pic_format = 3;
+			break;
+		case FMT_YUV422_SINGLE:
+			pic_format = 2;
+			break;
+		case FMT_YUV444_SINGLE:
+		case FMT_YUV444_PLANE:
+			pic_format = 1;
+			break;
+		default:
+			pic_format = 0;
+			break;
+	}
+	//pic_format = 2;
+
+    pic_width           = encoder_width;
+    pic_height          = encoder_height;
+        
+    q_sel_comp0         = QUANT_SEL_COMP0;
+    q_sel_comp1         = QUANT_SEL_COMP1;
+    q_sel_comp2         = QUANT_SEL_COMP2;
+       
+    dc_huff_sel_comp0   = DC_HUFF_SEL_COMP0;
+    dc_huff_sel_comp1   = DC_HUFF_SEL_COMP1;
+    dc_huff_sel_comp2   = DC_HUFF_SEL_COMP2;
+    ac_huff_sel_comp0   = AC_HUFF_SEL_COMP0;
+    ac_huff_sel_comp1   = AC_HUFF_SEL_COMP1;
+    ac_huff_sel_comp2   = AC_HUFF_SEL_COMP2;
+    lastcoeff_sel       =  JDCT_LASTCOEFF_SEL;
+    jdct_intr_sel       =  JDCT_INTR_SEL;
+
+    if (pic_format == 2) { // YUV422
+        h_factor_comp0 = 1; v_factor_comp0 = 0;
+        h_factor_comp1 = 0; v_factor_comp1 = 0;
+        h_factor_comp2 = 0; v_factor_comp2 = 0;
+    } else if (pic_format == 3) { // YUV420
+        h_factor_comp0 = 1; v_factor_comp0 = 1;
+        h_factor_comp1 = 0; v_factor_comp1 = 0;
+        h_factor_comp2 = 0; v_factor_comp2 = 0;
+    } else {    // RGB or YUV
+        h_factor_comp0 = 0; v_factor_comp0 = 0;
+        h_factor_comp1 = 0; v_factor_comp1 = 0;
+        h_factor_comp2 = 0; v_factor_comp2 = 0;
+    }	
+	
+    // SOI marker
+    
+    push_word(&header_bytes , (2       << 24)  |   // Number of bytes
+                       (0xffd8  << 0));     // data: SOI marker
+    //header_bytes += 2;  // Add SOI bytes
+    
+    // Define quantization tables
+    
+    q_num   = 1;
+    if ((q_sel_comp0 != q_sel_comp1) || (q_sel_comp0 != q_sel_comp2) || (q_sel_comp1 != q_sel_comp2)) {
+        q_num ++;
+    }
+    tq[0]   = q_sel_comp0;
+    tq[1]   = (q_sel_comp0 != q_sel_comp1)? q_sel_comp1 :
+              (q_sel_comp0 != q_sel_comp2)? q_sel_comp2 :
+                                            q_sel_comp0;
+    
+    push_word(&header_bytes , (2           << 24)  |
+                       (0xffdb      << 0));     // data: DQT marker
+    push_word(&header_bytes , (2           << 24)  |
+                       ((2+65*q_num)<< 0));     // data: Lq
+    for (i = 0; i < q_num; i ++) {
+        push_word(&header_bytes  , (1   << 24)  |
+                           (i   << 0));     // data: {Pq,Tq}
+        for (j = 0; j < 64; j ++) {
+            push_word(&header_bytes  , (1                               << 24)  |
+                               ((jpeg_quant[tq[i]][zigzag(j)])  << 0));     // data: Qk
+        }
+    }
+    
+    //header_bytes += (2 + (2+65*q_num)); // Add Quantization table bytes
+    
+    // Define Huffman tables
+    
+    dc_huff_num = 1;
+    if ((dc_huff_sel_comp0 != dc_huff_sel_comp1) || (dc_huff_sel_comp0 != dc_huff_sel_comp2) || (dc_huff_sel_comp1 != dc_huff_sel_comp2)) {
+        dc_huff_num ++;
+    }
+    ac_huff_num = 1;
+    if ((ac_huff_sel_comp0 != ac_huff_sel_comp1) || (ac_huff_sel_comp0 != ac_huff_sel_comp2) || (ac_huff_sel_comp1 != ac_huff_sel_comp2)) {
+        ac_huff_num ++;
+    }
+    dc_th[0]    = dc_huff_sel_comp0;
+    dc_th[1]    = (dc_huff_sel_comp0 != dc_huff_sel_comp1)? dc_huff_sel_comp1 :
+                  (dc_huff_sel_comp0 != dc_huff_sel_comp2)? dc_huff_sel_comp2 :
+                                                            dc_huff_sel_comp0;
+    ac_th[0]    = ac_huff_sel_comp0;
+    ac_th[1]    = (ac_huff_sel_comp0 != ac_huff_sel_comp1)? ac_huff_sel_comp1 :
+                  (ac_huff_sel_comp0 != ac_huff_sel_comp2)? ac_huff_sel_comp2 :
+                                                            ac_huff_sel_comp0;
+    
+    push_word(&header_bytes  , (2                                               << 24)  |
+                       (0xffc4                                          << 0));     // data: DHT marker
+    push_word(&header_bytes  , (2                                               << 24)  |
+                       ((2+(1+16+12)*dc_huff_num+(1+16+162)*ac_huff_num)<< 0));     // data: Lh
+    for (i = 0; i < dc_huff_num; i ++) {
+        push_word(&header_bytes , (1   << 24)  |
+                           (i   << 0));     // data: {Tc,Th}
+        for (j = 0; j < 16+12; j ++) {
+            push_word(&header_bytes  , (1                               << 24)  |
+                               ((jpeg_huffman_dc[dc_th[i]][j])  << 0));     // data: Li then Vi,j
+        }
+    }
+    for (i = 0; i < ac_huff_num; i ++) {
+        push_word(&header_bytes  , (1   << 24)  |
+                           (1   << 4)   |   // data: Tc
+                           (i   << 0));     // data: Th
+        for (j = 0; j < 16+162; j ++) {
+            push_word(&header_bytes  , (1                               << 24)  |
+                               ((jpeg_huffman_ac[ac_th[i]][j])  << 0));     // data: Li then Vi,j
+        }
+    }
+    
+    //header_bytes += (2 + (2+(1+16+12)*dc_huff_num+(1+16+162)*ac_huff_num)); // Add Huffman table bytes
+    
+    // Frame header
+    push_word(&header_bytes , (2                                       << 24)  |   // Number of bytes
+                       (0xffc0                                  << 0));     // data: SOF_0 marker
+    push_word(&header_bytes  , (2                                       << 24)  |
+                       ((8+3*3)                                 << 0));     // data: Lf
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (8                                       << 0));     // data: P -- Sample precision
+    push_word(&header_bytes  , (2                                       << 24)  |
+                       (pic_height                              << 0));     // data: Y -- Number of lines
+    push_word(&header_bytes  , (2                                       << 24)  |
+                       (pic_width                               << 0));      // data: X -- Number of samples per line
+    push_word(&header_bytes , (1                                       << 24)  |
+                       (3                                       << 0));     // data: Nf -- Number of components in a frame
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (0                                       << 0));     // data: C0 -- Comp0 identifier
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       ((h_factor_comp0+1)                      << 4)   |   // data: H0 -- Comp0 horizontal sampling factor
+                       ((v_factor_comp0+1)                      << 0));     // data: V0 -- Comp0 vertical sampling factor
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (0                                       << 0));     // data: Tq0 -- Comp0 quantization table seletor
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (1                                       << 0));     // data: C1 -- Comp1 identifier
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       ((h_factor_comp1+1)                      << 4)   |   // data: H1 -- Comp1 horizontal sampling factor
+                       ((v_factor_comp1+1)                      << 0));     // data: V1 -- Comp1 vertical sampling factor
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (((q_sel_comp0 != q_sel_comp1)? 1 : 0)   << 0));     // data: Tq1 -- Comp1 quantization table seletor
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (2                                       << 0));     // data: C2 -- Comp2 identifier
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       ((h_factor_comp2+1)                      << 4)   |   // data: H2 -- Comp2 horizontal sampling factor
+                       ((v_factor_comp2+1)                      << 0));     // data: V2 -- Comp2 vertical sampling factor
+    push_word(&header_bytes  , (1                                       << 24)  |
+                       (((q_sel_comp0 != q_sel_comp2)? 1 : 0)   << 0));     // data: Tq2 -- Comp2 quantization table seletor
+    
+    //header_bytes += (2 + (8+3*3));  // Add Frame header bytes
+    
+    // Scan header
+    
+    bak_header_bytes  = header_bytes + (2 + (6+2*3));
+    
+    //header_bytes += (2 + (6+2*3));  // Add Scan header bytes
+    // If total header bytes is not multiple of 8, then fill 0xff byte between Frame header segment and the Scan header segment.
+    for (i = 0; i < ((bak_header_bytes + 7)/8)*8 - bak_header_bytes; i ++) {
+        push_word(&header_bytes  , (1       << 24)  |
+                           (0xff    << 0)); // 0xff filler
+    }
+   // header_bytes = ((header_bytes + 7)/8)*8;
+    
+    
+    
+    push_word(&header_bytes  , (2                                               << 24)  |   // Number of bytes
+                       (0xffda                                          << 0));     // data: SOS marker
+    push_word(&header_bytes  , (2                                               << 24)  |
+                       ((6+2*3)                                         << 0));     // data: Ls
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (3                                               << 0));     // data: Ns -- Number of components in a scan
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (0                                               << 0));     // data: Cs0 -- Comp0 identifier
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (0                                               << 4)   |   // data: Td0 -- Comp0 DC Huffman table selector
+                       (0                                               << 0));     // data: Ta0 -- Comp0 AC Huffman table selector
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (1                                               << 0));     // data: Cs1 -- Comp1 identifier
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (((dc_huff_sel_comp0 != dc_huff_sel_comp1)? 1:0) << 4)   |   // data: Td1 -- Comp1 DC Huffman table selector
+                       (((ac_huff_sel_comp0 != ac_huff_sel_comp1)? 1:0) << 0));     // data: Ta1 -- Comp1 AC Huffman table selector
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (2                                               << 0));     // data: Cs2 -- Comp2 identifier
+    push_word(&header_bytes  , (1                                               << 24)  |
+                       (((dc_huff_sel_comp0 != dc_huff_sel_comp2)? 1:0) << 4)   |   // data: Td2 -- Comp2 DC Huffman table selector
+                       (((ac_huff_sel_comp0 != ac_huff_sel_comp2)? 1:0) << 0));     // data: Ta2 -- Comp2 AC Huffman table selector
+    push_word(&header_bytes  , (3                                               << 24)  |
+                       (0                                               << 16)  |   // data: Ss = 0
+                       (63                                              << 8)   |   // data: Se = 63
+                       (0                                               << 4)   |   // data: Ah = 0
+                       (0                                               << 0));     // data: Al = 0
+   debug_level(0,"jpeg header bytes is %d \n",header_bytes);  
+   WRITE_HREG(HCODEC_HENC_SCRATCH_1 , header_bytes); // Send MEM_OFFSET
+    // Put header file to DDR
+   // stimulus_event(1 , (0x1 << 28) | (header_bytes << 0));
+
+}
+void init_jpeg_encoder()
+{
+	unsigned long data32 ;
+    int i, j;
+    int pic_format;             // 0=RGB; 1=YUV; 2=YUV422; 3=YUV420
+    int pic_x_start, pic_x_end, pic_y_start, pic_y_end;
+
+    int pic_width, pic_height;
+    int q_sel_comp0, q_sel_comp1, q_sel_comp2;
+    int dc_huff_sel_comp0, dc_huff_sel_comp1, dc_huff_sel_comp2;
+    int ac_huff_sel_comp0, ac_huff_sel_comp1, ac_huff_sel_comp2;
+    int lastcoeff_sel;
+    int jdct_intr_sel;
+    int h_factor_comp0, v_factor_comp0;
+    int h_factor_comp1, v_factor_comp1;
+    int h_factor_comp2, v_factor_comp2;
+
+    int q_num;
+    int tq[2];
+    int dc_huff_num, ac_huff_num;
+    int dc_th[2], ac_th[2];
+    
+    int header_bytes;
+    
+    // Wait until stimulus done storing the test configuration
+   debug_level(0,"Initialize JPEG Encoder ....\n");
+    
+#if 0    
+// Load the test configuration into C   
+    pic_format          = (*P_DOS_SCRATCH0)         & 0x3;
+    pic_x_start         = (*P_DOS_SCRATCH1)         & 0x3fff;
+    pic_x_end           = ((*P_DOS_SCRATCH1)>>16)   & 0x3fff;
+    pic_y_start         = (*P_DOS_SCRATCH2)         & 0x3fff;
+    pic_y_end           = ((*P_DOS_SCRATCH2)>>16)   & 0x3fff;
+    pic_width           = pic_x_end - pic_x_start + 1;
+    pic_height          = pic_y_end - pic_y_start + 1;
+    q_sel_comp0         = (*P_DOS_SCRATCH3)         & 0xff;
+    q_sel_comp1         = ((*P_DOS_SCRATCH3)>>8)    & 0xff;
+    q_sel_comp2         = ((*P_DOS_SCRATCH3)>>16)   & 0xff;
+    dc_huff_sel_comp0   = (*P_DOS_SCRATCH4)         & 0xf;
+    dc_huff_sel_comp1   = ((*P_DOS_SCRATCH4)>>4)    & 0xf;
+    dc_huff_sel_comp2   = ((*P_DOS_SCRATCH4)>>8)    & 0xf;
+    ac_huff_sel_comp0   = ((*P_DOS_SCRATCH4)>>12)   & 0xf;
+    ac_huff_sel_comp1   = ((*P_DOS_SCRATCH4)>>16)   & 0xf;
+    ac_huff_sel_comp2   = ((*P_DOS_SCRATCH4)>>20)   & 0xf;
+    lastcoeff_sel       = ((*P_DOS_SCRATCH5)>>4)    & 0x3;
+    jdct_intr_sel       = ((*P_DOS_SCRATCH5)>>8)    & 0x7;
+#else
+	if(output_format >= MAX_FRAME_FMT){
+		debug_level(0,"Input format is wrong!!!!\n");
+	}
+	switch(output_format){
+		case FMT_NV21:
+		case FMT_NV12:
+		case FMT_YUV420:
+			pic_format = 3;
+			break;
+		case FMT_YUV422_SINGLE:
+			pic_format = 2;
+			break;
+		case FMT_YUV444_SINGLE:
+		case FMT_YUV444_PLANE:
+			pic_format = 1;
+			break;
+		default:
+			pic_format = 0;
+			break;
+	}
+	//pic_format = 2;
+    pic_x_start         = 0;
+    pic_x_end           = encoder_width -1;
+    pic_y_start         = 0;
+    pic_y_end           = encoder_height - 1;
+    pic_width           = encoder_width;
+    pic_height          = encoder_height;
+        
+    q_sel_comp0         = QUANT_SEL_COMP0;
+    q_sel_comp1         = QUANT_SEL_COMP1;
+    q_sel_comp2         = QUANT_SEL_COMP2;
+       
+    dc_huff_sel_comp0   = DC_HUFF_SEL_COMP0;
+    dc_huff_sel_comp1   = DC_HUFF_SEL_COMP1;
+    dc_huff_sel_comp2   = DC_HUFF_SEL_COMP2;
+    ac_huff_sel_comp0   = AC_HUFF_SEL_COMP0;
+    ac_huff_sel_comp1   = AC_HUFF_SEL_COMP1;
+    ac_huff_sel_comp2   = AC_HUFF_SEL_COMP2;
+    lastcoeff_sel       =  JDCT_LASTCOEFF_SEL;
+    jdct_intr_sel       =  JDCT_INTR_SEL;
+#endif
+
+    if (pic_format == 2) { // YUV422
+        h_factor_comp0 = 1; v_factor_comp0 = 0;
+        h_factor_comp1 = 0; v_factor_comp1 = 0;
+        h_factor_comp2 = 0; v_factor_comp2 = 0;
+    } else if (pic_format == 3) { // YUV420
+        h_factor_comp0 = 1; v_factor_comp0 = 1;
+        h_factor_comp1 = 0; v_factor_comp1 = 0;
+        h_factor_comp2 = 0; v_factor_comp2 = 0;
+    } else {    // RGB or YUV
+        h_factor_comp0 = 0; v_factor_comp0 = 0;
+        h_factor_comp1 = 0; v_factor_comp1 = 0;
+        h_factor_comp2 = 0; v_factor_comp2 = 0;
+    }
+
+    //--------------------------------------------------------------------------
+    // Configure picture size and format  
+    //--------------------------------------------------------------------------
+
+	WRITE_HREG(HCODEC_VLC_PIC_SIZE ,pic_width | (pic_height<<16));
+	WRITE_HREG(HCODEC_VLC_PIC_POSITION ,pic_format | (lastcoeff_sel <<4));
+
+	WRITE_HREG(HCODEC_QDCT_JPEG_X_START_END , ((pic_x_end<<16) | (pic_x_start<<0)));
+	WRITE_HREG(HCODEC_QDCT_JPEG_Y_START_END ,((pic_y_end<<16) | (pic_y_start<<0)));
+
+    //--------------------------------------------------------------------------
+    // Configure quantization tables
+    //--------------------------------------------------------------------------
+    
+    // Set Quantization LUT start address
+    data32  = 0;
+    data32 |= 0 << 8;   // [    8] 0=Write LUT, 1=Read
+    data32 |= 0 << 0;   // [ 5: 0] Start addr = 0
+   
+    WRITE_HREG(HCODEC_QDCT_JPEG_QUANT_ADDR ,data32);
+    
+
+    // Burst-write Quantization LUT data
+    write_jpeg_quant_lut(q_sel_comp0);
+    if (q_sel_comp1 != q_sel_comp0) {
+        write_jpeg_quant_lut(q_sel_comp1);
+    }
+    if ((q_sel_comp2 != q_sel_comp0) && (q_sel_comp2 != q_sel_comp1)) {
+        write_jpeg_quant_lut(q_sel_comp2);
+    }
+    
+    //--------------------------------------------------------------------------
+    // Configure Huffman tables
+    //--------------------------------------------------------------------------
+
+    // Set DC Huffman LUT start address
+    data32  = 0;
+    data32 |= 0 << 16;  // [   16] 0=Write LUT, 1=Read
+    data32 |= 0 << 0;   // [ 8: 0] Start addr = 0
+    WRITE_HREG(HCODEC_VLC_HUFFMAN_ADDR ,data32);
+
+
+    // Burst-write DC Huffman LUT data
+    write_jpeg_huffman_lut_dc(dc_huff_sel_comp0);
+    if (dc_huff_sel_comp1 != dc_huff_sel_comp0) {
+        write_jpeg_huffman_lut_dc(dc_huff_sel_comp1);
+    }
+    if ((dc_huff_sel_comp2 != dc_huff_sel_comp0) && (dc_huff_sel_comp2 != dc_huff_sel_comp1)) {
+        write_jpeg_huffman_lut_dc(dc_huff_sel_comp2);
+    }
+    
+    // Set AC Huffman LUT start address
+    data32  = 0;
+    data32 |= 0 << 16;  // [   16] 0=Write LUT, 1=Read
+    data32 |= 24<< 0;   // [ 8: 0] Start addr = 0
+    WRITE_HREG(HCODEC_VLC_HUFFMAN_ADDR ,data32);
+
+    // Burst-write AC Huffman LUT data
+    write_jpeg_huffman_lut_ac(ac_huff_sel_comp0);
+    if (ac_huff_sel_comp1 != ac_huff_sel_comp0) {
+        write_jpeg_huffman_lut_ac(ac_huff_sel_comp1);
+    }
+    if ((ac_huff_sel_comp2 != ac_huff_sel_comp0) && (ac_huff_sel_comp2 != ac_huff_sel_comp1)) {
+        write_jpeg_huffman_lut_ac(ac_huff_sel_comp2);
+    }
+
+    //--------------------------------------------------------------------------
+    // Configure general control registers
+    //--------------------------------------------------------------------------
+
+    data32  = 0;
+    data32 |= 0                                     << 18;  // [19:18] dct_inflow_ctrl: 0=No halt;
+                                                            //                          1=DCT halts request at end of each 8x8 block;
+                                                            //                          2=DCT halts request at end of each MCU.
+    data32 |= lastcoeff_sel                         << 16;  // [17:16] jpeg_coeff_last_sel: 0=Mark last coeff at the end of an 8x8 block,
+                                                            //                              1=Mark last coeff at the end of an MCU
+                                                            //                              2=Mark last coeff at the end of a scan
+    data32 |= ((q_sel_comp2==q_sel_comp0)? 0 : 1)   << 15;  // [   15] jpeg_quant_sel_comp2
+    data32 |= v_factor_comp2                        << 14;  // [   14] jpeg_v_factor_comp2
+    data32 |= h_factor_comp2                        << 13;  // [   13] jpeg_h_factor_comp2
+    data32 |= 1                                     << 12;  // [   12] jpeg_comp2_en
+    data32 |= ((q_sel_comp1==q_sel_comp0)? 0 : 1)   << 11;  // [   11] jpeg_quant_sel_comp1
+    data32 |= v_factor_comp1                        << 10;  // [   10] jpeg_v_factor_comp1
+    data32 |= h_factor_comp1                        << 9;   // [    9] jpeg_h_factor_comp1
+    data32 |= 1                                     << 8;   // [    8] jpeg_comp1_en
+    data32 |= 0                                     << 7;   // [    7] jpeg_quant_sel_comp0
+    data32 |= v_factor_comp0                        << 6;   // [    6] jpeg_v_factor_comp0
+    data32 |= h_factor_comp0                        << 5;   // [    5] jpeg_h_factor_comp0
+    data32 |= 1                                     << 4;   // [    4] jpeg_comp0_en
+    data32 |= jdct_intr_sel                         << 1;   // [ 3: 1] jdct_intr_sel:0=Disable intr;
+                                                            //                       1=Intr at end of each 8x8 block of DCT input;
+                                                            //                       2=Intr at end of each MCU of DCT input;
+                                                            //                       3=Intr at end of a scan of DCT input;
+                                                            //                       4=Intr at end of each 8x8 block of DCT output;
+                                                            //                       5=Intr at end of each MCU of DCT output;
+                                                            //                       6=Intr at end of a scan of DCT output.
+    data32 |= 1                                     << 0;   // [    0] jpeg_en
+    WRITE_HREG(HCODEC_QDCT_JPEG_CTRL ,data32);
+
+    data32  = 0;
+    data32 |= ((ac_huff_sel_comp2 == ac_huff_sel_comp0)? 0 : 1) << 29;  // [   29] jpeg_comp2_ac_table_sel
+    data32 |= ((dc_huff_sel_comp2 == dc_huff_sel_comp0)? 0 : 1) << 28;  // [   28] jpeg_comp2_dc_table_sel
+    data32 |= ((h_factor_comp2+1)*(v_factor_comp2+1)-1)         << 25;  // [26:25] jpeg_comp2_cnt_max
+    data32 |= 1                                                 << 24;  // [   24] jpeg_comp2_en
+    data32 |= ((ac_huff_sel_comp1 == ac_huff_sel_comp0)? 0 : 1) << 21;  // [   21] jpeg_comp1_ac_table_sel
+    data32 |= ((dc_huff_sel_comp1 == dc_huff_sel_comp0)? 0 : 1) << 20;  // [   20] jpeg_comp1_dc_table_sel
+    data32 |= ((h_factor_comp1+1)*(v_factor_comp1+1)-1)         << 17;  // [18:17] jpeg_comp1_cnt_max
+    data32 |= 1                                                 << 16;  // [   16] jpeg_comp1_en
+    data32 |= 0                                                 << 13;  // [   13] jpeg_comp0_ac_table_sel
+    data32 |= 0                                                 << 12;  // [   12] jpeg_comp0_dc_table_sel
+    data32 |= ((h_factor_comp0+1)*(v_factor_comp0+1)-1)         << 9;   // [10: 9] jpeg_comp0_cnt_max
+    data32 |= 1                                                 << 8;   // [    8] jpeg_comp0_en
+    data32 |= 0                                                 << 0;   // [    0] jpeg_en, will be enbled by amrisc
+	WRITE_HREG(HCODEC_VLC_JPEG_CTRL ,data32);
+
+    WRITE_HREG(HCODEC_QDCT_MB_CONTROL, 
+                (1<<9) | // mb_info_soft_reset
+                (1<<0))  // mb read buffer soft reset
+              ;
+    WRITE_HREG(HCODEC_QDCT_MB_CONTROL ,
+              (0<<28) | // ignore_t_p8x8
+              (0<<27) | // zero_mc_out_null_non_skipped_mb
+              (0<<26) | // no_mc_out_null_non_skipped_mb
+              (0<<25) | // mc_out_even_skipped_mb
+              (0<<24) | // mc_out_wait_cbp_ready
+              (0<<23) | // mc_out_wait_mb_type_ready
+              (0<<29) | // ie_start_int_enable
+              (0<<19) | // i_pred_enable
+              (0<<20) | // ie_sub_enable
+              (0<<18) | // iq_enable
+              (0<<17) | // idct_enable
+              (0<<14) | // mb_pause_enable
+              (1<<13) | // q_enable
+              (1<<12) | // dct_enable
+              (0<<10) | // mb_info_en
+              (0<<3) | // endian
+              (0<<1) | // mb_read_en
+              (0<<0))   // soft reset
+            ; // soft reset
+
+    //--------------------------------------------------------------------------
+    // Assember JPEG file header
+    //--------------------------------------------------------------------------
+    //need check
+    header_bytes    = READ_HREG(HCODEC_HENC_SCRATCH_1);
+	prepare_jpeg_header();
+}
+
+void write_jpeg_quant_lut(int table_num)
+{
+    int             i;
+    unsigned long   data32;
+    
+    for (i = 0; i < 64; i += 2) {
+        data32  = reciprocal(jpeg_quant[table_num][i]);
+        data32 |= reciprocal(jpeg_quant[table_num][i+1])    << 16;
+        WRITE_HREG(HCODEC_QDCT_JPEG_QUANT_DATA,data32);
+    }
+    
+}   /* write_jpeg_quant_lut */
+
+
+void write_jpeg_huffman_lut_dc(int table_num)
+{
+    unsigned int    code_len, code_word, pos, addr;
+    unsigned int    num_code_len;
+    unsigned int    lut[12];
+    unsigned int    i, j;
+    
+    code_len    = 1;
+    code_word   = 1;
+    pos         = 16;
+    
+    // Construct DC Huffman table
+    for (i = 0; i < 16; i ++) {
+        num_code_len    = jpeg_huffman_dc[table_num][i];
+        for (j = 0; j < num_code_len; j ++) {
+            code_word   = (code_word + 1) & ((1<<code_len)-1);
+            if (code_len < i + 1) {
+                code_word   <<= (i+1-code_len);
+                code_len    = i + 1;
+            }
+            addr        = jpeg_huffman_dc[table_num][pos];
+            lut[addr]   = ((code_len-1)<<16) | (code_word);
+            pos         ++;
+        }
+    }
+
+    // Write DC Huffman table to HW
+    for (i = 0; i < 12; i ++) {
+        WRITE_HREG(HCODEC_VLC_HUFFMAN_DATA,lut[i]);
+    }
+}   /* write_jpeg_huffman_lut_dc */
+
+void write_jpeg_huffman_lut_ac(int table_num)
+{
+    unsigned int    code_len, code_word, pos;
+    unsigned int    num_code_len;
+    unsigned int    run, size;
+    unsigned int    data, addr;
+    unsigned int    lut[162];
+    unsigned int    i, j;
+    
+    code_len    = 1;
+    code_word   = 1;
+    pos         = 16;
+    
+    // Construct AC Huffman table
+    for (i = 0; i < 16; i ++) {
+        num_code_len    = jpeg_huffman_ac[table_num][i];
+        for (j = 0; j < num_code_len; j ++) {
+            code_word   = (code_word + 1) & ((1<<code_len)-1);
+            if (code_len < i + 1) {
+                code_word   <<= (i+1-code_len);
+                code_len    = i + 1;
+            }
+            run         = jpeg_huffman_ac[table_num][pos] >> 4;
+            size        = jpeg_huffman_ac[table_num][pos] & 0xf;
+            data        = ((code_len-1)<<16) | (code_word);
+            if (size == 0) {
+                if (run == 0) {
+                    addr    = 0;        // EOB
+                } else if (run == 0xf) {
+                    addr    = 161;      // ZRL
+                } else {                	
+                	debug_level(0,"[TEST.C] Error: Illegal AC Huffman table format!\n");
+
+                }
+            } else if (size <= 0xa) {
+                addr    = 1 + 16*(size-1) + run;
+            } else {
+                debug_level(0,"[TEST.C] Error: Illegal AC Huffman table format!\n");
+            }
+            lut[addr]   = data;
+            pos         ++;
+        }
+    }
+
+    // Write AC Huffman table to HW
+    for (i = 0; i < 162; i ++) {
+        WRITE_HREG(HCODEC_VLC_HUFFMAN_DATA ,lut[i]);
+    }
+}   /* write_jpeg_huffman_lut_ac */
+
+int  zigzag(int i)
+{
+    int zigzag_i;
+    
+    switch (i) {
+        case 0   : zigzag_i = 0;    break;
+        case 1   : zigzag_i = 1;    break;
+        case 2   : zigzag_i = 8;    break;
+        case 3   : zigzag_i = 16;   break;
+        case 4   : zigzag_i = 9;    break;
+        case 5   : zigzag_i = 2;    break;
+        case 6   : zigzag_i = 3;    break;
+        case 7   : zigzag_i = 10;   break;
+        case 8   : zigzag_i = 17;   break;
+        case 9   : zigzag_i = 24;   break;
+        case 10  : zigzag_i = 32;   break;
+        case 11  : zigzag_i = 25;   break;
+        case 12  : zigzag_i = 18;   break;
+        case 13  : zigzag_i = 11;   break;
+        case 14  : zigzag_i = 4;    break;
+        case 15  : zigzag_i = 5;    break;
+        case 16  : zigzag_i = 12;   break;
+        case 17  : zigzag_i = 19;   break;
+        case 18  : zigzag_i = 26;   break;
+        case 19  : zigzag_i = 33;   break;
+        case 20  : zigzag_i = 40;   break;
+        case 21  : zigzag_i = 48;   break;
+        case 22  : zigzag_i = 41;   break;
+        case 23  : zigzag_i = 34;   break;
+        case 24  : zigzag_i = 27;   break;
+        case 25  : zigzag_i = 20;   break;
+        case 26  : zigzag_i = 13;   break;
+        case 27  : zigzag_i = 6;    break;
+        case 28  : zigzag_i = 7;    break;
+        case 29  : zigzag_i = 14;   break;
+        case 30  : zigzag_i = 21;   break;
+        case 31  : zigzag_i = 28;   break;
+        case 32  : zigzag_i = 35;   break;
+        case 33  : zigzag_i = 42;   break;
+        case 34  : zigzag_i = 49;   break;
+        case 35  : zigzag_i = 56;   break;
+        case 36  : zigzag_i = 57;   break;
+        case 37  : zigzag_i = 50;   break;
+        case 38  : zigzag_i = 43;   break;
+        case 39  : zigzag_i = 36;   break;
+        case 40  : zigzag_i = 29;   break;
+        case 41  : zigzag_i = 22;   break;
+        case 42  : zigzag_i = 15;   break;
+        case 43  : zigzag_i = 23;   break;
+        case 44  : zigzag_i = 30;   break;
+        case 45  : zigzag_i = 37;   break;
+        case 46  : zigzag_i = 44;   break;
+        case 47  : zigzag_i = 51;   break;
+        case 48  : zigzag_i = 58;   break;
+        case 49  : zigzag_i = 59;   break;
+        case 50  : zigzag_i = 52;   break;
+        case 51  : zigzag_i = 45;   break;
+        case 52  : zigzag_i = 38;   break;
+        case 53  : zigzag_i = 31;   break;
+        case 54  : zigzag_i = 39;   break;
+        case 55  : zigzag_i = 46;   break;
+        case 56  : zigzag_i = 53;   break;
+        case 57  : zigzag_i = 60;   break;
+        case 58  : zigzag_i = 61;   break;
+        case 59  : zigzag_i = 54;   break;
+        case 60  : zigzag_i = 47;   break;
+        case 61  : zigzag_i = 55;   break;
+        case 62  : zigzag_i = 62;   break;
+        default  : zigzag_i = 63;   break;
+    }
+    return zigzag_i;
+}   /* zigzag */
+
+/*
+static DEFINE_SPINLOCK(lock);
+
+static void avc_put_timer_func(unsigned long arg)
+{
+    struct timer_list *timer = (struct timer_list *)arg;
+    timer->expires = jiffies + PUT_INTERVAL;
+
+    add_timer(timer);
+}
+*/        
+static void jpegenc_init_output_buffer()
+{
+	unsigned mem_offset;
+	mem_offset    = READ_HREG(HCODEC_HENC_SCRATCH_1);
+	
+	WRITE_HREG(VLC_VB_MEM_CTL ,((1<<31)|(0x3f<<24)|(0x20<<16)|(2<<0)) );
+	WRITE_HREG(VLC_VB_START_PTR, BitstreamStart+mem_offset);
+	WRITE_HREG(VLC_VB_WR_PTR, BitstreamStart+mem_offset);
+	WRITE_HREG(VLC_VB_SW_RD_PTR, BitstreamStart+mem_offset);	
+	WRITE_HREG(VLC_VB_END_PTR, BitstreamEnd);
+	WRITE_HREG(VLC_VB_CONTROL, 1);
+	WRITE_HREG(VLC_VB_CONTROL, ((0<<14)|(7<<3)|(1<<1)|(0<<0)));
+}
+
+/****************************************/
+static void jpegenc_canvas_init(void)
+{
+    u32 canvas_width, canvas_height;
+    int start_addr = gJpegEncBuff.buf_start;
+	int y_size , uv_size;
+    canvas_width = ((encoder_width+15)>>4)<<4;
+    canvas_height = ((encoder_height+15)>>4)<<4;
+    y_size = canvas_width*canvas_height;
+    uv_size = canvas_width*canvas_height/2 ;
+        
+	gJpegEncBuff.bufspec = (BuffInfo_t*)&jpegenc_buffspec;
+	
+	gJpegEncBuff.bufspec->dec0_y = start_addr;
+	gJpegEncBuff.bufspec->dec0_uv = start_addr + y_size;
+	gJpegEncBuff.bufspec->bitstream= start_addr + y_size + uv_size ;
+
+	
+	/*input dct buffer config */ 
+    dct_buff_start_addr = start_addr;   //(w>>4)*(h>>4)*864
+    dct_buff_end_addr = dct_buff_start_addr + y_size + uv_size -1 ;
+    debug_level(0,"dct_buff_start_addr is %x \n",dct_buff_start_addr);
+
+    canvas_config(ENC_CANVAS_OFFSET,
+        gJpegEncBuff.bufspec->dec0_y,
+        canvas_width, canvas_height,
+        CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+    canvas_config(1 + ENC_CANVAS_OFFSET,
+        gJpegEncBuff.bufspec->dec0_uv,
+        canvas_width , canvas_height/2,
+        CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+    /*here the third plane use the same address as the second plane*/                      
+    canvas_config(2 + ENC_CANVAS_OFFSET,
+        gJpegEncBuff.bufspec->dec0_uv,
+        canvas_width , canvas_height/2,
+        CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+    
+
+	/*output stream buffer config*/
+    BitstreamStart  = gJpegEncBuff.bufspec->bitstream;
+    BitstreamEnd  =  BitstreamStart + 0x200000 -1;
+    debug_level(0,"BitstreamStart is %x \n",BitstreamStart);   
+    
+    BitstreamStartVirtAddr  = ioremap_nocache(BitstreamStart, 0x200000); 
+    debug_level(0,"BitstreamStartVirtAddr is %x \n",BitstreamStartVirtAddr);  
+
+}
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if 1
+static void mfdin_basic_jpeg (unsigned input, unsigned char iformat, unsigned char oformat, unsigned picsize_x, unsigned picsize_y, unsigned char r2y_en)
+{
+    unsigned char dsample_en; // Downsample Enable
+    unsigned char interp_en;  // Interpolation Enable
+    unsigned char y_size;     // 0:16 Pixels for y direction pickup; 1:8 pixels
+    unsigned char r2y_mode;   // RGB2YUV Mode, range(0~3)
+    unsigned char canv_idx0_bppx; // mfdin_reg3_canv[25:24];  // bytes per pixel in x direction for index0, 0:half 1:1 2:2 3:3
+    unsigned char canv_idx1_bppx; // mfdin_reg3_canv[27:26];  // bytes per pixel in x direction for index1-2, 0:half 1:1 2:2 3:3
+    unsigned char canv_idx0_bppy; // mfdin_reg3_canv[29:28];  // bytes per pixel in y direction for index0, 0:half 1:1 2:2 3:3
+    unsigned char canv_idx1_bppy; // mfdin_reg3_canv[31:30];  // bytes per pixel in y direction for index1-2, 0:half 1:1 2:2 3:3
+    unsigned char ifmt444,ifmt422,ifmt420,linear_bytes4p;
+    unsigned linear_bytesperline;
+    bool linear_enable = false;
+
+    ifmt444 = ((iformat==1) || (iformat==5) || (iformat==8) || (iformat==9) || (iformat==12)) ? 1 : 0;
+    ifmt422 = ((iformat==0) || (iformat==10)) ? 1 : 0;
+    ifmt420 = ((iformat==2) || (iformat==3) || (iformat==4) || (iformat==11)) ? 1 : 0;
+    dsample_en = ((ifmt444 && (oformat!=2)) || (ifmt422 && (oformat==0))) ? 1 : 0;
+    interp_en = ((ifmt422 && (oformat==2)) || (ifmt420 && (oformat!=0))) ? 1 : 0;
+    y_size = (oformat!=0) ? 1 : 0;
+    //r2y_mode = (r2y_en == 1)?1:0; // Fixed to 1 (TODO)
+    r2y_mode =1;
+    canv_idx0_bppx = (iformat==1) ? 3 : (iformat==0) ? 2 : 1; 
+    canv_idx1_bppx = (iformat==4) ? 0 : 1; 
+    canv_idx0_bppy = 1; 
+    canv_idx1_bppy = (iformat==5) ? 1 : 0; 
+    if((iformat==8) || (iformat==9) || (iformat==12)){
+        linear_bytes4p = 3;
+    }else if(iformat == 10){
+        linear_bytes4p = 2;
+    }else if(iformat==11){
+        linear_bytes4p = 1;
+    }else{
+        linear_bytes4p = 0;
+    }
+    linear_bytesperline = picsize_x*linear_bytes4p;
+
+    if(iformat<8)
+        linear_enable = false;
+    else
+        linear_enable = true;
+
+
+    WRITE_HREG(HCODEC_MFDIN_REG1_CTRL , (iformat << 0) |
+                                         (oformat << 4) |
+                                         (dsample_en <<6) |
+                                         (y_size <<8) |
+                                         (interp_en <<9) |
+                                         (r2y_en <<12) |
+                                         (r2y_mode <<13) |
+                                         (2 <<29) | // 0:H264_I_PIC_ALL_4x4, 1:H264_P_PIC_Y_16x16_C_8x8, 2:JPEG_ALL_8x8, 3:Reserved
+                                         (0 <<31));  // 0:YC interleaved 1:YC non-interleaved(for JPEG)
+
+
+    if(linear_enable == false){
+        WRITE_HREG(HCODEC_MFDIN_REG3_CANV,
+            (input & 0xffffff)|
+            (canv_idx1_bppy <<30) |
+            (canv_idx0_bppy <<28) |
+            (canv_idx1_bppx <<26) |
+            (canv_idx0_bppx <<24));
+        WRITE_HREG(HCODEC_MFDIN_REG4_LNR0, (0 <<16) |(0 <<0));
+        WRITE_HREG(HCODEC_MFDIN_REG5_LNR1, 0);
+    }else{
+        WRITE_HREG(HCODEC_MFDIN_REG3_CANV,
+            (canv_idx1_bppy <<30) |
+            (canv_idx0_bppy <<28) |
+            (canv_idx1_bppx <<26) |
+            (canv_idx0_bppx <<24));
+        WRITE_HREG(HCODEC_MFDIN_REG4_LNR0, (linear_bytes4p <<16) |(linear_bytesperline <<0));
+        WRITE_HREG(HCODEC_MFDIN_REG5_LNR1, input);
+    }
+
+    WRITE_HREG(HCODEC_MFDIN_REG8_DMBL,(picsize_x << 12) |(picsize_y << 0));
+    WRITE_HREG(HCODEC_MFDIN_REG9_ENDN,(7<<0)| (6<<3)|( 5<<6)|(4<<9) |(3<<12) |(2<<15) |( 1<<18) |(0<<21));
+}
+#else
+void mfdin_basic_jpeg (unsigned iformat, unsigned oformat, unsigned picsize_x, unsigned picsize_y, unsigned r2y_en)
+{    
+	unsigned dsample_en; // Downsample Enable
+    unsigned interp_en;  // Interpolation Enable
+    unsigned y_size;     // 0:16 Pixels for y direction pickup; 1:8 pixels
+    unsigned r2y_mode;   // RGB2YUV Mode, range(0~3)
+    unsigned canv_idx0_bppx; // mfdin_reg3_canv[25:24];  // bytes per pixel in x direction for index0, 0:half 1:1 2:2 3:3
+    unsigned canv_idx1_bppx; // mfdin_reg3_canv[27:26];  // bytes per pixel in x direction for index1-2, 0:half 1:1 2:2 3:3
+    unsigned canv_idx0_bppy; // mfdin_reg3_canv[29:28];  // bytes per pixel in y direction for index0, 0:half 1:1 2:2 3:3
+    unsigned canv_idx1_bppy; // mfdin_reg3_canv[31:30];  // bytes per pixel in y direction for index1-2, 0:half 1:1 2:2 3:3
+
+    unsigned ifmt444,ifmt422,ifmt420;
+    ifmt444 = ((iformat==1) || (iformat==5) || (iformat==8) || (iformat==9) || (iformat==12)) ? 1 : 0;
+    ifmt422 = ((iformat==0) || (iformat==10)) ? 1 : 0;
+    ifmt420 = ((iformat==2) || (iformat==3) || (iformat==4) || (iformat==11)) ? 1 : 0;
+    dsample_en = ((ifmt444 && (oformat!=2)) || (ifmt422 && (oformat==0))) ? 1 : 0;
+    interp_en = ((ifmt422 && (oformat==2)) || (ifmt420 && (oformat!=0))) ? 1 : 0;
+    y_size = (oformat!=0) ? 1 : 0;
+    r2y_mode = 1; // Fixed to 1 (TODO)
+    canv_idx0_bppx = (iformat==1) ? 3 : (iformat==0) ? 2 : 1; 
+    canv_idx1_bppx = (iformat==4) ? 0 : 1; 
+    canv_idx0_bppy = 1; 
+    canv_idx1_bppy = (iformat==5) ? 1 : 0; 
+
+    WRITE_HREG(HCODEC_MFDIN_REG1_CTRL , (iformat << 0) |
+                                         (oformat << 4) |
+                                         (dsample_en <<6) |
+                                         (y_size <<8) |
+                                         (interp_en <<9) |
+                                         (r2y_en <<12) |
+                                         (r2y_mode <<13) |
+                                         (2 <<29) | // 0:H264_I_PIC_ALL_4x4, 1:H264_P_PIC_Y_16x16_C_8x8, 2:JPEG_ALL_8x8, 3:Reserved
+                                         (0 <<31));  // 0:YC interleaved 1:YC non-interleaved(for JPEG)
+    WRITE_HREG(HCODEC_MFDIN_REG3_CANV , (canv_idx1_bppy <<30) |
+                                         (canv_idx0_bppy <<28) |
+                                         (canv_idx1_bppx <<26) |
+                                         (canv_idx0_bppx <<24));
+                                         
+    WRITE_HREG(HCODEC_MFDIN_REG8_DMBL,(picsize_x << 12) |(picsize_y << 0));
+    WRITE_HREG(HCODEC_MFDIN_REG9_ENDN,(7<<0)| (6<<3)|( 5<<6)|(4<<9) |(3<<12) |(2<<15) |( 1<<18) |(0<<21));                                         
+}
+
+#endif
+
+static int  set_jpeg_input_format (jpegenc_mem_type type, jpegenc_frame_fmt input_fmt,jpegenc_frame_fmt output_fmt , unsigned input, unsigned offset, unsigned size, unsigned char need_flush)
+{
+    int ret = 0;
+    unsigned char iformat = MAX_FRAME_FMT, oformat = MAX_FRAME_FMT, r2y_en = 0;
+    unsigned picsize_x, picsize_y;
+    debug_level(0,"************begin set input format**************\n");
+	debug_level(0,"type is %d\n",type);
+	debug_level(0,"fmt is %d\n",fmt);
+	debug_level(0,"input is %d\n",input);
+	debug_level(0,"offset is %d\n",offset);
+	debug_level(0,"size is %d\n",size);
+	debug_level(0,"need_flush is %d\n",need_flush);
+	debug_level(0,"************end set input format**************\n");
+
+    if((input_fmt == FMT_RGB565)||(input_fmt>=MAX_FRAME_FMT))
+        return -1;
+    input_format = input_fmt;
+    output_format = output_fmt;
+    picsize_x = ((encoder_width+15)>>4)<<4;
+    picsize_y = ((encoder_height+15)>>4)<<4;
+    if(output_fmt == FMT_YUV422_SINGLE){
+    	oformat = 1;
+	}else{
+		oformat = 0;	
+	}
+    if((type == LOCAL_BUFF)||(type == PHYSICAL_BUFF)){
+        if(type == LOCAL_BUFF){
+            if(need_flush)
+                dma_flush(dct_buff_start_addr + offset, size);
+            input = dct_buff_start_addr + offset;
+        }
+        if(input_fmt <= FMT_YUV444_PLANE)
+            r2y_en = 0;
+        else
+            r2y_en = 1;
+
+        if(input_fmt == FMT_YUV422_SINGLE){
+            iformat = 10;
+        }else if(input_fmt == FMT_YUV444_SINGLE){
+            iformat = 1;
+            canvas_config(ENC_CANVAS_OFFSET+6,
+                input, 
+                picsize_x*3, picsize_y, 
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+           input = ENC_CANVAS_OFFSET+6;
+        }else if((input_fmt == FMT_NV21)||(input_fmt == FMT_NV12)){
+            iformat = (input_fmt == FMT_NV21)?2:3;
+            canvas_config(ENC_CANVAS_OFFSET+6,
+                input, 
+                picsize_x, picsize_y, 
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(ENC_CANVAS_OFFSET+7,
+                input + picsize_x*picsize_y,
+                picsize_x , picsize_y/2,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            input = ((ENC_CANVAS_OFFSET+7)<<8)|(ENC_CANVAS_OFFSET+6);
+        }else if(input_fmt == FMT_YUV420){
+            iformat = 4;
+            canvas_config(ENC_CANVAS_OFFSET+6,
+                input, 
+                picsize_x, picsize_y, 
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(ENC_CANVAS_OFFSET+7,
+                input + picsize_x*picsize_y,
+                picsize_x/2, picsize_y/2,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(ENC_CANVAS_OFFSET+8,
+                input + picsize_x*picsize_y*5/4,
+                picsize_x/2 , picsize_y/2,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            input = ((ENC_CANVAS_OFFSET+8)<<16)|((ENC_CANVAS_OFFSET+7)<<8)|(ENC_CANVAS_OFFSET+6);
+        }else if(input_fmt == FMT_YUV444_PLANE){
+            iformat = 5;
+            canvas_config(ENC_CANVAS_OFFSET+6,
+                input, 
+                picsize_x, picsize_y, 
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(ENC_CANVAS_OFFSET+7,
+                input + picsize_x*picsize_y,
+                picsize_x, picsize_y,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(ENC_CANVAS_OFFSET+8,
+                input + picsize_x*picsize_y*2,
+                picsize_x, picsize_y,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            input = ((ENC_CANVAS_OFFSET+8)<<16)|((ENC_CANVAS_OFFSET+7)<<8)|(ENC_CANVAS_OFFSET+6);
+        }else if(input_fmt == FMT_RGB888){
+            iformat = 8;
+        }else if(input_fmt == FMT_RGB565){
+            iformat = 9;
+        }else if(input_fmt == FMT_RGBA8888){
+            iformat = 12;
+        }
+        ret = 0;
+    }else if(type == CANVAS_BUFF){
+        r2y_en = 0;
+        if(input_fmt == FMT_YUV422_SINGLE){
+            iformat = 0;
+            input = input&0xff;
+        }else if(input_fmt == FMT_YUV444_SINGLE){
+            iformat = 1;
+            input = input&0xff;
+        }else if((input_fmt == FMT_NV21)||(input_fmt == FMT_NV12)){
+            iformat = (input_fmt == FMT_NV21)?2:3;
+            input = input&0xffff;
+        }else if(input_fmt == FMT_YUV420){
+            iformat = 4;
+            input = input&0xfffff;
+        }else if(input_fmt == FMT_YUV444_PLANE){
+            iformat = 5;
+            input = input&0xfffff;
+        }else{
+            ret = -1;
+        }
+    }
+    if(ret == 0)
+        mfdin_basic_jpeg(input,iformat,oformat,picsize_x,picsize_y,r2y_en);
+    return ret;
+}
+#endif
+
+/*
+static void init_scaler(void)
+{
+}
+
+static void avc_local_init(void)
+{
+
+}
+*/
+
+static int encoder_status;
+static irqreturn_t jpegenc_isr(int irq, void *dev_id)
+{
+	int temp_canvas;
+	WRITE_HREG(HCODEC_ASSIST_MBOX2_CLR_REG, 1);
+	encoder_status  = READ_HREG(ENCODER_STATUS);
+	if(encoder_status == ENCODER_DONE){
+		debug_level(0,"encoder  is finished %d\n",encoder_status);
+	}	
+	return IRQ_HANDLED;
+}
+
+void jpegenc_reset(void)
+{
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    WRITE_VREG(DOS_SW_RESET1, (1<<2)|(1<<6)|(1<<7)|(1<<8)|(1<<16)|(1<<17));
+    WRITE_VREG(DOS_SW_RESET1, 0);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+
+}
+
+void jpegenc_start(void)
+{
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    WRITE_VREG(DOS_SW_RESET1, (1<<12)|(1<<11));
+    WRITE_VREG(DOS_SW_RESET1, 0);
+
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+
+    WRITE_HREG(HCODEC_MPSR, 0x0001);
+}
+
+void _jpegenc_stop(void)
+{
+    ulong timeout = jiffies + HZ;
+
+    WRITE_HREG(HCODEC_MPSR, 0);
+    WRITE_HREG(HCODEC_CPSR, 0);
+    while (READ_HREG(HCODEC_IMEM_DMA_CTRL) & 0x8000) {
+        if (time_after(jiffies, timeout)) {
+            break;
+        }
+    }
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+
+    WRITE_VREG(DOS_SW_RESET1, (1<<12)|(1<<11)|(1<<2)|(1<<6)|(1<<7)|(1<<8)|(1<<16)|(1<<17));
+    //WRITE_VREG(DOS_SW_RESET1, (1<<12)|(1<<11));
+    WRITE_VREG(DOS_SW_RESET1, 0);
+
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+    READ_VREG(DOS_SW_RESET1);
+}
+
+static void __iomem *mc_addr=NULL;
+static unsigned mc_addr_map;
+#define MC_SIZE (4096 * 4)
+
+s32 jpegenc_loadmc(const u32 *p)
+{
+    ulong timeout;
+    s32 ret = 0;
+    mc_addr = kmalloc(MC_SIZE, GFP_KERNEL);
+
+    if (!mc_addr) {
+        return -ENOMEM;
+    }
+
+    memcpy(mc_addr, p, MC_SIZE);
+
+    mc_addr_map = dma_map_single(NULL, mc_addr, MC_SIZE, DMA_TO_DEVICE);
+
+    WRITE_HREG(HCODEC_MPSR, 0);
+    WRITE_HREG(HCODEC_CPSR, 0);
+
+
+    /* Read CBUS register for timing */
+    timeout = READ_HREG(HCODEC_MPSR);
+    timeout = READ_HREG(HCODEC_MPSR);
+
+    timeout = jiffies + HZ;
+
+    WRITE_HREG(HCODEC_IMEM_DMA_ADR, mc_addr_map);
+    WRITE_HREG(HCODEC_IMEM_DMA_COUNT, 0x1000);
+    WRITE_HREG(HCODEC_IMEM_DMA_CTRL, (0x8000 |   (7 << 16)));
+
+    while (READ_HREG(HCODEC_IMEM_DMA_CTRL) & 0x8000) {
+        if (time_before(jiffies, timeout)) {
+            schedule();
+        } else {
+            printk("vdec load mc error\n");
+            ret = -EBUSY;
+            break;
+        }
+    }
+
+    dma_unmap_single(NULL, mc_addr_map, MC_SIZE, DMA_TO_DEVICE);
+
+
+    kfree(mc_addr);
+    mc_addr = NULL;
+
+    return ret;
+}
+
+
+
+#define  DMC_SEC_PORT8_RANGE0  0x840
+#define  DMC_SEC_CTRL  0x829
+static void enable_hcoder_ddr_access(void)
+{
+	WRITE_SEC_REG(DMC_SEC_PORT8_RANGE0 , 0xffff);
+	WRITE_SEC_REG(DMC_SEC_CTRL , 0x80000000);
+}
+
+static s32 jpegenc_poweron(void)
+{
+	u32 data32 = 0;
+	data32 = 0;
+	enable_hcoder_ddr_access();
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	data32 = READ_AOREG(AO_RTI_PWR_CNTL_REG0);
+	data32 = data32 & (~(0x18));
+	WRITE_AOREG(AO_RTI_PWR_CNTL_REG0, data32);
+	udelay(10);
+	// Powerup HCODEC
+	data32 = READ_AOREG(AO_RTI_GEN_PWR_SLEEP0); // [1:0] HCODEC
+	data32 = data32 & (~0x3); 
+	WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, data32);
+	udelay(10);
+#endif
+	// Enable Dos internal clock gating
+	jpegenc_clock_enable();
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	// Remove HCODEC ISO
+	data32 = READ_AOREG(AO_RTI_GEN_PWR_ISO0); 
+	data32 = data32 & (~(0x30));
+	WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, data32);
+	udelay(10);
+	//Powerup HCODEC memories
+	WRITE_VREG(DOS_MEM_PD_HCODEC, 0x0);
+	// Disable auto-clock gate
+	data32 = READ_VREG(DOS_GEN_CTRL0);
+	data32 = data32 | 0x1;
+	WRITE_VREG(DOS_GEN_CTRL0, data32);
+	data32 = READ_VREG(DOS_GEN_CTRL0);
+	data32 = data32 & 0xFFFFFFFE;
+	WRITE_VREG(DOS_GEN_CTRL0, data32);
+#endif
+	return 0;
+}
+
+static s32 jpegenc_poweroff(void)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	// enable HCODEC isolation
+	WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, READ_AOREG(AO_RTI_GEN_PWR_ISO0) | 0x30);
+	// power off HCODEC memories
+	WRITE_VREG(DOS_MEM_PD_HCODEC, 0xffffffffUL);
+	// disable HCODEC clock
+	jpegenc_clock_disable();
+	// HCODEC power off
+	WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, READ_AOREG(AO_RTI_GEN_PWR_SLEEP0) | 0x3);
+#else
+	jpegenc_clock_disable();
+#endif
+	return 0;
+}
+
+static s32 jpegenc_init(void)
+{
+    int r;   
+    jpegenc_poweron();
+    jpegenc_canvas_init();
+    WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
+    debug_level(1,"start to load microcode\n");
+    if (jpegenc_loadmc(jpeg_encoder_mc) < 0) {
+        //amvdec_disable();
+        return -EBUSY;
+    }	
+    debug_level(1,"succeed to load microcode\n");
+
+    r = request_irq(INT_JPEG_ENCODER, jpegenc_isr, IRQF_SHARED, "jpegenc-irq", (void *)jpeg_enc_id);//INT_MAILBOX_1A
+    encode_inited = 1;
+    return 0;
+}
+
+void jpegenc_start_cmd(int cmd, unsigned* input_info)
+{
+    set_jpeg_input_format((jpegenc_mem_type)input_info[0], (jpegenc_frame_fmt)input_info[1], (jpegenc_frame_fmt)input_info[2], input_info[3], input_info[4],input_info[5],(unsigned char)input_info[6]);
+	
+	//prepare_jpeg_header();
+	init_jpeg_encoder();
+	jpegenc_init_output_buffer();
+
+	
+	        /* clear mailbox interrupt */
+    WRITE_HREG(HCODEC_ASSIST_MBOX2_CLR_REG, 1);
+
+    /* enable mailbox interrupt */
+    WRITE_HREG(HCODEC_ASSIST_MBOX2_MASK, 1);
+	encoder_status = cmd;
+	WRITE_HREG(ENCODER_STATUS , cmd);
+	jpegenc_start();
+	debug_level(0,"jpegenc_start\n");
+}
+
+void jpegenc_stop(void)
+{
+	int i;
+#if 0	
+		/*MFDIN*/
+	for( i = 0x1010 ;i < 0x101b ; i++){
+		debug_level(0,"MFDIN register 0x%x :  0x%x \n",i, READ_HREG(i)); 	
+	}	
+	/*VLC*/
+	for( i = 0x1d00 ;i < 0x1d5d ; i++){
+		debug_level(0,"VLC register 0x%x :  0x%x \n",i, READ_HREG(i)); 	
+	}		
+	/*QDCT*/
+	for( i = 0x1f00 ;i < 0x1f5f ; i++){
+		debug_level(0,"QDCT register 0x%x :  0x%x \n",i, READ_HREG(i)); 	
+	}
+
+	for( i = 0x1001 ;i < 0x1f5f ; i++){
+		debug_level(0,"register 0x%x :  0x%x \n",i, READ_HREG(i)); 	
+	}	
+#endif 		
+	//WRITE_HREG(HCODEC_MPSR, 0);	
+	_jpegenc_stop();
+	jpegenc_poweroff();
+	debug_level(1,"jpegenc_stop\n");
+}
+static int jpegenc_open(struct inode *inode, struct file *file)
+{
+    int r = 0;
+    debug_level(1,"avc open\n");
+    if(encode_opened>0){
+        debug_level(2, "jpegenc open busy.\n");
+        return -EBUSY;
+    }
+    encode_opened++;
+#if 0
+    if (jpegenc_poweron() < 0) {
+        debug_level(2, "jpegenc init failed.\n");
+        encode_opened--;
+        return -ENODEV;
+    }
+#endif
+	BitstreamStartVirtAddr = NULL;
+    return r;
+}
+
+static int jpegenc_release(struct inode *inode, struct file *file)
+{
+    if(encode_inited){
+        free_irq(INT_JPEG_ENCODER, (void *)jpeg_enc_id);
+        //amvdec_disable();
+        jpegenc_stop();
+        encode_inited = 0;
+    }
+    if(encode_opened>0)
+        encode_opened--;
+    debug_level(1,"avc release\n");
+    if(BitstreamStartVirtAddr){
+		iounmap(BitstreamStartVirtAddr);
+		BitstreamStartVirtAddr = NULL;
+    }
+    return 0;
+}
+static void dma_flush(unsigned buf_start , unsigned buf_size )
+{
+    //dma_sync_single_for_cpu(jpegenc_dev,buf_start, buf_size, DMA_TO_DEVICE);
+	dma_sync_single_for_device(jpegenc_dev,buf_start ,buf_size, DMA_TO_DEVICE);
+}
+
+static void cache_flush(unsigned buf_start , unsigned buf_size )
+{
+	dma_sync_single_for_cpu(jpegenc_dev , buf_start, buf_size, DMA_FROM_DEVICE);
+	//dma_sync_single_for_device(jpegenc_dev ,buf_start , buf_size, DMA_FROM_DEVICE);
+}
+
+static long jpegenc_ioctl(struct file *file,
+                           unsigned int cmd, ulong arg)
+{
+    int r = 0;
+    int amrisc_cmd = 0;
+    unsigned* offset;
+    unsigned* addr_info;
+    unsigned buf_start;
+    switch (cmd) {
+    	debug_level(0,"jpegenc cmd is %d , \n" , cmd);
+	case JPEGENC_IOC_GET_ADDR:
+	    *((unsigned*)arg)  = 1;
+		break;
+  
+	case JPEGENC_IOC_NEW_CMD:
+		amrisc_cmd = *((unsigned*)arg) ;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+		addr_info = (unsigned*)arg;
+		jpegenc_start_cmd(amrisc_cmd, &addr_info[1]);
+#else
+		jpegenc_start_cmd(amrisc_cmd, NULL);
+#endif
+		break;
+	case JPEGENC_IOC_GET_STAGE:
+		*((unsigned*)arg)  = encoder_status;
+		break; 
+	case JPEGENC_IOC_GET_OUTPUT_SIZE:	
+		*((unsigned*)arg) = READ_HREG(VLC_TOTAL_BYTES);
+		break;
+	case JPEGENC_IOC_SET_ENCODER_WIDTH:
+
+		encoder_width = *((unsigned*)arg) ;
+		break;
+	case JPEGENC_IOC_SET_ENCODER_HEIGHT:
+
+		encoder_height = *((unsigned*)arg) ;
+		break;	
+	case JPEGENC_IOC_CONFIG_INIT:
+		jpegenc_init();
+		break;		
+	case JPEGENC_IOC_FLUSH_CACHE:
+		addr_info  = (unsigned*)arg ;
+		switch(addr_info[0]){
+			case 0:
+			buf_start = dct_buff_start_addr;
+			break;
+			case 1:
+			buf_start = BitstreamStart ;
+			break;
+			default:
+			buf_start = dct_buff_start_addr;
+			break;
+		}
+		dma_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
+		break;
+	case JPEGENC_IOC_FLUSH_DMA:
+		addr_info  = (unsigned*)arg ;
+		switch(addr_info[0]){
+			case 0:
+			buf_start = dct_buff_start_addr;
+			break;
+			case 1:
+			buf_start = BitstreamStart ;
+			break;
+			default:
+			buf_start = dct_buff_start_addr;
+			break;
+		}	    
+		cache_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
+		break;
+	case JPEGENC_IOC_GET_BUFFINFO:
+		addr_info  = (unsigned*)arg;
+		break;
+	case JPEGENC_IOC_GET_DEVINFO:
+		strncpy((char *)arg,JPEGENC_DEV_VERSION,strlen(JPEGENC_DEV_VERSION));
+		break;
+	default:
+		r= -1;
+		break;
+    }
+    return r;
+}
+
+
+
+static int jpegenc_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+    unsigned vma_size = vma->vm_end - vma->vm_start;
+
+    if (vma_size == 0) {
+        debug_level(1,"vma_size is 0 \n");
+        return -EAGAIN;
+    }
+    off += gJpegEncBuff.buf_start;
+    debug_level(0,"vma_size is %d , off is %ld \n" , vma_size ,off);
+    vma->vm_flags |= VM_RESERVED | VM_IO;
+    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+    if (remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+                        vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+        debug_level(1,"set_cached: failed remap_pfn_range\n");
+        return -EAGAIN;
+    }
+    debug_level(1,"jpegenc_mmap finished\n");
+    return 0;
+
+}
+
+const static struct file_operations jpegenc_fops = {
+    .owner    = THIS_MODULE,
+    .open     = jpegenc_open,
+    .mmap     = jpegenc_mmap,
+    .release  = jpegenc_release,
+    .unlocked_ioctl    = jpegenc_ioctl,
+};
+
+int  init_jpegenc_device(void)
+{
+    int  r =0;
+    r =register_chrdev(0,DEVICE_NAME,&jpegenc_fops);
+    if(r<=0) 
+    {
+        debug_level(2,"register jpegenc device error\r\n");
+        return  r  ;
+    }
+    jpegenc_device_major= r ;
+    
+    jpegenc_class = class_create(THIS_MODULE, DEVICE_NAME);
+
+    jpegenc_dev = device_create(jpegenc_class, NULL,
+                                  MKDEV(jpegenc_device_major, 0), NULL,
+                                  DEVICE_NAME);
+    return r;
+}
+int uninit_jpegenc_device(void)
+{
+    device_destroy(jpegenc_class, MKDEV(jpegenc_device_major, 0));
+
+    class_destroy(jpegenc_class);
+
+    unregister_chrdev(jpegenc_device_major, DEVICE_NAME);	
+    return 0;
+}
+
+static int jpegenc_probe(struct platform_device *pdev)
+{
+    struct resource *mem;
+
+    debug_level(1, "jpegenc probe start.\n");
+
+    if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
+        debug_level(2, "jpegenc memory resource undefined.\n");
+        return -EFAULT;
+    }
+
+    gJpegEncBuff.buf_start = mem->start;
+    gJpegEncBuff.buf_size = mem->end - mem->start + 1;
+
+    debug_level(1,"jpegenc  memory config sucess, buff size is 0x%x, level is %s\n",gJpegEncBuff.buf_size,(gJpegEncBuff.cur_buf_lev == 0)?"480P":(gJpegEncBuff.cur_buf_lev == 1)?"720P":"1080P");
+    init_jpegenc_device();
+    debug_level(1, "jpegenc probe end.\n");
+    return 0;
+}
+
+static int jpegenc_remove(struct platform_device *pdev)
+{
+    uninit_jpegenc_device();
+    debug_level(1, "jpegenc remove.\n");
+    return 0;
+}
+
+/****************************************/
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_jpegenc_dt_match[]={
+	{	.compatible = "amlogic,jpegenc",
+	},
+	{},
+};
+#else
+#define amlogic_jpegenc_dt_match NULL
+#endif
+
+static struct platform_driver jpegenc_driver = {
+    .probe      = jpegenc_probe,
+    .remove     = jpegenc_remove,
+    .driver     = {
+        .name   = DRIVER_NAME,
+        .of_match_table = amlogic_jpegenc_dt_match,
+    }
+};
+static struct codec_profile_t jpegenc_profile = {
+	.name = "jpegenc",
+	.profile = ""
+};
+static int __init jpegenc_driver_init_module(void)
+{
+    debug_level(1, "jpegenc module init\n");
+
+    if (platform_driver_register(&jpegenc_driver)) {
+        debug_level(2, "failed to register jpegenc driver\n");
+        return -ENODEV;
+    }
+    vcodec_profile_register(&jpegenc_profile);
+    return 0;
+}
+
+static void __exit jpegenc_driver_remove_module(void)
+{
+    debug_level(1, "jpegenc module remove.\n");
+	
+    platform_driver_unregister(&jpegenc_driver);
+}
+
+/****************************************/
+
+module_param(stat, uint, 0664);
+MODULE_PARM_DESC(stat, "\n jpegenc stat \n");
+
+module_init(jpegenc_driver_init_module);
+module_exit(jpegenc_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC JPEG Encoder Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("simon.zheng <simon.zheng@amlogic.com>");
diff --git a/drivers/amlogic/amports/jpegenc.h b/drivers/amlogic/amports/jpegenc.h
new file mode 100644
index 000000000000..7be176d64854
--- /dev/null
+++ b/drivers/amlogic/amports/jpegenc.h
@@ -0,0 +1,693 @@
+#ifndef __JPEG_ENC_H_
+#define __JPEG_ENC_H_
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#define JPEGENC_DEV_VERSION "AML-M8"
+#define INT_JPEG_ENCODER INT_DOS_MAILBOX_2
+#else
+#define JPEGENC_DEV_VERSION "AML-MT"
+#define INT_JPEG_ENCODER INT_MAILBOX_1A
+#endif
+
+#define VDEC_166M()  WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (5 << 9) | (1 << 8) | (5))
+#define VDEC_200M()  WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (5 << 9) | (1 << 8) | (4))
+#define VDEC_250M()  WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (5 << 9) | (1 << 8) | (3))
+#define VDEC_333M()  WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (5 << 9) | (1 << 8) | (2))
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#define HDEC_255M()   WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (2 << 25) | (1 << 16) |(1 << 24) | (0xffff&READ_CBUS_REG(HHI_VDEC_CLK_CNTL)))
+#define HDEC_319M()   WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (0 << 25) | (1 << 16) |(1 << 24) | (0xffff&READ_CBUS_REG(HHI_VDEC_CLK_CNTL)))
+#define jpegenc_clock_enable() \
+    HDEC_319M(); \
+    WRITE_VREG_BITS(DOS_GCLK_EN0, 0x7fff, 12, 15)
+
+#define jpegenc_clock_disable() \
+    WRITE_VREG_BITS(DOS_GCLK_EN0, 0, 12, 15); \
+    WRITE_MPEG_REG_BITS(HHI_VDEC_CLK_CNTL,  24, 0, 1);
+#else
+#define HDEC_250M()   WRITE_MPEG_REG(HHI_VDEC_CLK_CNTL, (0 << 25) | (3 << 16) |(1 << 24) | (0xffff&READ_CBUS_REG(HHI_VDEC_CLK_CNTL)))
+#define jpegenc_clock_enable() \
+    HDEC_250M(); \
+    WRITE_VREG(DOS_GCLK_EN0, 0xffffffff)
+
+#define jpegenc_clock_disable() \
+    WRITE_MPEG_REG_BITS(HHI_VDEC_CLK_CNTL,  24, 0, 1);
+#endif
+
+#define JPEGENC_IOC_MAGIC  'E'
+
+#define JPEGENC_IOC_GET_DEVINFO 				_IOW(JPEGENC_IOC_MAGIC, 0xf0, unsigned int)
+
+#define JPEGENC_IOC_GET_ADDR			 		_IOW(JPEGENC_IOC_MAGIC, 0x00, unsigned int)
+#define JPEGENC_IOC_INPUT_UPDATE				_IOW(JPEGENC_IOC_MAGIC, 0x01, unsigned int)
+#define JPEGENC_IOC_GET_STATUS					_IOW(JPEGENC_IOC_MAGIC, 0x02, unsigned int)
+#define JPEGENC_IOC_NEW_CMD						_IOW(JPEGENC_IOC_MAGIC, 0x03, unsigned int)
+#define JPEGENC_IOC_GET_STAGE					_IOW(JPEGENC_IOC_MAGIC, 0x04, unsigned int)
+#define JPEGENC_IOC_GET_OUTPUT_SIZE				_IOW(JPEGENC_IOC_MAGIC, 0x05, unsigned int)
+#define JPEGENC_IOC_SET_QUANT 					_IOW(JPEGENC_IOC_MAGIC, 0x06, unsigned int)
+#define JPEGENC_IOC_SET_ENCODER_WIDTH 			_IOW(JPEGENC_IOC_MAGIC, 0x07, unsigned int)
+#define JPEGENC_IOC_SET_ENCODER_HEIGHT 			_IOW(JPEGENC_IOC_MAGIC, 0x08, unsigned int)
+#define JPEGENC_IOC_CONFIG_INIT 				_IOW(JPEGENC_IOC_MAGIC, 0x09, unsigned int)
+#define JPEGENC_IOC_FLUSH_CACHE 				_IOW(JPEGENC_IOC_MAGIC, 0x0a, unsigned int)
+#define JPEGENC_IOC_FLUSH_DMA 					_IOW(JPEGENC_IOC_MAGIC, 0x0b, unsigned int)
+#define JPEGENC_IOC_GET_BUFFINFO 				_IOW(JPEGENC_IOC_MAGIC, 0x0c, unsigned int)
+
+typedef enum{
+    LOCAL_BUFF = 0,
+    CANVAS_BUFF,
+    PHYSICAL_BUFF,
+    MAX_BUFF_TYPE 
+}jpegenc_mem_type;
+
+typedef enum{
+    FMT_YUV422_SINGLE = 0,
+    FMT_YUV444_SINGLE,
+    FMT_NV21,
+    FMT_NV12,
+    FMT_YUV420,    
+    FMT_YUV444_PLANE,
+    FMT_RGB888,
+    FMT_RGB565,
+    FMT_RGBA8888,
+    MAX_FRAME_FMT 
+}jpegenc_frame_fmt;
+
+///////////////////////////////////////////////////////////////////////////
+// Memory Address 
+///////////////////////////////////////////////////////////////////////////
+
+// moved to jpeg_enc.s
+
+
+
+/********************************************
+ *  Interrupt
+********************************************/
+#define VB_FULL_REQ            0x01
+#define VLC_REQ                0x02
+#define MAIN_REQ               0x04
+#define QDCT_REQ               0x08
+
+/********************************************
+ *  Regsiter
+********************************************/
+#define COMMON_REG_0              r0
+#define COMMON_REG_1              r1
+
+#define VB_FULL_REG_0             r2
+
+#define MAIN_REG_0                r8
+#define MAIN_REG_1                r9
+#define MAIN_REG_2                r10
+#define MAIN_REG_3                r11
+#define MAIN_REG_4                r12
+#define MAIN_REG_5                r13
+#define MAIN_REG_6                r14
+#define MAIN_REG_7                r15
+
+#define VLC_REG_0                 r8
+#define VLC_REG_1                 r9
+#define VLC_REG_2                 r10
+#define VLC_REG_3                 r11
+#define VLC_REG_4                 r12
+#define VLC_REG_5                 r13
+#define VLC_REG_6                 r14
+#define VLC_REG_7                 r15
+#define VLC_REG_8                 r16
+#define VLC_REG_9                 r17
+#define VLC_REG_10                r18
+#define VLC_REG_11                r19
+#define VLC_REG_12                r20
+
+#define QDCT_REG_0                r8
+#define QDCT_REG_1                r9
+#define QDCT_REG_2                r10
+#define QDCT_REG_3                r11
+#define QDCT_REG_4                r12
+#define QDCT_REG_5                r13
+#define QDCT_REG_6                r14
+#define QDCT_REG_7                r15
+
+/********************************************
+ *  AV Scratch Register Re-Define
+********************************************/
+#define ENCODER_STATUS              HENC_SCRATCH_0
+#define BITSTREAM_OFFSET            HENC_SCRATCH_1
+
+//---------------------------------------------------
+// ENCODER_STATUS define
+//---------------------------------------------------
+#define ENCODER_IDLE                0
+#define ENCODER_START               1
+//#define ENCODER_SOS_HEADER          2
+#define ENCODER_MCU                 3
+#define ENCODER_DONE                4
+
+/********************************************
+ *  Local Memory
+********************************************/
+#if 0 //only defined for micro code
+#define INTR_MSK_SAVE               0x000
+#define pic_width                   0x001
+#define pic_height                  0x002
+#define pic_format                  0x003
+#define lastcoeff_sel               0x004
+#define mcu_x                       0x005
+#define mcu_y                       0x006
+#define blk_in_mcu                  0x007
+#define num_mcu_x                   0x008
+#define num_mcu_y                   0x009
+#define num_blk_in_mcu              0x00A
+#endif
+/********************************************
+* defines for HENC command 
+********************************************/
+#define HENC_SEND_RSVD_COMMAND1             1
+#define HENC_SEND_RSVD_COMMAND2             2
+#define HENC_SEND_RSVD_COMMAND3             3
+#define HENC_SEND_RSVD_COMMAND4             4
+#define HENC_SEND_RSVD_COMMAND5             5
+#define HENC_SEND_COEFF_COMMAND             6
+#define HENC_SEND_RSVD_COMMAND7             7
+#define HENC_SEND_RSVD_COMMAND8             8
+#define HENC_SEND_RSVD_COMMAND9             9
+#define HENC_SEND_RSVD_COMMAND10            15
+
+
+
+// Define Quantization table:   Max two tables
+#define QUANT_SEL_COMP0     0
+#define QUANT_SEL_COMP1     1
+#define QUANT_SEL_COMP2     1
+
+// Define Huffman table selection: Max two tables per DC/AC
+#define DC_HUFF_SEL_COMP0   0
+#define DC_HUFF_SEL_COMP1   1
+#define DC_HUFF_SEL_COMP2   1
+#define AC_HUFF_SEL_COMP0   0
+#define AC_HUFF_SEL_COMP1   1
+#define AC_HUFF_SEL_COMP2   1
+
+
+// When create the test for the 1st time, define header_bytes 0, then the C code will write out a new header file;
+// when the test is stable, define header_bytes to be the length of the header file already created by C code.
+#define JPEG_HEADER_BYTES   0
+//`define JPEG_HEADER_BYTES   592
+
+// Simulation parameters for improving test coverage
+
+#define JDCT_INTR_SEL       0   // DCT interrupt select:0=Disable intr;
+                                //                      1=Intr at end of each 8x8 block of DCT input;
+                                //                      2=Intr at end of each MCU of DCT input;
+                                //                      3=Intr at end of a scan of DCT input;
+                                //                      4=Intr at end of each 8x8 block of DCT output;
+                                //                      5=Intr at end of each MCU of DCT output;
+                                //                      6=Intr at end of a scan of DCT output;
+#define JDCT_LASTCOEFF_SEL  1   // 0=Mark last coeff at the end of an 8x8 block,
+                                // 1=Mark last coeff at the end of an MCU
+                                // 2=Mark last coeff at the end of a scan
+#define MAX_COMP_PER_SCAN   3
+
+
+
+// Perform convertion from Q to 1/Q
+unsigned long reciprocal (unsigned int q)
+{
+    unsigned long q_recip;
+    
+    switch (q) {
+        case   0    : q_recip   = 0;        break;  // Invalid 1/0
+        case   1    : q_recip   = 65535;    break;  // 65535 * (1/1)
+        case   2    : q_recip   = 32768;    break;  // 65536 * (1/2)
+        case   3    : q_recip   = 21845;    break;  // 65536 * (1/3)
+        case   4    : q_recip   = 16384;    break;  // 65536 * (1/4)
+        case   5    : q_recip   = 13107;    break;  // 65536 * (1/5)
+        case   6    : q_recip   = 10923;    break;  // 65536 * (1/6)
+        case   7    : q_recip   = 9362;     break;  // 65536 * (1/7)
+        case   8    : q_recip   = 8192;     break;  // 65536 * (1/8)
+        case   9    : q_recip   = 7282;     break;  // 65536 * (1/9)
+        case  10    : q_recip   = 6554;     break;  // 65536 * (1/10)
+        case  11    : q_recip   = 5958;     break;  // 65536 * (1/11)
+        case  12    : q_recip   = 5461;     break;  // 65536 * (1/12)
+        case  13    : q_recip   = 5041;     break;  // 65536 * (1/13)
+        case  14    : q_recip   = 4681;     break;  // 65536 * (1/14)
+        case  15    : q_recip   = 4369;     break;  // 65536 * (1/15)
+        case  16    : q_recip   = 4096;     break;  // 65536 * (1/16)
+        case  17    : q_recip   = 3855;     break;  // 65536 * (1/17)
+        case  18    : q_recip   = 3641;     break;  // 65536 * (1/18)
+        case  19    : q_recip   = 3449;     break;  // 65536 * (1/19)
+        case  20    : q_recip   = 3277;     break;  // 65536 * (1/20)
+        case  21    : q_recip   = 3121;     break;  // 65536 * (1/21)
+        case  22    : q_recip   = 2979;     break;  // 65536 * (1/22)
+        case  23    : q_recip   = 2849;     break;  // 65536 * (1/23)
+        case  24    : q_recip   = 2731;     break;  // 65536 * (1/24)
+        case  25    : q_recip   = 2621;     break;  // 65536 * (1/25)
+        case  26    : q_recip   = 2521;     break;  // 65536 * (1/26)
+        case  27    : q_recip   = 2427;     break;  // 65536 * (1/27)
+        case  28    : q_recip   = 2341;     break;  // 65536 * (1/28)
+        case  29    : q_recip   = 2260;     break;  // 65536 * (1/29)
+        case  30    : q_recip   = 2185;     break;  // 65536 * (1/30)
+        case  31    : q_recip   = 2114;     break;  // 65536 * (1/31)
+        case  32    : q_recip   = 2048;     break;  // 65536 * (1/32)
+        case  33    : q_recip   = 1986;     break;  // 65536 * (1/33)
+        case  34    : q_recip   = 1928;     break;  // 65536 * (1/34)
+        case  35    : q_recip   = 1872;     break;  // 65536 * (1/35)
+        case  36    : q_recip   = 1820;     break;  // 65536 * (1/36)
+        case  37    : q_recip   = 1771;     break;  // 65536 * (1/37)
+        case  38    : q_recip   = 1725;     break;  // 65536 * (1/38)
+        case  39    : q_recip   = 1680;     break;  // 65536 * (1/39)
+        case  40    : q_recip   = 1638;     break;  // 65536 * (1/40)
+        case  41    : q_recip   = 1598;     break;  // 65536 * (1/41)
+        case  42    : q_recip   = 1560;     break;  // 65536 * (1/42)
+        case  43    : q_recip   = 1524;     break;  // 65536 * (1/43)
+        case  44    : q_recip   = 1489;     break;  // 65536 * (1/44)
+        case  45    : q_recip   = 1456;     break;  // 65536 * (1/45)
+        case  46    : q_recip   = 1425;     break;  // 65536 * (1/46)
+        case  47    : q_recip   = 1394;     break;  // 65536 * (1/47)
+        case  48    : q_recip   = 1365;     break;  // 65536 * (1/48)
+        case  49    : q_recip   = 1337;     break;  // 65536 * (1/49)
+        case  50    : q_recip   = 1311;     break;  // 65536 * (1/50)
+        case  51    : q_recip   = 1285;     break;  // 65536 * (1/51)
+        case  52    : q_recip   = 1260;     break;  // 65536 * (1/52)
+        case  53    : q_recip   = 1237;     break;  // 65536 * (1/53)
+        case  54    : q_recip   = 1214;     break;  // 65536 * (1/54)
+        case  55    : q_recip   = 1192;     break;  // 65536 * (1/55)
+        case  56    : q_recip   = 1170;     break;  // 65536 * (1/56)
+        case  57    : q_recip   = 1150;     break;  // 65536 * (1/57)
+        case  58    : q_recip   = 1130;     break;  // 65536 * (1/58)
+        case  59    : q_recip   = 1111;     break;  // 65536 * (1/59)
+        case  60    : q_recip   = 1092;     break;  // 65536 * (1/60)
+        case  61    : q_recip   = 1074;     break;  // 65536 * (1/61)
+        case  62    : q_recip   = 1057;     break;  // 65536 * (1/62)
+        case  63    : q_recip   = 1040;     break;  // 65536 * (1/63)
+        case  64    : q_recip   = 1024;     break;  // 65536 * (1/64)
+        case  65    : q_recip   = 1008;     break;  // 65536 * (1/65)
+        case  66    : q_recip   = 993;      break;  // 65536 * (1/66)
+        case  67    : q_recip   = 978;      break;  // 65536 * (1/67)
+        case  68    : q_recip   = 964;      break;  // 65536 * (1/68)
+        case  69    : q_recip   = 950;      break;  // 65536 * (1/69)
+        case  70    : q_recip   = 936;      break;  // 65536 * (1/70)
+        case  71    : q_recip   = 923;      break;  // 65536 * (1/71)
+        case  72    : q_recip   = 910;      break;  // 65536 * (1/72)
+        case  73    : q_recip   = 898;      break;  // 65536 * (1/73)
+        case  74    : q_recip   = 886;      break;  // 65536 * (1/74)
+        case  75    : q_recip   = 874;      break;  // 65536 * (1/75)
+        case  76    : q_recip   = 862;      break;  // 65536 * (1/76)
+        case  77    : q_recip   = 851;      break;  // 65536 * (1/77)
+        case  78    : q_recip   = 840;      break;  // 65536 * (1/78)
+        case  79    : q_recip   = 830;      break;  // 65536 * (1/79)
+        case  80    : q_recip   = 819;      break;  // 65536 * (1/80)
+        case  81    : q_recip   = 809;      break;  // 65536 * (1/81)
+        case  82    : q_recip   = 799;      break;  // 65536 * (1/82)
+        case  83    : q_recip   = 790;      break;  // 65536 * (1/83)
+        case  84    : q_recip   = 780;      break;  // 65536 * (1/84)
+        case  85    : q_recip   = 771;      break;  // 65536 * (1/85)
+        case  86    : q_recip   = 762;      break;  // 65536 * (1/86)
+        case  87    : q_recip   = 753;      break;  // 65536 * (1/87)
+        case  88    : q_recip   = 745;      break;  // 65536 * (1/88)
+        case  89    : q_recip   = 736;      break;  // 65536 * (1/89)
+        case  90    : q_recip   = 728;      break;  // 65536 * (1/90)
+        case  91    : q_recip   = 720;      break;  // 65536 * (1/91)
+        case  92    : q_recip   = 712;      break;  // 65536 * (1/92)
+        case  93    : q_recip   = 705;      break;  // 65536 * (1/93)
+        case  94    : q_recip   = 697;      break;  // 65536 * (1/94)
+        case  95    : q_recip   = 690;      break;  // 65536 * (1/95)
+        case  96    : q_recip   = 683;      break;  // 65536 * (1/96)
+        case  97    : q_recip   = 676;      break;  // 65536 * (1/97)
+        case  98    : q_recip   = 669;      break;  // 65536 * (1/98)
+        case  99    : q_recip   = 662;      break;  // 65536 * (1/99)
+        case 100    : q_recip   = 655;      break;  // 65536 * (1/100)
+        case 101    : q_recip   = 649;      break;  // 65536 * (1/101)
+        case 102    : q_recip   = 643;      break;  // 65536 * (1/102)
+        case 103    : q_recip   = 636;      break;  // 65536 * (1/103)
+        case 104    : q_recip   = 630;      break;  // 65536 * (1/104)
+        case 105    : q_recip   = 624;      break;  // 65536 * (1/105)
+        case 106    : q_recip   = 618;      break;  // 65536 * (1/106)
+        case 107    : q_recip   = 612;      break;  // 65536 * (1/107)
+        case 108    : q_recip   = 607;      break;  // 65536 * (1/108)
+        case 109    : q_recip   = 601;      break;  // 65536 * (1/109)
+        case 110    : q_recip   = 596;      break;  // 65536 * (1/110)
+        case 111    : q_recip   = 590;      break;  // 65536 * (1/111)
+        case 112    : q_recip   = 585;      break;  // 65536 * (1/112)
+        case 113    : q_recip   = 580;      break;  // 65536 * (1/113)
+        case 114    : q_recip   = 575;      break;  // 65536 * (1/114)
+        case 115    : q_recip   = 570;      break;  // 65536 * (1/115)
+        case 116    : q_recip   = 565;      break;  // 65536 * (1/116)
+        case 117    : q_recip   = 560;      break;  // 65536 * (1/117)
+        case 118    : q_recip   = 555;      break;  // 65536 * (1/118)
+        case 119    : q_recip   = 551;      break;  // 65536 * (1/119)
+        case 120    : q_recip   = 546;      break;  // 65536 * (1/120)
+        case 121    : q_recip   = 542;      break;  // 65536 * (1/121)
+        case 122    : q_recip   = 537;      break;  // 65536 * (1/122)
+        case 123    : q_recip   = 533;      break;  // 65536 * (1/123)
+        case 124    : q_recip   = 529;      break;  // 65536 * (1/124)
+        case 125    : q_recip   = 524;      break;  // 65536 * (1/125)
+        case 126    : q_recip   = 520;      break;  // 65536 * (1/126)
+        case 127    : q_recip   = 516;      break;  // 65536 * (1/127)
+        case 128    : q_recip   = 512;      break;  // 65536 * (1/128)
+        case 129    : q_recip   = 508;      break;  // 65536 * (1/129)
+        case 130    : q_recip   = 504;      break;  // 65536 * (1/130)
+        case 131    : q_recip   = 500;      break;  // 65536 * (1/131)
+        case 132    : q_recip   = 496;      break;  // 65536 * (1/132)
+        case 133    : q_recip   = 493;      break;  // 65536 * (1/133)
+        case 134    : q_recip   = 489;      break;  // 65536 * (1/134)
+        case 135    : q_recip   = 485;      break;  // 65536 * (1/135)
+        case 136    : q_recip   = 482;      break;  // 65536 * (1/136)
+        case 137    : q_recip   = 478;      break;  // 65536 * (1/137)
+        case 138    : q_recip   = 475;      break;  // 65536 * (1/138)
+        case 139    : q_recip   = 471;      break;  // 65536 * (1/139)
+        case 140    : q_recip   = 468;      break;  // 65536 * (1/140)
+        case 141    : q_recip   = 465;      break;  // 65536 * (1/141)
+        case 142    : q_recip   = 462;      break;  // 65536 * (1/142)
+        case 143    : q_recip   = 458;      break;  // 65536 * (1/143)
+        case 144    : q_recip   = 455;      break;  // 65536 * (1/144)
+        case 145    : q_recip   = 452;      break;  // 65536 * (1/145)
+        case 146    : q_recip   = 449;      break;  // 65536 * (1/146)
+        case 147    : q_recip   = 446;      break;  // 65536 * (1/147)
+        case 148    : q_recip   = 443;      break;  // 65536 * (1/148)
+        case 149    : q_recip   = 440;      break;  // 65536 * (1/149)
+        case 150    : q_recip   = 437;      break;  // 65536 * (1/150)
+        case 151    : q_recip   = 434;      break;  // 65536 * (1/151)
+        case 152    : q_recip   = 431;      break;  // 65536 * (1/152)
+        case 153    : q_recip   = 428;      break;  // 65536 * (1/153)
+        case 154    : q_recip   = 426;      break;  // 65536 * (1/154)
+        case 155    : q_recip   = 423;      break;  // 65536 * (1/155)
+        case 156    : q_recip   = 420;      break;  // 65536 * (1/156)
+        case 157    : q_recip   = 417;      break;  // 65536 * (1/157)
+        case 158    : q_recip   = 415;      break;  // 65536 * (1/158)
+        case 159    : q_recip   = 412;      break;  // 65536 * (1/159)
+        case 160    : q_recip   = 410;      break;  // 65536 * (1/160)
+        case 161    : q_recip   = 407;      break;  // 65536 * (1/161)
+        case 162    : q_recip   = 405;      break;  // 65536 * (1/162)
+        case 163    : q_recip   = 402;      break;  // 65536 * (1/163)
+        case 164    : q_recip   = 400;      break;  // 65536 * (1/164)
+        case 165    : q_recip   = 397;      break;  // 65536 * (1/165)
+        case 166    : q_recip   = 395;      break;  // 65536 * (1/166)
+        case 167    : q_recip   = 392;      break;  // 65536 * (1/167)
+        case 168    : q_recip   = 390;      break;  // 65536 * (1/168)
+        case 169    : q_recip   = 388;      break;  // 65536 * (1/169)
+        case 170    : q_recip   = 386;      break;  // 65536 * (1/170)
+        case 171    : q_recip   = 383;      break;  // 65536 * (1/171)
+        case 172    : q_recip   = 381;      break;  // 65536 * (1/172)
+        case 173    : q_recip   = 379;      break;  // 65536 * (1/173)
+        case 174    : q_recip   = 377;      break;  // 65536 * (1/174)
+        case 175    : q_recip   = 374;      break;  // 65536 * (1/175)
+        case 176    : q_recip   = 372;      break;  // 65536 * (1/176)
+        case 177    : q_recip   = 370;      break;  // 65536 * (1/177)
+        case 178    : q_recip   = 368;      break;  // 65536 * (1/178)
+        case 179    : q_recip   = 366;      break;  // 65536 * (1/179)
+        case 180    : q_recip   = 364;      break;  // 65536 * (1/180)
+        case 181    : q_recip   = 362;      break;  // 65536 * (1/181)
+        case 182    : q_recip   = 360;      break;  // 65536 * (1/182)
+        case 183    : q_recip   = 358;      break;  // 65536 * (1/183)
+        case 184    : q_recip   = 356;      break;  // 65536 * (1/184)
+        case 185    : q_recip   = 354;      break;  // 65536 * (1/185)
+        case 186    : q_recip   = 352;      break;  // 65536 * (1/186)
+        case 187    : q_recip   = 350;      break;  // 65536 * (1/187)
+        case 188    : q_recip   = 349;      break;  // 65536 * (1/188)
+        case 189    : q_recip   = 347;      break;  // 65536 * (1/189)
+        case 190    : q_recip   = 345;      break;  // 65536 * (1/190)
+        case 191    : q_recip   = 343;      break;  // 65536 * (1/191)
+        case 192    : q_recip   = 341;      break;  // 65536 * (1/192)
+        case 193    : q_recip   = 340;      break;  // 65536 * (1/193)
+        case 194    : q_recip   = 338;      break;  // 65536 * (1/194)
+        case 195    : q_recip   = 336;      break;  // 65536 * (1/195)
+        case 196    : q_recip   = 334;      break;  // 65536 * (1/196)
+        case 197    : q_recip   = 333;      break;  // 65536 * (1/197)
+        case 198    : q_recip   = 331;      break;  // 65536 * (1/198)
+        case 199    : q_recip   = 329;      break;  // 65536 * (1/199)
+        case 200    : q_recip   = 328;      break;  // 65536 * (1/200)
+        case 201    : q_recip   = 326;      break;  // 65536 * (1/201)
+        case 202    : q_recip   = 324;      break;  // 65536 * (1/202)
+        case 203    : q_recip   = 323;      break;  // 65536 * (1/203)
+        case 204    : q_recip   = 321;      break;  // 65536 * (1/204)
+        case 205    : q_recip   = 320;      break;  // 65536 * (1/205)
+        case 206    : q_recip   = 318;      break;  // 65536 * (1/206)
+        case 207    : q_recip   = 317;      break;  // 65536 * (1/207)
+        case 208    : q_recip   = 315;      break;  // 65536 * (1/208)
+        case 209    : q_recip   = 314;      break;  // 65536 * (1/209)
+        case 210    : q_recip   = 312;      break;  // 65536 * (1/210)
+        case 211    : q_recip   = 311;      break;  // 65536 * (1/211)
+        case 212    : q_recip   = 309;      break;  // 65536 * (1/212)
+        case 213    : q_recip   = 308;      break;  // 65536 * (1/213)
+        case 214    : q_recip   = 306;      break;  // 65536 * (1/214)
+        case 215    : q_recip   = 305;      break;  // 65536 * (1/215)
+        case 216    : q_recip   = 303;      break;  // 65536 * (1/216)
+        case 217    : q_recip   = 302;      break;  // 65536 * (1/217)
+        case 218    : q_recip   = 301;      break;  // 65536 * (1/218)
+        case 219    : q_recip   = 299;      break;  // 65536 * (1/219)
+        case 220    : q_recip   = 298;      break;  // 65536 * (1/220)
+        case 221    : q_recip   = 297;      break;  // 65536 * (1/221)
+        case 222    : q_recip   = 295;      break;  // 65536 * (1/222)
+        case 223    : q_recip   = 294;      break;  // 65536 * (1/223)
+        case 224    : q_recip   = 293;      break;  // 65536 * (1/224)
+        case 225    : q_recip   = 291;      break;  // 65536 * (1/225)
+        case 226    : q_recip   = 290;      break;  // 65536 * (1/226)
+        case 227    : q_recip   = 289;      break;  // 65536 * (1/227)
+        case 228    : q_recip   = 287;      break;  // 65536 * (1/228)
+        case 229    : q_recip   = 286;      break;  // 65536 * (1/229)
+        case 230    : q_recip   = 285;      break;  // 65536 * (1/230)
+        case 231    : q_recip   = 284;      break;  // 65536 * (1/231)
+        case 232    : q_recip   = 282;      break;  // 65536 * (1/232)
+        case 233    : q_recip   = 281;      break;  // 65536 * (1/233)
+        case 234    : q_recip   = 280;      break;  // 65536 * (1/234)
+        case 235    : q_recip   = 279;      break;  // 65536 * (1/235)
+        case 236    : q_recip   = 278;      break;  // 65536 * (1/236)
+        case 237    : q_recip   = 277;      break;  // 65536 * (1/237)
+        case 238    : q_recip   = 275;      break;  // 65536 * (1/238)
+        case 239    : q_recip   = 274;      break;  // 65536 * (1/239)
+        case 240    : q_recip   = 273;      break;  // 65536 * (1/240)
+        case 241    : q_recip   = 272;      break;  // 65536 * (1/241)
+        case 242    : q_recip   = 271;      break;  // 65536 * (1/242)
+        case 243    : q_recip   = 270;      break;  // 65536 * (1/243)
+        case 244    : q_recip   = 269;      break;  // 65536 * (1/244)
+        case 245    : q_recip   = 267;      break;  // 65536 * (1/245)
+        case 246    : q_recip   = 266;      break;  // 65536 * (1/246)
+        case 247    : q_recip   = 265;      break;  // 65536 * (1/247)
+        case 248    : q_recip   = 264;      break;  // 65536 * (1/248)
+        case 249    : q_recip   = 263;      break;  // 65536 * (1/249)
+        case 250    : q_recip   = 262;      break;  // 65536 * (1/250)
+        case 251    : q_recip   = 261;      break;  // 65536 * (1/251)
+        case 252    : q_recip   = 260;      break;  // 65536 * (1/252)
+        case 253    : q_recip   = 259;      break;  // 65536 * (1/253)
+        case 254    : q_recip   = 258;      break;  // 65536 * (1/254)
+        default     : q_recip   = 257;      break;  // 65536 * (1/255)
+    }
+    return q_recip;
+}   /* reciprocal */
+
+static const unsigned short jpeg_quant[7][64]   = {
+    {       // jpeg_quant[0][] : Luma, Canon
+    0x06, 0x06, 0x08, 0x0A, 0x0A, 0x10, 0x15, 0x19,
+    0x06, 0x0A, 0x0A, 0x0E, 0x12, 0x1F, 0x29, 0x29,
+    0x08, 0x0A, 0x0E, 0x12, 0x21, 0x29, 0x29, 0x29,
+    0x0A, 0x0E, 0x12, 0x14, 0x23, 0x29, 0x29, 0x29,
+    0x0A, 0x12, 0x21, 0x23, 0x27, 0x29, 0x29, 0x29,
+    0x10, 0x1F, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+    0x15, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+    0x19, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29 
+    },
+    {       // jpeg_quant[1][] : Chroma, Canon
+    0x0A, 0x0E, 0x10, 0x14, 0x15, 0x1D, 0x2B, 0x35,
+    0x0E, 0x12, 0x14, 0x1D, 0x25, 0x3E, 0x54, 0x54,
+    0x10, 0x14, 0x19, 0x25, 0x40, 0x54, 0x54, 0x54,
+    0x14, 0x1D, 0x25, 0x27, 0x48, 0x54, 0x54, 0x54,
+    0x15, 0x25, 0x40, 0x48, 0x4E, 0x54, 0x54, 0x54,
+    0x1D, 0x3E, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54,
+    0x2B, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54,
+    0x35, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54 
+    },
+    {       // jpeg_quant[2][] : Luma, spec example Table K.1
+      16,   11,   10,   16,   24,   40,    51,  61,
+      12,   12,   14,   19,   26,   58,    60,  55,
+      14,   13,   16,   24,   40,   57,    69,  56,
+      14,   17,   22,   29,   51,   87,    80,  62,
+      18,   22,   37,   56,   68,  109,   103,  77,
+      24,   35,   55,   64,   81,  104,   113,  92,
+      49,   64,   78,   87,  103,  121,   120, 101,
+      72,   92,   95,   98,  112,  100,   103,  99 
+    },
+    {       // jpeg_quant[3][] : Chroma, spec example Table K.2
+      17,   18,   24,   47,   99,   99,    99,   99,   // 07
+      18,   21,   26,   66,   99,   99,    99,   99,   // 15
+      24,   26,   56,   99,   99,   99,    99,   99,   // 23
+      47,   66,   99,   99,   99,   99,    99,   99,   // 31
+      99,   99,   99,   99,   99,   99,    99,   99,   // 39
+      99,   99,   99,   99,   99,   99,    99,   99,   // 47
+      99,   99,   99,   99,   99,   99,    99,   99,   // 55
+      99,   99,   99,   99,   99,   99,    99,   99    // 63
+    },
+    {       // jpeg_quant[4][] : Luma, spec example Table K.1, modified to create long ZRL
+      16,   11,   10,   16,   24,   40,    51,  61,
+      12,   12,   14,   19,   26,   58,    60,  55,
+      14,   13,   16,   24,   40,   57,    69,  56,
+      14,   17,   22,   29,   51,   87,    80,  62,
+      18,   22,   37,   56,   68,  109,   103,  77,
+      24,   35,   55,   64,   81,  104,   113,  92,
+      49,   64,   78,   87,  103,  121,   120, 101,
+      72,   92,   95,   98,  112,  100,   103,  16 
+    },
+    {       // jpeg_quant[5][] : Chroma, spec example Table K.2, modified to create long ZRL
+      17,   18,   24,   47,   99,   99,    99,   99,   // 07
+      18,   21,   26,   66,   99,   99,    99,   99,   // 15
+      24,   26,   56,   99,   99,   99,    99,   99,   // 23
+      47,   66,   99,   99,   99,   99,    99,   99,   // 31
+      99,   99,   99,   99,   99,   99,    99,   99,   // 39
+      99,   99,   99,   99,   99,   99,    99,   99,   // 47
+      99,   99,   99,   99,   99,   99,    99,   99,   // 55
+      99,   99,   99,   99,   99,   99,    99,   17    // 63
+    },
+    {       // jpeg_quant[6][] : no compression
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1,
+       1,    1,    1,    1,    1,    1,     1,   1 
+    }
+};  /* jpeg_quant */
+
+static const unsigned char jpeg_huffman_dc[2][16+12]  = {
+    {                                   // jpeg_huffman_dc[0][]
+        0x00,                           // number of code length=1
+        0x01,                           // number of code length=2
+        0x05,                           // number of code length=3
+        0x01,                           // number of code length=4
+        0x01,                           // number of code length=5
+        0x01,                           // number of code length=6
+        0x01,                           // number of code length=7
+        0x01,                           // number of code length=8
+        0x01,                           // number of code length=9
+        0x00,                           // number of code length=10
+        0x00,                           // number of code length=11
+        0x00,                           // number of code length=12
+        0x00,                           // number of code length=13
+        0x00,                           // number of code length=14
+        0x00,                           // number of code length=15
+        0x00,                           // number of code length=16
+        
+        0x00,                           // Entry index for code with minimum code length (=2 in this case)
+        0x01, 0x02, 0x03, 0x04, 0x05,
+        0x06,
+        0x07,
+        0x08,
+        0x09,
+        0x0A,
+        0x0B
+    },
+    {                                   // jpeg_huffman_dc[1][]
+        0x00,                           // number of code length=1 
+        0x03,                           // number of code length=2 
+        0x01,                           // number of code length=3 
+        0x01,                           // number of code length=4 
+        0x01,                           // number of code length=5 
+        0x01,                           // number of code length=6 
+        0x01,                           // number of code length=7 
+        0x01,                           // number of code length=8 
+        0x01,                           // number of code length=9 
+        0x01,                           // number of code length=10
+        0x01,                           // number of code length=11
+        0x00,                           // number of code length=12
+        0x00,                           // number of code length=13
+        0x00,                           // number of code length=14
+        0x00,                           // number of code length=15
+        0x00,                           // number of code length=16
+
+        0x00, 0x01, 0x02,               // Entry index for code with minimum code length (=2 in this case)
+        0x03,
+        0x04,
+        0x05,
+        0x06,
+        0x07,
+        0x08,
+        0x09,
+        0x0A,
+        0x0B
+    }
+};  /* jpeg_huffman_dc */
+
+static const unsigned char jpeg_huffman_ac[2][16+162]  = {
+    {                                   // jpeg_huffman_ac[0][]
+        0x00,                           // number of code length=1  
+        0x02,                           // number of code length=2 
+        0x01,                           // number of code length=3 
+        0x03,                           // number of code length=4 
+        0x03,                           // number of code length=5 
+        0x02,                           // number of code length=6 
+        0x04,                           // number of code length=7 
+        0x03,                           // number of code length=8 
+        0x05,                           // number of code length=9 
+        0x05,                           // number of code length=10
+        0x04,                           // number of code length=11
+        0x04,                           // number of code length=12
+        0x00,                           // number of code length=13
+        0x00,                           // number of code length=14
+        0x01,                           // number of code length=15
+        0x7D,                           // number of code length=16
+
+        0x01, 0x02,                     // Entry index for code with minimum code length (=2 in this case)
+        0x03,
+        0x00, 0x04, 0x11,
+        0x05, 0x12, 0x21,
+        0x31, 0x41,
+        0x06, 0x13, 0x51, 0x61,
+        0x07, 0x22, 0x71,
+        0x14, 0x32, 0x81, 0x91, 0xA1,
+        0x08, 0x23, 0x42, 0xB1, 0xC1,
+        0x15, 0x52, 0xD1, 0xF0,
+        0x24, 0x33, 0x62, 0x72,
+        0x82,
+        0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,
+        0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
+        0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76,
+        0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95,
+        0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3,
+        0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA,
+        0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
+        0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA
+    },
+    {                                   // jpeg_huffman_ac[1][]
+        0x00,                           // number of code length=1  
+        0x02,                           // number of code length=2 
+        0x01,                           // number of code length=3 
+        0x02,                           // number of code length=4 
+        0x04,                           // number of code length=5 
+        0x04,                           // number of code length=6 
+        0x03,                           // number of code length=7 
+        0x04,                           // number of code length=8 
+        0x07,                           // number of code length=9 
+        0x05,                           // number of code length=10
+        0x04,                           // number of code length=11
+        0x04,                           // number of code length=12
+        0x00,                           // number of code length=13
+        0x01,                           // number of code length=14
+        0x02,                           // number of code length=15
+        0x77,                           // number of code length=16
+
+        0x00, 0x01,                     // Entry index for code with minimum code length (=2 in this case)
+        0x02,
+        0x03, 0x11,
+        0x04, 0x05, 0x21, 0x31,
+        0x06, 0x12, 0x41, 0x51,
+        0x07, 0x61, 0x71,
+        0x13, 0x22, 0x32, 0x81,
+        0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1,
+        0x09, 0x23, 0x33, 0x52, 0xF0,
+        0x15, 0x62, 0x72, 0xD1,
+        0x0A, 0x16, 0x24, 0x34,
+
+        0xE1,
+        0x25, 0xF1,
+        0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43,
+        0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63,
+        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82,
+        0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
+        0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
+        0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5,
+        0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3,
+        0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA
+    }
+};  /* jpeg_huffman_ac */
+#endif
diff --git a/drivers/amlogic/amports/jpegenc_mc.h b/drivers/amlogic/amports/jpegenc_mc.h
new file mode 100644
index 000000000000..38db9c0c7336
--- /dev/null
+++ b/drivers/amlogic/amports/jpegenc_mc.h
@@ -0,0 +1,13 @@
+/*
+ * AMLOGIC JPEG encoder driver.
+ *
+ * Author:  <simon.zheng@amlogic.com>
+ *
+ */
+
+#ifndef JPEG_ENCODER_MC_H
+#define JPEG_ENCODER_MC_H
+
+extern const u32 jpeg_encoder_mc[];
+
+#endif /* ENCODER_MC_H */
diff --git a/drivers/amlogic/amports/m8/ucode/jpegenc/Makefile b/drivers/amlogic/amports/m8/ucode/jpegenc/Makefile
new file mode 100644
index 000000000000..cc528b3b1323
--- /dev/null
+++ b/drivers/amlogic/amports/m8/ucode/jpegenc/Makefile
@@ -0,0 +1,2 @@
+
+obj-y				+= jpeg_encoder_mc.o
diff --git a/drivers/amlogic/amports/m8/ucode/jpegenc/Makefile.bak b/drivers/amlogic/amports/m8/ucode/jpegenc/Makefile.bak
new file mode 100755
index 000000000000..d3a045fdc40f
--- /dev/null
+++ b/drivers/amlogic/amports/m8/ucode/jpegenc/Makefile.bak
@@ -0,0 +1,2 @@
+
+obj-y				+= encoder_mc.o
diff --git a/drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c b/drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c
new file mode 100644
index 000000000000..fd83bfba1ffd
--- /dev/null
+++ b/drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c
@@ -0,0 +1,46 @@
+/*
+ * AMLOGIC  AVC encoder driver.
+ *
+ * Author:  Simon Zheng <simon.zheng@amlogic.com>
+ *
+ */
+
+#include <linux/types.h>
+
+const u32 jpeg_encoder_mc[] __attribute__((aligned(8))) = {
+	0x6810001,0x6800000,0xd000001,0x7400040,0xc000980,0x0000000,0xc000b40,0x0000000,
+	0x6bffc40,0x7c00000,0x6030400,0x0400000,0x80ac001,0x8030504,0xc780000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0xc782d00,0x0000000,0xc781a40,0x64d3008,0xc780440,0x0000000,0xc782d40,0x64f1f08,
+	0xcc00000,0x0400000,0x64ac101,0x60d1a01,0x80d3000,0x80ac000,0x8002515,0x8002608,
+	0x8002814,0xcc00000,0x0000000,0xcc00000,0x0000000,0x6bfff88,0x6030408,0x0400000,
+	0x64ac008,0xaa0c048,0xc781340,0x0000000,0x6bc0008,0x60d1f08,0x64d1e08,0x9c087c8,
+	0x60d1e08,0x64d1e08,0x98087c8,0x60d1e08,0x80d3040,0x64d0008,0x9808008,0x9808048,
+	0x60d0008,0x64d3108,0x900e248,0x7c00049,0x920e248,0x7c00089,0x64d3308,0x9002248,
+	0x7c000c9,0x9082248,0x7c00109,0x78000c8,0xaa3c088,0xaa680c8,0x0000000,0x7800049,
+	0x4007249,0x5803249,0x7c00209,0x7800089,0x4007249,0x5803249,0x7c00249,0x68000c9,
+	0x7c00289,0xc780600,0x0000000,0x7800049,0x400f249,0x5804249,0x7c00209,0x7800089,
+	0x4007249,0x5803249,0x7c00249,0x6800109,0x7c00289,0xc780300,0x0000000,0x7800049,
+	0x400f249,0x5804249,0x7c00209,0x7800089,0x400f249,0x5804249,0x7c00249,0x6800189,
+	0x7c00289,0x6800008,0x7c001c8,0x7c00148,0x7c00188,0x64d5808,0x9808008,0x9808048,
+	0x60d5808,0x6800048,0x60f2a08,0x80d3606,0x80ac003,0xc780080,0x0000000,0x0800000,
+	0x7800008,0xc7fe7c0,0x6030408,0xaa0c008,0xc780100,0x0000000,0xc7fe680,0x0000000,
+	0x7800108,0xaa54088,0xaa20048,0x78001c8,0x4001208,0x7800289,0xb83b248,0x7c001c8,
+	0x6800008,0x7c001c8,0x7800148,0x4001208,0x7800209,0xb834248,0x7c00148,0x6800008,
+	0x7c00148,0x7800188,0x4001208,0x7800249,0xb82d248,0x7c00188,0x80d3000,0x6bfffc8,
+	0x60d1f08,0x64d1e08,0x9c087c8,0x60d1e08,0x6bff648,0x6c00408,0x60d1f08,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,
+	0xbefc108,0x0000000,0x6800008,0x6e00008,0x60d1c08,0x80d1d00,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,0xbefc108,0x0000000,0x64d1b08,
+	0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac004,0x8007801,0xc780000,
+	0x0000000,0x80d3606,0xc7fd580,0x0000000,0x64d1602,0x9162082,0xaa0c002,0xc7fff40,
+	0x0000000,0xc7fd3c0,0x0000000,0xc7fd340,0x0000000,0x0000000
+};
+
+
+
+
+
+
+                   
diff --git a/drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c.bak b/drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c.bak
new file mode 100644
index 000000000000..2e610ba5ea6c
--- /dev/null
+++ b/drivers/amlogic/amports/m8/ucode/jpegenc/jpeg_encoder_mc.c.bak
@@ -0,0 +1,44 @@
+/*
+ * AMLOGIC  AVC encoder driver.
+ *
+ * Author:  Simon Zheng <simon.zheng@amlogic.com>
+ *
+ */
+
+#include <linux/types.h>
+
+const u32 jpeg_encoder_mc[] __attribute__((aligned(8))) = {
+	0x6810001,0x6800000,0xd000001,0x7400040,0xc000980,0x0000000,0xc000b40,0x0000000,
+	0x6bffc40,0x7c00000,0x6030400,0x0400000,0x80ac001,0x8030504,0xc780000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0xc782ac0,0x0000000,0xc781a40,0x64d3008,0xc780440,0x0000000,0xc782b00,0x64f1f08,
+	0xcc00000,0x0400000,0x64ac101,0x60d1a01,0x80d3000,0x80ac000,0x8002515,0x8002608,
+	0x8002814,0xcc00000,0x0000000,0xcc00000,0x0000000,0x6bfff88,0x6030408,0x0400000,
+	0x64ac008,0xaa0c048,0xc781340,0x0000000,0x6bc0008,0x60d1f08,0x64d1e08,0x9c087c8,
+	0x60d1e08,0x64d1e08,0x98087c8,0x60d1e08,0x80d3040,0x64d0008,0x9808008,0x9808048,
+	0x60d0008,0x64d3108,0x900e248,0x7c00049,0x920e248,0x7c00089,0x64d3308,0x9002248,
+	0x7c000c9,0x9082248,0x7c00109,0x78000c8,0xaa3c088,0xaa680c8,0x0000000,0x7800049,
+	0x4007249,0x5803249,0x7c00209,0x7800089,0x4007249,0x5803249,0x7c00249,0x68000c9,
+	0x7c00289,0xc780600,0x0000000,0x7800049,0x400f249,0x5804249,0x7c00209,0x7800089,
+	0x4007249,0x5803249,0x7c00249,0x6800109,0x7c00289,0xc780300,0x0000000,0x7800049,
+	0x400f249,0x5804249,0x7c00209,0x7800089,0x400f249,0x5804249,0x7c00249,0x6800189,
+	0x7c00289,0x6800008,0x7c001c8,0x7c00148,0x7c00188,0x64d5808,0x9808008,0x9808048,
+	0x60d5808,0x6800048,0x60f2a08,0x80d3606,0x80ac003,0xc780080,0x0000000,0x0800000,
+	0x7800008,0xc7fe7c0,0x6030408,0xaa0c008,0xc780100,0x0000000,0xc7fe680,0x0000000,
+	0x7800108,0xaa54088,0xaa20048,0x78001c8,0x4001208,0x7800289,0xb832248,0x7c001c8,
+	0x6800008,0x7c001c8,0x7800148,0x4001208,0x7800209,0xb82b248,0x7c00148,0x6800008,
+	0x7c00148,0x7800188,0x4001208,0x7800249,0xb824248,0x7c00188,0x80d3000,0x6bfffc8,
+	0x60d1f08,0x64d1e08,0x9c087c8,0x60d1e08,0x6bff648,0x6c00408,0x60d1f08,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,
+	0xbefc108,0x0000000,0x6800008,0x6e00008,0x60d1c08,0x80d1d00,0x64d1b08,0x9808648,
+	0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac004,0x8007801,0xc780000,0x0000000,
+	0x80d3606,0xc7fd7c0,0x0000000,0x64d1602,0x9162082,0xaa0c002,0xc7fff40,0x0000000,
+	0xc7fd600,0x0000000,0xc7fd580,0x0000000,0x0000000
+};
+
+
+
+
+
+                   
-- 
2.19.0

