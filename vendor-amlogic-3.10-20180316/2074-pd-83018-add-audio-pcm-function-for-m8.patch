From f52afc751dc5c5b3c67cea4cd7880b6b77674a69 Mon Sep 17 00:00:00 2001
From: "chengshun.wang" <chengshun.wang@amlogic.com>
Date: Wed, 27 Nov 2013 14:04:07 +0800
Subject: [PATCH 2074/5965] pd#83018:add audio pcm function for m8

---
 arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd    |   34 +-
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd |   46 +-
 arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd |   46 +-
 arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd |   34 +-
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd |   35 +-
 arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd |   35 +-
 arch/arm/boot/dts/amlogic/meson8_pxp.dtd     |   34 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd     |   34 +-
 arch/arm/configs/meson8_defconfig            |    5 +
 drivers/amlogic/amaudio/amaudio.c            |   22 +-
 sound/soc/aml/Kconfig                        |    2 +-
 sound/soc/aml/Makefile                       |   20 +-
 sound/soc/aml/aml_i2s.c                      | 1119 ++++++++++++++
 sound/soc/aml/aml_i2s.h                      |   77 +
 sound/soc/aml/{aml_dai.c => aml_i2s_dai.c}   |  153 +-
 sound/soc/aml/{aml_dai.h => aml_i2s_dai.h}   |    0
 sound/soc/aml/aml_m8.c                       |   20 +-
 sound/soc/aml/aml_m_dummy.c                  |    4 +-
 sound/soc/aml/aml_pcm.c                      | 1371 ++++++------------
 sound/soc/aml/aml_pcm.h                      |   80 +-
 sound/soc/aml/aml_pcm_dai.c                  |  268 ++++
 sound/soc/aml/aml_pcm_dai.h                  |    6 +
 sound/soc/aml/aml_platform.c                 |  573 --------
 sound/soc/aml/aml_platform.h                 |   36 -
 sound/soc/aml/aml_platform_pcm2bt.c          |  687 ---------
 sound/soc/aml/aml_platform_pcm2bt.h          |    6 -
 sound/soc/aml/aml_spdif_dai.c                |    2 +-
 sound/soc/codecs/Kconfig                     |    2 +
 sound/soc/codecs/Makefile                    |    2 +
 sound/soc/codecs/pcm2bt.c                    |  180 +++
 sound/soc/codecs/pcm2bt.h                    |   12 +
 31 files changed, 2478 insertions(+), 2467 deletions(-)
 create mode 100755 sound/soc/aml/aml_i2s.c
 create mode 100755 sound/soc/aml/aml_i2s.h
 rename sound/soc/aml/{aml_dai.c => aml_i2s_dai.c} (67%)
 rename sound/soc/aml/{aml_dai.h => aml_i2s_dai.h} (100%)
 mode change 100644 => 100755
 create mode 100755 sound/soc/aml/aml_pcm_dai.c
 create mode 100755 sound/soc/aml/aml_pcm_dai.h
 delete mode 100755 sound/soc/aml/aml_platform.c
 delete mode 100755 sound/soc/aml/aml_platform.h
 delete mode 100755 sound/soc/aml/aml_platform_pcm2bt.c
 delete mode 100755 sound/soc/aml/aml_platform_pcm2bt.h
 create mode 100755 sound/soc/codecs/pcm2bt.c
 create mode 100755 sound/soc/codecs/pcm2bt.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd b/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
index fcc948fc6c93..68f856ef11d2 100755
--- a/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
@@ -766,17 +766,17 @@ void root_func(){
 
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -795,6 +795,30 @@ void root_func(){
         status = "okay";
     };
 
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 2bc70585883a..ebcb81416b16 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1163,17 +1163,17 @@ sdio{
 
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -1192,6 +1192,30 @@ sdio{
         status = "okay";
     };
 
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
@@ -1221,6 +1245,8 @@ sdio{
         mute_gpio = "GPIOY_15";
         //mute_inv;
         hp_paraments = <800 300 0 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
         status = "okay";
         
     };
@@ -2032,6 +2058,16 @@ sdio{
 						"GPIODV_18","GPIODV_19","GPIODV_20","GPIODV_21","GPIODV_22","GPIODV_23";	//B2~B7
 			amlogic,enable-output=<1>;
         };
+//$$ MATCH "Audio_pin_0_match" = "&audio_pins"
+//$$ L2 PROP_U32 4 = "amlogic,setmask"
+//$$ L2 PROP_U32 10 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"
+        audio_pins:audio_pin{
+            amlogic,setmask=<3 0x78000000>;
+            amlogic,clrmask=<4 0x3c000
+                             5 0x1000>;
+            amlogic,pins ="GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7";
+        };
 	};
 
 }; /* end of / */
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
index 86c959c71a4a..185e037c784d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
@@ -1199,17 +1199,17 @@ sdio{
 
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -1228,6 +1228,30 @@ sdio{
         status = "okay";
     };
 
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
@@ -1257,6 +1281,8 @@ sdio{
         mute_gpio = "GPIOY_15";
         //mute_inv;
         hp_paraments = <800 300 0 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
         status = "okay";
         
     };
@@ -2068,6 +2094,16 @@ sdio{
 						"GPIODV_18","GPIODV_19","GPIODV_20","GPIODV_21","GPIODV_22","GPIODV_23";	//B2~B7
 			amlogic,enable-output=<1>;
         };
+//$$ MATCH "Audio_pin_0_match" = "&audio_pins"
+//$$ L2 PROP_U32 4 = "amlogic,setmask"
+//$$ L2 PROP_U32 10 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"
+        audio_pins:audio_pin{
+            amlogic,setmask=<3 0x78000000>;
+            amlogic,clrmask=<4 0x3c000
+                             5 0x1000>;
+            amlogic,pins ="GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7";
+        };
 	};
 
 }; /* end of / */
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
index 3e19780199f3..4ca8ee731de2 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
@@ -1195,17 +1195,17 @@ sdio{
 };
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -1224,6 +1224,30 @@ sdio{
         status = "okay";
     };
 
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index 7305cae47498..32089bef4a1e 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -792,17 +792,17 @@ interrupts = <0     137     0x04
 	};
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -820,6 +820,31 @@ interrupts = <0     137     0x04
         dev_name = "spdif-dit.0";
         status = "okay";
     };
+
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
index f744989dc4bd..43d02aa38c13 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
@@ -795,17 +795,17 @@ sdio{
 	};
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -823,6 +823,31 @@ sdio{
         dev_name = "spdif-dit.0";
         status = "okay";
     };
+
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
diff --git a/arch/arm/boot/dts/amlogic/meson8_pxp.dtd b/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
index 6270c211543b..1e3e977db06a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
@@ -767,17 +767,17 @@ void root_func(){
 
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -796,6 +796,30 @@ void root_func(){
         status = "okay";
     };
 
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index c0f80d9715f9..1c4a8166fea3 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -772,17 +772,17 @@ void root_func(){
 
 
 /// ***************************************************************************************
-///	-	Audio
+/// -   Audio
 //$$ MODULE="Audio"
-//$$ DEVICE="audio_platform"
+//$$ DEVICE="audio_i2s"
 //$$ L2 PROP_STR = "status"
     audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
         status = "okay";
     };
 
-//$$ DEVICE="audio_dai"
+//$$ DEVICE="audio_i2s_dai"
 //$$ L2 PROP_STR = "status"
     audio_dai{
         compatible = "amlogic,aml-i2s-dai";
@@ -801,6 +801,30 @@ void root_func(){
         status = "okay";
     };
 
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
 //$$ DEVICE="audio_m8_audio"
 //$$ L2 PROP_STR = "status"
     audio_m8_audio{
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index cfaf21fc2490..4df660a1e891 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -241,8 +241,13 @@ CONFIG_USB_VIDEO_CLASS=y
 CONFIG_V4L_PLATFORM_DRIVERS=y
 CONFIG_SPI=y
 CONFIG_MEDIA_SUPPORT=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SND_AML_SOC=y
 CONFIG_SND_AML_M_DUMMY_CODEC=y
 CONFIG_SND_AML_M8=y
+CONFIG_SND_AML_M8_PCM=y
 CONFIG_UHID=y
 CONFIG_SND_USB=y
 CONFIG_SND_USB_AUDIO=y
diff --git a/drivers/amlogic/amaudio/amaudio.c b/drivers/amlogic/amaudio/amaudio.c
index af3b842bd1b5..08455a76d627 100755
--- a/drivers/amlogic/amaudio/amaudio.c
+++ b/drivers/amlogic/amaudio/amaudio.c
@@ -70,10 +70,10 @@ extern void audio_in_i2s_enable(int flag);
 extern int audio_out_buf_ready ;
 extern int audio_in_buf_ready;
 
-extern unsigned int aml_pcm_playback_start_addr;
-extern unsigned int aml_pcm_capture_start_addr;
-extern unsigned int aml_pcm_capture_start_phy;
-extern unsigned int aml_pcm_capture_buf_size;
+extern unsigned int aml_i2s_playback_start_addr;
+extern unsigned int aml_i2s_capture_start_addr;
+extern unsigned int aml_i2s_capture_start_phy;
+extern unsigned int aml_i2s_capture_buf_size;
 
 static dev_t amaudio_devno;
 static struct class* amaudio_clsp;
@@ -110,7 +110,7 @@ static unsigned int dump_size = 512*1024;
 static unsigned int dump_off = 0;
 
 
-extern int aml_pcm_playback_enable;
+extern int aml_i2s_playback_enable;
 extern unsigned int dac_mute_const;
 
 static unsigned int audio_in_int_cnt = 0;
@@ -1199,7 +1199,7 @@ static int amaudio_open(struct inode *inode, struct file *file)
   int tmp=0;
   if (audio_in_buf_ready && iminor(inode)== 1){
     amaudio->in_size  = READ_MPEG_REG(AUDIN_FIFO0_END) - READ_MPEG_REG(AUDIN_FIFO0_START) + 8;
-    amaudio->in_start = aml_pcm_capture_start_addr;
+    amaudio->in_start = aml_i2s_capture_start_addr;
     amaudio->in_rd_ptr = 0;
     amaudio->in_wr_ptr = 0;
     memcpy(&amaudio_in, amaudio, sizeof(amaudio_t));
@@ -1207,7 +1207,7 @@ static int amaudio_open(struct inode *inode, struct file *file)
   
   if (audio_out_buf_ready && iminor(inode) == 0){
     amaudio->out_size = READ_MPEG_REG(AIU_MEM_I2S_END_PTR) - READ_MPEG_REG(AIU_MEM_I2S_START_PTR) + 64;
-    amaudio->out_start = aml_pcm_playback_start_addr;
+    amaudio->out_start = aml_i2s_playback_start_addr;
     amaudio->out_wr_ptr = 0;
     amaudio->out_rd_ptr = 0;
     
@@ -1553,7 +1553,7 @@ static long amaudio_utils_ioctl(struct file *file,
          //   WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0));
             // prepare aiu
         //    audio_in_i2s_set_buf(aml_pcm_capture_start_phy, aml_pcm_capture_buf_size*2);
-            memset((void*)aml_pcm_capture_start_addr,0,aml_pcm_capture_buf_size*2);
+            memset((void*)aml_i2s_capture_start_addr,0,aml_i2s_capture_buf_size*2);
             // prepare codec
      //       aml_linein_start();
             // trigger aiu
@@ -1667,16 +1667,16 @@ static ssize_t store_mic_mix(struct class* class, struct class_attribute* attr,
 static ssize_t show_alsa_out(struct class* class, struct class_attribute* attr,
     char* buf)
 {
-  return sprintf(buf, "ALSA OUT %s\n", aml_pcm_playback_enable? "ON": "OFF");
+  return sprintf(buf, "ALSA OUT %s\n", aml_i2s_playback_enable? "ON": "OFF");
 }
 
 static ssize_t store_alsa_out(struct class* class, struct class_attribute* attr,
    const char* buf, size_t count )
 {
   if(buf[0] == '0'){
-    aml_pcm_playback_enable = 0;
+    aml_i2s_playback_enable = 0;
   }else if(buf[0] == '1'){
-    aml_pcm_playback_enable = 1;
+    aml_i2s_playback_enable = 1;
   }
   return count;
 }
diff --git a/sound/soc/aml/Kconfig b/sound/soc/aml/Kconfig
index 2322623b408e..e6344064d40f 100755
--- a/sound/soc/aml/Kconfig
+++ b/sound/soc/aml/Kconfig
@@ -121,4 +121,4 @@ config SND_AML_M8
 config SND_AML_M8_PCM
 	tristate "M8 evaluation board with PCM2BT"
 	depends on SND_AML_SOC
-	select SND_SOC_PCM2BT
+	select SND_SOC_PCM2BT if SND_AML_M8_PCM
\ No newline at end of file
diff --git a/sound/soc/aml/Makefile b/sound/soc/aml/Makefile
index 11319961183d..749904bb052d 100755
--- a/sound/soc/aml/Makefile
+++ b/sound/soc/aml/Makefile
@@ -1,20 +1,26 @@
 # AML Platform Support
 snd-soc-aml-pcm-objs := aml_pcm.o
-snd-soc-aml-platform-pcm2bt-objs := aml_platform_pcm2bt.o
-snd-soc-aml-dai-objs := aml_dai.o
+snd-soc-aml-i2s-objs := aml_i2s.o
+#snd-soc-aml-platform-pcm2bt-objs := aml_platform_pcm2bt.o
+snd-soc-aml-i2s-dai-objs := aml_i2s_dai.o
+snd-soc-aml-pcm-dai-objs := aml_pcm_dai.o
+snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
 snd-soc-aml-hw-objs  := aml_audio_hw.o
 snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
-snd-soc-aml-platform-objs := aml_platform.o
+#snd-soc-aml-platform-objs := aml_platform.o
+
 
-snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-pcm.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-dai.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-i2s.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-i2s-dai.o
+obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-pcm-dai.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw.o
 obj-$(CONFIG_SND_AML_SOC) += aml_notify.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform-pcm2bt.o
+#obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform.o
+#obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform-pcm2bt.o
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw-pcm2bt.o
 
+
 obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-spdif-dai.o
 #AML M1 Machine support
 
diff --git a/sound/soc/aml/aml_i2s.c b/sound/soc/aml/aml_i2s.c
new file mode 100755
index 000000000000..92cb2eea23b8
--- /dev/null
+++ b/sound/soc/aml/aml_i2s.c
@@ -0,0 +1,1119 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/hrtimer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/amlogic/rt5631.h>
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include <linux/amlogic/amports/amaudio.h>
+
+#include <mach/mod_gate.h>
+
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+#define USE_HRTIMER 0
+#define HRTIMER_PERIOD (1000000000UL/1000)
+//#define DEBUG_ALSA_PLATFRORM
+
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s]" fmt,##args)
+#ifdef DEBUG_ALSA_PLATFRORM
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-i2s]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-i2s] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+
+
+unsigned int aml_i2s_playback_start_addr = 0;
+unsigned int aml_i2s_capture_start_addr  = 0;
+
+unsigned int aml_i2s_playback_end_addr = 0;
+unsigned int aml_i2s_capture_end_addr = 0;
+
+unsigned int aml_i2s_capture_start_phy = 0;
+unsigned int aml_i2s_capture_buf_size = 0;
+unsigned int aml_i2s_playback_phy_start_addr = 0;
+unsigned int aml_i2s_capture_phy_start_addr  = 0;
+unsigned int aml_i2s_playback_phy_end_addr = 0;
+unsigned int aml_i2s_capture_phy_end_addr = 0;
+unsigned int aml_i2s_playback_off = 0;
+unsigned int aml_i2s_playback_enable = 1;
+
+unsigned int aml_iec958_playback_start_addr = 0;
+unsigned int aml_iec958_playback_start_phy = 0;
+unsigned int aml_iec958_playback_size = 0;  // in bytes
+
+
+static int audio_type_info = -1;
+static int audio_sr_info = -1;
+extern unsigned audioin_mode;
+
+
+
+EXPORT_SYMBOL(aml_i2s_playback_start_addr);
+EXPORT_SYMBOL(aml_i2s_capture_start_addr);
+EXPORT_SYMBOL(aml_i2s_playback_off);
+EXPORT_SYMBOL(aml_i2s_playback_enable);
+
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_i2s_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE,
+
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 128 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static const struct snd_pcm_hardware aml_i2s_capture = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_MMAP |
+						 	SNDRV_PCM_INFO_MMAP_VALID |
+						  SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static char snd_i2s_tmp[32*1024];
+
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+/*--------------------------------------------------------------------------*/
+/*--------------------------------------------------------------------------*\
+ * Helper functions
+\*--------------------------------------------------------------------------*/
+static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	ALSA_TRACE();
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+	size_t size = 0;
+	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		    size = aml_i2s_hardware.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+            /* one size for i2s output, another for 958, and 128 for alignment */
+		    buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-i2s %d:"
+		    "playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+        }else{
+
+		size = aml_i2s_capture.buffer_bytes_max;
+		buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		buf->dev.dev = pcm->card->dev;
+		buf->private_data = NULL;
+		buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-i2s %d:"
+		    "capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+	    }
+
+	    if (!buf->area)
+		    return -ENOMEM;
+    
+	    buf->bytes = size;
+	    return 0;
+
+}
+/*--------------------------------------------------------------------------*\
+ * ISR
+\*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*\
+ * i2s operations
+\*--------------------------------------------------------------------------*/
+static int aml_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+//	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	audio_stream_t *s = &prtd->s;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+	ALSA_PRINT("runtime dma_bytes %d,stream type \n",runtime->dma_bytes,substream->stream);
+	s->I2S_addr = runtime->dma_addr;
+
+    /*
+     * Both capture and playback need to reset the last ptr to the start address,
+       playback and capture use different address calculate, so we reset the different
+       start address to the last ptr
+   * */
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+        /* s->last_ptr must initialized as dma buffer's start addr */
+        s->last_ptr = runtime->dma_addr;
+    }else{
+
+	s->last_ptr = 0;
+    }
+
+	return 0;
+}
+
+static int aml_i2s_hw_free(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	struct aml_i2s_dma_params *params = prtd->params;
+	if (params != NULL) {
+
+	}
+
+	return 0;
+}
+
+
+static int aml_i2s_prepare(struct snd_pcm_substream *substream)
+{
+	ALSA_TRACE();
+	return 0;
+}
+
+static int aml_i2s_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	ALSA_TRACE();
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct aml_runtime_data *prtd = rtd->private_data;
+	audio_stream_t *s = &prtd->s;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:		
+
+#if USE_HRTIMER == 0
+	  del_timer_sync(&prtd->timer);
+#endif      
+	  spin_lock(&s->lock);
+#if USE_HRTIMER == 0
+	  prtd->timer.expires = jiffies + 1;
+	  del_timer(&prtd->timer);
+	  add_timer(&prtd->timer);
+#endif
+
+	  s->active = 1;
+	  spin_unlock(&s->lock);
+	  break;		/* SNDRV_PCM_TRIGGER_START */
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		// TODO
+	    spin_lock(&s->lock);
+	    s->active = 0;
+	    spin_unlock(&s->lock);
+	    break;
+	default:
+		ret = -EINVAL;
+	}
+/*	if(clock_gating_status&clock_gating_playback){
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			aml_pcm_work.substream = substream;
+	}
+	else
+		aml_pcm_work.substream = substream;
+
+
+	if(clock_gating_status)
+	{
+		schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	}
+	*/
+	//schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_i2s_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+
+	unsigned int addr, ptr;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		if(s->device_type == AML_AUDIO_I2SOUT)
+			ptr = read_i2s_rd_ptr();
+		else
+			ptr = read_iec958_rd_ptr();
+	    addr = ptr - s->I2S_addr;
+	    return bytes_to_frames(runtime, addr);
+	}else{
+		if(s->device_type == AML_AUDIO_I2SIN)
+			ptr = audio_in_i2s_wr_ptr();
+		else
+			ptr = audio_in_spdif_wr_ptr();				
+			addr = ptr - s->I2S_addr;
+			return bytes_to_frames(runtime, addr)/2;
+	}
+
+	return 0;
+}	
+static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
+{
+  struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
+  audio_stream_t* s = &prtd->s;
+  struct snd_pcm_substream* substream = prtd->substream;
+  struct snd_pcm_runtime* runtime= substream->runtime;
+  
+  unsigned int last_ptr, size;
+  unsigned long flag;
+  //printk("------------->hrtimer start\n");
+  if(s->active == 0){
+    hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+    return HRTIMER_RESTART;
+  }
+  //spin_lock_irqsave(&s->lock, flag);
+
+  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+      last_ptr = read_i2s_rd_ptr();
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(substream->runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }else{
+      last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) /2;
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }
+  //spin_unlock_irqrestore(&s->lock, flag);
+  hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+  return HRTIMER_RESTART;
+}
+
+static void aml_i2s_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = runtime->private_data;
+		audio_stream_t *s = &prtd->s;
+
+    unsigned int last_ptr, size;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		if(s->active == 1)
+		{
+			spin_lock(&s->lock);
+			if(s->device_type == AML_AUDIO_I2SOUT)
+				last_ptr = read_i2s_rd_ptr();
+			else
+				last_ptr = read_iec958_rd_ptr();							
+						if (last_ptr < s->last_ptr) {
+				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
+				    } else {
+				        size = last_ptr - (s->last_ptr);
+				    }
+    				s->last_ptr = last_ptr;
+    				s->size += bytes_to_frames(substream->runtime, size);
+    				if (s->size >= runtime->period_size) {
+				        s->size %= runtime->period_size;
+				        spin_unlock(&s->lock);
+				        snd_pcm_period_elapsed(substream);
+				        spin_lock(&s->lock);
+				    }
+				    mod_timer(&prtd->timer, jiffies + 1);
+   					spin_unlock(&s->lock);
+				}else{
+						 mod_timer(&prtd->timer, jiffies + 1);
+				}
+		}
+	else
+	{
+		if(s->active == 1)
+		{
+			spin_lock(&s->lock);
+			if(s->device_type == AML_AUDIO_I2SIN)			
+				last_ptr = audio_in_i2s_wr_ptr() ;
+			else
+				last_ptr = audio_in_spdif_wr_ptr();				
+			if (last_ptr < s->last_ptr) {
+				size = runtime->dma_bytes + (last_ptr - (s->last_ptr))/2;
+			} else {
+				size = (last_ptr - (s->last_ptr))/2;
+			}
+			s->last_ptr = last_ptr;
+			s->size += bytes_to_frames(substream->runtime, size);
+			if (s->size >= runtime->period_size) {
+				s->size %= runtime->period_size;
+				spin_unlock(&s->lock);
+				snd_pcm_period_elapsed(substream);
+				spin_lock(&s->lock);
+			}
+			mod_timer(&prtd->timer, jiffies + 1);
+			spin_unlock(&s->lock);
+		}
+		else
+		{
+			mod_timer(&prtd->timer, jiffies + 1);
+		}
+	}
+}
+
+
+static int aml_i2s_open(struct snd_pcm_substream *substream)
+{
+	ALSA_TRACE();
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd;
+	int ret = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		snd_soc_set_runtime_hwparams(substream, &aml_i2s_hardware);
+	}else{
+		snd_soc_set_runtime_hwparams(substream, &aml_i2s_capture);
+	}
+
+    /* ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0)
+	{
+		printk("set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+						SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+	{
+		printk("set period error\n");
+		goto out;
+	}
+
+	prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		printk("alloc aml_runtime_data error\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	//WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);			
+	//WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
+	prtd->substream = substream;
+#if USE_HRTIMER == 0    
+	prtd->timer.function = &aml_i2s_timer_callback;
+	prtd->timer.data = (unsigned long)substream;
+	init_timer(&prtd->timer);
+#else
+    hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    prtd->hrtimer.function = aml_i2s_hrtimer_callback;
+    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
+
+
+    printk("hrtimer inited..\n");
+#endif
+	runtime->private_data = prtd;
+
+	spin_lock_init(&prtd->s.lock);
+ out:
+	return ret;
+}
+
+static int aml_i2s_close(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	audio_stream_t *s = &prtd->s;	
+	ALSA_TRACE();
+	if(s->device_type == AML_AUDIO_SPDIFOUT){
+	//	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);
+
+    }			
+#if USE_HRTIMER == 0
+	del_timer_sync(&prtd->timer);
+#else
+    hrtimer_cancel(&prtd->hrtimer);
+#endif
+	kfree(prtd);
+	return 0;
+}
+
+
+static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    int res = 0;
+    int n;
+    int i = 0, j = 0;
+    int  align = runtime->channels * 32 / runtime->byte_align;
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    n = frames_to_bytes(runtime, count);
+    if(aml_i2s_playback_enable == 0)
+      return res;
+	if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count)))
+	{
+		if(1/*runtime->channels == 2*/){
+			if(runtime->format == SNDRV_PCM_FORMAT_S16_LE ){
+        int16_t * tfrom, *to, *left, *right;
+        tfrom = (int16_t*)buf;
+        to = (int16_t*)hwbuf;
+
+        left = to;
+		right = to + 16;
+		if (pos % align) {
+		    printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+		}
+		for (j = 0; j < n; j += 64) {
+		    for (i = 0; i < 16; i++) {
+	          *left++ = (*tfrom++) ;
+	          *right++ = (*tfrom++);
+		    }
+		    left += 16;
+		    right += 16;
+		 }
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++);
+            *right++  = (*tfrom ++);
+          }
+          left += 8;
+          right += 8;
+        }
+
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S32_LE && I2S_MODE == AIU_I2S_MODE_PCM32){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+		
+		if(runtime->channels == 8){
+			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+			lf  = to;
+			cf  = to + 8*1;
+			rf  = to + 8*2;
+			ls  = to + 8*3;
+			rs  = to + 8*4;
+			lef = to + 8*5;
+			sbl = to + 8*6;
+			sbr = to + 8*7;
+			for (j = 0; j < n; j += 256) {
+		    	for (i = 0; i < 8; i++) {
+	         		*lf++  = (*tfrom ++)>>8;
+	          		*cf++  = (*tfrom ++)>>8;
+					*rf++  = (*tfrom ++)>>8;
+					*ls++  = (*tfrom ++)>>8;
+					*rs++  = (*tfrom ++)>>8;
+					*lef++ = (*tfrom ++)>>8;
+					*sbl++ = (*tfrom ++)>>8;
+					*sbr++ = (*tfrom ++)>>8;
+		    	}
+		    	lf  += 7*8;
+		    	cf  += 7*8;
+				rf  += 7*8;
+				ls  += 7*8;
+				rs  += 7*8;
+				lef += 7*8;
+				sbl += 7*8;
+				sbr += 7*8;
+		 	}
+		}
+		else {
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++)>>8;
+            *right++  = (*tfrom ++)>>8;
+          }
+          left += 8;
+          right += 8;
+        }
+      	}
+      }
+
+	}else{
+	  res = -EFAULT;
+	}
+
+	return res;
+    }
+}
+
+
+static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+		unsigned int *tfrom, *left, *right;
+		unsigned short *to;
+		int res = 0;
+		int n;
+    int i = 0, j = 0;
+    unsigned int t1, t2;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;	   
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
+    unsigned char r_shift = 8;	
+	if(s->device_type == AML_AUDIO_SPDIFIN) //spdif in
+    {
+    	r_shift = 12;
+    }
+    to = (unsigned short *)snd_i2s_tmp;//buf;
+    tfrom = (unsigned int *)hwbuf;	// 32bit buffer
+    n = frames_to_bytes(runtime, count);
+    if(n > 32*1024){
+		printk("Too many datas to read,please enlarge the snd_i2s_tmp buffer size\n");
+      return -EINVAL;
+    }
+	if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count)))
+	{
+		if(runtime->channels == 2){
+				left = tfrom;
+		    right = tfrom + 8;
+		    if (pos % 8) {
+		        printk("audio data unligned\n");
+		    }
+		    if((n*2)%64){
+		    		printk("audio data unaligned 64 bytes\n");
+		    }
+		    for (j = 0; j < n*2 ; j += 64) {
+		        for (i = 0; i < 8; i++) {
+		        	t1 = (*left++);
+		        	t2 = (*right++);
+		        	//printk("%08x,%08x,", t1, t2);
+	              *to++ = (unsigned short)((t1>>r_shift)&0xffff);
+	           //   *to++ = (unsigned short)((t1>>8)&0xffff);//copy left channel to right
+	              *to++ = (unsigned short)((t2>>r_shift)&0xffff);
+		         }
+		         //printk("\n");
+		        left += 8;
+		        right += 8;
+			}
+		}
+		else{
+		    }
+		}
+        res = copy_to_user(buf, snd_i2s_tmp,n);
+		return res;
+}
+
+static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+ 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+ 		ret = aml_i2s_copy_playback(runtime, channel,pos, buf, count);
+ 	}else{
+ 		ret = aml_i2s_copy_capture(runtime, channel,pos, buf, count);
+ 	}
+    return ret;
+}
+
+int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
+		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+	ALSA_TRACE();
+		char* ppos;
+		int n;
+		struct snd_pcm_runtime *runtime = substream->runtime;
+
+		n = frames_to_bytes(runtime, count);
+		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+		memset(ppos, 0, n);
+		return 0;
+}
+
+static struct snd_pcm_ops aml_i2s_ops = {
+	.open		= aml_i2s_open,
+	.close		= aml_i2s_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_i2s_hw_params,
+	.hw_free	= aml_i2s_hw_free,
+	.prepare	= aml_i2s_prepare,
+	.trigger	= aml_i2s_trigger,
+	.pointer	= aml_i2s_pointer,
+	.copy 		= aml_i2s_copy,
+	.silence	=	aml_i2s_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+static u64 aml_i2s_dmamask = 0xffffffff;
+
+static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
+{
+	ALSA_TRACE();
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_i2s_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_i2s_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		pr_debug("aml-i2s:"
+				"Allocating i2s capture DMA buffer\n");
+		ret = aml_i2s_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	return ret;
+}
+
+static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
+{
+	ALSA_TRACE();
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+#ifdef CONFIG_PM
+static int aml_i2s_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_i2s_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* disable the PDC and save the PDC registers */
+	// TODO
+	printk("aml i2s suspend\n");
+
+	return 0;
+}
+
+static int aml_i2s_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_i2s_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* restore the PDC registers and enable the PDC */
+	// TODO
+	printk("aml i2s resume\n");
+	return 0;
+}
+#else
+#define aml_i2s_suspend	NULL
+#define aml_i2s_resume	NULL
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+
+static struct dentry *debugfs_root;
+static struct dentry *debugfs_regs;
+static struct dentry *debugfs_mems;
+
+static int regs_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/**
+ *	cat regs
+ */
+static ssize_t regs_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo base reg val >regs\t(set the register)\n"
+										 "	echo base reg >regs\t(show the register)\n"
+										 "	base -> c(cbus), x(aix), p(apb), h(ahb) \n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static int read_regs(char base, int reg)
+{
+	int val = 0;
+	switch(base){
+		case 'c':
+			val = READ_CBUS_REG(reg);
+			break;
+		case 'x':
+			val = READ_AXI_REG(reg);
+			break;
+		case 'p':
+			val = READ_APB_REG(reg);
+			break;
+		case 'h':
+			//val = READ_AHB_REG(reg);
+			break;
+		default:
+			break;
+	};
+	printk("\tReg %x = %x\n", reg, val);
+	return val;
+}
+
+static void write_regs(char base, int reg, int val)
+{
+	switch(base){
+		case 'c':
+			WRITE_CBUS_REG(reg, val);
+			break;
+		case 'x':
+			WRITE_AXI_REG(reg, val);
+			break;
+		case 'p':
+			WRITE_APB_REG(reg, val);
+			break;
+		case 'h':
+			//WRITE_AHB_REG(reg, val);
+			break;
+		default:
+			break;
+	};
+	printk("Write reg:%x = %x\n", reg, val);
+}
+static ssize_t regs_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long reg, value;
+	char base;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+	while (*start == ' ')
+		start++;
+
+	base = *start;
+	start ++;
+	if(!(base =='c' || base == 'x' || base == 'p' || base == 'h')){
+		return -EINVAL;
+	}
+
+	while (*start == ' ')
+		start++;
+
+	reg = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			read_regs(base, reg);
+			return -EINVAL;
+	}
+
+	write_regs(base, reg, value);
+
+	return buf_size;
+}
+
+static const struct file_operations regs_fops = {
+	.open = regs_open_file,
+	.read = regs_read_file,
+	.write = regs_write_file,
+};
+
+static int mems_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t mems_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo vmem >mems\t(read 64 bytes from vmem)\n"
+										 "	echo vmem val >mems (write int value to vmem\n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t mems_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[256];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long mem, value;
+	int i=0;
+	unsigned* addr = 0;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	while (*start == ' ')
+		start++;
+
+	mem = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			addr = (unsigned*)mem;
+			printk("%p: ", addr);
+			for(i = 0; i< 8; i++){
+				printk("%08x, ", addr[i]);
+			}
+			printk("\n");
+			return -EINVAL;
+	}
+	addr = (unsigned*)mem;
+	printk("%p: %08x\n", addr, *addr);
+	*addr = value;
+	printk("%p: %08x^\n", addr, *addr);
+
+	return buf_size;
+}
+static const struct file_operations mems_fops={
+	.open = mems_open_file,
+	.read = mems_read_file,
+	.write = mems_write_file,
+};
+
+static void aml_i2s_init_debugfs(void)
+{
+	    debugfs_root = debugfs_create_dir("aml",NULL);
+		if (IS_ERR(debugfs_root) || !debugfs_root) {
+			printk("aml: Failed to create debugfs directory\n");
+			debugfs_root = NULL;
+		}
+
+		debugfs_regs = debugfs_create_file("regs", 0644, debugfs_root, NULL, &regs_fops);
+		if(!debugfs_regs){
+			printk("aml: Failed to create debugfs file\n");
+		}
+
+		debugfs_mems = debugfs_create_file("mems", 0644, debugfs_root, NULL, &mems_fops);
+		if(!debugfs_mems){
+			printk("aml: Failed to create debugfs file\n");
+		}
+}
+static void aml_i2s_cleanup_debugfs(void)
+{
+	debugfs_remove_recursive(debugfs_root);
+}
+#else
+static void aml_i2s_init_debugfs(void)
+{
+}
+static void aml_i2s_cleanup_debugfs(void)
+{
+}
+#endif
+
+struct snd_soc_platform_driver aml_soc_platform = {
+	.ops 	= &aml_i2s_ops,
+	.pcm_new	= aml_i2s_new,
+	.pcm_free	= aml_i2s_free_dma_buffers,
+	.suspend	= aml_i2s_suspend,
+	.resume		= aml_i2s_resume,
+};
+
+EXPORT_SYMBOL_GPL(aml_soc_platform);
+
+static int aml_soc_platform_probe(struct platform_device *pdev)
+{
+    ALSA_TRACE();	
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
+}
+
+static int aml_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-i2s",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_i2s_driver = {
+	.driver = {
+			.name = "aml-i2s",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,
+	},
+
+	.probe = aml_soc_platform_probe,
+	.remove = aml_soc_platform_remove,
+};
+
+static int __init aml_alsa_audio_init(void)
+{
+	aml_i2s_init_debugfs();
+	return platform_driver_register(&aml_i2s_driver);
+}
+
+static void __exit aml_alsa_audio_exit(void)
+{
+	aml_i2s_cleanup_debugfs();
+    platform_driver_unregister(&aml_i2s_driver);
+}
+
+module_init(aml_alsa_audio_init);
+module_exit(aml_alsa_audio_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
diff --git a/sound/soc/aml/aml_i2s.h b/sound/soc/aml/aml_i2s.h
new file mode 100755
index 000000000000..e194fb8743d2
--- /dev/null
+++ b/sound/soc/aml/aml_i2s.h
@@ -0,0 +1,77 @@
+#ifndef __AML_PCM_H__
+#define __AML_PCM_H__
+
+//#define debug_printk
+#ifdef debug_printk
+#define dug_printk(fmt, args...)  printk (fmt, ## args)
+#else
+#define dug_printk(fmt, args...)
+#endif
+
+typedef struct audio_stream {
+    int stream_id;
+    int active;
+    unsigned int last_ptr;
+    unsigned int size;
+    unsigned int sample_rate;
+    unsigned int I2S_addr;
+    spinlock_t lock;
+    struct snd_pcm_substream *stream;
+	unsigned i2s_mode; //0:master, 1:slave,
+    unsigned device_type;
+} audio_stream_t;
+
+typedef struct aml_audio {
+    struct snd_card *card;
+    struct snd_pcm *pcm;
+    audio_stream_t s[2];
+} aml_audio_t;
+
+typedef struct audio_mixer_control {
+    int output_devide;
+    int input_device;
+    int direction;
+    int input_volume;
+    int output_volume;
+} audio_mixer_control_t;
+
+typedef struct audio_tone_control {
+    unsigned short * tone_source;
+    unsigned short * tone_data;
+    int tone_data_len;
+    int tone_count;
+    int tone_flag;
+}audio_tone_control_t;
+
+struct aml_pcm_dma_params{
+		char *name;			/* stream identifier */
+		struct snd_pcm_substream *substream;
+		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
+	
+};
+typedef struct aml_dai_info {
+	unsigned i2s_mode; //0:master, 1:slave,
+} aml_dai_info_t;
+enum {
+	I2S_MASTER_MODE = 0,
+	I2S_SLAVE_MODE,	
+};
+/*--------------------------------------------------------------------------*\
+ * Data types
+\*--------------------------------------------------------------------------*/
+struct aml_runtime_data {
+	struct aml_pcm_dma_params *params;
+	dma_addr_t dma_buffer;		/* physical address of dma buffer */
+	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
+
+	struct snd_pcm *pcm;
+	struct snd_pcm_substream *substream;
+	audio_stream_t s;	
+	struct timer_list timer;	// timeer for playback and capture
+    struct hrtimer hrtimer;
+};
+
+extern struct snd_soc_platform_driver aml_soc_platform;
+//extern struct aml_audio_interface aml_i2s_interface;
+
+#endif
diff --git a/sound/soc/aml/aml_dai.c b/sound/soc/aml/aml_i2s_dai.c
similarity index 67%
rename from sound/soc/aml/aml_dai.c
rename to sound/soc/aml/aml_i2s_dai.c
index 6efb230ff46d..67fac27ad6c9 100755
--- a/sound/soc/aml/aml_dai.c
+++ b/sound/soc/aml/aml_i2s_dai.c
@@ -12,14 +12,17 @@
 #include <sound/soc.h>
 
 #include <mach/hardware.h>
+//#include <sound/soc-dai.h>
 
-#include "aml_dai.h"
+#include "aml_i2s_dai.h"
 #include "aml_pcm.h"
+#include "aml_i2s.h"
 #include "aml_audio_hw.h"
 #include <linux/of.h>
 
 static aml_dai_info_t dai_info[3] = {{0}};
 #define AML_DAI_DEBUG
+//#define AML_DAI_PCM_SUPPORT 
 
 
 #define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
@@ -157,7 +160,7 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *dai)
 {
 	ALSA_DEBUG();
-    printk("****aml_dai_i2s_trigger******\n");
+    //printk("****aml_dai_i2s_trigger******\n");
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	switch (cmd) {
 		case SNDRV_PCM_TRIGGER_START:
@@ -238,96 +241,15 @@ static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 }
 
 #else /* CONFIG_PM */
-#  define aml_dai_i2s_suspend	NULL
-#  define aml_dai_i2s_resume	NULL
+#define aml_dai_i2s_suspend	NULL
+#define aml_dai_i2s_resume	NULL
 #endif /* CONFIG_PM */
 
-#ifdef AML_DAI_PCM_SUPPORT
 
-static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{	  	
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-}
-
-static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *params,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai,
-					unsigned int fmt)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	if(fmt&SND_SOC_DAIFMT_CBS_CFS)
-	snd_soc_dai_get_drvdata(dai);		
-	return 0;
-}
-
-static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
-					int clk_id, unsigned int freq, int dir)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
-{
-		
-  printk("***Entered %s:%s\n", __FILE__,__func__);
-  return 0;
-}
-
-static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
-{
-  printk("***Entered %s:%s\n", __FILE__,__func__);
-  return 0;
-}
-
-#else /* CONFIG_PM */
-#  define aml_dai_i2s_suspend	NULL
-#  define aml_dai_i2s_resume	NULL
-#endif /* CONFIG_PM */
-
-#endif
 
 #define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_96000)
 #define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
-#ifdef AML_DAI_PCM_SUPPORT
-#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
-#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-#endif
 
 static struct snd_soc_dai_ops aml_dai_i2s_ops = {
 	.startup	= aml_dai_i2s_startup,
@@ -339,18 +261,9 @@ static struct snd_soc_dai_ops aml_dai_i2s_ops = {
 	.set_sysclk	= aml_dai_set_i2s_sysclk,
 };
 
-#ifdef AML_DAI_PCM_SUPPORT
-static struct snd_soc_dai_ops aml_dai_pcm_ops = {
-	.startup	= aml_dai_pcm_startup,
-	.shutdown	= aml_dai_pcm_shutdown,
-	.prepare	= aml_dai_pcm_prepare,
-	.hw_params	= aml_dai_pcm_hw_params,
-	.set_fmt	= aml_dai_set_pcm_fmt,
-	.set_sysclk	= aml_dai_set_pcm_sysclk,
-};
-#endif
 
-struct snd_soc_dai_driver aml_dai[] = {
+
+struct snd_soc_dai_driver aml_i2s_dai[] = {
 	{	.name = "aml-i2s-dai",
 		.id = 0,
 		.suspend = aml_dai_i2s_suspend,
@@ -367,45 +280,29 @@ struct snd_soc_dai_driver aml_dai[] = {
 			.formats = AML_DAI_I2S_FORMATS,},
 		.ops = &aml_dai_i2s_ops,
 	},
-#ifdef AML_DAI_PCM_SUPPORT
-	{	.name = "aml-dai1",
-		.id = 1,
-		.suspend = aml_dai_pcm_suspend,
-		.resume = aml_dai_pcm_resume,
-		.playback = {
-			.channels_min = 1,
-			.channels_max = 1,
-			.rates = AML_DAI_PCM_RATES,
-			.formats = AML_DAI_PCM_FORMATS,},
-		.capture = {
-			.channels_min = 1,
-			.channels_max = 1,
-			.rates = AML_DAI_PCM_RATES,
-			.formats = AML_DAI_PCM_FORMATS,},
-		.ops = &aml_dai_pcm_ops,
-	},
-#endif
+
 };
 
-EXPORT_SYMBOL_GPL(aml_dai);
+EXPORT_SYMBOL_GPL(aml_i2s_dai);
 
 static const struct snd_soc_component_driver aml_component= {
 	.name		= "aml-i2s-dai",
 };
-static int aml_dai_probe(struct platform_device *pdev)
+static int aml_i2s_dai_probe(struct platform_device *pdev)
 {
 	printk(KERN_DEBUG "enter %s\n", __func__);
-#if 0
+#if 0
 	BUG_ON(pdev->id < 0);
 	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
 	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
 #else
 	return snd_soc_register_component(&pdev->dev, &aml_component,
-					 aml_dai, ARRAY_SIZE(aml_dai));
+					 aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
+
 #endif
 }
 
-static int aml_dai_remove(struct platform_device *pdev)
+static int aml_i2s_dai_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_component(&pdev->dev);
 	return 0;
@@ -421,28 +318,28 @@ static const struct of_device_id amlogic_dai_dt_match[]={
 #define amlogic_dai_dt_match NULL
 #endif
 
-static struct platform_driver aml_dai_driver = {
+static struct platform_driver aml_i2s_dai_driver = {
 	.driver = {
 		.name = "aml-i2s-dai",
 		.owner = THIS_MODULE,
 		.of_match_table = amlogic_dai_dt_match,
 	},
 
-	.probe = aml_dai_probe,
-	.remove = aml_dai_remove,
+	.probe = aml_i2s_dai_probe,
+	.remove = aml_i2s_dai_remove,
 };
 
-static int __init aml_dai_modinit(void)
+static int __init aml_i2s_dai_modinit(void)
 {
-	return platform_driver_register(&aml_dai_driver);
+	return platform_driver_register(&aml_i2s_dai_driver);
 }
-module_init(aml_dai_modinit);
+module_init(aml_i2s_dai_modinit);
 
-static void __exit aml_dai_modexit(void)
+static void __exit aml_i2s_dai_modexit(void)
 {
-	platform_driver_unregister(&aml_dai_driver);
+	platform_driver_unregister(&aml_i2s_dai_driver);
 }
-module_exit(aml_dai_modexit);
+module_exit(aml_i2s_dai_modexit);
 
 /* Module information */
 MODULE_AUTHOR("AMLogic, Inc.");
diff --git a/sound/soc/aml/aml_dai.h b/sound/soc/aml/aml_i2s_dai.h
old mode 100644
new mode 100755
similarity index 100%
rename from sound/soc/aml/aml_dai.h
rename to sound/soc/aml/aml_i2s_dai.h
diff --git a/sound/soc/aml/aml_m8.c b/sound/soc/aml/aml_m8.c
index 09b9f57d4ced..ac82ff977340 100755
--- a/sound/soc/aml/aml_m8.c
+++ b/sound/soc/aml/aml_m8.c
@@ -33,8 +33,8 @@
 #include <linux/switch.h>
 #include <linux/amlogic/saradc.h>
 
-#include "aml_dai.h"
-#include "aml_pcm.h"
+#include "aml_i2s_dai.h"
+#include "aml_i2s.h"
 #include "aml_audio_hw.h"
 #include "../codecs/aml_m8_codec.h"
 #include <mach/register.h>
@@ -500,10 +500,21 @@ static struct snd_soc_dai_link aml_codec_dai_link[] = {
         .stream_name = "AML PCM",
         .cpu_dai_name = "aml-i2s-dai.0",
         .init = aml_asoc_init,
-        .platform_name = "aml-audio.0",
+        .platform_name = "aml-i2s.0",
         .codec_name = "aml_m8_codec.0",
         .ops = &aml_asoc_ops,
     },
+#ifdef CONFIG_SND_SOC_PCM2BT
+    {
+        .name = "BT Voice",
+        .stream_name = "Voice PCM",
+        .cpu_dai_name = "aml-pcm-dai.0",
+        .codec_dai_name = "pcm2bt-pcm",
+        .platform_name = "aml-pcm.0",
+        .codec_name = "pcm2bt.0",
+        //.ops = &voice_soc_ops,
+    },
+#endif
 
     {
         .name = "AML-SPDIF",
@@ -511,10 +522,11 @@ static struct snd_soc_dai_link aml_codec_dai_link[] = {
         .cpu_dai_name = "aml-spdif-dai.0",
         .codec_dai_name = "dit-hifi",
         .init = NULL,
-        .platform_name = "aml-audio.0",
+        .platform_name = "aml-i2s.0",
         .codec_name = "spdif-dit.0",
         .ops = NULL,      
     }, 
+
 };
 
 static struct snd_soc_card aml_snd_soc_card = {
diff --git a/sound/soc/aml/aml_m_dummy.c b/sound/soc/aml/aml_m_dummy.c
index d99e480ef84b..4f0b713da586 100755
--- a/sound/soc/aml/aml_m_dummy.c
+++ b/sound/soc/aml/aml_m_dummy.c
@@ -30,8 +30,8 @@
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
 
-#include "aml_dai.h"
-#include "aml_pcm.h"
+#include "aml_i2s_dai.h"
+#include "aml_i2s.h"
 #include "aml_audio_hw.h"
 
 #ifdef CONFIG_USE_OF
diff --git a/sound/soc/aml/aml_pcm.c b/sound/soc/aml/aml_pcm.c
index 336a7cae3f02..0d632f36a512 100755
--- a/sound/soc/aml/aml_pcm.c
+++ b/sound/soc/aml/aml_pcm.c
@@ -9,7 +9,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/soundcard.h>
 #include <linux/timer.h>
-#include <linux/hrtimer.h>
 #include <linux/debugfs.h>
 #include <linux/major.h>
 
@@ -19,63 +18,29 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
-#include <linux/amlogic/rt5631.h>
+
 
 #include <mach/am_regs.h>
 #include <mach/pinmux.h>
 
-#include <linux/amlogic/amports/amaudio.h>
-
-#include <mach/mod_gate.h>
-
+#include "aml_i2s.h" 
 #include "aml_pcm.h"
-#include "aml_audio_hw.h"
-#include "aml_platform.h"
+#include "aml_audio_hw_pcm2bt.h"
 
-#define USE_HRTIMER 1
+
+#define USE_HRTIMER 0
 #define HRTIMER_PERIOD (1000000000UL/1000)
 #define DEBUG_ALSA_PLATFRORM
 
-#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-pcm]" fmt,##args)
-#ifdef DEBUG_ALSA_PLATFRORM
-#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-pcm]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-pcm] enter func %s,line %d\n",__FUNCTION__,__LINE__);
-#else
-#define ALSA_DEBUG(fmt,args...) 
-#define ALSA_TRACE()   
-#endif
-
-
-unsigned int aml_pcm_playback_start_addr = 0;
-unsigned int aml_pcm_capture_start_addr  = 0;
-
-unsigned int aml_pcm_playback_end_addr = 0;
-unsigned int aml_pcm_capture_end_addr = 0;
 
-unsigned int aml_pcm_capture_start_phy = 0;
-unsigned int aml_pcm_capture_buf_size = 0;
-unsigned int aml_pcm_playback_phy_start_addr = 0;
-unsigned int aml_pcm_capture_phy_start_addr  = 0;
-unsigned int aml_pcm_playback_phy_end_addr = 0;
-unsigned int aml_pcm_capture_phy_end_addr = 0;
-unsigned int aml_pcm_playback_off = 0;
-unsigned int aml_pcm_playback_enable = 1;
 
-unsigned int aml_iec958_playback_start_addr = 0;
-unsigned int aml_iec958_playback_start_phy = 0;
-unsigned int aml_iec958_playback_size = 0;  // in bytes
+//#define PCM_DEBUG
 
-
-static int audio_type_info = -1;
-static int audio_sr_info = -1;
-extern unsigned audioin_mode;
-
-
-
-EXPORT_SYMBOL(aml_pcm_playback_start_addr);
-EXPORT_SYMBOL(aml_pcm_capture_start_addr);
-EXPORT_SYMBOL(aml_pcm_playback_off);
-EXPORT_SYMBOL(aml_pcm_playback_enable);
+#ifdef PCM_DEBUG
+#define pcm_debug(fmt, args...)  printk (fmt, ## args)
+#else
+#define pcm_debug(fmt, args...)
+#endif
 
 
 /*--------------------------------------------------------------------------*\
@@ -84,49 +49,25 @@ EXPORT_SYMBOL(aml_pcm_playback_enable);
 /* TODO: These values were taken from the AML platform driver, check
  *	 them against real values for AML
  */
-static const struct snd_pcm_hardware aml_pcm_hardware = {
-	.info			= SNDRV_PCM_INFO_INTERLEAVED|
-							SNDRV_PCM_INFO_BLOCK_TRANSFER|
-							SNDRV_PCM_INFO_PAUSE,
-
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE,
-
-	.period_bytes_min	= 64,
-	.period_bytes_max	= 32 * 1024,
-	.periods_min		= 2,
-	.periods_max		= 1024,
-	.buffer_bytes_max	= 128 * 1024,
-
-	.rate_min = 8000,
-	.rate_max = 48000,
-	.channels_min = 2,
-	.channels_max = 8,
-	.fifo_size = 0,
-};
-
-static const struct snd_pcm_hardware aml_pcm_capture = {
+static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
 	.info			= SNDRV_PCM_INFO_INTERLEAVED|
 							SNDRV_PCM_INFO_BLOCK_TRANSFER|
-							SNDRV_PCM_INFO_MMAP |
-						 	SNDRV_PCM_INFO_MMAP_VALID |
-						  SNDRV_PCM_INFO_PAUSE,
-
+				  		    SNDRV_PCM_INFO_PAUSE,
+				  		
 	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
-	.period_bytes_min	= 64,
-	.period_bytes_max	= 32 * 1024,
+
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8*1024,
 	.periods_min		= 2,
 	.periods_max		= 1024,
 	.buffer_bytes_max	= 64 * 1024,
-
+	
 	.rate_min = 8000,
-	.rate_max = 48000,
-	.channels_min = 2,
-	.channels_max = 8,
-	.fifo_size = 0,
+    .rate_max = 8000,
+    .channels_min = 1,
+    .channels_max = 1,
 };
 
-static char snd_pcm_tmp[32*1024];
-
 
 static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
 
@@ -136,646 +77,537 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 	.mask = 0
 };
 
-/*--------------------------------------------------------------------------*/
-/*--------------------------------------------------------------------------*\
- * Helper functions
-\*--------------------------------------------------------------------------*/
-static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
-	int stream)
+unsigned int aml_pcm2bt_playback_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_buffer_size = 0;
+
+unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
+
+#if 0
+static void aml_pcm_config_tx(u32 addr, u32 size)
 {
-	ALSA_TRACE();
-	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;
+    pcm_debug("****%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_out_set_buf(addr, size);
+}
 
-	size_t size = 0;
-	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		    size = aml_pcm_hardware.buffer_bytes_max;
-		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		    buf->dev.dev = pcm->card->dev;
-		    buf->private_data = NULL;
-            /* one size for i2s output, another for 958, and 128 for alignment */
-		    buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
-					  &buf->addr, GFP_KERNEL);
-		    printk("aml-pcm %d:"
-		    "playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
-		    (void *) buf->area,
-		    (void *) buf->addr,
-		    size);
-        }else{
-
-		size = aml_pcm_capture.buffer_bytes_max;
-		buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		buf->dev.dev = pcm->card->dev;
-		buf->private_data = NULL;
-		buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
-					  &buf->addr, GFP_KERNEL);
-		    printk("aml-pcm %d:"
-		    "capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
-		    (void *) buf->area,
-		    (void *) buf->addr,
-		    size);
-	    }
-
-	    if (!buf->area)
-		    return -ENOMEM;
-    
-	    buf->bytes = size;
-	    return 0;
+static void aml_pcm_config_rx(u32 addr, u32 size)
+{
+    pcm_debug("****%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_in_set_buf(addr, size);
+}
 
+static void aml_pcm_start_tx(void)
+{
+    pcm_debug( "***%s", __FUNCTION__);
+    pcm_out_enable(1);
 }
-/*--------------------------------------------------------------------------*\
- * ISR
-\*--------------------------------------------------------------------------*/
 
+static void aml_pcm_start_rx(void)
+{
+    pcm_debug("*****%s", __FUNCTION__);
+    pcm_in_enable(1);
+}
 
-/*--------------------------------------------------------------------------*\
- * PCM operations
-\*--------------------------------------------------------------------------*/
-static int aml_pcm_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
+static void aml_pcm_stop_tx(void)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-//	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
-	audio_stream_t *s = &prtd->s;
-
-	/* this may get called several times by oss emulation
-	 * with different params */
-
-	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
-	runtime->dma_bytes = params_buffer_bytes(params);
-	ALSA_PRINT("runtime dma_bytes %d,stream type \n",runtime->dma_bytes,substream->stream);
-	s->I2S_addr = runtime->dma_addr;
-
-    /*
-     * Both capture and playback need to reset the last ptr to the start address,
-       playback and capture use different address calculate, so we reset the different
-       start address to the last ptr
-   * */
-    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-        /* s->last_ptr must initialized as dma buffer's start addr */
-        s->last_ptr = runtime->dma_addr;
-    }else{
-
-	s->last_ptr = 0;
+    pcm_debug("*****%s", __FUNCTION__);
+    pcm_out_enable(0);
+}
+
+static void aml_pcm_stop_rx(void)
+{
+    pcm_debug("****%s", __FUNCTION__);
+    pcm_in_enable(0);
+}
+#endif
+static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_out_rd_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_in_wr_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
+{
+    struct snd_pcm_substream *substream = prtd->substream;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned int offset = 0;
+    unsigned int size = 0;
+    
+    if (prtd->running && snd_pcm_running(substream)) {
+    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    		offset = aml_pcm_offset_tx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+    	} else {
+            int rx_overflow = 0;
+    		offset = aml_pcm_offset_rx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+            rx_overflow = pcm_in_fifo_int() & (1 << 2);
+            if (rx_overflow) {
+                printk(KERN_WARNING "%s AUDIN_FIFO overflow !!\n", __FUNCTION__);
+            }
+    	}
     }
 
-	return 0;
+    prtd->buffer_offset = offset;
+    prtd->data_size += size;
+    if (prtd->data_size >= frames_to_bytes(runtime, runtime->period_size)) {
+        prtd->peroid_elapsed++;
+    }
+
+    pcm_debug(KERN_DEBUG "%s buffer offset: %d data size: %d peroid size: %d peroid elapsed: %d\n",
+                __FUNCTION__, prtd->buffer_offset, prtd->data_size, frames_to_bytes(runtime, runtime->period_size), prtd->peroid_elapsed);
 }
 
-static int aml_pcm_hw_free(struct snd_pcm_substream *substream)
+static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
 {
-	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	struct aml_pcm_dma_params *params = prtd->params;
-	if (params != NULL) {
+    prtd->timer.expires = jiffies + prtd->timer_period;
+	add_timer(&prtd->timer);
+}
 
-	}
+static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+	aml_pcm2bt_timer_rearm(prtd);
+    prtd->running = 1;
+	spin_unlock(&prtd->lock);
+	return 0;
+}
 
+static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+    prtd->running = 0;
+	del_timer(&prtd->timer);
+	spin_unlock(&prtd->lock);
 	return 0;
 }
 
 
-static int aml_pcm_prepare(struct snd_pcm_substream *substream)
+static void aml_pcm2bt_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	unsigned long flags;
+	unsigned int elapsed = 0;
+    unsigned int datasize = 0;
+	
+	spin_lock_irqsave(&prtd->lock, flags);
+    aml_pcm2bt_timer_update(prtd);
+    aml_pcm2bt_timer_rearm(prtd);
+	elapsed = prtd->peroid_elapsed;
+    datasize = prtd->data_size;
+    if (elapsed) {
+        prtd->peroid_elapsed--;
+        prtd->data_size -= frames_to_bytes(runtime, runtime->period_size);
+    }
+	spin_unlock_irqrestore(&prtd->lock, flags);
+	if (elapsed) {
+        if (elapsed > 1) {
+            printk(KERN_WARNING "PCM timer callback not fast enough (elapsed periods: %d data_bytes: %d period_bytes: %d)!",
+                    elapsed, datasize, frames_to_bytes(runtime, runtime->period_size));
+        }
+		snd_pcm_period_elapsed(prtd->substream);
+    }
+}
+
+static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
 {
-	ALSA_TRACE();
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	init_timer(&prtd->timer);
+    prtd->timer_period = 1;
+	prtd->timer.data = (unsigned long)substream;
+	prtd->timer.function = aml_pcm2bt_timer_callback;
+    prtd->running = 0;
 	return 0;
 }
 
-static int aml_pcm_trigger(struct snd_pcm_substream *substream,
-	int cmd)
+static int aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
 {
-	ALSA_TRACE();
-	struct snd_pcm_runtime *rtd = substream->runtime;
-	struct aml_runtime_data *prtd = rtd->private_data;
-	audio_stream_t *s = &prtd->s;
-	int ret = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	size_t size = params_buffer_bytes(params);
+    int ret = 0;
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:		
-
-#if USE_HRTIMER == 0
-	  del_timer_sync(&prtd->timer);
-#endif      
-	  spin_lock(&s->lock);
-#if USE_HRTIMER == 0
-	  prtd->timer.expires = jiffies + 1;
-	  del_timer(&prtd->timer);
-	  add_timer(&prtd->timer);
-#endif
+	ret = snd_pcm_lib_malloc_pages(substream, size);
+    if (ret < 0) {
+        printk(KERN_ERR "%s snd_pcm_lib_malloc_pages return: %d\n", __FUNCTION__, ret);
+    } else {
+        prtd->buffer_start = runtime->dma_addr;
+        prtd->buffer_size = runtime->dma_bytes;
+        pcm_debug(KERN_DEBUG "%s dma_addr: 0x%08x dma_bytes: 0x%x\n", __FUNCTION__, runtime->dma_addr, runtime->dma_bytes);
+
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_playback_phy_buffer_size = runtime->dma_bytes;
+        } else {
+            aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
+        }
+    }
 
-	  s->active = 1;
-	  spin_unlock(&s->lock);
-	  break;		/* SNDRV_PCM_TRIGGER_START */
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-	case SNDRV_PCM_TRIGGER_STOP:
-		// TODO
-	    spin_lock(&s->lock);
-	    s->active = 0;
-	    spin_unlock(&s->lock);
-	    break;
-	default:
-		ret = -EINVAL;
-	}
-/*	if(clock_gating_status&clock_gating_playback){
-		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			aml_pcm_work.substream = substream;
-	}
-	else
-		aml_pcm_work.substream = substream;
+    return ret;
+}
+
+static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	snd_pcm_lib_free_pages(substream);
 
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        aml_pcm2bt_playback_phy_buffer_addr = 0;
+        aml_pcm2bt_playback_phy_buffer_size = 0;
+    } else {
+        aml_pcm2bt_capture_phy_buffer_addr = 0;
+        aml_pcm2bt_capture_phy_buffer_size = 0;
+    }
 
-	if(clock_gating_status)
-	{
-		schedule_work(&aml_pcm_work.aml_codec_workqueue);
-	}
-	*/
-	//schedule_work(&aml_pcm_work.aml_codec_workqueue);
-	return ret;
+    return 0;
 }
 
-static snd_pcm_uframes_t aml_pcm_pointer(
-	struct snd_pcm_substream *substream)
+static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
 {
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    return 0;
+#if 0
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;
-
-	unsigned int addr, ptr;
-
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		if(s->device_type == AML_AUDIO_I2SOUT)
-			ptr = read_i2s_rd_ptr();
-		else
-			ptr = read_iec958_rd_ptr();
-	    addr = ptr - s->I2S_addr;
-	    return bytes_to_frames(runtime, addr);
-	}else{
-		if(s->device_type == AML_AUDIO_I2SIN)
-			ptr = audio_in_i2s_wr_ptr();
-		else
-			ptr = audio_in_spdif_wr_ptr();				
-			addr = ptr - s->I2S_addr;
-			return bytes_to_frames(runtime, addr)/2;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        pcm_debug(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_tx(prtd->buffer_start, prtd->buffer_size);
+       // aml_pcm2bt_playback_buffer_addr = (unsigned int)runtime->dma_area;
+       // aml_pcm2bt_playback_buffer_size = runtime->dma_bytes;
+	} else {
+	    pcm_debug(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_rx(prtd->buffer_start, prtd->buffer_size);
+        //aml_pcm2bt_capture_buffer_addr = (unsigned int)runtime->dma_area;
+        //aml_pcm2bt_capture_buffer_size = runtime->dma_bytes;
 	}
 
+    memset(runtime->dma_area, 0, runtime->dma_bytes);
+    prtd->buffer_offset = 0;
+    prtd->data_size = 0;
+    prtd->peroid_elapsed = 0;
+#endif
 	return 0;
-}	
-static enum hrtimer_restart aml_pcm_hrtimer_callback(struct hrtimer* timer)
-{
-  struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
-  audio_stream_t* s = &prtd->s;
-  struct snd_pcm_substream* substream = prtd->substream;
-  struct snd_pcm_runtime* runtime= substream->runtime;
-  
-  unsigned int last_ptr, size;
-  unsigned long flag;
-  //printk("------------->hrtimer start\n");
-  if(s->active == 0){
-    hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-    return HRTIMER_RESTART;
-  }
-  //spin_lock_irqsave(&s->lock, flag);
-
-  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-      last_ptr = read_i2s_rd_ptr();
-      if(last_ptr < s->last_ptr){
-        size = runtime->dma_bytes + last_ptr - s->last_ptr;
-      }else{
-        size = last_ptr - s->last_ptr;
-      }
-      s->last_ptr = last_ptr;
-      s->size += bytes_to_frames(substream->runtime, size);
-      if(s->size >= runtime->period_size){
-        s->size %= runtime->period_size;
-        snd_pcm_period_elapsed(substream);
-      }
-  }else{
-      last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) /2;
-      if(last_ptr < s->last_ptr){
-        size = runtime->dma_bytes + last_ptr - s->last_ptr;
-      }else{
-        size = last_ptr - s->last_ptr;
-      }
-      s->last_ptr = last_ptr;
-      s->size += bytes_to_frames(runtime, size);
-      if(s->size >= runtime->period_size){
-        s->size %= runtime->period_size;
-        snd_pcm_period_elapsed(substream);
-      }
-  }
-  //spin_unlock_irqrestore(&s->lock, flag);
-  hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-  return HRTIMER_RESTART;
 }
 
-static void aml_pcm_timer_callback(unsigned long data)
+static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_runtime_data *prtd = runtime->private_data;
-		audio_stream_t *s = &prtd->s;
-
-    unsigned int last_ptr, size;
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-	{
-		if(s->active == 1)
-		{
-			spin_lock(&s->lock);
-			if(s->device_type == AML_AUDIO_I2SOUT)
-				last_ptr = read_i2s_rd_ptr();
-			else
-				last_ptr = read_iec958_rd_ptr();							
-						if (last_ptr < s->last_ptr) {
-				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
-				    } else {
-				        size = last_ptr - (s->last_ptr);
-				    }
-    				s->last_ptr = last_ptr;
-    				s->size += bytes_to_frames(substream->runtime, size);
-    				if (s->size >= runtime->period_size) {
-				        s->size %= runtime->period_size;
-				        spin_unlock(&s->lock);
-				        snd_pcm_period_elapsed(substream);
-				        spin_lock(&s->lock);
-				    }
-				    mod_timer(&prtd->timer, jiffies + 1);
-   					spin_unlock(&s->lock);
-				}else{
-						 mod_timer(&prtd->timer, jiffies + 1);
-				}
-		}
-	else
-	{
-		if(s->active == 1)
-		{
-			spin_lock(&s->lock);
-			if(s->device_type == AML_AUDIO_I2SIN)			
-				last_ptr = audio_in_i2s_wr_ptr() ;
-			else
-				last_ptr = audio_in_spdif_wr_ptr();				
-			if (last_ptr < s->last_ptr) {
-				size = runtime->dma_bytes + (last_ptr - (s->last_ptr))/2;
-			} else {
-				size = (last_ptr - (s->last_ptr))/2;
-			}
-			s->last_ptr = last_ptr;
-			s->size += bytes_to_frames(substream->runtime, size);
-			if (s->size >= runtime->period_size) {
-				s->size %= runtime->period_size;
-				spin_unlock(&s->lock);
-				snd_pcm_period_elapsed(substream);
-				spin_lock(&s->lock);
-			}
-			mod_timer(&prtd->timer, jiffies + 1);
-			spin_unlock(&s->lock);
-		}
-		else
-		{
-			mod_timer(&prtd->timer, jiffies + 1);
-		}
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+    	case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_RESUME:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+/*    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_start_tx();
+    		else
+    			aml_pcm_start_rx();
+ */   			
+            aml_pcm2bt_timer_start(prtd);
+    		break;
+    	case SNDRV_PCM_TRIGGER_STOP:
+    	case SNDRV_PCM_TRIGGER_SUSPEND:
+    	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            aml_pcm2bt_timer_stop(prtd);
+/*    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_stop_tx();
+    		else
+    			aml_pcm_stop_rx();
+*/
+    		break;
+    	default:
+    		ret = -EINVAL;
 	}
+
+	return ret;
 }
 
+static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    snd_pcm_uframes_t frames;
+        
+	pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    frames = bytes_to_frames(runtime, (ssize_t)prtd->buffer_offset);
 
-static int aml_pcm_open(struct snd_pcm_substream *substream)
+	return frames;
+}
+
+static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
 {
-	ALSA_TRACE();
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd;
-	int ret = 0;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		snd_soc_set_runtime_hwparams(substream, &aml_pcm_hardware);
-	}else{
-		snd_soc_set_runtime_hwparams(substream, &aml_pcm_capture);
-	}
+	struct aml_pcm_runtime_data *prtd;
+	int ret;
 
-    /* ensure that peroid size is a multiple of 32bytes */
+	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
+
+    /* Ensure that peroid size is a multiple of 32bytes */
 	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
-	if (ret < 0)
-	{
-		printk("set period bytes constraint error\n");
+	if (ret < 0) {
+		printk(KERN_ERR "set period bytes constraint error\n");
 		goto out;
 	}
 
-	/* ensure that buffer size is a multiple of period size */
+	/* Ensure that buffer size is a multiple of period size */
 	ret = snd_pcm_hw_constraint_integer(runtime,
-						SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret < 0)
-	{
-		printk("set period error\n");
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+        printk(KERN_ERR "set periods constraint error\n");
 		goto out;
-	}
+    }
 
-	prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
 	if (prtd == NULL) {
-		printk("alloc aml_runtime_data error\n");
+        printk(KERN_ERR "out of memory\n");
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	//WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);			
-	//WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
-	prtd->substream = substream;
-#if USE_HRTIMER == 0    
-	prtd->timer.function = &aml_pcm_timer_callback;
-	prtd->timer.data = (unsigned long)substream;
-	init_timer(&prtd->timer);
-#else
-    hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-    prtd->hrtimer.function = aml_pcm_hrtimer_callback;
-    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
-
-
-    printk("hrtimer inited..\n");
-#endif
-	runtime->private_data = prtd;
+    runtime->private_data = prtd;
+    aml_pcm2bt_timer_create(substream);
+    prtd->substream = substream;
+	spin_lock_init(&prtd->lock);
 
-	spin_lock_init(&prtd->s.lock);
- out:
+    return 0;
+out:
 	return ret;
 }
 
-static int aml_pcm_close(struct snd_pcm_substream *substream)
+
+static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
 {
-	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	audio_stream_t *s = &prtd->s;	
-	ALSA_TRACE();
-	if(s->device_type == AML_AUDIO_SPDIFOUT){
-	//	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);
-
-    }			
-#if USE_HRTIMER == 0
-	del_timer_sync(&prtd->timer);
-#else
-    hrtimer_cancel(&prtd->hrtimer);
-#endif
-	kfree(prtd);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+   
+    printk(KERN_INFO "enter %s type: %d\n", __FUNCTION__, substream->stream);
+    if (prtd)
+	    kfree(runtime->private_data);
 	return 0;
 }
 
 
-static int aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
+static int aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
 {
-    int res = 0;
-    int n;
-    int i = 0, j = 0;
-    int  align = runtime->channels * 32 / runtime->byte_align;
-    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
-    n = frames_to_bytes(runtime, count);
-    if(aml_pcm_playback_enable == 0)
-      return res;
-	if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count)))
-	{
-		if(1/*runtime->channels == 2*/){
-			if(runtime->format == SNDRV_PCM_FORMAT_S16_LE ){
-        int16_t * tfrom, *to, *left, *right;
-        tfrom = (int16_t*)buf;
-        to = (int16_t*)hwbuf;
-
-        left = to;
-		right = to + 16;
-		if (pos % align) {
-		    printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-		}
-		for (j = 0; j < n; j += 64) {
-		    for (i = 0; i < 16; i++) {
-	          *left++ = (*tfrom++) ;
-	          *right++ = (*tfrom++);
-		    }
-		    left += 16;
-		    right += 16;
-		 }
-      }else if(runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24){
-        int32_t *tfrom, *to, *left, *right;
-        tfrom = (int32_t*)buf;
-        to = (int32_t*) hwbuf;
-
-        left = to;
-        right = to + 8;
-
-        if(pos % align){
-          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-        }
-        for(j=0; j< n; j+= 64){
-          for(i=0; i<8; i++){
-            *left++  =  (*tfrom ++);
-            *right++  = (*tfrom ++);
-          }
-          left += 8;
-          right += 8;
-        }
-
-      }else if(runtime->format == SNDRV_PCM_FORMAT_S32_LE && I2S_MODE == AIU_I2S_MODE_PCM32){
-        int32_t *tfrom, *to, *left, *right;
-        tfrom = (int32_t*)buf;
-        to = (int32_t*) hwbuf;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    unsigned char* hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    unsigned int wrptr = 0;
+    int ret = 0;
 
-        left = to;
-        right = to + 8;
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
 
-        if(pos % align){
-          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-        }
-		
-		if(runtime->channels == 8){
-			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-			lf  = to;
-			cf  = to + 8*1;
-			rf  = to + 8*2;
-			ls  = to + 8*3;
-			rs  = to + 8*4;
-			lef = to + 8*5;
-			sbl = to + 8*6;
-			sbr = to + 8*7;
-			for (j = 0; j < n; j += 256) {
-		    	for (i = 0; i < 8; i++) {
-	         		*lf++  = (*tfrom ++)>>8;
-	          		*cf++  = (*tfrom ++)>>8;
-					*rf++  = (*tfrom ++)>>8;
-					*ls++  = (*tfrom ++)>>8;
-					*rs++  = (*tfrom ++)>>8;
-					*lef++ = (*tfrom ++)>>8;
-					*sbl++ = (*tfrom ++)>>8;
-					*sbr++ = (*tfrom ++)>>8;
-		    	}
-		    	lf  += 7*8;
-		    	cf  += 7*8;
-				rf  += 7*8;
-				ls  += 7*8;
-				rs  += 7*8;
-				lef += 7*8;
-				sbl += 7*8;
-				sbr += 7*8;
-		 	}
-		}
-		else {
-        for(j=0; j< n; j+= 64){
-          for(i=0; i<8; i++){
-            *left++  =  (*tfrom ++)>>8;
-            *right++  = (*tfrom ++)>>8;
-          }
-          left += 8;
-          right += 8;
+	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy from user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        wrptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (wrptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            wrptr = prtd->buffer_start + prtd->buffer_size;
         }
-      	}
-      }
-
-	}else{
-	  res = -EFAULT;
-	}
-
-	return res;
+        pcm_out_set_wr_ptr(wrptr);
     }
+
+    return ret;
 }
 
+	
 
-static int aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
+
+static int aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
 {
-		unsigned int *tfrom, *left, *right;
-		unsigned short *to;
-		int res = 0;
-		int n;
-    int i = 0, j = 0;
-    unsigned int t1, t2;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;	   
-    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
-    unsigned char r_shift = 8;	
-	if(s->device_type == AML_AUDIO_SPDIFIN) //spdif in
-    {
-    	r_shift = 12;
-    }
-    to = (unsigned short *)snd_pcm_tmp;//buf;
-    tfrom = (unsigned int *)hwbuf;	// 32bit buffer
-    n = frames_to_bytes(runtime, count);
-    if(n > 32*1024){
-		printk("Too many datas to read,please enlarge the snd_pcm_tmp buffer size\n");
-      return -EINVAL;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    signed short *hwbuf = (signed short*)(runtime->dma_area + frames_to_bytes(runtime, pos));
+    unsigned int rdptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy to user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        //memset(hwbuf, 0xff, frames_to_bytes(runtime, count));
+        rdptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (rdptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            rdptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_in_set_rd_ptr(rdptr);
     }
-	if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count)))
-	{
-		if(runtime->channels == 2){
-				left = tfrom;
-		    right = tfrom + 8;
-		    if (pos % 8) {
-		        printk("audio data unligned\n");
-		    }
-		    if((n*2)%64){
-		    		printk("audio data unaligned 64 bytes\n");
-		    }
-		    for (j = 0; j < n*2 ; j += 64) {
-		        for (i = 0; i < 8; i++) {
-		        	t1 = (*left++);
-		        	t2 = (*right++);
-		        	//printk("%08x,%08x,", t1, t2);
-	              *to++ = (unsigned short)((t1>>r_shift)&0xffff);
-	           //   *to++ = (unsigned short)((t1>>8)&0xffff);//copy left channel to right
-	              *to++ = (unsigned short)((t2>>r_shift)&0xffff);
-		         }
-		         //printk("\n");
-		        left += 8;
-		        right += 8;
-			}
-		}
-		else{
-		    }
-		}
-        res = copy_to_user(buf, snd_pcm_tmp,n);
-		return res;
+    return ret;
 }
 
-static int aml_pcm_copy(struct snd_pcm_substream *substream, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
+static int aml_pcm2bt_copy(struct snd_pcm_substream *substream, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
 {
     struct snd_pcm_runtime *runtime = substream->runtime;
     int ret = 0;
 
- 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
- 		ret = aml_pcm_copy_playback(runtime, channel,pos, buf, count);
- 	}else{
- 		ret = aml_pcm_copy_capture(runtime, channel,pos, buf, count);
- 	}
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        ret = aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
+    } else {
+        ret = aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
+    }
+
     return ret;
 }
 
-int aml_pcm_silence(struct snd_pcm_substream *substream, int channel,
-		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+
+static int aml_pcm2bt_silence(struct snd_pcm_substream *substream, int channel, 
+    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
 {
-	ALSA_TRACE();
-		char* ppos;
-		int n;
-		struct snd_pcm_runtime *runtime = substream->runtime;
-
-		n = frames_to_bytes(runtime, count);
-		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
-		memset(ppos, 0, n);
-		return 0;
-}
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned char* ppos = NULL;
+    ssize_t n;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    n = frames_to_bytes(runtime, count);
+    ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+    memset(ppos, 0, n);
 
-static struct snd_pcm_ops aml_pcm_ops = {
-	.open		= aml_pcm_open,
-	.close		= aml_pcm_close,
+    return 0;
+}
+                        
+static struct snd_pcm_ops aml_pcm2bt_ops = {
+	.open		= aml_pcm2bt_open,
+	.close		= aml_pcm2bt_close,
 	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= aml_pcm_hw_params,
-	.hw_free	= aml_pcm_hw_free,
-	.prepare	= aml_pcm_prepare,
-	.trigger	= aml_pcm_trigger,
-	.pointer	= aml_pcm_pointer,
-	.copy 		= aml_pcm_copy,
-	.silence	=	aml_pcm_silence,
+	.hw_params	= aml_pcm2bt_hw_params,
+	.hw_free	= aml_pcm2bt_hw_free,
+	.prepare	= aml_pcm2bt_prepare,
+	.trigger	= aml_pcm2bt_trigger,
+	.pointer	= aml_pcm2bt_pointer,
+	.copy 		= aml_pcm2bt_copy,
+	.silence	= aml_pcm2bt_silence,
 };
 
 
 /*--------------------------------------------------------------------------*\
  * ASoC platform driver
 \*--------------------------------------------------------------------------*/
-static u64 aml_pcm_dmamask = 0xffffffff;
 
-static int aml_pcm_new(struct snd_soc_pcm_runtime *rtd)
+static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
+
+static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
 {
-	ALSA_TRACE();
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+    //struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
+
+    printk(KERN_DEBUG "enter %s stream: %d\n", __FUNCTION__, stream);
+    
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area) {
+        printk(KERN_ERR "%s dma_alloc_coherent failed (size: %d)!\n", __FUNCTION__, size);
+		return -ENOMEM;
+    }
+
+	buf->bytes = size;
+    printk(KERN_INFO "%s allcoate buf->area: %p buf->addr: 0x%x buf->bytes: %d\n",
+                __FUNCTION__, buf->area, buf->addr, buf->bytes);  
+	return 0;
+}
+
+static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
 	int ret = 0;
        struct snd_soc_card *card = rtd->card;
        struct snd_pcm *pcm =rtd->pcm ;  
+       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
+       pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
+    
 	if (!card->dev->dma_mask)
-		card->dev->dma_mask = &aml_pcm_dmamask;
+		card->dev->dma_mask = &aml_pcm2bt_dmamask;
 	if (!card->dev->coherent_dma_mask)
-		card->dev->coherent_dma_mask = 0xffffffff;
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
 
 	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
-		ret = aml_pcm_preallocate_dma_buffer(pcm,
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
 			SNDRV_PCM_STREAM_PLAYBACK);
 		if (ret)
 			goto out;
 	}
 
 	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		pr_debug("aml-pcm:"
-				"Allocating PCM capture DMA buffer\n");
-		ret = aml_pcm_preallocate_dma_buffer(pcm,
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
 			SNDRV_PCM_STREAM_CAPTURE);
 		if (ret)
 			goto out;
 	}
 
- out:
+out:
 	return ret;
 }
 
-static void aml_pcm_free_dma_buffers(struct snd_pcm *pcm)
+static void aml_pcm2bt_free(struct snd_pcm *pcm)
 {
-	ALSA_TRACE();
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	int stream;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
@@ -784,310 +616,40 @@ static void aml_pcm_free_dma_buffers(struct snd_pcm *pcm)
 		buf = &substream->dma_buffer;
 		if (!buf->area)
 			continue;
+
 		dma_free_coherent(pcm->card->dev, buf->bytes,
-				  buf->area, buf->addr);
+				      buf->area, buf->addr);
 		buf->area = NULL;
 	}
 }
 
-#ifdef CONFIG_PM
-static int aml_pcm_suspend(struct snd_soc_dai *dai)
-{
-	struct snd_pcm_runtime *runtime = dai->runtime;
-	struct aml_runtime_data *prtd;
-	struct aml_pcm_dma_params *params;
-	if (!runtime)
-		return 0;
-
-	prtd = runtime->private_data;
-	params = prtd->params;
-
-	/* disable the PDC and save the PDC registers */
-	// TODO
-	printk("aml pcm suspend\n");
-
-	return 0;
-}
-
-static int aml_pcm_resume(struct snd_soc_dai *dai)
-{
-	struct snd_pcm_runtime *runtime = dai->runtime;
-	struct aml_runtime_data *prtd;
-	struct aml_pcm_dma_params *params;
-	if (!runtime)
-		return 0;
-
-	prtd = runtime->private_data;
-	params = prtd->params;
-
-	/* restore the PDC registers and enable the PDC */
-	// TODO
-	printk("aml pcm resume\n");
-	return 0;
-}
-#else
-#define aml_pcm_suspend	NULL
-#define aml_pcm_resume	NULL
-#endif
-
-#ifdef CONFIG_DEBUG_FS
-
-static struct dentry *debugfs_root;
-static struct dentry *debugfs_regs;
-static struct dentry *debugfs_mems;
-
-static int regs_open_file(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-/**
- *	cat regs
- */
-static ssize_t regs_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = sprintf(buf, "Usage: \n"
-										 "	echo base reg val >regs\t(set the register)\n"
-										 "	echo base reg >regs\t(show the register)\n"
-										 "	base -> c(cbus), x(aix), p(apb), h(ahb) \n"
-									);
-
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-	kfree(buf);
-
-	return ret;
-}
-
-static int read_regs(char base, int reg)
-{
-	int val = 0;
-	switch(base){
-		case 'c':
-			val = READ_CBUS_REG(reg);
-			break;
-		case 'x':
-			val = READ_AXI_REG(reg);
-			break;
-		case 'p':
-			val = READ_APB_REG(reg);
-			break;
-		case 'h':
-			//val = READ_AHB_REG(reg);
-			break;
-		default:
-			break;
-	};
-	printk("\tReg %x = %x\n", reg, val);
-	return val;
-}
-
-static void write_regs(char base, int reg, int val)
-{
-	switch(base){
-		case 'c':
-			WRITE_CBUS_REG(reg, val);
-			break;
-		case 'x':
-			WRITE_AXI_REG(reg, val);
-			break;
-		case 'p':
-			WRITE_APB_REG(reg, val);
-			break;
-		case 'h':
-			//WRITE_AHB_REG(reg, val);
-			break;
-		default:
-			break;
-	};
-	printk("Write reg:%x = %x\n", reg, val);
-}
-static ssize_t regs_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[32];
-	int buf_size = 0;
-	char *start = buf;
-	unsigned long reg, value;
-	char base;
-
-	buf_size = min(count, (sizeof(buf)-1));
-
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-	while (*start == ' ')
-		start++;
-
-	base = *start;
-	start ++;
-	if(!(base =='c' || base == 'x' || base == 'p' || base == 'h')){
-		return -EINVAL;
-	}
-
-	while (*start == ' ')
-		start++;
-
-	reg = simple_strtoul(start, &start, 16);
-
-	while (*start == ' ')
-		start++;
-
-	if (strict_strtoul(start, 16, &value))
-	{
-			read_regs(base, reg);
-			return -EINVAL;
-	}
-
-	write_regs(base, reg, value);
-
-	return buf_size;
-}
-
-static const struct file_operations regs_fops = {
-	.open = regs_open_file,
-	.read = regs_read_file,
-	.write = regs_write_file,
-};
-
-static int mems_open_file(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-static ssize_t mems_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = sprintf(buf, "Usage: \n"
-										 "	echo vmem >mems\t(read 64 bytes from vmem)\n"
-										 "	echo vmem val >mems (write int value to vmem\n"
-									);
-
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-	kfree(buf);
-
-	return ret;
-}
-
-static ssize_t mems_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[256];
-	int buf_size = 0;
-	char *start = buf;
-	unsigned long mem, value;
-	int i=0;
-	unsigned* addr = 0;
-
-	buf_size = min(count, (sizeof(buf)-1));
-
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	while (*start == ' ')
-		start++;
-
-	mem = simple_strtoul(start, &start, 16);
-
-	while (*start == ' ')
-		start++;
-
-	if (strict_strtoul(start, 16, &value))
-	{
-			addr = (unsigned*)mem;
-			printk("%p: ", addr);
-			for(i = 0; i< 8; i++){
-				printk("%08x, ", addr[i]);
-			}
-			printk("\n");
-			return -EINVAL;
-	}
-	addr = (unsigned*)mem;
-	printk("%p: %08x\n", addr, *addr);
-	*addr = value;
-	printk("%p: %08x^\n", addr, *addr);
-
-	return buf_size;
-}
-static const struct file_operations mems_fops={
-	.open = mems_open_file,
-	.read = mems_read_file,
-	.write = mems_write_file,
+#if 0
+struct aml_audio_interface aml_pcm_interface = {
+    .id = AML_AUDIO_PCM,
+    .name = "PCM",
+    .pcm_ops = &aml_pcm2bt_ops,
+    .pcm_new = aml_pcm2bt_new,
+    .pcm_free =  aml_pcm2bt_free,
 };
 
-static void aml_pcm_init_debugfs(void)
-{
-	    debugfs_root = debugfs_create_dir("aml",NULL);
-		if (IS_ERR(debugfs_root) || !debugfs_root) {
-			printk("aml: Failed to create debugfs directory\n");
-			debugfs_root = NULL;
-		}
-
-		debugfs_regs = debugfs_create_file("regs", 0644, debugfs_root, NULL, &regs_fops);
-		if(!debugfs_regs){
-			printk("aml: Failed to create debugfs file\n");
-		}
-
-		debugfs_mems = debugfs_create_file("mems", 0644, debugfs_root, NULL, &mems_fops);
-		if(!debugfs_mems){
-			printk("aml: Failed to create debugfs file\n");
-		}
-}
-static void aml_pcm_cleanup_debugfs(void)
-{
-	debugfs_remove_recursive(debugfs_root);
-}
-#else
-static void aml_pcm_init_debugfs(void)
-{
-}
-static void aml_pcm_cleanup_debugfs(void)
-{
-}
 #endif
 
-struct aml_audio_interface aml_i2s_interface = {
-    .id = AML_AUDIO_I2S,
-    .name = "I2S",
-    .pcm_ops = &aml_pcm_ops,
-    .pcm_new = aml_pcm_new,
-    .pcm_free =  aml_pcm_free_dma_buffers,
-};
-#if 0
-struct snd_soc_platform_driver aml_soc_platform = {
-	.ops 	= &aml_pcm_ops,
-	.pcm_new	= aml_pcm_new,
-	.pcm_free	= aml_pcm_free_dma_buffers,
-	.suspend	= aml_pcm_suspend,
-	.resume		= aml_pcm_resume,
+struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
+	.ops 	= &aml_pcm2bt_ops,
+	.pcm_new	= aml_pcm2bt_new,
+	.pcm_free	= aml_pcm2bt_free,
+	//.suspend	= aml_pcm_suspend,
+	//.resume		= aml_pcm_resume,
 };
+EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
 
-EXPORT_SYMBOL_GPL(aml_soc_platform);
-
-static int aml_soc_platform_probe(struct platform_device *pdev)
+static int aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
 {
-	INIT_WORK(&aml_pcm_work.aml_codec_workqueue, aml_codec_power_switch_queue);
-	/* get audioin cfg data from board */
-	if(pdev->dev.platform_data){
-		audioin_mode = *(unsigned *)pdev->dev.platform_data;
-		printk("AML soc audio in mode =============   %d \n",audioin_mode);
-	}	
-	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
 }
 
-static int aml_soc_platform_remove(struct platform_device *pdev)
+static int aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
 {
 	snd_soc_unregister_platform(&pdev->dev);
 	return 0;
@@ -1095,7 +657,7 @@ static int aml_soc_platform_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_audio_dt_match[]={
-	{	.compatible = "amlogic,aml-audio",
+	{	.compatible = "amlogic,aml-pcm",
 	},
 	{},
 };
@@ -1103,33 +665,34 @@ static const struct of_device_id amlogic_audio_dt_match[]={
 #define amlogic_audio_dt_match NULL
 #endif
 
-static struct platform_driver aml_pcm_driver = {
+
+static struct platform_driver aml_platform_pcm2bt_driver = {
 	.driver = {
-			.name = "aml-audio",
+			.name = "aml-pcm",
 			.owner = THIS_MODULE,
 			.of_match_table = amlogic_audio_dt_match,
 	},
 
-	.probe = aml_soc_platform_probe,
-	.remove = aml_soc_platform_remove,
+	.probe = aml_soc_platform_pcm2bt_probe,
+	.remove = aml_soc_platform_pcm2bt_remove,
 };
 
-static int __init aml_alsa_audio_init(void)
+static int __init aml_alsa_bt_init(void)
 {
-	aml_pcm_init_debugfs();
-	return platform_driver_register(&aml_pcm_driver);
+	//aml_pcm_init_debugfs();		
+	return platform_driver_register(&aml_platform_pcm2bt_driver);
 }
 
-static void __exit aml_alsa_audio_exit(void)
+static void __exit aml_alsa_bt_exit(void)
 {
-	aml_pcm_cleanup_debugfs();
-    platform_driver_unregister(&aml_pcm_driver);
+	//aml_pcm_cleanup_debugfs();
+    platform_driver_unregister(&aml_platform_pcm2bt_driver);
 }
 
-module_init(aml_alsa_audio_init);
-module_exit(aml_alsa_audio_exit);
+module_init(aml_alsa_bt_init);
+module_exit(aml_alsa_bt_exit);
 
 MODULE_AUTHOR("AMLogic, Inc.");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("AML audio driver for ALSA");
-#endif
+
diff --git a/sound/soc/aml/aml_pcm.h b/sound/soc/aml/aml_pcm.h
index 5be7b6d188c9..73d68658df6b 100755
--- a/sound/soc/aml/aml_pcm.h
+++ b/sound/soc/aml/aml_pcm.h
@@ -1,77 +1,23 @@
-#ifndef __AML_PCM_H__
-#define __AML_PCM_H__
+#ifndef __AML_PCM_BT_H__
+#define __AML_PCM_BT_H__
 
-//#define debug_printk
-#ifdef debug_printk
-#define dug_printk(fmt, args...)  printk (fmt, ## args)
-#else
-#define dug_printk(fmt, args...)
-#endif
-
-typedef struct audio_stream {
-    int stream_id;
-    int active;
-    unsigned int last_ptr;
-    unsigned int size;
-    unsigned int sample_rate;
-    unsigned int I2S_addr;
-    spinlock_t lock;
-    struct snd_pcm_substream *stream;
-	unsigned i2s_mode; //0:master, 1:slave,
-    unsigned device_type;
-} audio_stream_t;
+struct aml_pcm_runtime_data {
+	spinlock_t			lock;
 
-typedef struct aml_audio {
-    struct snd_card *card;
-    struct snd_pcm *pcm;
-    audio_stream_t s[2];
-} aml_audio_t;
+    dma_addr_t          buffer_start;
+    unsigned int        buffer_size;
 
-typedef struct audio_mixer_control {
-    int output_devide;
-    int input_device;
-    int direction;
-    int input_volume;
-    int output_volume;
-} audio_mixer_control_t;
+    unsigned int        buffer_offset;
 
-typedef struct audio_tone_control {
-    unsigned short * tone_source;
-    unsigned short * tone_data;
-    int tone_data_len;
-    int tone_count;
-    int tone_flag;
-}audio_tone_control_t;
+    unsigned int        data_size;
 
-struct aml_pcm_dma_params{
-		char *name;			/* stream identifier */
-		struct snd_pcm_substream *substream;
-		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
-	
-};
-typedef struct aml_dai_info {
-	unsigned i2s_mode; //0:master, 1:slave,
-} aml_dai_info_t;
-enum {
-	I2S_MASTER_MODE = 0,
-	I2S_SLAVE_MODE,	
-};
-/*--------------------------------------------------------------------------*\
- * Data types
-\*--------------------------------------------------------------------------*/
-struct aml_runtime_data {
-	struct aml_pcm_dma_params *params;
-	dma_addr_t dma_buffer;		/* physical address of dma buffer */
-	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
+    unsigned int        running;
+    unsigned int        timer_period;
+    unsigned int        peroid_elapsed;
 
-	struct snd_pcm *pcm;
-	struct snd_pcm_substream *substream;
-	audio_stream_t s;	
-	struct timer_list timer;	// timeer for playback and capture
-    struct hrtimer hrtimer;
+    struct timer_list   timer;
+    struct snd_pcm_substream *substream;
 };
 
-extern struct snd_soc_platform_driver aml_soc_platform;
-extern struct aml_audio_interface aml_i2s_interface;
 
 #endif
diff --git a/sound/soc/aml/aml_pcm_dai.c b/sound/soc/aml/aml_pcm_dai.c
new file mode 100755
index 000000000000..9248c2bddb0a
--- /dev/null
+++ b/sound/soc/aml/aml_pcm_dai.c
@@ -0,0 +1,268 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+//#include <sound/soc-dai.h>
+
+#include "aml_pcm_dai.h"
+#include "aml_pcm.h"
+#include "aml_i2s.h"
+#include "aml_audio_hw_pcm2bt.h"
+
+
+#include <linux/of.h>
+
+#define DEV_NAME "aml-pcm-dai"
+
+//static aml_dai_info_t dai_info[3] = {{0}};
+#define AML_DAI_DEBUG
+
+
+
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
+#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-pcm-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+
+
+static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+
+static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+#if 1
+    struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        printk(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        pcm_out_set_buf(prtd->buffer_start, prtd->buffer_size);
+	} else {
+	    printk(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        pcm_in_set_buf(prtd->buffer_start, prtd->buffer_size);
+	}
+
+    memset(runtime->dma_area, 0, runtime->dma_bytes);
+    prtd->buffer_offset = 0;
+    prtd->data_size = 0;
+    prtd->peroid_elapsed = 0;
+#endif
+	return 0;
+}
+
+static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			// TODO
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu pcm playback enable\n\n");
+				pcm_out_enable(1);
+			}else{        
+                pcm_in_enable(1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu pcm playback disable\n\n");
+				pcm_out_enable(0);
+			}else{		
+                pcm_in_enable(0);
+				
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}	
+
+
+static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)
+	snd_soc_dai_get_drvdata(dai);		
+	return 0;
+}
+
+static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#define aml_dai_pcm_suspend	NULL
+#define aml_dai_pcm_resume	NULL
+#endif /* CONFIG_PM */
+
+
+#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
+#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+
+static struct snd_soc_dai_ops aml_dai_pcm_ops = {
+	.startup	= aml_dai_pcm_startup,
+	.shutdown	= aml_dai_pcm_shutdown,
+	.prepare	= aml_dai_pcm_prepare,
+	.trigger = aml_dai_pcm_trigger,
+	.hw_params	= aml_dai_pcm_hw_params,
+	.set_fmt	= aml_dai_set_pcm_fmt,
+	.set_sysclk	= aml_dai_set_pcm_sysclk,
+};
+
+
+struct snd_soc_dai_driver aml_pcm_dai[] = {
+	{	.name = DEV_NAME,
+		.id = 0,
+		.suspend = aml_dai_pcm_suspend,
+		.resume = aml_dai_pcm_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.ops = &aml_dai_pcm_ops,
+	},
+
+};
+
+EXPORT_SYMBOL_GPL(aml_pcm_dai);
+
+static const struct snd_soc_component_driver aml_component= {
+	.name		= DEV_NAME,
+};
+static int aml_pcm_dai_probe(struct platform_device *pdev)
+{
+	printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0
+	BUG_ON(pdev->id < 0);
+	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
+	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
+#else
+	return snd_soc_register_component(&pdev->dev, &aml_component,
+					 aml_pcm_dai, ARRAY_SIZE(aml_pcm_dai));
+//    return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
+
+#endif
+}
+
+static int aml_pcm_dai_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-pcm-dai",
+	},
+	{},
+};
+#else
+#define amlogic_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_pcm_dai_driver = {
+	.driver = {
+		.name = DEV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_dai_dt_match,
+	},
+
+	.probe = aml_pcm_dai_probe,
+	.remove = aml_pcm_dai_remove,
+};
+
+static int __init aml_dai_modinit(void)
+{
+	return platform_driver_register(&aml_pcm_dai_driver);
+}
+module_init(aml_dai_modinit);
+
+static void __exit aml_dai_modexit(void)
+{
+	platform_driver_unregister(&aml_pcm_dai_driver);
+}
+module_exit(aml_dai_modexit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML DAI driver for ALSA");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_pcm_dai.h b/sound/soc/aml/aml_pcm_dai.h
new file mode 100755
index 000000000000..332f1da65d9d
--- /dev/null
+++ b/sound/soc/aml/aml_pcm_dai.h
@@ -0,0 +1,6 @@
+#ifndef AML_DAI_H
+#define AML_DAI_H
+
+extern struct snd_soc_dai_driver aml_dai[];
+
+#endif
diff --git a/sound/soc/aml/aml_platform.c b/sound/soc/aml/aml_platform.c
deleted file mode 100755
index 5dace9fc1b5a..000000000000
--- a/sound/soc/aml/aml_platform.c
+++ /dev/null
@@ -1,573 +0,0 @@
-/*
- * aml_platform.c  --  ALSA audio platform interface for the AML Meson SoC
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- */
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/ioctl.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/dma-mapping.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/soc.h>
-#include <sound/pcm_params.h>
-
-#include "aml_platform_pcm2bt.h"
-#include "aml_pcm.h"
-#include "aml_platform.h"
-#include <linux/of.h>
-
-#ifndef ARRY_SIZE
-#define ARRY_SIZE(A)    (sizeof(A) /sizeof(A[0]))
-#endif
-
-static LIST_HEAD(stream_list);
-static DEFINE_SPINLOCK(platform_lock);
-    
-struct aml_platform_stream{
-    struct list_head list;
-    struct aml_audio_interface *interface;
-    struct snd_pcm_substream *substream;
-};
-
-static struct aml_audio_interface *audio_interfaces[] = {
-    &aml_i2s_interface,
-    &aml_pcm_interface,
-};
-
-static inline struct aml_audio_interface *find_audio_interface(int id)
-{
-    struct aml_audio_interface *interface = NULL;
-    int i = 0;
-
-    for (i=0; i<ARRAY_SIZE(audio_interfaces); i++) {
-        if (audio_interfaces[i]->id == id) {
-            interface = audio_interfaces[i];
-            break;
-        }
-    }
-
-    return interface;
-}
-
-static inline struct aml_platform_stream *find_platform_stream(struct snd_pcm_substream *substream)
-{
-    struct aml_platform_stream *plat_stream = NULL;
-    struct list_head *entry = NULL;
-
-    list_for_each(entry, &stream_list) {
-        plat_stream = list_entry(entry, struct aml_platform_stream, list);
-        if (plat_stream->substream == substream) {
-            return plat_stream;
-        }
-    }
-
-    return NULL;
-}
-
-static void dump_platform_stream(void)
-{
-    struct aml_platform_stream *plat_stream = NULL;
-    struct list_head *entry = NULL;
-    int n = 0;
-
-    list_for_each(entry, &stream_list) {
-        plat_stream = list_entry(entry, struct aml_platform_stream, list);
-        printk(KERN_INFO "substream#%d ptr: %p type: %s name: %s interface: %s\n",
-                        n,
-                        plat_stream->substream,
-                        (plat_stream->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture",
-                        plat_stream->substream->name,
-                        plat_stream->interface->name);
-        n++;
-    }
-}
-
-static int aml_platform_open(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
-                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
-
-    aud_interface = find_audio_interface(cpu_dai->id);
-    if (unlikely(NULL == aud_interface)) {
-        printk(KERN_ERR "aml-platform: no such audio interface!");
-        ret = -ENODEV;
-        goto out;
-    }
-
-    BUG_ON(aud_interface->pcm_ops->open == NULL);
-
-	plat_stream = kzalloc(sizeof(struct aml_platform_stream), GFP_KERNEL);
-	if (unlikely(plat_stream == NULL)) {
-        printk(KERN_ERR "aml-platform: out of memory!");
-		ret = -ENOMEM;
-		goto out;
-	}
-
-    ret = aud_interface->pcm_ops->open(substream);
-    if (ret >= 0) {
-        INIT_LIST_HEAD(&plat_stream->list);
-        plat_stream->substream = substream;
-        plat_stream->interface = aud_interface;
-
-        spin_lock(&platform_lock);
-        list_add_tail(&plat_stream->list, &stream_list);
-        spin_unlock(&platform_lock);
-
-        dump_platform_stream();
-    } else {
-        printk(KERN_ERR "aml-platform: open pcm substream failed ret: %d!", ret);
-    }
-
-out:
-    return ret;
-}
-
-static int aml_platform_close(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
-                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->close == NULL);
-
-        ret = aud_interface->pcm_ops->close(substream);
-        if (ret >= 0) {
-            spin_lock(&platform_lock);
-            list_del(&plat_stream->list);
-            spin_unlock(&platform_lock);
-            kfree(plat_stream);
-        } else {
-            printk(KERN_ERR "aml-platform: close pcm substream failed ret: %d!", ret);
-        }
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static int aml_platform_ioctl(struct snd_pcm_substream * substream,
-                unsigned int cmd, void *arg)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        if (aud_interface->pcm_ops->ioctl) {
-            ret = aud_interface->pcm_ops->ioctl(substream, cmd, arg);
-        } else {
-            ret = snd_pcm_lib_ioctl(substream, cmd, arg);
-        }
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static int aml_platform_hw_params(struct snd_pcm_substream *substream,
-		 struct snd_pcm_hw_params *params)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->hw_params == NULL);
-
-        ret = aud_interface->pcm_ops->hw_params(substream, params);
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static int aml_platform_hw_free(struct snd_pcm_substream *substream)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->hw_free == NULL);
-
-        ret = aud_interface->pcm_ops->hw_free(substream);
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static int aml_platform_prepare(struct snd_pcm_substream *substream)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->prepare == NULL);
-
-        ret = aud_interface->pcm_ops->prepare(substream);
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static int aml_platform_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->trigger == NULL);
-        ret = aud_interface->pcm_ops->trigger(substream, cmd);
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static snd_pcm_uframes_t aml_platform_pointer(struct snd_pcm_substream *substream)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    snd_pcm_uframes_t ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->pointer == NULL);    
-        ret = aud_interface->pcm_ops->pointer(substream);
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-    }
-
-    return ret;
-}
-
-static int aml_platform_copy(struct snd_pcm_substream *substream, int channel,
-        	    snd_pcm_uframes_t pos,
-        	    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        BUG_ON(aud_interface->pcm_ops->copy == NULL);
-
-        ret = aud_interface->pcm_ops->copy(substream, channel, pos, buf, count);
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static int aml_platform_silence(struct snd_pcm_substream *substream, int channel, 
-                snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    unsigned char* ppos = NULL;
-    ssize_t n = 0;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        if (aud_interface->pcm_ops->silence) {
-            ret = aud_interface->pcm_ops->silence(substream, channel, pos, count);
-        } else {
-            n = frames_to_bytes(runtime, count);
-            ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
-            memset(ppos, 0, n);
-        }
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-        ret = -EINVAL;
-    }
-
-    return ret;
-}
-
-static struct page *aml_platform_page(struct snd_pcm_substream *substream,
-                        unsigned long offset)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    struct page *ret = NULL;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        if (aud_interface->pcm_ops->page) {
-            ret = aud_interface->pcm_ops->page(substream, offset);
-        }
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-    }
-
-    return ret;
-}
-
-static int aml_platform_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        if (aud_interface->pcm_ops->mmap) {
-            ret = aud_interface->pcm_ops->mmap(substream, vma);
-        }
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-    }
-
-    return ret;
-}
-
-static int aml_platform_ack(struct snd_pcm_substream *substream)
-{
-    struct aml_audio_interface *aud_interface = NULL;
-    struct aml_platform_stream *plat_stream = NULL;
-    int ret = 0;
-
-    plat_stream = find_platform_stream(substream);
-    if (likely(plat_stream != NULL)) {
-        aud_interface = plat_stream->interface;
-        if (aud_interface->pcm_ops->ack) {
-            ret = aud_interface->pcm_ops->ack(substream);
-        }
-    } else {
-        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
-        dump_platform_stream();
-    }
-
-    return ret;
-}
-    
-static struct snd_pcm_ops aml_platform_ops = {
-	.open		= aml_platform_open,
-	.close		= aml_platform_close,
-	.ioctl		= aml_platform_ioctl,
-	.hw_params	= aml_platform_hw_params,
-	.hw_free	= aml_platform_hw_free,
-	.prepare	= aml_platform_prepare,
-	.trigger	= aml_platform_trigger,
-	.pointer	= aml_platform_pointer,
-	.copy       = aml_platform_copy,
-	.silence    = aml_platform_silence,
-	.page       = aml_platform_page,
-	.mmap       = aml_platform_mmap,
-	.ack        = aml_platform_ack,
-};
-
-static int aml_platform_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-    printk("rtd %x \n",	(unsigned)rtd);
-	
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    printk("cpu_dai %x \n",	(unsigned)cpu_dai);
-	
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    printk("codec_dai %x \n",	(unsigned)codec_dai);
-	
-    struct aml_audio_interface *aud_interface = NULL;
-    struct snd_pcm *pcm =rtd->pcm ;
-    struct snd_soc_card *card = rtd->card;
-	
-	int ret = 0;
-
-    printk(KERN_DEBUG"enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
-                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
-
-    aud_interface = find_audio_interface(cpu_dai->id);
-    if (unlikely(NULL == aud_interface)) {
-        printk(KERN_ERR "aml-platform: no such audio interface!");
-        ret = -ENODEV;
-        goto out;
-    }
-
-    BUG_ON(aud_interface->pcm_new == NULL);
-    ret = aud_interface->pcm_new(rtd);
-out:
-	return ret;
-}
-
-static void aml_platform_pcm_free(struct snd_pcm *pcm)
-{
-    struct snd_soc_pcm_runtime *rtd = pcm->private_data;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct aml_audio_interface *aud_interface = NULL;
-
-    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
-                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
-
-    aud_interface = find_audio_interface(cpu_dai->id);
-    if (unlikely(NULL == aud_interface)) {
-        printk(KERN_ERR "aml-platform: no such audio interface!");
-        return;
-    }
-
-    BUG_ON(aud_interface->pcm_free == NULL);
-    aud_interface->pcm_free(pcm);
-
-	return;
-}
-
-static int aml_platform_suspend(struct snd_soc_dai *dai)
-{
-
-	/* disable the PDC and save the PDC registers */
-	// TODO
-	printk("aml pcm suspend\n");	
-
-	return 0;
-}
-
-static int aml_platform_resume(struct snd_soc_dai *dai)
-{
-	/* restore the PDC registers and enable the PDC */
-	// TODO
-	printk("aml pcm resume\n");
-	return 0;
-}
-
-struct snd_soc_platform_driver aml_soc_platform2 = {
-	.ops 	= &aml_platform_ops,
-	.pcm_new	= aml_platform_pcm_new,
-	.pcm_free	= aml_platform_pcm_free,
-
-	.suspend	= aml_platform_suspend,
-	.resume		= aml_platform_resume,
-};
-
-static int  aml_soc_platform_probe(struct platform_device *pdev)
-{
-	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform2);
-}
-
-static int  aml_soc_platform_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_platform(&pdev->dev);
-	return 0;
-}
-#ifdef CONFIG_OF
-static const struct of_device_id amlogic_audio_dt_match[]={
-	{	.compatible = "amlogic,aml-audio",
-	},
-	{},
-};
-#else
-#define amlogic_audio_dt_match NULL
-#endif
-
-static struct platform_driver aml_soc_platform_driver = {
-	.driver = {
-			.name = "aml-audio",
-			.owner = THIS_MODULE,
-			.of_match_table = amlogic_audio_dt_match,			
-	},
-
-	.probe = aml_soc_platform_probe,
-	.remove = aml_soc_platform_remove,
-};
-
-static int __init aml_soc_platform_init(void)
-{
-	return platform_driver_register(&aml_soc_platform_driver);
-}
-
-static void __exit aml_soc_platform_exit(void)
-{
-    platform_driver_unregister(&aml_soc_platform_driver);
-}
-
-module_init(aml_soc_platform_init);
-
-module_exit(aml_soc_platform_exit);
-
-MODULE_AUTHOR("Amlogic, Inc.");
-MODULE_DESCRIPTION("Amlogic ASoC platform driver");
-MODULE_LICENSE("GPL");
-
diff --git a/sound/soc/aml/aml_platform.h b/sound/soc/aml/aml_platform.h
deleted file mode 100755
index d51694d2f0d9..000000000000
--- a/sound/soc/aml/aml_platform.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * aml_platform.h  --  ALSA audio platform interface for the AML Meson SoC
- *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- */
-
-#ifndef _AML_PLATFORM_H
-#define _AML_PLATFORM_H
-
-#define AML_AUDIO_I2S       0
-#define AML_AUDIO_PCM       1
-
-struct aml_audio_interface
-{
-    unsigned int id;
-    char    *name;
-    struct  snd_pcm_ops *pcm_ops;
-
-	int     (*pcm_new)(struct snd_soc_pcm_runtime *rtd);
-	void    (*pcm_free)(struct snd_pcm *);
-};
-
-#endif /* _AML_PLATFORM_H */
diff --git a/sound/soc/aml/aml_platform_pcm2bt.c b/sound/soc/aml/aml_platform_pcm2bt.c
deleted file mode 100755
index 39475697d9ba..000000000000
--- a/sound/soc/aml/aml_platform_pcm2bt.c
+++ /dev/null
@@ -1,687 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/ioctl.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/soundcard.h>
-#include <linux/timer.h>
-#include <linux/debugfs.h>
-#include <linux/major.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/control.h>
-#include <sound/soc.h>
-#include <sound/pcm_params.h>
-
-
-#include <mach/am_regs.h>
-#include <mach/pinmux.h>
-
-#include "aml_platform_pcm2bt.h"
-#include "aml_audio_hw_pcm2bt.h"
-#include "aml_pcm.h"
-#include "aml_platform.h"
-
-//#define PCM_DEBUG
-
-#ifdef PCM_DEBUG
-#define pcm_debug(fmt, args...)  printk (fmt, ## args)
-#else
-#define pcm_debug(fmt, args...)
-#endif
-
-
-/*--------------------------------------------------------------------------*\
- * Hardware definition
-\*--------------------------------------------------------------------------*/
-/* TODO: These values were taken from the AML platform driver, check
- *	 them against real values for AML
- */
-static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
-	.info			= SNDRV_PCM_INFO_INTERLEAVED|
-							SNDRV_PCM_INFO_BLOCK_TRANSFER|
-				  		    SNDRV_PCM_INFO_PAUSE,
-				  		
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
-
-	.period_bytes_min	= 32,
-	.period_bytes_max	= 8*1024,
-	.periods_min		= 2,
-	.periods_max		= 1024,
-	.buffer_bytes_max	= 64 * 1024,
-	
-	.rate_min = 8000,
-    .rate_max = 8000,
-    .channels_min = 1,
-    .channels_max = 1,
-};
-
-struct aml_pcm_runtime_data {
-	spinlock_t			lock;
-
-    dma_addr_t          buffer_start;
-    unsigned int        buffer_size;
-
-    unsigned int        buffer_offset;
-
-    unsigned int        data_size;
-
-    unsigned int        running;
-    unsigned int        timer_period;
-    unsigned int        peroid_elapsed;
-
-    struct timer_list   timer;
-    struct snd_pcm_substream *substream;
-};
-
-static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
-
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
-	.count = ARRAY_SIZE(period_sizes),
-	.list = period_sizes,
-	.mask = 0
-};
-
-unsigned int aml_pcm2bt_playback_buffer_addr = 0;
-unsigned int aml_pcm2bt_playback_buffer_size = 0;
-unsigned int aml_pcm2bt_capture_buffer_addr = 0;
-unsigned int aml_pcm2bt_capture_buffer_size = 0;
-
-unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
-unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
-unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
-unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
-
-static void aml_pcm_config_tx(u32 addr, u32 size)
-{
-    pcm_debug(KERN_DEBUG "%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
-    pcm_out_set_buf(addr, size);
-}
-
-static void aml_pcm_config_rx(u32 addr, u32 size)
-{
-    pcm_debug(KERN_DEBUG "%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
-    pcm_in_set_buf(addr, size);
-}
-
-static void aml_pcm_start_tx(void)
-{
-    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
-    pcm_out_enable(1);
-}
-
-static void aml_pcm_start_rx(void)
-{
-    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
-    pcm_in_enable(1);
-}
-
-static void aml_pcm_stop_tx(void)
-{
-    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
-    pcm_out_enable(0);
-}
-
-static void aml_pcm_stop_rx(void)
-{
-    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
-    pcm_in_enable(0);
-}
-
-static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
-{
-    unsigned int value = 0;
-    signed int diff = 0;
-
-    value = pcm_out_rd_ptr();
-    diff = value - prtd->buffer_start;
-    if (diff < 0)
-        diff = 0;
-    else if (diff >= prtd->buffer_size)
-        diff = prtd->buffer_size;
-
-    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
-    return (unsigned int)diff;
-}
-
-static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
-{
-    unsigned int value = 0;
-    signed int diff = 0;
-
-    value = pcm_in_wr_ptr();
-    diff = value - prtd->buffer_start;
-    if (diff < 0)
-        diff = 0;
-    else if (diff >= prtd->buffer_size)
-        diff = prtd->buffer_size;
-
-    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
-    return (unsigned int)diff;
-}
-
-static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
-{
-    struct snd_pcm_substream *substream = prtd->substream;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    unsigned int offset = 0;
-    unsigned int size = 0;
-    
-    if (prtd->running && snd_pcm_running(substream)) {
-    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-    		offset = aml_pcm_offset_tx(prtd);
-            if (offset < prtd->buffer_offset) {
-                size = prtd->buffer_size + offset - prtd->buffer_offset;
-            } else {
-                size = offset - prtd->buffer_offset;
-            }
-    	} else {
-            int rx_overflow = 0;
-    		offset = aml_pcm_offset_rx(prtd);
-            if (offset < prtd->buffer_offset) {
-                size = prtd->buffer_size + offset - prtd->buffer_offset;
-            } else {
-                size = offset - prtd->buffer_offset;
-            }
-            rx_overflow = pcm_in_fifo_int() & (1 << 2);
-            if (rx_overflow) {
-                printk(KERN_WARNING "%s AUDIN_FIFO overflow !!\n", __FUNCTION__);
-            }
-    	}
-    }
-
-    prtd->buffer_offset = offset;
-    prtd->data_size += size;
-    if (prtd->data_size >= frames_to_bytes(runtime, runtime->period_size)) {
-        prtd->peroid_elapsed++;
-    }
-
-    pcm_debug(KERN_DEBUG "%s buffer offset: %d data size: %d peroid size: %d peroid elapsed: %d\n",
-                __FUNCTION__, prtd->buffer_offset, prtd->data_size, frames_to_bytes(runtime, runtime->period_size), prtd->peroid_elapsed);
-}
-
-static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
-{
-    prtd->timer.expires = jiffies + prtd->timer_period;
-	add_timer(&prtd->timer);
-}
-
-static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
-{
-    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
-	spin_lock(&prtd->lock);
-	aml_pcm2bt_timer_rearm(prtd);
-    prtd->running = 1;
-	spin_unlock(&prtd->lock);
-	return 0;
-}
-
-static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
-{
-    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
-	spin_lock(&prtd->lock);
-    prtd->running = 0;
-	del_timer(&prtd->timer);
-	spin_unlock(&prtd->lock);
-	return 0;
-}
-
-
-static void aml_pcm2bt_timer_callback(unsigned long data)
-{
-    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	unsigned long flags;
-	unsigned int elapsed = 0;
-    unsigned int datasize = 0;
-	
-	spin_lock_irqsave(&prtd->lock, flags);
-    aml_pcm2bt_timer_update(prtd);
-    aml_pcm2bt_timer_rearm(prtd);
-	elapsed = prtd->peroid_elapsed;
-    datasize = prtd->data_size;
-    if (elapsed) {
-        prtd->peroid_elapsed--;
-        prtd->data_size -= frames_to_bytes(runtime, runtime->period_size);
-    }
-	spin_unlock_irqrestore(&prtd->lock, flags);
-	if (elapsed) {
-        if (elapsed > 1) {
-            printk(KERN_WARNING "PCM timer callback not fast enough (elapsed periods: %d data_bytes: %d period_bytes: %d)!",
-                    elapsed, datasize, frames_to_bytes(runtime, runtime->period_size));
-        }
-		snd_pcm_period_elapsed(prtd->substream);
-    }
-}
-
-static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-
-    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
-	init_timer(&prtd->timer);
-    prtd->timer_period = 1;
-	prtd->timer.data = (unsigned long)substream;
-	prtd->timer.function = aml_pcm2bt_timer_callback;
-    prtd->running = 0;
-	return 0;
-}
-
-static int aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
-			      struct snd_pcm_hw_params *params)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	size_t size = params_buffer_bytes(params);
-    int ret = 0;
-
-	ret = snd_pcm_lib_malloc_pages(substream, size);
-    if (ret < 0) {
-        printk(KERN_ERR "%s snd_pcm_lib_malloc_pages return: %d\n", __FUNCTION__, ret);
-    } else {
-        prtd->buffer_start = runtime->dma_addr;
-        prtd->buffer_size = runtime->dma_bytes;
-        pcm_debug(KERN_DEBUG "%s dma_addr: 0x%08x dma_bytes: 0x%x\n", __FUNCTION__, runtime->dma_addr, runtime->dma_bytes);
-
-        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-            aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
-            aml_pcm2bt_playback_phy_buffer_size = runtime->dma_bytes;
-        } else {
-            aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
-            aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
-        }
-    }
-
-    return ret;
-}
-
-static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	snd_pcm_lib_free_pages(substream);
-
-    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        aml_pcm2bt_playback_phy_buffer_addr = 0;
-        aml_pcm2bt_playback_phy_buffer_size = 0;
-    } else {
-        aml_pcm2bt_capture_phy_buffer_addr = 0;
-        aml_pcm2bt_capture_phy_buffer_size = 0;
-    }
-
-    return 0;
-}
-
-static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        pcm_debug(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
-        aml_pcm_config_tx(prtd->buffer_start, prtd->buffer_size);
-        aml_pcm2bt_playback_buffer_addr = (unsigned int)runtime->dma_area;
-        aml_pcm2bt_playback_buffer_size = runtime->dma_bytes;
-	} else {
-	    pcm_debug(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
-        aml_pcm_config_rx(prtd->buffer_start, prtd->buffer_size);
-        aml_pcm2bt_capture_buffer_addr = (unsigned int)runtime->dma_area;
-        aml_pcm2bt_capture_buffer_size = runtime->dma_bytes;
-	}
-
-    memset(runtime->dma_area, 0, runtime->dma_bytes);
-    prtd->buffer_offset = 0;
-    prtd->data_size = 0;
-    prtd->peroid_elapsed = 0;
-
-	return 0;
-}
-
-static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	int ret = 0;
-
-	switch (cmd) {
-    	case SNDRV_PCM_TRIGGER_START:
-        case SNDRV_PCM_TRIGGER_RESUME:
-        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-    			aml_pcm_start_tx();
-    		else
-    			aml_pcm_start_rx();
-            aml_pcm2bt_timer_start(prtd);
-    		break;
-    	case SNDRV_PCM_TRIGGER_STOP:
-    	case SNDRV_PCM_TRIGGER_SUSPEND:
-    	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-            aml_pcm2bt_timer_stop(prtd);
-    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-    			aml_pcm_stop_tx();
-    		else
-    			aml_pcm_stop_rx();
-    		break;
-    	default:
-    		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-    snd_pcm_uframes_t frames;
-        
-	pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-    frames = bytes_to_frames(runtime, (ssize_t)prtd->buffer_offset);
-
-	return frames;
-}
-
-static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd;
-	int ret;
-
-	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
-
-    /* Ensure that peroid size is a multiple of 32bytes */
-	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
-	if (ret < 0) {
-		printk(KERN_ERR "set period bytes constraint error\n");
-		goto out;
-	}
-
-	/* Ensure that buffer size is a multiple of period size */
-	ret = snd_pcm_hw_constraint_integer(runtime,
-					    SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret < 0) {
-        printk(KERN_ERR "set periods constraint error\n");
-		goto out;
-    }
-
-	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
-	if (prtd == NULL) {
-        printk(KERN_ERR "out of memory\n");
-		ret = -ENOMEM;
-		goto out;
-	}
-
-    runtime->private_data = prtd;
-    aml_pcm2bt_timer_create(substream);
-    prtd->substream = substream;
-	spin_lock_init(&prtd->lock);
-
-    return 0;
-out:
-	return ret;
-}
-
-
-static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-   
-    printk(KERN_INFO "enter %s type: %d\n", __FUNCTION__, substream->stream);
-    if (prtd)
-	    kfree(runtime->private_data);
-	return 0;
-}
-
-
-static int aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
-    snd_pcm_uframes_t pos,
-    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-    unsigned char* hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
-    unsigned int wrptr = 0;
-    int ret = 0;
-
-    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
-
-	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
-        printk(KERN_ERR "%s copy from user failed!\n", __FUNCTION__);
-		return -EFAULT;
-    } else {
-        wrptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
-        if (wrptr >= (prtd->buffer_start + prtd->buffer_size)) {
-            wrptr = prtd->buffer_start + prtd->buffer_size;
-        }
-        pcm_out_set_wr_ptr(wrptr);
-    }
-
-    return ret;
-}
-
-	
-
-
-static int aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
-    snd_pcm_uframes_t pos,
-    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-    signed short *hwbuf = (signed short*)(runtime->dma_area + frames_to_bytes(runtime, pos));
-    unsigned int rdptr = 0;
-    int ret = 0;
-
-    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
-
-	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
-        printk(KERN_ERR "%s copy to user failed!\n", __FUNCTION__);
-		return -EFAULT;
-    } else {
-        //memset(hwbuf, 0xff, frames_to_bytes(runtime, count));
-        rdptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
-        if (rdptr >= (prtd->buffer_start + prtd->buffer_size)) {
-            rdptr = prtd->buffer_start + prtd->buffer_size;
-        }
-        pcm_in_set_rd_ptr(rdptr);
-    }
-    return ret;
-}
-
-static int aml_pcm2bt_copy(struct snd_pcm_substream *substream, int channel,
-    snd_pcm_uframes_t pos,
-    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    int ret = 0;
-
-    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        ret = aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
-    } else {
-        ret = aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
-    }
-
-    return ret;
-}
-
-
-static int aml_pcm2bt_silence(struct snd_pcm_substream *substream, int channel, 
-    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    unsigned char* ppos = NULL;
-    ssize_t n;
-
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-    n = frames_to_bytes(runtime, count);
-    ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
-    memset(ppos, 0, n);
-
-    return 0;
-}
-                        
-static struct snd_pcm_ops aml_pcm2bt_ops = {
-	.open		= aml_pcm2bt_open,
-	.close		= aml_pcm2bt_close,
-	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= aml_pcm2bt_hw_params,
-	.hw_free	= aml_pcm2bt_hw_free,
-	.prepare	= aml_pcm2bt_prepare,
-	.trigger	= aml_pcm2bt_trigger,
-	.pointer	= aml_pcm2bt_pointer,
-	.copy 		= aml_pcm2bt_copy,
-	.silence	= aml_pcm2bt_silence,
-};
-
-
-/*--------------------------------------------------------------------------*\
- * ASoC platform driver
-\*--------------------------------------------------------------------------*/
-
-static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
-
-static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
-	int stream)
-{
-	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;
-	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
-
-    printk(KERN_DEBUG "enter %s stream: %d\n", __FUNCTION__, stream);
-    
-	buf->dev.type = SNDRV_DMA_TYPE_DEV;
-	buf->dev.dev = pcm->card->dev;
-	buf->private_data = NULL;
-	buf->area = dma_alloc_coherent(pcm->card->dev, size,
-					   &buf->addr, GFP_KERNEL);
-	if (!buf->area) {
-        printk(KERN_ERR "%s dma_alloc_coherent failed (size: %d)!\n", __FUNCTION__, size);
-		return -ENOMEM;
-    }
-
-	buf->bytes = size;
-    printk(KERN_INFO "%s allcoate buf->area: %p buf->addr: 0x%x buf->bytes: %d\n",
-                __FUNCTION__, buf->area, buf->addr, buf->bytes);
-	return 0;
-}
-
-static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
-{
-	int ret = 0;
-       struct snd_soc_card *card = rtd->card;
-       struct snd_pcm *pcm =rtd->pcm ;  
-       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
-       pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
-    
-	if (!card->dev->dma_mask)
-		card->dev->dma_mask = &aml_pcm2bt_dmamask;
-	if (!card->dev->coherent_dma_mask)
-		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
-
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
-		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
-			SNDRV_PCM_STREAM_PLAYBACK);
-		if (ret)
-			goto out;
-	}
-
-	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
-			SNDRV_PCM_STREAM_CAPTURE);
-		if (ret)
-			goto out;
-	}
-
-out:
-	return ret;
-}
-
-static void aml_pcm2bt_free(struct snd_pcm *pcm)
-{
-	struct snd_pcm_substream *substream;
-	struct snd_dma_buffer *buf;
-	int stream;
-
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	for (stream = 0; stream < 2; stream++) {
-		substream = pcm->streams[stream].substream;
-		if (!substream)
-			continue;
-
-		buf = &substream->dma_buffer;
-		if (!buf->area)
-			continue;
-
-		dma_free_coherent(pcm->card->dev, buf->bytes,
-				      buf->area, buf->addr);
-		buf->area = NULL;
-	}
-}
-
-struct aml_audio_interface aml_pcm_interface = {
-    .id = AML_AUDIO_PCM,
-    .name = "PCM",
-    .pcm_ops = &aml_pcm2bt_ops,
-    .pcm_new = aml_pcm2bt_new,
-    .pcm_free =  aml_pcm2bt_free,
-};
-
-
-#if 0
-struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
-	.ops 	= &aml_pcm2bt_ops,
-	.pcm_new	= aml_pcm2bt_new,
-	.pcm_free	= aml_pcm2bt_free,
-	//.suspend	= aml_pcm_suspend,
-	//.resume		= aml_pcm_resume,
-};
-EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
-
-static int __devinit aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
-{
-	//INIT_WORK(&aml_pcm_work.aml_codec_workqueue, aml_codec_power_switch_queue);
-	printk("shaoshuai, snd_soc_register_platform\n");
-	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
-}
-
-static int __devexit aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_platform(&pdev->dev);
-	return 0;
-}
-
-static struct platform_driver aml_platform_pcm2bt_driver = {
-	.driver = {
-			.name = "aml-bt",
-			.owner = THIS_MODULE,
-	},
-
-	.probe = aml_soc_platform_pcm2bt_probe,
-	.remove = __devexit_p(aml_soc_platform_pcm2bt_remove),
-};
-
-static int __init aml_alsa_bt_init(void)
-{
-	//aml_pcm_init_debugfs();		
-	return platform_driver_register(&aml_platform_pcm2bt_driver);
-}
-
-static void __exit aml_alsa_bt_exit(void)
-{
-	//aml_pcm_cleanup_debugfs();
-    platform_driver_unregister(&aml_platform_pcm2bt_driver);
-}
-
-module_init(aml_alsa_bt_init);
-module_exit(aml_alsa_bt_exit);
-
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("AML audio driver for ALSA");
-#endif
diff --git a/sound/soc/aml/aml_platform_pcm2bt.h b/sound/soc/aml/aml_platform_pcm2bt.h
deleted file mode 100755
index 233f906574c6..000000000000
--- a/sound/soc/aml/aml_platform_pcm2bt.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef __AML_PCM_BT_H__
-#define __AML_PCM_BT_H__
-
-extern struct aml_audio_interface aml_pcm_interface;
-
-#endif
diff --git a/sound/soc/aml/aml_spdif_dai.c b/sound/soc/aml/aml_spdif_dai.c
index 74a04992a818..2d23f42c7c4d 100755
--- a/sound/soc/aml/aml_spdif_dai.c
+++ b/sound/soc/aml/aml_spdif_dai.c
@@ -26,7 +26,7 @@
 #include <mach/pinmux.h>
 #include "aml_audio_hw.h"
 #include "aml_spdif_dai.h"
-#include "aml_pcm.h"
+#include "aml_i2s.h"
 #include <linux/of.h>
 
 #define DEBUG_ALSA_SPDIF_DAI
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index c782b808151e..1d5b2d26d2dc 100755
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -532,3 +532,5 @@ config SND_SOC_TPA6130A2
 	tristate
 config SND_SOC_DUMMY_CODEC
        tristate
+config SND_SOC_PCM2BT
+       tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 48eaa4719189..d57ed07b1aa5 100755
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -121,6 +121,7 @@ snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-dummy_codec-objs := dummy_codec.o
 snd-soc-aml-m8-codec-objs := aml_m8_codec.o
 aml_audio_codec_probe-objs := common/aml_audio_codec_probe.o
+snd-soc-pcm2bt-objs  := pcm2bt.o
 
 # Amp
 snd-soc-max9877-objs := max9877.o
@@ -248,6 +249,7 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 obj-$(CONFIG_SND_SOC_DUMMY_CODEC)   += snd-soc-dummy_codec.o
 obj-$(CONFIG_SND_SOC_AML_M8_CODEC)	+= snd-soc-aml-m8-codec.o
 obj-y += aml_audio_codec_probe.o
+obj-$(CONFIG_SND_SOC_PCM2BT)    += snd-soc-pcm2bt.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
diff --git a/sound/soc/codecs/pcm2bt.c b/sound/soc/codecs/pcm2bt.c
new file mode 100755
index 000000000000..42df1550934d
--- /dev/null
+++ b/sound/soc/codecs/pcm2bt.c
@@ -0,0 +1,180 @@
+/*
+ * PCM2BT ALSA SoC Audio driver
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+
+#include "pcm2bt.h"
+
+struct pcm2bt_priv {	
+    struct snd_soc_codec codec;
+};
+
+
+#define PCM2BT_RATES SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000
+
+#define PCM2BT_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \
+	SNDRV_PCM_FMTBIT_S8)
+	
+static int pcm2bt_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+    return 0;
+}
+
+static int pcm2bt_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+    return 0;
+}
+
+static int pcm2bt_set_sysclk(struct snd_soc_dai *dai,   int clk_id, 
+        unsigned int freq, int dir)
+{    
+    return 0;
+}
+
+static int pcm2bt_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+    return 0;
+}
+
+static int pcm2bt_set_bias_level(struct snd_soc_codec *codec,	
+        enum snd_soc_bias_level level)
+{  
+   return 0;
+}
+
+struct snd_soc_dai_ops pcm2bt_dai_ops = {
+	.hw_params = pcm2bt_hw_params,
+	.set_fmt = pcm2bt_set_fmt,
+	.set_sysclk = pcm2bt_set_sysclk,
+	.shutdown = pcm2bt_shutdown,
+	.set_sysclk = pcm2bt_set_sysclk,
+};
+
+struct snd_soc_dai_driver pcm2bt_dai[] = {
+    {
+		.name = "pcm2bt-pcm",
+		.playback = {
+			.stream_name = "PCM2BT Playback",
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = PCM2BT_RATES,
+			.formats = PCM2BT_FORMATS,
+		},
+		.capture = {
+			.stream_name = "BT2PCM Capture",
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = PCM2BT_RATES,
+			.formats = PCM2BT_FORMATS,
+		},
+		.ops = &pcm2bt_dai_ops,
+		.symmetric_rates = 1,
+    },
+};
+
+static int pcm2bt_probe(struct snd_soc_codec *codec)
+{
+    return 0;
+}
+
+static int pcm2bt_remove(struct snd_soc_codec *codec)
+{   
+    return 0;
+}
+
+static int pcm2bt_suspend(struct snd_soc_codec *codec,
+        pm_message_t state)
+{
+    return 0;
+}
+static int pcm2bt_resume(struct snd_soc_codec *codec)
+{
+    return 0;
+}
+
+
+static struct snd_soc_codec_driver soc_codec_dev_pcm2bt = {
+	.probe = pcm2bt_probe,
+	.remove = pcm2bt_remove,
+	.suspend = pcm2bt_suspend,
+	.resume = pcm2bt_resume,
+	.set_bias_level = pcm2bt_set_bias_level,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_pcm2bt);
+
+static int pcm2bt_platform_probe(struct platform_device *pdev)
+{
+    int ret;
+    struct pcm2bt_priv *pcm2bt = NULL;
+   printk("*****enter pcm2bt_codec_probe\n");
+    ret = snd_soc_register_codec(&pdev->dev, 
+        &soc_codec_dev_pcm2bt, pcm2bt_dai, ARRAY_SIZE(pcm2bt_dai));    
+   
+
+    printk("pcm2bt_codec_probe ok!\n");
+    
+    return ret;
+    
+}
+
+static int pcm2bt_platform_remove(struct platform_device *pdev)
+{   
+    snd_soc_unregister_codec(&pdev->dev);
+    return 0;   
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_pcm2BT_codec_dt_match[]={
+    { .compatible = "amlogic,pcm2BT-codec", },
+    {},
+};
+#else
+#define amlogic_pcm2BT_codec_dt_match NULL
+#endif
+
+
+static struct platform_driver pcm2bt_platform_driver = {
+	.driver = {
+		.name = "pcm2bt",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_pcm2BT_codec_dt_match,
+		},
+	.probe = pcm2bt_platform_probe,
+	.remove = pcm2bt_platform_remove,
+};
+
+static int __init pcm_bt_init(void)
+{
+	return platform_driver_register(&pcm2bt_platform_driver);
+}
+module_init(pcm_bt_init);
+
+static void __exit pcm_bt_exit(void)
+{
+	platform_driver_unregister(&pcm2bt_platform_driver);
+}
+module_exit(pcm_bt_exit);
+
+MODULE_DESCRIPTION("ASoC pcm2bt driver");
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/pcm2bt.h b/sound/soc/codecs/pcm2bt.h
new file mode 100755
index 000000000000..03d601ca97e4
--- /dev/null
+++ b/sound/soc/codecs/pcm2bt.h
@@ -0,0 +1,12 @@
+/*
+ * bt40183.h  --  BT40183 Soc Audio driver
+ *
+ */
+
+#ifndef _BT_CODEC_H
+#define _BT_CODEC_H
+
+extern struct snd_soc_dai bt40183_dai;
+extern struct snd_soc_codec_device soc_codec_dev_bt40183;
+
+#endif
-- 
2.19.0

