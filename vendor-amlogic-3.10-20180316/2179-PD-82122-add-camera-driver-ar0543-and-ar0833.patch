From 6e9c6a6e667d742e06d59ceea1b7c725b8553b1b Mon Sep 17 00:00:00 2001
From: "zhenfei.li" <zhenfei.li@amlogic>
Date: Mon, 2 Dec 2013 16:48:35 +0800
Subject: [PATCH 2179/5965] PD #82122: add camera driver ar0543 and ar0833

---
 arch/arm/boot/dts/amlogic/meson8_skt.dtd    |   48 +-
 arch/arm/configs/meson8_defconfig           |    2 +
 drivers/amlogic/camera/Kconfig              |   20 +
 drivers/amlogic/camera/Makefile             |    4 +
 drivers/amlogic/camera/ar0543.c             | 3819 ++++++++++++
 drivers/amlogic/camera/ar0833.c             | 5851 +++++++++++++++++++
 drivers/amlogic/camera/common/cam_prober.c  |  246 +-
 drivers/amlogic/camera/common/plat_ctrl.c   |   62 +-
 drivers/amlogic/camera/common/plat_ctrl.h   |   15 +
 include/linux/amlogic/camera/aml_cam_info.h |    4 +-
 include/media/v4l2-chip-ident.h             |    6 +
 11 files changed, 10017 insertions(+), 60 deletions(-)
 create mode 100755 drivers/amlogic/camera/ar0543.c
 create mode 100755 drivers/amlogic/camera/ar0833.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index e8710ceb5498..94f55588d4af 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -878,6 +878,36 @@ void root_func(){
 		pinctrl-0 = <&aml_cam_gpio_pins> ;
 		pinctrl-1 = <&aml_cam_csi_pins> ;
 
+///	-	ar0543
+//$$ DEVICE="ar0543"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "config_path"
+//$$ L2 PROP_U32 = "mclk"
+//$$ L2 PROP_STR = "bt_path"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_STR = "clk_channel"
+		cam_0{
+			cam_name = "ar0543";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;
+			config_path = "/system/etc/camera_isp_cfg/ar0543_skt";
+			mclk = <12000>;
+			bt_path = "csi";
+			interface = "mipi";
+			clk_channel = "a";
+			status = "okay";
+		};
+
 ///	-	ov5647
 //$$ DEVICE="ov5647"
 //$$ L2 PROP_STR = "status"
@@ -900,10 +930,26 @@ void root_func(){
 			vertical_flip = <0>;	
 			config_path = "/system/etc/camera_isp_cfg/ov5647_cw0767";
 			bt_path = "csi";
-			interface = "dvp";
+			interface = "mipi";
 			clk_channel = "b";
 			status = "okay";
 		};
+		
+		cam_2{
+			cam_name = "ar0833";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;
+			config_path = "/system/etc/camera_isp_cfg/ar0833_skt";
+			mclk = <12000>;
+			bt_path = "csi";
+			interface = "mipi";
+			clk_channel = "a";
+			status = "okay";
+		};
 	};	
 
 /// ***************************************************************************************
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 4df660a1e891..6071dd3b6f1e 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -326,6 +326,8 @@ CONFIG_VIDEO_AMLOGIC_CAPTURE_GT2005=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5640=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5647=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_HI253=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0543=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0833=y
 CONFIG_TVIN_ISP=y
 CONFIG_TVIN_CSI=y
 CONFIG_SENSOR_DEVICES=y
diff --git a/drivers/amlogic/camera/Kconfig b/drivers/amlogic/camera/Kconfig
index f61d85acee3e..81773ab235d5 100755
--- a/drivers/amlogic/camera/Kconfig
+++ b/drivers/amlogic/camera/Kconfig
@@ -336,6 +336,26 @@ config VIDEO_AMLOGIC_CAPTURE_NT99340
 	  Amlogic capture driver.
 	  Say Y here if you want this driver.	
 
+config VIDEO_AMLOGIC_CAPTURE_AR0543
+	tristate "Amlogic Platform Capture Driver for AR0543"
+	depends on VIDEO_AMLOGIC_CAPTURE
+	select VIDEOBUF_VMALLOC
+	select AMLOGIC_VIDEOIN_MANAGER
+	default n
+	---help---
+	  Amlogic capture driver.
+	  Say Y here if you want this driver.	
+	  
+config VIDEO_AMLOGIC_CAPTURE_AR0833
+	tristate "Amlogic Platform Capture Driver for AR0833"
+	depends on VIDEO_AMLOGIC_CAPTURE
+	select VIDEOBUF_VMALLOC
+	select AMLOGIC_VIDEOIN_MANAGER
+	default n
+	---help---
+	  Amlogic capture driver.
+	  Say Y here if you want this driver.	
+
 config AMLOGIC_VIDEOIN_MANAGER
 	tristate
 
diff --git a/drivers/amlogic/camera/Makefile b/drivers/amlogic/camera/Makefile
index b3aa5b868e19..e43fcc2395db 100755
--- a/drivers/amlogic/camera/Makefile
+++ b/drivers/amlogic/camera/Makefile
@@ -24,6 +24,8 @@ ov3660dri-objs := ov3660.o
 nt99250dri-objs := nt99250.o
 nt99252dri-objs := nt99252.o
 nt99340dri-objs := nt99340.o
+ar0543dri-objs := ar0543.o
+ar0833dri-objs := ar0833.o
 amlcamera-objs := common/plat_ctrl.o
 amlvm-objs := common/vm.o common/util.o
 cam_prober-objs := common/cam_prober.o common/config_parser.o
@@ -50,6 +52,8 @@ obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_OV3660) += ov3660dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_NT99250) += nt99250dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_NT99252) += nt99252dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_NT99340) += nt99340dri.o
+obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0543) += ar0543dri.o
+obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0833) += ar0833dri.o
 obj-$(CONFIG_AMLOGIC_VIDEOIN_MANAGER)  += amlvm.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE)  += amlcamera.o
 obj-y += cam_prober.o
diff --git a/drivers/amlogic/camera/ar0543.c b/drivers/amlogic/camera/ar0543.c
new file mode 100755
index 000000000000..e05c2e4bac3d
--- /dev/null
+++ b/drivers/amlogic/camera/ar0543.c
@@ -0,0 +1,3819 @@
+/*
+ *ar0543 - This code emulates a real video device with v4l2 api
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence, GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ */
+#include <linux/sizes.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/highmem.h>
+#include <linux/freezer.h>
+#include <media/videobuf-res.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <linux/wakelock.h>
+
+#include <linux/i2c.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/amlogic/camera/aml_cam_info.h>
+
+#define MIPI_INTERFACE
+#ifdef MIPI_INTERFACE
+#include <linux/amlogic/mipi/am_mipi_csi2.h>
+#endif
+#include "common/vm.h"
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+//#include <media/amlogic/656in.h>
+#include "common/plat_ctrl.h"
+#include <linux/amlogic/vmapi.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#include <mach/mod_gate.h>
+#endif
+
+#include "common/config_parser.h"
+
+#define AR0543_CAMERA_MODULE_NAME "ar0543"
+#define MAGIC_RE_MEM 0x123039dc
+#define AR0543_RES0_CANVAS_INDEX CAMERA_USER_CANVAS_INDEX
+
+
+/* Wake up at about 30 fps */
+#define WAKE_NUMERATOR 30
+#define WAKE_DENOMINATOR 1001
+#define BUFFER_TIMEOUT     msecs_to_jiffies(500)  /* 0.5 seconds */
+
+#define AR0543_CAMERA_MAJOR_VERSION 0
+#define AR0543_CAMERA_MINOR_VERSION 7
+#define AR0543_CAMERA_RELEASE 0
+#define AR0543_CAMERA_VERSION \
+	KERNEL_VERSION(AR0543_CAMERA_MAJOR_VERSION, AR0543_CAMERA_MINOR_VERSION, AR0543_CAMERA_RELEASE)
+
+
+
+MODULE_DESCRIPTION("ar0543 On Board");
+MODULE_AUTHOR("amlogic-sh");
+MODULE_LICENSE("GPL v2");
+
+static unsigned video_nr = -1;  /* videoX start number, -1 is autodetect. */
+
+static unsigned debug;
+//module_param(debug, uint, 0644);
+//MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 32;
+//module_param(vid_limit, uint, 0644);
+//MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+
+static int ar0543_h_active = 800;
+static int ar0543_v_active = 600;
+static struct v4l2_fract ar0543_frmintervals_active = {
+    .numerator = 1,
+    .denominator = 15,
+};
+
+static int ar0543_have_open=0;
+
+extern configure *cf;
+static camera_mode_t ar0543_work_mode = CAMERA_PREVIEW;
+static struct class *cam_class;
+static unsigned int g_ae_manual_exp;
+static unsigned int g_ae_manual_ag;
+static unsigned int g_ae_manual_vts;
+extern sensor_aet_info_t *sensor_aet_info; // point to 1 of up to 16 aet information
+extern sensor_aet_t *sensor_aet_table;
+extern unsigned int sensor_aet_step;
+
+static unsigned int exp_mode;
+static unsigned int change_cnt;
+static unsigned int current_fmt;
+static unsigned int current_fr = 0;//50 hz
+static unsigned int aet_index;
+static unsigned int last_af_step = 0;
+
+#define HI2056_CAMERA_MODULE_NAME "mipi-hi2056"
+
+static struct am_csi2_camera_para ar0543_para = {
+    .name = HI2056_CAMERA_MODULE_NAME,
+    .output_pixel = 0,
+    .output_line = 0,
+    .active_pixel = 0,
+    .active_line = 0,
+    .frame_rate = 0,
+    .ui_val = 0,
+    .hs_freq = 0,
+    .clock_lane_mode = 0,
+    .mirror = 0,
+    .in_fmt = NULL,
+    .out_fmt = NULL,
+};
+static int i_index = -1;
+static int t_index = -1;
+static int dest_hactive = 640;
+static int dest_vactive = 480;
+static bool bDoingAutoFocusMode = false;
+/* supported controls */
+static struct v4l2_queryctrl ar0543_qctrl[] = {
+	{
+		.id            = V4L2_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 127,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}, {
+		.id            = V4L2_CID_CONTRAST,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Contrast",
+		.minimum       = 0x10,
+		.maximum       = 0x60,
+		.step          = 0xa,
+		.default_value = 0x30,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_HFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on horizontal",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_DISABLED,
+	} ,{
+		.id            = V4L2_CID_VFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on vertical",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_DISABLED,
+	},{
+		.id            = V4L2_CID_DO_WHITE_BALANCE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "white balance",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_EXPOSURE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "exposure",
+		.minimum       = 0,
+		.maximum       = 8,
+		.step          = 0x1,
+		.default_value = 4,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_COLORFX,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "effect",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_WHITENESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "banding",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_FOCUS_AUTO,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "auto focus",
+		.minimum       = CAM_FOCUS_MODE_RELEASE,
+		.maximum       = CAM_FOCUS_MODE_CONTI_PIC,
+		.step          = 0x1,
+		.default_value = CAM_FOCUS_MODE_CONTI_PIC,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "flash",
+		.minimum       = FLASHLIGHT_ON,
+		.maximum       = FLASHLIGHT_TORCH,
+		.step          = 0x1,
+		.default_value = FLASHLIGHT_OFF,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_ZOOM_ABSOLUTE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Zoom, Absolute",
+		.minimum       = 100,
+		.maximum       = 300,
+		.step          = 20,
+		.default_value = 100,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id		= V4L2_CID_ROTATE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotate",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+        .id            = V4L2_CID_AUTO_FOCUS_STATUS,
+        .type          = 8,//V4L2_CTRL_TYPE_BITMASK,
+        .name          = "focus status",
+        .minimum       = 0,
+        .maximum       = ~3,
+        .step          = 0x1,
+        .default_value = V4L2_AUTO_FOCUS_STATUS_IDLE,
+        .flags         = V4L2_CTRL_FLAG_READ_ONLY,
+    },{
+        .id			   = V4L2_CID_FOCUS_ABSOLUTE,
+        .type		   = V4L2_CTRL_TYPE_INTEGER,
+		.name		   = "focus center",
+		.minimum	   = 0,
+		.maximum	   = ((2000) << 16) | 2000,
+		.step		   = 1,
+		.default_value = (1000 << 16) | 1000,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+ 	}
+};
+
+static struct v4l2_frmivalenum ar0543_frmivalenum[]={
+        {
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 640,
+                .height		= 480,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 30,
+                        }
+                }
+        },{
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 1280,
+                .height		= 720,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 30,
+                        }
+                }
+        },{
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 1920,
+                .height		= 1080,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 30,
+                        }
+                }
+        },{
+                .index 		= 1,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 1600,
+                .height		= 1200,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 15,
+                        }
+                }
+        },
+};
+
+struct v4l2_querymenu ar0543_qmenu_wbmode[] = {
+    {
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_CLOUD,
+        .name       = "cloudy-daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_DAYLIGHT,
+        .name       = "daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_INCANDESCENCE,
+        .name       = "incandescent",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_TUNGSTEN,
+        .name       = "tungsten",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "fluorescent", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_MANUAL,
+        .name       = "manual", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_SHADE,
+        .name       = "shade", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_TWILIGHT,
+        .name       = "twilight", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_WARM_FLUORESCENT,
+        .name       = "warm-fluorescent",
+        .reserved   = 0,
+    },
+};
+
+struct v4l2_querymenu ar0543_qmenu_autofocus[] = {
+    {
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_INFINITY,
+        .name       = "infinity",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_CONTI_VID,
+        .name       = "continuous-video",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_CONTI_PIC,
+        .name       = "continuous-picture",
+        .reserved   = 0,
+    }
+};
+
+struct v4l2_querymenu ar0543_qmenu_anti_banding_mode[] = {
+    {
+        .id         = V4L2_CID_POWER_LINE_FREQUENCY,
+        .index      = CAM_BANDING_50HZ, 
+        .name       = "50hz",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_POWER_LINE_FREQUENCY,
+        .index      = CAM_BANDING_60HZ, 
+        .name       = "60hz",
+        .reserved   = 0,
+    },
+};
+
+struct v4l2_querymenu ar0543_qmenu_flashmode[] = {
+    {
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_ON,
+        .name       = "on",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_OFF,
+        .name       = "off",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_TORCH,
+        .name       = "torch",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    }
+};
+
+typedef struct {
+    __u32   id;
+    int     num;
+    struct v4l2_querymenu* ar0543_qmenu;
+}ar0543_qmenu_set_t;
+
+ar0543_qmenu_set_t ar0543_qmenu_set[] = {
+    {
+        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .num            = ARRAY_SIZE(ar0543_qmenu_wbmode),
+        .ar0543_qmenu   = ar0543_qmenu_wbmode,
+    },{
+        .id         	= V4L2_CID_POWER_LINE_FREQUENCY,
+        .num            = ARRAY_SIZE(ar0543_qmenu_anti_banding_mode),
+        .ar0543_qmenu   = ar0543_qmenu_anti_banding_mode,
+    }, {
+        .id             = V4L2_CID_FOCUS_AUTO,
+        .num            = ARRAY_SIZE(ar0543_qmenu_autofocus),
+        .ar0543_qmenu   = ar0543_qmenu_autofocus,
+    }, {
+        .id             = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .num            = ARRAY_SIZE(ar0543_qmenu_flashmode),
+        .ar0543_qmenu   = ar0543_qmenu_flashmode,
+    }
+};
+
+static int vidioc_querymenu(struct file *file, void *priv,
+                struct v4l2_querymenu *a)
+{
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ar0543_qmenu_set); i++)
+	if (a->id && a->id == ar0543_qmenu_set[i].id) {
+	    for(j = 0; j < ar0543_qmenu_set[i].num; j++)
+		if (a->index == ar0543_qmenu_set[i].ar0543_qmenu[j].index) {
+			memcpy(a, &( ar0543_qmenu_set[i].ar0543_qmenu[j]),
+				sizeof(*a));
+			return (0);
+		}
+	}
+
+	return -EINVAL;
+}
+
+#define dprintk(dev, level, fmt, arg...) \
+	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+
+/* ------------------------------------------------------------------
+	Basic structures
+   ------------------------------------------------------------------*/
+
+struct ar0543_fmt {
+	char  *name;
+	u32   fourcc;          /* v4l2 format id */
+	int   depth;
+};
+
+static struct ar0543_fmt formats[] = {
+	{
+		.name     = "RGB565 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+		.depth    = 16,
+	},{
+		.name     = "RGB888 (24)",
+		.fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
+		.depth    = 24,
+	},{
+		.name     = "BGR888 (24)",
+		.fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
+		.depth    = 24,
+	},{
+		.name     = "12  Y/CbCr 4:2:0",
+		.fourcc   = V4L2_PIX_FMT_NV12,
+		.depth    = 12,
+	},{
+		.name     = "12  Y/CbCr 4:2:0",
+		.fourcc   = V4L2_PIX_FMT_NV21,
+		.depth    = 12,
+	},{
+		.name     = "YUV420P",
+		.fourcc   = V4L2_PIX_FMT_YUV420,
+		.depth    = 12,
+	},{
+		.name     = "YVU420P",
+		.fourcc   = V4L2_PIX_FMT_YVU420,
+		.depth    = 12,
+	}
+};
+
+static struct ar0543_fmt *get_format(struct v4l2_format *f)
+{
+	struct ar0543_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat)
+			break;
+	}
+
+	if (k == ARRAY_SIZE(formats))
+		return NULL;
+
+	return &formats[k];
+}
+
+struct sg_to_addr {
+	int pos;
+	struct scatterlist *sg;
+};
+
+/* buffer for one video frame */
+struct ar0543_buffer {
+	/* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+
+	struct ar0543_fmt        *fmt;
+	unsigned int canvas_id;
+};
+
+struct ar0543_dmaqueue {
+	struct list_head       active;
+
+	/* thread for generating video stream*/
+	struct task_struct         *kthread;
+	wait_queue_head_t          wq;
+	/* Counters to control fps rate */
+	int                        frame;
+	int                        ini_jiffies;
+};
+
+typedef enum resulution_size_type{
+	SIZE_NULL_TYPE = 0,
+	SIZE_CIF_352X288,
+	SIZE_VGA_640X480,
+	SIZE_720P_1280X720,
+	SIZE_960P_1280X960,
+	SIZE_1080P_1920X1080,
+	SIZE_H1080P_2592X1944
+} resulution_size_type_t;
+
+typedef struct resolution_param {
+	struct v4l2_frmsize_discrete frmsize;
+	struct v4l2_frmsize_discrete active_frmsize;
+	int active_fps;
+	resulution_size_type_t size_type;
+	cam_i2c_msg_t* reg_script[2];
+} resolution_param_t;
+
+static LIST_HEAD(ar0543_devicelist);
+
+struct ar0543_device {
+	struct list_head			ar0543_devicelist;
+	struct v4l2_subdev			sd;
+	struct v4l2_device			v4l2_dev;
+
+	spinlock_t                 slock;
+	struct mutex				mutex;
+
+	int                        users;
+
+	/* various device info */
+	struct video_device        *vdev;
+
+	struct ar0543_dmaqueue       vidq;
+
+	/* Several counters */
+	unsigned long              jiffies;
+
+	/* Input Number */
+	int			   input;
+
+	/* platform device data from board initting. */
+	aml_cam_info_t cam_info;
+	
+	cam_parameter_t *cam_para;
+	
+	para_index_t pindex;
+	
+	struct vdin_v4l2_ops_s *vops;
+	
+	fe_arg_t fe_arg;
+	/* wake lock */
+	struct wake_lock	wake_lock;
+	/* ae status */
+	bool ae_on;
+	
+	/* Control 'registers' */
+	int 			   qctl_regs[ARRAY_SIZE(ar0543_qctrl)];
+};
+
+static inline struct ar0543_device *to_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ar0543_device, sd);
+}
+
+struct ar0543_fh {
+	struct ar0543_device            *dev;
+
+	/* video capture */
+	struct ar0543_fmt            *fmt;
+	unsigned int               width, height;
+	struct videobuf_queue      vb_vidq;
+
+	struct videobuf_res_privdata res;
+
+	enum v4l2_buf_type         type;
+	int			   input; 	/* Input Number on bars */
+	int  stream_on;
+	unsigned int		f_flags;
+};
+
+static inline struct ar0543_fh *to_fh(struct ar0543_device *dev)
+{
+	return container_of(dev, struct ar0543_fh, dev);
+}
+
+#define RAW10
+
+/* ------------------------------------------------------------------
+	reg spec of AR0543
+   ------------------------------------------------------------------*/
+static cam_i2c_msg_t AR0543_init_script[] = {
+
+	{END_OF_SCRIPT, 0, 0},
+};
+#ifdef MIPI_INTERFACE
+static cam_i2c_msg_t AR0543_mipi_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+#endif
+static cam_i2c_msg_t AR0543_preview_VGA_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_VGA_script_mipi[] = {
+	//[Demo Initialization 1280 x 720 MCLK= 24MHz, PCLK=76.8MHz]
+	{1, 0x0103, 0x01},      //SOFTWARE_RESET (clears itself)
+	{TIME_DELAY, 0, 5},       //Initialization Time
+	    
+	    //stop_streaming
+	{1, 0x0100, 0x00},      // MODE_SELECT
+	
+	{2, 0x301A, 0x0218},      //RESET_REGISTER enable mipi interface  bit[9] mask bad frame
+	{2, 0x3064, 0xB800},      // SMIA_TEST
+	{2, 0x31AE, 0x0202},      // two lane
+	{2, 0x0112, 0x0A0A},      // 10bit raw output
+	
+	{1, 0x0300, 0x05},	//vt_pix_clk_div = 0x5
+	{1, 0x0302, 0x01},	//vt_sys_clk_div = 0x1
+	{1, 0x0304, 0x02},	//pre_pll_clk_div = 0x2
+	{1, 0x0306, 0x12},	//pll_multiplier = 0x12
+	{1, 0x0308, 0x0A},	//op_pix_clk_div = 0xA
+	{1, 0x030A, 0x01},	//op_sys_clk_div = 0x1
+	        
+	  //stop_streaming
+	{1, 0x0100, 0x0 },      // MODE_SELECT 
+	{1, 0x0104, 0x01},      // GROUPED_PARAMETER_HOLD = 0x1
+	    
+	//1280 x 720  Timing settings 30fps
+	
+	{2, 0x3064, 0xB800},      // SMIA_TEST
+	{2, 0x31AE, 0x0202},      // two lane 201 tow 202
+	{2, 0x0112, 0x0A0A},      // 10bit raw output
+	
+	//PLL MCLK=26MHZ, PCLK = 104MHZ, VT = 104MHZ
+	
+	{1, 0x0300, 0x05},	//vt_pix_clk_div = 0x5
+	{1, 0x0302, 0x01},	//vt_sys_clk_div = 0x1
+	{1, 0x0304, 0x02},	//pre_pll_clk_div = 0x2
+	{1, 0x0306, 0x12},	//pll_multiplier = 0x12
+	{1, 0x0308, 0x0A},	//op_pix_clk_div = 0xA
+	{1, 0x030A, 0x01},	//op_sys_clk_div = 0x1
+	 
+	{2, 0x0344, 0x0008},      // X_ADDR_START   =  8
+	{2, 0x0346, 0x0008},      // Y_ADDR_START   =  8
+	{2, 0x0348, 0x0A01},      // X_ADDR_END      = 2561
+	{2, 0x034A, 0x0781},      // Y_ADDR_END       =  1921
+	
+	{2, 0x3040, 0x85C7},        // READ_MODE  10 011 000011 xy binning enable xodd=3, yodd=3
+	{2, 0x034C, 0x0280},      // X_OUTPUT_SIZE    = 640
+	{2, 0x034E, 0x01E0},      // Y_OUTPUT_SIZE    =  480
+	
+	{2, 0x300C, 0x0A2C},      // LINE_LENGTH  2604
+	{2, 0x300A, 0x0229},      // FRAME_LINEs  553
+	
+	{2, 0x3014, 0x0678},      // fine_integration_time
+	{2, 0x3010, 0x0184},      // fine_correction
+	{1, 0x0104, 0x00  },    // GROUPED_PARAMETER_HOLD
+	    
+	    //start_streaming
+	{1, 0x0100, 0x01 },     // MODE_SELECT 
+	
+	//[LSC_85%]
+	{2, 0x3780, 0x0000}, 	// POLY_SC_ENABLE
+	{2, 0x3600, 0x01D0}, 	// P_GR_P0Q0     
+	{2, 0x3602, 0x278C}, 	// P_GR_P0Q1     
+	{2, 0x3604, 0x6D70}, 	// P_GR_P0Q2     
+	{2, 0x3606, 0x8B0D}, 	// P_GR_P0Q3     
+	{2, 0x3608, 0x974C}, 	// P_GR_P0Q4     
+	{2, 0x360A, 0x01F0}, 	// P_RD_P0Q0     
+	{2, 0x360C, 0x21CD}, 	// P_RD_P0Q1     
+	{2, 0x360E, 0x2F30}, 	// P_RD_P0Q2     
+	{2, 0x3610, 0x32CC}, 	// P_RD_P0Q3     
+	{2, 0x3612, 0x2D6A}, 	// P_RD_P0Q4     
+	{2, 0x3614, 0x0230}, 	// P_BL_P0Q0     
+	{2, 0x3616, 0x434D}, 	// P_BL_P0Q1     
+	{2, 0x3618, 0x2F8F}, 	// P_BL_P0Q2     
+	{2, 0x361A, 0xFDAF}, 	// P_BL_P0Q3     
+	{2, 0x361C, 0x79CF}, 	// P_BL_P0Q4     
+	{2, 0x361E, 0x0590}, 	// P_GB_P0Q0     
+	{2, 0x3620, 0xAE2B}, 	// P_GB_P0Q1     
+	{2, 0x3622, 0x7690}, 	// P_GB_P0Q2     
+	{2, 0x3624, 0x764D}, 	// P_GB_P0Q3     
+	{2, 0x3626, 0xF3AE}, 	// P_GB_P0Q4     
+	{2, 0x3640, 0xBFAC}, 	// P_GR_P1Q0     
+	{2, 0x3642, 0x992F}, 	// P_GR_P1Q1     
+	{2, 0x3644, 0x336F}, 	// P_GR_P1Q2     
+	{2, 0x3646, 0x272F}, 	// P_GR_P1Q3     
+	{2, 0x3648, 0xC350}, 	// P_GR_P1Q4     
+	{2, 0x364A, 0x9B6C}, 	// P_RD_P1Q0     
+	{2, 0x364C, 0xB66D}, 	// P_RD_P1Q1     
+	{2, 0x364E, 0x1030}, 	// P_RD_P1Q2     
+	{2, 0x3650, 0x622F}, 	// P_RD_P1Q3     
+	{2, 0x3652, 0xB0D1}, 	// P_RD_P1Q4     
+	{2, 0x3654, 0xE527}, 	// P_BL_P1Q0     
+	{2, 0x3656, 0xD20D}, 	// P_BL_P1Q1     
+	{2, 0x3658, 0x79AF}, 	// P_BL_P1Q2     
+	{2, 0x365A, 0x600F}, 	// P_BL_P1Q3     
+	{2, 0x365C, 0xA191}, 	// P_BL_P1Q4     
+	{2, 0x365E, 0xE7A8}, 	// P_GB_P1Q0     
+	{2, 0x3660, 0xDB0F}, 	// P_GB_P1Q1     
+	{2, 0x3662, 0x0A50}, 	// P_GB_P1Q2     
+	{2, 0x3664, 0x5FF0}, 	// P_GB_P1Q3     
+	{2, 0x3666, 0xBBF1}, 	// P_GB_P1Q4     
+	{2, 0x3680, 0x39D1}, 	// P_GR_P2Q0     
+	{2, 0x3682, 0x44AD}, 	// P_GR_P2Q1     
+	{2, 0x3684, 0xF5D1}, 	// P_GR_P2Q2     
+	{2, 0x3686, 0x8F52}, 	// P_GR_P2Q3     
+	{2, 0x3688, 0x36B3}, 	// P_GR_P2Q4     
+	{2, 0x368A, 0x4E71}, 	// P_RD_P2Q0     
+	{2, 0x368C, 0xC30C}, 	// P_RD_P2Q1     
+	{2, 0x368E, 0xC451}, 	// P_RD_P2Q2     
+	{2, 0x3690, 0xA352}, 	// P_RD_P2Q3     
+	{2, 0x3692, 0x1BB3}, 	// P_RD_P2Q4     
+	{2, 0x3694, 0x0431}, 	// P_BL_P2Q0     
+	{2, 0x3696, 0x5AED}, 	// P_BL_P2Q1     
+	{2, 0x3698, 0xC351}, 	// P_BL_P2Q2     
+	{2, 0x369A, 0xB011}, 	// P_BL_P2Q3     
+	{2, 0x369C, 0x2D93}, 	// P_BL_P2Q4     
+	{2, 0x369E, 0x3AD1}, 	// P_GB_P2Q0     
+	{2, 0x36A0, 0x76EC}, 	// P_GB_P2Q1     
+	{2, 0x36A2, 0x86F2}, 	// P_GB_P2Q2     
+	{2, 0x36A4, 0xC7F2}, 	// P_GB_P2Q3     
+	{2, 0x36A6, 0x5633}, 	// P_GB_P2Q4     
+	{2, 0x36C0, 0x494E}, 	// P_GR_P3Q0     
+	{2, 0x36C2, 0x7210}, 	// P_GR_P3Q1     
+	{2, 0x36C4, 0xB932}, 	// P_GR_P3Q2     
+	{2, 0x36C6, 0x8572}, 	// P_GR_P3Q3     
+	{2, 0x36C8, 0x3813}, 	// P_GR_P3Q4     
+	{2, 0x36CA, 0x442F}, 	// P_RD_P3Q0     
+	{2, 0x36CC, 0x3211}, 	// P_RD_P3Q1     
+	{2, 0x36CE, 0x8333}, 	// P_RD_P3Q2     
+	{2, 0x36D0, 0xEED2}, 	// P_RD_P3Q3     
+	{2, 0x36D2, 0x0DB4}, 	// P_RD_P3Q4     
+	{2, 0x36D4, 0xECC8}, 	// P_BL_P3Q0     
+	{2, 0x36D6, 0x04D1}, 	// P_BL_P3Q1     
+	{2, 0x36D8, 0xBBD2}, 	// P_BL_P3Q2     
+	{2, 0x36DA, 0xF8F2}, 	// P_BL_P3Q3     
+	{2, 0x36DC, 0x12F4}, 	// P_BL_P3Q4     
+	{2, 0x36DE, 0x3B0D}, 	// P_GB_P3Q0     
+	{2, 0x36E0, 0x3391}, 	// P_GB_P3Q1     
+	{2, 0x36E2, 0xD2F2}, 	// P_GB_P3Q2     
+	{2, 0x36E4, 0x94D3}, 	// P_GB_P3Q3     
+	{2, 0x36E6, 0x23F4}, 	// P_GB_P3Q4     
+	{2, 0x3700, 0xF011}, 	// P_GR_P4Q0     
+	{2, 0x3702, 0xD271}, 	// P_GR_P4Q1     
+	{2, 0x3704, 0x1154}, 	// P_GR_P4Q2     
+	{2, 0x3706, 0x0D13}, 	// P_GR_P4Q3     
+	{2, 0x3708, 0xDDB3}, 	// P_GR_P4Q4     
+	{2, 0x370A, 0x81D2}, 	// P_RD_P4Q0     
+	{2, 0x370C, 0xCA91}, 	// P_RD_P4Q1     
+	{2, 0x370E, 0x1C34}, 	// P_RD_P4Q2     
+	{2, 0x3710, 0x4991}, 	// P_RD_P4Q3     
+	{2, 0x3712, 0xDFB3}, 	// P_RD_P4Q4     
+	{2, 0x3714, 0xD271}, 	// P_BL_P4Q0     
+	{2, 0x3716, 0x9B12}, 	// P_BL_P4Q1     
+	{2, 0x3718, 0x3094}, 	// P_BL_P4Q2     
+	{2, 0x371A, 0x41D3}, 	// P_BL_P4Q3     
+	{2, 0x371C, 0x8335}, 	// P_BL_P4Q4     
+	{2, 0x371E, 0xF5B1}, 	// P_GB_P4Q0     
+	{2, 0x3720, 0xBC51}, 	// P_GB_P4Q1     
+	{2, 0x3722, 0x2574}, 	// P_GB_P4Q2     
+	{2, 0x3724, 0x39F2}, 	// P_GB_P4Q3     
+	{2, 0x3726, 0x9674}, 	// P_GB_P4Q4     
+	{2, 0x3782, 0x0468}, 	// POLY_ORIGIN_C 
+	{2, 0x3784, 0x0378}, 	// POLY_ORIGIN_R 
+	{2, 0x37C0, 0xE86A}, 	// P_GR_Q5       
+	{2, 0x37C2, 0xBBEB}, 	// P_RD_Q5       
+	{2, 0x37C4, 0xF82A}, 	// P_BL_Q5       
+	{2, 0x37C6, 0x840B}, 	// P_GB_Q5       
+	{2, 0x3780, 0x8000}, 	// POLY_SC_ENABLE
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_preview_720P_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_720P_script_mipi[] = {
+	//[Demo Initialization 1280 x 720 MCLK= 24MHz, PCLK=76.8MHz]
+	{1, 0x0103, 0x01},      //SOFTWARE_RESET (clears itself)
+	{TIME_DELAY, 0, 5},       //Initialization Time
+	    
+	    //stop_streaming
+	{1, 0x0100, 0x00},      // MODE_SELECT
+	
+	{2, 0x301A, 0x0218},      //RESET_REGISTER enable mipi interface  bit[9] mask bad frame
+	{2, 0x3064, 0xB800},      // SMIA_TEST
+	{2, 0x31AE, 0x0202},      // two lane
+	{2, 0x0112, 0x0A0A},      // 10bit raw output
+	
+	{1, 0x0300, 0x05},	//vt_pix_clk_div = 0x5
+	{1, 0x0302, 0x01},	//vt_sys_clk_div = 0x1
+	{1, 0x0304, 0x02},	//pre_pll_clk_div = 0x2
+	{1, 0x0306, 0x20},	//pll_multiplier = 0x20
+	{1, 0x0308, 0x0A},	//op_pix_clk_div = 0xA
+	{1, 0x030A, 0x01},	//op_sys_clk_div = 0x1
+	        
+	  //stop_streaming
+	{1, 0x0100, 0x0 },      // MODE_SELECT 
+	{1, 0x0104, 0x01},      // GROUPED_PARAMETER_HOLD = 0x1
+	    
+	//1280 x 720  Timing settings 30fps
+	
+	{2, 0x3064, 0xB800},      // SMIA_TEST
+	{2, 0x31AE, 0x0202},      // two lane 201 tow 202
+	{2, 0x0112, 0x0A0A},      // 10bit raw output
+	
+	//PLL MCLK=26MHZ, PCLK = 104MHZ, VT = 104MHZ
+	
+	{1, 0x0300, 0x05},	//vt_pix_clk_div = 0x5
+	{1, 0x0302, 0x01},	//vt_sys_clk_div = 0x1
+	{1, 0x0304, 0x02},	//pre_pll_clk_div = 0x2
+	{1, 0x0306, 0x20},	//pll_multiplier = 0x20
+	{1, 0x0308, 0x0A},	//op_pix_clk_div = 0xA
+	{1, 0x030A, 0x01},	//op_sys_clk_div = 0x1
+	 
+	{2, 0x0344, 0x0008},      // X_ADDR_START   =  8
+	{2, 0x0346, 0x0008},      // Y_ADDR_START   =  8
+	{2, 0x0348, 0x0A25},      // X_ADDR_END      = 2597
+	{2, 0x034A, 0x079D},      // Y_ADDR_END       =  1949
+	
+	{2, 0x3040, 0x84C3},        // READ_MODE  10 011 000011 xy binning enable xodd=3, yodd=3
+	{2, 0x034C, 0x0500},      // X_OUTPUT_SIZE    = 1280
+	{2, 0x034E, 0x02D0},      // Y_OUTPUT_SIZE    =  720
+	
+	{2, 0x300C, 0x0C3C},      // LINE_LENGTH  3151
+	{2, 0x300A, 0x0331},      // FRAME_LINEs  1100
+	
+	{2, 0x3014, 0x08F8},      // fine_integration_time
+	{2, 0x3010, 0x0184},      // fine_correction
+	{1, 0x0104, 0x00  },    // GROUPED_PARAMETER_HOLD
+	    
+	    //start_streaming
+	{1, 0x0100, 0x01 },     // MODE_SELECT 
+	
+	//[LSC_85%]
+	{2, 0x3780, 0x0000}, 	// POLY_SC_ENABLE
+	{2, 0x3600, 0x01D0}, 	// P_GR_P0Q0     
+	{2, 0x3602, 0x278C}, 	// P_GR_P0Q1     
+	{2, 0x3604, 0x6D70}, 	// P_GR_P0Q2     
+	{2, 0x3606, 0x8B0D}, 	// P_GR_P0Q3     
+	{2, 0x3608, 0x974C}, 	// P_GR_P0Q4     
+	{2, 0x360A, 0x01F0}, 	// P_RD_P0Q0     
+	{2, 0x360C, 0x21CD}, 	// P_RD_P0Q1     
+	{2, 0x360E, 0x2F30}, 	// P_RD_P0Q2     
+	{2, 0x3610, 0x32CC}, 	// P_RD_P0Q3     
+	{2, 0x3612, 0x2D6A}, 	// P_RD_P0Q4     
+	{2, 0x3614, 0x0230}, 	// P_BL_P0Q0     
+	{2, 0x3616, 0x434D}, 	// P_BL_P0Q1     
+	{2, 0x3618, 0x2F8F}, 	// P_BL_P0Q2     
+	{2, 0x361A, 0xFDAF}, 	// P_BL_P0Q3     
+	{2, 0x361C, 0x79CF}, 	// P_BL_P0Q4     
+	{2, 0x361E, 0x0590}, 	// P_GB_P0Q0     
+	{2, 0x3620, 0xAE2B}, 	// P_GB_P0Q1     
+	{2, 0x3622, 0x7690}, 	// P_GB_P0Q2     
+	{2, 0x3624, 0x764D}, 	// P_GB_P0Q3     
+	{2, 0x3626, 0xF3AE}, 	// P_GB_P0Q4     
+	{2, 0x3640, 0xBFAC}, 	// P_GR_P1Q0     
+	{2, 0x3642, 0x992F}, 	// P_GR_P1Q1     
+	{2, 0x3644, 0x336F}, 	// P_GR_P1Q2     
+	{2, 0x3646, 0x272F}, 	// P_GR_P1Q3     
+	{2, 0x3648, 0xC350}, 	// P_GR_P1Q4     
+	{2, 0x364A, 0x9B6C}, 	// P_RD_P1Q0     
+	{2, 0x364C, 0xB66D}, 	// P_RD_P1Q1     
+	{2, 0x364E, 0x1030}, 	// P_RD_P1Q2     
+	{2, 0x3650, 0x622F}, 	// P_RD_P1Q3     
+	{2, 0x3652, 0xB0D1}, 	// P_RD_P1Q4     
+	{2, 0x3654, 0xE527}, 	// P_BL_P1Q0     
+	{2, 0x3656, 0xD20D}, 	// P_BL_P1Q1     
+	{2, 0x3658, 0x79AF}, 	// P_BL_P1Q2     
+	{2, 0x365A, 0x600F}, 	// P_BL_P1Q3     
+	{2, 0x365C, 0xA191}, 	// P_BL_P1Q4     
+	{2, 0x365E, 0xE7A8}, 	// P_GB_P1Q0     
+	{2, 0x3660, 0xDB0F}, 	// P_GB_P1Q1     
+	{2, 0x3662, 0x0A50}, 	// P_GB_P1Q2     
+	{2, 0x3664, 0x5FF0}, 	// P_GB_P1Q3     
+	{2, 0x3666, 0xBBF1}, 	// P_GB_P1Q4     
+	{2, 0x3680, 0x39D1}, 	// P_GR_P2Q0     
+	{2, 0x3682, 0x44AD}, 	// P_GR_P2Q1     
+	{2, 0x3684, 0xF5D1}, 	// P_GR_P2Q2     
+	{2, 0x3686, 0x8F52}, 	// P_GR_P2Q3     
+	{2, 0x3688, 0x36B3}, 	// P_GR_P2Q4     
+	{2, 0x368A, 0x4E71}, 	// P_RD_P2Q0     
+	{2, 0x368C, 0xC30C}, 	// P_RD_P2Q1     
+	{2, 0x368E, 0xC451}, 	// P_RD_P2Q2     
+	{2, 0x3690, 0xA352}, 	// P_RD_P2Q3     
+	{2, 0x3692, 0x1BB3}, 	// P_RD_P2Q4     
+	{2, 0x3694, 0x0431}, 	// P_BL_P2Q0     
+	{2, 0x3696, 0x5AED}, 	// P_BL_P2Q1     
+	{2, 0x3698, 0xC351}, 	// P_BL_P2Q2     
+	{2, 0x369A, 0xB011}, 	// P_BL_P2Q3     
+	{2, 0x369C, 0x2D93}, 	// P_BL_P2Q4     
+	{2, 0x369E, 0x3AD1}, 	// P_GB_P2Q0     
+	{2, 0x36A0, 0x76EC}, 	// P_GB_P2Q1     
+	{2, 0x36A2, 0x86F2}, 	// P_GB_P2Q2     
+	{2, 0x36A4, 0xC7F2}, 	// P_GB_P2Q3     
+	{2, 0x36A6, 0x5633}, 	// P_GB_P2Q4     
+	{2, 0x36C0, 0x494E}, 	// P_GR_P3Q0     
+	{2, 0x36C2, 0x7210}, 	// P_GR_P3Q1     
+	{2, 0x36C4, 0xB932}, 	// P_GR_P3Q2     
+	{2, 0x36C6, 0x8572}, 	// P_GR_P3Q3     
+	{2, 0x36C8, 0x3813}, 	// P_GR_P3Q4     
+	{2, 0x36CA, 0x442F}, 	// P_RD_P3Q0     
+	{2, 0x36CC, 0x3211}, 	// P_RD_P3Q1     
+	{2, 0x36CE, 0x8333}, 	// P_RD_P3Q2     
+	{2, 0x36D0, 0xEED2}, 	// P_RD_P3Q3     
+	{2, 0x36D2, 0x0DB4}, 	// P_RD_P3Q4     
+	{2, 0x36D4, 0xECC8}, 	// P_BL_P3Q0     
+	{2, 0x36D6, 0x04D1}, 	// P_BL_P3Q1     
+	{2, 0x36D8, 0xBBD2}, 	// P_BL_P3Q2     
+	{2, 0x36DA, 0xF8F2}, 	// P_BL_P3Q3     
+	{2, 0x36DC, 0x12F4}, 	// P_BL_P3Q4     
+	{2, 0x36DE, 0x3B0D}, 	// P_GB_P3Q0     
+	{2, 0x36E0, 0x3391}, 	// P_GB_P3Q1     
+	{2, 0x36E2, 0xD2F2}, 	// P_GB_P3Q2     
+	{2, 0x36E4, 0x94D3}, 	// P_GB_P3Q3     
+	{2, 0x36E6, 0x23F4}, 	// P_GB_P3Q4     
+	{2, 0x3700, 0xF011}, 	// P_GR_P4Q0     
+	{2, 0x3702, 0xD271}, 	// P_GR_P4Q1     
+	{2, 0x3704, 0x1154}, 	// P_GR_P4Q2     
+	{2, 0x3706, 0x0D13}, 	// P_GR_P4Q3     
+	{2, 0x3708, 0xDDB3}, 	// P_GR_P4Q4     
+	{2, 0x370A, 0x81D2}, 	// P_RD_P4Q0     
+	{2, 0x370C, 0xCA91}, 	// P_RD_P4Q1     
+	{2, 0x370E, 0x1C34}, 	// P_RD_P4Q2     
+	{2, 0x3710, 0x4991}, 	// P_RD_P4Q3     
+	{2, 0x3712, 0xDFB3}, 	// P_RD_P4Q4     
+	{2, 0x3714, 0xD271}, 	// P_BL_P4Q0     
+	{2, 0x3716, 0x9B12}, 	// P_BL_P4Q1     
+	{2, 0x3718, 0x3094}, 	// P_BL_P4Q2     
+	{2, 0x371A, 0x41D3}, 	// P_BL_P4Q3     
+	{2, 0x371C, 0x8335}, 	// P_BL_P4Q4     
+	{2, 0x371E, 0xF5B1}, 	// P_GB_P4Q0     
+	{2, 0x3720, 0xBC51}, 	// P_GB_P4Q1     
+	{2, 0x3722, 0x2574}, 	// P_GB_P4Q2     
+	{2, 0x3724, 0x39F2}, 	// P_GB_P4Q3     
+	{2, 0x3726, 0x9674}, 	// P_GB_P4Q4     
+	{2, 0x3782, 0x0468}, 	// POLY_ORIGIN_C 
+	{2, 0x3784, 0x0378}, 	// POLY_ORIGIN_R 
+	{2, 0x37C0, 0xE86A}, 	// P_GR_Q5       
+	{2, 0x37C2, 0xBBEB}, 	// P_RD_Q5       
+	{2, 0x37C4, 0xF82A}, 	// P_BL_Q5       
+	{2, 0x37C6, 0x840B}, 	// P_GB_Q5       
+	{2, 0x3780, 0x8000}, 	// POLY_SC_ENABLE
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_preview_960P_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_960P_script_mipi[] = {
+	{2,0x0103, 0x01},    //SOFTWARE_RESET (clears itself)
+	{TIME_DELAY, 0, 5},      //Initialization Time
+	    
+	//stop_streaming
+	{2,0x0100, 0x00},    // MODE_SELECT
+	
+	{2,0x301A, 0x0218},    //RESET_REGISTER enable mipi interface  bit[9] mask bad frame
+	{2,0x3064, 0xB800},    // SMIA_TEST
+	{2,0x31AE, 0x0202},    // two lane
+	{2,0x0112, 0x0A0A},    // 10bit raw output
+	
+	{1,0x0300, 0x05},    //vt_pix_clk_div = 5
+	{1,0x0302, 0x01},    //vt_sys_clk_div = 1
+	{1,0x0304, 0x02},    //pre_pll_clk_div = 2
+	{1,0x0306, 0x28},    //pll_multiplier    =  40
+	{1,0x0308, 0x0A},    //op_pix_clk_div =  10
+	{1,0x030A, 0x01},    //op_sys_clk_div = 1
+	        
+	  //stop_streaming
+	{1,0x0100, 0x0 },    // MODE_SELECT 
+	{1,0x0104, 0x01},    // GROUPED_PARAMETER_HOLD = 0x1
+	    
+	//1296 x 972  Timing settings 30fps
+	
+	{2,0x3064, 0xB800},    // SMIA_TEST
+	{2,0x31AE, 0x0202},    // two lane 201 tow 202
+	{2,0x0112, 0x0A0A},    // 10bit raw output
+	
+	//PLL MCLK=26MHZ, PCLK = 104MHZ, VT = 104MHZ
+	
+	{1,0x0300, 0x05},    //vt_pix_clk_div = 5
+	{1,0x0302, 0x01},    //vt_sys_clk_div = 1
+	{1,0x0304, 0x02},    //pre_pll_clk_div = 2
+	{1,0x0306, 0x28},    //pll_multiplier    =  40
+	{1,0x0308, 0x0A},    //op_pix_clk_div =  10
+	{1,0x030A, 0x01},    //op_sys_clk_div = 1
+	 
+	{2,0x0344, 0x0008},    // X_ADDR_START   =  8
+	{2,0x0346, 0x0008},    // Y_ADDR_START   =  8
+	{2,0x0348, 0x0A25},    // X_ADDR_END      = 2597
+	{2,0x034A, 0x079D},    // Y_ADDR_END       =  1949
+	
+	{2,0x3040, 0x84C3},    // READ_MODE  10 011 000011 xy binning enable xodd=3, yodd=3
+	{2,0x034C, 0x0510},    // X_OUTPUT_SIZE    = 1296
+	{2,0x034E, 0x03CC},    // Y_OUTPUT_SIZE    =  972
+	
+	{2,0x300C, 0x0C4C},    // LINE_LENGTH  3151
+	{2,0x300A, 0x0415},    // FRAME_LINEs  1100
+	    
+	{2,0x3014, 0x0908},    // fine_integration_time
+	{2,0x3010, 0x0184},    // fine_correction
+	{1,0x0104, 0x00},    // GROUPED_PARAMETER_HOLD
+	    
+	    //start_streaming
+	{1,0x0100, 0x01},    // MODE_SELECT
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_preview_1080P_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_1080P_script_mipi[] = {
+	{1,0x0100, 0x00},    //Mode Select = 0x0
+	//{2,0x301A, 0x0018};    //Reset Register = 0x18  enable parallel bit[9] mask bad frame(0x12C8)
+	{2,0x0112, 0x0A0A},    //CCP Data Format = 0xA0A
+	{2,0x3064, 0x7800},    //SMIA_Test = 0x7800
+	{2,0x31AE, 0x0202},    //Serial Format = 0x202
+	
+	//Silicon Recommendation
+	//{1,0x301C, 0x00 };    //Turn-off streamming
+	{2,0x316A, 0x8400},    //RESERVED
+	{2,0x316C, 0x8400},    //RESERVED
+	{2,0x316E, 0x8400},    //RESERVED
+	{2,0x3EFA, 0x171F},    //RESERVED
+	{2,0x3ED2, 0xD965},    //Manufacturer-Specific
+	{2,0x3ED8, 0x7F1B},    //Manufacturer-Specific
+	{2,0x3EDA, 0x2F11},    //Manufacturer-Specific
+	{2,0x3EDE, 0xB000},    //Manufacturer-Specific
+	{2,0x3EE2, 0x0060},    //Manufacturer-Specific
+	{2,0x3EF2, 0xD965},    //Manufacturer-Specific
+	{2,0x3EF8, 0x797F},    //Manufacturer-Specific
+	{2,0x3EFC, 0x246F},    //Manufacturer-Specific
+	{2,0x3EFE, 0x6F01},    //Manufacturer-Specific
+	
+	//[A-5141_pixel_timing]
+	{2,0x3E00, 0x0428},
+	{2,0x3E02, 0xFFFF},
+	{2,0x3E04, 0xFFFF},
+	{2,0x3E06, 0xFFFF},
+	{2,0x3E08, 0x8071},
+	{2,0x3E0A, 0x7281},
+	{2,0x3E0C, 0x0041},
+	{2,0x3E0E, 0x5355},
+	{2,0x3E10, 0x8710},
+	{2,0x3E12, 0x6085},
+	{2,0x3E14, 0x4080},
+	{2,0x3E16, 0x41A0},
+	{2,0x3E18, 0x0018},
+	{2,0x3E1A, 0x9057},
+	{2,0x3E1C, 0xA049},
+	{2,0x3E1E, 0xA649},
+	{2,0x3E20, 0x8846},
+	{2,0x3E22, 0x8142},
+	{2,0x3E24, 0x0082},
+	{2,0x3E26, 0x8B49},
+	{2,0x3E28, 0x9C49},
+	{2,0x3E2A, 0x8A10},
+	{2,0x3E2C, 0x0C82},
+	{2,0x3E2E, 0x4784},
+	{2,0x3E30, 0x4D85},
+	{2,0x3E32, 0x0406},
+	{2,0x3E34, 0x9510},
+	{2,0x3E36, 0x0EC3},
+	{2,0x3E38, 0x4A42},
+	{2,0x3E3A, 0x8341},
+	{2,0x3E3C, 0x8B4B},
+	{2,0x3E3E, 0xA84B},
+	{2,0x3E40, 0x8056},
+	{2,0x3E42, 0x8000},
+	{2,0x3E44, 0x1C81},
+	{2,0x3E46, 0x10E0},
+	{2,0x3E48, 0x8055},
+	{2,0x3E4A, 0x1C00},
+	{2,0x3E4C, 0x827C},
+	{2,0x3E4E, 0x0970},
+	{2,0x3E50, 0x8082},
+	{2,0x3E52, 0x7281},
+	{2,0x3E54, 0x4C40},
+	{2,0x3E56, 0x9110},
+	{2,0x3E58, 0x0C85},
+	{2,0x3E5A, 0x4D9E},
+	{2,0x3E5C, 0x4D80},
+	{2,0x3E5E, 0x100C},
+	{2,0x3E60, 0x8E40},
+	{2,0x3E62, 0x4C81},
+	{2,0x3E64, 0x7C51},
+	{2,0x3E66, 0x7000},
+	{2,0x3E68, 0x0000},
+	{2,0x3E6A, 0x0000},
+	{2,0x3E6C, 0x0000},
+	{2,0x3E6E, 0x0000},
+	{2,0x3E70, 0x0000},
+	{2,0x3E72, 0x0000},
+	{2,0x3E74, 0x0000},
+	{2,0x3E76, 0x0000},
+	{2,0x3E78, 0x0000},
+	{2,0x3E7A, 0x0000},
+	{2,0x3E7C, 0x0000},
+	{2,0x3E7E, 0x0000},
+	{2,0x3E80, 0x0000},
+	{2,0x3E82, 0x0000},
+	{2,0x3E84, 0x0000},
+	{2,0x3E86, 0x0000},
+	{2,0x3E88, 0x0000},
+	{2,0x3E8A, 0x0000},
+	{2,0x3E8C, 0x0000},
+	{2,0x3E8E, 0x0000},
+	{2,0x3E90, 0x0000},
+	{2,0x3E92, 0x0000},
+	{2,0x3E94, 0x0000},
+	{2,0x3E96, 0x0000},
+	{2,0x3E98, 0x0000},
+	{2,0x3E9A, 0x0000},
+	{2,0x3E9C, 0x0000},
+	{2,0x3E9E, 0x0000},
+	{2,0x3EA0, 0x0000},
+	{2,0x3EA2, 0x0000},
+	{2,0x3EA4, 0x0000},
+	{2,0x3EA6, 0x0000},
+	{2,0x3EA8, 0x0000},
+	{2,0x3EAA, 0x0000},
+	{2,0x3EAC, 0x0000},
+	{2,0x3EAE, 0x0000},
+	{2,0x3EB0, 0x0000},
+	{2,0x3EB2, 0x0000},
+	{2,0x3EB4, 0x0000},
+	{2,0x3EB6, 0x0000},
+	{2,0x3EB8, 0x0000},
+	{2,0x3EBA, 0x0000},
+	{2,0x3EBC, 0x0000},
+	{2,0x3EBE, 0x0000},
+	{2,0x3EC0, 0x0000},
+	{2,0x3EC2, 0x0000},
+	{2,0x3EC4, 0x0000},
+	{2,0x3EC6, 0x0000},
+	{2,0x3EC8, 0x0000},
+	{2,0x3ECA, 0x0000},
+	{2,0x3170, 0x2150},    //Manufacturer-Specific
+	{2,0x317A, 0x0150},    //Manufacturer-Specific
+	{2,0x3ECC, 0x2200},    //Manufacturer-Specific
+	{2,0x3174, 0x0000},    //Manufacturer-Specific
+	{2,0x3176, 0X0000},    //Manufacturer-Specific
+	{2,0x30BC, 0x0384},    //CALIB_GLOBAL
+	{2,0x30C0, 0x1220},    //CALIB_CONTROL
+	
+	//{2,0x301C, 0x01 };    //Turn-on streamming
+	
+	// PLL Settings
+	{2,0x0300, 0x07},    //vt_pix_clk_div = 0x7
+	{2,0x0302, 0x01},    //vt_sys_clk_div = 0x1
+	{2,0x0304, 0x03},    //pre_pll_clk_div = 0x3
+	{2,0x0306, 0x62},    //pll_multiplier = 0x62
+	{2,0x0308, 0x0A},    //op_pix_clk_div = 0xA
+	{2,0x030A, 0x01},    //op_sys_clk_div = 0x1
+	{TIME_DELAY, 0, 1},               // Allow PLL to lock
+	
+	// Timing Settings
+	{2,0x0104, 0x1},    //Grouped Parameter Hold = 0x1
+	{2,0x034C, 0x0780},    //Output Width = 0x780
+	{2,0x034E, 0x0438},    //Output Height = 0x438
+	{2,0x0344, 0x0158},    //Column Start = 0x158
+	{2,0x0346, 0x01B8},    //Row Start = 0x1B8
+	{2,0x0348, 0x08D7},    //Column End = 0x8D7
+	{2,0x034A, 0x05EF},    //Row End = 0x5EF
+	{2,0x3040, 0x8041},    //Read Mode = 0x41
+	{2,0x3010, 0x00A0},    //Fine Correction = 0xA0
+	{2,0x3012, 0x04D2},    //Coarse Integration Time = 0x4D2
+	{2,0x3014, 0x09EC},    //Fine Integration Time = 0x9EC
+	{2,0x0340, 0x04D3},    //Frame Lines = 0x4D3
+	{2,0x0342, 0x0BCE},    //Line Length = 0xBCE
+	{1,0x0104, 0x00},    //Grouped Parameter Hold = 0x0
+	{1,0x0100, 0x01},    //Mode Select = 0x1
+	
+	//1080P
+	{2,0x0400, 0x0000}, // SCALING_MODE----disabled the scaling
+	{2,0x0404, 0x0010}, // SCALE_M
+	{2,0x0300, 0x0007}, // VT_PIX_CLK_DIV (N/A)
+	{2,0x0302, 0x0001}, // VT_SYS_CLK_DIV  (1/1)
+	{2,0x0304, 0x0003}, // PRE_PLL_CLK_DIV  (1/2)
+	{2,0x0306, 0x0062}, // PLL_MULTIPLIER  (1/49 dec)
+	{2,0x0308, 0x000A}, // OP_PIX_CLK_DIV
+	{2,0x030A, 0x0001}, // OP_SYS_CLK_DIV     1/10
+	
+	//{0x0104, 0x01},  // GROUPED_PARAMETER_HOLD     
+	{2,0x3004, 0x0008},  // X_ADDR_START_            
+	{2,0x3008, 0x0787},  // X_ADDR_END_              
+	{2,0x3002, 0x0008},  // Y_ADDR_START_            
+	{2,0x3006, 0x043F},  // Y_ADDR_END_              
+	{2,0x3040, 0x8041},  // READ_MODE                
+	{2,0x0382, 0x0001},  //X_ODD_INC
+	{2,0x0386, 0x0001},  //Y_ODD_INC  
+	{2,0x034C, 0x0780},  // X_OUTPUT_SIZE            
+	{2,0x034E, 0x0438},  // Y_OUTPUT_SIZE            
+	{2,0x300C, 0x0BCE},  // LINE_LENGTH_PCK_ ///HTS
+	{2,0x300A, 0x04D3},  // FRAME_LENGTH_LINES_ //VTS
+	{2,0x3012, 0x04D2},  // COARSE_INTEGRATION_TIME_ 
+	{2,0x3014, 0x09EC},  // FINE_INTEGRATION_TIME_ 
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_capture_5M_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0543_5M_script_mipi[] = {
+	//[AR0542 (A-5141) Register Wizard Defaults]
+	{1, 0x0100, 0x0},	//Mode Select = 0x0
+	//REG = 0x301A, 0x0018	//Reset Register = 0x18
+	{2, 0x0112, 0x0A0A},	//CCP Data Format = 0xA0A
+	{2, 0x3064, 0x7800},	//SMIA_Test = 0x7800
+	{2, 0x31AE, 0x0202},	//Serial Format = 0x202
+	
+	//Silicon Recommendation
+	//REG= 0x301C, 0x00 	//Turn-off streamming
+	{2, 0x316A, 0x8400}, 	//RESERVED
+	{2, 0x316C, 0x8400}, 	//RESERVED
+	{2, 0x316E, 0x8400}, 	//RESERVED
+	{2, 0x3EFA, 0x171F}, 	//RESERVED
+	{2, 0x3ED2, 0xD965}, 	//Manufacturer-Specific
+	{2, 0x3ED8, 0x7F1B}, 	//Manufacturer-Specific
+	{2, 0x3EDA, 0x2F11}, 	//Manufacturer-Specific
+	{2, 0x3EDE, 0xB000}, 	//Manufacturer-Specific
+	{2, 0x3EE2, 0x0060}, 	//Manufacturer-Specific
+	{2, 0x3EF2, 0xD965}, 	//Manufacturer-Specific
+	{2, 0x3EF8, 0x797F}, 	//Manufacturer-Specific
+	{2, 0x3EFC, 0x246F}, 	//Manufacturer-Specific
+	{2, 0x3EFE, 0x6F01}, 	//Manufacturer-Specific
+	//LOAD= A-5141_pixel_timing
+	{2, 0x3E00, 0x0428},
+	{2, 0x3E02, 0xFFFF},
+	{2, 0x3E04, 0xFFFF},
+	{2, 0x3E06, 0xFFFF},
+	{2, 0x3E08, 0x8071},
+	{2, 0x3E0A, 0x7281},
+	{2, 0x3E0C, 0x0041},
+	{2, 0x3E0E, 0x5355},
+	{2, 0x3E10, 0x8710},
+	{2, 0x3E12, 0x6085},
+	{2, 0x3E14, 0x4080},
+	{2, 0x3E16, 0x41A0},
+	{2, 0x3E18, 0x0018},
+	{2, 0x3E1A, 0x9057},
+	{2, 0x3E1C, 0xA049},
+	{2, 0x3E1E, 0xA649},
+	{2, 0x3E20, 0x8846},
+	{2, 0x3E22, 0x8142},
+	{2, 0x3E24, 0x0082},
+	{2, 0x3E26, 0x8B49},
+	{2, 0x3E28, 0x9C49},
+	{2, 0x3E2A, 0x8A10},
+	{2, 0x3E2C, 0x0C82},
+	{2, 0x3E2E, 0x4784},
+	{2, 0x3E30, 0x4D85},
+	{2, 0x3E32, 0x0406},
+	{2, 0x3E34, 0x9510},
+	{2, 0x3E36, 0x0EC3},
+	{2, 0x3E38, 0x4A42},
+	{2, 0x3E3A, 0x8341},
+	{2, 0x3E3C, 0x8B4B},
+	{2, 0x3E3E, 0xA84B},
+	{2, 0x3E40, 0x8056},
+	{2, 0x3E42, 0x8000},
+	{2, 0x3E44, 0x1C81},
+	{2, 0x3E46, 0x10E0},
+	{2, 0x3E48, 0x8055},
+	{2, 0x3E4A, 0x1C00},
+	{2, 0x3E4C, 0x827C},
+	{2, 0x3E4E, 0x0970},
+	{2, 0x3E50, 0x8082},
+	{2, 0x3E52, 0x7281},
+	{2, 0x3E54, 0x4C40},
+	{2, 0x3E56, 0x9110},
+	{2, 0x3E58, 0x0C85},
+	{2, 0x3E5A, 0x4D9E},
+	{2, 0x3E5C, 0x4D80},
+	{2, 0x3E5E, 0x100C},
+	{2, 0x3E60, 0x8E40},
+	{2, 0x3E62, 0x4C81},
+	{2, 0x3E64, 0x7C51},
+	{2, 0x3E66, 0x7000},
+	{2, 0x3E68, 0x0000},
+	{2, 0x3E6A, 0x0000},
+	{2, 0x3E6C, 0x0000},
+	{2, 0x3E6E, 0x0000},
+	{2, 0x3E70, 0x0000},
+	{2, 0x3E72, 0x0000},
+	{2, 0x3E74, 0x0000},
+	{2, 0x3E76, 0x0000},
+	{2, 0x3E78, 0x0000},
+	{2, 0x3E7A, 0x0000},
+	{2, 0x3E7C, 0x0000},
+	{2, 0x3E7E, 0x0000},
+	{2, 0x3E80, 0x0000},
+	{2, 0x3E82, 0x0000},
+	{2, 0x3E84, 0x0000},
+	{2, 0x3E86, 0x0000},
+	{2, 0x3E88, 0x0000},
+	{2, 0x3E8A, 0x0000},
+	{2, 0x3E8C, 0x0000},
+	{2, 0x3E8E, 0x0000},
+	{2, 0x3E90, 0x0000},
+	{2, 0x3E92, 0x0000},
+	{2, 0x3E94, 0x0000},
+	{2, 0x3E96, 0x0000},
+	{2, 0x3E98, 0x0000},
+	{2, 0x3E9A, 0x0000},
+	{2, 0x3E9C, 0x0000},
+	{2, 0x3E9E, 0x0000},
+	{2, 0x3EA0, 0x0000},
+	{2, 0x3EA2, 0x0000},
+	{2, 0x3EA4, 0x0000},
+	{2, 0x3EA6, 0x0000},
+	{2, 0x3EA8, 0x0000},
+	{2, 0x3EAA, 0x0000},
+	{2, 0x3EAC, 0x0000},
+	{2, 0x3EAE, 0x0000},
+	{2, 0x3EB0, 0x0000},
+	{2, 0x3EB2, 0x0000},
+	{2, 0x3EB4, 0x0000},
+	{2, 0x3EB6, 0x0000},
+	{2, 0x3EB8, 0x0000},
+	{2, 0x3EBA, 0x0000},
+	{2, 0x3EBC, 0x0000},
+	{2, 0x3EBE, 0x0000},
+	{2, 0x3EC0, 0x0000},
+	{2, 0x3EC2, 0x0000},
+	{2, 0x3EC4, 0x0000},
+	{2, 0x3EC6, 0x0000},
+	{2, 0x3EC8, 0x0000},
+	{2, 0x3ECA, 0x0000},
+	{2, 0x3170, 0x2150},	//Manufacturer-Specific
+	{2, 0x317A, 0x0150},	//Manufacturer-Specific
+	{2, 0x3ECC, 0x2200},	//Manufacturer-Specific
+	{2, 0x3174, 0x0000},	//Manufacturer-Specific
+	{2, 0x3176, 0X0000},	//Manufacturer-Specific
+	{2, 0x30BC, 0x0384},	//CALIB_GLOBAL
+	{2, 0x30C0, 0x1220},	//CALIB_CONTROL
+	
+	//REG= 0x301C, 0x01 	//Turn-on streamming
+	
+	// PLL Settings
+	{1, 0x0300, 0x08},	//vt_pix_clk_div = 0x8
+	{1, 0x0302, 0x01},	//vt_sys_clk_div = 0x1
+	{1, 0x0304, 0x02},	//pre_pll_clk_div = 0x2
+	{1, 0x0306, 0x40},	//pll_multiplier = 0x40
+	{1, 0x0308, 0x0A},	//op_pix_clk_div = 0xA
+	{1, 0x030A, 0x01},	//op_sys_clk_div = 0x1
+	//DELAY = 1               // Allow PLL to lock
+	{TIME_DELAY, 0, 1}, 
+	
+	// Timing Settings
+	{1, 0x0104, 0x1}, 	//Grouped Parameter Hold = 0x1
+	{2, 0x034C, 0x0A20},	//Output Width = 0xA20
+	{2, 0x034E, 0x0798},	//Output Height = 0x798
+	{2, 0x0344, 0x008 },      //Column Start = 0x8
+	{2, 0x0346, 0x008 },      //Row Start = 0x8
+	{2, 0x0348, 0xA27 },      //Column End = 0xA27
+	{2, 0x034A, 0x79F },      //Row End = 0x79F
+	{2, 0x3040, 0x0041},	//Read Mode = 0x41
+	{2, 0x3010, 0x00A0},	//Fine Correction = 0xA0
+	{2, 0x3012, 0x07E4},	//Coarse Integration Time = 0x7E4
+	{2, 0x3014, 0x0D43},	//Fine Integration Time = 0xD43
+	{2, 0x0340, 0x07E5},	//Frame Lines = 0x7E5
+	{2, 0x0342, 0x0F25},	//Line Length = 0xF25
+	{1, 0x0104, 0x0},	//Grouped Parameter Hold = 0x0
+	{1, 0x0100, 0x1},	//Mode Select = 0x1
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static resolution_param_t  prev_resolution_array[] = {
+	{
+		.frmsize			= {640, 480},
+		.active_frmsize		= {640, 480},
+		.active_fps			= 30,
+		.size_type			= SIZE_VGA_640X480,
+		.reg_script[0]		= AR0543_preview_VGA_script,
+		.reg_script[1]		= AR0543_VGA_script_mipi,
+	}, {
+		.frmsize			= {1280, 720},
+		.active_frmsize		= {1280, 720},
+		.active_fps			= 30,
+		.size_type			= SIZE_720P_1280X720,
+		.reg_script[0]		= AR0543_preview_720P_script,
+		.reg_script[1]		= AR0543_720P_script_mipi,
+	}, {
+		.frmsize			= {1280, 960},
+		.active_frmsize		= {1280, 960},
+		.active_fps			= 30,
+		.size_type			= SIZE_960P_1280X960,
+		.reg_script[0]		= AR0543_preview_960P_script,
+		.reg_script[1]		= AR0543_960P_script_mipi,
+	}, {
+		.frmsize			= {1920, 1080},
+		.active_frmsize		= {1920, 1080},
+		.active_fps			= 15,
+		.size_type			= SIZE_1080P_1920X1080,
+		.reg_script[0]		= AR0543_preview_1080P_script,
+		.reg_script[1]		= AR0543_1080P_script_mipi,
+	}
+};
+
+static resolution_param_t  debug_prev_resolution_array[] = {
+	{
+		.frmsize			= {640, 480},
+		.active_frmsize		= {640, 480},
+		.active_fps			= 30,
+		.size_type			= SIZE_VGA_640X480,
+		.reg_script[0]		= AR0543_preview_VGA_script,
+		.reg_script[1]		= AR0543_VGA_script_mipi,
+	}, {
+		.frmsize			= {1280, 720},
+		.active_frmsize		= {1280, 720},
+		.active_fps			= 30,
+		.size_type			= SIZE_720P_1280X720,
+		.reg_script[0]		= AR0543_preview_720P_script,
+		.reg_script[1]		= AR0543_720P_script_mipi,
+	}, {
+		.frmsize			= {1280, 960},
+		.active_frmsize		= {1280, 960},
+		.active_fps			= 30,
+		.size_type			= SIZE_960P_1280X960,
+		.reg_script[0]		= AR0543_preview_960P_script,
+		.reg_script[1]		= AR0543_960P_script_mipi,
+	}, {
+		.frmsize			= {1920, 1080},
+		.active_frmsize		= {1920, 1080},
+		.active_fps			= 15,
+		.size_type			= SIZE_1080P_1920X1080,
+		.reg_script[0]		= AR0543_preview_1080P_script,
+		.reg_script[1]		= AR0543_1080P_script_mipi,
+	},{
+		.frmsize			= {2592, 1944},
+		.active_frmsize		= {2592, 1944},
+		.active_fps			= 7.5,
+		.size_type			= SIZE_H1080P_2592X1944,
+		.reg_script[0]		= AR0543_capture_5M_script,
+		.reg_script[1]		= AR0543_5M_script_mipi,
+	},
+};	
+
+static resolution_param_t  capture_resolution_array[] = {
+	{
+		.frmsize			= {2592, 1944},
+		.active_frmsize		= {2592, 1944},
+		.active_fps			= 7.5,
+		.size_type			= SIZE_H1080P_2592X1944,
+		.reg_script[0]			= AR0543_capture_5M_script,
+		.reg_script[1]			= AR0543_5M_script_mipi,
+	},
+};
+
+
+static void parse_param(const char *buf,char **parm){
+	char *buf_orig, *ps, *token;
+	unsigned int n=0;
+
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	ps = buf_orig;
+	while(1) {
+	        token = strsep(&ps, " \n");
+	        if (token == NULL)
+	                break;
+	        if (*token == '\0')
+	                continue;
+	        parm[n++] = token;
+	        printk("%s\n",parm[n-1]);
+	}
+	//kfree(buf_orig);
+}
+
+extern int aml_i2c_put_word(struct i2c_adapter *adapter, 
+		unsigned short dev_addr, unsigned short addr, unsigned short data);
+
+void AR0543_manual_set_aet(unsigned int exp,unsigned int ag,unsigned int vts){
+	unsigned char exp_h = 0, exp_m = 0, exp_l = 0, ag_h = 0, ag_l = 0, vts_h = 0, vts_l = 0;
+	struct i2c_adapter *adapter;
+	adapter = i2c_get_adapter(4);
+	
+	aml_i2c_put_word(adapter, 0x36, 0x3012, exp & 0xffff);
+	
+	//aml_i2c_put_word(adapter, 0x36, 0x0204, ag & 0xffff);
+	
+	aml_i2c_put_word(adapter, 0x36, 0x0340, vts & 0xffff);	
+}
+
+static ssize_t aet_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char *param[3] = {NULL};
+	unsigned int exp = 0, ag = 0, vts = 0;
+	parse_param(buf,&param[0]);
+	
+	if(param[0] == NULL || param[1] == NULL || param[2] == NULL){
+		printk("wrong param\n");
+		return len;	
+	}	
+	sscanf(param[0],"%x",&exp);
+	sscanf(param[1],"%x",&ag);
+	sscanf(param[2],"%x",&vts);
+	
+	AR0543_manual_set_aet(exp,ag,vts);
+	return len;
+}
+
+static ssize_t aet_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	return len;
+}
+
+static CLASS_ATTR(aet_debug, 0664, aet_manual_show, aet_manual_store);
+
+/* ar0543 uses exp+ag mode */
+static bool AR0543_set_aet_new_step(unsigned int new_step, bool exp_mode, bool ag_mode){
+  unsigned int exp = 0, ag = 0, vts = 0;
+  if ((!exp_mode) || (!ag_mode) || (new_step > sensor_aet_info[current_fmt].tbl_max_step))
+		return(false);
+	else
+	{
+		sensor_aet_step = new_step;
+		exp = sensor_aet_table[sensor_aet_step].exp;
+		ag = sensor_aet_table[sensor_aet_step].ag;
+		vts = sensor_aet_table[sensor_aet_step].vts;
+		
+		AR0543_manual_set_aet(exp,ag,vts);
+		return true;
+	}
+}
+
+
+static bool AR0543_check_mains_freq(void){// when the fr change,we need to change the aet table
+    int detection; 
+    struct i2c_adapter *adapter;	
+	#if 0
+    if(exp_mode != 2)//if current is not auto mode ,return
+        return false;
+
+    detection = my_i2c_get_byte(adapter,0x36,0x3c0c) & 1;
+    if(current_fr != detection){
+        change_cnt++;
+        if(change_cnt > 5){
+            aet_index ^= 1;
+            sensor_aet_info = cf->aet.aet[aet_index].info;
+            sensor_aet_table = cf->aet.aet[aet_index].aet_table;
+            sensor_aet_step = sensor_aet_info->tbl_rated_step;
+            change_cnt = 0;
+            current_fr = detection;
+            return true;
+        }	
+    }else{
+        change_cnt = 0;	
+    }
+    return false;
+	#endif
+	return true;
+}
+
+bool AR0543_set_af_new_step(unsigned int af_step){
+    struct i2c_adapter *adapter;
+    char buf[3];
+    if(af_step == last_af_step)
+        return true;
+	/*
+    diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
+    last_af_step = af_step;
+    if(diff < 256){
+        codes = 1;
+    }else if(diff < 512){
+        codes = 2;	
+    }else
+        codes = 3;
+    vcm_data |= (codes << 2); // bit[3:2]
+    vcm_data |= (last_af_step << 4);  // bit[4:13]
+    byte_h  = (vcm_data >> 8) & 0x000000ff;
+    byte_l  = (vcm_data >> 0) & 0x000000ff;
+*/	
+	last_af_step = af_step;
+    buf[0] = (af_step>>4)&0xff;
+    buf[1] = (af_step<<4)&0xff;
+    //adapter = i2c_get_adapter(4);
+   // my_i2c_put_byte_add8(adapter,0x0c,buf,2);
+    return true;
+
+}
+
+
+
+void AR0543_set_new_format(int width,int height,int fr){
+    int index = 0;
+    current_fr = fr;
+    printk("sum:%d,mode:%d,fr:%d\n",cf->aet.sum,ar0543_work_mode,fr);
+    while(index < cf->aet.sum){
+        if(width == cf->aet.aet[index].info->fmt_hactive && height == cf->aet.aet[index].info->fmt_vactive \
+                && fr == cf->aet.aet[index].info->fmt_main_fr && ar0543_work_mode == cf->aet.aet[index].info->fmt_capture){
+            break;	
+        }
+        index++;	
+    }
+    if(index >= cf->aet.sum){
+        printk("use default value\n");
+        index = 0;	
+    }
+    printk("current aet index :%d\n",index);
+    sensor_aet_info = cf->aet.aet[index].info;
+    sensor_aet_table = cf->aet.aet[index].aet_table;
+    sensor_aet_step = sensor_aet_info->tbl_rated_step;
+    AR0543_set_aet_new_step(sensor_aet_step,1,1);
+}
+
+
+
+void AR0543_ae_manual_set(char **param){
+	if(param[0] == NULL || param[1] == NULL || param[2] == NULL){
+		printk("wrong param\n");
+		return ;	
+	}	
+	sscanf(param[0],"%x",&g_ae_manual_exp);
+	sscanf(param[1],"%x",&g_ae_manual_ag);
+	sscanf(param[2],"%x",&g_ae_manual_vts);
+	
+	g_ae_manual_exp = (g_ae_manual_exp > 0x0000ffff) ? 0x0000ffff : g_ae_manual_exp;
+	g_ae_manual_ag = (g_ae_manual_ag > 0x000003ff) ? 0x000003ff : g_ae_manual_ag;
+	g_ae_manual_vts = (g_ae_manual_vts > 0x0000ffff) ? 0x0000ffff : g_ae_manual_vts;
+	
+	AR0543_manual_set_aet(g_ae_manual_exp,g_ae_manual_ag,g_ae_manual_vts);
+}           
+
+static ssize_t ae_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char *param[3] = {NULL};
+	parse_param(buf,&param[0]);
+	AR0543_ae_manual_set(&param[0]);
+	return len;
+}
+
+static ssize_t ae_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	printk("exp:%x,ag%x,vts:%x\n",g_ae_manual_exp,g_ae_manual_ag,g_ae_manual_vts);
+	return len;
+}
+
+static CLASS_ATTR(ae_debug, 0664, ae_manual_show, ae_manual_store);
+
+static ssize_t i2c_debug_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char cmd;
+	int addr,value;
+    int endaddr;
+	struct i2c_adapter *adapter;
+	char *param[3] = {NULL};
+
+	parse_param(buf,&param[0]);
+	sscanf(param[0],"%c",&cmd);
+	printk("cmd:%c\n",cmd);
+	adapter = i2c_get_adapter(4);
+    switch( cmd ){
+        case 'w':
+			sscanf(param[1],"%x",&addr);
+			sscanf(param[2],"%x",&value);
+			my_i2c_put_byte(adapter,0x36,addr,value);
+                break;
+        case 'r':
+			sscanf(param[1],"%x",&addr);
+			value = my_i2c_get_byte(adapter,0x36,addr);
+			printk("reg:%x,value:%x\n",addr,value);
+                break;
+        case 'd':
+			sscanf(param[1],"%x",&addr);
+			sscanf(param[2],"%x",&endaddr);
+                for( ;addr <= endaddr; addr++)
+                {
+                        value = my_i2c_get_byte(adapter,0x36,addr);
+                        printk("[0x%04x]=0x%08x\n",addr,value);
+                }
+                break;
+        default :
+                break;
+	}
+	
+	return len;
+}
+
+static ssize_t i2c_debug_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+
+	size_t len = 0;
+
+	return len;
+}
+
+static CLASS_ATTR(camera_debug, 0664, i2c_debug_show, i2c_debug_store);
+
+static void power_down_ar0543(struct ar0543_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//i2c_put_byte(client,0x0104, 0x00);
+	//i2c_put_byte(client,0x0100, 0x00);
+}
+
+static ssize_t vcm_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	struct i2c_adapter *adapter;
+	char buff[3];
+	unsigned int af_step = 0;
+	unsigned int diff = 0;
+	int codes,vcm_data;
+	unsigned char byte_h, byte_l;
+	sscanf(buf,"%d",&af_step);
+    if(af_step == last_af_step)
+        return len;
+    diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
+    last_af_step = af_step;
+    if(diff < 256){
+        codes = 1;
+    }else if(diff < 512){
+        codes = 2;	
+    }else
+        codes = 3;
+    vcm_data |= (codes << 2); // bit[3:2]
+    vcm_data |= (last_af_step << 4);  // bit[4:13]
+    printk("set vcm step :%x\n",vcm_data);   
+    byte_h  = (vcm_data >> 8) & 0x000000ff;
+    byte_l  = (vcm_data >> 0) & 0x000000ff;
+    buff[0] = byte_h;
+    buff[1] = byte_l;
+    /*adapter = i2c_get_adapter(4);
+    my_i2c_put_byte_add8(adapter,0x0c,buff,2);
+    */
+    return len;
+}
+
+static ssize_t vcm_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	struct i2c_adapter *adapter;
+	unsigned int af;
+	//adapter = i2c_get_adapter(4);
+	//af = my_i2c_get_word(adapter,0x0c);
+	printk("current vcm step :%x\n",af);
+	return len;
+}
+
+static CLASS_ATTR(vcm_debug, 0664, vcm_manual_show, vcm_manual_store);
+
+static ssize_t light_source_freq_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	int freq;
+	sscanf(buf,"%d",&freq);
+	current_fr = freq ? 1 : 0;
+	printk("set current light soure frequency :%d\n",freq);
+	return len;
+}
+
+static ssize_t light_source_freq_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	printk("light source frequence :%d\n",current_fr);
+	return len;
+}
+
+static CLASS_ATTR(light_source_debug, 0664, light_source_freq_manual_show, light_source_freq_manual_store);
+
+
+void AR0543_init_regs(struct ar0543_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int i=0;
+	
+	while (1) {
+		if (AR0543_init_script[i].type == END_OF_SCRIPT) {
+			printk("success in initial AR0543.\n");
+			break;
+		}
+		if ((cam_i2c_send_msg(client, AR0543_init_script[i])) < 0) {
+			printk("fail in initial AR0543. \n");
+			return;
+		}
+		i++;
+	}
+	return;
+}
+
+static ssize_t version_info_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	return len;
+}
+
+static ssize_t version_info_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+    if(cf->version_info_valid == 0)
+        printk("verion info envalid\n");
+    else{
+        printk("Date %s",cf->version.date);
+        printk("Module %s",cf->version.module);
+        printk("Version %s",cf->version.version);	
+    }
+    return len;
+}
+
+static CLASS_ATTR(version_debug, 0664, version_info_show, version_info_store);
+/*************************************************************************
+* FUNCTION
+*    AR0543_set_param_wb
+*
+* DESCRIPTION
+*    wb setting.
+*
+* PARAMETERS
+*    none
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+
+static wb_pair_t wb_pair[] = {
+    {CAM_WB_AUTO,"CAM_WB_AUTO"},
+    {CAM_WB_CLOUD,"CAM_WB_CLOUD"},
+    {CAM_WB_DAYLIGHT,"CAM_WB_DAYLIGHT"},
+    {CAM_WB_INCANDESCENCE,"CAM_WB_INCANDESCENCE"},
+    {CAM_WB_TUNGSTEN,"CAM_WB_TUNGSTEN"},
+    {CAM_WB_FLUORESCENT,"CAM_WB_FLUORESCENT"},
+    {CAM_WB_MANUAL,"CAM_WB_MANUAL"},
+    {CAM_WB_SHADE,"CAM_WB_SHADE"},
+    {CAM_WB_TWILIGHT,"CAM_WB_TWILIGHT"},
+    {CAM_WB_WARM_FLUORESCENT,"CAM_WB_WARM_FLUORESCENT"},
+};
+
+void AR0543_set_param_wb(struct ar0543_device *dev,enum  camera_wb_flip_e para)//white balance
+{
+    int index = 0;
+    int i = 0;
+    while(i < ARRAY_SIZE(wb_pair)){
+        if(wb_pair[i].wb == para){
+            break;
+        }else
+            i++;
+    }
+    if(i == ARRAY_SIZE(wb_pair)){
+        printk("not support this wb\n");
+        return;
+    }
+    if(cf != NULL && cf->wb_valid == 1){
+        while(index < cf->wb.sum){
+            if(strcmp(wb_pair[i].name, cf->wb.wb[index].name) == 0){
+                break;	
+            }
+            index++;
+        }
+        if(index == cf->wb.sum){
+            printk("invalid wb value\n");
+            return;	
+        }
+        if(para == CAM_WB_AUTO){
+            printk("auto wb\n");
+            dev->cam_para->cam_command = CAM_COMMAND_AWB;
+        }else{
+            dev->cam_para->cam_command = CAM_COMMAND_MWB;
+            memcpy(dev->cam_para->xml_wb_manual->reg_map,cf->wb.wb[index].export,2*sizeof(int));
+        }
+        printk("set wb :%d\n",index);
+        dev->fe_arg.port = TVIN_PORT_ISP;
+        dev->fe_arg.index = 0;
+        dev->fe_arg.arg = (void *)(dev->cam_para);
+        dev->vops->tvin_fe_func(0,&dev->fe_arg);
+    }else{
+        return;	
+    }
+
+} /* AR0543_set_param_wb */
+/*************************************************************************
+ * FUNCTION
+ *    AR0543_set_param_exposure
+ *
+ * DESCRIPTION
+ *    exposure setting.
+ *
+ * PARAMETERS
+ *    none
+ *
+ * RETURNS
+ *    None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void AR0543_set_param_exposure(struct ar0543_device *dev,enum camera_exposure_e para)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    int value;
+    if(para == EXPOSURE_0_STEP){
+        dev->cam_para->cam_command = CAM_COMMAND_AE_ON;
+        dev->ae_on = true;
+    }else{
+        if(dev->ae_on == false){ // set ae on
+            dev->cam_para->cam_command = CAM_COMMAND_AE_ON;	
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            dev->ae_on = true;
+        }
+        value = para < 8 ? para : 7;
+        value = value > 0 ? value : 1;
+        value -= 4;
+        dev->cam_para->cam_command = CAM_COMMAND_SET_AE_LEVEL;
+        dev->cam_para->exposure_level = value;
+        printk("set manual exposure level:%d\n",value);
+    }
+    dev->fe_arg.port = TVIN_PORT_ISP;
+    dev->fe_arg.index = 0;
+    dev->fe_arg.arg = (void *)(dev->cam_para);
+    dev->vops->tvin_fe_func(0,&dev->fe_arg);	
+
+} /* ar0543_set_param_exposure */
+/*************************************************************************
+ * FUNCTION
+ *    AR0543_set_param_effect
+ *
+ * DESCRIPTION
+ *    effect setting.
+ *
+ * PARAMETERS
+ *    none
+ *
+ * RETURNS
+ *    None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static effect_pair_t effect_pair[] = {
+    {SPECIAL_EFFECT_NORMAL,"CAM_EFFECT_ENC_NORMAL"},
+    {SPECIAL_EFFECT_BW,NULL},
+    {SPECIAL_EFFECT_BLUISH,"CAM_EFFECT_ENC_SEPIABLUE"},
+    {SPECIAL_EFFECT_SEPIA,"CAM_EFFECT_ENC_SEPIA"},
+    {SPECIAL_EFFECT_REDDISH,NULL},
+    {SPECIAL_EFFECT_GREENISH,"CAM_EFFECT_ENC_SEPIAGREEN"},
+    {SPECIAL_EFFECT_NEGATIVE,"CAM_EFFECT_ENC_COLORINV"}
+};
+
+void AR0543_set_param_effect(struct ar0543_device *dev,enum camera_effect_flip_e para)
+{
+    int index = 0;
+    int i = 0;
+    while(i < ARRAY_SIZE(effect_pair)){
+        if(effect_pair[i].effect == para){
+            break;
+        }else
+            i++;
+    }
+    if(i == ARRAY_SIZE(effect_pair)){
+        printk("not support\n");
+        return;
+    }
+    if(cf != NULL && cf->effect_valid == 1){
+        while(index < cf->eff.sum){
+            if(strcmp(effect_pair[i].name, cf->eff.eff[index].name) == 0){
+                break;	
+            }
+            index++;
+        }
+        if(index == cf->eff.sum){
+            printk("invalid effect value\n");
+            return;	
+        }
+        dev->cam_para->cam_command = CAM_COMMAND_EFFECT;
+        memcpy(dev->cam_para->xml_effect_manual->csc.reg_map,cf->eff.eff[index].export,18*sizeof(unsigned int));
+
+        dev->fe_arg.port = TVIN_PORT_ISP;
+        dev->fe_arg.index = 0;
+        dev->fe_arg.arg = (void *)(dev->cam_para);
+        printk("call tvin fe func\n");
+        dev->vops->tvin_fe_func(0,&dev->fe_arg);
+        return;
+    } 
+
+} /* AR0543_set_param_effect */
+
+/*************************************************************************
+ * FUNCTION
+ *    AR0543_NightMode
+ *
+ * DESCRIPTION
+ *    This function night mode of AR0543.
+ *
+ * PARAMETERS
+ *    none
+ *
+ * RETURNS
+ *    None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void AR0543_set_night_mode(struct ar0543_device *dev,enum  camera_night_mode_flip_e enable)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    if (50) {
+        
+    }
+    else{
+       
+    }
+
+}   /* AR0543_NightMode */
+
+static void AR0543_set_param_banding(struct ar0543_device *dev,enum  camera_night_mode_flip_e banding)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    switch(banding){
+        case CAM_BANDING_60HZ:
+            printk("set banding 60Hz\n");
+            
+            break;
+        case CAM_BANDING_50HZ:
+            printk("set banding 50Hz\n");
+           
+            break;
+        default:
+            break;
+    }
+}
+
+
+static int AR0543_AutoFocus(struct ar0543_device *dev, int focus_mode)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    int ret = 0;
+
+    switch (focus_mode) {
+        case CAM_FOCUS_MODE_AUTO:       
+            printk("auto focus mode start\n");
+            bDoingAutoFocusMode = true;
+            dev->cam_para->cam_command = CAM_COMMAND_FULLSCAN;
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            if(dev->vops != NULL){
+                dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            }
+            break;
+
+        case CAM_FOCUS_MODE_CONTI_VID:
+        case CAM_FOCUS_MODE_CONTI_PIC:
+            printk("continus focus\n");
+            dev->cam_para->cam_command = CAM_COMMAND_CONTINUOUS_FOCUS_ON;
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            if(dev->vops != NULL){
+                dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            }
+            printk("start continous focus\n");
+            break;
+
+        case CAM_FOCUS_MODE_RELEASE:
+        case CAM_FOCUS_MODE_FIXED:
+            printk("continus focus\n");
+            dev->cam_para->cam_command = CAM_COMMAND_CONTINUOUS_FOCUS_OFF;
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            if(dev->vops != NULL){
+                dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            }
+            printk("focus release\n");
+            break;
+        default:
+            printk("release focus to infinit\n");
+            break;
+    }
+    return ret;
+
+}
+
+static int set_flip(struct ar0543_device *dev)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    unsigned char temp;
+    temp = i2c_get_byte(client, 0x0101);
+    temp &= 0xfc;
+    temp |= dev->cam_info.m_flip << 0;
+    temp |= dev->cam_info.v_flip << 1;
+    //printk("dst temp is 0x%x\n", temp);
+    /*if((i2c_put_byte(client, 0x0101, temp)) < 0) {
+        printk("fail in setting sensor orientation \n");
+        return -1;
+    }*/
+}
+
+
+static resulution_size_type_t get_size_type(int width, int height)
+{
+    resulution_size_type_t rv = SIZE_NULL_TYPE;
+    if (width * height >= 2500 * 1900)
+        rv = SIZE_H1080P_2592X1944;
+    else if (width * height >= 1900 * 1000)
+        rv = SIZE_1080P_1920X1080;
+    else if (width * height >= 1200 * 900)
+        rv = SIZE_960P_1280X960;
+    else if (width * height >= 1200 * 700)
+        rv = SIZE_720P_1280X720;
+    else if (width * height >= 600 * 400)
+        rv = SIZE_VGA_640X480;
+    return rv;
+}
+
+static int AR0543_FlashCtrl(struct ar0543_device *dev, int flash_mode)
+{
+    switch (flash_mode) {
+        case FLASHLIGHT_ON:
+        case FLASHLIGHT_AUTO:
+        case FLASHLIGHT_OFF:
+            dev->cam_para->cam_command = CAM_COMMAND_SET_FLASH_MODE;
+            dev->cam_para->flash_mode = flash_mode;
+            break;
+        case FLASHLIGHT_TORCH:
+            dev->cam_para->cam_command = CAM_COMMAND_TORCH;
+            dev->cam_para->level = 100;
+            break;
+        default:
+            printk("this flash mode not support yet\n");
+            return -1;
+    }
+    dev->fe_arg.port = TVIN_PORT_ISP;
+    dev->fe_arg.index = 0;
+    dev->fe_arg.arg = (void *)(dev->cam_para);
+    if(dev->vops != NULL){
+        dev->vops->tvin_fe_func(0,&dev->fe_arg);
+    }
+    return 0;
+}
+
+static resolution_param_t* get_resolution_param(struct ar0543_device *dev, int ar0543_work_mode, int width, int height)
+{
+    int i = 0;
+    int arry_size = 0;
+    resolution_param_t* tmp_resolution_param = NULL;
+    resulution_size_type_t res_type = SIZE_NULL_TYPE;
+    printk("target resolution is %dX%d\n", width, height);
+    res_type = get_size_type(width, height);
+    if (res_type == SIZE_NULL_TYPE)
+        return NULL;
+    if (ar0543_work_mode == CAMERA_CAPTURE) {
+        tmp_resolution_param = capture_resolution_array;
+        arry_size = ARRAY_SIZE(capture_resolution_array);
+    } else {
+        tmp_resolution_param = debug_prev_resolution_array;
+        arry_size = ARRAY_SIZE(debug_prev_resolution_array);
+    }
+    for (i = 0; i < arry_size; i++) {
+        if (tmp_resolution_param[i].size_type == res_type)
+            return &tmp_resolution_param[i];
+    }
+    return NULL;
+}
+
+static char *res_size[]={
+	"480p",
+	"720p",
+	"960p",
+	"1080p",
+	"5m",
+};
+
+static void set_resolution_param(struct ar0543_device *dev, resolution_param_t* res_param)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int rc = -1;
+	int i=0;
+	unsigned char t = 1;//dev->cam_info.interface;
+	printk("%s, %d, interface =%d\n" , __func__, __LINE__, t);
+	
+
+	if(i_index != -1 && ar0543_work_mode != CAMERA_CAPTURE){
+        res_param = &debug_prev_resolution_array[i_index];
+    }
+	if (!res_param->reg_script[t]) {
+		printk("error, resolution reg script is NULL\n");
+		return;
+	}
+	while(1) {
+        	if (res_param->reg_script[t][i].type == END_OF_SCRIPT) {
+        		printk("setting resolutin param complete\n");
+        		break;
+        	}
+        	if((cam_i2c_send_msg(client, res_param->reg_script[t][i])) < 0) {
+        		printk("fail in setting resolution param. i=%d\n",i);
+        		break;
+        	}
+		i++;
+	}
+	#if 0
+    int default_sensor_data[4] = {0x00000100,0x000001a0,0x000001ff,0x00000108};
+	int *sensor_data;
+	int data = 0;
+	int index = 0;
+	if(cf->wb_sensor_data_valid == 1){
+		sensor_data = cf->wb_sensor_data.export;
+	}else
+		sensor_data = default_sensor_data;
+		
+	i2c_put_word(client, 0x206, sensor_data[0] & 0xffff);
+	i2c_put_word(client, 0x208, sensor_data[1] & 0xffff);
+	i2c_put_word(client, 0x20a, sensor_data[2] & 0xffff);
+	i2c_put_word(client, 0x20c, sensor_data[3] & 0xffff);
+	#endif
+	ar0543_frmintervals_active.numerator = 1;
+	ar0543_frmintervals_active.denominator = res_param->active_fps;
+	ar0543_h_active = res_param->active_frmsize.width;
+	ar0543_v_active = res_param->active_frmsize.height;
+	AR0543_set_new_format(ar0543_h_active,ar0543_v_active,current_fr);// should set new para
+}    /* AR0543_set_resolution */
+
+static int set_focus_zone(struct ar0543_device *dev, int value)
+{
+	int xc, yc, tx, ty;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int retry_count = 10;
+	int ret = -1;
+	
+	xc = (value >> 16) & 0xffff;
+	yc = (value & 0xffff);
+	if(xc == 1000 && yc == 1000)
+		return 0;
+	tx = xc * ar0543_h_active /2000;
+	ty = yc * ar0543_v_active /2000;
+	printk("xc = %d, yc = %d, tx = %d , ty = %d \n", xc, yc, tx, ty);
+	
+	dev->cam_para->xml_scenes->af.x = tx;
+	dev->cam_para->xml_scenes->af.y = ty;	
+	dev->cam_para->cam_command = CAM_COMMAND_TOUCH_FOCUS;
+	dev->fe_arg.port = TVIN_PORT_ISP;
+	dev->fe_arg.index = 0;
+	dev->fe_arg.arg = (void *)(dev->cam_para);
+	if(dev->vops != NULL){
+	  dev->vops->tvin_fe_func(0,&dev->fe_arg);
+	}
+	return 0;
+}
+
+unsigned char v4l_2_ar0543(int val)
+{
+	int ret=val/0x20;
+	if(ret<4) return ret*0x20+0x80;
+	else if(ret<8) return ret*0x20+0x20;
+	else return 0;
+}
+
+static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_canvas)
+{
+	int canvas = start_canvas;
+
+	switch(v4l2_format){
+	case V4L2_PIX_FMT_RGB565X:
+	case V4L2_PIX_FMT_VYUY:
+		canvas = start_canvas;
+		break;
+	case V4L2_PIX_FMT_YUV444:
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB24:
+		canvas = start_canvas;
+		break; 
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21: 
+		canvas = start_canvas | ((start_canvas+1)<<8);
+		break;
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV420:
+		if(V4L2_PIX_FMT_YUV420 == v4l2_format){
+			canvas = start_canvas|((start_canvas+1)<<8)|((start_canvas+2)<<16);
+		}else{
+			canvas = start_canvas|((start_canvas+2)<<8)|((start_canvas+1)<<16);
+		}
+		break;
+	default:
+		break;
+	}
+	return canvas;
+}
+
+static int ar0543_setting(struct ar0543_device *dev,int PROP_ID,int value )
+{
+	int ret=0;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct ar0543_fh *fh = to_fh(dev);
+	switch(PROP_ID)  {
+	case V4L2_CID_BRIGHTNESS:
+		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_ar0543(value));
+		//ret=i2c_put_byte(client,0x0201,v4l_2_ar0543(value));
+		break;
+	case V4L2_CID_CONTRAST:
+		break;
+	case V4L2_CID_SATURATION:
+		break;
+	case V4L2_CID_HFLIP:    /* set flip on H. */
+		value = value & 0x1;
+		if(ar0543_qctrl[2].default_value!=value){
+			 ar0543_qctrl[2].default_value=value;
+			printk(" set camera  h filp =%d. \n ",value);
+			value = value << 1; //bit[1]
+			//ret=i2c_put_byte(client,0x3821, value);
+			break;
+		}
+		break;
+	case V4L2_CID_VFLIP:    /* set flip on V. */
+		break;
+	case V4L2_CID_DO_WHITE_BALANCE:
+		if(ar0543_qctrl[4].default_value!=value){
+			ar0543_qctrl[4].default_value=value;
+			if(fh->stream_on)
+				AR0543_set_param_wb(dev,value);
+			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_EXPOSURE:
+		if(ar0543_qctrl[5].default_value!=value){
+			ar0543_qctrl[5].default_value=value;
+			if(fh->stream_on)
+				AR0543_set_param_exposure(dev,value);
+			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_BACKLIGHT_COMPENSATION:
+		if(ar0543_qctrl[9].default_value!=value){
+			ar0543_qctrl[9].default_value=value;
+			ret = AR0543_FlashCtrl(dev,value);
+			printk(KERN_INFO " set light compensation =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_COLORFX:
+		if(ar0543_qctrl[6].default_value!=value){
+			ar0543_qctrl[6].default_value=value;
+			if(fh->stream_on)
+				AR0543_set_param_effect(dev,value);
+		}
+		break;
+	
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		if(ar0543_qctrl[3].default_value!=value){
+			ar0543_qctrl[3].default_value=value;
+			AR0543_set_param_banding(dev,value);
+			printk(KERN_INFO " set camera  banding=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		if(ar0543_qctrl[10].default_value!=value){
+			ar0543_qctrl[10].default_value=value;
+			printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_ROTATE:
+		if(ar0543_qctrl[11].default_value!=value){
+			ar0543_qctrl[11].default_value=value;
+			printk(" set camera  rotate =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		printk("V4L2_CID_FOCUS_ABSOLUTE\n");
+		if(ar0543_qctrl[13].default_value!=value){
+			ar0543_qctrl[13].default_value=value;
+			printk(" set camera  focus zone =%d. \n ",value);
+			set_focus_zone(dev, value);
+		}
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		printk("V4L2_CID_FOCUS_AUTO\n");
+		if(ar0543_qctrl[8].default_value!=value){
+			ar0543_qctrl[8].default_value=value;
+			if(fh->stream_on)
+				AR0543_AutoFocus(dev,value);
+		}
+	case V4L2_CID_PRIVACY:       
+        break;
+	default:
+   		ret=-1;
+		break;
+	}
+	
+	return ret;
+
+}
+
+
+/* ------------------------------------------------------------------
+	DMA and thread functions
+   ------------------------------------------------------------------*/
+
+#define TSTAMP_MIN_Y	24
+#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X	10
+#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
+
+static void ar0543_fillbuff(struct ar0543_fh *fh, struct ar0543_buffer *buf)
+{
+	struct ar0543_device *dev = fh->dev;
+	//void *vbuf = videobuf_to_vmalloc(&buf->vb);
+	void *vbuf = (void *)videobuf_to_res(&buf->vb);
+	vm_output_para_t para = {0};
+	dprintk(dev,1,"%s\n", __func__);
+	if (!vbuf)
+		return;
+	/*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
+	if(buf->canvas_id == 0)
+		buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, AR0543_RES0_CANVAS_INDEX+buf->vb.i*3);
+	para.mirror = ar0543_qctrl[2].default_value&3;// not set
+	para.v4l2_format = fh->fmt->fourcc;
+	para.v4l2_memory = MAGIC_RE_MEM;//0x18221223;
+	para.zoom = ar0543_qctrl[10].default_value;
+	para.angle = ar0543_qctrl[11].default_value;
+	para.vaddr = (unsigned)vbuf;
+	para.ext_canvas = buf->canvas_id;
+	para.width = buf->vb.width;
+	para.height = buf->vb.height;
+	vm_fill_buffer(&buf->vb,&para);
+	buf->vb.state = VIDEOBUF_DONE;
+}
+
+static void ar0543_thread_tick(struct ar0543_fh *fh)
+{
+	struct ar0543_buffer *buf;
+	struct ar0543_device *dev = fh->dev;
+	struct ar0543_dmaqueue *dma_q = &dev->vidq;
+
+	unsigned long flags = 0;
+
+	dprintk(dev, 1, "Thread tick\n");
+	if(!fh->stream_on){
+		dprintk(dev, 1, "sensor doesn't stream on\n");
+		return ;
+	}
+
+	spin_lock_irqsave(&dev->slock, flags);
+	if (list_empty(&dma_q->active)) {
+		dprintk(dev, 1, "No active queue to serve\n");
+		goto unlock;
+	}
+
+    buf = list_entry(dma_q->active.next,
+            struct ar0543_buffer, vb.queue);
+    dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
+
+    if(!(fh->f_flags & O_NONBLOCK)){
+        /* Nobody is waiting on this buffer, return */
+        if (!waitqueue_active(&buf->vb.done))
+            goto unlock;
+    }
+    buf->vb.state = VIDEOBUF_ACTIVE;
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+
+	/* Fill buffer */
+	spin_unlock_irqrestore(&dev->slock, flags);
+	ar0543_fillbuff(fh, buf);
+	dprintk(dev, 1, "filled buffer %p\n", buf);
+
+	wake_up(&buf->vb.done);
+	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+	return;
+unlock:
+	spin_unlock_irqrestore(&dev->slock, flags);
+	return;
+}
+
+#define frames_to_ms(frames)					\
+	((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+
+static void ar0543_sleep(struct ar0543_fh *fh)
+{
+	struct ar0543_device *dev = fh->dev;
+	struct ar0543_dmaqueue *dma_q = &dev->vidq;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
+		(unsigned long)dma_q);
+
+	add_wait_queue(&dma_q->wq, &wait);
+	if (kthread_should_stop())
+		goto stop_task;
+
+	/* Calculate time to wake up */
+	//timeout = msecs_to_jiffies(frames_to_ms(1));
+
+	ar0543_thread_tick(fh);
+
+	schedule_timeout_interruptible(1);//if fps > 25 , 2->1
+
+stop_task:
+	remove_wait_queue(&dma_q->wq, &wait);
+	try_to_freeze();
+}
+
+static int ar0543_thread(void *data)
+{
+	struct ar0543_fh  *fh = data;
+	struct ar0543_device *dev = fh->dev;
+
+	dprintk(dev, 1, "thread started\n");
+
+	set_freezable();
+
+	for (;;) {
+		ar0543_sleep(fh);
+
+		if (kthread_should_stop())
+			break;
+	}
+	dprintk(dev, 1, "thread: exit\n");
+	return 0;
+}
+
+static int ar0543_start_thread(struct ar0543_fh *fh)
+{
+	struct ar0543_device *dev = fh->dev;
+	struct ar0543_dmaqueue *dma_q = &dev->vidq;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	dma_q->kthread = kthread_run(ar0543_thread, fh, "ar0543");
+
+	if (IS_ERR(dma_q->kthread)) {
+		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+		return PTR_ERR(dma_q->kthread);
+	}
+	/* Wakes thread */
+	wake_up_interruptible(&dma_q->wq);
+
+	dprintk(dev, 1, "returning from %s\n", __func__);
+	return 0;
+}
+
+static void ar0543_stop_thread(struct ar0543_dmaqueue  *dma_q)
+{
+	struct ar0543_device *dev = container_of(dma_q, struct ar0543_device, vidq);
+
+	dprintk(dev, 1, "%s\n", __func__);
+	/* shutdown control thread */
+	if (dma_q->kthread) {
+		kthread_stop(dma_q->kthread);
+		dma_q->kthread = NULL;
+	}
+}
+
+/* ------------------------------------------------------------------
+	Videobuf operations
+   ------------------------------------------------------------------*/
+static int
+buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0543_fh *fh  = container_of(res, struct ar0543_fh, res);
+	struct ar0543_device *dev  = fh->dev;
+    //int bytes = fh->fmt->depth >> 3 ;
+	int height = fh->height;
+	if(height==1080)
+		height = 1088;
+	*size = (fh->width*height*fh->fmt->depth)>>3;  
+	if (0 == *count)
+		*count = 32;
+
+	while (*size * *count > vid_limit * 1024 * 1024)
+		(*count)--;
+
+	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+		*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct ar0543_buffer *buf)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0543_fh *fh  = container_of(res, struct ar0543_fh, res);
+	struct ar0543_device *dev  = fh->dev;
+
+	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+
+	videobuf_waiton(vq, &buf->vb, 0, 0);
+	if (in_interrupt())
+		BUG();
+
+	videobuf_res_free(vq, &buf->vb);
+	dprintk(dev, 1, "free_buffer: freed\n");
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+#define norm_maxw() 3000
+#define norm_maxh() 3000
+static int
+buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						enum v4l2_field field)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0543_fh *fh  = container_of(res, struct ar0543_fh, res);
+	struct ar0543_device    *dev = fh->dev;
+	struct ar0543_buffer *buf = container_of(vb, struct ar0543_buffer, vb);
+	int rc;
+    //int bytes = fh->fmt->depth >> 3 ;
+	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+
+	BUG_ON(NULL == fh->fmt);
+
+	if (fh->width  < 48 || fh->width  > norm_maxw() ||
+	    fh->height < 32 || fh->height > norm_maxh())
+		return -EINVAL;
+
+	buf->vb.size = (fh->width*fh->height*fh->fmt->depth)>>3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+		return -EINVAL;
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = fh->fmt;
+	buf->vb.width  = fh->width;
+	buf->vb.height = fh->height;
+	buf->vb.field  = field;
+
+	//precalculate_bars(fh);
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0)
+			goto fail;
+	}
+
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void
+buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct ar0543_buffer    *buf  = container_of(vb, struct ar0543_buffer, vb);
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0543_fh *fh  = container_of(res, struct ar0543_fh, res);
+	struct ar0543_device       *dev  = fh->dev;
+	struct ar0543_dmaqueue *vidq = &dev->vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct ar0543_buffer   *buf  = container_of(vb, struct ar0543_buffer, vb);
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0543_fh *fh  = container_of(res, struct ar0543_fh, res);
+	struct ar0543_device      *dev  = (struct ar0543_device *)fh->dev;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops ar0543_video_qops = {
+	.buf_setup      = buffer_setup,
+	.buf_prepare    = buffer_prepare,
+	.buf_queue      = buffer_queue,
+	.buf_release    = buffer_release,
+};
+
+/* ------------------------------------------------------------------
+	IOCTL vidioc handling
+   ------------------------------------------------------------------*/
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct ar0543_fh  *fh  = priv;
+	struct ar0543_device *dev = fh->dev;
+
+	strcpy(cap->driver, "ar0543");
+	strcpy(cap->card, "ar0543.canvas");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+	cap->version = AR0543_CAMERA_VERSION;
+	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
+				V4L2_CAP_STREAMING     |
+				V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct ar0543_fmt *fmt;
+
+	if (f->index >= ARRAY_SIZE(formats))
+		return -EINVAL;
+
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_enum_frameintervals(struct file *file, void *priv,
+        struct v4l2_frmivalenum *fival)
+{
+    unsigned int k;
+
+    if(fival->index > ARRAY_SIZE(ar0543_frmivalenum))
+        return -EINVAL;
+
+    for(k =0; k< ARRAY_SIZE(ar0543_frmivalenum); k++)
+    {
+        if( (fival->index==ar0543_frmivalenum[k].index)&&
+                (fival->pixel_format ==ar0543_frmivalenum[k].pixel_format )&&
+                (fival->width==ar0543_frmivalenum[k].width)&&
+                (fival->height==ar0543_frmivalenum[k].height)){
+            memcpy( fival, &ar0543_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
+            return 0;
+        }
+    }
+    return -EINVAL;
+
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct ar0543_fh *fh = priv;
+
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vb_vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+	return (0);
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct ar0543_fh  *fh  = priv;
+	struct ar0543_device *dev = fh->dev;
+	struct ar0543_fmt *fmt;
+	enum v4l2_field field;
+	unsigned int maxw, maxh;
+
+	fmt = get_format(f);
+	if (!fmt) {
+		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+			f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	field = f->fmt.pix.field;
+
+	if (field == V4L2_FIELD_ANY) {
+		field = V4L2_FIELD_INTERLACED;
+	} else if (V4L2_FIELD_INTERLACED != field) {
+		dprintk(dev, 1, "Field type invalid.\n");
+		return -EINVAL;
+	}
+
+	maxw  = norm_maxw();
+	maxh  = norm_maxh();
+
+	f->fmt.pix.field = field;
+	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
+			      &f->fmt.pix.height, 32, maxh, 0, 0);
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+	return 0;
+}
+
+/*FIXME: This seems to be generic enough to be at videodev2 */
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct ar0543_fh *fh = priv;
+	struct videobuf_queue *q = &fh->vb_vidq;
+	struct ar0543_device *dev = fh->dev;
+	resolution_param_t* res_param = NULL;
+	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	if (ret < 0)
+		return ret;
+	
+	mutex_lock(&q->vb_lock);
+
+	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	fh->fmt           = get_format(f);
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+    if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
+        ar0543_work_mode = CAMERA_CAPTURE;
+        res_param = get_resolution_param(dev, 1, fh->width,fh->height);
+        if (!res_param) {
+            printk("error, resolution param not get\n");
+            goto out;
+        }
+        set_resolution_param(dev, res_param);
+    }
+    else {
+    	printk("preview resolution is %dX%d\n",fh->width,  fh->height);
+        if((fh->width == 1280 && fh->height == 720) || 
+        	(fh->width == 1920 && fh->height == 1080)){
+        	ar0543_work_mode = CAMERA_RECORD;
+        }else
+        	ar0543_work_mode = CAMERA_PREVIEW;
+        res_param = get_resolution_param(dev, 0, fh->width,fh->height);
+        if (!res_param) {
+            printk("error, resolution param not get\n");
+            goto out;
+        }
+        set_resolution_param(dev, res_param);
+        /** set target ***/
+        if(t_index == -1){
+            dest_hactive = 0;
+            dest_vactive = 0;
+        }
+    }
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+        struct v4l2_streamparm *parms)
+{
+    struct ar0543_fh *fh = priv;
+    struct ar0543_device *dev = fh->dev;
+    struct v4l2_captureparm *cp = &parms->parm.capture;
+
+    dprintk(dev,3,"vidioc_g_parm\n");
+    if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+
+    memset(cp, 0, sizeof(struct v4l2_captureparm));
+    cp->capability = V4L2_CAP_TIMEPERFRAME;
+
+    cp->timeperframe = ar0543_frmintervals_active;
+    printk("g_parm,deno=%d, numerator=%d\n", cp->timeperframe.denominator,
+            cp->timeperframe.numerator );
+    return 0;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct ar0543_fh  *fh = priv;
+
+	return (videobuf_reqbufs(&fh->vb_vidq, p));
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct ar0543_fh  *fh = priv;
+
+	int ret = videobuf_querybuf(&fh->vb_vidq, p);
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+	if(ret == 0){
+		p->reserved  = convert_canvas_index(fh->fmt->fourcc, AR0543_RES0_CANVAS_INDEX+p->index*3);
+	}else{
+		p->reserved = 0;
+	}
+#endif		
+	return ret;
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct ar0543_fh *fh = priv;
+
+	return (videobuf_qbuf(&fh->vb_vidq, p));
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct ar0543_fh  *fh = priv;
+
+	return (videobuf_dqbuf(&fh->vb_vidq, p,
+				file->f_flags & O_NONBLOCK));
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct ar0543_fh  *fh = priv;
+
+	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
+}
+#endif
+#ifdef MIPI_INTERFACE
+static struct ar0543_fmt input_formats_vdin[] = 
+{
+    // vdin path format
+    {
+        .name     = "4:2:2, packed, UYVY",
+        .fourcc   = V4L2_PIX_FMT_UYVY,
+        .depth    = 16,
+    },
+    {
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV21,
+        .depth    = 12,
+    },
+    {
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV12,
+        .depth    = 12,
+    }
+};
+#endif
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct ar0543_fh  *fh = priv;
+	struct ar0543_device *dev = fh->dev;	
+	vdin_parm_t para;
+	int ret = 0 ;
+	
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+
+	memset( &para, 0, sizeof( para ));
+	//para.port  = TVIN_PORT_CAMERA;
+	
+	if (CAM_MIPI == dev->cam_info.interface) {
+	        para.isp_fe_port  = TVIN_PORT_MIPI;
+	} else {
+	        para.isp_fe_port  = TVIN_PORT_CAMERA;
+	}
+	para.port  = TVIN_PORT_ISP;   
+	para.fmt = TVIN_SIG_FMT_MAX;
+	para.frame_rate = ar0543_frmintervals_active.denominator;
+	para.h_active = ar0543_h_active;
+	para.v_active = ar0543_v_active;
+    if(ar0543_work_mode != CAMERA_CAPTURE){
+		para.skip_count = 2;
+        para.dest_hactive = dest_hactive;
+        para.dest_vactive = dest_vactive;
+    }else{
+        para.dest_hactive = 0;
+        para.dest_vactive = 0;
+    }
+    dev->cam_para->cam_mode = ar0543_work_mode;
+	para.hsync_phase = 1;
+	para.vsync_phase  = 1;
+	para.hs_bp = 0;
+	para.vs_bp = 2;
+	para.cfmt = TVIN_YUV422;
+	para.dfmt = TVIN_NV21;
+	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
+	para.bt_path = dev->cam_info.bt_path;
+	current_fmt = 0;
+	if(dev->cam_para == NULL)
+		return -EINVAL;
+	if(generate_para(dev->cam_para,dev->pindex) == 0){
+	    para.reserved = (int)(dev->cam_para);
+	}else{
+		free_para(dev->cam_para);
+		para.reserved = 0;
+	}
+	dev->cam_para->cam_function.set_aet_new_step = AR0543_set_aet_new_step;
+	dev->cam_para->cam_function.check_mains_freq = AR0543_check_mains_freq;
+	dev->cam_para->cam_function.set_af_new_step = AR0543_set_af_new_step;
+	dev->cam_para->cam_mode = CAMERA_PREVIEW;	
+	if (CAM_MIPI == dev->cam_info.interface)
+	{
+			printk("mipi param init\n");
+	        para.csi_hw_info.lanes = 2;
+	        para.csi_hw_info.channel = 1;
+	        para.csi_hw_info.mode = 1;
+	        para.csi_hw_info.clock_lane_mode = 1; // 0 clock gate 1: always on
+	        para.csi_hw_info.active_pixel = ar0543_h_active;
+	        para.csi_hw_info.active_line = ar0543_v_active;
+	        para.csi_hw_info.frame_size=0;
+	        para.csi_hw_info.ui_val = 2; //ns
+	        para.csi_hw_info.urgent = 1;
+
+	        para.csi_hw_info.hs_freq = 410; //MHz
+	        para.csi_hw_info.clk_channel = dev->cam_info.clk_channel; //clock channel a or b
+	}
+	if(cf->aet_valid == 1){
+	    dev->cam_para->xml_scenes->ae.aet_fmt_gain = sensor_aet_info->format_transfer_parameter;        	
+	}else
+	    dev->cam_para->xml_scenes->ae.aet_fmt_gain = 0;
+	printk("aet_fmt_gain:%d\n",dev->cam_para->xml_scenes->ae.aet_fmt_gain);
+
+	printk("ar0543,h=%d, v=%d, frame_rate=%d\n", 
+	        ar0543_h_active, ar0543_v_active, ar0543_frmintervals_active.denominator);
+	ret =  videobuf_streamon(&fh->vb_vidq);
+	if(ret == 0){
+		dev->vops->start_tvin_service(0,&para);
+		fh->stream_on        = 1;
+	}
+	AR0543_set_param_wb(fh->dev,ar0543_qctrl[4].default_value);
+	AR0543_set_param_exposure(fh->dev,ar0543_qctrl[5].default_value);
+	AR0543_set_param_effect(fh->dev,ar0543_qctrl[6].default_value);
+	return ret;
+}
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct ar0543_fh  *fh = priv;
+	struct ar0543_device *dev = fh->dev;
+	int ret = 0 ;
+	printk(KERN_INFO " vidioc_streamoff+++ \n ");
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+	ret = videobuf_streamoff(&fh->vb_vidq);
+	if(ret == 0 ){
+        dev->vops->stop_tvin_service(0);
+        fh->stream_on        = 0;
+	}
+	return ret;
+}
+
+static int get_index(char *res){
+	int i = 0;
+	while(i < ARRAY_SIZE(res_size)){
+		if(strcmp(res_size[i],res) == 0){
+			break;
+		}
+		else
+			i++;	
+	}
+	if(i < ARRAY_SIZE(res_size)){
+		return i;	
+	}else
+		return -1;
+}
+
+static ssize_t manual_format_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char input[20];
+	char target[20];
+	char *param[3] = {NULL};
+	resolution_param_t *res_param;
+
+	
+	parse_param(buf,&param[0]);
+	if(param[0] == NULL || param[1] == NULL){
+		printk("wrong param\n");
+		return len;	
+	}
+	sscanf(param[0],"%s",input);
+	sscanf(param[1],"%s",target);
+	i_index = get_index(input);
+	t_index = get_index(target);
+	printk("i:%d,t:%x\n",i_index,t_index);
+	if(i_index < 0 || t_index <0){
+		printk("wrong res\n");
+		return len;
+	}
+	res_param = &debug_prev_resolution_array[t_index];	
+	dest_hactive = res_param->active_frmsize.width;
+    dest_vactive = res_param->active_frmsize.height;
+    printk("d_h:%d,d_v:%d\n",dest_hactive,dest_vactive);
+    return len;
+}
+
+static ssize_t manual_format_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+
+	size_t len = 0;
+	printk("current hactive :%d, v_active :%d, dest_hactive :%d, dest_vactive:%d\n",ar0543_h_active,ar0543_v_active,dest_hactive,dest_vactive);
+	return len;
+}
+static CLASS_ATTR(resolution_debug, 0664, manual_format_show,manual_format_store);
+
+static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsizeenum *fsize)
+{
+
+      int ret = 0,i=0;
+      struct ar0543_fmt *fmt = NULL;
+      struct v4l2_frmsize_discrete *frmsize = NULL;
+      for (i = 0; i < ARRAY_SIZE(formats); i++) {
+            if (formats[i].fourcc == fsize->pixel_format){
+                    fmt = &formats[i];
+                    break;
+            }
+      }
+      if (fmt == NULL)
+            return -EINVAL;
+      if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+                      ||(fmt->fourcc == V4L2_PIX_FMT_NV12)
+                      ||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
+                      ||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
+         ){
+              printk("ar0543_prev_resolution[fsize->index]"
+                              "   before fsize->index== %d\n",fsize->index);//potti
+              if (fsize->index >= ARRAY_SIZE(prev_resolution_array))
+                      return -EINVAL;
+              frmsize = &prev_resolution_array[fsize->index].frmsize;
+              printk("ar0543_prev_resolution[fsize->index]"
+                              "   after fsize->index== %d\n",fsize->index);
+              fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+              fsize->discrete.width = frmsize->width;
+              fsize->discrete.height = frmsize->height;
+      } else if (fmt->fourcc == V4L2_PIX_FMT_RGB24){
+              printk("ar0543_pic_resolution[fsize->index]"
+                              "   before fsize->index== %d\n",fsize->index);
+              if (fsize->index >= ARRAY_SIZE(capture_resolution_array))
+                      return -EINVAL;
+              frmsize = &capture_resolution_array[fsize->index].frmsize;
+              printk("ar0543_pic_resolution[fsize->index]"
+                              "   after fsize->index== %d\n",fsize->index);
+              fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+              fsize->discrete.width = frmsize->width;
+              fsize->discrete.height = frmsize->height;
+      }
+      return ret;
+}
+
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+{
+	return 0;
+}
+
+/* only one input in this sample driver */
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	//if (inp->index >= NUM_INPUTS)
+		//return -EINVAL;
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->std = V4L2_STD_525_60;
+	sprintf(inp->name, "Camera %u", inp->index);
+	return (0);
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct ar0543_fh *fh = priv;
+	struct ar0543_device *dev = fh->dev;
+
+	*i = dev->input;
+	return (0);
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct ar0543_fh *fh = priv;
+	struct ar0543_device *dev = fh->dev;
+
+	//if (i >= NUM_INPUTS)
+		//return -EINVAL;
+
+	dev->input = i;
+	//precalculate_bars(fh);
+
+	return (0);
+}
+
+	/* --- controls ---------------------------------------------- */
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ar0543_qctrl); i++)
+		if (qc->id && qc->id == ar0543_qctrl[i].id) {
+			memcpy(qc, &(ar0543_qctrl[i]),sizeof(*qc));
+			return (0);
+		}
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct ar0543_fh *fh = priv;
+	struct ar0543_device *dev = fh->dev;
+	int i, status;
+	int ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(ar0543_qctrl); i++)
+		if (ctrl->id == ar0543_qctrl[i].id) {
+		#if 0
+            if( (V4L2_CID_FOCUS_AUTO == ctrl->id)
+                    && bDoingAutoFocusMode){
+                dev->cam_para->cam_command = CAM_COMMAND_GET_STATE;
+                dev->fe_arg.port = TVIN_PORT_ISP;
+                dev->fe_arg.index = 0;
+                dev->fe_arg.arg = (void *)(dev->cam_para);
+                status = dev->vops->tvin_fe_func(0,&dev->fe_arg);
+                switch(status){
+                    case CAM_STATE_DOING:
+                        ret = -EBUSY;
+                        break;
+                    case CAM_STATE_ERROR:
+                    case CAM_STATE_NULL:
+                        printk("auto mode failed!\n");
+                        bDoingAutoFocusMode = false;
+                        ret = -EAGAIN;
+                        break;
+                    case CAM_STATE_SUCCESS:
+                        bDoingAutoFocusMode = false;
+                        ret = 0;
+                        break;
+                    default:
+                        printk("wrong state\n");
+                        ret = 0;
+                }
+            }else if( V4L2_CID_AUTO_FOCUS_STATUS == ctrl->id){
+                dev->cam_para->cam_command = CAM_COMMAND_GET_STATE;
+                dev->fe_arg.port = TVIN_PORT_ISP;
+                dev->fe_arg.index = 0;
+                dev->fe_arg.arg = (void *)(dev->cam_para);
+                status = dev->vops->tvin_fe_func(0,&dev->fe_arg);
+                switch(status){
+                    case CAM_STATE_DOING:
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_BUSY;
+                        break;
+                    case CAM_STATE_ERROR:
+                        printk("should resart focus\n");
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_FAILED;
+                        break;
+                    case CAM_STATE_NULL:
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_IDLE;
+                        break;
+                    case CAM_STATE_SUCCESS:
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_REACHED;
+                        break;
+                    default:
+                        printk("wrong state\n");
+                }	
+                return 0;
+            }
+			#endif
+            ctrl->value = dev->qctl_regs[i];
+            return ret;
+        }
+
+	return -EINVAL;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct ar0543_fh *fh = priv;
+	struct ar0543_device *dev = fh->dev;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(ar0543_qctrl); i++)
+		if (ctrl->id == ar0543_qctrl[i].id) {
+			if (ctrl->value < ar0543_qctrl[i].minimum ||
+			    ctrl->value > ar0543_qctrl[i].maximum ||
+			    ar0543_setting(dev,ctrl->id,ctrl->value)<0) {
+				return -ERANGE;
+			}
+			dev->qctl_regs[i] = ctrl->value;
+			return 0;
+		}
+	return -EINVAL;
+
+}
+
+/* ------------------------------------------------------------------
+	File operations for the device
+   ------------------------------------------------------------------*/
+
+static int ar0543_open(struct file *file)
+{
+    struct ar0543_device *dev = video_drvdata(file);
+    struct ar0543_fh *fh = NULL;
+    resource_size_t mem_start = 0;
+    unsigned int mem_size = 0;
+    int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0) {
+    	printk("error: no cma memory\n");
+        return -1;
+    }
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+    switch_mod_gate_by_name("ge2d", 1);
+#endif		
+    aml_cam_init(&dev->cam_info);
+    printk("config path:%s\n",(dev->cam_info).config);
+    if((dev->cam_info).config != NULL){
+        if((cf = kmalloc(sizeof(configure),0)) != NULL){
+            if(parse_config((dev->cam_info).config) == 0){
+                printk("parse successfully");
+            }else{
+                printk("parse failed");
+            }
+        }else{
+            printk("malloc failed");
+            return -ENOMEM;
+        }      
+    }
+    if((dev->cam_para = kzalloc(sizeof(cam_parameter_t),0)) == NULL){
+        printk("memalloc failed\n");
+        return -ENOMEM;
+    }
+    AR0543_init_regs(dev);
+    msleep(40);
+    mutex_lock(&dev->mutex);
+    dev->users++;
+    if (dev->users > 1) {
+        dev->users--;
+        mutex_unlock(&dev->mutex);
+        return -EBUSY;
+    }
+
+    dprintk(dev, 1, "open %s type=%s users=%d\n",
+            video_device_node_name(dev->vdev),
+            v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+    /* init video dma queues */
+    INIT_LIST_HEAD(&dev->vidq.active);
+    init_waitqueue_head(&dev->vidq.wq);
+    spin_lock_init(&dev->slock);
+    /* allocate + initialize per filehandle data */
+    fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+    if (NULL == fh) {
+        dev->users--;
+        retval = -ENOMEM;
+    }
+    mutex_unlock(&dev->mutex);
+
+    if (retval)
+        return retval;
+
+    wake_lock(&(dev->wake_lock));
+    file->private_data = fh;
+    fh->dev      = dev;
+
+    fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    fh->fmt      = &formats[0];
+    fh->width    = 640;
+    fh->height   = 480;
+    fh->stream_on = 0 ;
+    fh->f_flags  = file->f_flags;
+    /* Resets frame counters */
+    dev->jiffies = jiffies;
+
+    get_vm_buf_info(&mem_start, &mem_size, NULL);
+    fh->res.start = mem_start;
+    fh->res.end = mem_start+mem_size-1;
+    fh->res.magic = MAGIC_RE_MEM;
+    fh->res.priv = NULL;
+    videobuf_queue_res_init(&fh->vb_vidq, &ar0543_video_qops,
+    			NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+    			sizeof(struct ar0543_buffer), (void*)&fh->res, NULL);
+    ar0543_start_thread(fh);
+    ar0543_have_open = 1;
+    ar0543_work_mode = CAMERA_PREVIEW;
+    dev->pindex.effect_index = 0;
+    dev->pindex.scenes_index = 0;
+    dev->pindex.wb_index = 0;
+    dev->pindex.capture_index = 0;
+    if(generate_para(dev->cam_para,dev->pindex) != 0){
+        printk("generate para failed\n");
+        free_para(dev->cam_para);
+        kfree(dev->cam_para);
+        return -EINVAL;
+    }
+    dev->cam_para->cam_function.set_aet_new_step = AR0543_set_aet_new_step;
+    dev->cam_para->cam_function.check_mains_freq = AR0543_check_mains_freq;
+    dev->cam_para->cam_function.set_af_new_step = AR0543_set_af_new_step;  
+    dev->ae_on = false;
+    /**creat class file**/		
+    cam_class = class_create(THIS_MODULE,"camera"); 
+    if(IS_ERR(cam_class)){
+        return PTR_ERR(cam_class);
+    }
+    retval = class_create_file(cam_class,&class_attr_ae_debug);
+    retval = class_create_file(cam_class,&class_attr_camera_debug);
+    retval = class_create_file(cam_class,&class_attr_aet_debug);
+    retval = class_create_file(cam_class,&class_attr_vcm_debug);
+    retval = class_create_file(cam_class,&class_attr_resolution_debug);
+    retval = class_create_file(cam_class,&class_attr_light_source_debug);
+    retval = class_create_file(cam_class,&class_attr_version_debug);
+    printk("open successfully\n");
+    dev->vops = get_vdin_v4l2_ops();
+	bDoingAutoFocusMode=false;
+    return 0;
+}
+
+static ssize_t
+ar0543_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct ar0543_fh *fh = file->private_data;
+
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+	}
+	return 0;
+}
+
+static unsigned int
+ar0543_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct ar0543_fh        *fh = file->private_data;
+	struct ar0543_device       *dev = fh->dev;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+		return POLLERR;
+
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int ar0543_close(struct file *file)
+{
+    struct ar0543_fh         *fh = file->private_data;
+    struct ar0543_device *dev       = fh->dev;
+    struct ar0543_dmaqueue *vidq = &dev->vidq;
+    struct video_device  *vdev = video_devdata(file);
+    int i=0;
+    ar0543_have_open = 0;
+    ar0543_stop_thread(vidq);
+    videobuf_stop(&fh->vb_vidq);
+    if(fh->stream_on){
+        dev->vops->stop_tvin_service(0);
+    }
+    videobuf_mmap_free(&fh->vb_vidq);
+
+    kfree(fh);
+    if(cf != NULL){
+        if(cf->aet_valid){
+            for(i = 0; i < cf->aet.sum; i++){
+                kfree(cf->aet.aet[i].info);
+                kfree(cf->aet.aet[i].aet_table);
+                if(cf->aet.aet[i].manual != NULL)
+                    kfree(cf->aet.aet[i].manual);
+            }
+        }
+        if(cf->scene_valid){
+            kfree(cf->scene.scene);
+        }
+
+        kfree(cf);
+    }
+    if(dev->cam_para != NULL ){
+        free_para(dev->cam_para);
+        kfree(dev->cam_para);
+    }
+
+    mutex_lock(&dev->mutex);
+    dev->users--;
+    mutex_unlock(&dev->mutex);
+
+    dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+            video_device_node_name(vdev), dev->users);
+    //ar0543_h_active=800;
+    //ar0543_v_active=600;
+    ar0543_qctrl[0].default_value=0;
+    ar0543_qctrl[1].default_value=4;
+    ar0543_qctrl[2].default_value=0;
+    ar0543_qctrl[3].default_value=CAM_BANDING_50HZ;
+    ar0543_qctrl[4].default_value=CAM_WB_AUTO;
+
+    ar0543_qctrl[5].default_value=4;
+    ar0543_qctrl[6].default_value=0;
+    ar0543_qctrl[10].default_value=100;
+    ar0543_qctrl[11].default_value=0;
+    //ar0543_frmintervals_active.numerator = 1;
+    //ar0543_frmintervals_active.denominator = 15;
+    power_down_ar0543(dev);
+    //dw9714_uninit();
+    msleep(10);
+
+    aml_cam_uninit(&dev->cam_info);
+
+    msleep(10);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+    switch_mod_gate_by_name("ge2d", 0);
+#endif		
+    wake_unlock(&(dev->wake_lock));
+    class_remove_file(cam_class,&class_attr_ae_debug);
+    class_remove_file(cam_class,&class_attr_camera_debug);
+    class_remove_file(cam_class,&class_attr_aet_debug);
+    class_remove_file(cam_class,&class_attr_vcm_debug);
+    class_remove_file(cam_class,&class_attr_resolution_debug);
+	class_remove_file(cam_class,&class_attr_light_source_debug);
+    class_remove_file(cam_class,&class_attr_version_debug);
+    class_destroy(cam_class);
+    printk("close success\n");
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
+    return 0;
+}
+
+static int ar0543_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct ar0543_fh  *fh = file->private_data;
+	struct ar0543_device *dev = fh->dev;
+	int ret;
+
+	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+
+	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+		ret);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations ar0543_fops = {
+	.owner		= THIS_MODULE,
+	.open           = ar0543_open,
+	.release        = ar0543_close,
+	.read           = ar0543_read,
+	.poll		= ar0543_poll,
+	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+	.mmap           = ar0543_mmap,
+};
+
+static const struct v4l2_ioctl_ops ar0543_ioctl_ops = {
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_querymenu     = vidioc_querymenu,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+	.vidioc_enum_framesizes = vidioc_enum_framesizes,
+	.vidioc_g_parm = vidioc_g_parm,
+	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf          = vidiocgmbuf,
+#endif
+};
+
+static struct video_device ar0543_template = {
+	.name		= "ar0543_v4l",
+	.fops           = &ar0543_fops,
+	.ioctl_ops 	= &ar0543_ioctl_ops,
+	.release	= video_device_release,
+
+	.tvnorms              = V4L2_STD_525_60,
+	.current_norm         = V4L2_STD_NTSC_M,
+};
+
+static int ar0543_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_AR0543, 0);
+}
+
+static const struct v4l2_subdev_core_ops ar0543_core_ops = {
+	.g_chip_ident = ar0543_g_chip_ident,
+};
+
+static const struct v4l2_subdev_ops ar0543_ops = {
+	.core = &ar0543_core_ops,
+};
+
+static ssize_t cam_info_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct ar0543_device *t;
+	
+	t = dev_get_drvdata(dev);
+	
+	len += sprintf(buf+len, "\t%s parameters below\n", t->cam_info.name);
+	len += sprintf(buf+len, "\ti2c_bus_num=%d, front_back=%d,flash=%d, auto_focus=%d, i2c_addr=0x%x\n"
+	                "\tmclk=%d, flash_support=%d, flash_ctrl_level=%d, interface=%d, clk_channel=%d\n",
+	                t->cam_info.i2c_bus_num,
+	                t->cam_info.front_back,
+	                t->cam_info.flash,
+	                t->cam_info.auto_focus,
+	                t->cam_info.i2c_addr,
+	                t->cam_info.mclk,
+	                t->cam_info.flash_support,
+	                t->cam_info.flash_ctrl_level,
+	                t->cam_info.interface,
+	                t->cam_info.clk_channel);
+	return len;
+}
+static ssize_t cam_info_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t len)
+{
+
+	struct ar0543_device *t;
+	unsigned char n=0;
+	unsigned char ret=0;
+	char *buf_orig, *ps, *token;
+	char *parm[3] = {NULL};
+	
+	if(!buf)
+		return len;
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	t = dev_get_drvdata(dev);
+	
+	ps = buf_orig;
+	while (1) {
+	    if ( n >=ARRAY_SIZE(parm) ){
+	            printk("parm array overflow, n=%d, ARRAY_SIZE(parm)=%d\n", n, ARRAY_SIZE(parm));
+	            return len;
+	    }
+	
+	    token = strsep(&ps, " \n");
+	    if (token == NULL)
+	            break;
+	    if (*token == '\0')
+	            continue;
+	    parm[n++] = token;
+	}
+	
+	if ( 0 == strcmp(parm[0],"interface")){
+	    t->cam_info.interface = simple_strtol(parm[1],NULL,16);
+	    printk("substitude with %s interface\n", t->cam_info.interface?"mipi":"dvp");
+	}else if ( 0 == strcmp(parm[0],"clk")){
+	    t->cam_info.clk_channel = simple_strtol(parm[1],NULL,16);
+	    printk("clk channel =%s\n", t->cam_info.interface?"clkB":"clkA");
+	}
+	
+	kfree(buf_orig);
+	
+	return len;
+
+}
+
+static DEVICE_ATTR(cam_info, 0664, cam_info_show, cam_info_store);
+static int ar0543_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	struct ar0543_device *t;
+	struct v4l2_subdev *sd;
+	aml_cam_info_t* plat_dat;
+	v4l_info(client, "chip found @ 0x%x (%s)\n",
+			client->addr << 1, client->adapter->name);
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (t == NULL)
+		return -ENOMEM;
+	sd = &t->sd;
+	v4l2_i2c_subdev_init(sd, client, &ar0543_ops);
+
+	plat_dat = (aml_cam_info_t*)client->dev.platform_data;
+
+	/* Now create a video4linux device */
+	mutex_init(&t->mutex);
+
+	/* Now create a video4linux device */
+	t->vdev = video_device_alloc();
+	if (t->vdev == NULL) {
+		kfree(t);
+		kfree(client);
+		return -ENOMEM;
+	}
+	memcpy(t->vdev, &ar0543_template, sizeof(*t->vdev));
+
+	video_set_drvdata(t->vdev, t);
+	
+	wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "ar0543");
+	/* Register it */
+	if (plat_dat) {
+		memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
+		if(plat_dat->front_back>=0)  
+			video_nr=plat_dat->front_back;
+	}else {
+		printk("camera ar0543: have no platform data\n");
+		kfree(t);
+		kfree(client);
+		return -1;
+	}
+	printk("register device\n");	
+	err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (err < 0) {
+		video_device_release(t->vdev);
+		kfree(t);
+		return err;
+	}
+	device_create_file( &t->vdev->dev, &dev_attr_cam_info);
+	return 0;
+}
+
+static int ar0543_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ar0543_device *t = to_dev(sd);
+	device_remove_file( &t->vdev->dev, &dev_attr_cam_info);
+	video_unregister_device(t->vdev);
+	v4l2_device_unregister_subdev(sd);
+	wake_lock_destroy(&(t->wake_lock));
+	kfree(t);
+	return 0;
+}
+
+static const struct i2c_device_id ar0543_id[] = {
+	{ "ar0543", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0543_id);
+
+static struct i2c_driver ar0543_i2c_driver = {
+	.driver = {
+		.name = "ar0543",
+	},
+	.probe = ar0543_probe,
+	.remove = ar0543_remove,
+	.id_table = ar0543_id,
+};
+
+module_i2c_driver(ar0543_i2c_driver);
+
diff --git a/drivers/amlogic/camera/ar0833.c b/drivers/amlogic/camera/ar0833.c
new file mode 100755
index 000000000000..05b7305f0bb9
--- /dev/null
+++ b/drivers/amlogic/camera/ar0833.c
@@ -0,0 +1,5851 @@
+/*
+ *ar0833 - This code emulates a real video device with v4l2 api
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence, GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ */
+#include <linux/sizes.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/highmem.h>
+#include <linux/freezer.h>
+#include <media/videobuf-res.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <linux/wakelock.h>
+
+#include <linux/i2c.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/amlogic/camera/aml_cam_info.h>
+
+#define MIPI_INTERFACE
+#ifdef MIPI_INTERFACE
+#include <linux/amlogic/mipi/am_mipi_csi2.h>
+#endif
+#include "common/vm.h"
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+//#include <media/amlogic/656in.h>
+#include "common/plat_ctrl.h"
+#include <linux/amlogic/vmapi.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#include <mach/mod_gate.h>
+#endif
+
+#include "common/config_parser.h"
+
+#define AR0833_CAMERA_MODULE_NAME "ar0833"
+#define MAGIC_RE_MEM 0x123039dc
+#define AR0833_RES0_CANVAS_INDEX CAMERA_USER_CANVAS_INDEX
+
+
+/* Wake up at about 30 fps */
+#define WAKE_NUMERATOR 30
+#define WAKE_DENOMINATOR 1001
+#define BUFFER_TIMEOUT     msecs_to_jiffies(500)  /* 0.5 seconds */
+
+#define AR0833_CAMERA_MAJOR_VERSION 0
+#define AR0833_CAMERA_MINOR_VERSION 7
+#define AR0833_CAMERA_RELEASE 0
+#define AR0833_CAMERA_VERSION \
+	KERNEL_VERSION(AR0833_CAMERA_MAJOR_VERSION, AR0833_CAMERA_MINOR_VERSION, AR0833_CAMERA_RELEASE)
+
+
+
+MODULE_DESCRIPTION("ar0833 On Board");
+MODULE_AUTHOR("amlogic-sh");
+MODULE_LICENSE("GPL v2");
+
+static unsigned video_nr = -1;  /* videoX start number, -1 is autodetect. */
+
+static unsigned debug;
+//module_param(debug, uint, 0644);
+//MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 32;
+//module_param(vid_limit, uint, 0644);
+//MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+
+static int ar0833_h_active = 800;
+static int ar0833_v_active = 600;
+static struct v4l2_fract ar0833_frmintervals_active = {
+    .numerator = 1,
+    .denominator = 15,
+};
+
+static int ar0833_have_open=0;
+
+extern configure *cf;
+static camera_mode_t ar0833_work_mode = CAMERA_PREVIEW;
+static struct class *cam_class;
+static unsigned int g_ae_manual_exp;
+static unsigned int g_ae_manual_ag;
+static unsigned int g_ae_manual_vts;
+extern sensor_aet_info_t *sensor_aet_info; // point to 1 of up to 16 aet information
+extern sensor_aet_t *sensor_aet_table;
+extern unsigned int sensor_aet_step;
+
+static unsigned int exp_mode;
+static unsigned int change_cnt;
+static unsigned int current_fmt;
+static unsigned int current_fr = 0;//50 hz
+static unsigned int aet_index;
+static unsigned int last_af_step = 0;
+
+#define HI2056_CAMERA_MODULE_NAME "mipi-hi2056"
+
+static struct am_csi2_camera_para ar0833_para = {
+    .name = HI2056_CAMERA_MODULE_NAME,
+    .output_pixel = 0,
+    .output_line = 0,
+    .active_pixel = 0,
+    .active_line = 0,
+    .frame_rate = 0,
+    .ui_val = 0,
+    .hs_freq = 0,
+    .clock_lane_mode = 0,
+    .mirror = 0,
+    .in_fmt = NULL,
+    .out_fmt = NULL,
+};
+static int i_index = -1;
+static int t_index = -1;
+static int dest_hactive = 640;
+static int dest_vactive = 480;
+static bool bDoingAutoFocusMode = false;
+/* supported controls */
+static struct v4l2_queryctrl ar0833_qctrl[] = {
+	{
+		.id            = V4L2_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 127,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}, {
+		.id            = V4L2_CID_CONTRAST,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Contrast",
+		.minimum       = 0x10,
+		.maximum       = 0x60,
+		.step          = 0xa,
+		.default_value = 0x30,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_HFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on horizontal",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_DISABLED,
+	} ,{
+		.id            = V4L2_CID_VFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on vertical",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_DISABLED,
+	},{
+		.id            = V4L2_CID_DO_WHITE_BALANCE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "white balance",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_EXPOSURE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "exposure",
+		.minimum       = 0,
+		.maximum       = 8,
+		.step          = 0x1,
+		.default_value = 4,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_COLORFX,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "effect",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_WHITENESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "banding",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_FOCUS_AUTO,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "auto focus",
+		.minimum       = CAM_FOCUS_MODE_RELEASE,
+		.maximum       = CAM_FOCUS_MODE_CONTI_PIC,
+		.step          = 0x1,
+		.default_value = CAM_FOCUS_MODE_CONTI_PIC,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "flash",
+		.minimum       = FLASHLIGHT_ON,
+		.maximum       = FLASHLIGHT_TORCH,
+		.step          = 0x1,
+		.default_value = FLASHLIGHT_OFF,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_ZOOM_ABSOLUTE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Zoom, Absolute",
+		.minimum       = 100,
+		.maximum       = 300,
+		.step          = 20,
+		.default_value = 100,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id		= V4L2_CID_ROTATE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotate",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+        .id            = V4L2_CID_AUTO_FOCUS_STATUS,
+        .type          = 8,//V4L2_CTRL_TYPE_BITMASK,
+        .name          = "focus status",
+        .minimum       = 0,
+        .maximum       = ~3,
+        .step          = 0x1,
+        .default_value = V4L2_AUTO_FOCUS_STATUS_IDLE,
+        .flags         = V4L2_CTRL_FLAG_READ_ONLY,
+    },{
+        .id		       = V4L2_CID_FOCUS_ABSOLUTE,
+        .type		   = V4L2_CTRL_TYPE_INTEGER,
+		.name		   = "focus center",
+		.minimum	   = 0,
+		.maximum	   = ((2000) << 16) | 2000,
+		.step		   = 1,
+		.default_value = (1000 << 16) | 1000,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+ 	}
+};
+
+static struct v4l2_frmivalenum ar0833_frmivalenum[]={
+        {
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 640,
+                .height		= 480,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 30,
+                        }
+                }
+        },{
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 1280,
+                .height		= 720,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 30,
+                        }
+                }
+        },{
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 1920,
+                .height		= 1080,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 30,
+                        }
+                }
+        },{
+                .index 		= 1,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 1600,
+                .height		= 1200,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 15,
+                        }
+                }
+        },
+};
+
+struct v4l2_querymenu ar0833_qmenu_wbmode[] = {
+    {
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_CLOUD,
+        .name       = "cloudy-daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_DAYLIGHT,
+        .name       = "daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_INCANDESCENCE,
+        .name       = "incandescent",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_TUNGSTEN,
+        .name       = "tungsten",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "fluorescent", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_MANUAL,
+        .name       = "manual", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_SHADE,
+        .name       = "shade", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_TWILIGHT,
+        .name       = "twilight", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_WARM_FLUORESCENT,
+        .name       = "warm-fluorescent",
+        .reserved   = 0,
+    },
+};
+
+struct v4l2_querymenu ar0833_qmenu_autofocus[] = {
+    {
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_INFINITY,
+        .name       = "infinity",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_CONTI_VID,
+        .name       = "continuous-video",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_FOCUS_AUTO,
+        .index      = CAM_FOCUS_MODE_CONTI_PIC,
+        .name       = "continuous-picture",
+        .reserved   = 0,
+    }
+};
+
+struct v4l2_querymenu ar0833_qmenu_anti_banding_mode[] = {
+    {
+        .id         = V4L2_CID_POWER_LINE_FREQUENCY,
+        .index      = CAM_BANDING_50HZ, 
+        .name       = "50hz",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_POWER_LINE_FREQUENCY,
+        .index      = CAM_BANDING_60HZ, 
+        .name       = "60hz",
+        .reserved   = 0,
+    },
+};
+
+struct v4l2_querymenu ar0833_qmenu_flashmode[] = {
+    {
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_ON,
+        .name       = "on",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_OFF,
+        .name       = "off",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_TORCH,
+        .name       = "torch",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .index      = FLASHLIGHT_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    }
+};
+
+typedef struct {
+    __u32   id;
+    int     num;
+    struct v4l2_querymenu* ar0833_qmenu;
+}ar0833_qmenu_set_t;
+
+ar0833_qmenu_set_t ar0833_qmenu_set[] = {
+    {
+        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .num            = ARRAY_SIZE(ar0833_qmenu_wbmode),
+        .ar0833_qmenu   = ar0833_qmenu_wbmode,
+    },{
+        .id         	= V4L2_CID_POWER_LINE_FREQUENCY,
+        .num            = ARRAY_SIZE(ar0833_qmenu_anti_banding_mode),
+        .ar0833_qmenu   = ar0833_qmenu_anti_banding_mode,
+    }, {
+        .id             = V4L2_CID_FOCUS_AUTO,
+        .num            = ARRAY_SIZE(ar0833_qmenu_autofocus),
+        .ar0833_qmenu   = ar0833_qmenu_autofocus,
+    }, {
+        .id             = V4L2_CID_BACKLIGHT_COMPENSATION,
+        .num            = ARRAY_SIZE(ar0833_qmenu_flashmode),
+        .ar0833_qmenu   = ar0833_qmenu_flashmode,
+    }
+};
+
+static int vidioc_querymenu(struct file *file, void *priv,
+                struct v4l2_querymenu *a)
+{
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ar0833_qmenu_set); i++)
+	if (a->id && a->id == ar0833_qmenu_set[i].id) {
+	    for(j = 0; j < ar0833_qmenu_set[i].num; j++)
+		if (a->index == ar0833_qmenu_set[i].ar0833_qmenu[j].index) {
+			memcpy(a, &( ar0833_qmenu_set[i].ar0833_qmenu[j]),
+				sizeof(*a));
+			return (0);
+		}
+	}
+
+	return -EINVAL;
+}
+
+#define dprintk(dev, level, fmt, arg...) \
+	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+
+/* ------------------------------------------------------------------
+	Basic structures
+   ------------------------------------------------------------------*/
+
+struct ar0833_fmt {
+	char  *name;
+	u32   fourcc;          /* v4l2 format id */
+	int   depth;
+};
+
+static struct ar0833_fmt formats[] = {
+	{
+		.name     = "RGB565 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+		.depth    = 16,
+	},{
+		.name     = "RGB888 (24)",
+		.fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
+		.depth    = 24,
+	},{
+		.name     = "BGR888 (24)",
+		.fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
+		.depth    = 24,
+	},{
+		.name     = "12  Y/CbCr 4:2:0",
+		.fourcc   = V4L2_PIX_FMT_NV12,
+		.depth    = 12,
+	},{
+		.name     = "12  Y/CbCr 4:2:0",
+		.fourcc   = V4L2_PIX_FMT_NV21,
+		.depth    = 12,
+	},{
+		.name     = "YUV420P",
+		.fourcc   = V4L2_PIX_FMT_YUV420,
+		.depth    = 12,
+	},{
+		.name     = "YVU420P",
+		.fourcc   = V4L2_PIX_FMT_YVU420,
+		.depth    = 12,
+	}
+};
+
+static struct ar0833_fmt *get_format(struct v4l2_format *f)
+{
+	struct ar0833_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat)
+			break;
+	}
+
+	if (k == ARRAY_SIZE(formats))
+		return NULL;
+
+	return &formats[k];
+}
+
+struct sg_to_addr {
+	int pos;
+	struct scatterlist *sg;
+};
+
+/* buffer for one video frame */
+struct ar0833_buffer {
+	/* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+
+	struct ar0833_fmt        *fmt;
+	unsigned int canvas_id;
+};
+
+struct ar0833_dmaqueue {
+	struct list_head       active;
+
+	/* thread for generating video stream*/
+	struct task_struct         *kthread;
+	wait_queue_head_t          wq;
+	/* Counters to control fps rate */
+	int                        frame;
+	int                        ini_jiffies;
+};
+
+typedef enum resulution_size_type{
+	SIZE_NULL_TYPE = 0,
+	SIZE_CIF_352X288,
+	SIZE_VGA_640X480,
+	SIZE_720P_1280X720,
+	SIZE_960P_1280X960,
+	SIZE_1080P_1920X1080,
+	SIZE_H1080P_2592X1944,
+	SIZE_6M_3264X1836,
+	SIZE_8M_3264X2448,
+} resulution_size_type_t;
+
+typedef struct resolution_param {
+	struct v4l2_frmsize_discrete frmsize;
+	struct v4l2_frmsize_discrete active_frmsize;
+	int active_fps;
+	resulution_size_type_t size_type;
+	cam_i2c_msg_t* reg_script[2];
+} resolution_param_t;
+
+static LIST_HEAD(ar0833_devicelist);
+
+struct ar0833_device {
+	struct list_head			ar0833_devicelist;
+	struct v4l2_subdev			sd;
+	struct v4l2_device			v4l2_dev;
+
+	spinlock_t                 slock;
+	struct mutex				mutex;
+
+	int                        users;
+
+	/* various device info */
+	struct video_device        *vdev;
+
+	struct ar0833_dmaqueue       vidq;
+
+	/* Several counters */
+	unsigned long              jiffies;
+
+	/* Input Number */
+	int			   input;
+
+	/* platform device data from board initting. */
+	aml_cam_info_t cam_info;
+	
+	cam_parameter_t *cam_para;
+	
+	para_index_t pindex;
+	
+	struct vdin_v4l2_ops_s *vops;
+	
+	fe_arg_t fe_arg;
+	/* wake lock */
+	struct wake_lock	wake_lock;
+	/* ae status */
+	bool ae_on;
+	
+	/* Control 'registers' */
+	int 			   qctl_regs[ARRAY_SIZE(ar0833_qctrl)];
+};
+
+static inline struct ar0833_device *to_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ar0833_device, sd);
+}
+
+struct ar0833_fh {
+	struct ar0833_device            *dev;
+
+	/* video capture */
+	struct ar0833_fmt            *fmt;
+	unsigned int               width, height;
+	struct videobuf_queue      vb_vidq;
+
+	struct videobuf_res_privdata res;
+
+	enum v4l2_buf_type         type;
+	int			   input; 	/* Input Number on bars */
+	int  stream_on;
+	unsigned int		f_flags;
+};
+
+static inline struct ar0833_fh *to_fh(struct ar0833_device *dev)
+{
+	return container_of(dev, struct ar0833_fh, dev);
+}
+
+#define RAW10
+
+/* ------------------------------------------------------------------
+	reg spec of AR0833
+   ------------------------------------------------------------------*/
+static cam_i2c_msg_t AR0833_init_script[] = {
+
+	{END_OF_SCRIPT, 0, 0},
+};
+#ifdef MIPI_INTERFACE
+static cam_i2c_msg_t AR0833_mipi_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+#endif
+static cam_i2c_msg_t AR0833_preview_VGA_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_VGA_script_mipi[] = {
+	{2, 0x301A, 0x0019}, 	// RESET_REGISTER
+	//DELAY 1
+	{TIME_DELAY, 0, 1},
+	{2, 0x301A, 0x0218}, 	// RESET_REGISTER
+	{2, 0x3042, 0x0000}, 	// RESERVED_MFR_3042
+	{2, 0x30C0, 0x1810}, 	// RESERVED_MFR_30C0
+	{2, 0x30C8, 0x0018}, 	// RESERVED_MFR_30C8
+	{2, 0x30D2, 0x0000}, 	// RESERVED_MFR_30D2
+	{2, 0x30D4, 0x3030}, 	// RESERVED_MFR_30D4
+	{2, 0x30D6, 0x2200}, 	// RESERVED_MFR_30D6
+	{2, 0x30DA, 0x0080}, 	// RESERVED_MFR_30DA
+	{2, 0x30DC, 0x0080}, 	// RESERVED_MFR_30DC
+	{2, 0x30EE, 0x0340}, 	// RESERVED_MFR_30EE
+	{2, 0x316A, 0x8800}, 	// RESERVED_MFR_316A
+	{2, 0x316C, 0x8200}, 	// RESERVED_MFR_316C
+	{2, 0x316E, 0x8200}, 	// RESERVED_MFR_316E
+	{2, 0x3172, 0x0286}, 	// ANALOG_CONTROL2
+	{2, 0x3174, 0x8000}, 	// RESERVED_MFR_3174
+	{2, 0x317C, 0xE103}, 	// RESERVED_MFR_317C
+	{2, 0x3180, 0xB080}, 	// RESERVED_MFR_3180
+	{2, 0x31E0, 0x0741}, 	// RESERVED_MFR_31E0
+	{2, 0x31E6, 0x0000}, 	// RESERVED_MFR_31E6
+	{2, 0x3ECC, 0x0056}, 	// RESERVED_MFR_3ECC
+	{2, 0x3ED0, 0xA666}, 	// RESERVED_MFR_3ED0
+	{2, 0x3ED2, 0x6664}, 	// RESERVED_MFR_3ED2
+	{2, 0x3ED4, 0x6ACC}, 	// RESERVED_MFR_3ED4
+	{2, 0x3ED8, 0x7488}, 	// RESERVED_MFR_3ED8
+	{2, 0x3EDA, 0x77CB}, 	// RESERVED_MFR_3EDA
+	{2, 0x3EDE, 0x6664}, 	// RESERVED_MFR_3EDE
+	{2, 0x3EE0, 0x26D5}, 	// RESERVED_MFR_3EE0
+	{2, 0x3EE4, 0x3548}, 	// RESERVED_MFR_3EE4
+	{2, 0x3EE6, 0xB10C}, 	// RESERVED_MFR_3EE6
+	{2, 0x3EE8, 0x6E79}, 	// RESERVED_MFR_3EE8
+	{2, 0x3EEA, 0xC8B9}, 	// RESERVED_MFR_3EEA
+	{2, 0x3EFA, 0xA656}, 	// RESERVED_MFR_3EFA
+	{2, 0x3EFE, 0x99CC}, 	// RESERVED_MFR_3EFE
+	{2, 0x3F00, 0x0028}, 	// RESERVED_MFR_3F00
+	{2, 0x3F02, 0x0140}, 	// RESERVED_MFR_3F02
+	{2, 0x3F04, 0x0002}, 	// RESERVED_MFR_3F04
+	{2, 0x3F06, 0x0004}, 	// RESERVED_MFR_3F06
+	{2, 0x3F08, 0x0008}, 	// RESERVED_MFR_3F08
+	{2, 0x3F0A, 0x0B09}, 	// RESERVED_MFR_3F0A
+	{2, 0x3F0C, 0x0302}, 	// RESERVED_MFR_3F0C
+	{2, 0x3F10, 0x0505}, 	// RESERVED_MFR_3F10
+	{2, 0x3F12, 0x0303}, 	// RESERVED_MFR_3F12
+	{2, 0x3F14, 0x0101}, 	// RESERVED_MFR_3F14
+	{2, 0x3F16, 0x2020}, 	// RESERVED_MFR_3F16
+	{2, 0x3F18, 0x0404}, 	// RESERVED_MFR_3F18
+	{2, 0x3F1A, 0x7070}, 	// RESERVED_MFR_3F1A
+	{2, 0x3F1C, 0x003A}, 	// RESERVED_MFR_3F1C
+	{2, 0x3F1E, 0x003C}, 	// RESERVED_MFR_3F1E
+	{2, 0x3F20, 0x0209}, 	// RESERVED_MFR_3F20
+	{2, 0x3F2C, 0x2210}, 	// RESERVED_MFR_3F2C
+	{2, 0x3F38, 0x44A8}, 	// RESERVED_MFR_3F38
+	{2, 0x3F40, 0x2020}, 	// RESERVED_MFR_3F40
+	{2, 0x3F42, 0x0808}, 	// RESERVED_MFR_3F42
+	{2, 0x3F44, 0x0101}, 	// RESERVED_MFR_3F44
+	{2, 0x0300, 0x0005}, 	// VT_PIX_CLK_DIV
+	{2, 0x0302, 0x0001}, 	// VT_SYS_CLK_DIV
+	{2, 0x0304, 0x0004}, 	// PRE_PLL_CLK_DIV
+	{2, 0x0306, 0x007A}, 	// PLL_MULTIPLIER
+	{2, 0x0308, 0x000A}, 	// OP_PIX_CLK_DIV
+	{2, 0x030A, 0x0001}, 	// OP_SYS_CLK_DIV
+	{2, 0x3064, 0x7800}, 	// RESERVED_MFR_3064
+	//DELAY=1
+	{TIME_DELAY, 0, 1}, 
+	{2, 0x31B0, 0x0060}, 	// FRAME_PREAMBLE
+	{2, 0x31B2, 0x0042}, 	// LINE_PREAMBLE
+	{2, 0x31B4, 0x4C36}, 	// MIPI_TIMING_0
+	{2, 0x31B6, 0x5218}, 	// MIPI_TIMING_1
+	{2, 0x31B8, 0x404A}, 	// MIPI_TIMING_2
+	{2, 0x31BA, 0x028A}, 	// MIPI_TIMING_3
+	{2, 0x31BC, 0x0008}, 	// MIPI_TIMING_4
+	{2, 0x31AE, 0x0202},
+	{1, 0x3D00, 0x04},
+	{1, 0x3D01, 0x71},
+	{1, 0x3D02, 0xC9},
+	{1, 0x3D03, 0xFF},
+	{1, 0x3D04, 0xFF},
+	{1, 0x3D05, 0xFF},
+	{1, 0x3D06, 0xFF},
+	{1, 0x3D07, 0xFF},
+	{1, 0x3D08, 0x6F},
+	{1, 0x3D09, 0x40},
+	{1, 0x3D0A, 0x14},
+	{1, 0x3D0B, 0x0E},
+	{1, 0x3D0C, 0x23},
+	{1, 0x3D0D, 0xC2},
+	{1, 0x3D0E, 0x41},
+	{1, 0x3D0F, 0x20},
+	{1, 0x3D10, 0x30},
+	{1, 0x3D11, 0x54},
+	{1, 0x3D12, 0x80},
+	{1, 0x3D13, 0x42},
+	{1, 0x3D14, 0x00},
+	{1, 0x3D15, 0xC0},
+	{1, 0x3D16, 0x83},
+	{1, 0x3D17, 0x57},
+	{1, 0x3D18, 0x84},
+	{1, 0x3D19, 0x64},
+	{1, 0x3D1A, 0x64},
+	{1, 0x3D1B, 0x55},
+	{1, 0x3D1C, 0x80},
+	{1, 0x3D1D, 0x23},
+	{1, 0x3D1E, 0x00},
+	{1, 0x3D1F, 0x65},
+	{1, 0x3D20, 0x65},
+	{1, 0x3D21, 0x82},
+	{1, 0x3D22, 0x00},
+	{1, 0x3D23, 0xC0},
+	{1, 0x3D24, 0x6E},
+	{1, 0x3D25, 0x80},
+	{1, 0x3D26, 0x50},
+	{1, 0x3D27, 0x51},
+	{1, 0x3D28, 0x83},
+	{1, 0x3D29, 0x42},
+	{1, 0x3D2A, 0x83},
+	{1, 0x3D2B, 0x58},
+	{1, 0x3D2C, 0x6E},
+	{1, 0x3D2D, 0x80},
+	{1, 0x3D2E, 0x5F},
+	{1, 0x3D2F, 0x87},
+	{1, 0x3D30, 0x63},
+	{1, 0x3D31, 0x82},
+	{1, 0x3D32, 0x5B},
+	{1, 0x3D33, 0x82},
+	{1, 0x3D34, 0x59},
+	{1, 0x3D35, 0x80},
+	{1, 0x3D36, 0x5A},
+	{1, 0x3D37, 0x5E},
+	{1, 0x3D38, 0xBD},
+	{1, 0x3D39, 0x59},
+	{1, 0x3D3A, 0x59},
+	{1, 0x3D3B, 0x9D},
+	{1, 0x3D3C, 0x6C},
+	{1, 0x3D3D, 0x80},
+	{1, 0x3D3E, 0x6D},
+	{1, 0x3D3F, 0xA3},
+	{1, 0x3D40, 0x50},
+	{1, 0x3D41, 0x80},
+	{1, 0x3D42, 0x51},
+	{1, 0x3D43, 0x82},
+	{1, 0x3D44, 0x58},
+	{1, 0x3D45, 0x80},
+	{1, 0x3D46, 0x66},
+	{1, 0x3D47, 0x83},
+	{1, 0x3D48, 0x64},
+	{1, 0x3D49, 0x64},
+	{1, 0x3D4A, 0x80},
+	{1, 0x3D4B, 0x30},
+	{1, 0x3D4C, 0x50},
+	{1, 0x3D4D, 0xDC},
+	{1, 0x3D4E, 0x6A},
+	{1, 0x3D4F, 0x83},
+	{1, 0x3D50, 0x6B},
+	{1, 0x3D51, 0xAA},
+	{1, 0x3D52, 0x30},
+	{1, 0x3D53, 0x94},
+	{1, 0x3D54, 0x67},
+	{1, 0x3D55, 0x84},
+	{1, 0x3D56, 0x65},
+	{1, 0x3D57, 0x65},
+	{1, 0x3D58, 0x81},
+	{1, 0x3D59, 0x4D},
+	{1, 0x3D5A, 0x68},
+	{1, 0x3D5B, 0x6A},
+	{1, 0x3D5C, 0xAC},
+	{1, 0x3D5D, 0x06},
+	{1, 0x3D5E, 0x08},
+	{1, 0x3D5F, 0x8D},
+	{1, 0x3D60, 0x45},
+	{1, 0x3D61, 0x96},
+	{1, 0x3D62, 0x45},
+	{1, 0x3D63, 0x85},
+	{1, 0x3D64, 0x6A},
+	{1, 0x3D65, 0x83},
+	{1, 0x3D66, 0x6B},
+	{1, 0x3D67, 0x06},
+	{1, 0x3D68, 0x08},
+	{1, 0x3D69, 0xA9},
+	{1, 0x3D6A, 0x30},
+	{1, 0x3D6B, 0x90},
+	{1, 0x3D6C, 0x67},
+	{1, 0x3D6D, 0x64},
+	{1, 0x3D6E, 0x64},
+	{1, 0x3D6F, 0x89},
+	{1, 0x3D70, 0x65},
+	{1, 0x3D71, 0x65},
+	{1, 0x3D72, 0x81},
+	{1, 0x3D73, 0x58},
+	{1, 0x3D74, 0x88},
+	{1, 0x3D75, 0x10},
+	{1, 0x3D76, 0xC0},
+	{1, 0x3D77, 0xB1},
+	{1, 0x3D78, 0x5E},
+	{1, 0x3D79, 0x96},
+	{1, 0x3D7A, 0x53},
+	{1, 0x3D7B, 0x82},
+	{1, 0x3D7C, 0x5E},
+	{1, 0x3D7D, 0x52},
+	{1, 0x3D7E, 0x66},
+	{1, 0x3D7F, 0x80},
+	{1, 0x3D80, 0x58},
+	{1, 0x3D81, 0x83},
+	{1, 0x3D82, 0x64},
+	{1, 0x3D83, 0x64},
+	{1, 0x3D84, 0x80},
+	{1, 0x3D85, 0x5B},
+	{1, 0x3D86, 0x81},
+	{1, 0x3D87, 0x5A},
+	{1, 0x3D88, 0x1D},
+	{1, 0x3D89, 0x0C},
+	{1, 0x3D8A, 0x80},
+	{1, 0x3D8B, 0x55},
+	{1, 0x3D8C, 0x30},
+	{1, 0x3D8D, 0x60},
+	{1, 0x3D8E, 0x41},
+	{1, 0x3D8F, 0x82},
+	{1, 0x3D90, 0x42},
+	{1, 0x3D91, 0xB2},
+	{1, 0x3D92, 0x42},
+	{1, 0x3D93, 0x80},
+	{1, 0x3D94, 0x40},
+	{1, 0x3D95, 0x81},
+	{1, 0x3D96, 0x40},
+	{1, 0x3D97, 0x89},
+	{1, 0x3D98, 0x06},
+	{1, 0x3D99, 0xC0},
+	{1, 0x3D9A, 0x41},
+	{1, 0x3D9B, 0x80},
+	{1, 0x3D9C, 0x42},
+	{1, 0x3D9D, 0x85},
+	{1, 0x3D9E, 0x44},
+	{1, 0x3D9F, 0x83},
+	{1, 0x3DA0, 0x43},
+	{1, 0x3DA1, 0x82},
+	{1, 0x3DA2, 0x6A},
+	{1, 0x3DA3, 0x83},
+	{1, 0x3DA4, 0x6B},
+	{1, 0x3DA5, 0x8D},
+	{1, 0x3DA6, 0x43},
+	{1, 0x3DA7, 0x83},
+	{1, 0x3DA8, 0x44},
+	{1, 0x3DA9, 0x81},
+	{1, 0x3DAA, 0x41},
+	{1, 0x3DAB, 0x85},
+	{1, 0x3DAC, 0x06},
+	{1, 0x3DAD, 0xC0},
+	{1, 0x3DAE, 0x8C},
+	{1, 0x3DAF, 0x30},
+	{1, 0x3DB0, 0xA4},
+	{1, 0x3DB1, 0x67},
+	{1, 0x3DB2, 0x81},
+	{1, 0x3DB3, 0x42},
+	{1, 0x3DB4, 0x82},
+	{1, 0x3DB5, 0x65},
+	{1, 0x3DB6, 0x65},
+	{1, 0x3DB7, 0x81},
+	{1, 0x3DB8, 0x69},
+	{1, 0x3DB9, 0x6A},
+	{1, 0x3DBA, 0x96},
+	{1, 0x3DBB, 0x40},
+	{1, 0x3DBC, 0x82},
+	{1, 0x3DBD, 0x40},
+	{1, 0x3DBE, 0x89},
+	{1, 0x3DBF, 0x06},
+	{1, 0x3DC0, 0xC0},
+	{1, 0x3DC1, 0x41},
+	{1, 0x3DC2, 0x80},
+	{1, 0x3DC3, 0x42},
+	{1, 0x3DC4, 0x85},
+	{1, 0x3DC5, 0x44},
+	{1, 0x3DC6, 0x83},
+	{1, 0x3DC7, 0x43},
+	{1, 0x3DC8, 0x92},
+	{1, 0x3DC9, 0x43},
+	{1, 0x3DCA, 0x83},
+	{1, 0x3DCB, 0x44},
+	{1, 0x3DCC, 0x85},
+	{1, 0x3DCD, 0x41},
+	{1, 0x3DCE, 0x81},
+	{1, 0x3DCF, 0x06},
+	{1, 0x3DD0, 0xC0},
+	{1, 0x3DD1, 0x81},
+	{1, 0x3DD2, 0x6A},
+	{1, 0x3DD3, 0x83},
+	{1, 0x3DD4, 0x6B},
+	{1, 0x3DD5, 0x82},
+	{1, 0x3DD6, 0x42},
+	{1, 0x3DD7, 0xA0},
+	{1, 0x3DD8, 0x40},
+	{1, 0x3DD9, 0x84},
+	{1, 0x3DDA, 0x38},
+	{1, 0x3DDB, 0xA8},
+	{1, 0x3DDC, 0x33},
+	{1, 0x3DDD, 0x00},
+	{1, 0x3DDE, 0x28},
+	{1, 0x3DDF, 0x30},
+	{1, 0x3DE0, 0x70},
+	{1, 0x3DE1, 0x00},
+	{1, 0x3DE2, 0x6F},
+	{1, 0x3DE3, 0x40},
+	{1, 0x3DE4, 0x14},
+	{1, 0x3DE5, 0x0E},
+	{1, 0x3DE6, 0x23},
+	{1, 0x3DE7, 0xC2},
+	{1, 0x3DE8, 0x41},
+	{1, 0x3DE9, 0x82},
+	{1, 0x3DEA, 0x42},
+	{1, 0x3DEB, 0x00},
+	{1, 0x3DEC, 0xC0},
+	{1, 0x3DED, 0x5D},
+	{1, 0x3DEE, 0x80},
+	{1, 0x3DEF, 0x5A},
+	{1, 0x3DF0, 0x80},
+	{1, 0x3DF1, 0x57},
+	{1, 0x3DF2, 0x84},
+	{1, 0x3DF3, 0x64},
+	{1, 0x3DF4, 0x80},
+	{1, 0x3DF5, 0x55},
+	{1, 0x3DF6, 0x86},
+	{1, 0x3DF7, 0x64},
+	{1, 0x3DF8, 0x80},
+	{1, 0x3DF9, 0x65},
+	{1, 0x3DFA, 0x88},
+	{1, 0x3DFB, 0x65},
+	{1, 0x3DFC, 0x82},
+	{1, 0x3DFD, 0x54},
+	{1, 0x3DFE, 0x80},
+	{1, 0x3DFF, 0x58},
+	{1, 0x3E00, 0x80},
+	{1, 0x3E01, 0x00},
+	{1, 0x3E02, 0xC0},
+	{1, 0x3E03, 0x86},
+	{1, 0x3E04, 0x42},
+	{1, 0x3E05, 0x82},
+	{1, 0x3E06, 0x10},
+	{1, 0x3E07, 0x30},
+	{1, 0x3E08, 0x9C},
+	{1, 0x3E09, 0x5C},
+	{1, 0x3E0A, 0x80},
+	{1, 0x3E0B, 0x6E},
+	{1, 0x3E0C, 0x86},
+	{1, 0x3E0D, 0x5B},
+	{1, 0x3E0E, 0x80},
+	{1, 0x3E0F, 0x63},
+	{1, 0x3E10, 0x9E},
+	{1, 0x3E11, 0x59},
+	{1, 0x3E12, 0x8C},
+	{1, 0x3E13, 0x5E},
+	{1, 0x3E14, 0x8A},
+	{1, 0x3E15, 0x6C},
+	{1, 0x3E16, 0x80},
+	{1, 0x3E17, 0x6D},
+	{1, 0x3E18, 0x81},
+	{1, 0x3E19, 0x5F},
+	{1, 0x3E1A, 0x60},
+	{1, 0x3E1B, 0x61},
+	{1, 0x3E1C, 0x88},
+	{1, 0x3E1D, 0x10},
+	{1, 0x3E1E, 0x30},
+	{1, 0x3E1F, 0x66},
+	{1, 0x3E20, 0x83},
+	{1, 0x3E21, 0x6E},
+	{1, 0x3E22, 0x80},
+	{1, 0x3E23, 0x64},
+	{1, 0x3E24, 0x87},
+	{1, 0x3E25, 0x64},
+	{1, 0x3E26, 0x30},
+	{1, 0x3E27, 0x50},
+	{1, 0x3E28, 0xD3},
+	{1, 0x3E29, 0x6A},
+	{1, 0x3E2A, 0x6B},
+	{1, 0x3E2B, 0xAD},
+	{1, 0x3E2C, 0x30},
+	{1, 0x3E2D, 0x94},
+	{1, 0x3E2E, 0x67},
+	{1, 0x3E2F, 0x84},
+	{1, 0x3E30, 0x65},
+	{1, 0x3E31, 0x82},
+	{1, 0x3E32, 0x4D},
+	{1, 0x3E33, 0x83},
+	{1, 0x3E34, 0x65},
+	{1, 0x3E35, 0x30},
+	{1, 0x3E36, 0x50},
+	{1, 0x3E37, 0xA7},
+	{1, 0x3E38, 0x43},
+	{1, 0x3E39, 0x06},
+	{1, 0x3E3A, 0x00},
+	{1, 0x3E3B, 0x8D},
+	{1, 0x3E3C, 0x45},
+	{1, 0x3E3D, 0x9A},
+	{1, 0x3E3E, 0x6A},
+	{1, 0x3E3F, 0x6B},
+	{1, 0x3E40, 0x45},
+	{1, 0x3E41, 0x85},
+	{1, 0x3E42, 0x06},
+	{1, 0x3E43, 0x00},
+	{1, 0x3E44, 0x81},
+	{1, 0x3E45, 0x43},
+	{1, 0x3E46, 0x8A},
+	{1, 0x3E47, 0x6F},
+	{1, 0x3E48, 0x96},
+	{1, 0x3E49, 0x30},
+	{1, 0x3E4A, 0x90},
+	{1, 0x3E4B, 0x67},
+	{1, 0x3E4C, 0x64},
+	{1, 0x3E4D, 0x88},
+	{1, 0x3E4E, 0x64},
+	{1, 0x3E4F, 0x80},
+	{1, 0x3E50, 0x65},
+	{1, 0x3E51, 0x82},
+	{1, 0x3E52, 0x10},
+	{1, 0x3E53, 0xC0},
+	{1, 0x3E54, 0x84},
+	{1, 0x3E55, 0x65},
+	{1, 0x3E56, 0xEF},
+	{1, 0x3E57, 0x10},
+	{1, 0x3E58, 0xC0},
+	{1, 0x3E59, 0x66},
+	{1, 0x3E5A, 0x85},
+	{1, 0x3E5B, 0x64},
+	{1, 0x3E5C, 0x81},
+	{1, 0x3E5D, 0x17},
+	{1, 0x3E5E, 0x00},
+	{1, 0x3E5F, 0x80},
+	{1, 0x3E60, 0x20},
+	{1, 0x3E61, 0x0D},
+	{1, 0x3E62, 0x80},
+	{1, 0x3E63, 0x18},
+	{1, 0x3E64, 0x0C},
+	{1, 0x3E65, 0x80},
+	{1, 0x3E66, 0x64},
+	{1, 0x3E67, 0x30},
+	{1, 0x3E68, 0x60},
+	{1, 0x3E69, 0x41},
+	{1, 0x3E6A, 0x82},
+	{1, 0x3E6B, 0x42},
+	{1, 0x3E6C, 0xB2},
+	{1, 0x3E6D, 0x42},
+	{1, 0x3E6E, 0x80},
+	{1, 0x3E6F, 0x40},
+	{1, 0x3E70, 0x82},
+	{1, 0x3E71, 0x40},
+	{1, 0x3E72, 0x4C},
+	{1, 0x3E73, 0x45},
+	{1, 0x3E74, 0x92},
+	{1, 0x3E75, 0x6A},
+	{1, 0x3E76, 0x6B},
+	{1, 0x3E77, 0x9B},
+	{1, 0x3E78, 0x45},
+	{1, 0x3E79, 0x81},
+	{1, 0x3E7A, 0x4C},
+	{1, 0x3E7B, 0x40},
+	{1, 0x3E7C, 0x8C},
+	{1, 0x3E7D, 0x30},
+	{1, 0x3E7E, 0xA4},
+	{1, 0x3E7F, 0x67},
+	{1, 0x3E80, 0x85},
+	{1, 0x3E81, 0x65},
+	{1, 0x3E82, 0x87},
+	{1, 0x3E83, 0x65},
+	{1, 0x3E84, 0x30},
+	{1, 0x3E85, 0x60},
+	{1, 0x3E86, 0xD3},
+	{1, 0x3E87, 0x6A},
+	{1, 0x3E88, 0x6B},
+	{1, 0x3E89, 0xAC},
+	{1, 0x3E8A, 0x6C},
+	{1, 0x3E8B, 0x32},
+	{1, 0x3E8C, 0xA8},
+	{1, 0x3E8D, 0x80},
+	{1, 0x3E8E, 0x28},
+	{1, 0x3E8F, 0x30},
+	{1, 0x3E90, 0x70},
+	{1, 0x3E91, 0x00},
+	{1, 0x3E92, 0x80},
+	{1, 0x3E93, 0x40},
+	{1, 0x3E94, 0x4C},
+	{1, 0x3E95, 0xBD},
+	{1, 0x3E96, 0x00},
+	{1, 0x3E97, 0x0E},
+	{1, 0x3E98, 0xBE},
+	{1, 0x3E99, 0x44},
+	{1, 0x3E9A, 0x88},
+	{1, 0x3E9B, 0x44},
+	{1, 0x3E9C, 0xBC},
+	{1, 0x3E9D, 0x78},
+	{1, 0x3E9E, 0x09},
+	{1, 0x3E9F, 0x00},
+	{1, 0x3EA0, 0x89},
+	{1, 0x3EA1, 0x04},
+	{1, 0x3EA2, 0x80},
+	{1, 0x3EA3, 0x80},
+	{1, 0x3EA4, 0x02},
+	{1, 0x3EA5, 0x40},
+	{1, 0x3EA6, 0x86},
+	{1, 0x3EA7, 0x09},
+	{1, 0x3EA8, 0x00},
+	{1, 0x3EA9, 0x8E},
+	{1, 0x3EAA, 0x09},
+	{1, 0x3EAB, 0x00},
+	{1, 0x3EAC, 0x80},
+	{1, 0x3EAD, 0x02},
+	{1, 0x3EAE, 0x40},
+	{1, 0x3EAF, 0x80},
+	{1, 0x3EB0, 0x04},
+	{1, 0x3EB1, 0x80},
+	{1, 0x3EB2, 0x88},
+	{1, 0x3EB3, 0x7D},
+	{1, 0x3EB4, 0xA0},
+	{1, 0x3EB5, 0x86},
+	{1, 0x3EB6, 0x09},
+	{1, 0x3EB7, 0x00},
+	{1, 0x3EB8, 0x87},
+	{1, 0x3EB9, 0x7A},
+	{1, 0x3EBA, 0x00},
+	{1, 0x3EBB, 0x0E},
+	{1, 0x3EBC, 0xC3},
+	{1, 0x3EBD, 0x79},
+	{1, 0x3EBE, 0x4C},
+	{1, 0x3EBF, 0x40},
+	{1, 0x3EC0, 0xBF},
+	{1, 0x3EC1, 0x70},
+	{1, 0x3EC2, 0x00},
+	{1, 0x3EC3, 0x00},
+	{1, 0x3EC4, 0x00},
+	{1, 0x3EC5, 0x00},
+	{1, 0x3EC6, 0x00},
+	{1, 0x3EC7, 0x00},
+	{1, 0x3EC8, 0x00},
+	{1, 0x3EC9, 0x00},
+	{1, 0x3ECA, 0x00},
+	{1, 0x3ECB, 0x00},
+	{2, 0x0342, 0x1D9E}, 	// LINE_LENGTH_PCK
+	{2, 0x0340, 0x0507}, 	// FRAME_LENGTH_LINES
+	{2, 0x0202, 0x0507}, 	// COARSE_INTEGRATION_TIME
+	{2, 0x0344, 0x0008}, 	// X_ADDR_START
+	{2, 0x0348, 0x0CC5}, 	// X_ADDR_END
+	{2, 0x0346, 0x0008}, 	// Y_ADDR_START
+	{2, 0x034A, 0x0995}, 	// Y_ADDR_END
+	{2, 0x034C, 0x0280}, 	// X_OUTPUT_SIZE
+	{2, 0x034E, 0x01E0}, 	// Y_OUTPUT_SIZE
+	{2, 0x3040, 0x40C3}, 	// READ_MODE
+	{2, 0x0400, 0x0002}, 	// SCALING_MODE
+	{2, 0x0402, 0x0000}, 	// SPATIAL_SAMPLING
+	{2, 0x0404, 0x0028}, 	// SCALE_M
+	{2, 0x0408, 0x280C}, 	// RESERVED_CONF_408
+	{2, 0x040A, 0x00C7}, 	// RESERVED_CONF_40A
+	{2, 0x306E, 0x9090}, 	// DATA_PATH_SELECT
+	{2, 0x301A, 0x001C}, 	// RESET_REGISTER
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_preview_720P_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_720P_script_mipi[] = {
+		{2, 0x301A, 0x0019}, 	// RESET_REGISTER
+	//DELAY 1   
+	{TIME_DELAY,0, 1},
+	{2, 0x301A, 0x0218}, 	// RESET_REGISTER
+	{2, 0x3042, 0x0000}, 	// RESERVED_MFR_3042
+	{2, 0x30C0, 0x1810}, 	// RESERVED_MFR_30C0
+	{2, 0x30C8, 0x0018}, 	// RESERVED_MFR_30C8
+	{2, 0x30D2, 0x0000}, 	// RESERVED_MFR_30D2
+	{2, 0x30D4, 0x3030}, 	// RESERVED_MFR_30D4
+	{2, 0x30D6, 0x2200}, 	// RESERVED_MFR_30D6
+	{2, 0x30DA, 0x0080}, 	// RESERVED_MFR_30DA
+	{2, 0x30DC, 0x0080}, 	// RESERVED_MFR_30DC
+	{2, 0x30EE, 0x0340}, 	// RESERVED_MFR_30EE
+	{2, 0x316A, 0x8800}, 	// RESERVED_MFR_316A
+	{2, 0x316C, 0x8200}, 	// RESERVED_MFR_316C
+	{2, 0x316E, 0x8200}, 	// RESERVED_MFR_316E
+	{2, 0x3172, 0x0286}, 	// ANALOG_CONTROL2
+	{2, 0x3174, 0x8000}, 	// RESERVED_MFR_3174
+	{2, 0x317C, 0xE103}, 	// RESERVED_MFR_317C
+	{2, 0x3180, 0xB080}, 	// RESERVED_MFR_3180
+	{2, 0x31E0, 0x0741}, 	// RESERVED_MFR_31E0
+	{2, 0x31E6, 0x0000}, 	// RESERVED_MFR_31E6
+	{2, 0x3ECC, 0x0056}, 	// RESERVED_MFR_3ECC
+	{2, 0x3ED0, 0xA666}, 	// RESERVED_MFR_3ED0
+	{2, 0x3ED2, 0x6664}, 	// RESERVED_MFR_3ED2
+	{2, 0x3ED4, 0x6ACC}, 	// RESERVED_MFR_3ED4
+	{2, 0x3ED8, 0x7488}, 	// RESERVED_MFR_3ED8
+	{2, 0x3EDA, 0x77CB}, 	// RESERVED_MFR_3EDA
+	{2, 0x3EDE, 0x6664}, 	// RESERVED_MFR_3EDE
+	{2, 0x3EE0, 0x26D5}, 	// RESERVED_MFR_3EE0
+	{2, 0x3EE4, 0x3548}, 	// RESERVED_MFR_3EE4
+	{2, 0x3EE6, 0xB10C}, 	// RESERVED_MFR_3EE6
+	{2, 0x3EE8, 0x6E79}, 	// RESERVED_MFR_3EE8
+	{2, 0x3EEA, 0xC8B9}, 	// RESERVED_MFR_3EEA
+	{2, 0x3EFA, 0xA656}, 	// RESERVED_MFR_3EFA
+	{2, 0x3EFE, 0x99CC}, 	// RESERVED_MFR_3EFE
+	{2, 0x3F00, 0x0028}, 	// RESERVED_MFR_3F00
+	{2, 0x3F02, 0x0140}, 	// RESERVED_MFR_3F02
+	{2, 0x3F04, 0x0002}, 	// RESERVED_MFR_3F04
+	{2, 0x3F06, 0x0004}, 	// RESERVED_MFR_3F06
+	{2, 0x3F08, 0x0008}, 	// RESERVED_MFR_3F08
+	{2, 0x3F0A, 0x0B09}, 	// RESERVED_MFR_3F0A
+	{2, 0x3F0C, 0x0302}, 	// RESERVED_MFR_3F0C
+	{2, 0x3F10, 0x0505}, 	// RESERVED_MFR_3F10
+	{2, 0x3F12, 0x0303}, 	// RESERVED_MFR_3F12
+	{2, 0x3F14, 0x0101}, 	// RESERVED_MFR_3F14
+	{2, 0x3F16, 0x2020}, 	// RESERVED_MFR_3F16
+	{2, 0x3F18, 0x0404}, 	// RESERVED_MFR_3F18
+	{2, 0x3F1A, 0x7070}, 	// RESERVED_MFR_3F1A
+	{2, 0x3F1C, 0x003A}, 	// RESERVED_MFR_3F1C
+	{2, 0x3F1E, 0x003C}, 	// RESERVED_MFR_3F1E
+	{2, 0x3F20, 0x0209}, 	// RESERVED_MFR_3F20
+	{2, 0x3F2C, 0x2210}, 	// RESERVED_MFR_3F2C
+	{2, 0x3F38, 0x44A8}, 	// RESERVED_MFR_3F38
+	{2, 0x3F40, 0x2020}, 	// RESERVED_MFR_3F40
+	{2, 0x3F42, 0x0808}, 	// RESERVED_MFR_3F42
+	{2, 0x3F44, 0x0101}, 	// RESERVED_MFR_3F44
+	{2, 0x0300, 0x0005}, 	// VT_PIX_CLK_DIV
+	{2, 0x0302, 0x0001}, 	// VT_SYS_CLK_DIV
+	{2, 0x0304, 0x0004}, 	// PRE_PLL_CLK_DIV
+	{2, 0x0306, 0x007A}, 	// PLL_MULTIPLIER
+	{2, 0x0308, 0x000A}, 	// OP_PIX_CLK_DIV
+	{2, 0x030A, 0x0001}, 	// OP_SYS_CLK_DIV
+	{2, 0x3064, 0x7800}, 	// RESERVED_MFR_3064
+	//DELAY=1
+	{TIME_DELAY, 0, 1},
+	{2, 0x31B0, 0x0060}, 	// FRAME_PREAMBLE
+	{2, 0x31B2, 0x0042}, 	// LINE_PREAMBLE
+	{2, 0x31B4, 0x4C36}, 	// MIPI_TIMING_0
+	{2, 0x31B6, 0x5218}, 	// MIPI_TIMING_1
+	{2, 0x31B8, 0x404A}, 	// MIPI_TIMING_2
+	{2, 0x31BA, 0x028A}, 	// MIPI_TIMING_3
+	{2, 0x31BC, 0x0008}, 	// MIPI_TIMING_4
+	{2, 0x31AE, 0x0202},
+	{1, 0x3D00, 0x04},
+	{1, 0x3D01, 0x71},
+	{1, 0x3D02, 0xC9},
+	{1, 0x3D03, 0xFF},
+	{1, 0x3D04, 0xFF},
+	{1, 0x3D05, 0xFF},
+	{1, 0x3D06, 0xFF},
+	{1, 0x3D07, 0xFF},
+	{1, 0x3D08, 0x6F},
+	{1, 0x3D09, 0x40},
+	{1, 0x3D0A, 0x14},
+	{1, 0x3D0B, 0x0E},
+	{1, 0x3D0C, 0x23},
+	{1, 0x3D0D, 0xC2},
+	{1, 0x3D0E, 0x41},
+	{1, 0x3D0F, 0x20},
+	{1, 0x3D10, 0x30},
+	{1, 0x3D11, 0x54},
+	{1, 0x3D12, 0x80},
+	{1, 0x3D13, 0x42},
+	{1, 0x3D14, 0x00},
+	{1, 0x3D15, 0xC0},
+	{1, 0x3D16, 0x83},
+	{1, 0x3D17, 0x57},
+	{1, 0x3D18, 0x84},
+	{1, 0x3D19, 0x64},
+	{1, 0x3D1A, 0x64},
+	{1, 0x3D1B, 0x55},
+	{1, 0x3D1C, 0x80},
+	{1, 0x3D1D, 0x23},
+	{1, 0x3D1E, 0x00},
+	{1, 0x3D1F, 0x65},
+	{1, 0x3D20, 0x65},
+	{1, 0x3D21, 0x82},
+	{1, 0x3D22, 0x00},
+	{1, 0x3D23, 0xC0},
+	{1, 0x3D24, 0x6E},
+	{1, 0x3D25, 0x80},
+	{1, 0x3D26, 0x50},
+	{1, 0x3D27, 0x51},
+	{1, 0x3D28, 0x83},
+	{1, 0x3D29, 0x42},
+	{1, 0x3D2A, 0x83},
+	{1, 0x3D2B, 0x58},
+	{1, 0x3D2C, 0x6E},
+	{1, 0x3D2D, 0x80},
+	{1, 0x3D2E, 0x5F},
+	{1, 0x3D2F, 0x87},
+	{1, 0x3D30, 0x63},
+	{1, 0x3D31, 0x82},
+	{1, 0x3D32, 0x5B},
+	{1, 0x3D33, 0x82},
+	{1, 0x3D34, 0x59},
+	{1, 0x3D35, 0x80},
+	{1, 0x3D36, 0x5A},
+	{1, 0x3D37, 0x5E},
+	{1, 0x3D38, 0xBD},
+	{1, 0x3D39, 0x59},
+	{1, 0x3D3A, 0x59},
+	{1, 0x3D3B, 0x9D},
+	{1, 0x3D3C, 0x6C},
+	{1, 0x3D3D, 0x80},
+	{1, 0x3D3E, 0x6D},
+	{1, 0x3D3F, 0xA3},
+	{1, 0x3D40, 0x50},
+	{1, 0x3D41, 0x80},
+	{1, 0x3D42, 0x51},
+	{1, 0x3D43, 0x82},
+	{1, 0x3D44, 0x58},
+	{1, 0x3D45, 0x80},
+	{1, 0x3D46, 0x66},
+	{1, 0x3D47, 0x83},
+	{1, 0x3D48, 0x64},
+	{1, 0x3D49, 0x64},
+	{1, 0x3D4A, 0x80},
+	{1, 0x3D4B, 0x30},
+	{1, 0x3D4C, 0x50},
+	{1, 0x3D4D, 0xDC},
+	{1, 0x3D4E, 0x6A},
+	{1, 0x3D4F, 0x83},
+	{1, 0x3D50, 0x6B},
+	{1, 0x3D51, 0xAA},
+	{1, 0x3D52, 0x30},
+	{1, 0x3D53, 0x94},
+	{1, 0x3D54, 0x67},
+	{1, 0x3D55, 0x84},
+	{1, 0x3D56, 0x65},
+	{1, 0x3D57, 0x65},
+	{1, 0x3D58, 0x81},
+	{1, 0x3D59, 0x4D},
+	{1, 0x3D5A, 0x68},
+	{1, 0x3D5B, 0x6A},
+	{1, 0x3D5C, 0xAC},
+	{1, 0x3D5D, 0x06},
+	{1, 0x3D5E, 0x08},
+	{1, 0x3D5F, 0x8D},
+	{1, 0x3D60, 0x45},
+	{1, 0x3D61, 0x96},
+	{1, 0x3D62, 0x45},
+	{1, 0x3D63, 0x85},
+	{1, 0x3D64, 0x6A},
+	{1, 0x3D65, 0x83},
+	{1, 0x3D66, 0x6B},
+	{1, 0x3D67, 0x06},
+	{1, 0x3D68, 0x08},
+	{1, 0x3D69, 0xA9},
+	{1, 0x3D6A, 0x30},
+	{1, 0x3D6B, 0x90},
+	{1, 0x3D6C, 0x67},
+	{1, 0x3D6D, 0x64},
+	{1, 0x3D6E, 0x64},
+	{1, 0x3D6F, 0x89},
+	{1, 0x3D70, 0x65},
+	{1, 0x3D71, 0x65},
+	{1, 0x3D72, 0x81},
+	{1, 0x3D73, 0x58},
+	{1, 0x3D74, 0x88},
+	{1, 0x3D75, 0x10},
+	{1, 0x3D76, 0xC0},
+	{1, 0x3D77, 0xB1},
+	{1, 0x3D78, 0x5E},
+	{1, 0x3D79, 0x96},
+	{1, 0x3D7A, 0x53},
+	{1, 0x3D7B, 0x82},
+	{1, 0x3D7C, 0x5E},
+	{1, 0x3D7D, 0x52},
+	{1, 0x3D7E, 0x66},
+	{1, 0x3D7F, 0x80},
+	{1, 0x3D80, 0x58},
+	{1, 0x3D81, 0x83},
+	{1, 0x3D82, 0x64},
+	{1, 0x3D83, 0x64},
+	{1, 0x3D84, 0x80},
+	{1, 0x3D85, 0x5B},
+	{1, 0x3D86, 0x81},
+	{1, 0x3D87, 0x5A},
+	{1, 0x3D88, 0x1D},
+	{1, 0x3D89, 0x0C},
+	{1, 0x3D8A, 0x80},
+	{1, 0x3D8B, 0x55},
+	{1, 0x3D8C, 0x30},
+	{1, 0x3D8D, 0x60},
+	{1, 0x3D8E, 0x41},
+	{1, 0x3D8F, 0x82},
+	{1, 0x3D90, 0x42},
+	{1, 0x3D91, 0xB2},
+	{1, 0x3D92, 0x42},
+	{1, 0x3D93, 0x80},
+	{1, 0x3D94, 0x40},
+	{1, 0x3D95, 0x81},
+	{1, 0x3D96, 0x40},
+	{1, 0x3D97, 0x89},
+	{1, 0x3D98, 0x06},
+	{1, 0x3D99, 0xC0},
+	{1, 0x3D9A, 0x41},
+	{1, 0x3D9B, 0x80},
+	{1, 0x3D9C, 0x42},
+	{1, 0x3D9D, 0x85},
+	{1, 0x3D9E, 0x44},
+	{1, 0x3D9F, 0x83},
+	{1, 0x3DA0, 0x43},
+	{1, 0x3DA1, 0x82},
+	{1, 0x3DA2, 0x6A},
+	{1, 0x3DA3, 0x83},
+	{1, 0x3DA4, 0x6B},
+	{1, 0x3DA5, 0x8D},
+	{1, 0x3DA6, 0x43},
+	{1, 0x3DA7, 0x83},
+	{1, 0x3DA8, 0x44},
+	{1, 0x3DA9, 0x81},
+	{1, 0x3DAA, 0x41},
+	{1, 0x3DAB, 0x85},
+	{1, 0x3DAC, 0x06},
+	{1, 0x3DAD, 0xC0},
+	{1, 0x3DAE, 0x8C},
+	{1, 0x3DAF, 0x30},
+	{1, 0x3DB0, 0xA4},
+	{1, 0x3DB1, 0x67},
+	{1, 0x3DB2, 0x81},
+	{1, 0x3DB3, 0x42},
+	{1, 0x3DB4, 0x82},
+	{1, 0x3DB5, 0x65},
+	{1, 0x3DB6, 0x65},
+	{1, 0x3DB7, 0x81},
+	{1, 0x3DB8, 0x69},
+	{1, 0x3DB9, 0x6A},
+	{1, 0x3DBA, 0x96},
+	{1, 0x3DBB, 0x40},
+	{1, 0x3DBC, 0x82},
+	{1, 0x3DBD, 0x40},
+	{1, 0x3DBE, 0x89},
+	{1, 0x3DBF, 0x06},
+	{1, 0x3DC0, 0xC0},
+	{1, 0x3DC1, 0x41},
+	{1, 0x3DC2, 0x80},
+	{1, 0x3DC3, 0x42},
+	{1, 0x3DC4, 0x85},
+	{1, 0x3DC5, 0x44},
+	{1, 0x3DC6, 0x83},
+	{1, 0x3DC7, 0x43},
+	{1, 0x3DC8, 0x92},
+	{1, 0x3DC9, 0x43},
+	{1, 0x3DCA, 0x83},
+	{1, 0x3DCB, 0x44},
+	{1, 0x3DCC, 0x85},
+	{1, 0x3DCD, 0x41},
+	{1, 0x3DCE, 0x81},
+	{1, 0x3DCF, 0x06},
+	{1, 0x3DD0, 0xC0},
+	{1, 0x3DD1, 0x81},
+	{1, 0x3DD2, 0x6A},
+	{1, 0x3DD3, 0x83},
+	{1, 0x3DD4, 0x6B},
+	{1, 0x3DD5, 0x82},
+	{1, 0x3DD6, 0x42},
+	{1, 0x3DD7, 0xA0},
+	{1, 0x3DD8, 0x40},
+	{1, 0x3DD9, 0x84},
+	{1, 0x3DDA, 0x38},
+	{1, 0x3DDB, 0xA8},
+	{1, 0x3DDC, 0x33},
+	{1, 0x3DDD, 0x00},
+	{1, 0x3DDE, 0x28},
+	{1, 0x3DDF, 0x30},
+	{1, 0x3DE0, 0x70},
+	{1, 0x3DE1, 0x00},
+	{1, 0x3DE2, 0x6F},
+	{1, 0x3DE3, 0x40},
+	{1, 0x3DE4, 0x14},
+	{1, 0x3DE5, 0x0E},
+	{1, 0x3DE6, 0x23},
+	{1, 0x3DE7, 0xC2},
+	{1, 0x3DE8, 0x41},
+	{1, 0x3DE9, 0x82},
+	{1, 0x3DEA, 0x42},
+	{1, 0x3DEB, 0x00},
+	{1, 0x3DEC, 0xC0},
+	{1, 0x3DED, 0x5D},
+	{1, 0x3DEE, 0x80},
+	{1, 0x3DEF, 0x5A},
+	{1, 0x3DF0, 0x80},
+	{1, 0x3DF1, 0x57},
+	{1, 0x3DF2, 0x84},
+	{1, 0x3DF3, 0x64},
+	{1, 0x3DF4, 0x80},
+	{1, 0x3DF5, 0x55},
+	{1, 0x3DF6, 0x86},
+	{1, 0x3DF7, 0x64},
+	{1, 0x3DF8, 0x80},
+	{1, 0x3DF9, 0x65},
+	{1, 0x3DFA, 0x88},
+	{1, 0x3DFB, 0x65},
+	{1, 0x3DFC, 0x82},
+	{1, 0x3DFD, 0x54},
+	{1, 0x3DFE, 0x80},
+	{1, 0x3DFF, 0x58},
+	{1, 0x3E00, 0x80},
+	{1, 0x3E01, 0x00},
+	{1, 0x3E02, 0xC0},
+	{1, 0x3E03, 0x86},
+	{1, 0x3E04, 0x42},
+	{1, 0x3E05, 0x82},
+	{1, 0x3E06, 0x10},
+	{1, 0x3E07, 0x30},
+	{1, 0x3E08, 0x9C},
+	{1, 0x3E09, 0x5C},
+	{1, 0x3E0A, 0x80},
+	{1, 0x3E0B, 0x6E},
+	{1, 0x3E0C, 0x86},
+	{1, 0x3E0D, 0x5B},
+	{1, 0x3E0E, 0x80},
+	{1, 0x3E0F, 0x63},
+	{1, 0x3E10, 0x9E},
+	{1, 0x3E11, 0x59},
+	{1, 0x3E12, 0x8C},
+	{1, 0x3E13, 0x5E},
+	{1, 0x3E14, 0x8A},
+	{1, 0x3E15, 0x6C},
+	{1, 0x3E16, 0x80},
+	{1, 0x3E17, 0x6D},
+	{1, 0x3E18, 0x81},
+	{1, 0x3E19, 0x5F},
+	{1, 0x3E1A, 0x60},
+	{1, 0x3E1B, 0x61},
+	{1, 0x3E1C, 0x88},
+	{1, 0x3E1D, 0x10},
+	{1, 0x3E1E, 0x30},
+	{1, 0x3E1F, 0x66},
+	{1, 0x3E20, 0x83},
+	{1, 0x3E21, 0x6E},
+	{1, 0x3E22, 0x80},
+	{1, 0x3E23, 0x64},
+	{1, 0x3E24, 0x87},
+	{1, 0x3E25, 0x64},
+	{1, 0x3E26, 0x30},
+	{1, 0x3E27, 0x50},
+	{1, 0x3E28, 0xD3},
+	{1, 0x3E29, 0x6A},
+	{1, 0x3E2A, 0x6B},
+	{1, 0x3E2B, 0xAD},
+	{1, 0x3E2C, 0x30},
+	{1, 0x3E2D, 0x94},
+	{1, 0x3E2E, 0x67},
+	{1, 0x3E2F, 0x84},
+	{1, 0x3E30, 0x65},
+	{1, 0x3E31, 0x82},
+	{1, 0x3E32, 0x4D},
+	{1, 0x3E33, 0x83},
+	{1, 0x3E34, 0x65},
+	{1, 0x3E35, 0x30},
+	{1, 0x3E36, 0x50},
+	{1, 0x3E37, 0xA7},
+	{1, 0x3E38, 0x43},
+	{1, 0x3E39, 0x06},
+	{1, 0x3E3A, 0x00},
+	{1, 0x3E3B, 0x8D},
+	{1, 0x3E3C, 0x45},
+	{1, 0x3E3D, 0x9A},
+	{1, 0x3E3E, 0x6A},
+	{1, 0x3E3F, 0x6B},
+	{1, 0x3E40, 0x45},
+	{1, 0x3E41, 0x85},
+	{1, 0x3E42, 0x06},
+	{1, 0x3E43, 0x00},
+	{1, 0x3E44, 0x81},
+	{1, 0x3E45, 0x43},
+	{1, 0x3E46, 0x8A},
+	{1, 0x3E47, 0x6F},
+	{1, 0x3E48, 0x96},
+	{1, 0x3E49, 0x30},
+	{1, 0x3E4A, 0x90},
+	{1, 0x3E4B, 0x67},
+	{1, 0x3E4C, 0x64},
+	{1, 0x3E4D, 0x88},
+	{1, 0x3E4E, 0x64},
+	{1, 0x3E4F, 0x80},
+	{1, 0x3E50, 0x65},
+	{1, 0x3E51, 0x82},
+	{1, 0x3E52, 0x10},
+	{1, 0x3E53, 0xC0},
+	{1, 0x3E54, 0x84},
+	{1, 0x3E55, 0x65},
+	{1, 0x3E56, 0xEF},
+	{1, 0x3E57, 0x10},
+	{1, 0x3E58, 0xC0},
+	{1, 0x3E59, 0x66},
+	{1, 0x3E5A, 0x85},
+	{1, 0x3E5B, 0x64},
+	{1, 0x3E5C, 0x81},
+	{1, 0x3E5D, 0x17},
+	{1, 0x3E5E, 0x00},
+	{1, 0x3E5F, 0x80},
+	{1, 0x3E60, 0x20},
+	{1, 0x3E61, 0x0D},
+	{1, 0x3E62, 0x80},
+	{1, 0x3E63, 0x18},
+	{1, 0x3E64, 0x0C},
+	{1, 0x3E65, 0x80},
+	{1, 0x3E66, 0x64},
+	{1, 0x3E67, 0x30},
+	{1, 0x3E68, 0x60},
+	{1, 0x3E69, 0x41},
+	{1, 0x3E6A, 0x82},
+	{1, 0x3E6B, 0x42},
+	{1, 0x3E6C, 0xB2},
+	{1, 0x3E6D, 0x42},
+	{1, 0x3E6E, 0x80},
+	{1, 0x3E6F, 0x40},
+	{1, 0x3E70, 0x82},
+	{1, 0x3E71, 0x40},
+	{1, 0x3E72, 0x4C},
+	{1, 0x3E73, 0x45},
+	{1, 0x3E74, 0x92},
+	{1, 0x3E75, 0x6A},
+	{1, 0x3E76, 0x6B},
+	{1, 0x3E77, 0x9B},
+	{1, 0x3E78, 0x45},
+	{1, 0x3E79, 0x81},
+	{1, 0x3E7A, 0x4C},
+	{1, 0x3E7B, 0x40},
+	{1, 0x3E7C, 0x8C},
+	{1, 0x3E7D, 0x30},
+	{1, 0x3E7E, 0xA4},
+	{1, 0x3E7F, 0x67},
+	{1, 0x3E80, 0x85},
+	{1, 0x3E81, 0x65},
+	{1, 0x3E82, 0x87},
+	{1, 0x3E83, 0x65},
+	{1, 0x3E84, 0x30},
+	{1, 0x3E85, 0x60},
+	{1, 0x3E86, 0xD3},
+	{1, 0x3E87, 0x6A},
+	{1, 0x3E88, 0x6B},
+	{1, 0x3E89, 0xAC},
+	{1, 0x3E8A, 0x6C},
+	{1, 0x3E8B, 0x32},
+	{1, 0x3E8C, 0xA8},
+	{1, 0x3E8D, 0x80},
+	{1, 0x3E8E, 0x28},
+	{1, 0x3E8F, 0x30},
+	{1, 0x3E90, 0x70},
+	{1, 0x3E91, 0x00},
+	{1, 0x3E92, 0x80},
+	{1, 0x3E93, 0x40},
+	{1, 0x3E94, 0x4C},
+	{1, 0x3E95, 0xBD},
+	{1, 0x3E96, 0x00},
+	{1, 0x3E97, 0x0E},
+	{1, 0x3E98, 0xBE},
+	{1, 0x3E99, 0x44},
+	{1, 0x3E9A, 0x88},
+	{1, 0x3E9B, 0x44},
+	{1, 0x3E9C, 0xBC},
+	{1, 0x3E9D, 0x78},
+	{1, 0x3E9E, 0x09},
+	{1, 0x3E9F, 0x00},
+	{1, 0x3EA0, 0x89},
+	{1, 0x3EA1, 0x04},
+	{1, 0x3EA2, 0x80},
+	{1, 0x3EA3, 0x80},
+	{1, 0x3EA4, 0x02},
+	{1, 0x3EA5, 0x40},
+	{1, 0x3EA6, 0x86},
+	{1, 0x3EA7, 0x09},
+	{1, 0x3EA8, 0x00},
+	{1, 0x3EA9, 0x8E},
+	{1, 0x3EAA, 0x09},
+	{1, 0x3EAB, 0x00},
+	{1, 0x3EAC, 0x80},
+	{1, 0x3EAD, 0x02},
+	{1, 0x3EAE, 0x40},
+	{1, 0x3EAF, 0x80},
+	{1, 0x3EB0, 0x04},
+	{1, 0x3EB1, 0x80},
+	{1, 0x3EB2, 0x88},
+	{1, 0x3EB3, 0x7D},
+	{1, 0x3EB4, 0xA0},
+	{1, 0x3EB5, 0x86},
+	{1, 0x3EB6, 0x09},
+	{1, 0x3EB7, 0x00},
+	{1, 0x3EB8, 0x87},
+	{1, 0x3EB9, 0x7A},
+	{1, 0x3EBA, 0x00},
+	{1, 0x3EBB, 0x0E},
+	{1, 0x3EBC, 0xC3},
+	{1, 0x3EBD, 0x79},
+	{1, 0x3EBE, 0x4C},
+	{1, 0x3EBF, 0x40},
+	{1, 0x3EC0, 0xBF},
+	{1, 0x3EC1, 0x70},
+	{1, 0x3EC2, 0x00},
+	{1, 0x3EC3, 0x00},
+	{1, 0x3EC4, 0x00},
+	{1, 0x3EC5, 0x00},
+	{1, 0x3EC6, 0x00},
+	{1, 0x3EC7, 0x00},
+	{1, 0x3EC8, 0x00},
+	{1, 0x3EC9, 0x00},
+	{1, 0x3ECA, 0x00},
+	{1, 0x3ECB, 0x00},
+	{2, 0x0342, 0x2500}, 	// LINE_LENGTH_PCK
+	{2, 0x0340, 0x0408}, 	// FRAME_LENGTH_LINES
+	{2, 0x0202, 0x0300}, 	// COARSE_INTEGRATION_TIME
+	{2, 0x0344, 0x0008}, 	// X_ADDR_START
+	{2, 0x0348, 0x0CC5}, 	// X_ADDR_END
+	{2, 0x0346, 0x0130}, 	// Y_ADDR_START
+	{2, 0x034A, 0x085B}, 	// Y_ADDR_END
+	{2, 0x034C, 0x0500}, 	// X_OUTPUT_SIZE
+	{2, 0x034E, 0x02D0}, 	// Y_OUTPUT_SIZE
+	{2, 0x3040, 0x48C3}, 	// READ_MODE
+	{2, 0x0400, 0x0002}, 	// SCALING_MODE
+	{2, 0x0402, 0x0000}, 	// SPATIAL_SAMPLING
+	{2, 0x0404, 0x0014}, 	// SCALE_M
+	{2, 0x0408, 0x1414}, 	// RESERVED_CONF_408
+	{2, 0x040A, 0x018C}, 	// RESERVED_CONF_40A
+	{2, 0x306E, 0x9080}, 	// DATA_PATH_SELECT
+	{2, 0x301A, 0x001C}, 	// RESET_REGISTER
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_preview_960P_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_960P_script_mipi[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_preview_1080P_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_preview_6M_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+static cam_i2c_msg_t AR0833_preview_8M_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_1080P_script_mipi[] = {
+	{2, 0x301A, 0x0019}, 	// RESET_REGISTER
+	//DELAY 1
+	{TIME_DELAY, 0, 1},
+	{2, 0x301A, 0x0218}, 	// RESET_REGISTER
+	{2, 0x3042, 0x0000}, 	// RESERVED_MFR_3042
+	{2, 0x30C0, 0x1810}, 	// RESERVED_MFR_30C0
+	{2, 0x30C8, 0x0018}, 	// RESERVED_MFR_30C8
+	{2, 0x30D2, 0x0000}, 	// RESERVED_MFR_30D2
+	{2, 0x30D4, 0x3030}, 	// RESERVED_MFR_30D4
+	{2, 0x30D6, 0x2200}, 	// RESERVED_MFR_30D6
+	{2, 0x30DA, 0x0080}, 	// RESERVED_MFR_30DA
+	{2, 0x30DC, 0x0080}, 	// RESERVED_MFR_30DC
+	{2, 0x30EE, 0x0340}, 	// RESERVED_MFR_30EE
+	{2, 0x316A, 0x8800}, 	// RESERVED_MFR_316A
+	{2, 0x316C, 0x8200}, 	// RESERVED_MFR_316C
+	{2, 0x316E, 0x8200}, 	// RESERVED_MFR_316E
+	{2, 0x3172, 0x0286}, 	// ANALOG_CONTROL2
+	{2, 0x3174, 0x8000}, 	// RESERVED_MFR_3174
+	{2, 0x317C, 0xE103}, 	// RESERVED_MFR_317C
+	{2, 0x3180, 0xB080}, 	// RESERVED_MFR_3180
+	{2, 0x31E0, 0x0741}, 	// RESERVED_MFR_31E0
+	{2, 0x31E6, 0x0000}, 	// RESERVED_MFR_31E6
+	{2, 0x3ECC, 0x0056}, 	// RESERVED_MFR_3ECC
+	{2, 0x3ED0, 0xA666}, 	// RESERVED_MFR_3ED0
+	{2, 0x3ED2, 0x6664}, 	// RESERVED_MFR_3ED2
+	{2, 0x3ED4, 0x6ACC}, 	// RESERVED_MFR_3ED4
+	{2, 0x3ED8, 0x7488}, 	// RESERVED_MFR_3ED8
+	{2, 0x3EDA, 0x77CB}, 	// RESERVED_MFR_3EDA
+	{2, 0x3EDE, 0x6664}, 	// RESERVED_MFR_3EDE
+	{2, 0x3EE0, 0x26D5}, 	// RESERVED_MFR_3EE0
+	{2, 0x3EE4, 0x3548}, 	// RESERVED_MFR_3EE4
+	{2, 0x3EE6, 0xB10C}, 	// RESERVED_MFR_3EE6
+	{2, 0x3EE8, 0x6E79}, 	// RESERVED_MFR_3EE8
+	{2, 0x3EEA, 0xC8B9}, 	// RESERVED_MFR_3EEA
+	{2, 0x3EFA, 0xA656}, 	// RESERVED_MFR_3EFA
+	{2, 0x3EFE, 0x99CC}, 	// RESERVED_MFR_3EFE
+	{2, 0x3F00, 0x0028}, 	// RESERVED_MFR_3F00
+	{2, 0x3F02, 0x0140}, 	// RESERVED_MFR_3F02
+	{2, 0x3F04, 0x0002}, 	// RESERVED_MFR_3F04
+	{2, 0x3F06, 0x0004}, 	// RESERVED_MFR_3F06
+	{2, 0x3F08, 0x0008}, 	// RESERVED_MFR_3F08
+	{2, 0x3F0A, 0x0B09}, 	// RESERVED_MFR_3F0A
+	{2, 0x3F0C, 0x0302}, 	// RESERVED_MFR_3F0C
+	{2, 0x3F10, 0x0505}, 	// RESERVED_MFR_3F10
+	{2, 0x3F12, 0x0303}, 	// RESERVED_MFR_3F12
+	{2, 0x3F14, 0x0101}, 	// RESERVED_MFR_3F14
+	{2, 0x3F16, 0x2020}, 	// RESERVED_MFR_3F16
+	{2, 0x3F18, 0x0404}, 	// RESERVED_MFR_3F18
+	{2, 0x3F1A, 0x7070}, 	// RESERVED_MFR_3F1A
+	{2, 0x3F1C, 0x003A}, 	// RESERVED_MFR_3F1C
+	{2, 0x3F1E, 0x003C}, 	// RESERVED_MFR_3F1E
+	{2, 0x3F20, 0x0209}, 	// RESERVED_MFR_3F20
+	{2, 0x3F2C, 0x2210}, 	// RESERVED_MFR_3F2C
+	{2, 0x3F38, 0x44A8}, 	// RESERVED_MFR_3F38
+	{2, 0x3F40, 0x2020}, 	// RESERVED_MFR_3F40
+	{2, 0x3F42, 0x0808}, 	// RESERVED_MFR_3F42
+	{2, 0x3F44, 0x0101}, 	// RESERVED_MFR_3F44
+	{2, 0x0300, 0x0005}, 	// VT_PIX_CLK_DIV
+	{2, 0x0302, 0x0001}, 	// VT_SYS_CLK_DIV
+	{2, 0x0304, 0x0004}, 	// PRE_PLL_CLK_DIV
+	{2, 0x0306, 0x007A}, 	// PLL_MULTIPLIER
+	{2, 0x0308, 0x000A}, 	// OP_PIX_CLK_DIV
+	{2, 0x030A, 0x0001}, 	// OP_SYS_CLK_DIV
+	{2, 0x3064, 0x7800}, 	// RESERVED_MFR_3064
+	//DELAY=1
+	{TIME_DELAY, 0, 1},
+	{2, 0x31B0, 0x0060}, 	// FRAME_PREAMBLE
+	{2, 0x31B2, 0x0042}, 	// LINE_PREAMBLE
+	{2, 0x31B4, 0x4C36}, 	// MIPI_TIMING_0
+	{2, 0x31B6, 0x5218}, 	// MIPI_TIMING_1
+	{2, 0x31B8, 0x404A}, 	// MIPI_TIMING_2
+	{2, 0x31BA, 0x028A}, 	// MIPI_TIMING_3
+	{2, 0x31BC, 0x0008}, 	// MIPI_TIMING_4
+	{2, 0x31AE, 0x0202},
+	{1, 0x3D00, 0x04},
+	{1, 0x3D01, 0x71},
+	{1, 0x3D02, 0xC9},
+	{1, 0x3D03, 0xFF},
+	{1, 0x3D04, 0xFF},
+	{1, 0x3D05, 0xFF},
+	{1, 0x3D06, 0xFF},
+	{1, 0x3D07, 0xFF},
+	{1, 0x3D08, 0x6F},
+	{1, 0x3D09, 0x40},
+	{1, 0x3D0A, 0x14},
+	{1, 0x3D0B, 0x0E},
+	{1, 0x3D0C, 0x23},
+	{1, 0x3D0D, 0xC2},
+	{1, 0x3D0E, 0x41},
+	{1, 0x3D0F, 0x20},
+	{1, 0x3D10, 0x30},
+	{1, 0x3D11, 0x54},
+	{1, 0x3D12, 0x80},
+	{1, 0x3D13, 0x42},
+	{1, 0x3D14, 0x00},
+	{1, 0x3D15, 0xC0},
+	{1, 0x3D16, 0x83},
+	{1, 0x3D17, 0x57},
+	{1, 0x3D18, 0x84},
+	{1, 0x3D19, 0x64},
+	{1, 0x3D1A, 0x64},
+	{1, 0x3D1B, 0x55},
+	{1, 0x3D1C, 0x80},
+	{1, 0x3D1D, 0x23},
+	{1, 0x3D1E, 0x00},
+	{1, 0x3D1F, 0x65},
+	{1, 0x3D20, 0x65},
+	{1, 0x3D21, 0x82},
+	{1, 0x3D22, 0x00},
+	{1, 0x3D23, 0xC0},
+	{1, 0x3D24, 0x6E},
+	{1, 0x3D25, 0x80},
+	{1, 0x3D26, 0x50},
+	{1, 0x3D27, 0x51},
+	{1, 0x3D28, 0x83},
+	{1, 0x3D29, 0x42},
+	{1, 0x3D2A, 0x83},
+	{1, 0x3D2B, 0x58},
+	{1, 0x3D2C, 0x6E},
+	{1, 0x3D2D, 0x80},
+	{1, 0x3D2E, 0x5F},
+	{1, 0x3D2F, 0x87},
+	{1, 0x3D30, 0x63},
+	{1, 0x3D31, 0x82},
+	{1, 0x3D32, 0x5B},
+	{1, 0x3D33, 0x82},
+	{1, 0x3D34, 0x59},
+	{1, 0x3D35, 0x80},
+	{1, 0x3D36, 0x5A},
+	{1, 0x3D37, 0x5E},
+	{1, 0x3D38, 0xBD},
+	{1, 0x3D39, 0x59},
+	{1, 0x3D3A, 0x59},
+	{1, 0x3D3B, 0x9D},
+	{1, 0x3D3C, 0x6C},
+	{1, 0x3D3D, 0x80},
+	{1, 0x3D3E, 0x6D},
+	{1, 0x3D3F, 0xA3},
+	{1, 0x3D40, 0x50},
+	{1, 0x3D41, 0x80},
+	{1, 0x3D42, 0x51},
+	{1, 0x3D43, 0x82},
+	{1, 0x3D44, 0x58},
+	{1, 0x3D45, 0x80},
+	{1, 0x3D46, 0x66},
+	{1, 0x3D47, 0x83},
+	{1, 0x3D48, 0x64},
+	{1, 0x3D49, 0x64},
+	{1, 0x3D4A, 0x80},
+	{1, 0x3D4B, 0x30},
+	{1, 0x3D4C, 0x50},
+	{1, 0x3D4D, 0xDC},
+	{1, 0x3D4E, 0x6A},
+	{1, 0x3D4F, 0x83},
+	{1, 0x3D50, 0x6B},
+	{1, 0x3D51, 0xAA},
+	{1, 0x3D52, 0x30},
+	{1, 0x3D53, 0x94},
+	{1, 0x3D54, 0x67},
+	{1, 0x3D55, 0x84},
+	{1, 0x3D56, 0x65},
+	{1, 0x3D57, 0x65},
+	{1, 0x3D58, 0x81},
+	{1, 0x3D59, 0x4D},
+	{1, 0x3D5A, 0x68},
+	{1, 0x3D5B, 0x6A},
+	{1, 0x3D5C, 0xAC},
+	{1, 0x3D5D, 0x06},
+	{1, 0x3D5E, 0x08},
+	{1, 0x3D5F, 0x8D},
+	{1, 0x3D60, 0x45},
+	{1, 0x3D61, 0x96},
+	{1, 0x3D62, 0x45},
+	{1, 0x3D63, 0x85},
+	{1, 0x3D64, 0x6A},
+	{1, 0x3D65, 0x83},
+	{1, 0x3D66, 0x6B},
+	{1, 0x3D67, 0x06},
+	{1, 0x3D68, 0x08},
+	{1, 0x3D69, 0xA9},
+	{1, 0x3D6A, 0x30},
+	{1, 0x3D6B, 0x90},
+	{1, 0x3D6C, 0x67},
+	{1, 0x3D6D, 0x64},
+	{1, 0x3D6E, 0x64},
+	{1, 0x3D6F, 0x89},
+	{1, 0x3D70, 0x65},
+	{1, 0x3D71, 0x65},
+	{1, 0x3D72, 0x81},
+	{1, 0x3D73, 0x58},
+	{1, 0x3D74, 0x88},
+	{1, 0x3D75, 0x10},
+	{1, 0x3D76, 0xC0},
+	{1, 0x3D77, 0xB1},
+	{1, 0x3D78, 0x5E},
+	{1, 0x3D79, 0x96},
+	{1, 0x3D7A, 0x53},
+	{1, 0x3D7B, 0x82},
+	{1, 0x3D7C, 0x5E},
+	{1, 0x3D7D, 0x52},
+	{1, 0x3D7E, 0x66},
+	{1, 0x3D7F, 0x80},
+	{1, 0x3D80, 0x58},
+	{1, 0x3D81, 0x83},
+	{1, 0x3D82, 0x64},
+	{1, 0x3D83, 0x64},
+	{1, 0x3D84, 0x80},
+	{1, 0x3D85, 0x5B},
+	{1, 0x3D86, 0x81},
+	{1, 0x3D87, 0x5A},
+	{1, 0x3D88, 0x1D},
+	{1, 0x3D89, 0x0C},
+	{1, 0x3D8A, 0x80},
+	{1, 0x3D8B, 0x55},
+	{1, 0x3D8C, 0x30},
+	{1, 0x3D8D, 0x60},
+	{1, 0x3D8E, 0x41},
+	{1, 0x3D8F, 0x82},
+	{1, 0x3D90, 0x42},
+	{1, 0x3D91, 0xB2},
+	{1, 0x3D92, 0x42},
+	{1, 0x3D93, 0x80},
+	{1, 0x3D94, 0x40},
+	{1, 0x3D95, 0x81},
+	{1, 0x3D96, 0x40},
+	{1, 0x3D97, 0x89},
+	{1, 0x3D98, 0x06},
+	{1, 0x3D99, 0xC0},
+	{1, 0x3D9A, 0x41},
+	{1, 0x3D9B, 0x80},
+	{1, 0x3D9C, 0x42},
+	{1, 0x3D9D, 0x85},
+	{1, 0x3D9E, 0x44},
+	{1, 0x3D9F, 0x83},
+	{1, 0x3DA0, 0x43},
+	{1, 0x3DA1, 0x82},
+	{1, 0x3DA2, 0x6A},
+	{1, 0x3DA3, 0x83},
+	{1, 0x3DA4, 0x6B},
+	{1, 0x3DA5, 0x8D},
+	{1, 0x3DA6, 0x43},
+	{1, 0x3DA7, 0x83},
+	{1, 0x3DA8, 0x44},
+	{1, 0x3DA9, 0x81},
+	{1, 0x3DAA, 0x41},
+	{1, 0x3DAB, 0x85},
+	{1, 0x3DAC, 0x06},
+	{1, 0x3DAD, 0xC0},
+	{1, 0x3DAE, 0x8C},
+	{1, 0x3DAF, 0x30},
+	{1, 0x3DB0, 0xA4},
+	{1, 0x3DB1, 0x67},
+	{1, 0x3DB2, 0x81},
+	{1, 0x3DB3, 0x42},
+	{1, 0x3DB4, 0x82},
+	{1, 0x3DB5, 0x65},
+	{1, 0x3DB6, 0x65},
+	{1, 0x3DB7, 0x81},
+	{1, 0x3DB8, 0x69},
+	{1, 0x3DB9, 0x6A},
+	{1, 0x3DBA, 0x96},
+	{1, 0x3DBB, 0x40},
+	{1, 0x3DBC, 0x82},
+	{1, 0x3DBD, 0x40},
+	{1, 0x3DBE, 0x89},
+	{1, 0x3DBF, 0x06},
+	{1, 0x3DC0, 0xC0},
+	{1, 0x3DC1, 0x41},
+	{1, 0x3DC2, 0x80},
+	{1, 0x3DC3, 0x42},
+	{1, 0x3DC4, 0x85},
+	{1, 0x3DC5, 0x44},
+	{1, 0x3DC6, 0x83},
+	{1, 0x3DC7, 0x43},
+	{1, 0x3DC8, 0x92},
+	{1, 0x3DC9, 0x43},
+	{1, 0x3DCA, 0x83},
+	{1, 0x3DCB, 0x44},
+	{1, 0x3DCC, 0x85},
+	{1, 0x3DCD, 0x41},
+	{1, 0x3DCE, 0x81},
+	{1, 0x3DCF, 0x06},
+	{1, 0x3DD0, 0xC0},
+	{1, 0x3DD1, 0x81},
+	{1, 0x3DD2, 0x6A},
+	{1, 0x3DD3, 0x83},
+	{1, 0x3DD4, 0x6B},
+	{1, 0x3DD5, 0x82},
+	{1, 0x3DD6, 0x42},
+	{1, 0x3DD7, 0xA0},
+	{1, 0x3DD8, 0x40},
+	{1, 0x3DD9, 0x84},
+	{1, 0x3DDA, 0x38},
+	{1, 0x3DDB, 0xA8},
+	{1, 0x3DDC, 0x33},
+	{1, 0x3DDD, 0x00},
+	{1, 0x3DDE, 0x28},
+	{1, 0x3DDF, 0x30},
+	{1, 0x3DE0, 0x70},
+	{1, 0x3DE1, 0x00},
+	{1, 0x3DE2, 0x6F},
+	{1, 0x3DE3, 0x40},
+	{1, 0x3DE4, 0x14},
+	{1, 0x3DE5, 0x0E},
+	{1, 0x3DE6, 0x23},
+	{1, 0x3DE7, 0xC2},
+	{1, 0x3DE8, 0x41},
+	{1, 0x3DE9, 0x82},
+	{1, 0x3DEA, 0x42},
+	{1, 0x3DEB, 0x00},
+	{1, 0x3DEC, 0xC0},
+	{1, 0x3DED, 0x5D},
+	{1, 0x3DEE, 0x80},
+	{1, 0x3DEF, 0x5A},
+	{1, 0x3DF0, 0x80},
+	{1, 0x3DF1, 0x57},
+	{1, 0x3DF2, 0x84},
+	{1, 0x3DF3, 0x64},
+	{1, 0x3DF4, 0x80},
+	{1, 0x3DF5, 0x55},
+	{1, 0x3DF6, 0x86},
+	{1, 0x3DF7, 0x64},
+	{1, 0x3DF8, 0x80},
+	{1, 0x3DF9, 0x65},
+	{1, 0x3DFA, 0x88},
+	{1, 0x3DFB, 0x65},
+	{1, 0x3DFC, 0x82},
+	{1, 0x3DFD, 0x54},
+	{1, 0x3DFE, 0x80},
+	{1, 0x3DFF, 0x58},
+	{1, 0x3E00, 0x80},
+	{1, 0x3E01, 0x00},
+	{1, 0x3E02, 0xC0},
+	{1, 0x3E03, 0x86},
+	{1, 0x3E04, 0x42},
+	{1, 0x3E05, 0x82},
+	{1, 0x3E06, 0x10},
+	{1, 0x3E07, 0x30},
+	{1, 0x3E08, 0x9C},
+	{1, 0x3E09, 0x5C},
+	{1, 0x3E0A, 0x80},
+	{1, 0x3E0B, 0x6E},
+	{1, 0x3E0C, 0x86},
+	{1, 0x3E0D, 0x5B},
+	{1, 0x3E0E, 0x80},
+	{1, 0x3E0F, 0x63},
+	{1, 0x3E10, 0x9E},
+	{1, 0x3E11, 0x59},
+	{1, 0x3E12, 0x8C},
+	{1, 0x3E13, 0x5E},
+	{1, 0x3E14, 0x8A},
+	{1, 0x3E15, 0x6C},
+	{1, 0x3E16, 0x80},
+	{1, 0x3E17, 0x6D},
+	{1, 0x3E18, 0x81},
+	{1, 0x3E19, 0x5F},
+	{1, 0x3E1A, 0x60},
+	{1, 0x3E1B, 0x61},
+	{1, 0x3E1C, 0x88},
+	{1, 0x3E1D, 0x10},
+	{1, 0x3E1E, 0x30},
+	{1, 0x3E1F, 0x66},
+	{1, 0x3E20, 0x83},
+	{1, 0x3E21, 0x6E},
+	{1, 0x3E22, 0x80},
+	{1, 0x3E23, 0x64},
+	{1, 0x3E24, 0x87},
+	{1, 0x3E25, 0x64},
+	{1, 0x3E26, 0x30},
+	{1, 0x3E27, 0x50},
+	{1, 0x3E28, 0xD3},
+	{1, 0x3E29, 0x6A},
+	{1, 0x3E2A, 0x6B},
+	{1, 0x3E2B, 0xAD},
+	{1, 0x3E2C, 0x30},
+	{1, 0x3E2D, 0x94},
+	{1, 0x3E2E, 0x67},
+	{1, 0x3E2F, 0x84},
+	{1, 0x3E30, 0x65},
+	{1, 0x3E31, 0x82},
+	{1, 0x3E32, 0x4D},
+	{1, 0x3E33, 0x83},
+	{1, 0x3E34, 0x65},
+	{1, 0x3E35, 0x30},
+	{1, 0x3E36, 0x50},
+	{1, 0x3E37, 0xA7},
+	{1, 0x3E38, 0x43},
+	{1, 0x3E39, 0x06},
+	{1, 0x3E3A, 0x00},
+	{1, 0x3E3B, 0x8D},
+	{1, 0x3E3C, 0x45},
+	{1, 0x3E3D, 0x9A},
+	{1, 0x3E3E, 0x6A},
+	{1, 0x3E3F, 0x6B},
+	{1, 0x3E40, 0x45},
+	{1, 0x3E41, 0x85},
+	{1, 0x3E42, 0x06},
+	{1, 0x3E43, 0x00},
+	{1, 0x3E44, 0x81},
+	{1, 0x3E45, 0x43},
+	{1, 0x3E46, 0x8A},
+	{1, 0x3E47, 0x6F},
+	{1, 0x3E48, 0x96},
+	{1, 0x3E49, 0x30},
+	{1, 0x3E4A, 0x90},
+	{1, 0x3E4B, 0x67},
+	{1, 0x3E4C, 0x64},
+	{1, 0x3E4D, 0x88},
+	{1, 0x3E4E, 0x64},
+	{1, 0x3E4F, 0x80},
+	{1, 0x3E50, 0x65},
+	{1, 0x3E51, 0x82},
+	{1, 0x3E52, 0x10},
+	{1, 0x3E53, 0xC0},
+	{1, 0x3E54, 0x84},
+	{1, 0x3E55, 0x65},
+	{1, 0x3E56, 0xEF},
+	{1, 0x3E57, 0x10},
+	{1, 0x3E58, 0xC0},
+	{1, 0x3E59, 0x66},
+	{1, 0x3E5A, 0x85},
+	{1, 0x3E5B, 0x64},
+	{1, 0x3E5C, 0x81},
+	{1, 0x3E5D, 0x17},
+	{1, 0x3E5E, 0x00},
+	{1, 0x3E5F, 0x80},
+	{1, 0x3E60, 0x20},
+	{1, 0x3E61, 0x0D},
+	{1, 0x3E62, 0x80},
+	{1, 0x3E63, 0x18},
+	{1, 0x3E64, 0x0C},
+	{1, 0x3E65, 0x80},
+	{1, 0x3E66, 0x64},
+	{1, 0x3E67, 0x30},
+	{1, 0x3E68, 0x60},
+	{1, 0x3E69, 0x41},
+	{1, 0x3E6A, 0x82},
+	{1, 0x3E6B, 0x42},
+	{1, 0x3E6C, 0xB2},
+	{1, 0x3E6D, 0x42},
+	{1, 0x3E6E, 0x80},
+	{1, 0x3E6F, 0x40},
+	{1, 0x3E70, 0x82},
+	{1, 0x3E71, 0x40},
+	{1, 0x3E72, 0x4C},
+	{1, 0x3E73, 0x45},
+	{1, 0x3E74, 0x92},
+	{1, 0x3E75, 0x6A},
+	{1, 0x3E76, 0x6B},
+	{1, 0x3E77, 0x9B},
+	{1, 0x3E78, 0x45},
+	{1, 0x3E79, 0x81},
+	{1, 0x3E7A, 0x4C},
+	{1, 0x3E7B, 0x40},
+	{1, 0x3E7C, 0x8C},
+	{1, 0x3E7D, 0x30},
+	{1, 0x3E7E, 0xA4},
+	{1, 0x3E7F, 0x67},
+	{1, 0x3E80, 0x85},
+	{1, 0x3E81, 0x65},
+	{1, 0x3E82, 0x87},
+	{1, 0x3E83, 0x65},
+	{1, 0x3E84, 0x30},
+	{1, 0x3E85, 0x60},
+	{1, 0x3E86, 0xD3},
+	{1, 0x3E87, 0x6A},
+	{1, 0x3E88, 0x6B},
+	{1, 0x3E89, 0xAC},
+	{1, 0x3E8A, 0x6C},
+	{1, 0x3E8B, 0x32},
+	{1, 0x3E8C, 0xA8},
+	{1, 0x3E8D, 0x80},
+	{1, 0x3E8E, 0x28},
+	{1, 0x3E8F, 0x30},
+	{1, 0x3E90, 0x70},
+	{1, 0x3E91, 0x00},
+	{1, 0x3E92, 0x80},
+	{1, 0x3E93, 0x40},
+	{1, 0x3E94, 0x4C},
+	{1, 0x3E95, 0xBD},
+	{1, 0x3E96, 0x00},
+	{1, 0x3E97, 0x0E},
+	{1, 0x3E98, 0xBE},
+	{1, 0x3E99, 0x44},
+	{1, 0x3E9A, 0x88},
+	{1, 0x3E9B, 0x44},
+	{1, 0x3E9C, 0xBC},
+	{1, 0x3E9D, 0x78},
+	{1, 0x3E9E, 0x09},
+	{1, 0x3E9F, 0x00},
+	{1, 0x3EA0, 0x89},
+	{1, 0x3EA1, 0x04},
+	{1, 0x3EA2, 0x80},
+	{1, 0x3EA3, 0x80},
+	{1, 0x3EA4, 0x02},
+	{1, 0x3EA5, 0x40},
+	{1, 0x3EA6, 0x86},
+	{1, 0x3EA7, 0x09},
+	{1, 0x3EA8, 0x00},
+	{1, 0x3EA9, 0x8E},
+	{1, 0x3EAA, 0x09},
+	{1, 0x3EAB, 0x00},
+	{1, 0x3EAC, 0x80},
+	{1, 0x3EAD, 0x02},
+	{1, 0x3EAE, 0x40},
+	{1, 0x3EAF, 0x80},
+	{1, 0x3EB0, 0x04},
+	{1, 0x3EB1, 0x80},
+	{1, 0x3EB2, 0x88},
+	{1, 0x3EB3, 0x7D},
+	{1, 0x3EB4, 0xA0},
+	{1, 0x3EB5, 0x86},
+	{1, 0x3EB6, 0x09},
+	{1, 0x3EB7, 0x00},
+	{1, 0x3EB8, 0x87},
+	{1, 0x3EB9, 0x7A},
+	{1, 0x3EBA, 0x00},
+	{1, 0x3EBB, 0x0E},
+	{1, 0x3EBC, 0xC3},
+	{1, 0x3EBD, 0x79},
+	{1, 0x3EBE, 0x4C},
+	{1, 0x3EBF, 0x40},
+	{1, 0x3EC0, 0xBF},
+	{1, 0x3EC1, 0x70},
+	{1, 0x3EC2, 0x00},
+	{1, 0x3EC3, 0x00},
+	{1, 0x3EC4, 0x00},
+	{1, 0x3EC5, 0x00},
+	{1, 0x3EC6, 0x00},
+	{1, 0x3EC7, 0x00},
+	{1, 0x3EC8, 0x00},
+	{1, 0x3EC9, 0x00},
+	{1, 0x3ECA, 0x00},
+	{1, 0x3ECB, 0x00},
+	{2, 0x0342, 0x138C}, 	// LINE_LENGTH_PCK
+	{2, 0x0340, 0x079D}, 	// FRAME_LENGTH_LINES
+	{2, 0x0202, 0x0700}, 	// COARSE_INTEGRATION_TIME
+	{2, 0x0344, 0x0008}, 	// X_ADDR_START
+	{2, 0x0348, 0x0CC7}, 	// X_ADDR_END
+	{2, 0x0346, 0x0130}, 	// Y_ADDR_START
+	{2, 0x034A, 0x085B}, 	// Y_ADDR_END
+	{2, 0x034C, 0x0780}, 	// X_OUTPUT_SIZE
+	{2, 0x034E, 0x0438}, 	// Y_OUTPUT_SIZE
+	{2, 0x3040, 0x4041}, 	// READ_MODE
+	{2, 0x0400, 0x0002}, 	// SCALING_MODE
+	{2, 0x0402, 0x0000}, 	// SPATIAL_SAMPLING
+	{2, 0x0404, 0x001A}, 	// SCALE_M
+	{2, 0x0408, 0x0B0C}, 	// RESERVED_CONF_408
+	{2, 0x040A, 0x018C}, 	// RESERVED_CONF_40A
+	{2, 0x306E, 0x9090}, 	// DATA_PATH_SELECT
+	{2, 0x301A, 0x001C}, 	// RESET_REGISTER
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_capture_8M_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_8M_script_mipi[] = {
+	{2, 0x301A, 0x0019}, 	// RESET_REGISTER
+	//DELAY=1   
+	{TIME_DELAY, 0, 1}, 
+	{2, 0x301A, 0x0218}, 	// RESET_REGISTER
+	{2, 0x301A, 0x0019}, 	// RESET_REGISTER
+	{2, 0x301A, 0x0218}, 	// RESET_REGISTER
+	{2, 0x3042, 0x0000}, 	// RESERVED_MFR_3042
+	{2, 0x30C0, 0x1810}, 	// RESERVED_MFR_30C0
+	{2, 0x30C8, 0x0018}, 	// RESERVED_MFR_30C8
+	{2, 0x30D2, 0x0000}, 	// RESERVED_MFR_30D2
+	{2, 0x30D4, 0x3030}, 	// RESERVED_MFR_30D4
+	{2, 0x30D6, 0x2200}, 	// RESERVED_MFR_30D6
+	{2, 0x30DA, 0x0080}, 	// RESERVED_MFR_30DA
+	{2, 0x30DC, 0x0080}, 	// RESERVED_MFR_30DC
+	{2, 0x30EE, 0x0340}, 	// RESERVED_MFR_30EE
+	{2, 0x316A, 0x8800}, 	// RESERVED_MFR_316A
+	{2, 0x316C, 0x8200}, 	// RESERVED_MFR_316C
+	{2, 0x316E, 0x8200}, 	// RESERVED_MFR_316E
+	{2, 0x3172, 0x0286}, 	// ANALOG_CONTROL2
+	{2, 0x3174, 0x8000}, 	// RESERVED_MFR_3174
+	{2, 0x317C, 0xE103}, 	// RESERVED_MFR_317C
+	{2, 0x3180, 0xB080}, 	// RESERVED_MFR_3180
+	{2, 0x31E0, 0x0741}, 	// RESERVED_MFR_31E0
+	{2, 0x31E6, 0x0000}, 	// RESERVED_MFR_31E6
+	{2, 0x3ECC, 0x0056}, 	// RESERVED_MFR_3ECC
+	{2, 0x3ED0, 0xA666}, 	// RESERVED_MFR_3ED0
+	{2, 0x3ED2, 0x6664}, 	// RESERVED_MFR_3ED2
+	{2, 0x3ED4, 0x6ACC}, 	// RESERVED_MFR_3ED4
+	{2, 0x3ED8, 0x7488}, 	// RESERVED_MFR_3ED8
+	{2, 0x3EDA, 0x77CB}, 	// RESERVED_MFR_3EDA
+	{2, 0x3EDE, 0x6664}, 	// RESERVED_MFR_3EDE
+	{2, 0x3EE0, 0x26D5}, 	// RESERVED_MFR_3EE0
+	{2, 0x3EE4, 0x3548}, 	// RESERVED_MFR_3EE4
+	{2, 0x3EE6, 0xB10C}, 	// RESERVED_MFR_3EE6
+	{2, 0x3EE8, 0x6E79}, 	// RESERVED_MFR_3EE8
+	{2, 0x3EEA, 0xC8B9}, 	// RESERVED_MFR_3EEA
+	{2, 0x3EFA, 0xA656}, 	// RESERVED_MFR_3EFA
+	{2, 0x3EFE, 0x99CC}, 	// RESERVED_MFR_3EFE
+	{2, 0x3F00, 0x0028}, 	// RESERVED_MFR_3F00
+	{2, 0x3F02, 0x0140}, 	// RESERVED_MFR_3F02
+	{2, 0x3F04, 0x0002}, 	// RESERVED_MFR_3F04
+	{2, 0x3F06, 0x0004}, 	// RESERVED_MFR_3F06
+	{2, 0x3F08, 0x0008}, 	// RESERVED_MFR_3F08
+	{2, 0x3F0A, 0x0B09}, 	// RESERVED_MFR_3F0A
+	{2, 0x3F0C, 0x0302}, 	// RESERVED_MFR_3F0C
+	{2, 0x3F10, 0x0505}, 	// RESERVED_MFR_3F10
+	{2, 0x3F12, 0x0303}, 	// RESERVED_MFR_3F12
+	{2, 0x3F14, 0x0101}, 	// RESERVED_MFR_3F14
+	{2, 0x3F16, 0x2020}, 	// RESERVED_MFR_3F16
+	{2, 0x3F18, 0x0404}, 	// RESERVED_MFR_3F18
+	{2, 0x3F1A, 0x7070}, 	// RESERVED_MFR_3F1A
+	{2, 0x3F1C, 0x003A}, 	// RESERVED_MFR_3F1C
+	{2, 0x3F1E, 0x003C}, 	// RESERVED_MFR_3F1E
+	{2, 0x3F20, 0x0209}, 	// RESERVED_MFR_3F20
+	{2, 0x3F2C, 0x2210}, 	// RESERVED_MFR_3F2C
+	{2, 0x3F38, 0x44A8}, 	// RESERVED_MFR_3F38
+	{2, 0x3F40, 0x2020}, 	// RESERVED_MFR_3F40
+	{2, 0x3F42, 0x0808}, 	// RESERVED_MFR_3F42
+	{2, 0x3F44, 0x0101}, 	// RESERVED_MFR_3F44
+	{2, 0x0300, 0x0005}, 	// VT_PIX_CLK_DIV
+	{2, 0x0302, 0x0001}, 	// VT_SYS_CLK_DIV
+	{2, 0x0304, 0x0004}, 	// PRE_PLL_CLK_DIV
+	{2, 0x0306, 0x007A}, 	// PLL_MULTIPLIER
+	{2, 0x0308, 0x000A}, 	// OP_PIX_CLK_DIV
+	{2, 0x030A, 0x0001}, 	// OP_SYS_CLK_DIV
+	{2, 0x3064, 0x7800}, 	// RESERVED_MFR_3064
+	//DELAY=1
+	{TIME_DELAY, 0, 1},
+	{2, 0x31B0, 0x0060}, 	// FRAME_PREAMBLE
+	{2, 0x31B2, 0x0042}, 	// LINE_PREAMBLE
+	{2, 0x31B4, 0x4C36}, 	// MIPI_TIMING_0
+	{2, 0x31B6, 0x5218}, 	// MIPI_TIMING_1
+	{2, 0x31B8, 0x404A}, 	// MIPI_TIMING_2
+	{2, 0x31BA, 0x028A}, 	// MIPI_TIMING_3
+	{2, 0x31BC, 0x0008}, 	// MIPI_TIMING_4
+	{2, 0x31AE, 0x0202},
+	{1, 0x3D00, 0x04},
+	{1, 0x3D01, 0x71},
+	{1, 0x3D02, 0xC9},
+	{1, 0x3D03, 0xFF},
+	{1, 0x3D04, 0xFF},
+	{1, 0x3D05, 0xFF},
+	{1, 0x3D06, 0xFF},
+	{1, 0x3D07, 0xFF},
+	{1, 0x3D08, 0x6F},
+	{1, 0x3D09, 0x40},
+	{1, 0x3D0A, 0x14},
+	{1, 0x3D0B, 0x0E},
+	{1, 0x3D0C, 0x23},
+	{1, 0x3D0D, 0xC2},
+	{1, 0x3D0E, 0x41},
+	{1, 0x3D0F, 0x20},
+	{1, 0x3D10, 0x30},
+	{1, 0x3D11, 0x54},
+	{1, 0x3D12, 0x80},
+	{1, 0x3D13, 0x42},
+	{1, 0x3D14, 0x00},
+	{1, 0x3D15, 0xC0},
+	{1, 0x3D16, 0x83},
+	{1, 0x3D17, 0x57},
+	{1, 0x3D18, 0x84},
+	{1, 0x3D19, 0x64},
+	{1, 0x3D1A, 0x64},
+	{1, 0x3D1B, 0x55},
+	{1, 0x3D1C, 0x80},
+	{1, 0x3D1D, 0x23},
+	{1, 0x3D1E, 0x00},
+	{1, 0x3D1F, 0x65},
+	{1, 0x3D20, 0x65},
+	{1, 0x3D21, 0x82},
+	{1, 0x3D22, 0x00},
+	{1, 0x3D23, 0xC0},
+	{1, 0x3D24, 0x6E},
+	{1, 0x3D25, 0x80},
+	{1, 0x3D26, 0x50},
+	{1, 0x3D27, 0x51},
+	{1, 0x3D28, 0x83},
+	{1, 0x3D29, 0x42},
+	{1, 0x3D2A, 0x83},
+	{1, 0x3D2B, 0x58},
+	{1, 0x3D2C, 0x6E},
+	{1, 0x3D2D, 0x80},
+	{1, 0x3D2E, 0x5F},
+	{1, 0x3D2F, 0x87},
+	{1, 0x3D30, 0x63},
+	{1, 0x3D31, 0x82},
+	{1, 0x3D32, 0x5B},
+	{1, 0x3D33, 0x82},
+	{1, 0x3D34, 0x59},
+	{1, 0x3D35, 0x80},
+	{1, 0x3D36, 0x5A},
+	{1, 0x3D37, 0x5E},
+	{1, 0x3D38, 0xBD},
+	{1, 0x3D39, 0x59},
+	{1, 0x3D3A, 0x59},
+	{1, 0x3D3B, 0x9D},
+	{1, 0x3D3C, 0x6C},
+	{1, 0x3D3D, 0x80},
+	{1, 0x3D3E, 0x6D},
+	{1, 0x3D3F, 0xA3},
+	{1, 0x3D40, 0x50},
+	{1, 0x3D41, 0x80},
+	{1, 0x3D42, 0x51},
+	{1, 0x3D43, 0x82},
+	{1, 0x3D44, 0x58},
+	{1, 0x3D45, 0x80},
+	{1, 0x3D46, 0x66},
+	{1, 0x3D47, 0x83},
+	{1, 0x3D48, 0x64},
+	{1, 0x3D49, 0x64},
+	{1, 0x3D4A, 0x80},
+	{1, 0x3D4B, 0x30},
+	{1, 0x3D4C, 0x50},
+	{1, 0x3D4D, 0xDC},
+	{1, 0x3D4E, 0x6A},
+	{1, 0x3D4F, 0x83},
+	{1, 0x3D50, 0x6B},
+	{1, 0x3D51, 0xAA},
+	{1, 0x3D52, 0x30},
+	{1, 0x3D53, 0x94},
+	{1, 0x3D54, 0x67},
+	{1, 0x3D55, 0x84},
+	{1, 0x3D56, 0x65},
+	{1, 0x3D57, 0x65},
+	{1, 0x3D58, 0x81},
+	{1, 0x3D59, 0x4D},
+	{1, 0x3D5A, 0x68},
+	{1, 0x3D5B, 0x6A},
+	{1, 0x3D5C, 0xAC},
+	{1, 0x3D5D, 0x06},
+	{1, 0x3D5E, 0x08},
+	{1, 0x3D5F, 0x8D},
+	{1, 0x3D60, 0x45},
+	{1, 0x3D61, 0x96},
+	{1, 0x3D62, 0x45},
+	{1, 0x3D63, 0x85},
+	{1, 0x3D64, 0x6A},
+	{1, 0x3D65, 0x83},
+	{1, 0x3D66, 0x6B},
+	{1, 0x3D67, 0x06},
+	{1, 0x3D68, 0x08},
+	{1, 0x3D69, 0xA9},
+	{1, 0x3D6A, 0x30},
+	{1, 0x3D6B, 0x90},
+	{1, 0x3D6C, 0x67},
+	{1, 0x3D6D, 0x64},
+	{1, 0x3D6E, 0x64},
+	{1, 0x3D6F, 0x89},
+	{1, 0x3D70, 0x65},
+	{1, 0x3D71, 0x65},
+	{1, 0x3D72, 0x81},
+	{1, 0x3D73, 0x58},
+	{1, 0x3D74, 0x88},
+	{1, 0x3D75, 0x10},
+	{1, 0x3D76, 0xC0},
+	{1, 0x3D77, 0xB1},
+	{1, 0x3D78, 0x5E},
+	{1, 0x3D79, 0x96},
+	{1, 0x3D7A, 0x53},
+	{1, 0x3D7B, 0x82},
+	{1, 0x3D7C, 0x5E},
+	{1, 0x3D7D, 0x52},
+	{1, 0x3D7E, 0x66},
+	{1, 0x3D7F, 0x80},
+	{1, 0x3D80, 0x58},
+	{1, 0x3D81, 0x83},
+	{1, 0x3D82, 0x64},
+	{1, 0x3D83, 0x64},
+	{1, 0x3D84, 0x80},
+	{1, 0x3D85, 0x5B},
+	{1, 0x3D86, 0x81},
+	{1, 0x3D87, 0x5A},
+	{1, 0x3D88, 0x1D},
+	{1, 0x3D89, 0x0C},
+	{1, 0x3D8A, 0x80},
+	{1, 0x3D8B, 0x55},
+	{1, 0x3D8C, 0x30},
+	{1, 0x3D8D, 0x60},
+	{1, 0x3D8E, 0x41},
+	{1, 0x3D8F, 0x82},
+	{1, 0x3D90, 0x42},
+	{1, 0x3D91, 0xB2},
+	{1, 0x3D92, 0x42},
+	{1, 0x3D93, 0x80},
+	{1, 0x3D94, 0x40},
+	{1, 0x3D95, 0x81},
+	{1, 0x3D96, 0x40},
+	{1, 0x3D97, 0x89},
+	{1, 0x3D98, 0x06},
+	{1, 0x3D99, 0xC0},
+	{1, 0x3D9A, 0x41},
+	{1, 0x3D9B, 0x80},
+	{1, 0x3D9C, 0x42},
+	{1, 0x3D9D, 0x85},
+	{1, 0x3D9E, 0x44},
+	{1, 0x3D9F, 0x83},
+	{1, 0x3DA0, 0x43},
+	{1, 0x3DA1, 0x82},
+	{1, 0x3DA2, 0x6A},
+	{1, 0x3DA3, 0x83},
+	{1, 0x3DA4, 0x6B},
+	{1, 0x3DA5, 0x8D},
+	{1, 0x3DA6, 0x43},
+	{1, 0x3DA7, 0x83},
+	{1, 0x3DA8, 0x44},
+	{1, 0x3DA9, 0x81},
+	{1, 0x3DAA, 0x41},
+	{1, 0x3DAB, 0x85},
+	{1, 0x3DAC, 0x06},
+	{1, 0x3DAD, 0xC0},
+	{1, 0x3DAE, 0x8C},
+	{1, 0x3DAF, 0x30},
+	{1, 0x3DB0, 0xA4},
+	{1, 0x3DB1, 0x67},
+	{1, 0x3DB2, 0x81},
+	{1, 0x3DB3, 0x42},
+	{1, 0x3DB4, 0x82},
+	{1, 0x3DB5, 0x65},
+	{1, 0x3DB6, 0x65},
+	{1, 0x3DB7, 0x81},
+	{1, 0x3DB8, 0x69},
+	{1, 0x3DB9, 0x6A},
+	{1, 0x3DBA, 0x96},
+	{1, 0x3DBB, 0x40},
+	{1, 0x3DBC, 0x82},
+	{1, 0x3DBD, 0x40},
+	{1, 0x3DBE, 0x89},
+	{1, 0x3DBF, 0x06},
+	{1, 0x3DC0, 0xC0},
+	{1, 0x3DC1, 0x41},
+	{1, 0x3DC2, 0x80},
+	{1, 0x3DC3, 0x42},
+	{1, 0x3DC4, 0x85},
+	{1, 0x3DC5, 0x44},
+	{1, 0x3DC6, 0x83},
+	{1, 0x3DC7, 0x43},
+	{1, 0x3DC8, 0x92},
+	{1, 0x3DC9, 0x43},
+	{1, 0x3DCA, 0x83},
+	{1, 0x3DCB, 0x44},
+	{1, 0x3DCC, 0x85},
+	{1, 0x3DCD, 0x41},
+	{1, 0x3DCE, 0x81},
+	{1, 0x3DCF, 0x06},
+	{1, 0x3DD0, 0xC0},
+	{1, 0x3DD1, 0x81},
+	{1, 0x3DD2, 0x6A},
+	{1, 0x3DD3, 0x83},
+	{1, 0x3DD4, 0x6B},
+	{1, 0x3DD5, 0x82},
+	{1, 0x3DD6, 0x42},
+	{1, 0x3DD7, 0xA0},
+	{1, 0x3DD8, 0x40},
+	{1, 0x3DD9, 0x84},
+	{1, 0x3DDA, 0x38},
+	{1, 0x3DDB, 0xA8},
+	{1, 0x3DDC, 0x33},
+	{1, 0x3DDD, 0x00},
+	{1, 0x3DDE, 0x28},
+	{1, 0x3DDF, 0x30},
+	{1, 0x3DE0, 0x70},
+	{1, 0x3DE1, 0x00},
+	{1, 0x3DE2, 0x6F},
+	{1, 0x3DE3, 0x40},
+	{1, 0x3DE4, 0x14},
+	{1, 0x3DE5, 0x0E},
+	{1, 0x3DE6, 0x23},
+	{1, 0x3DE7, 0xC2},
+	{1, 0x3DE8, 0x41},
+	{1, 0x3DE9, 0x82},
+	{1, 0x3DEA, 0x42},
+	{1, 0x3DEB, 0x00},
+	{1, 0x3DEC, 0xC0},
+	{1, 0x3DED, 0x5D},
+	{1, 0x3DEE, 0x80},
+	{1, 0x3DEF, 0x5A},
+	{1, 0x3DF0, 0x80},
+	{1, 0x3DF1, 0x57},
+	{1, 0x3DF2, 0x84},
+	{1, 0x3DF3, 0x64},
+	{1, 0x3DF4, 0x80},
+	{1, 0x3DF5, 0x55},
+	{1, 0x3DF6, 0x86},
+	{1, 0x3DF7, 0x64},
+	{1, 0x3DF8, 0x80},
+	{1, 0x3DF9, 0x65},
+	{1, 0x3DFA, 0x88},
+	{1, 0x3DFB, 0x65},
+	{1, 0x3DFC, 0x82},
+	{1, 0x3DFD, 0x54},
+	{1, 0x3DFE, 0x80},
+	{1, 0x3DFF, 0x58},
+	{1, 0x3E00, 0x80},
+	{1, 0x3E01, 0x00},
+	{1, 0x3E02, 0xC0},
+	{1, 0x3E03, 0x86},
+	{1, 0x3E04, 0x42},
+	{1, 0x3E05, 0x82},
+	{1, 0x3E06, 0x10},
+	{1, 0x3E07, 0x30},
+	{1, 0x3E08, 0x9C},
+	{1, 0x3E09, 0x5C},
+	{1, 0x3E0A, 0x80},
+	{1, 0x3E0B, 0x6E},
+	{1, 0x3E0C, 0x86},
+	{1, 0x3E0D, 0x5B},
+	{1, 0x3E0E, 0x80},
+	{1, 0x3E0F, 0x63},
+	{1, 0x3E10, 0x9E},
+	{1, 0x3E11, 0x59},
+	{1, 0x3E12, 0x8C},
+	{1, 0x3E13, 0x5E},
+	{1, 0x3E14, 0x8A},
+	{1, 0x3E15, 0x6C},
+	{1, 0x3E16, 0x80},
+	{1, 0x3E17, 0x6D},
+	{1, 0x3E18, 0x81},
+	{1, 0x3E19, 0x5F},
+	{1, 0x3E1A, 0x60},
+	{1, 0x3E1B, 0x61},
+	{1, 0x3E1C, 0x88},
+	{1, 0x3E1D, 0x10},
+	{1, 0x3E1E, 0x30},
+	{1, 0x3E1F, 0x66},
+	{1, 0x3E20, 0x83},
+	{1, 0x3E21, 0x6E},
+	{1, 0x3E22, 0x80},
+	{1, 0x3E23, 0x64},
+	{1, 0x3E24, 0x87},
+	{1, 0x3E25, 0x64},
+	{1, 0x3E26, 0x30},
+	{1, 0x3E27, 0x50},
+	{1, 0x3E28, 0xD3},
+	{1, 0x3E29, 0x6A},
+	{1, 0x3E2A, 0x6B},
+	{1, 0x3E2B, 0xAD},
+	{1, 0x3E2C, 0x30},
+	{1, 0x3E2D, 0x94},
+	{1, 0x3E2E, 0x67},
+	{1, 0x3E2F, 0x84},
+	{1, 0x3E30, 0x65},
+	{1, 0x3E31, 0x82},
+	{1, 0x3E32, 0x4D},
+	{1, 0x3E33, 0x83},
+	{1, 0x3E34, 0x65},
+	{1, 0x3E35, 0x30},
+	{1, 0x3E36, 0x50},
+	{1, 0x3E37, 0xA7},
+	{1, 0x3E38, 0x43},
+	{1, 0x3E39, 0x06},
+	{1, 0x3E3A, 0x00},
+	{1, 0x3E3B, 0x8D},
+	{1, 0x3E3C, 0x45},
+	{1, 0x3E3D, 0x9A},
+	{1, 0x3E3E, 0x6A},
+	{1, 0x3E3F, 0x6B},
+	{1, 0x3E40, 0x45},
+	{1, 0x3E41, 0x85},
+	{1, 0x3E42, 0x06},
+	{1, 0x3E43, 0x00},
+	{1, 0x3E44, 0x81},
+	{1, 0x3E45, 0x43},
+	{1, 0x3E46, 0x8A},
+	{1, 0x3E47, 0x6F},
+	{1, 0x3E48, 0x96},
+	{1, 0x3E49, 0x30},
+	{1, 0x3E4A, 0x90},
+	{1, 0x3E4B, 0x67},
+	{1, 0x3E4C, 0x64},
+	{1, 0x3E4D, 0x88},
+	{1, 0x3E4E, 0x64},
+	{1, 0x3E4F, 0x80},
+	{1, 0x3E50, 0x65},
+	{1, 0x3E51, 0x82},
+	{1, 0x3E52, 0x10},
+	{1, 0x3E53, 0xC0},
+	{1, 0x3E54, 0x84},
+	{1, 0x3E55, 0x65},
+	{1, 0x3E56, 0xEF},
+	{1, 0x3E57, 0x10},
+	{1, 0x3E58, 0xC0},
+	{1, 0x3E59, 0x66},
+	{1, 0x3E5A, 0x85},
+	{1, 0x3E5B, 0x64},
+	{1, 0x3E5C, 0x81},
+	{1, 0x3E5D, 0x17},
+	{1, 0x3E5E, 0x00},
+	{1, 0x3E5F, 0x80},
+	{1, 0x3E60, 0x20},
+	{1, 0x3E61, 0x0D},
+	{1, 0x3E62, 0x80},
+	{1, 0x3E63, 0x18},
+	{1, 0x3E64, 0x0C},
+	{1, 0x3E65, 0x80},
+	{1, 0x3E66, 0x64},
+	{1, 0x3E67, 0x30},
+	{1, 0x3E68, 0x60},
+	{1, 0x3E69, 0x41},
+	{1, 0x3E6A, 0x82},
+	{1, 0x3E6B, 0x42},
+	{1, 0x3E6C, 0xB2},
+	{1, 0x3E6D, 0x42},
+	{1, 0x3E6E, 0x80},
+	{1, 0x3E6F, 0x40},
+	{1, 0x3E70, 0x82},
+	{1, 0x3E71, 0x40},
+	{1, 0x3E72, 0x4C},
+	{1, 0x3E73, 0x45},
+	{1, 0x3E74, 0x92},
+	{1, 0x3E75, 0x6A},
+	{1, 0x3E76, 0x6B},
+	{1, 0x3E77, 0x9B},
+	{1, 0x3E78, 0x45},
+	{1, 0x3E79, 0x81},
+	{1, 0x3E7A, 0x4C},
+	{1, 0x3E7B, 0x40},
+	{1, 0x3E7C, 0x8C},
+	{1, 0x3E7D, 0x30},
+	{1, 0x3E7E, 0xA4},
+	{1, 0x3E7F, 0x67},
+	{1, 0x3E80, 0x85},
+	{1, 0x3E81, 0x65},
+	{1, 0x3E82, 0x87},
+	{1, 0x3E83, 0x65},
+	{1, 0x3E84, 0x30},
+	{1, 0x3E85, 0x60},
+	{1, 0x3E86, 0xD3},
+	{1, 0x3E87, 0x6A},
+	{1, 0x3E88, 0x6B},
+	{1, 0x3E89, 0xAC},
+	{1, 0x3E8A, 0x6C},
+	{1, 0x3E8B, 0x32},
+	{1, 0x3E8C, 0xA8},
+	{1, 0x3E8D, 0x80},
+	{1, 0x3E8E, 0x28},
+	{1, 0x3E8F, 0x30},
+	{1, 0x3E90, 0x70},
+	{1, 0x3E91, 0x00},
+	{1, 0x3E92, 0x80},
+	{1, 0x3E93, 0x40},
+	{1, 0x3E94, 0x4C},
+	{1, 0x3E95, 0xBD},
+	{1, 0x3E96, 0x00},
+	{1, 0x3E97, 0x0E},
+	{1, 0x3E98, 0xBE},
+	{1, 0x3E99, 0x44},
+	{1, 0x3E9A, 0x88},
+	{1, 0x3E9B, 0x44},
+	{1, 0x3E9C, 0xBC},
+	{1, 0x3E9D, 0x78},
+	{1, 0x3E9E, 0x09},
+	{1, 0x3E9F, 0x00},
+	{1, 0x3EA0, 0x89},
+	{1, 0x3EA1, 0x04},
+	{1, 0x3EA2, 0x80},
+	{1, 0x3EA3, 0x80},
+	{1, 0x3EA4, 0x02},
+	{1, 0x3EA5, 0x40},
+	{1, 0x3EA6, 0x86},
+	{1, 0x3EA7, 0x09},
+	{1, 0x3EA8, 0x00},
+	{1, 0x3EA9, 0x8E},
+	{1, 0x3EAA, 0x09},
+	{1, 0x3EAB, 0x00},
+	{1, 0x3EAC, 0x80},
+	{1, 0x3EAD, 0x02},
+	{1, 0x3EAE, 0x40},
+	{1, 0x3EAF, 0x80},
+	{1, 0x3EB0, 0x04},
+	{1, 0x3EB1, 0x80},
+	{1, 0x3EB2, 0x88},
+	{1, 0x3EB3, 0x7D},
+	{1, 0x3EB4, 0xA0},
+	{1, 0x3EB5, 0x86},
+	{1, 0x3EB6, 0x09},
+	{1, 0x3EB7, 0x00},
+	{1, 0x3EB8, 0x87},
+	{1, 0x3EB9, 0x7A},
+	{1, 0x3EBA, 0x00},
+	{1, 0x3EBB, 0x0E},
+	{1, 0x3EBC, 0xC3},
+	{1, 0x3EBD, 0x79},
+	{1, 0x3EBE, 0x4C},
+	{1, 0x3EBF, 0x40},
+	{1, 0x3EC0, 0xBF},
+	{1, 0x3EC1, 0x70},
+	{1, 0x3EC2, 0x00},
+	{1, 0x3EC3, 0x00},
+	{1, 0x3EC4, 0x00},
+	{1, 0x3EC5, 0x00},
+	{1, 0x3EC6, 0x00},
+	{1, 0x3EC7, 0x00},
+	{1, 0x3EC8, 0x00},
+	{1, 0x3EC9, 0x00},
+	{1, 0x3ECA, 0x00},
+	{1, 0x3ECB, 0x00},
+	{2, 0x0342, 0x0ECC}, 	// LINE_LENGTH_PCK
+	{2, 0x0340, 0x0A10}, 	// FRAME_LENGTH_LINES
+	{2, 0x0202, 0x0A01}, 	// COARSE_INTEGRATION_TIME
+	{2, 0x0344, 0x0008}, 	// X_ADDR_START
+	{2, 0x0348, 0x0CC7}, 	// X_ADDR_END
+	{2, 0x0346, 0x0008}, 	// Y_ADDR_START
+	{2, 0x034A, 0x0997}, 	// Y_ADDR_END
+	{2, 0x034C, 0x0CC0}, 	// X_OUTPUT_SIZE
+	{2, 0x034E, 0x0990}, 	// Y_OUTPUT_SIZE
+	{2, 0x3040, 0x4041}, 	// READ_MODE
+	{2, 0x0400, 0x0000}, 	// SCALING_MODE
+	{2, 0x0402, 0x0000}, 	// SPATIAL_SAMPLING
+	{2, 0x0404, 0x0010}, 	// SCALE_M
+	{2, 0x0408, 0x1010}, 	// RESERVED_CONF_408
+	{2, 0x040A, 0x0210}, 	// RESERVED_CONF_40A
+	{2, 0x306E, 0x9080}, 	// DATA_PATH_SELECT
+	{2, 0x301A, 0x001C}, 	// RESET_REGISTER
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_capture_6M_script[] = {
+	{END_OF_SCRIPT, 0, 0},
+};
+
+static cam_i2c_msg_t AR0833_6M_script_mipi[] = {
+		{2, 0x301A, 0x0019}, 	// RESET_REGISTER
+	//DELAY 1
+	{TIME_DELAY, 0, 1},
+	{2, 0x301A, 0x0218}, 	// RESET_REGISTER
+	{2, 0x3042, 0x0000}, 	// RESERVED_MFR_3042
+	{2, 0x30C0, 0x1810}, 	// RESERVED_MFR_30C0
+	{2, 0x30C8, 0x0018}, 	// RESERVED_MFR_30C8
+	{2, 0x30D2, 0x0000}, 	// RESERVED_MFR_30D2
+	{2, 0x30D4, 0x3030}, 	// RESERVED_MFR_30D4
+	{2, 0x30D6, 0x2200}, 	// RESERVED_MFR_30D6
+	{2, 0x30DA, 0x0080}, 	// RESERVED_MFR_30DA
+	{2, 0x30DC, 0x0080}, 	// RESERVED_MFR_30DC
+	{2, 0x30EE, 0x0340}, 	// RESERVED_MFR_30EE
+	{2, 0x316A, 0x8800}, 	// RESERVED_MFR_316A
+	{2, 0x316C, 0x8200}, 	// RESERVED_MFR_316C
+	{2, 0x316E, 0x8200}, 	// RESERVED_MFR_316E
+	{2, 0x3172, 0x0286}, 	// ANALOG_CONTROL2
+	{2, 0x3174, 0x8000}, 	// RESERVED_MFR_3174
+	{2, 0x317C, 0xE103}, 	// RESERVED_MFR_317C
+	{2, 0x3180, 0xB080}, 	// RESERVED_MFR_3180
+	{2, 0x31E0, 0x0741}, 	// RESERVED_MFR_31E0
+	{2, 0x31E6, 0x0000}, 	// RESERVED_MFR_31E6
+	{2, 0x3ECC, 0x0056}, 	// RESERVED_MFR_3ECC
+	{2, 0x3ED0, 0xA666}, 	// RESERVED_MFR_3ED0
+	{2, 0x3ED2, 0x6664}, 	// RESERVED_MFR_3ED2
+	{2, 0x3ED4, 0x6ACC}, 	// RESERVED_MFR_3ED4
+	{2, 0x3ED8, 0x7488}, 	// RESERVED_MFR_3ED8
+	{2, 0x3EDA, 0x77CB}, 	// RESERVED_MFR_3EDA
+	{2, 0x3EDE, 0x6664}, 	// RESERVED_MFR_3EDE
+	{2, 0x3EE0, 0x26D5}, 	// RESERVED_MFR_3EE0
+	{2, 0x3EE4, 0x3548}, 	// RESERVED_MFR_3EE4
+	{2, 0x3EE6, 0xB10C}, 	// RESERVED_MFR_3EE6
+	{2, 0x3EE8, 0x6E79}, 	// RESERVED_MFR_3EE8
+	{2, 0x3EEA, 0xC8B9}, 	// RESERVED_MFR_3EEA
+	{2, 0x3EFA, 0xA656}, 	// RESERVED_MFR_3EFA
+	{2, 0x3EFE, 0x99CC}, 	// RESERVED_MFR_3EFE
+	{2, 0x3F00, 0x0028}, 	// RESERVED_MFR_3F00
+	{2, 0x3F02, 0x0140}, 	// RESERVED_MFR_3F02
+	{2, 0x3F04, 0x0002}, 	// RESERVED_MFR_3F04
+	{2, 0x3F06, 0x0004}, 	// RESERVED_MFR_3F06
+	{2, 0x3F08, 0x0008}, 	// RESERVED_MFR_3F08
+	{2, 0x3F0A, 0x0B09}, 	// RESERVED_MFR_3F0A
+	{2, 0x3F0C, 0x0302}, 	// RESERVED_MFR_3F0C
+	{2, 0x3F10, 0x0505}, 	// RESERVED_MFR_3F10
+	{2, 0x3F12, 0x0303}, 	// RESERVED_MFR_3F12
+	{2, 0x3F14, 0x0101}, 	// RESERVED_MFR_3F14
+	{2, 0x3F16, 0x2020}, 	// RESERVED_MFR_3F16
+	{2, 0x3F18, 0x0404}, 	// RESERVED_MFR_3F18
+	{2, 0x3F1A, 0x7070}, 	// RESERVED_MFR_3F1A
+	{2, 0x3F1C, 0x003A}, 	// RESERVED_MFR_3F1C
+	{2, 0x3F1E, 0x003C}, 	// RESERVED_MFR_3F1E
+	{2, 0x3F20, 0x0209}, 	// RESERVED_MFR_3F20
+	{2, 0x3F2C, 0x2210}, 	// RESERVED_MFR_3F2C
+	{2, 0x3F38, 0x44A8}, 	// RESERVED_MFR_3F38
+	{2, 0x3F40, 0x2020}, 	// RESERVED_MFR_3F40
+	{2, 0x3F42, 0x0808}, 	// RESERVED_MFR_3F42
+	{2, 0x3F44, 0x0101}, 	// RESERVED_MFR_3F44
+	{2, 0x0300, 0x0005}, 	// VT_PIX_CLK_DIV
+	{2, 0x0302, 0x0001}, 	// VT_SYS_CLK_DIV
+	{2, 0x0304, 0x0004}, 	// PRE_PLL_CLK_DIV
+	{2, 0x0306, 0x007A}, 	// PLL_MULTIPLIER
+	{2, 0x0308, 0x000A}, 	// OP_PIX_CLK_DIV
+	{2, 0x030A, 0x0001}, 	// OP_SYS_CLK_DIV
+	{2, 0x3064, 0x7800}, 	// RESERVED_MFR_3064
+	//DELAY=1
+	{TIME_DELAY, 0, 1},
+	{2, 0x31B0, 0x0060}, 	// FRAME_PREAMBLE
+	{2, 0x31B2, 0x0042}, 	// LINE_PREAMBLE
+	{2, 0x31B4, 0x4C36}, 	// MIPI_TIMING_0
+	{2, 0x31B6, 0x5218}, 	// MIPI_TIMING_1
+	{2, 0x31B8, 0x404A}, 	// MIPI_TIMING_2
+	{2, 0x31BA, 0x028A}, 	// MIPI_TIMING_3
+	{2, 0x31BC, 0x0008}, 	// MIPI_TIMING_4
+	{2, 0x31AE, 0x0202},
+	{1, 0x3D00, 0x04},
+	{1, 0x3D01, 0x71},
+	{1, 0x3D02, 0xC9},
+	{1, 0x3D03, 0xFF},
+	{1, 0x3D04, 0xFF},
+	{1, 0x3D05, 0xFF},
+	{1, 0x3D06, 0xFF},
+	{1, 0x3D07, 0xFF},
+	{1, 0x3D08, 0x6F},
+	{1, 0x3D09, 0x40},
+	{1, 0x3D0A, 0x14},
+	{1, 0x3D0B, 0x0E},
+	{1, 0x3D0C, 0x23},
+	{1, 0x3D0D, 0xC2},
+	{1, 0x3D0E, 0x41},
+	{1, 0x3D0F, 0x20},
+	{1, 0x3D10, 0x30},
+	{1, 0x3D11, 0x54},
+	{1, 0x3D12, 0x80},
+	{1, 0x3D13, 0x42},
+	{1, 0x3D14, 0x00},
+	{1, 0x3D15, 0xC0},
+	{1, 0x3D16, 0x83},
+	{1, 0x3D17, 0x57},
+	{1, 0x3D18, 0x84},
+	{1, 0x3D19, 0x64},
+	{1, 0x3D1A, 0x64},
+	{1, 0x3D1B, 0x55},
+	{1, 0x3D1C, 0x80},
+	{1, 0x3D1D, 0x23},
+	{1, 0x3D1E, 0x00},
+	{1, 0x3D1F, 0x65},
+	{1, 0x3D20, 0x65},
+	{1, 0x3D21, 0x82},
+	{1, 0x3D22, 0x00},
+	{1, 0x3D23, 0xC0},
+	{1, 0x3D24, 0x6E},
+	{1, 0x3D25, 0x80},
+	{1, 0x3D26, 0x50},
+	{1, 0x3D27, 0x51},
+	{1, 0x3D28, 0x83},
+	{1, 0x3D29, 0x42},
+	{1, 0x3D2A, 0x83},
+	{1, 0x3D2B, 0x58},
+	{1, 0x3D2C, 0x6E},
+	{1, 0x3D2D, 0x80},
+	{1, 0x3D2E, 0x5F},
+	{1, 0x3D2F, 0x87},
+	{1, 0x3D30, 0x63},
+	{1, 0x3D31, 0x82},
+	{1, 0x3D32, 0x5B},
+	{1, 0x3D33, 0x82},
+	{1, 0x3D34, 0x59},
+	{1, 0x3D35, 0x80},
+	{1, 0x3D36, 0x5A},
+	{1, 0x3D37, 0x5E},
+	{1, 0x3D38, 0xBD},
+	{1, 0x3D39, 0x59},
+	{1, 0x3D3A, 0x59},
+	{1, 0x3D3B, 0x9D},
+	{1, 0x3D3C, 0x6C},
+	{1, 0x3D3D, 0x80},
+	{1, 0x3D3E, 0x6D},
+	{1, 0x3D3F, 0xA3},
+	{1, 0x3D40, 0x50},
+	{1, 0x3D41, 0x80},
+	{1, 0x3D42, 0x51},
+	{1, 0x3D43, 0x82},
+	{1, 0x3D44, 0x58},
+	{1, 0x3D45, 0x80},
+	{1, 0x3D46, 0x66},
+	{1, 0x3D47, 0x83},
+	{1, 0x3D48, 0x64},
+	{1, 0x3D49, 0x64},
+	{1, 0x3D4A, 0x80},
+	{1, 0x3D4B, 0x30},
+	{1, 0x3D4C, 0x50},
+	{1, 0x3D4D, 0xDC},
+	{1, 0x3D4E, 0x6A},
+	{1, 0x3D4F, 0x83},
+	{1, 0x3D50, 0x6B},
+	{1, 0x3D51, 0xAA},
+	{1, 0x3D52, 0x30},
+	{1, 0x3D53, 0x94},
+	{1, 0x3D54, 0x67},
+	{1, 0x3D55, 0x84},
+	{1, 0x3D56, 0x65},
+	{1, 0x3D57, 0x65},
+	{1, 0x3D58, 0x81},
+	{1, 0x3D59, 0x4D},
+	{1, 0x3D5A, 0x68},
+	{1, 0x3D5B, 0x6A},
+	{1, 0x3D5C, 0xAC},
+	{1, 0x3D5D, 0x06},
+	{1, 0x3D5E, 0x08},
+	{1, 0x3D5F, 0x8D},
+	{1, 0x3D60, 0x45},
+	{1, 0x3D61, 0x96},
+	{1, 0x3D62, 0x45},
+	{1, 0x3D63, 0x85},
+	{1, 0x3D64, 0x6A},
+	{1, 0x3D65, 0x83},
+	{1, 0x3D66, 0x6B},
+	{1, 0x3D67, 0x06},
+	{1, 0x3D68, 0x08},
+	{1, 0x3D69, 0xA9},
+	{1, 0x3D6A, 0x30},
+	{1, 0x3D6B, 0x90},
+	{1, 0x3D6C, 0x67},
+	{1, 0x3D6D, 0x64},
+	{1, 0x3D6E, 0x64},
+	{1, 0x3D6F, 0x89},
+	{1, 0x3D70, 0x65},
+	{1, 0x3D71, 0x65},
+	{1, 0x3D72, 0x81},
+	{1, 0x3D73, 0x58},
+	{1, 0x3D74, 0x88},
+	{1, 0x3D75, 0x10},
+	{1, 0x3D76, 0xC0},
+	{1, 0x3D77, 0xB1},
+	{1, 0x3D78, 0x5E},
+	{1, 0x3D79, 0x96},
+	{1, 0x3D7A, 0x53},
+	{1, 0x3D7B, 0x82},
+	{1, 0x3D7C, 0x5E},
+	{1, 0x3D7D, 0x52},
+	{1, 0x3D7E, 0x66},
+	{1, 0x3D7F, 0x80},
+	{1, 0x3D80, 0x58},
+	{1, 0x3D81, 0x83},
+	{1, 0x3D82, 0x64},
+	{1, 0x3D83, 0x64},
+	{1, 0x3D84, 0x80},
+	{1, 0x3D85, 0x5B},
+	{1, 0x3D86, 0x81},
+	{1, 0x3D87, 0x5A},
+	{1, 0x3D88, 0x1D},
+	{1, 0x3D89, 0x0C},
+	{1, 0x3D8A, 0x80},
+	{1, 0x3D8B, 0x55},
+	{1, 0x3D8C, 0x30},
+	{1, 0x3D8D, 0x60},
+	{1, 0x3D8E, 0x41},
+	{1, 0x3D8F, 0x82},
+	{1, 0x3D90, 0x42},
+	{1, 0x3D91, 0xB2},
+	{1, 0x3D92, 0x42},
+	{1, 0x3D93, 0x80},
+	{1, 0x3D94, 0x40},
+	{1, 0x3D95, 0x81},
+	{1, 0x3D96, 0x40},
+	{1, 0x3D97, 0x89},
+	{1, 0x3D98, 0x06},
+	{1, 0x3D99, 0xC0},
+	{1, 0x3D9A, 0x41},
+	{1, 0x3D9B, 0x80},
+	{1, 0x3D9C, 0x42},
+	{1, 0x3D9D, 0x85},
+	{1, 0x3D9E, 0x44},
+	{1, 0x3D9F, 0x83},
+	{1, 0x3DA0, 0x43},
+	{1, 0x3DA1, 0x82},
+	{1, 0x3DA2, 0x6A},
+	{1, 0x3DA3, 0x83},
+	{1, 0x3DA4, 0x6B},
+	{1, 0x3DA5, 0x8D},
+	{1, 0x3DA6, 0x43},
+	{1, 0x3DA7, 0x83},
+	{1, 0x3DA8, 0x44},
+	{1, 0x3DA9, 0x81},
+	{1, 0x3DAA, 0x41},
+	{1, 0x3DAB, 0x85},
+	{1, 0x3DAC, 0x06},
+	{1, 0x3DAD, 0xC0},
+	{1, 0x3DAE, 0x8C},
+	{1, 0x3DAF, 0x30},
+	{1, 0x3DB0, 0xA4},
+	{1, 0x3DB1, 0x67},
+	{1, 0x3DB2, 0x81},
+	{1, 0x3DB3, 0x42},
+	{1, 0x3DB4, 0x82},
+	{1, 0x3DB5, 0x65},
+	{1, 0x3DB6, 0x65},
+	{1, 0x3DB7, 0x81},
+	{1, 0x3DB8, 0x69},
+	{1, 0x3DB9, 0x6A},
+	{1, 0x3DBA, 0x96},
+	{1, 0x3DBB, 0x40},
+	{1, 0x3DBC, 0x82},
+	{1, 0x3DBD, 0x40},
+	{1, 0x3DBE, 0x89},
+	{1, 0x3DBF, 0x06},
+	{1, 0x3DC0, 0xC0},
+	{1, 0x3DC1, 0x41},
+	{1, 0x3DC2, 0x80},
+	{1, 0x3DC3, 0x42},
+	{1, 0x3DC4, 0x85},
+	{1, 0x3DC5, 0x44},
+	{1, 0x3DC6, 0x83},
+	{1, 0x3DC7, 0x43},
+	{1, 0x3DC8, 0x92},
+	{1, 0x3DC9, 0x43},
+	{1, 0x3DCA, 0x83},
+	{1, 0x3DCB, 0x44},
+	{1, 0x3DCC, 0x85},
+	{1, 0x3DCD, 0x41},
+	{1, 0x3DCE, 0x81},
+	{1, 0x3DCF, 0x06},
+	{1, 0x3DD0, 0xC0},
+	{1, 0x3DD1, 0x81},
+	{1, 0x3DD2, 0x6A},
+	{1, 0x3DD3, 0x83},
+	{1, 0x3DD4, 0x6B},
+	{1, 0x3DD5, 0x82},
+	{1, 0x3DD6, 0x42},
+	{1, 0x3DD7, 0xA0},
+	{1, 0x3DD8, 0x40},
+	{1, 0x3DD9, 0x84},
+	{1, 0x3DDA, 0x38},
+	{1, 0x3DDB, 0xA8},
+	{1, 0x3DDC, 0x33},
+	{1, 0x3DDD, 0x00},
+	{1, 0x3DDE, 0x28},
+	{1, 0x3DDF, 0x30},
+	{1, 0x3DE0, 0x70},
+	{1, 0x3DE1, 0x00},
+	{1, 0x3DE2, 0x6F},
+	{1, 0x3DE3, 0x40},
+	{1, 0x3DE4, 0x14},
+	{1, 0x3DE5, 0x0E},
+	{1, 0x3DE6, 0x23},
+	{1, 0x3DE7, 0xC2},
+	{1, 0x3DE8, 0x41},
+	{1, 0x3DE9, 0x82},
+	{1, 0x3DEA, 0x42},
+	{1, 0x3DEB, 0x00},
+	{1, 0x3DEC, 0xC0},
+	{1, 0x3DED, 0x5D},
+	{1, 0x3DEE, 0x80},
+	{1, 0x3DEF, 0x5A},
+	{1, 0x3DF0, 0x80},
+	{1, 0x3DF1, 0x57},
+	{1, 0x3DF2, 0x84},
+	{1, 0x3DF3, 0x64},
+	{1, 0x3DF4, 0x80},
+	{1, 0x3DF5, 0x55},
+	{1, 0x3DF6, 0x86},
+	{1, 0x3DF7, 0x64},
+	{1, 0x3DF8, 0x80},
+	{1, 0x3DF9, 0x65},
+	{1, 0x3DFA, 0x88},
+	{1, 0x3DFB, 0x65},
+	{1, 0x3DFC, 0x82},
+	{1, 0x3DFD, 0x54},
+	{1, 0x3DFE, 0x80},
+	{1, 0x3DFF, 0x58},
+	{1, 0x3E00, 0x80},
+	{1, 0x3E01, 0x00},
+	{1, 0x3E02, 0xC0},
+	{1, 0x3E03, 0x86},
+	{1, 0x3E04, 0x42},
+	{1, 0x3E05, 0x82},
+	{1, 0x3E06, 0x10},
+	{1, 0x3E07, 0x30},
+	{1, 0x3E08, 0x9C},
+	{1, 0x3E09, 0x5C},
+	{1, 0x3E0A, 0x80},
+	{1, 0x3E0B, 0x6E},
+	{1, 0x3E0C, 0x86},
+	{1, 0x3E0D, 0x5B},
+	{1, 0x3E0E, 0x80},
+	{1, 0x3E0F, 0x63},
+	{1, 0x3E10, 0x9E},
+	{1, 0x3E11, 0x59},
+	{1, 0x3E12, 0x8C},
+	{1, 0x3E13, 0x5E},
+	{1, 0x3E14, 0x8A},
+	{1, 0x3E15, 0x6C},
+	{1, 0x3E16, 0x80},
+	{1, 0x3E17, 0x6D},
+	{1, 0x3E18, 0x81},
+	{1, 0x3E19, 0x5F},
+	{1, 0x3E1A, 0x60},
+	{1, 0x3E1B, 0x61},
+	{1, 0x3E1C, 0x88},
+	{1, 0x3E1D, 0x10},
+	{1, 0x3E1E, 0x30},
+	{1, 0x3E1F, 0x66},
+	{1, 0x3E20, 0x83},
+	{1, 0x3E21, 0x6E},
+	{1, 0x3E22, 0x80},
+	{1, 0x3E23, 0x64},
+	{1, 0x3E24, 0x87},
+	{1, 0x3E25, 0x64},
+	{1, 0x3E26, 0x30},
+	{1, 0x3E27, 0x50},
+	{1, 0x3E28, 0xD3},
+	{1, 0x3E29, 0x6A},
+	{1, 0x3E2A, 0x6B},
+	{1, 0x3E2B, 0xAD},
+	{1, 0x3E2C, 0x30},
+	{1, 0x3E2D, 0x94},
+	{1, 0x3E2E, 0x67},
+	{1, 0x3E2F, 0x84},
+	{1, 0x3E30, 0x65},
+	{1, 0x3E31, 0x82},
+	{1, 0x3E32, 0x4D},
+	{1, 0x3E33, 0x83},
+	{1, 0x3E34, 0x65},
+	{1, 0x3E35, 0x30},
+	{1, 0x3E36, 0x50},
+	{1, 0x3E37, 0xA7},
+	{1, 0x3E38, 0x43},
+	{1, 0x3E39, 0x06},
+	{1, 0x3E3A, 0x00},
+	{1, 0x3E3B, 0x8D},
+	{1, 0x3E3C, 0x45},
+	{1, 0x3E3D, 0x9A},
+	{1, 0x3E3E, 0x6A},
+	{1, 0x3E3F, 0x6B},
+	{1, 0x3E40, 0x45},
+	{1, 0x3E41, 0x85},
+	{1, 0x3E42, 0x06},
+	{1, 0x3E43, 0x00},
+	{1, 0x3E44, 0x81},
+	{1, 0x3E45, 0x43},
+	{1, 0x3E46, 0x8A},
+	{1, 0x3E47, 0x6F},
+	{1, 0x3E48, 0x96},
+	{1, 0x3E49, 0x30},
+	{1, 0x3E4A, 0x90},
+	{1, 0x3E4B, 0x67},
+	{1, 0x3E4C, 0x64},
+	{1, 0x3E4D, 0x88},
+	{1, 0x3E4E, 0x64},
+	{1, 0x3E4F, 0x80},
+	{1, 0x3E50, 0x65},
+	{1, 0x3E51, 0x82},
+	{1, 0x3E52, 0x10},
+	{1, 0x3E53, 0xC0},
+	{1, 0x3E54, 0x84},
+	{1, 0x3E55, 0x65},
+	{1, 0x3E56, 0xEF},
+	{1, 0x3E57, 0x10},
+	{1, 0x3E58, 0xC0},
+	{1, 0x3E59, 0x66},
+	{1, 0x3E5A, 0x85},
+	{1, 0x3E5B, 0x64},
+	{1, 0x3E5C, 0x81},
+	{1, 0x3E5D, 0x17},
+	{1, 0x3E5E, 0x00},
+	{1, 0x3E5F, 0x80},
+	{1, 0x3E60, 0x20},
+	{1, 0x3E61, 0x0D},
+	{1, 0x3E62, 0x80},
+	{1, 0x3E63, 0x18},
+	{1, 0x3E64, 0x0C},
+	{1, 0x3E65, 0x80},
+	{1, 0x3E66, 0x64},
+	{1, 0x3E67, 0x30},
+	{1, 0x3E68, 0x60},
+	{1, 0x3E69, 0x41},
+	{1, 0x3E6A, 0x82},
+	{1, 0x3E6B, 0x42},
+	{1, 0x3E6C, 0xB2},
+	{1, 0x3E6D, 0x42},
+	{1, 0x3E6E, 0x80},
+	{1, 0x3E6F, 0x40},
+	{1, 0x3E70, 0x82},
+	{1, 0x3E71, 0x40},
+	{1, 0x3E72, 0x4C},
+	{1, 0x3E73, 0x45},
+	{1, 0x3E74, 0x92},
+	{1, 0x3E75, 0x6A},
+	{1, 0x3E76, 0x6B},
+	{1, 0x3E77, 0x9B},
+	{1, 0x3E78, 0x45},
+	{1, 0x3E79, 0x81},
+	{1, 0x3E7A, 0x4C},
+	{1, 0x3E7B, 0x40},
+	{1, 0x3E7C, 0x8C},
+	{1, 0x3E7D, 0x30},
+	{1, 0x3E7E, 0xA4},
+	{1, 0x3E7F, 0x67},
+	{1, 0x3E80, 0x85},
+	{1, 0x3E81, 0x65},
+	{1, 0x3E82, 0x87},
+	{1, 0x3E83, 0x65},
+	{1, 0x3E84, 0x30},
+	{1, 0x3E85, 0x60},
+	{1, 0x3E86, 0xD3},
+	{1, 0x3E87, 0x6A},
+	{1, 0x3E88, 0x6B},
+	{1, 0x3E89, 0xAC},
+	{1, 0x3E8A, 0x6C},
+	{1, 0x3E8B, 0x32},
+	{1, 0x3E8C, 0xA8},
+	{1, 0x3E8D, 0x80},
+	{1, 0x3E8E, 0x28},
+	{1, 0x3E8F, 0x30},
+	{1, 0x3E90, 0x70},
+	{1, 0x3E91, 0x00},
+	{1, 0x3E92, 0x80},
+	{1, 0x3E93, 0x40},
+	{1, 0x3E94, 0x4C},
+	{1, 0x3E95, 0xBD},
+	{1, 0x3E96, 0x00},
+	{1, 0x3E97, 0x0E},
+	{1, 0x3E98, 0xBE},
+	{1, 0x3E99, 0x44},
+	{1, 0x3E9A, 0x88},
+	{1, 0x3E9B, 0x44},
+	{1, 0x3E9C, 0xBC},
+	{1, 0x3E9D, 0x78},
+	{1, 0x3E9E, 0x09},
+	{1, 0x3E9F, 0x00},
+	{1, 0x3EA0, 0x89},
+	{1, 0x3EA1, 0x04},
+	{1, 0x3EA2, 0x80},
+	{1, 0x3EA3, 0x80},
+	{1, 0x3EA4, 0x02},
+	{1, 0x3EA5, 0x40},
+	{1, 0x3EA6, 0x86},
+	{1, 0x3EA7, 0x09},
+	{1, 0x3EA8, 0x00},
+	{1, 0x3EA9, 0x8E},
+	{1, 0x3EAA, 0x09},
+	{1, 0x3EAB, 0x00},
+	{1, 0x3EAC, 0x80},
+	{1, 0x3EAD, 0x02},
+	{1, 0x3EAE, 0x40},
+	{1, 0x3EAF, 0x80},
+	{1, 0x3EB0, 0x04},
+	{1, 0x3EB1, 0x80},
+	{1, 0x3EB2, 0x88},
+	{1, 0x3EB3, 0x7D},
+	{1, 0x3EB4, 0xA0},
+	{1, 0x3EB5, 0x86},
+	{1, 0x3EB6, 0x09},
+	{1, 0x3EB7, 0x00},
+	{1, 0x3EB8, 0x87},
+	{1, 0x3EB9, 0x7A},
+	{1, 0x3EBA, 0x00},
+	{1, 0x3EBB, 0x0E},
+	{1, 0x3EBC, 0xC3},
+	{1, 0x3EBD, 0x79},
+	{1, 0x3EBE, 0x4C},
+	{1, 0x3EBF, 0x40},
+	{1, 0x3EC0, 0xBF},
+	{1, 0x3EC1, 0x70},
+	{1, 0x3EC2, 0x00},
+	{1, 0x3EC3, 0x00},
+	{1, 0x3EC4, 0x00},
+	{1, 0x3EC5, 0x00},
+	{1, 0x3EC6, 0x00},
+	{1, 0x3EC7, 0x00},
+	{1, 0x3EC8, 0x00},
+	{1, 0x3EC9, 0x00},
+	{1, 0x3ECA, 0x00},
+	{1, 0x3ECB, 0x00},
+	{2, 0x0342, 0x138C}, 	// LINE_LENGTH_PCK
+	{2, 0x0340, 0x079D}, 	// FRAME_LENGTH_LINES
+	{2, 0x0202, 0x0700}, 	// COARSE_INTEGRATION_TIME
+	{2, 0x0344, 0x0008}, 	// X_ADDR_START
+	{2, 0x0348, 0x0CC7}, 	// X_ADDR_END
+	{2, 0x0346, 0x0130}, 	// Y_ADDR_START
+	{2, 0x034A, 0x085B}, 	// Y_ADDR_END
+	{2, 0x034C, 0x0CC0}, 	// X_OUTPUT_SIZE
+	{2, 0x034E, 0x072C}, 	// Y_OUTPUT_SIZE
+	{2, 0x3040, 0x4041}, 	// READ_MODE
+	{2, 0x0400, 0x0000}, 	// SCALING_MODE
+	{2, 0x0402, 0x0000}, 	// SPATIAL_SAMPLING
+	{2, 0x0404, 0x0010}, 	// SCALE_M
+	{2, 0x0408, 0x1010}, 	// RESERVED_CONF_408
+	{2, 0x040A, 0x0210}, 	// RESERVED_CONF_40A
+	{2, 0x306E, 0x9080}, 	// DATA_PATH_SELECT
+	{2, 0x301A, 0x001C}, 	// RESET_REGISTER
+	{END_OF_SCRIPT, 0, 0},	
+};
+
+static resolution_param_t  prev_resolution_array[] = {
+	{
+		.frmsize			= {640, 480},
+		.active_frmsize		= {640, 480},
+		.active_fps			= 30,
+		.size_type			= SIZE_VGA_640X480,
+		.reg_script[0]		= AR0833_preview_VGA_script,
+		.reg_script[1]		= AR0833_VGA_script_mipi,
+	}, {
+		.frmsize			= {1280, 720},
+		.active_frmsize		= {1280, 720},
+		.active_fps			= 30,
+		.size_type			= SIZE_720P_1280X720,
+		.reg_script[0]		= AR0833_preview_720P_script,
+		.reg_script[1]		= AR0833_720P_script_mipi,
+	}, {
+		.frmsize			= {1280, 960},
+		.active_frmsize		= {1280, 720},
+		.active_fps			= 30,
+		.size_type			= SIZE_960P_1280X960,
+		.reg_script[0]		= AR0833_preview_960P_script,
+		.reg_script[1]		= AR0833_960P_script_mipi,
+	}, {
+		.frmsize			= {1920, 1080},
+		.active_frmsize		= {1920, 1080},
+		.active_fps			= 15,
+		.size_type			= SIZE_1080P_1920X1080,
+		.reg_script[0]		= AR0833_preview_1080P_script,
+		.reg_script[1]		= AR0833_1080P_script_mipi, //AR0833_1080P_script_mipi,
+	}
+};
+
+static resolution_param_t  debug_prev_resolution_array[] = {
+	{
+		.frmsize			= {640, 480},
+		.active_frmsize		= {640, 480},
+		.active_fps			= 30,
+		.size_type			= SIZE_VGA_640X480,
+		.reg_script[0]		= AR0833_preview_VGA_script,
+		.reg_script[1]		= AR0833_VGA_script_mipi,
+	}, {
+		.frmsize			= {1280, 720},
+		.active_frmsize		= {1280, 720},
+		.active_fps			= 30,
+		.size_type			= SIZE_720P_1280X720,
+		.reg_script[0]		= AR0833_preview_720P_script,
+		.reg_script[1]		= AR0833_720P_script_mipi,
+	}, {
+		.frmsize			= {1280, 960},
+		.active_frmsize		= {1280, 720},
+		.active_fps			= 30,
+		.size_type			= SIZE_960P_1280X960,
+		.reg_script[0]		= AR0833_preview_960P_script,
+		.reg_script[1]		= AR0833_960P_script_mipi,
+	}, {
+		.frmsize			= {1920, 1080},
+		.active_frmsize		= {1920, 1080},
+		.active_fps			= 15,
+		.size_type			= SIZE_1080P_1920X1080,
+		.reg_script[0]		= AR0833_preview_1080P_script,
+		.reg_script[1]		= AR0833_1080P_script_mipi, //AR0833_1080P_script_mipi,
+	}, {
+		.frmsize			= {3264, 1836},
+		.active_frmsize		= {3264, 1836},
+		.active_fps			= 15,
+		.size_type			= SIZE_6M_3264X1836,
+		.reg_script[0]		= AR0833_preview_6M_script,
+		.reg_script[1]		= AR0833_6M_script_mipi, //AR0833_1080P_script_mipi,
+	}, {
+		.frmsize			= {3264, 2448},
+		.active_frmsize		= {3264, 2448},
+		.active_fps			= 15,
+		.size_type			= SIZE_8M_3264X2448,
+		.reg_script[0]		= AR0833_preview_8M_script,
+		.reg_script[1]		= AR0833_8M_script_mipi, //AR0833_1080P_script_mipi,
+	}
+};
+
+static resolution_param_t  capture_resolution_array[] = {
+	{
+		.frmsize			= {2592, 1944},
+		.active_frmsize		= {2592, 1944},
+		.active_fps			= 7.5,
+		.size_type			= SIZE_H1080P_2592X1944,
+		.reg_script[0]		= AR0833_capture_8M_script,
+		.reg_script[1]		= AR0833_8M_script_mipi,
+	},
+};
+
+
+static void parse_param(const char *buf,char **parm){
+	char *buf_orig, *ps, *token;
+	unsigned int n=0;
+
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	ps = buf_orig;
+	while(1) {
+	        token = strsep(&ps, " \n");
+	        if (token == NULL)
+	                break;
+	        if (*token == '\0')
+	                continue;
+	        parm[n++] = token;
+	        printk("%s\n",parm[n-1]);
+	}
+	//kfree(buf_orig);
+}
+
+extern int aml_i2c_put_word(struct i2c_adapter *adapter, 
+		unsigned short dev_addr, unsigned short addr, unsigned short data);
+
+void AR0833_manual_set_aet(unsigned int exp,unsigned int ag,unsigned int vts){
+	unsigned char exp_h = 0, exp_m = 0, exp_l = 0, ag_h = 0, ag_l = 0, vts_h = 0, vts_l = 0;
+	struct i2c_adapter *adapter;
+	adapter = i2c_get_adapter(4);
+	
+	aml_i2c_put_word(adapter, 0x36, 0x3012, exp & 0xffff);
+	
+	//aml_i2c_put_word(adapter, 0x36, 0x0204, ag & 0xffff);
+	
+	aml_i2c_put_word(adapter, 0x36, 0x0340, vts & 0xffff);	
+}
+
+static ssize_t aet_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char *param[3] = {NULL};
+	unsigned int exp = 0, ag = 0, vts = 0;
+	parse_param(buf,&param[0]);
+	
+	if(param[0] == NULL || param[1] == NULL || param[2] == NULL){
+		printk("wrong param\n");
+		return len;	
+	}	
+	sscanf(param[0],"%x",&exp);
+	sscanf(param[1],"%x",&ag);
+	sscanf(param[2],"%x",&vts);
+	
+	AR0833_manual_set_aet(exp,ag,vts);
+	return len;
+}
+
+static ssize_t aet_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	return len;
+}
+
+static CLASS_ATTR(aet_debug, 0664, aet_manual_show, aet_manual_store);
+
+/* ar0833 uses exp+ag mode */
+static bool AR0833_set_aet_new_step(unsigned int new_step, bool exp_mode, bool ag_mode){
+  unsigned int exp = 0, ag = 0, vts = 0;
+
+  if ((!exp_mode) || (!ag_mode) || (new_step > sensor_aet_info[current_fmt].tbl_max_step))
+		return(false);
+	else
+	{
+		sensor_aet_step = new_step;
+		exp = sensor_aet_table[sensor_aet_step].exp;
+		ag = sensor_aet_table[sensor_aet_step].ag;
+		vts = sensor_aet_table[sensor_aet_step].vts;
+		
+		AR0833_manual_set_aet(exp,ag,vts);
+		return true;
+	}
+}
+
+
+static bool AR0833_check_mains_freq(void){// when the fr change,we need to change the aet table
+    int detection; 
+    struct i2c_adapter *adapter;
+#if 0		
+    if(exp_mode != 2)//if current is not auto mode ,return
+        return false;
+
+    detection = my_i2c_get_byte(adapter,0x36,0x3c0c) & 1;
+    if(current_fr != detection){
+        change_cnt++;
+        if(change_cnt > 5){
+            aet_index ^= 1;
+            sensor_aet_info = cf->aet.aet[aet_index].info;
+            sensor_aet_table = cf->aet.aet[aet_index].aet_table;
+            sensor_aet_step = sensor_aet_info->tbl_rated_step;
+            change_cnt = 0;
+            current_fr = detection;
+            return true;
+        }	
+    }else{
+        change_cnt = 0;	
+    }
+    return false;
+#endif
+    return true;
+}
+
+bool AR0833_set_af_new_step(unsigned int af_step){
+    struct i2c_adapter *adapter;
+    char buf[3];
+    if(af_step == last_af_step)
+        return true;
+	/*
+    diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
+    last_af_step = af_step;
+    if(diff < 256){
+        codes = 1;
+    }else if(diff < 512){
+        codes = 2;	
+    }else
+        codes = 3;
+    vcm_data |= (codes << 2); // bit[3:2]
+    vcm_data |= (last_af_step << 4);  // bit[4:13]
+    byte_h  = (vcm_data >> 8) & 0x000000ff;
+    byte_l  = (vcm_data >> 0) & 0x000000ff;
+*/	
+	last_af_step = af_step;
+    buf[0] = (af_step>>4)&0xff;
+    buf[1] = (af_step<<4)&0xff;
+    //adapter = i2c_get_adapter(4);
+   // my_i2c_put_byte_add8(adapter,0x0c,buf,2);
+    return true;
+
+}
+
+
+
+void AR0833_set_new_format(int width,int height,int fr){
+    int index = 0;
+    current_fr = fr;
+    printk("sum:%d,mode:%d,fr:%d\n",cf->aet.sum,ar0833_work_mode,fr);
+    while(index < cf->aet.sum){
+        if(width == cf->aet.aet[index].info->fmt_hactive && height == cf->aet.aet[index].info->fmt_vactive \
+                && fr == cf->aet.aet[index].info->fmt_main_fr && ar0833_work_mode == cf->aet.aet[index].info->fmt_capture){
+            break;	
+        }
+        index++;	
+    }
+    if(index >= cf->aet.sum){
+        printk("use default value\n");
+        index = 0;	
+    }
+    printk("current aet index :%d\n",index);
+    sensor_aet_info = cf->aet.aet[index].info;
+    sensor_aet_table = cf->aet.aet[index].aet_table;
+    sensor_aet_step = sensor_aet_info->tbl_rated_step;
+    AR0833_set_aet_new_step(sensor_aet_step,1,1);
+}
+
+
+
+void AR0833_ae_manual_set(char **param){
+	if(param[0] == NULL || param[1] == NULL || param[2] == NULL){
+		printk("wrong param\n");
+		return ;	
+	}	
+	sscanf(param[0],"%x",&g_ae_manual_exp);
+	sscanf(param[1],"%x",&g_ae_manual_ag);
+	sscanf(param[2],"%x",&g_ae_manual_vts);
+	
+	g_ae_manual_exp = (g_ae_manual_exp > 0x0000ffff) ? 0x0000ffff : g_ae_manual_exp;
+	g_ae_manual_ag = (g_ae_manual_ag > 0x000003ff) ? 0x000003ff : g_ae_manual_ag;
+	g_ae_manual_vts = (g_ae_manual_vts > 0x0000ffff) ? 0x0000ffff : g_ae_manual_vts;
+	
+	AR0833_manual_set_aet(g_ae_manual_exp,g_ae_manual_ag,g_ae_manual_vts);
+}           
+
+static ssize_t ae_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char *param[3] = {NULL};
+	parse_param(buf,&param[0]);
+	AR0833_ae_manual_set(&param[0]);
+	return len;
+}
+
+static ssize_t ae_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	printk("exp:%x,ag%x,vts:%x\n",g_ae_manual_exp,g_ae_manual_ag,g_ae_manual_vts);
+	return len;
+}
+
+static CLASS_ATTR(ae_debug, 0664, ae_manual_show, ae_manual_store);
+
+static ssize_t i2c_debug_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char cmd;
+	int addr,value;
+    int endaddr;
+	struct i2c_adapter *adapter;
+	char *param[3] = {NULL};
+
+	parse_param(buf,&param[0]);
+	sscanf(param[0],"%c",&cmd);
+	printk("cmd:%c\n",cmd);
+	adapter = i2c_get_adapter(4);
+    switch( cmd ){
+        case 'w':
+			sscanf(param[1],"%x",&addr);
+			sscanf(param[2],"%x",&value);
+			my_i2c_put_byte(adapter,0x36,addr,value);
+                break;
+        case 'r':
+			sscanf(param[1],"%x",&addr);
+			value = my_i2c_get_byte(adapter,0x36,addr);
+			printk("reg:%x,value:%x\n",addr,value);
+                break;
+        case 'd':
+			sscanf(param[1],"%x",&addr);
+			sscanf(param[2],"%x",&endaddr);
+                for( ;addr <= endaddr; addr++)
+                {
+                        value = my_i2c_get_byte(adapter,0x36,addr);
+                        printk("[0x%04x]=0x%08x\n",addr,value);
+                }
+                break;
+        default :
+                break;
+	}
+	
+	return len;
+}
+
+static ssize_t i2c_debug_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+
+	size_t len = 0;
+
+	return len;
+}
+
+static CLASS_ATTR(camera_debug, 0664, i2c_debug_show, i2c_debug_store);
+
+static void power_down_ar0833(struct ar0833_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//i2c_put_byte(client,0x0104, 0x00);
+	//i2c_put_byte(client,0x0100, 0x00);
+}
+
+
+static ssize_t vcm_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	struct i2c_adapter *adapter;
+	char buff[3];
+	unsigned int af_step = 0;
+	unsigned int diff = 0;
+	int codes,vcm_data;
+	unsigned char byte_h, byte_l;
+	sscanf(buf,"%d",&af_step);
+    if(af_step == last_af_step)
+        return len;
+    diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
+    last_af_step = af_step;
+    if(diff < 256){
+        codes = 1;
+    }else if(diff < 512){
+        codes = 2;	
+    }else
+        codes = 3;
+    vcm_data |= (codes << 2); // bit[3:2]
+    vcm_data |= (last_af_step << 4);  // bit[4:13]
+    printk("set vcm step :%x\n",vcm_data);   
+    byte_h  = (vcm_data >> 8) & 0x000000ff;
+    byte_l  = (vcm_data >> 0) & 0x000000ff;
+    buff[0] = byte_h;
+    buff[1] = byte_l;
+    /*adapter = i2c_get_adapter(4);
+    my_i2c_put_byte_add8(adapter,0x0c,buff,2);
+    */
+    return len;
+}
+
+static ssize_t vcm_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	struct i2c_adapter *adapter;
+	unsigned int af;
+	//adapter = i2c_get_adapter(4);
+	//af = my_i2c_get_word(adapter,0x0c);
+	printk("current vcm step :%x\n",af);
+	return len;
+}
+
+static CLASS_ATTR(vcm_debug, 0664, vcm_manual_show, vcm_manual_store);
+
+static ssize_t light_source_freq_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	int freq;
+	sscanf(buf,"%d",&freq);
+	current_fr = freq ? 1 : 0;
+	printk("set current light soure frequency :%d\n",freq);
+	return len;
+}
+
+static ssize_t light_source_freq_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+	printk("light source frequence :%d\n",current_fr);
+	return len;
+}
+
+static CLASS_ATTR(light_source_debug, 0664, light_source_freq_manual_show, light_source_freq_manual_store);
+
+
+void AR0833_init_regs(struct ar0833_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int i=0;
+	
+	while (1) {
+		if (AR0833_init_script[i].type == END_OF_SCRIPT) {
+			printk("success in initial AR0833.\n");
+			break;
+		}
+		if ((cam_i2c_send_msg(client, AR0833_init_script[i])) < 0) {
+			printk("fail in initial AR0833. \n");
+			return;
+		}
+		i++;
+	}
+	return;
+}
+
+static ssize_t version_info_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	return len;
+}
+
+static ssize_t version_info_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+	size_t len = 0;
+    if(cf->version_info_valid == 0)
+        printk("verion info envalid\n");
+    else{
+        printk("Date %s",cf->version.date);
+        printk("Module %s",cf->version.module);
+        printk("Version %s",cf->version.version);	
+    }
+    return len;
+}
+
+static CLASS_ATTR(version_debug, 0664, version_info_show, version_info_store);
+/*************************************************************************
+* FUNCTION
+*    AR0833_set_param_wb
+*
+* DESCRIPTION
+*    wb setting.
+*
+* PARAMETERS
+*    none
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+
+static wb_pair_t wb_pair[] = {
+    {CAM_WB_AUTO,"CAM_WB_AUTO"},
+    {CAM_WB_CLOUD,"CAM_WB_CLOUD"},
+    {CAM_WB_DAYLIGHT,"CAM_WB_DAYLIGHT"},
+    {CAM_WB_INCANDESCENCE,"CAM_WB_INCANDESCENCE"},
+    {CAM_WB_TUNGSTEN,"CAM_WB_TUNGSTEN"},
+    {CAM_WB_FLUORESCENT,"CAM_WB_FLUORESCENT"},
+    {CAM_WB_MANUAL,"CAM_WB_MANUAL"},
+    {CAM_WB_SHADE,"CAM_WB_SHADE"},
+    {CAM_WB_TWILIGHT,"CAM_WB_TWILIGHT"},
+    {CAM_WB_WARM_FLUORESCENT,"CAM_WB_WARM_FLUORESCENT"},
+};
+
+void AR0833_set_param_wb(struct ar0833_device *dev,enum  camera_wb_flip_e para)//white balance
+{
+    int index = 0;
+    int i = 0;
+    while(i < ARRAY_SIZE(wb_pair)){
+        if(wb_pair[i].wb == para){
+            break;
+        }else
+            i++;
+    }
+    if(i == ARRAY_SIZE(wb_pair)){
+        printk("not support\n");
+        return;
+    }
+    if(cf != NULL && cf->wb_valid == 1){
+        while(index < cf->wb.sum){
+            if(strcmp(wb_pair[i].name, cf->wb.wb[index].name) == 0){
+                break;	
+            }
+            index++;
+        }
+        if(index == cf->wb.sum){
+            printk("invalid wb value\n");
+            return;	
+        }
+        if(para == CAM_WB_AUTO){
+            printk("auto wb\n");
+            dev->cam_para->cam_command = CAM_COMMAND_AWB;
+        }else{
+            dev->cam_para->cam_command = CAM_COMMAND_MWB;
+            memcpy(dev->cam_para->xml_wb_manual->reg_map,cf->wb.wb[index].export,2*sizeof(int));
+        }
+        printk("set wb :%d\n",index);
+        dev->fe_arg.port = TVIN_PORT_ISP;
+        dev->fe_arg.index = 0;
+        dev->fe_arg.arg = (void *)(dev->cam_para);
+        dev->vops->tvin_fe_func(0,&dev->fe_arg);
+    }else{
+        return;	
+    }
+
+
+} /* AR0833_set_param_wb */
+/*************************************************************************
+ * FUNCTION
+ *    AR0833_set_param_exposure
+ *
+ * DESCRIPTION
+ *    exposure setting.
+ *
+ * PARAMETERS
+ *    none
+ *
+ * RETURNS
+ *    None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void AR0833_set_param_exposure(struct ar0833_device *dev,enum camera_exposure_e para)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    int value;
+    if(para == EXPOSURE_0_STEP){
+        dev->cam_para->cam_command = CAM_COMMAND_AE_ON;
+        dev->ae_on = true;
+    }else{
+        if(dev->ae_on == false){ // set ae on
+            dev->cam_para->cam_command = CAM_COMMAND_AE_ON;	
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            dev->ae_on = true;
+        }
+        value = para < 8 ? para : 7;
+        value = value > 0 ? value : 1;
+        value -= 4;
+        dev->cam_para->cam_command = CAM_COMMAND_SET_AE_LEVEL;
+        dev->cam_para->exposure_level = value;
+        printk("set manual exposure level:%d\n",value);
+    }
+    dev->fe_arg.port = TVIN_PORT_ISP;
+    dev->fe_arg.index = 0;
+    dev->fe_arg.arg = (void *)(dev->cam_para);
+    dev->vops->tvin_fe_func(0,&dev->fe_arg);	
+
+} /* ar0833_set_param_exposure */
+/*************************************************************************
+ * FUNCTION
+ *    AR0833_set_param_effect
+ *
+ * DESCRIPTION
+ *    effect setting.
+ *
+ * PARAMETERS
+ *    none
+ *
+ * RETURNS
+ *    None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static effect_pair_t effect_pair[] = {
+    {SPECIAL_EFFECT_NORMAL,"CAM_EFFECT_ENC_NORMAL"},
+    {SPECIAL_EFFECT_BW,NULL},
+    {SPECIAL_EFFECT_BLUISH,"CAM_EFFECT_ENC_SEPIABLUE"},
+    {SPECIAL_EFFECT_SEPIA,"CAM_EFFECT_ENC_SEPIA"},
+    {SPECIAL_EFFECT_REDDISH,NULL},
+    {SPECIAL_EFFECT_GREENISH,"CAM_EFFECT_ENC_SEPIAGREEN"},
+    {SPECIAL_EFFECT_NEGATIVE,"CAM_EFFECT_ENC_COLORINV"}
+};
+
+void AR0833_set_param_effect(struct ar0833_device *dev,enum camera_effect_flip_e para)
+{
+    int index = 0;
+    int i = 0;
+    while(i < ARRAY_SIZE(effect_pair)){
+        if(effect_pair[i].effect == para){
+            break;
+        }else
+            i++;
+    }
+    if(i == ARRAY_SIZE(effect_pair)){
+        printk("not support\n");
+        return;
+    }
+    if(cf != NULL && cf->effect_valid == 1){
+        while(index < cf->eff.sum){
+            if(strcmp(effect_pair[i].name, cf->eff.eff[index].name) == 0){
+                break;	
+            }
+            index++;
+        }
+        if(index == cf->eff.sum){
+            printk("invalid effect value\n");
+            return;	
+        }
+        dev->cam_para->cam_command = CAM_COMMAND_EFFECT;
+        memcpy(dev->cam_para->xml_effect_manual->csc.reg_map,cf->eff.eff[index].export,18*sizeof(unsigned int));
+
+        dev->fe_arg.port = TVIN_PORT_ISP;
+        dev->fe_arg.index = 0;
+        dev->fe_arg.arg = (void *)(dev->cam_para);
+        printk("call tvin fe func\n");
+        dev->vops->tvin_fe_func(0,&dev->fe_arg);
+        return;
+    } 
+
+} /* AR0833_set_param_effect */
+
+/*************************************************************************
+ * FUNCTION
+ *    AR0833_NightMode
+ *
+ * DESCRIPTION
+ *    This function night mode of AR0833.
+ *
+ * PARAMETERS
+ *    none
+ *
+ * RETURNS
+ *    None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void AR0833_set_night_mode(struct ar0833_device *dev,enum  camera_night_mode_flip_e enable)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    if (50) {
+        
+    }
+    else{
+       
+    }
+
+}   /* AR0833_NightMode */
+
+static void AR0833_set_param_banding(struct ar0833_device *dev,enum  camera_night_mode_flip_e banding)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    switch(banding){
+        case CAM_BANDING_60HZ:
+            printk("set banding 60Hz\n");
+            
+            break;
+        case CAM_BANDING_50HZ:
+            printk("set banding 50Hz\n");
+           
+            break;
+        default:
+            break;
+    }
+}
+
+
+static int AR0833_AutoFocus(struct ar0833_device *dev, int focus_mode)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    int ret = 0;
+
+    switch (focus_mode) {
+        case CAM_FOCUS_MODE_AUTO:       
+            printk("auto focus mode start\n");
+            bDoingAutoFocusMode = true;
+            dev->cam_para->cam_command = CAM_COMMAND_FULLSCAN;
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            if(dev->vops != NULL){
+                dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            }
+            break;
+
+        case CAM_FOCUS_MODE_CONTI_VID:
+        case CAM_FOCUS_MODE_CONTI_PIC:
+            printk("continus focus\n");
+            dev->cam_para->cam_command = CAM_COMMAND_CONTINUOUS_FOCUS_ON;
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            if(dev->vops != NULL){
+                dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            }
+            printk("start continous focus\n");
+            break;
+
+        case CAM_FOCUS_MODE_RELEASE:
+        case CAM_FOCUS_MODE_FIXED:
+            printk("continus focus\n");
+            dev->cam_para->cam_command = CAM_COMMAND_CONTINUOUS_FOCUS_OFF;
+            dev->fe_arg.port = TVIN_PORT_ISP;
+            dev->fe_arg.index = 0;
+            dev->fe_arg.arg = (void *)(dev->cam_para);
+            if(dev->vops != NULL){
+                dev->vops->tvin_fe_func(0,&dev->fe_arg);
+            }
+            printk("focus release\n");
+            break;
+        default:
+            
+            printk("release focus to infinit\n");
+            break;
+    }
+    return ret;
+
+}
+
+static int set_flip(struct ar0833_device *dev)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    unsigned char temp;
+    temp = i2c_get_byte(client, 0x0101);
+    temp &= 0xfc;
+    temp |= dev->cam_info.m_flip << 0;
+    temp |= dev->cam_info.v_flip << 1;
+    //printk("dst temp is 0x%x\n", temp);
+    /*if((i2c_put_byte(client, 0x0101, temp)) < 0) {
+        printk("fail in setting sensor orientation \n");
+        return -1;
+    }*/
+}
+
+
+static resulution_size_type_t get_size_type(int width, int height)
+{
+    resulution_size_type_t rv = SIZE_NULL_TYPE;
+    if (width * height >= 2500 * 1900)
+        rv = SIZE_H1080P_2592X1944;
+    else if (width * height >= 1900 * 1000)
+        rv = SIZE_1080P_1920X1080;
+    else if (width * height >= 1200 * 900)
+        rv = SIZE_960P_1280X960;
+    else if (width * height >= 1200 * 700)
+        rv = SIZE_720P_1280X720;
+    else if (width * height >= 600 * 400)
+        rv = SIZE_VGA_640X480;
+    return rv;
+}
+
+static int AR0833_FlashCtrl(struct ar0833_device *dev, int flash_mode)
+{
+    switch (flash_mode) {
+        case FLASHLIGHT_ON:
+        case FLASHLIGHT_AUTO:
+        case FLASHLIGHT_OFF:
+            dev->cam_para->cam_command = CAM_COMMAND_SET_FLASH_MODE;
+            dev->cam_para->flash_mode = flash_mode;
+            break;
+        case FLASHLIGHT_TORCH:
+            dev->cam_para->cam_command = CAM_COMMAND_TORCH;
+            dev->cam_para->level = 100;
+            break;
+        default:
+            printk("this flash mode not support yet\n");
+            return -1;
+    }
+    dev->fe_arg.port = TVIN_PORT_ISP;
+    dev->fe_arg.index = 0;
+    dev->fe_arg.arg = (void *)(dev->cam_para);
+    if(dev->vops != NULL){
+        dev->vops->tvin_fe_func(0,&dev->fe_arg);
+    }
+    return 0;
+}
+
+static resolution_param_t* get_resolution_param(struct ar0833_device *dev, int is_capture, int width, int height)
+{
+    int i = 0;
+    int arry_size = 0;
+    resolution_param_t* tmp_resolution_param = NULL;
+    resulution_size_type_t res_type = SIZE_NULL_TYPE;
+    printk("target resolution is %dX%d\n", width, height);
+    res_type = get_size_type(width, height);
+    if (res_type == SIZE_NULL_TYPE)
+        return NULL;
+    if (ar0833_work_mode == CAMERA_CAPTURE) {
+        tmp_resolution_param = capture_resolution_array;
+        arry_size = ARRAY_SIZE(capture_resolution_array);
+    } else {
+        tmp_resolution_param = debug_prev_resolution_array;
+        arry_size = ARRAY_SIZE(debug_prev_resolution_array);
+    }
+    for (i = 0; i < arry_size; i++) {
+        if (tmp_resolution_param[i].size_type == res_type)
+            return &tmp_resolution_param[i];
+    }
+    return NULL;
+}
+
+static char *res_size[]={
+	"480p",
+	"720p",
+	"960p",
+	"1080p",
+	"6m",
+	"8m"
+};
+
+static void set_resolution_param(struct ar0833_device *dev, resolution_param_t* res_param)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    int rc = -1;
+    int i=0;
+    unsigned char t = dev->cam_info.interface;
+    printk("%s, %d, interface =%d\n" , __func__, __LINE__, t);
+
+	if(i_index != -1 && ar0833_work_mode != CAMERA_CAPTURE){
+        res_param = &debug_prev_resolution_array[i_index];
+    }
+    if (!res_param->reg_script[t]) {
+        printk("error, resolution reg script is NULL\n");
+        return;
+    }
+    while(1){
+        if (res_param->reg_script[t][i].type == END_OF_SCRIPT) {
+            printk("setting resolutin param complete\n");
+            break;
+        }
+        if((cam_i2c_send_msg(client, res_param->reg_script[t][i])) < 0) {
+            printk("fail in setting resolution param. i=%d\n",i);
+            break;
+        }
+        i++;
+    }
+    ar0833_frmintervals_active.numerator = 1;
+    ar0833_frmintervals_active.denominator = res_param->active_fps;
+    ar0833_h_active = res_param->frmsize.width;
+    ar0833_v_active = res_param->frmsize.height;
+    AR0833_set_new_format(ar0833_h_active,ar0833_v_active,current_fr);// should set new para
+}    /* AR0833_set_resolution */
+
+static int set_focus_zone(struct ar0833_device *dev, int value)
+{
+	int xc, yc, tx, ty;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int retry_count = 10;
+	int ret = -1;
+	
+	xc = (value >> 16) & 0xffff;
+	yc = (value & 0xffff);
+	if(xc == 1000 && yc == 1000)
+		return 0;
+	tx = xc * ar0833_h_active /2000;
+	ty = yc * ar0833_v_active /2000;
+	printk("xc = %d, yc = %d, tx = %d , ty = %d \n", xc, yc, tx, ty);
+	
+	dev->cam_para->xml_scenes->af.x = tx;
+	dev->cam_para->xml_scenes->af.y = ty;	
+	dev->cam_para->cam_command = CAM_COMMAND_TOUCH_FOCUS;
+	dev->fe_arg.port = TVIN_PORT_ISP;
+	dev->fe_arg.index = 0;
+	dev->fe_arg.arg = (void *)(dev->cam_para);
+	if(dev->vops != NULL){
+	  dev->vops->tvin_fe_func(0,&dev->fe_arg);
+	}
+	return 0;
+}
+
+unsigned char v4l_2_ar0833(int val)
+{
+	int ret=val/0x20;
+	if(ret<4) return ret*0x20+0x80;
+	else if(ret<8) return ret*0x20+0x20;
+	else return 0;
+}
+
+static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_canvas)
+{
+	int canvas = start_canvas;
+
+	switch(v4l2_format){
+	case V4L2_PIX_FMT_RGB565X:
+	case V4L2_PIX_FMT_VYUY:
+		canvas = start_canvas;
+		break;
+	case V4L2_PIX_FMT_YUV444:
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB24:
+		canvas = start_canvas;
+		break; 
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21: 
+		canvas = start_canvas | ((start_canvas+1)<<8);
+		break;
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV420:
+		if(V4L2_PIX_FMT_YUV420 == v4l2_format){
+			canvas = start_canvas|((start_canvas+1)<<8)|((start_canvas+2)<<16);
+		}else{
+			canvas = start_canvas|((start_canvas+2)<<8)|((start_canvas+1)<<16);
+		}
+		break;
+	default:
+		break;
+	}
+	return canvas;
+}
+
+static int ar0833_setting(struct ar0833_device *dev,int PROP_ID,int value )
+{
+	int ret=0;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct ar0833_fh *fh = to_fh(dev);
+	switch(PROP_ID)  {
+	case V4L2_CID_BRIGHTNESS:
+		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_ar0833(value));
+		//ret=i2c_put_byte(client,0x0201,v4l_2_ar0833(value));
+		break;
+	case V4L2_CID_CONTRAST:
+		break;
+	case V4L2_CID_SATURATION:
+		break;
+	case V4L2_CID_HFLIP:    /* set flip on H. */
+		value = value & 0x1;
+		if(ar0833_qctrl[2].default_value!=value){
+			 ar0833_qctrl[2].default_value=value;
+			printk(" set camera  h filp =%d. \n ",value);
+			value = value << 1; //bit[1]
+			//ret=i2c_put_byte(client,0x3821, value);
+			break;
+		}
+		break;
+	case V4L2_CID_VFLIP:    /* set flip on V. */
+		break;
+	case V4L2_CID_DO_WHITE_BALANCE:
+		if(ar0833_qctrl[4].default_value!=value){
+			ar0833_qctrl[4].default_value=value;
+			if(fh->stream_on)
+			AR0833_set_param_wb(dev,value);
+			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_EXPOSURE:
+		if(ar0833_qctrl[5].default_value!=value){
+			ar0833_qctrl[5].default_value=value;
+			if(fh->stream_on)
+				AR0833_set_param_exposure(dev,value);
+			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_BACKLIGHT_COMPENSATION:
+        if(ar0833_qctrl[9].default_value!=value){
+			ar0833_qctrl[9].default_value=value;
+            ret = AR0833_FlashCtrl(dev,value);
+			printk(KERN_INFO " set light compensation =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_COLORFX:
+		if(ar0833_qctrl[6].default_value!=value){
+			ar0833_qctrl[6].default_value=value;
+			if(fh->stream_on)
+				AR0833_set_param_effect(dev,value);
+		}
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		if(ar0833_qctrl[3].default_value!=value){
+			ar0833_qctrl[3].default_value=value;
+			AR0833_set_param_banding(dev,value);
+			printk(KERN_INFO " set camera  banding=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		if(ar0833_qctrl[10].default_value!=value){
+			ar0833_qctrl[10].default_value=value;
+			printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_ROTATE:
+		if(ar0833_qctrl[11].default_value!=value){
+			ar0833_qctrl[11].default_value=value;
+			printk(" set camera  rotate =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		printk("V4L2_CID_FOCUS_ABSOLUTE\n");
+		if(ar0833_qctrl[13].default_value!=value){
+			ar0833_qctrl[13].default_value=value;
+			printk(" set camera  focus zone =%d. \n ",value);
+			set_focus_zone(dev, value);
+		}
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		printk("V4L2_CID_FOCUS_AUTO\n");
+		if(ar0833_qctrl[8].default_value!=value){
+			ar0833_qctrl[8].default_value=value;
+			if(fh->stream_on)
+				AR0833_AutoFocus(dev,value);
+		}
+	case V4L2_CID_PRIVACY:       
+        break;
+	default:
+   		ret=-1;
+		break;
+	}
+	
+	return ret;
+
+}
+
+
+/* ------------------------------------------------------------------
+	DMA and thread functions
+   ------------------------------------------------------------------*/
+
+#define TSTAMP_MIN_Y	24
+#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X	10
+#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
+
+static void ar0833_fillbuff(struct ar0833_fh *fh, struct ar0833_buffer *buf)
+{
+	struct ar0833_device *dev = fh->dev;
+	//void *vbuf = videobuf_to_vmalloc(&buf->vb);
+	void *vbuf = (void *)videobuf_to_res(&buf->vb);
+	vm_output_para_t para = {0};
+	dprintk(dev,1,"%s\n", __func__);
+	if (!vbuf)
+		return;
+	/*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
+	if(buf->canvas_id == 0)
+		buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, AR0833_RES0_CANVAS_INDEX+buf->vb.i*3);
+	para.mirror = ar0833_qctrl[2].default_value&3;// not set
+	para.v4l2_format = fh->fmt->fourcc;
+	para.v4l2_memory = MAGIC_RE_MEM;//0x18221223;
+	para.zoom = ar0833_qctrl[10].default_value;
+	para.angle = ar0833_qctrl[11].default_value;
+	para.vaddr = (unsigned)vbuf;
+	para.ext_canvas = buf->canvas_id;
+	para.width = buf->vb.width;
+	para.height = buf->vb.height;
+	vm_fill_buffer(&buf->vb,&para);
+	buf->vb.state = VIDEOBUF_DONE;
+}
+
+static void ar0833_thread_tick(struct ar0833_fh *fh)
+{
+	struct ar0833_buffer *buf;
+	struct ar0833_device *dev = fh->dev;
+	struct ar0833_dmaqueue *dma_q = &dev->vidq;
+
+	unsigned long flags = 0;
+
+	dprintk(dev, 1, "Thread tick\n");
+	if(!fh->stream_on){
+		dprintk(dev, 1, "sensor doesn't stream on\n");
+		return ;
+	}
+
+	spin_lock_irqsave(&dev->slock, flags);
+	if (list_empty(&dma_q->active)) {
+		dprintk(dev, 1, "No active queue to serve\n");
+		goto unlock;
+	}
+
+    buf = list_entry(dma_q->active.next,
+            struct ar0833_buffer, vb.queue);
+    dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
+
+    if(!(fh->f_flags & O_NONBLOCK)){
+        /* Nobody is waiting on this buffer, return */
+        if (!waitqueue_active(&buf->vb.done))
+            goto unlock;
+    }
+    buf->vb.state = VIDEOBUF_ACTIVE;
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+
+	/* Fill buffer */
+	spin_unlock_irqrestore(&dev->slock, flags);
+	ar0833_fillbuff(fh, buf);
+	dprintk(dev, 1, "filled buffer %p\n", buf);
+
+	wake_up(&buf->vb.done);
+	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+	return;
+unlock:
+	spin_unlock_irqrestore(&dev->slock, flags);
+	return;
+}
+
+#define frames_to_ms(frames)					\
+	((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+
+static void ar0833_sleep(struct ar0833_fh *fh)
+{
+	struct ar0833_device *dev = fh->dev;
+	struct ar0833_dmaqueue *dma_q = &dev->vidq;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
+		(unsigned long)dma_q);
+
+	add_wait_queue(&dma_q->wq, &wait);
+	if (kthread_should_stop())
+		goto stop_task;
+
+	/* Calculate time to wake up */
+	//timeout = msecs_to_jiffies(frames_to_ms(1));
+
+	ar0833_thread_tick(fh);
+
+	schedule_timeout_interruptible(1);//if fps > 25 , 2->1
+
+stop_task:
+	remove_wait_queue(&dma_q->wq, &wait);
+	try_to_freeze();
+}
+
+static int ar0833_thread(void *data)
+{
+	struct ar0833_fh  *fh = data;
+	struct ar0833_device *dev = fh->dev;
+
+	dprintk(dev, 1, "thread started\n");
+
+	set_freezable();
+
+	for (;;) {
+		ar0833_sleep(fh);
+
+		if (kthread_should_stop())
+			break;
+	}
+	dprintk(dev, 1, "thread: exit\n");
+	return 0;
+}
+
+static int ar0833_start_thread(struct ar0833_fh *fh)
+{
+	struct ar0833_device *dev = fh->dev;
+	struct ar0833_dmaqueue *dma_q = &dev->vidq;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	dma_q->kthread = kthread_run(ar0833_thread, fh, "ar0833");
+
+	if (IS_ERR(dma_q->kthread)) {
+		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+		return PTR_ERR(dma_q->kthread);
+	}
+	/* Wakes thread */
+	wake_up_interruptible(&dma_q->wq);
+
+	dprintk(dev, 1, "returning from %s\n", __func__);
+	return 0;
+}
+
+static void ar0833_stop_thread(struct ar0833_dmaqueue  *dma_q)
+{
+	struct ar0833_device *dev = container_of(dma_q, struct ar0833_device, vidq);
+
+	dprintk(dev, 1, "%s\n", __func__);
+	/* shutdown control thread */
+	if (dma_q->kthread) {
+		kthread_stop(dma_q->kthread);
+		dma_q->kthread = NULL;
+	}
+}
+
+/* ------------------------------------------------------------------
+	Videobuf operations
+   ------------------------------------------------------------------*/
+static int
+buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0833_fh *fh  = container_of(res, struct ar0833_fh, res);
+	struct ar0833_device *dev  = fh->dev;
+    //int bytes = fh->fmt->depth >> 3 ;
+	int height = fh->height;
+	if(height==1080)
+		height = 1088;
+	*size = (fh->width*height*fh->fmt->depth)>>3;  
+	if (0 == *count)
+		*count = 32;
+
+	while (*size * *count > vid_limit * 1024 * 1024)
+		(*count)--;
+
+	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+		*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct ar0833_buffer *buf)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0833_fh *fh  = container_of(res, struct ar0833_fh, res);
+	struct ar0833_device *dev  = fh->dev;
+
+	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+
+	videobuf_waiton(vq, &buf->vb, 0, 0);
+	if (in_interrupt())
+		BUG();
+
+	videobuf_res_free(vq, &buf->vb);
+	dprintk(dev, 1, "free_buffer: freed\n");
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+#define norm_maxw() 4000
+#define norm_maxh() 3000
+static int
+buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						enum v4l2_field field)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0833_fh *fh  = container_of(res, struct ar0833_fh, res);
+	struct ar0833_device    *dev = fh->dev;
+	struct ar0833_buffer *buf = container_of(vb, struct ar0833_buffer, vb);
+	int rc;
+    //int bytes = fh->fmt->depth >> 3 ;
+	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+
+	BUG_ON(NULL == fh->fmt);
+
+	if (fh->width  < 48 || fh->width  > norm_maxw() ||
+	    fh->height < 32 || fh->height > norm_maxh())
+		return -EINVAL;
+
+	buf->vb.size = (fh->width*fh->height*fh->fmt->depth)>>3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+		return -EINVAL;
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = fh->fmt;
+	buf->vb.width  = fh->width;
+	buf->vb.height = fh->height;
+	buf->vb.field  = field;
+
+	//precalculate_bars(fh);
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0)
+			goto fail;
+	}
+
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void
+buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct ar0833_buffer    *buf  = container_of(vb, struct ar0833_buffer, vb);
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0833_fh *fh  = container_of(res, struct ar0833_fh, res);
+	struct ar0833_device       *dev  = fh->dev;
+	struct ar0833_dmaqueue *vidq = &dev->vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct ar0833_buffer   *buf  = container_of(vb, struct ar0833_buffer, vb);
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct ar0833_fh *fh  = container_of(res, struct ar0833_fh, res);
+	struct ar0833_device      *dev  = (struct ar0833_device *)fh->dev;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops ar0833_video_qops = {
+	.buf_setup      = buffer_setup,
+	.buf_prepare    = buffer_prepare,
+	.buf_queue      = buffer_queue,
+	.buf_release    = buffer_release,
+};
+
+/* ------------------------------------------------------------------
+	IOCTL vidioc handling
+   ------------------------------------------------------------------*/
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct ar0833_fh  *fh  = priv;
+	struct ar0833_device *dev = fh->dev;
+
+	strcpy(cap->driver, "ar0833");
+	strcpy(cap->card, "ar0833.canvas");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+	cap->version = AR0833_CAMERA_VERSION;
+	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
+				V4L2_CAP_STREAMING     |
+				V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct ar0833_fmt *fmt;
+
+	if (f->index >= ARRAY_SIZE(formats))
+		return -EINVAL;
+
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_enum_frameintervals(struct file *file, void *priv,
+        struct v4l2_frmivalenum *fival)
+{
+    unsigned int k;
+
+    if(fival->index > ARRAY_SIZE(ar0833_frmivalenum))
+        return -EINVAL;
+
+    for(k =0; k< ARRAY_SIZE(ar0833_frmivalenum); k++)
+    {
+        if( (fival->index==ar0833_frmivalenum[k].index)&&
+                (fival->pixel_format ==ar0833_frmivalenum[k].pixel_format )&&
+                (fival->width==ar0833_frmivalenum[k].width)&&
+                (fival->height==ar0833_frmivalenum[k].height)){
+            memcpy( fival, &ar0833_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
+            return 0;
+        }
+    }
+    return -EINVAL;
+
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct ar0833_fh *fh = priv;
+
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vb_vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+	return (0);
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct ar0833_fh  *fh  = priv;
+	struct ar0833_device *dev = fh->dev;
+	struct ar0833_fmt *fmt;
+	enum v4l2_field field;
+	unsigned int maxw, maxh;
+
+	fmt = get_format(f);
+	if (!fmt) {
+		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+			f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	field = f->fmt.pix.field;
+
+	if (field == V4L2_FIELD_ANY) {
+		field = V4L2_FIELD_INTERLACED;
+	} else if (V4L2_FIELD_INTERLACED != field) {
+		dprintk(dev, 1, "Field type invalid.\n");
+		return -EINVAL;
+	}
+
+	maxw  = norm_maxw();
+	maxh  = norm_maxh();
+
+	f->fmt.pix.field = field;
+	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
+			      &f->fmt.pix.height, 32, maxh, 0, 0);
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+	return 0;
+}
+
+/*FIXME: This seems to be generic enough to be at videodev2 */
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct ar0833_fh *fh = priv;
+	struct videobuf_queue *q = &fh->vb_vidq;
+	struct ar0833_device *dev = fh->dev;
+	resolution_param_t* res_param = NULL;
+	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	if (ret < 0)
+		return ret;
+	
+	mutex_lock(&q->vb_lock);
+
+	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	fh->fmt           = get_format(f);
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+    if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
+        ar0833_work_mode = CAMERA_CAPTURE;
+        res_param = get_resolution_param(dev, 1, fh->width,fh->height);
+        if (!res_param) {
+            printk("error, resolution param not get\n");
+            goto out;
+        }
+        set_resolution_param(dev, res_param);
+    }
+    else {
+    	printk("preview resolution is %dX%d\n",fh->width,  fh->height);
+        if((fh->width == 1280 && fh->height == 720) || 
+        	(fh->width == 1920 && fh->height == 1080)){
+        	ar0833_work_mode = CAMERA_RECORD;
+        }else
+        	ar0833_work_mode = CAMERA_PREVIEW;
+        res_param = get_resolution_param(dev, 0, fh->width,fh->height);
+        if (!res_param) {
+            printk("error, resolution param not get\n");
+            goto out;
+        }
+        set_resolution_param(dev, res_param);
+        /** set target ***/
+        if(t_index == -1){
+            dest_hactive = 0;
+            dest_vactive = 0;
+        }
+    }
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+        struct v4l2_streamparm *parms)
+{
+    struct ar0833_fh *fh = priv;
+    struct ar0833_device *dev = fh->dev;
+    struct v4l2_captureparm *cp = &parms->parm.capture;
+
+    dprintk(dev,3,"vidioc_g_parm\n");
+    if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+
+    memset(cp, 0, sizeof(struct v4l2_captureparm));
+    cp->capability = V4L2_CAP_TIMEPERFRAME;
+
+    cp->timeperframe = ar0833_frmintervals_active;
+    printk("g_parm,deno=%d, numerator=%d\n", cp->timeperframe.denominator,
+            cp->timeperframe.numerator );
+    return 0;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct ar0833_fh  *fh = priv;
+
+	return (videobuf_reqbufs(&fh->vb_vidq, p));
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct ar0833_fh  *fh = priv;
+
+	int ret = videobuf_querybuf(&fh->vb_vidq, p);
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+	if(ret == 0){
+		p->reserved  = convert_canvas_index(fh->fmt->fourcc, AR0833_RES0_CANVAS_INDEX+p->index*3);
+	}else{
+		p->reserved = 0;
+	}
+#endif		
+	return ret;
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct ar0833_fh *fh = priv;
+
+	return (videobuf_qbuf(&fh->vb_vidq, p));
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct ar0833_fh  *fh = priv;
+
+	return (videobuf_dqbuf(&fh->vb_vidq, p,
+				file->f_flags & O_NONBLOCK));
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct ar0833_fh  *fh = priv;
+
+	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
+}
+#endif
+#ifdef MIPI_INTERFACE
+static struct ar0833_fmt input_formats_vdin[] = 
+{
+    // vdin path format
+    {
+        .name     = "4:2:2, packed, UYVY",
+        .fourcc   = V4L2_PIX_FMT_UYVY,
+        .depth    = 16,
+    },
+    {
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV21,
+        .depth    = 12,
+    },
+    {
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV12,
+        .depth    = 12,
+    }
+};
+#endif
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct ar0833_fh  *fh = priv;
+	struct ar0833_device *dev = fh->dev;	
+	vdin_parm_t para;
+	int ret = 0 ;
+	
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+
+	memset( &para, 0, sizeof( para ));
+	//para.port  = TVIN_PORT_CAMERA;
+	
+	if (CAM_MIPI == dev->cam_info.interface) {
+	        para.isp_fe_port  = TVIN_PORT_MIPI;
+	} else {
+	        para.isp_fe_port  = TVIN_PORT_CAMERA;
+	}
+	para.port  = TVIN_PORT_ISP;    
+	para.fmt = TVIN_SIG_FMT_MAX;
+	para.frame_rate = ar0833_frmintervals_active.denominator;
+	para.h_active = ar0833_h_active;
+	para.v_active = ar0833_v_active;
+    if(ar0833_work_mode != CAMERA_CAPTURE){
+		para.skip_count = 2;
+        para.dest_hactive = dest_hactive;
+        para.dest_vactive = dest_vactive;
+    }else{
+        para.dest_hactive = 0;
+        para.dest_vactive = 0;
+    }
+    dev->cam_para->cam_mode = ar0833_work_mode;
+	para.hsync_phase = 1;
+	para.vsync_phase  = 1;
+	para.hs_bp = 0;
+	para.vs_bp = 2;
+	para.cfmt = TVIN_YUV422;
+	para.dfmt = TVIN_NV21;
+	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
+	para.bt_path = dev->cam_info.bt_path;
+	current_fmt = 0;
+	if(dev->cam_para == NULL)
+		return -EINVAL;
+	if(generate_para(dev->cam_para,dev->pindex) == 0){
+	    para.reserved = (int)(dev->cam_para);
+	}else{
+		free_para(dev->cam_para);
+		para.reserved = 0;
+	}
+	dev->cam_para->cam_function.set_aet_new_step = AR0833_set_aet_new_step;
+	dev->cam_para->cam_function.check_mains_freq = AR0833_check_mains_freq;
+	dev->cam_para->cam_function.set_af_new_step = AR0833_set_af_new_step;
+	dev->cam_para->cam_mode = CAMERA_PREVIEW;	
+	if (CAM_MIPI == dev->cam_info.interface)
+	{
+	        para.csi_hw_info.lanes = 2;
+	        para.csi_hw_info.channel = 1;
+	        para.csi_hw_info.mode = 1;
+	        para.csi_hw_info.clock_lane_mode = 1; // 0 clock gate 1: always on
+	        para.csi_hw_info.active_pixel = ar0833_h_active;
+	        para.csi_hw_info.active_line = ar0833_v_active;
+	        para.csi_hw_info.frame_size=0;
+	        para.csi_hw_info.ui_val = 2; //ns
+	        para.csi_hw_info.urgent = 1;
+	        para.csi_hw_info.clk_channel = dev->cam_info.clk_channel; //clock channel a or b
+	}
+	if(cf->aet_valid == 1){
+	    dev->cam_para->xml_scenes->ae.aet_fmt_gain = sensor_aet_info->format_transfer_parameter;        	
+	}else
+	    dev->cam_para->xml_scenes->ae.aet_fmt_gain = 0;
+	printk("aet_fmt_gain:%d\n",dev->cam_para->xml_scenes->ae.aet_fmt_gain);
+
+	printk("ar0833,h=%d, v=%d, frame_rate=%d\n", 
+	        ar0833_h_active, ar0833_v_active, ar0833_frmintervals_active.denominator);
+	ret =  videobuf_streamon(&fh->vb_vidq);
+	if(ret == 0){
+		dev->vops->start_tvin_service(0,&para);
+		fh->stream_on        = 1;
+	}
+	AR0833_set_param_wb(fh->dev,ar0833_qctrl[4].default_value);
+	AR0833_set_param_exposure(fh->dev,ar0833_qctrl[5].default_value);
+	AR0833_set_param_effect(fh->dev,ar0833_qctrl[6].default_value);
+
+	return ret;
+}
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct ar0833_fh  *fh = priv;
+	struct ar0833_device *dev = fh->dev;
+	int ret = 0 ;
+	printk(KERN_INFO " vidioc_streamoff+++ \n ");
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+	ret = videobuf_streamoff(&fh->vb_vidq);
+	if(ret == 0 ){
+        dev->vops->stop_tvin_service(0);
+        fh->stream_on        = 0;
+	}
+	return ret;
+}
+
+static int get_index(char *res){
+	int i = 0;
+	while(i < ARRAY_SIZE(res_size)){
+		if(strcmp(res_size[i],res) == 0){
+			break;
+		}
+		else
+			i++;	
+	}
+	if(i < ARRAY_SIZE(res_size)){
+		return i;	
+	}else
+		return -1;
+}
+
+static ssize_t manual_format_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
+{
+	char input[20];
+	char target[20];
+	char *param[3] = {NULL};
+	resolution_param_t *res_param;
+
+	
+	parse_param(buf,&param[0]);
+	if(param[0] == NULL || param[1] == NULL){
+		printk("wrong param\n");
+		return len;	
+	}
+	sscanf(param[0],"%s",input);
+	sscanf(param[1],"%s",target);
+	i_index = get_index(input);
+	t_index = get_index(target);
+	printk("i:%d,t:%x\n",i_index,t_index);
+	if(i_index < 0 || t_index <0){
+		printk("wrong res\n");
+		return len;
+	}
+	res_param = &debug_prev_resolution_array[t_index];	
+	dest_hactive = res_param->active_frmsize.width;
+    dest_vactive = res_param->active_frmsize.height;
+    printk("d_h:%d,d_v:%d\n",dest_hactive,dest_vactive);
+    return len;
+}
+
+static ssize_t manual_format_show(struct class *cls,struct class_attribute *attr, char* buf)
+{
+
+	size_t len = 0;
+	printk("current hactive :%d, v_active :%d, dest_hactive :%d, dest_vactive:%d\n",ar0833_h_active,ar0833_v_active,dest_hactive,dest_vactive);
+	return len;
+}
+static CLASS_ATTR(resolution_debug, 0664, manual_format_show,manual_format_store);
+
+static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsizeenum *fsize)
+{
+
+      int ret = 0,i=0;
+      struct ar0833_fmt *fmt = NULL;
+      struct v4l2_frmsize_discrete *frmsize = NULL;
+      for (i = 0; i < ARRAY_SIZE(formats); i++) {
+            if (formats[i].fourcc == fsize->pixel_format){
+                    fmt = &formats[i];
+                    break;
+            }
+      }
+      if (fmt == NULL)
+            return -EINVAL;
+      if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+                      ||(fmt->fourcc == V4L2_PIX_FMT_NV12)
+                      ||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
+                      ||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
+         ){
+              printk("ar0833_prev_resolution[fsize->index]"
+                              "   before fsize->index== %d\n",fsize->index);//potti
+              if (fsize->index >= ARRAY_SIZE(prev_resolution_array))
+                      return -EINVAL;
+              frmsize = &prev_resolution_array[fsize->index].frmsize;
+              printk("ar0833_prev_resolution[fsize->index]"
+                              "   after fsize->index== %d\n",fsize->index);
+              fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+              fsize->discrete.width = frmsize->width;
+              fsize->discrete.height = frmsize->height;
+      } else if (fmt->fourcc == V4L2_PIX_FMT_RGB24){
+              printk("ar0833_pic_resolution[fsize->index]"
+                              "   before fsize->index== %d\n",fsize->index);
+              if (fsize->index >= ARRAY_SIZE(capture_resolution_array))
+                      return -EINVAL;
+              frmsize = &capture_resolution_array[fsize->index].frmsize;
+              printk("ar0833_pic_resolution[fsize->index]"
+                              "   after fsize->index== %d\n",fsize->index);
+              fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+              fsize->discrete.width = frmsize->width;
+              fsize->discrete.height = frmsize->height;
+      }
+      return ret;
+}
+
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+{
+	return 0;
+}
+
+/* only one input in this sample driver */
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	//if (inp->index >= NUM_INPUTS)
+		//return -EINVAL;
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->std = V4L2_STD_525_60;
+	sprintf(inp->name, "Camera %u", inp->index);
+	return (0);
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct ar0833_fh *fh = priv;
+	struct ar0833_device *dev = fh->dev;
+
+	*i = dev->input;
+	return (0);
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct ar0833_fh *fh = priv;
+	struct ar0833_device *dev = fh->dev;
+
+	//if (i >= NUM_INPUTS)
+		//return -EINVAL;
+
+	dev->input = i;
+	//precalculate_bars(fh);
+
+	return (0);
+}
+
+	/* --- controls ---------------------------------------------- */
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ar0833_qctrl); i++)
+		if (qc->id && qc->id == ar0833_qctrl[i].id) {
+			memcpy(qc, &(ar0833_qctrl[i]),sizeof(*qc));
+			return (0);
+		}
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct ar0833_fh *fh = priv;
+	struct ar0833_device *dev = fh->dev;
+	int i, status;
+	int ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(ar0833_qctrl); i++)
+		if (ctrl->id == ar0833_qctrl[i].id) {
+		#if 0
+            if( (V4L2_CID_FOCUS_AUTO == ctrl->id)
+                    && bDoingAutoFocusMode){
+                dev->cam_para->cam_command = CAM_COMMAND_GET_STATE;
+                dev->fe_arg.port = TVIN_PORT_ISP;
+                dev->fe_arg.index = 0;
+                dev->fe_arg.arg = (void *)(dev->cam_para);
+                status = dev->vops->tvin_fe_func(0,&dev->fe_arg);
+                switch(status){
+                    case CAM_STATE_DOING:
+                        ret = -EBUSY;
+                        break;
+                    case CAM_STATE_ERROR:
+                    case CAM_STATE_NULL:
+                        printk("auto mode failed!\n");
+                        bDoingAutoFocusMode = false;
+                        ret = -EAGAIN;
+                        break;
+                    case CAM_STATE_SUCCESS:
+                        bDoingAutoFocusMode = false;
+                        ret = 0;
+                        break;
+                    default:
+                        printk("wrong state\n");
+                        ret = 0;
+                }
+            }else if( V4L2_CID_AUTO_FOCUS_STATUS == ctrl->id){
+                dev->cam_para->cam_command = CAM_COMMAND_GET_STATE;
+                dev->fe_arg.port = TVIN_PORT_ISP;
+                dev->fe_arg.index = 0;
+                dev->fe_arg.arg = (void *)(dev->cam_para);
+                status = dev->vops->tvin_fe_func(0,&dev->fe_arg);
+                switch(status){
+                    case CAM_STATE_DOING:
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_BUSY;
+                        break;
+                    case CAM_STATE_ERROR:
+                        printk("should resart focus\n");
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_FAILED;
+                        break;
+                    case CAM_STATE_NULL:
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_IDLE;
+                        break;
+                    case CAM_STATE_SUCCESS:
+                        ctrl->value = V4L2_AUTO_FOCUS_STATUS_REACHED;
+                        break;
+                    default:
+                        printk("wrong state\n");
+                }	
+                return 0;
+            }
+			#endif
+            ctrl->value = dev->qctl_regs[i];
+            return ret;
+        }
+
+	return -EINVAL;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct ar0833_fh *fh = priv;
+	struct ar0833_device *dev = fh->dev;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(ar0833_qctrl); i++)
+		if (ctrl->id == ar0833_qctrl[i].id) {
+			if (ctrl->value < ar0833_qctrl[i].minimum ||
+			    ctrl->value > ar0833_qctrl[i].maximum ||
+			    ar0833_setting(dev,ctrl->id,ctrl->value)<0) {
+				return -ERANGE;
+			}
+			dev->qctl_regs[i] = ctrl->value;
+			return 0;
+		}
+	return -EINVAL;
+
+}
+
+/* ------------------------------------------------------------------
+	File operations for the device
+   ------------------------------------------------------------------*/
+
+static int ar0833_open(struct file *file)
+{
+    struct ar0833_device *dev = video_drvdata(file);
+    struct ar0833_fh *fh = NULL;
+    resource_size_t mem_start = 0;
+    unsigned int mem_size = 0;
+    int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0) {
+    	printk("error: no cma memory\n");
+        return -1;
+    }
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+    switch_mod_gate_by_name("ge2d", 1);
+#endif		
+    aml_cam_init(&dev->cam_info);
+    printk("config path:%s\n",(dev->cam_info).config);
+    if((dev->cam_info).config != NULL){
+        if((cf = kmalloc(sizeof(configure),0)) != NULL){
+            if(parse_config((dev->cam_info).config) == 0){
+                printk("parse successfully");
+            }else{
+                printk("parse failed");
+            }
+        }else{
+            printk("malloc failed");
+            return -ENOMEM;
+        }      
+    }
+    if((dev->cam_para = kzalloc(sizeof(cam_parameter_t),0)) == NULL){
+        printk("memalloc failed\n");
+        return -ENOMEM;
+    }
+    AR0833_init_regs(dev);
+    msleep(40);
+    mutex_lock(&dev->mutex);
+    dev->users++;
+    if (dev->users > 1) {
+        dev->users--;
+        mutex_unlock(&dev->mutex);
+        return -EBUSY;
+    }
+
+    dprintk(dev, 1, "open %s type=%s users=%d\n",
+            video_device_node_name(dev->vdev),
+            v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+    /* init video dma queues */
+    INIT_LIST_HEAD(&dev->vidq.active);
+    init_waitqueue_head(&dev->vidq.wq);
+    spin_lock_init(&dev->slock);
+    /* allocate + initialize per filehandle data */
+    fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+    if (NULL == fh) {
+        dev->users--;
+        retval = -ENOMEM;
+    }
+    mutex_unlock(&dev->mutex);
+
+    if (retval)
+        return retval;
+
+    wake_lock(&(dev->wake_lock));
+    file->private_data = fh;
+    fh->dev      = dev;
+
+    fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    fh->fmt      = &formats[0];
+    fh->width    = 640;
+    fh->height   = 480;
+    fh->stream_on = 0 ;
+    fh->f_flags  = file->f_flags;
+    /* Resets frame counters */
+    dev->jiffies = jiffies;
+
+    get_vm_buf_info(&mem_start, &mem_size, NULL);
+    fh->res.start = mem_start;
+    fh->res.end = mem_start+mem_size-1;
+    fh->res.magic = MAGIC_RE_MEM;
+    fh->res.priv = NULL;
+    videobuf_queue_res_init(&fh->vb_vidq, &ar0833_video_qops,
+    			NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+    			sizeof(struct ar0833_buffer), (void*)&fh->res, NULL);
+    ar0833_start_thread(fh);
+    ar0833_have_open = 1;
+    ar0833_work_mode = CAMERA_PREVIEW;
+    dev->pindex.effect_index = 0;
+    dev->pindex.scenes_index = 0;
+    dev->pindex.wb_index = 0;
+    dev->pindex.capture_index = 0;
+    if(generate_para(dev->cam_para,dev->pindex) != 0){
+        printk("generate para failed\n");
+        free_para(dev->cam_para);
+        kfree(dev->cam_para);
+        return -EINVAL;
+    }
+    dev->cam_para->cam_function.set_aet_new_step = AR0833_set_aet_new_step;
+    dev->cam_para->cam_function.check_mains_freq = AR0833_check_mains_freq;
+    dev->cam_para->cam_function.set_af_new_step = AR0833_set_af_new_step;  
+    dev->ae_on = false;
+    /**creat class file**/		
+    cam_class = class_create(THIS_MODULE,"camera"); 
+    if(IS_ERR(cam_class)){
+        return PTR_ERR(cam_class);
+    }
+    retval = class_create_file(cam_class,&class_attr_ae_debug);
+    retval = class_create_file(cam_class,&class_attr_camera_debug);
+    retval = class_create_file(cam_class,&class_attr_aet_debug);
+    retval = class_create_file(cam_class,&class_attr_vcm_debug);
+    retval = class_create_file(cam_class,&class_attr_resolution_debug);
+    retval = class_create_file(cam_class,&class_attr_light_source_debug);
+    retval = class_create_file(cam_class,&class_attr_version_debug);
+    printk("open successfully\n");
+    dev->vops = get_vdin_v4l2_ops();
+	bDoingAutoFocusMode=false;
+    return 0;
+}
+
+static ssize_t
+ar0833_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct ar0833_fh *fh = file->private_data;
+
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+	}
+	return 0;
+}
+
+static unsigned int
+ar0833_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct ar0833_fh        *fh = file->private_data;
+	struct ar0833_device       *dev = fh->dev;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+		return POLLERR;
+
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int ar0833_close(struct file *file)
+{
+    struct ar0833_fh         *fh = file->private_data;
+    struct ar0833_device *dev       = fh->dev;
+    struct ar0833_dmaqueue *vidq = &dev->vidq;
+    struct video_device  *vdev = video_devdata(file);
+    int i=0;
+    ar0833_have_open = 0;
+    ar0833_stop_thread(vidq);
+    videobuf_stop(&fh->vb_vidq);
+    if(fh->stream_on){
+        dev->vops->stop_tvin_service(0);
+    }
+    videobuf_mmap_free(&fh->vb_vidq);
+
+    kfree(fh);
+    if(cf != NULL){
+        if(cf->aet_valid){
+            for(i = 0; i < cf->aet.sum; i++){
+                kfree(cf->aet.aet[i].info);
+                kfree(cf->aet.aet[i].aet_table);
+                if(cf->aet.aet[i].manual != NULL)
+                    kfree(cf->aet.aet[i].manual);
+            }
+        }
+        if(cf->scene_valid){
+            kfree(cf->scene.scene);
+        }
+
+        kfree(cf);
+    }
+    if(dev->cam_para != NULL ){
+        free_para(dev->cam_para);
+        kfree(dev->cam_para);
+    }
+
+    mutex_lock(&dev->mutex);
+    dev->users--;
+    mutex_unlock(&dev->mutex);
+
+    dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+            video_device_node_name(vdev), dev->users);
+    //ar0833_h_active=800;
+    //ar0833_v_active=600;
+    ar0833_qctrl[0].default_value=0;
+    ar0833_qctrl[1].default_value=4;
+    ar0833_qctrl[2].default_value=0;
+    ar0833_qctrl[3].default_value=CAM_BANDING_50HZ;
+    ar0833_qctrl[4].default_value=CAM_WB_AUTO;
+
+    ar0833_qctrl[5].default_value=4;
+    ar0833_qctrl[6].default_value=0;
+    ar0833_qctrl[10].default_value=100;
+    ar0833_qctrl[11].default_value=0;
+    //ar0833_frmintervals_active.numerator = 1;
+    //ar0833_frmintervals_active.denominator = 15;
+    power_down_ar0833(dev);
+    msleep(10);
+
+    aml_cam_uninit(&dev->cam_info);
+
+    msleep(10);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+    switch_mod_gate_by_name("ge2d", 0);
+#endif		
+    wake_unlock(&(dev->wake_lock));
+    class_remove_file(cam_class,&class_attr_ae_debug);
+    class_remove_file(cam_class,&class_attr_camera_debug);
+    class_remove_file(cam_class,&class_attr_aet_debug);
+    class_remove_file(cam_class,&class_attr_vcm_debug);
+    class_remove_file(cam_class,&class_attr_resolution_debug);
+	class_remove_file(cam_class,&class_attr_light_source_debug);
+    class_remove_file(cam_class,&class_attr_version_debug);
+    class_destroy(cam_class);
+    printk("close success\n");
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
+    return 0;
+}
+
+static int ar0833_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct ar0833_fh  *fh = file->private_data;
+	struct ar0833_device *dev = fh->dev;
+	int ret;
+
+	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+
+	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+		ret);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations ar0833_fops = {
+	.owner		= THIS_MODULE,
+	.open           = ar0833_open,
+	.release        = ar0833_close,
+	.read           = ar0833_read,
+	.poll		= ar0833_poll,
+	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+	.mmap           = ar0833_mmap,
+};
+
+static const struct v4l2_ioctl_ops ar0833_ioctl_ops = {
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_querymenu     = vidioc_querymenu,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+	.vidioc_enum_framesizes = vidioc_enum_framesizes,
+	.vidioc_g_parm = vidioc_g_parm,
+	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf          = vidiocgmbuf,
+#endif
+};
+
+static struct video_device ar0833_template = {
+	.name		= "ar0833_v4l",
+	.fops           = &ar0833_fops,
+	.ioctl_ops 	= &ar0833_ioctl_ops,
+	.release	= video_device_release,
+
+	.tvnorms              = V4L2_STD_525_60,
+	.current_norm         = V4L2_STD_NTSC_M,
+};
+
+static int ar0833_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_AR0833, 0);
+}
+
+static const struct v4l2_subdev_core_ops ar0833_core_ops = {
+	.g_chip_ident = ar0833_g_chip_ident,
+};
+
+static const struct v4l2_subdev_ops ar0833_ops = {
+	.core = &ar0833_core_ops,
+};
+
+static ssize_t cam_info_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct ar0833_device *t;
+	
+	t = dev_get_drvdata(dev);
+	
+	len += sprintf(buf+len, "\t%s parameters below\n", t->cam_info.name);
+	len += sprintf(buf+len, "\ti2c_bus_num=%d, front_back=%d,flash=%d, auto_focus=%d, i2c_addr=0x%x\n"
+	                "\tmclk=%d, flash_support=%d, flash_ctrl_level=%d, interface=%d, clk_channel=%d\n",
+	                t->cam_info.i2c_bus_num,
+	                t->cam_info.front_back,
+	                t->cam_info.flash,
+	                t->cam_info.auto_focus,
+	                t->cam_info.i2c_addr,
+	                t->cam_info.mclk,
+	                t->cam_info.flash_support,
+	                t->cam_info.flash_ctrl_level,
+	                t->cam_info.interface,
+	                t->cam_info.clk_channel);
+	return len;
+}
+static ssize_t cam_info_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t len)
+{
+
+	struct ar0833_device *t;
+	unsigned char n=0;
+	unsigned char ret=0;
+	char *buf_orig, *ps, *token;
+	char *parm[3] = {NULL};
+	
+	if(!buf)
+		return len;
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	t = dev_get_drvdata(dev);
+	
+	ps = buf_orig;
+	while (1) {
+	    if ( n >=ARRAY_SIZE(parm) ){
+	            printk("parm array overflow, n=%d, ARRAY_SIZE(parm)=%d\n", n, ARRAY_SIZE(parm));
+	            return len;
+	    }
+	
+	    token = strsep(&ps, " \n");
+	    if (token == NULL)
+	            break;
+	    if (*token == '\0')
+	            continue;
+	    parm[n++] = token;
+	}
+	
+	if ( 0 == strcmp(parm[0],"interface")){
+	    t->cam_info.interface = simple_strtol(parm[1],NULL,16);
+	    printk("substitude with %s interface\n", t->cam_info.interface?"mipi":"dvp");
+	}else if ( 0 == strcmp(parm[0],"clk")){
+	    t->cam_info.clk_channel = simple_strtol(parm[1],NULL,16);
+	    printk("clk channel =%s\n", t->cam_info.interface?"clkB":"clkA");
+	}
+	
+	kfree(buf_orig);
+	
+	return len;
+
+}
+
+static DEVICE_ATTR(cam_info, 0664, cam_info_show, cam_info_store);
+static int ar0833_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	struct ar0833_device *t;
+	struct v4l2_subdev *sd;
+	aml_cam_info_t* plat_dat;
+	v4l_info(client, "chip found @ 0x%x (%s)\n",
+			client->addr << 1, client->adapter->name);
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (t == NULL)
+		return -ENOMEM;
+	sd = &t->sd;
+	v4l2_i2c_subdev_init(sd, client, &ar0833_ops);
+
+	plat_dat = (aml_cam_info_t*)client->dev.platform_data;
+
+	/* Now create a video4linux device */
+	mutex_init(&t->mutex);
+
+	/* Now create a video4linux device */
+	t->vdev = video_device_alloc();
+	if (t->vdev == NULL) {
+		kfree(t);
+		kfree(client);
+		return -ENOMEM;
+	}
+	memcpy(t->vdev, &ar0833_template, sizeof(*t->vdev));
+
+	video_set_drvdata(t->vdev, t);
+	
+	wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "ar0833");
+	/* Register it */
+	if (plat_dat) {
+		memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
+		if(plat_dat->front_back>=0)  
+			video_nr=plat_dat->front_back;
+	}else {
+		printk("camera ar0833: have no platform data\n");
+		kfree(t);
+		kfree(client);
+		return -1;
+	}
+   printk("register device\n");	
+	err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (err < 0) {
+		video_device_release(t->vdev);
+		kfree(t);
+		return err;
+	}
+	device_create_file( &t->vdev->dev, &dev_attr_cam_info);
+	return 0;
+}
+
+static int ar0833_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ar0833_device *t = to_dev(sd);
+	device_remove_file( &t->vdev->dev, &dev_attr_cam_info);
+	video_unregister_device(t->vdev);
+	v4l2_device_unregister_subdev(sd);
+	wake_lock_destroy(&(t->wake_lock));
+	kfree(t);
+	return 0;
+}
+
+static const struct i2c_device_id ar0833_id[] = {
+	{ "ar0833", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0833_id);
+
+static struct i2c_driver ar0833_i2c_driver = {
+	.driver = {
+		.name = "ar0833",
+	},
+	.probe = ar0833_probe,
+	.remove = ar0833_remove,
+	.id_table = ar0833_id,
+};
+
+module_i2c_driver(ar0833_i2c_driver);
\ No newline at end of file
diff --git a/drivers/amlogic/camera/common/cam_prober.c b/drivers/amlogic/camera/common/cam_prober.c
index f8ab90f5dee4..3789dec7c10d 100755
--- a/drivers/amlogic/camera/common/cam_prober.c
+++ b/drivers/amlogic/camera/common/cam_prober.c
@@ -81,6 +81,19 @@ static int aml_i2c_get_byte(struct i2c_adapter *adapter,
 	return buff[0];
 }
 
+static int aml_i2c_put_byte(struct i2c_adapter *adapter, 
+		unsigned short dev_addr, unsigned short addr, unsigned char data)
+{
+	unsigned char buff[4];
+	buff[0] = (unsigned char)((addr >> 8) & 0xff);
+	buff[1] = (unsigned char)(addr & 0xff);
+	buff[2] = data;
+	if (aml_camera_write_buff(adapter, dev_addr, buff, 3) <0)
+		return -1;
+	return  0;
+}
+
+
 static int aml_i2c_get_byte_add8(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr)
 {
@@ -92,43 +105,70 @@ static int aml_i2c_get_byte_add8(struct i2c_adapter *adapter,
 	return buff[0];
 }
 
-static int aml_i2c_put_byte(struct i2c_adapter *adapter, 
+static int aml_i2c_put_byte_add8(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr, unsigned char data)
 {
 	unsigned char buff[4];
-	buff[0] = (unsigned char)((addr >> 8) & 0xff);
-	buff[1] = (unsigned char)(addr & 0xff);
-	buff[2] = data;
-	if (aml_camera_write_buff(adapter, dev_addr, buff, 3) <0)
+	buff[0] = (unsigned char)(addr & 0xff);
+	buff[1] = data;
+	if (aml_camera_write_buff(adapter, dev_addr, buff, 2) <0)
 		return -1;
 	return  0;
 }
 
-
-/*static int aml_i2c_put_word(struct i2c_adapter *adapter, 
+int aml_i2c_put_word(struct i2c_adapter *adapter, 
 		unsigned short dev_addr, unsigned short addr, unsigned short data)
 {
 	unsigned char buff[4];
 	buff[0] = (unsigned char)((addr >> 8) & 0xff);
 	buff[1] = (unsigned char)(addr & 0xff);
-	buff[2] = (unsigned char)(data & 0xff);
-	buff[3] = (unsigned char)((data >> 8) & 0xff);
+	buff[2] = (unsigned char)((data >> 8) & 0xff);
+	buff[3] = (unsigned char)(data & 0xff);
 	if (aml_camera_write_buff(adapter, dev_addr, buff, 4) <0)
 		return -1;
 	return 0;
-}*/
+}
 
-static int aml_i2c_put_byte_add8(struct i2c_adapter *adapter, 
-		unsigned short dev_addr, unsigned char addr, unsigned char data)
+static int aml_i2c_get_word(struct i2c_adapter *adapter, 
+		unsigned short dev_addr, unsigned short addr)
+{
+	int ret;
+	unsigned char buff[4];
+	buff[0] = (unsigned char)((addr >> 8) & 0xff);
+	buff[1] = (unsigned char)(addr & 0xff);
+	if (aml_camera_read_buff(adapter, dev_addr, buff, 2, 2) <0)
+		return -1;
+	ret =  (buff[0]<< 8)|(buff[1]);
+	return ret;
+}
+
+static int aml_i2c_get_word_add8(struct i2c_adapter *adapter, 
+		unsigned short dev_addr, unsigned short addr)
+{
+	int ret;
+	unsigned char buff[4];
+	buff[0] = (unsigned char)((addr >> 8) & 0xff);
+	buff[1] = (unsigned char)(addr & 0xff);
+	if (aml_camera_read_buff(adapter, dev_addr, buff, 2, 2) <0)
+		return -1;
+	ret =  buff[0] | (buff[1] << 8);
+	return ret;
+}
+
+
+static int aml_i2c_put_word_add8(struct i2c_adapter *adapter, 
+		unsigned short dev_addr, unsigned char addr, unsigned short data)
 {
 	unsigned char buff[4];
 	buff[0] = (unsigned char)(addr & 0xff);
-	buff[1] = (unsigned char)(data & 0xff);
-	if (aml_camera_write_buff(adapter, dev_addr, buff, 2) <0)
+	buff[1] = (unsigned char)(data >> 8 & 0xff);
+	buff[2] = (unsigned char)(data & 0xff);
+	if (aml_camera_write_buff(adapter, dev_addr, buff, 3) <0)
 		return -1;
 	return  0;
 }
 
+
 extern struct i2c_client *
 i2c_new_existing_device(struct i2c_adapter *adap, 
 			struct i2c_board_info const *info);
@@ -364,6 +404,31 @@ int ov5647_v4l2_probe(struct i2c_adapter *adapter)
 }
 #endif
 
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0543
+int ar0543_v4l2_probe(struct i2c_adapter *adapter)
+{
+ 	int ret = 0, reg_val;
+	reg_val = aml_i2c_get_word(adapter, 0x36, 0x3000);
+	printk("reg:0x%x\n",reg_val);
+	if (reg_val == 0x4800)
+		ret = 1;
+	return ret;
+}
+#endif
+
+
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0833
+int ar0833_v4l2_probe(struct i2c_adapter *adapter)
+{
+ 	int ret = 0, reg_val;
+	reg_val = aml_i2c_get_word(adapter, 0x36, 0x3000);
+	printk("reg:0x%x\n",reg_val);
+	if (reg_val == 0x4B03)
+		ret = 1;
+	return ret;
+}
+#endif
+
 
 typedef struct {
 	unsigned char addr;
@@ -536,6 +601,24 @@ static aml_cam_dev_info_t cam_devs[] = {
 		.probe_func = hi2056_v4l2_probe,
 	},
 #endif
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0543
+	{
+		.addr = 0x36,
+		.name = "ar0543",
+		.pwdn = 0,
+		.max_cap_size = SIZE_2592X1944,
+		.probe_func = ar0543_v4l2_probe,
+	},
+#endif
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0833
+	{
+		.addr = 0x36,
+		.name = "ar0833",
+		.pwdn = 0,
+		.max_cap_size = SIZE_2592X1944,
+		.probe_func = ar0833_v4l2_probe,
+	},
+#endif
 };
 
 static aml_cam_dev_info_t* get_cam_info_by_name(const char* name)
@@ -623,9 +706,11 @@ static resulution_size_t get_res_size(const char* res_str)
 }
 
 #ifdef CONFIG_ARCH_MESON8
-static inline void cam_enable_clk(void)
+static inline void cam_enable_clk(int clk)
 {
 	aml_set_reg32_bits(P_HHI_GEN_CLK_CNTL, 1, 11, 5);
+	if (clk == 12000)
+		aml_set_reg32_bits(P_HHI_GEN_CLK_CNTL, 1, 0, 7);
 }
 
 static inline void cam_disable_clk(void)
@@ -633,7 +718,7 @@ static inline void cam_disable_clk(void)
 	aml_set_reg32_bits(P_HHI_GEN_CLK_CNTL, 0, 11, 5); //close clock
 }
 #elif defined CONFIG_ARCH_MESON6
-static inline void cam_enable_clk(void)
+static inline void cam_enable_clk(int clk)
 {
 	aml_set_reg32_bits(P_HHI_GEN_CLK_CNTL, 1, 8, 5); 
 }
@@ -643,7 +728,7 @@ static inline void cam_disable_clk(void)
 	aml_set_reg32_bits(P_HHI_GEN_CLK_CNTL, 0, 8, 5);  //close clock
 }
 #else
-static inline void cam_enable_clk(void)
+static inline void cam_enable_clk(int clk)
 {
 }
 
@@ -666,7 +751,7 @@ void aml_cam_init(aml_cam_info_t* cam_dev)
 		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "gpio");
 
 	//select XTAL as camera clock
-	cam_enable_clk();
+	cam_enable_clk(cam_dev->mclk);
 	
 	msleep(20);
 	// set camera power enable
@@ -740,7 +825,7 @@ static int fill_csi_dev(struct device_node* p_node, aml_cam_info_t* cam_dev)
                 }
 	}
 
-    return ret;
+        return ret;
 
 }
 static int fill_cam_dev(struct device_node* p_node, aml_cam_info_t* cam_dev)
@@ -749,6 +834,7 @@ static int fill_cam_dev(struct device_node* p_node, aml_cam_info_t* cam_dev)
 	int ret = 0;
 	aml_cam_dev_info_t* cam_info = NULL;
 	struct i2c_adapter *adapter;
+	unsigned mclk = 0;
 	
 	if (!p_node || !cam_dev)
 		return -1;
@@ -857,6 +943,40 @@ static int fill_cam_dev(struct device_node* p_node, aml_cam_info_t* cam_dev)
 			cam_dev->bt_path = BT_PATH_GPIO;
 	}
 
+	ret = of_property_read_u32(p_node, "mclk", &mclk);
+	if (ret) {
+		cam_dev->mclk = 24000;
+	} else {
+		cam_dev->mclk = mclk;
+	}
+	
+	ret = of_property_read_string(p_node, "flash_support", &str);
+	if (ret) {
+		printk("failed to read camera flash_support\n");
+		cam_dev->flash_support = 0;
+	} else {
+		printk("camera interface:%s\n", str);
+		if (strncmp("flash_support", str, 1) == 0){
+                        cam_dev->flash_support = 1;
+                        of_property_read_u32(p_node, "flash_ctrl_level", &cam_dev->flash_ctrl_level);
+                        ret = of_property_read_string(p_node, "flash_ctrl_pin", &str);
+			if (ret) {
+				printk("%s: faild to get flash_ctrl_pin!\n", cam_dev->name);
+				cam_dev->flash_support = 0;
+			} else {
+				ret = amlogic_gpio_name_map_num(str);
+				if (ret < 0) {
+					printk("%s: faild to map flash_ctrl_pin !\n", cam_dev->name);
+					cam_dev->flash_support = 0;
+					cam_dev->flash_ctrl_level = 0;
+				}
+				cam_dev->flash_ctrl_pin = ret;  
+			}
+                }else{
+                        cam_dev->flash_support = 0;
+                }
+	}
+
 	ret = of_property_read_string(p_node, "interface", &str);
 	if (ret) {
 		printk("failed to read camera interface \"mipi or dvp\"\n");
@@ -908,7 +1028,7 @@ err_out:
 
 static int  do_read_work(char argn ,char **argv)
 {
-	unsigned int dev_addr, reg_addr, result;     
+	unsigned int dev_addr, reg_addr, data_len = 1, result;     
 	unsigned int i2c_bus;    
 	struct i2c_adapter *adapter;   
 
@@ -942,14 +1062,27 @@ static int  do_read_work(char argn ,char **argv)
         
 	dev_addr = simple_strtol(argv[2],NULL,16);
 	reg_addr = simple_strtol(argv[3],NULL,16);
-	
+	if (argn == 5) {
+		printk("argv[4] is %s\n", argv[4]);
+		data_len = simple_strtol(argv[4],NULL,16);
+	}
 	
 	if (reg_addr > 256) {
-		result = aml_i2c_get_byte(adapter, dev_addr, reg_addr);
-		printk("register [0x%04x]=0x%02x\n", reg_addr, result);
+		if (data_len != 2) {
+			result = aml_i2c_get_byte(adapter, dev_addr, reg_addr);
+			printk("register [0x%04x]=0x%02x\n", reg_addr, result);
+		} else {
+			result = aml_i2c_get_word(adapter, dev_addr, reg_addr);
+			printk("register [0x%04x]=0x%04x\n", reg_addr, result);
+		}
 	} else {
-		result = aml_i2c_get_byte_add8(adapter, dev_addr, reg_addr);
-		printk("register [0x%02x]=0x%02x\n", reg_addr, result);
+		if (data_len != 2) {
+			result = aml_i2c_get_byte_add8(adapter, dev_addr, reg_addr);
+			printk("register [0x%02x]=0x%02x\n", reg_addr, result);
+		} else {
+			result = aml_i2c_get_word_add8(adapter, dev_addr, reg_addr);
+			printk("register [0x%02x]=0x%04x\n", reg_addr, result);
+		}
 	}
 		
 	return 0;
@@ -957,15 +1090,15 @@ static int  do_read_work(char argn ,char **argv)
 
 static int do_write_work(char argn ,char **argv)
 {
-	unsigned int dev_addr, reg_addr, reg_val, ret = 0;     
+	unsigned int dev_addr, reg_addr, reg_val, data_len = 1, ret = 0;     
 	unsigned int i2c_bus;    
 	struct i2c_adapter *adapter;   
 
 
-	/*if (argn < 5){
+	if (argn < 5){
 		printk("args num error");
 		return -1;
-	}*/
+	}
 	
 	if (!strncmp(argv[1], "i2c_bus_ao", 9))
 		i2c_bus = AML_I2C_MASTER_AO;
@@ -992,22 +1125,43 @@ static int do_write_work(char argn ,char **argv)
 	dev_addr = simple_strtol(argv[2],NULL,16);
 	reg_addr = simple_strtol(argv[3],NULL,16);
 	reg_val = simple_strtol(argv[4],NULL,16);
+	if (argn == 6)
+		data_len = simple_strtol(argv[5],NULL,16);
 	if (reg_addr > 256) {
-		if(aml_i2c_put_byte(adapter, dev_addr, reg_addr, reg_val) < 0) {
-			printk("write error\n");
-			ret = -1;
+		if (data_len != 2) {
+			if(aml_i2c_put_byte(adapter, dev_addr, reg_addr, reg_val) < 0) {
+				printk("write error\n");
+				ret = -1;
+			} else {
+				printk("write ok\n");
+				ret = 0;
+			}
 		} else {
-			printk("write ok\n");
-			ret = 0;
+			if(aml_i2c_put_word(adapter, dev_addr, reg_addr, reg_val) < 0) {
+				printk("write error\n");
+				ret = -1;
+			} else {
+				printk("write ok\n");
+				ret = 0;
+			}
 		}
-		
 	} else {
-		if (aml_i2c_put_byte_add8(adapter, dev_addr, reg_addr, reg_val) < 0){
-			printk("write error\n");
-			ret = -1;
+		if (data_len != 2) {
+			if (aml_i2c_put_byte_add8(adapter, dev_addr, reg_addr, reg_val) < 0){
+				printk("write error\n");
+				ret = -1;
+			} else {
+				printk("write ok\n");
+				ret = 0;
+			}
 		} else {
-			printk("write ok\n");
-			ret = 0;
+			if (aml_i2c_put_word_add8(adapter, dev_addr, reg_addr, reg_val) < 0){
+				printk("write error\n");
+				ret = -1;
+			} else {
+				printk("write ok\n");
+				ret = 0;
+			}
 		}
 	}
 		
@@ -1021,10 +1175,10 @@ static ssize_t show_help(struct class* class, struct class_attribute* attr,
 	char* buf)
 {
 	ssize_t size = 0;
-	printk( "echo [read | write] i2c_bus_type device_address register_address [value] > i2c_debug\n"
+	printk( "echo [read | write] i2c_bus_type device_address register_address [value] [data_len] > i2c_debug\n"
 		"i2c_bus_type are: i2c_bus_ao, i2c_bus_a, i2c_bus_b, i2c_bus_c, i2c_bus_d\n"
-		"e.g.: echo read i2c_bus_ao 0x3c 0x18\n"
-		"      echo write i2c_bus_ao 0x3c 0x18 0x24\n");
+		"e.g.: echo read i2c_bus_ao 0x3c 0x18 1\n"
+		"      echo write i2c_bus_ao 0x3c 0x18 0x24 1\n");
 	return size;
 }
 
@@ -1034,20 +1188,20 @@ static ssize_t store_i2c_debug(struct class* class, struct class_attribute* attr
 	int argn;
 	char * buf_work,*p,*para;
 	char cmd;
-	char * argv[4];
+	char * argv[6];
 	
 	buf_work = kstrdup(buf, GFP_KERNEL);
 	p = buf_work;
 	
-	for(argn = 0; argn < 5; argn++){
+	for(argn = 0; argn < 6; argn++){
 		para = strsep(&p," ");
 		if(para == NULL)
 			break;
 		argv[argn] = para;
-		//printk("argv[%d] = %s\n",argn,para);
+		printk("argv[%d] = %s\n",argn,para);
 	}
 	
-	if(argn < 4 || argn > 5)
+	if(argn < 4 || argn > 6)
 		goto end;
 		
 	cmd = argv[0][0];
diff --git a/drivers/amlogic/camera/common/plat_ctrl.c b/drivers/amlogic/camera/common/plat_ctrl.c
index e8290d7637cd..06a2d43c4ca9 100755
--- a/drivers/amlogic/camera/common/plat_ctrl.c
+++ b/drivers/amlogic/camera/common/plat_ctrl.c
@@ -31,6 +31,7 @@
 #include <media/videobuf-vmalloc.h>
 
 #include <linux/i2c.h>
+#include "plat_ctrl.h"
 
 /****************************************************************
  *   i2c functions
@@ -44,8 +45,7 @@ static int camera_read_buff(struct i2c_client *client,char *buf, int addr_len, i
 			.flags	= 0,
 			.len	= addr_len,
 			.buf	= buf,
-		},
-		{
+		},{
 			.addr	= client->addr,
 			.flags	= I2C_M_RD,
 			.len	= data_len,
@@ -70,11 +70,10 @@ static int  camera_write_buff(struct i2c_client *client,char *buf, int len)
 
 	};
 
-	if (i2c_transfer(client->adapter, msg, 1) < 0)
-	{
+	if (i2c_transfer(client->adapter, msg, 1) < 0) {
+		printk("i2c error\n");
 		return -1;
-	}
-	else
+	} else
 		return 0;
 }
 
@@ -110,11 +109,10 @@ int i2c_get_word(struct i2c_client *client,unsigned short addr)
 		return -1;
     else
     {
-        data = buff[1];
-        data = (data << 8) | buff[0];
+		data = buff[0];
+		data = (data << 8) | buff[1];
         return data;
     }
-
 }
 
 int i2c_put_byte(struct i2c_client *client, unsigned short addr, unsigned char data)
@@ -133,8 +131,9 @@ int i2c_put_word(struct i2c_client *client, unsigned short addr, unsigned short
     unsigned char buff[4];
     buff[0] = (unsigned char)((addr >> 8) & 0xff);
     buff[1] = (unsigned char)(addr & 0xff);
-    buff[2] = (unsigned char)(data & 0xff);
-    buff[3] = (unsigned char)((data >> 8) & 0xff);
+	buff[2] = (unsigned char)((data >> 8) & 0xff);
+	buff[3] = (unsigned char)(data & 0xff);
+	
 	if (camera_write_buff(client, buff, 4) <0)
 		return -1;
 	return 0;
@@ -157,4 +156,45 @@ int i2c_put_byte_add8(struct i2c_client *client,char *buf, int len)
 	return  0;
 }
 
+int cam_i2c_send_msg(struct i2c_client *client, cam_i2c_msg_t i2c_msg)
+{
+	unsigned char buff[4];
+	
+	switch (i2c_msg.type) {
+	case ADDR16_DATA16:
+		buff[0] = (unsigned char)((i2c_msg.addr >> 8) & 0xff);
+		buff[1] = (unsigned char)(i2c_msg.addr & 0xff);
+		buff[2] = (unsigned char)((i2c_msg.data >> 8) & 0xff);
+		buff[3] = (unsigned char)(i2c_msg.data & 0xff);
+		if (camera_write_buff(client, buff, 4) <0)
+			return -1;
+		break;
+	case ADDR16_DATA8:
+		buff[0] = (unsigned char)((i2c_msg.addr >> 8) & 0xff);
+		buff[1] = (unsigned char)(i2c_msg.addr & 0xff);
+		buff[2] = (unsigned char)(i2c_msg.data & 0xff);
+		if (camera_write_buff(client, buff, 3) <0)
+			return -1;
+		break;
+	case ADDR8_DATA16:
+		buff[0] = (unsigned char)(i2c_msg.addr & 0xff);
+		buff[1] = (unsigned char)((i2c_msg.data >> 8) & 0xff);
+		buff[2] = (unsigned char)(i2c_msg.data & 0xff);
+		if (camera_write_buff(client, buff, 3) <0)
+			return -1;
+		break;
+	case ADDR8_DATA8:
+		buff[0] = (unsigned char)(i2c_msg.addr & 0xff);
+		buff[1] = (unsigned char)(i2c_msg.data & 0xff);
+		if (camera_write_buff(client, buff, 2) <0)
+			return -1;
+	case TIME_DELAY:
+		msleep(i2c_msg.data);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
 
diff --git a/drivers/amlogic/camera/common/plat_ctrl.h b/drivers/amlogic/camera/common/plat_ctrl.h
index 67b6487a86f5..d6627e337436 100755
--- a/drivers/amlogic/camera/common/plat_ctrl.h
+++ b/drivers/amlogic/camera/common/plat_ctrl.h
@@ -1,6 +1,20 @@
 #ifndef _AMLOGIC_CAMERA_PLAT_CTRL_H
 #define _AMLOGIC_CAMERA_PLAT_CTRL_H
 
+#define ADDR8_DATA8		0
+#define ADDR16_DATA8		1
+#define ADDR16_DATA16 		2
+#define ADDR8_DATA16		3
+#define TIME_DELAY		0xfe   
+#define END_OF_SCRIPT			0xff   
+
+typedef struct cam_i2c_msg_s {
+	unsigned char type;
+	unsigned short addr;
+	unsigned short data;
+} cam_i2c_msg_t;
+	
+
 extern int i2c_get_byte(struct i2c_client *client,unsigned short addr);
 extern int i2c_get_word(struct i2c_client *client,unsigned short addr);
 extern int i2c_get_byte_add8(struct i2c_client *client, unsigned char addr);
@@ -8,6 +22,7 @@ extern int i2c_put_byte(struct i2c_client *client, unsigned short addr, unsigned
 extern int i2c_put_word(struct i2c_client *client, unsigned short addr, unsigned short data);
 extern int i2c_put_byte_add8_new(struct i2c_client *client, unsigned char addr, unsigned char data);
 extern int i2c_put_byte_add8(struct i2c_client *client,char *buf, int len);
+extern int cam_i2c_send_msg(struct i2c_client *client, cam_i2c_msg_t i2c_msg);
 
 
 #endif /* _AMLOGIC_CAMERA_PLAT_CTRL_H. */
diff --git a/include/linux/amlogic/camera/aml_cam_info.h b/include/linux/amlogic/camera/aml_cam_info.h
index 85d7bd2571d9..88e213cbe750 100755
--- a/include/linux/amlogic/camera/aml_cam_info.h
+++ b/include/linux/amlogic/camera/aml_cam_info.h
@@ -76,8 +76,8 @@ typedef struct {
 	unsigned flash_support;
 	unsigned flash_ctrl_level;
 	bt_path_t bt_path;
-    cam_interface_t         interface;
-    clk_channel_t           clk_channel;
+	cam_interface_t         interface;
+	clk_channel_t           clk_channel;
 	gpio_t pwdn_pin;
 	gpio_t rst_pin;
 	gpio_t flash_ctrl_pin;
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index f14b5f63559f..930cbb6e1506 100755
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -75,6 +75,12 @@ enum {
 	/* GC0328  */
         V4L2_IDENT_GC0328 = 38,
 
+        /* AR0543  */
+        V4L2_IDENT_AR0543 = 39,
+        
+        /* AR0833  */
+        V4L2_IDENT_AR0833 = 40,
+
 	/* module tvaudio: reserved range 50-99 */
 	V4L2_IDENT_TVAUDIO = 50,	/* A tvaudio chip, unknown which it is exactly */
 
-- 
2.19.0

