From 8e21be0be031996887c81333570125d8e795125d Mon Sep 17 00:00:00 2001
From: "yu.zheng" <yu.zheng@amlogic.com>
Date: Fri, 22 Nov 2013 19:19:59 +0800
Subject: [PATCH 2534/5965] add CEC funciton PD#80172: M8 HDMI CEC             
 1.add tx irq handle.              2.add cec arbitration.             
 3.change cec_node_init and polling dev strategy.

PD #80172: M8 HDMI CEC:

                1).env value bug:cecconfig fixed.
                2).add new remote cec feature for standby.

PD #80172: M8 HDMI CEC: cec standby bug fixed.

Conflicts:

	drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
---
 drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c   |   19 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c        |  345 ++-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c    | 1889 +++++++----------
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h    |   47 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c   |   13 +-
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c  |    2 +-
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c |   37 +
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h |    3 +
 .../amlogic/input/new_remote/remote_func.c    |   19 +
 drivers/amlogic/input/remote/am_remote.c      |   10 +-
 10 files changed, 1076 insertions(+), 1308 deletions(-)
 mode change 100644 => 100755 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
 mode change 100644 => 100755 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h

diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
index 94ccd1645c21..077212454183 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
@@ -50,14 +50,14 @@ __u16 cec_key_map[128] = {
     0 , 0, 0, 0, 0, 0, 0, 0,//0x30
     0 , 0, 0, 0, 0, 0, 0, 0,
     
-    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, 0,//0x40
-    KEY_REWIND, KEY_FASTFORWARD, 0, KEY_PREVIOUSSONG, KEY_NEXTSONG, 0, 0, 0,
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
     0 , 0, 0, 0, 0, 0, 0, 0,//0x50
     0 , 0, 0, 0, 0, 0, 0, 0,
     KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
     0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
     0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
-    0 , 0, 0, 0, 0, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
 };
 
 void cec_send_event(cec_rx_message_t* pcec_message)
@@ -86,15 +86,13 @@ void cec_send_event(cec_rx_message_t* pcec_message)
     if(cec_key_flag) {
         input_event(remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
         input_sync(remote_cec_dev);
-        hdmitx_cec_dbg_print("CEC:cec_key_map[operands[0]]:%d\n",cec_key_map[operands[0]]);
+        hdmitx_cec_dbg_print("CEC:key map:%d\n",cec_key_map[operands[0]]);
     }
     else{
         input_event(remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
         input_sync(remote_cec_dev);
-        hdmitx_cec_dbg_print("CEC:cec_key_map[operands[0]]:%d\n",cec_key_map[operands[0]]);
+        hdmitx_cec_dbg_print("CEC:key map:%d\n",cec_key_map[operands[0]]);
     }   
-
-    hdmitx_cec_dbg_print("CEC:cec_send_event\n");
 }
 
 
@@ -113,7 +111,8 @@ void cec_send_event_irq(void)
     
     switch(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
     case 0x33:
-        cec_system_audio_mode_request();
+        //cec_system_audio_mode_request();
+        //cec_set_system_audio_mode();
         break;
     case 0x35:
         break;
@@ -125,9 +124,7 @@ void cec_send_event_irq(void)
     input_sync(remote_cec_dev);	
     input_event(remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
     input_sync(remote_cec_dev);
-    hdmitx_cec_dbg_print("CEC:cec_key_map[operands_irq[0]]:%d\n",cec_key_map[operands_irq[0]]);       		
-   	
-    hdmitx_cec_dbg_print("CEC:cec_send_event_irq\n");  	 	
+    hdmitx_cec_dbg_print("CEC:key map:%d\n",cec_key_map[operands_irq[0]]);      		  	 	
 }
 
 void cec_user_control_pressed_irq(void)
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 6e6c76026594..f9eb003dcbf1 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -30,7 +30,7 @@
 #include <linux/platform_device.h>
 #include <linux/mutex.h>
 #include <linux/cdev.h>
-#include <linux/proc_fs.h> 
+#include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
@@ -76,7 +76,7 @@ struct hdmi_config_platform_data *hdmi_pdata;
 static hdmitx_dev_t hdmitx_device;
 static struct switch_dev sdev = {	// android ics switch device
 	.name = "hdmi",
-	};	
+	};
 static struct switch_dev hdcp_dev = {	// android ics switch device
 	.name = "hdcp",
 	};
@@ -128,19 +128,19 @@ static struct early_suspend hdmitx_early_suspend_handler = {
 
 #define INIT_FLAG_NOT_LOAD 0x80
 
-int hdmi_ch = 1;        //1: 2ch   
+int hdmi_ch = 1;        //1: 2ch
 
 static unsigned char init_flag=0;
 static unsigned char init_powermode=0;
 #undef DISABLE_AUDIO
 unsigned char hdmi_audio_off_flag = 0;        //if set to 1, then HDMI will output no audio
                                                 //In KTV case, HDMI output Picture only, and Audio is driven by other sources.
-static int hpdmode = 1; /* 
-                            0, do not unmux hpd when off or unplug ; 
+static int hpdmode = 1; /*
+                            0, do not unmux hpd when off or unplug ;
                             1, unmux hpd when unplug;
                             2, unmux hpd when unplug  or off;
                         */
-static int force_vout_index = 0;                      
+static int force_vout_index = 0;
 static int hdmi_prbs_mode = 0xffff; /* 0xffff=disable; 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31*/
 static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
 
@@ -149,7 +149,7 @@ static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
 // write /sys/module/hdmitx/parameters/hdmi_output_force 0
 static int hdmi_output_force = 1;
 
-static int hdmi_authenticated = -1;                     
+static int hdmi_authenticated = -1;
 static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
 static int hdmi_hdcp_status = 1;
 static int hdmi_hdcp_reset = 0;
@@ -182,8 +182,8 @@ static void set_test_mode(void)
                         hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURN_ON_PRBS, hdmi_prbs_mode);
                     }
                 }
-#endif                
-    
+#endif
+
 }
 
 int get_cur_vout_index(void)
@@ -197,7 +197,7 @@ return value: 1, vout; 2, vout2;
         vout_index = force_vout_index;
     }
     else{
-//VPU_VIU_VENC_MUX_CTRL        
+//VPU_VIU_VENC_MUX_CTRL
 // [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
 //         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
 // [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
@@ -206,12 +206,12 @@ return value: 1, vout; 2, vout2;
         int viu1_sel = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
         if(((viu2_sel==1)||(viu2_sel==2))&&
             (viu1_sel!=1)&&(viu1_sel!=2)){
-            vout_index = 2;    
+            vout_index = 2;
         }
     }
 #endif
-    return vout_index;    
-}    
+    return vout_index;
+}
 
 const vinfo_t * hdmi_get_current_vinfo(void)
 {
@@ -230,7 +230,7 @@ const vinfo_t * hdmi_get_current_vinfo(void)
     info = get_current_vinfo();
 #endif
     return info;
-}    
+}
 
 static  int  set_disp_mode(const char *mode)
 {
@@ -284,13 +284,13 @@ static  int  set_disp_mode(const char *mode)
     if(hdmitx_device.cur_VIC == HDMI_Unkown){
         if(hpdmode == 2){
             hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
-            hdmitx_device.mux_hpd_if_pin_high_flag = 0; 
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
         }
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);    
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
         }
     }
-    
+
     return ret;
 }
 
@@ -300,7 +300,7 @@ static int set_disp_mode_auto(void)
     const vinfo_t *info = hdmi_get_current_vinfo();
     unsigned char mode[10];
     HDMI_Video_Codes_t vic;     //Prevent warning
-    
+
     if(info == NULL) {
         printk("HDMITX: cann't get valid mode\n");
         hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
@@ -375,37 +375,28 @@ static int set_disp_mode_auto(void)
         }
         // If current display is NOT panel, needn't TURNOFF_HDMIHW
         if(strncmp(mode, "panel", 5) == 0){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);    
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
         }
     }
     return ret;
-}    
+}
 #if 0
 static unsigned int set_cec_code(const char * buf, size_t count)
 {
     char tmpbuf[128];
     int i=0;
-    //int j;
     unsigned int cec_code;
-    //unsigned int value=0;
 
     while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
         tmpbuf[i]=buf[i];
-        i++;    
+        i++;
     }
     tmpbuf[i]=0;
 
     cec_code=simple_strtoul(tmpbuf, NULL, 16);
-    //cec_value=simple_strtoul(buf+i+1, NULL, 16);    
-    //cec_code = param[0];
-    //cec_value = param[1];
-    //printk("\n----------set_cec_code------------ \n");
-
-    //printk("\n----cec_code:%u\n",cec_code);
-    //printk("\n----cec_value:%u\n",cec_value);
     input_event(remote_cec_dev, EV_KEY, cec_code,1);
-    input_event(remote_cec_dev, EV_KEY, cec_code,0);       
-    input_sync(remote_cec_dev);  
+    input_event(remote_cec_dev, EV_KEY, cec_code,0);
+    input_sync(remote_cec_dev);
     return cec_code;
 }
 #endif
@@ -427,19 +418,19 @@ static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr
 {
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
-    return pos;    
+    return pos;
 }
-    
+
 static ssize_t store_disp_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     set_disp_mode(buf);
-    return 16;    
+    return 16;
 }
 
 /*cec attr*/
 static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
 {
-    ssize_t t = cec_usrcmd_get_global_info(buf);    
+    ssize_t t = cec_usrcmd_get_global_info(buf);
     return t;
 }
 
@@ -449,17 +440,11 @@ static ssize_t store_cec(struct device * dev, struct device_attribute *attr, con
     return count;
 }
 
-//static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
-//{
-//    ssize_t t = cec_usrcmd_get_global_info(buf);    
-//    return t;
-//}
-
 static ssize_t show_cec_config(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\r\n", aml_read_reg32(P_AO_DEBUG_REG0));
-    return pos;  
+    return pos;
 }
 
 static ssize_t store_cec_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
@@ -471,8 +456,7 @@ static ssize_t store_cec_config(struct device * dev, struct device_attribute *at
 static ssize_t store_cec_lang_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
 	printk("store_cec_lang_config\n");
-	//cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = strtoul(buf, NULL, 16);
-    cec_usrcmd_set_lang_config(buf, count);   
+    cec_usrcmd_set_lang_config(buf, count);
     return count;
 }
 
@@ -480,28 +464,28 @@ static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute
 {
     int pos=0;
     printk("show_cec_lang_config\n");
-    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);   
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
     return pos;
 }
 
 /*aud_mode attr*/
 static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
 {
-    return 0;    
+    return 0;
 }
-    
+
 static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     //set_disp_mode(buf);
     Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
     if(strncmp(buf, "32k", 3)==0){
-        audio_param->sample_rate = FS_32K; 
+        audio_param->sample_rate = FS_32K;
     }
     else if(strncmp(buf, "44.1k", 5)==0){
-        audio_param->sample_rate = FS_44K1; 
+        audio_param->sample_rate = FS_44K1;
     }
     else if(strncmp(buf, "48k", 3)==0){
-        audio_param->sample_rate = FS_48K; 
+        audio_param->sample_rate = FS_48K;
     }
     else{
         hdmitx_device.force_audio_flag = 0;
@@ -509,12 +493,12 @@ static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr
     }
     audio_param->type = CT_PCM;
     audio_param->channel_num = CC_2CH;
-    audio_param->sample_size = SS_16BITS; 
-    
+    audio_param->sample_size = SS_16BITS;
+
     hdmitx_device.audio_param_update_flag = 1;
     hdmitx_device.force_audio_flag = 1;
-    
-    return count;    
+
+    return count;
 }
 
 /*edid attr*/
@@ -546,17 +530,17 @@ static ssize_t store_edid(struct device * dev, struct device_attribute *attr, co
             printk("\n");
         }
     }
-    return 16;    
+    return 16;
 }
 
 /*config attr*/
 static ssize_t show_config(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int pos=0;
     pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
-    return pos;    
+    return pos;
 }
-    
+
 static ssize_t store_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     if(strncmp(buf, "force", 5)==0){
@@ -567,14 +551,14 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
     }
     else if(strncmp(buf, "vdacoff", 7)==0){
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);    
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);
         }
     }
     else if(strncmp(buf, "powermode", 9)==0){
         int tmp;
         tmp = simple_strtoul(buf+9,NULL,10);
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, tmp); 
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, tmp);
             printk("hdmi: set powermode %d\n", tmp);
         }
     }
@@ -591,7 +575,7 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
             hdmi_set_3d(&hdmitx_device, 6, 0);
         }
         else if(strncmp(buf+2, "lr", 2)==0){
-            int sub_sample_mode=0; 
+            int sub_sample_mode=0;
             if(buf[2])
                 sub_sample_mode = simple_strtoul(buf+2,NULL,10);
             hdmi_set_3d(&hdmitx_device, 8, sub_sample_mode); //side by side
@@ -605,22 +589,22 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
             hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_OFF);
         }
         else if(buf[5] == '1') {
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_ON); 
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_ON);
         }
     }
-    return 16;    
+    return 16;
 }
-  
-    
+
+
 static ssize_t store_dbg(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     hdmitx_device.HWOp.DebugFun(&hdmitx_device, buf);
-    return 16;    
+    return 16;
 }
 
 /**/
 static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int i,pos=0;
     char* disp_mode_t[]={"480i","480p","576i","576p","720p","1080i","1080p","720p50hz","1080i50hz","1080p50hz","1080p24hz","4k2k30hz","4k2k25hz","4k2k24hz","4k2ksmpte",NULL};
     char* native_disp_mode = hdmitx_edid_get_native_VIC(&hdmitx_device);
@@ -642,13 +626,13 @@ static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr,
             }
         }
     }
-    return pos;    
+    return pos;
 }
 
 
 /**/
 static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int i,pos=0;
     int j=0;
     char* disp_mode_t[]={"480i","480p","576i","576p","720p","1080i","1080p","720p50hz","1080i50hz","1080p50hz","1080p24hz","4k2k30hz","4k2k25hz","4k2k24hz","4k2ksmpte",NULL};
@@ -676,14 +660,14 @@ static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *at
     }
     pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
 
-    return pos;    
+    return pos;
 }
 
 /**/
 static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int i,pos=0, j;
-    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS_ATRAC", 
+    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS_ATRAC",
 				"OneBitAudio", "Dobly_Digital+", "DTS-HD", "MAT", "DST", "WMA_Pro", "Reserved", NULL};
     const char* aud_sampling_frequency[] = {"ReferToStreamHeader", "32", "44.1", "48", "88.2", "96", "176.4", "192", NULL};
     const char* aud_sample_size[] = {"ReferToStreamHeader", "16", "20", "24", NULL};
@@ -691,7 +675,7 @@ static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr,
     rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
     pos += snprintf(buf + pos, PAGE_SIZE, "CodingType, MaxChannels, SamplingFrequency, SampleSize\n");
     for(i = 0; i< pRXCap->AUD_count; i++) {
-        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code], 
+        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code],
 			pRXCap->RxAudioCap[i].channel_num_max + 1);
         for(j = 0; j < 7; j++) {
             if(pRXCap->RxAudioCap[i].freq_cc & (1 << j))
@@ -718,22 +702,22 @@ static ssize_t show_aud_ch(struct device * dev, struct device_attribute *attr, c
 static ssize_t store_aud_ch(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     if(strncmp(buf, "6ch", 3) == 0){
-        hdmi_ch = 5; 
+        hdmi_ch = 5;
     }
     else if(strncmp(buf, "8ch", 3) == 0){
-        hdmi_ch = 7; 
+        hdmi_ch = 7;
     }
     else if(strncmp(buf, "2ch", 3) == 0){
-        hdmi_ch = 1; 
+        hdmi_ch = 1;
     }
     else{
         return count;
     }
-    
+
     hdmitx_device.audio_param_update_flag = 1;
     hdmitx_device.force_audio_flag = 1;
 
-    return count;    
+    return count;
 }
 
 static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *attr, char * buf)
@@ -760,10 +744,10 @@ static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *
 }
 
 static ssize_t show_hpd_state(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int pos=0;
     pos += snprintf(buf+pos, PAGE_SIZE,"%d", hdmitx_device.hpd_state);
-    return pos;    
+    return pos;
 }
 
 static unsigned char* hdmi_log_buf=NULL;
@@ -781,7 +765,7 @@ int hdmi_print_buf(char* buf, int len)
     int hdmi_log_rd_pos_;
     if(hdmi_log_buf_size==0)
         return 0;
-    
+
     spin_lock_irqsave(&hdmi_print_lock, flags);
     hdmi_log_rd_pos_=hdmi_log_rd_pos;
     if(hdmi_log_wr_pos>=hdmi_log_rd_pos)
@@ -792,12 +776,12 @@ int hdmi_print_buf(char* buf, int len)
             hdmi_log_buf[hdmi_log_wr_pos-hdmi_log_buf_size]=buf[pos];
         else
             hdmi_log_buf[hdmi_log_wr_pos]=buf[pos];
-    }    
+    }
     if(hdmi_log_wr_pos>=hdmi_log_buf_size)
         hdmi_log_wr_pos-=hdmi_log_buf_size;
     spin_unlock_irqrestore(&hdmi_print_lock, flags);
     return pos;
-    
+
 }
 
 int hdmi_print(int printk_flag, const char *fmt, ...)
@@ -809,14 +793,14 @@ int hdmi_print(int printk_flag, const char *fmt, ...)
     if(printk_flag){
         va_start(args, fmt);
 	      vprintk(fmt, args);
-        va_end(args);	
+        va_end(args);
     }
     if(hdmi_log_buf_size==0)
         return 0;
-        
+
     va_start(args, fmt);
     len += vsnprintf(buf+len, avail-len, fmt, args);
-    va_end(args);	
+    va_end(args);
 
     if ((avail-len) <= 0) {
         buf[PRINT_TEMP_BUF_SIZE - 1] = '\0';
@@ -827,7 +811,7 @@ int hdmi_print(int printk_flag, const char *fmt, ...)
 }
 
 static ssize_t show_log(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     unsigned long flags;
     int read_size=0;
     if(hdmi_log_buf_size==0)
@@ -844,12 +828,12 @@ static ssize_t show_log(struct device * dev, struct device_attribute *attr, char
         read_size=PAGE_SIZE;
     if(read_size>0)
         memcpy(buf, hdmi_log_buf+hdmi_log_rd_pos, read_size);
-    
-    hdmi_log_rd_pos += read_size;  
+
+    hdmi_log_rd_pos += read_size;
     if(hdmi_log_rd_pos>=hdmi_log_buf_size)
         hdmi_log_rd_pos = 0;
     spin_unlock_irqrestore(&hdmi_print_lock, flags);
-    return read_size;    
+    return read_size;
 }
 
 static ssize_t store_log(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
@@ -862,22 +846,22 @@ static ssize_t store_log(struct device * dev, struct device_attribute *attr, con
         if(tmp==0){
             if(hdmi_log_buf){
                 kfree(hdmi_log_buf);
-                hdmi_log_buf=NULL; 
+                hdmi_log_buf=NULL;
                 hdmi_log_buf_size=0;
-                hdmi_log_rd_pos=0;   
-                hdmi_log_wr_pos=0;   
-            }    
-        }    
+                hdmi_log_rd_pos=0;
+                hdmi_log_wr_pos=0;
+            }
+        }
         if((tmp>=1024)&&(hdmi_log_buf==NULL)){
             hdmi_log_buf_size=0;
-            hdmi_log_rd_pos=0;   
-            hdmi_log_wr_pos=0;   
+            hdmi_log_rd_pos=0;
+            hdmi_log_wr_pos=0;
             hdmi_log_buf=kmalloc(tmp, GFP_KERNEL);
             if(hdmi_log_buf){
                 hdmi_log_buf_size=tmp;
                 hdmitx_device.HWOp.DebugFun(&hdmitx_device, "v");
             }
-        }            
+        }
         spin_unlock_irqrestore(&hdmi_print_lock, flags);
         //printk("hdmi_store:set bufsize tmp %d %d\n",tmp, hdmi_log_buf_size);
     }
@@ -901,12 +885,11 @@ static DEVICE_ATTR(hpd_state, S_IWUSR | S_IRUGO, show_hpd_state, NULL);
 static DEVICE_ATTR(log, S_IWUSR | S_IRUGO, show_log, store_log);
 static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
 static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO , show_cec_config, store_cec_config);
-//static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
 static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO , show_cec_lang_config, store_cec_lang_config);
 
 /*****************************
-*    hdmitx display client interface 
-*    
+*    hdmitx display client interface
+*
 ******************************/
 static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
 {
@@ -998,111 +981,111 @@ static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long
 {
     struct snd_pcm_substream *substream =(struct snd_pcm_substream*)para;
     Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
-    
+
     switch (substream->runtime->rate) {
         case 192000:
-            audio_param->sample_rate = FS_192K; 
+            audio_param->sample_rate = FS_192K;
             break;
         case 176400:
-            audio_param->sample_rate = FS_176K4; 
+            audio_param->sample_rate = FS_176K4;
             break;
         case 96000:
-            audio_param->sample_rate = FS_96K; 
+            audio_param->sample_rate = FS_96K;
             break;
         case 88200:
-            audio_param->sample_rate = FS_88K2; 
+            audio_param->sample_rate = FS_88K2;
             break;
         case 48000:
-            audio_param->sample_rate = FS_48K; 
+            audio_param->sample_rate = FS_48K;
             break;
         case 44100:
-            audio_param->sample_rate = FS_44K1; 
+            audio_param->sample_rate = FS_44K1;
             break;
         case 32000:
-            audio_param->sample_rate = FS_32K; 
+            audio_param->sample_rate = FS_32K;
             break;
         default:
             printk("HDMI: unknown audio frequence\n");
             break;
     }
     hdmi_print(1, "HDMI: aout notify rate %d\n", substream->runtime->rate);
-    
+
     switch (cmd){
     case AOUT_EVENT_IEC_60958_PCM:
         audio_param->type = CT_PCM;
-        audio_param->sample_size = SS_16BITS;     
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format PCM\n");
         break;
     case AOUT_EVENT_RAWDATA_AC_3:
         audio_param->type = CT_AC_3;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format AC-3\n");
         break;
     case AOUT_EVENT_RAWDATA_MPEG1:
         audio_param->type = CT_MPEG1;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format MPEG1(Layer1 2)\n");
         break;
     case AOUT_EVENT_RAWDATA_MP3:
         audio_param->type = CT_MP3;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format MP3(MPEG1 Layer3)\n");
         break;
     case AOUT_EVENT_RAWDATA_MPEG2:
         audio_param->type = CT_MPEG2;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format MPEG2\n");
         break;
     case AOUT_EVENT_RAWDATA_AAC:
         audio_param->type = CT_AAC;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format AAC\n");
         break;
     case AOUT_EVENT_RAWDATA_DTS:
         audio_param->type = CT_DTS;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format DTS\n");
         break;
     case AOUT_EVENT_RAWDATA_ATRAC:
         audio_param->type = CT_ATRAC;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format ATRAC\n");
         break;
     case AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO:
         audio_param->type = CT_ONE_BIT_AUDIO;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format One Bit Audio\n");
         break;
     case AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS:
         audio_param->type = CT_DOLBY_D;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         //audio_param->sample_rate = FS_48K;//192K;      // FS_48K;       //
         hdmi_print(1, "HDMI: aout notify format Dobly Digital +\n");
         printk("audio sample_rate: %d\n", substream->runtime->rate);
         break;
     case AOUT_EVENT_RAWDATA_DTS_HD:
         audio_param->type = CT_DTS_HD;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format DTS-HD\n");
         break;
     case AOUT_EVENT_RAWDATA_MAT_MLP:
         audio_param->type = CT_MAT;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format MAT(MLP)\n");
         break;
     case AOUT_EVENT_RAWDATA_DST:
         audio_param->type = CT_DST;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format DST\n");
         break;
     case AOUT_EVENT_RAWDATA_WMA_PRO:
         audio_param->type = CT_WMA;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         hdmi_print(1, "HDMI: aout notify format WMA Pro\n");
         break;
     default:
         break;
-    }    
+    }
 
     audio_param->channel_num = substream->runtime->channels - 1;
 
@@ -1142,7 +1125,7 @@ static int hdmi_task_monitor_handle(void *data)
     return 0;
 }
 
-static int hdmi_task_handle(void *data) 
+static int hdmi_task_handle(void *data)
 {
     extern void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t*);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)data;
@@ -1157,28 +1140,28 @@ static int hdmi_task_handle(void *data)
 
     if(hdmitx_device->HWOp.Cntl){
         if(init_flag&INIT_FLAG_VDACOFF){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);    
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);
         }
         if(init_powermode&0x80){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, init_powermode&0x1f);    
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, init_powermode&0x1f);
         }
     }
     if(init_flag&INIT_FLAG_POWERDOWN){
         hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //power down
         hdmitx_device->unplug_powerdown=1;
         if(hdmitx_device->HWOp.Cntl){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);    
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
         }
     }
     else{
         if(hdmitx_device->HWOp.Cntl){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);    
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);
         }
     }
     if(hdmitx_device->HWOp.Cntl){
         hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_IP_INTR_MASN_RST, 0);
     }
-    
+
     HDMI_DEBUG();
 
     while (hdmitx_device->hpd_event != 0xff)
@@ -1199,7 +1182,7 @@ static int hdmi_task_handle(void *data)
                 hdmitx_device->hpd_event = 1;
             }
         }
-        
+
         if((!hdmi_audio_off_flag)&&(hdmitx_device->audio_param_update_flag))//todo &&
             //((hdmitx_device->cur_VIC != HDMI_Unkown)||(hdmitx_device->force_audio_flag))){
                 {
@@ -1207,7 +1190,7 @@ static int hdmi_task_handle(void *data)
             hdmitx_device->audio_param_update_flag = 0;
             hdmi_print(1, "HDMI: set audio param\n");
         }
-        
+
         if(hdmitx_device->hpd_state == 0) {
             hdmitx_device->HWOp.Cntl(hdmitx_device, HMDITX_PHY_SUSPEND, 0);
         }
@@ -1223,18 +1206,16 @@ static int hdmi_task_handle(void *data)
                 hdmitx_edid_parse(hdmitx_device);
                 hdmitx_device->tv_no_edid = 0;
                 set_disp_mode_auto();
-
-				switch_set_state(&sdev, 1);
-                cec_node_init(hdmitx_device);
-            }    
+            }
             else{
                 hdmi_print(1,"HDMI: EDID Bad\n");
                 hdmitx_device->tv_no_edid = 1;
                 set_disp_mode_auto();
-                switch_set_state(&sdev, 1);
-                printk("test:aml_read_reg32(P_AO_DEBUG_REG0)%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
-                cec_node_init(hdmitx_device);
             }
+
+            switch_set_state(&sdev, 1);
+            cec_node_init(hdmitx_device);
+
             if(hdmitx_device->hpd_event ==1)
                 hdmitx_device->hpd_event = 0;
         }
@@ -1251,11 +1232,10 @@ static int hdmi_task_handle(void *data)
             hdmitx_edid_clear(hdmitx_device);
             //When unplug hdmi, clear the hdmitx module edid ram and edid buffer.
             hdmitx_edid_ram_buffer_clear(hdmitx_device);
-            cec_node_uninit(hdmitx_device);
             if(hdmitx_device->unplug_powerdown){
                 hdmitx_set_display(hdmitx_device, HDMI_Unkown);
                 if(hdmitx_device->HWOp.Cntl){
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);    
+                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
                 }
             }
             hdmitx_device->cur_VIC = HDMI_Unkown;
@@ -1270,7 +1250,11 @@ static int hdmi_task_handle(void *data)
                 hdmi_hdcp_reset = 1;
             }
             switch_set_state(&hdcp_dev, 0);
-        }    
+#ifdef CONFIG_ARCH_MESON6
+
+            aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear int for cec fiq.
+#endif
+        }
         else{
         }
         msleep(100);
@@ -1307,7 +1291,7 @@ static int hdmi_task_handle(void *data)
                     hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_ON);
                     hdmitx_device->repeater_hdcp_cmd = 0;
                 }
-                
+
                 if(hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, IS_HDCP_ON)){
                     hdmi_authenticated = hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_GET_AUTHENTICATE_STATE, 0);
                     //printk("hdmi_authenticated =%d\n", hdmi_authenticated);
@@ -1316,7 +1300,7 @@ static int hdmi_task_handle(void *data)
                 }
             }
             else
-#endif                
+#endif
             {
 	            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_OFF);
 	            if(hdmi_hdcp_process == 0){    // 0: stop hdcp
@@ -1356,7 +1340,7 @@ static int hdmi_task_handle(void *data)
             hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
             hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, 1);
         }
-        /**/    
+        /**/
 next:
         if(hdmitx_device->HWOp.Cntl(hdmitx_device, IS_HDCP_ON, 0)) {
             msleep(10);
@@ -1385,9 +1369,10 @@ void hdmi_pre_set_change_mode(void)
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_CBUS_RST, 0);
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_IP_SW_RST, TX_SYS_SW_RST);
     //msleep(50);
-//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
-//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
-//    msleep(20);
+    //hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
+    //Don't clear irq for M8 cec tx msg(irq).otherwise broken down when standby.
+    //hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
+    msleep(20);
     printk("%s[%d]\n", __func__, __LINE__);
     hdmitx_device.internal_mode_change = 0;
 }
@@ -1395,8 +1380,8 @@ EXPORT_SYMBOL(hdmi_pre_set_change_mode);
 
 /* Linux */
 /*****************************
-*    hdmitx driver file_operations 
-*    
+*    hdmitx driver file_operations
+*
 ******************************/
 static int amhdmitx_open(struct inode *node, struct file *file)
 {
@@ -1569,7 +1554,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
 
     HDMI_DEBUG();
     pr_dbg("amhdmitx_probe\n");
- 
+
     r = alloc_chrdev_region(&hdmitx_id, 0, HDMI_TX_COUNT, DEVICE_NAME);
     if (r < 0) {
         pr_error("Can't register major for amhdmitx device\n");
@@ -1582,17 +1567,17 @@ static int amhdmitx_probe(struct platform_device *pdev)
         return -1;
         //return PTR_ERR(aoe_class);
     }
-                    
+
     hdmitx_device.unplug_powerdown=0;
     hdmitx_device.vic_count=0;
     hdmitx_device.auth_process_timer=0;
     hdmitx_device.force_audio_flag=0;
     hdmitx_device.tv_cec_support=0;
-    
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
     register_early_suspend(&hdmitx_early_suspend_handler);
 #endif
-    
+
     if((init_flag&INIT_FLAG_POWERDOWN)&&(hpdmode==2)){
         hdmitx_device.mux_hpd_if_pin_high_flag=0;
     }
@@ -1605,7 +1590,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
     cdev_add(&(hdmitx_device.cdev), hdmitx_id, HDMI_TX_COUNT);
 
     //hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, "amhdmitx%d", 0);
-    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27 
+    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27
 
     ret=device_create_file(hdmitx_dev, &dev_attr_disp_mode);
     ret=device_create_file(hdmitx_dev, &dev_attr_aud_mode);
@@ -1622,7 +1607,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
     ret=device_create_file(hdmitx_dev, &dev_attr_cec);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
-    
+
     if (hdmitx_dev == NULL) {
         pr_error("device_create create error\n");
         class_destroy(hdmitx_class);
@@ -1733,10 +1718,10 @@ static int amhdmitx_remove(struct platform_device *pdev)
     }
     hdmitx_device.hpd_event = 0xff;
     kthread_stop(hdmitx_device.task);
-    
-    vout_unregister_client(&hdmitx_notifier_nb_v);    
+
+    vout_unregister_client(&hdmitx_notifier_nb_v);
 #ifdef CONFIG_AM_TV_OUTPUT2
-    vout2_unregister_client(&hdmitx_notifier_nb_v2);    
+    vout2_unregister_client(&hdmitx_notifier_nb_v2);
 #endif
 #ifndef DISABLE_AUDIO
 #ifdef CONFIG_SND_AML_SOC
@@ -1843,7 +1828,7 @@ static int  __init amhdmitx_init(void)
     HDMI_DEBUG();
     if(init_flag&INIT_FLAG_NOT_LOAD)
         return 0;
-        
+
     pr_dbg("amhdmitx_init\n");
     printk("HDMI Ver: %s\n", HDMITX_VER);
     if(hdmi_log_buf_size>0){
@@ -1855,7 +1840,7 @@ static int  __init amhdmitx_init(void)
 
     if (platform_driver_register(&amhdmitx_driver)) {
         pr_error("failed to register amhdmitx module\n");
-#if 0        
+#if 0
         platform_device_del(amhdmi_tx_device);
         platform_device_put(amhdmi_tx_device);
 #endif
@@ -1871,7 +1856,7 @@ static void __exit amhdmitx_exit(void)
 {
     pr_dbg("amhdmitx_exit\n");
     platform_driver_unregister(&amhdmitx_driver);
-//\\    platform_device_unregister(amhdmi_tx_device); 
+//\\    platform_device_unregister(amhdmi_tx_device);
 //\\    amhdmi_tx_device = NULL;
     return ;
 }
@@ -1924,7 +1909,7 @@ static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned o
                 return pToken + 1;
             }
             trans_char_flag = 0;
-        }        
+        }
         if (pToken) {
             *token_len = (unsigned)(buf + offset - pToken);
             *token_offset = offset;
@@ -1939,7 +1924,7 @@ static  int __init hdmitx_boot_para_setup(char *s)
     char *token;
     unsigned token_len, token_offset, offset=0;
     int size=strlen(s);
-    
+
     HDMI_DEBUG();
     do{
         token=next_token_ex(separator, s, size, offset, &token_len, &token_offset);
@@ -1958,10 +1943,10 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 hdmi_pll_mode = 1;
             }
             else if((token_len==7)&& (strncmp(token, "hpdmode", token_len)==0)){
-                hpdmode = simple_strtoul(token+7,NULL,10);   
+                hpdmode = simple_strtoul(token+7,NULL,10);
             }
             else if((token_len==3)&&(strncmp(token, "rgb", 3)==0)){
-                hdmitx_output_rgb();    
+                hdmitx_output_rgb();
             }
             else if(strncmp(token, "audpara", 7)==0){
                 int tmp;
@@ -1974,17 +1959,17 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 tmp = simple_strtoul(token+7,NULL,10);
                 if(tmp>=1024){
                     hdmi_log_buf_size=0;
-                    hdmi_log_rd_pos=0;   
-                    hdmi_log_wr_pos=0;   
+                    hdmi_log_rd_pos=0;
+                    hdmi_log_wr_pos=0;
                     hdmi_log_buf_size=tmp;
                     printk("hdmi: set log buffer size %d\n", tmp);
-                }            
+                }
             }
             else if(strncmp(token, "powermode", 9)==0){
                 int tmp;
                 tmp = simple_strtoul(token+9,NULL,10);
                 init_powermode=tmp|0x80;
-                printk("hdmi: set init powermode %d\n", tmp);                
+                printk("hdmi: set init powermode %d\n", tmp);
             }
             else if(strncmp(token, "audiooff", 8)==0){
                 hdmi_audio_off_flag = 1;
@@ -1992,11 +1977,11 @@ static  int __init hdmitx_boot_para_setup(char *s)
             }
             else if(strncmp(token, "prbs", 4)==0){
                 hdmi_prbs_mode = simple_strtoul(token+4,NULL,16);
-                printk("hdmi, set prbs mode as %x always\n", hdmi_prbs_mode);    
+                printk("hdmi, set prbs mode as %x always\n", hdmi_prbs_mode);
             }
             else if(strncmp(token, "480p_clk", 8)==0){
                 hdmi_480p_force_clk = simple_strtoul(token+8,NULL,10);
-                printk("hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);    
+                printk("hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);
             }
             else if(strncmp(token, "cec", 3)==0) {
                 unsigned int list = simple_strtoul(token+3,NULL,16);
@@ -2012,7 +1997,7 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 printk("HDMI aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
                 printk("HDMI hdmi_cec_func_config:0x%x\n",hdmitx_device.cec_func_config);
             }
-        }    
+        }
         offset=token_offset;
     }while(token);
     return 0;
@@ -2028,17 +2013,17 @@ unsigned char get_hdmi_tx_state(unsigned char type)
         return hdmitx_device.hpd_state;
     }
     else if(type == HDMI_TX_STATE_HDCP_AUTH){ //hdcp
-        return hdmi_authenticated;    
+        return hdmi_authenticated;
     }
     else if(type == HDMI_TX_STATE_HDCP_CMD_DONE){
         if(hdmitx_device.repeater_hdcp_cmd == 0){
-            return 1;  
+            return 1;
         }
         else{
             return 0;
-        }  
+        }
     }
-    
+
 }
 
 #define HDMI_TX_HDCP_MODE_NONE_REPEATER     0
@@ -2056,8 +2041,9 @@ void hdmi_repeater_enable_hdcp(unsigned char enable)
     else{
         hdmitx_device.repeater_hdcp_cmd = 2;
     }
-    
+
 }
+#endif            
 
 __setup("hdmitx=",hdmitx_boot_para_setup);
 
@@ -2079,4 +2065,3 @@ module_param(hdmi_hdcp_process, int, 0664);
 MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
 module_param(hdmi_output_force, int, 0664);
 
-#endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index aef299fbbe4c..360af7d62798 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -41,6 +41,7 @@
 #include <linux/spinlock.h>
 #include <linux/spinlock_types.h>
 #include <linux/switch.h>
+#include <linux/workqueue.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -53,61 +54,65 @@
 #include "hdmi_tx_module.h"
 #include "hdmi_info_global.h"
 #include "hdmi_tx_cec.h"
+#include "hdmi_parameter.h"
 
-//static void remote_cec_tasklet(unsigned long);
-//static int REMOTE_CEC_IRQ = INT_REMOTE;
-//DECLARE_TASKLET_DISABLED(tasklet_cec, remote_cec_tasklet, 0);
 static hdmitx_dev_t *hdmitx_device = NULL;
 struct input_dev *remote_cec_dev;
 DEFINE_SPINLOCK(cec_input_key);
-DEFINE_SPINLOCK(cec_rx_lock);
-DEFINE_SPINLOCK(cec_tx_lock);
-DEFINE_SPINLOCK(cec_init_lock); 
+DEFINE_SPINLOCK(cec_init_lock);
+static DEFINE_MUTEX(cec_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(cec_key_poll);
 
-//#define _RX_DATA_BUF_SIZE_ 6
-
 /* global variables */
 static	unsigned char    gbl_msg[MAX_MSG];
 cec_global_info_t cec_global_info;
 unsigned char cec_power_flag = 0;
-unsigned char cec_tx_flag = 0;
-unsigned char cec_rx_flag = 0;
 EXPORT_SYMBOL(cec_power_flag);
 unsigned char rc_long_press_pwr_key = 0;
 EXPORT_SYMBOL(rc_long_press_pwr_key);
-static bool cec_msg_dbg_en = 0; 
-static unsigned char test_buf[128] = { 0 };
+static int cec_msg_dbg_en = 0;
 static int cec_fiq_flag = 0;
 static void cec_gpi_receive_bits(void);
+static int cec_repeat_flag = 0;
+static unsigned int cec_init_ready_flag = 0;
+static int repeat;
+static int cec_ll_tx_polling(const unsigned char *msg, unsigned char len);
+
+/**************************************************
+ *                  cec rx work queue             *
+ *                                                *
+ **************************************************/
+
+#define CEC_WQ  0
+struct work_struct cec_wq_func;
+void cec_do_work(unsigned long data);
+
+void cec_do_work(unsigned long data){
+    //cec_isr_post_process();
+}
+#if CEC_WQ
+struct workqueue_struct *cec_wq;
+#endif
 
 ssize_t	cec_lang_config_state(struct switch_dev *sdev, char *buf){
     int pos=0;
-    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff, 
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff,
                                                   (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
                                                   (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 0) & 0xff);
-    return pos;  
+    return pos;
 };
 
 struct switch_dev lang_dev = {	// android ics switch device
 	.name = "lang_config",
 	.print_state = cec_lang_config_state,
-	};	
+	};
 EXPORT_SYMBOL(lang_dev);
 
-static struct semaphore  tv_cec_sema;
-
 static DEFINE_SPINLOCK(p_tx_list_lock);
-//static DEFINE_SPINLOCK(cec_tx_lock);
-
 static unsigned long cec_tx_list_flags;
-//static unsigned long cec_tx_flags;
 static unsigned int tx_msg_cnt = 0;
-
 static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
 
-//static tv_cec_polling_state_e cec_polling_state = TV_CEC_POLLING_OFF;
-
 unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
                                   (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
                                   (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
@@ -121,104 +126,17 @@ static unsigned char * osd_name = "Amlogic MBox";
 static unsigned int vendor_id = 0x00;
 
 cec_rx_msg_buf_t cec_rx_msg_buf;
-
 static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
+#ifdef CONFIG_ARCH_MESON6
 static void cec_gpi_init(void);
-
-//static unsigned char dev = 0;
+#endif
 static unsigned char cec_init_flag = 0;
-static unsigned char cec_mutex_flag = 0;
-
-
-//static unsigned int hdmi_rd_reg(unsigned long addr);
-//static void hdmi_wr_reg(unsigned long addr, unsigned long data);
-
-void cec_test_function(unsigned char* arg, unsigned char arg_cnt)
-{
-//    int i;
-//    char buf[512];
-//
-//    switch (arg[0]) {
-//    case 0x0:
-//        cec_usrcmd_parse_all_dev_online();
-//        break;
-//    case 0x2:
-//        cec_usrcmd_get_audio_status(arg[1]);
-//        break;
-//    case 0x3:
-//        cec_usrcmd_get_deck_status(arg[1]);
-//        break;
-//    case 0x4:
-//        cec_usrcmd_get_device_power_status(arg[1]);
-//        break;
-//    case 0x5:
-//        cec_usrcmd_get_device_vendor_id(arg[1]);
-//        break;
-//    case 0x6:
-//        cec_usrcmd_get_osd_name(arg[1]);
-//        break;
-//    case 0x7:
-//        cec_usrcmd_get_physical_address(arg[1]);
-//        break;
-//    case 0x8:
-//        cec_usrcmd_get_system_audio_mode_status(arg[1]);
-//        break;
-//    case 0x9:
-//        cec_usrcmd_get_tuner_device_status(arg[1]);
-//        break;
-//    case 0xa:
-//        cec_usrcmd_set_deck_cnt_mode(arg[1], arg[2]);
-//        break;
-//    case 0xc:
-//        cec_usrcmd_set_imageview_on(arg[1]);
-//        break;
-//    case 0xd:
-//        cec_usrcmd_set_play_mode(arg[1], arg[2]);
-//        break;
-//    case 0xe:
-//        cec_usrcmd_get_menu_state(arg[1]);
-//        break;
-//    case 0xf:
-//        cec_usrcmd_set_menu_state(arg[1], arg[2]);
-//        break;
-//    case 0x10:
-//        cec_usrcmd_get_global_info(buf);
-//        break;
-//    case 0x11:
-//        cec_usrcmd_get_menu_language(arg[1]);
-//        break;
-//    case 0x12:
-//        cec_usrcmd_set_menu_language(arg[1], arg[2]);
-//        break;
-//    case 0x13:
-//        cec_usrcmd_get_active_source();
-//        break;
-//    case 0x14:
-//        cec_usrcmd_set_active_source();
-//        break;
-//    case 0x15:
-//        cec_usrcmd_set_deactive_source(arg[1]);
-//        break;
-//    case 0x17:
-//        cec_usrcmd_set_report_physical_address(arg[1], arg[2], arg[3], arg[4]);
-//        break;
-//    case 0x18:
-//    	{int i = 0;
-//    	cec_polling_online_dev(arg[1], &i);
-//    	}
-//    	break;
-//    default:
-//        break;
-//    }
-}
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend hdmitx_cec_early_suspend_handler;
 static void hdmitx_cec_early_suspend(struct early_suspend *h)
 {
-//    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
-    //cec_node_uninit((hdmitx_dev_t *)h->param);
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         cec_menu_status_smp(DEVICE_MENU_INACTIVE);
         cec_inactive_source();
@@ -233,8 +151,7 @@ static void hdmitx_cec_early_suspend(struct early_suspend *h)
 
 static void hdmitx_cec_late_resume(struct early_suspend *h)
 {
-//    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
-    //cec_node_init((hdmitx_dev_t *)h->param);
+    cec_hw_reset();//for M8 CEC standby.
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
 		cec_imageview_on_smp();
 		cec_active_source_smp();
@@ -247,32 +164,6 @@ static void hdmitx_cec_late_resume(struct early_suspend *h)
 
 #endif
 
-/***************************** cec low level code *****************************/
-/*
-static unsigned int cec_get_ms_tick(void)
-{
-    unsigned int ret = 0;
-    struct timeval cec_tick;
-    do_gettimeofday(&cec_tick);
-    ret = cec_tick.tv_sec * 1000 + cec_tick.tv_usec / 1000;
-
-    return ret;
-}
-*/
-/*
-static unsigned int cec_get_ms_tick_interval(unsigned int last_tick)
-{
-    unsigned int ret = 0;
-    unsigned int tick = 0;
-    struct timeval cec_tick;
-    do_gettimeofday(&cec_tick);
-    tick = cec_tick.tv_sec * 1000 + cec_tick.tv_usec / 1000;
-
-    if (last_tick < tick) ret = tick - last_tick;
-    else ret = ((unsigned int)(-1) - last_tick) + tick;
-    return ret;
-}
-*/
 
 int cec_ll_rx( unsigned char *msg, unsigned char *len)
 {
@@ -284,14 +175,20 @@ int cec_ll_rx( unsigned char *msg, unsigned char *len)
     unsigned char n;
     unsigned char *msg_start = msg;
     int rx_msg_length;
-    
+#ifdef CONFIG_ARCH_MESON6
+    printk("cec irq status: rx: 0x%x; tx: 0x%x\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS), hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS));
     if(RX_DONE != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS)){
         hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        //hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD, RX_DISABLE);
         hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
         return -1;
     }
-    
+
+    if(1 != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_NUM_MSG)){
+        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+
     rx_msg_length = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_MSG_LENGTH) + 1;
 
     hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
@@ -304,9 +201,36 @@ int cec_ll_rx( unsigned char *msg, unsigned char *len)
     *len = rx_msg_length;
     rx_status = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS);
 
-    //hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD, RX_DISABLE);
 
     hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+
+    if(RX_DONE != aocec_rd_reg(CEC_RX_MSG_STATUS)){
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+    if(1 != aocec_rd_reg(CEC_RX_NUM_MSG)){
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+    rx_msg_length = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
+
+    aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+
+    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
+        data = aocec_rd_reg(CEC_RX_MSG_0_HEADER +i);
+        *msg = data;
+        msg++;
+    }
+    *len = rx_msg_length;
+    rx_status = aocec_rd_reg(CEC_RX_MSG_STATUS);
+
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
+#endif
     if(cec_msg_dbg_en == 1){
         pos = 0;
         pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
@@ -325,11 +249,7 @@ void cec_isr_post_process(void)
     /* isr post process */
     while(cec_rx_msg_buf.rx_read_pos != cec_rx_msg_buf.rx_write_pos) {
         cec_handle_message(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_read_pos]));
-        if (cec_rx_msg_buf.rx_read_pos == cec_rx_msg_buf.rx_buf_size - 1) {
-            cec_rx_msg_buf.rx_read_pos = 0;
-        } else {
-            cec_rx_msg_buf.rx_read_pos++;
-        }
+        (cec_rx_msg_buf.rx_read_pos == cec_rx_msg_buf.rx_buf_size - 1) ? (cec_rx_msg_buf.rx_read_pos = 0) : (cec_rx_msg_buf.rx_read_pos++);
     }
 }
 
@@ -337,25 +257,47 @@ void cec_usr_cmd_post_process(void)
 {
     cec_tx_message_list_t *p, *ptmp;
     /* usr command post process */
-    //spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
-
     list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list) {
         cec_ll_tx(p->msg, p->length);
         unregister_cec_tx_msg(p);
     }
 }
-
 #if 0
 static int detect_tv_support_cec(unsigned addr)
 {
     unsigned int ret = 0;
     unsigned char msg[1];
     msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
-    ret = cec_ll_tx(msg, 1);
+    ret = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
     printk("CEC: tv%shave CEC feature\n", ret ? " " : " don\'t ");
     return (hdmitx_device->tv_cec_support = ret);
 }
 #endif
+#ifdef CONFIG_ARCH_MESON8
+//--------------------------------------------------------------------------
+// AO CEC0 config
+//--------------------------------------------------------------------------
+static void ao_cec_init(void)
+{
+    unsigned long data32;
+    // Assert SW reset AO_CEC
+    data32  = 0;
+    data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, data32);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    // Enable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+
+    // Device 0 config
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+}
+#endif
 
 void cec_node_init(hdmitx_dev_t* hdmitx_device)
 {
@@ -367,12 +309,12 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
                                                     CEC_PLAYBACK_DEVICE_3_ADDR,
                                                    };
 
-    //unsigned long cec_init_flags;
-    cec_tx_flag = 1;
-    cec_rx_flag = 1;
+    unsigned long cec_phy_addr;
     cec_power_flag = 1;
-    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
-        printk("CEC not ready\n");
+    //if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+    if((cec_init_ready_flag == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+        printk("CEC not ready,cec_init_ready:0x%x;hpd_state:0x%x\n",hdmitx_device->cec_init_ready, hdmitx_device->hpd_state);
+        printk("cec_init_ready_flag:0x%x\n", cec_init_ready_flag);
         return;
     }
     else {
@@ -386,114 +328,110 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
         printk("hdmitx: cec: no valid cec physical address\n");
         return ;
     }
+#if 1       //todo
     if(hdmitx_device->config_data.vend_data)
         vend_data = hdmitx_device->config_data.vend_data;
     if((vend_data) && (vend_data->cec_osd_string)) {
         i = strlen(vend_data->cec_osd_string);
-        if(i > 14) 
+        if(i > 14)
             vend_data->cec_osd_string[14] = '\0';   // OSD string length must be less than 14 bytes
         osd_name = vend_data->cec_osd_string;
     }
     if((vend_data) && (vend_data->vendor_id)) {
         vendor_id = (vend_data->vendor_id ) & 0xffffff;
     }
-
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1); 
-#if 0
-    //Init GPIOx_27 IN for HDMI CEC arbitration
-    //Disable I2C_SDA_B:reg5[31]
-    //Disable I2C_SDA_SLAVE:reg5[29]
-    //Enable GPIOx_27 IN:0x2018[27]
-    //GPIOx_27 IN:0x201a[27]
-    aml_write_reg32(P_PERIPHS_PIN_MUX_5, aml_read_reg32(P_PERIPHS_PIN_MUX_5) & (~(1 << 31)));
-    aml_write_reg32(P_PERIPHS_PIN_MUX_5, aml_read_reg32(P_PERIPHS_PIN_MUX_5) & (~(1 << 29))); 
-    aml_write_reg32(P_PREG_PAD_GPIO4_EN_N, aml_read_reg32(P_PREG_PAD_GPIO4_EN_N) | (1 << 27));
 #endif
+#ifdef CONFIG_ARCH_MESON6
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
     // Clear CEC Int. state and set CEC Int. mask
-////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
-////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
+
+#endif
+#ifdef CONFIG_ARCH_MESON8
+#if 1           // Please match with H/W cec config
+// GPIOAO_12
+    aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 0, 12, 1);       // disable AO_12 internal pull-up   //fe60002c
+    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);      // AO_CEC pinmux                    //fe600014
+    ao_cec_init();
+#else
+// GPIOH_3
+    aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG1, 0, 19, 1);    // disable gpioh_3 internal pull-up
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 23, 1);      // gpioh_3 cec pinmux
+#endif
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+#endif
+    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
 
-    
-	for(i = 0; i < 3; i++){ 
-	    //hdmitx_cec_dbg_print("CEC: start poll dev\n");  	
+
+	for(i = 0; i < 3; i++){
+	    printk("CEC: start poll dev\n");
 		cec_polling_online_dev(player_dev[i], &bool);
 		hdmitx_cec_dbg_print("CEC: player_dev[%d]:0x%x\n", i, player_dev[i]);
 		//hdmitx_cec_dbg_print("CEC: end poll dev\n");
 		if(bool == 0){  // 0 means that no any respond
-		    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;	
+            aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+		    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
             cec_global_info.my_node_index = player_dev[i];
             aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
             cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
             // Set Physical address
-            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = ( ((hdmitx_device->hdmi_info.vsdb_phy_addr.a)<<12)
-            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.b)<< 8)
-            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.c)<< 4)
-            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.d)    )
-            	    												);
-            	    												
+            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
+
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
-                        	    												
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF;
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;
+
+            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
             cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
-            //hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
+#ifdef CONFIG_ARCH_MESON6
             hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-		    
+#endif
+#ifdef CONFIG_ARCH_MESON8
+            aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
+#endif
      		hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", player_dev[i]);
-            
-            //cec_hw_reset();
-            //spin_lock_irqsave(&cec_init_lock,cec_init_flags);
-            hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
-            
-            cec_report_physical_address_smp();
-            
-
 
+            hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
+        	if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
+        	    break;
+            msleep(100);
+			cec_report_physical_address_smp();
+            msleep(150);
             cec_device_vendor_id((cec_rx_message_t*)0);
-            
-            cec_imageview_on_smp();
-            msleep(200);
+
+            msleep(150);
             cec_imageview_on_smp();
+            msleep(100);
 
             // here, we need to detect whether TV is supporting the CEC function
             // if not, jump out to save system time
-            //if(!detect_tv_support_cec(player_dev[i])) 
+            //if(!detect_tv_support_cec(player_dev[i])) {
+            //    printk("HDMI CEC: No TV detected.\n");
             //    break;
+            //}
             cec_get_menu_language_smp();
-            
+            msleep(350);
+
             cec_active_source_smp();
-            //cec_usrcmd_set_report_physical_address();
-
-            //cec_report_physical_address_smp();
-
-            //cec_get_menu_language_smp();
-            
-            //cec_device_vendor_id((cec_rx_message_t*)0);
-            
-            //cec_set_osd_name_init();
-            
-            //cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-            
-            //msleep(200);
-            //cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV again
-            //msleep(200);
-            //hdmitx_cec_dbg_print("CEC: Set physical address: %x\n", cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4);
-            
-            //cec_usrcmd_set_active_source(); 
-            
-            //spin_unlock_irqrestore(&cec_init_lock,cec_init_flags);
-            //cec_active_source(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_read_pos]));    
-            
+            msleep(120);
+
             cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-            
+            msleep(100);
+
             cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
             cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
             break;
 		}
-	}	
+	}
 	if(bool == 1)
 		hdmitx_cec_dbg_print("CEC: Can't get a valid logical address\n");
 }
@@ -504,12 +442,7 @@ void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
        return ;
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
     cec_power_flag = 0;
-    cec_tx_flag = 0;
-    cec_rx_flag = 0;
     hdmitx_cec_dbg_print("CEC: cec node uninit!\n");
-    //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
-    //free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
 }
 
@@ -517,12 +450,6 @@ static int cec_task(void *data)
 {
 	extern void dump_hdmi_cec_reg(void);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
-
-//    hdmitx_cec_dbg_print("CEC: Physical Address [A]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.a);
-//    hdmitx_cec_dbg_print("CEC: Physical Address [B]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.b);
-//    hdmitx_cec_dbg_print("CEC: Physical Address [C]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.c);
-//    hdmitx_cec_dbg_print("CEC: Physical Address [D]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.d);
-
     cec_init_flag = 1;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -534,25 +461,21 @@ static int cec_task(void *data)
     register_early_suspend(&hdmitx_cec_early_suspend_handler);
 #endif
 
-    //cec_node_init(hdmitx_device);
-    
-//    dump_hdmi_cec_reg();
-    
     // Get logical address
 
     hdmitx_cec_dbg_print("CEC: CEC task process\n");
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
         msleep(10000);
+#ifdef CONFIG_ARCH_MESON6
         cec_gpi_init();
+#endif
+		printk("cec_func_config:0x%x\n", hdmitx_device->cec_func_config);
         cec_node_init(hdmitx_device);
     }
     while (1) {
-        if(down_interruptible(&tv_cec_sema))
-           continue; 
-                
+        msleep(5);
         cec_isr_post_process();
-        cec_usr_cmd_post_process();
-        //\\cec_timer_post_process();
+        //cec_usr_cmd_post_process();
     }
 
     return 0;
@@ -566,26 +489,17 @@ static int cec_task(void *data)
 void register_cec_rx_msg(unsigned char *msg, unsigned char len )
 {
     unsigned long flags;
-    //    hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);  
+    spin_lock_irqsave(&cec_input_key,flags);
     memset((void*)(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
     memcpy(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
 
     cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
     cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].msg_length = len;
-    
-    //spin_lock(&cec_input_key);
-    spin_lock_irqsave(&cec_input_key,flags);
+
     cec_input_handle_message();
-    spin_unlock_irqrestore(&cec_input_key,flags);
-    //spin_unlock(&cec_input_key);    
-    //wake_up_interruptible(&cec_key_poll);
-    if (cec_rx_msg_buf.rx_write_pos == cec_rx_msg_buf.rx_buf_size - 1) {
-        cec_rx_msg_buf.rx_write_pos = 0;
-    } else {
-        cec_rx_msg_buf.rx_write_pos++;
-    }
 
-    up(&tv_cec_sema);    
+    (cec_rx_msg_buf.rx_write_pos == cec_rx_msg_buf.rx_buf_size - 1) ? (cec_rx_msg_buf.rx_write_pos = 0) : (cec_rx_msg_buf.rx_write_pos++);
+    spin_unlock_irqrestore(&cec_input_key,flags);
 }
 
 void register_cec_tx_msg(unsigned char *msg, unsigned char len )
@@ -602,146 +516,29 @@ void register_cec_tx_msg(unsigned char *msg, unsigned char len )
         spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
 
         tx_msg_cnt++;
-        up(&tv_cec_sema); 
     }
 }
 void cec_input_handle_message(void)
 {
     unsigned char   opcode;
-    //unsigned char   operand_num;
-    //unsigned char   msg_length;
-    
-//    hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);  
 
-    opcode = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.opcode;   
-    //operand_num = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num;
-    //msg_length  = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].msg_length;
+    opcode = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
 
-    /* process messages from tv polling and cec devices */
-    //hdmitx_cec_dbg_print("----OP code----: %x\n", opcode);
+    /* process key event messages from tv */
     if((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) && cec_power_flag)
     {
         switch (opcode) {
-        /*case CEC_OC_ACTIVE_SOURCE:
-            cec_active_source(pcec_message);
-            break;
-        case CEC_OC_INACTIVE_SOURCE:
-            cec_deactive_source(pcec_message);
-            break;
-        case CEC_OC_CEC_VERSION:
-            cec_report_version(pcec_message);
-            break;
-        case CEC_OC_DECK_STATUS:
-            cec_deck_status(pcec_message);
-            break;
-        case CEC_OC_DEVICE_VENDOR_ID:
-            cec_device_vendor_id(pcec_message);
-            break;
-        case CEC_OC_FEATURE_ABORT:
-            cec_feature_abort(pcec_message);
-            break;
-        case CEC_OC_GET_CEC_VERSION:
-            cec_get_version(pcec_message);
-            break;
-        case CEC_OC_GIVE_DECK_STATUS:
-            cec_give_deck_status(pcec_message);
-            break;
-        case CEC_OC_MENU_STATUS:
-            cec_menu_status(pcec_message);
-            break;
-        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-            cec_report_phy_addr(pcec_message);
-            break;
-        case CEC_OC_REPORT_POWER_STATUS:
-            cec_report_power_status(pcec_message);
-            break;
-        case CEC_OC_SET_OSD_NAME:
-            cec_set_osd_name(pcec_message);
-            break;
-        case CEC_OC_VENDOR_COMMAND_WITH_ID:
-            cec_vendor_cmd_with_id(pcec_message);
-            break;
-        case CEC_OC_SET_MENU_LANGUAGE:
-            cec_set_menu_language(pcec_message);
-            break;
-        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
-            cec_give_physical_address(pcec_message);
-            break;
-        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-            cec_give_device_vendor_id(pcec_message);
-            break;
-        case CEC_OC_GIVE_OSD_NAME:
-            cec_give_osd_name(pcec_message);
-            break;
-        case CEC_OC_STANDBY:
-              hdmitx_cec_dbg_print("----cec_standby-----");
-            cec_standby(pcec_message);
-            break;
-        case CEC_OC_SET_STREAM_PATH:
-            cec_set_stream_path(pcec_message);
-            break;
-        case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            cec_request_active_source(pcec_message);
-            break;
-        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-            cec_give_device_power_status(pcec_message);
-            break;
-            
-         case CEC_OC_STANDBY:
-            if(POWER_ON != cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status)
-                break; 
-            cec_standby_irq();
-            break;
-            */      
         case CEC_OC_USER_CONTROL_PRESSED:
+            // check valid msg
+            {
+                unsigned char opernum;
+                unsigned char follower;
+                opernum  = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num;
+                follower = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
+                if(opernum != 1 || follower == 0xf) break;
+            }
             cec_user_control_pressed_irq();
             break;
-        case CEC_OC_USER_CONTROL_RELEASED:
-            //cec_user_control_released_irq();
-            break; 
-        //case CEC_OC_IMAGE_VIEW_ON:      //not support in source
-        //      cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-        //      break;  
-        case CEC_OC_ROUTING_CHANGE: 
-        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
-        case CEC_OC_CLEAR_ANALOGUE_TIMER:
-        case CEC_OC_CLEAR_DIGITAL_TIMER:
-        case CEC_OC_CLEAR_EXTERNAL_TIMER:
-        case CEC_OC_DECK_CONTROL:
-        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
-        case CEC_OC_MENU_REQUEST:
-        case CEC_OC_SET_OSD_STRING:
-        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
-        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
-        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
-        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:       //not support in source
-        case CEC_OC_TIMER_CLEARED_STATUS:
-        case CEC_OC_TIMER_STATUS:
-        case CEC_OC_TUNER_DEVICE_STATUS:
-        case CEC_OC_TUNER_STEP_DECREMENT:
-        case CEC_OC_TUNER_STEP_INCREMENT:
-        case CEC_OC_VENDOR_COMMAND:
-        case CEC_OC_ROUTING_INFORMATION:
-        case CEC_OC_SELECT_ANALOGUE_SERVICE:
-        case CEC_OC_SELECT_DIGITAL_SERVICE:
-        case CEC_OC_SET_ANALOGUE_TIMER :
-        case CEC_OC_SET_AUDIO_RATE:
-        case CEC_OC_SET_DIGITAL_TIMER:
-        case CEC_OC_SET_EXTERNAL_TIMER:
-        case CEC_OC_PLAY:
-        case CEC_OC_RECORD_OFF:
-        case CEC_OC_RECORD_ON:
-        case CEC_OC_RECORD_STATUS:
-        case CEC_OC_RECORD_TV_SCREEN:
-        case CEC_OC_REPORT_AUDIO_STATUS:
-        case CEC_OC_GET_MENU_LANGUAGE:
-        case CEC_OC_GIVE_AUDIO_STATUS:
-        case CEC_OC_ABORT_MESSAGE:
-            //hdmitx_cec_dbg_print("CEC: not support cmd: %x\n", opcode);
-            break;
         default:
             break;
         }
@@ -762,11 +559,12 @@ void unregister_cec_tx_msg(cec_tx_message_list_t* cec_tx_message_list)
 
 void cec_hw_reset(void)
 {
+#ifdef CONFIG_ARCH_MESON6
     aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
     hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0xc); //[3]cec_creg_sw_rst [2]cec_sys_sw_rst
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x1);
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x1);
-    
+
     //mdelay(10);
     {//Delay some time
     	int i = 10;
@@ -780,6 +578,33 @@ void cec_hw_reset(void)
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
 
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+
+    //unsigned long data32;
+    // Assert SW reset AO_CEC
+    //data32  = 0;
+    //data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    //data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    // Enable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
+
+    //Cec arbitration 3/5/7 bit time set.
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+
+    printk("hw reset :logical addr:0x%x\n", aocec_rd_reg(CEC_LOGICAL_ADDR0));
+
+#endif
 }
 
 unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
@@ -787,6 +612,7 @@ unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
     unsigned char rt = 0;
     unsigned char opcode;
     unsigned char opernum;
+    unsigned char follower;
     if (!pcec_message)
         return rt;
 
@@ -895,34 +721,149 @@ unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
             break;
     }
 
+ // for CTS12.2
+    follower = pcec_message->content.msg.header & 0x0f;
+    switch (opcode) {
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            // broadcast only
+            if(follower != 0xf) rt = 0;
+            break;
+
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_SET_OSD_NAME:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            // directly addressed only
+            if(follower == 0xf) rt = 0;
+            break;
+
+        case CEC_OC_STANDBY:
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+            // both broadcast and directly addressed
+            break;
+
+        default:
+            break;
+    }
+
     if ((rt == 0) & (opcode != 0)){
         hdmirx_cec_dbg_print("CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
     }
-    
-    //?????rt = 1; // temporal
     return rt;
 }
 
-//static char *tx_status[] = {
-//    "TX_IDLE ",
-//    "TX_BUSY ",
-//    "TX_DONE ",
-//    "TX_ERROR",
-//};
+void cec_disable_irq(void)
+{
+#ifdef CONFIG_ARCH_MESON6
+    //Disable irq
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));
+    //Clear the interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    // disable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 0, 3);
+    printk("disable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+#endif
+}
+void cec_enable_irq(void)
+{
+#ifdef CONFIG_ARCH_MESON6
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) & ~(1 << 23));
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+    printk("enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+#endif
+}
 
 static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
 {
-    unsigned int data_msg_num;
     unsigned char rx_msg[MAX_MSG], rx_len;
+    unsigned int intr_stat = 0;
+
+    //cec_disable_irq();
+
+#ifdef CONFIG_ARCH_MESON8
+    intr_stat = aml_read_reg32(P_AO_CEC_INTR_STAT);
+    printk("aocec irq %x\n", intr_stat);
 
-    data_msg_num = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_NUM_MSG);             
-    //cec_ll_rx(rx_msg, &rx_len);
-    if((-1) == cec_ll_rx(rx_msg, &rx_len))
+    if(intr_stat & (1<<1)) { // aocec tx intr
+        tx_irq_handle();
+        //cec_enable_irq();
         return IRQ_HANDLED;
-    register_cec_rx_msg(rx_msg, rx_len);                
+    }
+#endif
+    if((-1) == cec_ll_rx(rx_msg, &rx_len)){
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
+
+#if CEC_WQ
+    queue_work(cec_wq, &cec_wq_func);
+#else
+    schedule_work(&cec_wq_func);
+#endif
 
-//    Clear the interrupt
-//    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) & ~(1 << 23));
+    register_cec_rx_msg(rx_msg, rx_len);
+
+    //cec_enable_irq();
 
     return IRQ_HANDLED;
 }
@@ -944,142 +885,72 @@ unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
 
     return us;
 }
-//
-//static cec_hdmi_port_e cec_find_hdmi_port(unsigned char log_addr)
-//{
-//    cec_hdmi_port_e rt = CEC_HDMI_PORT_UKNOWN;
-//
-//    if ((cec_global_info.dev_mask & (1 << log_addr)) &&
-//            (cec_global_info.cec_node_info[log_addr].phy_addr != 0) &&
-//            (cec_global_info.cec_node_info[log_addr].hdmi_port == CEC_HDMI_PORT_UKNOWN)) {
-//        if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x1000) {
-//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_1;
-//        } else if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x2000) {
-//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_2;
-//        } else if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x3000) {
-//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_3;
-//        }
-//    }
-//
-//    rt = cec_global_info.cec_node_info[log_addr].hdmi_port;
-//
-//    return rt;
-//}
-
 // -------------- command from cec devices ---------------------
 
 void cec_polling_online_dev(int log_addr, int *bool)
 {
-    //int log_addr = 0;
     unsigned long r;
-    unsigned short dev_mask_tmp = 0;
     unsigned char msg[1];
 
-    //for (log_addr = 1; log_addr < CEC_UNREGISTERED_ADDR; log_addr++) {
-        hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG3):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG3));
-        //if(aml_read_reg32(P_AO_DEBUG_REG3) & 0xf){
-        //    *bool = 0;
-        //    cec_global_info.my_node_index = aml_read_reg32(P_AO_DEBUG_REG3) & 0xf;
-        //    return;
-        //}
-        cec_global_info.my_node_index = log_addr;
-        msg[0] = (log_addr<<4) | log_addr;
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
-        hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%lx\n",hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
-        r = cec_ll_tx(msg, 1);
-            
-        if (r == 0) {
-            //dev_mask_tmp |= 1 << log_addr;
-            //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
-            //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-            //cec_global_info.cec_node_info[log_addr].dev_type = CEC_PLAYBACK_DEVICE_TYPE;
-//            cec_find_hdmi_port(log_addr);
-            *bool = 0;
-            //cec_hw_reset();
-            //msleep(200);
-        }else{
-            dev_mask_tmp &= ~(1 << log_addr);
-            memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
-            //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
-            //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);            
-            cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-        	  *bool = 1;
-        }
+    cec_global_info.my_node_index = log_addr;
+    msg[0] = (log_addr<<4) | log_addr;
+#ifdef CONFIG_ARCH_MESON6
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    r = cec_ll_tx(msg, 1);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%lx\n",aocec_rd_reg(CEC_LOGICAL_ADDR0));
+    r = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
+
+#endif
+
+    if (r == 0) {
+        *bool = 0;
+    }else{
+        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
+        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+    	  *bool = 1;
+    }
     if(*bool == 0) {
+#ifdef CONFIG_ARCH_MESON6
         hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
+#endif
     }
     hdmitx_cec_dbg_print("CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
 
-    if (cec_global_info.dev_mask != dev_mask_tmp) {
-        cec_global_info.dev_mask = dev_mask_tmp;
-    }
 }
 
-void cec_report_phy_addr(cec_rx_message_t* pcec_message)
-{
-    //unsigned char index = cec_global_info.my_node_index;
-    ////unsigned char log_addr = pcec_message->content.msg.header >> 4;
-
-    //cec_global_info.dev_mask |= 1 << index;
-    //cec_global_info.cec_node_info[index].dev_type = cec_log_addr_to_dev_type(index);
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DEVICE_TYPE;
-    //memcpy(cec_global_info.cec_node_info[index].osd_name_def, default_osd_name[index], 16);
-    //if ((cec_global_info.cec_node_info[index].real_info_mask & INFO_MASK_OSD_NAME) == 0) {
-    //    memcpy(cec_global_info.cec_node_info[index].osd_name, osd_name_uninit, 16);
-    //}
-    //cec_global_info.cec_node_info[index].log_addr = index;
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_LOGIC_ADDRESS;
-    //cec_global_info.cec_node_info[index].phy_addr.phy_addr_4 = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_PHYSICAL_ADDRESS;
-//
-
-}
-
-void cec_give_physical_address(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-        unsigned char msg[5];
-        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-        msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
-        msg[2] = phy_addr_ab;
-        msg[3] = phy_addr_cd;
-        msg[4] = cec_global_info.cec_node_info[index].log_addr;
-        //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-        //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-        //msg[4] = cec_global_info.cec_node_info[index].log_addr;
-        cec_ll_tx(msg, 5);
-    //}
-//    hdmirx_cec_dbg_print("cec_report_phy_addr: %x\n", cec_global_info.cec_node_info[index].log_addr);
-}
 
 //***************************************************************
 void cec_device_vendor_id(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[5];
-    
+
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_DEVICE_VENDOR_ID;
     msg[2] = (vendor_id >> 16) & 0xff;
     msg[3] = (vendor_id >> 8) & 0xff;
     msg[4] = (vendor_id >> 0) & 0xff;
-    
+
     cec_ll_tx(msg, 5);
 }
 
 void cec_report_power_status(cec_rx_message_t* pcec_message)
 {
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
     unsigned char index = cec_global_info.my_node_index;
-    if (cec_global_info.dev_mask & (1 << index)) {
-        cec_global_info.cec_node_info[index].power_status = pcec_message->content.msg.operands[0];
-        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_POWER_STATUS;
-        hdmirx_cec_dbg_print("cec_report_power_status: %x\n", cec_global_info.cec_node_info[index].power_status);
-    }
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_REPORT_POWER_STATUS;
+    msg[2] = cec_global_info.cec_node_info[index].power_status;
+    cec_ll_tx(msg, 3);
+
 }
 
 void cec_feature_abort(cec_rx_message_t* pcec_message)
@@ -1087,51 +958,40 @@ void cec_feature_abort(cec_rx_message_t* pcec_message)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char opcode = pcec_message->content.msg.opcode;
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-
-    if(opcode != 0xf){
+    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
+    if(dst_log_addr != 0xf){
         unsigned char msg[4];
-        
+
         msg[0] = ((index & 0xf) << 4) | src_log_addr;
         msg[1] = CEC_OC_FEATURE_ABORT;
         msg[2] = opcode;
         msg[3] = CEC_UNRECONIZED_OPCODE;
-        
-        cec_ll_tx(msg, 4);        
+
+        cec_ll_tx(msg, 4);
     }
-    
-    //hdmirx_cec_dbg_print("cec_feature_abort: opcode %x\n", pcec_message->content.msg.opcode);
 }
 
 void cec_report_version(cec_rx_message_t* pcec_message)
-{
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index;   
-    if (cec_global_info.dev_mask & (1 << index)) {
-        cec_global_info.cec_node_info[index].cec_version = pcec_message->content.msg.operands[0];
-        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_CEC_VERSION;
-        hdmirx_cec_dbg_print("cec_report_version: %x\n", cec_global_info.cec_node_info[index].cec_version);
-    }
+{
+    ;//todo
 }
 
 
 void cec_report_physical_address_smp(void)
 {
-    unsigned char msg[5]; 
+    unsigned char msg[5];
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;    
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);     
-    
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
     msg[2] = phy_addr_ab;
     msg[3] = phy_addr_cd;
-    //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-    //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-    msg[4] = cec_global_info.cec_node_info[index].dev_type;                        
-    
+    msg[4] = cec_global_info.cec_node_info[index].dev_type;
+
     cec_ll_tx(msg, 5);
-        
+
 }
 
 void cec_imageview_on_smp(void)
@@ -1139,29 +999,25 @@ void cec_imageview_on_smp(void)
     unsigned char msg[2];
     unsigned char index = cec_global_info.my_node_index;
 
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);   
-    //hdmitx_cec_dbg_print("cec_func_config:0x%x\n",hdmitx_device->cec_func_config);  
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
             msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
             msg[1] = CEC_OC_IMAGE_VIEW_ON;
             cec_ll_tx(msg, 2);
         }
-    }  
+    }
 }
 
 void cec_get_menu_language_smp(void)
 {
     unsigned char msg[2];
     unsigned char index = cec_global_info.my_node_index;
-    
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
 
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_GET_MENU_LANGUAGE;
-    
+
     cec_ll_tx(msg, 2);
-    
+
 }
 
 void cec_menu_status(cec_rx_message_t* pcec_message)
@@ -1171,17 +1027,9 @@ void cec_menu_status(cec_rx_message_t* pcec_message)
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
 
      if(0xf != src_log_addr) {
-            msg[0] = ((index & 0xf) << 4) | src_log_addr;
-            msg[1] = CEC_OC_MENU_STATUS;
-        if((2 == pcec_message->content.msg.operands[0])){    
-            msg[2] = cec_global_info.cec_node_info[index].menu_status;
-        }else if(0 == pcec_message->content.msg.operands[0]){
-            cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
-            msg[2] = DEVICE_MENU_INACTIVE;        
-        }else{
-            cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
-            msg[2] = DEVICE_MENU_ACTIVE; 
-        }
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = cec_global_info.cec_node_info[index].menu_status;
         cec_ll_tx(msg, 3);
     }
 }
@@ -1191,71 +1039,41 @@ void cec_menu_status_smp(cec_device_menu_state_e status)
     unsigned char msg[3];
     unsigned char index = cec_global_info.my_node_index;
 
-    if(status == DEVICE_MENU_ACTIVE){    
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_MENU_STATUS;
+    if(status == DEVICE_MENU_ACTIVE){
         msg[2] = DEVICE_MENU_ACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
     }else{
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = DEVICE_MENU_INACTIVE;        
+        msg[2] = DEVICE_MENU_INACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
     }
     cec_ll_tx(msg, 3);
-    
-    //MSG_P1( index, CEC_TV_ADDR,
-    //        CEC_OC_MENU_STATUS, 
-    //        DEVICE_MENU_ACTIVE
-    //        );
-
-    //register_cec_tx_msg(gbl_msg, 3); 
-
 }
 
-void cec_menu_status_smp_irq(unsigned int status)
+void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
 {
-    unsigned char msg[3];
     unsigned char index = cec_global_info.my_node_index;
 
-    if(status == DEVICE_MENU_ACTIVE){    
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = DEVICE_MENU_ACTIVE;
-    }else{
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = DEVICE_MENU_INACTIVE;        
+    if(1 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }else if(0 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
     }
-    cec_ll_tx(msg, 3);
-    
-    //MSG_P1( index, CEC_TV_ADDR,
-    //        CEC_OC_MENU_STATUS, 
-    //        DEVICE_MENU_ACTIVE
-    //        );
-
-    //register_cec_tx_msg(gbl_msg, 3); 
-
 }
-EXPORT_SYMBOL(cec_menu_status_smp_irq);
 
-void cec_active_source_irq(void)
+void cec_active_source_rx(cec_rx_message_t* pcec_message)
 {
-    unsigned char msg[4];
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
+    unsigned int phy_addr_active;
 
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {    
-            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-            msg[1] = CEC_OC_ACTIVE_SOURCE;
-            msg[2] = phy_addr_ab;
-            msg[3] = phy_addr_cd;
-            //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-            //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-            cec_ll_tx(msg, 4);
-        }
-    }
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 
 void cec_active_source_smp(void)
@@ -1263,114 +1081,87 @@ void cec_active_source_smp(void)
     unsigned char msg[4];
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
 
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {    
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
             msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
             msg[1] = CEC_OC_ACTIVE_SOURCE;
             msg[2] = phy_addr_ab;
             msg[3] = phy_addr_cd;
-            //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-            //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
             cec_ll_tx(msg, 4);
         }
     }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
 }
 void cec_active_source(cec_rx_message_t* pcec_message)
 {
     unsigned char msg[4];
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
     unsigned char index = cec_global_info.my_node_index;
-    //unsigned short phy_addr = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;    
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
 
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-//    if (phy_addr == cec_global_info.cec_node_info[index].phy_addr.phy_addr_4) {
 
-        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-        msg[1] = CEC_OC_ACTIVE_SOURCE;
-        msg[2] = phy_addr_ab;
-        msg[3] = phy_addr_cd;
-        //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-        //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-        cec_ll_tx(msg, 4);
-        
-//        MSG_P2( index, CEC_TV_ADDR, 
-//                CEC_OC_ACTIVE_SOURCE, 
-//                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-//                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
-        
-//        register_cec_tx_msg(gbl_msg, 4);         
-//    }else{
-//        cec_deactive_source(pcec_message);    	
-//    }
-}
-
-//////////////////////////////////
 void cec_set_stream_path(cec_rx_message_t* pcec_message)
 {
-//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned short phy_addr = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
-            
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {    
-        if(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))
-        {    
-            if (phy_addr == cec_global_info.cec_node_info[index].phy_addr.phy_addr_4) {    
-                unsigned char msg[4];
-                msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-                msg[1] = CEC_OC_ACTIVE_SOURCE;
-                msg[2] = phy_addr_ab;
-                msg[3] = phy_addr_cd;
-                //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-                //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-                cec_ll_tx(msg, 4);
-            }
-        }
-    }
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_active_source_smp();
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 void cec_set_system_audio_mode(void)
 {
     unsigned char index = cec_global_info.my_node_index;
 
     MSG_P1( index, CEC_TV_ADDR,
-    //MSG_P1( index, CEC_BROADCAST_ADDR,  
-            CEC_OC_SET_SYSTEM_AUDIO_MODE, 
+            CEC_OC_SET_SYSTEM_AUDIO_MODE,
             cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
             );
-    
-    register_cec_tx_msg(gbl_msg, 3);
+
+    cec_ll_tx(gbl_msg, 3);
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
     else
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;    	      
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
 }
 
 void cec_system_audio_mode_request(void)
 {
     unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF){
-        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST, 
-                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd
+        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                phy_addr_ab,
+                phy_addr_cd
                 );
-        register_cec_tx_msg(gbl_msg, 4);    	
+        cec_ll_tx(gbl_msg, 4);
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
     }
-    else{        
-        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 
-                ); 
-        register_cec_tx_msg(gbl_msg, 2);    	
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF; 
-    }   	      
+    else{
+        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
+                );
+        cec_ll_tx(gbl_msg, 2);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    }
 }
 
 void cec_report_audio_status(void)
@@ -1378,41 +1169,27 @@ void cec_report_audio_status(void)
     unsigned char index = cec_global_info.my_node_index;
 
     MSG_P1( index, CEC_TV_ADDR,
-    //MSG_P1( index, CEC_BROADCAST_ADDR,  
-            CEC_OC_REPORT_AUDIO_STATUS, 
+            CEC_OC_REPORT_AUDIO_STATUS,
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
             );
 
-    register_cec_tx_msg(gbl_msg, 3);   	      
+    cec_ll_tx(gbl_msg, 3);
 }
 void cec_request_active_source(cec_rx_message_t* pcec_message)
 {
     cec_set_stream_path(pcec_message);
 }
 
-void cec_give_device_power_status(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
-
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_REPORT_POWER_STATUS;
-        msg[2] = cec_global_info.cec_node_info[index].power_status;
-        cec_ll_tx(msg, 3);
-    //}
-}
-
 void cec_set_imageview_on_irq(void)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[2];
-    
+
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_IMAGE_VIEW_ON;
 
-    cec_ll_tx(msg, 2);    
+    cec_ll_tx(msg, 2);
 }
 
 void cec_inactive_source(void)
@@ -1420,33 +1197,20 @@ void cec_inactive_source(void)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[4];
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
-        
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_INACTIVE_SOURCE;
 	msg[2] = phy_addr_ab;
 	msg[3] = phy_addr_cd;
 
-    cec_ll_tx(msg, 4);    
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
 }
-void cec_deactive_source(cec_rx_message_t* pcec_message)
-{
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index;    
-    
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-    //    if (cec_global_info.active_log_dev == log_addr) {
-    //    cec_global_info.active_log_dev = 0;
-    //    }
-    //    hdmirx_cec_dbg_print("cec_deactive_source: %x\n", log_addr);
-    //}
-    
-    MSG_P2( index, CEC_TV_ADDR, 
-            CEC_OC_INACTIVE_SOURCE, 
-            cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-            cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
 
-    register_cec_tx_msg(gbl_msg, 4); 
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
+{
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
 }
 
 void cec_get_version(cec_rx_message_t* pcec_message)
@@ -1458,27 +1222,27 @@ void cec_get_version(cec_rx_message_t* pcec_message)
     if (0xf != dest_log_addr) {
         msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
         msg[1] = CEC_OC_CEC_VERSION;
-        msg[2] = CEC_VERSION_13A;
+        msg[2] = CEC_VERSION_14A;
         cec_ll_tx(msg, 3);
     }
 }
 
 void cec_give_deck_status(cec_rx_message_t* pcec_message)
 {
-    unsigned char index = cec_global_info.my_node_index; 
-    MSG_P1( index, CEC_TV_ADDR, 
-            CEC_OC_DECK_STATUS, 
-            0x1a);
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
 
-    register_cec_tx_msg(gbl_msg, 3); 
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_DECK_STATUS;
+    msg[2] = 0x1a;
+    cec_ll_tx(msg, 3);
 }
 
 
 void cec_deck_status(cec_rx_message_t* pcec_message)
 {
-//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index; 
-        
+    unsigned char index = cec_global_info.my_node_index;
+
     if (cec_global_info.dev_mask & (1 << index)) {
         cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
         cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
@@ -1496,8 +1260,6 @@ void cec_set_standby(void)
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
 			cec_ll_tx(msg, 2);
-			//mdelay(100);
-			cec_rx_flag = 0;
 		}
 	}
 }
@@ -1508,11 +1270,10 @@ void cec_set_osd_name(cec_rx_message_t* pcec_message)
 	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
     unsigned char msg[16];
-        
+
     if(0xf != src_log_addr) {
         msg[0] = ((index & 0xf) << 4) | src_log_addr;
         msg[1] = CEC_OC_SET_OSD_NAME;
-
         memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
 
         cec_ll_tx(msg, 2 + osd_len);
@@ -1534,18 +1295,7 @@ void cec_set_osd_name_init(void)
 
 void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
 {
-//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
-//    unsigned char index = cec_global_info.my_node_index;  
-//    if (cec_global_info.dev_mask & (1 << index)) {
-//        if (cec_global_info.cec_node_info[index].vendor_id.vendor_id_byte_num != 0) {
-//            int i = cec_global_info.cec_node_info[index].vendor_id.vendor_id_byte_num;
-//            int tmp = 0;
-//            for ( ; i < pcec_message->operand_num; i++) {
-//                tmp |= (pcec_message->content.msg.operands[i] << ((cec_global_info.cec_node_info[log_addr].vendor_id.vendor_id_byte_num - i - 1)*8));
-//            }
-//            hdmirx_cec_dbg_print("cec_vendor_cmd_with_id: %lx, %x\n", cec_global_info.cec_node_info[log_addr].vendor_id.vendor_id, tmp);
-//        }
-//    }
+    ;//todo
 }
 
 
@@ -1553,20 +1303,17 @@ void cec_set_menu_language(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-    
+
     if(0x0 == src_log_addr) {
         cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
                                                                (pcec_message->content.msg.operands[1] <<  8)  |
                                                                (pcec_message->content.msg.operands[2]));
-        
-        
+
         switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
         cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
-        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff, 
+        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
                                                                  (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
                                                                  (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
-    }else{
-        //cec_feature_abort(pcec_message);
     }
 }
 
@@ -1578,7 +1325,8 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
     unsigned char   msg_length;
 
     /* parse message */
-    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) //return;
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
+        return;
 
     initiator	= pcec_message->content.msg.header >> 4;
     follower	= pcec_message->content.msg.header & 0x0f;
@@ -1589,36 +1337,26 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
 
     if(0 == pcec_message->content.msg.header)
         return;
+
     /* process messages from tv polling and cec devices */
-//    hdmitx_cec_dbg_print("OP code: 0x%x\n", opcode);
-//    hdmitx_cec_dbg_print("cec_power_flag: 0x%x\n", cec_power_flag);
-//    hdmitx_cec_dbg_print("cec: cec_func_config: 0x%x\n", hdmitx_device->cec_func_config);
     if(CEC_OC_GIVE_OSD_NAME == opcode)
         cec_set_osd_name(pcec_message);
     if((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) && cec_power_flag)
-    {    
+    {
 
         switch (opcode) {
         case CEC_OC_ACTIVE_SOURCE:
-            //if((0 == pcec_message->content.msg.operands[0]) && (0 == pcec_message->content.msg.operands[1]))
-                //cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-                //cec_active_source_smp();
-            //cec_deactive_source(pcec_message);
+            cec_active_source_rx(pcec_message);
             break;
         case CEC_OC_INACTIVE_SOURCE:
-            //cec_deactive_source(pcec_message);
             break;
         case CEC_OC_CEC_VERSION:
-            //cec_report_version(pcec_message);
             break;
         case CEC_OC_DECK_STATUS:
-            //cec_deck_status(pcec_message);
             break;
         case CEC_OC_DEVICE_VENDOR_ID:
-            //cec_device_vendor_id(pcec_message);
             break;
         case CEC_OC_FEATURE_ABORT:
-            //cec_feature_abort(pcec_message);
             break;
         case CEC_OC_GET_CEC_VERSION:
             cec_get_version(pcec_message);
@@ -1627,114 +1365,94 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             cec_give_deck_status(pcec_message);
             break;
         case CEC_OC_MENU_STATUS:
-            //cec_menu_status(pcec_message);
-            //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+            cec_menu_status_smp_irq(pcec_message);
             break;
         case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-            cec_report_phy_addr(pcec_message);
             break;
         case CEC_OC_REPORT_POWER_STATUS:
-            //cec_report_power_status(pcec_message);
             break;
         case CEC_OC_SET_OSD_NAME:
-            //cec_set_osd_name(pcec_message);
             break;
         case CEC_OC_VENDOR_COMMAND_WITH_ID:
-            //cec_feature_abort(pcec_message);
-            //cec_vendor_cmd_with_id(pcec_message);
             break;
         case CEC_OC_SET_MENU_LANGUAGE:
             cec_set_menu_language(pcec_message);
             break;
         case CEC_OC_GIVE_PHYSICAL_ADDRESS:
             cec_report_physical_address_smp();
-            //cec_report_phy_addr(pcec_message);//
-            //cec_give_physical_address(pcec_message);
-            //cec_usrcmd_set_report_physical_address();
             break;
         case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-            //cec_feature_abort(pcec_message);
             cec_device_vendor_id(pcec_message);
-            //cec_usrcmd_set_device_vendor_id();
             break;
         case CEC_OC_GIVE_OSD_NAME:
-            cec_set_osd_name(pcec_message);
-            //cec_give_osd_name(pcec_message);
-            //cec_usrcmd_set_osd_name(pcec_message);
             break;
         case CEC_OC_STANDBY:
-            hdmitx_cec_dbg_print("CEC: system standby\n");
-        	//cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-            cec_deactive_source(pcec_message);
+            cec_inactive_source_rx(pcec_message);
             cec_standby(pcec_message);
             break;
         case CEC_OC_SET_STREAM_PATH:
             cec_set_stream_path(pcec_message);
             break;
         case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            //cec_request_active_source(pcec_message);
-            //cec_usrcmd_set_active_source();
+            if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
+                break;
             cec_active_source_smp();
             break;
         case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-            cec_give_device_power_status(pcec_message);
+            cec_report_power_status(pcec_message);
             break;
         case CEC_OC_USER_CONTROL_PRESSED:
-            //hdmitx_cec_dbg_print("----cec_user_control_pressed-----");
-            //cec_user_control_pressed(pcec_message);
             break;
         case CEC_OC_USER_CONTROL_RELEASED:
-            //hdmitx_cec_dbg_print("----cec_user_control_released----");
-            //cec_user_control_released(pcec_message);
-            break; 
+            break;
         case CEC_OC_IMAGE_VIEW_ON:      //not support in source
             cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-            break;  
+            break;
         case CEC_OC_ROUTING_CHANGE:
-        case CEC_OC_ROUTING_INFORMATION:    	
-        	cec_usrcmd_routing_information(pcec_message);	
+            cec_routing_change(pcec_message);
+            break;
+        case CEC_OC_ROUTING_INFORMATION:
+        	cec_routing_information(pcec_message);
         	break;
-        case CEC_OC_GIVE_AUDIO_STATUS:   	  
+        case CEC_OC_GIVE_AUDIO_STATUS:
         	cec_report_audio_status();
         	break;
         case CEC_OC_MENU_REQUEST:
             cec_menu_status(pcec_message);
             break;
         case CEC_OC_PLAY:
-            hdmitx_cec_dbg_print("CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);        
+            hdmitx_cec_dbg_print("CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
             switch(pcec_message->content.msg.operands[0]){
                 case 0x24:
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);	
+                    input_sync(remote_cec_dev);
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
                     input_sync(remote_cec_dev);
                     break;
                 case 0x25:
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);	
+                    input_sync(remote_cec_dev);
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
                     input_sync(remote_cec_dev);
                     break;
                 default:
-                    break;                
+                    break;
             }
             break;
         case CEC_OC_DECK_CONTROL:
-            hdmitx_cec_dbg_print("CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);        
+            hdmitx_cec_dbg_print("CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
             switch(pcec_message->content.msg.operands[0]){
                 case 0x3:
                     input_event(remote_cec_dev, EV_KEY, KEY_STOP, 1);
-                    input_sync(remote_cec_dev);	
+                    input_sync(remote_cec_dev);
                     input_event(remote_cec_dev, EV_KEY, KEY_STOP, 0);
                     input_sync(remote_cec_dev);
                     break;
                 default:
-                    break;                
+                    break;
             }
             break;
         case CEC_OC_GET_MENU_LANGUAGE:
-            //cec_set_menu_language(pcec_message);
-            //break;                 	  
         case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
         case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
         case CEC_OC_CLEAR_ANALOGUE_TIMER:
@@ -1747,7 +1465,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
         case CEC_OC_SET_TIMER_PROGRAM_TITLE:
         case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
         case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:       //not support in source
+        case CEC_OC_TEXT_VIEW_ON:
         case CEC_OC_TIMER_CLEARED_STATUS:
         case CEC_OC_TIMER_STATUS:
         case CEC_OC_TUNER_DEVICE_STATUS:
@@ -1809,174 +1527,160 @@ void cec_usrcmd_parse_all_dev_online(void)
     hdmirx_cec_dbg_print("##############################################################\n");
 }
 
-//////////////////////////////////////////////////
 void cec_usrcmd_get_cec_version(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr, 
+    MSG_P0(cec_global_info.my_node_index, log_addr,
             CEC_OC_GET_CEC_VERSION);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_audio_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_deck_status(unsigned char log_addr)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_device_power_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_osd_name(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_physical_address(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_standby(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 /////////////////////////
 void cec_usrcmd_set_imageview_on(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr, 
+    MSG_P0(cec_global_info.my_node_index, log_addr,
             CEC_OC_IMAGE_VIEW_ON);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_text_view_on(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr, 
+    MSG_P0(cec_global_info.my_node_index, log_addr,
             CEC_OC_TEXT_VIEW_ON);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_menu_state(unsigned char log_addr)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
 
-
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_menu_language(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
-//void cec_usrcmd_set_menu_language(unsigned char log_addr, cec_menu_lang_e menu_lang)
-//{
-//    MSG_P3(cec_global_info.my_node_index, log_addr, CEC_OC_SET_MENU_LANGUAGE, (menu_lang_array[menu_lang]>>16)&0xFF,
-//           (menu_lang_array[menu_lang]>>8)&0xFF,
-//           (menu_lang_array[menu_lang])&0xFF);
-//    register_cec_tx_msg(gbl_msg, 5);
-//}
-
 void cec_usrcmd_get_active_source(void)
 {
     MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
-        
-    register_cec_tx_msg(gbl_msg, 2);
+
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_active_source(void)
 {
     unsigned char index = cec_global_info.my_node_index;
-    //unsigned char phy_addr_ab = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-    //unsigned char phy_addr_cd = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
-    
-    MSG_P2(index, CEC_BROADCAST_ADDR, 
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(index, CEC_BROADCAST_ADDR,
             CEC_OC_ACTIVE_SOURCE,
 			phy_addr_ab,
 			phy_addr_cd);
 
-    register_cec_tx_msg(gbl_msg, 4);
+    cec_ll_tx(gbl_msg, 4);
 }
 
 void cec_usrcmd_set_deactive_source(unsigned char log_addr)
 {
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    
+
     MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
            phy_addr_ab,
            phy_addr_cd);
-          //cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.ab,
-          //cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.cd);
 
-    register_cec_tx_msg(gbl_msg, 4);
+    cec_ll_tx(gbl_msg, 4);
 }
 
 void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
@@ -1984,39 +1688,31 @@ void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_m
     cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
 }
 
-//void cec_usrcmd_set_stream_path(unsigned char log_addr)
-//{
-//    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_SET_STREAM_PATH, 
-//                                                  cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.ab,
-//                                                  cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.cd);
-//
-//    register_cec_tx_msg(gbl_msg, 4);
-//}
 
 void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
 {
 
-    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;  
+    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
     unsigned char index = cec_global_info.my_node_index;
 
-    MSG_P14(index, log_addr, 
-            CEC_OC_SET_OSD_NAME, 
+    MSG_P14(index, log_addr,
+            CEC_OC_SET_OSD_NAME,
             cec_global_info.cec_node_info[index].osd_name[0],
             cec_global_info.cec_node_info[index].osd_name[1],
             cec_global_info.cec_node_info[index].osd_name[2],
             cec_global_info.cec_node_info[index].osd_name[3],
             cec_global_info.cec_node_info[index].osd_name[4],
-            cec_global_info.cec_node_info[index].osd_name[5],           
+            cec_global_info.cec_node_info[index].osd_name[5],
             cec_global_info.cec_node_info[index].osd_name[6],
             cec_global_info.cec_node_info[index].osd_name[7],
             cec_global_info.cec_node_info[index].osd_name[8],
             cec_global_info.cec_node_info[index].osd_name[9],
             cec_global_info.cec_node_info[index].osd_name[10],
-            cec_global_info.cec_node_info[index].osd_name[11],  
+            cec_global_info.cec_node_info[index].osd_name[11],
             cec_global_info.cec_node_info[index].osd_name[12],
             cec_global_info.cec_node_info[index].osd_name[13]);
 
-    register_cec_tx_msg(gbl_msg, 16);
+    cec_ll_tx(gbl_msg, 16);
 }
 
 
@@ -2025,64 +1721,67 @@ void cec_usrcmd_set_device_vendor_id(void)
 {
     unsigned char index = cec_global_info.my_node_index;
 
-    MSG_P3(index, CEC_BROADCAST_ADDR, 
-            CEC_OC_DEVICE_VENDOR_ID, 
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+            CEC_OC_DEVICE_VENDOR_ID,
             (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
             (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
             (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
 
-    register_cec_tx_msg(gbl_msg, 5);
+    cec_ll_tx(gbl_msg, 5);
 }
 void cec_usrcmd_set_report_physical_address(void)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    
-    MSG_P3(index, CEC_BROADCAST_ADDR, 
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
            CEC_OC_REPORT_PHYSICAL_ADDRESS,
            phy_addr_ab,
            phy_addr_cd,
            CEC_PLAYBACK_DEVICE_TYPE);
-			//cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-			//cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd,
-			//cec_global_info.cec_node_info[index].dev_type);
 
-    register_cec_tx_msg(gbl_msg, 5);
+    cec_ll_tx(gbl_msg, 5);
 }
 
-void cec_usrcmd_routing_change(cec_rx_message_t* pcec_message)
+void cec_routing_change(cec_rx_message_t* pcec_message)
 {
-    //unsigned char index = cec_global_info.my_node_index;
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
-    //cec_global_info.cec_node_info[index].log_addr = index;
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_LOGIC_ADDRESS;
-    //cec_global_info.cec_node_info[index].phy_addr.phy_addr_4 = (pcec_message->content.msg.operands[2] << 8) | pcec_message->content.msg.operands[3];
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_PHYSICAL_ADDRESS;    
-    //MSG_P4(index, CEC_BROADCAST_ADDR, 
-    //        CEC_OC_ROUTING_CHANGE, 
-        //  cec_global_info.cec_node_info[original_index].phy_addr.phy_addr_2.ab,
-        //  cec_global_info.cec_node_info[original_index].phy_addr.phy_addr_2.cd,
-        //  cec_global_info.cec_node_info[new_index].phy_addr.phy_addr_2.ab,
-        //  cec_global_info.cec_node_info[new_index].phy_addr.phy_addr_2.cd,
-        //  );
+    unsigned int phy_addr_origin;
+    unsigned int phy_addr_destination;
+
+    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
+                                         (pcec_message->content.msg.operands[3] << 0));
 
-    //register_cec_tx_msg(gbl_msg, 6);
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 
-void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message)
+void cec_routing_information(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    unsigned int phy_addr_destination;
     unsigned char msg[4];
 
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                         (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_ROUTING_INFORMATION;
     msg[2] = phy_addr_ab;
     msg[3] = phy_addr_cd;
     cec_ll_tx(msg, 4);
-
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 /***************************** cec middle level code end *****************************/
 
@@ -2091,22 +1790,17 @@ void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message)
 
 static int __init cec_init(void)
 {
-    int i;    
+    int i;
     extern __u16 cec_key_map[128];
     extern hdmitx_dev_t * get_hdmitx_device(void);
     hdmitx_device = get_hdmitx_device();
     cec_key_init();
+    hdmitx_cec_dbg_print("CEC init\n");
 
-    //if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
-    //    hdmitx_cec_dbg_print("CEC not init\n");
-    //    return 0;
-    //}
-    //else {
-        hdmitx_cec_dbg_print("CEC init\n");
-    //}
-
+#ifdef CONFIG_ARCH_MESON6
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+#endif
 
     cec_rx_msg_buf.rx_write_pos = 0;
     cec_rx_msg_buf.rx_read_pos = 0;
@@ -2114,36 +1808,41 @@ static int __init cec_init(void)
     memset(cec_rx_msg_buf.cec_rx_message, 0, sizeof(cec_rx_msg_buf.cec_rx_message));
 
     memset(&cec_global_info, 0, sizeof(cec_global_info_t));
-    //cec_global_info.my_node_index = CEC0_LOG_ADDR;
 
-    if (cec_mutex_flag == 0) {
-        //init_MUTEX(&tv_cec_sema);
-        sema_init(&tv_cec_sema,1);
-        cec_mutex_flag = 1;
-    }
-    
     kthread_run(cec_task, (void*)hdmitx_device, "kthread_cec");
+#ifdef CONFIG_ARCH_MESON6
     if(request_irq(INT_HDMI_CEC, &cec_isr_handler,
                 IRQF_SHARED, "amhdmitx-cec",
                 (void *)hdmitx_device)){
         hdmitx_cec_dbg_print("HDMI CEC:Can't register IRQ %d\n",INT_HDMI_CEC);
-        return -EFAULT;               
+        return -EFAULT;
+    }
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    if(request_irq(INT_AO_CEC, &cec_isr_handler,
+                IRQF_SHARED, "amhdmitx-aocec",
+                (void *)hdmitx_device)){
+        hdmitx_cec_dbg_print("HDMI CEC:Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
     }
+#endif
+
+#if CEC_WQ
+    cec_wq = create_workqueue("cec wq");
+    if(!cec_wq)
+        panic("Failed to create cec_workqueue.");
+#endif
 
-    remote_cec_dev = input_allocate_device();   
-    if (!remote_cec_dev)                          
-    {  
-        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Not enough memory\n");   
+    INIT_WORK(&cec_wq_func, (void (*)(void *))cec_do_work);
+    remote_cec_dev = input_allocate_device();
+    if (!remote_cec_dev)
+    {
+        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Not enough memory\n");
     }
     remote_cec_dev->name = "cec_input";
-   
-    //hdmitx_cec_dbg_print("\n--111--function:%s,line:%d,count:%d\n",__FUNCTION__,__LINE__,tasklet_cec.count);
-   // tasklet_enable(&tasklet_cec);
-    //hdmitx_cec_dbg_print("\n--222--function:%s,line:%d,count:%d\n",__FUNCTION__,__LINE__,tasklet_cec.count);
-      //tasklet_cec.data = (unsigned long)remote_cec;
-                                           
-    remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);      
-    remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0); 
+
+    remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
+    remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
     remote_cec_dev->id.bustype = BUS_ISA;
     remote_cec_dev->id.vendor = 0x1b8e;
     remote_cec_dev->id.product = 0x0cec;
@@ -2152,19 +1851,15 @@ static int __init cec_init(void)
     for (i = 0; i < 128; i++){
           set_bit( cec_key_map[i], remote_cec_dev->keybit);
       }
-                   
-    if(input_register_device(remote_cec_dev)) {  
-        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Failed to register device\n");  
-        input_free_device(remote_cec_dev);   
+
+    if(input_register_device(remote_cec_dev)) {
+        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Failed to register device\n");
+        input_free_device(remote_cec_dev);
     }
 
     hdmitx_device->cec_init_ready = 1;
-    
-    //if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
-    //    msleep(10000);
-    //    cec_gpi_init();
-    //    cec_node_init(hdmitx_device);
-    //}
+    cec_init_ready_flag = 1;
+    printk("hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
     return 0;
 }
 
@@ -2175,14 +1870,24 @@ static void __exit cec_uninit(void)
     }
     hdmitx_cec_dbg_print("CEC: cec uninit!\n");
     if (cec_init_flag == 1) {
-////        WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+
+#ifdef CONFIG_ARCH_MESON6
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
         free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+        free_irq(INT_AO_CEC, (void *)hdmitx_device);
+#endif
         cec_init_flag = 0;
     }
+#if CEC_WQ
+    if(cec_wq)
+        destroy_workqueue(cec_wq);
+#endif
     hdmitx_device->cec_init_ready = 0;
+    cec_init_ready_flag = 0;
     input_unregister_device(remote_cec_dev);
-    free_fiq(INT_GPIO_0, &cec_gpi_receive_bits); 
-    cec_fiq_flag = 0;   
+    cec_fiq_flag = 0;
 }
 
 size_t cec_usrcmd_get_global_info(char * buf)
@@ -2222,7 +1927,7 @@ void cec_usrcmd_set_lang_config(const char * buf, size_t count)
 
     while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
         tmpbuf[i]=buf[i];
-        i++;    
+        i++;
     }
 
     cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = simple_strtoul(tmpbuf, NULL, 16);
@@ -2254,8 +1959,11 @@ void cec_usrcmd_set_config(const char * buf, size_t count)
     }
     if((0 == value) && (1 == (param[0] & 1))){
         hdmitx_device->cec_init_ready = 1;
+        cec_init_ready_flag = 1;
         hdmitx_device->hpd_state = 1;
+#ifdef CONFIG_ARCH_MESON6
         cec_gpi_init();
+#endif
         cec_node_init(hdmitx_device);
     }
     if((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2))){
@@ -2272,8 +1980,13 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
 {
     int i = 0;
     int j = 0;
+    int n = 0;
+    int m = 0;
     int bool = 0;
     char param[16] = {0};
+    char tmpbuf[32] = {0};
+    unsigned bit_set;
+    unsigned time_set;
     unsigned char msg[4] = {0};
 
     if(count > 32){
@@ -2287,9 +2000,22 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         while ( buf[i] != ' ' )
             i ++;
     }
-   
-    hdmirx_cec_dbg_print("cec_usrcmd_set_dispatch: \n");
 
+    while((buf[n]!=',')&&(buf[i]!=' ')){
+        tmpbuf[n]=buf[n];
+        n++;
+    }
+    tmpbuf[n]=0;
+    hdmirx_cec_dbg_print("cec_usrcmd_set_dispatch: \n");
+    if(strncmp(tmpbuf, "waocec", 6)==0){
+        bit_set = simple_strtoul(tmpbuf+6, NULL, 16);
+        time_set = simple_strtoul(buf+n+1, NULL, 16);
+        cec_arbit_bit_time_set(bit_set, time_set, 1);
+        return;
+    }else if(strncmp(tmpbuf, "raocec", 6)==0){
+        cec_arbit_bit_time_read();
+        return;
+    }
     switch (param[0]) {
     case GET_CEC_VERSION:   //0 LA
         cec_usrcmd_get_cec_version(param[1]);
@@ -2339,12 +2065,11 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         cec_usrcmd_set_menu_state(param[1], param[2]);
         break;
     case SET_MENU_LANGAGE:
-        //cec_usrcmd_set_menu_language(param[1], param[2]);
         break;
     case GET_MENU_LANGUAGE:
         cec_usrcmd_get_menu_language(param[1]);
         break;
-    case GET_ACTIVE_SOURCE:     //13???????
+    case GET_ACTIVE_SOURCE:     //13
         cec_usrcmd_get_active_source();
         break;
     case SET_ACTIVE_SOURCE:
@@ -2353,20 +2078,13 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
     case SET_DEACTIVE_SOURCE:
         cec_usrcmd_set_deactive_source(param[1]);
         break;
-//    case CLR_NODE_DEV_REAL_INFO_MASK:
-//        cec_usrcmd_clear_node_dev_real_info_mask(param[1], (((cec_info_mask)param[2]) << 24) |
-//                                                         (((cec_info_mask)param[3]) << 16) |
-//                                                         (((cec_info_mask)param[4]) << 8)  |
-//                                                         ((cec_info_mask)param[5]));
-//        break;
-    case REPORT_PHYSICAL_ADDRESS:    //17 
+    case REPORT_PHYSICAL_ADDRESS:    //17
     	cec_usrcmd_set_report_physical_address();
     	break;
     case SET_TEXT_VIEW_ON:          //18 LA
     	cec_usrcmd_text_view_on(param[1]);
         break;
-    case POLLING_ONLINE_DEV:    //19 LA 
-        hdmitx_cec_dbg_print("\n-----POLLING_ONLINE_DEV------\n");
+    case POLLING_ONLINE_DEV:    //19 LA
         cec_polling_online_dev(param[1], &bool);
         break;
 
@@ -2379,12 +2097,9 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         msg[1] = CEC_OC_FEATURE_ABORT;
         msg[2] = 0;
         msg[3] = CEC_UNRECONIZED_OPCODE;
-        
+
         cec_ll_tx(msg, 4);
         break;
-    case 0xaa : //for cec tx test.
-        for(i = 0; i < 128; i++)                             
-            printk("test_buf[%d]:%d\n", i, test_buf[i]);
     default:
         break;
     }
@@ -2404,68 +2119,89 @@ module_param(cec_msg_dbg_en, bool, 0664);
 
 /*************************** cec arbitration cts code ******************************/
 // using the cec pin as fiq gpi to assist the bus arbitration
+static unsigned char msg_log_buf[128] = { 0 };
+// return value: 1: successful      0: error
+static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+    unsigned int cnt = 30;
+    int pos;
+#ifdef CONFIG_ARCH_MESON6
+    for (i = 0; i < len; i++) {
+        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
+    //cec_tx_start = 1;
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, RX_ACK_CURRENT);//TX_REQ_NEXT
+    msleep(len * 24 + 5);
 
-struct _cec_msg_ {
-    unsigned char msg[16];
-    unsigned char len;
-};
-
-static struct _cec_msg_ cec_msg_bak;
+    ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
 
-static unsigned long frame_time_log[512] = { 0 };
-static unsigned long frame_time_idx = 0;
-static int test_idx = 0;
-static int ack_check_point[16] = { 0 };
-static unsigned char msg_log_buf[128] = { 0 };
-static unsigned int cec_tx_start = 0;
-static unsigned int cec_rx_start = 0;
+    if(ret == TX_DONE)
+        ret = 1;
+    else
+        ret = 0;
 
-#define BUS_LEVEL()         (!!(aml_read_reg32(P_PREG_PAD_GPIO2_I) & (1<<13)))
-static void get_bus_free(void)
-{
-    unsigned int cnt = 0;
-    do {
-        frame_time_idx = 0;
-        while(!BUS_LEVEL()) {  // judge whether cec bus level is low
-            msleep(30);
-            cnt ++;
-            if(frame_time_idx != 0) {       // if frame_time_idx > 0, means the bus is busy
-                break;
-            }
-            if((frame_time_idx == 0) && (cnt > 33)) {       // test 1 second, if always low, return
-                pr_err("CEC: bus error, always low\n");
-                return ;
-            }
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    while(aocec_rd_reg(CEC_TX_MSG_STATUS) || aocec_rd_reg(CEC_RX_MSG_STATUS)){
+        msleep(5);
+        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            //cec_hw_reset();
+            break;
+        }
+        if(!(cnt--)){
+            printk("tx busy time out.\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
         }
-        frame_time_idx = 0;
-        msleep(30);             // judge whether cec bus is busy
-        cnt ++;
-        if(cnt & (1 << 7)) {
-            pr_err("CEC: bus busy\n");
+    }
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+#endif
+    if(cec_msg_dbg_en == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
         }
-    } while (frame_time_idx);   // frame_time_idx > 0, means that cec line is working
+#ifdef CONFIG_ARCH_MESON6
+        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
+#endif
+#ifdef CONFIG_ARCH_MESON8
+        pos += sprintf(msg_log_buf + pos, "\n");
+#endif
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
 }
+#ifdef CONFIG_ARCH_MESON8
 
-// return value: 1: successful      0: error
-static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
+static int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
 {
     int i;
     unsigned int ret = 0xf;
     unsigned int n;
+	unsigned int j = 30;
     int pos;
-    
-    cec_tx_start = 1;
-    cec_rx_start = 1;
-    get_bus_free();
-    cec_rx_start = 0;
-    frame_time_idx = 0;
-
+#ifdef CONFIG_ARCH_MESON6
     for (i = 0; i < len; i++) {
      hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
     }
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
     //cec_tx_start = 1;
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_REQ_CURRENT);//TX_REQ_NEXT
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, RX_ACK_CURRENT);//TX_REQ_NEXT
     msleep(len * 24 + 5);
 
     ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
@@ -2476,7 +2212,29 @@ static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
         ret = 0;
 
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-    cec_tx_start = 0;
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 1, 1);
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+    while((TX_DONE != aocec_rd_reg(CEC_TX_MSG_STATUS)) && (j--)){
+		msleep(5);
+	}
+
+    ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
+
+    if(ret == TX_DONE)
+        ret = 1;
+    else
+        ret = 0;
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 1, 1, 1);
+#endif
     if(cec_msg_dbg_en == 1) {
         pos = 0;
         pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
@@ -2490,6 +2248,72 @@ static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
     return ret;
 }
 
+void cec_arbit_bit_time_read(void){//11bit:bit[10:0]
+    //3 bit
+    printk("read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+    //5 bit
+    printk("read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+    //7 bit
+    printk("read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+}
+
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag){//11bit:bit[10:0]
+    if(flag)
+        printk("bit_set:0x%x;time_set:0x%x \n", bit_set, time_set);
+    switch(bit_set){
+    case 3:
+        //3 bit
+        if(flag)
+            printk("read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
+        if(flag)
+            printk("write 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+        break;
+        //5 bit
+    case 5:
+        if(flag)
+            printk("read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
+        if(flag)
+            printk("write 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        //7 bit
+	case 7:
+        if(flag)
+            printk("read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
+        if(flag)
+            printk("write 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+        break;
+    default:
+        break;
+    }
+}
+
+void tx_irq_handle(void){
+    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    switch(tx_status){
+    case TX_DONE:
+      aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+      break;
+    case TX_BUSY:
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        break;
+    case TX_ERROR:
+        cec_hw_reset();
+        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        break;
+    default:
+        break;
+    }
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 1));
+    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) | (1 << 2));
+
+}
+#endif
 // Return value: 0: fail    1: success
 int cec_ll_tx(const unsigned char *msg, unsigned char len)
 {
@@ -2497,119 +2321,54 @@ int cec_ll_tx(const unsigned char *msg, unsigned char len)
     int repeat = 0;
     int i;
 
-    memset(&cec_msg_bak, 0, sizeof(cec_msg_bak));
-    memset(ack_check_point, 0, sizeof(ack_check_point));
-
-    // save msg
-    cec_msg_bak.len = len;
-    for(i = 0; i < len; i++) {
-        cec_msg_bak.msg[i] = msg[i];
-        ack_check_point[i] = (i + 1) * 20 + 1;
-    }
-    
-    // if transmit message error, try repeat(4) times
+    mutex_lock(&cec_mutex);
+#ifdef CONFIG_ARCH_MESON8
+    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) & ~(1 << 2));
+    cec_ll_tx_once(msg, len);
+#endif
+    //if transmit message error, try repeat(4) times
+#ifdef CONFIG_ARCH_MESON6
     do {
         ret = cec_ll_tx_once(msg, len);
-        //ret ? msleep(18) : ((!repeat) ? msleep(12) : msleep(8));       // if transmit fails, waiting proper time to try again.
         repeat ++;
-        ret ? 0 : msleep(31);       // if transmit fails, wait 31ms and try send again
-        cec_hw_reset();
+        if(repeat > 1)
+            cec_hw_reset();
     } while((ret == 0) && (repeat < 3));
 
     cec_msg_dbg_en ? printk("cec: ret = %d\n", ret) : 0;
     if(repeat > 1) {
         printk("cec: try %d times\n", repeat);
     }
-
+#endif
+    mutex_unlock(&cec_mutex);
     return ret;
 }
-
-static inline int get_value(unsigned time_rise, unsigned time_fall)
-{
-    unsigned time;
-    if(time_rise > time_fall)
-        time = time_rise - time_fall;
-    else
-        time = ((unsigned int)(0xffffffff)) - time_fall + time_rise;
-    if((time > 1300) && (time < 1700))
-        return 0;
-    if((time > 400) && (time < 800))
-        return 1;
-    if((time > 2400) && (time < 3500))
-        return 2;
-    return -1;
-}
-
-static inline int need_check_ack(unsigned idx)
-{
-    int i;
-    for(i = 0; (ack_check_point[i]) && (i < 16) ; i++) {
-        if(ack_check_point[i] == idx) {
-            return 1;
-        }
-    }
-    return 0;
-}
-
-static void cec_gpi_receive_bits(void)
+#ifdef CONFIG_ARCH_MESON6
+static void cec_gpi_init(void)
 {
-    int val = 0;
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
-    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, BUS_LEVEL(), 16, 1);
-    if(!cec_tx_start)
+    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+        aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq.
+        printk("CEC FIQ return.\n");
         return;
-    frame_time_log[frame_time_idx] = aml_read_reg32(P_ISA_TIMERE);
-
-    // ack rising position
-    val = get_value(frame_time_log[frame_time_idx], frame_time_log[frame_time_idx - 1]);
-
-    if(128 == test_idx)
-        test_idx = 0;
-    if((!cec_rx_start) && (val == 2) && (frame_time_idx > 20)) {
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_ABORT);       // stop cec tx
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-        //test_buf[test_idx++] = frame_time_idx; //for cec tx arbitration point test.
-    }
-    
-    if((!cec_rx_start) && need_check_ack(frame_time_idx)) {
-        // if val == 1, and DES != 0xf
-        // if val == 0, and DES == 0xf
-        // means we need stop cec tx
-        if(((val == 1) ? ((cec_msg_bak.msg[0] & 0xf) != 0xf) : ((cec_msg_bak.msg[0] & 0xf) == 0xf)) || (val == -1)) {
-            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_ABORT);       // stop cec tx
-            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-            //test_buf[test_idx++] = frame_time_idx;//for cec tx arbitration point test.
-        }
     }
-    (512 == frame_time_idx) ? (frame_time_idx = 0) : frame_time_idx++;
-    if(test_buf[test_idx] < frame_time_idx)
-        test_buf[test_idx] = frame_time_idx;
-    if(1 == frame_time_idx)
-        test_idx++;
-    
-}
-
-static void cec_gpi_init(void)
-{
-    if(cec_fiq_flag){
+    if(cec_fiq_flag){ //This function run only once.
         return;
     }
     cec_fiq_flag = 1;
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 0, 0, 1);     // disable irq
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
+    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 0, 0, 1);     // disable irq
+    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
 
     aml_set_reg32_bits(P_GPIO_INTR_GPIO_SEL0, 0x76, 0, 8);      // set GPIOC_23 as GPIO IRQ #0 source
-    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge 
+    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge
     aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 16, 1);
     request_fiq(INT_GPIO_0, &cec_gpi_receive_bits);
     printk("cec: register fiq\n");
 
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
+    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
 }
-
+#endif
 // DELETE LATER, TEST ONLY
 void cec_test_(unsigned int cmd)
 {
-    printk("CEC: bus level: %s\n", BUS_LEVEL() ? "High" : "Low");
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
index c1f50eb0f701..0c2cee3ff4b0 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
@@ -19,15 +19,12 @@
 #define _TV_CEC_H_
 #include "hdmi_tx_module.h"
 
-//#define CEC0_LOG_ADDR 0 // TV logical address
 #define CEC0_LOG_ADDR 4 // MBX logical address
 #define TV_CEC_INTERVAL     (HZ*3)
 
 #define CEC_VERSION     "v1.3"
-#define _RX_DATA_BUF_SIZE_ 6
+#define _RX_DATA_BUF_SIZE_ 16
 
-
-//#define _SUPPORT_CEC_TV_MASTER_
 #define _RX_CEC_DBG_ON_
 #define _TX_CEC_DBG_ON_
 
@@ -42,6 +39,7 @@
 #else
 #define hdmitx_cec_dbg_print(fmt, args...)
 #endif
+#define HDMI_CEC_DEBUG()  printk("HDMI CEC DEBUG: %s [%d]\n", __FUNCTION__, __LINE__)
 
 extern unsigned int cec_tx_irq_flag;
 extern unsigned int cec_tx_irq_syn_flag;
@@ -233,8 +231,6 @@ typedef struct {
             unsigned char header;          // 4bit Initiator logical address + 4bit Destination logical address
             unsigned char opcode;          // message opcode
             unsigned char operands[14];    // the maximun operand is 14
-            //unsigned int  flag;            // flag = 1 ,cec key pressed;flag = 0, cec key released
-            //struct input_dev *remote_cec_dev; //cec input device
         }msg;                              // message struct
     }content;                              // message content
     unsigned char operand_num;             // number of operand
@@ -334,6 +330,7 @@ typedef enum {
     CEC_VERSION_12A,
     CEC_VERSION_13,
     CEC_VERSION_13A,
+    CEC_VERSION_14A,
 } cec_version_e;
 
 typedef enum {
@@ -343,16 +340,6 @@ typedef enum {
     CEC_HDMI_PORT_3,
 } cec_hdmi_port_e;
 
-//typedef enum {
-//    CEC_MENU_LANG_CHN = 0,
-//    CEC_MENU_LANG_ENG,
-//    CEC_MENU_LANG_JAP,
-//    CEC_MENU_LANG_KOR,
-//    CEC_MENU_LANG_FRA,
-//    CEC_MENU_LANG_GER,
-//    //CEC_MENU_LANG_UNSUPPORTED = 0xff;
-//} cec_menu_lang_e;
-
 typedef enum {
     OFF = 0,
     ON,
@@ -377,23 +364,12 @@ typedef unsigned long cec_info_mask;
 #define ONE_TOUCH_STANDBY_MASK               2
 #define AUTO_POWER_ON_MASK                   3
 
-//typedef struct {
-//    unsigned long vendor_id;
-//    unsigned char vendor_id_byte_num;
-//} vendor_id_t;
-
-//typedef struct {
-//    unsigned char vsdb_phy_addr_offset;
-//    unsigned short phy_addr[3];
-//    unsigned char checksum[3];
-//} vsdb_phy_addr_t;
 
 typedef struct {
     cec_hdmi_port_e hdmi_port;
     cec_info_mask real_info_mask;
     unsigned char cec_version;
     unsigned int vendor_id:24;
-//    vendor_id_t vendor_id;
     unsigned char dev_type;
     unsigned char menu_status;
     cec_power_status_e power_status;
@@ -440,8 +416,6 @@ typedef struct {
 
 typedef struct {
     unsigned short dev_mask;
-    //unsigned char tv_log_addr;
-    //unsigned short tv_phy_addr;
     unsigned char active_log_dev;
     unsigned char my_node_index;
     cec_node_info_t cec_node_info[MAX_NUM_OF_DEV];
@@ -478,7 +452,6 @@ typedef enum {
     SET_ACTIVE_SOURCE,
     SET_DEACTIVE_SOURCE,
     CLR_NODE_DEV_REAL_INFO_MASK,
-    //SET_STREAM_PATH,
     REPORT_PHYSICAL_ADDRESS,    //0x17
     SET_TEXT_VIEW_ON,
     POLLING_ONLINE_DEV, //0x19
@@ -526,8 +499,8 @@ void cec_set_pending(tv_cec_pending_e on_off);
 void cec_polling_online_dev(int log_addr, int *bool);
 unsigned short cec_log_addr_to_dev_type(unsigned char log_addr);
 
-void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message);
-void cec_usrcmd_routing_change(cec_rx_message_t* pcec_message);
+void cec_routing_information(cec_rx_message_t* pcec_message);
+void cec_routing_change(cec_rx_message_t* pcec_message);
 void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message);
 void cec_usrcmd_set_device_vendor_id(void);
 void cec_usrcmd_get_cec_version(unsigned char log_addr);
@@ -547,7 +520,6 @@ void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode);
 void cec_usrcmd_get_menu_state(unsigned char log_addr);
 void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type);
 void cec_usrcmd_get_menu_language(unsigned char log_addr);
-//void cec_usrcmd_set_menu_language(unsigned char log_addr, cec_menu_lang_e menu_lang);
 void cec_usrcmd_get_active_source(void);
 void cec_usrcmd_set_active_source(void);
 void cec_usrcmd_set_deactive_source(unsigned char log_addr);
@@ -561,7 +533,7 @@ void cec_active_source(cec_rx_message_t* pcec_message);
 void cec_set_stream_path(cec_rx_message_t* pcec_message);
 void cec_set_osd_name(cec_rx_message_t* pcec_message);
 void cec_set_osd_name_init(void);
-void cec_deactive_source(cec_rx_message_t* pcec_message);
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message);
 void cec_set_system_audio_mode(void);
 void cec_system_audio_mode_request(void);
 void cec_report_audio_status(void);
@@ -573,7 +545,7 @@ void cec_set_imageview_on_irq(void);
 void cec_report_physical_address_smp(void);
 void cec_imageview_on_smp(void);
 void cec_active_source_smp(void);
-void cec_active_source_irq(void);
+void cec_active_source_rx(cec_rx_message_t* pcec_message);
 
 size_t cec_usrcmd_get_global_info(char * buf);
 void cec_usrcmd_set_dispatch(const char * buf, size_t count);
@@ -586,6 +558,11 @@ void cec_user_control_released_irq(void);
 void cec_user_control_pressed_irq(void);
 void cec_inactive_source(void);
 void cec_set_standby(void);
+void cec_isr_post_process(void);
+void cec_clear_buf(unsigned int flag);
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag);
+void tx_irq_handle(void);
+void cec_arbit_bit_time_read(void);
 
 extern struct input_dev *remote_cec_dev;
 extern __u16 cec_key_map[];
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
index 4dbf0563e460..fb63fe384e29 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
@@ -355,18 +355,7 @@ int Edid_Parse_check_HDMI_VSDB(HDMI_TX_INFO_t * info, unsigned char *buff)
 	}
 
     set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
-	if(info->vsdb_phy_addr.a == 0) {
-		printk("CEC: not a valid physical address\n");
-	}
-    else {
-        vsdb_phy_addr_t *tmp = &info->vsdb_phy_addr;
-        if(tmp->valid){
-            aml_write_reg32(P_AO_DEBUG_REG1, (((tmp->a) & 0xf) << 12) | (((tmp->b) & 0xf) << 8) | (((tmp->c) & 0xf) << 4) | ((tmp->d) & 0xf));
-            printk("CEC: Physical address: 0x%x\n",aml_read_reg32(P_AO_DEBUG_REG1));
-            printk("CEC: Physical address: %1x.%1x.%1x.%1x\n", tmp->a, tmp->b, tmp->c, tmp->d);
-        }
-    }
-
+    
 	//For test only.
 	hdmi_print(0,"HDMI DEBUG [%s]\n", __FUNCTION__);
     hdmi_print(0,"max_tmds_clk_7:%d\n",buff[BlockAddr + 7]);
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
index 8e20e3feff22..1f42b292b836 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
@@ -1362,7 +1362,7 @@ void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device, int power_mode, int vic)
 void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
 {
 #ifdef CONFIG_ARCH_MESON8
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0xf, 23, 4); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V)
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0xe, 23, 4); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V) bit23: gpioh_3 cec
 #endif
     unsigned int tmp_add_data;
     
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
old mode 100644
new mode 100755
index b0809ba77f48..bc2b9299fd48
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
@@ -22,6 +22,7 @@
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <linux/device.h>
+#include <linux/delay.h>
 #include <linux/mm.h>
 #include <linux/major.h>
 #include <linux/platform_device.h>
@@ -32,6 +33,7 @@
 
 #include "hdmi_tx_reg.h"
 static DEFINE_SPINLOCK(reg_lock);
+static DEFINE_SPINLOCK(reg_lock2);
 // if the following bits are 0, then access HDMI IP Port will cause system hungup
 #define GATE_NUM    2
 Hdmi_Gate_s hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
@@ -100,3 +102,38 @@ void hdmi_wr_reg(unsigned long addr, unsigned long data)
     spin_unlock(&reg_lock);
 #endif
 }
+
+#ifdef CONFIG_ARCH_MESON8
+#define waiting_aocec_free()    while(aml_read_reg32(P_AO_CEC_RW_REG) & (1<<23))
+unsigned long aocec_rd_reg (unsigned long addr)
+{
+    unsigned long data32;
+    waiting_aocec_free();
+    spin_lock(&reg_lock2);
+    data32  = 0;
+    data32 |= 0     << 16;  // [16]     cec_reg_wr
+    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+
+    waiting_aocec_free();
+    data32 = ((aml_read_reg32(P_AO_CEC_RW_REG)) >> 24) & 0xff;
+    spin_unlock(&reg_lock2);
+    return (data32);
+} /* aocec_rd_reg */
+
+void aocec_wr_reg (unsigned long addr, unsigned long data)
+{
+    unsigned long data32;
+    waiting_aocec_free();
+    spin_lock(&reg_lock2);
+    data32  = 0;
+    data32 |= 1     << 16;  // [16]     cec_reg_wr
+    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+    spin_unlock(&reg_lock2);
+    waiting_aocec_free();
+    //waiting_aocec_free();
+} /* aocec_wr_only_reg */
+#endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
old mode 100644
new mode 100755
index 3b0110d45d35..fe41e1c09c53
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
@@ -26,6 +26,9 @@ unsigned long hdmi_rd_reg(unsigned long addr);
 
 void hdmi_wr_reg(unsigned long addr, unsigned long data);
 
+unsigned long aocec_rd_reg(unsigned long addr);
+void aocec_wr_reg(unsigned long addr, unsigned long data);
+
 typedef struct {
     unsigned short cbus_addr;
     unsigned char gate_bit;
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index 01ba1eddbf90..7f8d58179a4a 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -15,6 +15,12 @@
 #include <asm/io.h>
 #include <mach/am_regs.h>
 #include "remote_main.h"
+#ifdef CONFIG_AML_HDMI_TX
+#ifdef CONFIG_ARCH_MESON8
+extern int cec_power_flag;
+unsigned char cec_repeat = 10;
+#endif
+#endif
 extern char *remote_log_buf;
 static int repeat_count = 0;
 static int dbg_printk(const char *fmt, ...)
@@ -385,6 +391,19 @@ int remote_hw_reprot_key(struct remote *remote_data)
 		}
 	}
 	else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg){	//repeate key
+#ifdef CONFIG_AML_HDMI_TX
+#ifdef CONFIG_ARCH_MESON8
+       extern int rc_long_press_pwr_key;
+		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
+            rc_long_press_pwr_key = 1;
+		    cec_repeat = 10;
+		    mdelay(20);
+		}
+		if(remote_data->repeat_release_code == 0x1a)
+ 		    cec_repeat--;
+
+#endif
+#endif
 		if (remote_data->repeat_enable) {
 			repeat_count++;
 			if (remote_data->repeat_tick < jiffies) {
diff --git a/drivers/amlogic/input/remote/am_remote.c b/drivers/amlogic/input/remote/am_remote.c
index 09d4815e90fb..916f8fdbe18e 100755
--- a/drivers/amlogic/input/remote/am_remote.c
+++ b/drivers/amlogic/input/remote/am_remote.c
@@ -59,11 +59,11 @@
 
 type_printk input_dbg;
 #ifdef CONFIG_AML_HDMI_TX
-extern void cec_inactive_source(void);
-extern void cec_set_standby(void);
+#ifdef CONFIG_ARCH_MESON6
 extern int cec_power_flag;
 unsigned char cec_repeat = 10;
 #endif
+#endif
 
 static DEFINE_MUTEX(remote_enable_mutex);
 static DEFINE_MUTEX(remote_file_mutex);
@@ -390,14 +390,16 @@ static inline int remote_hw_reprot_key(struct remote *remote_data)
 			return -1;
 		}
 #ifdef CONFIG_AML_HDMI_TX
-		//printk("last_scan_code:%x\n", last_scan_code);
+#ifdef CONFIG_ARCH_MESON6
 		if((((scan_code >> 16) & 0xff) == 0x1a) && (!cec_repeat)) {
+            extern int rc_long_press_pwr_key;
+            rc_long_press_pwr_key = 1;
 		    cec_repeat = 10;
-		    cec_set_standby();
 		    mdelay(20);
 		}
 		if(((scan_code >> 16) & 0xff) == 0x1a)
  		    cec_repeat--;
+#endif
 #endif
 		if (remote_data->repeat_enable) {
 			if ((remote_data->repeat_tick < jiffies)&&(repeat_flag == 1)) {
-- 
2.19.0

