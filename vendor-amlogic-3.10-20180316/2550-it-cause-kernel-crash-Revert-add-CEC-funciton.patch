From 01fbc32dc658eaf7d9184a76c0e3d86f56b9e618 Mon Sep 17 00:00:00 2001
From: "tao.dong" <tao.dong@amlogic.com>
Date: Wed, 18 Dec 2013 21:26:50 +0800
Subject: [PATCH 2550/5965] it cause kernel crash,Revert "add CEC funciton"

This reverts commit 8e21be0be031996887c81333570125d8e795125d.
---
 drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c   |   19 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c        |  345 +--
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c    | 1887 ++++++++++-------
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h    |   47 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c   |   13 +-
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c  |    2 +-
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c |   37 -
 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h |    3 -
 .../amlogic/input/new_remote/remote_func.c    |   19 -
 drivers/amlogic/input/remote/am_remote.c      |   10 +-
 10 files changed, 1307 insertions(+), 1075 deletions(-)
 mode change 100755 => 100644 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
 mode change 100755 => 100644 drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h

diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
index 077212454183..94ccd1645c21 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
@@ -50,14 +50,14 @@ __u16 cec_key_map[128] = {
     0 , 0, 0, 0, 0, 0, 0, 0,//0x30
     0 , 0, 0, 0, 0, 0, 0, 0,
     
-    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
-    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, 0,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, 0, KEY_PREVIOUSSONG, KEY_NEXTSONG, 0, 0, 0,
     0 , 0, 0, 0, 0, 0, 0, 0,//0x50
     0 , 0, 0, 0, 0, 0, 0, 0,
     KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
     0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
     0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
-    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+    0 , 0, 0, 0, 0, 0, 0, 0,
 };
 
 void cec_send_event(cec_rx_message_t* pcec_message)
@@ -86,13 +86,15 @@ void cec_send_event(cec_rx_message_t* pcec_message)
     if(cec_key_flag) {
         input_event(remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
         input_sync(remote_cec_dev);
-        hdmitx_cec_dbg_print("CEC:key map:%d\n",cec_key_map[operands[0]]);
+        hdmitx_cec_dbg_print("CEC:cec_key_map[operands[0]]:%d\n",cec_key_map[operands[0]]);
     }
     else{
         input_event(remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
         input_sync(remote_cec_dev);
-        hdmitx_cec_dbg_print("CEC:key map:%d\n",cec_key_map[operands[0]]);
+        hdmitx_cec_dbg_print("CEC:cec_key_map[operands[0]]:%d\n",cec_key_map[operands[0]]);
     }   
+
+    hdmitx_cec_dbg_print("CEC:cec_send_event\n");
 }
 
 
@@ -111,8 +113,7 @@ void cec_send_event_irq(void)
     
     switch(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
     case 0x33:
-        //cec_system_audio_mode_request();
-        //cec_set_system_audio_mode();
+        cec_system_audio_mode_request();
         break;
     case 0x35:
         break;
@@ -124,7 +125,9 @@ void cec_send_event_irq(void)
     input_sync(remote_cec_dev);	
     input_event(remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
     input_sync(remote_cec_dev);
-    hdmitx_cec_dbg_print("CEC:key map:%d\n",cec_key_map[operands_irq[0]]);      		  	 	
+    hdmitx_cec_dbg_print("CEC:cec_key_map[operands_irq[0]]:%d\n",cec_key_map[operands_irq[0]]);       		
+   	
+    hdmitx_cec_dbg_print("CEC:cec_send_event_irq\n");  	 	
 }
 
 void cec_user_control_pressed_irq(void)
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index f9eb003dcbf1..6e6c76026594 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -30,7 +30,7 @@
 #include <linux/platform_device.h>
 #include <linux/mutex.h>
 #include <linux/cdev.h>
-#include <linux/proc_fs.h>
+#include <linux/proc_fs.h> 
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
@@ -76,7 +76,7 @@ struct hdmi_config_platform_data *hdmi_pdata;
 static hdmitx_dev_t hdmitx_device;
 static struct switch_dev sdev = {	// android ics switch device
 	.name = "hdmi",
-	};
+	};	
 static struct switch_dev hdcp_dev = {	// android ics switch device
 	.name = "hdcp",
 	};
@@ -128,19 +128,19 @@ static struct early_suspend hdmitx_early_suspend_handler = {
 
 #define INIT_FLAG_NOT_LOAD 0x80
 
-int hdmi_ch = 1;        //1: 2ch
+int hdmi_ch = 1;        //1: 2ch   
 
 static unsigned char init_flag=0;
 static unsigned char init_powermode=0;
 #undef DISABLE_AUDIO
 unsigned char hdmi_audio_off_flag = 0;        //if set to 1, then HDMI will output no audio
                                                 //In KTV case, HDMI output Picture only, and Audio is driven by other sources.
-static int hpdmode = 1; /*
-                            0, do not unmux hpd when off or unplug ;
+static int hpdmode = 1; /* 
+                            0, do not unmux hpd when off or unplug ; 
                             1, unmux hpd when unplug;
                             2, unmux hpd when unplug  or off;
                         */
-static int force_vout_index = 0;
+static int force_vout_index = 0;                      
 static int hdmi_prbs_mode = 0xffff; /* 0xffff=disable; 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31*/
 static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
 
@@ -149,7 +149,7 @@ static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
 // write /sys/module/hdmitx/parameters/hdmi_output_force 0
 static int hdmi_output_force = 1;
 
-static int hdmi_authenticated = -1;
+static int hdmi_authenticated = -1;                     
 static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
 static int hdmi_hdcp_status = 1;
 static int hdmi_hdcp_reset = 0;
@@ -182,8 +182,8 @@ static void set_test_mode(void)
                         hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURN_ON_PRBS, hdmi_prbs_mode);
                     }
                 }
-#endif
-
+#endif                
+    
 }
 
 int get_cur_vout_index(void)
@@ -197,7 +197,7 @@ return value: 1, vout; 2, vout2;
         vout_index = force_vout_index;
     }
     else{
-//VPU_VIU_VENC_MUX_CTRL
+//VPU_VIU_VENC_MUX_CTRL        
 // [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
 //         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
 // [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
@@ -206,12 +206,12 @@ return value: 1, vout; 2, vout2;
         int viu1_sel = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
         if(((viu2_sel==1)||(viu2_sel==2))&&
             (viu1_sel!=1)&&(viu1_sel!=2)){
-            vout_index = 2;
+            vout_index = 2;    
         }
     }
 #endif
-    return vout_index;
-}
+    return vout_index;    
+}    
 
 const vinfo_t * hdmi_get_current_vinfo(void)
 {
@@ -230,7 +230,7 @@ const vinfo_t * hdmi_get_current_vinfo(void)
     info = get_current_vinfo();
 #endif
     return info;
-}
+}    
 
 static  int  set_disp_mode(const char *mode)
 {
@@ -284,13 +284,13 @@ static  int  set_disp_mode(const char *mode)
     if(hdmitx_device.cur_VIC == HDMI_Unkown){
         if(hpdmode == 2){
             hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
-            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0; 
         }
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);    
         }
     }
-
+    
     return ret;
 }
 
@@ -300,7 +300,7 @@ static int set_disp_mode_auto(void)
     const vinfo_t *info = hdmi_get_current_vinfo();
     unsigned char mode[10];
     HDMI_Video_Codes_t vic;     //Prevent warning
-
+    
     if(info == NULL) {
         printk("HDMITX: cann't get valid mode\n");
         hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
@@ -375,28 +375,37 @@ static int set_disp_mode_auto(void)
         }
         // If current display is NOT panel, needn't TURNOFF_HDMIHW
         if(strncmp(mode, "panel", 5) == 0){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);    
         }
     }
     return ret;
-}
+}    
 #if 0
 static unsigned int set_cec_code(const char * buf, size_t count)
 {
     char tmpbuf[128];
     int i=0;
+    //int j;
     unsigned int cec_code;
+    //unsigned int value=0;
 
     while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
         tmpbuf[i]=buf[i];
-        i++;
+        i++;    
     }
     tmpbuf[i]=0;
 
     cec_code=simple_strtoul(tmpbuf, NULL, 16);
+    //cec_value=simple_strtoul(buf+i+1, NULL, 16);    
+    //cec_code = param[0];
+    //cec_value = param[1];
+    //printk("\n----------set_cec_code------------ \n");
+
+    //printk("\n----cec_code:%u\n",cec_code);
+    //printk("\n----cec_value:%u\n",cec_value);
     input_event(remote_cec_dev, EV_KEY, cec_code,1);
-    input_event(remote_cec_dev, EV_KEY, cec_code,0);
-    input_sync(remote_cec_dev);
+    input_event(remote_cec_dev, EV_KEY, cec_code,0);       
+    input_sync(remote_cec_dev);  
     return cec_code;
 }
 #endif
@@ -418,19 +427,19 @@ static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr
 {
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
-    return pos;
+    return pos;    
 }
-
+    
 static ssize_t store_disp_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     set_disp_mode(buf);
-    return 16;
+    return 16;    
 }
 
 /*cec attr*/
 static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
 {
-    ssize_t t = cec_usrcmd_get_global_info(buf);
+    ssize_t t = cec_usrcmd_get_global_info(buf);    
     return t;
 }
 
@@ -440,11 +449,17 @@ static ssize_t store_cec(struct device * dev, struct device_attribute *attr, con
     return count;
 }
 
+//static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
+//{
+//    ssize_t t = cec_usrcmd_get_global_info(buf);    
+//    return t;
+//}
+
 static ssize_t show_cec_config(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\r\n", aml_read_reg32(P_AO_DEBUG_REG0));
-    return pos;
+    return pos;  
 }
 
 static ssize_t store_cec_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
@@ -456,7 +471,8 @@ static ssize_t store_cec_config(struct device * dev, struct device_attribute *at
 static ssize_t store_cec_lang_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
 	printk("store_cec_lang_config\n");
-    cec_usrcmd_set_lang_config(buf, count);
+	//cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = strtoul(buf, NULL, 16);
+    cec_usrcmd_set_lang_config(buf, count);   
     return count;
 }
 
@@ -464,28 +480,28 @@ static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute
 {
     int pos=0;
     printk("show_cec_lang_config\n");
-    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);   
     return pos;
 }
 
 /*aud_mode attr*/
 static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
 {
-    return 0;
+    return 0;    
 }
-
+    
 static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     //set_disp_mode(buf);
     Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
     if(strncmp(buf, "32k", 3)==0){
-        audio_param->sample_rate = FS_32K;
+        audio_param->sample_rate = FS_32K; 
     }
     else if(strncmp(buf, "44.1k", 5)==0){
-        audio_param->sample_rate = FS_44K1;
+        audio_param->sample_rate = FS_44K1; 
     }
     else if(strncmp(buf, "48k", 3)==0){
-        audio_param->sample_rate = FS_48K;
+        audio_param->sample_rate = FS_48K; 
     }
     else{
         hdmitx_device.force_audio_flag = 0;
@@ -493,12 +509,12 @@ static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr
     }
     audio_param->type = CT_PCM;
     audio_param->channel_num = CC_2CH;
-    audio_param->sample_size = SS_16BITS;
-
+    audio_param->sample_size = SS_16BITS; 
+    
     hdmitx_device.audio_param_update_flag = 1;
     hdmitx_device.force_audio_flag = 1;
-
-    return count;
+    
+    return count;    
 }
 
 /*edid attr*/
@@ -530,17 +546,17 @@ static ssize_t store_edid(struct device * dev, struct device_attribute *attr, co
             printk("\n");
         }
     }
-    return 16;
+    return 16;    
 }
 
 /*config attr*/
 static ssize_t show_config(struct device * dev, struct device_attribute *attr, char * buf)
-{
+{   
     int pos=0;
     pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
-    return pos;
+    return pos;    
 }
-
+    
 static ssize_t store_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     if(strncmp(buf, "force", 5)==0){
@@ -551,14 +567,14 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
     }
     else if(strncmp(buf, "vdacoff", 7)==0){
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);    
         }
     }
     else if(strncmp(buf, "powermode", 9)==0){
         int tmp;
         tmp = simple_strtoul(buf+9,NULL,10);
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, tmp);
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, tmp); 
             printk("hdmi: set powermode %d\n", tmp);
         }
     }
@@ -575,7 +591,7 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
             hdmi_set_3d(&hdmitx_device, 6, 0);
         }
         else if(strncmp(buf+2, "lr", 2)==0){
-            int sub_sample_mode=0;
+            int sub_sample_mode=0; 
             if(buf[2])
                 sub_sample_mode = simple_strtoul(buf+2,NULL,10);
             hdmi_set_3d(&hdmitx_device, 8, sub_sample_mode); //side by side
@@ -589,22 +605,22 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
             hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_OFF);
         }
         else if(buf[5] == '1') {
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_ON);
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_ON); 
         }
     }
-    return 16;
+    return 16;    
 }
-
-
+  
+    
 static ssize_t store_dbg(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     hdmitx_device.HWOp.DebugFun(&hdmitx_device, buf);
-    return 16;
+    return 16;    
 }
 
 /**/
 static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr, char * buf)
-{
+{   
     int i,pos=0;
     char* disp_mode_t[]={"480i","480p","576i","576p","720p","1080i","1080p","720p50hz","1080i50hz","1080p50hz","1080p24hz","4k2k30hz","4k2k25hz","4k2k24hz","4k2ksmpte",NULL};
     char* native_disp_mode = hdmitx_edid_get_native_VIC(&hdmitx_device);
@@ -626,13 +642,13 @@ static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr,
             }
         }
     }
-    return pos;
+    return pos;    
 }
 
 
 /**/
 static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *attr, char * buf)
-{
+{   
     int i,pos=0;
     int j=0;
     char* disp_mode_t[]={"480i","480p","576i","576p","720p","1080i","1080p","720p50hz","1080i50hz","1080p50hz","1080p24hz","4k2k30hz","4k2k25hz","4k2k24hz","4k2ksmpte",NULL};
@@ -660,14 +676,14 @@ static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *at
     }
     pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
 
-    return pos;
+    return pos;    
 }
 
 /**/
 static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int i,pos=0, j;
-    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS_ATRAC",
+    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS_ATRAC", 
 				"OneBitAudio", "Dobly_Digital+", "DTS-HD", "MAT", "DST", "WMA_Pro", "Reserved", NULL};
     const char* aud_sampling_frequency[] = {"ReferToStreamHeader", "32", "44.1", "48", "88.2", "96", "176.4", "192", NULL};
     const char* aud_sample_size[] = {"ReferToStreamHeader", "16", "20", "24", NULL};
@@ -675,7 +691,7 @@ static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr,
     rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
     pos += snprintf(buf + pos, PAGE_SIZE, "CodingType, MaxChannels, SamplingFrequency, SampleSize\n");
     for(i = 0; i< pRXCap->AUD_count; i++) {
-        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code],
+        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code], 
 			pRXCap->RxAudioCap[i].channel_num_max + 1);
         for(j = 0; j < 7; j++) {
             if(pRXCap->RxAudioCap[i].freq_cc & (1 << j))
@@ -702,22 +718,22 @@ static ssize_t show_aud_ch(struct device * dev, struct device_attribute *attr, c
 static ssize_t store_aud_ch(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     if(strncmp(buf, "6ch", 3) == 0){
-        hdmi_ch = 5;
+        hdmi_ch = 5; 
     }
     else if(strncmp(buf, "8ch", 3) == 0){
-        hdmi_ch = 7;
+        hdmi_ch = 7; 
     }
     else if(strncmp(buf, "2ch", 3) == 0){
-        hdmi_ch = 1;
+        hdmi_ch = 1; 
     }
     else{
         return count;
     }
-
+    
     hdmitx_device.audio_param_update_flag = 1;
     hdmitx_device.force_audio_flag = 1;
 
-    return count;
+    return count;    
 }
 
 static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *attr, char * buf)
@@ -744,10 +760,10 @@ static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *
 }
 
 static ssize_t show_hpd_state(struct device * dev, struct device_attribute *attr, char * buf)
-{
+{   
     int pos=0;
     pos += snprintf(buf+pos, PAGE_SIZE,"%d", hdmitx_device.hpd_state);
-    return pos;
+    return pos;    
 }
 
 static unsigned char* hdmi_log_buf=NULL;
@@ -765,7 +781,7 @@ int hdmi_print_buf(char* buf, int len)
     int hdmi_log_rd_pos_;
     if(hdmi_log_buf_size==0)
         return 0;
-
+    
     spin_lock_irqsave(&hdmi_print_lock, flags);
     hdmi_log_rd_pos_=hdmi_log_rd_pos;
     if(hdmi_log_wr_pos>=hdmi_log_rd_pos)
@@ -776,12 +792,12 @@ int hdmi_print_buf(char* buf, int len)
             hdmi_log_buf[hdmi_log_wr_pos-hdmi_log_buf_size]=buf[pos];
         else
             hdmi_log_buf[hdmi_log_wr_pos]=buf[pos];
-    }
+    }    
     if(hdmi_log_wr_pos>=hdmi_log_buf_size)
         hdmi_log_wr_pos-=hdmi_log_buf_size;
     spin_unlock_irqrestore(&hdmi_print_lock, flags);
     return pos;
-
+    
 }
 
 int hdmi_print(int printk_flag, const char *fmt, ...)
@@ -793,14 +809,14 @@ int hdmi_print(int printk_flag, const char *fmt, ...)
     if(printk_flag){
         va_start(args, fmt);
 	      vprintk(fmt, args);
-        va_end(args);
+        va_end(args);	
     }
     if(hdmi_log_buf_size==0)
         return 0;
-
+        
     va_start(args, fmt);
     len += vsnprintf(buf+len, avail-len, fmt, args);
-    va_end(args);
+    va_end(args);	
 
     if ((avail-len) <= 0) {
         buf[PRINT_TEMP_BUF_SIZE - 1] = '\0';
@@ -811,7 +827,7 @@ int hdmi_print(int printk_flag, const char *fmt, ...)
 }
 
 static ssize_t show_log(struct device * dev, struct device_attribute *attr, char * buf)
-{
+{   
     unsigned long flags;
     int read_size=0;
     if(hdmi_log_buf_size==0)
@@ -828,12 +844,12 @@ static ssize_t show_log(struct device * dev, struct device_attribute *attr, char
         read_size=PAGE_SIZE;
     if(read_size>0)
         memcpy(buf, hdmi_log_buf+hdmi_log_rd_pos, read_size);
-
-    hdmi_log_rd_pos += read_size;
+    
+    hdmi_log_rd_pos += read_size;  
     if(hdmi_log_rd_pos>=hdmi_log_buf_size)
         hdmi_log_rd_pos = 0;
     spin_unlock_irqrestore(&hdmi_print_lock, flags);
-    return read_size;
+    return read_size;    
 }
 
 static ssize_t store_log(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
@@ -846,22 +862,22 @@ static ssize_t store_log(struct device * dev, struct device_attribute *attr, con
         if(tmp==0){
             if(hdmi_log_buf){
                 kfree(hdmi_log_buf);
-                hdmi_log_buf=NULL;
+                hdmi_log_buf=NULL; 
                 hdmi_log_buf_size=0;
-                hdmi_log_rd_pos=0;
-                hdmi_log_wr_pos=0;
-            }
-        }
+                hdmi_log_rd_pos=0;   
+                hdmi_log_wr_pos=0;   
+            }    
+        }    
         if((tmp>=1024)&&(hdmi_log_buf==NULL)){
             hdmi_log_buf_size=0;
-            hdmi_log_rd_pos=0;
-            hdmi_log_wr_pos=0;
+            hdmi_log_rd_pos=0;   
+            hdmi_log_wr_pos=0;   
             hdmi_log_buf=kmalloc(tmp, GFP_KERNEL);
             if(hdmi_log_buf){
                 hdmi_log_buf_size=tmp;
                 hdmitx_device.HWOp.DebugFun(&hdmitx_device, "v");
             }
-        }
+        }            
         spin_unlock_irqrestore(&hdmi_print_lock, flags);
         //printk("hdmi_store:set bufsize tmp %d %d\n",tmp, hdmi_log_buf_size);
     }
@@ -885,11 +901,12 @@ static DEVICE_ATTR(hpd_state, S_IWUSR | S_IRUGO, show_hpd_state, NULL);
 static DEVICE_ATTR(log, S_IWUSR | S_IRUGO, show_log, store_log);
 static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
 static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO , show_cec_config, store_cec_config);
+//static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
 static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO , show_cec_lang_config, store_cec_lang_config);
 
 /*****************************
-*    hdmitx display client interface
-*
+*    hdmitx display client interface 
+*    
 ******************************/
 static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
 {
@@ -981,111 +998,111 @@ static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long
 {
     struct snd_pcm_substream *substream =(struct snd_pcm_substream*)para;
     Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
-
+    
     switch (substream->runtime->rate) {
         case 192000:
-            audio_param->sample_rate = FS_192K;
+            audio_param->sample_rate = FS_192K; 
             break;
         case 176400:
-            audio_param->sample_rate = FS_176K4;
+            audio_param->sample_rate = FS_176K4; 
             break;
         case 96000:
-            audio_param->sample_rate = FS_96K;
+            audio_param->sample_rate = FS_96K; 
             break;
         case 88200:
-            audio_param->sample_rate = FS_88K2;
+            audio_param->sample_rate = FS_88K2; 
             break;
         case 48000:
-            audio_param->sample_rate = FS_48K;
+            audio_param->sample_rate = FS_48K; 
             break;
         case 44100:
-            audio_param->sample_rate = FS_44K1;
+            audio_param->sample_rate = FS_44K1; 
             break;
         case 32000:
-            audio_param->sample_rate = FS_32K;
+            audio_param->sample_rate = FS_32K; 
             break;
         default:
             printk("HDMI: unknown audio frequence\n");
             break;
     }
     hdmi_print(1, "HDMI: aout notify rate %d\n", substream->runtime->rate);
-
+    
     switch (cmd){
     case AOUT_EVENT_IEC_60958_PCM:
         audio_param->type = CT_PCM;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS;     
         hdmi_print(1, "HDMI: aout notify format PCM\n");
         break;
     case AOUT_EVENT_RAWDATA_AC_3:
         audio_param->type = CT_AC_3;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format AC-3\n");
         break;
     case AOUT_EVENT_RAWDATA_MPEG1:
         audio_param->type = CT_MPEG1;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format MPEG1(Layer1 2)\n");
         break;
     case AOUT_EVENT_RAWDATA_MP3:
         audio_param->type = CT_MP3;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format MP3(MPEG1 Layer3)\n");
         break;
     case AOUT_EVENT_RAWDATA_MPEG2:
         audio_param->type = CT_MPEG2;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format MPEG2\n");
         break;
     case AOUT_EVENT_RAWDATA_AAC:
         audio_param->type = CT_AAC;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format AAC\n");
         break;
     case AOUT_EVENT_RAWDATA_DTS:
         audio_param->type = CT_DTS;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format DTS\n");
         break;
     case AOUT_EVENT_RAWDATA_ATRAC:
         audio_param->type = CT_ATRAC;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format ATRAC\n");
         break;
     case AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO:
         audio_param->type = CT_ONE_BIT_AUDIO;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format One Bit Audio\n");
         break;
     case AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS:
         audio_param->type = CT_DOLBY_D;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         //audio_param->sample_rate = FS_48K;//192K;      // FS_48K;       //
         hdmi_print(1, "HDMI: aout notify format Dobly Digital +\n");
         printk("audio sample_rate: %d\n", substream->runtime->rate);
         break;
     case AOUT_EVENT_RAWDATA_DTS_HD:
         audio_param->type = CT_DTS_HD;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format DTS-HD\n");
         break;
     case AOUT_EVENT_RAWDATA_MAT_MLP:
         audio_param->type = CT_MAT;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format MAT(MLP)\n");
         break;
     case AOUT_EVENT_RAWDATA_DST:
         audio_param->type = CT_DST;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format DST\n");
         break;
     case AOUT_EVENT_RAWDATA_WMA_PRO:
         audio_param->type = CT_WMA;
-        audio_param->sample_size = SS_16BITS;
+        audio_param->sample_size = SS_16BITS; 
         hdmi_print(1, "HDMI: aout notify format WMA Pro\n");
         break;
     default:
         break;
-    }
+    }    
 
     audio_param->channel_num = substream->runtime->channels - 1;
 
@@ -1125,7 +1142,7 @@ static int hdmi_task_monitor_handle(void *data)
     return 0;
 }
 
-static int hdmi_task_handle(void *data)
+static int hdmi_task_handle(void *data) 
 {
     extern void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t*);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)data;
@@ -1140,28 +1157,28 @@ static int hdmi_task_handle(void *data)
 
     if(hdmitx_device->HWOp.Cntl){
         if(init_flag&INIT_FLAG_VDACOFF){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);    
         }
         if(init_powermode&0x80){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, init_powermode&0x1f);
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, init_powermode&0x1f);    
         }
     }
     if(init_flag&INIT_FLAG_POWERDOWN){
         hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //power down
         hdmitx_device->unplug_powerdown=1;
         if(hdmitx_device->HWOp.Cntl){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);    
         }
     }
     else{
         if(hdmitx_device->HWOp.Cntl){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);    
         }
     }
     if(hdmitx_device->HWOp.Cntl){
         hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_IP_INTR_MASN_RST, 0);
     }
-
+    
     HDMI_DEBUG();
 
     while (hdmitx_device->hpd_event != 0xff)
@@ -1182,7 +1199,7 @@ static int hdmi_task_handle(void *data)
                 hdmitx_device->hpd_event = 1;
             }
         }
-
+        
         if((!hdmi_audio_off_flag)&&(hdmitx_device->audio_param_update_flag))//todo &&
             //((hdmitx_device->cur_VIC != HDMI_Unkown)||(hdmitx_device->force_audio_flag))){
                 {
@@ -1190,7 +1207,7 @@ static int hdmi_task_handle(void *data)
             hdmitx_device->audio_param_update_flag = 0;
             hdmi_print(1, "HDMI: set audio param\n");
         }
-
+        
         if(hdmitx_device->hpd_state == 0) {
             hdmitx_device->HWOp.Cntl(hdmitx_device, HMDITX_PHY_SUSPEND, 0);
         }
@@ -1206,16 +1223,18 @@ static int hdmi_task_handle(void *data)
                 hdmitx_edid_parse(hdmitx_device);
                 hdmitx_device->tv_no_edid = 0;
                 set_disp_mode_auto();
-            }
+
+				switch_set_state(&sdev, 1);
+                cec_node_init(hdmitx_device);
+            }    
             else{
                 hdmi_print(1,"HDMI: EDID Bad\n");
                 hdmitx_device->tv_no_edid = 1;
                 set_disp_mode_auto();
+                switch_set_state(&sdev, 1);
+                printk("test:aml_read_reg32(P_AO_DEBUG_REG0)%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
+                cec_node_init(hdmitx_device);
             }
-
-            switch_set_state(&sdev, 1);
-            cec_node_init(hdmitx_device);
-
             if(hdmitx_device->hpd_event ==1)
                 hdmitx_device->hpd_event = 0;
         }
@@ -1232,10 +1251,11 @@ static int hdmi_task_handle(void *data)
             hdmitx_edid_clear(hdmitx_device);
             //When unplug hdmi, clear the hdmitx module edid ram and edid buffer.
             hdmitx_edid_ram_buffer_clear(hdmitx_device);
+            cec_node_uninit(hdmitx_device);
             if(hdmitx_device->unplug_powerdown){
                 hdmitx_set_display(hdmitx_device, HDMI_Unkown);
                 if(hdmitx_device->HWOp.Cntl){
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
+                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);    
                 }
             }
             hdmitx_device->cur_VIC = HDMI_Unkown;
@@ -1250,11 +1270,7 @@ static int hdmi_task_handle(void *data)
                 hdmi_hdcp_reset = 1;
             }
             switch_set_state(&hdcp_dev, 0);
-#ifdef CONFIG_ARCH_MESON6
-
-            aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear int for cec fiq.
-#endif
-        }
+        }    
         else{
         }
         msleep(100);
@@ -1291,7 +1307,7 @@ static int hdmi_task_handle(void *data)
                     hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_ON);
                     hdmitx_device->repeater_hdcp_cmd = 0;
                 }
-
+                
                 if(hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, IS_HDCP_ON)){
                     hdmi_authenticated = hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_GET_AUTHENTICATE_STATE, 0);
                     //printk("hdmi_authenticated =%d\n", hdmi_authenticated);
@@ -1300,7 +1316,7 @@ static int hdmi_task_handle(void *data)
                 }
             }
             else
-#endif
+#endif                
             {
 	            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_OFF);
 	            if(hdmi_hdcp_process == 0){    // 0: stop hdcp
@@ -1340,7 +1356,7 @@ static int hdmi_task_handle(void *data)
             hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
             hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, 1);
         }
-        /**/
+        /**/    
 next:
         if(hdmitx_device->HWOp.Cntl(hdmitx_device, IS_HDCP_ON, 0)) {
             msleep(10);
@@ -1369,10 +1385,9 @@ void hdmi_pre_set_change_mode(void)
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_CBUS_RST, 0);
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_IP_SW_RST, TX_SYS_SW_RST);
     //msleep(50);
-    //hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
-    //Don't clear irq for M8 cec tx msg(irq).otherwise broken down when standby.
-    //hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
-    msleep(20);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
+//    msleep(20);
     printk("%s[%d]\n", __func__, __LINE__);
     hdmitx_device.internal_mode_change = 0;
 }
@@ -1380,8 +1395,8 @@ EXPORT_SYMBOL(hdmi_pre_set_change_mode);
 
 /* Linux */
 /*****************************
-*    hdmitx driver file_operations
-*
+*    hdmitx driver file_operations 
+*    
 ******************************/
 static int amhdmitx_open(struct inode *node, struct file *file)
 {
@@ -1554,7 +1569,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
 
     HDMI_DEBUG();
     pr_dbg("amhdmitx_probe\n");
-
+ 
     r = alloc_chrdev_region(&hdmitx_id, 0, HDMI_TX_COUNT, DEVICE_NAME);
     if (r < 0) {
         pr_error("Can't register major for amhdmitx device\n");
@@ -1567,17 +1582,17 @@ static int amhdmitx_probe(struct platform_device *pdev)
         return -1;
         //return PTR_ERR(aoe_class);
     }
-
+                    
     hdmitx_device.unplug_powerdown=0;
     hdmitx_device.vic_count=0;
     hdmitx_device.auth_process_timer=0;
     hdmitx_device.force_audio_flag=0;
     hdmitx_device.tv_cec_support=0;
-
+    
 #ifdef CONFIG_HAS_EARLYSUSPEND
     register_early_suspend(&hdmitx_early_suspend_handler);
 #endif
-
+    
     if((init_flag&INIT_FLAG_POWERDOWN)&&(hpdmode==2)){
         hdmitx_device.mux_hpd_if_pin_high_flag=0;
     }
@@ -1590,7 +1605,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
     cdev_add(&(hdmitx_device.cdev), hdmitx_id, HDMI_TX_COUNT);
 
     //hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, "amhdmitx%d", 0);
-    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27
+    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27 
 
     ret=device_create_file(hdmitx_dev, &dev_attr_disp_mode);
     ret=device_create_file(hdmitx_dev, &dev_attr_aud_mode);
@@ -1607,7 +1622,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
     ret=device_create_file(hdmitx_dev, &dev_attr_cec);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
-
+    
     if (hdmitx_dev == NULL) {
         pr_error("device_create create error\n");
         class_destroy(hdmitx_class);
@@ -1718,10 +1733,10 @@ static int amhdmitx_remove(struct platform_device *pdev)
     }
     hdmitx_device.hpd_event = 0xff;
     kthread_stop(hdmitx_device.task);
-
-    vout_unregister_client(&hdmitx_notifier_nb_v);
+    
+    vout_unregister_client(&hdmitx_notifier_nb_v);    
 #ifdef CONFIG_AM_TV_OUTPUT2
-    vout2_unregister_client(&hdmitx_notifier_nb_v2);
+    vout2_unregister_client(&hdmitx_notifier_nb_v2);    
 #endif
 #ifndef DISABLE_AUDIO
 #ifdef CONFIG_SND_AML_SOC
@@ -1828,7 +1843,7 @@ static int  __init amhdmitx_init(void)
     HDMI_DEBUG();
     if(init_flag&INIT_FLAG_NOT_LOAD)
         return 0;
-
+        
     pr_dbg("amhdmitx_init\n");
     printk("HDMI Ver: %s\n", HDMITX_VER);
     if(hdmi_log_buf_size>0){
@@ -1840,7 +1855,7 @@ static int  __init amhdmitx_init(void)
 
     if (platform_driver_register(&amhdmitx_driver)) {
         pr_error("failed to register amhdmitx module\n");
-#if 0
+#if 0        
         platform_device_del(amhdmi_tx_device);
         platform_device_put(amhdmi_tx_device);
 #endif
@@ -1856,7 +1871,7 @@ static void __exit amhdmitx_exit(void)
 {
     pr_dbg("amhdmitx_exit\n");
     platform_driver_unregister(&amhdmitx_driver);
-//\\    platform_device_unregister(amhdmi_tx_device);
+//\\    platform_device_unregister(amhdmi_tx_device); 
 //\\    amhdmi_tx_device = NULL;
     return ;
 }
@@ -1909,7 +1924,7 @@ static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned o
                 return pToken + 1;
             }
             trans_char_flag = 0;
-        }
+        }        
         if (pToken) {
             *token_len = (unsigned)(buf + offset - pToken);
             *token_offset = offset;
@@ -1924,7 +1939,7 @@ static  int __init hdmitx_boot_para_setup(char *s)
     char *token;
     unsigned token_len, token_offset, offset=0;
     int size=strlen(s);
-
+    
     HDMI_DEBUG();
     do{
         token=next_token_ex(separator, s, size, offset, &token_len, &token_offset);
@@ -1943,10 +1958,10 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 hdmi_pll_mode = 1;
             }
             else if((token_len==7)&& (strncmp(token, "hpdmode", token_len)==0)){
-                hpdmode = simple_strtoul(token+7,NULL,10);
+                hpdmode = simple_strtoul(token+7,NULL,10);   
             }
             else if((token_len==3)&&(strncmp(token, "rgb", 3)==0)){
-                hdmitx_output_rgb();
+                hdmitx_output_rgb();    
             }
             else if(strncmp(token, "audpara", 7)==0){
                 int tmp;
@@ -1959,17 +1974,17 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 tmp = simple_strtoul(token+7,NULL,10);
                 if(tmp>=1024){
                     hdmi_log_buf_size=0;
-                    hdmi_log_rd_pos=0;
-                    hdmi_log_wr_pos=0;
+                    hdmi_log_rd_pos=0;   
+                    hdmi_log_wr_pos=0;   
                     hdmi_log_buf_size=tmp;
                     printk("hdmi: set log buffer size %d\n", tmp);
-                }
+                }            
             }
             else if(strncmp(token, "powermode", 9)==0){
                 int tmp;
                 tmp = simple_strtoul(token+9,NULL,10);
                 init_powermode=tmp|0x80;
-                printk("hdmi: set init powermode %d\n", tmp);
+                printk("hdmi: set init powermode %d\n", tmp);                
             }
             else if(strncmp(token, "audiooff", 8)==0){
                 hdmi_audio_off_flag = 1;
@@ -1977,11 +1992,11 @@ static  int __init hdmitx_boot_para_setup(char *s)
             }
             else if(strncmp(token, "prbs", 4)==0){
                 hdmi_prbs_mode = simple_strtoul(token+4,NULL,16);
-                printk("hdmi, set prbs mode as %x always\n", hdmi_prbs_mode);
+                printk("hdmi, set prbs mode as %x always\n", hdmi_prbs_mode);    
             }
             else if(strncmp(token, "480p_clk", 8)==0){
                 hdmi_480p_force_clk = simple_strtoul(token+8,NULL,10);
-                printk("hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);
+                printk("hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);    
             }
             else if(strncmp(token, "cec", 3)==0) {
                 unsigned int list = simple_strtoul(token+3,NULL,16);
@@ -1997,7 +2012,7 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 printk("HDMI aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
                 printk("HDMI hdmi_cec_func_config:0x%x\n",hdmitx_device.cec_func_config);
             }
-        }
+        }    
         offset=token_offset;
     }while(token);
     return 0;
@@ -2013,17 +2028,17 @@ unsigned char get_hdmi_tx_state(unsigned char type)
         return hdmitx_device.hpd_state;
     }
     else if(type == HDMI_TX_STATE_HDCP_AUTH){ //hdcp
-        return hdmi_authenticated;
+        return hdmi_authenticated;    
     }
     else if(type == HDMI_TX_STATE_HDCP_CMD_DONE){
         if(hdmitx_device.repeater_hdcp_cmd == 0){
-            return 1;
+            return 1;  
         }
         else{
             return 0;
-        }
+        }  
     }
-
+    
 }
 
 #define HDMI_TX_HDCP_MODE_NONE_REPEATER     0
@@ -2041,9 +2056,8 @@ void hdmi_repeater_enable_hdcp(unsigned char enable)
     else{
         hdmitx_device.repeater_hdcp_cmd = 2;
     }
-
+    
 }
-#endif            
 
 __setup("hdmitx=",hdmitx_boot_para_setup);
 
@@ -2065,3 +2079,4 @@ module_param(hdmi_hdcp_process, int, 0664);
 MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
 module_param(hdmi_output_force, int, 0664);
 
+#endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index 360af7d62798..aef299fbbe4c 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -41,7 +41,6 @@
 #include <linux/spinlock.h>
 #include <linux/spinlock_types.h>
 #include <linux/switch.h>
-#include <linux/workqueue.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -54,65 +53,61 @@
 #include "hdmi_tx_module.h"
 #include "hdmi_info_global.h"
 #include "hdmi_tx_cec.h"
-#include "hdmi_parameter.h"
 
+//static void remote_cec_tasklet(unsigned long);
+//static int REMOTE_CEC_IRQ = INT_REMOTE;
+//DECLARE_TASKLET_DISABLED(tasklet_cec, remote_cec_tasklet, 0);
 static hdmitx_dev_t *hdmitx_device = NULL;
 struct input_dev *remote_cec_dev;
 DEFINE_SPINLOCK(cec_input_key);
-DEFINE_SPINLOCK(cec_init_lock);
-static DEFINE_MUTEX(cec_mutex);
+DEFINE_SPINLOCK(cec_rx_lock);
+DEFINE_SPINLOCK(cec_tx_lock);
+DEFINE_SPINLOCK(cec_init_lock); 
 static DECLARE_WAIT_QUEUE_HEAD(cec_key_poll);
 
+//#define _RX_DATA_BUF_SIZE_ 6
+
 /* global variables */
 static	unsigned char    gbl_msg[MAX_MSG];
 cec_global_info_t cec_global_info;
 unsigned char cec_power_flag = 0;
+unsigned char cec_tx_flag = 0;
+unsigned char cec_rx_flag = 0;
 EXPORT_SYMBOL(cec_power_flag);
 unsigned char rc_long_press_pwr_key = 0;
 EXPORT_SYMBOL(rc_long_press_pwr_key);
-static int cec_msg_dbg_en = 0;
+static bool cec_msg_dbg_en = 0; 
+static unsigned char test_buf[128] = { 0 };
 static int cec_fiq_flag = 0;
 static void cec_gpi_receive_bits(void);
-static int cec_repeat_flag = 0;
-static unsigned int cec_init_ready_flag = 0;
-static int repeat;
-static int cec_ll_tx_polling(const unsigned char *msg, unsigned char len);
-
-/**************************************************
- *                  cec rx work queue             *
- *                                                *
- **************************************************/
-
-#define CEC_WQ  0
-struct work_struct cec_wq_func;
-void cec_do_work(unsigned long data);
-
-void cec_do_work(unsigned long data){
-    //cec_isr_post_process();
-}
-#if CEC_WQ
-struct workqueue_struct *cec_wq;
-#endif
 
 ssize_t	cec_lang_config_state(struct switch_dev *sdev, char *buf){
     int pos=0;
-    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff,
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff, 
                                                   (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
                                                   (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 0) & 0xff);
-    return pos;
+    return pos;  
 };
 
 struct switch_dev lang_dev = {	// android ics switch device
 	.name = "lang_config",
 	.print_state = cec_lang_config_state,
-	};
+	};	
 EXPORT_SYMBOL(lang_dev);
 
+static struct semaphore  tv_cec_sema;
+
 static DEFINE_SPINLOCK(p_tx_list_lock);
+//static DEFINE_SPINLOCK(cec_tx_lock);
+
 static unsigned long cec_tx_list_flags;
+//static unsigned long cec_tx_flags;
 static unsigned int tx_msg_cnt = 0;
+
 static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
 
+//static tv_cec_polling_state_e cec_polling_state = TV_CEC_POLLING_OFF;
+
 unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
                                   (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
                                   (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
@@ -126,17 +121,104 @@ static unsigned char * osd_name = "Amlogic MBox";
 static unsigned int vendor_id = 0x00;
 
 cec_rx_msg_buf_t cec_rx_msg_buf;
+
 static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
-#ifdef CONFIG_ARCH_MESON6
 static void cec_gpi_init(void);
-#endif
+
+//static unsigned char dev = 0;
 static unsigned char cec_init_flag = 0;
+static unsigned char cec_mutex_flag = 0;
+
+
+//static unsigned int hdmi_rd_reg(unsigned long addr);
+//static void hdmi_wr_reg(unsigned long addr, unsigned long data);
+
+void cec_test_function(unsigned char* arg, unsigned char arg_cnt)
+{
+//    int i;
+//    char buf[512];
+//
+//    switch (arg[0]) {
+//    case 0x0:
+//        cec_usrcmd_parse_all_dev_online();
+//        break;
+//    case 0x2:
+//        cec_usrcmd_get_audio_status(arg[1]);
+//        break;
+//    case 0x3:
+//        cec_usrcmd_get_deck_status(arg[1]);
+//        break;
+//    case 0x4:
+//        cec_usrcmd_get_device_power_status(arg[1]);
+//        break;
+//    case 0x5:
+//        cec_usrcmd_get_device_vendor_id(arg[1]);
+//        break;
+//    case 0x6:
+//        cec_usrcmd_get_osd_name(arg[1]);
+//        break;
+//    case 0x7:
+//        cec_usrcmd_get_physical_address(arg[1]);
+//        break;
+//    case 0x8:
+//        cec_usrcmd_get_system_audio_mode_status(arg[1]);
+//        break;
+//    case 0x9:
+//        cec_usrcmd_get_tuner_device_status(arg[1]);
+//        break;
+//    case 0xa:
+//        cec_usrcmd_set_deck_cnt_mode(arg[1], arg[2]);
+//        break;
+//    case 0xc:
+//        cec_usrcmd_set_imageview_on(arg[1]);
+//        break;
+//    case 0xd:
+//        cec_usrcmd_set_play_mode(arg[1], arg[2]);
+//        break;
+//    case 0xe:
+//        cec_usrcmd_get_menu_state(arg[1]);
+//        break;
+//    case 0xf:
+//        cec_usrcmd_set_menu_state(arg[1], arg[2]);
+//        break;
+//    case 0x10:
+//        cec_usrcmd_get_global_info(buf);
+//        break;
+//    case 0x11:
+//        cec_usrcmd_get_menu_language(arg[1]);
+//        break;
+//    case 0x12:
+//        cec_usrcmd_set_menu_language(arg[1], arg[2]);
+//        break;
+//    case 0x13:
+//        cec_usrcmd_get_active_source();
+//        break;
+//    case 0x14:
+//        cec_usrcmd_set_active_source();
+//        break;
+//    case 0x15:
+//        cec_usrcmd_set_deactive_source(arg[1]);
+//        break;
+//    case 0x17:
+//        cec_usrcmd_set_report_physical_address(arg[1], arg[2], arg[3], arg[4]);
+//        break;
+//    case 0x18:
+//    	{int i = 0;
+//    	cec_polling_online_dev(arg[1], &i);
+//    	}
+//    	break;
+//    default:
+//        break;
+//    }
+}
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend hdmitx_cec_early_suspend_handler;
 static void hdmitx_cec_early_suspend(struct early_suspend *h)
 {
+//    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
+    //cec_node_uninit((hdmitx_dev_t *)h->param);
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         cec_menu_status_smp(DEVICE_MENU_INACTIVE);
         cec_inactive_source();
@@ -151,7 +233,8 @@ static void hdmitx_cec_early_suspend(struct early_suspend *h)
 
 static void hdmitx_cec_late_resume(struct early_suspend *h)
 {
-    cec_hw_reset();//for M8 CEC standby.
+//    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
+    //cec_node_init((hdmitx_dev_t *)h->param);
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
 		cec_imageview_on_smp();
 		cec_active_source_smp();
@@ -164,6 +247,32 @@ static void hdmitx_cec_late_resume(struct early_suspend *h)
 
 #endif
 
+/***************************** cec low level code *****************************/
+/*
+static unsigned int cec_get_ms_tick(void)
+{
+    unsigned int ret = 0;
+    struct timeval cec_tick;
+    do_gettimeofday(&cec_tick);
+    ret = cec_tick.tv_sec * 1000 + cec_tick.tv_usec / 1000;
+
+    return ret;
+}
+*/
+/*
+static unsigned int cec_get_ms_tick_interval(unsigned int last_tick)
+{
+    unsigned int ret = 0;
+    unsigned int tick = 0;
+    struct timeval cec_tick;
+    do_gettimeofday(&cec_tick);
+    tick = cec_tick.tv_sec * 1000 + cec_tick.tv_usec / 1000;
+
+    if (last_tick < tick) ret = tick - last_tick;
+    else ret = ((unsigned int)(-1) - last_tick) + tick;
+    return ret;
+}
+*/
 
 int cec_ll_rx( unsigned char *msg, unsigned char *len)
 {
@@ -175,20 +284,14 @@ int cec_ll_rx( unsigned char *msg, unsigned char *len)
     unsigned char n;
     unsigned char *msg_start = msg;
     int rx_msg_length;
-#ifdef CONFIG_ARCH_MESON6
-    printk("cec irq status: rx: 0x%x; tx: 0x%x\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS), hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS));
+    
     if(RX_DONE != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS)){
         hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        //hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD, RX_DISABLE);
         hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
         return -1;
     }
-
-    if(1 != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_NUM_MSG)){
-        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
-        return -1;
-    }
-
+    
     rx_msg_length = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_MSG_LENGTH) + 1;
 
     hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
@@ -201,36 +304,9 @@ int cec_ll_rx( unsigned char *msg, unsigned char *len)
     *len = rx_msg_length;
     rx_status = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS);
 
+    //hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD, RX_DISABLE);
 
     hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-
-    if(RX_DONE != aocec_rd_reg(CEC_RX_MSG_STATUS)){
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
-        return -1;
-    }
-    if(1 != aocec_rd_reg(CEC_RX_NUM_MSG)){
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
-        return -1;
-    }
-    rx_msg_length = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
-
-    aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-
-    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
-        data = aocec_rd_reg(CEC_RX_MSG_0_HEADER +i);
-        *msg = data;
-        msg++;
-    }
-    *len = rx_msg_length;
-    rx_status = aocec_rd_reg(CEC_RX_MSG_STATUS);
-
-    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
-    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
-#endif
     if(cec_msg_dbg_en == 1){
         pos = 0;
         pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
@@ -249,7 +325,11 @@ void cec_isr_post_process(void)
     /* isr post process */
     while(cec_rx_msg_buf.rx_read_pos != cec_rx_msg_buf.rx_write_pos) {
         cec_handle_message(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_read_pos]));
-        (cec_rx_msg_buf.rx_read_pos == cec_rx_msg_buf.rx_buf_size - 1) ? (cec_rx_msg_buf.rx_read_pos = 0) : (cec_rx_msg_buf.rx_read_pos++);
+        if (cec_rx_msg_buf.rx_read_pos == cec_rx_msg_buf.rx_buf_size - 1) {
+            cec_rx_msg_buf.rx_read_pos = 0;
+        } else {
+            cec_rx_msg_buf.rx_read_pos++;
+        }
     }
 }
 
@@ -257,47 +337,25 @@ void cec_usr_cmd_post_process(void)
 {
     cec_tx_message_list_t *p, *ptmp;
     /* usr command post process */
+    //spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
+
     list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list) {
         cec_ll_tx(p->msg, p->length);
         unregister_cec_tx_msg(p);
     }
 }
+
 #if 0
 static int detect_tv_support_cec(unsigned addr)
 {
     unsigned int ret = 0;
     unsigned char msg[1];
     msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
-    ret = cec_ll_tx_polling(msg, 1);
-    cec_hw_reset();
+    ret = cec_ll_tx(msg, 1);
     printk("CEC: tv%shave CEC feature\n", ret ? " " : " don\'t ");
     return (hdmitx_device->tv_cec_support = ret);
 }
 #endif
-#ifdef CONFIG_ARCH_MESON8
-//--------------------------------------------------------------------------
-// AO CEC0 config
-//--------------------------------------------------------------------------
-static void ao_cec_init(void)
-{
-    unsigned long data32;
-    // Assert SW reset AO_CEC
-    data32  = 0;
-    data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
-    data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
-    aml_write_reg32(P_AO_CEC_GEN_CNTL, data32);
-    // Enable gated clock (Normal mode).
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
-    // Release SW reset
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
-
-    // Enable all AO_CEC interrupt sources
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
-
-    // Device 0 config
-    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
-}
-#endif
 
 void cec_node_init(hdmitx_dev_t* hdmitx_device)
 {
@@ -309,12 +367,12 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
                                                     CEC_PLAYBACK_DEVICE_3_ADDR,
                                                    };
 
-    unsigned long cec_phy_addr;
+    //unsigned long cec_init_flags;
+    cec_tx_flag = 1;
+    cec_rx_flag = 1;
     cec_power_flag = 1;
-    //if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
-    if((cec_init_ready_flag == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
-        printk("CEC not ready,cec_init_ready:0x%x;hpd_state:0x%x\n",hdmitx_device->cec_init_ready, hdmitx_device->hpd_state);
-        printk("cec_init_ready_flag:0x%x\n", cec_init_ready_flag);
+    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+        printk("CEC not ready\n");
         return;
     }
     else {
@@ -328,110 +386,114 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
         printk("hdmitx: cec: no valid cec physical address\n");
         return ;
     }
-#if 1       //todo
     if(hdmitx_device->config_data.vend_data)
         vend_data = hdmitx_device->config_data.vend_data;
     if((vend_data) && (vend_data->cec_osd_string)) {
         i = strlen(vend_data->cec_osd_string);
-        if(i > 14)
+        if(i > 14) 
             vend_data->cec_osd_string[14] = '\0';   // OSD string length must be less than 14 bytes
         osd_name = vend_data->cec_osd_string;
     }
     if((vend_data) && (vend_data->vendor_id)) {
         vendor_id = (vend_data->vendor_id ) & 0xffffff;
     }
-#endif
-#ifdef CONFIG_ARCH_MESON6
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
-    // Clear CEC Int. state and set CEC Int. mask
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
 
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1); 
+#if 0
+    //Init GPIOx_27 IN for HDMI CEC arbitration
+    //Disable I2C_SDA_B:reg5[31]
+    //Disable I2C_SDA_SLAVE:reg5[29]
+    //Enable GPIOx_27 IN:0x2018[27]
+    //GPIOx_27 IN:0x201a[27]
+    aml_write_reg32(P_PERIPHS_PIN_MUX_5, aml_read_reg32(P_PERIPHS_PIN_MUX_5) & (~(1 << 31)));
+    aml_write_reg32(P_PERIPHS_PIN_MUX_5, aml_read_reg32(P_PERIPHS_PIN_MUX_5) & (~(1 << 29))); 
+    aml_write_reg32(P_PREG_PAD_GPIO4_EN_N, aml_read_reg32(P_PREG_PAD_GPIO4_EN_N) | (1 << 27));
 #endif
-#ifdef CONFIG_ARCH_MESON8
-#if 1           // Please match with H/W cec config
-// GPIOAO_12
-    aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 0, 12, 1);       // disable AO_12 internal pull-up   //fe60002c
-    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);      // AO_CEC pinmux                    //fe600014
-    ao_cec_init();
-#else
-// GPIOH_3
-    aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG1, 0, 19, 1);    // disable gpioh_3 internal pull-up
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 23, 1);      // gpioh_3 cec pinmux
-#endif
-    cec_arbit_bit_time_set(3, 0x118, 0);
-    cec_arbit_bit_time_set(5, 0x000, 0);
-    cec_arbit_bit_time_set(7, 0x2aa, 0);
-#endif
-    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
-                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
-                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
-                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
-
+    // Clear CEC Int. state and set CEC Int. mask
+////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
 
-	for(i = 0; i < 3; i++){
-	    printk("CEC: start poll dev\n");
+    
+	for(i = 0; i < 3; i++){ 
+	    //hdmitx_cec_dbg_print("CEC: start poll dev\n");  	
 		cec_polling_online_dev(player_dev[i], &bool);
 		hdmitx_cec_dbg_print("CEC: player_dev[%d]:0x%x\n", i, player_dev[i]);
 		//hdmitx_cec_dbg_print("CEC: end poll dev\n");
 		if(bool == 0){  // 0 means that no any respond
-            aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
-		    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
+		    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;	
             cec_global_info.my_node_index = player_dev[i];
             aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
             cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
             // Set Physical address
-            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
-
+            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = ( ((hdmitx_device->hdmi_info.vsdb_phy_addr.a)<<12)
+            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.b)<< 8)
+            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.c)<< 4)
+            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.d)    )
+            	    												);
+            	    												
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF;
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;
-
-            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
+                        	    												
             cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
-#ifdef CONFIG_ARCH_MESON6
+            //hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
             hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-            aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-#endif
+		    
      		hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", player_dev[i]);
-
+            
+            //cec_hw_reset();
+            //spin_lock_irqsave(&cec_init_lock,cec_init_flags);
             hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
-        	if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
-        	    break;
-            msleep(100);
-			cec_report_physical_address_smp();
-            msleep(150);
-            cec_device_vendor_id((cec_rx_message_t*)0);
+            
+            cec_report_physical_address_smp();
+            
+
 
-            msleep(150);
+            cec_device_vendor_id((cec_rx_message_t*)0);
+            
+            cec_imageview_on_smp();
+            msleep(200);
             cec_imageview_on_smp();
-            msleep(100);
 
             // here, we need to detect whether TV is supporting the CEC function
             // if not, jump out to save system time
-            //if(!detect_tv_support_cec(player_dev[i])) {
-            //    printk("HDMI CEC: No TV detected.\n");
+            //if(!detect_tv_support_cec(player_dev[i])) 
             //    break;
-            //}
             cec_get_menu_language_smp();
-            msleep(350);
-
+            
             cec_active_source_smp();
-            msleep(120);
-
+            //cec_usrcmd_set_report_physical_address();
+
+            //cec_report_physical_address_smp();
+
+            //cec_get_menu_language_smp();
+            
+            //cec_device_vendor_id((cec_rx_message_t*)0);
+            
+            //cec_set_osd_name_init();
+            
+            //cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
+            
+            //msleep(200);
+            //cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV again
+            //msleep(200);
+            //hdmitx_cec_dbg_print("CEC: Set physical address: %x\n", cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4);
+            
+            //cec_usrcmd_set_active_source(); 
+            
+            //spin_unlock_irqrestore(&cec_init_lock,cec_init_flags);
+            //cec_active_source(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_read_pos]));    
+            
             cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-            msleep(100);
-
+            
             cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
             cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
             break;
 		}
-	}
+	}	
 	if(bool == 1)
 		hdmitx_cec_dbg_print("CEC: Can't get a valid logical address\n");
 }
@@ -442,7 +504,12 @@ void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
        return ;
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
     cec_power_flag = 0;
+    cec_tx_flag = 0;
+    cec_rx_flag = 0;
     hdmitx_cec_dbg_print("CEC: cec node uninit!\n");
+    //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+    //free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
 }
 
@@ -450,6 +517,12 @@ static int cec_task(void *data)
 {
 	extern void dump_hdmi_cec_reg(void);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
+
+//    hdmitx_cec_dbg_print("CEC: Physical Address [A]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.a);
+//    hdmitx_cec_dbg_print("CEC: Physical Address [B]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.b);
+//    hdmitx_cec_dbg_print("CEC: Physical Address [C]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.c);
+//    hdmitx_cec_dbg_print("CEC: Physical Address [D]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.d);
+
     cec_init_flag = 1;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -461,21 +534,25 @@ static int cec_task(void *data)
     register_early_suspend(&hdmitx_cec_early_suspend_handler);
 #endif
 
+    //cec_node_init(hdmitx_device);
+    
+//    dump_hdmi_cec_reg();
+    
     // Get logical address
 
     hdmitx_cec_dbg_print("CEC: CEC task process\n");
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
         msleep(10000);
-#ifdef CONFIG_ARCH_MESON6
         cec_gpi_init();
-#endif
-		printk("cec_func_config:0x%x\n", hdmitx_device->cec_func_config);
         cec_node_init(hdmitx_device);
     }
     while (1) {
-        msleep(5);
+        if(down_interruptible(&tv_cec_sema))
+           continue; 
+                
         cec_isr_post_process();
-        //cec_usr_cmd_post_process();
+        cec_usr_cmd_post_process();
+        //\\cec_timer_post_process();
     }
 
     return 0;
@@ -489,17 +566,26 @@ static int cec_task(void *data)
 void register_cec_rx_msg(unsigned char *msg, unsigned char len )
 {
     unsigned long flags;
-    spin_lock_irqsave(&cec_input_key,flags);
+    //    hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);  
     memset((void*)(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
     memcpy(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
 
     cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
     cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].msg_length = len;
-
+    
+    //spin_lock(&cec_input_key);
+    spin_lock_irqsave(&cec_input_key,flags);
     cec_input_handle_message();
-
-    (cec_rx_msg_buf.rx_write_pos == cec_rx_msg_buf.rx_buf_size - 1) ? (cec_rx_msg_buf.rx_write_pos = 0) : (cec_rx_msg_buf.rx_write_pos++);
     spin_unlock_irqrestore(&cec_input_key,flags);
+    //spin_unlock(&cec_input_key);    
+    //wake_up_interruptible(&cec_key_poll);
+    if (cec_rx_msg_buf.rx_write_pos == cec_rx_msg_buf.rx_buf_size - 1) {
+        cec_rx_msg_buf.rx_write_pos = 0;
+    } else {
+        cec_rx_msg_buf.rx_write_pos++;
+    }
+
+    up(&tv_cec_sema);    
 }
 
 void register_cec_tx_msg(unsigned char *msg, unsigned char len )
@@ -516,29 +602,146 @@ void register_cec_tx_msg(unsigned char *msg, unsigned char len )
         spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
 
         tx_msg_cnt++;
+        up(&tv_cec_sema); 
     }
 }
 void cec_input_handle_message(void)
 {
     unsigned char   opcode;
+    //unsigned char   operand_num;
+    //unsigned char   msg_length;
+    
+//    hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);  
 
-    opcode = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
+    opcode = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.opcode;   
+    //operand_num = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num;
+    //msg_length  = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].msg_length;
 
-    /* process key event messages from tv */
+    /* process messages from tv polling and cec devices */
+    //hdmitx_cec_dbg_print("----OP code----: %x\n", opcode);
     if((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) && cec_power_flag)
     {
         switch (opcode) {
+        /*case CEC_OC_ACTIVE_SOURCE:
+            cec_active_source(pcec_message);
+            break;
+        case CEC_OC_INACTIVE_SOURCE:
+            cec_deactive_source(pcec_message);
+            break;
+        case CEC_OC_CEC_VERSION:
+            cec_report_version(pcec_message);
+            break;
+        case CEC_OC_DECK_STATUS:
+            cec_deck_status(pcec_message);
+            break;
+        case CEC_OC_DEVICE_VENDOR_ID:
+            cec_device_vendor_id(pcec_message);
+            break;
+        case CEC_OC_FEATURE_ABORT:
+            cec_feature_abort(pcec_message);
+            break;
+        case CEC_OC_GET_CEC_VERSION:
+            cec_get_version(pcec_message);
+            break;
+        case CEC_OC_GIVE_DECK_STATUS:
+            cec_give_deck_status(pcec_message);
+            break;
+        case CEC_OC_MENU_STATUS:
+            cec_menu_status(pcec_message);
+            break;
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+            cec_report_phy_addr(pcec_message);
+            break;
+        case CEC_OC_REPORT_POWER_STATUS:
+            cec_report_power_status(pcec_message);
+            break;
+        case CEC_OC_SET_OSD_NAME:
+            cec_set_osd_name(pcec_message);
+            break;
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            cec_vendor_cmd_with_id(pcec_message);
+            break;
+        case CEC_OC_SET_MENU_LANGUAGE:
+            cec_set_menu_language(pcec_message);
+            break;
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+            cec_give_physical_address(pcec_message);
+            break;
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+            cec_give_device_vendor_id(pcec_message);
+            break;
+        case CEC_OC_GIVE_OSD_NAME:
+            cec_give_osd_name(pcec_message);
+            break;
+        case CEC_OC_STANDBY:
+              hdmitx_cec_dbg_print("----cec_standby-----");
+            cec_standby(pcec_message);
+            break;
+        case CEC_OC_SET_STREAM_PATH:
+            cec_set_stream_path(pcec_message);
+            break;
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+            cec_request_active_source(pcec_message);
+            break;
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+            cec_give_device_power_status(pcec_message);
+            break;
+            
+         case CEC_OC_STANDBY:
+            if(POWER_ON != cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status)
+                break; 
+            cec_standby_irq();
+            break;
+            */      
         case CEC_OC_USER_CONTROL_PRESSED:
-            // check valid msg
-            {
-                unsigned char opernum;
-                unsigned char follower;
-                opernum  = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num;
-                follower = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
-                if(opernum != 1 || follower == 0xf) break;
-            }
             cec_user_control_pressed_irq();
             break;
+        case CEC_OC_USER_CONTROL_RELEASED:
+            //cec_user_control_released_irq();
+            break; 
+        //case CEC_OC_IMAGE_VIEW_ON:      //not support in source
+        //      cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
+        //      break;  
+        case CEC_OC_ROUTING_CHANGE: 
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_TEXT_VIEW_ON:       //not support in source
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_SET_ANALOGUE_TIMER :
+        case CEC_OC_SET_AUDIO_RATE:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_PLAY:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_ABORT_MESSAGE:
+            //hdmitx_cec_dbg_print("CEC: not support cmd: %x\n", opcode);
+            break;
         default:
             break;
         }
@@ -559,12 +762,11 @@ void unregister_cec_tx_msg(cec_tx_message_list_t* cec_tx_message_list)
 
 void cec_hw_reset(void)
 {
-#ifdef CONFIG_ARCH_MESON6
     aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
     hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0xc); //[3]cec_creg_sw_rst [2]cec_sys_sw_rst
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x1);
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x1);
-
+    
     //mdelay(10);
     {//Delay some time
     	int i = 10;
@@ -578,33 +780,6 @@ void cec_hw_reset(void)
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
 
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-
-    //unsigned long data32;
-    // Assert SW reset AO_CEC
-    //data32  = 0;
-    //data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
-    //data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
-    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
-    // Enable gated clock (Normal mode).
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
-    // Release SW reset
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
-
-    // Enable all AO_CEC interrupt sources
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
-
-    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
-
-    //Cec arbitration 3/5/7 bit time set.
-    cec_arbit_bit_time_set(3, 0x118, 0);
-    cec_arbit_bit_time_set(5, 0x000, 0);
-    cec_arbit_bit_time_set(7, 0x2aa, 0);
-
-    printk("hw reset :logical addr:0x%x\n", aocec_rd_reg(CEC_LOGICAL_ADDR0));
-
-#endif
 }
 
 unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
@@ -612,7 +787,6 @@ unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
     unsigned char rt = 0;
     unsigned char opcode;
     unsigned char opernum;
-    unsigned char follower;
     if (!pcec_message)
         return rt;
 
@@ -721,149 +895,34 @@ unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
             break;
     }
 
- // for CTS12.2
-    follower = pcec_message->content.msg.header & 0x0f;
-    switch (opcode) {
-        case CEC_OC_ACTIVE_SOURCE:
-        case CEC_OC_REQUEST_ACTIVE_SOURCE:
-        case CEC_OC_ROUTING_CHANGE:
-        case CEC_OC_ROUTING_INFORMATION:
-        case CEC_OC_SET_STREAM_PATH:
-        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-        case CEC_OC_SET_MENU_LANGUAGE:
-        case CEC_OC_DEVICE_VENDOR_ID:
-            // broadcast only
-            if(follower != 0xf) rt = 0;
-            break;
-
-        case CEC_OC_IMAGE_VIEW_ON:
-        case CEC_OC_TEXT_VIEW_ON:
-        case CEC_OC_INACTIVE_SOURCE:
-        case CEC_OC_RECORD_OFF:
-        case CEC_OC_RECORD_ON:
-        case CEC_OC_RECORD_STATUS:
-        case CEC_OC_RECORD_TV_SCREEN:
-        case CEC_OC_CLEAR_ANALOGUE_TIMER:
-        case CEC_OC_CLEAR_DIGITAL_TIMER:
-        case CEC_OC_CLEAR_EXTERNAL_TIMER:
-        case CEC_OC_SET_ANALOGUE_TIMER:
-        case CEC_OC_SET_DIGITAL_TIMER:
-        case CEC_OC_SET_EXTERNAL_TIMER:
-        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
-        case CEC_OC_TIMER_CLEARED_STATUS:
-        case CEC_OC_TIMER_STATUS:
-        case CEC_OC_CEC_VERSION:
-        case CEC_OC_GET_CEC_VERSION:
-        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
-        case CEC_OC_GET_MENU_LANGUAGE:
-        case CEC_OC_DECK_CONTROL:
-        case CEC_OC_DECK_STATUS:
-        case CEC_OC_GIVE_DECK_STATUS:
-        case CEC_OC_PLAY:
-        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
-        case CEC_OC_SELECT_ANALOGUE_SERVICE:
-        case CEC_OC_SELECT_DIGITAL_SERVICE:
-        case CEC_OC_TUNER_DEVICE_STATUS:
-        case CEC_OC_TUNER_STEP_DECREMENT:
-        case CEC_OC_TUNER_STEP_INCREMENT:
-        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-        case CEC_OC_VENDOR_COMMAND:
-        case CEC_OC_SET_OSD_STRING:
-        case CEC_OC_GIVE_OSD_NAME:
-        case CEC_OC_SET_OSD_NAME:
-        case CEC_OC_MENU_REQUEST:
-        case CEC_OC_MENU_STATUS:
-        case CEC_OC_USER_CONTROL_PRESSED:
-        case CEC_OC_USER_CONTROL_RELEASED:
-        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-        case CEC_OC_REPORT_POWER_STATUS:
-        case CEC_OC_FEATURE_ABORT:
-        case CEC_OC_ABORT_MESSAGE:
-        case CEC_OC_GIVE_AUDIO_STATUS:
-        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_REPORT_AUDIO_STATUS:
-        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
-        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_SET_AUDIO_RATE:
-            // directly addressed only
-            if(follower == 0xf) rt = 0;
-            break;
-
-        case CEC_OC_STANDBY:
-        case CEC_OC_VENDOR_COMMAND_WITH_ID:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
-        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
-            // both broadcast and directly addressed
-            break;
-
-        default:
-            break;
-    }
-
     if ((rt == 0) & (opcode != 0)){
         hdmirx_cec_dbg_print("CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
     }
+    
+    //?????rt = 1; // temporal
     return rt;
 }
 
-void cec_disable_irq(void)
-{
-#ifdef CONFIG_ARCH_MESON6
-    //Disable irq
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));
-    //Clear the interrupt
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    // disable all AO_CEC interrupt sources
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 0, 3);
-    printk("disable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
-#endif
-}
-void cec_enable_irq(void)
-{
-#ifdef CONFIG_ARCH_MESON6
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) & ~(1 << 23));
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
-    printk("enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
-#endif
-}
+//static char *tx_status[] = {
+//    "TX_IDLE ",
+//    "TX_BUSY ",
+//    "TX_DONE ",
+//    "TX_ERROR",
+//};
 
 static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
 {
+    unsigned int data_msg_num;
     unsigned char rx_msg[MAX_MSG], rx_len;
-    unsigned int intr_stat = 0;
-
-    //cec_disable_irq();
 
-#ifdef CONFIG_ARCH_MESON8
-    intr_stat = aml_read_reg32(P_AO_CEC_INTR_STAT);
-    printk("aocec irq %x\n", intr_stat);
-
-    if(intr_stat & (1<<1)) { // aocec tx intr
-        tx_irq_handle();
-        //cec_enable_irq();
+    data_msg_num = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_NUM_MSG);             
+    //cec_ll_rx(rx_msg, &rx_len);
+    if((-1) == cec_ll_rx(rx_msg, &rx_len))
         return IRQ_HANDLED;
-    }
-#endif
-    if((-1) == cec_ll_rx(rx_msg, &rx_len)){
-        //cec_enable_irq();
-        return IRQ_HANDLED;
-    }
+    register_cec_rx_msg(rx_msg, rx_len);                
 
-#if CEC_WQ
-    queue_work(cec_wq, &cec_wq_func);
-#else
-    schedule_work(&cec_wq_func);
-#endif
-
-    register_cec_rx_msg(rx_msg, rx_len);
-
-    //cec_enable_irq();
+//    Clear the interrupt
+//    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) & ~(1 << 23));
 
     return IRQ_HANDLED;
 }
@@ -885,72 +944,142 @@ unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
 
     return us;
 }
+//
+//static cec_hdmi_port_e cec_find_hdmi_port(unsigned char log_addr)
+//{
+//    cec_hdmi_port_e rt = CEC_HDMI_PORT_UKNOWN;
+//
+//    if ((cec_global_info.dev_mask & (1 << log_addr)) &&
+//            (cec_global_info.cec_node_info[log_addr].phy_addr != 0) &&
+//            (cec_global_info.cec_node_info[log_addr].hdmi_port == CEC_HDMI_PORT_UKNOWN)) {
+//        if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x1000) {
+//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_1;
+//        } else if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x2000) {
+//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_2;
+//        } else if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x3000) {
+//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_3;
+//        }
+//    }
+//
+//    rt = cec_global_info.cec_node_info[log_addr].hdmi_port;
+//
+//    return rt;
+//}
+
 // -------------- command from cec devices ---------------------
 
 void cec_polling_online_dev(int log_addr, int *bool)
 {
+    //int log_addr = 0;
     unsigned long r;
+    unsigned short dev_mask_tmp = 0;
     unsigned char msg[1];
 
-    cec_global_info.my_node_index = log_addr;
-    msg[0] = (log_addr<<4) | log_addr;
-#ifdef CONFIG_ARCH_MESON6
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
-    r = cec_ll_tx(msg, 1);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
-    hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%lx\n",aocec_rd_reg(CEC_LOGICAL_ADDR0));
-    r = cec_ll_tx_polling(msg, 1);
-    cec_hw_reset();
-
-#endif
-
-    if (r == 0) {
-        *bool = 0;
-    }else{
-        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
-        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-    	  *bool = 1;
-    }
+    //for (log_addr = 1; log_addr < CEC_UNREGISTERED_ADDR; log_addr++) {
+        hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG3):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG3));
+        //if(aml_read_reg32(P_AO_DEBUG_REG3) & 0xf){
+        //    *bool = 0;
+        //    cec_global_info.my_node_index = aml_read_reg32(P_AO_DEBUG_REG3) & 0xf;
+        //    return;
+        //}
+        cec_global_info.my_node_index = log_addr;
+        msg[0] = (log_addr<<4) | log_addr;
+        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+        hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%lx\n",hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
+        r = cec_ll_tx(msg, 1);
+            
+        if (r == 0) {
+            //dev_mask_tmp |= 1 << log_addr;
+            //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
+            //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+            //cec_global_info.cec_node_info[log_addr].dev_type = CEC_PLAYBACK_DEVICE_TYPE;
+//            cec_find_hdmi_port(log_addr);
+            *bool = 0;
+            //cec_hw_reset();
+            //msleep(200);
+        }else{
+            dev_mask_tmp &= ~(1 << log_addr);
+            memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
+            //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
+            //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);            
+            cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+        	  *bool = 1;
+        }
     if(*bool == 0) {
-#ifdef CONFIG_ARCH_MESON6
         hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
-#endif
     }
     hdmitx_cec_dbg_print("CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
 
+    if (cec_global_info.dev_mask != dev_mask_tmp) {
+        cec_global_info.dev_mask = dev_mask_tmp;
+    }
+}
+
+void cec_report_phy_addr(cec_rx_message_t* pcec_message)
+{
+    //unsigned char index = cec_global_info.my_node_index;
+    ////unsigned char log_addr = pcec_message->content.msg.header >> 4;
+
+    //cec_global_info.dev_mask |= 1 << index;
+    //cec_global_info.cec_node_info[index].dev_type = cec_log_addr_to_dev_type(index);
+    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DEVICE_TYPE;
+    //memcpy(cec_global_info.cec_node_info[index].osd_name_def, default_osd_name[index], 16);
+    //if ((cec_global_info.cec_node_info[index].real_info_mask & INFO_MASK_OSD_NAME) == 0) {
+    //    memcpy(cec_global_info.cec_node_info[index].osd_name, osd_name_uninit, 16);
+    //}
+    //cec_global_info.cec_node_info[index].log_addr = index;
+    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_LOGIC_ADDRESS;
+    //cec_global_info.cec_node_info[index].phy_addr.phy_addr_4 = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
+    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_PHYSICAL_ADDRESS;
+//
+
 }
 
+void cec_give_physical_address(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    
+    //if (cec_global_info.dev_mask & (1 << log_addr)) {
+        unsigned char msg[5];
+        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+        msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
+        msg[2] = phy_addr_ab;
+        msg[3] = phy_addr_cd;
+        msg[4] = cec_global_info.cec_node_info[index].log_addr;
+        //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+        //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
+        //msg[4] = cec_global_info.cec_node_info[index].log_addr;
+        cec_ll_tx(msg, 5);
+    //}
+//    hdmirx_cec_dbg_print("cec_report_phy_addr: %x\n", cec_global_info.cec_node_info[index].log_addr);
+}
 
 //***************************************************************
 void cec_device_vendor_id(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[5];
-
+    
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_DEVICE_VENDOR_ID;
     msg[2] = (vendor_id >> 16) & 0xff;
     msg[3] = (vendor_id >> 8) & 0xff;
     msg[4] = (vendor_id >> 0) & 0xff;
-
+    
     cec_ll_tx(msg, 5);
 }
 
 void cec_report_power_status(cec_rx_message_t* pcec_message)
 {
+    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
     unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_REPORT_POWER_STATUS;
-    msg[2] = cec_global_info.cec_node_info[index].power_status;
-    cec_ll_tx(msg, 3);
-
+    if (cec_global_info.dev_mask & (1 << index)) {
+        cec_global_info.cec_node_info[index].power_status = pcec_message->content.msg.operands[0];
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_POWER_STATUS;
+        hdmirx_cec_dbg_print("cec_report_power_status: %x\n", cec_global_info.cec_node_info[index].power_status);
+    }
 }
 
 void cec_feature_abort(cec_rx_message_t* pcec_message)
@@ -958,40 +1087,51 @@ void cec_feature_abort(cec_rx_message_t* pcec_message)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char opcode = pcec_message->content.msg.opcode;
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
-    if(dst_log_addr != 0xf){
-        unsigned char msg[4];
 
+    if(opcode != 0xf){
+        unsigned char msg[4];
+        
         msg[0] = ((index & 0xf) << 4) | src_log_addr;
         msg[1] = CEC_OC_FEATURE_ABORT;
         msg[2] = opcode;
         msg[3] = CEC_UNRECONIZED_OPCODE;
-
-        cec_ll_tx(msg, 4);
+        
+        cec_ll_tx(msg, 4);        
     }
+    
+    //hdmirx_cec_dbg_print("cec_feature_abort: opcode %x\n", pcec_message->content.msg.opcode);
 }
 
 void cec_report_version(cec_rx_message_t* pcec_message)
 {
-    ;//todo
+    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
+    unsigned char index = cec_global_info.my_node_index;   
+    if (cec_global_info.dev_mask & (1 << index)) {
+        cec_global_info.cec_node_info[index].cec_version = pcec_message->content.msg.operands[0];
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_CEC_VERSION;
+        hdmirx_cec_dbg_print("cec_report_version: %x\n", cec_global_info.cec_node_info[index].cec_version);
+    }
 }
 
 
 void cec_report_physical_address_smp(void)
 {
-    unsigned char msg[5];
+    unsigned char msg[5]; 
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;    
+    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);     
+    
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
     msg[2] = phy_addr_ab;
     msg[3] = phy_addr_cd;
-    msg[4] = cec_global_info.cec_node_info[index].dev_type;
-
+    //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+    //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
+    msg[4] = cec_global_info.cec_node_info[index].dev_type;                        
+    
     cec_ll_tx(msg, 5);
-
+        
 }
 
 void cec_imageview_on_smp(void)
@@ -999,25 +1139,29 @@ void cec_imageview_on_smp(void)
     unsigned char msg[2];
     unsigned char index = cec_global_info.my_node_index;
 
+    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);   
+    //hdmitx_cec_dbg_print("cec_func_config:0x%x\n",hdmitx_device->cec_func_config);  
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
             msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
             msg[1] = CEC_OC_IMAGE_VIEW_ON;
             cec_ll_tx(msg, 2);
         }
-    }
+    }  
 }
 
 void cec_get_menu_language_smp(void)
 {
     unsigned char msg[2];
     unsigned char index = cec_global_info.my_node_index;
+    
+    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
 
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_GET_MENU_LANGUAGE;
-
+    
     cec_ll_tx(msg, 2);
-
+    
 }
 
 void cec_menu_status(cec_rx_message_t* pcec_message)
@@ -1027,9 +1171,17 @@ void cec_menu_status(cec_rx_message_t* pcec_message)
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
 
      if(0xf != src_log_addr) {
-        msg[0] = ((index & 0xf) << 4) | src_log_addr;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = cec_global_info.cec_node_info[index].menu_status;
+            msg[0] = ((index & 0xf) << 4) | src_log_addr;
+            msg[1] = CEC_OC_MENU_STATUS;
+        if((2 == pcec_message->content.msg.operands[0])){    
+            msg[2] = cec_global_info.cec_node_info[index].menu_status;
+        }else if(0 == pcec_message->content.msg.operands[0]){
+            cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+            msg[2] = DEVICE_MENU_INACTIVE;        
+        }else{
+            cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+            msg[2] = DEVICE_MENU_ACTIVE; 
+        }
         cec_ll_tx(msg, 3);
     }
 }
@@ -1039,41 +1191,71 @@ void cec_menu_status_smp(cec_device_menu_state_e status)
     unsigned char msg[3];
     unsigned char index = cec_global_info.my_node_index;
 
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_MENU_STATUS;
-    if(status == DEVICE_MENU_ACTIVE){
+    if(status == DEVICE_MENU_ACTIVE){    
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_MENU_STATUS;
         msg[2] = DEVICE_MENU_ACTIVE;
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
     }else{
-        msg[2] = DEVICE_MENU_INACTIVE;
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = DEVICE_MENU_INACTIVE;        
     }
     cec_ll_tx(msg, 3);
+    
+    //MSG_P1( index, CEC_TV_ADDR,
+    //        CEC_OC_MENU_STATUS, 
+    //        DEVICE_MENU_ACTIVE
+    //        );
+
+    //register_cec_tx_msg(gbl_msg, 3); 
+
 }
 
-void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
+void cec_menu_status_smp_irq(unsigned int status)
 {
+    unsigned char msg[3];
     unsigned char index = cec_global_info.my_node_index;
 
-    if(1 == pcec_message->content.msg.operands[0]){
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
-    }else if(0 == pcec_message->content.msg.operands[0]){
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    if(status == DEVICE_MENU_ACTIVE){    
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = DEVICE_MENU_ACTIVE;
+    }else{
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = DEVICE_MENU_INACTIVE;        
     }
+    cec_ll_tx(msg, 3);
+    
+    //MSG_P1( index, CEC_TV_ADDR,
+    //        CEC_OC_MENU_STATUS, 
+    //        DEVICE_MENU_ACTIVE
+    //        );
+
+    //register_cec_tx_msg(gbl_msg, 3); 
+
 }
+EXPORT_SYMBOL(cec_menu_status_smp_irq);
 
-void cec_active_source_rx(cec_rx_message_t* pcec_message)
+void cec_active_source_irq(void)
 {
-    unsigned int phy_addr_active;
-
-    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                    (pcec_message->content.msg.operands[1] << 0));
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
+    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
 
-	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {    
+            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+            msg[1] = CEC_OC_ACTIVE_SOURCE;
+            msg[2] = phy_addr_ab;
+            msg[3] = phy_addr_cd;
+            //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+            //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
+            cec_ll_tx(msg, 4);
+        }
+    }
 }
 
 void cec_active_source_smp(void)
@@ -1081,87 +1263,114 @@ void cec_active_source_smp(void)
     unsigned char msg[4];
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
+    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
 
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {    
             msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
             msg[1] = CEC_OC_ACTIVE_SOURCE;
             msg[2] = phy_addr_ab;
             msg[3] = phy_addr_cd;
+            //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+            //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
             cec_ll_tx(msg, 4);
         }
     }
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
 }
 void cec_active_source(cec_rx_message_t* pcec_message)
 {
     unsigned char msg[4];
+    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
     unsigned char index = cec_global_info.my_node_index;
+    //unsigned short phy_addr = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_ACTIVE_SOURCE;
-    msg[2] = phy_addr_ab;
-    msg[3] = phy_addr_cd;
-    cec_ll_tx(msg, 4);
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-}
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;    
 
+    //if (cec_global_info.dev_mask & (1 << log_addr)) {
+//    if (phy_addr == cec_global_info.cec_node_info[index].phy_addr.phy_addr_4) {
 
+        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+        msg[1] = CEC_OC_ACTIVE_SOURCE;
+        msg[2] = phy_addr_ab;
+        msg[3] = phy_addr_cd;
+        //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+        //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
+        cec_ll_tx(msg, 4);
+        
+//        MSG_P2( index, CEC_TV_ADDR, 
+//                CEC_OC_ACTIVE_SOURCE, 
+//                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
+//                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
+        
+//        register_cec_tx_msg(gbl_msg, 4);         
+//    }else{
+//        cec_deactive_source(pcec_message);    	
+//    }
+}
+
+//////////////////////////////////
 void cec_set_stream_path(cec_rx_message_t* pcec_message)
 {
-    unsigned int phy_addr_active;
-
-    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                    (pcec_message->content.msg.operands[1] << 0));
-
-	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_active_source_smp();
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
+//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned short phy_addr = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
+            
+    //if (cec_global_info.dev_mask & (1 << log_addr)) {
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {    
+        if(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))
+        {    
+            if (phy_addr == cec_global_info.cec_node_info[index].phy_addr.phy_addr_4) {    
+                unsigned char msg[4];
+                msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+                msg[1] = CEC_OC_ACTIVE_SOURCE;
+                msg[2] = phy_addr_ab;
+                msg[3] = phy_addr_cd;
+                //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+                //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
+                cec_ll_tx(msg, 4);
+            }
+        }
+    }
 }
 void cec_set_system_audio_mode(void)
 {
     unsigned char index = cec_global_info.my_node_index;
 
     MSG_P1( index, CEC_TV_ADDR,
-            CEC_OC_SET_SYSTEM_AUDIO_MODE,
+    //MSG_P1( index, CEC_BROADCAST_ADDR,  
+            CEC_OC_SET_SYSTEM_AUDIO_MODE, 
             cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
             );
-
-    cec_ll_tx(gbl_msg, 3);
+    
+    register_cec_tx_msg(gbl_msg, 3);
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
     else
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;    	      
 }
 
 void cec_system_audio_mode_request(void)
 {
     unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF){
-        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
-                phy_addr_ab,
-                phy_addr_cd
+        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST, 
+                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
+                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd
                 );
-        cec_ll_tx(gbl_msg, 4);
+        register_cec_tx_msg(gbl_msg, 4);    	
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
     }
-    else{
-        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
-                );
-        cec_ll_tx(gbl_msg, 2);
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
-    }
+    else{        
+        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 
+                ); 
+        register_cec_tx_msg(gbl_msg, 2);    	
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF; 
+    }   	      
 }
 
 void cec_report_audio_status(void)
@@ -1169,27 +1378,41 @@ void cec_report_audio_status(void)
     unsigned char index = cec_global_info.my_node_index;
 
     MSG_P1( index, CEC_TV_ADDR,
-            CEC_OC_REPORT_AUDIO_STATUS,
+    //MSG_P1( index, CEC_BROADCAST_ADDR,  
+            CEC_OC_REPORT_AUDIO_STATUS, 
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
             );
 
-    cec_ll_tx(gbl_msg, 3);
+    register_cec_tx_msg(gbl_msg, 3);   	      
 }
 void cec_request_active_source(cec_rx_message_t* pcec_message)
 {
     cec_set_stream_path(pcec_message);
 }
 
+void cec_give_device_power_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    //if (cec_global_info.dev_mask & (1 << log_addr)) {
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_REPORT_POWER_STATUS;
+        msg[2] = cec_global_info.cec_node_info[index].power_status;
+        cec_ll_tx(msg, 3);
+    //}
+}
+
 void cec_set_imageview_on_irq(void)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[2];
-
+    
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_IMAGE_VIEW_ON;
 
-    cec_ll_tx(msg, 2);
+    cec_ll_tx(msg, 2);    
 }
 
 void cec_inactive_source(void)
@@ -1197,20 +1420,33 @@ void cec_inactive_source(void)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[4];
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
+        
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_INACTIVE_SOURCE;
 	msg[2] = phy_addr_ab;
 	msg[3] = phy_addr_cd;
 
-    cec_ll_tx(msg, 4);
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+    cec_ll_tx(msg, 4);    
 }
-
-void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
+void cec_deactive_source(cec_rx_message_t* pcec_message)
 {
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
+    unsigned char index = cec_global_info.my_node_index;    
+    
+    //if (cec_global_info.dev_mask & (1 << log_addr)) {
+    //    if (cec_global_info.active_log_dev == log_addr) {
+    //    cec_global_info.active_log_dev = 0;
+    //    }
+    //    hdmirx_cec_dbg_print("cec_deactive_source: %x\n", log_addr);
+    //}
+    
+    MSG_P2( index, CEC_TV_ADDR, 
+            CEC_OC_INACTIVE_SOURCE, 
+            cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
+            cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
+
+    register_cec_tx_msg(gbl_msg, 4); 
 }
 
 void cec_get_version(cec_rx_message_t* pcec_message)
@@ -1222,27 +1458,27 @@ void cec_get_version(cec_rx_message_t* pcec_message)
     if (0xf != dest_log_addr) {
         msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
         msg[1] = CEC_OC_CEC_VERSION;
-        msg[2] = CEC_VERSION_14A;
+        msg[2] = CEC_VERSION_13A;
         cec_ll_tx(msg, 3);
     }
 }
 
 void cec_give_deck_status(cec_rx_message_t* pcec_message)
 {
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index; 
+    MSG_P1( index, CEC_TV_ADDR, 
+            CEC_OC_DECK_STATUS, 
+            0x1a);
 
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_DECK_STATUS;
-    msg[2] = 0x1a;
-    cec_ll_tx(msg, 3);
+    register_cec_tx_msg(gbl_msg, 3); 
 }
 
 
 void cec_deck_status(cec_rx_message_t* pcec_message)
 {
-    unsigned char index = cec_global_info.my_node_index;
-
+//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
+    unsigned char index = cec_global_info.my_node_index; 
+        
     if (cec_global_info.dev_mask & (1 << index)) {
         cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
         cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
@@ -1260,6 +1496,8 @@ void cec_set_standby(void)
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
 			cec_ll_tx(msg, 2);
+			//mdelay(100);
+			cec_rx_flag = 0;
 		}
 	}
 }
@@ -1270,10 +1508,11 @@ void cec_set_osd_name(cec_rx_message_t* pcec_message)
 	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
     unsigned char msg[16];
-
+        
     if(0xf != src_log_addr) {
         msg[0] = ((index & 0xf) << 4) | src_log_addr;
         msg[1] = CEC_OC_SET_OSD_NAME;
+
         memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
 
         cec_ll_tx(msg, 2 + osd_len);
@@ -1295,7 +1534,18 @@ void cec_set_osd_name_init(void)
 
 void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
 {
-    ;//todo
+//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
+//    unsigned char index = cec_global_info.my_node_index;  
+//    if (cec_global_info.dev_mask & (1 << index)) {
+//        if (cec_global_info.cec_node_info[index].vendor_id.vendor_id_byte_num != 0) {
+//            int i = cec_global_info.cec_node_info[index].vendor_id.vendor_id_byte_num;
+//            int tmp = 0;
+//            for ( ; i < pcec_message->operand_num; i++) {
+//                tmp |= (pcec_message->content.msg.operands[i] << ((cec_global_info.cec_node_info[log_addr].vendor_id.vendor_id_byte_num - i - 1)*8));
+//            }
+//            hdmirx_cec_dbg_print("cec_vendor_cmd_with_id: %lx, %x\n", cec_global_info.cec_node_info[log_addr].vendor_id.vendor_id, tmp);
+//        }
+//    }
 }
 
 
@@ -1303,17 +1553,20 @@ void cec_set_menu_language(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-
+    
     if(0x0 == src_log_addr) {
         cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
                                                                (pcec_message->content.msg.operands[1] <<  8)  |
                                                                (pcec_message->content.msg.operands[2]));
-
+        
+        
         switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
         cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
-        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
+        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff, 
                                                                  (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
                                                                  (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
+    }else{
+        //cec_feature_abort(pcec_message);
     }
 }
 
@@ -1325,8 +1578,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
     unsigned char   msg_length;
 
     /* parse message */
-    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
-        return;
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) //return;
 
     initiator	= pcec_message->content.msg.header >> 4;
     follower	= pcec_message->content.msg.header & 0x0f;
@@ -1337,26 +1589,36 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
 
     if(0 == pcec_message->content.msg.header)
         return;
-
     /* process messages from tv polling and cec devices */
+//    hdmitx_cec_dbg_print("OP code: 0x%x\n", opcode);
+//    hdmitx_cec_dbg_print("cec_power_flag: 0x%x\n", cec_power_flag);
+//    hdmitx_cec_dbg_print("cec: cec_func_config: 0x%x\n", hdmitx_device->cec_func_config);
     if(CEC_OC_GIVE_OSD_NAME == opcode)
         cec_set_osd_name(pcec_message);
     if((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) && cec_power_flag)
-    {
+    {    
 
         switch (opcode) {
         case CEC_OC_ACTIVE_SOURCE:
-            cec_active_source_rx(pcec_message);
+            //if((0 == pcec_message->content.msg.operands[0]) && (0 == pcec_message->content.msg.operands[1]))
+                //cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+                //cec_active_source_smp();
+            //cec_deactive_source(pcec_message);
             break;
         case CEC_OC_INACTIVE_SOURCE:
+            //cec_deactive_source(pcec_message);
             break;
         case CEC_OC_CEC_VERSION:
+            //cec_report_version(pcec_message);
             break;
         case CEC_OC_DECK_STATUS:
+            //cec_deck_status(pcec_message);
             break;
         case CEC_OC_DEVICE_VENDOR_ID:
+            //cec_device_vendor_id(pcec_message);
             break;
         case CEC_OC_FEATURE_ABORT:
+            //cec_feature_abort(pcec_message);
             break;
         case CEC_OC_GET_CEC_VERSION:
             cec_get_version(pcec_message);
@@ -1365,94 +1627,114 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             cec_give_deck_status(pcec_message);
             break;
         case CEC_OC_MENU_STATUS:
-            cec_menu_status_smp_irq(pcec_message);
+            //cec_menu_status(pcec_message);
+            //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
             break;
         case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+            cec_report_phy_addr(pcec_message);
             break;
         case CEC_OC_REPORT_POWER_STATUS:
+            //cec_report_power_status(pcec_message);
             break;
         case CEC_OC_SET_OSD_NAME:
+            //cec_set_osd_name(pcec_message);
             break;
         case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            //cec_feature_abort(pcec_message);
+            //cec_vendor_cmd_with_id(pcec_message);
             break;
         case CEC_OC_SET_MENU_LANGUAGE:
             cec_set_menu_language(pcec_message);
             break;
         case CEC_OC_GIVE_PHYSICAL_ADDRESS:
             cec_report_physical_address_smp();
+            //cec_report_phy_addr(pcec_message);//
+            //cec_give_physical_address(pcec_message);
+            //cec_usrcmd_set_report_physical_address();
             break;
         case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+            //cec_feature_abort(pcec_message);
             cec_device_vendor_id(pcec_message);
+            //cec_usrcmd_set_device_vendor_id();
             break;
         case CEC_OC_GIVE_OSD_NAME:
+            cec_set_osd_name(pcec_message);
+            //cec_give_osd_name(pcec_message);
+            //cec_usrcmd_set_osd_name(pcec_message);
             break;
         case CEC_OC_STANDBY:
-            cec_inactive_source_rx(pcec_message);
+            hdmitx_cec_dbg_print("CEC: system standby\n");
+        	//cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+            cec_deactive_source(pcec_message);
             cec_standby(pcec_message);
             break;
         case CEC_OC_SET_STREAM_PATH:
             cec_set_stream_path(pcec_message);
             break;
         case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
-                break;
+            //cec_request_active_source(pcec_message);
+            //cec_usrcmd_set_active_source();
             cec_active_source_smp();
             break;
         case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-            cec_report_power_status(pcec_message);
+            cec_give_device_power_status(pcec_message);
             break;
         case CEC_OC_USER_CONTROL_PRESSED:
+            //hdmitx_cec_dbg_print("----cec_user_control_pressed-----");
+            //cec_user_control_pressed(pcec_message);
             break;
         case CEC_OC_USER_CONTROL_RELEASED:
-            break;
+            //hdmitx_cec_dbg_print("----cec_user_control_released----");
+            //cec_user_control_released(pcec_message);
+            break; 
         case CEC_OC_IMAGE_VIEW_ON:      //not support in source
             cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-            break;
+            break;  
         case CEC_OC_ROUTING_CHANGE:
-            cec_routing_change(pcec_message);
-            break;
-        case CEC_OC_ROUTING_INFORMATION:
-        	cec_routing_information(pcec_message);
+        case CEC_OC_ROUTING_INFORMATION:    	
+        	cec_usrcmd_routing_information(pcec_message);	
         	break;
-        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_AUDIO_STATUS:   	  
         	cec_report_audio_status();
         	break;
         case CEC_OC_MENU_REQUEST:
             cec_menu_status(pcec_message);
             break;
         case CEC_OC_PLAY:
-            hdmitx_cec_dbg_print("CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
+            hdmitx_cec_dbg_print("CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);        
             switch(pcec_message->content.msg.operands[0]){
                 case 0x24:
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);
+                    input_sync(remote_cec_dev);	
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
                     input_sync(remote_cec_dev);
                     break;
                 case 0x25:
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);
+                    input_sync(remote_cec_dev);	
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
                     input_sync(remote_cec_dev);
                     break;
                 default:
-                    break;
+                    break;                
             }
             break;
         case CEC_OC_DECK_CONTROL:
-            hdmitx_cec_dbg_print("CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
+            hdmitx_cec_dbg_print("CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);        
             switch(pcec_message->content.msg.operands[0]){
                 case 0x3:
                     input_event(remote_cec_dev, EV_KEY, KEY_STOP, 1);
-                    input_sync(remote_cec_dev);
+                    input_sync(remote_cec_dev);	
                     input_event(remote_cec_dev, EV_KEY, KEY_STOP, 0);
                     input_sync(remote_cec_dev);
                     break;
                 default:
-                    break;
+                    break;                
             }
             break;
         case CEC_OC_GET_MENU_LANGUAGE:
+            //cec_set_menu_language(pcec_message);
+            //break;                 	  
         case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
         case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
         case CEC_OC_CLEAR_ANALOGUE_TIMER:
@@ -1465,7 +1747,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
         case CEC_OC_SET_TIMER_PROGRAM_TITLE:
         case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
         case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_TEXT_VIEW_ON:       //not support in source
         case CEC_OC_TIMER_CLEARED_STATUS:
         case CEC_OC_TIMER_STATUS:
         case CEC_OC_TUNER_DEVICE_STATUS:
@@ -1527,160 +1809,174 @@ void cec_usrcmd_parse_all_dev_online(void)
     hdmirx_cec_dbg_print("##############################################################\n");
 }
 
+//////////////////////////////////////////////////
 void cec_usrcmd_get_cec_version(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr,
+    MSG_P0(cec_global_info.my_node_index, log_addr, 
             CEC_OC_GET_CEC_VERSION);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_audio_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_deck_status(unsigned char log_addr)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
 
-    cec_ll_tx(gbl_msg, 3);
+    register_cec_tx_msg(gbl_msg, 3);
 }
 
 void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
 
-    cec_ll_tx(gbl_msg, 3);
+    register_cec_tx_msg(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_device_power_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_osd_name(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_physical_address(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_standby(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 /////////////////////////
 void cec_usrcmd_set_imageview_on(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr,
+    MSG_P0(cec_global_info.my_node_index, log_addr, 
             CEC_OC_IMAGE_VIEW_ON);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_text_view_on(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr,
+    MSG_P0(cec_global_info.my_node_index, log_addr, 
             CEC_OC_TEXT_VIEW_ON);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
 
-    cec_ll_tx(gbl_msg, 3);
+    register_cec_tx_msg(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_menu_state(unsigned char log_addr)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
 
-    cec_ll_tx(gbl_msg, 3);
+    register_cec_tx_msg(gbl_msg, 3);
 }
 
 void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
 
-    cec_ll_tx(gbl_msg, 3);
+
+    register_cec_tx_msg(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_menu_language(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
 
-    cec_ll_tx(gbl_msg, 2);
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
+//void cec_usrcmd_set_menu_language(unsigned char log_addr, cec_menu_lang_e menu_lang)
+//{
+//    MSG_P3(cec_global_info.my_node_index, log_addr, CEC_OC_SET_MENU_LANGUAGE, (menu_lang_array[menu_lang]>>16)&0xFF,
+//           (menu_lang_array[menu_lang]>>8)&0xFF,
+//           (menu_lang_array[menu_lang])&0xFF);
+//    register_cec_tx_msg(gbl_msg, 5);
+//}
+
 void cec_usrcmd_get_active_source(void)
 {
     MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
-
-    cec_ll_tx(gbl_msg, 2);
+        
+    register_cec_tx_msg(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_active_source(void)
 {
     unsigned char index = cec_global_info.my_node_index;
+    //unsigned char phy_addr_ab = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
+    //unsigned char phy_addr_cd = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    MSG_P2(index, CEC_BROADCAST_ADDR,
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
+    
+    MSG_P2(index, CEC_BROADCAST_ADDR, 
             CEC_OC_ACTIVE_SOURCE,
 			phy_addr_ab,
 			phy_addr_cd);
 
-    cec_ll_tx(gbl_msg, 4);
+    register_cec_tx_msg(gbl_msg, 4);
 }
 
 void cec_usrcmd_set_deactive_source(unsigned char log_addr)
 {
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
+    
     MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
            phy_addr_ab,
            phy_addr_cd);
+          //cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.ab,
+          //cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.cd);
 
-    cec_ll_tx(gbl_msg, 4);
+    register_cec_tx_msg(gbl_msg, 4);
 }
 
 void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
@@ -1688,31 +1984,39 @@ void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_m
     cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
 }
 
+//void cec_usrcmd_set_stream_path(unsigned char log_addr)
+//{
+//    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_SET_STREAM_PATH, 
+//                                                  cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.ab,
+//                                                  cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.cd);
+//
+//    register_cec_tx_msg(gbl_msg, 4);
+//}
 
 void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
 {
 
-    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
+    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;  
     unsigned char index = cec_global_info.my_node_index;
 
-    MSG_P14(index, log_addr,
-            CEC_OC_SET_OSD_NAME,
+    MSG_P14(index, log_addr, 
+            CEC_OC_SET_OSD_NAME, 
             cec_global_info.cec_node_info[index].osd_name[0],
             cec_global_info.cec_node_info[index].osd_name[1],
             cec_global_info.cec_node_info[index].osd_name[2],
             cec_global_info.cec_node_info[index].osd_name[3],
             cec_global_info.cec_node_info[index].osd_name[4],
-            cec_global_info.cec_node_info[index].osd_name[5],
+            cec_global_info.cec_node_info[index].osd_name[5],           
             cec_global_info.cec_node_info[index].osd_name[6],
             cec_global_info.cec_node_info[index].osd_name[7],
             cec_global_info.cec_node_info[index].osd_name[8],
             cec_global_info.cec_node_info[index].osd_name[9],
             cec_global_info.cec_node_info[index].osd_name[10],
-            cec_global_info.cec_node_info[index].osd_name[11],
+            cec_global_info.cec_node_info[index].osd_name[11],  
             cec_global_info.cec_node_info[index].osd_name[12],
             cec_global_info.cec_node_info[index].osd_name[13]);
 
-    cec_ll_tx(gbl_msg, 16);
+    register_cec_tx_msg(gbl_msg, 16);
 }
 
 
@@ -1721,67 +2025,64 @@ void cec_usrcmd_set_device_vendor_id(void)
 {
     unsigned char index = cec_global_info.my_node_index;
 
-    MSG_P3(index, CEC_BROADCAST_ADDR,
-            CEC_OC_DEVICE_VENDOR_ID,
+    MSG_P3(index, CEC_BROADCAST_ADDR, 
+            CEC_OC_DEVICE_VENDOR_ID, 
             (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
             (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
             (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
 
-    cec_ll_tx(gbl_msg, 5);
+    register_cec_tx_msg(gbl_msg, 5);
 }
 void cec_usrcmd_set_report_physical_address(void)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    MSG_P3(index, CEC_BROADCAST_ADDR,
+    
+    MSG_P3(index, CEC_BROADCAST_ADDR, 
            CEC_OC_REPORT_PHYSICAL_ADDRESS,
            phy_addr_ab,
            phy_addr_cd,
            CEC_PLAYBACK_DEVICE_TYPE);
+			//cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
+			//cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd,
+			//cec_global_info.cec_node_info[index].dev_type);
 
-    cec_ll_tx(gbl_msg, 5);
+    register_cec_tx_msg(gbl_msg, 5);
 }
 
-void cec_routing_change(cec_rx_message_t* pcec_message)
+void cec_usrcmd_routing_change(cec_rx_message_t* pcec_message)
 {
-    unsigned int phy_addr_origin;
-    unsigned int phy_addr_destination;
-
-    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                    (pcec_message->content.msg.operands[1] << 0));
-    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
-                                         (pcec_message->content.msg.operands[3] << 0));
+    //unsigned char index = cec_global_info.my_node_index;
+    //unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
+    //cec_global_info.cec_node_info[index].log_addr = index;
+    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_LOGIC_ADDRESS;
+    //cec_global_info.cec_node_info[index].phy_addr.phy_addr_4 = (pcec_message->content.msg.operands[2] << 8) | pcec_message->content.msg.operands[3];
+    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_PHYSICAL_ADDRESS;    
+    //MSG_P4(index, CEC_BROADCAST_ADDR, 
+    //        CEC_OC_ROUTING_CHANGE, 
+        //  cec_global_info.cec_node_info[original_index].phy_addr.phy_addr_2.ab,
+        //  cec_global_info.cec_node_info[original_index].phy_addr.phy_addr_2.cd,
+        //  cec_global_info.cec_node_info[new_index].phy_addr.phy_addr_2.ab,
+        //  cec_global_info.cec_node_info[new_index].phy_addr.phy_addr_2.cd,
+        //  );
 
-	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
+    //register_cec_tx_msg(gbl_msg, 6);
 }
 
-void cec_routing_information(cec_rx_message_t* pcec_message)
+void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    unsigned int phy_addr_destination;
     unsigned char msg[4];
 
-    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                         (pcec_message->content.msg.operands[1] << 0));
-
-	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_ROUTING_INFORMATION;
     msg[2] = phy_addr_ab;
     msg[3] = phy_addr_cd;
     cec_ll_tx(msg, 4);
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
+
 }
 /***************************** cec middle level code end *****************************/
 
@@ -1790,17 +2091,22 @@ void cec_routing_information(cec_rx_message_t* pcec_message)
 
 static int __init cec_init(void)
 {
-    int i;
+    int i;    
     extern __u16 cec_key_map[128];
     extern hdmitx_dev_t * get_hdmitx_device(void);
     hdmitx_device = get_hdmitx_device();
     cec_key_init();
-    hdmitx_cec_dbg_print("CEC init\n");
 
-#ifdef CONFIG_ARCH_MESON6
+    //if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
+    //    hdmitx_cec_dbg_print("CEC not init\n");
+    //    return 0;
+    //}
+    //else {
+        hdmitx_cec_dbg_print("CEC init\n");
+    //}
+
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
-#endif
 
     cec_rx_msg_buf.rx_write_pos = 0;
     cec_rx_msg_buf.rx_read_pos = 0;
@@ -1808,41 +2114,36 @@ static int __init cec_init(void)
     memset(cec_rx_msg_buf.cec_rx_message, 0, sizeof(cec_rx_msg_buf.cec_rx_message));
 
     memset(&cec_global_info, 0, sizeof(cec_global_info_t));
+    //cec_global_info.my_node_index = CEC0_LOG_ADDR;
 
+    if (cec_mutex_flag == 0) {
+        //init_MUTEX(&tv_cec_sema);
+        sema_init(&tv_cec_sema,1);
+        cec_mutex_flag = 1;
+    }
+    
     kthread_run(cec_task, (void*)hdmitx_device, "kthread_cec");
-#ifdef CONFIG_ARCH_MESON6
     if(request_irq(INT_HDMI_CEC, &cec_isr_handler,
                 IRQF_SHARED, "amhdmitx-cec",
                 (void *)hdmitx_device)){
         hdmitx_cec_dbg_print("HDMI CEC:Can't register IRQ %d\n",INT_HDMI_CEC);
-        return -EFAULT;
-    }
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    if(request_irq(INT_AO_CEC, &cec_isr_handler,
-                IRQF_SHARED, "amhdmitx-aocec",
-                (void *)hdmitx_device)){
-        hdmitx_cec_dbg_print("HDMI CEC:Can't register IRQ %d\n",INT_HDMI_CEC);
-        return -EFAULT;
+        return -EFAULT;               
     }
-#endif
-
-#if CEC_WQ
-    cec_wq = create_workqueue("cec wq");
-    if(!cec_wq)
-        panic("Failed to create cec_workqueue.");
-#endif
 
-    INIT_WORK(&cec_wq_func, (void (*)(void *))cec_do_work);
-    remote_cec_dev = input_allocate_device();
-    if (!remote_cec_dev)
-    {
-        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Not enough memory\n");
+    remote_cec_dev = input_allocate_device();   
+    if (!remote_cec_dev)                          
+    {  
+        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Not enough memory\n");   
     }
     remote_cec_dev->name = "cec_input";
-
-    remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
-    remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+   
+    //hdmitx_cec_dbg_print("\n--111--function:%s,line:%d,count:%d\n",__FUNCTION__,__LINE__,tasklet_cec.count);
+   // tasklet_enable(&tasklet_cec);
+    //hdmitx_cec_dbg_print("\n--222--function:%s,line:%d,count:%d\n",__FUNCTION__,__LINE__,tasklet_cec.count);
+      //tasklet_cec.data = (unsigned long)remote_cec;
+                                           
+    remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);      
+    remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0); 
     remote_cec_dev->id.bustype = BUS_ISA;
     remote_cec_dev->id.vendor = 0x1b8e;
     remote_cec_dev->id.product = 0x0cec;
@@ -1851,15 +2152,19 @@ static int __init cec_init(void)
     for (i = 0; i < 128; i++){
           set_bit( cec_key_map[i], remote_cec_dev->keybit);
       }
-
-    if(input_register_device(remote_cec_dev)) {
-        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Failed to register device\n");
-        input_free_device(remote_cec_dev);
+                   
+    if(input_register_device(remote_cec_dev)) {  
+        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Failed to register device\n");  
+        input_free_device(remote_cec_dev);   
     }
 
     hdmitx_device->cec_init_ready = 1;
-    cec_init_ready_flag = 1;
-    printk("hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
+    
+    //if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
+    //    msleep(10000);
+    //    cec_gpi_init();
+    //    cec_node_init(hdmitx_device);
+    //}
     return 0;
 }
 
@@ -1870,24 +2175,14 @@ static void __exit cec_uninit(void)
     }
     hdmitx_cec_dbg_print("CEC: cec uninit!\n");
     if (cec_init_flag == 1) {
-
-#ifdef CONFIG_ARCH_MESON6
-        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+////        WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
         free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-        free_irq(INT_AO_CEC, (void *)hdmitx_device);
-#endif
         cec_init_flag = 0;
     }
-#if CEC_WQ
-    if(cec_wq)
-        destroy_workqueue(cec_wq);
-#endif
     hdmitx_device->cec_init_ready = 0;
-    cec_init_ready_flag = 0;
     input_unregister_device(remote_cec_dev);
-    cec_fiq_flag = 0;
+    free_fiq(INT_GPIO_0, &cec_gpi_receive_bits); 
+    cec_fiq_flag = 0;   
 }
 
 size_t cec_usrcmd_get_global_info(char * buf)
@@ -1927,7 +2222,7 @@ void cec_usrcmd_set_lang_config(const char * buf, size_t count)
 
     while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
         tmpbuf[i]=buf[i];
-        i++;
+        i++;    
     }
 
     cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = simple_strtoul(tmpbuf, NULL, 16);
@@ -1959,11 +2254,8 @@ void cec_usrcmd_set_config(const char * buf, size_t count)
     }
     if((0 == value) && (1 == (param[0] & 1))){
         hdmitx_device->cec_init_ready = 1;
-        cec_init_ready_flag = 1;
         hdmitx_device->hpd_state = 1;
-#ifdef CONFIG_ARCH_MESON6
         cec_gpi_init();
-#endif
         cec_node_init(hdmitx_device);
     }
     if((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2))){
@@ -1980,13 +2272,8 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
 {
     int i = 0;
     int j = 0;
-    int n = 0;
-    int m = 0;
     int bool = 0;
     char param[16] = {0};
-    char tmpbuf[32] = {0};
-    unsigned bit_set;
-    unsigned time_set;
     unsigned char msg[4] = {0};
 
     if(count > 32){
@@ -2000,22 +2287,9 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         while ( buf[i] != ' ' )
             i ++;
     }
-
-    while((buf[n]!=',')&&(buf[i]!=' ')){
-        tmpbuf[n]=buf[n];
-        n++;
-    }
-    tmpbuf[n]=0;
+   
     hdmirx_cec_dbg_print("cec_usrcmd_set_dispatch: \n");
-    if(strncmp(tmpbuf, "waocec", 6)==0){
-        bit_set = simple_strtoul(tmpbuf+6, NULL, 16);
-        time_set = simple_strtoul(buf+n+1, NULL, 16);
-        cec_arbit_bit_time_set(bit_set, time_set, 1);
-        return;
-    }else if(strncmp(tmpbuf, "raocec", 6)==0){
-        cec_arbit_bit_time_read();
-        return;
-    }
+
     switch (param[0]) {
     case GET_CEC_VERSION:   //0 LA
         cec_usrcmd_get_cec_version(param[1]);
@@ -2065,11 +2339,12 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         cec_usrcmd_set_menu_state(param[1], param[2]);
         break;
     case SET_MENU_LANGAGE:
+        //cec_usrcmd_set_menu_language(param[1], param[2]);
         break;
     case GET_MENU_LANGUAGE:
         cec_usrcmd_get_menu_language(param[1]);
         break;
-    case GET_ACTIVE_SOURCE:     //13
+    case GET_ACTIVE_SOURCE:     //13???????
         cec_usrcmd_get_active_source();
         break;
     case SET_ACTIVE_SOURCE:
@@ -2078,13 +2353,20 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
     case SET_DEACTIVE_SOURCE:
         cec_usrcmd_set_deactive_source(param[1]);
         break;
-    case REPORT_PHYSICAL_ADDRESS:    //17
+//    case CLR_NODE_DEV_REAL_INFO_MASK:
+//        cec_usrcmd_clear_node_dev_real_info_mask(param[1], (((cec_info_mask)param[2]) << 24) |
+//                                                         (((cec_info_mask)param[3]) << 16) |
+//                                                         (((cec_info_mask)param[4]) << 8)  |
+//                                                         ((cec_info_mask)param[5]));
+//        break;
+    case REPORT_PHYSICAL_ADDRESS:    //17 
     	cec_usrcmd_set_report_physical_address();
     	break;
     case SET_TEXT_VIEW_ON:          //18 LA
     	cec_usrcmd_text_view_on(param[1]);
         break;
-    case POLLING_ONLINE_DEV:    //19 LA
+    case POLLING_ONLINE_DEV:    //19 LA 
+        hdmitx_cec_dbg_print("\n-----POLLING_ONLINE_DEV------\n");
         cec_polling_online_dev(param[1], &bool);
         break;
 
@@ -2097,9 +2379,12 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         msg[1] = CEC_OC_FEATURE_ABORT;
         msg[2] = 0;
         msg[3] = CEC_UNRECONIZED_OPCODE;
-
+        
         cec_ll_tx(msg, 4);
         break;
+    case 0xaa : //for cec tx test.
+        for(i = 0; i < 128; i++)                             
+            printk("test_buf[%d]:%d\n", i, test_buf[i]);
     default:
         break;
     }
@@ -2119,89 +2404,68 @@ module_param(cec_msg_dbg_en, bool, 0664);
 
 /*************************** cec arbitration cts code ******************************/
 // using the cec pin as fiq gpi to assist the bus arbitration
-static unsigned char msg_log_buf[128] = { 0 };
-// return value: 1: successful      0: error
-static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
-{
-    int i;
-    unsigned int ret = 0xf;
-    unsigned int n;
-    unsigned int cnt = 30;
-    int pos;
-#ifdef CONFIG_ARCH_MESON6
-    for (i = 0; i < len; i++) {
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
-    }
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
-    //cec_tx_start = 1;
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, RX_ACK_CURRENT);//TX_REQ_NEXT
-    msleep(len * 24 + 5);
 
-    ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
+struct _cec_msg_ {
+    unsigned char msg[16];
+    unsigned char len;
+};
 
-    if(ret == TX_DONE)
-        ret = 1;
-    else
-        ret = 0;
+static struct _cec_msg_ cec_msg_bak;
 
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    while(aocec_rd_reg(CEC_TX_MSG_STATUS) || aocec_rd_reg(CEC_RX_MSG_STATUS)){
-        msleep(5);
-        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
-            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-            //cec_hw_reset();
-            break;
-        }
-        if(!(cnt--)){
-            printk("tx busy time out.\n");
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-        }
-    }
-    for (i = 0; i < len; i++)
-    {
-        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
-    }
-    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
-    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+static unsigned long frame_time_log[512] = { 0 };
+static unsigned long frame_time_idx = 0;
+static int test_idx = 0;
+static int ack_check_point[16] = { 0 };
+static unsigned char msg_log_buf[128] = { 0 };
+static unsigned int cec_tx_start = 0;
+static unsigned int cec_rx_start = 0;
 
-#endif
-    if(cec_msg_dbg_en == 1) {
-        pos = 0;
-        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
-        for(n = 0; n < len; n++) {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+#define BUS_LEVEL()         (!!(aml_read_reg32(P_PREG_PAD_GPIO2_I) & (1<<13)))
+static void get_bus_free(void)
+{
+    unsigned int cnt = 0;
+    do {
+        frame_time_idx = 0;
+        while(!BUS_LEVEL()) {  // judge whether cec bus level is low
+            msleep(30);
+            cnt ++;
+            if(frame_time_idx != 0) {       // if frame_time_idx > 0, means the bus is busy
+                break;
+            }
+            if((frame_time_idx == 0) && (cnt > 33)) {       // test 1 second, if always low, return
+                pr_err("CEC: bus error, always low\n");
+                return ;
+            }
         }
-#ifdef CONFIG_ARCH_MESON6
-        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-        pos += sprintf(msg_log_buf + pos, "\n");
-#endif
-        msg_log_buf[pos] = '\0';
-        printk("%s", msg_log_buf);
-    }
-    return ret;
+        frame_time_idx = 0;
+        msleep(30);             // judge whether cec bus is busy
+        cnt ++;
+        if(cnt & (1 << 7)) {
+            pr_err("CEC: bus busy\n");
+        }
+    } while (frame_time_idx);   // frame_time_idx > 0, means that cec line is working
 }
-#ifdef CONFIG_ARCH_MESON8
 
-static int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+// return value: 1: successful      0: error
+static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
 {
     int i;
     unsigned int ret = 0xf;
     unsigned int n;
-	unsigned int j = 30;
     int pos;
-#ifdef CONFIG_ARCH_MESON6
+    
+    cec_tx_start = 1;
+    cec_rx_start = 1;
+    get_bus_free();
+    cec_rx_start = 0;
+    frame_time_idx = 0;
+
     for (i = 0; i < len; i++) {
      hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
     }
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
     //cec_tx_start = 1;
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, RX_ACK_CURRENT);//TX_REQ_NEXT
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_REQ_CURRENT);//TX_REQ_NEXT
     msleep(len * 24 + 5);
 
     ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
@@ -2212,29 +2476,7 @@ static int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
         ret = 0;
 
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 1, 1);
-    for (i = 0; i < len; i++)
-    {
-        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
-    }
-    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
-    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
-
-    while((TX_DONE != aocec_rd_reg(CEC_TX_MSG_STATUS)) && (j--)){
-		msleep(5);
-	}
-
-    ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
-
-    if(ret == TX_DONE)
-        ret = 1;
-    else
-        ret = 0;
-    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 1, 1, 1);
-#endif
+    cec_tx_start = 0;
     if(cec_msg_dbg_en == 1) {
         pos = 0;
         pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
@@ -2248,72 +2490,6 @@ static int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
     return ret;
 }
 
-void cec_arbit_bit_time_read(void){//11bit:bit[10:0]
-    //3 bit
-    printk("read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
-    //5 bit
-    printk("read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
-    //7 bit
-    printk("read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
-}
-
-void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag){//11bit:bit[10:0]
-    if(flag)
-        printk("bit_set:0x%x;time_set:0x%x \n", bit_set, time_set);
-    switch(bit_set){
-    case 3:
-        //3 bit
-        if(flag)
-            printk("read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
-        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
-        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
-        if(flag)
-            printk("write 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
-        break;
-        //5 bit
-    case 5:
-        if(flag)
-            printk("read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
-        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
-        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
-        if(flag)
-            printk("write 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
-        //7 bit
-	case 7:
-        if(flag)
-            printk("read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
-        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
-        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
-        if(flag)
-            printk("write 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
-        break;
-    default:
-        break;
-    }
-}
-
-void tx_irq_handle(void){
-    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
-    switch(tx_status){
-    case TX_DONE:
-      aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-      break;
-    case TX_BUSY:
-        aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-        break;
-    case TX_ERROR:
-        cec_hw_reset();
-        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-        break;
-    default:
-        break;
-    }
-    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 1));
-    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) | (1 << 2));
-
-}
-#endif
 // Return value: 0: fail    1: success
 int cec_ll_tx(const unsigned char *msg, unsigned char len)
 {
@@ -2321,54 +2497,119 @@ int cec_ll_tx(const unsigned char *msg, unsigned char len)
     int repeat = 0;
     int i;
 
-    mutex_lock(&cec_mutex);
-#ifdef CONFIG_ARCH_MESON8
-    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) & ~(1 << 2));
-    cec_ll_tx_once(msg, len);
-#endif
-    //if transmit message error, try repeat(4) times
-#ifdef CONFIG_ARCH_MESON6
+    memset(&cec_msg_bak, 0, sizeof(cec_msg_bak));
+    memset(ack_check_point, 0, sizeof(ack_check_point));
+
+    // save msg
+    cec_msg_bak.len = len;
+    for(i = 0; i < len; i++) {
+        cec_msg_bak.msg[i] = msg[i];
+        ack_check_point[i] = (i + 1) * 20 + 1;
+    }
+    
+    // if transmit message error, try repeat(4) times
     do {
         ret = cec_ll_tx_once(msg, len);
+        //ret ? msleep(18) : ((!repeat) ? msleep(12) : msleep(8));       // if transmit fails, waiting proper time to try again.
         repeat ++;
-        if(repeat > 1)
-            cec_hw_reset();
+        ret ? 0 : msleep(31);       // if transmit fails, wait 31ms and try send again
+        cec_hw_reset();
     } while((ret == 0) && (repeat < 3));
 
     cec_msg_dbg_en ? printk("cec: ret = %d\n", ret) : 0;
     if(repeat > 1) {
         printk("cec: try %d times\n", repeat);
     }
-#endif
-    mutex_unlock(&cec_mutex);
+
     return ret;
 }
-#ifdef CONFIG_ARCH_MESON6
-static void cec_gpi_init(void)
+
+static inline int get_value(unsigned time_rise, unsigned time_fall)
 {
-    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
-        aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq.
-        printk("CEC FIQ return.\n");
+    unsigned time;
+    if(time_rise > time_fall)
+        time = time_rise - time_fall;
+    else
+        time = ((unsigned int)(0xffffffff)) - time_fall + time_rise;
+    if((time > 1300) && (time < 1700))
+        return 0;
+    if((time > 400) && (time < 800))
+        return 1;
+    if((time > 2400) && (time < 3500))
+        return 2;
+    return -1;
+}
+
+static inline int need_check_ack(unsigned idx)
+{
+    int i;
+    for(i = 0; (ack_check_point[i]) && (i < 16) ; i++) {
+        if(ack_check_point[i] == idx) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static void cec_gpi_receive_bits(void)
+{
+    int val = 0;
+////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
+    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, BUS_LEVEL(), 16, 1);
+    if(!cec_tx_start)
         return;
+    frame_time_log[frame_time_idx] = aml_read_reg32(P_ISA_TIMERE);
+
+    // ack rising position
+    val = get_value(frame_time_log[frame_time_idx], frame_time_log[frame_time_idx - 1]);
+
+    if(128 == test_idx)
+        test_idx = 0;
+    if((!cec_rx_start) && (val == 2) && (frame_time_idx > 20)) {
+        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_ABORT);       // stop cec tx
+        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
+        //test_buf[test_idx++] = frame_time_idx; //for cec tx arbitration point test.
+    }
+    
+    if((!cec_rx_start) && need_check_ack(frame_time_idx)) {
+        // if val == 1, and DES != 0xf
+        // if val == 0, and DES == 0xf
+        // means we need stop cec tx
+        if(((val == 1) ? ((cec_msg_bak.msg[0] & 0xf) != 0xf) : ((cec_msg_bak.msg[0] & 0xf) == 0xf)) || (val == -1)) {
+            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_ABORT);       // stop cec tx
+            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
+            //test_buf[test_idx++] = frame_time_idx;//for cec tx arbitration point test.
+        }
     }
-    if(cec_fiq_flag){ //This function run only once.
+    (512 == frame_time_idx) ? (frame_time_idx = 0) : frame_time_idx++;
+    if(test_buf[test_idx] < frame_time_idx)
+        test_buf[test_idx] = frame_time_idx;
+    if(1 == frame_time_idx)
+        test_idx++;
+    
+}
+
+static void cec_gpi_init(void)
+{
+    if(cec_fiq_flag){
         return;
     }
     cec_fiq_flag = 1;
-    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 0, 0, 1);     // disable irq
-    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
+////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 0, 0, 1);     // disable irq
+////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
 
     aml_set_reg32_bits(P_GPIO_INTR_GPIO_SEL0, 0x76, 0, 8);      // set GPIOC_23 as GPIO IRQ #0 source
-    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge
+    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge 
     aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 16, 1);
     request_fiq(INT_GPIO_0, &cec_gpi_receive_bits);
     printk("cec: register fiq\n");
 
-    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
+////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
 }
-#endif
+
 // DELETE LATER, TEST ONLY
 void cec_test_(unsigned int cmd)
 {
+    printk("CEC: bus level: %s\n", BUS_LEVEL() ? "High" : "Low");
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
index 0c2cee3ff4b0..c1f50eb0f701 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
@@ -19,12 +19,15 @@
 #define _TV_CEC_H_
 #include "hdmi_tx_module.h"
 
+//#define CEC0_LOG_ADDR 0 // TV logical address
 #define CEC0_LOG_ADDR 4 // MBX logical address
 #define TV_CEC_INTERVAL     (HZ*3)
 
 #define CEC_VERSION     "v1.3"
-#define _RX_DATA_BUF_SIZE_ 16
+#define _RX_DATA_BUF_SIZE_ 6
 
+
+//#define _SUPPORT_CEC_TV_MASTER_
 #define _RX_CEC_DBG_ON_
 #define _TX_CEC_DBG_ON_
 
@@ -39,7 +42,6 @@
 #else
 #define hdmitx_cec_dbg_print(fmt, args...)
 #endif
-#define HDMI_CEC_DEBUG()  printk("HDMI CEC DEBUG: %s [%d]\n", __FUNCTION__, __LINE__)
 
 extern unsigned int cec_tx_irq_flag;
 extern unsigned int cec_tx_irq_syn_flag;
@@ -231,6 +233,8 @@ typedef struct {
             unsigned char header;          // 4bit Initiator logical address + 4bit Destination logical address
             unsigned char opcode;          // message opcode
             unsigned char operands[14];    // the maximun operand is 14
+            //unsigned int  flag;            // flag = 1 ,cec key pressed;flag = 0, cec key released
+            //struct input_dev *remote_cec_dev; //cec input device
         }msg;                              // message struct
     }content;                              // message content
     unsigned char operand_num;             // number of operand
@@ -330,7 +334,6 @@ typedef enum {
     CEC_VERSION_12A,
     CEC_VERSION_13,
     CEC_VERSION_13A,
-    CEC_VERSION_14A,
 } cec_version_e;
 
 typedef enum {
@@ -340,6 +343,16 @@ typedef enum {
     CEC_HDMI_PORT_3,
 } cec_hdmi_port_e;
 
+//typedef enum {
+//    CEC_MENU_LANG_CHN = 0,
+//    CEC_MENU_LANG_ENG,
+//    CEC_MENU_LANG_JAP,
+//    CEC_MENU_LANG_KOR,
+//    CEC_MENU_LANG_FRA,
+//    CEC_MENU_LANG_GER,
+//    //CEC_MENU_LANG_UNSUPPORTED = 0xff;
+//} cec_menu_lang_e;
+
 typedef enum {
     OFF = 0,
     ON,
@@ -364,12 +377,23 @@ typedef unsigned long cec_info_mask;
 #define ONE_TOUCH_STANDBY_MASK               2
 #define AUTO_POWER_ON_MASK                   3
 
+//typedef struct {
+//    unsigned long vendor_id;
+//    unsigned char vendor_id_byte_num;
+//} vendor_id_t;
+
+//typedef struct {
+//    unsigned char vsdb_phy_addr_offset;
+//    unsigned short phy_addr[3];
+//    unsigned char checksum[3];
+//} vsdb_phy_addr_t;
 
 typedef struct {
     cec_hdmi_port_e hdmi_port;
     cec_info_mask real_info_mask;
     unsigned char cec_version;
     unsigned int vendor_id:24;
+//    vendor_id_t vendor_id;
     unsigned char dev_type;
     unsigned char menu_status;
     cec_power_status_e power_status;
@@ -416,6 +440,8 @@ typedef struct {
 
 typedef struct {
     unsigned short dev_mask;
+    //unsigned char tv_log_addr;
+    //unsigned short tv_phy_addr;
     unsigned char active_log_dev;
     unsigned char my_node_index;
     cec_node_info_t cec_node_info[MAX_NUM_OF_DEV];
@@ -452,6 +478,7 @@ typedef enum {
     SET_ACTIVE_SOURCE,
     SET_DEACTIVE_SOURCE,
     CLR_NODE_DEV_REAL_INFO_MASK,
+    //SET_STREAM_PATH,
     REPORT_PHYSICAL_ADDRESS,    //0x17
     SET_TEXT_VIEW_ON,
     POLLING_ONLINE_DEV, //0x19
@@ -499,8 +526,8 @@ void cec_set_pending(tv_cec_pending_e on_off);
 void cec_polling_online_dev(int log_addr, int *bool);
 unsigned short cec_log_addr_to_dev_type(unsigned char log_addr);
 
-void cec_routing_information(cec_rx_message_t* pcec_message);
-void cec_routing_change(cec_rx_message_t* pcec_message);
+void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message);
+void cec_usrcmd_routing_change(cec_rx_message_t* pcec_message);
 void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message);
 void cec_usrcmd_set_device_vendor_id(void);
 void cec_usrcmd_get_cec_version(unsigned char log_addr);
@@ -520,6 +547,7 @@ void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode);
 void cec_usrcmd_get_menu_state(unsigned char log_addr);
 void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type);
 void cec_usrcmd_get_menu_language(unsigned char log_addr);
+//void cec_usrcmd_set_menu_language(unsigned char log_addr, cec_menu_lang_e menu_lang);
 void cec_usrcmd_get_active_source(void);
 void cec_usrcmd_set_active_source(void);
 void cec_usrcmd_set_deactive_source(unsigned char log_addr);
@@ -533,7 +561,7 @@ void cec_active_source(cec_rx_message_t* pcec_message);
 void cec_set_stream_path(cec_rx_message_t* pcec_message);
 void cec_set_osd_name(cec_rx_message_t* pcec_message);
 void cec_set_osd_name_init(void);
-void cec_inactive_source_rx(cec_rx_message_t* pcec_message);
+void cec_deactive_source(cec_rx_message_t* pcec_message);
 void cec_set_system_audio_mode(void);
 void cec_system_audio_mode_request(void);
 void cec_report_audio_status(void);
@@ -545,7 +573,7 @@ void cec_set_imageview_on_irq(void);
 void cec_report_physical_address_smp(void);
 void cec_imageview_on_smp(void);
 void cec_active_source_smp(void);
-void cec_active_source_rx(cec_rx_message_t* pcec_message);
+void cec_active_source_irq(void);
 
 size_t cec_usrcmd_get_global_info(char * buf);
 void cec_usrcmd_set_dispatch(const char * buf, size_t count);
@@ -558,11 +586,6 @@ void cec_user_control_released_irq(void);
 void cec_user_control_pressed_irq(void);
 void cec_inactive_source(void);
 void cec_set_standby(void);
-void cec_isr_post_process(void);
-void cec_clear_buf(unsigned int flag);
-void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag);
-void tx_irq_handle(void);
-void cec_arbit_bit_time_read(void);
 
 extern struct input_dev *remote_cec_dev;
 extern __u16 cec_key_map[];
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
index d5930e22d693..47d6a16098cd 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
@@ -356,7 +356,18 @@ int Edid_Parse_check_HDMI_VSDB(HDMI_TX_INFO_t * info, unsigned char *buff)
 	}
 
     set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
-    
+	if(info->vsdb_phy_addr.a == 0) {
+		printk("CEC: not a valid physical address\n");
+	}
+    else {
+        vsdb_phy_addr_t *tmp = &info->vsdb_phy_addr;
+        if(tmp->valid){
+            aml_write_reg32(P_AO_DEBUG_REG1, (((tmp->a) & 0xf) << 12) | (((tmp->b) & 0xf) << 8) | (((tmp->c) & 0xf) << 4) | ((tmp->d) & 0xf));
+            printk("CEC: Physical address: 0x%x\n",aml_read_reg32(P_AO_DEBUG_REG1));
+            printk("CEC: Physical address: %1x.%1x.%1x.%1x\n", tmp->a, tmp->b, tmp->c, tmp->d);
+        }
+    }
+
 	//For test only.
 	hdmi_print(0,"HDMI DEBUG [%s]\n", __FUNCTION__);
     hdmi_print(0,"max_tmds_clk_7:%d\n",buff[BlockAddr + 7]);
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
index 1f42b292b836..8e20e3feff22 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
@@ -1362,7 +1362,7 @@ void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device, int power_mode, int vic)
 void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
 {
 #ifdef CONFIG_ARCH_MESON8
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0xe, 23, 4); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V) bit23: gpioh_3 cec
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0xf, 23, 4); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V)
 #endif
     unsigned int tmp_add_data;
     
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
old mode 100755
new mode 100644
index bc2b9299fd48..b0809ba77f48
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
@@ -22,7 +22,6 @@
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <linux/device.h>
-#include <linux/delay.h>
 #include <linux/mm.h>
 #include <linux/major.h>
 #include <linux/platform_device.h>
@@ -33,7 +32,6 @@
 
 #include "hdmi_tx_reg.h"
 static DEFINE_SPINLOCK(reg_lock);
-static DEFINE_SPINLOCK(reg_lock2);
 // if the following bits are 0, then access HDMI IP Port will cause system hungup
 #define GATE_NUM    2
 Hdmi_Gate_s hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
@@ -102,38 +100,3 @@ void hdmi_wr_reg(unsigned long addr, unsigned long data)
     spin_unlock(&reg_lock);
 #endif
 }
-
-#ifdef CONFIG_ARCH_MESON8
-#define waiting_aocec_free()    while(aml_read_reg32(P_AO_CEC_RW_REG) & (1<<23))
-unsigned long aocec_rd_reg (unsigned long addr)
-{
-    unsigned long data32;
-    waiting_aocec_free();
-    spin_lock(&reg_lock2);
-    data32  = 0;
-    data32 |= 0     << 16;  // [16]     cec_reg_wr
-    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
-    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
-    aml_write_reg32(P_AO_CEC_RW_REG, data32);
-
-    waiting_aocec_free();
-    data32 = ((aml_read_reg32(P_AO_CEC_RW_REG)) >> 24) & 0xff;
-    spin_unlock(&reg_lock2);
-    return (data32);
-} /* aocec_rd_reg */
-
-void aocec_wr_reg (unsigned long addr, unsigned long data)
-{
-    unsigned long data32;
-    waiting_aocec_free();
-    spin_lock(&reg_lock2);
-    data32  = 0;
-    data32 |= 1     << 16;  // [16]     cec_reg_wr
-    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
-    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
-    aml_write_reg32(P_AO_CEC_RW_REG, data32);
-    spin_unlock(&reg_lock2);
-    waiting_aocec_free();
-    //waiting_aocec_free();
-} /* aocec_wr_only_reg */
-#endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
old mode 100755
new mode 100644
index fe41e1c09c53..3b0110d45d35
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
@@ -26,9 +26,6 @@ unsigned long hdmi_rd_reg(unsigned long addr);
 
 void hdmi_wr_reg(unsigned long addr, unsigned long data);
 
-unsigned long aocec_rd_reg(unsigned long addr);
-void aocec_wr_reg(unsigned long addr, unsigned long data);
-
 typedef struct {
     unsigned short cbus_addr;
     unsigned char gate_bit;
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index 7f8d58179a4a..01ba1eddbf90 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -15,12 +15,6 @@
 #include <asm/io.h>
 #include <mach/am_regs.h>
 #include "remote_main.h"
-#ifdef CONFIG_AML_HDMI_TX
-#ifdef CONFIG_ARCH_MESON8
-extern int cec_power_flag;
-unsigned char cec_repeat = 10;
-#endif
-#endif
 extern char *remote_log_buf;
 static int repeat_count = 0;
 static int dbg_printk(const char *fmt, ...)
@@ -391,19 +385,6 @@ int remote_hw_reprot_key(struct remote *remote_data)
 		}
 	}
 	else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg){	//repeate key
-#ifdef CONFIG_AML_HDMI_TX
-#ifdef CONFIG_ARCH_MESON8
-       extern int rc_long_press_pwr_key;
-		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-            rc_long_press_pwr_key = 1;
-		    cec_repeat = 10;
-		    mdelay(20);
-		}
-		if(remote_data->repeat_release_code == 0x1a)
- 		    cec_repeat--;
-
-#endif
-#endif
 		if (remote_data->repeat_enable) {
 			repeat_count++;
 			if (remote_data->repeat_tick < jiffies) {
diff --git a/drivers/amlogic/input/remote/am_remote.c b/drivers/amlogic/input/remote/am_remote.c
index 916f8fdbe18e..09d4815e90fb 100755
--- a/drivers/amlogic/input/remote/am_remote.c
+++ b/drivers/amlogic/input/remote/am_remote.c
@@ -59,11 +59,11 @@
 
 type_printk input_dbg;
 #ifdef CONFIG_AML_HDMI_TX
-#ifdef CONFIG_ARCH_MESON6
+extern void cec_inactive_source(void);
+extern void cec_set_standby(void);
 extern int cec_power_flag;
 unsigned char cec_repeat = 10;
 #endif
-#endif
 
 static DEFINE_MUTEX(remote_enable_mutex);
 static DEFINE_MUTEX(remote_file_mutex);
@@ -390,16 +390,14 @@ static inline int remote_hw_reprot_key(struct remote *remote_data)
 			return -1;
 		}
 #ifdef CONFIG_AML_HDMI_TX
-#ifdef CONFIG_ARCH_MESON6
+		//printk("last_scan_code:%x\n", last_scan_code);
 		if((((scan_code >> 16) & 0xff) == 0x1a) && (!cec_repeat)) {
-            extern int rc_long_press_pwr_key;
-            rc_long_press_pwr_key = 1;
 		    cec_repeat = 10;
+		    cec_set_standby();
 		    mdelay(20);
 		}
 		if(((scan_code >> 16) & 0xff) == 0x1a)
  		    cec_repeat--;
-#endif
 #endif
 		if (remote_data->repeat_enable) {
 			if ((remote_data->repeat_tick < jiffies)&&(repeat_flag == 1)) {
-- 
2.19.0

