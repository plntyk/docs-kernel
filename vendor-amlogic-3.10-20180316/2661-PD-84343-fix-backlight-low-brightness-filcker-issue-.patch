From 8ff9cdc09cb9081e1c36c6a5895cc34e2e4e3104 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Thu, 26 Dec 2013 14:06:54 +0800
Subject: [PATCH 2661/5965] PD #84343: fix backlight low brightness filcker
 issue when low battery

---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |  37 +-
 arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd  |  37 +-
 arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd  |  39 +-
 arch/arm/mach-meson8/aml_pin.dtd              |  10 +
 drivers/amlogic/display/backlight/aml.dtd     |  25 +-
 drivers/amlogic/display/backlight/aml_bl.c    | 518 ++++++++++++++++--
 .../amlogic/display/backlight/aml_lcd_bl.h    |   2 +-
 7 files changed, 586 insertions(+), 82 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 0fda612084d8..34970573fdc1 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -796,6 +796,7 @@ sdio{
 //$$ DEVICE="backlight"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_CHOICE "Bl_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Bl_pin_1_match" = "pinctrl-1"
 //$$ L2 PROP_U32 2= "bl_level_default_uboot_kernel"
 //$$ L2 PROP_U32 2= "bl_level_middle_mapping"
 //$$ L2 PROP_U32 2= "bl_level_max_min"
@@ -805,24 +806,38 @@ sdio{
 //$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
 //$$ L2 PROP_U32 = "bl_pwm_freq"
 //$$ L2 PROP_U32 2 = "bl_pwm_duty_max_min"
-     backlight{
+//$$ L2 PROP_U32 = "bl_pwm_combo_high_low_level_switch"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_high_port_method"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_low_port_method"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_high_freq_duty_max_min"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_low_freq_duty_max_min"
+    backlight{
 		compatible = "amlogic,backlight";
 		dev_name = "backlight";
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
+		pinctrl-names = "default","pwm_combo";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
+		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
 		
 		bl_level_default_uboot_kernel=<20 128>;	/** default brightness level for uboot & kernel */
 		bl_level_middle_mapping=<102 70>;	/** brightness middle level mapping to a new level*/
 		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
 		
 		/* backlight power ctrl */
-		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. decided by hardware design) */
+		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive, 3=pwm_combo. decided by hardware design) */
+		
 		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
 		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
 		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
-		bl_pwm_freq=<1000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
-		bl_pwm_duty_max_min=<85 20>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		bl_pwm_freq=<300000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<85 25>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		
+		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
+		bl_pwm_combo_high_low_level_switch=<220>;	/** backlight pwm_combo control switch level */
+		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_low_port_method="PWM_D","2";	/** backlight pwm_combo low port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_high_freq_duty_max_min=<300000 96 89>;	/** backlight pwm_combo level_high port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+		bl_pwm_combo_low_freq_duty_max_min=<10000 100 10>;	/** backlight pwm_combo level_low port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
 	};
 //$$ DEVICE="lcd"
 //$$ L2 PROP_STR = "status"
@@ -2077,6 +2092,16 @@ sdio{
 			amlogic,pins = "GPIODV_9";
 		};
 		
+//$$ MATCH "Bl_pin_1_match" = "&lcd_backlight_combo_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		lcd_backlight_combo_pins:lcd_backlight_combo{
+			amlogic,setmask=<3 0x5000000>;
+			amlogic,clrmask=<0 0x48 7 0x18000200>;
+			amlogic,pins = "GPIODV_9","GPIODV_28";
+		};
+		
 		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
 			amlogic,setmask=<8 0x1800000>;
 			amlogic,clrmask=<0 0x3c0300 6 0xc00000>;
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
index 4254ea8b82d3..fe60826a9682 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
@@ -808,6 +808,7 @@ sdio{
 //$$ DEVICE="backlight"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_CHOICE "Bl_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Bl_pin_1_match" = "pinctrl-1"
 //$$ L2 PROP_U32 2= "bl_level_default_uboot_kernel"
 //$$ L2 PROP_U32 2= "bl_level_middle_mapping"
 //$$ L2 PROP_U32 2= "bl_level_max_min"
@@ -817,24 +818,38 @@ sdio{
 //$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
 //$$ L2 PROP_U32 = "bl_pwm_freq"
 //$$ L2 PROP_U32 2 = "bl_pwm_duty_max_min"
-     backlight{
+//$$ L2 PROP_U32 = "bl_pwm_combo_high_low_level_switch"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_high_port_method"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_low_port_method"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_high_freq_duty_max_min"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_low_freq_duty_max_min"
+    backlight{
 		compatible = "amlogic,backlight";
 		dev_name = "backlight";
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
+		pinctrl-names = "default","pwm_combo";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
+		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
 		
 		bl_level_default_uboot_kernel=<20 128>;	/** default brightness level for uboot & kernel */
 		bl_level_middle_mapping=<102 70>;	/** brightness middle level mapping to a new level*/
 		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
 		
 		/* backlight power ctrl */
-		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. decided by hardware design) */
+		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive, 3=pwm_combo. decided by hardware design) */
+		
 		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
 		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
 		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
-		bl_pwm_freq=<1000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
-		bl_pwm_duty_max_min=<85 20>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		bl_pwm_freq=<300000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<85 25>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		
+		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
+		bl_pwm_combo_high_low_level_switch=<220>;	/** backlight pwm_combo control switch level */
+		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_low_port_method="PWM_D","2";	/** backlight pwm_combo low port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_high_freq_duty_max_min=<300000 96 89>;	/** backlight pwm_combo level_high port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+		bl_pwm_combo_low_freq_duty_max_min=<10000 100 10>;	/** backlight pwm_combo level_low port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
 	};
 //$$ DEVICE="lcd"
 //$$ L2 PROP_STR = "status"
@@ -2091,6 +2106,16 @@ sdio{
 			amlogic,pins = "GPIODV_9";
 		};
 		
+//$$ MATCH "Bl_pin_1_match" = "&lcd_backlight_combo_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		lcd_backlight_combo_pins:lcd_backlight_combo{
+			amlogic,setmask=<3 0x5000000>;
+			amlogic,clrmask=<0 0x48 7 0x18000200>;
+			amlogic,pins = "GPIODV_9","GPIODV_28";
+		};
+		
 		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
 			amlogic,setmask=<8 0x1800000>;
 			amlogic,clrmask=<0 0x3c0300 6 0xc00000>;
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
index 970c768591b4..90747ed6ac00 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
@@ -774,6 +774,7 @@ sdio{
 //$$ DEVICE="backlight"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_CHOICE "Bl_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Bl_pin_1_match" = "pinctrl-1"
 //$$ L2 PROP_U32 2= "bl_level_default_uboot_kernel"
 //$$ L2 PROP_U32 2= "bl_level_middle_mapping"
 //$$ L2 PROP_U32 2= "bl_level_max_min"
@@ -783,24 +784,38 @@ sdio{
 //$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
 //$$ L2 PROP_U32 = "bl_pwm_freq"
 //$$ L2 PROP_U32 2 = "bl_pwm_duty_max_min"
-     backlight{
+//$$ L2 PROP_U32 = "bl_pwm_combo_high_low_level_switch"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_high_port_method"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_low_port_method"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_high_freq_duty_max_min"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_low_freq_duty_max_min"
+    backlight{
 		compatible = "amlogic,backlight";
 		dev_name = "backlight";
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
+		pinctrl-names = "default","pwm_combo";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
+		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
 		
-		bl_level_default_uboot_kernel=<20 128>;	/** default brightness level for uboot & kernel */
+		bl_level_default_uboot_kernel=<10 102>;	/** default brightness level for uboot & kernel */
 		bl_level_middle_mapping=<128 102>;	/** brightness middle level mapping to a new level*/
 		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
 		
 		/* backlight power ctrl */
-		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. decided by hardware design) */
+		bl_ctrl_method=<3>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive, 3=pwm_combo. decided by hardware design) */
+		
 		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
 		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
 		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
-		bl_pwm_freq=<1000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
-		bl_pwm_duty_max_min=<90 20>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		bl_pwm_freq=<300000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<90 30>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		
+		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
+		bl_pwm_combo_high_low_level_switch=<220>;	/** backlight pwm_combo control switch level */
+		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_low_port_method="PWM_D","2";	/** backlight pwm_combo low port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_high_freq_duty_max_min=<300000 96 89>;	/** backlight pwm_combo level_high port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+		bl_pwm_combo_low_freq_duty_max_min=<10000 100 10>;	/** backlight pwm_combo level_low port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
 	};
 //$$ DEVICE="lcd"
 //$$ L2 PROP_STR = "status"
@@ -2076,6 +2091,16 @@ sdio{
 			amlogic,pins = "GPIODV_9";
 		};
 		
+//$$ MATCH "Bl_pin_1_match" = "&lcd_backlight_combo_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		lcd_backlight_combo_pins:lcd_backlight_combo{
+			amlogic,setmask=<3 0x5000000>;
+			amlogic,clrmask=<0 0x48 7 0x18000200>;
+			amlogic,pins = "GPIODV_9","GPIODV_28";
+		};
+		
 		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
 			amlogic,setmask=<8 0x1800000>;
 			amlogic,clrmask=<0 0x3c0300 6 0xc00000>;
diff --git a/arch/arm/mach-meson8/aml_pin.dtd b/arch/arm/mach-meson8/aml_pin.dtd
index 0465ac457a4b..cdf982b94b15 100755
--- a/arch/arm/mach-meson8/aml_pin.dtd
+++ b/arch/arm/mach-meson8/aml_pin.dtd
@@ -318,6 +318,16 @@
 			amlogic,pins = "GPIODV_9";
 		};
 		
+//$$ MATCH "Bl_pin_1_match" = "&lcd_backlight_combo_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		lcd_backlight_combo_pins:lcd_backlight_pwm_combo{
+			amlogic,setmask=<3 0x5000000>;
+			amlogic,clrmask=<0 0x48 7 0x18000200>;
+			amlogic,pins = "GPIODV_9","GPIODV_28";
+		};
+		
 		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
 			amlogic,setmask=<8 0x1800000>;
 			amlogic,clrmask=<0 0x3c0300 6 0xc00000>;
diff --git a/drivers/amlogic/display/backlight/aml.dtd b/drivers/amlogic/display/backlight/aml.dtd
index 749a65d95fab..acb46fec9324 100755
--- a/drivers/amlogic/display/backlight/aml.dtd
+++ b/drivers/amlogic/display/backlight/aml.dtd
@@ -2,6 +2,7 @@
 //$$ DEVICE="backlight"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_CHOICE "Bl_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Bl_pin_1_match" = "pinctrl-1"
 //$$ L2 PROP_U32 2= "bl_level_default_uboot_kernel"
 //$$ L2 PROP_U32 2= "bl_level_middle_mapping"
 //$$ L2 PROP_U32 2= "bl_level_max_min"
@@ -11,23 +12,37 @@
 //$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
 //$$ L2 PROP_U32 = "bl_pwm_freq"
 //$$ L2 PROP_U32 2 = "bl_pwm_duty_max_min"
+//$$ L2 PROP_U32 = "bl_pwm_combo_high_low_level_switch"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_high_port_method"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_low_port_method"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_high_freq_duty_max_min"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_low_freq_duty_max_min"
      backlight{
 		compatible = "amlogic,backlight";
 		dev_name = "backlight";
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
+		pinctrl-names = "default","pwm_combo";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
+		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
 		
-		bl_level_default_uboot_kernel=<20 128>;	/** default brightness level for uboot & kernel */
-		bl_level_middle_mapping=<102 76>;	/** brightness middle level mapping to a new level*/
+		bl_level_default_uboot_kernel=<10 102>;	/** default brightness level for uboot & kernel */
+		bl_level_middle_mapping=<128 102>;	/** brightness middle level mapping to a new level*/
 		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
 		
 		/* backlight power ctrl */
-		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. decided by hardware design) */
+		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. 3=pwm_combo. decided by hardware design) */
+		
 		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
 		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
 		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
 		bl_pwm_freq=<1000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
 		bl_pwm_duty_max_min=<100 25>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		
+		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
+		bl_pwm_combo_high_low_level_switch=<102>;	/** backlight pwm_combo control switch level */
+		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_low_port_method="PWM_D","2";	/** backlight pwm_combo low port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_high_freq_duty_max_min=<300000 90 50>;	/** backlight pwm_combo level_high port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+		bl_pwm_combo_low_freq_duty_max_min=<10000 100 50>;	/** backlight pwm_combo level_low port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
 	};
 #endif
\ No newline at end of file
diff --git a/drivers/amlogic/display/backlight/aml_bl.c b/drivers/amlogic/display/backlight/aml_bl.c
index 1067ad186cc7..5368cc580895 100755
--- a/drivers/amlogic/display/backlight/aml_bl.c
+++ b/drivers/amlogic/display/backlight/aml_bl.c
@@ -47,7 +47,7 @@
 #define DTRACE()
 #endif /* MESON_BACKLIGHT_DEBUG */
 
-#define BL_LEVEL_DEFAULT					200
+#define BL_LEVEL_DEFAULT					BL_LEVEL_MID
 #define BL_NAME 							"backlight"
 #define bl_gpio_request(gpio) 				amlogic_gpio_request(gpio, BL_NAME)
 #define bl_gpio_free(gpio) 					amlogic_gpio_free(gpio, BL_NAME)
@@ -58,6 +58,31 @@
 
 #include "aml_lcd_bl.h"
 #ifdef LCD_BACKLIGHT_SUPPORT
+/* for lcd backlight power */
+typedef enum {
+	BL_CTL_GPIO = 0,
+	BL_CTL_PWM_NEGATIVE,
+	BL_CTL_PWM_POSITIVE,
+	BL_CTL_PWM_COMBO,
+	BL_CTL_MAX,
+} BL_Ctrl_Method_t;
+
+static const char* bl_ctrl_method_table[]={
+	"gpio",
+	"pwm_negative",
+	"pwm_positive",
+	"pwm_combo",
+	"null"
+};
+
+typedef enum {
+	BL_PWM_A = 0,
+	BL_PWM_B,
+	BL_PWM_C,
+	BL_PWM_D,
+	BL_PWM_MAX,
+} BL_PWM_t;
+
 typedef struct {
 	unsigned level_default;
 	unsigned level_mid;
@@ -68,12 +93,27 @@ typedef struct {
 	int gpio;
 	unsigned dim_max;
 	unsigned dim_min;
-	unsigned short pwm_port;
+	unsigned char pwm_port;
 	unsigned char pwm_gpio_used;
 	unsigned pwm_cnt;
 	unsigned pwm_pre_div;
 	unsigned pwm_max;
 	unsigned pwm_min;
+	
+	unsigned combo_level_switch;
+	unsigned char combo_high_port;
+	unsigned char combo_high_method;
+	unsigned char combo_low_port;
+	unsigned char combo_low_method;
+	unsigned combo_high_cnt;
+	unsigned combo_high_pre_div;
+	unsigned combo_high_duty_max;
+	unsigned combo_high_duty_min;
+	unsigned combo_low_cnt;
+	unsigned combo_low_pre_div;
+	unsigned combo_low_duty_max;
+	unsigned combo_low_duty_min;
+	
 	struct pinctrl *p;
 } Lcd_Bl_Config_t;
 
@@ -103,37 +143,40 @@ void bl_power_on(int bl_flag)
 		aml_set_reg32_bits(P_LED_PWM_REG0, 1, 12, 2);
 		bl_gpio_direction_output(bl_config.gpio, 1);
 	}
-	else {
-		if (bl_config.pwm_port == BL_PWM_A) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.pwm_pre_div, 8, 7);  //pwm_a_clk_div
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
-		}
-		else if (bl_config.pwm_port == BL_PWM_B) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.pwm_pre_div, 16, 7);  //pwm_b_clk_div
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
-		}
-		else if (bl_config.pwm_port == BL_PWM_C) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.pwm_pre_div, 8, 7);  //pwm_c_clk_div
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
-		}
-		else if (bl_config.pwm_port == BL_PWM_D) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.pwm_pre_div, 16, 7);  //pwm_d_clk_div
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
+	else if ((bl_config.method == BL_CTL_PWM_NEGATIVE) || (bl_config.method == BL_CTL_PWM_POSITIVE)) {
+		switch (bl_config.pwm_port) {
+			case BL_PWM_A:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 8, 7);  //pwm_a_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
+				break;
+			case BL_PWM_B:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 16, 7);  //pwm_b_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
+				break;
+			case BL_PWM_C:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 8, 7);  //pwm_c_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
+				break;
+			case BL_PWM_D:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 16, 7);  //pwm_d_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
+				break;
+			default:
+				break;
 		}
 	
-		if (IS_ERR(bl_config.p)) {			
+		if (IS_ERR(bl_config.p)) {
 			printk("set backlight pinmux error.\n");
 			goto exit_bl_power_on;
-		}	
-			
+		}
 		s = pinctrl_lookup_state(bl_config.p, "default");	//select pinctrl
 		if (IS_ERR(s)) {
 			printk("set backlight pinmux error.\n");
@@ -152,6 +195,86 @@ void bl_power_on(int bl_flag)
 				bl_gpio_direction_output(bl_config.gpio, 1);
 		}
 	}
+	else if (bl_config.method == BL_CTL_PWM_COMBO) {
+		switch (bl_config.combo_high_port) {
+			case BL_PWM_A:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 8, 7);  //pwm_a_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
+				break;
+			case BL_PWM_B:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 16, 7);  //pwm_b_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
+				break;
+			case BL_PWM_C:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 8, 7);  //pwm_c_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
+				break;
+			case BL_PWM_D:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 16, 7);  //pwm_d_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
+				break;
+			default:
+				break;
+		}
+		switch (bl_config.combo_low_port) {
+			case BL_PWM_A:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 8, 7);  //pwm_a_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
+				break;
+			case BL_PWM_B:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 16, 7);  //pwm_b_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
+				break;
+			case BL_PWM_C:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 8, 7);  //pwm_c_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
+				break;
+			case BL_PWM_D:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 16, 7);  //pwm_d_clk_div
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
+				break;
+			default:
+				break;
+		}
+	
+		if (IS_ERR(bl_config.p)) {
+			printk("set backlight pinmux error.\n");
+			goto exit_bl_power_on;
+		}
+		s = pinctrl_lookup_state(bl_config.p, "pwm_combo");	//select pinctrl	
+		if (IS_ERR(s)) {
+			printk("set backlight pinmux error.\n");
+			devm_pinctrl_put(bl_config.p);
+			goto exit_bl_power_on;
+		}
+	
+		ret = pinctrl_select_state(bl_config.p, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set backlight pinmux error.\n");
+			devm_pinctrl_put(bl_config.p);
+			goto exit_bl_power_on;
+		}
+	}
+	else {
+		printk("Wrong backlight control method\n");
+		goto exit_bl_power_on;
+	}
 	bl_real_status = 1;
 	printk("backlight power on\n");
 	
@@ -175,22 +298,60 @@ void bl_power_off(int bl_flag)
 	if (bl_config.method == BL_CTL_GPIO) {
 		bl_gpio_direction_output(bl_config.gpio, 0);
 	}
-	else {
+	else if ((bl_config.method == BL_CTL_PWM_NEGATIVE) || (bl_config.method == BL_CTL_PWM_POSITIVE)) {
 		if (bl_config.pwm_gpio_used) {
 			if (bl_config.gpio)
 				bl_gpio_direction_output(bl_config.gpio, 0);
 		}
-		if (bl_config.pwm_port == BL_PWM_A) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //enable pwm_a
-		}
-		else if (bl_config.pwm_port == BL_PWM_B) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 1, 1);  //enable pwm_b
+		switch (bl_config.pwm_port) {
+			case BL_PWM_A:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //disable pwm_a
+				break;
+			case BL_PWM_B:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 1, 1);  //disable pwm_b
+				break;
+			case BL_PWM_C:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 0, 1);  //disable pwm_c
+				break;
+			case BL_PWM_D:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);	//disable pwm_d
+				break;
+			default:
+				break;
 		}
-		else if (bl_config.pwm_port == BL_PWM_C) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 0, 1);  //enable pwm_c
+	}
+	else if (bl_config.method == BL_CTL_PWM_COMBO) {
+		switch (bl_config.combo_high_port) {
+			case BL_PWM_A:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //disable pwm_a
+				break;
+			case BL_PWM_B:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 1, 1);  //disable pwm_b
+				break;
+			case BL_PWM_C:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 0, 1);  //disable pwm_c
+				break;
+			case BL_PWM_D:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);	//disable pwm_d
+				break;
+			default:
+				break;
 		}
-		else if (bl_config.pwm_port == BL_PWM_D) {
-			aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);	//disable pwm_d
+		switch (bl_config.combo_low_port) {
+			case BL_PWM_A:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //disable pwm_a
+				break;
+			case BL_PWM_B:
+				aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 1, 1);  //disable pwm_b
+				break;
+			case BL_PWM_C:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 0, 1);  //disable pwm_c
+				break;
+			case BL_PWM_D:
+				aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);	//disable pwm_d
+				break;
+			default:
+				break;
 		}
 	}
 	bl_real_status = 0;
@@ -209,8 +370,9 @@ static void set_backlight_level(unsigned level)
 	level = (level > bl_config.level_max ? bl_config.level_max : (level < bl_config.level_min ? (level < BL_LEVEL_OFF ? 0 : bl_config.level_min) : level));
 	bl_level = level;
 
-	if ((level == 0) && (bl_status == 1)) {
-		bl_power_off(DRV_BL_FLAG);
+	if (bl_level == 0) {
+		if (bl_real_status == 1)
+			bl_power_off(DRV_BL_FLAG);
 	}
 	else {
 		//mapping
@@ -223,7 +385,7 @@ static void set_backlight_level(unsigned level)
 			level = bl_config.dim_min - ((level - bl_config.level_min) * (bl_config.dim_min - bl_config.dim_max)) / (bl_config.level_max - bl_config.level_min);
 			aml_set_reg32_bits(P_LED_PWM_REG0, level, 0, 4);
 		}
-		else {
+		else if ((bl_config.method == BL_CTL_PWM_NEGATIVE) || (bl_config.method == BL_CTL_PWM_POSITIVE)) {
 			level = (bl_config.pwm_max - bl_config.pwm_min) * (level - bl_config.level_min) / (bl_config.level_max - bl_config.level_min) + bl_config.pwm_min;
 			if (bl_config.method == BL_CTL_PWM_NEGATIVE) {
 				pwm_hi = bl_config.pwm_cnt - level;
@@ -233,21 +395,135 @@ static void set_backlight_level(unsigned level)
 				pwm_hi = level;
 				pwm_lo = bl_config.pwm_cnt - level;
 			}
-			if (bl_config.pwm_port == BL_PWM_A) {
-				aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
+			switch (bl_config.pwm_port) {
+				case BL_PWM_A:
+					aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
+					break;
+				case BL_PWM_B:
+					aml_write_reg32(P_PWM_PWM_B, (pwm_hi << 16) | (pwm_lo));
+					break;
+				case BL_PWM_C:
+					aml_write_reg32(P_PWM_PWM_C, (pwm_hi << 16) | (pwm_lo));
+					break;
+				case BL_PWM_D:
+					aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
+					break;
+				default:
+					break;
 			}
-			else if (bl_config.pwm_port == BL_PWM_B) {
-				aml_write_reg32(P_PWM_PWM_B, (pwm_hi << 16) | (pwm_lo));
-			}
-			else if (bl_config.pwm_port == BL_PWM_C) {
-				aml_write_reg32(P_PWM_PWM_C, (pwm_hi << 16) | (pwm_lo));
+		}
+		else if (bl_config.method == BL_CTL_PWM_COMBO) {
+			if (level >= bl_config.combo_level_switch) {
+				//pre_set combo_low duty max
+				if (bl_config.combo_low_method == BL_CTL_PWM_NEGATIVE) {
+					pwm_hi = bl_config.combo_low_cnt - bl_config.combo_low_duty_max;
+					pwm_lo = bl_config.combo_low_duty_max;
+				}
+				else {
+					pwm_hi = bl_config.combo_low_duty_max;
+					pwm_lo = bl_config.combo_low_cnt - bl_config.combo_low_duty_max;
+				}
+				switch (bl_config.combo_low_port) {
+					case BL_PWM_A:
+						aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_B:
+						aml_write_reg32(P_PWM_PWM_B, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_C:
+						aml_write_reg32(P_PWM_PWM_C, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_D:
+						aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
+						break;
+					default:
+						break;
+				}
+				
+				//set combo_high duty
+				level = (bl_config.combo_high_duty_max - bl_config.combo_high_duty_min) * (level - bl_config.combo_level_switch) / (bl_config.level_max - bl_config.combo_level_switch) + bl_config.combo_high_duty_min;
+				if (bl_config.combo_high_method == BL_CTL_PWM_NEGATIVE) {
+					pwm_hi = bl_config.combo_high_cnt - level;
+					pwm_lo = level;
+				}
+				else {
+					pwm_hi = level;
+					pwm_lo = bl_config.combo_high_cnt - level;
+				}
+				switch (bl_config.combo_high_port) {
+					case BL_PWM_A:
+						aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_B:
+						aml_write_reg32(P_PWM_PWM_B, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_C:
+						aml_write_reg32(P_PWM_PWM_C, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_D:
+						aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
+						break;
+					default:
+						break;
+				}
 			}
-			else if (bl_config.pwm_port == BL_PWM_D) {
-				aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
+			else {
+				//pre_set combo_high duty min
+				if (bl_config.combo_high_method == BL_CTL_PWM_NEGATIVE) {
+					pwm_hi = bl_config.combo_high_cnt - bl_config.combo_high_duty_min;
+					pwm_lo = bl_config.combo_high_duty_min;
+				}
+				else {
+					pwm_hi = bl_config.combo_high_duty_min;;
+					pwm_lo = bl_config.combo_high_cnt - bl_config.combo_high_duty_min;
+				}
+				switch (bl_config.combo_high_port) {
+					case BL_PWM_A:
+						aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_B:
+						aml_write_reg32(P_PWM_PWM_B, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_C:
+						aml_write_reg32(P_PWM_PWM_C, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_D:
+						aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
+						break;
+					default:
+						break;
+				}
+				
+				//set combo_low duty
+				level = (bl_config.combo_low_duty_max - bl_config.combo_low_duty_min) * (level - bl_config.level_min) / (bl_config.combo_level_switch - bl_config.level_min) + bl_config.combo_low_duty_min;
+				if (bl_config.combo_low_method == BL_CTL_PWM_NEGATIVE) {
+					pwm_hi = bl_config.combo_low_cnt - level;
+					pwm_lo = level;
+				}
+				else {
+					pwm_hi = level;
+					pwm_lo = bl_config.combo_low_cnt - level;
+				}
+				switch (bl_config.combo_low_port) {
+					case BL_PWM_A:
+						aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_B:
+						aml_write_reg32(P_PWM_PWM_B, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_C:
+						aml_write_reg32(P_PWM_PWM_C, (pwm_hi << 16) | (pwm_lo));
+						break;
+					case BL_PWM_D:
+						aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
+						break;
+					default:
+						break;
+				}
 			}
 		}
 		if ((bl_status == 1) && (bl_real_status == 0))
-			bl_power_on(DRV_BL_FLAG);	
+			bl_power_on(DRV_BL_FLAG);
 	}
 	mutex_unlock(&bl_level_mutex);
 }
@@ -362,7 +638,7 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 	int ret=0;
 	int val;
 	const char *str;
-	unsigned int bl_para[2];
+	unsigned int bl_para[3];
 	unsigned pwm_freq, pwm_cnt, pwm_pre_div;
 	int i;
 	
@@ -402,13 +678,17 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 		ret = of_property_read_u32(pdev->dev.of_node, "bl_ctrl_method", &val);
 		if (ret) {
 			printk("faild to get bl_ctrl_method!\n");
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 			bl_config.method = BL_CTL_GPIO;
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+			bl_config.method = BL_CTL_PWM_NEGATIVE;
+#endif
 		}
 		else {
-			val = (val > 2) ? 2 : val;
+			val = (val >= BL_CTL_MAX) ? (BL_CTL_MAX-1) : val;
 			bl_config.method = (unsigned char)val;
 		}
-		DPRINT("bl control_method: %s(%u)\n", ((bl_config.method == 0) ? "GPIO" : ((bl_config.method == 1) ? "PWM_NEGATIVE" : "PWM_POSITIVE")), bl_config.method);
+		DPRINT("bl control_method: %s(%u)\n", bl_ctrl_method_table[bl_config.method], bl_config.method);
 		ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_port_gpio_used", 1, &str);
 		if (ret) {
 			printk("faild to get bl_pwm_port_gpio_used!\n");
@@ -424,7 +704,11 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 		ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_port_gpio_used", 0, &str);
 		if (ret) {
 			printk("faild to get bl_pwm_port_gpio_used!\n");
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 			bl_config.pwm_port = BL_PWM_D;
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+			bl_config.pwm_port = BL_PWM_C;
+#endif
 		}
 		else {
 			if (strcmp(str, "PWM_A") == 0)
@@ -437,11 +721,15 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 				bl_config.pwm_port = BL_PWM_D;
 			DPRINT("bl pwm_port: %s(%u)\n", str, bl_config.pwm_port);
 		}
-		if ((bl_config.method == BL_CTL_GPIO) || (bl_config.pwm_gpio_used == 1)) {
+		if ((bl_config.method == BL_CTL_GPIO) || ((bl_config.pwm_gpio_used == 1) && ((bl_config.method == BL_CTL_PWM_NEGATIVE) || (bl_config.method == BL_CTL_PWM_POSITIVE)))) {
 			ret = of_property_read_string(pdev->dev.of_node, "bl_gpio_port", &str);
 			if (ret) {
 				printk("faild to get bl_gpio_port!\n");
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 				str = "GPIOD_1";
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+				str = "GPIODV_28";
+#endif
 			}
 			val = amlogic_gpio_name_map_num(str);
 			if (val > 0) {
@@ -469,11 +757,15 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 		DPRINT("bl dim max=%u, min=%u\n", bl_config.dim_max, bl_config.dim_min);
 		ret = of_property_read_u32(pdev->dev.of_node,"bl_pwm_freq",&val);
 		if (ret) {
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 			pwm_freq = 1000;
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+			pwm_freq = 300000;
+#endif
 			printk("faild to get bl_pwm_freq, default set to %u\n", pwm_freq);
 		}
 		else {	
-			pwm_freq = ((val >= (FIN_FREQ * 500)) ? (FIN_FREQ * 500) : val);			
+			pwm_freq = ((val >= (FIN_FREQ * 500)) ? (FIN_FREQ * 500) : val);
 		}
 		for (i=0; i<0x7f; i++) {
 			pwm_pre_div = i;
@@ -494,6 +786,118 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 		bl_config.pwm_min = (bl_config.pwm_cnt * bl_para[1] / 100);
 		DPRINT("bl pwm_duty max=%u\%, min=%u\%\n", bl_para[0], bl_para[1]);
 		
+		//pwm combo
+		ret = of_property_read_u32(pdev->dev.of_node,"bl_pwm_combo_high_low_level_switch",&val);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_high_low_level_switch\n");
+			val = bl_config.level_mid;
+		}
+		if (val > bl_config.level_mid)
+			val = ((val - bl_config.level_mid) * (bl_config.level_max - bl_config.level_mid_mapping)) / (bl_config.level_max - bl_config.level_mid) + bl_config.level_mid_mapping;
+		else
+			val = ((val - bl_config.level_min) * (bl_config.level_mid_mapping - bl_config.level_min)) / (bl_config.level_mid - bl_config.level_min) + bl_config.level_min;
+		bl_config.combo_level_switch = val;
+		DPRINT("bl pwm_combo level switch =%u\n", bl_config.combo_level_switch);
+		ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_high_port_method", 0, &str);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_high_port_method!\n");
+			str = "PWM_C";
+			bl_config.combo_high_port = BL_PWM_C;
+		}
+		else {
+			if (strcmp(str, "PWM_A") == 0)
+				bl_config.combo_high_port = BL_PWM_A;
+			else if (strcmp(str, "PWM_B") == 0)
+				bl_config.combo_high_port = BL_PWM_B;
+			else if (strcmp(str, "PWM_C") == 0)
+				bl_config.combo_high_port = BL_PWM_C;
+			else if (strcmp(str, "PWM_D") == 0)
+				bl_config.combo_high_port = BL_PWM_D;
+		}
+		DPRINT("bl pwm_combo high port: %s(%u)\n", str, bl_config.combo_high_port);
+		ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_high_port_method", 1, &str);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_high_port_method!\n");
+			str = "1";
+			bl_config.combo_high_method = BL_CTL_PWM_NEGATIVE;
+		}
+		else {
+			if (strncmp(str, "1", 1) == 0)
+				bl_config.combo_high_method = BL_CTL_PWM_NEGATIVE;
+			else
+				bl_config.combo_high_method = BL_CTL_PWM_POSITIVE;
+		}
+		DPRINT("bl pwm_combo high method: %s(%u)\n", bl_ctrl_method_table[bl_config.combo_high_method], bl_config.combo_high_method);
+		ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_low_port_method", 0, &str);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_low_port_method!\n");
+			str = "PWM_D";
+			bl_config.combo_low_port = BL_PWM_D;
+		}
+		else {
+			if (strcmp(str, "PWM_A") == 0)
+				bl_config.combo_low_port = BL_PWM_A;
+			else if (strcmp(str, "PWM_B") == 0)
+				bl_config.combo_low_port = BL_PWM_B;
+			else if (strcmp(str, "PWM_C") == 0)
+				bl_config.combo_low_port = BL_PWM_C;
+			else if (strcmp(str, "PWM_D") == 0)
+				bl_config.combo_low_port = BL_PWM_D;
+		}
+		DPRINT("bl pwm_combo high port: %s(%u)\n", str, bl_config.combo_low_port);
+		ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_low_port_method", 1, &str);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_low_port_method!\n");
+			str = "1";
+			bl_config.combo_low_method = BL_CTL_PWM_NEGATIVE;
+		}
+		else {
+			if (strncmp(str, "1", 1) == 0)
+				bl_config.combo_low_method = BL_CTL_PWM_NEGATIVE;
+			else
+				bl_config.combo_low_method = BL_CTL_PWM_POSITIVE;
+		}
+		DPRINT("bl pwm_combo low method: %s(%u)\n", bl_ctrl_method_table[bl_config.combo_low_method], bl_config.combo_low_method);
+		ret = of_property_read_u32_array(pdev->dev.of_node,"bl_pwm_combo_high_freq_duty_max_min",&bl_para[0],3);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_high_freq_duty_max_min\n");
+			bl_para[0] = 300000;	//freq=300k
+			bl_para[1] = 100;
+			bl_para[2] = 50;
+		}
+		pwm_freq = ((bl_para[0] >= (FIN_FREQ * 500)) ? (FIN_FREQ * 500) : bl_para[0]);
+		for (i=0; i<0x7f; i++) {
+			pwm_pre_div = i;
+			pwm_cnt = FIN_FREQ * 1000 / (pwm_freq * (pwm_pre_div + 1)) - 2;
+			if (pwm_cnt <= 0xffff)
+				break;
+		}			
+		bl_config.combo_high_cnt = pwm_cnt;
+		bl_config.combo_high_pre_div = pwm_pre_div;
+		bl_config.combo_high_duty_max = (bl_config.combo_high_cnt * bl_para[1] / 100);
+		bl_config.combo_high_duty_min = (bl_config.combo_high_cnt * bl_para[2] / 100);
+		DPRINT("bl pwm_combo high freq=%uHz, duty_max=%u\%, duty_min=%u\%\n", pwm_freq, bl_para[1], bl_para[2]);
+		ret = of_property_read_u32_array(pdev->dev.of_node,"bl_pwm_combo_low_freq_duty_max_min",&bl_para[0],3);
+		if (ret) {
+			printk("faild to get bl_pwm_combo_low_freq_duty_max_min\n");
+			bl_para[0] = 1000;	//freq=1k
+			bl_para[1] = 100;
+			bl_para[2] = 50;
+		}
+		pwm_freq = ((bl_para[0] >= (FIN_FREQ * 500)) ? (FIN_FREQ * 500) : bl_para[0]);
+		for (i=0; i<0x7f; i++) {
+			pwm_pre_div = i;
+			pwm_cnt = FIN_FREQ * 1000 / (pwm_freq * (pwm_pre_div + 1)) - 2;
+			if (pwm_cnt <= 0xffff)
+				break;
+		}			
+		bl_config.combo_low_cnt = pwm_cnt;
+		bl_config.combo_low_pre_div = pwm_pre_div;
+		bl_config.combo_low_duty_max = (bl_config.combo_low_cnt * bl_para[1] / 100);
+		bl_config.combo_low_duty_min = (bl_config.combo_low_cnt * bl_para[2] / 100);
+		DPRINT("bl pwm_combo low freq=%uHz, duty_max=%u\%, duty_min=%u\%\n", pwm_freq, bl_para[1], bl_para[2]);
+		
+		//pinmux
 		bl_config.p = devm_pinctrl_get(&pdev->dev);
 		if (IS_ERR(bl_config.p))
 			printk("get backlight pinmux error.\n");
diff --git a/drivers/amlogic/display/backlight/aml_lcd_bl.h b/drivers/amlogic/display/backlight/aml_lcd_bl.h
index cadcbf32bffd..d8ce7f2a92a1 100755
--- a/drivers/amlogic/display/backlight/aml_lcd_bl.h
+++ b/drivers/amlogic/display/backlight/aml_lcd_bl.h
@@ -1 +1 @@
-/* * AMLOGIC lcd driver header file for backlight driver. * * * Author:  Evoke Zhang <evoke.zhang@amlogic.com> * */#ifndef __AML_LCD_BACKLIGHT_H#define __AML_LCD_BACKLIGHT_H#define LCD_BACKLIGHT_SUPPORT#define	DRV_BL_FLAG		0#define LCD_BL_FLAG		1/* for lcd backlight power */#define BL_CTL_GPIO				0#define BL_CTL_PWM_NEGATIVE		1#define BL_CTL_PWM_POSITIVE		2#define BL_PWM_A				0#define BL_PWM_B				1#define BL_PWM_C				2#define BL_PWM_D				3#define BL_LEVEL_MAX    		255#define BL_LEVEL_MIN    		10#define BL_LEVEL_OFF			1#define BL_LEVEL_MID    		128#define BL_LEVEL_MID_MAPPED		102extern void bl_power_on(int bl_flag);extern void bl_power_off(int bl_flag);#endif
\ No newline at end of file
+/* * AMLOGIC lcd driver header file for backlight driver. * * * Author:  Evoke Zhang <evoke.zhang@amlogic.com> * */#ifndef __AML_LCD_BACKLIGHT_H#define __AML_LCD_BACKLIGHT_H#define LCD_BACKLIGHT_SUPPORT#define	DRV_BL_FLAG		0#define LCD_BL_FLAG		1#define BL_LEVEL_MAX    		255#define BL_LEVEL_MIN    		10#define BL_LEVEL_OFF			1#define BL_LEVEL_MID    		128#define BL_LEVEL_MID_MAPPED		102extern void bl_power_on(int bl_flag);extern void bl_power_off(int bl_flag);#endif
\ No newline at end of file
-- 
2.19.0

