From a31bde50c2bd1b8146d8979541c3c06e31b8e4b5 Mon Sep 17 00:00:00 2001
From: "yun.cai" <yun.cai@amlogic.com>
Date: Tue, 3 Dec 2013 19:47:53 +0800
Subject: [PATCH 2856/5965] 1) add M6 DTD, g18, g33, g24 support. 2)add i2c
 support and remove related warning

---
 arch/arm/boot/dts/amlogic/aml_top.dtd       |   15 +-
 arch/arm/boot/dts/amlogic/meson6_g18.dtd    |  842 ++++++++++++
 arch/arm/boot/dts/amlogic/meson6_g24.dtd    | 1205 ++++++++++++++++++
 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd | 1267 +++++++++++++++++++
 arch/arm/boot/dts/amlogic/meson6_skt.dtd    |   44 +-
 arch/arm/configs/meson6_defconfig           |    3 +-
 drivers/amlogic/hdmi/hdmi_tx/aml.dtd        |   11 +-
 drivers/amlogic/i2c/aml.dtd                 |    3 +-
 drivers/amlogic/i2c/aml_i2c.c               |  182 ++-
 drivers/amlogic/i2c/aml_i2c.h               |    2 +-
 include/linux/i2c-aml.h                     |    2 +-
 mk_m6.sh                                    |   20 +
 scripts/amlogic/aml_dtd.sh                  |   48 +-
 13 files changed, 3496 insertions(+), 148 deletions(-)
 create mode 100644 arch/arm/boot/dts/amlogic/meson6_g18.dtd
 create mode 100644 arch/arm/boot/dts/amlogic/meson6_g24.dtd
 create mode 100644 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
 create mode 100755 mk_m6.sh

diff --git a/arch/arm/boot/dts/amlogic/aml_top.dtd b/arch/arm/boot/dts/amlogic/aml_top.dtd
index 2c635f911131..c1b8c746d9ca 100755
--- a/arch/arm/boot/dts/amlogic/aml_top.dtd
+++ b/arch/arm/boot/dts/amlogic/aml_top.dtd
@@ -9,6 +9,7 @@ void root_func(){
 //$$ ADD /{
 	compatible = "AMLOGIC,8726_MX";
 	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
 	#address-cells = <1>;
 	#size-cells = <1>;
 #else
@@ -57,7 +58,6 @@ void root_func(){
 #endif
     };
 
-#ifdef CONFIG_ARCH_MESON8
 /// ***************************************************************************************
 ///	-	Cache
 //$$ MODULE="Cache"
@@ -82,7 +82,6 @@ void root_func(){
           prefetch-prefetch_drop;
           prefetch-prefetch_offset = <7>;
     };
-#endif
 
 /// ***************************************************************************************
 ///	-	Memory
@@ -91,13 +90,22 @@ void root_func(){
 //$$ L2 PROP_U32 = "aml_reserved_start"
 //$$ L2 PROP_U32 = "aml_reserved_end"
 //$$ L2 PROP_U32 6 = "linux,usable-memory"
+#ifndef CONFIG_ARCH_MESON6
 	memory{
 		device_type = "memory";
 		aml_reserved_start = <0x05000000>; /**reserved memory start */
 		aml_reserved_end = <0x1c2fffff>;/**reserved memory end */
 		linux,usable-memory = <0x00000000 0x04000000 0x1c300000 0x63d00000>;
 	};
-#ifdef CONFIG_ARCH_MESON8	
+#else
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x85000000>; /**reserved memory start */
+		aml_reserved_end = <0x9c2fffff>;/**reserved memory end */
+		linux,usable-memory = <0x80000000 0x04000000 0x9c300000 0x23d00000>;
+	};
+#endif
+
 /// ***************************************************************************************
 ///	-	GIC
 //$$ MODULE="GIC"
@@ -111,6 +119,7 @@ void root_func(){
         #address-cells = <0>;
     };
     
+#ifdef CONFIG_ARCH_MESON8    
 /// ***************************************************************************************
 ///	-	VPU
 //$$ MODULE="VPU"
diff --git a/arch/arm/boot/dts/amlogic/meson6_g18.dtd b/arch/arm/boot/dts/amlogic/meson6_g18.dtd
new file mode 100644
index 000000000000..589bd82b2f8f
--- /dev/null
+++ b/arch/arm/boot/dts/amlogic/meson6_g18.dtd
@@ -0,0 +1,842 @@
+/*
+ * Amlogic-MX SKT Device Tree Source
+ *
+ * Copyright Amlogic 2013
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+/dts-v1/;
+/{
+	compatible = "AMLOGIC,8726_MX";
+	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        cpu@0 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            reg = <0x200>;
+        };
+        cpu@1 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            reg = <0x1>;
+        };
+    };
+
+	/*start  memory config*/
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x84000000>;
+		aml_reserved_end = <0x92afffff>;
+		linux,usable-memory = <0x80000000 0x04000000 0x92b00000 0x0d400000 0xa0000000 0x20000000>; 
+	};
+    gic:interrupt-controller{
+        compatible = "arm,cortex-a9-gic";
+        reg = <0xc4301000 0x1000
+               0xc4300100 0x0100>;
+        interrupt-controller;
+        #interrupt-cells = <3>;
+        #address-cells = <0>;
+    };
+
+	mesonfb{
+		compatible = "amlogic,mesonfb";
+		dev_name = "mesonfb";
+		reg = <0x84100000 0x01000000
+	   	 		0x85100000 0x00100000>;
+	  vmode = <0>; /*0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P*/
+	  display_size_default = <1280 1080 1280 2160 32>;
+	};
+				
+	mesonstream{
+		compatible = "amlogic,mesonstream";
+		dev_name = "mesonstream.0";
+		reg = <0x85200000 0x04000000
+						0x92100000 0x00a00000>;
+	};
+	
+	vdin0{
+		compatible = "amlogic,vdin";
+		dev_name = "vdin";
+		reg = <0x89200000 0x04000000
+					0x89200000 0x04000000>;
+		irq = <115>;
+		vdin_id = <0>;
+	};
+
+	deinterlace{
+		compatible = "amlogic,deinterlace";
+		dev_name = "deinterlace";
+		reg = <0x8d200000 0x02300000>;
+	};
+	
+	ppmgr{
+		compatible = "amlogic,ppmgr";
+		dev_name = "ppmgr";
+		reg = <0x8f500000 0x02c00000>;		
+	};
+	/*end*/
+	
+	early_init{
+		compatible = "amlogic,early_init";
+		dev_name = "early_init";
+		status = "ok";
+		gpio-1 = "GPIOAO_3";
+		gpio-2 = "GPIOAO_2";
+	};
+	
+	usb_con {
+		lm-compatible = "logicmodule-bus";
+					
+		usb_b{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <1>; /* lm name */
+			clock-src = "usb1";
+			port-id = <1>; /* ref to mach/usb.h */
+			port-type = <1>;	/* 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /* 0: default, 1: high, 2: full */
+			port-config = <0>; /* 0: default */
+			port-dma = <0>; /* 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <1>; /* 0: hardware, 1: sw_host, 2: sw_slave*/
+		};
+
+		usb_a{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <0>; /* lm name */
+			clock-src = "usb0";
+			port-id = <0>; /* ref to mach/usb.h */
+			port-type = <0>;	/* 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /* 0: default, high, 1: full */
+			port-config = <0>; /* 0: default */
+			port-dma = <0>; /* 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <0>; /* 0: hardware, 1: sw_host, 2: sw_slave*/
+			gpio-vbus-power = "GPIOD_9";
+			gpio-work-mask	= <1>; /*0: work on pulldown,1:work on pullup*/
+		};
+	};
+
+	rtc{
+		compatible = "amlogic,aml_rtc";
+	};
+	
+	uart_ao{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_ao";
+		status = "okay";
+		dev_name = "uart_ao";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ao_uart_pins>;
+	};
+	
+	uart_0{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_a";
+		status = "okay";
+		dev_name = "uart_0";
+	};
+	
+	uart_1{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_b";
+		status = "disabled";
+		dev_name = "uart_1";
+	};
+	
+	uart_2{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_c";
+		status = "disabled";
+		dev_name = "uart_2";
+	};
+	
+	uart_3{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_d";
+		status = "ok";
+		dev_name = "uart_3";
+	};
+
+	aml_pm{
+		compatible = "amlogic,pm";
+		dev_name = "aml_pm";
+	};
+	
+	meson-cs-regulator{
+		compatible = "amlogic,meson-cs-regulator";
+		dev_name = "meson-cs-regulator";
+		default_uV = <1110000>;
+		consumer_supplies-supply = "vcck-armcore";
+		init-data = <&vcck_init_data>;
+		vcck-table = <&vcck_opp_table>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&aml_pwm_pins>;
+			
+		voltage_step_table = <
+			1400000 1380000 1350000 1330000
+			1300000 1280000 1260000 1240000
+			1210000 1180000 1140000 1110000
+			1070000 1040000 1010000   970000
+		>;
+
+		vcck_pwm_table = <
+		    0x00001c 0x01001b 0x030019 0x040018
+	        0x060016 0x070015 0x080014 0x090013
+	        0x0b0011 0x0d000f 0x0f000d 0x11000b 
+	        0x130009 0x150007 0x170005 0x190003
+		>;
+			
+		vcck_init_data: vcck_init_data{
+			cons_name = "vcck";
+			min_uV = <1010000>;
+			max_uV = <1380000>;
+			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
+			num = <1>;	/*the number of vcck_data-supply*/
+			vcck_data-supply = "vcck-armcore";	
+		};
+			
+		vcck_opp_table: vcck_opp_table{
+			num = <11>;
+			table = <
+			1500000 1330000 1330000
+			1320000 1330000 1330000
+			1200000 1260000 1260000
+			1080000 1240000 1240000
+			1000000 1140000 1140000
+			  984000 1140000 1140000
+			  840000 1110000 1110000
+			  816000 1110000 1110000
+			  792000 1040000 1040000
+			  600000 1040000 1040000
+			  200000 1040000 1040000
+			>;
+		};
+	};
+
+    cpufreq-meson{
+		compatible = "amlogic,cpufreq-meson";
+		cpufreq_info = <&vcck_opp_table>;
+	};
+	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		reg = <0xc8100500 0x1d>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+	
+	i2c@c1108500{ /*I2C-A*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-A";
+		reg = <0xc1108500 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+		pinctrl-0=<&a_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+	};
+	
+	i2c@c11087c0{ /*I2C-B*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-B";
+		reg = <0xc11087c0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&b_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		
+		i2c@1A{
+			compatible = "asoc,rt5631";
+			reg = <0x1A>;
+		};
+	};
+	
+	amhdmitx{
+		compatible = "amlogic,amhdmitx";
+		dev_name = "amhdmitx";
+        vend-data = <&vend_data>;
+        pwr-ctrl = <&pwr_ctrl>;
+		phy-size = <3>;
+		phy-data = <27  0x16  0x30    /* 480i/p 576i/p */
+				 74  0x16  0x40    /* 720p 1080i */
+				 148  0x16  0x40   /* 1080p */
+				>;
+        vend_data: vend_data{
+            vendor_name = "Amlogic";           /* Max Chars: 8     */
+            vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+            product_desc = "MX MBox G18Ref";        /* Max Chars: 16    */
+            cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
+        };
+        pwr_ctrl: pwr_ctrl{
+            pwr_5v_on = "cpu","GPIOD_5","H";
+            pwr_5v_off = "cpu","GPIOD_5","L";
+            pwr_3v3_on = "";
+            pwr_3v3_off = "";
+            pwr_hpll_vdd_on = "";
+            pwr_hpll_vdd_off = "";
+        };
+	};
+	
+	mesonvout{
+		compatible = "amlogic,mesonvout";
+		dev_name = "mesonvout";
+		/*reg = <0 0>;*/
+	};
+	
+
+    vdacswitch{
+        compatible = "amlogic,vdacswitch";
+        dev_name = "vdacswitch";
+        hw-switch = <&hw_switch>;
+        hw_switch: hw_switch{
+            vout_cvbs = "GPIOC_2", "H", "GPIOC_3", "H";
+            vout_ypbr = "GPIOC_2", "L", "GPIOC_3", "L";
+            vout_vga  = "GPIOC_2", "H", "GPIOC_3", "L";
+        };
+    };
+		
+	card{
+		compatible = "amlogic,aml_card";
+		dev_name = "aml_sd_mmc.0";
+		pinctrl-names="sdhc_b","sdhc_c","sdhc_a";
+		pinctrl-0=<&sdhc_b_pins>;
+		pinctrl-1=<&sdhc_c_pins>;
+		pinctrl-2=<&sdhc_a_pins>;
+	};
+	sdio{
+        compatible = "amlogic,aml_sdio";
+        dev_name = "aml_sdio.0";
+        reg = <0xc1108c20 0x20>;
+        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins"; /*sd:sdio_b, emmc:sdio_c, sdio:sdio_a*/
+        // pinctrl-0 = <&sd_pins>;
+        // pinctrl-1 = <&emmc_pins>;
+        // pinctrl-2 = <&sdio_pins>;
+        pinctrl-0 = <&sd_clk_cmd_pins>;
+        pinctrl-1 = <&sd_all_pins>;
+        pinctrl-2 = <&emmc_clk_cmd_pins>;
+        pinctrl-3 = <&emmc_all_pins>;
+        pinctrl-4 = <&sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdio_all_pins>;
+
+        sd{
+            port = <1>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+            gpio_cd = "CARD_6";
+            gpio_power = "CARD_8";
+            power_level = <0>;
+            irq_in = <5>;
+            #irq_in_edge = "GPIO_IRQ_FALLING";
+            irq_out = <6>;
+            #irq_out_edge = "GPIO_IRQ_RISING";
+        };
+        	
+        emmc{
+            port = <2>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+            gpio_dat3 = "BOOT_3";
+            #gpio_cd = "CARD_6";
+            #gpio_power = "CARD_8";
+            #power_level = <0>;
+        };
+        
+        // sdio{
+            // port = <0>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            // pinname = "sdio";
+            // ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            // caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
+            // f_min = <300000>;
+            // f_max = <50000000>;
+            // f_max_w = <50000000>;
+            // max_req_size = <0x20000>;          /*128KB*/
+        // };
+    };
+    
+    // sdhc{
+        // compatible = "amlogic,aml_sdhc";
+        // dev_name = "aml_sdhc.0";
+        // reg = <0xc1108e00 0x30>;
+        // pinctrl-names = "sd"; /*sd:sdio_b, emmc:sdio_c, sdio:sdio_a*/
+        // pinctrl-0 = <&sdhc_b_pins>;
+
+        // sd{
+            // port = <4>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            // pinname = "sd";
+            // ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            // caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            // f_min = <300000>;
+            // f_max = <50000000>;
+            // f_max_w = <50000000>;
+            // max_req_size = <0x80000>;          /*512KB*/
+            // gpio_cd = "CARD_6";
+            // gpio_power = "CARD_8";
+            // power_level = <0>;
+            // irq_in = <5>;
+            // irq_out = <6>;
+        // };
+     // };
+	
+	meson-eth{
+		compatible = "amlogic,meson-eth";
+		dev_name = "meson-eth";
+		ethbaseaddr = <0xf3610000>;
+		interruptsnum = <8>;
+		pinctrl-names="default";
+	};
+
+	meson-remote{
+		compatible = "amlogic,aml_remote";
+		dev_name = "meson-remote";
+		ao_baseaddr = <0xf3100480>;
+		pinctrl-names="default";
+		pinctrl-0=<&remote_pins>;
+	};
+	
+	audio{
+		compatible = "amlogic,aml-audio";
+		dev_name = "aml-audio.0";
+	};
+
+	audio_dai{
+		compatible = "amlogic,aml-dai";
+		dev_name = "aml-dai.0";
+	};
+
+	
+	dummy_codec_audio{
+        status = "okay";
+        compatible = "amlogic,aml_dummy_codec_audio";
+        dev_name = "aml_dummy_codec_audio.0";
+        pinctrl-names = "dummy_codec_audio";
+        pinctrl-0 = <&aml_dummy_codec_pins>;
+    };
+    
+    dummy_codec{
+        status = "okay";
+        compatible = "amlogic,aml_dummy_codec";
+        dev_name = "dummy_codec.0";
+    };
+ 
+    wifi_power{
+        compatible = "amlogic,wifi_power";
+        dev_name = "wifi_power";
+        power_gpio = "GPIOE_11";
+    };
+    
+	saradc{
+		compatible = "amlogic,saradc";
+	};
+
+	adc_keypad{
+		compatible = "amlogic,adc_keypad";
+		key_num = <5>;
+		name_len = <20>;
+		key_name = "menu","vol-","vol+","back","home";
+		key_code = <139 114 115 158 102>;
+		key_chan = <4 4 4 4 4>;
+		key_val = <9 275 150 392 513>;
+		key_tolerance = <40 40 40 40 40>;
+	};
+
+	key_input{
+		compatible = "amlogic,key_input";
+		scan_period = <20>;
+		fuzz_time = <60>;
+		key_code_list = <116>;
+		key_num = <1>;
+		config = <0>;
+	};
+	
+    securitykey{ 
+        compatible = "amlogic,aml_keys"; 
+    }; 
+	
+	spi@cc000000{
+		compatible = "amlogic,apollo_spi_nor";
+		status = "ok";
+		reg = <0xcc000000 0x04000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&aml_spi_nor_pins>;
+
+		nr-parts = <2>;
+		nr-part-0 = <&bootloader>;
+		nr-part-1 = <&ubootenv>;
+
+		bootloader:bootloader{
+			name = "bootloader";
+			offset = <0>;
+			size = <0x60000>;
+		};
+
+		ubootenv:ubootenv{
+			name = "ubootenv";
+      offset = <0x80000>;
+      size = <0x8000>;
+    };
+	};
+
+	nand{
+		compatible = "amlogic,aml_nand";
+		dev_name = "nand";
+		reg = <0xc1108600 0x24>;
+		pinctrl-names = "nand_rb_mod","nand_norb_mod";
+		pinctrl-0 = <&nand_input_state &conf_nand_state &nand_base 
+									&nand_ce0 &nand_rb0 
+									&nand_rb1 &nand_ce1>;
+		pinctrl-1 = <&nand_input_state &conf_nand_state &nand_base 
+									&nand_ce0 &nand_ce1 
+									&nand_ce2 &nand_ce3>;							
+		device_id = <0>;			
+		plat-names = "nandnormal";
+		plat-num = <1>;
+		plat-part-0 = <&normal>;
+
+		normal: normal{
+			enable_pad ="ce0","ce1";
+			busy_pad = "rb0","rb1";
+			timming_mode = "mode5";
+			bch_mode = "bch60_1k";
+			plane_mode = "twoplane";
+			t_rea = <20>;
+			t_rhoh = <15>;
+			chip_num = <2>;
+			part_num = <8>;
+			partition = <&nand_partitions>;
+			rb_detect = <1>;
+		};
+				
+		nand_partitions:nand_partition{
+			logo{
+				offset=<0x0 0x4800000>;
+				size=<0x0 0x800000>;
+			};
+			aml_logo{
+				offset=<0x0 0x5800000>;
+				size=<0x0 0x800000>;
+			};
+			recovery{
+				offset=<0x0 0x6800000>;
+				size=<0x0 0x800000>;
+			};
+			boot{
+				offset=<0x0 0x8800000>;
+				size=<0x0 0x800000>;
+			};
+			system{
+				offset=<0x0 0xa800000>;
+				size=<0x0 0x40000000>;
+			};
+			cache{
+				offset=<0x0 0x4a800000>;
+				size=<0x0 0x20000000>;
+			};
+			backup{
+				offset=<0x0 0x6a800000>;
+				size=<0x0 0x10000000>;
+			};
+			userdata{
+				offset=<0xffffffff 0xffffffff>;
+				size=<0x0 0x0>;
+			};
+		};
+	};	
+	
+	gpio:gpio{
+		compatible = "amlogic,m6-gpio";
+		dev_name = "gpio";
+		#gpio-cells=<2>;
+	};
+
+	pinmux{
+		compatible = "amlogic,pinmux-m6";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;
+		ao_uart_pins:ao_uart{
+			amlogic,setmask=<10 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		a_uart_pins:a_uart{
+			amlogic,setmask=<4 0x3c00>;
+			amlogic,pins="GPIOX_13", "GPIOX_14", "GPIOX_15", "GPIOX_16";
+		};
+		aml_pwm_pins:aml_pwm{
+		    amlogic,setmask=<2 0x4>;
+			amlogic,clrmask=<1 0x20000000>;
+			amlogic,pins="GPIOD_0";
+		};
+		ao_i2c_master:ao_i2c{
+			amlogic,setmask=<10 0x60>;
+			amlogic,clrmask=<10 0x1800006>;
+			amlogic,pins="GPIOAO_4","GPIOAO_5";
+		};
+		a_i2c_master:a_i2c{
+			amlogic,setmask=<5 0xc000000>;
+			amlogic,clrmask=<5 0x3000000>;
+			amlogic,pins="GPIOX_25","GPIOX_26";
+		};
+		b_i2c_master:b_i2c{
+			amlogic,setmask=<5 0xc0000000>;
+			amlogic,clrmask=<5 0x30000000>;
+			amlogic,pins="GPIOX_27","GPIOX_28";
+		};
+		nand_input_state:nand_input{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_8","BOOT_9","BOOT_10","BOOT_11",
+						"BOOT_14","BOOT_15","BOOT_16";
+			amlogic,enable-output=<1>;
+		};
+		conf_nand_state: conf_nand{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_16";
+			amlogic,pullup=<1>;
+		};
+		nand_base: nand{
+			amlogic,setmask=<2 0xc3c0000>;
+			amlogic,clrmask=<	5 0xe
+							3 0x80000000
+							6 0x3c000000
+							4 0x70000000>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_14","BOOT_15","BOOT_16";
+		};
+		nand_ce0: nand_ce0{
+			amlogic,setmask=<2 0x2000000>;
+			amlogic,pins = "BOOT_8";
+		};
+		nand_ce1: nand_ce1{
+			amlogic,setmask=<2 0x1000000>;
+			amlogic,pins = "BOOT_9";
+		};
+		nand_ce2: nand_ce2{
+			amlogic,setmask=<2 0x800000>;
+			amlogic,pins = "BOOT_10";
+		};
+		nand_ce3: nand_ce3{
+			amlogic,setmask=<2 0x400000>;
+			amlogic,pins = "BOOT_11";
+		};
+		nand_rb0: nand_rb0{
+			amlogic,setmask=<2 0x20000>;
+			amlogic,clrmask=<2 0x800000>;
+			amlogic,pins = "BOOT_10";
+		};
+		nand_rb1: nand_rb1{
+			amlogic,setmask=<2 0x10000>;
+			amlogic,clrmask=<2 0x400000>;
+			amlogic,pins = "BOOT_11";
+		};
+
+		sdhc_b_pins:sdhc_b_pin{
+			amlogic,setmask=<2 0xfc00>;
+			amlogic,clrmask=<2 0xf0>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+		};
+		sdhc_c_pins:sdhc_c_pin{
+			amlogic,setmask=<6 0x3f000000>;
+			amlogic,clrmask=<4 0x6c000000 2 0x4c30000 3 0x80000000>;
+			amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+		};
+		sdhc_a_pins:sdhc_a_pin{
+			amlogic,setmask=<8 0x3f>;
+			amlogic,clrmask=<5 0x6c00 >;
+			amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+		};
+        
+        // sdhc_a_pins:sdhc_a_pin{
+            // amlogic,setmask=<5 0x00006c00>; /*0x00007c00 adds "GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7"; At the same time we should clrmask reg3_bit[27-30]*/
+            // amlogic,clrmask=<2 0x000000f0           /*sdhc b*/
+                                // 4 0x7c000000        /*sdhc c*/
+                                // 8 0x0000003f>;      /*sdio a, because it uses the same pins with sdhc a*/
+            // amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+        // };
+        // sdhc_b_pins:sdhc_b_pin{
+            // amlogic,setmask=<2 0x000000f0>;         /*sdhc b*/
+            // amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                // 4 0x7c000000        /*sdhc c*/
+                                // 2 0x0000fc00>;      /*sdio b*/
+            // amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+        // };
+        // sdhc_c_pins:sdhc_c_pin{
+            // amlogic,setmask=<4 0x6c000000>; /*0x7c000000 adds "BOOT_4","BOOT_5","BOOT_6","BOOT_7"; At the same time we should clrmask reg2_bit[24-25]*/
+            // amlogic,clrmask=<2 0x04c300f0           /*sdhc b & nand*/
+                                // 5 0x00007c00        /*sdhc a*/
+                                // 6 0x3f000000        /*sdio c*/
+                                // 3 0x80000000>;      /*I2C*/
+            // amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+        // };
+        sdio_all_pins:sdio_all_pins{
+            amlogic,setmask=<8 0x0000003f>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdio_clk_cmd_pins:sdio_clk_cmd_pins{
+            amlogic,setmask=<8 0x00000003>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sd_all_pins:sd_all_pins{
+            amlogic,setmask=<2 0x0000fc00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sd_clk_cmd_pins:sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_4","CARD_5"; /* CARD_4:CLK, CARD_5:CMD */
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        emmc_all_pins:emmc_all_pins{
+            amlogic,setmask=<6 0x3f000000>;         /*sdio c, */
+            amlogic,clrmask=<2 0x04c3fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000        /*sdhc c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+            amlogic,setmask=<6 0x03000000>;         /*bit[24-25] */
+            amlogic,clrmask=<2 0x04c3fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000        /*sdhc c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins = "BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        
+		remote_pins:remote_pin{
+			amlogic,setmask=<10 0x1>;
+			amlogic,pins="GPIOAO_7";
+		};
+		aml_i2s_pins: aml_i2s_pins{
+			amlogic,setmask=<9 0xAB0>;
+			amlogic,clrmask=<9 0x440>;
+			amlogic,pins = "GPIOE_0","GPIOE_1","GPIOE_2","GPIOE_3";
+		};
+		config_aml_hp_det_pins: config_aml_hp_det_pins{
+			amlogic,pins = "GPIOA_19";
+			amlogic,pullup=<1>;
+		};
+		aml_dummy_codec_pins: aml_dummy_codec_pins{
+			amlogic,setmask=<9 0x2B0
+							3 0x1000000>;
+			amlogic,clrmask=<9 0x380c4e>;
+			amlogic,pins = "GPIOE_1","GPIOE_2","GPIOE_3","GPIOE_4","GPIOC_9";
+		};
+		lcd_backlight_pins:lcd_backlight{
+			amlogic,setmask=<2 0x8>;
+			amlogic,clrmask=<1 0x10000000>;
+			amlogic,pins = "GPIOD_1";
+		};
+		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
+			amlogic,setmask=<1 0xc0000>;
+			amlogic,clrmask=<0 0xc00000>;
+			amlogic,pins = "GPIOD_2","GPIOD_3";
+		};
+		lcd_ttl_hvsync_pins_off:lcd_ttl_hvsync_off{
+			amlogic,clrmask=<0 0xc00000 1 0xc0000>;
+			amlogic,pins = "GPIOD_2","GPIOD_3";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_de_pins_on:lcd_ttl_de_on{
+			amlogic,setmask=<1 0x20000>;
+			amlogic,clrmask=<0 0x1000000>;
+			amlogic,pins = "GPIOD_4";
+		};
+		lcd_ttl_de_pins_off:lcd_ttl_de_off{
+			amlogic,clrmask=<0 0x1000000 1 0x20000>;
+			amlogic,pins = "GPIOD_4";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_clk_pins_on:lcd_ttl_clk_on{
+			amlogic,setmask=<1 0x4000>;
+			amlogic,clrmask=<0 0x8000000  1 0x3800>;
+			amlogic,pins = "GPIOD_7";
+		};
+		lcd_ttl_clk_pins_off:lcd_ttl_clk_off{
+			amlogic,clrmask=<0 0x8000000  1 0x7800>;
+			amlogic,pins = "GPIOD_7";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_8bit_pins_on:lcd_ttl_rgb_8bit_on{
+			amlogic,setmask=<0 0x3f>;
+			amlogic,clrmask=<5 0xff8000>;
+			amlogic,pins = "GPIOB_0","GPIOB_1","GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R0~R7
+						"GPIOB_8","GPIOB_9","GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G0~G7
+						"GPIOB_16","GPIOB_17","GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";//B0~B7
+		};
+		lcd_ttl_rgb_8bit_pins_off:lcd_ttl_rgb_8bit_off{
+			amlogic,clrmask=<0 0x3f 5 0xff8000>;
+			amlogic,pins = "GPIOB_0","GPIOB_1","GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R0~R7
+						"GPIOB_8","GPIOB_9","GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G0~G7
+						"GPIOB_16","GPIOB_17","GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";//B0~B7
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_6bit_pins_on:lcd_ttl_rgb_6bit_on{
+			amlogic,setmask=<0 0x15>;
+			amlogic,clrmask=<5 0xf98000>;
+			amlogic,pins = "GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R2~R7
+						"GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G2~G7
+						"GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";	//B2~B7
+		};
+		lcd_ttl_rgb_6bit_pins_off:lcd_ttl_rgb_6bit_off{
+			amlogic,clrmask=<0 0x15 5 0xf98000>;
+			amlogic,pins = "GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R2~R7
+						"GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G2~G7
+						"GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";	//B2~B7
+			amlogic,enable-output=<1>;
+		};
+		aml_cam_pins: aml_cam_pins{
+			amlogic,setmask=<9 0x1000>;
+			amlogic,pins = "GPIOZ_12";
+		};
+		aml_spi_nor_pins: aml_spi_nor_pins{
+			amlogic,setmask=<5 0xf>;
+			amlogic,clrmask=<2 0x380000>;
+			amlogic,pins = "BOOT_12","BOOT_13","BOOT_14","BOOT_17";
+		};
+	};
+}; /* end of / */
+
diff --git a/arch/arm/boot/dts/amlogic/meson6_g24.dtd b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
new file mode 100644
index 000000000000..29f6d83aea2d
--- /dev/null
+++ b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
@@ -0,0 +1,1205 @@
+/*
+ * Amlogic-MX SKT Device Tree Source
+ *
+ * Copyright Amlogic 2013
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+/dts-v1/;
+/{
+	compatible = "AMLOGIC,8726_MX";
+	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        cpu@0 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            reg = <0x200>;
+        };
+        cpu@1 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            reg = <0x1>;
+        };
+    };
+
+	/*start  memory config*/
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x84000000>;
+		aml_reserved_end = <0x90cfffff>;
+		linux,usable-memory = <0x80000000 0x04000000 0x90d00000 0x0f200000 0xa0000000 0x20000000>; 
+	};
+	
+    gic:interrupt-controller{
+        compatible = "arm,cortex-a9-gic";
+        reg = <0xc4301000 0x1000
+               0xc4300100 0x0100>;
+        interrupt-controller;
+        #interrupt-cells = <3>;
+        #address-cells = <0>;
+    };
+
+	mesonfb{
+		compatible = "amlogic,mesonfb";
+		dev_name = "mesonfb";
+		reg = <0x84100000 0x00600000
+	   	 		0x84700000 0x00100000>;
+ 		vmode = <1>; /*0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P*/
+ 		display_size_default = <1024 768 1024 1536 32>;
+	};
+
+	mesonfb-ext{
+		compatible = "amlogic,mesonfb-ext";
+		dev_name = "mesonfb-ext";
+		reg = <0x84800000 0x00600000
+	       	 0x84e00000 0x00100000>;
+	       display_size_default = <1024 768 1024 1536 32>;
+	};
+
+	mesonstream{
+		compatible = "amlogic,mesonstream";
+		dev_name = "mesonstream.0";
+		reg = <0x84f00000 0x04000000
+						0x8fe00000 0x00f00000>;
+	};
+	
+	vdin0{
+		compatible = "amlogic,vdin";
+		dev_name = "vdin";
+		reg = <0x88f00000 0x04000000
+					0x88f00000 0x04000000>;
+		irq = <115>;
+                vdin_id = <0>;
+	};
+
+	vm{
+		compatible = "amlogic,vm";
+		dev_name = "vm.0";
+		reg = <0x8cf00000 0x01000000>;
+	};
+
+	ppmgr{
+		compatible = "amlogic,ppmgr";
+		dev_name = "ppmgr";
+		reg = <0x8ee00000 0x00fc0000>;		
+	};
+
+	/*end*/
+	
+	usb_con {
+		lm-compatible = "logicmodule-bus";
+					
+		usb_b{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <1>; /* lm name */
+			clock-src = "usb1";
+			port-id = <1>; /* ref to mach/usb.h */
+			port-type = <1>;	/* 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /* 0: default, 1: high, 2: full */
+			port-config = <0>; /* 0: default */
+			port-dma = <0>; /* 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <1>; /* 0: hardware, 1: sw_host, 2: sw_slave*/
+		};
+
+		usb_a{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <0>; /* lm name */
+			clock-src = "usb0";
+			port-id = <0>; /* ref to mach/usb.h */
+			port-type = <0>;	/* 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /* 0: default, high, 1: full */
+			port-config = <0>; /* 0: default */
+			port-dma = <0>; /* 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <0>; /* 0: hardware, 1: sw_host, 2: sw_slave*/
+			gpio-vbus-power = "GPIOD_9";
+			gpio-work-mask	= <1>; /*0: work on pulldown,1:work on pullup*/
+		};
+	};
+
+	rtc{
+		compatible = "amlogic,aml_rtc";
+	};
+	
+	uart_ao{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_ao";
+		status = "okay";
+		dev_name = "uart_ao";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ao_uart_pins>;
+	};
+	
+	uart_0{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_a";
+		status = "okay";
+		dev_name = "uart_0";
+        pinctrl-names = "default";
+        pinctrl-0 = <&a_uart_pins>;
+	};
+	
+	uart_1{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_b";
+		status = "disabled";
+		dev_name = "uart_1";
+	};
+	
+	uart_2{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_c";
+		status = "disabled";
+		dev_name = "uart_2";
+	};
+	
+	uart_3{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_d";
+		status = "ok";
+		dev_name = "uart_3";
+	};
+	aml_pm{
+		compatible = "amlogic,pm";
+		dev_name = "aml_pm";
+	};
+	meson-cs-regulator{
+		compatible = "amlogic,meson-cs-regulator";
+		dev_name = "meson-cs-regulator";
+		default_uV = <1307000>;
+		consumer_supplies-supply = "vcck-armcore";
+		init-data = <&vcck_init_data>;
+		vcck-table = <&vcck_opp_table>;
+			
+		voltage_step_table = <
+			1307000 1298000 1277000 1255000
+			1234000 1212000 1190000 1169000
+			1147000 1126000 1104000 1082000
+			1061000 1039000 1018000  996000
+		>;
+					
+		vcck_init_data: vcck_init_data{
+			cons_name = "vcck";
+			min_uV = <996000>;
+			max_uV = <1307000>;
+			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
+			num = <1>;	/*the number of vcck_data-supply*/
+			vcck_data-supply = "vcck-armcore";	
+		};
+			
+		vcck_opp_table: vcck_opp_table{
+			num = <7>;
+			table = <
+			1500000 1307000 1307000
+			1320000 1298000 1298000
+			1200000 1212000 1212000
+			1080000 1147000 1147000
+			840000  1104000 1104000
+			600000  1039000 1039000
+			200000  996000  996000
+			>;
+		};
+	};
+
+	cpufreq-meson{
+		compatible = "amlogic,cpufreq-meson";
+		cpufreq_info = <&vcck_opp_table>;
+	};
+
+    battery_parameter:battery_parameter{
+        pmu_twi_id = <2>;                   /* AXP20_I2CBUS                         */
+        pmu_irq_id = <0>;                   /* INT_WATCHDOG                         */
+        pmu_twi_addr = <0x34>;              /* AXP20_ADDR                           */
+        pmu_battery_rdc = <87>;             /* battery internal resistor            */
+        pmu_battery_cap = <7200>;           /* battery capacity                     */
+        pmu_battery_technology = <4>;       /* POWER_SUPPLY_TECHNOLOGY_LiFe         */
+        pmu_battery_name = "PTI PL336078";  /* battery name                         */
+        pmu_init_chgvol = <4200000>;        /* target charge voltage                */
+        pmu_init_chgend_rate = <10>;        /* set initial charing end current rate */
+        pmu_init_chg_enabled = <1>;         /* set initial charing enabled          */
+        pmu_init_adc_freq = <25>;           /* set initial adc frequency            */
+        pmu_init_adc_freqc = <100>;         /* set initial coulomb adc coufrequency */
+        pmu_init_chg_pretime = <50>;        /* set initial pre-charging time        */
+        pmu_init_chg_csttime = <720>;       /* set initial pre-charging time        */
+        pmu_init_chgcur = <600000>;         /* set initial charging current limite  */
+        pmu_suspend_chgcur = <1000000>;     /* set suspend charging current limite  */
+        pmu_resume_chgcur = <600000>;       /* set resume charging current limite   */
+        pmu_shutdown_chgcur = <1000000>;    /* set shutdown charging current limite */
+        pmu_usbcur_limit = <1>;             /* enable usb current limit?            */
+        pmu_usbcur = <500>;                 /* usb limit current value if enabled   */
+        pmu_usbvol_limit = <1>;             /* enable usb vbus voltage limit        */
+        pmu_usbvol = <4400>;                /* voltage limit value if enabled       */
+        pmu_pwroff_vol = <3200>;            /* hardware force power off voltage     */
+        pmu_pwron_vol = <2900>;             /* power on when battery voltage above  */
+        pmu_pekoff_time = <6000>;           /* long press to power off system       */
+        pmu_pekoff_en  = <1>;               /* enable long press to PWR OFF system  */
+        pmu_peklong_time = <1500>;          /* threshold to detect long press       */
+        pmu_pwrok_time   = <64>;            /* delay to detect pwr ok signal        */
+        pmu_pwrnoe_time = <2000>;           /*                                      */
+        pmu_intotp_en = <1>;                /* over temperature protection enable   */
+        pmu_pekon_time = <128>;             /* powerkey hold time for power on      */
+        pmu_charge_efficiency = <84>;       /* efficient of charging                */
+        pmu_bat_curve = <
+         /* ocv, charge, discharge */
+            3132      0       0
+            3273      0       0
+            3414      0       0
+            3555      0       0
+            3625      1       3
+            3660      2       8
+            3696      3      16
+            3731     10      24
+            3766     15      38
+            3801     26      48
+            3836     42      56
+            3872     52      63
+            3942     66      74
+            4012     79      85
+            4083     90      95
+            4153    100     100>;
+    };
+    pmu {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        compatible = "amlogic, aml_pmu_prober";                 /* fixed for pmu driver, don't change   */
+        axp202 { /* PMU for AXP */
+            compatible = "axp_mfd";                             /* for driver probe, must have          */
+            sub_type = "axp20_mfd";                             /* sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /* attached i2c bus, must have          */
+            reg = <0x34>;                                       /* device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /* optional                             */
+            ddr_voltage   = <1500000>;                          /* default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /* default voltage for AO, optional     */
+            board_battery = <&battery_parameter>;               /* battery parameter used, must have    */
+            status = "okay";                                    /* status of pmu, only one should be OK */
+        };
+        aml1212{                                                /* PMU for AML1212, see comment above   */
+            compatible = "aml_pmu";
+            sub_type = "aml1212";
+            i2c_bus = "i2c_bus_ao";
+            reg = <0x35>;
+            soft_limit_to99 = <0>;
+            ddr_voltage   = <1500000>;
+            vddao_voltage = <1200000>;
+            board_battery = <&battery_parameter>;
+            status = "disable";
+        };
+        rn5t618{                                                /* PMU for RN5T618, see comment above   */
+            compatible = "ricoh_pmu";
+            sub_type = "rn5t618";
+            i2c_bus = "i2c_bus_ao";
+            reg = <0x32>;
+            soft_limit_to99 = <0>;
+            ddr_voltage   = <1500000>;
+            vddao_voltage = <1200000>;
+            board_battery = <&battery_parameter>;
+            status = "disable";
+        };
+    };
+		
+		
+	aml_cams{
+		compatible = "amlogic,cams_prober";
+		pinctrl-names = "default";
+		pinctrl-0 = <&aml_cam_pins> ;
+		cam_0{
+			cam_name = "gc0308";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_a";
+			gpio_pwdn = "GPIOE_11";
+			gpio_rst = "GPIOZ_0";
+			mirror_flip = <1>;
+			vertical_flip = <0>;
+		};
+		cam_1{
+			cam_name = "gt2005";
+			front_back = <1>;
+			i2c_bus = "i2c_bus_a";
+			gpio_pwdn = "GPIOE_10";
+			gpio_rst = "GPIOZ_0";
+			mirror_flip = <0>;
+			vertical_flip = <0>;
+		};
+		cam_2{
+			cam_name = "gc0328";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_a";
+			gpio_pwdn = "GPIOE_11";
+			gpio_rst = "GPIOZ_0";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+		};
+	
+	};
+	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		reg = <0xc8100500 0x1d>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+	
+	i2c@c1108500{ /*I2C-A*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-A";
+		reg = <0xc1108500 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+		pinctrl-0=<&a_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	
+	i2c@c11087c0{ /*I2C-B*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-B";
+		reg = <0xc11087c0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&b_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+	};
+	
+	amhdmitx{
+		compatible = "amlogic,amhdmitx";
+		dev_name = "amhdmitx";
+		phy-size = <3>;
+		phy-data = <27  0x16  0x30    /* 480i/p 576i/p */
+				 74  0x16  0x40    /* 720p 1080i */
+				 148  0x16  0x40   /* 1080p */
+				>;
+	};
+	
+	mesonvout{
+		compatible = "amlogic,mesonvout";
+		dev_name = "mesonvout";
+		/*reg = <0 0>;*/
+	};
+	
+	mesonvout2{
+		compatible = "amlogic,mesonvout2";
+		dev_name = "mesonvout2";
+		/*reg = <0 0>;*/
+	};
+	
+	backlight{
+		compatible = "amlogic,backlight";
+		dev_name = "backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
+		
+		bl_level_default=<102>;	/** default backlight level when enter kernel */
+		
+		//backlight power ctrl
+		bl_ctrl_method="gpio";	/** gpio, pwm_negative, pwm_positive */
+		bl_gpio_port="GPIOD_1";	/** backlight control gpio port */
+		bl_gpio_dim_max_min=<0x0 0xf>;	/** backlight brightness diming level for gpio control method, 0x0~0xf, negative logic */
+		bl_pwm_port_gpio_used="PWM_D","0";	/** pwm_gpio_used: 0 for no use gpio; 1 for use bl_gpio_port to enable/disable backlight */
+		bl_pwm_cnt_div=<60000 0>;	/** pwm_cnt<=65536, pwm_cnt=(pwm_high+pwm_low); pwm_freq=24M/pwm_cnt/(pwm_div+1) */
+		bl_pwm_duty_max_min=<100 20>;	/** backlight brightness diminig level for pwm control method, unit: % */
+	};
+	
+	lcd{
+		compatible = "amlogic,lcd";
+		dev_name = "lcd";
+		pinctrl-names = "ttl_6bit_hvsync_de_on","ttl_6bit_hvsync_on","ttl_6bit_de_on","ttl_8bit_hvsync_de_on","ttl_8bit_hvsync_on","ttl_8bit_de_on",
+						"ttl_6bit_hvsync_de_off","ttl_8bit_hvsync_de_off";
+		pinctrl-0 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-1 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-2 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-3 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-4 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-5 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-6 = <&lcd_ttl_rgb_6bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		pinctrl-7 = <&lcd_ttl_rgb_8bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		
+		lcd_model_name ="lcd_LP097X02";	/** lcd model name for uboot driver */
+		lcd_model_config = <&lcd_LP097X02>;	/** choose panel model config */
+		lcd_bits=<6>;	/** 6 or 8, desided by hardware design; only valid when lcd_bits_option=1 */
+		
+		/* below configs are decided by hardware design, you can modify them if needed. */
+		//ttl config
+		ttl_rb_bit_swap=<0 0>;	/** 0 for normal, 1 for swap */
+		//lvds config
+		lvds_channel_pn_swap=<0>;	/** 0 for normal, 1 for swap */
+		
+		/* recommend settings, you can modify them if needed. */
+		valid_hvsync_de=<0 1>;	/** 0 for disable signal, 1 for enable signal */
+		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** "sign-offset" is a pair; sign: 1 for positive, 0 for negative */
+		
+		dither_user_ctrl=<0 0x600>;	/** user define dither control, for special condition */
+		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust control */
+		
+		gamma_en_revert=<1 0>;	/** gamma_en: 1 for enable gamma table, 0 for disable gamma table; gamma_revert: 1 for revert gamma table */
+		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi: 0 for single gamma, means RGB use the same gamma; 1 for multi gamma, means RGB use different gamma */
+		/** gamma_coeff unit: % */
+		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
+		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
+				32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
+				64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 
+				96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 
+				128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 
+				160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 
+				192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 
+				224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
+		
+		/* default settings, don't modify them unless there is display problem */
+		clock_spread_spectrum=<0>;	/** ss_level: 0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5% */
+		clock_auto_generation=<1>;	/** 1 for auto generate clock parameters by lcd_clock, 0 for using customer clock parameters, as clk_pll_div_clk_ctrl defined */
+		clk_pll_div_clk_ctrl=<0x10220 0x18803 0x1111>;	/** only valid when clock_auto=0 */
+		lvds_phy_ctrl=<0xaf40>; /** lvds signals voltage control */
+		lvds_user_repack=<0 0>;	/** user define lvds data mapping, only valid when user=1, for special condition */
+		rgb_base_coeff=<0xf0 0x74a>;	/** rgb base & coeff control */
+		video_on_pixel_line=<80 32>;	/** cpu internal video hold time */
+		
+		//lcd power ctrl	//support up to 15 steps for each sequence
+		power_on_uboot="null";	/** only for uboot, ahead of lcd_power_on, no need config delay */
+		power_on_step_1="cpu","GPIOA_27","output_high";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_2="axp202","GPIO3","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_3="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_4="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_5="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_delay=<20 20 200>;	/** power on delay after each step */
+		power_off_step_1="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_2="axp202","GPIO3","input";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_3="cpu","GPIOA_27","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_4="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_5="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_delay=<30 20 100>;	/** power off delay after each step */
+		power_off_uboot="null";	/** only for uboot, at the end of lcd_power_off, no need config delay */
+	};
+
+	lcd_CLAP070NJ02:lcd_CLAP070NJ02{	//g33
+		model_name="CLAP070NJ02";	/** lcd model name */
+		interface="ttl";			/** mipi, lvds, edp, ttl */
+		active_area=<154 86>;		/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
+		lcd_bits_option=<8 1>;		/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		
+		resolution=<1024 600>;	/** horizontal resolution, vertical resolution */
+		period=<1344 635>;		/** horizontal period, vertical period */		
+		
+		clock_hz_pol=<42700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
+		hsync_width_backporch=<10 160>;	/** hsync_backporch include hsync_width */
+		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
+		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+	};
+	
+	lcd_TN070TN92:lcd_TN070TN92{	//800*480
+		model_name="TN070TN92";	/** lcd model name */
+		interface="ttl";	/** mipi, lvds, edp, ttl */
+		active_area=<154 86>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
+		lcd_bits_option=<8 1>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		
+		resolution=<800 480>;	/** horizontal resolution, vertical resolution */
+		period=<1056 525>;		/** horizontal period, vertical period */		
+		
+		clock_hz_pol=<33300000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
+		hsync_width_backporch=<10 46>;	/** hsync_backporch include hsync_width */
+		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
+		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+	};
+	
+	lcd_LP097X02:lcd_LP097X02{	//g24
+		model_name="LP097X02";	/** lcd model name */
+		interface="lvds";	/** mipi, lvds, edp, ttl */
+		active_area=<197 147>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
+		lcd_bits_option=<6 0>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		
+		resolution=<1024 768>;	/** horizontal resolution, vertical resolution */
+		period=<2084 810>;		/** horizontal period, vertical period */		
+		
+		clock_hz_pol=<85700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
+		hsync_width_backporch=<10 70>;	/** hsync_backporch include hsync_width */
+		vsync_width_backporch=<3 30>;	/** vsync_backporch include vsync_width */
+		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+	};
+		
+	efuse{
+		compatible = "amlogic,efuse";
+		dev_name = "efuse";
+		plat-pos = <0 454>;
+		plat-count = <58>;
+		usid-min = <8>; /*reserved*/
+		usid-max = <31>; /*reserved*/
+	};
+	
+	card{
+		compatible = "amlogic,aml_card";
+		dev_name = "aml_sd_mmc.0";
+		pinctrl-names="sdhc_b","sdhc_c","sdhc_a";
+		pinctrl-0=<&sdhc_b_pins>;
+		pinctrl-1=<&sdhc_c_pins>;
+		pinctrl-2=<&sdhc_a_pins>;
+	};
+	sdio{
+        compatible = "amlogic,aml_sdio";
+        dev_name = "aml_sdio.0";
+        reg = <0xc1108c20 0x20>;
+        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins"; /*sd:sdio_b, emmc:sdio_c, sdio:sdio_a*/
+        // pinctrl-0 = <&sd_pins>;
+        // pinctrl-1 = <&emmc_pins>;
+        // pinctrl-2 = <&sdio_pins>;
+        pinctrl-0 = <&sd_clk_cmd_pins>;
+        pinctrl-1 = <&sd_all_pins>;
+        pinctrl-2 = <&emmc_clk_cmd_pins>;
+        pinctrl-3 = <&emmc_all_pins>;
+        pinctrl-4 = <&sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdio_all_pins>;
+
+        sd{
+            port = <1>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+            gpio_cd = "CARD_6";
+            gpio_power = "CARD_8";
+            power_level = <0>;
+            irq_in = <5>;
+            #irq_in_edge = "GPIO_IRQ_FALLING";
+            irq_out = <6>;
+            #irq_out_edge = "GPIO_IRQ_RISING";
+        };
+        	
+        emmc{
+            port = <2>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+            gpio_dat3 = "BOOT_3";
+            #gpio_cd = "CARD_6";
+            #gpio_power = "CARD_8";
+            #power_level = <0>;
+        };
+        
+        sdio{
+            port = <0>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sdio";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+        };
+    };
+    
+    // sdhc{
+        // compatible = "amlogic,aml_sdhc";
+        // dev_name = "aml_sdhc.0";
+        // reg = <0xc1108e00 0x30>;
+        // pinctrl-names = "sd"; /*sd:sdio_b, emmc:sdio_c, sdio:sdio_a*/
+        // pinctrl-0 = <&sdhc_b_pins>;
+
+        // sd{
+            // port = <4>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            // pinname = "sd";
+            // ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            // caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            // f_min = <300000>;
+            // f_max = <50000000>;
+            // f_max_w = <50000000>;
+            // max_req_size = <0x80000>;          /*512KB*/
+            // gpio_cd = "CARD_6";
+            // gpio_power = "CARD_8";
+            // power_level = <0>;
+            // irq_in = <5>;
+            // irq_out = <6>;
+        // };
+     // };
+	
+	wifi{
+		compatible = "amlogic,aml_broadcm_wifi";
+		dev_name = "aml_broadcm_wifi";
+		interrupt_pin = "GPIOX_11";
+		irq_num = <4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		power_on_pin = "GPIOC_8";
+		clock_32k_pin = "GPIOX_12";
+	};
+	
+	meson-remote{
+		compatible = "amlogic,aml_remote";
+		dev_name = "meson-remote";
+		ao_baseaddr = <0xf3100480>;
+		pinctrl-names="default";
+		pinctrl-0=<&remote_pins>;
+	};
+    
+    aml_audio_codc{
+        compatible = "amlogic,audio_codec";
+        codec_rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <0>;
+            status = "okay";
+                
+        };  
+        codec_wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+            status = "disabled";
+        };
+    };
+    
+    audio_platform{
+        compatible = "amlogic,aml-audio";
+        dev_name = "aml-audio.0";
+    };
+
+    audio_dai{
+        compatible = "amlogic,aml-dai";
+        dev_name = "aml-dai.0";
+    };
+
+    wm8960_sound_card{
+        compatible = "sound_card,wm8960";
+        aml,sound_card = "AML-WM8960";
+        //aml,audio-codec = <&wm8960>;
+        aml,codec_dai = "wm8960-hifi";
+        aml,audio-routing =
+            "Ext Spk","SPK_LP",
+            "Ext Spk","SPK_LN",
+            "Ext Spk","SPK_RP",
+            "Ext Spk","SPK_RN",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICB","Mic",
+            "LINPUT1","MICB",
+            "LINPUT2","MICB",
+            "RINPUT1","MICB",
+            "RINPUT2","MICB";
+            
+        capless = <1>; 
+        dres = <2>; /*WM8960_DRES_600R*/
+        dis_hp_det = <0>;
+        pinctrl-names = "wm8960_audio";
+        pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
+        wm8960_gpio = "GPIOA_19";
+        hp_det_inv;
+        status = "disabled";
+        
+    };
+
+    rt5631_sound_card{
+        compatible = "sound_card,rt5631";
+        aml,sound_card = "AML-RT5631";
+        //aml,audio-codec = <&rt5631>;
+        aml,codec_dai = "rt5631-hifi";
+        aml,audio-routing =
+            "Ext Spk", "SPOL",
+            "Ext Spk","SPOR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "MIC1","MIC Bias1",
+            "MIC Bias1","MAIN MIC";
+        
+        /*dev_name = "aml_sound_card";*/
+        /*reg = <0 0>;*/
+        capless = <0>;
+        spk_watt = <0>;     /*RT5631_SPK_1_0W*/
+        spk_output = <2>;   /*RT5631_SPK_RIGHT*/
+        mic_input = <0>;    /*RT5631_MIC_DIFFERENTIAL*/
+        pinctrl-names = "rt5631_audio";
+        pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
+        rt5631_gpio = "GPIOA_19";
+        hp_det_inv;
+        status = "okay";
+    };
+    touch{
+        compatible = "amlogic,aml_touch";
+        #address-cells = <1>;
+        #size-cells = <0>;
+				touch_ft5x06:ft5x06{
+					touch_name = "ft5x06";
+					i2c_bus = "i2c_bus_a";
+					reg = <0x38>;
+					ic_type = <0>;
+					irq = <0>;
+					gpio_interrupt = "GPIOA_16";
+					gpio_reset = "GPIOC_3";
+					xres = <1024>;
+					yres = <768>;
+					pol = <0x4>;
+					fw_file = "/etc/touch/ft5x06.fw";
+				};
+				touch_gt81xx:gt81xx{
+					touch_name = "gt81xx";
+					i2c_bus = "i2c_bus_a";
+					reg = <0x55>;
+					irq = <0>;
+					irq_edge = "GPIO_IRQ_FALLING";
+					gpio_interrupt = "GPIOA_16";
+					gpio_reset = "GPIOC_3";
+					xres = <1024>;
+					yres = <768>;
+					pol = <0>;
+					max_num = <10>;
+					config_file = "/etc/touch/goodix.con";
+				};
+   };
+    
+	saradc{
+		compatible = "amlogic,saradc";
+	};
+
+	adc_keypad{
+		compatible = "amlogic,adc_keypad";
+		key_num = <5>;
+		name_len = <20>;
+		key_name = "menu","vol-","vol+","back","home";
+		key_code = <139 114 115 158 102>;
+		key_chan = <4 4 4 4 4>;
+		key_val = <9 275 150 392 513>;
+		key_tolerance = <40 40 40 40 40>;
+	};
+
+	key_input{
+		compatible = "amlogic,key_input";
+		scan_period = <20>;
+		fuzz_time = <60>;
+		key_code_list = <116>;
+		key_num = <1>;
+		config = <0>;
+	};
+    bt-dev{
+        compatible = "amlogic,bt-dev";
+        dev_name = "bt-dev";
+        gpio_reset = "GPIOC_9";
+        gpio_en = "GPIOC_7";
+        gpio_wake = "GPIOX_10";
+    };
+	nand{
+		compatible = "amlogic,aml_nand";
+		dev_name = "nand";
+		reg = <0xc1108600 0x24>;
+		pinctrl-names = "nand_rb_mod","nand_norb_mod";
+		pinctrl-0 = <&nand_input_state &conf_nand_state &nand_base 
+									&nand_ce0 &nand_rb0 
+									&nand_rb1 &nand_ce1>;
+		pinctrl-1 = <&nand_input_state &conf_nand_state &nand_base 
+									&nand_ce0 &nand_ce1 
+									&nand_ce2 &nand_ce3>;							
+		device_id = <0>;			
+		plat-names = "bootloader","nandnormal";
+		plat-num = <2>;
+		plat-part-0 = <&bootload>;
+		plat-part-1 = <&normal>;
+
+		bootload: bootload{
+			enable_pad ="ce0";
+			busy_pad = "rb0";
+			timming_mode = "mode5";
+			bch_mode = "bch60_1k";
+			t_rea = <20>;
+			t_rhoh = <15>;
+			chip_num = <1>;
+			part_num = <0>;
+			rb_detect = <1>;
+		};
+		normal: normal{
+			enable_pad ="ce0","ce1";
+			busy_pad = "rb0","rb1";
+			timming_mode = "mode5";
+			bch_mode = "bch60_1k";
+			plane_mode = "twoplane";
+			t_rea = <20>;
+			t_rhoh = <15>;
+			chip_num = <2>;
+			part_num = <7>;
+			partition = <&nand_partitions>;
+			rb_detect = <1>;
+		};
+				
+		nand_partitions:nand_partition{
+			logo{
+				offset=<0x0 0x4800000>;
+				size=<0x0 0x800000>;
+			};
+			aml_logo{
+				offset=<0x0 0x5800000>;
+				size=<0x0 0x800000>;
+			};
+			recovery{
+				offset=<0x0 0x6800000>;
+				size=<0x0 0x800000>;
+			};
+			boot{
+				offset=<0x0 0x8800000>;
+				size=<0x0 0x800000>;
+			};
+			system{
+				offset=<0x0 0xa800000>;
+				size=<0x0 0x40000000>;
+			};
+			cache{
+				offset=<0x0 0x4a800000>;
+				size=<0x0 0x20000000>;
+			};
+			userdata{
+				offset=<0xffffffff 0xffffffff>;
+				size=<0x0 0x0>;
+			};
+		};
+	};	
+
+    sensor{
+		compatible = "amlogic,aml_sensor";
+        sensor_bma250:bma250{
+            dev_name = "bma250";
+            status = "okay";
+            address = <0x18>;
+            i2c_bus = "i2c_bus_b";
+        };
+    };
+
+	securitykey{
+		compatible = "amlogic,aml_keys";
+	};
+
+	gpio:gpio{
+		compatible = "amlogic,m6-gpio";
+		dev_name = "gpio";
+		#gpio-cells=<2>;
+	};
+
+	pinmux{
+		compatible = "amlogic,pinmux-m6";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;
+		ao_uart_pins:ao_uart{
+			amlogic,setmask=<10 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		a_uart_pins:a_uart{
+			amlogic,setmask=<4 0x3c00>;
+			amlogic,pins="GPIOX_13", "GPIOX_14", "GPIOX_15", "GPIOX_16";
+		};
+		ao_i2c_master:ao_i2c{
+			amlogic,setmask=<10 0x60>;
+			amlogic,clrmask=<10 0x1800006>;
+			amlogic,pins="GPIOAO_4","GPIOAO_5";
+		};
+		a_i2c_master:a_i2c{
+			amlogic,setmask=<5 0xc000000>;
+			amlogic,clrmask=<5 0x3000000>;
+			amlogic,pins="GPIOX_25","GPIOX_26";
+		};
+		b_i2c_master:b_i2c{
+			amlogic,setmask=<5 0xc0000000>;
+			amlogic,clrmask=<5 0x30000000>;
+			amlogic,pins="GPIOX_27","GPIOX_28";
+		};
+		nand_input_state:nand_input{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_8","BOOT_9","BOOT_10","BOOT_11",
+						"BOOT_14","BOOT_15","BOOT_16";
+			amlogic,enable-output=<1>;
+		};
+		conf_nand_state: conf_nand{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_16";
+			amlogic,pullup=<1>;
+		};
+		nand_base: nand{
+			amlogic,setmask=<2 0xc3c0000>;
+			amlogic,clrmask=<	5 0xe
+							3 0x80000000
+							6 0x3c000000
+							4 0x70000000>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_14","BOOT_15","BOOT_16";
+		};
+		nand_ce0: nand_ce0{
+			amlogic,setmask=<2 0x2000000>;
+			amlogic,pins = "BOOT_8";
+		};
+		nand_ce1: nand_ce1{
+			amlogic,setmask=<2 0x1000000>;
+			amlogic,pins = "BOOT_9";
+		};
+		nand_ce2: nand_ce2{
+			amlogic,setmask=<2 0x800000>;
+			amlogic,pins = "BOOT_10";
+		};
+		nand_ce3: nand_ce3{
+			amlogic,setmask=<2 0x400000>;
+			amlogic,pins = "BOOT_11";
+		};
+		nand_rb0: nand_rb0{
+			amlogic,setmask=<2 0x20000>;
+			amlogic,clrmask=<2 0x800000>;
+			amlogic,pins = "BOOT_10";
+		};
+		nand_rb1: nand_rb1{
+			amlogic,setmask=<2 0x10000>;
+			amlogic,clrmask=<2 0x400000>;
+			amlogic,pins = "BOOT_11";
+		};
+
+		sdhc_b_pins:sdhc_b_pin{
+			amlogic,setmask=<2 0xfc00>;
+			amlogic,clrmask=<2 0xf0>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+		};
+		sdhc_c_pins:sdhc_c_pin{
+			amlogic,setmask=<6 0x3f000000>;
+			amlogic,clrmask=<4 0x6c000000 2 0x4c30000 3 0x80000000>;
+			amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+		};
+		sdhc_a_pins:sdhc_a_pin{
+			amlogic,setmask=<8 0x3f>;
+			amlogic,clrmask=<5 0x6c00 >;
+			amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+		};
+        
+        // sdhc_a_pins:sdhc_a_pin{
+            // amlogic,setmask=<5 0x00006c00>; /*0x00007c00 adds "GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7"; At the same time we should clrmask reg3_bit[27-30]*/
+            // amlogic,clrmask=<2 0x000000f0           /*sdhc b*/
+                                // 4 0x7c000000        /*sdhc c*/
+                                // 8 0x0000003f>;      /*sdio a, because it uses the same pins with sdhc a*/
+            // amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+        // };
+        // sdhc_b_pins:sdhc_b_pin{
+            // amlogic,setmask=<2 0x000000f0>;         /*sdhc b*/
+            // amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                // 4 0x7c000000        /*sdhc c*/
+                                // 2 0x0000fc00>;      /*sdio b*/
+            // amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+        // };
+        // sdhc_c_pins:sdhc_c_pin{
+            // amlogic,setmask=<4 0x6c000000>; /*0x7c000000 adds "BOOT_4","BOOT_5","BOOT_6","BOOT_7"; At the same time we should clrmask reg2_bit[24-25]*/
+            // amlogic,clrmask=<2 0x04c300f0           /*sdhc b & nand*/
+                                // 5 0x00007c00        /*sdhc a*/
+                                // 6 0x3f000000        /*sdio c*/
+                                // 3 0x80000000>;      /*I2C*/
+            // amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+        // };
+        sdio_all_pins:sdio_all_pins{
+            amlogic,setmask=<8 0x0000003f>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdio_clk_cmd_pins:sdio_clk_cmd_pins{
+            amlogic,setmask=<8 0x00000003>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sd_all_pins:sd_all_pins{
+            amlogic,setmask=<2 0x0000fc00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sd_clk_cmd_pins:sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_4","CARD_5"; /* CARD_4:CLK, CARD_5:CMD */
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        emmc_all_pins:emmc_all_pins{
+            amlogic,setmask=<6 0x3f000000>;         /*sdio c, */
+            amlogic,clrmask=<2 0x04c3fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000        /*sdhc c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+            amlogic,setmask=<6 0x03000000>;         /*bit[24-25] */
+            amlogic,clrmask=<2 0x04c3fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000        /*sdhc c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins = "BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        
+		remote_pins:remote_pin{
+			amlogic,setmask=<10 0x1>;
+			amlogic,pins="GPIOAO_7";
+		};
+		aml_i2s_pins: aml_i2s_pins{
+			amlogic,setmask=<9 0xAB0>;
+			amlogic,clrmask=<9 0x440>;
+			amlogic,pins = "GPIOE_0","GPIOE_1","GPIOE_2","GPIOE_3";
+		};
+		config_aml_hp_det_pins: config_aml_hp_det_pins{
+			amlogic,pins = "GPIOA_19";
+			amlogic,pullup=<1>;
+		};
+		aml_dummy_codec_pins: aml_dummy_codec_pins{
+			amlogic,setmask=<9 0x2B0
+							3 0x1000000>;
+			amlogic,clrmask=<9 0x380c4e>;
+			amlogic,pins = "GPIOE_1","GPIOE_2","GPIOE_3","GPIOE_4","GPIOC_9";
+		};
+		lcd_backlight_pins:lcd_backlight{
+			amlogic,setmask=<2 0x8>;
+			amlogic,clrmask=<1 0x10000000>;
+			amlogic,pins = "GPIOD_1";
+		};
+		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
+			amlogic,setmask=<1 0xc0000>;
+			amlogic,clrmask=<0 0xc00000>;
+			amlogic,pins = "GPIOD_2","GPIOD_3";
+		};
+		lcd_ttl_hvsync_pins_off:lcd_ttl_hvsync_off{
+			amlogic,clrmask=<0 0xc00000 1 0xc0000>;
+			amlogic,pins = "GPIOD_2","GPIOD_3";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_de_pins_on:lcd_ttl_de_on{
+			amlogic,setmask=<1 0x20000>;
+			amlogic,clrmask=<0 0x1000000>;
+			amlogic,pins = "GPIOD_4";
+		};
+		lcd_ttl_de_pins_off:lcd_ttl_de_off{
+			amlogic,clrmask=<0 0x1000000 1 0x20000>;
+			amlogic,pins = "GPIOD_4";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_clk_pins_on:lcd_ttl_clk_on{
+			amlogic,setmask=<1 0x4000>;
+			amlogic,clrmask=<0 0x8000000  1 0x3800>;
+			amlogic,pins = "GPIOD_7";
+		};
+		lcd_ttl_clk_pins_off:lcd_ttl_clk_off{
+			amlogic,clrmask=<0 0x8000000  1 0x7800>;
+			amlogic,pins = "GPIOD_7";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_8bit_pins_on:lcd_ttl_rgb_8bit_on{
+			amlogic,setmask=<0 0x3f>;
+			amlogic,clrmask=<5 0xff8000>;
+			amlogic,pins = "GPIOB_0","GPIOB_1","GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R0~R7
+						"GPIOB_8","GPIOB_9","GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G0~G7
+						"GPIOB_16","GPIOB_17","GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";//B0~B7
+		};
+		lcd_ttl_rgb_8bit_pins_off:lcd_ttl_rgb_8bit_off{
+			amlogic,clrmask=<0 0x3f 5 0xff8000>;
+			amlogic,pins = "GPIOB_0","GPIOB_1","GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R0~R7
+						"GPIOB_8","GPIOB_9","GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G0~G7
+						"GPIOB_16","GPIOB_17","GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";//B0~B7
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_6bit_pins_on:lcd_ttl_rgb_6bit_on{
+			amlogic,setmask=<0 0x15>;
+			amlogic,clrmask=<5 0xf98000>;
+			amlogic,pins = "GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R2~R7
+						"GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G2~G7
+						"GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";	//B2~B7
+		};
+		lcd_ttl_rgb_6bit_pins_off:lcd_ttl_rgb_6bit_off{
+			amlogic,clrmask=<0 0x15 5 0xf98000>;
+			amlogic,pins = "GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R2~R7
+						"GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G2~G7
+						"GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";	//B2~B7
+			amlogic,enable-output=<1>;
+		};
+		aml_cam_pins: aml_cam_pins{
+			amlogic,setmask=<9 0x1000>;
+			amlogic,pins = "GPIOZ_12";
+		};
+		aml_spi_nor_pins: aml_spi_nor_pins{
+			amlogic,setmask=<5 0xf>;
+			amlogic,clrmask=<2 0x380000>;
+			amlogic,pins = "BOOT_12","BOOT_13","BOOT_14","BOOT_17";
+		};
+	};
+	unifykey{
+		compatible = "amlogic,unifykey";
+		
+		/*efuse-version = <2>;*/ /*m6 efuse version 2,m3 efuse version 1, not config efuse version in default*/
+		unifykey-num = <3>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+
+		keysn_0: key_0{
+			key-name = "key0";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "key1";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+			key-name = "key2";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+	};
+
+}; /* end of / */
+
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
new file mode 100644
index 000000000000..8c6663e5aadc
--- /dev/null
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
@@ -0,0 +1,1267 @@
+/*
+ * Amlogic-MX SKT Device Tree Source
+ *
+ * Copyright Amlogic 2013
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+/dts-v1/;
+/{
+	compatible = "AMLOGIC,8726_MX";
+	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        cpu@0 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            reg = <0x200>;
+        };
+        cpu@1 {
+            device_type = "cpu";
+            compatible = "arm,cortex-a9";
+            reg = <0x1>;
+        };
+    };
+
+	/*start  memory config*/
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x84000000>;
+		aml_reserved_end = <0x907fffff>;
+		linux,usable-memory = <0x80000000 0x04000000 0x90800000 0x0f700000 0xa0000000 0x20000000>; 
+	};
+	gic:interrupt-controller{
+        compatible = "arm,cortex-a9-gic";
+        reg = <0xc4301000 0x1000
+               0xc4300100 0x0100>;
+        interrupt-controller;
+        #interrupt-cells = <3>;
+        #address-cells = <0>;
+    };
+
+	mesonfb{
+		compatible = "amlogic,mesonfb";
+		dev_name = "mesonfb";
+		reg = <0x84100000 0x00500000
+	   	 		0x84600000 0x00100000>;
+ 		vmode = <1>; /*0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P*/
+ 		display_size_default = <1024 600 1024 1200 32>;
+	};
+	
+	mesonfb-ext{
+		compatible = "amlogic,mesonfb-ext";
+		dev_name = "mesonfb-ext";
+		reg = <0x84700000 0x00500000
+	       	 0x84c00000 0x00100000>;
+		display_size_default = <1024 600 1024 1200 32>;
+	 
+	};
+
+	mesonstream{
+		compatible = "amlogic,mesonstream";
+		dev_name = "mesonstream.0";
+		reg = <0x84d00000 0x04000000
+						0x8f900000 0x00f00000>;
+	};
+
+	vdin0{
+		compatible = "amlogic,vdin";
+		dev_name = "vdin";
+		reg = <0x88d00000 0x04000000
+					0x88d00000 0x04000000>;
+		irq = <115>;
+		vdin_id = <0>;
+	};
+
+	vm{
+		compatible = "amlogic,vm";
+		dev_name = "vm.0";
+		reg = <0x8cd00000 0x01000000>;
+	};
+
+	ppmgr{
+		compatible = "amlogic,ppmgr";
+		dev_name = "ppmgr";
+		reg = <0x8ec00000 0x00d00000>;		
+	};
+	/*end*/
+	
+	usb_con {
+		lm-compatible = "logicmodule-bus";
+					
+		usb_b{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <1>; /* lm name */
+			clock-src = "usb1";
+			port-id = <1>; /* ref to mach/usb.h */
+			port-type = <1>;	/* 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /* 0: default, 1: high, 2: full */
+			port-config = <0>; /* 0: default */
+			port-dma = <0>; /* 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <1>; /* 0: hardware, 1: sw_host, 2: sw_slave*/
+		};
+
+		usb_a{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <0>; /* lm name */
+			clock-src = "usb0";
+			port-id = <0>; /* ref to mach/usb.h */
+			port-type = <0>;	/* 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /* 0: default, high, 1: full */
+			port-config = <0>; /* 0: default */
+			port-dma = <0>; /* 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <0>; /* 0: hardware, 1: sw_host, 2: sw_slave*/
+			gpio-vbus-power = "GPIOD_9";
+			gpio-work-mask	= <1>; /*0: work on pulldown,1:work on pullup*/
+		};
+	};
+
+	rtc{
+		compatible = "amlogic,aml_rtc";
+	};
+	
+	uart_ao{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_ao";
+		status = "okay";
+		dev_name = "uart_ao";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ao_uart_pins>;
+	};
+	
+	uart_0{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_a";
+		status = "okay";
+		dev_name = "uart_0";
+        pinctrl-names = "default";
+        pinctrl-0 = <&a_uart_pins>;
+	};
+	
+	uart_1{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_b";
+		status = "disabled";
+		dev_name = "uart_1";
+	};
+	
+	uart_2{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_c";
+		status = "disabled";
+		dev_name = "uart_2";
+	};
+	
+	uart_3{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_d";
+		status = "ok";
+		dev_name = "uart_3";
+	};
+	aml_pm{
+		compatible = "amlogic,pm";
+		dev_name = "aml_pm";
+	};
+ 	meson-cs-regulator{
+ 		compatible = "amlogic,meson-cs-regulator";
+ 		dev_name = "meson-cs-regulator";
+		default_uV = <1280000>;
+ 		consumer_supplies-supply = "vcck-armcore";
+ 		init-data = <&vcck_init_data>;
+ 		vcck-table = <&vcck_opp_table>;
+ 		pinctrl-names = "default";
+		pinctrl-0 = <&aml_pwm_pins>;
+ 			
+ 		vcck_pwm_table = <	
+ 		    0x040018 0x050017 0x060016 0x070015 
+	        0x080014 0x090013 0x0a0012 0x0b0011
+	        0x0c0010 0x0d000f 0x0e000e 0x0f000d
+	        0x10000c 0x11000b 0x12000a 0x130009
+	    >;
+		
+ 		voltage_step_table = <
+			1320000 1300000 1280000 1270000
+			1240000 1220000 1210000 1190000
+			1170000 1150000 1130000 1110000
+			1090000 1070000 1050000 1010000
+ 		>;
+ 					
+ 		vcck_init_data: vcck_init_data{
+ 			cons_name = "vcck";
+			min_uV = <1000000>;
+			max_uV = <1400000>;
+ 			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
+ 			num = <1>;	/*the number of vcck_data-supply*/
+ 			vcck_data-supply = "vcck-armcore";	
+ 		};
+ 			
+ 		vcck_opp_table: vcck_opp_table{
+			num = <11>;
+ 			table = <
+			1500000 1320000 1320000
+			1320000 1320000 1320000
+			1200000 1240000 1240000
+			1080000 1220000 1220000
+			1000000 1110000 1110000
+			  984000 1110000 1110000
+			  840000 1110000 1110000
+			  816000 1110000 1110000
+			  792000 1010000 1010000
+			  600000 1010000 1010000
+			  200000 1010000 1010000
+ 			>;
+ 		};
+ 	};
+ 	
+ 	 cpufreq-meson{
+		compatible = "amlogic,cpufreq-meson";
+		cpufreq_info = <&vcck_opp_table>;
+	};
+ 	
+    battery_parameter:battery_parameter{
+        pmu_twi_id = <2>;                   /* AXP20_I2CBUS                         */
+        pmu_irq_id = <0>;                   /* INT_WATCHDOG                         */
+        pmu_twi_addr = <0x34>;              /* AXP20_ADDR                           */
+        pmu_battery_rdc = <121>;             /* battery internal resistor            */
+        pmu_battery_cap = <3000>;           /* battery capacity                     */
+        pmu_battery_technology = <4>;       /* POWER_SUPPLY_TECHNOLOGY_LiFe         */
+        pmu_battery_name = "PTI PL336078";  /* battery name                         */
+        pmu_init_chgvol = <4200000>;        /* target charge voltage                */
+        pmu_init_chgend_rate = <10>;        /* set initial charing end current rate */
+        pmu_init_chg_enabled = <1>;         /* set initial charing enabled          */
+        pmu_init_adc_freq = <25>;           /* set initial adc frequency            */
+        pmu_init_adc_freqc = <100>;         /* set initial coulomb adc coufrequency */
+        pmu_init_chg_pretime = <50>;        /* set initial pre-charging time        */
+        pmu_init_chg_csttime = <720>;       /* set initial pre-charging time        */
+        pmu_init_chgcur = <600000>;         /* set initial charging current limite  */
+        pmu_suspend_chgcur = <1000000>;     /* set suspend charging current limite  */
+        pmu_resume_chgcur = <600000>;       /* set resume charging current limite   */
+        pmu_shutdown_chgcur = <1000000>;    /* set shutdown charging current limite */
+        pmu_usbcur_limit = <1>;             /* enable usb current limit?            */
+        pmu_usbcur = <500>;                 /* usb limit current value if enabled   */
+        pmu_usbvol_limit = <1>;             /* enable usb vbus voltage limit        */
+        pmu_usbvol = <4400>;                /* voltage limit value if enabled       */
+        pmu_pwroff_vol = <3200>;            /* hardware force power off voltage     */
+        pmu_pwron_vol = <2900>;             /* power on when battery voltage above  */
+        pmu_pekoff_time = <6000>;           /* long press to power off system       */
+        pmu_pekoff_en  = <1>;               /* enable long press to PWR OFF system  */
+        pmu_peklong_time = <1500>;          /* threshold to detect long press       */
+        pmu_pwrok_time   = <64>;            /* delay to detect pwr ok signal        */
+        pmu_pwrnoe_time = <2000>;           /*                                      */
+        pmu_intotp_en = <1>;                /* over temperature protection enable   */
+        pmu_pekon_time = <128>;             /* powerkey hold time for power on      */
+        pmu_charge_efficiency = <91>;       /* efficient of charging                */
+        pmu_bat_curve = <
+         /* ocv, charge, discharge */
+            3132      0       0
+            3273      0       0
+            3414      0       0
+            3555      0       0  
+            3625      7       9  
+            3660     11      14  
+            3696     16      18 
+            3731     20      22 
+            3766     22      28 
+            3801     29      50 
+            3836     47      62
+            3872     57      64
+            3942     72      75
+            4012     82      86
+            4083     90      94
+            4153    100     100>;
+    };
+    pmu {
+        compatible = "amlogic, aml_pmu_prober";                 /* fixed for pmu driver, don't change   */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        axp202 { /* PMU for AXP */
+            compatible = "axp_mfd";                             /* for driver probe, must have          */
+            sub_type = "axp20_mfd";                             /* sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /* attached i2c bus, must have          */
+            reg = <0x34>;                                       /* device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /* optional                             */
+            ddr_voltage   = <1500000>;                          /* default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /* default voltage for AO, optional     */
+            board_battery = <&battery_parameter>;               /* battery parameter used, must have    */
+            status = "okay";                                    /* status of pmu, only one should be OK */
+        };
+        aml1212{                                                /* PMU for AML1212, see comment above   */
+            compatible = "aml_pmu";
+            sub_type = "aml1212";
+            i2c_bus = "i2c_bus_ao";
+            reg = <0x35>;
+            soft_limit_to99 = <0>;
+            ddr_voltage   = <1500000>;
+            vddao_voltage = <1200000>;
+            board_battery = <&battery_parameter>;
+            status = "disable";
+        };
+        rn5t618{                                                /* PMU for RN5T618, see comment above   */
+            compatible = "ricoh_pmu";
+            sub_type = "rn5t618";
+            i2c_bus = "i2c_bus_ao";
+            reg = <0x32>;
+            soft_limit_to99 = <0>;
+            ddr_voltage   = <1500000>;
+            vddao_voltage = <1200000>;
+            board_battery = <&battery_parameter>;
+            status = "disable";
+        };
+    };
+		
+	aml_cams{
+		compatible = "amlogic,cams_prober";
+		pinctrl-names = "default";
+		pinctrl-0 = <&aml_cam_pins> ;
+		cam_0{
+			cam_name = "gc0308";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_a";
+			gpio_pwdn = "GPIOE_11";
+			gpio_rst = "GPIOZ_0";
+			mirror_flip = <1>;
+			vertical_flip = <0>;
+		};
+		cam_1{
+			cam_name = "gc0328";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_a";
+			gpio_pwdn = "GPIOE_11";
+			gpio_rst = "GPIOZ_0";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+		};
+	
+	};
+	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		reg = <0xc8100500 0x1d>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+	
+	i2c@c1108500{ /*I2C-A*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-A";
+		reg = <0xc1108500 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+		pinctrl-0=<&a_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	
+	i2c@c11087c0{ /*I2C-B*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-B";
+		reg = <0xc11087c0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&b_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+ 	};
+			
+	amhdmitx{
+		compatible = "amlogic,amhdmitx";
+		dev_name = "amhdmitx";
+		phy-size = <3>;
+		phy-data = <27  0x16  0x30    /* 480i/p 576i/p */
+				 74  0x16  0x40    /* 720p 1080i */
+				 148  0x16  0x40   /* 1080p */
+				>;
+	};
+	
+	mesonvout{
+		compatible = "amlogic,mesonvout";
+		dev_name = "mesonvout";
+		/*reg = <0 0>;*/
+	};
+	
+	mesonvout2{
+		compatible = "amlogic,mesonvout2";
+		dev_name = "mesonvout2";
+		/*reg = <0 0>;*/
+	};
+	
+	backlight{
+		compatible = "amlogic,backlight";
+		dev_name = "backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
+		
+		bl_level_default=<102>;	/** default backlight level when enter kernel */
+		
+		//backlight power ctrl
+		bl_ctrl_method="gpio";	/** gpio, pwm_negative, pwm_positive */
+		bl_gpio_port="GPIOD_1";	/** backlight control gpio port */
+		bl_gpio_dim_max_min=<0x0 0xf>;	/** backlight brightness diming level for gpio control method, 0x0~0xf, negative logic */
+		bl_pwm_port_gpio_used="PWM_D","0";	/** pwm_gpio_used: 0 for no use gpio; 1 for use bl_gpio_port to enable/disable backlight */
+		bl_pwm_cnt_div=<60000 0>;	/** pwm_cnt<=65536, pwm_cnt=(pwm_high+pwm_low); pwm_freq=24M/pwm_cnt/(pwm_div+1) */
+		bl_pwm_duty_max_min=<100 20>;	/** backlight brightness diminig level for pwm control method, unit: % */
+	};
+	
+	lcd{
+		compatible = "amlogic,lcd";
+		dev_name = "lcd";
+		pinctrl-names = "ttl_6bit_hvsync_de_on","ttl_6bit_hvsync_on","ttl_6bit_de_on","ttl_8bit_hvsync_de_on","ttl_8bit_hvsync_on","ttl_8bit_de_on",
+						"ttl_6bit_hvsync_de_off","ttl_8bit_hvsync_de_off";
+		pinctrl-0 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-1 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-2 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-3 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-4 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-5 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-6 = <&lcd_ttl_rgb_6bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		pinctrl-7 = <&lcd_ttl_rgb_8bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		
+		lcd_model_name ="lcd_CLAP070NJ02";	/** lcd model name for uboot driver */
+		lcd_model_config = <&lcd_CLAP070NJ02>;	/** choose panel model config */
+		lcd_bits=<6>;	/** 6 or 8, desided by hardware design; only valid when lcd_bits_option=1 */
+		
+		/* below configs are decided by hardware design, you can modify them if needed. */
+		//ttl config
+		ttl_rb_bit_swap=<0 0>;	/** 0 for normal, 1 for swap */
+		//lvds config
+		lvds_channel_pn_swap=<0>;	/** 0 for normal, 1 for swap */
+		
+		/* recommend settings, you can modify them if needed. */
+		valid_hvsync_de=<0 1>;	/** 0 for disable signal, 1 for enable signal */
+		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** "sign-offset" is a pair; sign: 1 for positive, 0 for negative */
+		
+		dither_user_ctrl=<0 0x600>;	/** user define dither control, for special condition */
+		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust control */
+		
+		gamma_en_revert=<1 0>;	/** gamma_en: 1 for enable gamma table, 0 for disable gamma table; gamma_revert: 1 for revert gamma table */
+		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi: 0 for single gamma, means RGB use the same gamma; 1 for multi gamma, means RGB use different gamma */
+		/** gamma_coeff unit: % */
+		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
+		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
+				32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
+				64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 
+				96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 
+				128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 
+				160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 
+				192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 
+				224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
+		
+		/* default settings, don't modify them unless there is display problem */
+		clock_spread_spectrum=<0>;	/** ss_level: 0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5% */
+		clock_auto_generation=<1>;	/** 1 for auto generate clock parameters by lcd_clock, 0 for using customer clock parameters, as clk_pll_div_clk_ctrl defined */
+		clk_pll_div_clk_ctrl=<0x10220 0x18803 0x1111>;	/** only valid when clock_auto=0 */
+		lvds_phy_ctrl=<0xaf40>; /** lvds signals voltage control */
+		lvds_user_repack=<0 0>;	/** user define lvds data mapping, only valid when user=1, for special condition */
+		rgb_base_coeff=<0xf0 0x74a>;	/** rgb base & coeff control */
+		video_on_pixel_line=<80 32>;	/** cpu internal video hold time */
+		
+		//lcd power ctrl	//support up to 15 steps for each sequence
+		power_on_uboot="axp202","GPIO1","output_low";	/** only for uboot, ahead of lcd_power_on, no need config delay */
+		power_on_step_1="cpu","GPIOD_8","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_2="cpu","GPIOA_27","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_3="cpu","GPIOD_8","output_high";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_4="axp202","GPIO3","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_5="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_delay=<0 10 20 10 200>;	/** power on delay after each step */
+		power_off_step_1="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_2="axp202","GPIO3","input";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_3="cpu","GPIOD_8","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_4="cpu","GPIOA_27","input";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_5="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_delay=<200 20 10 100>;	/** power off delay after each step */
+		power_off_uboot="axp202","GPIO1","input";	/** only for uboot, at the end of lcd_power_off, no need config delay */
+	};
+
+	lcd_CLAP070NJ02:lcd_CLAP070NJ02{	//g33
+		model_name="CLAP070NJ02";	/** lcd model name */
+		interface="ttl";			/** mipi, lvds, edp, ttl */
+		active_area=<154 86>;		/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
+		lcd_bits_option=<8 1>;		/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		
+		resolution=<1024 600>;	/** horizontal resolution, vertical resolution */
+		period=<1344 635>;		/** horizontal period, vertical period */		
+		
+		clock_hz_pol=<42700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
+		hsync_width_backporch=<10 160>;	/** hsync_backporch include hsync_width */
+		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
+		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+	};
+	
+	lcd_TN070TN92:lcd_TN070TN92{	//800*480
+		model_name="TN070TN92";	/** lcd model name */
+		interface="ttl";	/** mipi, lvds, edp, ttl */
+		active_area=<154 86>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
+		lcd_bits_option=<8 1>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		
+		resolution=<800 480>;	/** horizontal resolution, vertical resolution */
+		period=<1056 525>;		/** horizontal period, vertical period */		
+		
+		clock_hz_pol=<33300000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
+		hsync_width_backporch=<10 46>;	/** hsync_backporch include hsync_width */
+		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
+		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+	};
+	
+	lcd_LP097X02:lcd_LP097X02{	//g24
+		model_name="LP097X02";	/** lcd model name */
+		interface="lvds";	/** mipi, lvds, edp, ttl */
+		active_area=<197 147>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
+		lcd_bits_option=<6 0>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		
+		resolution=<1024 768>;	/** horizontal resolution, vertical resolution */
+		period=<2084 810>;		/** horizontal period, vertical period */		
+		
+		clock_hz_pol=<85700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
+		hsync_width_backporch=<10 70>;	/** hsync_backporch include hsync_width */
+		vsync_width_backporch=<3 30>;	/** vsync_backporch include vsync_width */
+		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+	};
+	
+	efuse{
+		compatible = "amlogic,efuse";
+		dev_name = "efuse";
+		plat-pos = <0 454>;
+		plat-count = <58>;
+		usid-min = <8>; /*reserved*/
+		usid-max = <31>; /*reserved*/
+	};
+	
+	card{
+		compatible = "amlogic,aml_card";
+		dev_name = "aml_sd_mmc.0";
+		pinctrl-names="sdhc_b","sdhc_c","sdhc_a";
+		pinctrl-0=<&sdhc_b_pins>;
+		pinctrl-1=<&sdhc_c_pins>;
+		pinctrl-2=<&sdhc_a_pins>;
+	};
+    sdio{
+        compatible = "amlogic,aml_sdio";
+        dev_name = "aml_sdio.0";
+        reg = <0xc1108c20 0x20>;
+        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins"; /*sd:sdio_b, emmc:sdio_c, sdio:sdio_a*/
+        // pinctrl-0 = <&sd_pins>;
+        // pinctrl-1 = <&emmc_pins>;
+        // pinctrl-2 = <&sdio_pins>;
+        pinctrl-0 = <&sd_clk_cmd_pins>;
+        pinctrl-1 = <&sd_all_pins>;
+        pinctrl-2 = <&emmc_clk_cmd_pins>;
+        pinctrl-3 = <&emmc_all_pins>;
+        pinctrl-4 = <&sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdio_all_pins>;
+
+        sd{
+            port = <1>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+            gpio_dat3 = "CARD_3";
+            gpio_cd = "CARD_6";
+            gpio_power = "CARD_8";
+            power_level = <0>;
+            irq_in = <5>;
+            #irq_in_edge = "GPIO_IRQ_FALLING";
+            irq_out = <6>;
+            #irq_out_edge = "GPIO_IRQ_RISING";
+        };
+            
+        emmc{
+            port = <2>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+            gpio_dat3 = "BOOT_3";
+            #gpio_cd = "CARD_6";
+            #gpio_power = "CARD_8";
+            #power_level = <0>;
+        };
+        
+        sdio{
+            port = <0>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sdio";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /*128KB*/
+        };
+    };
+    
+    // sdhc{
+        // compatible = "amlogic,aml_sdhc";
+        // dev_name = "aml_sdhc.0";
+        // reg = <0xc1108e00 0x30>;
+        // pinctrl-names = "sdhc_sd_clk_cmd_pins", "sdhc_sd_all_pins", "sdhc_emmc_clk_cmd_pins", "sdhc_emmc_all_pins"; // , "sdhc_sdio_clk_cmd_pins", "sdhc_sdio_all_pins"; [>sd:sdio_b, emmc:sdio_c, sdio:sdio_a<]
+        // pinctrl-0 = <&sdhc_sd_clk_cmd_pins>;
+        // pinctrl-1 = <&sdhc_sd_all_pins>;
+        // pinctrl-2 = <&sdhc_emmc_clk_cmd_pins>;
+        // pinctrl-3 = <&sdhc_emmc_all_pins>;
+        // pinctrl-4 = <&sdhc_sdio_clk_cmd_pins>;
+        // pinctrl-5 = <&sdhc_sdio_all_pins>;
+
+        // emmc{
+            // port = <5>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            // pinname = "emmc";
+            // ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            // caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            // f_min = <300000>;
+            // f_max = <50000000>;
+            // f_max_w = <50000000>;
+            // max_req_size = <0x20000>;          /*128KB*/
+            // gpio_dat3 = "BOOT_3";
+            // #gpio_cd = "CARD_6";
+            // #gpio_power = "CARD_8";
+            // #power_level = <0>;
+            // all_pins_name = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+        // };
+
+        // sd{
+            // port = <4>;          [>0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c <]
+            // pinname = "sd";
+            // ocr_avail = <0x200000>;          [>VDD voltage 3.3 ~ 3.4 <]
+            // caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            // f_min = <300000>;
+            // f_max = <50000000>;
+            // f_max_w = <50000000>;
+            // max_req_size = <0x80000>;          [>512KB<]
+            // gpio_dat3 = "CARD_3";
+            // gpio_cd = "CARD_6";
+            // gpio_power = "CARD_8";
+            // power_level = <0>;
+            // irq_in = <5>;
+            // irq_out = <6>;
+            // all_pins_name = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+        // };
+        
+        // sdio{
+            // port = <3>;          [>0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c <]
+            // pinname = "sdio";
+            // ocr_avail = <0x200000>;          [>VDD voltage 3.3 ~ 3.4 <]
+            // caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
+            // f_min = <300000>;
+            // f_max = <50000000>;
+            // f_max_w = <50000000>;
+            // max_req_size = <0x20000>;          [>128KB<]
+            // all_pins_name = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+        // };
+    // };
+	
+	wifi{
+		compatible = "amlogic,aml_broadcm_wifi";
+		dev_name = "aml_broadcm_wifi";
+		interrupt_pin = "GPIOX_11";
+		irq_num = <4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		power_on_pin = "GPIOAO_3";
+		clock_32k_pin = "GPIOX_12";
+	};
+	
+	meson-remote{
+		compatible = "amlogic,aml_remote";
+		dev_name = "meson-remote";
+		ao_baseaddr = <0xf3100480>;
+		pinctrl-names="default";
+		pinctrl-0=<&remote_pins>;
+	};
+
+    aml_audio_codc{
+        compatible = "amlogic,audio_codec";
+        codec_rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <0>;
+            status = "disabled";    
+        };  
+        codec_wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+            status = "okay";
+        };
+    };
+    
+    audio_platform{
+        compatible = "amlogic,aml-audio";
+        dev_name = "aml-audio.0";
+    };
+
+    audio_dai{
+        compatible = "amlogic,aml-dai";
+        dev_name = "aml-dai.0";
+    };
+
+    wm8960_sound_card{
+        compatible = "sound_card,wm8960";
+        aml,sound_card = "AML-WM8960";
+        //aml,audio-codec = <&wm8960>;
+        aml,codec_dai = "wm8960-hifi";
+        aml,audio-routing =
+            "Ext Spk","SPK_LP",
+            "Ext Spk","SPK_LN",
+            "Ext Spk","SPK_RP",
+            "Ext Spk","SPK_RN",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICB","Mic",
+            "LINPUT1","MICB",
+            "LINPUT2","MICB",
+            "RINPUT1","MICB",
+            "RINPUT2","MICB";
+            
+        capless = <1>; 
+        dres = <2>; /*WM8960_DRES_600R*/
+        dis_hp_det = <0>;
+        pinctrl-names = "wm8960_audio";
+        pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
+        wm8960_gpio = "GPIOA_19";
+        hp_det_inv;
+        status = "okay";
+    };
+
+    rt5631_sound_card{
+        compatible = "sound_card,rt5631";
+        aml,sound_card = "AML-RT5631";
+        //aml,audio-codec = <&rt5631>;
+        aml,codec_dai = "rt5631-hifi";
+        aml,audio-routing =
+            "Ext Spk", "SPOL",
+            "Ext Spk","SPOR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "MIC1","MIC Bias1",
+            "MIC Bias1","MAIN MIC";
+        
+        /*dev_name = "aml_sound_card";*/
+        /*reg = <0 0>;*/
+        capless = <0>;
+        spk_watt = <0>;     /*RT5631_SPK_1_0W*/
+        spk_output = <2>;   /*RT5631_SPK_RIGHT*/
+        mic_input = <0>;    /*RT5631_MIC_DIFFERENTIAL*/
+        pinctrl-names = "rt5631_audio";
+        pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
+        rt5631_gpio = "GPIOA_19";
+        hp_det_inv;
+        status = "disabled";
+    };
+    touch{
+        compatible = "amlogic,aml_touch";
+        #address-cells = <1>;
+        #size-cells = <0>;
+				touch_ft5x06:ft5x06{
+					touch_name = "ft5x06";
+					i2c_bus = "i2c_bus_a";
+					reg = <0x38>;
+					ic_type = <0>;
+					irq = <0>;
+					gpio_interrupt = "GPIOA_16";
+					gpio_reset = "GPIOC_3";
+					xres = <1024>;
+					yres = <600>;
+					pol = <0x1>;
+					fw_file = "/etc/touch/ft5x06.fw";
+				};
+				touch_gslx680:gslx680{
+					touch_name = "gslx680";
+					i2c_bus = "i2c_bus_a";
+					reg = <0x40>;
+					ic_type = <0>;
+					irq = <1>;
+					irq_edge = "GPIO_IRQ_RISING";
+					gpio_interrupt = "GPIOA_16";
+					gpio_reset = "GPIOC_3";
+					xres = <1024>;
+					yres = <600>;
+					pol = <0x4>;
+					max_num = <5>;
+					fw_file = "/etc/touch/gslx680.fw";
+				};
+   };
+    
+	saradc{
+		compatible = "amlogic,saradc";
+	};
+
+	adc_keypad{
+		compatible = "amlogic,adc_keypad";
+		key_num = <5>;
+		name_len = <20>;
+		key_name = "menu","vol-","vol+","back","home";
+		key_code = <139 114 115 158 102>;
+		key_chan = <4 4 4 4 4>;
+		key_val = <9 275 150 392 513>;
+		key_tolerance = <40 40 40 40 40>;
+	};
+
+	key_input{
+		compatible = "amlogic,key_input";
+		scan_period = <20>;
+		fuzz_time = <60>;
+		key_code_list = <116>;
+		key_num = <1>;
+		config = <0>;
+	};
+
+    securitykey{ 
+        compatible = "amlogic,aml_keys"; 
+    }; 
+    	
+    bt-dev{
+        compatible = "amlogic,bt-dev";
+        dev_name = "bt-dev";
+        gpio_reset = "GPIOC_9";
+        gpio_en = "GPIOC_7";
+        gpio_wake = "GPIOX_10";
+    };
+	nand{
+		compatible = "amlogic,aml_nand";
+		dev_name = "nand";
+		reg = <0xc1108600 0x24>;
+		pinctrl-names = "nand_rb_mod","nand_norb_mod";
+		pinctrl-0 = <&nand_input_state &conf_nand_state &nand_base 
+									&nand_ce0 &nand_rb0 
+									&nand_rb1 &nand_ce1>;
+		pinctrl-1 = <&nand_input_state &conf_nand_state &nand_base 
+									&nand_ce0 &nand_ce1 
+									&nand_ce2 &nand_ce3>;							
+		device_id = <0>;			
+		plat-names = "bootloader","nandnormal";
+		plat-num = <2>;
+		plat-part-0 = <&bootload>;
+		plat-part-1 = <&normal>;
+
+		bootload: bootload{
+			enable_pad ="ce0";
+			busy_pad = "rb0";
+			timming_mode = "mode5";
+			bch_mode = "bch60_1k";
+			t_rea = <20>;
+			t_rhoh = <15>;
+			chip_num = <1>;
+			part_num = <0>;
+			rb_detect = <1>;
+		};
+		normal: normal{
+			enable_pad ="ce0","ce1";
+			busy_pad = "rb0","rb1";
+			timming_mode = "mode5";
+			bch_mode = "bch60_1k";
+			plane_mode = "twoplane";
+			t_rea = <20>;
+			t_rhoh = <15>;
+			chip_num = <2>;
+			part_num = <7>;
+			partition = <&nand_partitions>;
+			rb_detect = <1>;
+		};
+				
+		nand_partitions:nand_partition{
+			logo{
+				offset=<0x0 0x4800000>;
+				size=<0x0 0x800000>;
+			};
+			aml_logo{
+				offset=<0x0 0x5800000>;
+				size=<0x0 0x800000>;
+			};
+			recovery{
+				offset=<0x0 0x6800000>;
+				size=<0x0 0x800000>;
+			};
+			boot{
+				offset=<0x0 0x8800000>;
+				size=<0x0 0x800000>;
+			};
+			system{
+				offset=<0x0 0xa800000>;
+				size=<0x0 0x40000000>;
+			};
+			cache{
+				offset=<0x0 0x4a800000>;
+				size=<0x0 0x20000000>;
+			};
+			userdata{
+				offset=<0xffffffff 0xffffffff>;
+				size=<0x0 0x0>;
+			};
+		};
+	};	
+
+    sensor{
+		compatible = "amlogic,aml_sensor";
+        sensor_stk831x:stk831x{
+            dev_name = "stk831x";
+            status = "okay";
+            address = <0x3d>;
+            i2c_bus = "i2c_bus_b";
+        };
+
+        sensor_mma7660:mma7660{
+            dev_name = "mma7660";
+            status = "okay";
+            address = <0x4c>;
+            i2c_bus = "i2c_bus_b";
+        };
+    };
+
+	gpio:gpio{
+		compatible = "amlogic,m6-gpio";
+		dev_name = "gpio";
+		#gpio-cells=<2>;
+	};
+
+	pinmux{
+		compatible = "amlogic,pinmux-m6";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;
+		ao_uart_pins:ao_uart{
+			amlogic,setmask=<10 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		a_uart_pins:a_uart{
+			amlogic,setmask=<4 0x3c00>;
+			amlogic,pins="GPIOX_13", "GPIOX_14", "GPIOX_15", "GPIOX_16";
+		};
+		aml_pwm_pins:aml_pwm{
+		    amlogic,setmask=<2 0x4>;
+			amlogic,clrmask=<1 0x20000000>;
+			amlogic,pins="GPIOD_0";
+		};
+		ao_i2c_master:ao_i2c{
+			amlogic,setmask=<10 0x60>;
+			amlogic,clrmask=<10 0x1800006>;
+			amlogic,pins="GPIOAO_4","GPIOAO_5";
+		};
+		a_i2c_master:a_i2c{
+			amlogic,setmask=<5 0xc000000>;
+			amlogic,clrmask=<5 0x3000000>;
+			amlogic,pins="GPIOX_25","GPIOX_26";
+		};
+		b_i2c_master:b_i2c{
+			amlogic,setmask=<5 0xc0000000>;
+			amlogic,clrmask=<5 0x30000000>;
+			amlogic,pins="GPIOX_27","GPIOX_28";
+		};
+		nand_input_state:nand_input{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_8","BOOT_9","BOOT_10","BOOT_11",
+						"BOOT_14","BOOT_15","BOOT_16";
+			amlogic,enable-output=<1>;
+		};
+		conf_nand_state: conf_nand{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_16";
+			amlogic,pullup=<1>;
+		};
+		nand_base: nand{
+			amlogic,setmask=<2 0xc3c0000>;
+			amlogic,clrmask=<	5 0xe
+							3 0x80000000
+							6 0x3c000000
+							4 0x70000000>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_14","BOOT_15","BOOT_16";
+		};
+		nand_ce0: nand_ce0{
+			amlogic,setmask=<2 0x2000000>;
+			amlogic,pins = "BOOT_8";
+		};
+		nand_ce1: nand_ce1{
+			amlogic,setmask=<2 0x1000000>;
+			amlogic,pins = "BOOT_9";
+		};
+		nand_ce2: nand_ce2{
+			amlogic,setmask=<2 0x800000>;
+			amlogic,pins = "BOOT_10";
+		};
+		nand_ce3: nand_ce3{
+			amlogic,setmask=<2 0x400000>;
+			amlogic,pins = "BOOT_11";
+		};
+		nand_rb0: nand_rb0{
+			amlogic,setmask=<2 0x20000>;
+			amlogic,clrmask=<2 0x800000>;
+			amlogic,pins = "BOOT_10";
+		};
+		nand_rb1: nand_rb1{
+			amlogic,setmask=<2 0x10000>;
+			amlogic,clrmask=<2 0x400000>;
+			amlogic,pins = "BOOT_11";
+		};
+
+		sdhc_b_pins:sdhc_b_pin{
+			amlogic,setmask=<2 0xfc00>;
+			amlogic,clrmask=<2 0xf0>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+		};
+		sdhc_c_pins:sdhc_c_pin{
+			amlogic,setmask=<6 0x3f000000>;
+			amlogic,clrmask=<4 0x6c000000 2 0x4c30000 3 0x80000000>;
+			amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+		};
+		sdhc_a_pins:sdhc_a_pin{
+			amlogic,setmask=<8 0x3f>;
+			amlogic,clrmask=<5 0x6c00 >;
+			amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+		};
+        
+        sdhc_sdio_all_pins:sdhc_sdio_all_pins{
+            amlogic,setmask=<5 0x00006c00>; /*0x00007c00 adds "GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7"; At the same time we should clrmask reg3_bit[27-30]*/
+            amlogic,clrmask=<2 0x000000f0           /*sdhc b*/
+                                4 0x7c000000        /*sdhc c*/
+                                8 0x0000003f>;      /*sdio a, because it uses the same pins with sdhc a*/
+            amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdhc_sdio_clk_cmd_pins:sdhc_sdio_clk_cmd_pins{
+            amlogic,setmask=<5 0x00000c00>; /*0x00007c00 adds "GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7"; At the same time we should clrmask reg3_bit[27-30]*/
+            amlogic,clrmask=<2 0x000000f0           /*sdhc b*/
+                                4 0x7c000000        /*sdhc c*/
+                                8 0x0000003f>;      /*sdio a, because it uses the same pins with sdhc a*/
+            amlogic,pins="GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        // sdhc_sd_init_pins:sdhc_sd_init_pins{
+            // amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            // amlogic,enable-output=<1>; [> 0:output, 1:input <]
+            // amlogic,pullup=<0>;
+        // };
+        sdhc_sd_all_pins:sdhc_sd_all_pins{
+            amlogic,setmask=<2 0x000000f0>;         /*sdhc b*/
+            amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                4 0x7c000000        /*sdhc c*/
+                                2 0x0000fc00>;      /*sdio b*/
+            amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdhc_sd_clk_cmd_pins:sdhc_sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000030>;         /*sdhc b*/
+            amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                4 0x7c000000        /*sdhc c*/
+                                2 0x0000fc00>;      /*sdio b*/
+            amlogic,pins="CARD_4","CARD_5"; /* CARD_4:CLK, CARD_5:CMD */
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdhc_emmc_all_pins:sdhc_emmc_all_pins{
+            amlogic,setmask=<4 0x6c000000>; /*0x7c000000 adds "BOOT_4","BOOT_5","BOOT_6","BOOT_7"; At the same time we should clrmask reg2_bit[24-25]*/
+            amlogic,clrmask=<2 0x04c300f0           /*sdhc b & nand*/
+                                5 0x00007c00        /*sdhc a*/
+                                6 0x3f000000        /*sdio c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdhc_emmc_clk_cmd_pins:sdhc_emmc_clk_cmd_pins{
+            amlogic,setmask=<4 0x0c000000>; /*0x7c000000 adds "BOOT_4","BOOT_5","BOOT_6","BOOT_7"; At the same time we should clrmask reg2_bit[24-25]*/
+            amlogic,clrmask=<2 0x04c300f0           /*sdhc b & nand*/
+                                5 0x00007c00        /*sdhc a*/
+                                6 0x3f000000        /*sdio c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins="BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        
+        sdio_all_pins:sdio_all_pins{
+            amlogic,setmask=<8 0x0000003f>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sdio_clk_cmd_pins:sdio_clk_cmd_pins{
+            amlogic,setmask=<8 0x00000003>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sd_all_pins:sd_all_pins{
+            amlogic,setmask=<2 0x0000fc00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        sd_clk_cmd_pins:sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_4","CARD_5"; /* CARD_4:CLK, CARD_5:CMD */
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        emmc_all_pins:emmc_all_pins{
+            amlogic,setmask=<6 0x3f000000>;         /*sdio c, */
+            amlogic,clrmask=<2 0x04c3fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000        /*sdhc c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+            amlogic,setmask=<6 0x03000000>;         /*bit[24-25] */
+            amlogic,clrmask=<2 0x04c3fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000        /*sdhc c*/
+                                3 0x80000000>;      /*I2C*/
+            amlogic,pins = "BOOT_10","BOOT_11";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<0>;
+        };
+        
+		remote_pins:remote_pin{
+			amlogic,setmask=<10 0x1>;
+			amlogic,pins="GPIOAO_7";
+		};
+		aml_i2s_pins: aml_i2s_pins{
+			amlogic,setmask=<9 0xAB0>;
+			amlogic,clrmask=<9 0x440>;
+			amlogic,pins = "GPIOE_0","GPIOE_1","GPIOE_2","GPIOE_3";
+		};
+		config_aml_hp_det_pins: config_aml_hp_det_pins{
+			amlogic,pins = "GPIOA_19";
+			amlogic,pullup=<1>;
+		};
+		aml_dummy_codec_pins: aml_dummy_codec_pins{
+			amlogic,setmask=<9 0x2B0
+							3 0x1000000>;
+			amlogic,clrmask=<9 0x380c4e>;
+			amlogic,pins = "GPIOE_1","GPIOE_2","GPIOE_3","GPIOE_4","GPIOC_9";
+		};
+		lcd_backlight_pins:lcd_backlight{
+			amlogic,setmask=<2 0x8>;
+			amlogic,clrmask=<1 0x10000000>;
+			amlogic,pins = "GPIOD_1";
+		};
+		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
+			amlogic,setmask=<1 0xc0000>;
+			amlogic,clrmask=<0 0xc00000>;
+			amlogic,pins = "GPIOD_2","GPIOD_3";
+		};
+		lcd_ttl_hvsync_pins_off:lcd_ttl_hvsync_off{
+			amlogic,clrmask=<0 0xc00000 1 0xc0000>;
+			amlogic,pins = "GPIOD_2","GPIOD_3";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_de_pins_on:lcd_ttl_de_on{
+			amlogic,setmask=<1 0x20000>;
+			amlogic,clrmask=<0 0x1000000>;
+			amlogic,pins = "GPIOD_4";
+		};
+		lcd_ttl_de_pins_off:lcd_ttl_de_off{
+			amlogic,clrmask=<0 0x1000000 1 0x20000>;
+			amlogic,pins = "GPIOD_4";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_clk_pins_on:lcd_ttl_clk_on{
+			amlogic,setmask=<1 0x4000>;
+			amlogic,clrmask=<0 0x8000000  1 0x3800>;
+			amlogic,pins = "GPIOD_7";
+		};
+		lcd_ttl_clk_pins_off:lcd_ttl_clk_off{
+			amlogic,clrmask=<0 0x8000000  1 0x7800>;
+			amlogic,pins = "GPIOD_7";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_8bit_pins_on:lcd_ttl_rgb_8bit_on{
+			amlogic,setmask=<0 0x3f>;
+			amlogic,clrmask=<5 0xff8000>;
+			amlogic,pins = "GPIOB_0","GPIOB_1","GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R0~R7
+						"GPIOB_8","GPIOB_9","GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G0~G7
+						"GPIOB_16","GPIOB_17","GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";//B0~B7
+		};
+		lcd_ttl_rgb_8bit_pins_off:lcd_ttl_rgb_8bit_off{
+			amlogic,clrmask=<0 0x3f 5 0xff8000>;
+			amlogic,pins = "GPIOB_0","GPIOB_1","GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R0~R7
+						"GPIOB_8","GPIOB_9","GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G0~G7
+						"GPIOB_16","GPIOB_17","GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";//B0~B7
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_6bit_pins_on:lcd_ttl_rgb_6bit_on{
+			amlogic,setmask=<0 0x15>;
+			amlogic,clrmask=<5 0xf98000>;
+			amlogic,pins = "GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R2~R7
+						"GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G2~G7
+						"GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";	//B2~B7
+		};
+		lcd_ttl_rgb_6bit_pins_off:lcd_ttl_rgb_6bit_off{
+			amlogic,clrmask=<0 0x15 5 0xf98000>;
+			amlogic,pins = "GPIOB_2","GPIOB_3","GPIOB_4","GPIOB_5","GPIOB_6","GPIOB_7",		//R2~R7
+						"GPIOB_10","GPIOB_11","GPIOB_12","GPIOB_13","GPIOB_14","GPIOB_15",	//G2~G7
+						"GPIOB_18","GPIOB_19","GPIOB_20","GPIOB_21","GPIOB_22","GPIOB_23";	//B2~B7
+			amlogic,enable-output=<1>;
+		};
+		aml_cam_pins: aml_cam_pins{
+			amlogic,setmask=<9 0x1000>;
+			amlogic,pins = "GPIOZ_12";
+		};
+		aml_spi_nor_pins: aml_spi_nor_pins{
+			amlogic,setmask=<5 0xf>;
+			amlogic,clrmask=<2 0x380000>;
+			amlogic,pins = "BOOT_12","BOOT_13","BOOT_14","BOOT_17";
+		};
+	};
+
+}; /* end of / */
+
diff --git a/arch/arm/boot/dts/amlogic/meson6_skt.dtd b/arch/arm/boot/dts/amlogic/meson6_skt.dtd
index a49e35c25fdb..a00132e82367 100644
--- a/arch/arm/boot/dts/amlogic/meson6_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_skt.dtd
@@ -300,11 +300,22 @@
 	
 	};
 	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		reg = <0xc8100500 0x1d>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+	
 	i2c@c1108500{ /*I2C-A*/
 		compatible = "amlogic,aml_i2c";
 		dev_name = "i2c-A";
 		reg = <0xc1108500 0x20>;
-		device_id = <0>;
+		device_id = <1>;
 		pinctrl-names="default";
 		pinctrl-0=<&a_i2c_master>;
 		#address-cells = <1>;
@@ -315,7 +326,7 @@
 		compatible = "amlogic,aml_i2c";
 		dev_name = "i2c-B";
 		reg = <0xc11087c0 0x20>;
-		device_id = <1>;
+		device_id = <2>;
 		pinctrl-names="default";
 		pinctrl-0=<&b_i2c_master>;
 		#address-cells = <1>;
@@ -323,25 +334,32 @@
 
 	};
 	
-	i2c@c8100500{ /*I2C-AO*/
-		compatible = "amlogic,aml_i2c";
-		dev_name = "i2c-AO";
-		reg = <0xc8100500 0x1d>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-		device_id = <2>;
-		pinctrl-names="default";
-		pinctrl-0=<&ao_i2c_master>;
-	};
-	
 	amhdmitx{
 		compatible = "amlogic,amhdmitx";
 		dev_name = "amhdmitx";
+		vend-data = <&vend_data>;
+		pwr-ctrl = <&pwr_ctrl>;
+		
 		phy-size = <3>;
 		phy-data = <27  0x16  0x30    /* 480i/p 576i/p */
 				 74  0x16  0x40    /* 720p 1080i */
 				 148  0x16  0x40   /* 1080p */
 				>;
+		
+    vend_data: vend_data{
+            vendor_name = "Amlogic";           /* Max Chars: 8     */
+            vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+            product_desc = "MX MBox G18Ref";        /* Max Chars: 16    */
+            cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
+    };
+    pwr_ctrl: pwr_ctrl{
+            pwr_5v_on = "cpu","GPIOD_5","H";
+            pwr_5v_off = "cpu","GPIOD_5","L";
+            pwr_3v3_on = "";
+            pwr_3v3_off = "";
+            pwr_hpll_vdd_on = "";
+            pwr_hpll_vdd_off = "";
+    };
 	};
 	
 	mesonvout{
diff --git a/arch/arm/configs/meson6_defconfig b/arch/arm/configs/meson6_defconfig
index ffa4839d5f96..b613a6d54581 100644
--- a/arch/arm/configs/meson6_defconfig
+++ b/arch/arm/configs/meson6_defconfig
@@ -153,6 +153,7 @@ CONFIG_RFKILL=y
 CONFIG_RFKILL_INPUT=y
 CONFIG_EARLY_INIT=y
 # CONFIG_AML_RTC is not set
+CONFIG_I2C_AML=y
 # CONFIG_MESON_INPUT_REMOTE is not set
 # CONFIG_MESON_NEW_INPUT_REMOTE is not set
 # CONFIG_MESON_INPUT_KEYBOARD is not set
@@ -195,8 +196,6 @@ CONFIG_INPUT_EVDEV=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_UINPUT=y
 CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
 # CONFIG_HID_GENERIC is not set
 # CONFIG_USB_SUPPORT is not set
 CONFIG_SWITCH=y
diff --git a/drivers/amlogic/hdmi/hdmi_tx/aml.dtd b/drivers/amlogic/hdmi/hdmi_tx/aml.dtd
index 8f7f551c52b1..30182fe01704 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/aml.dtd
+++ b/drivers/amlogic/hdmi/hdmi_tx/aml.dtd
@@ -7,8 +7,15 @@
 		compatible = "amlogic,amhdmitx";
 		dev_name = "amhdmitx";
 		status = "ok";
-        vend-data = <&vend_data>;
-        pwr-ctrl = <&pwr_ctrl>;
+		vend-data = <&vend_data>;
+		pwr-ctrl = <&pwr_ctrl>;
+#ifdef CONFIG_ARCH_MESON6
+		phy-size = <3>;
+		phy-data = <27  0x16  0x30    /* 480i/p 576i/p */
+				 74  0x16  0x40    /* 720p 1080i */
+				 148  0x16  0x40   /* 1080p */
+				>;
+#endif        
         
 //$$ MATCH "HDMI_vend-data_match" = <&vend_data>
 //$$ L2 PROP_STR = "vendor_name"
diff --git a/drivers/amlogic/i2c/aml.dtd b/drivers/amlogic/i2c/aml.dtd
index ce2ed2790d08..c26a45ee7b48 100755
--- a/drivers/amlogic/i2c/aml.dtd
+++ b/drivers/amlogic/i2c/aml.dtd
@@ -49,7 +49,7 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
  	};
-
+#ifdef CONFIG_ARCH_MESON8
 //$$ DEVICE="I2C_C"
 //$$ L2 PROP_STR = "status"
 //$$ L3 PROP_U32 2="reg"
@@ -83,4 +83,5 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 	};
+#endif
 #endif
\ No newline at end of file
diff --git a/drivers/amlogic/i2c/aml_i2c.c b/drivers/amlogic/i2c/aml_i2c.c
index 7a94817dcb27..1092316aba40 100755
--- a/drivers/amlogic/i2c/aml_i2c.c
+++ b/drivers/amlogic/i2c/aml_i2c.c
@@ -95,6 +95,7 @@ static void aml_i2c_set_platform_data(struct aml_i2c *i2c,
 	i2c->wait_xfer_interval = plat->wait_xfer_interval;
 	i2c->mode = plat->use_pio & 3;
 	i2c->irq = plat->use_pio >> 2;
+	i2c->master_no = plat->master_no;
 
 	if(IS_ERR(plat->master_state_name)){
 		printk("error: no master_state_name");
@@ -713,7 +714,7 @@ static ssize_t test_slave_device(struct class *class,
     }
     
     i = sscanf(buf, "%d%x%d%d%d%x%x%x%x", &bus_num, &slave_addr, &speed, &wnum, &rnum, 
-      &wbuf[0], &wbuf[1], &wbuf[2], &wbuf[3]);
+     (unsigned int *)&wbuf[0], (unsigned int *)&wbuf[1], (unsigned int *)&wbuf[2], (unsigned int *)&wbuf[3]);
     restart = !!(rnum & 0x80);
     rnum &= 0x7f;
     printk("bus_num=%d, slave_addr=%x, speed=%d, wnum=%d, rnum=%d\n",
@@ -843,10 +844,10 @@ static inline struct aml_i2c_platform   *aml_get_driver_data(
 	if (pdev->dev.of_node) {
 		const struct of_device_id *match;
 		match = of_match_node(meson6_i2c_dt_match, pdev->dev.of_node);
-		return (struct aml_uart_platform *)match->data;
+		return (struct aml_i2c_platform *)match->data;
 	}
 #endif
-	return (struct aml_uart_platform *)
+	return (struct aml_i2c_platform *)
 			platform_get_device_id(pdev)->driver_data;
 }
 
@@ -854,52 +855,43 @@ static inline struct aml_i2c_platform   *aml_get_driver_data(
 
 static int aml_i2c_probe(struct platform_device *pdev)
 {
-    int ret;
-#ifdef CONFIG_OF
+	int ret;
 	struct aml_i2c_platform *plat;
 	int device_id=-1;
-#else
-    struct aml_i2c_platform *plat = (struct aml_i2c_platform *)(pdev->dev.platform_data);
-#endif
-//    struct resource *res;
-    resource_size_t *res_start;
-    struct aml_i2c *i2c = kzalloc(sizeof(struct aml_i2c), GFP_KERNEL);
+//    struct aml_i2c_platform *plat = (struct aml_i2c_platform *)(pdev->dev.platform_data);
 
-    printk("%s : %s\n", __FILE__, __FUNCTION__);
+	resource_size_t *res_start;
+	struct aml_i2c *i2c = kzalloc(sizeof(struct aml_i2c), GFP_KERNEL);
 
-#ifdef CONFIG_OF
-	//plat = aml_get_driver_data(pdev);
-	if (pdev->dev.of_node) {
-		ret = of_property_read_u32(pdev->dev.of_node,"device_id",&device_id);
-		if(ret){
+	printk("%s : %s\n", __FILE__, __FUNCTION__);
+
+	if (!pdev->dev.of_node) {
+			dev_err(&pdev->dev, "no platform data\n");
+			return -EINVAL;
+	}
+	
+	ret = of_property_read_u32(pdev->dev.of_node,"device_id",&device_id);
+	if(ret){
 			printk("don't find to match device_id\n");
 			return -1;
-		}
-		
-		pdev->id = device_id;
-		//if(device_id<sizeof(aml_i2c_properties_config)/sizeof(aml_i2c_properties_config[0])){
-		if(device_id<AML_I2C_DEVICE_NUM){
-			plat = (struct aml_i2c_platform*)aml_i2c_properties_config[device_id].drv_data;
-		}
-		ret=of_property_read_string(pdev->dev.of_node,"pinctrl-names",&plat->master_state_name);
-		printk("plat->state_name:%s\n",plat->master_state_name);
-		
 	}
-#endif
+		
+	pdev->id = device_id;
+	plat = (struct aml_i2c_platform*)aml_i2c_properties_config[device_id].drv_data;
+
+	ret=of_property_read_string(pdev->dev.of_node,"pinctrl-names",&plat->master_state_name);
+	printk("plat->state_name:%s\n",plat->master_state_name);
 	
-    i2c->ops = &aml_i2c_m1_ops;
-    i2c->dev=&pdev->dev;
+  i2c->ops = &aml_i2c_m1_ops;
+  i2c->dev=&pdev->dev;
 
-    /*master a or master b*/
-    i2c->master_no = plat->master_no;
-//    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-    res_start = of_iomap(pdev->dev.of_node,0);
-    i2c->master_regs = (struct aml_i2c_reg_master __iomem*)(res_start);
-    printk("master_no = %d, maseter_regs=%p\n", i2c->master_no, i2c->master_regs);
+  res_start = of_iomap(pdev->dev.of_node,0);
+	i2c->master_regs = (struct aml_i2c_reg_master __iomem*)(res_start);
 
-    BUG_ON(!i2c->master_regs);
-    BUG_ON(!plat);
-    aml_i2c_set_platform_data(i2c, plat);
+  BUG_ON(!i2c->master_regs);
+  BUG_ON(!plat);
+	aml_i2c_set_platform_data(i2c, plat);
+	printk("master_no = %d, maseter_regs=%p\n", i2c->master_no, i2c->master_regs);
 
     /*lock init*/
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON3
@@ -919,55 +911,53 @@ static int aml_i2c_probe(struct platform_device *pdev)
     mutex_init(i2c->lock);
 #endif
 
-    /*setup adapter*/
-    i2c->adap.nr = pdev->id==-1? 0: pdev->id;
-    i2c->adap.class = I2C_CLASS_HWMON;
-    i2c->adap.algo = &aml_i2c_algorithm;
-    i2c->adap.retries = 2;
-    i2c->adap.timeout = 5;
-
-	if(pdev->dev.of_node){
-		i2c->adap.dev.of_node = pdev->dev.of_node;
-	}
-
-    //memset(i2c->adap.name, 0 , 48);
-    sprintf(i2c->adap.name, ADAPTER_NAME"%d", i2c->adap.nr);
-    i2c_set_adapdata(&i2c->adap, i2c);
-    ret = i2c_add_numbered_adapter(&i2c->adap);
-    if (ret < 0)
-    {
-            dev_err(&pdev->dev, "Adapter %s registration failed\n",
-                i2c->adap.name);
-            kzfree(i2c);
-            return -1;
-    }
-    dev_info(&pdev->dev, "add adapter %s(%p)\n", i2c->adap.name, &i2c->adap);
-    of_i2c_register_devices(&i2c->adap);
-
-    /*need 2 different speed in 1 adapter, add a virtual one*/
-    if(plat->master_i2c_speed2){
-        i2c->master_i2c_speed2 = plat->master_i2c_speed2;
-        /*setup adapter 2*/
-        i2c->adap2.nr = i2c->adap.nr+1;
-        i2c->adap2.class = I2C_CLASS_HWMON;
-        i2c->adap2.algo = &aml_i2c_algorithm_s2;
-        i2c->adap2.retries = 2;
-        i2c->adap2.timeout = 5;
-        //memset(i2c->adap.name, 0 , 48);
-        sprintf(i2c->adap2.name, ADAPTER_NAME"%d", i2c->adap2.nr);
-        i2c_set_adapdata(&i2c->adap2, i2c);
-        ret = i2c_add_numbered_adapter(&i2c->adap2);
-        if (ret < 0)
-        {
-            dev_err(&pdev->dev, "Adapter %s registration failed\n",
-            i2c->adap2.name);
-            i2c_del_adapter(&i2c->adap);
-            kzfree(i2c);
-            return -1;
-        }
-        dev_info(&pdev->dev, "add adapter %s\n", i2c->adap2.name);
-    }
-    dev_info(&pdev->dev, "aml i2c bus driver.\n");
+  /*setup adapter*/
+  i2c->adap.nr = pdev->id==-1? 0: pdev->id;
+  i2c->adap.class = I2C_CLASS_HWMON;
+  i2c->adap.algo = &aml_i2c_algorithm;
+  i2c->adap.retries = 2;
+  i2c->adap.timeout = 5;
+
+	i2c->adap.dev.of_node = pdev->dev.of_node;
+
+  //memset(i2c->adap.name, 0 , 48);
+  sprintf(i2c->adap.name, ADAPTER_NAME"%d", i2c->adap.nr);
+  i2c_set_adapdata(&i2c->adap, i2c);
+  ret = i2c_add_numbered_adapter(&i2c->adap);
+  if (ret < 0)
+  {
+          dev_err(&pdev->dev, "Adapter %s registration failed\n",
+              i2c->adap.name);
+          kzfree(i2c);
+          return -1;
+  }
+  dev_info(&pdev->dev, "add adapter %s(%p)\n", i2c->adap.name, &i2c->adap);
+  of_i2c_register_devices(&i2c->adap);
+
+  /*need 2 different speed in 1 adapter, add a virtual one*/
+  if(plat->master_i2c_speed2){
+      i2c->master_i2c_speed2 = plat->master_i2c_speed2;
+      /*setup adapter 2*/
+      i2c->adap2.nr = i2c->adap.nr+1;
+      i2c->adap2.class = I2C_CLASS_HWMON;
+      i2c->adap2.algo = &aml_i2c_algorithm_s2;
+      i2c->adap2.retries = 2;
+      i2c->adap2.timeout = 5;
+      //memset(i2c->adap.name, 0 , 48);
+      sprintf(i2c->adap2.name, ADAPTER_NAME"%d", i2c->adap2.nr);
+      i2c_set_adapdata(&i2c->adap2, i2c);
+      ret = i2c_add_numbered_adapter(&i2c->adap2);
+      if (ret < 0)
+      {
+          dev_err(&pdev->dev, "Adapter %s registration failed\n",
+          i2c->adap2.name);
+          i2c_del_adapter(&i2c->adap);
+          kzfree(i2c);
+          return -1;
+      }
+      dev_info(&pdev->dev, "add adapter %s\n", i2c->adap2.name);
+  }
+  dev_info(&pdev->dev, "aml i2c bus driver.\n");
 
 
 
@@ -1023,10 +1013,10 @@ static int aml_i2c_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_OF
 
-static bool pinmux_dummy_share(bool select)
-{
-    return select;
-}
+//static bool pinmux_dummy_share(bool select)
+//{
+//    return select;
+//}
 
 static struct aml_i2c_platform aml_i2c_driver_data_ao = {
     .wait_count         = 50000,
@@ -1045,7 +1035,7 @@ static struct aml_i2c_platform aml_i2c_driver_data_a = {
     .wait_read_interval  = 5,
     .wait_xfer_interval   = 5,
     .master_no          = AML_I2C_MASTER_A,
-    .use_pio            = (INT_I2C_MASTER0<<2)|I2C_INTERRUPT_MODE,
+    .use_pio            = 0,//(INT_I2C_MASTER0<<2)|I2C_INTERRUPT_MODE,
     .master_i2c_speed   = AML_I2C_SPPED_300K,
     .master_state_name  = NULL,
 };
@@ -1056,7 +1046,7 @@ static struct aml_i2c_platform aml_i2c_driver_data_b = {
     .wait_read_interval = 5,
     .wait_xfer_interval = 5,
     .master_no          = AML_I2C_MASTER_B,
-    .use_pio            = (INT_I2C_MASTER1<<2)|I2C_INTERRUPT_MODE,
+    .use_pio            = 0,//(INT_I2C_MASTER1<<2)|I2C_INTERRUPT_MODE,
     .master_i2c_speed   = AML_I2C_SPPED_300K,
     .master_state_name  = NULL,
 };
@@ -1067,7 +1057,7 @@ static struct aml_i2c_platform aml_i2c_driver_data_c = {
     .wait_read_interval = 5,
     .wait_xfer_interval = 5,
     .master_no          = AML_I2C_MASTER_C,
-    .use_pio            = (INT_I2C_MASTER2<<2)|I2C_INTERRUPT_MODE,
+    .use_pio            = 0,//(INT_I2C_MASTER2<<2)|I2C_INTERRUPT_MODE,
     .master_i2c_speed   = AML_I2C_SPPED_300K,
     .master_state_name  = NULL,
 };
@@ -1078,7 +1068,7 @@ static struct aml_i2c_platform aml_i2c_driver_data_d = {
     .wait_read_interval = 5,
     .wait_xfer_interval = 5,
     .master_no          = AML_I2C_MASTER_D,
-    .use_pio            = (INT_I2C_MASTER3<<2)|I2C_INTERRUPT_MODE,
+    .use_pio            = 0,//(INT_I2C_MASTER3<<2)|I2C_INTERRUPT_MODE,
     .master_i2c_speed   = AML_I2C_SPPED_300K,
     .master_state_name  = NULL,
 };
diff --git a/drivers/amlogic/i2c/aml_i2c.h b/drivers/amlogic/i2c/aml_i2c.h
index 8b7a772ee718..c87f72459647 100755
--- a/drivers/amlogic/i2c/aml_i2c.h
+++ b/drivers/amlogic/i2c/aml_i2c.h
@@ -224,7 +224,7 @@ struct aml_i2c {
 	pinmux_set_t	master_b_pinmux;
 	struct device *dev;
 	struct pinctrl *p;
-	char *master_state_name;
+	const char *master_state_name;
 };
 
 struct aml_i2c_ops {
diff --git a/include/linux/i2c-aml.h b/include/linux/i2c-aml.h
index 221c7f09dff6..27091d83063b 100755
--- a/include/linux/i2c-aml.h
+++ b/include/linux/i2c-aml.h
@@ -100,7 +100,7 @@ struct aml_i2c_platform{
 	pinmux_set_t  master_pinmux;
 	pinmux_set_t  master_a_pinmux;
 	pinmux_set_t  master_b_pinmux;
-	char *master_state_name;
+	const char *master_state_name;
 };
 
 /**************i2c software gpio***************/
diff --git a/mk_m6.sh b/mk_m6.sh
new file mode 100755
index 000000000000..82c78b806466
--- /dev/null
+++ b/mk_m6.sh
@@ -0,0 +1,20 @@
+#! /bin/bash
+
+#make UIMAGE_COMPRESSION=none uImage -j
+make uImage -j
+#make modules
+
+make meson6_skt.dtd
+make meson6_skt.dtb
+
+#cd ../root/g18
+#find .| cpio -o -H newc | gzip -9 > ../ramdisk.img
+
+#rootfs.cpio -- original buildroot rootfs, busybox
+#m8rootfs.cpio -- build from buildroot
+ROOTFS="rootfs.cpio"
+
+#cd ..
+./mkbootimg --kernel ./arch/arm/boot/uImage --ramdisk ./${ROOTFS} --second ./arch/arm/boot/dts/amlogic/meson6_skt.dtb --output ./m6boot.img
+ls -l ./m6boot.img
+echo "m6boot.img done"
diff --git a/scripts/amlogic/aml_dtd.sh b/scripts/amlogic/aml_dtd.sh
index d28aa66dac77..4f7975a052df 100755
--- a/scripts/amlogic/aml_dtd.sh
+++ b/scripts/amlogic/aml_dtd.sh
@@ -5,8 +5,8 @@
 # Written by Cai Yun 2013-07-04
 
 #debug
-print=echo
-#print=test  
+#print=echo
+print=test  
 
 TMP_DTD="./arch/arm/boot/meson.dtd"
 touch "$TMP_DTD"
@@ -15,72 +15,62 @@ copy_fragment(){
     if [ -z "$val_1" ]; then          # no "#ifdef" or "#ifndef", is "#else" ?
         local val_2=`sed -n -e "s/^#else/else/p" "$TMP_FILE"`
         if [ -n "$val_2" ]; then  # key word--"#else"
-            noelse=1
-            if [ "$nodef" -eq 0 ]; then   # ifdef config
-                nodef=1
-                if [ "$invalidconfig" -eq 1 ] ; then # ifdef config is not define
-                    start_copy=$[$start_copy+1]                             # start copy
-                fi
-            fi
-            if [ "$nodef" -eq 1 ] ; then  # ifndef config
-                nodef=0
-                if [ "$invalidconfig" -eq 0 ]; then # ifndef config is define
-                    start_copy=$[$start_copy+1]                             # start copy
-                fi
-            fi
+        	$print "key word--#else"
+           noelse=1
         else  # no key word--"#else"
             val_2=`sed -n -e 's/^#endif/END_CONFIG/p' "$TMP_FILE"`
             if [ -z "$val_2" ]; then  # no key word--"#endif"
-                if [ "$invalidconfig" -eq "$nodef" ] ; then
+                total=$[$[$invalidconfig+$nodef+$noelse]%2]
+                $print "total is $total"
+                if [ $total -eq 0 ]; then
                     local val_3=`sed -n -e 's/^sub_file.//p' "$TMP_FILE"`
                     if [ -z "$val_3" ]; then
-
                         local val_4=`sed -n -e '/^#/p' "$TMP_FILE"`
                         if [ -z "$val_4" ]; then
                             cat "$TMP_FILE" >> "$TMP_DTD"
+                            #cat "$TMP_FILE"
+                            $print "no #ifdef #ifndef #else"
                         fi
                     fi
+                    
                     if [ -n "$val_3" ]; then
                         if [[ IFS != $saveIFS ]] ; then
                             IFS=$saveIFS
                         fi
                         process_file "${path}$val_3"
                     fi
+                
                 fi
             fi
             if [ -n "$val_2" ] ; then    # key word--"#endif"
-                 if ([ "$invalidconfig" -ne 1 ] || [ "$noelse" -ne 0 ]); then
-                    start_copy=$[$start_copy-1]
-                 fi
+            $print "key word-- #endif"
                     invalidconfig=0
+                    nodef=0
                     noelse=0
             fi
         fi
     fi       # no "#ifdef" or "#ifndef"
     
     if [ -n "$val_1" ]; then          # key word--"#ifdef" or "#ifndef", there is a CONFIG
+    $print "key word--#ifdef or #ifndef, there is a CONFIG: $val_1"
         local CONFIG=`"$path"/scripts/config -s  "$1"`
         if [[ "$CONFIG" = 'y' ]] || [[ "$CONFIG" = 'm' ]] ; then
+        		$print "CONFIG is y or m"
             invalidconfig=0
-            if [ "$nodef" -eq 0 ]; then         # ifdef config is y  or m
-                start_copy=$[$start_copy+1]
-            fi
         else
+        		$print "CONFIG is not define"
             invalidconfig=1
-            if [ "$nodef" -eq 1 ]; then         # ifdef config is not define
-                start_copy=$[$start_copy+1]
-            fi
         fi
     fi
 }
 
 
 process_file(){
-    $print "process file $1 start"
-    local start_copy=0
+    echo "process file $1 start"
     local invalidconfig=0
     local nodef=0
     local noelse=0
+    local total=0
 
     line=`sed -n '$=' $1`
 
@@ -104,7 +94,7 @@ process_file(){
         IFS=$saveIFS
     fi
     
-    $print "process file $1 end"
+    echo "process file $1 end"
     $print ""
 }   
     
-- 
2.19.0

