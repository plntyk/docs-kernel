From 424da847242d8699c861b61f3cd1a9a931405a0e Mon Sep 17 00:00:00 2001
From: "tao.zeng" <tao.zeng@amlogic.com>
Date: Tue, 10 Dec 2013 19:06:24 +0800
Subject: [PATCH 2869/5965] PD #00002: Merage PMU driver to kernel 3.10

include AXP202, AML1212, RN5T618, all can work OK now
---
 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd   |    6 +-
 arch/arm/configs/meson6_defconfig             |    7 +
 drivers/amlogic/power/Kconfig                 |    2 +-
 drivers/amlogic/power/Makefile                |    4 +-
 drivers/amlogic/power/aml_pmu/Kconfig         |   20 +
 drivers/amlogic/power/aml_pmu/Makefile        |    3 +
 drivers/amlogic/power/aml_pmu/aml1212-sply.c  | 1896 +++++++++++++++++
 drivers/amlogic/power/aml_pmu/aml_pmu.c       |  214 ++
 drivers/amlogic/power/aml_pmu_algorithm_lib.z |  Bin 117456 -> 114319 bytes
 drivers/amlogic/power/aml_pmu_of_common.c     |    4 +-
 drivers/amlogic/power/axp_power/Kconfig       |    1 +
 drivers/amlogic/power/axp_power/Makefile      |   21 -
 drivers/amlogic/power/axp_power/axp-mfd.c     |   25 +-
 drivers/amlogic/power/axp_power/axp-sply.h    |   69 +-
 drivers/amlogic/power/axp_power/axp20-gpio.c  |    2 -
 drivers/amlogic/power/axp_power/axp20-sply.c  | 1109 +++++-----
 drivers/amlogic/power/ricoh/ricoh_pmu.c       |   22 +-
 drivers/amlogic/power/ricoh/rn5t618-rw.c      |    2 +-
 drivers/amlogic/power/ricoh/rn5t618-sply.c    |    6 +-
 include/linux/amlogic/aml_pmu.h               |  151 ++
 include/linux/amlogic/battery_parameter.h     |    4 +
 21 files changed, 2900 insertions(+), 668 deletions(-)
 mode change 100644 => 100755 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
 create mode 100755 drivers/amlogic/power/aml_pmu/Kconfig
 create mode 100755 drivers/amlogic/power/aml_pmu/Makefile
 create mode 100755 drivers/amlogic/power/aml_pmu/aml1212-sply.c
 create mode 100755 drivers/amlogic/power/aml_pmu/aml_pmu.c
 mode change 100644 => 100755 drivers/amlogic/power/aml_pmu_algorithm_lib.z
 mode change 100644 => 100755 drivers/amlogic/power/axp_power/Kconfig
 mode change 100644 => 100755 drivers/amlogic/power/axp_power/Makefile
 mode change 100644 => 100755 drivers/amlogic/power/axp_power/axp-sply.h
 mode change 100644 => 100755 drivers/amlogic/power/axp_power/axp20-gpio.c
 create mode 100755 include/linux/amlogic/aml_pmu.h
 mode change 100644 => 100755 include/linux/amlogic/battery_parameter.h

diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
old mode 100644
new mode 100755
index 31c503864899..59294f465b7b
--- a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
@@ -312,13 +312,14 @@
             status = "okay";                                    /* status of pmu, only one should be OK */
         };
         aml1212{                                                /* PMU for AML1212, see comment above   */
-            compatible = "aml_pmu";
-            sub_type = "aml1212";
+            compatible = "amlogic_pmu";
+            sub_type = "aml1212-supplyer";
             i2c_bus = "i2c_bus_ao";
             reg = <0x35>;
             soft_limit_to99 = <0>;
             ddr_voltage   = <1500000>;
             vddao_voltage = <1200000>;
+            vbus_dcin_short_connect = <0>;
             board_battery = <&battery_parameter>;
             status = "disable";
         };
@@ -331,6 +332,7 @@
             ddr_voltage   = <1500000>;
             vddao_voltage = <1200000>;
             board_battery = <&battery_parameter>;
+            vbus_dcin_short_connect = <0>;
             status = "disable";
         };
     };
diff --git a/arch/arm/configs/meson6_defconfig b/arch/arm/configs/meson6_defconfig
index 220a0dd0a80f..b0caf2c43c7d 100755
--- a/arch/arm/configs/meson6_defconfig
+++ b/arch/arm/configs/meson6_defconfig
@@ -237,3 +237,10 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
 CONFIG_AVERAGE=y
+CONFIG_AMLOGIC_BOARD_HAS_PMU=y
+CONFIG_AW_AXP=y
+CONFIG_AW_AXP20=y
+CONFIG_AML_PMU=y
+CONFIG_AML1212=y
+CONFIG_RICOH_PMU=y
+CONFIG_RN5T618=y
diff --git a/drivers/amlogic/power/Kconfig b/drivers/amlogic/power/Kconfig
index c11b2aeec253..f80da7e61336 100755
--- a/drivers/amlogic/power/Kconfig
+++ b/drivers/amlogic/power/Kconfig
@@ -72,6 +72,6 @@ config AML_DVFS
 #source "drivers/amlogic/power/act8xxx_pmu/Kconfig"
 source "drivers/amlogic/power/axp_power/Kconfig"
 source "drivers/amlogic/power/meson_cs_dcdc_regulator/Kconfig"
-#source "drivers/amlogic/power/aml_pmu/Kconfig"
+source "drivers/amlogic/power/aml_pmu/Kconfig"
 source "drivers/amlogic/power/ricoh/Kconfig"
 endmenu
diff --git a/drivers/amlogic/power/Makefile b/drivers/amlogic/power/Makefile
index d315886636e2..ba25ff06be89 100755
--- a/drivers/amlogic/power/Makefile
+++ b/drivers/amlogic/power/Makefile
@@ -13,7 +13,7 @@ ifneq ($(KBUILD_SRC),)
 TOP_KBUILD_SRC := $(KBUILD_SRC)/
 endif
 
-MAKE_FOR_LIB := n
+MAKE_FOR_LIB := y
 ifeq ($(MAKE_FOR_LIB), n)
 $(obj)/aml_pmu_algorithm_lib:
 	@cp $(TOP_KBUILD_SRC)drivers/amlogic/power/aml_pmu_algorithm_lib.z \
@@ -33,7 +33,7 @@ endif
 #obj-$(CONFIG_PMU_ACT8xxx)                  += act8xxx_pmu/
 obj-$(CONFIG_AW_AXP)                        += axp_power/
 #obj-$(CONFIG_CW2015)                       += cw2015/cw2015_gasgauge.o
-#obj-$(CONFIG_AML_PMU)                      += aml_pmu/
+obj-$(CONFIG_AML_PMU)                       += aml_pmu/
 obj-$(CONFIG_RICOH_PMU)                     += ricoh/
 obj-$(CONFIG_UBOOT_BATTERY_PARAMETERS)      += battery_parameter.o
 obj-$(CONFIG_AMLOGIC_PMU_OF)                += aml_pmu_of_common.o 
diff --git a/drivers/amlogic/power/aml_pmu/Kconfig b/drivers/amlogic/power/aml_pmu/Kconfig
new file mode 100755
index 000000000000..596504b414d1
--- /dev/null
+++ b/drivers/amlogic/power/aml_pmu/Kconfig
@@ -0,0 +1,20 @@
+menuconfig AML_PMU
+    bool    "Amlogic PMU drivers"
+    select  I2C
+    select  REGULATOR
+    default n
+    ---help---
+        say yes if you want add Amlogic power management unit support
+if AML_PMU
+choice 
+    prompt "AML PMU type"
+    default AML1212
+config AML1212
+    bool "AML1212 driver"
+    select AML_PMU_ALGORITHM_SUPPORT
+    ---help---
+        drivers for AML1212
+
+endchoice
+
+endif #AML_PMU
diff --git a/drivers/amlogic/power/aml_pmu/Makefile b/drivers/amlogic/power/aml_pmu/Makefile
new file mode 100755
index 000000000000..8d5adcd935bb
--- /dev/null
+++ b/drivers/amlogic/power/aml_pmu/Makefile
@@ -0,0 +1,3 @@
+obj-y += aml_pmu.o
+obj-$(CONFIG_AML1212) += aml1212-sply.o
+
diff --git a/drivers/amlogic/power/aml_pmu/aml1212-sply.c b/drivers/amlogic/power/aml_pmu/aml1212-sply.c
new file mode 100755
index 000000000000..dfee1a212f4d
--- /dev/null
+++ b/drivers/amlogic/power/aml_pmu/aml1212-sply.c
@@ -0,0 +1,1896 @@
+/*
+ * Battery charger driver for Amlogic PMU AML1212
+ *
+ * Copyright (C) 2012 Amlogic Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/utsname.h>
+
+#include <linux/i2c.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <mach/am_regs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/aml_pmu.h>
+#include <linux/amlogic/battery_parameter.h>
+#include <linux/amlogic/aml_rtc.h>
+#include <mach/irqs.h> 
+#include <mach/usbclock.h>
+#ifdef CONFIG_RESET_TO_SYSTEM
+#include <linux/reboot.h>
+#include <linux/notifier.h>
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend aml_pmu_early_suspend;
+int early_suspend_flag = 0;
+#endif
+
+#define MAX_BUF         100
+#define CHECK_DRIVER()      \
+    if (!g1212_supply) {    \
+        AML_PMU_DBG("driver is not ready right now, wait...\n");   \
+        dump_stack();       \
+        return -ENODEV;     \
+    }
+
+#define CHECK_REGISTER_TEST     1
+#if CHECK_REGISTER_TEST
+int register_wrong_flag = 0;
+#endif
+
+static struct amlogic_pmu_init  *aml1212_init      = NULL;
+static struct battery_parameter *aml_pmu_battery   = NULL;
+static struct input_dev         *aml_pmu_power_key = NULL;
+
+int      re_charge_cnt  = 0;
+int      power_flag     = 0;
+int      pmu_version    = 0;
+
+struct aml1212_supply *g1212_supply  = NULL;
+EXPORT_SYMBOL_GPL(g1212_supply);
+
+int aml_pmu_write(int add, uint8_t val)
+{
+    int ret;
+    uint8_t buf[3] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1212_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g1212_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    buf[2] = val & 0xff;
+    ret = i2c_transfer(pdev->adapter, msg, 1);
+    if (ret < 0) {
+        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_write);
+
+int aml_pmu_write16(int add, uint16_t val)
+{
+    int ret;
+    uint8_t buf[4] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1212_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g1212_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    buf[2] = val & 0xff;
+    buf[3] = (val >> 8) & 0xff;
+    ret = i2c_transfer(pdev->adapter, msg, 1);
+    if (ret < 0) {
+        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_write16);
+
+int aml_pmu_writes(int add, uint8_t *buff, int len)
+{
+    int ret;
+    uint8_t buf[MAX_BUF] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1212_ADDR,
+            .flags = 0,
+            .len   = len + 2,
+            .buf   = buf,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g1212_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    memcpy(buf + 2, buff, len > MAX_BUF ? MAX_BUF : len);
+    ret = i2c_transfer(pdev->adapter, msg, 1);
+    if (ret < 0) {
+        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_writes);
+
+int aml_pmu_read(int add, uint8_t *val)
+{
+    int ret;
+    uint8_t buf[2] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1212_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },
+        {
+            .addr  = AML1212_ADDR,
+            .flags = I2C_M_RD,
+            .len   = 1,
+            .buf   = val,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g1212_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    ret = i2c_transfer(pdev->adapter, msg, 2);
+    if (ret < 0) {
+        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_read);
+
+int aml_pmu_read16(int add, uint16_t *val)
+{
+    int ret;
+    uint8_t buf[2] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1212_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },
+        {
+            .addr  = AML1212_ADDR,
+            .flags = I2C_M_RD,
+            .len   = 2, 
+            .buf   = (uint8_t *)val,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g1212_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    ret = i2c_transfer(pdev->adapter, msg, 2);
+    if (ret < 0) {
+        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_read16);
+
+int aml_pmu_reads(int add, uint8_t *buff, int len)
+{
+    int ret;
+    uint8_t buf[2] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1212_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },
+        {
+            .addr  = AML1212_ADDR,
+            .flags = I2C_M_RD,
+            .len   = len,
+            .buf   = buff,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g1212_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    ret = i2c_transfer(pdev->adapter, msg, 2);
+    if (ret < 0) {
+        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_reads);
+
+int aml_pmu_set_bits(int addr, uint8_t bits, uint8_t mask)
+{
+    uint8_t val; 
+    int ret; 
+ 
+    ret = aml_pmu_read(addr, &val); 
+    if (ret) { 
+        return ret; 
+    } 
+    val &= ~(mask); 
+    val |=  (bits & mask); 
+    return aml_pmu_write(addr, val); 
+} 
+EXPORT_SYMBOL_GPL(aml_pmu_set_bits); 
+
+int aml_pmu_set_dcin(int enable)
+{
+    uint8_t val;
+
+    aml_pmu_read(AML1212_CHG_CTRL4, &val);
+    if (enable) {
+        val &= ~0x10;    
+    } else {
+        val |= 0x10;    
+    }    
+    return aml_pmu_write(AML1212_CHG_CTRL4, val);
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_dcin);
+
+int aml_pmu_set_gpio(int pin, int val)
+{
+    uint32_t data;
+
+    if (pin <= 0 || pin > 4 || val > 1 || val < 0) {
+        AML_PMU_DBG("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
+        return -EINVAL;
+    }
+    data = (1 << (pin + 11));
+    if (val) {
+        return aml_pmu_write16(AML1212_PWR_DN_SW_ENABLE,  data);
+    } else {
+        return aml_pmu_write16(AML1212_PWR_UP_SW_ENABLE, data);
+    }
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_gpio);
+
+int aml_pmu_get_gpio(int pin, int *val)
+{
+    int ret;
+    uint8_t data;
+
+    if (pin <= 0 || pin > 4 || !val) { 
+        AML_PMU_DBG("ERROR, invalid input value, pin = %d, val= %p\n", pin, val);
+        return -EINVAL;
+    }
+    ret = aml_pmu_read(AML1212_GPIO_INPUT_STATUS, &data);
+    if (ret) {                                                  // read failed
+        return ret;    
+    }
+    if (data & (1 << (pin - 1))) {
+        *val = 1;
+    } else {
+        *val = 0;    
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_get_gpio);
+
+int aml_pmu_get_voltage(void)
+{
+    uint8_t buf[2] = {};
+    int     result = 0;
+    int     tmp, i;
+
+    for (i = 0; i < 4; i++) {
+        aml_pmu_write(AML1212_SAR_SW_EN_FIELD, 0x04);
+        udelay(10);
+        aml_pmu_reads(AML1212_SAR_RD_VBAT_ACTIVE, buf, 2);
+        tmp = (((buf[1] & 0x0f) << 8) + buf[0]);
+        if (pmu_version == 0x02 || pmu_version == 0x01) {       // VERSION A & B
+            tmp = (tmp * 7200) / 2048; 
+        } else if (pmu_version == 0x03) {                       // VERSION D
+            tmp = (tmp * 4800) / 2048;
+        } else {
+            tmp = 0;    
+        }
+        result += tmp;
+    }
+    return result / 4;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_get_voltage);
+
+int aml_pmu_get_current(void)
+{
+    uint8_t  buf[2] = {};
+    uint32_t tmp, i;
+    int      result = 0;
+    int      sign_bit;
+
+    for (i = 0; i < 4; i++) {
+        aml_pmu_write(AML1212_SAR_SW_EN_FIELD, 0x40);
+        udelay(10);
+        aml_pmu_reads(AML1212_SAR_RD_IBAT_LAST, buf, 2);
+        tmp = ((buf[1] & 0x0f) << 8) + buf[0];
+        sign_bit = tmp & 0x800;
+        if (tmp & 0x800) {                                              // complement code
+            tmp = (tmp ^ 0xfff) + 1;
+        }
+        result += (tmp * 4000) / 2048;                                  // LSB of IBAT ADC is 1.95mA
+    }
+    result /= 4;
+    return result;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_get_current);
+
+static int aml1212_get_coulomb_acc(struct aml_charger *charger)
+{
+    uint8_t buf[4] = {};
+    int result;
+    int coulomb;
+
+    aml_pmu_write(AML1212_SAR_SW_EN_FIELD, 0x40);
+    aml_pmu_reads(AML1212_SAR_RD_IBAT_ACC, buf, 4);
+
+    result  = (buf[0] <<  0) |
+              (buf[1] <<  8) |
+              (buf[2] << 16) |
+              (buf[3] << 24);
+    coulomb = (result) / (3600 * 100);                              // convert to mAh
+    coulomb = (coulomb * 4000) / 2048;                              // LSB of current is 1.95mA
+    charger->charge_cc    = coulomb;
+    charger->discharge_cc = 0;
+    return 0;
+}
+
+int aml_pmu_get_ibat_cnt(void)
+{
+    uint8_t buf[4] = {};
+    uint32_t cnt = 0;
+    
+    aml_pmu_write(AML1212_SAR_SW_EN_FIELD, 0x40);
+    aml_pmu_reads(AML1212_SAR_RD_IBAT_CNT, buf, 4);
+
+    cnt = (buf[0] <<  0) | 
+          (buf[1] <<  8) |
+          (buf[2] << 16) |
+          (buf[3] << 24);
+    return cnt;
+}
+
+int aml_pmu_manual_measure_current(void)
+{
+    uint8_t buf[2] = {};
+    int result;
+    int tmp;
+
+    aml_pmu_write(0xA2, 0x09);                                      // MSR_SEL = 3
+    aml_pmu_write(0xA9, 0x0f);                                      // select proper ADC channel
+    aml_pmu_write(0xAA, 0xe0);
+    udelay(20);
+    aml_pmu_write(AML1212_SAR_SW_EN_FIELD, 0x08);
+    udelay(20);
+    aml_pmu_reads(AML1212_SAR_RD_MANUAL, buf, 2);
+    tmp = ((buf[1] & 0x0f)<< 8) | buf[0];
+    if (tmp & 0x800) {                                              // complement code
+        tmp = (tmp ^ 0xfff) + 1;
+    }
+    result = tmp * 4000 / 2048;
+    return result;
+}
+
+static unsigned int dcdc1_voltage_table[] = {                  // voltage table of DCDC1
+    2000, 1980, 1960, 1940, 1920, 1900, 1880, 1860, 
+    1840, 1820, 1800, 1780, 1760, 1740, 1720, 1700, 
+    1680, 1660, 1640, 1620, 1600, 1580, 1560, 1540, 
+    1520, 1500, 1480, 1460, 1440, 1420, 1400, 1380, 
+    1360, 1340, 1320, 1300, 1280, 1260, 1240, 1220, 
+    1200, 1180, 1160, 1140, 1120, 1100, 1080, 1060, 
+    1040, 1020, 1000,  980,  960,  940,  920,  900,  
+     880,  860,  840,  820,  800,  780,  760,  740
+};
+
+static unsigned int dcdc2_voltage_table[] = {                  // voltage table of DCDC2
+    2160, 2140, 2120, 2100, 2080, 2060, 2040, 2020,
+    2000, 1980, 1960, 1940, 1920, 1900, 1880, 1860, 
+    1840, 1820, 1800, 1780, 1760, 1740, 1720, 1700, 
+    1680, 1660, 1640, 1620, 1600, 1580, 1560, 1540, 
+    1520, 1500, 1480, 1460, 1440, 1420, 1400, 1380, 
+    1360, 1340, 1320, 1300, 1280, 1260, 1240, 1220, 
+    1200, 1180, 1160, 1140, 1120, 1100, 1080, 1060, 
+    1040, 1020, 1000,  980,  960,  940,  920,  900
+};
+
+int find_idx_by_voltage(int voltage, unsigned int *table)
+{
+    int i;
+
+    /*
+     * under this section divide(/ or %) can not be used, may cause exception
+     */
+    for (i = 0; i < 64; i++) {
+        if (voltage >= table[i]) {
+            break;    
+        }
+    }
+    if (voltage == table[i]) {
+        return i;    
+    }
+    return i - 1;
+}
+
+void aml_pmu_set_voltage(int dcdc, int voltage)
+{
+    int idx_to = 0xff;
+    int idx_cur;
+    unsigned char val;
+    unsigned char addr;
+    unsigned int *table;
+    
+    if (dcdc < 0 || dcdc > AML_PMU_DCDC2 || voltage > 2100 || voltage < 840) {
+        return ;                                                // current only support DCDC1&2 voltage adjust
+    }
+    if (dcdc == AML_PMU_DCDC1) {
+        addr  = 0x2f; 
+        table = dcdc1_voltage_table; 
+    } else if (dcdc == AML_PMU_DCDC2) {
+        addr  = 0x38;    
+        table = dcdc2_voltage_table; 
+    }
+    aml_pmu_read(addr, &val);
+    idx_cur = ((val & 0xfc) >> 2);
+    idx_to = find_idx_by_voltage(voltage, table);
+    AML_PMU_DBG("set idx from %x to %x\n", idx_cur, idx_to);
+    while (idx_cur != idx_to) {
+        if (idx_cur < idx_to) {                                 // adjust to target voltage step by step
+            idx_cur++;    
+        } else {
+            idx_cur--;
+        }
+        val &= ~0xfc;
+        val |= (idx_cur << 2);
+        aml_pmu_write(addr, val);
+        udelay(100);                                            // atleast delay 100uS
+    }
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_voltage);
+
+void aml_pmu_poweroff(void)
+{
+    uint8_t buf = (1 << 5);                                     // software goto OFF state
+
+#ifdef CONFIG_RESET_TO_SYSTEM
+    aml_pmu_write(0x00ff, 0x00);
+#endif
+    aml_pmu_write(0x0019, 0x10);                                // according Harry, cut usb output
+    aml_pmu_write16(0x0084, 0x0001);
+  //aml_pmu_write(AML1212_PIN_MUX4, 0x04);                      // according David Wang, for charge cannot stop
+    aml_pmu_write(0x0078, 0x04);                                // close LDO6 before power off
+    aml_pmu_set_charge_enable(0);                               // close charger before power off
+    if (pmu_version == 0x03) {
+        aml_pmu_set_bits(0x004a, 0x00, 0x08);                   // close clock of charger for REVD
+    }
+    AML_PMU_DBG("software goto OFF state\n");
+    mdelay(10);
+    aml_pmu_write(AML1212_GEN_CNTL1, buf);    
+    AML_PMU_DBG("power off PMU failed\n");
+    while (1) {
+            
+    }
+}
+EXPORT_SYMBOL_GPL(aml_pmu_poweroff);
+
+static int aml1212_update_status(struct aml_charger *charger);
+
+static enum power_supply_property aml_pmu_battery_props[] = {
+    POWER_SUPPLY_PROP_MODEL_NAME,
+    POWER_SUPPLY_PROP_STATUS,
+    POWER_SUPPLY_PROP_PRESENT,
+    POWER_SUPPLY_PROP_ONLINE,
+    POWER_SUPPLY_PROP_HEALTH,
+    POWER_SUPPLY_PROP_TECHNOLOGY,
+    POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+    POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+    POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_CURRENT_NOW,
+    POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+    POWER_SUPPLY_PROP_CAPACITY,
+    POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property aml_pmu_ac_props[] = {
+    POWER_SUPPLY_PROP_MODEL_NAME,
+    POWER_SUPPLY_PROP_PRESENT,
+    POWER_SUPPLY_PROP_ONLINE,
+    POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property aml_pmu_usb_props[] = {
+    POWER_SUPPLY_PROP_MODEL_NAME,
+    POWER_SUPPLY_PROP_PRESENT,
+    POWER_SUPPLY_PROP_ONLINE,
+    POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static void aml_pmu_battery_check_status(struct aml1212_supply       *supply,
+                                         union  power_supply_propval *val)
+{
+    struct aml_charger *charger = &supply->aml_charger;
+
+    if (charger->bat_det) {
+        if (charger->ext_valid){
+            if( charger->rest_vol == 100) {
+                val->intval = POWER_SUPPLY_STATUS_FULL;
+            } else if (charger->rest_vol == 0 && 
+                       charger->charge_status == CHARGER_DISCHARGING) { 
+                // protect for over-discharging
+                val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+            } else {
+                val->intval = POWER_SUPPLY_STATUS_CHARGING;
+            }
+        } else {
+            val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+        }
+    } else {
+        val->intval = POWER_SUPPLY_STATUS_FULL;
+    }
+}
+
+static void aml_pmu_battery_check_health(struct aml1212_supply       *supply,
+                                         union  power_supply_propval *val)
+{
+    // TODO: need implement
+#if 0
+    struct aml_charger *charger = &supply->charger;
+    if (charger->fault & ) {
+    } else if (charger->fault & ) {
+    } else if (charger->fault & ) {
+    } else {
+        val->intval = POWER_SUPPLY_HEALTH_GOOD;
+    }
+#else
+    val->intval = POWER_SUPPLY_HEALTH_GOOD;
+#endif
+}
+
+static int aml_pmu_battery_get_property(struct power_supply *psy,
+                                        enum   power_supply_property psp,
+                                        union  power_supply_propval *val)
+{
+    struct aml1212_supply *supply;
+    struct aml_charger    *charger;
+    int ret = 0;
+    supply  = container_of(psy, struct aml1212_supply, batt);
+    charger = &supply->aml_charger;
+    
+    switch (psp) {
+    case POWER_SUPPLY_PROP_STATUS:
+        aml_pmu_battery_check_status(supply, val);
+        break;
+
+    case POWER_SUPPLY_PROP_HEALTH:
+        aml_pmu_battery_check_health(supply, val);
+        break;
+
+    case POWER_SUPPLY_PROP_TECHNOLOGY:
+        val->intval = supply->battery_info->technology;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+        val->intval = supply->battery_info->voltage_max_design;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+        val->intval = supply->battery_info->voltage_min_design;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        val->intval = charger->vbat * 1000; 
+        break;
+
+    case POWER_SUPPLY_PROP_CURRENT_NOW:             // charging : +, discharging -;
+        if (ABS(charger->ibat) > 20  && 
+            !charger->charge_timeout && 
+            charger->charge_status != CHARGER_NONE) {
+            val->intval = charger->ibat * 1000 * (charger->charge_status == CHARGER_CHARGING ? 1 : -1);
+        } else {
+            val->intval = 0;                        // when charge time out, report 0
+        }
+        break;
+
+    case POWER_SUPPLY_PROP_MODEL_NAME:
+        val->strval = supply->batt.name;
+        break;
+
+    case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+        val->intval = supply->battery_info->energy_full_design;
+        break;
+
+    case POWER_SUPPLY_PROP_CAPACITY:
+        val->intval = charger->rest_vol;
+        break;
+
+    case POWER_SUPPLY_PROP_ONLINE:
+        val->intval = charger->bat_det; 
+        break;
+
+    case POWER_SUPPLY_PROP_PRESENT:
+        val->intval = charger->bat_det;
+        break;
+    case POWER_SUPPLY_PROP_TEMP:
+        val->intval =  300;                         // fixed to 300k, need implement dynamic values
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    
+    return ret;
+}
+
+static int aml_pmu_ac_get_property(struct power_supply *psy,
+                                   enum   power_supply_property psp,
+                                   union  power_supply_propval *val)
+{
+    struct aml1212_supply *supply;
+    struct aml_charger    *charger;
+    int ret = 0;
+    supply  = container_of(psy, struct aml1212_supply, ac);
+    charger = &supply->aml_charger;
+
+    switch(psp){
+    case POWER_SUPPLY_PROP_MODEL_NAME:
+        val->strval = supply->ac.name;
+        break;
+
+    case POWER_SUPPLY_PROP_PRESENT:
+        val->intval = charger->dcin_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_ONLINE:
+        val->intval = charger->dcin_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        val->intval = 5000 * 1000;          // charger->v_dcin * 1000;
+        break;
+
+    case POWER_SUPPLY_PROP_CURRENT_NOW:
+        val->intval = 1000 * 1000;          // charger->i_dcin * 1000;
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static int aml_pmu_usb_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+    struct aml1212_supply *supply;
+    struct aml_charger    *charger;
+    int ret = 0;
+    supply  = container_of(psy, struct aml1212_supply, usb);
+    charger = &supply->aml_charger;
+
+    switch(psp){
+    case POWER_SUPPLY_PROP_MODEL_NAME:
+        val->strval = supply->usb.name;
+        break;
+
+    case POWER_SUPPLY_PROP_PRESENT:
+        val->intval = charger->usb_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_ONLINE:
+        val->intval = charger->usb_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        val->intval = 5000 * 1000;      // charger->v_usb * 1000;
+        break;
+
+    case POWER_SUPPLY_PROP_CURRENT_NOW:
+        val->intval = 1000 * 1000;      // charger->i_usb * 1000;
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static char *supply_list[] = {
+    "battery",
+};
+
+static void aml_pmu_battery_setup_psy(struct aml1212_supply *supply)
+{
+    struct power_supply      *batt = &supply->batt;
+    struct power_supply      *ac   = &supply->ac;
+    struct power_supply      *usb  = &supply->usb;
+    struct power_supply_info *info =  supply->battery_info;
+    
+    batt->name           = "battery";
+    batt->use_for_apm    = info->use_for_apm;
+    batt->type           = POWER_SUPPLY_TYPE_BATTERY;
+    batt->get_property   = aml_pmu_battery_get_property;
+    batt->properties     = aml_pmu_battery_props;
+    batt->num_properties = ARRAY_SIZE(aml_pmu_battery_props);
+    
+    ac->name             = "ac";
+    ac->type             = POWER_SUPPLY_TYPE_MAINS;
+    ac->get_property     = aml_pmu_ac_get_property;
+    ac->supplied_to      = supply_list;
+    ac->num_supplicants  = ARRAY_SIZE(supply_list);
+    ac->properties       = aml_pmu_ac_props;
+    ac->num_properties   = ARRAY_SIZE(aml_pmu_ac_props);
+    
+    usb->name            = "usb";
+    usb->type            = POWER_SUPPLY_TYPE_USB;
+    usb->get_property    = aml_pmu_usb_get_property;
+    usb->supplied_to     = supply_list,
+    usb->num_supplicants = ARRAY_SIZE(supply_list),
+    usb->properties      = aml_pmu_usb_props;
+    usb->num_properties  = ARRAY_SIZE(aml_pmu_usb_props);
+}
+
+int aml_pmu_set_usb_current_limit(int curr, int bc_mode)
+{
+    uint8_t val;
+
+    aml_pmu_read(AML1212_CHG_CTRL3, &val);
+    val &= ~(0x30);
+    if (bc_mode > 0) {
+       g1212_supply->usb_connect_type = bc_mode;
+    }
+    AML_PMU_DBG("usb connet mode:%d, current limit to:%dmA\n", bc_mode, curr);
+    switch (curr) {
+    case 0:
+        val |= 0x30;                                    // disable limit
+        break;
+
+    case 100:
+        val |= 0x00;                                    // 100mA
+        break;
+
+    case 500:
+        val |= 0x10;                                    // 500mA
+        break;
+
+    case 900:
+        val |= 0x20;                                    // 900mA
+        break;
+
+    default:
+        AML_PMU_DBG("%s, wrong usb current limit:%d\n", __func__, curr);
+        return -1; 
+    }
+    return aml_pmu_write(AML1212_CHG_CTRL3, val);
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_usb_current_limit);
+
+int aml1212_set_usb_current_limit(int curr)
+{
+    return aml_pmu_set_usb_current_limit(curr, -1);    
+}
+
+int aml_pmu_get_battery_percent(void)
+{
+    CHECK_DRIVER();
+    return g1212_supply->aml_charger.rest_vol;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_get_battery_percent);
+
+int aml_pmu_set_charge_current(int chg_cur)
+{
+    uint8_t val;
+
+    aml_pmu_read(AML1212_CHG_CTRL4, &val);
+    switch (chg_cur) {
+    case 1500000:
+        val &= ~(0x01 << 5);
+        break;
+
+    case 2000000:
+        val |= (0x01 << 5);
+        break;
+
+    default:
+        AML_PMU_DBG("%s, Wrong charge current:%d\n", __func__, chg_cur);
+        return -1;
+    }
+    aml_pmu_write(AML1212_CHG_CTRL4, val);
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_charge_current);
+
+int aml_pmu_set_charge_voltage(int voltage)
+{
+    uint8_t val;
+    uint8_t tmp;
+    
+    if (voltage > 4400000 || voltage < 4050000) {
+        AML_PMU_DBG("%s,Wrong charge voltage:%d\n", __func__, voltage);
+        return -1;
+    }
+    tmp = ((voltage - 4050000) / 50000) & 0x07;
+    aml_pmu_read(AML1212_CHG_CTRL0, &val);
+    val &= ~(0x07);
+    val |= tmp;
+    aml_pmu_write(AML1212_CHG_CTRL0, val);
+
+    return 0; 
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_charge_voltage);
+
+int aml_pmu_set_charge_end_rate(int rate) 
+{
+    uint8_t val;
+
+    aml_pmu_read(AML1212_CHG_CTRL4, &val);
+    switch (rate) {
+    case 10:
+        val &= ~(0x01 << 3);
+        break;
+
+    case 20:
+        val |= (0x01 << 3);
+        break;
+
+    default:
+        AML_PMU_DBG("%s, Wrong charge end rate:%d\n", __func__, rate);
+        return -1;
+    }
+    aml_pmu_write(AML1212_CHG_CTRL4, val);
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_charge_end_rate);
+
+int aml_pmu_set_adc_freq(int freq)
+{
+    uint8_t val;
+    int32_t time;
+    int32_t time_base;
+    int32_t time_bit;
+
+    if (freq > 1000 || freq < 10) {
+        AML_PMU_DBG("%s, Wrong adc freq:%d\n", __func__, freq);    
+        return -1;
+    }
+    time = 1000 / freq;
+    if (time >= 1 && time < 10) {
+        time_base = 1;
+        time_bit  = 0;
+    } else if (time >= 10 && time < 99) {
+        time_base = 10;
+        time_bit  = 1;
+    } else {
+        time_base = 100;
+        time_bit  = 2;
+    }
+    time /= time_base;
+    val = ((time_bit << 6) | (time - 1)) & 0xff;
+    AML_PMU_DBG("%s, set reg[0xA0] to %02x\n", __func__, val);          // TEST
+    aml_pmu_write(AML1212_SAR_CNTL_REG5, val);
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_adc_freq);
+
+int aml_pmu_set_precharge_time(int minute)
+{
+    uint8_t val;
+
+    if (minute > 80 || minute < 30) {
+        AML_PMU_DBG("%s, Wrong pre-charge time:%d\n", __func__, minute);
+        return -1;
+    }
+    aml_pmu_read(AML1212_CHG_CTRL3, &val);
+    val &= ~(0x03);
+    switch (minute) {
+    case 30:
+        val |= 0x01;
+        break;
+
+    case 50:
+        val |= 0x02;
+        break;
+
+    case 80:
+        val |= 0x03;
+        break;
+    
+    default:
+        AML_PMU_DBG("%s, Wrong pre-charge time:%d\n", __func__, minute);
+        return -1;
+    }
+    aml_pmu_write(AML1212_CHG_CTRL3, val);
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_precharge_time);
+
+int aml_pmu_set_fastcharge_time(int minute)
+{
+    uint8_t val;
+
+    if (minute < 360 || minute > 720) {
+        AML_PMU_DBG("%s, Wrong fast-charge time:%d\n", __func__, minute);
+        return -1;
+    }
+    aml_pmu_read(AML1212_CHG_CTRL3, &val);
+    val &= ~(0xC0);
+    switch (minute) {
+    case 360:
+        val |= (0x01 << 6);
+        break;
+
+    case 540:
+        val |= (0x02 << 6);
+        break;
+
+    case 720:
+        val |= (0x03 << 6);
+        break;
+
+    default:
+        AML_PMU_DBG("%s, Wrong pre-charge time:%d\n", __func__, minute);
+        return -1;
+    }
+    aml_pmu_write(AML1212_CHG_CTRL3, val);
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_fastcharge_time);
+
+int aml_pmu_set_charge_enable(int en)
+{
+    uint8_t val;
+    
+    if (pmu_version <= 0x02 && pmu_version != 0) {                      /* reversion A or B             */
+        aml_pmu_read(AML1212_OTP_GEN_CONTROL0, &val);
+        if (en) {
+            val |= (0x01);    
+        } else {
+            val &= ~(0x01);    
+        }
+        aml_pmu_write(AML1212_OTP_GEN_CONTROL0, val);
+    } else if (pmu_version == 0x03) {                                   /* reversion D                  */
+        aml_pmu_set_bits(0x0011, ((en & 0x01) << 7), 0x80); 
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_charge_enable);
+
+int aml_pmu_set_usb_voltage_limit(int voltage)
+{
+    uint8_t val;
+
+    if (voltage > 4600 || voltage < 4300) {
+        AML_PMU_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
+    }
+    aml_pmu_read(AML1212_CHG_CTRL4, &val);
+    val &= ~(0xc0);
+    switch (voltage) {
+    case 4300:
+        val |= (0x01 << 6);
+        break;
+
+    case 4400:
+        val |= (0x02 << 6);
+        break;
+
+    case 4500:
+        val |= (0x00 << 6);
+        break;
+
+    case 4600:
+        val |= (0x03 << 6);
+        break;
+    
+    default:
+        AML_PMU_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
+        return -1;
+    }
+    aml_pmu_write(AML1212_CHG_CTRL4, val);
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml_pmu_set_usb_voltage_limit);
+
+static int aml1212_clear_coulomb(struct aml_charger *charger)
+{
+	aml_pmu_write(AML1212_SAR_SW_EN_FIELD, 0x80); 
+    return 0;
+}
+
+int aml_pmu_first_init(struct aml1212_supply *supply)
+{
+    uint8_t irq_mask[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0xf0};
+
+    aml_pmu_write(AML1212_SAR_CNTL_REG2,   0x64);                       // select vref=2.4V
+    aml_pmu_write(AML1212_SAR_CNTL_REG3,   0x14);                       // close the useless channel input
+    aml_pmu_write(AML1212_SAR_CNTL_REG0,   0x0c);                       // enable IBAT_AUTO, ACCUM
+    aml_pmu_writes(AML1212_IRQ_MASK_0, irq_mask, sizeof(irq_mask));     // open all IRQ
+
+    /*
+     * initialize charger from battery parameters
+     */
+    aml_pmu_set_charge_current (aml_pmu_battery->pmu_init_chgcur);
+    aml_pmu_set_charge_voltage (aml_pmu_battery->pmu_init_chgvol);
+    aml_pmu_set_charge_end_rate(aml_pmu_battery->pmu_init_chgend_rate);
+    aml_pmu_set_adc_freq       (aml_pmu_battery->pmu_init_adc_freqc);
+    aml_pmu_set_precharge_time (aml_pmu_battery->pmu_init_chg_pretime);
+    aml_pmu_set_fastcharge_time(aml_pmu_battery->pmu_init_chg_csttime);
+    aml_pmu_set_charge_enable  (aml_pmu_battery->pmu_init_chg_enabled);
+
+    if (aml_pmu_battery->pmu_usbvol_limit) {
+        aml_pmu_set_usb_voltage_limit(aml_pmu_battery->pmu_usbvol); 
+    }
+    if (aml_pmu_battery->pmu_usbcur_limit) {
+        aml_pmu_set_usb_current_limit(500, USB_BC_MODE_SDP);            // fix to 500 when init
+    }
+
+    return 0;
+}
+
+/*
+ * add for debug 
+ */
+static ssize_t dbg_info_show     (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t dbg_info_store    (struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t battery_para_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t battery_para_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t report_delay_show (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t report_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t dump_pmu_regs_show   (struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t dump_pmu_regs_store  (struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static int     aml_pmu_regs_base = 0;
+static ssize_t aml_pmu_reg_base_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "aml_pmu_regs_base: 0x%02x\n", aml_pmu_regs_base); 
+}
+
+static ssize_t aml_pmu_reg_base_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    int tmp = simple_strtoul(buf, NULL, 16);
+    if (tmp > 255) {
+        AML_PMU_DBG("Invalid input value\n");
+        return -1;
+    }
+    aml_pmu_regs_base = tmp;
+    AML_PMU_DBG("Set register base to 0x%02x\n", aml_pmu_regs_base);
+    return count;
+}
+
+static ssize_t aml_pmu_reg_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    uint8_t data;
+    aml_pmu_read(aml_pmu_regs_base, &data);
+    return sprintf(buf, "reg[0x%02x] = 0x%02x\n", aml_pmu_regs_base, data);
+}
+
+static ssize_t aml_pmu_reg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    uint8_t data = simple_strtoul(buf, NULL, 16);
+    if (data > 255) {
+        AML_PMU_DBG("Invalid input value\n");
+        return -1;
+    }
+    aml_pmu_write(aml_pmu_regs_base, data);
+    return count; 
+}
+
+static ssize_t aml_pmu_reg_16bit_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    uint16_t data;
+    if (aml_pmu_regs_base & 1){
+        AML_PMU_DBG("Invalid reg base value\n");
+        return -1;
+    }
+    aml_pmu_read16(aml_pmu_regs_base, &data);
+    return sprintf(buf, "reg[0x%04x] = 0x%04x\n", aml_pmu_regs_base, data);
+}
+
+static ssize_t aml_pmu_reg_16bit_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    uint16_t data = simple_strtoul(buf, NULL, 16);
+    if (data > 0xffff) {
+        AML_PMU_DBG("Invalid input value\n");
+        return -1;
+    }
+    if (aml_pmu_regs_base & 1){
+        AML_PMU_DBG("Invalid reg base value\n");
+        return -1;
+    }
+    aml_pmu_write16(aml_pmu_regs_base, data);
+    return count; 
+}
+
+static ssize_t aml_pmu_vddao_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    uint8_t data;
+    aml_pmu_read(0x2f, &data);
+
+    return sprintf(buf, "Voltage of VDD_AO = %4dmV\n", dcdc1_voltage_table[(data & 0xfc) >> 2]);
+}
+
+static ssize_t aml_pmu_vddao_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    uint32_t data = simple_strtoul(buf, NULL, 10);
+    if (data > 2000 || data < 740) {
+        AML_PMU_DBG("Invalid input value = %d\n", data);
+        return -1;
+    }
+    AML_PMU_DBG("Set VDD_AO to %4d mV\n", data);
+    aml_pmu_set_voltage(AML_PMU_DCDC1, data);
+    return count; 
+}
+
+static ssize_t driver_version_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Amlogic PMU Aml1212 driver version is %s, build time:%s\n", 
+                   AML1212_DRIVER_VERSION, init_uts_ns.name.version);
+}
+
+static ssize_t driver_version_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count; 
+}
+
+static ssize_t clear_rtc_mem_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return 0;
+}
+
+static ssize_t clear_rtc_mem_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ 
+    aml_write_rtc_mem_reg(0, 0);
+    aml_pmu_poweroff();
+    return count; 
+}
+
+static ssize_t charge_timeout_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+
+    aml_pmu_read(AML1212_CHG_CTRL3, &val);
+    val >>= 6;
+    if (val) {
+        return sprintf(buf, "charge timeout is %d minutes\n", val * 180 + 180);   
+    }
+    return 0;
+}
+
+static ssize_t charge_timeout_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ 
+    uint32_t data = simple_strtoul(buf, NULL, 10);
+    if (data > 720 || data < 360) {
+        AML_PMU_DBG("Invalid input value = %d\n", data);
+        return -1;
+    }
+    AML_PMU_DBG("Set charge timeout to %4d minutes\n", data);
+    aml_pmu_set_fastcharge_time(data); 
+    return count; 
+}
+
+static struct device_attribute aml1212_supply_attrs[] = {
+    AML_PMU_CHG_ATTR(aml_pmu_reg_base),
+    AML_PMU_CHG_ATTR(aml_pmu_reg),
+    AML_PMU_CHG_ATTR(aml_pmu_reg_16bit),
+    AML_PMU_CHG_ATTR(aml_pmu_vddao),
+    AML_PMU_CHG_ATTR(dbg_info),
+    AML_PMU_CHG_ATTR(battery_para),
+    AML_PMU_CHG_ATTR(report_delay),
+    AML_PMU_CHG_ATTR(driver_version),
+    AML_PMU_CHG_ATTR(clear_rtc_mem),
+    AML_PMU_CHG_ATTR(charge_timeout),
+    AML_PMU_CHG_ATTR(dump_pmu_regs),
+};
+
+int aml1212_supply_create_attrs(struct power_supply *psy)
+{
+    int j,ret;
+    for (j = 0; j < ARRAY_SIZE(aml1212_supply_attrs); j++) {
+        ret = device_create_file(psy->dev, &aml1212_supply_attrs[j]);
+        if (ret)
+            goto sysfs_failed;
+    }
+    goto succeed;
+
+sysfs_failed:
+    while (j--) {
+        device_remove_file(psy->dev, &aml1212_supply_attrs[j]);
+    }
+succeed:
+    return ret;
+}
+
+static int aml_cal_ocv(int ibat, int vbat, int dir)
+{
+    int result;
+
+    if (dir == 1) {                                                     // charging
+        result = vbat - (ibat * aml_pmu_battery->pmu_battery_rdc) / 1000;
+    } else if (dir == 2) {                                              // discharging
+        result = vbat + (ibat * aml_pmu_battery->pmu_battery_rdc) / 1000;    
+    } else {
+        result = vbat;    
+    }
+    return result;
+}
+
+static int aml1212_update_status(struct aml_charger *charger)
+{
+    uint8_t buff[5] = {};
+    static int chg_gat_bat_lv = 0;
+    struct aml1212_supply *supply = container_of(charger, struct aml1212_supply, aml_charger);
+
+    aml_pmu_reads(AML1212_SP_CHARGER_STATUS0, buff, sizeof(buff));
+
+    if (!(buff[3] & 0x02)) {                                            // CHG_GAT_BAT_LV = 0, discharging
+        charger->charge_status = CHARGER_DISCHARGING; 
+    } else if ((buff[3] & 0x02) && (buff[2] & 0x04)) {
+        charger->charge_status = CHARGER_CHARGING;                      // charging
+    } else {
+        charger->charge_status = CHARGER_NONE;                          // Not charging 
+    }
+    charger->bat_det    = 1;                                            // do not check register 0xdf, bug here
+    charger->dcin_valid = buff[2] & 0x10 ? 1 : 0;
+    charger->usb_valid  = buff[2] & 0x08 ? 1 : 0;
+    charger->ext_valid  = buff[2] & 0x18;                               // to differ USB / AC status update 
+
+    charger->fault = ((buff[0] <<  0) | (buff[1] <<  8) |
+                      (buff[2] << 16) | (buff[3] << 24));
+    if ((!(buff[3] & 0x02)) && !chg_gat_bat_lv) {                       // according David Wang
+        AML_PMU_DBG("CHG_GAT_BAT_LV is 0, limit usb current to 500mA\n");
+        aml_pmu_set_usb_current_limit(500, supply->usb_connect_type); 
+        chg_gat_bat_lv = 1;
+    } else if (buff[3] & 0x02 && chg_gat_bat_lv) {
+        chg_gat_bat_lv = 0;    
+        if (supply->usb_connect_type == USB_BC_MODE_DCP || 
+            supply->usb_connect_type == USB_BC_MODE_CDP) {              // reset to 900 when enough current supply
+            aml_pmu_set_usb_current_limit(900, supply->usb_connect_type);    
+            AML_PMU_DBG("CHG_GAT_BAT_LV is 1, limit usb current to 900mA\n");
+        }
+    }
+    if (buff[1] & 0x40) {                                               // charge timeout detect
+        AML_PMU_DBG("Charge timeout deteceted\n");
+        if ((aml1212_init->charge_timeout_retry) &&
+            (aml1212_init->charge_timeout_retry > re_charge_cnt)) {
+            re_charge_cnt++;
+            AML_PMU_DBG("reset charger due to charge timeout occured, ocv :%d, retry:%d\n", 
+                        charger->ocv, re_charge_cnt);
+            aml_pmu_set_fastcharge_time(360);                           // only retry charge 6 hours, for safe problem
+            aml_pmu_set_charge_enable(0);
+            msleep(1000);
+            aml_pmu_set_charge_enable(1);
+        }
+        charger->charge_timeout = 1;
+    } else {
+        charger->charge_timeout = 0;    
+    }
+    if (charger->ext_valid && !(power_flag & 0x01)) {                   // enable charger when detect extern power
+        power_flag |=  0x01;                                            // remember enabled charger 
+        power_flag &= ~0x02;
+    } else if (!charger->ext_valid && !(power_flag & 0x02)) {
+        re_charge_cnt = 0;
+        aml_pmu_set_fastcharge_time(aml_pmu_battery->pmu_init_chg_csttime);
+        power_flag |=  0x02;                                            // remember disabled charger
+        power_flag &= ~0x01;
+    }
+    if (!charger->ext_valid && aml1212_init->vbus_dcin_short_connect) {
+        aml_pmu_set_dcin(0);                                            // disable DCIN when no extern power
+    }
+    charger->vbat = aml_pmu_get_voltage();
+    charger->ibat = aml_pmu_get_current();
+    charger->ocv  = aml_cal_ocv(charger->ibat, charger->vbat, charger->charge_status);
+    return 0;
+}
+
+void dump_pmu_register(void)
+{
+    uint8_t val[16];
+    int     i;
+    printk("[AML_PMU] DUMP ALL REGISTERS\n");
+    for (i = 0; i < 16; i++) {
+        aml_pmu_reads(i*16, val, 16);
+        printk("0x%02x - %02x: ", i * 16, i * 16 + 15);
+        printk("%02x %02x %02x %02x ",   val[0],  val[1],  val[2],  val[3]);
+        printk("%02x %02x %02x %02x   ", val[4],  val[5],  val[6],  val[7]);
+        printk("%02x %02x %02x %02x ",   val[8],  val[9],  val[10], val[11]);
+        printk("%02x %02x %02x %02x\n",  val[12], val[13], val[14], val[15]);
+    }
+}
+EXPORT_SYMBOL_GPL(dump_pmu_register);
+
+static ssize_t dump_pmu_regs_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    dump_pmu_register();
+    return sprintf(buf, "[AML_PMU] DUMP ALL REGISTERS OVER!\n"); 
+}
+static ssize_t dump_pmu_regs_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;                                           /* nothing to do        */
+}
+
+static ssize_t dbg_info_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct power_supply   *battery = dev_get_drvdata(dev);
+    struct aml1212_supply *supply= container_of(battery, struct aml1212_supply, batt); 
+    int size;
+
+    size = aml_pmu_format_dbg_buffer(&supply->aml_charger, buf);
+
+    return size;
+}
+
+static ssize_t dbg_info_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;                                           /* nothing to do        */
+}
+
+static ssize_t battery_para_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct power_supply   *battery = dev_get_drvdata(dev);
+    struct aml1212_supply *supply  = container_of(battery, struct aml1212_supply, batt); 
+    struct aml_charger    *charger = &supply->aml_charger;
+    int i = 0; 
+    int size;
+
+    size = sprintf(buf, "\n i,      ocv,    charge,  discharge,\n");
+    for (i = 0; i < 16; i++) {
+        size += sprintf(buf + size, "%2d,     %4d,       %3d,        %3d,\n",
+                        i, 
+                        aml_pmu_battery->pmu_bat_curve[i].ocv,
+                        aml_pmu_battery->pmu_bat_curve[i].charge_percent,
+                        aml_pmu_battery->pmu_bat_curve[i].discharge_percent);
+    }
+    size += sprintf(buf + size, "\nBattery capability:%4d@3700mAh, RDC:%3d mohm\n", 
+                                aml_pmu_battery->pmu_battery_cap, 
+                                aml_pmu_battery->pmu_battery_rdc);
+    size += sprintf(buf + size, "Charging efficiency:%3d%%, capability now:%3d%%\n", 
+                                aml_pmu_battery->pmu_charge_efficiency,
+                                charger->rest_vol);
+    size += sprintf(buf + size, "ocv_empty:%4d, ocv_full:%4d\n\n",
+                                charger->ocv_empty, 
+                                charger->ocv_full);
+    return size;
+}
+
+static ssize_t battery_para_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;                                                       /* nothing to do        */
+}
+
+static ssize_t report_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "report_delay = %d\n", aml_pmu_get_report_delay()); 
+}
+
+static ssize_t report_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    uint32_t tmp = simple_strtoul(buf, NULL, 10);
+
+    if (tmp > 200) {
+        AML_PMU_DBG("input too large, failed to set report_delay\n");    
+        return count;
+    }
+    aml_pmu_set_report_delay(tmp);
+    return count;
+}
+
+static void aml_pmu_charging_monitor(struct work_struct *work)
+{
+    struct   aml1212_supply *supply;
+    struct   aml_charger    *charger;
+    static int check_charge_flag = 0; 
+    uint8_t  v[2] = {};
+    int32_t pre_rest_cap;
+    uint8_t pre_chg_status;
+
+    supply  = container_of(work, struct aml1212_supply, work.work);
+    charger = &supply->aml_charger;
+    pre_chg_status = charger->ext_valid;
+    pre_rest_cap   = charger->rest_vol;
+
+    /*
+     * 1. update status of PMU and all ADC value
+     * 2. read ocv value and calculate ocv percent of battery
+     * 3. read coulomb value and calculate movement of energy
+     * 4. if battery capacity is larger than 429496 mAh, will cause over flow
+     */
+    aml_pmu_update_battery_capacity(charger, aml_pmu_battery);
+
+    if (charger->ocv > 5000) {
+        // SAR ADC error, only occur when battery voltage is very low
+        AML_PMU_DBG(">> SAR ADC error, ocv:%d, vbat:%d, ibat:%d\n", 
+                    charger->ocv, charger->vbat, charger->ibat);
+        charger->rest_vol = 0;
+    }
+
+    /*
+     * work around for cannot stop charge problem, according David Wang
+     */
+    if (charger->rest_vol >= 99 && charger->ibat < 150 && charger->charge_status == CHARGER_CHARGING && !check_charge_flag) {
+        aml_pmu_read(AML1212_SP_CHARGER_STATUS3, v);
+        if (!(v[0] & 0x08)) {
+            check_charge_flag = 1;
+            AML_PMU_DBG("CHG_END_DET = 0 find, close charger for 1 second\n");
+            aml_pmu_set_charge_enable(0);
+            msleep(1000);
+            aml_pmu_set_charge_enable(1);
+        }
+    } else if (charger->rest_vol < 99) {
+        check_charge_flag = 0;
+    }
+
+    if((charger->rest_vol - pre_rest_cap) || (pre_chg_status != charger->ext_valid) || charger->resume){
+        AML_PMU_DBG("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
+        if (unlikely(charger->resume)) {
+            charger->resume = 0;
+        }
+        power_supply_changed(&supply->batt);
+    }
+
+    /* reschedule for the next time */
+    schedule_delayed_work(&supply->work, supply->interval);
+}
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+static void aml_pmu_earlysuspend(struct early_suspend *h)
+{
+    // add charge current limit code here
+}
+
+static void aml_pmu_lateresume(struct early_suspend *h)
+{
+    struct  aml1212_supply *supply = (struct aml1212_supply *)h->param;
+
+    schedule_work(&supply->work.work);                                      // update for upper layer 
+    // add charge current limit code here
+}
+#endif
+
+irqreturn_t aml_pmu_irq_handler(int irq, void *dev_id)
+{
+    struct   aml1212_supply *supply= (struct aml1212_supply *)dev_id;
+
+    disable_irq_nosync(supply->irq);
+    schedule_work(&supply->irq_work);
+
+    return IRQ_HANDLED;
+}
+
+static void aml_pmu_irq_work_func(struct work_struct *work)
+{
+    struct aml1212_supply *supply = container_of(work, struct aml1212_supply, irq_work);
+    uint8_t irq_status[6] = {};
+
+    aml_pmu_reads(AML1212_IRQ_STATUS_CLR_0, irq_status, sizeof(irq_status));
+    AML_PMU_DBG("PMU IRQ status: %02x %02x %02x %02x %02x %02x", 
+                irq_status[0], irq_status[1], irq_status[2],
+                irq_status[3], irq_status[4], irq_status[5]);
+    aml_pmu_writes(AML1212_IRQ_STATUS_CLR_0, irq_status, sizeof(irq_status));       // clear IRQ status
+    if (irq_status[5] & 0x08) {
+        AML_PMU_DBG("Over Temperature is occured, shutdown system\n");
+        aml_pmu_poweroff();
+    }
+    enable_irq(supply->irq);
+
+    return ;
+}
+
+static void check_pmu_version(void)
+{
+    uint8_t val;
+
+    aml_pmu_read(0x007e, &val);
+    AML_PMU_DBG("OTP VERSION: 0x%02x\n", val);
+    aml_pmu_read(0x007f, &val);
+    AML_PMU_DBG("PMU VERSION: 0x%02x\n", val);
+    if (val > 0x03 || val == 0x00) {
+        AML_PMU_DBG("#### ERROR: unknow pmu version:0x%02x ####\n", val);    
+    } else {
+        pmu_version = val;
+    }
+}
+
+#ifdef CONFIG_RESET_TO_SYSTEM
+static int aml_pmu_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
+{
+    AML_PMU_DBG("%s in\n", __func__);
+    aml_pmu_write(0x00ff, 0x00);            // clear boot flag
+    return NOTIFY_DONE;
+}
+
+static struct notifier_block pmu_reboot_nb;
+#endif
+
+struct aml_pmu_driver aml1212_driver = {
+    .name                       = "aml1212",
+    .pmu_get_coulomb            = aml1212_get_coulomb_acc, 
+    .pmu_clear_coulomb          = aml1212_clear_coulomb, 
+    .pmu_update_status          = aml1212_update_status, 
+    .pmu_set_rdc                = NULL,
+    .pmu_set_gpio               = aml_pmu_set_gpio,
+    .pmu_get_gpio               = aml_pmu_get_gpio, 
+    .pmu_reg_read               = aml_pmu_read, 
+    .pmu_reg_write              = aml_pmu_write,
+    .pmu_reg_reads              = aml_pmu_reads,
+    .pmu_reg_writes             = aml_pmu_writes,
+    .pmu_set_bits               = aml_pmu_set_bits,
+    .pmu_set_usb_current_limit  = aml1212_set_usb_current_limit,
+    .pmu_set_charge_current     = aml_pmu_set_charge_current,
+    .pmu_power_off              = aml_pmu_poweroff, 
+};
+
+static struct workqueue_struct *aml_pwr_key_work;
+static struct delayed_work pwr_key_work;
+
+static void pwr_key_work_func(struct work_struct *work)
+{
+    static int pressed = 0;
+    uint8_t key_value;
+    aml_pmu_read(0x00c4, &key_value);
+    if (key_value & 0x20) {
+        if (pressed) {
+            AML_PMU_DBG("pwk key is not pressed\n");
+            input_report_key(aml_pmu_power_key, KEY_POWER, 0);
+            input_sync(aml_pmu_power_key);
+            pressed = 0;
+        }
+    } else {
+        if (!pressed) {
+            AML_PMU_DBG("pwk key is pressed\n");
+            input_report_key(aml_pmu_power_key, KEY_POWER, 1);
+            input_sync(aml_pmu_power_key);
+            pressed = 1;
+        }    
+    }
+    queue_delayed_work(aml_pwr_key_work, &pwr_key_work, msecs_to_jiffies(20));
+}
+
+static int aml_pmu_battery_probe(struct platform_device *pdev)
+{
+    struct   aml1212_supply *supply;
+    struct   aml_charger    *charger;
+    int      ret;
+    int      max_diff = 0, tmp_diff;
+    uint32_t tmp2;
+
+	AML_PMU_DBG("call %s in", __func__);
+    aml1212_init = pdev->dev.platform_data;
+    aml_pmu_power_key = input_allocate_device();
+    if (!aml_pmu_power_key) {
+        kfree(aml_pmu_power_key);
+        return -ENODEV;
+    }
+
+    aml_pmu_power_key->name       = pdev->name;
+    aml_pmu_power_key->phys       = "m1kbd/input2";
+    aml_pmu_power_key->id.bustype = BUS_HOST;
+    aml_pmu_power_key->id.vendor  = 0x0001;
+    aml_pmu_power_key->id.product = 0x0001;
+    aml_pmu_power_key->id.version = 0x0100;
+    aml_pmu_power_key->open       = NULL;
+    aml_pmu_power_key->close      = NULL;
+    aml_pmu_power_key->dev.parent = &pdev->dev;
+
+    set_bit(EV_KEY, aml_pmu_power_key->evbit);
+    set_bit(EV_REL, aml_pmu_power_key->evbit);
+    set_bit(KEY_POWER, aml_pmu_power_key->keybit);
+
+    ret = input_register_device(aml_pmu_power_key);
+
+    if (aml1212_init == NULL) {
+        return -EINVAL;    
+    }
+
+    aml_pwr_key_work = create_singlethread_workqueue("aml_pwr_key");
+    if (!aml_pwr_key_work) {
+        AML_PMU_DBG("%s, create workqueue failed\n", __func__);
+        return -ENOMEM;    
+    }
+    INIT_DELAYED_WORK(&pwr_key_work, pwr_key_work_func);
+    queue_delayed_work(aml_pwr_key_work, &pwr_key_work, msecs_to_jiffies(2000));
+#ifdef CONFIG_UBOOT_BATTERY_PARAMETERS 
+    if (get_uboot_battery_para_status() == UBOOT_BATTERY_PARA_SUCCESS) {
+        aml_pmu_battery = get_uboot_battery_para();
+        AML_PMU_DBG("use uboot passed battery parameters\n");
+    } else {
+        aml_pmu_battery = aml1212_init->board_battery; 
+        AML_PMU_DBG("uboot battery parameter not get, use BSP configed battery parameters\n");
+    }
+#else
+    aml_pmu_battery = aml1212_init->board_battery; 
+    AML_PMU_DBG("use BSP configed battery parameters\n");
+#endif
+
+    /*
+     * initialize parameters for supply 
+     */
+    supply = kzalloc(sizeof(*supply), GFP_KERNEL);
+    if (supply == NULL) {
+        return -ENOMEM;
+    }
+    supply->battery_info = kzalloc(sizeof(struct power_supply_info), GFP_KERNEL);
+    if (supply->battery_info == NULL) {
+        kfree(supply);
+        return -ENOMEM;    
+    }
+    supply->master = pdev->dev.parent;
+
+    aml_pmu_register_driver(&aml1212_driver);
+    g1212_supply = supply;
+    check_pmu_version();
+    charger = &supply->aml_charger;
+    for (tmp2 = 1; tmp2 < 16; tmp2++) {
+        if (!charger->ocv_empty && aml_pmu_battery->pmu_bat_curve[tmp2].discharge_percent > 0) {
+            charger->ocv_empty = aml_pmu_battery->pmu_bat_curve[tmp2-1].ocv;
+        }
+        if (!charger->ocv_full && aml_pmu_battery->pmu_bat_curve[tmp2].discharge_percent == 100) {
+            charger->ocv_full = aml_pmu_battery->pmu_bat_curve[tmp2].ocv;    
+        }
+        tmp_diff = aml_pmu_battery->pmu_bat_curve[tmp2].discharge_percent -
+                   aml_pmu_battery->pmu_bat_curve[tmp2].charge_percent;
+        if (tmp_diff > max_diff) {
+            max_diff = tmp_diff;
+        }
+    }
+
+    supply->irq = aml_pmu_battery->pmu_irq_id;
+
+    supply->battery_info->technology         = aml_pmu_battery->pmu_battery_technology;
+    supply->battery_info->voltage_max_design = aml_pmu_battery->pmu_init_chgvol;
+    supply->battery_info->energy_full_design = aml_pmu_battery->pmu_battery_cap;
+    supply->battery_info->voltage_min_design = charger->ocv_empty * 1000;
+    supply->battery_info->use_for_apm        = 1;
+    supply->battery_info->name               = aml_pmu_battery->pmu_battery_name;
+
+    re_charge_cnt            = aml1212_init->charge_timeout_retry;
+    charger->soft_limit_to99 = aml1212_init->soft_limit_to99;
+    charger->coulomb_type    = COULOMB_SINGLE_CHG_DEC;
+    if (supply->irq == AML_PMU_IRQ_NUM) {
+        INIT_WORK(&supply->irq_work, aml_pmu_irq_work_func); 
+        ret = request_irq(supply->irq, 
+                          aml_pmu_irq_handler, 
+                          IRQF_DISABLED | IRQF_SHARED,
+                          AML1212_IRQ_NAME,
+                          supply); 
+        if (ret) {
+            AML_PMU_DBG("request irq failed, ret:%d, irq:%d\n", ret, supply->irq);    
+        }
+    }
+
+    ret = aml_pmu_first_init(supply);
+    if (ret) {
+        goto err_charger_init;
+    }
+
+    aml_pmu_battery_setup_psy(supply);
+    ret = power_supply_register(&pdev->dev, &supply->batt);
+    if (ret) {
+        goto err_ps_register;
+    }
+
+    ret = power_supply_register(&pdev->dev, &supply->ac);
+    if (ret){
+        power_supply_unregister(&supply->batt);
+        goto err_ps_register;
+    }
+    ret = power_supply_register(&pdev->dev, &supply->usb);
+    if (ret){
+        power_supply_unregister(&supply->ac);
+        power_supply_unregister(&supply->batt);
+        goto err_ps_register;
+    }
+
+    ret = aml1212_supply_create_attrs(&supply->batt);
+    if(ret){
+        return ret;
+    }
+
+    platform_set_drvdata(pdev, supply);
+
+    supply->interval = msecs_to_jiffies(AML_PMU_WORK_CYCLE);
+    INIT_DELAYED_WORK(&supply->work, aml_pmu_charging_monitor);
+    schedule_delayed_work(&supply->work, supply->interval);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    aml_pmu_early_suspend.suspend = aml_pmu_earlysuspend;
+    aml_pmu_early_suspend.resume  = aml_pmu_lateresume;
+    aml_pmu_early_suspend.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 2;
+    aml_pmu_early_suspend.param   = supply;
+    register_early_suspend(&aml_pmu_early_suspend);
+#endif
+
+    aml_pmu_probe_process(charger, aml_pmu_battery);
+    power_supply_changed(&supply->batt);                   // update battery status
+    
+    aml_pmu_set_gpio(1, 0);                                 // open LCD backlight, test
+    aml_pmu_set_gpio(2, 0);                                 // open VCCx2, test
+
+    dump_pmu_register();
+#ifdef CONFIG_RESET_TO_SYSTEM
+    pmu_reboot_nb.notifier_call = aml_pmu_reboot_notifier;
+    ret = register_reboot_notifier(&pmu_reboot_nb);
+    if (ret) {
+        AML_PMU_DBG("%s, register reboot notifier failed, ret:%d\n", __func__, ret);
+    }
+#endif
+	AML_PMU_DBG("call %s exit, ret:%d", __func__, ret);
+    return ret;
+
+err_ps_register:
+    free_irq(supply->irq, supply);
+    cancel_delayed_work_sync(&supply->work);
+    destroy_workqueue(aml_pwr_key_work);
+
+err_charger_init:
+    kfree(supply->battery_info);
+    kfree(supply);
+    input_unregister_device(aml_pmu_power_key);
+    kfree(aml_pmu_power_key);
+	AML_PMU_DBG("call %s exit, ret:%d", __func__, ret);
+    return ret;
+}
+
+static int aml_pmu_battery_remove(struct platform_device *dev)
+{
+    struct aml1212_supply *supply= platform_get_drvdata(dev);
+
+    cancel_work_sync(&supply->irq_work);
+    cancel_delayed_work_sync(&supply->work);
+    power_supply_unregister(&supply->usb);
+    power_supply_unregister(&supply->ac);
+    power_supply_unregister(&supply->batt);
+    
+    free_irq(supply->irq, supply);
+    kfree(supply->battery_info);
+    kfree(supply);
+    input_unregister_device(aml_pmu_power_key);
+    kfree(aml_pmu_power_key);
+    destroy_workqueue(aml_pwr_key_work);
+
+    return 0;
+}
+
+
+static int aml_pmu_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct aml1212_supply *supply  = platform_get_drvdata(dev);
+    struct aml_charger    *charger = &supply->aml_charger;
+
+    cancel_delayed_work_sync(&supply->work);
+    aml_pmu_set_charge_current(aml_pmu_battery->pmu_suspend_chgcur);
+    if (supply->usb_connect_type != USB_BC_MODE_SDP) {
+        aml_pmu_set_usb_current_limit(900, supply->usb_connect_type);  // not pc, set to 900mA when suspend
+    } else {
+        aml_pmu_set_usb_current_limit(500, supply->usb_connect_type);  // pc, limit to 500mA
+    }
+    aml_pmu_suspend_process(charger);
+
+    return 0;
+}
+
+static int aml_pmu_resume(struct platform_device *dev)
+{
+    struct   aml1212_supply *supply  = platform_get_drvdata(dev);
+    struct   aml_charger    *charger = &supply->aml_charger;
+
+    aml_pmu_resume_process(charger, aml_pmu_battery);
+    schedule_work(&supply->work.work);
+    aml_pmu_set_charge_current(aml_pmu_battery->pmu_resume_chgcur);
+#ifdef CONFIG_RESET_TO_SYSTEM
+	aml_pmu_write(0x00ff, 0x01); // cann't reset after resume
+#endif
+    return 0;
+}
+
+static void aml_pmu_shutdown(struct platform_device *dev)
+{
+#if 0
+    uint8_t tmp;
+    struct aml1212_supply *supply= platform_get_drvdata(dev);
+    
+    // add code here
+#endif
+}
+
+static struct platform_driver aml_pmu_battery_driver = {
+    .driver = {
+        .name  = AML1212_SUPPLY_NAME, 
+        .owner = THIS_MODULE,
+    },
+    .probe    = aml_pmu_battery_probe,
+    .remove   = aml_pmu_battery_remove,
+    .suspend  = aml_pmu_suspend,
+    .resume   = aml_pmu_resume,
+    .shutdown = aml_pmu_shutdown,
+};
+
+static int aml_pmu_battery_init(void)
+{
+    int ret;
+    ret = platform_driver_register(&aml_pmu_battery_driver);
+	AML_PMU_DBG("call %s, ret = %d\n", __func__, ret);
+	return ret;
+}
+
+static void aml_pmu_battery_exit(void)
+{
+    platform_driver_unregister(&aml_pmu_battery_driver);
+}
+
+module_init(aml_pmu_battery_init);
+module_exit(aml_pmu_battery_exit);
+
+MODULE_DESCRIPTION("Amlogic PMU AML1212 battery driver");
+MODULE_AUTHOR("tao.zeng@amlogic.com, Amlogic, Inc");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/power/aml_pmu/aml_pmu.c b/drivers/amlogic/power/aml_pmu/aml_pmu.c
new file mode 100755
index 000000000000..6f8840a561c1
--- /dev/null
+++ b/drivers/amlogic/power/aml_pmu/aml_pmu.c
@@ -0,0 +1,214 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <mach/am_regs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/aml_pmu.h>
+
+#ifdef CONFIG_OF
+#define DEBUG_TREE      0
+#define DEBUG_PARSE     0
+#define DBG(format, args...) printk("[AML_PMU]%s, "format, __func__, ##args)
+
+/*
+ * must make sure value is 32 bit when use this macro
+ * otherwise you should use another variable to get result value
+ */
+#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)        \
+    if (of_property_read_u32(node, prop_name, (u32*)(&value))) {        \
+        DBG("failed to get property: %s\n", prop_name);                 \
+        goto exception;                                                 \
+    }                                                                   \
+    if (DEBUG_PARSE) {                                                  \
+        DBG("get property:%25s, value:0x%08x, dec:%8d\n",               \
+            prop_name, value, value);                                   \
+    }
+
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)            \
+    if (of_property_read_string(node, prop_name, (const char **)&value)) {  \
+        DBG("failed to get property: %s\n", prop_name);                     \
+        goto exception;                                                     \
+    }                                                                       \
+    if (DEBUG_PARSE) {                                                      \
+        DBG("get property:%25s, value:%s\n",                                \
+            prop_name, value);                                              \
+    }
+
+#define ALLOC_DEVICES(return_pointer, size, flag)                       \
+    return_pointer = kzalloc(size, flag);                               \
+    if (!return_pointer) {                                              \
+        DBG("%d, allocate "#return_pointer" failed\n", __LINE__);       \
+        return -ENOMEM;                                                 \
+    } 
+
+#if DEBUG_TREE
+char msg_buf[100];
+static void scan_node_tree(struct device_node *top_node, int off)
+{
+    if (!top_node) {
+        return;
+    }
+    if (!off) {
+        printk("device tree is :\n");
+    }
+    while (top_node) {
+        memset(msg_buf, ' ', sizeof(msg_buf));
+        sprintf(msg_buf + off, "|--%s\n", top_node->name);
+        printk(msg_buf);
+        scan_node_tree(top_node->child, off + 4);
+        top_node = top_node->sibling;
+    }
+}
+#endif      
+
+static int setup_supply_data(struct device_node *node, struct amlogic_pmu_init *s_data)
+{
+    struct device_node *b_node;
+    struct battery_parameter *battery;
+    phandle fhandle;
+
+    PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
+    PARSE_UINT32_PROPERTY(node, "board_battery",   fhandle,                 parse_failed);
+    PARSE_UINT32_PROPERTY(node, "vbus_dcin_short_connect", s_data->vbus_dcin_short_connect, parse_failed);
+    b_node = of_find_node_by_phandle(fhandle);
+    if (!b_node) {
+        DBG("find battery node failed, current:%s\n", node->name);
+    }
+    ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
+    if (parse_battery_parameters(b_node, battery)) {
+        DBG("failed to parse battery parameter, node:%s\n", b_node->name);
+        kfree(battery);
+    } else {
+        s_data->board_battery = battery;                                // attach to axp_supply_init_data 
+    }
+    return 0;
+
+parse_failed:
+    return -EINVAL;
+}
+
+static int setup_platform_pmu_init_data(struct device_node *node, struct amlogic_pmu_init *pdata)
+{
+    if (setup_supply_data(node, pdata)) {
+        return  -EINVAL;
+    }
+
+    return 0;
+}
+
+static struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *look_table, char *name)
+{
+    while (look_table->name && look_table->name[0]) {
+        if (!strcmp(look_table->name, name)) {
+            return (struct i2c_device_id *)look_table;
+        }
+        look_table++;
+    }
+    return NULL;
+}
+static struct amlogic_pmu_init *init_data;
+#endif /* CONFIG_OF */
+
+static const struct i2c_device_id aml_pmu_id_table[] = {
+	{ "aml1212-supplyer", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, aml_pmu_id_table);
+
+static int aml_pmu_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+#ifdef CONFIG_OF
+    char   *sub_type = NULL;
+    struct  platform_device *pdev;
+    struct  i2c_device_id *type = NULL;
+	int     ret;
+    
+    /*
+     * allocate and regist AML1212 devices, then kernel will probe driver for AML1212
+     */
+#if DEBUG_TREE
+    scan_node_tree(client->dev.of_node, 0);
+#endif
+    init_data = kzalloc(sizeof(*init_data), GFP_KERNEL);
+    if (!init_data) {
+        DBG("%s, allocate initialize data failed\n", __func__);
+        return -ENOMEM;
+    }
+    setup_platform_pmu_init_data(client->dev.of_node, init_data);
+    PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
+    type = find_id_table_by_name(aml_pmu_id_table, sub_type);
+    if (!type) {                                                        // sub type is not supported
+        DBG("sub_type of '%s' is not match, abort\n", sub_type);
+        goto out_free_chip;
+    }
+
+    pdev = platform_device_alloc(sub_type, 0);
+    if (pdev == NULL) {
+        printk(">> %s, allocate platform device failed\n", __func__);
+        return -ENOMEM;
+    }
+    pdev->dev.parent        = &client->dev;
+    pdev->dev.platform_data =  init_data; 
+    ret = platform_device_add(pdev);
+    if (ret) {
+        printk(">> %s, add platform device failed\n", __func__);
+        platform_device_del(pdev);
+        return -EINVAL;
+    }
+    i2c_set_clientdata(client, pdev); 
+
+out_free_chip:
+#endif  /* CONFIG_OF */
+	return 0;
+}
+
+static int aml_pmu_remove(struct i2c_client *client)
+{
+    struct platform_device *pdev = i2c_get_clientdata(client);
+
+    platform_device_del(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_pmu_match_id = {
+        .compatible = "amlogic_pmu",
+};
+#endif
+
+static struct i2c_driver aml_pmu_driver = {
+	.driver	= {
+		.name	= "amlogic_pmu",
+		.owner	= THIS_MODULE,
+    #ifdef CONFIG_OF
+        .of_match_table = &amlogic_pmu_match_id,
+    #endif
+	},
+	.probe		= aml_pmu_probe,
+	.remove		= aml_pmu_remove,
+	.id_table	= aml_pmu_id_table,
+};
+
+static int __init aml_pmu_init(void)
+{
+    printk("%s, %d\n", __func__, __LINE__);
+	return i2c_add_driver(&aml_pmu_driver);
+}
+arch_initcall(aml_pmu_init);
+
+static void __exit aml_pmu_exit(void)
+{
+	i2c_del_driver(&aml_pmu_driver);
+}
+module_exit(aml_pmu_exit);
+
+MODULE_DESCRIPTION("Amlogic PMU device driver");
+MODULE_AUTHOR("tao.zeng@amlogic.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/power/aml_pmu_algorithm_lib.z b/drivers/amlogic/power/aml_pmu_algorithm_lib.z
old mode 100644
new mode 100755
index 657b90013b1484b274512826f51df6a2e6212273..6f4add40d987bdbe68a95774da9b25e68baa0883
GIT binary patch
literal 114319
zcmcG1d3;nwwtwB*x6|D>O>#Tk4NX#n3!RVv2{a*)us0A$SQ5gfh&W_r(LiDn6kH=a
z3S*R21!;v*RK`JEMo~11E8@tE8?MtK_K1!%!>BWZPoDg~r|Ncy&U>Ht{`fsUrn|ni
zoH}*toKvUj)@^T|G<~w7C@lU@VcF~=VytAEK=yo5A)Ae5qZkXZ4rWF=SSXC|HL>&y
zgWE+OVYXFZ9@-mYCemzHN4gm~hI+4PW^2red@bH4-YL;TTg__wb6OYiniyk|4(iVt
z&i#^w%1>*Ir7kh{#+I<Xu^%s7_%mbC4rj~JGYd@g&+f!ud54`bop=eOUdhkuX~tI6
znc1PDj@wETO&{u-KdZ|^t7Akv&Nh9U_$$ZX*%{y`9BD5Mos3OCS$bM2kF+}@tucko
zCfcct&F^55D-T1OUs>swh~Ks72eO3xw#Do$(#{*U#ZI-n*lrxUBW6}?i=AEjR=d`E
zN6go9N376zH<lmW77Mg(i;Xt6#Ihq>Vw$ln=8kNOoh*8*Jp*}xLtA3!!f&;YF5eR~
zTerkQEn8x&0re`j#EkMSF<*2`jJIux<wUl`+~}Kln0|80>9e=XajnEy&P~Et!2fqG
zdt;pKiUlfmS+bqmkqkK{fKR&-X_xXY@6a*6KxkKt@|8%WgNL@p0-=qfjU8h<gnkZn
z$`a#89jebDn*iwXFwMc74nNJ4F&A?hX-`60&~GR|oe26I@}YblTHi@`9_Y@q=n|h)
z-+?;k)*U^=!`ouKVuzsn<%J8W@p6*A9rTE=0NV3TzM>t}j`T}@GX~z+dHk7}w6o)-
zOw6nI#*}cRU9A8wY$xcKcQ`>WE(^{!fKQfs9<<L}v=gC|XKy)rhU$DB+8aA*I5F<6
zQl>5CrxQ^B1nR%rIhLKGEZ#0qzA=^ndHcdrrh)Lz*sgNY?>Qaa(bkDFC&sf2?E@|A
zL|e|bi*J${_08BN9d_`Ixsq}P-ww1*K)Z7EUGcNN{T9!>T*{sLXKZfA*N|nrKi;x7
zmhrQ8q{Fg5#>i(BL3Z?S3BFtL_XPeL$ac%oZw2@b(Hzb0XlOa=<ZOrFIS`ifMs`Da
z4Pha>uL95kqEGcfM)yJYhr$=oT$3#R3EsZBZ~^v(fAA@yAM#1j)>utNq=V+o*S0k_
zy_eRZg<50d4f0o!4i&uY_+7u~H5C{BWLvUc=rxU3K^e`NhO}y>N$+h)$9XbnETAjq
zzYTsYO8nuwE!>fWx|+EyRv3C0{DnKr=;qEj;o#jwnPH9X9Q=pU5^2wG#JpCJKOo(j
z-QmJGHP{oSp(nZ+udySRVeX8nY-YR0cGyYZhQhC$SD<sAy|HsMq`V44??V@N2p=>M
zb+SQIF{`4H2-)5&`0lF1woprS-?%kVvWsJ(Nc)|^W6>Vy=Wd%ldVB`>XpMB-egAFI
zF(X;W2ScZJxY|%>PDWJE>ejK(Ebd4=v^IL@)OAsnHMiT!pNz8bL#MaS-ygm6@`F*#
zafcS(jqhKb-a749(TrfEJ##30NABwOaNGN_3}ZvA=swcp1syi<cPe}w^13r>5ABPd
zGmp2A1^+Z|_=QvxW6puz`(DKQfpKSmM;f1s@;)@S^4+k@nrM!(8ExituyD=cQ|1Zy
zsg~${y>E%Wh`HD{{*|a^&I0{opnsy>3z=m=CT(qdV>Zwv-&SZ6%~>68i>5798O;FA
zV>5!$V>61PKc{(zrbHFcd~uwlX-Iu;w=?!|oIjtr%icVe*&tg+a|j#*?l={GO~_kg
zv%u#&QOMw7X2AcLueBSH4g3mp8DlZuI}KYn;<IQY{Sh-GSTkkaZ1|jWmj8C5kk+F@
zOD_w{PhvcCg^wm#f~M|+?&q<Ipji(6VGpN=)||G12PG7FJP=y@WMRwEr`>E@tS)p1
z<Wk-aKXH7N(Bauwqgm?8KJbCy6Ln)DV|5Jm&lqj6LGZHxI_L(iP^cwV6N>CZonN8+
zfDiPbbM0~Z3iJs5b?lE~-oQ%|%4m#-fGLfBjws;E-M0C(0lvS3Z70L-6pW>XwM5s1
z)<iwvh0VMrY8!G(bbs6S*nX_v2cr0c?^DgXsAAMb?;CeZG>KJ2g>Hw;DA{R%t&JTB
zZO7PJqLe27Nk;z_y@Q~4@P9$?;LqqWMe=nJzUM%BYixfT{)j*L{iO1B(Sxw*UoBiG
zczmTi(th9HP#?DVI~HjtdnEpkg=(XB+9c16t?T3!)633beiitMZ8Kp%Ve%K-V{Xe&
zpjh|`@;xMD@@2FR(AdTJkx%gk&ACB(ins#4q@x?;nQv^5g<)e96T$bS7FO;>+_5{x
zD&UhFDx(SP()M)5Mk=9+rwbWu4LZP~r$npJ*!~`T$45ltJZy?+&>BPZ6{Jb`YhYWL
z=hRWiqjLChl<$tAudhy^4QRyL8ql_l`mBt)*(K1EHGK=&hD`L8iTVQ+=wu;VH*BOu
zgW`s2=m=<hRA^FPvpO)Y)EeX&q3wR~nqq|3`Kuud;umFKk$n>{G-mS8<VPruiR(Et
z*ZRTlS40DPd<^Yg0pG{ThM?z<13x(q?FiEtd`!ktB<FLMPp5gJe<3t%V7XtmgemrI
zjcKqIHB=WJhqhsJ^Gih69jdbM^p{4LZ;Neyu`WvMquRDP>Ik_{JIu|e*UhYrlCM<T
zB9Ga|u8W@N16>&cJ5s$JqcJYUT%Dri9rJ4DdjIIqdOyDHs?FO$`DB|7Os)&W6UD1O
z#HokoNc~Y7BJHChCo!MfW2~hWF(u-|pXrmMiyn1NlTN+b8*3i)vD)G4c)V9h$N1#Q
z9j79%w6nHIhw+8l(K=vFlzi45Bkzy4j>6giepC}{LulXWI|lBH-k*uJ+1MHDz1`Wd
z=DOAGf4*Z<$Gr|F?Deigo1&P<SPf_ept}#HMA{#^b4_%&QW+gWI@G%9r5Tt@pRo=x
zD0BdNLHb59WL(cEhJ;V~$|v>jcwFc0sKc-pD@GM$JF|lsm4_4XT?RV4Y<sb1*dE*b
zIO%e0ETOG3O1>wO+!AeL3)&~c4qRwQwnMt-f_x~}u0cDcb;@ayixIjfMm&?f7@^y+
zA7Wpr#!}G+Jbgquh_=V$ZF5B1O+Rb9MzqEH^p(mkYlqHu+AQg;<<}pM)A(AY{^K;Z
zTm2J_bz;9@3n^G{XSO50{ivE<Mls}ZvH@$aqQ`9jcA`7sCnhJ)COZ-IX&z{dM1Ldt
zkz@R6AJFHoNNx&j7pgWOT(K^uOItg>8vN6^<2FaJGx2?q?v&H{UFb@=t%F{Yzq(AU
z5g`*ifF5Lt^_pyVR!17><Rd?d_=n2ihf+i49U@(b?*vvA#r*3U;$F~PU089;I@s{K
zfsEaHh}sxbcV>GgaDeoI&8EH{HZTs-i{9XwcqznK$cOa87>S=kbNhQFN9w!A>YK(C
z_e1c1I?X@LGw7v`0>8wc@O$8k{9Xv{Kqr<#eiwWYujJ!|->cZ1iT*Ol@2QX{`X4sZ
zqCs)m&;4Es`uOks9>qJbiPShh&?n)WNq@;7#%+aspBjpI!23`9AL0|~|IEnaD1Qv~
zp0u%f?XWrFH{Fpvm}eok)Df0%#9WL02F1GMA1LmPuSNOLrI1PUC48#4uwu18KeXE4
z)vxAs@vA=Cr&_Ts`7ru74?;bNKL+OJ;O_wb$lsoIV0|pdx`%a_hxcGF*cuz#ax&%)
zuZ@}wSc_+@jV72?QBdf3xh>MZTTQ^)7HNOAH}-`XPXzPf2vtY*;%*&d=Ch7{;o^=D
zW>4+dZF5JR5yZfYUW;z)w+1@Z*lrI!4&Qd*^!DNRN4FI`Z27jkg>T!QwJ+M&7HJQ9
zv2W<s((Y#E(G$I2jN%mKD+PU1UzlsGDZf8G95GLX?5icx@$-J2;Bo7J+vh>6Pw7v8
z-lvJa5EY6(U?&epTF{5taGHhMPqPU6T8uGXhcQ-Qj7?KJboBN5UW~D1UGz?u8r>Dl
zj@rvNMt5Yafs7j49b&u>pWc~&e{{#NpZ2{o^QYs5-lA{xWwf6@>o|Ib&TeS!DZ<*r
z!dSa7N904Y8O|wa--LY<tAMT`M&+&BVmTF9hs>=pGXlM7K|XAU>=+9wzRBN)JMzT&
z)6Q6YpM*YP=aF{WD^UzYYYpMfGYjm~vMcr=#t3(m57#<Ob9d}%_;}I>ieoYuyZa#g
zFv&*vH)HK-A7qxq?l_Yf#rXyUFKtA3ZEV+?H=@3Z?J=`_8_u@CEBG}qmR-v?M144K
z3AD-e;NDeP(X$nAwV$haQ;b&w4T{a;`#_D|hW*fOu^jWZm@jf$%)nnh){7CLmt#fN
z`HaiN{yl^-x8OXd%XrS(-fG9bvm?J{Pt0(rSO>SqUaya|pIq}+dqM-94fKn;Lj9uE
z8(bZ)?qwYb*snOS2YP%D*6G_Pcbp5p)xN80LlpMeaaZF5(OpfCMp*;m#)^CK{ov`l
zsvnF#upRsQs<+xV+`Xy2)g{+uPO^<e+Rf0mShlez)&jrnPS|oL!@MV!gLRK&XBziF
zPAG5K6U#<^1?o7AO6V)bfPAV${?<TQiRJg*$PXh;YqS%6P#xNz`ap9k=9b1qw!>OK
zJk46S#q`LUh%IvEp&G1Z39u(RCm<gPSCD$L8nVIJ2W$A?^kCQ*(Sc7oQe!~xAwxmC
zh4gMylwmIr&u1-RG50=WV+?B_&aAFH9WRsoMB53o)=g2O!&=wISSu54SZlbW#;82)
zGd4lTScl*Ny2dc)w11oqf1hC9i8<I8t$|(AUKBe0QH=?D&<Xg}m@jk-*1Ndf%6Job
zPm<nKyh3_!Vy|@yd&RTnTkSra2M}L0Co~@!<_65c2KW-_dMk7t<9Qe7JSNWFTn*Jx
zlKqb4OQFkbq=7bwe<`jwf>^hsc@X-5Zd2^$gFku>KG<lxC3dIH7Ckl?`UKwG<}IQ>
zq62w;<+EsD?K@8G<T&u%wl>y+_UBBTX@UmvNNpJE=d|q+dqvp2S1}`4p2FUIv&D~e
z#|ZOf)BztRoeRtJwhZIWST@f8a?CrSJL{!gbXgD1Ltyz3<a7ATursz2e-Zqh#9sy!
zqXK{NbK2=o>_vNdPFtiQ?X%90p=0s5_kZ#u<WGpV_?WU`uNwXc7s8&=yVQpW{9HV3
z%Cn?=bBn0QTI6{WwaGUzPq0@Vbe*9{`xE4Y5NkE!T&nM`NPDP4wh6)3$QMu@DsM$S
zYHvnyHf+E*LAG>WdIPnO$~I(E4ZvM(YWf(hV|*wKJDE>=d|@{gup5Z)xDDS}Mn9?!
ztv~%L(mfFu<y-v(8n(sA50X#JX@h+?U{8g9cWr<#WZPq;3mK7nVovbpX3`fL5u81@
z;mjKKL!mt}ic!fYl7H;#7w?8H(OIU0#@2e#&lwM@LYC)jWY3X~(U2ASxtHMQPQibX
zpHo}<MQyF{b6N0n<KX97=0zQ?Z$!rrp4{>Hn39fjtKVwBbBXkGTUS01y>nH>@^h`i
z&uv}$V3d5^11lo!8SteWuiMam0DkXoYac>$rGY1kPpMCmy|cxdNBASGt@<hW8^pcB
z-$15ELS%dJ0kqaQD>h;MoZs$?Y<|yIvH2CK<yWB!nsb!Ho}HmfXdR#EgWdWn?h(F-
zViKBL;cMWZ;@F3^f?`L?4>8c_;(OwLjPj{1`5}t=$PcT=>eCe4!c>lv&Fh$B4Qndd
zZI?Y!DvcxVHxc(9hCg_c{HAJ7z`4=vcGQ139^+yhqJDhbin-=~H59oIe(YCW_s`U)
zi1oU}kG|IJ@bRz#1N*<|J+V*VE4FTWBkGK9iEX+%(!Q}W(thBk4eic~9Z^@qgHgwe
zk@kM$Hn%6>dvs_^tPuJ`ye72l!dyQTJ==mcwneV747TjF_OM-TnS4_Q>@<h|%zMOI
znt^pn$O``M>46NoKf8TSXzzP?cJ&UPUA>1fezY;Di2Tu^y|G;6kC)H2I@f3TF&2T3
zc@BS=Xy$|hl;bag#=G$SI{ubGa1s2`zshBG3mcZLSlC#*cxh8}ZR5h4#--QPHg@K(
zSl(GuU0GLGRat#iXW74(T%@<6p{BCAc46)E+Q!AJWLM%D1|`3=@KWo$1cIS|dGd=@
zSQz#${@sdCW$5MQrE{;yY|1ew&6+i1*2uEC)2Ew~S?JHdm&+nEv&mdi*<@DMHP%+v
zm=?!1de{1O^-ay@(q#?xjm?$Io6SWlmRC0~tzX_mWLfjb%)%8pX5+$Z>gz^k4z0;C
zCoZfWnVByVH8L@2Waf}iT^+KTMrMZcR_2(C@Lh;+h-_qL9t!F&wy$5fL^i9hzD6dN
zR#l=KB6&?`YRN(r=7G_ljx9b1G_KC6p;}$!)3wg>dJJgk@_(a)sjRQY1ewcLG}o>)
z7ga8;s}+^H(CMtxN$_H|cz>Nm;3qCz414j&%!Z%HxNE(o@#$D))~<xobsb~Vil&Cz
z<uzv5%p|Figh;H-mCY+4TX5Kgzv{~6S<U9++Gex5ennmVvMTys4jm?fR=r?QXiG4d
zV=k{ZAzc)&GHYt9o9Vxc^u`V`rN+{fEv;&VXmZTvWep4KufYsTR$wDd&2k=*(OFLv
zOFb7HcJ@6s@Be`2(EkIP!~PFw4*&m8b9(*q#b)!;WwoZIB{0j{CQN^PUd*ahCd{<C
za&c`}or=#os;+1lNlLYF(TcjdG4W}wUDnXNN+4ZM<Csig%v3Q>S`?F?w1_RNu51u_
zmg+66{t1F(=v3cModvBGU|y<rLu2hV3#;KtP*0?5WLj2=msrRuliV$=S-J@R1?`qD
zHydgjt816Tdyw&3I$v8?+0ay50}C>nYOCv)*T84eSg4ygUo<c<BOv)lh>duwUqr1c
zo8uDh<h`pbM5C_i-^Jd{>Lrzpi)$M%nk?89P7VA@?<U+#oL8E@`21KrG}j9r7Qs?!
zX2DjDxumgkCPeS?CULXFd|e#>MLmf(uY^a5H=)s1)z&VDpRcR4*uCfn{^zzeOPk~v
zYfNw|bf?Ssr!TECt5z(nYZi(+GE*!f!9sI(X}LLPMXgy>TWt;rnL`Rj4$T`GDljL`
zo@3^Ph766%!)$D>Ubw7wnYDh%RpjDl=X{t=mDga3<Aah8QrLs#p=dS1q{(HanwG3W
z<kZN-MOm5ED;gW2KxS1vR*E<oQ|OCW@&31TAnGnt3G1k=UfR6MtgNoCZ>(7g!v!;4
z<kZRd|7erYTH@`e^Z$Qjs2A4_^Cz|@+ySiyUGxoR`(M}|EbgL0cS=F1bY}yz(}3er
z_zBsc>N?4c{@q~3L=rLftd*EzeGj$D-?6aE!ux^aF&=n>7%9$KSOX`qs<QxV=zm{8
zroRXp-6bgOG=BJ$`l?#`tgdZp>ZFJA>J@bq|5+nkShZ>)=yX<CRNuI)5?oX*URbqa
z(V{M-rOEyqMa$#=TmFCDzZHDOJCDypXZKb)jSNcOnN4E&S@>IBS6lgSF>z<y`?JcO
z0a+uKhyO*a?0ihQ<<KFvmZnUm7m76DLx&Ev_^j^?>$}|guCTrvtnYXuALjhfZ&F%t
zaL;g-&c4Iu`Ou+*En$tmA8y%ieY>$2ICSVh%N%_F#`##we(VVz!uMKi<{rU!J~mm0
z4&C4KGJXF>YuS&7FozC3&=SVM{-NI(EzjX$4SkPCAL3u}#EB!#?CQq)rl#il`nue*
zVzX}P^2)~g+#!R83>`EiH-At;F1fiup}gGC5RnY!<qa`&&FP|^2@1jwqC$TYwFeCq
zFq9V>W@f_$G}dAwnri#A@q^G~Wo>2EQl^kx>;<{wS%U5u?^IlBisn=NN)KB=>8Yfu
z>1tmEM@x)O<{87-t$!uhBgg*@y{EHWxe{kjN-hj)0^~sd;uTe=qhtb3_ci;{<;_gh
z952rRJq?NDsAV6GkJ<Q3pbv%0YezEX&?*3(wfImK=R=bibM1lLoVL{M$kH=%L6B2Z
zHOTZjY)fsu<_n~;#CZ_7=8X_k64s4lEU^znulWv(9H)|noR%Wwbbpz0RQs4=$XPud
zIX&JNIgUtQ<m^PRTF)HhBz{_oB;C+qi4Da__WF_PIqeuTOC*74>6!R+Hx)8_a)eSV
zkTR%8chivJ%$`DBxmQrqOMSSThUPK5pNP9xP_jD_cQ*~sXZ8RQcdwviPommQX@p89
zQC*fe08Aw$-G~fTv#&2ePHBJSqzN{cL(T~y!DbfbEdeVdDkvCU!bFi=PpykY-E~lf
zgiEQb#HKtX=TRq#Ge#kKnMh8@1~Os3sO!!~@^VT#v|4KM3y^fU&rtFRMB_+4M~!i;
zz#J(wyu|+C#Nl5{xn9hGBlQbPK8bC!qt{4OQx&xga!X7OA*c84RJgJ)lIGo%v_st-
zxzAEkffYH1|B8}psi#qgC`lIz9g|+A<d`xf7kx^d=0aMID<7ofUOSR?g2A4ce8<(_
zQtlcI)Uo<<YBqtAYee!<=z?R9kWV4T?6_AXf5bdH_KM_c4BxST5;dDQ0Lcgcgb^fb
zj^B8pc>0eJq~j0?2fD}-HxC4S>^y3?3UFNQbUaf`wN|Gh`v@gTWBWqPail@0>Bx8e
zp6tSLbO}{AuyQ$`ze84Mu78G!(u;&8rI)NC{Yv!Vcxk7oNR+6xL!(mH95*%k{i~gg
z{y<6UzP}%p-Z>=@HQIwzH-&H#RYA@Pd^xnw@o6Y>-p?ZKQS3DRDyB!6tAn{FPJ*sF
zQ;LzL*Os6|U)(A`gpN2<EvwYQCUd3>^9nlk_aSnpDUr@xr_qqRQl26rA3>*G-oKNM
z1X&7pv&`j_NE3$c@=KDEh^xEo&aH2TI=Olf2{mZwA7QfM$fx(8eh~#QF5=c3?E{v2
z+@tsw;nt9*r+to0{{fnCzkdW=k$;Q>w3zFasf_vb>;h<%o{8z#`@bSOVS1DvUk@0A
z0yU`V^TB{VaFIYx{a$E=p3^9hTmL0ANY7m>kO7g7L@y4FNOo6d<CFf9=Hmmom*J}i
z{2#soH-R<9p-n{E5EUI-9n#$tB9%l`(0~rfUDrXQG7?ki#*6+v`Mk7#NYZ4l0ndqC
zB2BNys1tih<kYXl1L(wbJO)Qix88FsP;ZG0eInE+(Ui!iA0nE4B?{;##sg&(iXOQB
z5af}VDa%YSN7R#OUc?7DB(AzCR6U-PgLJafeReLsg$23)PPPbsS>nfIpi<wAMM+|}
z;b^#p%*^#;E>tEdbsIGxho6)t^?>PnvFIf6B%v{+&3B`UYkd*qkv#ee%%P~Bj7Pvy
z9v|XTYw}pKIGQz5o8)msl_YRElrK5_7cU`0Uor$}{A2_YYS5R`RKt=d%n~4=r@{dx
zPrOW2<URYrZ6p_w>S#)DHE8xc*B2R+WJWq=6ro-6WSP;6GKOKa$;C2*Q%02&86`3!
z4H+27Rp82@(GVP3Jw8*(q;?rUsJEkT+M<Okm|?T+T0-nG{zxixM6*3Hlc1Bo2IVjk
zZ2yAhV<`MftcixhcH1H`7XB1mjnU1v8Lm+c2KbXnfXOy8bT!ENxMDz$twIRJ<fEuG
z#YU{D!3;hM#$kAECxyJT`Pnd_&vvPRA$}ta-SFF9Urdz?`4?CrjqbMdlL(gc6fa;8
zTS)LckNe^Mjh;3+^DFsV&^ROA2F{r+*rM>F4B);tnkrjxt->`LM9{*U75+Y0GBRxi
zaOJk(HU(1J4#Bua^~03_&*z&Ehv>7xo#%_VOB!kdosme>{{u{Uz9v~hV0w3$LL9mE
zG7QJ_*C)XMDZ+X9OV2-LJFb5M;d%a}6n-Alq|XAko*%x!Z4wAa{{Zs#oR>AT`F2Ro
z<5KPcgK98`_w5bnQKagP=6gZG<5iA{(jxvir0(giye(h}cfx^qdMc9Cbbj0en5Ha+
z8jv9U5VMC1KcWWbFjpE3#hr9R8;yA@#-DWKM@W+SSA(;pn=S~X>6f5h(#@GzT`*=i
zpJf;))l4D_NFr5B`UaW_Q4%RxPHnrClN}{hp&cqkMJ4iHsURsUQ3^#SzMN8n?MS-r
zN(N4G%|TlK9u}UW)ACImwu8fzL=n;i$$kf-iv0|TT#1Ag7WVqfWX7Jhd3Eg|1i|}3
z2fc~f`$DZ4KM7fR-5MzlY?_ZnSKe+KxeYP}T5P;Yn$%x6zXsFiO}3!Hb;#SBqV)hv
zuyTG6)WGZ2q$vb=1oHCwEy(%%sO9ZpL6hGPd3C}Jo;IWl%;piu$Q!Ua%Heydw5QfC
zcn+mC)iQ6Y_6P6=J4tJ7X5KXIT9ny>r&PWl)9cOE4r4&J;8~UD5?6VGlr8w3%BNHL
zP{D^ScuwW-LU+9R+Fzlkw%~b{ufV)`Cu$of5N@&Y+d#-WS%ew3V8q5(!jilt+5w2s
z7Cc}}TeggOr)i|pw%~I%J{*GY#BH|pM`@g;qI)<vTkvHY|B41T+v4DL8$U~<n`7Y<
zHeN_VkK>azem{+1u2uf7jaNb6yq8!bI%VT!PzLX17XHMRz6Q49z5HUAQCs?|0mxcl
zWu@DK$Vwnae_>_y5?N!XBCFEM;v(z3hO8PZD@|n0#v<UYwX#wvE3IK^4f8J6dSYO<
z;O91O(1?~;_>7HjgD|~KLjP>RuWg)G4sWxC&)WD%(v6jtjK8yS3PHT9EPUR^f5CyT
zv+A$a_}^*HZn4TYYWx<G&}s{}YW#VuxZZWz*Fq<DX?!cG;(Dw6IgP(VbGT9SW)i<I
zYy1Zf@FuOBz^`k3JE9Zstrk9k{)per+6CBwEqGGnA(%%eepllU!ooW7DUC1c-UWYx
z{>iGgSnZ=4UxfwPd%JcCf(FP-<H`Mi@7Bm+K|UIPf#ea#XEpvy;_n_|-Oyo;-wt#2
z?zZrGjepn+_+G31T00*GW$wfq?Yy1j7136U{#xzan*n^EHpQg=B6hArd%gQLT54>;
zr|sNL8uWmLpR@DJ#{(bGa&ceF7HqTgkEa3u+S16Ac0RSB3x3zmza@STX*x6oHfiS%
z(s+NXy_iDy6MNdCCgy!c>jtUWf@kdfb8<<~YCQ%1+Rnq^%X?I#9UM&9&fo3>{DRh7
zlz(UEOGumBv`m4|*|}B<{F2rpx;t;@za({t<FyI==oH{%R{7=x{xO;O%i06r8jD{7
zPa}G-TH@QEz#B<jUem}?!^9K#GQ<wv*R@fizk><<IOOPkL-<Tv@K6Gui>29nTpKUS
zpGe@dsQgWh_5%=S0tfrd`<7NJ%AZT%SqM12f6&$m7t)r%t7yFMX|zj%coTR6sn`1!
zemQ|}B=z}FqmaWEd_94?QPKN}Hc#La3H&NDkEpgq&^wvHCzAS{)-DtMol4**NIg`$
z3=Td?;P(?fyS-MFM-%w_v<A5BR}1`k0)LPA>t?@E;4=w)9M*YnvVD`lUnlTsBp;7`
zyTE4?_&LNPUavTgfO;nIHUuMHpZy+DelCF<5Tw^{zZLoo7n{Hb5r5fsvKoOuNC3{U
z%V4F&!P7|{bM23d@{NwP#_AQ!JKj!PEn9H2gQwDbOt!xu%C|ZAg8slI_Az->zRSUX
zp#J9AX(57oJ9r+^pKIa$4&E^y_!5iX0}eil)VIRI2Oazr6wg~};X@9rtF)ZDdP9vg
zU$>8;-1?=kFki}GOav{%v_tiIB~n>$&6oHesAO)-LbjWx)y&0Q`TU2Gi`}nJPXz2k
zgwUEL=BJ~u2Q@)i8dcSQfhqEFN>Yu!v;ZgWgP482x+BjOhQ@1tA8CLdfHC_0L{SjC
zjG#FNu(#$Pe=WYv`{BO)6DW(hM#9E5f0%TsPc=S78!uKI|8%OGtaVR(6yJhscXwXA
z#<TDU-Fxf=3>vT&7BF3Z#nRvo^h<#9>o!O%kWKyz^z^D3K>a1s^m{Q|fdLXZ_1%c;
z0y)nJx^CujVJZSWL$n*vhYV({XPyi_m_7{)XV0NB%+~bnQ-Shj_~#VT?>U^p845A8
zK(glu8Nv9Ni}n{<YM_}&KHeAMRZoi~bN%N8u$<Os4;7Jw)A~yKO#c$Pl@^rraSrx=
zPrytf;i7#_e)3-0*yuA*D>))-G2MrNHTgbC!Kn{}2$Juo4HWH$Dhq-3Jq;~UgCQu;
z0V4GT#OzD1qg|2yI<z8rSq+jTF^WNxmtQH6reA@HPOh(p04TZ++JPEcMVVVfp~+W2
zAdmsV--2*p4tm30cRF&rDMV9*lPH~sv_osar;}p(?#enO=`UX4HY%d+yF*)nq});y
z^>~FHNN0?N|K8|KZvF>=z5(7Xc?Bhj^FC0w<ZGm<wJ0e#RA<T8+A(h0cIfjkHOVVw
z=~@r7Q-Dl`A~fyI#F0pM;LO=joeMY<d7qRj`TA1i=|5r>O}?QDN$Q9;uE{s976|$P
zT}i&_*8)*6PF+yVB$_A5yK^zHLnBh%mH8;Awq46Ni1KBkoZ3J5lky~jXnzm`bsiQ~
zw}{W@@#!R{T{n>}@ubg?)^mm-wiZb+E01O=q!a_C-FO)lA45*RR5z0Mt9FdeP8ohA
ztZK<xuc{nCL9JI65hiMhWl(`$Ra7x669d<JU8B?k_!s1XMgN1CS;hY+h+6eeg~HqX
z_re5he!MaUQx8Em?97!2^(;?M@ndNela%hIxgf#5istD)TI^_3zYiqS{SrBaNv3y~
z$gP*a38eRs+f_sV0)*285(V@JKrOwe+>V;UxYAR}HK@Vtl==pio;DvntHH4T78ptA
zByTlXq|=jwbW_@H33H{Rl93*yy5ck|J!8FS#`G7V80ndN1k!}VP49P9Ag9>1rDvTI
z$c-thK*~uY?JjnC*CCZ8K3b4MImynU5$8CQMOHV3=*lX@3bHpNL$;<)E*2$OB=(7N
z8U=NGu^dg0A;Tep3D=k8ih5^VK#u-M7#=x$C|Zaq{R|;!@BW{oBs(%5?3#o62H>g_
zO?(V4hg4XiA5&qD(vdCfWDF8QPm)>SuKvQ{Da)1C4>If1vk_^1$w0VuaoA2XyA`7D
zlSbYSGs_Y$L4446(0B|xu@wg0ckpy1GloLH%a!0Ce}hFrr_Euo{aSc<YESMi__^g2
zg#iY?=!c%k!5y23vaf~<RHA=82<Xp>Xtz@6Lhx%cIW>5LJ{bBQ{0kvEnb03a*TKKi
zo>_Q^!3foZe}4rnZNZI-{v|?{;5R1)+^p!1A%NeK&}_k0CFQCH7X0VOqHvp{&zg+F
zf62mKivD~7;D1QCThX5+!aqpD5k-G!I^cOpc)!9URB9-)_<+Lip?*DzEI+95zjgyo
zQ6#lP3V#P?81!5C359z~fV(SS2wt96cnpFM_EbKD#IOwn?h7mr84%JboX$~#y@fhr
z$D#0z#Cu<h-s=kQ2bJu^CltQR1)OP>pTyH7OmZiFSK)tz6Aoru<);*WJ<*HfPZYj)
zD)2z%Z`s68RN<=-!Uc1!`rj#hJv1{o#KPwkzH~Tno;Y7YNT%>hrvMLC{vyV=R^>i~
zGQrWxw*qfe`QM;5op`g#uP5P;vFNp`eD91dc$>-}!GanbtB}t@h^F%2By_>MRlc<l
zc)W5!(2uD6OZdxRk&+0p+JgI4{$wfe6s!FKl|MBJxYUy8L6!F-`IK4xA5!^{VZckQ
z@jRjOI{3oil@@+Z<pW`U!DR}C5SR~@e?#(UQ0O2QA-2kEVH&|k#UuJZp~9dy!oD2Z
zjbw3$G1$==gYM?A7+RJx21{L+huj$<i8Osbn93NEa}C*nQ%^+Hn~^8W+`5JsJ0pLW
zC^PiUP`8X>68XfzYQ}IPj}u050-sSJ5f`WP8HEy=!VhMQkSIfc11&N}N|c?_P*ck?
zM(r0p<cL$(jM4JcHKdn$QF9D*5<TSW+o8-EV@C>9h(SIJSKumy1j;l0bOx5Pba_3?
z>~5Vhr_|J5!!mo=P)@_5Bjn70JVJKs%OJ4Ko@6$N%u-h1Tp%-*JQJM)FD8^m5~N`z
zL!&aeq{77_l-WxzCZ=A|9cAfsn1$s-?~d=x-V%lMlUM*VO^FKiXRs_}_K^b#>mMSJ
z&g=`Xhjt}!>&;+3NqkTZjO;pOxB{?E)6@T1q{Y(|&p_Fp>BH?f8qB3bQ8>&#%g_@>
z*ykDX?d$WM_~sx(LP;!#N%aeeM_WU%F!t*yk{(J9JB<o<+IG?5rf}K{OS~28&~NyQ
z$my?T^&0?Q{U4@)E&l|p0*YTHU+TXNYrf4dws!u*P)ZFUJ8Uf@YxZn3(67hTWX+)@
zIq1QJ=1T5OCN@yjC=wmon5&-Fr>x2wkd?BMWmQpv79X*k+y*dUHi^Xtr_Z#krPIN>
ze>e1!`M*X4s`$^qNh<z_k)!%mFk$n1;O8~}D`;T%`@m^}e}6vY>R$+_?)3M9U|s%k
zm=fK8EKDod?=S+lKNI%S&41$zOosn!kWcnM0wEawvCw*t|Bei>=U<FEUjMhSCZE3v
zp^V>O2Vc?MzXcNN;ZFp$fd2p{rl-FUo;=n6ULhiM|6|~jGv6U}sb$@FBMsmm&_L!N
z3++_=*P|QNpIt<(pGUUlub2qdv44U}8CgdkKm+{)d}O_fd?C^V(9L>HA}4dTV3G^7
zj=xP6{aB2$-lQbS{u$^>)(PqoIx1!VM*tyvjro4S7__Vo%>*-N5Xm$DX(7|EAUoCH
z26u)D`TzpU$olIPR1%?9*57Exi2BV${j5ZqPFwe^zf0tle0)cZun^0hF9Q%g<DuKD
z5Jpkfzgm%%(oo&Nvd$3`MD!y!$o!`Pxzc(23I_BeRa1kRc;b%i2!J4y#<EllM$6Ka
zSCQvGL^|f5hnZ6RSHN|u{_&Vi8|!rqG_Xz08lf!1Q20)$LDm?NMt^(}MwwM)ox{61
zM-N$LR;j_0G2>ZttWwSsrvm;$xe;{mY=G1DEUQY9yQ>U705g(REy8?=o0CaoH7ILD
z<sAONc))9w&tOM5aIx_|SY5K#DP#*+eQo?WSkBrghzU%ynzc!x=@%!m|G>bqZWF9v
z^|Og%@2t%hZqfMeY?R-wY(;knS~Pwm337XUHP!gD)ZZ?vzZN^cc>?g`%05va_%m33
z))N*zoX_P$FSDMsFwW<083TMoc`!)yH`{pu+;i4*Ryoe=?wJmJ+QQrH+yPa{>ag%G
zJHHi^k@dNSciTBFN?BiuO%I*#$?XV9*3uC?DaEYX$pz7vM6S;4^wf%Ywp0KQx4}oR
znP9%nnf07X?D6M0NFP<RATgTaaZrq`=hXs0NY>y#VBO7nK?Q%npBwy-!+~E^$p_=8
z&)~PiA!NO#mWujc8$3vw{f<iNg`+-$PbdL?*TUZ!{CdOzS?^i+oWXxbcJYBl|GdHX
z6a$}9Y14%0(!*2XM6*6riE+%7hY#xm{E>xQJ$xal<j1O9_jh~vUr4f_So9(uK8>{S
zQ<V$>afb)K{vik?^$j$0X01~{BoUC#XRQ}$62U-J$l4%CP?+t|$YN4ggRzXPd(=dX
zlsggqWbIZxme3BWfP2&)0%|Pa%Y<DyG^%R<HF_Z7iaD?`I}s!4S~F+=Bg%{87*27)
zP|=pMTnjK*BfH0~Nb42w+S!3mAy=||I!wv#NvjI&@#rumJ5|Q@PB07-%(oIE)A}!_
z=XU<5X+`im(3Rr94FggAo8fxlus#GG_kiHn)I%f-3rGgd9Q9B$4k(ifs0VsdGoYVD
z)B{m<jm6w)0|wA3yH11#43rgUVJ3xfXj208*&7vHVH1NJ*t3Ny)4|Zd)cC>B{jmLk
zY2An|^z;_|#6aFtAg5ji2Q;u(ra*3;e$!-N`knCTbWHR;NDb^gM3mu}h|ahd<Sg0*
z?bhk3SI%Oq0}-|4)XS(v6H!Y}gN$07`doC7bG0mU>k}peHOewW55r63G+EJ(zHkCi
zb3EE9odmQ(mT`S0^>>XdGxhFN^IDn&a?7WP%E}2?#VGcf1kaVTN}`Z{Gv+1dI*AJP
zSD}YF*Gm-Ee<%Xl5P?%g?4z&1;+(UQLQXX}U8j2yIh#BJm8Z~gYR;{6no7?<MKEv|
zq#!g5XEHPu55=*AC00OCxz01lO-!DMr0Y#eeuB<(#Wg0^8^|?spBk72N&3-8?r&c}
zb5e?vP`KQui5N}Q-&{b?$TFv%0!z(3a#)Pot!JZg?z0kg)1M+L&pjd9C9%ZUVBNV#
zj{~}9CO`oPWi3PX6x=FhgZh7jB>GCh9ZEK6;6DV?bh;ik$htKWKOb6+vLuSXlPCp6
z+lVjc7JRs(a0AAm5YZA5{h%RKkI2?HG_gT>zs01`5Qbv{1`U-5y-vLkG;vUVhC*d}
zpC8be7G#G;+{q&;Vn;j`j&~VFMsID<uuKpfhzsj%&~SJ_Hn6F=kqs&+letJ19z+tC
zdC-G%&=|_sr(*nr#!59|`em4vLF42Z4mq7UsNy85uDimp=0OvQK+3Ypm2A+Yc$;IB
z(MH^)z*th2uUN(g6_c|-kSoVoBFE|0?}qvfnnIkxazOnsQNIiy4(%u<hhrH1wZSgh
zU;1x1QP2M_M5Fj0!Kdnf6e6+t7pB7A{i#@F5OIx$zW4^G=$Li=6c&ZSUP?m3%x)q<
zep@IY+~EnVA#jJ3C6tp68ARDA=K99LSSXl%9kRrUYp}mOam7&UYgljqonnv`y<UR-
z+dz3YB|Bvq&JA)}&<0ltSYRex73dQUR~dNZ!NFe;y@y~k!O&IEFw$MR3J@I9Z2%#s
zxC#&)nkSH3zZr{QaM%=q3_TBlU2yn9fqX*qf(2I#6o4AgH32#pNfI9pO3|!AlIzi_
zL!;3-G-5#3r9QgUosX*VD+68>byKL@BpRpCWwb3shEzA=K@=f(hNw(@#B*wq_Pvcs
z)q=-&Bkga5T`~WyI!&BuVxay{PzpD{29DDi{D@9R^ioW9@Z-3fk6<ATej*X6-J7W5
ztP{g|pORGK(8#6&7o0-O?Z|fE$|`-5iwM+1un_<E$PWx2BGPuKn?oa>#Dr%7iV62J
z*R60<&QK5Xaw*l74J;IxuZsy{iSNMggnCkChc+9Zy?%j@jf!WIvS<)y^?@*U7n2ov
zNrmw*^8t&MZ-l;Ud<ks9Q(~1mxrr8@smc+U3T&9yz+rkymEQ|!@ROJ@&kPY?(M5+P
zaBH4&3kLYF!H{RB1v&o~GVsi@pvl`H2G48@X7Cy)uqPh%W~VhQu3?_J$_JvO9De0^
zlwP99l_<owCjwq-!F*2lJUsKPAh?jX5zq6j5P39rxB)L$W{Uxad386yE36wc<$MEi
zRc)~`k3UG1Yb>~ce*h_a7Fn=@e})ywv)F<)ydPFj&k_qR;a6dfJxeWE$6vv^>bcT_
z4g3x&y~={k+z#XL)LC#PACL#Q%z`)Y%b{qV<pR>-ApccS7mRC5SHa75mTy$}WhBga
zeOzNYOXTXU_N_`<RpV6`@ivA3YigJBT?+p*mPb#6Rev|=6L)bOQFuMvK_|vB;o+WL
zFpdd};LJRY%BPqvTM);D1K?&nE0v`JpHTTH#Q${)omh&?DE|p_@!X(%56^-J-zula
zV4j<m2xbn)a;n&9cy6)y!DW>nuxxqODBp|rxUBLF^|#L2xZtwNMAE$VN-3rb8x@t$
z$NJ#eDXum_em4FgP5RS9{}KM$SdcQ<kXw?Cyaehr1xGM>PP#crF76S8A$e}}C0txO
z#+uiS44782#4@Dvl9r=UZ_P9OJ$##V{_iQE8fGp0kEamcf|)x>qel#eo5RyX&tlJD
zY|@XC9xoxvnqi=;o+rshNK8yiRw$#!g^Vjj25zngMK5!Pp{+R;TzP8A1ad^LdFa|x
z2f={8(=%%h>hz&bXau#>QMO!~i^h68Jw<eAWA2}V>={Hnhe)zyw`bUTYWE0ep<N#$
zf;Er`uB77~aggR&McWi2JAEwL-}EwC(xP8PlX|m63DimR88jJK*SLatR!|h3L$pmg
zE%&S;Z02Ky@vQwTa#>)0u5fYG1cKa{4vjPEsfTBi5Ts!uxpe~kpm`;<#IucfV6IOG
z;0<84i1PJqaMS9fOQ34R8(qm#i{&(F`ZJhcwL~JPI7L&Zkf<<)`pcLub*e;$eg(#)
zPLs%|ca#E6mne`@U(eLiF`@%5Vg|KbA~R*#(&bE@DN%+Vg-q31uVAhzIHjkn>TF3Q
zN57u5YL2|98`4Pw)VZ=OU-!f3tCvVrsL!Kzmr68R#9QjT`GV=Nc;=v9Cif;qVu@ET
zmrML~-47S8E?FS>Y=F}zS*EUobE+_QD0FJa6EYCT?NsE|O~#Ai<&0g*k2BE@m)mYi
z2E5C1m<CUs2za;H#gkX3)y}xbS|9@aWvs}?Zp(jiJ{f%*dldOdD}#RxM`7$0hN}ig
z^O*=(jfe%qJRb)U#(m1uRn%{huyW&mtF%O1r!e*@o3H{QIOjWpsJ!3es+=F9w!gCa
zog*)HJ|GUd)!+gQx&$iWx*A&M^gQ2;G3#`k>3Jcpx-`w6m){i9)PzEKUXdt)<r*GM
z+^9@ztYRL!Lc21k6#oKUdJ-)D+-wjouqsDEdhj~3a)(0Q46d1gv{UfK0(AcpYdBR3
z+=+1@{T|ZJH}H|lAseTspOOG&;ZKpz$Px$b)D_*7@MMc3vOkCR5w#$<$2|iTy41@j
zCZS4>wdgTU#_h>fs2<IspVp#53hflhO@%bi5aE9Po1hHLe*}uA_`Aa;seT9cTsD^4
z1fp)wcx62ir>&%Cf=GiMdE~JJ1tQ!~5k`?IQ529w*F`Vh#J-pU&(xrs2o93y-e3G;
zb{n!C+6S;-adqS`ak5z~@TGJDl;zOK<0kfkix?`O621k;tL3L=Lc{b_RLoBsNQw^j
z0#9J@kS!G@ZpO?G!y=93Sm@@klw#yMv>{Zs4i0aakKQv#954+@f3+wp#b>f}crx9L
zN@-fUm<=~33e7;hYE1fY&r+0R-w0dP3LK9jZDuFnyunGfY5L(K3S1+RWQpUlkk)S#
z^a@6NhHw22Fjz2>-ctdq`adyi1*7O~6q?s$qhMSv!gxIuH4DO@Se0H&0U9q2U(;Vs
z2bw_DD8e>4&_v>a&}*27f+ATHXPmX*VKger1M6gWK}kJP7c5Nq2@6v#79_oC7Cn~i
zE12<oXOr@uG?^K1GT4PqXUR^Tdh#fs*}oU8yY)$ZfaXYKK&S=tI*8m6C$cXi8Icg0
z#sgg;R|;BO3M!r0>gfGYv!F`e(q$<N7uB$WYD)-MnhF+=qDrkK_$6^lJBiZLxTN;F
zfy817*|6Tt1;ciui75m)TqK9k{EU7E(le)rk(@+RG;ksA#uiK`!I{ZKa4t#Byp;y_
z3zCNU>lsMa&`8W9#YkR7{K_MMgGdRh;LLRj*49!G`aAJ?4JsE5k(^=OMD>EaIG+<?
z4Fy9ba_U#YDHhbx;6y+XfMFCYBeJQV!-wT~H>z}6!M}&edN-+Z5oi1%AK<MP)a2d3
z+brnh52A&4vjyFpPRhK$w4lL%gtPJ9Zb2Vk0Au%VSLs-juIgV7o$}rz&JyXW{%45s
zz57&p>jwwUY4ohhyI++@G}$n$^WfA){TYQl-^Q0%nhLFBGp5s}#KJVPESeM7IZ*Qz
zp6?F#q(6s_3V$3eig5OZ$t%2oEL7Aut&fFvWu9!uRXFcLha$<iS?ZhM##g8-d7zWl
zRLKex73!Oufp05xO&gJLDT@5pqCNBPz`Q8_G?<?1x54hQb=&C!!z1!Gqf*N9Mm8ef
znyHlKO>D$4c^0PW2f+M@;d1Cs7FYxFa5L0s2;Jq)88HIC;Uo{<MvSs%MjUsH7!Bt|
z1JQ58_lU7n4dWMQN+ZU}GbNus3VJXi{DUat%ueAd0n5qSX#|NlC=eJz{_P-m=n<3h
zktNpn5yg@-Jih=lBTA@%gzV6Ep{45wEY#-66gmtO7fnWb<-w-pcciae5!J<fjqEN%
z2}7rtaAbfQK^H)3Bx(ieCMFv-+;s?=;v7AbE_LhaMesGVWHa>kFr@AqJ@=1PM0eOn
zTVV{-=OhDNDl2NT**uAGvF$E6Pv@8cP8hV_flkJBK4e^#3Y25%19PoI*MYIlAykn9
zoUtxzS=M`@x3M~13!y_8*Q<cevEAlVMGqF^u}N|-D}&du$y7kT*P&6TzO~(<E#oe%
zLfRjg3=aH{AV*=YN!fV8G+g&jqC*{qmr;FkU-*3`7G5qp4Csr|ak$<M3Bf${FJNim
zhT8?o5cfpFSIaSE>t%53;U=kQIr?%eVc}+wM7xk)*8^w;-5kb~W~{FjC`bU6B>Dia
z#GgYWW?Xl9U<=_ps1IF*PKWQLC)C6kZ9KwTWe1wxw*+WghDv2l{Z{y+@OBa(#k`eM
zfp)})kVjN@P7zd0{a<N7yJT6mh=;>>NkljFQqXM%JrfQn;U}nLp<Cf6<GSUCjf9_y
zYyYx|K);p9sb8%DJtJuudJ@*P@Da&vK>r)2D*UWOTrWZgVe${)*3{RNP>)KKp?^U%
zpO+|GzZ=BEFIfEPWh8+YuR|eTc>uTD!L6ZCDPD0yuI~u!9zQovHT>VWX}UMT$twQ3
z>1g7ghUm%W-)%!3yikj_bQf2cANGhFQH709bkQmC<{a}+D3T}Qed3n?6l9&#SB?QM
z|A4a`9HbF1PJNmmD1#c2{OJjNPA0wYg9lj(v(p(jA<-8Om!HHO*rCXBArDl!h2x<d
zhju6GxekLFZNm6G<cLk#gb9=+|K|`dn)Lde7o)X%uT|C|U&M3Xm7T#N?U%f(L=ib#
zWjx?@*7kX=&Yy+Nd#_jI)1i%c;zjOyJLm}Z#<A2ZFc|K=NpU0A;=|CX_h#$3h4DND
zUEUT&F5?=ngGjw{>kcvSZ{U=?s}*`h0CM04OrjGS{PIk|HCBY}<9&N|fdQ6UfWX7>
zu2<-V08VD_-C$8-yaX$|ccTS0KGFo-q|jXh>NYzS@Ky_A{pbPdIKA5xy6P`qTiD)7
zNxZeNBTk8>zKyvsybmfzJL?|!Y2An7b@|ar=;mPsqo7_{>MzS+C*C)ebJUdj^qvr1
zVxIUS9q=tnY=(G{>;0V~&B(`ky@hqEQ1yPSEP!F~N8pUSpLEXO5U8N{QwwThE8zXi
zBIV={VV&?s#q^Pk$6<lS?|aK@zyUrKZo&H}g>LoJ@}3F>^?qr!&EcCVH29kZLwpI%
z?OCgBK3C!Syx&@-h4Qth@2s8S==2<fM&1hoikB3_=|`cZUZ!HQ@!BHZQVjEZY1B3q
zouc<5{!tiEQ{{3{!dH_zI8<_W^a|R3l9*Gabq%+n6iyHLye^f@8P98#w552Z$xul^
zc>h4*J!xd!RhlPUPEzFS96eR}I!9EIuXCiSQ%ov9tMDDz3VC~3<Z)Sx(d?OmH&~^b
z*4(^`dHbr3f<7*5iPu|lRrz`gE^7%ziDO*Wx_k!O$1yHzWs>0I7?-ug>n($<_PDHd
zl4L#D!nmv@UUwOy%GX_RSxda`GSqsgi_2N!b(c7PTIG#Sw2xz4)*6X5q!YKP@^zPd
zt357niPv4?7?-yi$QI)mr*ij0FrE0M%F{7#-eFezcU68V<lc!-sr;I8T`*4VX3+G+
z>*LgJ7?xA-aI5|2Du0l)Cyvjk@_mN_Rle`=waO>JZoK1EvL5kD+V`YSQ`MD1{y5dU
z4=bj(R3%4*SJG^pG}>FEeykGSrt#S{f3@n%qCH+`nne6Avhdv+Uq`CGRHd^CTW~i#
zJh`trP#11ZVS$$rsUW_iEIS1<^m3ahOJ=F`zMJX&t@;P#@j>u^-e<(f$dsSW20S7d
zCudVd{T#KR!8gz}J#WDP%la)$K=Yne&w-MEFf4@m+hFX9{~feb{b{I<?RdB+d8l2s
zjEU$k4+i1A%Lc~}yFm9uF%C7B+B*^VYrPNI=v6;{0A#%nTW`GLDLlsEeZ+!Jezp+s
zpal)Som|DQEg0bM(?am51x>zL1N@Bzv-#C-z{e~Y;y;pj4_mO1mm-q$K5mmyWti`w
z$#~K#E#dznyMM}p<vbY!_Wss_^Y}8vSKg;BSi!$1#W`ZZCH$xZ@L3BsaFhCd&VnoX
z9}uv5j|wQx#&>bx=Piu0@EIh#HVd~Zd>i%kqJ`m9en*VHWZ{UyU2yl_V-|*2IW`LT
zWeekq>lD(uS1kOr!k5!p`l^N76#iUa;MXh+FZ9J!;MXmTCnQ+Yph=4NgpJ<C<iAcw
z@mn@h2AbOEF@@gW*<@_%<R2q4^S&+KN2aqk@vi7e>pf}CpUpt&9|UQHNpkgh$AZ~>
zEluXT77X!zWX<ncu#lgoHU0w&hWVQ`ijRc0(Vf85ze30X?^)YP;;|1D&--_a3&v;C
z<b7jlqmvIH?f=$-Za#}<`a6q9gBOrE|0(ET1c**()O{&B2+-@QFt;y|;rtjMcG~RF
z%XPx$=rXAaMR3yHhQL5HKwSqi0x$IuX)n?ajh0qC+k;P#&-Uo;v-r;z3=}nJ(-=S#
zYF|w41Mt&G&!#lJ<AwA>N?*Y0gY;FDrgyuLzLwJCU~WjSp)|eIh4k%6J2cwp2k7J&
zIrmZN3kY_Q{xzj<Hbwdwq%+2Y+BRikce;%su9!~jA+MOq$LJFS#VDZNBHc%r*pu!f
zU<I=2zJY+Lm^i>z8+v?&C?D)6D0|T+P^XG?Z=~~<<Iz5PABeO#2_m9Glwp>!6Q;ag
zDGK}=d3p}`F6vo;Bvek%1G%D9iN=c;Zi><f*@CMTaYwy~OL$DtuYgx7>LuY?RiBI%
zpeS8JoOZiP(Tg#u$2Zi;4yeVXfcyamrvCspHmRpXn%)A1nv^P$Q+L87CZ$Q|hArXr
z@gSlODkuRFdVZn~rX)B`X~s5J4atg{IM7vx$OB!c-UP|0c@oj(0$4qBJqxSS)G_o-
z05?0;v9c*m9kFO{M1CFqgpeT2=~A&M%hervs7>y(6>0HPDU<s?ha|XQuCF0J=j2Sn
zBKDr#&ngl>l`^^COQIs}FsZdeqtaw&an4_;!2qaBajuL@SxQ~)@=in#W{L+Uz@6pL
zV|nv-j+%q%HZgPk8fl|=Kz|hWAu=>?bbGCM2xU>M>Cgrv<vfhqAam1f0J8zEsQ6|I
zuFSi$kZhrY2j;p2anHu$#WUcT^nuigc;G}N4Li`4^d1H&<1W}q@l`Yibf7mu7mMqt
z5#16xW&kZCX6cgh5=gUnxqO_Et&f54C~o-A=~R}Z*Aq=TTm~xF%P`l)&GNe99Q`>M
zZ}EyJuyUxud3pd7UwqBZazYFAx#+j}S~+7C`nyOJucS#;gEjhhsX*7ssBuY34SuGg
z_?CRZOM~vj@?N}JmaWt;5S2A_PC|<Vq(p-0waUcrHz<ZnC6@Ug;2;carC~}C0)J^3
zV50iI=u73lM-{_u9e8QnfN+d%s=Sos<d;DnMv{ndDc07gvPW&GCQ=3;19LV~Ea>A)
z;RX!9`e_Z726!5{FuJR9z?}cG2(X7LuT`6TDU{Jjw_=QpK3`N(qio&}PRbad+61#X
zJUS6@pek>Khxl^Xi;<&R*S`7vSU!wg3x@d`8t5Pkmhd+r3S+P;C!?INCF2cQ<DSF!
z1p$XxBb&$RYKxJl9ufUk@Hbt6!&Ip%OZZqg0%L^5Y#rYN?J!1)NJ|Yi@B_rvXe$uJ
zlDwa2jTJ|VwEg8<F!9DXu?wJI+2A9bz+nsH@iXR-8RIRyU+I$s@rvil71VIDN;ZNE
ztqNCZfW_iq6W1&iekC;6D6ueJC-FivjVTt!+I$DGJypGJ5w*wbB>zN&X-rcOFD8uF
zN$3H!F<qr+Nwy$fCz%Z0GRoAaML8n!c{GFN7Guw;eL{jUgxU>*QE;hx28@gMB%a0)
zjQJKusJ#Y$)VN%g52z7pp9}+6s-)lOh?c&&P%JxHb2nIra8N<!`U?aTF20itM*lOE
zsd(#QVJ%F*1&d_yHi<0D-Tqfm=F}gD$`tR+ok<Gh))#=4;=3mbWatl&1>Q4PAfN6c
zyV@;LK-a0}o;p#+_1gyk-Md*JQ-3@UXz!;2W$4vpbCGib(U~y)VwaN`@AVJNP>X83
ztC5!T$Kj-n_rwnjkfpUG0=}<FU3T(+U`uLzAbyg9Y-tk04C9n|_CvPxD!i`op?DpQ
zjOTDV;78gubu=oI|1JmcW9{8#1T%OBytna*_D2D;xe2W`KGnVwFo$d8O+V9q5HQ5w
zhleu$Xmym&UnLl|U?FeL0BqN!;~UKvl3ASA;@3yANP{}Wy-eD%u7aqI&#m7DnZpyQ
z?HSFzoVc3D=^m%?l{NeYyn@F2XKf|K45!Au<Vyac$sh1q!j}={zgv~-_{52T-&(Ml
zGt%VmtbT9cm1N5QvR-{}fd!H5&WYOe`WQdq1O8rA7Z&#z3G)Z-lR2bs2#Wtf0y?kJ
zvsPh&MF@+G|I~tDT<pAiKr@XW#ZP}>>x2s^B>fAT?-x{#AXy`<*hgPQ7#B1?!E$5R
z?3?-tj9;=K?lpUVK@Yz?@pd=h1nX7%h{pGq0Xyt4H?-fc@s_c`PCNYq5a?^XgzCHP
zv~0rgHU23XVv1dE<qm25DK~IHyf+Jb)A%v6uXGFJmnqIn0Pbxk!x6tsF_=7YhV`mD
zewkt)iL;;m&$Fl;zf3XL0o-5Q^u~BJK5Zayj#d9VTH0R#DH(B+(It_3BoX^4+Jg*P
z^am;uAD>d{3_ehP3SUlIha6f5CCSts8m*-c?P+AlwtZnuUD{rxLcPfQnN$UBvhn4V
z&A;nxP6jTTqry<6yD4PWf=}d35jkYql5<)Ik$pKbx{J5R$j)UE-NKW<4Cv4rksG)i
z>x9x>Ie;|%B|VA{w7nBw4vl^s%C#NRa+WyAJESbbFEW-msUig!6nd1nq%DyYcOhR6
zmz;;}P+XCLXprHeR}b7%!ox5x`rA;3DdTDMMCl5s)|3hIiiM`%3}cxxaTKaiEEG80
zM?}Tc%+(L7Svb|WpGX`pWNa#)=t~lXgMhpeIrV3t5>x#W8M*=rQ@c|mif`_Lx=rnI
zMs%I6_rj_^HE>vz<uE%nAt0PI&T^^ROL2^#_)VC(bDEQMOK?5SCAnt$c&rlB+%m+$
z3rv?3LAuk@$IeE@%i+(a^<Ic14fZC8e42?YAo-fhv_A5H)hQm|Ov{k*j$3~_2{kk2
zqdcD_+S#CzBt9-f3Q{Ll92)WH(5N@x@8J-&>H1ov{T}Ec^IruAs`$4IMUVJ@g`xY+
z#%~mI7d)Fx?T{j!Hska-#dyp*64ZD#IgZ2D%@QX+LU#DLB10TE-%V!xgmpW_;JIGF
zC#^di+58-0L*psy4o8SzPd@Fp7R=`d$OND6JbP>+%FigIEOfJEQGdW^EmC2gMgH!n
zU>Mt3ex(8Uyf~Spt0dQwhkrqNql(&=^C?3BU$jc+@J~&^m#mKF@eXno$CUR(<psPK
zRLFQ)X&1197m%ZS#p<_)ucX!Cgmr*j$LVRF@wP>(fuE)E{@xmXGlWk9cW7rI)<BC3
z0(b3$qzjGcs<}{sMbL1g9Wx+QATj~yw2V<T-IW5=As@mzb#E@v=Q1R9>-2v(Gh#9#
zM4&z%=ua{r4CtRxZ2N^orhbJEbVj0VeK*A{f1~>x^ji!ry)R=8rFlm#0V|(EM@xrp
zw^*S)LutN5ioOz#uyoj)qD<8vgF2KBmzJXGiO|N<g1Cj13;@DIUFyKl|AFpGM@SUV
z>)-=RM@nSsrLct3Q4(eAFJVBXqa_OIN3cefj`>vdSE%0r373wOXtdrJR$CgDyoB`~
z5K`%Qi6-d#Gl3?^nnn6@483%sq*<buV|gkqlBiriKxmRg^YojrRF+Pb?JD#XXi{mh
zq*<f?hG>>NBY0V)A0ag58*r-zmoOI{UIa?-{5uISOhex)Nn)D?6Dr*%kyF1f18BPx
znZXkO;0N46Vt2g@V=6D*weM0;7(m0mD?SB{u#M8Y<3j&Ev3QRx)AYa4&~{U|v~BBy
zm9%t^M5g{{XnyIvvadqD7Y$}_TzJDsToH-FdP@S(eQ|NU4-+Z9U-nm`-wdTJ-6zph
zDDXpIFm(rP`#_mrxoRFc2?(LAyJ9_`=3nFi_OPtP$se5r7_gwh=~;PMPYVY4PROb(
z)v^+kzXAVUmS#QcDCF%yKyE$U7|j)kvaFZoU`qJo7++bsl6n~pemZ{&%3s!7k+v|8
zYmif!X<26l|CZS3ql^)im$1aUOBkEsrCTnE!AvAGXeh3n5tzpETV6$4|1C|(>i9JF
zz~WTCCO(a{i7sDjO{0Dk!Yp4Wk&pR$W8KrrhT;E2&-`y-f|)-V^Qri6=?6wx;$&ib
z^pD8zt(A=<?g!F6i?T3T_&|CgxNJO`w`tEt#R=Dd40A1pP@QFCiTyrjkwXhbCdsad
zc*R1&TxS5oWk+8}6}=W}R`xt`Koy?|1HB-TQ#UcLvNnkfy?G4KixLI&>uD-qk_ZZf
zag`mDC|f@Sr&ac{L?Qh%EW%~4tW>FoLcNlt`>I5vnac^2E-d@q?D=5Dk1Azv??IAS
zVbIXBlkvrE4%DdZ4{|wk>Lk>%ci??c(-7h>dly+iKAps0_MSumeLWm;+52%epQf4q
zAkL;b73dT^6WWDX>aS=uC@WQn0e*pMmRT+uKRANPDVw3VenE9L{xA)<T#>I!IQjE5
z-kG8yb|}z%8cu($?9Zq1?SB*!X8zuoBD@XU9|Zi}v3A(}-%Z2h`<M2@hR#0+Lr?HO
z48Q2`55&NoEMow4!&J)t<-Q!E*^9bm=k6l4fN1E4f6Kn70_<^^eI!(o1Bgh&!BS6P
zdU;u<vK4tem*%jaazIqZyL2AFEDLJ<A81;ZZ9ylWkq+43f^NQ-hB-iaUbHp%9m4<z
zTF}QEiKiS3(z_ZoSJY1ut?TjFkeHA~L?(%x76kMt(y70Kk(y;8W$FU(`D}Mk8)8vo
zd`lQGPg#f}61W#`r);QlwSZ3kLK$GbRoTrK6WhZqXmC#|;BX82_yaVR1=gSfJg5VX
zRJI6G9J~=r)Xz`YCZ4*9{^BgxBB#5u0iX1jWQE40OE?ckPHGES&Mpfp1y^7=eo~3?
z$|Xo+#yI_$P1ywH8UZ!_9ZlfGPO-l-7_g{Q>~1WbWs{WMqO!q%iJ+xyvITwoH7G$@
zvGS5A4e-DA0xYp0=X*y2PEk5Usmar)15Q<JLT@vyi6Evf4pvN5JX$B-<!lkFKdXd+
zF6b=Z@zZjGD8EIB<A%;!&vn)!@0COlwJ45pX!m#4`n0narBHPK68e0-vjXuinIXH5
ztJaq&cWB8dbCUX}ehI0*UbaTrj2!V0x@@f#y)k|>>Fzpf_0V`Kd9U>r<a`OK@&@bW
zk9=`!t_&|c3#k?HNl@&vP0DTo%hTwcwz6B5gMf6J#O$OBR2Yx+$*)pr9Fy00?jjEK
zfcD}*{&i$IDSwb=%uxP@#8CSEC!<{Kv<B19N*FUmoQtc+#&l)aLJaFgD3VdCRKZ`6
zUeSeIqs)R@8od%{%u?P0EiCflwu3R-a$;`QZwKNaV~*&`p%J;%7_4r(ahcLs0osl!
zD4wruMVe^;097(BR~{8m<M$Q<{z7>}KqpV2o-36<3h3rblK`s~t&-Xrd?ywmW05je
zKp)p3A!Di1C}4nB7XvO=wg|}isJ?*p3f&%}Gn>8$HH`-4fGEx2-w+#DD@O#(=6}Ny
zY&0sL3z);V63@*_QWdog@y9S##&yb20rUA69PkE<$wIz?Jp7HyY*9Lz&sP9%R+bAG
z=80ngS1S<#{~u@H0vK0uoqg}Fw3cOAEU^J$7LdUPW2}d5VGP({*^;f7^;pTq5GU)^
zYPDLl+Ld=#vP4WE*gQ)J1}AY6eoPyZI0?;zkc9F`Xn`b6NJG>72~A0V5=cs0novrD
zo6`3GzH?^oUdfN<{|#4j&&=F2GiT16*UY`!5^1XixZiz5z&5igZo_c(lNh`M_k9pa
zO%`3mgp!E5ct|rn0$s$QQ0-%05$RXWU~aX+@TgZrS_*PJ@B=TGBvoAU6yrcPqVP+v
z(%PAoXxT_5{UfE^EdgS7Xiixr>T6dyCqDGEo@8yiZPp^sd=aQQaXJP<KsV)~<E$xx
z=*^<&K4i?7*|S6Yf>h><eVjxUKfi#lQ~eiU+iK~+Iy{PJpO%`KQoO^5OUBP4eTD<7
z=0^)q^Pjw$oO-P(eV0GUeyOw&MLKA5fcCN(tH7Q>zsxHqOO%iR|21CG-7Jzna>V`P
z08xGrNzFF`!Um)X=!~5C!aYJ=<a`=AbIQJfzZF~1YE2AF23+$DGHO29A@@Jv{k;LX
z|2y16GF%Xto51@6--b01zEJO1FT(vY3BfxR6o~Z|;f(<XnH%;3Pk56AkQ?r&sAvhu
z<_-|`1>VaVL9WbbfM0)X_#Bs3e}Mjb!@r(~`+>j^>YzI?3(z$_Q1df9fcxukzvz}4
zgl)rBA#PPfn)t;0&;z?wTugFNSBIVxuq;xJi3y()dRf4V$Umc>;c)0b1gwg@&C+*;
z&dRH}*vn<RAatpK3nQPe1$bI$r+_t)CUhx$dT6hJk;sc&r)PvdDqwBovy@9Up|1<L
zB(e?z3!fSKiGa%@e;oq2$W&etxu2NN3cVwxjgiY>l!YUq#RYbwDKa0!4xba+DB#-2
z!7Bis8yXRCU1aHcfVH7}1>6uhX9>W?p|1<r5*cEz&I|oSz_!RK;M4H=p*IEWiu~{#
zfJ;JW7uis6Wc{fCF9@v{a3FH%0)Q8WG6L=Zle_}@R!oxO?^}$$$nd|Eb1x#o&t`^y
zU9M)Q6M2br`AzxXXNj~dG7o$cexp2?BUlk>glG@{Yxyz(t0Ldy^t@TVRlsm$6!uB@
z-we1gG8g7`_^t9WDXob-JrCe-%MS_|i4@3uzbk)KK)7D30lsa(CGw_d_-OeLq;y&2
zpQ*S0z5Jg9ToL(?g#dqFUOvuVHAeX1#_)fb(x%AVO98%9zFbPzMt(;2{m=4N0oO&i
zQyu=V@}z(p<SbnHzsqkCuq6`bd^n*;1#FXdP{VHMadeJ8-YXnnAoN`+?Trj@rh_4U
zb|7*(Jgab7=q)MT5&04)uRL^)aOcj*-$ww3LRSj7E7DEfHYb!2a42$!8fb3l{Q{0)
zwhmx!Dqh2sE&4HLYdrkNLGBbqZsB15MDD3hFI)-mljgKUS>#O^B;kh)SQV)%1Nf=n
z<0I_-!U$g#34hw0mZ*vJaXvm1d;}BD!+AF?0C>cd)<&LV>1Ts_&U;BDFbCl0f;^_l
zoxwHagU<&wfYTItlS}Pk^VR&dk*{!i{?vdQB2P2`{9^Fvb$qrhk|*Xbn=>3;ksq`4
z5d-!{$~Xa!2LDSc4@BNe9{*}^?kJz#5$O*Dd@497rF`}3BOp^bjctCS-`GZrJ`sY5
z3IA=N5d+r={%L?;PzA;0yV&8slY@BVZyw+ezZBrve(<-vaS;BQ*?_Hz@beKK7>@Kb
z0{nY(pm3qH=t+>SHvDRUKUxssFMWi6>7CR17Fp$2W=pdy!tXAJ|G|J2k&j*l@ShA=
z6<K&Dz<)MiIC6Ovz}L-2YYio_Ba_&0Il07@`E7_^i2FcLB=H5mI0eA1!8135Uw((x
zP!Ya8_$GUGCMW8SU@$GCkGNdycLq-runf9{1=Zv%`2&LTsrfD|*qphzU-UTozcBp4
zU=cv%D;ERH-N8F>PbU1)Mt~o(NF$SE^m~GzmC}mHX=K6!rnD+@F}OK=Z}7WP8aAqv
zm}c~X&8Su-no^Oq(m&*tKg)9YLzRvJa4>VqzKHC(f3gm3_063FZjs~heU+`C4Z18}
ztL>XNU)ZQj!rFaRCJunZ<`trx_}JXfw!xq73)d3`C1u~KP4W;JY%iz)9mb-%s_>r)
zQ>t2d+&jL+k2i*&2(oKnFTBPV{#x)JJkYRi6AHc_d;#5Tc!a7KzXpK()p2}>JN#tu
za@;$Me$@$LhYyr-<wRDTjav80wi}5)a2CM(%%)sf<P8ige9(Xuk@t`}J}eJ%d-E%t
zp^ud5at%jrCLe!PekVuINwG_F%F3|FD!zsJhyTOdv(UN5vhb5-+-f^*6CQF-JG&W!
zK5cm&#&g=Kknh3M?gF#oTwv20YVmKE-HN&q#uCDRDfjFvKYAJdu6(*EaQ?2y&|HAe
zo4#fubr%Etz9}8o$iqi~MOHI*1R8rtg{nE+ewEKCh3C(?RtV}uUJl~fYJPhO^ev0r
zOU$RuIek*d9SLp#c*dMx7YSCWrmLBwnhsPT+0PWTl#aJzOyNayxJ}MI-#=OmFf!*!
za4)6f^5p=}_CTJQ51-?K=Tdf_J0~LTMk4>j5iRygzeyo|o(KK{;|ZT{K@gjRUG&3K
zaZDt<HpE@!$d9RYFALo)9mgnPA%!mw9Tc!Eay?7eg+4D}MdX5u0Im;x%Z##@=&uaD
zBw#r5DNIuMD)a2Z$Um^-8$wEwn#d2%1K1qWKu#p`kF5YVhRP;5=-Nnz!`fuPC6Up2
z09!&AOX;%6`<4J~4Rs2*B61d4ZnMGM7`cKh*A^O<(xym=)NME5+Q{2P)nUMOk%u|~
zb{cR)<VZQdt)YA5*_OyNRF&PK#|3PQTt)-4H}q2hyCSD^lKV_2dn3=1R?*PEO6dTo
z`%@6KVlQ}SPT4Pc`|P`U`v!0C+lgg-4Z4D5?84xw_$_j4euO2DjCUbpPFW4JL-<qk
zPnaNNpN;$SMObZ@;YL^#2X=o$W(hx2z7Khkzt{rc+49wfMIWOn`J4gEBK30se#?Lr
zk*{$u-<Ah8%GVsl7YXkq@m?+eFwo5@`vm@~EPNJs;yCG+EV*7?8y-qg|Lt@MK+}3t
z|4Td{Rs<qGt{*g^Ij7~a<4VWhent0HuM&+st;E$PA3U*@=AuY3(e$e>Ia(07+9fns
zFO}FfEkMPD(K^+4pb3=sOF7AOyI0OT6y1%ahF=T;!3$E2JCHOL6%8M<4%Ww|oXyZ!
z)N+1c1ZW=jifA}WbWO@p^uN8L@^SkV?IaYv;T6$>RD?oCKP~5>NGGM0m4pI@%#B`A
zl10o_B&NL6E2rUDDzf@^RLaLNC$vJfTs%&}<js{;g@5FsqgiTmANP>Z9Id8jrkMD#
zWSvVA5yO4Kt4T}MS4p0c=1k4sOHKBIMy%H4yomY*rX|QdU0%kaRjcLFXODWQ)FPFb
zO<PyL(oDUCqO=tCbU4lfEMf#qcj-<0`=y*L^k*z*#cJN+(QhKD`9Dp<Fb_#Jwm?5o
z(GWtl?@19)%+Y6@QS>YCDf*Ac9!GGIJKv=<S!&n@F%~0NnStJ=ujAZ8t>(5d+FtKf
zqR**Fydk1|&?~1CT0(-No4q1Bq@^PJwW0szmD5A@m9u?3|CCowA9YrFbx<q)%&SDt
z)mO>i$pDIUr0ZBorhs>7<ktiId!bihkQL<6hSVa6@&{oY;)4lZEjqr6Mud#~a-8s-
znK8T~iw3zE=o9;DiX>r8pgZJMqNl8tJi&(Yr=*-1={lE?py+2_(HT&fI%>HSk;*@)
zL{X2^-(FR^*jkmp|74fk`N&n;(C79MknF87GvNn*Y!B!*Np%vJYF+}-$i>^?U^8lZ
zL4cgwC5OshQ5wR092wdg6~7kUwo5R7*(;(EVDUVU`}r;vzisOmUOg&&oBNiRdoFWj
z@_2`?EJafDNRzBGeydd5rvadGbdJn^No%E7P7^@aIdK6^pA>OUsp0iej!M7ECbLh8
zftnewCY8UhrZ9`Y=0~I^vCuBinj$n!#PDh4&Ua}Ql(3+Im*p|`i#B8RWCnkvE7AaY
z43*wSrE(gA{A_fnA9>hDl@CduLw{oKKWqS5mMrF{qV?O;=aKp7W_+m|2lCG+LRhEr
zGp|dQ5Gi~C{Z8~!{k}AQp=|+bUO@H9&BvQy4=uTHwLpB2;ZmTkxeuk#hY#R>ZW0b-
zRkZr&xPKRaOF4RqHsVySN7Nx2woO*RxQU*s5VrrGhub;iMi<VXMpsW+j57JnR(5qc
z#uq)^KDYdQKxdfeDz`&tL~9hPs{B6-0m%=^va5Gvs8PPyhmJ3-{FhSzouyDs<^F0w
zkuxr4S)_6&EbHjmTGm*(hR`_*HC4U=H$Qr=LTf8;12LlJ2-3RBKWzuJSj#q4cEh@g
zo~KYt<$ap~83MOers4NTmuOj6<rhu^v{a$q$``RxqZcSNQ29D+=IDhA?WjBlZbS4U
zg?3gJP6foH^XT=i%GZ_wx>%v1$~V~F3WY{0ze+6i3S}z42Fo+rpwM{bo9xR<g^HEG
z*$T*flVPfI{USiCwQO%CgG<pSLOeEJxxEYEB?{u_Ix;XHqiYnz$M|pHpe|JqALIW$
zF<qwMJ#OWyFu=<d#Mk(L2+BvVP!M0^-w0<kx=ulSjsHf{{7MBMbSv+N%@n<goPkr3
z*ns*Rc<XFH!tkd!bH9WRw)CHtxgM<Zk5%}QPs1$Afc=J9a2^;F)Nh!jqVo6e0%Vw_
zs&dyFK!#bum6w3!`VF%ztXu{5?l(U|QB!#f^hCd5mPqAaUjWE3OKs&R+W;A6SyI^!
zM(Q`rvaIsUAXmR(mKBv-F?s!lSsE+<s|(QiAA@M&7uL7IpYC6Jw?J#<M?d>7Q0TJC
zUw|t87b<jl<*HSHmML^a<-?ff{)-e^SNX*GfR-z?zVc&OeEk<IbY<nT9zZJ;x~lRT
zm|*>N3T<%a{rp0Jje9^%e8C=nRhHh1yK4D!ImnG7&cNK80Icg@wdZ{xJ>SIWUu^}<
zr@&YJO}C+d0_LZS09~R`Mdd3kfYvBfRr!AKfB&T#xeQlkNy4>%BF`<XJevc&>?wh2
zDkskcbot*46sg<<KJLHb-vz3z<fm}^*PXeS?JcSNHd|P)(6Y)Y*z5gQUM6KLDu+3p
zS802VmH&)2+`mDgrpgbJ^v(RRKi{0!k+YvNatxXS)m-*a1v2>*MIZEv*j+6$3iXIr
z^rBb9J3K|IV^hSdz~Sh#EJ4w$UJ*y5MIIKE|F>7p@s%E}HqW1n+_}F(=(5&bw;%U1
zP40RXeUAL3ifg{+zp(Ps<q+goaUt=%C&Li#20jEKiKec?UDLNf=YdyblQsASWLz=@
zkR(`>cLshbw77IQQ*Z{#U9I#JR9cHl<pN%o$Lm=GbL8H++(moaHn_o4ZvdikeART@
z2HIIyFhsd+1GVTC6OaYlHW2S6so`;FTeGOmre`U-bFy6=?7`FWNFXPV{1}rT$g$oP
z_d_EDa#UAq*l=Js_!Wa_gz^d8rBC0)whI9HIe;rd>sTVsvJ-*3h|y_!D}wub^?|Q=
z&D~pS?%q;!_p&*sDSL(EY_C-s{1w~C0;E=Un!XNUc=dcO`klpgwR}x)9eaGW=uD^S
zBN%qzkhXf!`|ThPm0CT-R^^ev$F<d?Xm!WGDC*7jksbe{qc{(97kEJNz0Vc~9w^~^
zfcVz0;}<jnpOU$BuDl+SYDalMpZYYOx{8EB4j;RUw8lN3b2hklc7kIb;}{(b!wKBr
zxXtc!K;Ztl`y)Kc%q6A(#xeM8qkA?i5%<eMm-)S>EO?{iZ2DE16j0{4y-tg}<r3UH
z9+a`M;x1FU#r-Txp4JlPj+>HJ_g*L#_gh-R-2J9x7!7RZyLl+oaiU<0`yoWi-9MHV
zSd(AgI}fSr+=K($PeEw9f6QTQL|*$dS0NIDe779Z0!N|m$Dgx5?l{i?b*I~>xt(sW
z-Z&l4n(|kUDX&F|)AfcapZP2Y3L7tpKWt1?-WfPAh5N1U`yeabO+j%&*w>eFeGN6;
zmr=Y~=(j0I`n`h8Zl1P4Z3^g9aP@E+-Bua?X28A0NyptBq!LQ9nA+0aBE|av_jTdV
z8jP<CZ|^!SxRH)d0W$^}{5Q9+GjKy=V9G(VB5*yE+Q2lEn!x**gaZ>yDuTZ)TZ*(S
zFiFq}>;Z-??)S+BS)n{f@fLdVNu+Mw&7eFri<@P~pTQMPWF2>$V(D!_{Y8AQS3!6C
z!0(~P-QAqgi-AGrXgx4sj-VTzzN2^`fv$H{p>z*!uKR$DgI#lb(Icm01xgO0<o!~j
zdFznJseMTDqEZ_ZOq4Rg@8HJi;7h2)`HdMkizwM|aQ@KXWZpr8^XSQN_T7(KM}V{M
zNpsVM*P^5^o$j&ysCC&9VHS>BnB^>|f;8OX{yGdgv<ihu-3?`qGmX^UxE~Z2!QV>3
z&-rirZ42vO4rE-|O8-{U|6c({6DcqT>3;?0MP@@Fe$rAX9tB2Fya|tQqnKHTf-X*B
z-^P8Ai62AO3)?@4zqMCWMA_mUa{@aCS$5O*t66xBEx0xd@ZFU18w{qv=XUM_xFd}}
zFWhvE&E8oA+{LDz1kJ#o!O9nILND;IuLik4MQ#VbSHZ~~-6vJFpE8XtBwrs}6&~4T
zDjqzh;)qn_v0lzi$4$6-4L4ubio!+@A&;&6Nb;gw7jB>Yg+RDRo_`osWNx3u4H>87
zCG$`f2*~-x3ZWn&A*F+l%5$%p=Q<XaX&Y-z_2aY=K^3;4Ou>l}ra057;IzNTy=pC{
z<!+bE@DQ#spmrZdNt+0dyD2+9h`fF-xqCR}?m*uzR3w4kJB1sU*kkwLjtgi4ExpJ6
z;sWHq;1XdKwE3SC>9x05q%RQZ&ym;mHU-cNWH^5Cxh;F81#1DW`|^B%Kjd>AuL3Ur
z1ir-x0L{3KPRAQ2Yq@0g38{MBl}^VyreKpPD9RJ7oL%gSODvoSS?@e8SI*|ILtUXu
z(22XhIv4ex3b?F4fa^*ibia)nDo~#au>bExW?v0TDG@t1;D(d^Rn(G+dYKcoi%$zR
zNgAwqkcLi}`-;nwhvqoWUgCc9R!f>!i28oywLM<PdMtSX;J|Y*k=<WDgszt1Nm*nS
zw;`)MNc}K~%Xt=cqp?`tagWjxXohhNaL|B12AF`la|X^@hv$wi#qB?9l_>*Wg#O?O
zygV<ZtqP7AFs>ljKuT{=FaeOQeON&VVgWy^;PnRl20(cCH=*l4LN7@TNZMW8OL0jy
zVR8;cXjg$z((q*jK|~oxDzkH%Q*ji}C*Ai@t1ok1l5jtm=!Zz%Z=;${(K45G<j3DP
z3mumUiNh7pfs9DtNh*lFfHxOG2m`+cxHs*%%cXQK(DwWu7NL8wz-JTYXL$|0nJ~Yn
zU|{a=_521a)m<U=e?s_Z2@YZg!Cc>3f*OgS%U(CZ2tAJzd-v_O=Lyl)8<D9!PXx&V
zy8!px1%Jv-iaP!j;9++o;Nc*7LNs?uH22@3Xy^!#uLn-Ub{$Uwo)7Bml)Qd-C077t
zi*RM%(<l};j-W%FkG=YAd9aaFv1=K!-K+O|_%MuvXCiCRbvcA*as3+2x|Mg>VGPOy
zRHHzLF(?zz0JvAQ^^lOL7jVy^7Cf00c%0=jLBj&?1H6kzb6j@5)9uH)$K+qT3^~)T
z%XS}vPWw~Vxc852+tbqa-y&1no|d+`tEX+h&*h3gzsizyue3EtSV($<OOh^u@DZ}U
zU#f2fm`ajYZgj;@KG2nVh)ek<cOPoII|hY)@5Dp01n-uExF5h%BeDh+E><UKF7?O~
zyxRpj=j*7Fj>WJB75+@}I$44Wu?P!Lfmgn8>+gSc^qIf?;EiYl>riul3j}xs3sKu(
zgII<Js6bV$LWLrTd4W5Qf)wvYPc3(pVd&(*3CZh&J!VV7D52o{(Cm`Fg(wl0S%K!s
zGEbT+(=Hw^5AFa_tZ~;dV(PqX>)a@H9`@IH*wiV*Jd!)7wT=Td;o%9R|7>g7%sPD0
z%d0bD>U7yU+Mgr7I(<!G8tHr+Zm8_iQdt&5M-h2!<R;CtYhXXJXRLv(E-E>0O+eU%
ze7FJeq((IFj@@l}u|{-7FEW)E&kS%m?<SntfSQW};34NV!jpv05_m2mm77kbOA`?|
zaKPz#nU2Xh0kY;!6!-88E(ZR4!k0FB@COhi?D_l_z~{>2SD;@#pQj|#k9t)@JNJB*
z@M0-n4|woF^dtO1%f8FyywA^20RDjrQMhs;bjZ`Fs0_S3Kn6Y+nWzK?R`@*%LyIUp
ztuVM);SVbe{#E$P3WI;Ok-t<JENnWVFql~3Hvyx+FXPYCUVj^;zoFA?e-&O0IB^se
zwZ9G0-!`p;{wjQ{!sxHUeDek4L4OtI@Am>me--|z!sxFy@}|P*uj$0;QXl<Q_$<Ka
zMi>SG&_Fw{k-j!)HPBY!_XAEWLnZC&8tLnOS_yqs_^%a4Ulslrh0#}q=OP%ceN}j=
z!sx3uvR+~IRpCB`(N~3s0pnlNZG}#Ep9{ET=_k<$e-78}K497UIbrM1AXC};IbrMP
z04pDUTln-H!oud?2~bGZ!d>c_+yG2}De!8-!sg!<xDT+3=<mt%IhHTpi2Bb9pMI3^
zZ6J~ReSyD9_;MO+e<kqG34gsC@DBnM@h)`K;0DzH#fL2I-x1m`MuCcDg&~${&@1KN
z5z1eWDk_#0wqjW!BbF7IEtWO+D?p%PS=%sT*#Jf?EA$gog)un*T2m?w9mLIlpvy)I
z4?PTc-aQ`N@ibs6#O0C)rRdqSv@tv0Krsbavp!NDd<U}6>1e@XX7&!7-BiZxdyq}t
zd5a>W-wwY6Zo9RSfm4L*6e_R4+9Qrfq;g-`fyZtPi70;(xKOJ~-Tn$Z?{xH<%71Aa
zTvE;kcbV*$ZT6I87ftrtHv2)z=9zA`SPkBjmR^wTD)1z;m)h(lA>!U(ve(({UCiFa
zUqqN;h9})Odyus;;F7u9&Vnh7IdK2@pk?rl!r(QFEQ4<p244es_yICtOMq^PGJC5q
z>j27n#7b9qif{v&ce60}(|}V~uLQhB;J|?m%G+%M{tb!;=@lNl*YfI=@aj7#z><cX
zP`DGFO)$Ww+&U%P8b>B7K~5<AxWbSV3jbJP$O(ntR2VW%;p&Jy4>_TYtX3FuLg6h6
zLry6C9>5^?ONQK!qR-%$^5Byox6IOmr2EiYD1TPURJB$>Adqoik-TFVcOi<u4YK~H
zqB9|xB9_Jyl!(G^#Lao1z%Pc}Ck@dLTxYUYm@IgJT_)=)leNm}*kQ7wCTlgEc4U!<
z_DWX2anQ;CuwP#0NKA05<B+NOr@oqIjRX&D&=pWI$M?Xa=7DFmH8^P~bvnLdvj5Iz
zE06OVChW+YHv5p&-f6PK;7ZuOUQ6GR(!D6<x?QiOVzk*HgT}JVy5&;j8D6%KX5~=y
zzOw%N%E}M4{jOrE40fbK`d$GNI2}j8aIAZiAO<NOM5!}G{=G-DC}p}{0!-5h2*k4;
zod+w#T~7O?Jjf?T|9u%UWOuSWh+Ahgu@D)uL0KML!i-;Eh>SW~K;`1rjLzdit=Eh&
zYgA&a;xeNK#ntG~ArIU}tpV5>{p+pBkiE?EAn-e*_kp)v+0N9s$!PpMWXO&tY&q7L
zdlfP+p@t}zquryYpug@K&8TIK*YVfAR5R8x<9}a-jJ2Avff+Se0WMGb0S6bu=$|uo
zaXDkd8txr!r6StIh>6AtM++QF=5IdCjJ;UE5`Y=~{VL}2cd^WKhjHuP^?Rwdi`5vs
z8$IJx=K89&)Fb07i$B8W+E~rG3Dw@uv3{jgP2A@#s3h+5LT9wD85N$~A&;%*W0&G~
z^ui|Q&U)<q_OW+?AROIuACkvv`B;{Zy+FD>H|w#l+Q&|JQV(^Y!XEeA^4wfL_bJ?_
zUZb$x<CY#wJ%yFwo*sBZD*hwrS;0@{q#hxIoF4F1d>m}&J`p(cqa63&up$Ejsj4lK
z?W=g@>BxB|uu&>L!HOhMYW?|=?W-7TK~8gUR4P8iiqgmDH%qp!;<63Mi3bl##XDJ%
z5wz58>`^>eswgyn0=0zZwHQS$YJ4&HeR(j=2S1P76oo9ZOAn^*T92H^g1?iB?W`zN
z=p!dR=C7C}UA_@K_YkQ71~Pp<muul0zKYV7&8Q_^sc}-1<l|?9JLEyk0)Cngx2dx@
zPtW=uOns{kIo}I@Kq{i1srXxV<$J!0ndjy^&Ncjr632DRxh}tiN5-7YUqFCfyW~><
zke@{UcO*Z%yB5ypBkqr-pyDYcnXhcZ2IZYw%2+k?2&gh|`JK@60RG_;oLQB9cOY2@
zBsCwiWR(#)PWG=b{K&rtE<l0nRs@h_J_eJp=Tv?q94PicDD0f%IX3`5!1}-HyX>Xw
zX75;ocwC>msYW20*6$fGP-Y%h_IuCMikWlJv-h5F0gU%T`6VQv_+lr313~`gE1($g
zE;uxYKZ}627C{bOE++_3bS@Uyf<+;|v4Wyo(VI;Xe!~&~zZKaU;rA#pM(#lV&W>@u
zlX;`fady1?D;ZpdFUWWQ=P#~R9CHz)*!gktkehP{mV(+E$Z)ABt5FG?V7uL~L2m4-
zkYI$HcVigqyN7jK)@1}&k2PuKf_o3B-rwrF3`Oht!JPZ^If(9FAR!W$yCQ;F{x}79
z9f-eUzbhf&YVO-2?<o+ff3xc{0Ix{$?)xyqJDzsk%Sn00;Hx>%YS}Z~?e5%wCt9>H
z=SC{g;6iyNSc0{sE;>2)4J_YXbG0|L1F9bZMm=3zbjLBeU2}A-Qh>%zb(dBzm=~-*
ztNK*;U2Ygm8Cc@Xn|CF$aG1p0LX4H2f?TX7*KJ?mE&!7)cG?#(UNwgW?Z~OP06AdP
z1#Yl<-n`4_T``aKD(5@FY69&G)}rH3U=~E^8$gAY!R|TDy|9W;RF?~$Qx>=-EaB6f
z3#*9zRNmm+6tJ2niFLsOV3pb+@xrnh9XM?n$|7LO)7gM_{)`Jil^Q;@4#>_db#dOj
z`SYsg5#=Ip80GBLS*F2q9R~2pFbsIMR4&I*r1CkX(h|aR&+v_>w$!BKES`@6v(57^
zk&&P8jRxdh;-MCDE)}w4louF6q6b)F-jJpJWoOKwz(r-gmX{L&_WsOxWabc}VqTr0
zxZtQa-4&prG$6iJqUfY#CAwEpnx|FhdIf2^+TfS&HPxd(oM+O%R>pBjxi^8ZT$_Br
zrKrrQEiYAGYbpz}%S>efE-ztLyjP&AVK;1$psEL~p9l4NrK#^jewBGb@NKAfuBx(q
z<$~By`O%FSPP0G1eSxoJW4&vh08THTEVHSEIDpB8JyNPT14XMJg|CE2Hv5oZZEo?Z
z3N59*5PHa}ZKa{}^ZV@_eEWi?DmLD6$IUL5I%W$MJMX+1KM`1YfI;*wTY$}S54TWf
z2JUX)mPu(}K-@isu%H>i-qMs1>;q1RjbXRMlz`1x((eP&_<%uUO1GVjXV~nHdDjS&
zY%h0KE?~(0YF`O>e~0Ab2Gv*}qP+<<A-a9_@Yqh)gVyo}2BOUv)_b+5AKqBSdNHL1
zWTf7h?6~*1oncGy!Fles5Gk7A4SWE7jycI=ANq(+)36z|@LQ?`aGFL8eNYy`@bF_|
zmg*E>*ZDw<Zqz(W>fzZ;3B0O`OK@y4gk09-0;A^Uyp9P6trOOvVsLhQ3~EXoC+}4j
zme9%tFBA1NtLV>aU%=L#2k|H1bb~Ab_dlxVLkqi@C<m82luu74^M!`^SSFWBCmP0c
zdy;u4olRsWhLR1LbarCOgC^qR>4tb=tS*(zCiCfpSK!ZUz{dj{hSQm3K9?&t6yv%2
z>yz13!*zqPruwFaL~d*>mu;~4kHPo{Jsr;{MjGPzF%J#e_xd6zwcmdbvKd{OIbMM*
zWw0MMmWhpzO~m4vR4$(`j*QhK1_3J~Gcgz&N)FeLfW}U8YCM-O>U}y}tjlE9Gyw{N
zgGvyrsPSAOJryfXk0%Q#27}pK;24}pArF<(xe~I`+~9S|L@}0SeN@U#6qETxJTa04
zjG2uWb7Sd*|GqAh%Nj(5>B6vi&frlbHgjyu>k3d8(_=&mW2yl3Lt3>kp3Y`+iBYd2
z+B_x?59jyHsD&KDL&<SPGoH^Sl7&Jp4-go}Fp4QH8O>W7?un-j1ry^FWAVbMR><at
zk|n5++#MsEX&E3kV=$Qkpl$HmcqUm)=dxOaFLdF{TzZdR)t<1==gjmKigDBQc&Zp5
z%p~hpWs;N0Or4z`_Id33T-LOk-&07A)mb_y-f_&!_=Mi)2aEZnshcfe@Ke)TkjPuY
zCNpds#Mb_d$Mf+qt>bkNjV9vb@xgQ^T{O>60N0@K4n{dP#^zXSe1c<-U6&pnPD?4c
z2t8DM_?5(LJW~f=H9V&o`Y7(x+2I@j@Tyk;<oKO3eO$*COXMc9U_FB}nIMTxg-p6&
zsFzO`aufN4VI%e_zk4D%VJIQ6J~NW{0Y%JpES-zRffS9Tg?-6ECBzfOLN+e!iTn}(
z@(m?3aS{h)VD;EwMq3!Ni-co|7e_QVA0J9j)s-d(<Qj`}9I&qoBl&c8)DCehoyy0H
z$rxtCbbn~~U}iKnB~(Q9-4nTDT(M$OuCwH_+2~q!xDdntX{|IEFM@v4F`4P4k`fM*
z6)!3xQ5AWE=^{R8gnJBXbSycRNyZJ2Lt3v=bg5)9mmiYea<Vh=LCqi81D?@G$1$Fw
zT^z}LHfcyh(re{Cx%{Yaf=1G*5iAugD-`iK1qleqPUedgGw2;$5M;qMdCYYee0o7=
z@Ym%X3sPO*T+rFg|3`u^PIolmw2a%yKdCPM-6wzKHZ;upP)Z9|2JbC@yyv3&m5rSv
zT@7^&!BYcQy1@@!e{+39<BCQ>6Y2;ZZfLx?v*BZFQu0)2IFv%whC6zK;~i^)Q}w}l
z9nzNk+1J$&eB#Cj>Q`R8m9^N6{7G#s3j}}a)CY&^VXL=DFSLiO(%IDrjQf)f4V_zq
z$@<_~_0miIE3L{9<bll|&h}_~LuY40aLJqXEBAGdHm+FSP}kWOT>rr7%U2DqT6yux
z;B?2TbVDlDSr>dISYO|es%!W_1O5g-xwjrYTq%tVhpt=0o8a}2OR~B{lC9Es6Ym@O
zXGK?M-M+fchR(W%WJ7yH#eH?1eYYq<9te$etw8CmtQWf3K=_$sKpbcw^aTHYAYIoW
zBOnDwf|U={ulB0AAt`C^>}+2pnZVNC(6DMn*NT<xD?95(gTwW~MM{s3(ErK=tLy86
zg?c6pb-^NTI##R<?ye7>QoldA`({iD^Y?IWkdN}J`dfn&H?LaWQy09x9&@{D`6Vo#
zTaUkMmapy&-d1*V{pyQW?`u5V5PX+5G#vWLlMQuSwUeQrND6LvqM@$4p-G3{0bUr<
z+xk#vs;jS|y%E3EgOR7ePr<Lf@8;Dj8dG(Roh#9w2K?XNP}jI(C2lTW-Pusr6P(|H
zVf3sCPS@A1Nj0WY=-T1Bip32p8tXb6R|G5TgOluT6bS(70{;entOS#$KhRaNSeoRY
zH2+-8KaCIauVHxUldp_L`z(VCmf1D#kf(3PsC;O!9{o*pJ>4lBf<+?pH@i5C>H+Nm
z=6t^(dLXo#q>%fYLn*A1nG_yA358Rst}#+r27*R^0!+jpJOhfi2j^DQf?g}vU|Jhj
zG%&ejq=AccZvBmzgNg&G&Q!ynHB@{#mHM;86<>%3Z*@C5z$L+|j^G4tNbfo(d+Hn3
zr1qz}gosLCT?g#Av?oNCHMD|xQrgZt0j1!6uK>SCVycuLGZQKqvJ`|U0tzw#FXDr8
zCupVR;P)U%9>1~U#k$6}!|k0|jn`mV{%ys1`yT{lN0&Fs<Dk#aI#YF>PaY=kJvg#r
zKSUbtu!g<Pyyao9le^VV)PX*Ajrgx_KPcP2az#VK*3_+?pIC{77~KE<iXBl<v;LCQ
zzOKWm&W5g3YTwq28*TwVuX^&u!^9zys;;w35DHWEF<U4jMA4R*S0Y7;P^G&qtg<rt
z5Eg7#-Rg^Upa)Y=bna_xYrO5LeRU1{G3vU8+gLC3fN~%Pof^T<FffZ^CQWu3f!M37
zI8fKHdS6#(<E^QEon2jl2s{${DgTXsuH){luA1)<w*R<SVqxBgeee?8ukgXWv&whP
zg2w?92QU8HkLw;>E!7qK0(c3J`1p?})SpM%QoUsV+*>McopW30_VPQ*?hO7BYIRkQ
z*Rm4+y^MOS+frS-uVVk4TSB*%-&S^e@J`}Fz*GM51Tzn$w^Y~c58YCJYuRnV+gVOm
zkN-A6aStJFsSfWiyCrz5zl`TnM^M)0E3<v)q0csXu3|r*v3=)(&0e(GQoU?n<*~i@
z+U1Ev_8;x;E88Eu#ouS1`TLUgd0%LM`7LF)25<BCi-+lyZdH8pR#f%ce->pgqu<A+
zT}$=aTGZt~9z?od+K7}WcSqn(KQ5l?;K9=q;2N=G=H@tm`|P;&x~fOSm5C)`RpJ){
z=^53^9~eeXEH;6#SA1e9U4(TD<94bD6Ed6RpHYX#evE!WEL}{(&x{oYV>B?G$uXF4
zsbmaBUlHCN9)_t5{|xqH9M*koa*S2v$syR|Fsft8d_J3VXy&3;F%EAEl@jqxVj@Em
zlWsK-N^M$N2_Q<r9jBiY%f|&5dd1F9WND)(hiW;1Os0@bjym~FdMuWh$UEK9SZ8ar
zyR|FUKhV6X)9H$Ci*4&}-QK=wpm}3gD@^(ry(I^B;UwAx#yv1DV=&s2`N^aMQx!Jf
zM54$(qFedoSZ*>In}8#fEyfD?<G>dv<lsz@m>5(pZ!3`^Y`?v~r>l9OwI#N>9Sy>?
zR=>d+$;Wu8l76(cgJGsRuqk8cg2Pw@oHeI8x;56{x+&JWqkX`5Bf~?nJ-bJod=f@*
zAqk%cI0t!GNDpG7QcgA>Q(GMf3eIqxKSnN;<5*)kbU98(umBYCA^6tugfp}|9UIQ&
z$Kn`jY<D6z4qkxa4+A*{H*xhUoG%_F4TOTtn+Dpqx5k>gd%8KX`9Y_puYVx6IojG9
zYw6q8Gtdvr!+b9cA&?lol)`vCk#vUA`QmgeP4`vV1a1r2B%g%E4M#=nZcqS>lxARI
z+KG|pfUDqSQ~BHkK51ImgVEAIvokZ2go$2s;u#Fi;GUp|f*vQQz=|?+7}VfUnuK8=
z(#awCf|=o1aw>^uhMb{^F%Shr$YpcG!!hy20mVk*g%M0WoCBGs!bD*_nH>T*rpR3B
z*hFDaTr4LImP}u-wPXR9DjYj}EwJ)%KAr-~!B`rsJOutsgQ7}cOuHRSTXdj(Yil&N
zwRuNuQ&-QX&e+E0{?>kauCa;iP)^s|P%JHOp)-nBQ}F~R(<#FD%5W9Y#mdA}1zBDC
z0NC*AX!}6xMy!F@K<n0CFgnIrbcQpr+#XQa$&AGY!40Dh_&Yz0Wx&sNlQ)Zd(xed1
z_r{WA<CqfQA}7aM+M@&4I0!x=<O6>bY*lb3hYMr$SDiuOw4vl=8q<zQP#P;LmZdo1
z`YeESgVV(%(i}q^vBJcdlTGf488;T>EP{FP%mm1n$xrAg;A;wz3vdOw?qYEAMer1o
z<j!Q#E=+dCN{r$NncUJ>WgnM!F_z1c<3}A7CU+x(lR;l&d%$){Je<x@fJul4GYnCH
zMTWRf%E=GL7|(Ndvn!yWjm6+rI8=DknaFZcLiojjUgv6Xh<<L-p-1Ty;*>FPS3!DG
zSvXEb(FEj}tT%C+Q4LEJtcW?tCli@C1e>hGLToIKFr~E5LObbjR>`$7S!BE6YG)H@
zWoS26j>jt6QIgU0Z3unI=cZ#rY|}wMhgQZ=e-aEusaje#D4KwvVVCpCl%bYkWAWmJ
z4X(=#CW;xUC5s_GlmP#O$O()Xl!N0u$VH{AAO^9YiN%M8Al|`@cB&F%@u_?P6N&CK
z4?!sD*{T?_vV|NJfqL^!ehiD6qFjZvsH9jSHw^V9j3*r#PmT)9b1j4G$#%ljBT!(u
z{Is(bV)p9h-qvmrULsjVf)7JiO%);ONpQTW)3dQ7*4-Z)xTY7&QkYj12*#wkK_{D&
zOo;~R2!TOasw0Tm*aoPFhRMSi{2=t7Gd>KlFH%gDO*$b`&>75+Lg8WQkAdHYI2FTj
zD8V70gpb7$<ARa~Ys##nsRT63)mxjRow2R$-6ozEGXYO0i^a}P>&mCXkxqjZH}!54
z(bL|71+GI(XD4HORK!A8<|iC>77GEZeo}dTyqF}TK-@w!4#kUc$Lhz4@o{iDrZ791
zDC~he0y7o3o+pzDClj|4AA$zv0^^D@Q_zOg-B@#2lBgqN8qDP~j$snS5oKwCc8JOf
zai_<?9v*QK2#RSqAF;4(5fLVz&Pz@ulH-(^F$rtZ5W@89VuKhZYeTG0<}wgE6w<;~
z6Bq=9O<F>9PQyrUELn=^Gh{R~tnUoxa|rf3afI+xqNw1Z-f~9Mxx}E88%Fp%!?6`G
zKa`oWRA_RkD(Q~(ba%CPw~EpLJw$C5oZZ7lj#Ax#<tc?Azm)B$ohYP07AShv0-&Hs
zO%;fo>P&8I5UnA;D63#NoreuKCR&cHGd_)XCW@3#w1FTUMR!xn!1Ng#Q!{XeEaIcF
z0_7(aAu3{x<tMUPc4df*9g5WIJkpoaH;+&FZtZE=21bKvHqaW|)B{%CVz&c;B2Td<
zfl%!~=|6;3FN^}yNsYv5N4EnCC2<4Yi?xGTH@X2~Ga++pR1(*)k=#RRObX4)7<5U3
zwj2ZR8tIow2lJ&91qnAQt8vC)WEAr>W<;wqY)Ww=ebOBdKd(_B!FE9fQLZtiF_(^$
zoq)!jfR-MVC4+qjox<+e*4C{((QBY5_Q2%KQ=@Nf-x4K>bVZKmG8v*o6deSDI_~dk
z-WZFvZt7}o-zrwE%m-DiVGG(pu*GwGAij$u)F!Z7#B79J0gi%drfwyRb6X)c8Ha6(
zj!8!g`GmDaLDb0@_G@6s6}TlpHKt5vrC4l)>Iy0%?=$-fnPid{4z*u8YZysPP^W*R
zSdG`p^!IkP4zyyCV^a%#geICnN*D=)LS_*hP-e22jNz_whvbe?;bW{B>Pt#s$c;8*
zRneA;ZSCpq8R+S5--L1~9cYeHCpP!%w5oy}oJOcyw;EtJ%7}&D8+*2OZ)%0c6*?m(
zo<(=lVp&eBr7|`qN@z>>w%Sd#P4$=7udZFyxN>#ls>Vxdmw}4LbiWAVDLw?R3HFMr
zUeH{PPg+j!vqbh$LSrk$8N-^T36YLx99pju*QVm9mWN<5J0YqDo#7aFR)o(|<C)m-
zL~(+Obb3rhnK%qX*c%x2EzaKd7V=oEzr97av|`u`g=(TW5Y`<w(+w@8b``w~t_k{1
zcu$=_2s`2#Tcj^n34Vvb=LU(_Kq+9o9<h<tQv^M*CLq>S8i`lYe@*wMevHOAn>6~2
zv{uQAzJM-32CmV06QXs;x_hEqo4f3Cioq~a(Iv}jES?9$+b)Q^3DY(P1&Em#r2bK{
zr;=2)16?TaHvKvn14XEH7<oqU!eP;=7lL6Lb?U(LB%W}?aDg^8C59S$Dom8XLS6oW
zgOR{yhe0-}27wr;WU)ao8$?eLUKAuX{nGS!f*urDK>NrgK;a;|9gEmc=wdQ4lFebi
zWE$iwszWG_y~yZ2@jMVgUiwTk>IY+?X2FE8fk2o%MJ0U}h)pQSBA5&fPCySA);ibr
zbaRPq7dZqns3RZ(e0&0v45<OVORqm&u*{s9j!ldgbC847Xv+VF;^L92bdAMGN!j3m
zQW2&R&wva%Nkcw11Ygk;dKmjK<cGJJbgaQe_LPlNT|KnXW||Qb*<&A?7-u(iHGuQ>
z#7C3xO05MZG7f?q{w<9y&x0r#6;6Tu)%{GUSg0F{Ma5@!0AmUAgnIP3+?ZK%G#o`O
z`^+_1m%@{U33@|58^?rSz@s`g?0Qd9)Kl@QZ^Iv>hOXwKh$p~I)RnN#)--``hyty}
zL|`jz5<B3D(IkvEdJ?RpHW4hC;*@f=_Me)_YN=>ze`|C*LLGF0GD-NS(<VHD?MxaG
z6ueNGz$O8j{x)blOzEI<piGNwEYj9d8<jrP7(^dJ2v`NMHql&+o+_*iP>?wjNv{Lj
zx-A2WzfDg-yFH2Z4m)5pHlBf$ft;E^P#}-h1MzBijIp#uuH*}de@s&e8pF#*zZjkv
z&VoM1SyBa<%@xzwIYr<F%nj6I@hs)UL>7Ke5+)j~fN@%o!wD`Hl1mJsk%{6EeI64o
z7)C{L-Qj;=BePU54%5pDD=zT~D4!hnAL-SNz&)_?pb&!(4#wj8FiQzT7%rG@=;ER{
z?lwUjiAs&C?*^GdlTG&dIdX;oVYAaf<pBX$wZ`%m4+Tc}5PrPc7Yjo;MHx~Ig;@qC
zShPTw2N5A<a9Aa<JIRtpdx0pryiHgLijgNIpg%w|x>0t4P<N?NfaOB*Pb(Vn5!f9{
zS4%1ynd(2v$_5_DAYwBLm@byY{Xmhe47WI#0c-d=!xPyAW=)LqvG{eE8pvDNM8olk
zOcA`CaSD{rD&rjGRM^VU+eSExWeq7uMi7(88mWlY(0uhcws%vn@wQ_51k@WPR{;lE
z5CkEc%y6O;4*3&wbhh<J8Ek77=}$pG&cOQ3CwW)~9Yt8ib8HY)gl7g9k!BR<F@<0w
zr8rEt^dR^3Nf!kEV8T#DDcR^`sG3Eg$eLqaSsN8I(}iwRn21Oz06C^)hMnJq(4jYz
zG|^}la%phG-iE{=i3fd#8$`-Lb96wvVisO&W*A|T{%J_HX|NSUAy=9xm_554h7-U$
z>b&?xBL*QVjk>EK5!N&#oD#!^c}xA_uMT57otSpwG9ig<S{&Juq$}CnoF~T0B#wba
zNxlYmi*)Bf2IW0^5Do&P(Bj7N6j>-*5`=<NO7mtMW?^xJu{{KqZERY_?Xl!H8p*Oe
zrZk>l=+rmWw3x-(6>TqT#`wi%&7@W4DXU{e9UEdOxpT1KF}+kw1>uqS&~=DKWN{2j
zMghB#XDo(g^+;e+PD)VMn$R{D7)(5_SwEqz>Djx5wr5OFo?zJw8gWnhj_=8XLbT{b
z5{dgi6tn)HbqQ=ROD!-H@hg(tB#SyDbOW!?2!fczsi~{T5R|8~V7Zo(vhrYVOXy|T
zM3pl+jKzdRFdZ7h6>WwIA45oju^4YUB#;4FDyt|)zXVzjvG#&!40sq~h}y7_nM_7o
zIZVhAhP{%A!BGAIji`FiCnq5cbQhW(=HZxzq9lMWKA5QSV+<NKUMzM5Br&ZFZPIvR
zY+hHrn)aBYM4tOJ2-(GA=~z~nN2Vb;%AFTAT8t?}S(P5d88&ajqNR1a>{+n$y2xc$
zhLo2;@Uixm?mxta22=2ihlfF@VRcw>YN!d)S0X(^5iimMnKLN+PE-^kD-%$ih^m<=
zM>ekx$dH7t*m>Hq(2n$8efAqf9#@*2SL4Gx*JXSPE(b^!iF;8Iihl~Zl1xD1C!E+u
zMy5<GHVH!`J1Pb_9ucb_5<%o4%?D*$$woc&6W*p+(-2jNbi)d!aS6v&Brs<LI~B1#
zBarno^g0a_ita%O8I6!YYDg<86t9LFb&zAYMT=+#rSrRW)(Qw}ijv?)4_F=slu{4!
zi2*)iI>2%ebL7~$0=djqo#k|R%lrt4x?pO*Fea-m1fqUpF?!0P@F$>oH1d*2I1;U<
z<48j15Qy=IHeq){2g(Ug6YUeZL1IEbB7Vj#1^>A;+7lAIMSKw(CbXfben*WXCH930
z;Lx;%4}vN@BnZi%AqA`)Sj5oxRQK3Blev&Uuf_{;5)HdiSQ*>{gx_w|rH+SE1F=Gh
z?CYjja~JFiyDP@+$C;LwtS6o{jv+ej_#E{_9-$|gCEL28`mj|Q>qc<G8bDN+;=o^r
zvxU$RYC$nRz)lw@!GUli1qJnxTGKS>xPL$s&ogp?5~h=}%k5qxcAv0ch-fs76p4Lf
zn<oK%<Q;rP;D?dH_{7wt@-$5Y?F8(E%owc~YhtOH%)Y65;fT%bClR+!q?1`FShH+p
z--W(O!Dx93TL2RHF<u9)6U?gYiYQ9$t48<=;6Q|eji1V;$Og><GiJ7!@`6%AB;zSW
zpT)D_0Y~`P@hsKM7($sNFn@tyNCVtr)&iAAmC|6ZDRkU(){ObAYp|L78LIvzz^A=P
zp(pG);@#YP#O@8;hG|0?G4rgUD919vsj$>!zllz>ccj?FJWXIXB}*R>S=!dvf)^QL
zHOg%33|di|gmZ@-!bxoR)9x~hi(C3Lt+g#Z49c2q3{?i^^ses2!cw76NAr=UG57mG
zagk~=LdI}Ml2fsGfrsSj7>}pN$tqO;V)t97YwyMe_t+>39BlolwT<Z^=3|YX6N(=&
zId&|du~m}FjA1<(y{aa$&&J2_IWgimP%ZMn!78k2#9kQ<fzSdAWFbIGyED3VWL#z*
zMK!Tu8C-r3m2rH01e;bM2!?6wK8QYGk!9lZ(+eUz#L-l@H(5yJ(};yI{z@la8PLZI
z(hAX(P9~_8D5ynN2}5F~!}_J7n6Z$R<Oth}n+i`6am`T;9ZBTV+uiML-h%xtSt#kD
zDQp+#Mj^FJq!p>!9cydf(q<!USQxTlfL%ODam0xs)hN_B3T&r3u(FS9m3ToGvt@(e
zZN513SO)?ny3&0rdmIB~FrhG=#qJ`Q4l<N-Q5C*1OSq&k4+(}ctVM?yDBb~Z;B#$@
zZN|Zhts7fgAo68<gF=-Nf2fumd_S-TRVH{CDuJp{SaD{QX!ZhwBdYs3stM%`f-GLJ
zrgb+ZKI0vWP&Z#aQPn1h^kqgx(fGv%luZI+RJdFAK#S0)=oZuwHWMIEu#<(e?vP}{
zqt+p&Bv9+qZ-9^F=zPbf#K|Px#DazNOcpiI3JQcv5d=lNj$1;aY7#We5YeZtgJ7~X
z{3Y~9hLCU$f~bR~T_1!bxM|KkQrK3UF3cphXr#Z;a@)7|Z))z=LkhYfVK!Y=iFWn$
zbZ+bI$4LU5*HB~9%C{3s0yz=GCCDu{;R<*x@hpxCS?^GsJuVz!blPP`4vxaE#PM~o
zD|h49B4s!aE{%zKf!xNgz-Z|0iqA7Dh698ebT9-D*gnP1(jcJr^Zaaj4{_}3a@$no
zlo;>2K{Jf~JB0FiRseew*%XD5xm{hlZBj~LYlxdcYKkCsu7L@eNP5#S;~>LeM)GZ$
z_8yqsd}+qm_})IF?#-ensVs`@OCr`5mdGthC|)1*0M9gFR1$oKEl<O3JSC(PHHU9K
zt877VQ5n^&L>MH9nZQfH%8Pbr++sWhI*Xf(y(#nF4t+wPWK0Y5BH?Xsp<s`my9X+p
z7z|azrnHd<bJAz2={X2kYGz&Fb88aI@lK4<3~?mPsgYktS8i+&oAVM^%oRuAg~UeF
z@Y=C_#d23`87x8nh<^~Cf`O5kkgYEmjGlKh(^Zk^HB=1vjR6P-GC@Ba*y1L0K_oX^
zWJG`Pxv4?SIUNIZI3w=Y2|PJ#dwWhlqO=+T1GkxD1>CdqQOGz(%HR}d<_r=$ARI57
zE-ld>EH_#DLpkAM94OGJqLXCM*jS=e`jAOba<t0qnmkcRV)S|=S4XB{bHYFZ6^F3<
zC2T6uDliyV4AAP)t8^;CopBAZ!KR$Zny{8_O1MDY+!K!|oyCNu#ZWhjeGrx)CXPfF
zV}L%2jo;WXG1k4Tx=|i3!|LSO5S5rBJ-DnX#wD(gT@H=7;=Mj}-y<MJx^c$js2A8p
zoqbWU1yLNwGQ^Bfo%iaAU0*U4(bndcei;nIA2_wezyNrM);a7{>qv5%Vd#i;S`sy)
z!FV8(vM5m~im<Zp&**lx?zvgR0A>Y)X7Umq)Pq?N>Tnv4;(jp=8{IrCMc2`^yy+xX
zDQIEn1Z&RtB}gd1p|ff2XL+mzHW7B2MYcd|2@@S_>>Y0(MhRe|n<j8TucKs;IW)~w
zKw$pV2cGHRGbDzPCwED)9C&yT$I!fEM0&VH#0jJLa-IVf1`)=_(6BOL%QDg)$F>u8
zu#9TMu7{mH*^bhv31zrA`Vz_DFon(GX~?^ZAeL;*<3Q(_=X_A$C<mz>sv96?Lu7_O
zE6l;T29E6^5IQalqK1z&#o3$TdFmD{?KOxPwU;Es;j>s|c(MlVN;8YvY?aD-LGWb)
zYe%HNNIw&`lO6hao)%3;ZAhcSBq%|%0lq2x$J7Llg_ux-9Z`lmrlLL#E00_MUQA9h
zv>uk5ke4tq1qfl#l<RK2y6c)4PcC7PZJ52nn#V55WtTCqtww`6OGckUjzhpK6yAff
zVhp%+!V(?FhEnNZ09DTB=51XAy02$8JrLT`6RzM03Pp)v!<v!vkz1R4dtq2g!&nk%
zQsj?~)L;=wEDtQJhOxIT4PL+=f@7j^h6Nx+bT7b&{Nu<Idipcu2?#wg6&u7<jZuag
z8SMq?AZy1{G|<sw|7H+Hs+?aOr;85;2VEHRfZH?<!JUS5IZo@dt#~m^G-6_`1x_9N
zD0ZzUH_bs*S!X;3N{by4SE>ZbON=05%JVA}u);dz19Nsu1O_M!-6LCiur<h-#?H_^
zWZ_i3<zU4Gfc|Aq1d|3nNep9wiycFgN7txWxKKhRE{Exg%{SVTv|=%#P-gHK_CStc
z=LPndHJN$*Z4#81x5VYhHTR_Dysa2%8m<+WPC1HOvSN=8!yvak)l+b4U0@R?PKU<`
zKDpKNR^V~&BqD&pqt9ZK>ZvAhjyPcu*}jt=Fc!t3DZs*|;(}T+2hNpL5*@**Q7B`C
z2@vu?5E@7FaYU5ZurRiDZ;tj{i_c|2%u{aahJt5=s-=guEP-oXt6(RFa1g!6=~oy!
zFz2{Z)STm)1_Z~!l6h>}Gu&j~pC*59-x?G5f=9(-ILN%UA7oY8YRp}B)W)&&<YQOQ
z)qIqaj|YG3whPW!$Po_uOfdT}Ixc<AE}RmcH^BBRPIFLb2)h~k6=4$w%EW-BvxuXD
zbm+KwuT~}I8iy3Q1WkNsRA}h)SoN4DaquK{Vdk+UsQE6Q{Wj;%#D8}Z386PW6KwCW
zYj5Nqr8=hv9p@=E9^7EiLQNfsBAIn39;nE38{q&BMq#kPM(sA#D9K1YghfgLkQxUG
z(03f}EWp{2Eq0J;R72sJQJ7_@-R3`7HPGCS6EwX&{r&BHwPJKP>NAoGo#w4}(+Zt|
z9L*=|gm*`c!KJ1*)a@AOj)&F<z+((GLQ{(Mj)P2yCs{QuJBN@clq#@@%<)0)&GO7N
zcZ7`u#yMJ%S~Hz@PilGgavDeBXv>PQhCtFN77R~WQ$VWn!fHj#HY4}6AGiZS4iLM8
z$6#sVYy2EW0gf_@Jdu+WrHQhpC{H<I7hwuZ)b6bKj~e4J6HbD1a(IpzM_0MP<xB)j
zS6x%^CiH~5*x1@GXOgslmCg?7(BO?4mK9N=K|~QkK#SlTcDEpFk3%et(V8fYu|V}e
zfjYxHE})x0aymgnw{ohUn?BwKANKdq0T}_-n0C~+N<^k%?rEgNR5r+)Cx{t{HKQjh
zW*m1xUuccd&zp9r(CJmjX^P?16xw_!S!r)pmAKIy1Qm0Iet~%hK-LE0>)dgp;xlHg
zdVdm}LQueSc1U9`EaTUCtPa}(3@*`DoC~4JNJ$B^c{fgXDcMZeo!i6UV6|2C9U@t-
zmdDt_48@*?&7*Xi$nHTHTD74>7pXz?@SLh9_=9qMLYW$Qx^)6RRs_ZX)%`r~Cc-YE
z9SvWBEQSm*kgyFa4iRi$M%K|F&$Z$84RDgaCdO)dWKM`NL63PNCAJ}U3)HRPX#zQG
zM%*BY?%QLxUTqz05aAUcZi44`d;S-KA$)fSdenH#`1FH#%;G)EOC%6|+zwD$=nD~C
zgA@lNqO}KMPLM%xN`8okD_{@NPaYOlll6?*&cw5bTGA-y(Q`1M9IM^dJ^Ns7z7$%~
zS8k{!%!1-eDCjQt4^(SORI7dK*4CDG9N?8Woe4E~@7&p0_C%2lgJL7v9OuU9`EH7g
zfohA}M54OX-j+GY%XTr(QW!;z$OQDL`0mIA4Y_)R<Atfsc7ctEiJ1!GL#OFmSlH`9
zq>QJJL5l947IRFy-{X6{jAVr-mWVJ8NQsqZkN=a6L}Km1tA55NfzPOOPw(G5p8;dc
z3l0gJsZW9-iUvmfLShX5H!;RxoYEqdZ}q?+MJMI;vrSu@jnJTHCWn>Pj1=90(RoLq
zRBL0xsMBY>*8x{zK%>P@dKk-6EJ%nEoZ(PG!%@-S;#(fp;Tlyt%FZUdM}3o#tAP%g
z^n!Ab8@Jf_!iX8YmdLbyh&Jhrg>LsoHuXeXJzd$nZJ>wa^}okxD`L}K_EBg=7R(zU
z49S}1#BBBS;YQ%RtbN%_oEH>;3$O@i2dVXI&bpby4qS!Uk(#FUD+e&dBP)q+G7qD7
z>LFjB6#GZ!Q?`^vJ%AE+w1&^c2^aQLtww1#MZ<<0D7x@vv6g0EDq}7*IAi0B^2Cgj
zMlexv1Q<RTJ1c!9Psk1QH6|3>>j=zfXh32u@{$~aEi~J~lT@%8t1u@;u+<N_A;;4^
zapwtq-3jFGF=m!WO(>?JY|{KfNo->ED*rxqY#0s>HG;%!8Fd#nv}~+;50L*=OR_t@
zAcYhBC7Od@#$cHulu>#&3}+P(RKdm$g>5OwY&~q<w?v>;HGsaiq%nVl9zhXC*+kh{
z*-jotfo^*WZ%~V<$t*7}hzfwVqlkgfD2yPEV!S<`;IW&r#x~VmIQxDB-|>?03#5mH
zYN5iRghbcN$`iw14|DT{1C0zLDhruoeKrhqxF9+o63h58hA-&yW6fa;L&7O=>ZpZa
zcu+hILrv*XVhm0coqc5tOHoPUi*e{{fe>*F5{WnkPDuI^iz{gnR#7fPTiAWeKm$X!
z!vdUC1u45~*mOpm6U+lE9d5FBqQ#5d(WdmBZ9xYMBUx<4nKNi2MoZ^?KtdSos?FsP
zFX?aPvr()F4}z)HEL9CCFVhOY%5uX=9T<<aP*dUsIykq`KOleLc6BxP57=`X#;DS5
z6+ME&=w$(~H4Re-k~fro$A+G9c3!QuNv;kWMe)oqOj^3;d^Jfo`^ma`ki%GIT)UWO
zEGfKurV(FjT$#7d)E|^x^gR4?&hxSKrFb!qi=hH56)lt7#1A&%8T1Bc-9=}pqU9dB
zNDlLsp@SFla5g}A#&8;Z!8rCu#6v^`KTqWVEaJ7mY_g68lp!OB7&hKnmmLVcd5!3L
zTpGX*+^n}X#7gm0K1_24lX*5Z7W0moN!$E_l5m>nSgHu`tcgVY_$r^qT)Cmat$tMD
zYrO4{ku(=|mDuxi$I|ZD16m@o^XBb-m>J|c@jr}(D_#_QSL~%SKus@JLl+1G$O_cT
zdPc;YLPp>a=T;ft=KkCSj)(BrH?|W?p=R{kd!HF%)<kan?~aK~p@`?Z4t!-vEkR3r
z&bNMYO@uImOyDh0q!jX#29Co(GrXWuxLFQv(vnAiJQ0MKwqZ_UzGSl_1N@kG21O^W
zLx}@Y<|7J}XI!w3xZ<+1M8+6H9Tq#oSL)Kj$Tz2K$<6xCjJ`>&JgYXXysK-^kI5?n
z>IHbaMrJQaL$^st>7<y3-r|-Ofr*p223Cs(P3_S`v0&wox1mPA2zzIE>&V-f@YEx0
z40)|t3?bd2fjN?))R)7l2)k&EoE{99h*UJX-h{<`<kpj1mRE65L(jEX6$HB#hZ`s@
z#GxL-+DPzdT}-#eeS%Yu>$E`zVdi94h4Neu2x2x62{o!!j|@UH;UFSVi?b=G3dN(5
z_l;G*fjJp->T2)DtHf#)?4bh$vFPi+Fg_4X(Dvf85xK=}8a<sze#D!TI-mOaL+W7J
zVZkvOZbv8O1T^H6JvB|!l965!eOS;Oy4v8-!kAu2SeSS*e9w|6!*zc|RIKl0m#BBq
z{v3oqE-Y~*71vm4@(o5PwwURn{Z!m>Rt&oBkC8y;uUsQ>bW90pZsHac$6z3S_#+P|
zhOZxh3%H@I+wZCuXq?C@Ce7e8sb5MTm!CW^!ETnB{R&!=*nsEBN(8d88u5Aq->snR
zLjZCU-sKx;jpAq>#|*8mZ!mJT`96VR-D7hAPCQ$UHVjMPf5vHO5mxfDjJMIq=nfcS
zOB)oZzGF!;>CP)ovB-x6Ko*#Yy5yDXMLEz@=kZf6N*oP8CL-lC1<g4~p8U=vhY{1o
zbNcEDkU)Y`Ov~mpn0U8%2%wF#CEBaI@iv$TQ_CE;haupJGJP3;Y!vI&kr&x)Jea50
z;FFGeXF6$_;KZiB|06mD!c5;<l>Ha0n}y+pRnf1~p(sSj<ZywQ<&=n6wJ--UJ76~R
z0ya0wJpDd9qBn!t^!;JQ2vU_kivsR~%%_f<`TR_)3oohZ`%-vo0tN^s0qR88qzT0P
zmoAxB-lQ0$^5RJ}axf+q$IOPYF@P6v#i6y<v**&$+;`HD%bp$2Ct*!tNyH~poH&}R
zG?t(x5XZ358w6m)E}F3kVQm;|%j)|EJXV|@bG$dou&U5QoDybuSA?5+4q`&hA;*hZ
zn(z47c!bCZ=mp>YA!1OB7x9&0d}Wj`gQoOV2-1gstpt><>vyanA<GlA*Hbq*um@dP
z+AI|zg+Z4N&C|INBalbf@{ZV=o@?OANjXbm{T^XON-UgpiDP$(U-}S}&c<MyB?t>2
zD82`y(f8g=Blg?3`c+^;$9w>nBUU=f_Bb49@AX8iBO{*dmM)kAokR>gDVDGJylI@A
zL9ASKpRgD$2S0ns8v%0g7JMKF_{`Ufz}UyWu`z=4R+jjbB-k`FewcUww3*a=myneP
z431q6?AeTv1a^`5r4~L8qn4)(#hu|HLCcjSe+J7Ju92((pKjzCQHj#R0TWS#tugUb
zMcK<Dm)F19k(qvx5$9YHq=WzUN}uqMFD__Y&nFo9*#Nr{E1QKj7R`gsa;A)d8BV*{
zh1k}`Cx$Q}@lMP<VY&F`755^kMF?4eM+81iI<y-L54=ByMJ=9;iSS}K73K$H8kUV_
zn3PmlYH0BeG)90mjSm`d*Hc!BY<Blx8%(yk#eK3e(-(?V@nj3ckK5F|sjU@9Her_F
ztpscf$P$nZI#GTyc&=3we$iu_Y)+bj!jzc&K(x8LzqdJxPo>1#wrw%{cVsmlP{C)B
zDF}>^v^quJyx-W<Gay@Bc)=7FfQV)Yu+lef5rCKTc|J!-&alf@Z&mB#NWw7^8Q)<7
zF(D&$k@-JIgU<rVksj`>=(~j)Z;{D^Vj+901tcH4;j2K$UjyVjtPy%x{%IC{tgjSV
zi(Xr_=jR|la2A1Y*kCP4FhCZrRr>sl1sP0un(`SN-9t%i=aHQ390Y-Ut^?~AqD!_E
z==|{0E^@MhuMp!)Vjd2V7FGl#Ijw2=Qh-d1e*6ZJ3zmRV>;%r|LDZX1J}{Qgud;Y7
z2_Y$O1<ndXz(5l#9;b<5!7{E#Z*;a2McHwm7R51hlKr87`cUK^SQzLbUohqYQxo$N
zQsITycw+Yi;>=h~{8o|e@A1wE`L}G3?IRg|hGavqQ%{yq7NHMN$B<SqqZl-W+T}Zj
z64H#xH*zoyj7;_G2{u*r35_M<{XU+}!YUh*9TIFFn%!qwomBSv^*P<j;w~~jk^tSn
z&y9(V<ZVt<<?~Dd%nn(eCUh~w<5JUAyf{uRJy0D8eJgGgTO!T0ZTS7in{c^KFO&Va
z@Pi8Y>-}Ta?YIKY4U+Qfj=0B{p7kHg58(m^CirC+-1akh2v?c&Z*K2l-aRY@y-c2w
z+kPherli*4-EXvj$x*L>cWe|`aVP%>)@VN@U846(n7)iF=-lvztt-!VA`=~Ca!76m
zn6RogZYvY9*6m|*1efb<WAX#J?PX#g>pSd!>;;qroW{dUSp&`4;sJm=HH(R&irUf@
z$T}#c*D_&g&^hp>8*Mp}y^4zyz?7fQ#C@&5{0-!zK_(+8MxU9C%55JLK7?HR%m6^G
zI8dtC%Zf*&;sAf(_ffsI&%6cX>yX7kGTk8eD-SbmG5Jgn;&Pp9neZp&0?x|AOyAOM
z4;#RvQhbA?8_Hx<HU9D{Fd|09<aW8;#)LIz&KgmlAr<<V?3ddCCbn*As!DaEtox|c
z-Ol70x$R>D{AhSPlQOyOV?t!iHUEgI3zbO^n^(fq`#OsBi2++mumu-qlIcTwkI#PU
zKbG&rg)uX^U2eBA`H<!^;X}TeB=|5c;$+H?pyJ-c$#VV-J#aE%@l4{e!n0DLj|nTd
zj@M<Dz9OYjCR*yT5y7xFC@H_RipD+J!16P2p>ZZG_TeUoA54+1Gv)VJ@$@oF4wm1D
z3r{mSB)8j{+^@Mz_>gZ>O3(C_p4q`?9+YSLnCLS*{O!Dq>`LbWujhnc#T9a*@{^0a
ze+$<<=X&Su6>l&7ZD8p+hnZ1<Z_&?prXF-dUN*B@a5Xu*o!}C*5{jJ3!f{7_Ofhs`
z4{pyh_bV@8(K!~uIfwb=E?l<d$8gUd=d5;$((-Qkd(L6zJumeJ?kn4NU)gK8e*@PU
zrWG`?>MR@yaw2D*!zK>1ung2X%U?nJSE|Gc5nSgUTgeVZv038rce&Q$TJ!%i*tb_7
z=Cd5~rvJa^e_OV6&D%?tzP-9)=$weR3^`jw8gwd#yiE4A78j>^=ZF5{x65{ZC_tD!
z2suhb+nWl<AfE9wQS#~E@XO5j=cj=!V;%&h_m8dGvdW))a(q4h*g{(ta<09v?A`Za
zed#}&PtiF$4@258Ba>bBiy$)h5nL1qO!?*F83F-${2fxPDkd!Utw}yzfmPr-eM}bO
zqPXZg%)9%wfXR=%0^Yr@1x%IzpFY96b%MQ*2^-P^J0!MMCQnA0*tVk5))6gWV%v%y
z=G{>(U}D>f9_HPMv=wDy+lqRWVq4GRf)T;QR_LEmp$j<uq<k3gH>J70caWSS4fG8l
zDd?>o$z3Qth^xjaIP1>Y?VNZ15jQkmx{Vxu38k;jsPS;A25w8dYa5*dvPbtik;ArW
zFM}Q6C__%(VFli6hdi5t^jLvwk-tN>Z)gspVaCXbk|SqI+V~U<!P})6_8(Gy=^Fgx
zDQcE~1{e5=35$LFR4VOb=^IjUJClX@Whld1{EaAF5aUdUVJ4$Ii|P+bg(#C}aRr=W
z4b#^(o5@+yv7*<pr}0#c^u{y9h<dG5yFpTZnHyuNvh&FDZ{osOn6Q{V>Gfz;s?g`J
zP%<yZ@yLF`u#?GMxPnf8+C%UtGPDJ6t~Ma67nkcqne4(9aK_7+PHDF79{ckhDZW9{
z=k<OGQ+_-gLs{#u`!@116ecY8O$#w;X&;jzP{4JrX2OaysXva~`=vrJlh<)o;Rh-y
za^GHk*4xhECHOtYWw>VM+K%v<W%!LS*SUrXe%=qaeN6D<ejv`Ydzd#vl79`8l-%|)
z8Nr1rHy-BA5y`)X$>-&^kIBQhqzZ2;&<!-i<P^E>V-m(CRd};Y@~>f%lG{EeBe<k5
zyisCZV@D9d2nKNRm*$Yi+a0)|BLYjWfb#JsmlbPqf#yus3C*`NX_4DrCW_p%B2R$)
zG;J$nns|G4WwF|);P})!T+~J@U;F;iIDRaYF#Bc=hm-d+hni+Uyp5n|v(=F8nqMTc
z_eXGn)g<Nj=y7j9?JuKy3FROG6Bf^0K}7JfROn;!mfUV*(uUtVRnFsG1{b6dlSjP*
z-W}BfCXEJr-(lXZ#f2xB*k()XlFdFZZAF>b3O)sa+}EW-KNH)T{=>Z6A#L_Ev7PBZ
z%)2MGfQdy}QYjqYYq&yA?|o%`u+VT{ftuBj+iDMr>35iUjkrS2_WR1NzORh;Y*iSH
z){XSxh}2L_Y<daCX))X3Ti9|gd%)4mclJOLMD{vryD`fFib`bKJi=^rv2$Q51d(@s
z8SPZupJ#xT7Zl9ntVUAI!pf{ET-9jo-`sw$HRiFyOHKX>@oVQSS!ZD<iC;VpcILf`
z>s^%7=hvd^rIwlhI<AGjvZAx{0z(CqkZ>3IO8<wxSvt=iqUE{&2UK>7TF?s;)K1+l
z-0#Izjk)nN3G==r^^{3?Pg2?Ep2z(gxaK<(eqV%HM{!j<zjc<LYm3e~%sg_?sge%^
z?|k#rIfqvun*+6&?cgkId;TNCMXs~cGS8wDGmr4_6k0`fChYsks<WK)hw643%i#g7
zyx=frl>Ix|({`fpwC(=Ms{4mTu~p%WN5Dx@*lmEgvgZktm`s0luBDJJuftYwz{s>~
z#1`#9r#YlKW)XPO!&b2T?NxZu3{zWH#`ff#SIdrWMlIXF3ZlRT!-@&}6m}-5wvOX7
zQ97~444;V@YH;~|Cc;E#^^8Sb5?B8AiSl?p6EWK|*7y5N{<7IVlP$Bta&}vOpUKvp
z;WIIlUG{4=F0O}gfly31Q70x8S14=DAQUm&h09MU!bE2YWl<kXC_YV;$0L-#Y&N0%
zWwQxo%VrbG=KBd{^JWl=ne4KkP)7mRVmT~0Mr^>9X8~nO?Qsf^&vO)7T&goj$u=sG
z=_e&&qPL{vJs&)llzf^c$0Mb`Y&I$VWwS|X%WRau@|?~0lhWqRASE-|Wj`r50B(^y
z1Ot(_>HQL>{PiBhuwSzci3sXP0n92UEcaRSM5U#DOz`vJDBZ?n3YXecywk_L=-okN
zJ&4N+cHXl}z&WtNwmc4ePa_{jwauDB*6X+s<0aBCetrqJwsbE_j!NkcmfkPVdZ9Mk
zWI0*n%)@LE+8I*uz=q#dAj4uI(ug4LWpYq%OKo^r{VX}ErA$_w#_?Y7oa<rY0KOyr
z+0H~Md*I0%ZA&|lxl_t}nV9m&yz(EJF3vSw1fR3Vci{?qS<{Z1=gj>QF6bH=&)cgH
zw1j#tXk9YtT(NZVOcS1nU&2L3wI)2_cW_DkpEqo3_5$XEb0l9wle{<6)@Db=I(**G
zaIEvROz#bnKCkynn6{lYi{V)LN4UUnOjzz?IF`OBrF~4a)Z?q0;DYbRW%-Kt&o2_b
z@;Yei7)D@~H*kRw+Jq4ZEIX4pU=Uw(U)f!_Kjee$KyNw&JdC<N{(J{u8LFb|Ooq_1
z>+E3i8M%$xXP-nxwu7maMlrRvSxl|T+GD2{s2;_2Y>7q3A#s>xe8S^DHu5Yk|1=YR
z8JA2mZ`iDzX4{4TY2-xA=7{(+Z_W%z`pazhZ0avde6%_Dty8}8L4Vn6(w7}Vb>6cL
zbhNZ0EP@%lWh!FqPQ{F|b9nxmuOl@31}?_VF=nR>R~0TB^R!+0L+dSs^IAg(7FQ##
zCS3H+cj00@!~Xk2>(PdL2NzA+GHN1R>u}kB|5G`wgDG5ArP}9Clus4-DlV%xZ2c4E
zAH=FYgzGU}6wKej^#U%gcuEWV?+>j<uI1``5Z4i0U&8emF3vJp(f<2G>pAs$mJX?$
z-9b8H?{EaBUVculKF<%m$DMlQ#7evJINyG;-KOTb2eZ$8l3M0K&>&x@#yd&gCvZ;k
z2#zHj|D%;Bd1m%&c_*pLe*4aeoTTRQPAi<GIuXw}s&JCJ#~!US6z8O@tZzCQ;k~ii
zvmGa^e9ZZYlXPnKH_}d0^+ZQUPWA{+SK)`<^qr8C)SG$y;UpDjoi#g2O`N-#d9>M{
zgaNVf^{#?bk2mw`<$$Ho(ttc%R<Fxo5U)Sg^SuGSIa$vmEA{x<kUE_GN{s5$e4|7@
zt&56WMsnUCALiiKb7o}8K_*)~i1VtG{s(ZFCh3Rql_H$eGS$&te;JON*b>u>l?8u5
zdM@hFrGsRbe@*yHGr|6|dtJ;zoZkC)6lW!R@z6Tt@Ojo_&~>SSvF9%T_Ts@2bI-)$
zTZwx<XY0L+dVJpgv-Rqb;cvI?-7ZwSw#z!U-K%l$$M^aP@b%Bax5I~zG_d&YoQ3bL
z6X3gb7QPW5K90xY`^GGM@0<YN<FoKh`S4-y#KZTGv+$K6vU@!G{c;w*+kN<`b#4C^
zfOvlTRh<CeDX8S1k3&9uh{${RHqOGg@C5j-oQ3a*4<F~*_AfgNU*rV%uA7DLF&{p-
z4IaLa8hope$A3$Jj~jUQAKOJ0=X0~#tp$VostG<m^XXabe#h4?d>yadpUlFy>;(A!
zW){8|efVHXd-#G_K&a}iqs9~9!w(eCn77w__+Tx2`08ijTYCb0%TdqI2S<JQz}g<Z
z_$+)IPJr({v+z~m0G3_nXZ!HoF$-VY3Gm%A3tx>7A7!59t4C(x>pcO!FU-QX%!hBW
z58q3(@a;GOz87cVTkFGjz7Jmjr<45iy9@X}!VL4z-Y%R~@8|_Ew{0b)954T!ul2@n
zR?rDw2y+tm7LToWF6#N`w+;RK4(hGLg-1O4)th#a$iK%>XmK#Z-Z!BF*Nv_BH0rg<
z6Z(f`{CAnb*QlVwdKq)ig#F~T(bQue|E*Z2sr_rm6Gc7zKW_6`ufYOHZN1@H_}-0r
zwa2M9h<bjygx^!*(|XkBcsZ8oS@_-ue3yQrgwVD-F$-TU@HKWSok;_W@0MBk9(l%b
zuBE~<|17?b&Z<}ST?7Yx?v<@~->i0fadwjZ=KQY4W!wGCEPP-3F<dtAuKj1{_mi{m
z?Et=BG)8=v;IjC5@Q!`3^BewK(5u&CE6uMS@+;-nT;w{tA*1a-JC1M8YWK)zUFShm
zV!LZ`*>?YG);R8Hb>;LYs>nZ!4<4S!qbx{oah;d&to>)}G4+wbX@jERNr3gpzXuoF
z4dWuO_#StTeARXSfrK{yEIxu4W6iQ?1yXv5gt>+Zw;>Hc@OLpqCP~Kf0aLz<@N&4)
zgprOLxM<)*NF$$uD{9i$P0Gm#U?62o(f<mjz+YwHuu0pHMjk+vf$8TFRboEsy=2OH
z=rnRKo(HbTXAu)(`Z3G_Q?$#|tIWU2<lkfR4>A1=Tv?O8VDeu@O8l=e#q~N<^zRLm
zQr<-#!C09B|5~PKzm4hr2o;+AA*R5;m+1kx&nEwf$$y$D`t_p8f7#@RF@eNe!xYai
zLCXFtV~RekV2b`UGW{yT83tZ!(sd@~`B3(&i1cjWd64<Q!}FS)KOP0;{JxAd@@b6I
zq(@C!QI6-3zYr<uUxSp-)iPa!ej(-aO-uo=L&|>lB0c+aXoo4_Lvys<`<bHO4>H9#
zo&>{1{si+4MrAr~(wmU7pN|nfh<Z%fKAt81B}mVPJX?m8^;R$ie>O73^(3yd@!Zpd
zQI10=PUHv@reDU|U<!O0rf7E=4uude&y_Ic;Sr`)Fe)YAq>Wfqe6EEl#y8Fs^=?AS
z{_ID}_HJj2{@leBeYnS@2Tgj&r1zWjL6i2rOYt+@Ogb~xO#1FO@LdLe5-I8Ow8{U!
zh1~~y&Da0O@o&Ty)TljTuNXmz6;ZRASdH0eL=r?MNg5+4HGVW^W7aOEepaovYLrsd
znpHKL5H(6g6|LI-pU*w78~5Jm?|&Z;k7wTJobNg3JMQ<6#P_S;S!+A}!d>U%CtvfZ
zDeA}a{3<T$da6?Hk3krRM^tHdLe%lEh}!RUE#E5JQQk~yeJN4v%W0N!Pf^?H7wcNy
zn4C<WNM0c7`0FX(MtNTOdRWU_VmDFy=_6{tL&#C&S)v|asiJQ01*&Z4#kd?-;aXge
zn{gX{f%-MI&LgMnJKesosB*k`s<Pj`)aCMg$4(fC$*L@$iktBOKEXaRXKgn^mHqRV
zD%<rHc{8l#4Mf{^6m|W(kpszbqPBlemF=HOy?*zt<%>mKZawv@<l9;8_pB=0t(3e;
z*6mhKmF?z<Rk0>|VFPT8KG+idu$?OFsE-^g%<E7NId*J$kxSm-k{7t-`7U{*OJ47i
zm$>9jE?K^CmeZP*HJ^Ddd6r9F<&w9#WI3NW_4lE3t}U-gw#Quax~f^8=9Vg(-liwk
z#0Cypo8@_=S)L<4l>1>j$~%#}VILfTLog0U;CuKVoP`T;Ip!8~$OoWTRGGIeSFoK<
ztsIqX-+tSaDcY37&DKsoGiiHiV&#wzJi30`z6rL*Ua0fb`e+=9Q&4u5tzMogHrL{I
z)bA~H`9pXF&*25Ufq$W!n^`V5#^ZZ931{I)sGqlWyw7kK9>O0n9k1g<%$dV1Ul_|^
zHEe*b@O2EpJ{XEII1(q~Ok9MkaWj5}-{MKs&yl)*zu{fXCGStPT;Knw`Z-OlgZlYN
za~JG~5vZRxwElfuitF$TbeAWVwkwR~u?{xFP8f)BI2KcI5w6AE_$~g3XYm4F#XI;M
z3+6KOD~q)-1V6y}xEi<OK0J=;coQFD9(ls)cIb$`Fa)D;1Wv|}a1Cz9Z}22u#7CG{
z-<QdFrLi`)K!1$G6#NL+;g_iYbwK+&gV*qH)IaFg`eIlaz0nW5Vlc+yIGl$oaWn40
zBX}OK<9*Dj?>A*0MbQ)Mqb~+v5JuuCoQCso6>dSV{AL^<?0}It690qq@e|yRw!dwc
z`JN*Gig!@{5Y4teg|PzG#l9GUBXKG&#82@{Jd4-yF&2>b(YpQ0VjXOOZ{ph+gX1w3
z*WgY}$6NRm3(EU*9j`pr#a0-A{V^KH;B;Jq8*n!s#dN%dPqCnU9<Ys%b+Hu&V1JCp
zF*qHU;0D}{M=>35p+{jeZaMVAmgtW`7=_80f{SrI?!qIOhMD*TJ>-pmu6H@~!j|Zd
zK^TR}n1YLOJ?_FIn1-471U=*n65IHwzjD{?k3krP`s;PAPr=2w75Cy%)L*e{``hRt
zpQkie#75|gov|-Q;Ru|L%W)I##Qk^-)9`nEfO(3Uc@)D+SRY&Ao7fKrVIq#lnYa``
z#qIbFp2Umz7wQ*8x?KvP{`HmS+USD;xB++KcX$m;${R>sz6yF{YdnA_@HRfe3MI_)
zb<qdg<D1wWdt-kL#R!bUX=wX=Df9b;Z2R0Oc|Z9CUciT#M?MSbdX>P+*Z_UeAFtva
z)DH@}d;u(pRnQkZV=oNDcpQsUaUQP1E%-Ga!!-OIA7Wm4qp$NSiPf<!_P`L-&#T&g
z9L~gLxC!^-alDAP@i`Wj&#~HHMXZmlu`32+ERMsOxC}SpUObK$@isok!umN^$H)5E
z8oOdJ#^N}fiOX;oeuqD!{$5(gxr>&32d%jf>hB>n*G3=gfPol?V=)C+;9)$2Zt?+6
z`z?&+u?{xFj@T1N;}o2W`|&8A#e0}rK2z#=9#|AhVFj#;b+9S6$1qI61-KMf;X2%m
zJ8&27$M5hM{)Fc-1FvBw-o*#_40Fn7VO`Js_zIT5a#$H_Vm)k(&Cw4#U;y^TU<}7d
z9EM3a7N_9?T!UM2A7)@C-o*#_40Cy!^(}%Gu`ag2ewct0a0PC}ZMYM^#zS}-ui!n@
zZLa@{peNQxUkt$h7>#3aIxfKtxEqgRI^M#kSg^90M|rG^tuO%l<2w8T58)a74gbMB
zRZRaSu?9B9j@TOqV-ilm`M43k!tXHyZ{ZX4sA|UVgn>8!V=x(K;}ZNBKgCVB1NY+z
zyny%cIeJzz^YFsvsK2k*<DeIY;cy&})A4gWh^O!p-o~d`pt|Y5G}ge^uq}4SV2s9f
zxE;U7AMgxb#e3*h!;D)P%cB=I#bBI)i*N@X!0I(ke+|(O`(Xku#UJn_p22jyj5qL4
ze1c_bnem!pTMWk0I0Zk%6}Sm^;}3WaN7Od`PsC|B3+Ley{1iXOU-1#<u4DSEiES|u
z2jVb%4`<?1+<?3A2Rx5A@Bx<aGUHam#@H5nU<k(HIGlk?a6Nv7-{U#Fj{jipx@P<m
zSRI>S2ONa&;$)nMpWqJs7JtTTcpr1uV_d9`O|S#@!ofHZ=imz5hI{dQynwe+|5!uM
z7iF+EcEJ8P6PMtB@kdO@8~7CSHZc7c!-`l3n_)-niJ>?Q$Keh<fInge{((<0zqc8`
z6jsN^_y+dEaFko**tX02I0skYX55R%FdZ}TG3IY*`YVk!(HA>oACwz!+s049)%Y3i
z!SC@GypI21!A7Q^GFS_Jusim~{uqiwF$w=b{l$$QHwCaHR>y|e3cFxm9FHlu06)e}
zxF1j8Z}>O5zh>r91S?{Dd<#Qx1Wv|OT#1|U5T3?NEYie`R}t%CJM4=6Fb+rKWSor~
z@Jl>|r|~l0#iy9RshLM<tcgvr1NOu)jK>MM2DjoqJb`KWJ3hcXK4$!q*a%x=dwdhS
zV;>xg({VL!#eJBL9?i^nrLYBd#GV+6!*DXrz(x2eZpUx%BxYbHKEiy>%{*SkD%cQx
z(H}!F8sl*kPR3MRiJNf`9>Mc?9gDRv^Qnk+u?4<?y)hi)aXik$kMT3yi%0Pnyn+8<
zu9jvV#jq0A$8H#e191q(U;=)CAL26HfM4NZJcGGgahzaPY=#}N7lvaZ&cly!3+}@c
zcoF}=r&!R}j9&(8p$~S%-WZ1Q_&(0UWw;Ud;175nZ{S1B)7s3V1Xjbw*cN+W2*%+!
zoPkSlJ?_C1coF}=r&!R>%)<*?qCW;<6sF)}T#vi(2&Q2sK0%K*X1sFfg)Pw^gD?t{
zF$EXndfbIaFby;D33|NF_~?Z#(I2C6D$c{zxDCI-Q<#C*Fca_ML(JXQ%;Qz8h7GX|
zcEezd!7-SEAK^Ou62HSUcn$x?obAj!ieY7Jh_7Q09Eihl0?xsexCQs)DZGS#;&Uw2
z-pr#sdSMIfjD2wkj=)KniXY<^+=pqHw}Tn4ICjE79Dq?c0w>}uT!|ZTCw_~k@Dkp}
zXIQ+WnTIEK!k!q4!|*+viA!-K?!@o#XS{;<@Hv+4WX7+Bz8H-oaT2EDa@>d~@iFFk
z!}MDgTVW>*!~qzC$v6!c;3v2Z_u~n?fSLFR^L94#D1i;p4|`!4#^VH>jmvQp?!lv&
zhBxsM7I~BXi}leL12709aTHF)1-J%x;6Xf%SMhJm<!{EXfc4N9yWl$*gJW?9F2&FB
z5T3!`uuy;*uMF12CfE*p-~f!lWSoWz@DuzRk6}7y;$zI;#mu8L*2JdR0efN?#^VH>
zjmvQp?!lv&hBxsM=Id(aQ3`8dQ|ySnaWE#~6r7K1@N+zbXYe=t2lI3@<Cnx5*c3Zr
zZybzCI0ZlKZu;4d$MHE9=)v~J8rTG1$1WIzLvaL7##H<Uk7GJ!;seb6mKnb|R>lT6
z2#4bc9E+214z9q>xEGIMI%eWy%pb^hz?#?;J77-?!+4y4vvE0Y!aaBtZ{TfwjQM(+
zd6dLz*a+KTSL~0GI0`3YDz3!MxCf8mdAyGIF=sC`pQ7lA^{^#&#y&U*6L12~!lk$#
zzrsU!8ZYBre2V#cvz@RSHo`V2w`aF~pVA*AaU@Q`xwsBL$8Yg8Ucq~qqmSvo2zp|D
z^u+)S!YE9_2{;26<2w8T58)|1hZpf07Vc~2RTk@`FLuU0I0zGP0?xvvxE^=nVLXkO
z@eV%6g8i5e*21RP9s@B1<8U0#!1cHVzra0s0Kdl*_%o*AW&9JLVfnYsd~0Jf?1a5>
z5GLY8JcvKyCHxbgW1%23PI>gg7MO}Fa5L`3W0;Pa_!#r|H~p8!n)vEFro1wGqaSv~
zcQ6`v<7Iq^d4o-V)v*b7!k!q0@i+lz<8s`Dd+;cx;Z1ym`39KrOJNOcg6%O7LvaSq
z9cY$6fG02w@8DA`6>8d7#pc)nd!XEu(surd#3Y=EAL2^<48O+XcmZ$W6D$yB`Y(gE
z&<8tWFO=KS*yfXf@8cX?ftztJ9>W`WA9ID9{)%H2Y=~{J8wR6XCc-w4F_?lM;X3>h
zzr!<l4gbcRgG_(Lurhk1A9lreFdCC_KCZ&8xF1hq2HwVJSa7hJM>(v6&G8NFgM(4-
zzh>JWlQ0!O#>4nC{)I({nB^*=H~L}#24N(Q!l}3tH{w@#2!F!MST4ehTMK=#Blf~@
zJc;Re6CYyUp{Bp$=!x~Q9lnK8I09$mQrv*M@CQ7PH?Tsa8Mi9d#s=5~TVZGHi$gF8
z=i@5eiu>^-X5ejnh6SU{e9B=RY>sbW9~_Kha2hVewfH%Hi>L7l-oqTxX8a=PiS^MJ
z12709aTHF)1-J%x;6c2Pd1B1C6|gyW#9k<Omon!soQ5-FP5IZujMWp3b>B7mU_0!A
z126`YaT+ee|KdSBg}>r$e2N8<%($ho2EK-Eu{#E1G>*opI3HKzR@{fjF&%H>L(DV6
z%;#0Cg5KB~1MqE(z$BcEb8!`J#r=2^Gw?P(!wMtKd}?C{48(yLhhs4X7vWmmfd}wM
z%)meJ3FaSV#xI4{u`#}m-S8cZ#)Y^Vx8goLj_G(4A7Y--><_Gh-q;!g@NJAhzhtw#
zKlZ~R_%42cXYo&bj77(oeyU(SY=+%%C??`~oP$enEpEf(n1MI(AIv+}j9&~ZU~O!H
z9kCCFVk{=(3|xe3ag*w1SzB>8<=>HyU>fCD$k*|2%5#k~^DUxEf3IRi%IlEpV>8Oz
zli$Ezl!vI5<^L&@<Ec-=(bP|(ekM7UyiCm@|6g8}`D`ceQ47eWAt^si`31_aP=1H<
zN0gU*PnN4Be^0MUe>Jd<D)W4edOvbE>`D0max5lLK8`$5m42t=B30)3t19E(qWlj2
zt;)F1sn0jw<dRrRmE{_deaLN9*)E+_H_PgdkvI<LsnTwlD)U%P`CdGQzpK*jo+|Ag
zQl4XiWH<SH4XmI_yBeyrYo}JStgfoGdkcH3l`ShomHJ4sUf@RaDDpV+RPuaWjq9l2
zuI8|;J*teeAJg#?-p5Cn_kGje11n+`tcz{YAN#90ENhS|>lsCPB2K1$CiQbEUy57s
zIQ6H=7w|WHrph>ZCYo^ys<M71uo30W$bD7Wegnv1I7F>%S;MJMCQqk+9xlg?s`Rs+
z{3Y&IrJqC8pCtcG&LCeU-zNV>ey+;=i%v4u!FCv>%D4&S5tyvXxRa@$O`b>nGTf}n
z{@6i2tV(|;$Uos(Rr>pt`b_d2@?)|!*({%5mG*_nWz-z<{}|LNmer8@HrRpkH&q$G
zC*@%nj}ve<F2_x{2M?;U-A?0WRmRU$Wqk`zG2@g}rCnL9sLH%+QQw%{jNFbKh<zy!
zBM-+U$|sPgkmr!+lUI`0khhROC+{a8CZAMwz3?3Mm#P1Qe2@H$?EW9KzJ*j-zhdNC
z<a(;~>x=zy5GJXz-Nuk-sg>k<805vcT$TRUQNNwMlYEeT8qZUHmHan8Qe{3KQ_VQV
zRmr8WoGRl~r{0^~gxrSQ9eYt8LLNjOMt%<`QJ#t`RXJXFP=A<wjQVqwmzief(;od*
znQsuji?eVcZdPTx?k4|4zC?aN&h>%mube9FYmxoP0pwmd6h~7(o}8-6ep^mng=<yW
zo?EEjP2NvFO8$|YPX3jAi+q>tmSV>7P^I4@<Z|RnWG}Kexh1&`*`M5<97GOLWxphn
zC*d^8XR5NEizr`*JMnuwkH6z1%s-uZt1?bC@@v?f^46-1)0y&qI21?WG+c!1a3}6l
zWt@}bOL&d)o2ra+pYq%@B+GU!fz`1IcEDaZ2xC?0CrNd)tkF1*`l-~Xk{6O!kv}DG
zBY#OgKt4?ViF}THh5Q#jq&(+LvmW_WnOAXgX>wI^EplUWGgY=%0C@m8T$O&}DE|!8
z@UklForzD-W0onegDuqpmi0RMEplJ-WL!r1R`LPz_vBy5m&kX?56Jmun{f)OGA~bZ
zb#ha3D{?ng)~^pa2nVQgJPf5ikvxh#i9C%w4_8qB3HdYf4)Q+ox8&29LHSix_QOMR
zzBy(dg;XgorpkOPP+kvxu?xO~F*p`y;9OO<&nK$vmrb~x@`HE<pJAR4&2nY1F8bkH
z7^h0VW5_GW8_9dg2gyH^)5y2T_s9iOO@BpHnYS<Yr+g@RG<iIEHm+1<yKPiU$>&h=
zUh)C*3G!+3CGs`$UGhI<_qnFOysGqHTrDZr;UHI|zBaiDxdpi+*`M5p+@Bmljv<dC
zk0XCTo<&|vUP0bK-a_6({)T*9EpA!o$X8Vl%le&spL%PaSw9aoue|<{%d4_{4RRwj
zw|wp+2U7nId8qn|{C{Hd2h`6cuTb6P{Q>zK>W`Aot3@sAA~}=#`(*d|QlC?<+oa0=
zcvY48RU~_<MJ&sk>`Q$oa!<98TqBb_nEGMlv1&274i0%1^^3@B)ckTCJMv-bPmwd!
zT$Xi}e3$ws<a`UHzOej1VO8c|R+afzBR5p@$aQ7Nfz-c4j#Tr>`I<b2`YGg8wV-7!
zB!7m7F%56veJs6DmXrB-VKeN2Z(#_=Vlqy}dAJI<;9fk6=kXuRxyX!P1S_HscEE5P
ziSuwB?!h$t9rJu-`mc&_%Q39y8QJt!4o`F4FU?iSHC4%t$v)(E<WA&3avyRSc?day
zJc2B5mu%z7%bBhJZR9V=XUS>g2jnN@;xZ@Od{z0^fZUj@*W=WBe{vi-ft*6NT{la9
zUQgak{deRe<Uh%J9Z%c#%E9=ml(i)LkxS@2OInugdP}7&D^{KhdOjYFr|~|z>3)#<
zvRECxunPv^5S)RFaV^%DV_*AA!H>|A=e(BxuZO!OE9CHSx8y|S@Nl=}#N+UAw_SDZ
zMS<Kh>P3*B+~sB}jt_Ue*rmh6T_@%6aJOB}?L~pRB_~3Mhr8`)eNo`97kzYixLdN}
z9UkshX@{iqDeIEUyX1;4xspq+;*zVm<mxWDhD)yHl54x<IxgAECD(Py^;~iTm)y`L
zH*(3Zx#XrU*~cX}cRE6HT6dm1?*TW<`4FpZRd(v3hAr#4!#vz<d$5~5O7G5Fw3b;u
z>#%fl>94wNc|9lC`_u9C8oc(b^UH9^TCdm8H4iiXUk+L8t7aYMrrysXYyEPEto^TY
z$n_<^7_Yc(zIu&W^DzDCy}a#N`_pU6+OzgI(IIQSUQ5<I%<_#LvexUhWF71E=E(M}
z^?L1Bd$!HjA#1%}tJJZ6mqXTiy(Xu<Uh|8GyX_j*nsvXs$uq1SKbIrFCF*NP8S+3;
z_qPtA?VbC}X$_Ndedw9QP0lwnL{Hg&@|Hw$HJA3et^Z27K1}=E)@k|qhWzuCf7#pT
zwVq44K1}<(wrgERNUkLRvbWD~_2k$w?ekknlJzyltgq{QJgkLI?LDlWlJ!}rXQu4^
z7qWhFYG255%VAjqq|9tT*ZyCzYDm34%zR$4I!o5Goc_z+e^D#iseMsvwq*H=i2dQ(
ze=Tb}?e&m$lUvJH7GFHf@%$pcYVCLG|5fXn<Ybw@+25}Hm$dTpl49mx(yB{-`TR>;
z-JIH&wuVdoN+$5~?O)qUrM;PdZEJ~S{n?&Bm8@f%@oQUpT}OR7*z3QQT-+i5C|Sp{
z*I$sV`^KK{NcMEdPbF7%$VH@KO@~}YvYyrL%X`ZY4IHwcWPQHa>$}PiJ`Ooda!ZFC
zBiYX(JMXWu)+Fsn9%g;ZTAL)lA=y*@Wj|iZTj!kGm$&qK+l^#@>Ukr3`-)acc^{(>
z(|<*)spM0V&GXxJ|5vhlJGHN5jgXvA`hWTJql&fAseKh|r{q=AzhnEX(^=NpNN1$m
z@XmAR?NQD8MV7BBb-E9V${IbUe{HY*=x00oLvs<ye)2XXS+;|=uPIs2-x)Gz&23!T
z_mS)&eRh&%wLVUAH~Crn(mX}-MEQ9Zd6~=dt0n9CJA?5KO4ef{jP~bU+TWC{uYX6V
z&z1GsV#d_#WyVRJ9@9F0LznuFlC{o0zkV+DgC(z$%Ehej80zi)&2eeJ&?Rqj$zMy>
z*Dw3}pK+<bAX#5ehcMr#F7>(OKpWsN-wKlT^-|xz>-x2poFPB!HqrdHWPN?t&jXqh
zCEFjm&MA@uWq);(Hd?>ZrGAS`-Y;2SANBgJ+WxFdy=A}uTS(O4*x?ZgL!#@2T2<vv
zasF+(wC&WjM+2*BSXS_spW1piu!4gJCB}pX2iI%p-Jod`r}&zWQ*7MOF?u&>EYW_q
zF8jz1cb?Nq+g<E}|D|$dbVA6$tjd488(sEp{#Q%qK12WQc6Hf1{hv*pd(FDZ8#heL
z-r37qIQQXlr@QQ3yrhA14==j|UiNPOt(9|M*=~=Qy`z^laqcDijq|d1lf8}8ZTWNo
z=T5UWrR<=nfqF}~?47>6jdMTQZnl@bo0m3m=_N5fE<7eISZ;(D8ZP&pdr2oQEe6|f
ztEcxh91;<q5IcONWxwTOcue^4!6U8EkT|*fVpPPy;UNj(){x<HtHSt%;CExAtif7t
zTkUu&E;=zQ1xF{!y&$dO38BHEv57Hq|3)iL?p7BZIwWNH;BYOAij5v<%4A^kLs&$-
zOTFxk(D2~6*rf2`v4aL#+>6gVzrxHy3GW8;d<zSY3K?nHZqFDM8<LP!ZJX?i>1W@C
zS#`SE2FiH<y7B&3OXnRC>UhV(?0X?wwe!;d-#oI{J1@@`(QTo7Df{>@Y2e($OKyAU
ze6Dn9U_XWa+ZK{DZK(V?p&lc)LnByjKp2_zdhoBEaWl^sD-seOGB6@IF(xTOj`GmB
zIN4bZvbu4-38j5fF6SzHan{q4^JL_p;o;#~ow14RPX&1ngoH*UjLfPJi_JRP<E_Z(
z@MwvlL&AgQ`4AhL)hhe>L`S!stQ?*j_8Db+hHJ&}@Q|=zeJ1G`GUu$mwU?|@yxA}j
zVG-}j)75?xRNM16JUA>uo;>z3oDRJ>xrb$f*$+wbf*kHN&WoLu7~{0NT#g>yx6yI7
zeH$P0Zg{YLlgS+}6B6Tt6JoVjE8aHNi+N-_VP{P+Yx?$%29DIbu4b*l%U(0=3uo<9
z*$DR2@k@>w?-!lL$z3|bgE`abD%*A-C$Qk)7uz*DHY{r?=O<ufv{}Y>0K{AW2lE%O
A%>V!Z

literal 117456
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

diff --git a/drivers/amlogic/power/aml_pmu_of_common.c b/drivers/amlogic/power/aml_pmu_of_common.c
index 79c0a6ae5b1e..656f7a4911ef 100755
--- a/drivers/amlogic/power/aml_pmu_of_common.c
+++ b/drivers/amlogic/power/aml_pmu_of_common.c
@@ -44,8 +44,8 @@
             prop_name, value, value);                                   \
     }
 
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_string(node, prop_name, &value)) {             \
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)                \
+    if (of_property_read_string(node, prop_name, (const char **)&value)) {      \
         DBG("failed to get property: %s\n", prop_name);                 \
         goto exception;                                                 \
     }                                                                   \
diff --git a/drivers/amlogic/power/axp_power/Kconfig b/drivers/amlogic/power/axp_power/Kconfig
old mode 100644
new mode 100755
index 669a87bc9be0..6a60c2155f18
--- a/drivers/amlogic/power/axp_power/Kconfig
+++ b/drivers/amlogic/power/axp_power/Kconfig
@@ -25,6 +25,7 @@ config AW_AXP19
 
 config AW_AXP20
 	bool "AXP20 driver"
+    select AML_PMU_ALGORITHM_SUPPORT
 	---help---
 	  AXP20 driver
 
diff --git a/drivers/amlogic/power/axp_power/Makefile b/drivers/amlogic/power/axp_power/Makefile
old mode 100644
new mode 100755
index 8c23f2444dc1..c33c0c302828
--- a/drivers/amlogic/power/axp_power/Makefile
+++ b/drivers/amlogic/power/axp_power/Makefile
@@ -1,16 +1,5 @@
 obj-y += axp-mfd.o
 
-ifneq ($(KBUILD_SRC),)
-TOP_KBUILD_SRC := $(KBUILD_SRC)/
-endif
-
-MAKE_FOR_LIB := n
-ifeq ($(MAKE_FOR_LIB), n)
-$(obj)/axp20_algorithm_lib:
-	@cp $(TOP_KBUILD_SRC)drivers/amlogic/power/axp_power/axp20_algorithm_lib.z \
-        drivers/amlogic/power/axp_power/axp20_algorithm_lib.o 
-endif
-
 #Make this built-in, so that it will be loaded before I2C driver
 obj-$(CONFIG_AW_AXP18) += axp18-regu.o
 obj-$(CONFIG_AW_AXP18) += axp18-sply.o
@@ -29,13 +18,3 @@ obj-$(CONFIG_AW_AXP20) += axp20-gpio.o
 obj-$(CONFIG_AW_AXP20) += virtual20.o
 obj-$(CONFIG_AW_AXP20) += virtual20_dev.o
 
-ifeq ($(MAKE_FOR_LIB), y)
-    axp20_algorithm_lib-y := axp20_algorithm.o
-else 
-    # add FORCE to make compile force copy obj file, so no need to delete obj file
-    # when .z has updated
-    $(obj)/axp20_algorithm_lib.o: $(obj)/axp20_algorithm_lib FORCE
-endif
-
-obj-$(CONFIG_AW_AXP20) += axp20_algorithm_lib.o 
-
diff --git a/drivers/amlogic/power/axp_power/axp-mfd.c b/drivers/amlogic/power/axp_power/axp-mfd.c
index cf1268247d36..f60c132ca73f 100755
--- a/drivers/amlogic/power/axp_power/axp-mfd.c
+++ b/drivers/amlogic/power/axp_power/axp-mfd.c
@@ -345,7 +345,7 @@ static void axp_mfd_irq_work(struct work_struct *work)
 	enable_irq(chip->client->irq);
 }
 
-#if 1
+#if 0
 static irqreturn_t axp_mfd_irq_handler(int irq, void *data)
 {
 	struct axp_mfd_chip *chip = data;
@@ -517,14 +517,14 @@ EXPORT_SYMBOL_GPL(axp_power_off);
             prop_name, value, value);                                   \
     }
 
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_string(node, prop_name, &value)) {             \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:%s\n",                            \
-            prop_name, value);                                          \
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)                \
+    if (of_property_read_string(node, prop_name, (const char **)&value)) {      \
+        DBG("failed to get property: %s\n", prop_name);                         \
+        goto exception;                                                         \
+    }                                                                           \
+    if (DEBUG_PARSE) {                                                          \
+        DBG("get property:%25s, value:%s\n",                                    \
+            prop_name, value);                                                  \
     }
 
 #define ALLOC_DEVICES(return_pointer, size, flag)                       \
@@ -616,11 +616,11 @@ setup2:
     return 0;
 }
 
-struct i2c_device_id* find_id_table_by_name(struct i2c_device_id *look_table, char *name)
+struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *look_table, char *name)
 {
     while (look_table->name && look_table->name[0]) {
         if (!strcmp(look_table->name, name)) {
-            return look_table;    
+            return (struct i2c_device_id *)look_table;    
         }
         look_table++;
     }
@@ -634,12 +634,11 @@ static int  axp_mfd_probe(struct i2c_client *client,
 #ifdef CONFIG_OF
     struct i2c_device_id *type;
     char   *sub_type = NULL;
-    int    idx; 
 #else
 	struct axp_platform_data *pdata = client->dev.platform_data;
 #endif
 	struct axp_mfd_chip *chip;
-	int ret;
+    int ret = 0;
 
 	chip = kzalloc(sizeof(struct axp_mfd_chip), GFP_KERNEL);
 	if (chip == NULL)
diff --git a/drivers/amlogic/power/axp_power/axp-sply.h b/drivers/amlogic/power/axp_power/axp-sply.h
old mode 100644
new mode 100755
index 7c28dfa3c639..6de5d02e2c01
--- a/drivers/amlogic/power/axp_power/axp-sply.h
+++ b/drivers/amlogic/power/axp_power/axp-sply.h
@@ -1,6 +1,7 @@
 #ifndef	_LINUX_AXP_SPLY_H_
 #define	_LINUX_AXP_SPLY_H_
 
+#include <linux/amlogic/aml_pmu_common.h>
 /*      AXP18      */
 #define	AXP18_STATUS						POWER18_STATUS
 #define	AXP18_CHARGE_STATUS					POWER18_ONOFF
@@ -314,55 +315,11 @@ struct axp_adc_res {//struct change
 	uint16_t iusb_res;
 };
 
-struct axp_charger {
-	unsigned int sample_time;
+struct axp20_supply {
+    struct aml_charger aml_charger;
 	unsigned int interval;
-	unsigned int chgcur;
-	unsigned int chgvol;
-	unsigned int chgend;
-
-	int chgpretime;
-	int chgcsttime;
-
-	int vbat;
-	int ibat;
-	int pbat;
-	int vac;
-	int iac;
-	int vusb;
-	int iusb;
-	int ocv;
-	
-	int disvbat;
-	int disibat;
-
-	int rest_vol;
-	int ocv_rest_vol;
-	int resume;
-
-    int ocv_full;
-    int ocv_empty;
-    int soft_limit_to99;
-    void *para;
-    int  (*pmu_call_back)(void *para);
-    void (*led_control)(int flag);
 
-	/* charger status */
-	bool chgen;
-	bool bat_det;
-	bool is_on;
-	bool ac_det;
-	bool usb_det;
-	bool ac_valid;
-	bool usb_valid;
-	bool ext_valid;
-	bool bat_current_direction;
-	bool in_short;
-	bool batery_active;
-	bool low_charge_current;
-	bool int_over_temp;
-	bool charge_on;
-	uint8_t fault;
+    void (*led_control)(int flag);
 
 	/* adc */
 	struct axp_adc_res adc;
@@ -383,7 +340,7 @@ struct axp_charger {
 /*
  * export global axp_charger struct so this struct can be used by call back function.
  */
-extern struct axp_charger *gcharger;
+extern struct axp20_supply *g_axp20_supply;
 
 /*
  * R/W operation:
@@ -393,10 +350,11 @@ extern struct axp_charger *gcharger;
  * @size       : R/W size for multiple
  * @val        : value write to register
  */
-extern int axp_reg_read  (uint8_t addr, uint8_t *buf);
-extern int axp_reg_reads (uint8_t start_addr, uint8_t *buf, int size);
-extern int axp_reg_write (uint8_t addr, uint8_t val);
-extern int axp_reg_writes(uint8_t start_addr, uint8_t *buf, int size);
+extern int axp20_reg_read  (int addr, uint8_t *buf);
+extern int axp20_reg_reads (int start_addr, uint8_t *buf, int size);
+extern int axp20_reg_write (int addr, uint8_t val);
+extern int axp20_reg_writes(int start_addr, uint8_t *buf, int size);
+extern int axp20_set_bits  (int addr, uint8_t bits, uint8_t mask);
 
 extern int axp_set_charge_current(int chgcur);                          // set charge current, in uA, 0 to disable charger
 extern int axp_set_usb_voltage_limit(int voltage);                      // set usb voltage limit, in mV
@@ -413,12 +371,5 @@ extern int axp_charger_set_usbcur_limit_extern(int usbcur_limit);       // set u
 extern int axp_get_battery_percent(void);                               // return percent of battery capacity now
 extern int axp_get_battery_voltage(void);                               // return battery voltage, in mV not OCV
 extern int axp_get_battery_current(void);                               // return battery current, in mA
-
-/*
- * these functions are open to axp20_algorithm file, do not use them
- */
-extern void axp_get_coulomb(struct axp_charger *charger, int *charge_c, int *discharge_c);
-extern void axp_caculate_ocv_vol(struct axp_charger *charger, int ocv);
-extern void axp_clear_coulomb(struct axp_charger *charger);
 #endif      /* _LINUX_AXP_SPLY_H_ */
 
diff --git a/drivers/amlogic/power/axp_power/axp20-gpio.c b/drivers/amlogic/power/axp_power/axp20-gpio.c
old mode 100644
new mode 100755
index b5ea909ae735..556afbc04617
--- a/drivers/amlogic/power/axp_power/axp20-gpio.c
+++ b/drivers/amlogic/power/axp_power/axp20-gpio.c
@@ -114,8 +114,6 @@ EXPORT_SYMBOL_GPL(axp_gpio_get_io);
 
 int axp_gpio_set_value(int gpio, int value)
 {
-	int io_state,ret;
-
     if (!axp) {
         printk("[AXP] driver has not ready now, wait...\n");
 		return -ENODEV;
diff --git a/drivers/amlogic/power/axp_power/axp20-sply.c b/drivers/amlogic/power/axp_power/axp20-sply.c
index 2396565070ed..94daca95b8a4 100755
--- a/drivers/amlogic/power/axp_power/axp20-sply.c
+++ b/drivers/amlogic/power/axp_power/axp20-sply.c
@@ -19,7 +19,6 @@
 #include <linux/power_supply.h>
 #include <linux/utsname.h>
 
-
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
@@ -31,7 +30,7 @@
 #include <mach/gpio.h>
 #include "axp-mfd.h"
 #include <linux/amlogic/aml_rtc.h>
-#include <linux/amlogic/axp_algorithm.h>
+#include <linux/amlogic/aml_pmu_common.h>
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
@@ -41,6 +40,10 @@
 #include <linux/amlogic/battery_parameter.h>
 #endif
 
+#define AXP_OCV_BUFFER0					(0xBC)
+
+#define AML_PMU_CALL_BACK_DEMO      0
+
 #include "axp-sply.h"
 #include "axp-gpio.h"
 
@@ -48,21 +51,17 @@
 
 #define ABS(x)				((x) >0 ? (x) : -(x))
 #define CHECK_DRIVER()                                                  \
-    if (!gcharger) {                                                    \
+    if (!g_axp20_supply) {                                                    \
         AXP_PMU_DBG("AXP driver has not probed now, please wait\n");    \
         return -ENODEV;                                                 \
     }                                                                   \
 
-uint8_t  pre_chg_status         = 0;
-
 struct battery_parameter *axp_pmu_battery = NULL;
-struct axp_charger *gcharger;
+struct axp20_supply      *g_axp20_supply  = NULL;
 
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
-static int pmu_earlysuspend_chgcur = 0;
 static struct early_suspend axp_early_suspend;
-int early_suspend_flag = 0;
 #endif
 
 static inline int axp20_vbat_to_mV(uint16_t reg)
@@ -96,13 +95,13 @@ static inline int axp20_iusb_to_mA(uint16_t reg)
     return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 375 / 1000;
 }
 
-static void axp_read_adc(struct axp_charger *charger, struct axp_adc_res *adc);
-static void axp_charger_update_state(struct axp_charger *charger);
-static void axp_charger_update(struct axp_charger *charger);
+void axp_read_adc(struct axp20_supply *, struct axp_adc_res *);
+int  axp20_update_status(struct aml_charger *);
+void axp_charger_update(struct axp20_supply *);
 
 
 #if defined  (CONFIG_AXP_CHARGEINIT)
-static int axp_set_charge(struct axp_charger *charger)
+static int axp_set_charge(struct axp20_supply *supply)
 {
     uint8_t val = 0x00;
     int tmp;
@@ -137,7 +136,7 @@ static int axp_set_charge(struct axp_charger *charger)
         AXP_PMU_DBG("something wrong with your config, do you sure not open charger?\n");    
         val &= ~(1 << 7);
     }
-    axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+    axp_write(supply->master, AXP20_CHARGE_CONTROL1, val);
 
     val = 0;
     tmp = axp_pmu_battery->pmu_init_chg_pretime;
@@ -154,10 +153,10 @@ static int axp_set_charge(struct axp_charger *charger)
         tmp = 720;    
     }
     val |= (((tmp - 360) / 120) & 0x03);
-	return axp_update(charger->master, AXP20_CHARGE_CONTROL2, val, 0xc3);
+	return axp_update(supply->master, AXP20_CHARGE_CONTROL2, val, 0xc3);
 }
 #else
-static void axp_set_charge(struct axp_charger *charger)
+static void axp_set_charge(struct axp20_supply *supply)
 {
 
 }
@@ -197,34 +196,35 @@ static enum power_supply_property axp_usb_props[] = {
     POWER_SUPPLY_PROP_CURRENT_NOW,
 };
 
-static void axp_battery_check_status(struct axp_charger *charger, union power_supply_propval *val)
+static void axp_battery_check_status(struct axp20_supply *supply, union power_supply_propval *val)
 {
-    //if (charger->bat_det) {
+    struct aml_charger *charger = &supply->aml_charger;
+    //if (aml_charger->bat_det) {
     if (1) {
         if (charger->ext_valid) {
             if (charger->rest_vol == 100) {
                 val->intval = POWER_SUPPLY_STATUS_FULL;
-                if (charger->led_control) {
-                    axp_update(charger->master, 0x32, 0x08, 0x38);
-                    charger->led_control(AXP_LED_CTRL_BATTERY_FULL);
+                if (supply->led_control) {
+                    axp_update(supply->master, 0x32, 0x08, 0x38);
+                    supply->led_control(AXP_LED_CTRL_BATTERY_FULL);
                 }
             } else if (charger->rest_vol == 0 && 
-            		!charger->bat_current_direction 
-            		&& charger->bat_det) {
+            		   charger->charge_status == CHARGER_DISCHARGING && 
+                       charger->bat_det) {
                 // protect for over-discharging
                 val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
             } else {
                 val->intval = POWER_SUPPLY_STATUS_CHARGING;
-                if (charger->led_control) {
-                    axp_clr_bits(charger->master,0x32,0x38);
-                    charger->led_control(AXP_LED_CTRL_CHARGING);
+                if (supply->led_control) {
+                    axp_clr_bits(supply->master,0x32,0x38);
+                    supply->led_control(AXP_LED_CTRL_CHARGING);
                 }
             }
         } else {
             val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
-            if (charger->led_control) {
-                axp_clr_bits(charger->master,0x32,0x38);
-                charger->led_control(AXP_LED_CTRL_DISCHARGING);
+            if (supply->led_control) {
+                axp_clr_bits(supply->master,0x32,0x38);
+                supply->led_control(AXP_LED_CTRL_DISCHARGING);
             }
         }
    //} else {
@@ -232,61 +232,72 @@ static void axp_battery_check_status(struct axp_charger *charger, union power_su
     }
 }
 
-static void axp_battery_check_health(struct axp_charger *charger,
+static void axp_battery_check_health(struct axp20_supply *supply,
             union power_supply_propval *val)
 {
-    if (charger->fault & AXP20_FAULT_LOG_BATINACT) {            // active battery
+#if 0
+    struct aml_charger *charger = &supply->aml_charger;
+    if (charger->fault & AXP20_FAULT_LOG_BATINACT) {                // active battery
         val->intval = POWER_SUPPLY_HEALTH_DEAD;
-    } else if (charger->fault & AXP20_FAULT_LOG_OVER_TEMP) {    // over temperature
+    } else if (charger->fault & AXP20_FAULT_LOG_OVER_TEMP) {        // over temperature
         val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
-    } else if (charger->fault & AXP20_FAULT_LOG_COLD) {         // under temperature 
+    } else if (charger->fault & AXP20_FAULT_LOG_COLD) {             // under temperature 
         val->intval = POWER_SUPPLY_HEALTH_COLD;
     } else {
         val->intval = POWER_SUPPLY_HEALTH_GOOD;
     }
+#else
+    val->intval = POWER_SUPPLY_HEALTH_GOOD;
+#endif
 }
 
 static int axp_battery_get_property(struct power_supply         *psy,
                                     enum   power_supply_property psp,
                                     union  power_supply_propval *val)
 {
-    struct axp_charger *charger;
-    int ret = 0;
-    charger = container_of(psy, struct axp_charger, batt);
+    struct axp20_supply *supply;
+    struct aml_charger  *charger;
+    int ret     = 0;
+    supply      = container_of(psy, struct axp20_supply, batt);
+    charger     = &supply->aml_charger;
 
     switch (psp) {
     case POWER_SUPPLY_PROP_STATUS:                              // check battery status
-        axp_battery_check_status(charger, val);
+        axp_battery_check_status(supply, val);
         break;
     case POWER_SUPPLY_PROP_HEALTH:
-        axp_battery_check_health(charger, val);
+        axp_battery_check_health(supply, val);
         break;
     case POWER_SUPPLY_PROP_TECHNOLOGY:
-        val->intval = charger->battery_info->technology;
+        val->intval = supply->battery_info->technology;
         break;
     case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
-        val->intval = charger->battery_info->voltage_max_design;
+        val->intval = supply->battery_info->voltage_max_design;
         break;
     case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
-        val->intval = charger->battery_info->voltage_min_design;
+        val->intval = supply->battery_info->voltage_min_design;
         break;
     case POWER_SUPPLY_PROP_VOLTAGE_NOW:
         val->intval = charger->ocv * 1000;
         break;
     case POWER_SUPPLY_PROP_CURRENT_NOW:                         // positive for charging, negative for discharging
-        val->intval = charger->ibat * 1000 * (charger->bat_current_direction ? 1 : -1);
+        if (charger->charge_status == CHARGER_CHARGING) {
+            val->intval = charger->ibat * 1000;
+        } else {
+            val->intval = charger->ibat * 1000 * -1;
+        }
         break;
     case POWER_SUPPLY_PROP_MODEL_NAME:
-        val->strval = charger->batt.name;
+        val->strval = supply->batt.name;
         break;
     case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
-        val->intval = charger->battery_info->energy_full_design;
+        val->intval = supply->battery_info->energy_full_design;
         break;
     case POWER_SUPPLY_PROP_CAPACITY:
         val->intval = charger->rest_vol;
         break;
     case POWER_SUPPLY_PROP_ONLINE:
-        val->intval = (!charger->is_on)&&(charger->bat_det) && (! charger->ext_valid);
+        val->intval = (charger->bat_det) && (!charger->ext_valid);
         break;
     case POWER_SUPPLY_PROP_PRESENT:
         val->intval = charger->bat_det;
@@ -306,25 +317,27 @@ static int axp_ac_get_property(struct power_supply         *psy,
                                enum   power_supply_property psp,
                                union  power_supply_propval *val)
 {
-    struct axp_charger *charger;
+    struct axp20_supply *supply;
+    struct aml_charger  *charger;
     int ret = 0;
-    charger = container_of(psy, struct axp_charger, ac);
+    supply  = container_of(psy, struct axp20_supply, ac);
+    charger = &supply->aml_charger;
 
     switch(psp){
     case POWER_SUPPLY_PROP_MODEL_NAME:
-        val->strval = charger->ac.name;
+        val->strval = supply->ac.name;
         break;
     case POWER_SUPPLY_PROP_PRESENT:
-        val->intval = charger->ac_det;
+        val->intval = charger->dcin_valid;
         break;
     case POWER_SUPPLY_PROP_ONLINE:
-        val->intval = charger->ac_valid;    
+        val->intval = charger->dcin_valid;    
         break;
     case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-        val->intval = charger->vac * 1000;
+        val->intval = charger->v_dcin * 1000;
         break;
     case POWER_SUPPLY_PROP_CURRENT_NOW:
-        val->intval = charger->iac * 1000;
+        val->intval = charger->i_dcin * 1000;
         break;
     default:
         ret = -EINVAL;
@@ -337,25 +350,27 @@ static int axp_usb_get_property(struct power_supply         *psy,
                                 enum   power_supply_property psp,
                                 union  power_supply_propval *val)
 {
-    struct axp_charger *charger;
-    int ret = 0;
-    charger = container_of(psy, struct axp_charger, usb);
+    struct axp20_supply *supply;
+    struct aml_charger  *charger;
+    int ret     = 0;
+    supply  = container_of(psy, struct axp20_supply, usb);
+    charger = &supply->aml_charger;
 
     switch(psp){
     case POWER_SUPPLY_PROP_MODEL_NAME:
-        val->strval = charger->usb.name;
+        val->strval = supply->usb.name;
         break;
     case POWER_SUPPLY_PROP_PRESENT:
-        val->intval = charger->usb_det;
+        val->intval = charger->usb_valid;
         break;
     case POWER_SUPPLY_PROP_ONLINE:
         val->intval = charger->usb_valid;
         break;
     case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-        val->intval = charger->vusb * 1000;
+        val->intval = charger->v_usb * 1000;
         break;
     case POWER_SUPPLY_PROP_CURRENT_NOW:
-        val->intval = charger->iusb * 1000;
+        val->intval = charger->i_usb * 1000;
         break;
     default:
         ret = -EINVAL;
@@ -368,12 +383,12 @@ static char *supply_list[] = {
     "battery",
 };
 
-static void axp_battery_setup_psy(struct axp_charger *charger)
+static void axp_battery_setup_psy(struct axp20_supply *supply)
 {
-    struct power_supply *batt = &charger->batt;
-    struct power_supply *ac = &charger->ac;
-    struct power_supply *usb = &charger->usb;
-    struct power_supply_info *info = charger->battery_info;
+    struct power_supply *batt = &supply->batt;
+    struct power_supply *ac   = &supply->ac;
+    struct power_supply *usb  = &supply->usb;
+    struct power_supply_info *info = supply->battery_info;
 
     batt->name           = "battery";
     batt->use_for_apm    = info->use_for_apm;
@@ -408,10 +423,9 @@ int axp_set_charge_current(int chgcur)
 
     if(chgcur >= 300000 && chgcur <= 1800000){
         tmp = ((chgcur - 200001) / 100000 & 0x0f) | 0x80;                   // enable charge
-        gcharger->chgcur = tmp * 100000 + 300000;
-        axp_update(gcharger->master, AXP20_CHARGE_CONTROL1, tmp, 0x8F);
+        axp_update(g_axp20_supply->master, AXP20_CHARGE_CONTROL1, tmp, 0x8F);
     } else if (chgcur == 0) {
-        axp_clr_bits(gcharger->master, AXP20_CHARGE_CONTROL1, 0x80);
+        axp_clr_bits(g_axp20_supply->master, AXP20_CHARGE_CONTROL1, 0x80);
     } else {
         AXP_PMU_DBG("Invalid charge current input:%d\n", chgcur);
         return -1;
@@ -420,40 +434,55 @@ int axp_set_charge_current(int chgcur)
 }
 EXPORT_SYMBOL_GPL(axp_set_charge_current);
 
-int axp_reg_read(uint8_t addr, uint8_t *buf)
+int axp20_reg_read(int addr, uint8_t *buf)
 {
     CHECK_DRIVER();
-    return axp_read(gcharger->master, addr, buf);
+    return axp_read(g_axp20_supply->master, addr, buf);
 }
-EXPORT_SYMBOL_GPL(axp_reg_read);
+EXPORT_SYMBOL_GPL(axp20_reg_read);
 
-int axp_reg_reads(uint8_t start_addr, uint8_t *buf, int size)
+int axp20_reg_reads(int start_addr, uint8_t *buf, int size)
 {
     CHECK_DRIVER();
-    return axp_reads(gcharger->master, start_addr, size, buf);
+    return axp_reads(g_axp20_supply->master, start_addr, size, buf);
 }
-EXPORT_SYMBOL_GPL(axp_reg_reads);
+EXPORT_SYMBOL_GPL(axp20_reg_reads);
 
-int axp_reg_write(uint8_t addr, uint8_t val)
+int axp20_reg_write(int addr, uint8_t val)
 {
     CHECK_DRIVER();
-    return axp_read(gcharger->master, addr, val);
+    return axp_write(g_axp20_supply->master, addr, val);
 }
-EXPORT_SYMBOL_GPL(axp_reg_write);
+EXPORT_SYMBOL_GPL(axp20_reg_write);
 
-int axp_reg_writes(uint8_t start_addr, uint8_t *buf, int size)
+int axp20_reg_writes(int start_addr, uint8_t *buf, int size)
 {
     CHECK_DRIVER();
-    return axp_writes(gcharger->master, start_addr, size, buf);
+    return axp_writes(g_axp20_supply->master, start_addr, size, buf);
+}
+EXPORT_SYMBOL_GPL(axp20_reg_writes);
+
+int axp20_set_bits(int addr, uint8_t bits, uint8_t mask)
+{
+    uint8_t val; 
+    int ret; 
+ 
+    ret = axp20_reg_read(addr, &val); 
+    if (ret) { 
+        return ret; 
+    } 
+    val &= ~(mask); 
+    val |=  (bits & mask); 
+    return axp20_reg_write(addr, val); 
 }
-EXPORT_SYMBOL_GPL(axp_reg_writes);
+EXPORT_SYMBOL_GPL(axp20_set_bits);
 
 int axp_charger_set_usbcur_limit_extern(int usbcur_limit)
 {
     uint8_t val;
 
     CHECK_DRIVER();
-	axp_read(gcharger->master, AXP20_CHARGE_VBUS, &val);
+	axp_read(g_axp20_supply->master, AXP20_CHARGE_VBUS, &val);
     val &= ~(0x03);
 	switch (usbcur_limit) {
 		case 0:
@@ -473,14 +502,14 @@ int axp_charger_set_usbcur_limit_extern(int usbcur_limit)
 			return -1;
 			break;
 	}
-	axp_write(gcharger->master, AXP20_CHARGE_VBUS, val);
+	axp_write(g_axp20_supply->master, AXP20_CHARGE_VBUS, val);
 	
     return 0;
 }
 EXPORT_SYMBOL_GPL(axp_charger_set_usbcur_limit_extern);
 
 #if defined  (CONFIG_AXP_CHARGEINIT)
-static int axp_battery_adc_set(struct axp_charger *charger)
+static int axp_battery_adc_set(struct axp20_supply *supply)
 {
     int     ret;
 	uint8_t val;
@@ -493,7 +522,7 @@ static int axp_battery_adc_set(struct axp_charger *charger)
           AXP20_ADC_USBVOL_ENABLE  | 
           AXP20_ADC_USBCUR_ENABLE;                                      // enable ADC
 
-    ret = axp_update(charger->master, AXP20_ADC_CONTROL1, val , val);
+    ret = axp_update(supply->master, AXP20_ADC_CONTROL1, val , val);
     if (ret) {
         return ret;
     }
@@ -502,8 +531,8 @@ static int axp_battery_adc_set(struct axp_charger *charger)
         AXP_PMU_DBG("%s, invalid pmu_init_adc_freqc:%d, we use 100Hz as default\n",
                     __func__, freq);
         freq = 100;
-}
-    ret = axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+    }
+    ret = axp_read(supply->master, AXP20_ADC_CONTROL3, &val);
     val &= ~(3 << 6);
     switch (freq / 25) {
     case 1:                                                             //  25 Hz
@@ -521,48 +550,38 @@ static int axp_battery_adc_set(struct axp_charger *charger)
         val |= 2 << 6;                                                  // use 100Hz for default
         break;
     }
-    ret = axp_write(charger->master, AXP20_ADC_CONTROL3, val);
+    ret = axp_write(supply->master, AXP20_ADC_CONTROL3, val);
     if (ret) {
         return ret;
     }
     return 0;
 }
 #else
-static int axp_battery_adc_set(struct axp_charger *charger)
+static int axp_battery_adc_set(struct axp20_supply *supply)
 {
     return 0;
 }
 #endif
 
-static int axp_battery_first_init(struct axp_charger *charger)
+static int axp_battery_first_init(struct axp20_supply *supply)
 {
     int ret;
-    uint8_t val;
+    
+    ret  = axp_set_charge(supply);
+    ret |= axp_battery_adc_set(supply);
+    return ret;
+}
 
-    ret  = axp_set_charge(charger);
-    ret |= axp_battery_adc_set(charger);
-    if (ret) {
-        return ret;
-    }
+int axp20_set_rdc(int rdc) 
+{
+    uint32_t rdc_tmp = (rdc * 10000 + 5371) / 10742;
 
-    ret = axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
-    switch ((val >> 6) & 0x03){
-    case 0: 
-        charger->sample_time = 25;
-        break;
-    case 1: 
-        charger->sample_time = 50;
-        break;
-    case 2: 
-        charger->sample_time = 100;
-        break;
-    case 3: 
-        charger->sample_time = 200;
-        break;
-    default:
-        break;
-    }
-    return ret;
+    CHECK_DRIVER();
+    axp_set_bits(g_axp20_supply->master, 0xB9, 0x80);                   // stop
+    axp_clr_bits(g_axp20_supply->master, 0xBA, 0x80);
+    axp_write(g_axp20_supply->master, 0xBB, rdc_tmp & 0xff);
+    axp_write(g_axp20_supply->master, 0xBA, (rdc_tmp >> 8) & 0x1F);
+    return  axp_clr_bits(g_axp20_supply->master, 0xB9, 0x80);           // start
 }
 
 int axp_set_usb_voltage_limit(int voltage)
@@ -574,11 +593,11 @@ int axp_set_usb_voltage_limit(int voltage)
         return -1;
     }
     CHECK_DRIVER();
-    axp_read(gcharger->master, AXP20_CHARGE_VBUS, &val);
+    axp_read(g_axp20_supply->master, AXP20_CHARGE_VBUS, &val);
     voltage = ((voltage - 4000) / 100) & 0x07;
     val &= ~(0x38);
     val |=  (voltage << 3);
-    return axp_write(gcharger->master, AXP20_CHARGE_VBUS, val);
+    return axp_write(g_axp20_supply->master, AXP20_CHARGE_VBUS, val);
 }
 EXPORT_SYMBOL_GPL(axp_set_usb_voltage_limit);
 
@@ -591,10 +610,10 @@ int axp_set_noe_delay(int delay)
         return -1;
     }
     CHECK_DRIVER();
-    axp_read(gcharger->master, POWER20_OFF_CTL, &val);
+    axp_read(g_axp20_supply->master, POWER20_OFF_CTL, &val);
     val &= 0xfc;
     val |= ((delay / 1000) & 0x03);
-    return axp_write(gcharger->master, POWER20_OFF_CTL, val);
+    return axp_write(g_axp20_supply->master, POWER20_OFF_CTL, val);
 }
 EXPORT_SYMBOL_GPL(axp_set_noe_delay);
 
@@ -606,7 +625,7 @@ int axp_set_pek_on_time(int time)
         return -1;
     }
     CHECK_DRIVER();
-    axp_read(gcharger->master,POWER20_PEK_SET,&val);
+    axp_read(g_axp20_supply->master,POWER20_PEK_SET,&val);
     val &= 0x3f;
     if (time < 1000) {                                                  // 128ms
         val |= 0x00;
@@ -617,7 +636,7 @@ int axp_set_pek_on_time(int time)
     } else {                                                            // 3S
         val |= 0x40;
     }
-    return axp_write(gcharger->master,POWER20_PEK_SET,val);
+    return axp_write(g_axp20_supply->master,POWER20_PEK_SET,val);
 }
 EXPORT_SYMBOL_GPL(axp_set_pek_on_time);
 
@@ -630,10 +649,10 @@ int axp_set_pek_long_time(int time)
         return -1;
     }
     CHECK_DRIVER();
-    axp_read(gcharger->master,POWER20_PEK_SET,&val);
+    axp_read(g_axp20_supply->master,POWER20_PEK_SET,&val);
     val &= 0xcf;
     val |= (((time - 1000) / 500) << 4);
-    return axp_write(gcharger->master,POWER20_PEK_SET,val);
+    return axp_write(g_axp20_supply->master,POWER20_PEK_SET,val);
 }
 EXPORT_SYMBOL_GPL(axp_set_pek_long_time);
 
@@ -642,10 +661,10 @@ int axp_set_pek_off_en(int en)
     uint8_t val;
 
     CHECK_DRIVER();
-    axp_read(gcharger->master,POWER20_PEK_SET,&val);
+    axp_read(g_axp20_supply->master,POWER20_PEK_SET,&val);
     val &= 0xf7;
     val |= ((en ? 1 : 0) << 3);
-    return axp_write(gcharger->master,POWER20_PEK_SET,val);
+    return axp_write(g_axp20_supply->master,POWER20_PEK_SET,val);
 }
 EXPORT_SYMBOL_GPL(axp_set_pek_off_en);
 
@@ -657,10 +676,10 @@ int axp_set_pwrok_delay(int delay)
         AXP_PMU_DBG("%s, invalid value of pmu_pwrok_time:%d\n", __func__, delay);
     }
     CHECK_DRIVER();
-    axp_read(gcharger->master,POWER20_PEK_SET,&val);
+    axp_read(g_axp20_supply->master,POWER20_PEK_SET,&val);
     val &= 0xfb;
     val |= ((delay == 8 ? 0 : 1) << 2);
-    return axp_write(gcharger->master,POWER20_PEK_SET,val);
+    return axp_write(g_axp20_supply->master,POWER20_PEK_SET,val);
 }
 EXPORT_SYMBOL_GPL(axp_set_pwrok_delay);
 
@@ -673,10 +692,10 @@ int axp_set_pek_off_time(int time)
     }
     CHECK_DRIVER();
     time = (time - 4000) / 2000;
-    axp_read(gcharger->master,POWER20_PEK_SET,&val);
+    axp_read(g_axp20_supply->master,POWER20_PEK_SET,&val);
     val &= 0xfc;
     val |= (time & 0x03);
-    return axp_write(gcharger->master,POWER20_PEK_SET,val);
+    return axp_write(g_axp20_supply->master,POWER20_PEK_SET,val);
 }
 EXPORT_SYMBOL_GPL(axp_set_pek_off_time);
 
@@ -685,31 +704,31 @@ int axp_set_ot_power_off_en(int en)
     uint8_t val; 
 
     CHECK_DRIVER();
-    axp_read(gcharger->master, POWER20_HOTOVER_CTL, &val);
+    axp_read(g_axp20_supply->master, POWER20_HOTOVER_CTL, &val);
     val &= 0xfb;
     val |= ((en ? 1 : 0) << 2);
-    return axp_write(gcharger->master, POWER20_HOTOVER_CTL, val);
+    return axp_write(g_axp20_supply->master, POWER20_HOTOVER_CTL, val);
 }
 EXPORT_SYMBOL_GPL(axp_set_ot_power_off_en);
 
 int axp_get_battery_percent(void)
 {
     CHECK_DRIVER();
-    return gcharger->rest_vol;
+    return g_axp20_supply->aml_charger.rest_vol;
 }
 EXPORT_SYMBOL_GPL(axp_get_battery_percent);
 
 int axp_get_battery_voltage(void)
 {
     CHECK_DRIVER();
-    return gcharger->vbat;
+    return g_axp20_supply->aml_charger.vbat;
 }
 EXPORT_SYMBOL_GPL(axp_get_battery_voltage);
 
 int axp_get_battery_current(void)
 {
     CHECK_DRIVER();
-    return gcharger->ibat;
+    return g_axp20_supply->aml_charger.ibat;
 }
 EXPORT_SYMBOL_GPL(axp_get_battery_current);
 
@@ -722,28 +741,30 @@ int axp_set_poweroff_voltage(int voltage)
         AXP_PMU_DBG("Invalid input of voltage:%d\n", voltage);
         return -EINVAL;
     }
-    axp_read(gcharger->master, 0x31, &val);
+    axp_read(g_axp20_supply->master, 0x31, &val);
     val &= ~(0x07);
     voltage = ((voltage - 2600) / 100) & 0x07;
     val |= voltage;
-    axp_write(gcharger->master, 0x31, val);
+    axp_write(g_axp20_supply->master, 0x31, val);
     return 0;
 }
 EXPORT_SYMBOL_GPL(axp_set_poweroff_voltage);
 
-static int axp_battery_para_init(struct axp_charger *charger)
+static void axp_battery_para_init(struct axp20_supply *supply)
 {
     if (axp_pmu_battery->pmu_usbvol_limit) {                            // limit VBUS voltage
         axp_set_usb_voltage_limit(axp_pmu_battery->pmu_usbvol);
     } else {
-        axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, (1<<6));       // not limit
+        axp_clr_bits(supply->master, AXP20_CHARGE_VBUS, (1<<6));       // not limit
     }
 
+#if 0
     if(axp_pmu_battery->pmu_usbcur_limit) {                             // limit USB current
         axp_charger_set_usbcur_limit_extern(axp_pmu_battery->pmu_usbcur);
     } else {
         axp_charger_set_usbcur_limit_extern(0);
     }
+#endif
 
     axp_set_noe_delay(axp_pmu_battery->pmu_pwrnoe_time);                // set n_oe delay
     axp_set_pek_on_time(axp_pmu_battery->pmu_pekon_time);               // set pek_on time
@@ -757,55 +778,52 @@ static int axp_battery_para_init(struct axp_charger *charger)
 }
 
 /*------------------------ sysfs for debug ----------------------------*/
-
-static ssize_t chgen_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgen_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt);
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
 
-    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
-    charger->chgen = val >> 7;
-    return sprintf(buf, "%d\n", charger->chgen);
+    axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
+    return sprintf(buf, "%d\n", val >> 7);
 }
 
-static ssize_t chgen_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgen_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int var;
 
     var = simple_strtoul(buf, NULL, 10);
     if(var){
-        charger->chgen = 1;
-        axp_set_bits(charger->master, AXP20_CHARGE_CONTROL1, 0x80);
+        axp_set_bits(supply->master, AXP20_CHARGE_CONTROL1, 0x80);
     } else{
-        charger->chgen = 0;
-        axp_clr_bits(charger->master, AXP20_CHARGE_CONTROL1, 0x80);
+        axp_clr_bits(supply->master, AXP20_CHARGE_CONTROL1, 0x80);
     }
     return count;
 }
 
-static ssize_t chgmicrovol_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgmicrovol_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
+    int chgvol = 0;
 
-    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+    axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
     switch ((val >> 5) & 0x03){
-    case 0: charger->chgvol = 4100000; break;
-    case 1: charger->chgvol = 4150000; break;
-    case 2: charger->chgvol = 4200000; break;
-    case 3: charger->chgvol = 4360000; break;
+    case 0: chgvol = 4100000; break;
+    case 1: chgvol = 4150000; break;
+    case 2: chgvol = 4200000; break;
+    case 3: chgvol = 4360000; break;
     }
-    return sprintf(buf, "%d\n",charger->chgvol);
+    return sprintf(buf, "%d\n", chgvol);
 }
 
-static ssize_t chgmicrovol_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgmicrovol_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt);
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int var;
     uint8_t tmp, val;
 
@@ -818,277 +836,270 @@ static ssize_t chgmicrovol_store(struct device *dev, struct device_attribute *at
     default:  tmp = 4; break;
     }
     if(tmp < 4){
-        charger->chgvol = var;
-        axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+        axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
         val &= 0x9F;
         val |= tmp << 5;
-        axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+        axp_write(supply->master, AXP20_CHARGE_CONTROL1, val);
     }
     return count;
 }
 
-static ssize_t chgintmicrocur_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgintmicrocur_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
+    int chgcur = 0;
 
-    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
-    charger->chgcur = (val & 0x0F) * 100000 +300000;
-    return sprintf(buf, "%d\n",charger->chgcur);
+    axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
+    chgcur = (val & 0x0F) * 100000 +300000;
+    return sprintf(buf, "%d\n", chgcur);
 }
 
-static ssize_t chgintmicrocur_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgintmicrocur_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int var;
     uint8_t val,tmp;
 
     var = simple_strtoul(buf, NULL, 10);
     if(var >= 300000 && var <= 1800000){
         tmp = (var -200001)/100000;
-        charger->chgcur = tmp *100000 + 300000;
-        axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+        axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
         val &= 0xF0;
         val |= tmp;
-        axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+        axp_write(supply->master, AXP20_CHARGE_CONTROL1, val);
     }
     return count;
 }
 
-static ssize_t chgendcur_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgendcur_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
+    int chgend = 0;
 
-    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
-    charger->chgend = ((val >> 4)& 0x01)? 15 : 10;
-    return sprintf(buf, "%d\n",charger->chgend);
+    axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
+    chgend = ((val >> 4)& 0x01)? 15 : 10;
+    return sprintf(buf, "%d\n", chgend);
 }
 
-static ssize_t chgendcur_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgendcur_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int var;
 
     var = simple_strtoul(buf, NULL, 10);
     if(var == 10 ){
-        charger->chgend = var;
-        axp_clr_bits(charger->master ,AXP20_CHARGE_CONTROL1,0x10);
-    }
-    else if (var == 15){
-        charger->chgend = var;
-        axp_set_bits(charger->master ,AXP20_CHARGE_CONTROL1,0x10);
-
+        axp_clr_bits(supply->master ,AXP20_CHARGE_CONTROL1,0x10);
+    } else if (var == 15){
+        axp_set_bits(supply->master ,AXP20_CHARGE_CONTROL1,0x10);
     }
     return count;
 }
 
-static ssize_t chgpretimemin_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgpretimemin_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
+    int chgpretime = 0;
 
-    axp_read(charger->master,AXP20_CHARGE_CONTROL2, &val);
-    charger->chgpretime = (val >> 6) * 10 +40;
-    return sprintf(buf, "%d\n",charger->chgpretime);
+    axp_read(supply->master,AXP20_CHARGE_CONTROL2, &val);
+    chgpretime = (val >> 6) * 10 +40;
+    return sprintf(buf, "%d\n", chgpretime);
 }
 
-static ssize_t chgpretimemin_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgpretimemin_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int     var;
     uint8_t tmp,val;
 
     var = simple_strtoul(buf, NULL, 10);
     if(var >= 40 && var <= 70){
         tmp = (var - 40)/10;
-        charger->chgpretime = tmp * 10 + 40;
-        axp_read(charger->master,AXP20_CHARGE_CONTROL2,&val);
+        axp_read(supply->master,AXP20_CHARGE_CONTROL2,&val);
         val &= 0x3F;
         val |= (tmp << 6);
-        axp_write(charger->master,AXP20_CHARGE_CONTROL2,val);
+        axp_write(supply->master,AXP20_CHARGE_CONTROL2,val);
     }
     return count;
 }
 
-static ssize_t chgcsttimemin_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgcsttimemin_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
+    int chgcsttime = 0;
 
-    axp_read(charger->master,AXP20_CHARGE_CONTROL2, &val);
-    charger->chgcsttime = (val & 0x03) *120 + 360;
-    return sprintf(buf, "%d\n",charger->chgcsttime);
+    axp_read(supply->master,AXP20_CHARGE_CONTROL2, &val);
+    chgcsttime = (val & 0x03) *120 + 360;
+    return sprintf(buf, "%d\n", chgcsttime);
 }
 
-static ssize_t chgcsttimemin_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t chgcsttimemin_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int     var;
     uint8_t tmp,val;
 
     var = simple_strtoul(buf, NULL, 10);
     if(var >= 360 && var <= 720){
         tmp = (var - 360)/120;
-        charger->chgcsttime = tmp * 120 + 360;
-        axp_read(charger->master,AXP20_CHARGE_CONTROL2,&val);
+        axp_read(supply->master,AXP20_CHARGE_CONTROL2,&val);
         val &= 0xFC;
         val |= tmp;
-        axp_write(charger->master,AXP20_CHARGE_CONTROL2,val);
+        axp_write(supply->master,AXP20_CHARGE_CONTROL2,val);
     }
     return count;
 }
 
-static ssize_t adcfreq_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t adcfreq_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
+    int sample_time = 0;
 
-    axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+    axp_read(supply->master, AXP20_ADC_CONTROL3, &val);
     switch ((val >> 6) & 0x03){
-    case 0: charger->sample_time = 25;  break;
-    case 1: charger->sample_time = 50;  break;
-    case 2: charger->sample_time = 100; break;
-    case 3: charger->sample_time = 200; break;
+    case 0: sample_time = 25;  break;
+    case 1: sample_time = 50;  break;
+    case 2: sample_time = 100; break;
+    case 3: sample_time = 200; break;
     default:break;
     }
-    return sprintf(buf, "%d\n",charger->sample_time);
+    return sprintf(buf, "%d\n", sample_time);
 }
 
-static ssize_t adcfreq_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t adcfreq_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int     var;
     uint8_t val;
 
     var = simple_strtoul(buf, NULL, 10);
-    axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+    axp_read(supply->master, AXP20_ADC_CONTROL3, &val);
     val &= ~(3 << 6);
     switch (var / 25) {
     case 1: 
-        charger->sample_time = 25;
         break;
     case 2: 
         val |= 1 << 6;
-        charger->sample_time = 50;
         break;
     case 4: 
         val |= 2 << 6;
-        charger->sample_time = 100;
         break;
     case 8: 
         val |= 3 << 6;
-        charger->sample_time = 200;
         break;
     default: 
         break;
     }
-    axp_write(charger->master, AXP20_ADC_CONTROL3, val);
+    axp_write(supply->master, AXP20_ADC_CONTROL3, val);
     return count;
 }
 
 
-static ssize_t vholden_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t vholden_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
 
-    axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+    axp_read(supply->master,AXP20_CHARGE_VBUS, &val);
     val = (val>>6) & 0x01;
     return sprintf(buf, "%d\n",val);
 }
 
-static ssize_t vholden_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t vholden_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int var;
 
     var = simple_strtoul(buf, NULL, 10);
     if (var) {
-        axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+        axp_set_bits(supply->master, AXP20_CHARGE_VBUS, 0x40);
     } else {
-        axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+        axp_clr_bits(supply->master, AXP20_CHARGE_VBUS, 0x40);
     }
 
     return count;
 }
 
-static ssize_t vhold_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t vhold_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
     int     vhold;
 
-    axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+    axp_read(supply->master,AXP20_CHARGE_VBUS, &val);
     vhold = ((val >> 3) & 0x07) * 100000 + 4000000;
     return sprintf(buf, "%d\n",vhold);
 }
 
-static ssize_t vhold_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t vhold_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int     var;
     uint8_t val,tmp;
 
     var = simple_strtoul(buf, NULL, 10);
     if(var >= 4000000 && var <=4700000){
         tmp = (var - 4000000)/100000;
-        axp_read(charger->master, AXP20_CHARGE_VBUS,&val);
+        axp_read(supply->master, AXP20_CHARGE_VBUS,&val);
         val &= 0xC7;
         val |= tmp << 3;
-        axp_write(charger->master, AXP20_CHARGE_VBUS,val);
+        axp_write(supply->master, AXP20_CHARGE_VBUS,val);
     }
     return count;
 }
 
-static ssize_t iholden_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t iholden_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val;
 
-    axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+    axp_read(supply->master,AXP20_CHARGE_VBUS, &val);
     return sprintf(buf, "%d\n",((val & 0x03) == 0x03)?0:1);
 }
 
-static ssize_t iholden_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t iholden_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int     var;
 
     var = simple_strtoul(buf, NULL, 10);
     if (var) {
-        axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+        axp_clr_bits(supply->master, AXP20_CHARGE_VBUS, 0x01);
     } else {
-        axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+        axp_set_bits(supply->master, AXP20_CHARGE_VBUS, 0x03);
     }
 
     return count;
 }
 
-static ssize_t ihold_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t ihold_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     uint8_t val,tmp;
     int     ihold;
 
-    axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+    axp_read(supply->master,AXP20_CHARGE_VBUS, &val);
     tmp = (val) & 0x03;
     switch(tmp){
     case 0: ihold = 900000;break;
@@ -1099,59 +1110,60 @@ static ssize_t ihold_show(struct device *dev, struct device_attribute *attr, cha
     return sprintf(buf, "%d\n",ihold);
 }
 
-static ssize_t ihold_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t ihold_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
     int     var;
 
     var = simple_strtoul(buf, NULL, 10);
     if (var == 900000) {
-        axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+        axp_clr_bits(supply->master, AXP20_CHARGE_VBUS, 0x03);
     } else if (var == 500000) {
-        axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
-        axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+        axp_clr_bits(supply->master, AXP20_CHARGE_VBUS, 0x02);
+        axp_set_bits(supply->master, AXP20_CHARGE_VBUS, 0x01);
     } else if (var == 100000) {
-        axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
-        axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+        axp_clr_bits(supply->master, AXP20_CHARGE_VBUS, 0x01);
+        axp_set_bits(supply->master, AXP20_CHARGE_VBUS, 0x02);
     }
 
     return count;
 }
 
-static ssize_t clear_rtc_mem_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t clear_rtc_mem_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-    return count;    
+    return 0;
 }
 
-static ssize_t clear_rtc_mem_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t clear_rtc_mem_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-
     aml_write_rtc_mem_reg(0, 0);
     axp_power_off();
     return count;
 }
 
-static ssize_t dbg_info_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t dbg_info_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
-    int     size;
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
+    int    size;
+    struct aml_charger  *charger = &supply->aml_charger;
     
-    size = axp_format_dbg_buffer(charger, buf);
+    size = aml_pmu_format_dbg_buffer(charger, buf);
 
     return size;
 }
 
-static ssize_t dbg_info_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t dbg_info_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     return 0;                                           /* nothing to do        */
 }
 
-static ssize_t battery_para_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t battery_para_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     struct power_supply *battery = dev_get_drvdata(dev);
-    struct axp_charger  *charger = container_of(battery, struct axp_charger, batt); 
+    struct axp20_supply *supply  = container_of(battery, struct axp20_supply, batt);
+    struct aml_charger  *charger = &supply->aml_charger;
     int    i = 0; 
     int    size;
 
@@ -1175,17 +1187,17 @@ static ssize_t battery_para_show(struct device *dev, struct device_attribute *at
     return size;
 }
 
-static ssize_t battery_para_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t battery_para_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     return 0;                                           /* nothing to do        */    
 }
 
-static ssize_t report_delay_show(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t report_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-    return sprintf(buf, "report_delay = %d\n", report_delay); 
+    return sprintf(buf, "report_delay = %d\n", aml_pmu_get_report_delay()); 
 }
 
-static ssize_t report_delay_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t report_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     uint32_t tmp = simple_strtoul(buf, NULL, 10);
 
@@ -1193,21 +1205,82 @@ static ssize_t report_delay_store(struct device *dev, struct device_attribute *a
         AXP_PMU_DBG("input too large, failed to set report_delay\n");    
         return 0;
     }
-    report_delay = tmp;
+    aml_pmu_set_report_delay(tmp);
     return 0;
 }
 
-static ssize_t driver_version_show (struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t driver_version_show (struct device *dev, struct device_attribute *attr, char *buf)
 {
     return sprintf(buf, "Amlogic AXP202 driver version is %s, build time:%s\n", 
                    AXP_DRIVER_VERSION, init_uts_ns.name.version);    
 }
-static ssize_t driver_version_store(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+static ssize_t driver_version_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
     return 0;    
 }
 
-static struct device_attribute axp_charger_attrs[] = {
+static int find_idx(int start, int target, int step, int length)
+{
+    int i = 0;
+    do {
+        if (start >= target) {
+            break;    
+        }    
+        start += step;
+        i++;
+    } while (i < length);
+    return i;
+}
+
+void axp20_dcdc_voltage(int dcdc, int target) 
+{
+    int idx_to = 0, idx_cur = 0;
+    int addr = 0, val, mask = 0;
+    if (dcdc == 2) {
+        idx_to = find_idx(700, target, 25, 64);
+        addr   = 0x23; 
+        mask   = 0x3f;
+    } else if (dcdc == 3) {
+        idx_to = find_idx(700, target, 25, 128);
+        addr   = 0x27; 
+        mask   = 0x7f;
+    }   
+    axp_read(g_axp20_supply->master, addr, (uint8_t *)&val);
+    idx_cur = val & mask;
+    while (idx_cur != idx_to) {
+        if (idx_cur < idx_to) {                                 // adjust to target voltage step by step
+            idx_cur++;
+        } else {
+            idx_cur--;
+        }
+        val &= ~mask;
+        val |= (idx_cur);
+        axp_write(g_axp20_supply->master, addr, val);
+        udelay(100);                                            // atleast delay 100uS
+    }
+}
+
+static ssize_t aml_pmu_vddao_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    uint8_t data;
+    axp_read(g_axp20_supply->master, 0x2f, &data);
+
+    return sprintf(buf, "Voltage of VDD_AO = %4dmV\n", 700 + 25 * (data & 0x7f));
+}
+
+static ssize_t aml_pmu_vddao_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    uint32_t data = simple_strtoul(buf, NULL, 10);
+    if (data > 3500 || data < 700) {
+        AXP_PMU_DBG("Invalid input value = %d\n", data);
+        return -1;
+    }
+    AXP_PMU_DBG("Set VDD_AO to %4d mV\n", data);
+    axp20_dcdc_voltage(3, data);
+    return count; 
+}
+
+static struct device_attribute axp_supply_attrs[] = {
     AXP_CHG_ATTR(chgen),
     AXP_CHG_ATTR(chgmicrovol),
     AXP_CHG_ATTR(chgintmicrocur),
@@ -1224,13 +1297,14 @@ static struct device_attribute axp_charger_attrs[] = {
     AXP_CHG_ATTR(report_delay),
     AXP_CHG_ATTR(driver_version),
     AXP_CHG_ATTR(clear_rtc_mem),
+    AXP_CHG_ATTR(aml_pmu_vddao),
 };
 
 int axp_charger_create_attrs(struct power_supply *psy)
 {
     int j, ret;
-    for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
-        ret = device_create_file(psy->dev, &axp_charger_attrs[j]);
+    for (j = 0; j < ARRAY_SIZE(axp_supply_attrs); j++) {
+        ret = device_create_file(psy->dev, &axp_supply_attrs[j]);
         if (ret) {
             goto sysfs_failed;
         }
@@ -1239,7 +1313,7 @@ int axp_charger_create_attrs(struct power_supply *psy)
 
 sysfs_failed:
     while (j--) {
-        device_remove_file(psy->dev, &axp_charger_attrs[j]);
+        device_remove_file(psy->dev, &axp_supply_attrs[j]);
     }
     return ret;
 }
@@ -1335,7 +1409,6 @@ static inline int axp_iusb_to_mA(uint16_t reg)
 #define AXP_CAP							(0xB9)
 #define AXP_RDC_BUFFER0					(0xBA)
 #define AXP_RDC_BUFFER1					(0xBB)
-#define AXP_OCV_BUFFER0					(0xBC)
 #define AXP_OCV_BUFFER1					(0xBD)
 
 #define AXP_HOTOVER_CTL					POWER20_HOTOVER_CTL
@@ -1350,7 +1423,7 @@ static int axp_get_freq(void)
 {
 	int  ret = 25;
 	uint8_t  temp;
-    axp_read(gcharger->master, AXP_ADC_CONTROL3,&temp);
+    axp_read(g_axp20_supply->master, AXP_ADC_CONTROL3,&temp);
 	temp &= 0xc0;
 	switch(temp >> 6){
 		case 0:	ret = 25; break;
@@ -1362,257 +1435,230 @@ static int axp_get_freq(void)
 	return ret;
 }
 
-void axp_get_coulomb(struct axp_charger *charger, int *charge_c, int *discharge_c)
+int axp20_get_coulomb(struct aml_charger *charger)
 {
-    uint8_t  temp[8];
-    int64_t  rValue1,rValue2,rValue;
-    int      m;
+    struct  axp20_supply *supply = (struct axp20_supply*)container_of(charger, struct axp20_supply, aml_charger);
+    uint8_t temp[8];
+    int64_t rValue1, rValue2, rValue;
+    int     m;
 
     m = axp_get_freq() * 480;
-	axp_reads(charger->master, AXP_CCHAR3_RES,8,temp);
+	axp_reads(supply->master, AXP_CCHAR3_RES,8,temp);
 	rValue1 = ((temp[0] << 24) + (temp[1] << 16) + (temp[2] << 8) + temp[3]);
 	rValue2 = ((temp[4] << 24) + (temp[5] << 16) + (temp[6] << 8) + temp[7]);
 
     rValue  = rValue1 * 4369;
     do_div(rValue, m);
-    *charge_c = (int)rValue;
+    charger->charge_cc = (int)rValue;
 
     rValue = rValue2 * 4369;
     do_div(rValue, m);
-    *discharge_c = (int)rValue;
+    charger->discharge_cc = (int)rValue;
 
-    return ;
+    return 0;
 }
-EXPORT_SYMBOL_GPL(axp_get_coulomb);
 
-void axp_clear_coulomb(struct axp_charger *charger)
+int axp20_clear_coulomb(struct aml_charger *charger)
 {
+    struct  axp20_supply *supply = (struct axp20_supply*)container_of(charger, struct axp20_supply, aml_charger);
     uint8_t val;
 
-    axp_read(charger->master, 0xb8, &val);
+    axp_read(supply->master, 0xb8, &val);
     val |= 0x20;
-    axp_write(charger->master, 0xb8, val);
+    axp_write(supply->master, 0xb8, val);
+    return 0;
 }
-EXPORT_SYMBOL_GPL(axp_clear_coulomb);
 
-static void axp_read_adc(struct axp_charger *charger, struct axp_adc_res *adc)
+void axp_read_adc(struct axp20_supply *supply, struct axp_adc_res *adc)
 {
 	uint8_t tmp[8];
 
-	axp_reads(charger->master, AXP_VACH_RES, 8, tmp);
+	axp_reads(supply->master, AXP_VACH_RES, 8, tmp);
 	adc->vac_res  = ((uint16_t) tmp[0] << 4) | (tmp[1] & 0x0f);
 	adc->iac_res  = ((uint16_t) tmp[2] << 4) | (tmp[3] & 0x0f);
 	adc->vusb_res = ((uint16_t) tmp[4] << 4) | (tmp[5] & 0x0f);
 	adc->iusb_res = ((uint16_t) tmp[6] << 4) | (tmp[7] & 0x0f);
 
-	axp_reads(charger->master, AXP_VBATH_RES, 6, tmp);
+	axp_reads(supply->master, AXP_VBATH_RES, 6, tmp);
 	adc->vbat_res     = ((uint16_t) tmp[0] << 4) | (tmp[1] & 0x0f);
 	adc->ichar_res    = ((uint16_t) tmp[2] << 4) | (tmp[3] & 0x0f);
 	adc->idischar_res = ((uint16_t) tmp[4] << 5) | (tmp[5] & 0x1f);
 }
 
-static void reset_charger(struct axp_charger *charger)
+#if 0
+static void reset_charger(struct axp20_supply *supply)
 {
 	uint8_t val;
 
 	AXP_PMU_DBG("reset_charger\n");
-	axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
-	val &= ~(1<<7);
-	axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+	axp_read(supply->master, AXP20_CHARGE_CONTROL1, &val);
+	val &= ~(1 << 7);
+	axp_write(supply->master, AXP20_CHARGE_CONTROL1, val);
 	mdelay(100);
-	val |= 1<<7;
-	axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+	val |= 1 << 7;
+	axp_write(supply->master, AXP20_CHARGE_CONTROL1, val);
 }
+#endif
 
-static void axp_charger_update_state(struct axp_charger *charger)
+int axp20_update_status(struct aml_charger *charger)
 {
-	uint8_t val[2];
-	uint16_t tmp;
+    struct  axp20_supply *supply = (struct axp20_supply*)container_of(charger, struct axp20_supply, aml_charger);
+	uint8_t        val[2];
+	uint16_t       tmp;
     static uint8_t usb_cur_limit_canceled = 0;
-    static uint8_t recharge_cnt = 0;
 
-	axp_reads(charger->master, AXP_CHARGE_STATUS, 2, val);
+    axp_charger_update(supply);
+	axp_reads(supply->master, AXP_CHARGE_STATUS, 2, val);
 	tmp = (val[1] << 8 )+ val[0];
-	charger->is_on 					= (tmp & AXP_STATUS_INCHAR)     ? 1 : 0;
 	charger->bat_det 				= (tmp & AXP_STATUS_BATEN)      ? 1 : 0;
-	charger->ac_det 				= (tmp & AXP_STATUS_ACEN)       ? 1 : 0;
-	charger->usb_det 				= (tmp & AXP_STATUS_USBEN)      ? 1 : 0;
+    charger->fault                  = tmp;
 	charger->usb_valid 				= (tmp & AXP_STATUS_USBVA)      ? 1 : 0;
-	charger->ac_valid 				= (tmp & AXP_STATUS_ACVA)       ? 1 : 0;
-	charger->ext_valid 				= charger->ac_valid | (charger->usb_valid << 1);
-	charger->bat_current_direction 	= (tmp & AXP_STATUS_BATCURDIR)  ? 1 : 0;
-	charger->in_short 				= (tmp & AXP_STATUS_ACUSBSH)    ? 1 : 0;
-	charger->batery_active 			= (tmp & AXP_STATUS_BATINACT)   ? 1 : 0;
-	charger->low_charge_current 	= (tmp & AXP_STATUS_CHACURLOEXP)? 1 : 0;
-	charger->int_over_temp 			= (tmp & AXP_STATUS_ICTEMOV)    ? 1 : 0;
-	axp_read(charger->master, AXP_CHARGE_CONTROL1, val);
-	charger->charge_on 				= ((val[0] & 0x80)?1:0);
+	charger->dcin_valid 			= (tmp & AXP_STATUS_ACVA)       ? 1 : 0;
+	charger->ext_valid              = charger->dcin_valid | (charger->usb_valid << 1);
+	charger->charge_status 	        = (tmp & AXP_STATUS_BATCURDIR) ? CHARGER_CHARGING : CHARGER_DISCHARGING;
     /*
      * when usb is connected && board config tell us do not limit current
      */
     if (charger->usb_valid && !axp_pmu_battery->pmu_usbcur_limit && !usb_cur_limit_canceled) {
-        axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+        axp_set_bits(supply->master, AXP20_CHARGE_VBUS, 0x03);
         usb_cur_limit_canceled = 1;
     } else if (!charger->usb_valid) {
         usb_cur_limit_canceled = 0;    
     }
+    return 0;
 }
 
-static void axp_charger_update(struct axp_charger *charger)
+void axp_charger_update(struct axp20_supply *supply)
 {
-	uint16_t tmp;	
+    struct aml_charger *charger = &supply->aml_charger;
+    uint8_t v[2] = {};
 
-	axp_read_adc(charger, &charger->adc);
-	tmp = charger->adc.vbat_res;
-	charger->vbat = axp_vbat_to_mV(tmp);
-	charger->ibat = ABS(axp_ibat_to_mA(charger->adc.ichar_res) - 
-                        axp_ibat_to_mA(charger->adc.idischar_res));
-	tmp = charger->adc.vac_res;
-	charger->vac = axp_vdc_to_mV(tmp);
-	tmp = charger->adc.iac_res;
-	charger->iac = axp_iac_to_mA(tmp);
-	tmp = charger->adc.vusb_res;
-	charger->vusb = axp_vdc_to_mV(tmp);
-	tmp = charger->adc.iusb_res;
-	charger->iusb = axp_iusb_to_mA(tmp);
-	if(!charger->ext_valid){
-		charger->disvbat =  charger->vbat;
-		charger->disibat =  charger->ibat;
-	}
+	axp_read_adc(supply, &supply->adc);
+	charger->vbat   = axp_vbat_to_mV(supply->adc.vbat_res);
+	charger->ibat   = ABS(axp_ibat_to_mA(supply->adc.ichar_res) - 
+                          axp_ibat_to_mA(supply->adc.idischar_res));
+    charger->v_dcin = axp_vdc_to_mV(supply->adc.vac_res);
+    charger->i_dcin = axp_iac_to_mA(supply->adc.iac_res);
+    charger->v_usb  = axp_vdc_to_mV(supply->adc.vusb_res);
+    charger->i_usb  = axp_iusb_to_mA(supply->adc.iusb_res);
+    axp_reads(supply->master, AXP_OCV_BUFFER0, 2, v);
+    charger->ocv    = ((v[0] << 4) + (v[1] & 0x0f)) * 11 /10 ;
 }
 
-static int axp_calculate_ocv(struct axp_charger *charger)
+#if AML_PMU_CALL_BACK_DEMO
+int axp_call_back1(struct aml_charger *charger, void *pdata)
 {
-    int ret;
-    int ibat = charger->ibat;
-    int vbat = charger->vbat;
-
-    if (charger->bat_current_direction) {
-        ret = vbat - (ibat * axp_pmu_battery->pmu_battery_rdc) / 1000;
-	} else {
-        ret = vbat + (ibat * axp_pmu_battery->pmu_battery_rdc) / 1000;    
-	}
-    return ret;
+    char *str = (char *)pdata;
+    AXP_PMU_DBG("%s, %s, battery percent now:%d\n", __func__, str, charger->rest_vol);
+    return 0;
 }
 
-void axp_caculate_ocv_vol(struct axp_charger *charger, int ocv)
+int axp_call_back2(struct aml_charger *charger, void *pdata)
 {
-    int i = 0;
-    int ocv_diff, percent_diff, ocv_diff2;
-
-    if (ocv >= charger->ocv_full) {                     // full voltage 
-        charger->ocv_rest_vol = 100;
-        return;
-    } else if (ocv < charger->ocv_empty) {
-        charger->ocv_rest_vol = 0;                      // empty voltage 
-        return;
-			}
-    for (i = 0; i < 15; i++) {                          // find which range this ocv is in
-        if (ocv >= axp_pmu_battery->pmu_bat_curve[i].ocv &&
-            ocv <  axp_pmu_battery->pmu_bat_curve[i + 1].ocv) {
-			break;
-		}
-	}
-    if (charger->bat_current_direction) {
-        percent_diff = axp_pmu_battery->pmu_bat_curve[i + 1].charge_percent - 
-                       axp_pmu_battery->pmu_bat_curve[i].charge_percent;
-    } else {
-        percent_diff = axp_pmu_battery->pmu_bat_curve[i + 1].discharge_percent - 
-                       axp_pmu_battery->pmu_bat_curve[i].discharge_percent;
-		}
-    ocv_diff = axp_pmu_battery->pmu_bat_curve[i + 1].ocv - 
-               axp_pmu_battery->pmu_bat_curve[i].ocv;
-    ocv_diff2 = ocv - axp_pmu_battery->pmu_bat_curve[i].ocv;
-    charger->ocv_rest_vol = (percent_diff * ocv_diff2 + ocv_diff / 2)/ocv_diff;
-    if (charger->bat_current_direction) {
-        charger->ocv_rest_vol += axp_pmu_battery->pmu_bat_curve[i].charge_percent;    
-    } else {
-        charger->ocv_rest_vol += axp_pmu_battery->pmu_bat_curve[i].discharge_percent;    
-		}
-    return ;
-		}
-EXPORT_SYMBOL_GPL(axp_caculate_ocv_vol);
+    char *str = (char *)pdata;
+    struct aml_pmu_driver *driver = aml_pmu_get_driver();
+    AXP_PMU_DBG("%s, %s, battery voltage:%d, cuurent:%d\n", 
+                __func__, str, charger->vbat, charger->ibat);
+    /*
+     * just for demo:
+     * when extern power is removed, set usb current limit to 
+     * 900mA to avoid large current sink form source
+     */
+    if (driver && !charger->ext_valid) {
+        if (driver->pmu_set_usb_current_limit) {
+            driver->pmu_set_usb_current_limit(900); 
+        }
+    }
+    return 0;
+}
+#endif  /* AML_PMU_CALL_BACK_DEMO */
 
 static void axp_charging_monitor(struct work_struct *work)
 {
-	struct axp_charger *charger;
-	int pre_rest_cap;
-	uint8_t  v[2];
+    struct axp20_supply *supply;
+    struct aml_charger  *charger;
+    int32_t pre_rest_cap;
+    uint8_t pre_chg_status;
 
-	charger = container_of(work, struct axp_charger, work.work);
 
-	pre_rest_cap = charger->rest_vol;
-	axp_charger_update_state(charger);
-	axp_charger_update(charger);
+    supply  = container_of(work, struct axp20_supply, work.work);
+    charger = &supply->aml_charger;
+    pre_chg_status = charger->ext_valid;
+    pre_rest_cap   = charger->rest_vol;
 
-	axp_reads(charger->master,AXP_OCV_BUFFER0,2,v);
-	charger->ocv = ((v[0] << 4) + (v[1] & 0x0f)) * 11 /10 ;
-    
-    axp_update_ocv_vol(charger);
-	axp_update_coulomb(charger, axp_pmu_battery);
-    axp_update_battery_capacity(charger, axp_pmu_battery);
+    aml_pmu_update_battery_capacity(charger, axp_pmu_battery);
 
     if(!charger->ext_valid){                                    // clear charge LED when extern power is removed
-        axp_clr_bits(charger->master, POWER20_OFF_CTL, 0x38);
-		}
-    if (charger->pmu_call_back) {
-        charger->pmu_call_back(charger->para);    
-			} 
+        axp_clr_bits(supply->master, POWER20_OFF_CTL, 0x38);
+    }
+    if((charger->rest_vol - pre_rest_cap) || (pre_chg_status != charger->ext_valid) || charger->resume){
+        AXP_PMU_DBG("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
+        if (unlikely(charger->resume)) {
+            charger->resume = 0;
+        }
+        power_supply_changed(&supply->batt);
+    }
 
-	if((charger->rest_vol - pre_rest_cap) || (pre_chg_status != charger->ext_valid) || charger->resume){
-		AXP_PMU_DBG("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
-		power_supply_changed(&charger->batt);
-        axp_post_update_process(charger);
-		}
-	pre_chg_status = charger->ext_valid;
+    schedule_delayed_work(&supply->work, supply->interval);
+}
 
-    schedule_delayed_work(&charger->work, charger->interval);
-		}
 
-		
 
 #if defined CONFIG_HAS_EARLYSUSPEND
 static void axp_earlysuspend(struct early_suspend *h)
-		{
+{
     uint8_t tmp;
 
 #if defined (CONFIG_AXP_CHGCHANGE)
-    early_suspend_flag = 1;
-    if (pmu_earlysuspend_chgcur >= 300000 && pmu_earlysuspend_chgcur <= 1800000) {
-        tmp = (pmu_earlysuspend_chgcur -200001)/100000;
-        axp_update(gcharger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
-		}
+    if (axp_pmu_battery->pmu_suspend_chgcur >= 300000 && axp_pmu_battery->pmu_suspend_chgcur <= 1800000) {
+        tmp = (axp_pmu_battery->pmu_suspend_chgcur - 200001) / 100000;
+        axp_update(g_axp20_supply->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+    }
 #endif
-		}
+}
 
 static void axp_lateresume(struct early_suspend *h)
-	{
-    struct axp_charger *charger = (struct axp_charger *)h->param;
+{
+    struct axp20_supply *supply = (struct axp20_supply*)h->param;
     uint8_t tmp;
 
-	schedule_work(&charger->work); 
+    schedule_work(&supply->work.work); 
 
 #if defined (CONFIG_AXP_CHGCHANGE)
-	early_suspend_flag = 0;
     if(axp_pmu_battery->pmu_resume_chgcur >= 300000 && axp_pmu_battery->pmu_resume_chgcur <= 1800000){
         tmp = (axp_pmu_battery->pmu_resume_chgcur -200001)/100000;
-        axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
-			}
+        axp_update(supply->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
 #endif
-	}
+}
 #endif
 
+static struct aml_pmu_driver axp20_pmu_driver = {
+    .name                      = "axp20",
+    .pmu_get_coulomb           = axp20_get_coulomb,
+    .pmu_clear_coulomb         = axp20_clear_coulomb,
+    .pmu_update_status         = axp20_update_status,
+    .pmu_set_rdc               = axp20_set_rdc,
+    .pmu_set_gpio              = axp_gpio_set_value,
+    .pmu_get_gpio              = axp_gpio_get_value,
+    .pmu_reg_read              = axp20_reg_read,
+    .pmu_reg_write             = axp20_reg_write,
+    .pmu_reg_reads             = axp20_reg_reads,
+    .pmu_reg_writes            = axp20_reg_writes,
+    .pmu_set_bits              = axp20_set_bits, 
+    .pmu_set_usb_current_limit = axp_charger_set_usbcur_limit_extern,
+    .pmu_set_charge_current    = axp_set_charge_current,
+    .pmu_power_off             = axp_power_off, 
+};
+
 static int axp_battery_probe(struct platform_device *pdev)
 {
-	struct axp_charger *charger;
+	struct axp20_supply *supply;
+    struct aml_charger  *charger;
 	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
-	int ret,k,var;
-	uint8_t val1,val2,tmp,val;
-	uint8_t ocv_cap[31];
-	int Cur_CoulombCounter;
-	int      ocv_init = 0;
+	int      ret;
+	uint8_t  tmp, val;
 	uint32_t tmp2;
-    int      max_diff = 0, tmp_diff;
 
     AXP_PMU_DBG("call %s, in\n", __func__);
 	powerkeydev = input_allocate_device();
@@ -1658,161 +1704,134 @@ static int axp_battery_probe(struct platform_device *pdev)
 #endif
 
     /*
-     * initialize parameters for charger
+     * initialize parameters for supply 
      */
-	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
-	if (charger == NULL) {
+	supply = kzalloc(sizeof(*supply), GFP_KERNEL);
+	if (supply == NULL) {
 	    return -ENOMEM;
     }
-    charger->battery_info = kzalloc(sizeof(struct power_supply_info), GFP_KERNEL);
-    if (charger->battery_info == NULL) {
-        kfree(charger);
+    supply->battery_info = kzalloc(sizeof(struct power_supply_info), GFP_KERNEL);
+    if (supply->battery_info == NULL) {
+        kfree(supply);
         return -ENOMEM;    
     }
-	charger->master = pdev->dev.parent;
-
-    for (tmp2 = 0; tmp2 < 16; tmp2++) {
+	supply->master = pdev->dev.parent;
+    charger        = &supply->aml_charger;
+    for (tmp2 = 1; tmp2 < 16; tmp2++) {
         if (!charger->ocv_empty && axp_pmu_battery->pmu_bat_curve[tmp2].discharge_percent > 0) {
             charger->ocv_empty = axp_pmu_battery->pmu_bat_curve[tmp2-1].ocv;
         }
         if (!charger->ocv_full && axp_pmu_battery->pmu_bat_curve[tmp2].discharge_percent == 100) {
             charger->ocv_full = axp_pmu_battery->pmu_bat_curve[tmp2].ocv;    
         }
-        tmp_diff = axp_pmu_battery->pmu_bat_curve[tmp2].discharge_percent - 
-                   axp_pmu_battery->pmu_bat_curve[tmp2].charge_percent;
-        if (tmp_diff > max_diff) {
-            max_diff = tmp_diff;    
-        }
     }
+    aml_pmu_register_driver(&axp20_pmu_driver);
 
-	charger->chgcur       = axp_pmu_battery->pmu_init_chgcur;
-	charger->chgvol       = axp_pmu_battery->pmu_init_chgvol;
-	charger->chgend       = axp_pmu_battery->pmu_init_chgend_rate;
-	charger->sample_time  = axp_pmu_battery->pmu_init_adc_freqc;
-	charger->chgen        = axp_pmu_battery->pmu_init_chg_enabled;
-	charger->chgpretime   = axp_pmu_battery->pmu_init_chg_pretime;
-	charger->chgcsttime   = axp_pmu_battery->pmu_init_chg_csttime;
-
-    charger->battery_info->technology         = axp_pmu_battery->pmu_battery_technology;
-    charger->battery_info->voltage_max_design = axp_pmu_battery->pmu_init_chgvol;
-    charger->battery_info->energy_full_design = axp_pmu_battery->pmu_battery_cap;
-    charger->battery_info->voltage_min_design = charger->ocv_empty * 1000;
-    charger->battery_info->use_for_apm        = 1;
-    charger->battery_info->name               = axp_pmu_battery->pmu_battery_name;
-
-	charger->disvbat = 0;
-	charger->disibat = 0;
-    charger->led_control     = pdata->led_control;
+    supply->battery_info->technology         = axp_pmu_battery->pmu_battery_technology;
+    supply->battery_info->voltage_max_design = axp_pmu_battery->pmu_init_chgvol;
+    supply->battery_info->energy_full_design = axp_pmu_battery->pmu_battery_cap;
+    supply->battery_info->voltage_min_design = charger->ocv_empty * 1000;
+    supply->battery_info->use_for_apm        = 1;
+    supply->battery_info->name               = axp_pmu_battery->pmu_battery_name;
+
+    supply->led_control      = pdata->led_control;
     charger->soft_limit_to99 = pdata->soft_limit_to99;
-    charger->para            = pdata->para;
-    charger->pmu_call_back   = pdata->pmu_call_back;
-	gcharger = charger;
+	charger->coulomb_type    = COULOMB_BOTH;
+	g_axp20_supply = supply;
 
-    ret = axp_battery_first_init(charger);
+    ret = axp_battery_first_init(supply);
     if (ret) {
-        goto err_charger_init;
+        goto err_ps_register;
     }
 
-    axp_battery_setup_psy(charger);                                     // regist power supply interface
-    ret = power_supply_register(&pdev->dev, &charger->batt);
+    axp_battery_setup_psy(supply);                                     // regist power supply interface
+    ret = power_supply_register(&pdev->dev, &supply->batt);
     if (ret) {
         goto err_ps_register;
     }
-    ret = power_supply_register(&pdev->dev, &charger->ac);
+    ret = power_supply_register(&pdev->dev, &supply->ac);
     if (ret){
-        power_supply_unregister(&charger->batt);
+        power_supply_unregister(&supply->batt);
         goto err_ps_register;
     }
-    ret = power_supply_register(&pdev->dev, &charger->usb);
+    ret = power_supply_register(&pdev->dev, &supply->usb);
     if (ret){
-        power_supply_unregister(&charger->ac);
-        power_supply_unregister(&charger->batt);
+        power_supply_unregister(&supply->ac);
+        power_supply_unregister(&supply->batt);
         goto err_ps_register;
     }
 
-    ret = axp_charger_create_attrs(&charger->batt);
+    ret = axp_charger_create_attrs(&supply->batt);
     if(ret){
         return ret;
     }
 
-    platform_set_drvdata(pdev, charger);
-    axp_battery_para_init(charger);
-    axp_write(charger->master, AXP20_APS_WARNING1, 0x7A);               // 3.555V, warning to system	
-    axp_charger_update_state(charger);
+    platform_set_drvdata(pdev, supply);
+    axp_battery_para_init(supply);
+    axp_write(supply->master, AXP20_APS_WARNING1, 0x7A);               // 3.555V, warning to system	
+    axp20_update_status(charger);
 
     if (charger->bat_det == 0) {                                        // no battery connect 
         AXP_PMU_DBG("%s, not dectected battery\n", __func__);
 	}
 
-	axp_set_bits(charger->master,0xB8,0x80);
-    axp_set_bits(charger->master, 0xB9, 0x80);
-	axp_clr_bits(charger->master,0xBA,0x80);
+	axp_set_bits(supply->master,0xB8,0x80);
+    axp_set_bits(supply->master, 0xB9, 0x80);
+	axp_clr_bits(supply->master,0xBA,0x80);
 
-    tmp2 = (axp_pmu_battery->pmu_battery_rdc * 10000 + 5371) / 10742;   // set RDC
-		axp_write(charger->master,0xBB,tmp2 & 0x00FF);
-		axp_update(charger->master, 0xBA, (tmp2 >> 8), 0x1F);
-    axp_clr_bits(charger->master, 0xB9, 0x80);                          // start to work
-	mdelay(500);
+    axp20_set_rdc(axp_pmu_battery->pmu_battery_rdc);
+    mdelay(500);
 
-	charger->interval = msecs_to_jiffies(2 * 1000);
-	INIT_DELAYED_WORK(&charger->work, axp_charging_monitor);
-	schedule_delayed_work(&charger->work, charger->interval);
+    supply->interval = msecs_to_jiffies(2 * 1000);
+    INIT_DELAYED_WORK(&supply->work, axp_charging_monitor);
+    schedule_delayed_work(&supply->work, supply->interval);
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
-    pmu_earlysuspend_chgcur   = axp_pmu_battery->pmu_suspend_chgcur;
     axp_early_suspend.suspend = axp_earlysuspend;
     axp_early_suspend.resume  = axp_lateresume;
     axp_early_suspend.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 2;
-    axp_early_suspend.param   = charger;
+    axp_early_suspend.param   = supply;
     register_early_suspend(&axp_early_suspend);
 #endif
 
     /* axp202 ntc battery low / high temperature alarm function */
     if (axp_pmu_battery->pmu_ntc_enable) {
 #define TS_CURRENT_REG 		0x84
-        axp_read(charger->master,TS_CURRENT_REG, &val);
+        axp_read(supply->master,TS_CURRENT_REG, &val);
         tmp = axp_pmu_battery->pmu_ntc_ts_current << 4;
         val &= ~(3<<4);	//val &= 0xcf;
         val |= tmp;		
         val &= ~(3<<0);
         val |= 0x1;		//TS pin:charge output current	
-        axp_write(charger->master,TS_CURRENT_REG,val); 	//set TS pin output current
+        axp_write(supply->master,TS_CURRENT_REG,val); 	//set TS pin output current
 
         if(axp_pmu_battery->pmu_ntc_lowtempvol < 0)
             axp_pmu_battery->pmu_ntc_lowtempvol = 0;
         else if(axp_pmu_battery->pmu_ntc_lowtempvol > 3264)
             axp_pmu_battery->pmu_ntc_lowtempvol = 3264;
         val = (axp_pmu_battery->pmu_ntc_lowtempvol*10)/(16*8);
-        axp_write(charger->master,POWER20_VLTF_CHGSET,val);	//set battery low temperature threshold
+        axp_write(supply->master,POWER20_VLTF_CHGSET,val);	//set battery low temperature threshold
 
         if(axp_pmu_battery->pmu_ntc_hightempvol < 0)
             axp_pmu_battery->pmu_ntc_hightempvol = 0;
         else if(axp_pmu_battery->pmu_ntc_hightempvol > 3264)
             axp_pmu_battery->pmu_ntc_hightempvol = 3264;
         val = (axp_pmu_battery->pmu_ntc_hightempvol*10)/(16*8);
-        axp_write(charger->master,POWER20_VHTF_CHGSET,val);	//set battery high temperature threshold
+        axp_write(supply->master,POWER20_VHTF_CHGSET,val);	//set battery high temperature threshold
     }
 
-    for (tmp2 = 0; tmp2 < 8; tmp2++) {
-        axp_reads(charger->master, AXP_OCV_BUFFER0, 2, ocv_cap);
-        ocv_init += ((ocv_cap[0] << 4) + (ocv_cap[1] & 0x0f)) * 11 /10;
-        msleep(10);
-    }
-    charger->ocv = ocv_init / 8;
-    axp_update_coulomb(charger, axp_pmu_battery);
-    axp_caculate_ocv_vol(charger, charger->ocv);
-    axp_battery_probe_process(charger, axp_pmu_battery);
+#if AML_PMU_CALL_BACK_DEMO
+    aml_pmu_register_callback(axp_call_back1, "callback1...",  "demo 1");
+    aml_pmu_register_callback(axp_call_back2, "callback2...",  "demo 2");
+#endif /* AML_PMU_CALL_BACK_DEMO*/
+
+    aml_pmu_probe_process(charger, axp_pmu_battery);
 
     return ret;
 
 err_ps_register:
-
-err_notifier:
-    cancel_delayed_work_sync(&charger->work);
-
-err_charger_init:
-    kfree(charger->battery_info);
-    kfree(charger);
+    kfree(supply->battery_info);
+    kfree(supply);
     input_unregister_device(powerkeydev);
     kfree(powerkeydev);
 
@@ -1822,30 +1841,35 @@ err_charger_init:
 
 static int axp_battery_remove(struct platform_device *dev)
 {
-    struct axp_charger *charger = platform_get_drvdata(dev);
+    struct axp20_supply *supply = platform_get_drvdata(dev);
 
-    cancel_delayed_work_sync(&charger->work);
-    power_supply_unregister(&charger->usb);
-    power_supply_unregister(&charger->ac);
-    power_supply_unregister(&charger->batt);
+    cancel_delayed_work_sync(&supply->work);
+    power_supply_unregister(&supply->usb);
+    power_supply_unregister(&supply->ac);
+    power_supply_unregister(&supply->batt);
 
-    kfree(charger->battery_info);
-    kfree(charger);
+    kfree(supply->battery_info);
+    kfree(supply);
     input_unregister_device(powerkeydev);
     kfree(powerkeydev);
+    aml_pmu_clear_driver();
+#if AML_PMU_CALL_BACK_DEMO
+    aml_pmu_unregister_callback("demo 1");
+    aml_pmu_unregister_callback("demo 2");
+#endif /* AML_PMU_CALL_BACK_DEMO*/
 
     return 0;
 }
 
-static extern_led_ctrl = 0;
+static int extern_led_ctrl = 0;
 
 static int axp20_suspend(struct platform_device *dev, pm_message_t state)
 {
+    struct axp20_supply *supply  = platform_get_drvdata(dev);
+    struct aml_charger  *charger = &supply->aml_charger;
     uint8_t irq_w[9];
     uint8_t tmp;
-
-    struct axp_charger *charger = platform_get_drvdata(dev);
-	cancel_delayed_work_sync(&charger->work);
+	cancel_delayed_work_sync(&supply->work);
 
     /*clear all irqs events*/
     irq_w[0] = 0xff;
@@ -1857,59 +1881,44 @@ static int axp20_suspend(struct platform_device *dev, pm_message_t state)
     irq_w[6] = 0xff;
     irq_w[7] = POWER20_INTSTS5;
     irq_w[8] = 0xff;
-    axp_writes(charger->master, POWER20_INTSTS1, 9, irq_w);
+    axp_writes(supply->master, POWER20_INTSTS1, 9, irq_w);
     
-    charger->disvbat = 0;
-    charger->disibat = 0;
-
     axp_set_charge_current(axp_pmu_battery->pmu_suspend_chgcur);	//set charging current
     /* close all irqs*/
-    //axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
-    axp_read(charger->master, POWER20_OFF_CTL, &tmp);
+    axp_read(supply->master, POWER20_OFF_CTL, &tmp);
     extern_led_ctrl = tmp & 0x08;
     if (extern_led_ctrl) {
-    	axp_clr_bits(charger->master, POWER20_OFF_CTL, 0x08);
+    	axp_clr_bits(supply->master, POWER20_OFF_CTL, 0x08);
     }
-    axp_battery_suspend_process();
+    aml_pmu_suspend_process(charger);
 	
     return 0;
 }
 
 static int axp20_resume(struct platform_device *dev)
 {
-    struct   axp_charger *charger = platform_get_drvdata(dev);
-    int      ocv_resume = 0, i;
-    uint8_t  reg[2];
+    struct  axp20_supply *supply = platform_get_drvdata(dev);
+    struct  aml_charger *charger = &supply->aml_charger;
 
-    for (i = 0; i < 8; i++) {
-        axp_reads(charger->master, AXP_OCV_BUFFER0, 2, reg);
-        ocv_resume += (((reg[0] << 4) + (reg[1] & 0x0f)) * 11 / 10);
-        msleep(5);
-    }
-    ocv_resume /= 8;
-    charger->ocv = ocv_resume;
-    axp_caculate_ocv_vol(charger, charger->ocv);
-    axp_battery_resume_process(charger, axp_pmu_battery, ocv_resume);
+    aml_pmu_resume_process(charger, axp_pmu_battery);
 
 	axp_set_charge_current(axp_pmu_battery->pmu_resume_chgcur);	//set charging current
 
     if (extern_led_ctrl) {
-        axp_set_bits(charger->master, POWER20_OFF_CTL, 0x08);
+        axp_set_bits(supply->master, POWER20_OFF_CTL, 0x08);
         extern_led_ctrl = 0;
     }
-	
-	schedule_work(&charger->work);
+	schedule_work(&supply->work.work);
 
     return 0;
 }
 
 static void axp20_shutdown(struct platform_device *dev)
 {
-    uint8_t tmp;
-    struct axp_charger *charger = platform_get_drvdata(dev);
+    struct axp20_supply *supply = platform_get_drvdata(dev);
 
     /* not limit usb  voltage*/
-  	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS,0x40);
+  	axp_clr_bits(supply->master, AXP20_CHARGE_VBUS,0x40);
 
 	axp_set_charge_current(axp_pmu_battery->pmu_shutdown_chgcur);	//set charging current
 }
@@ -1926,7 +1935,7 @@ static struct platform_driver axp_battery_driver = {
     .shutdown = axp20_shutdown,
 };
 
-static int __init axp_battery_init(void)
+static int axp_battery_init(void)
 {
     int ret;
     ret = platform_driver_register(&axp_battery_driver);
@@ -1934,12 +1943,12 @@ static int __init axp_battery_init(void)
     return ret;
 }
 
-static void __exit axp_battery_exit(void)
+static void axp_battery_exit(void)
 {
     platform_driver_unregister(&axp_battery_driver);
 }
 
-subsys_initcall(axp_battery_init);
+module_init(axp_battery_init);
 module_exit(axp_battery_exit);
 
 MODULE_DESCRIPTION("axp20 battery charger driver");
diff --git a/drivers/amlogic/power/ricoh/ricoh_pmu.c b/drivers/amlogic/power/ricoh/ricoh_pmu.c
index 4a8fc7b47f44..1c62d0edceed 100755
--- a/drivers/amlogic/power/ricoh/ricoh_pmu.c
+++ b/drivers/amlogic/power/ricoh/ricoh_pmu.c
@@ -47,14 +47,14 @@ static const char *ricoh_pmu_sub_driver[] = {
             prop_name, value, value);                                   \
     }
 
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_string(node, prop_name, &value)) {             \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:%s\n",                            \
-            prop_name, value);                                          \
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)            \
+    if (of_property_read_string(node, prop_name, (const char **)&value)) {  \
+        DBG("failed to get property: %s\n", prop_name);                     \
+        goto exception;                                                     \
+    }                                                                       \
+    if (DEBUG_PARSE) {                                                      \
+        DBG("get property:%25s, value:%s\n",                                \
+            prop_name, value);                                              \
     }
 
 #define ALLOC_DEVICES(return_pointer, size, flag)                       \
@@ -140,11 +140,11 @@ setup2:
     return 0;
 }
 
-static struct i2c_device_id* find_id_table_by_name(struct i2c_device_id *look_table, char *name)
+static struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *look_table, char *name)
 {
     while (look_table->name && look_table->name[0]) {
         if (!strcmp(look_table->name, name)) {
-            return look_table;    
+            return (struct i2c_device_id *)look_table;    
         }
         look_table++;
     }
@@ -208,8 +208,8 @@ struct aml_dvfs_driver rn5t618_dvfs_driver = {
     .set_voltage = rn5t618_set_voltage, 
     .get_voltage = rn5t618_get_voltage,
 };
-extern struct aml_pmu_driver rn5t618_pmu_driver;
 #endif
+extern struct aml_pmu_driver rn5t618_pmu_driver;
 
 static int ricoh_pmu_check_device(struct i2c_client *client)
 {
diff --git a/drivers/amlogic/power/ricoh/rn5t618-rw.c b/drivers/amlogic/power/ricoh/rn5t618-rw.c
index 2637c9eb73a8..cdf676ccfcea 100755
--- a/drivers/amlogic/power/ricoh/rn5t618-rw.c
+++ b/drivers/amlogic/power/ricoh/rn5t618-rw.c
@@ -166,7 +166,7 @@ int rn5t618_set_bits(int addr, uint8_t bits, uint8_t mask)
 } 
 EXPORT_SYMBOL_GPL(rn5t618_set_bits); 
 
-int find_idx(uint32_t start, uint32_t target, uint32_t step, int size)
+static int find_idx(uint32_t start, uint32_t target, uint32_t step, int size)
 {
     int i = 0; 
 
diff --git a/drivers/amlogic/power/ricoh/rn5t618-sply.c b/drivers/amlogic/power/ricoh/rn5t618-sply.c
index 23077bee0777..0266f3cfb3fc 100755
--- a/drivers/amlogic/power/ricoh/rn5t618-sply.c
+++ b/drivers/amlogic/power/ricoh/rn5t618-sply.c
@@ -812,8 +812,6 @@ static int rn5t618_otg_change(struct notifier_block *nb, unsigned long value, vo
 
 static int rn5t618_usb_charger(struct notifier_block *nb, unsigned long value, void *pdata)
 {
-    int current_limit;
-
     switch (value) {
     case USB_BC_MODE_DISCONNECT:                                        // disconnect
     case USB_BC_MODE_SDP:                                               // pc
@@ -832,6 +830,7 @@ static int rn5t618_usb_charger(struct notifier_block *nb, unsigned long value, v
     default:
         break;
     }
+    return 0;
 }
 
 /*
@@ -852,7 +851,6 @@ int printf_usage(void)
 
 static ssize_t pmu_reg_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-    uint8_t data;
     return printf_usage(); 
 }
 
@@ -1199,7 +1197,6 @@ static void check_chip_temperature(void)
         rn5t618_power_off();    
     }
 }
-#endif
 
 static void check_extern_power_voltage(struct aml_charger *charger)
 {
@@ -1250,6 +1247,7 @@ static void check_extern_power_voltage(struct aml_charger *charger)
         }
     }
 }
+#endif
 
 static void rn5t618_charging_monitor(struct work_struct *work)
 {
diff --git a/include/linux/amlogic/aml_pmu.h b/include/linux/amlogic/aml_pmu.h
new file mode 100755
index 000000000000..5aaa1d795daf
--- /dev/null
+++ b/include/linux/amlogic/aml_pmu.h
@@ -0,0 +1,151 @@
+#ifndef __AML_PMU_H__
+#define __AML_PMU_H__
+
+#include <linux/power_supply.h>
+#include <linux/amlogic/aml_pmu_common.h>
+
+#define BATCAPCORRATE           5                                       // battery capability is very low
+#define ABS(x)                  ((x) >0 ? (x) : -(x))
+#define AML_PMU_WORK_CYCLE      2000                                    // PMU work cycle
+
+/*
+ * debug message control
+ */
+#define AML_PMU_DBG(format,args...)                 \
+    if (1) printk(KERN_ERR "[AML_PMU]"format,##args) 
+
+#define AML_PMU_CHG_ATTR(_name)                     \
+{                                                   \
+    .attr = { .name = #_name,.mode = 0644 },        \
+    .show =  _name##_show,                          \
+    .store = _name##_store,                         \
+}
+
+#define AML1212_ADDR                    0x35
+#define AML1212_SUPPLY_NAME             "aml1212-supplyer"
+#define AML1212_IRQ_NAME                "aml1212-irq"
+#define AML_PMU_IRQ_NUM                 INT_GPIO_2
+#define AML1212_SUPPLY_ID               0
+#define AML1212_DRIVER_VERSION          "v0.2"
+
+#define AML1212_OTP_GEN_CONTROL0        0x17
+
+#define AML1212_CHG_CTRL0               0x29
+#define AML1212_CHG_CTRL1               0x2A
+#define AML1212_CHG_CTRL2               0x2B
+#define AML1212_CHG_CTRL3               0x2C
+#define AML1212_CHG_CTRL4               0x2D
+#define AML1212_CHG_CTRL5               0x2E
+#define AML1212_SAR_ADJ                 0x73
+
+#define AML1212_GEN_CNTL0               0x80
+#define AML1212_GEN_CNTL1               0x81
+#define AML1212_PWR_UP_SW_ENABLE        0x82        // software power up
+#define AML1212_PWR_DN_SW_ENABLE        0x84        // software power down
+#define AML1212_GEN_STATUS0             0x86
+#define AML1212_GEN_STATUS1             0x87
+#define AML1212_GEN_STATUS2             0x88
+#define AML1212_GEN_STATUS3             0x89
+#define AML1212_GEN_STATUS4             0x8A
+#define AML1212_WATCH_DOG               0x8F
+#define AML1212_PWR_KEY_ADDR            0x90
+#define AML1212_SAR_SW_EN_FIELD         0x9A
+#define AML1212_SAR_CNTL_REG0           0x9B
+#define AML1212_SAR_CNTL_REG2           0x9D
+#define AML1212_SAR_CNTL_REG3           0x9E
+#define AML1212_SAR_CNTL_REG5           0xA0
+#define AML1212_SAR_RD_IBAT_LAST        0xAB        // battery current measure
+#define AML1212_SAR_RD_VBAT_ACTIVE      0xAF        // battery voltage measure
+#define AML1212_SAR_RD_MANUAL           0xB1        // manual measure
+#define AML1212_SAR_RD_IBAT_ACC         0xB5        // IBAT accumulated result, coulomb
+#define AML1212_SAR_RD_IBAT_CNT         0xB9        // IBAT measure count
+#define AML1212_GPIO_OUTPUT_CTRL        0xC3        // GPIO output control
+#define AML1212_GPIO_INPUT_STATUS       0xC4        // GPIO input status
+#define AML1212_IRQ_MASK_0              0xC8        // IRQ Mask base address
+#define AML1212_IRQ_STATUS_CLR_0        0xCF        // IRQ status base address
+#define AML1212_SP_CHARGER_STATUS0      0xDE        // charge status0
+#define AML1212_SP_CHARGER_STATUS1      0xDF        // charge status1
+#define AML1212_SP_CHARGER_STATUS2      0xE0        // charge status2
+#define AML1212_SP_CHARGER_STATUS3      0xE1        // charge status3
+#define AML1212_SP_CHARGER_STATUS4      0xE2        // charge status4
+#define AML1212_PIN_MUX4                0xF4        // pin mux select 4
+
+#define AML_PMU_DCDC1                   0
+#define AML_PMU_DCDC2                   1
+#define AML_PMU_DCDC3                   2
+#define AML_PMU_BOOST                   3
+#define AML_PMU_LDO1                    4
+#define AML_PMU_LDO2                    5
+#define AML_PMU_LDO3                    6
+#define AML_PMU_LDO4                    7
+#define AML_PMU_LDO5                    8
+
+/*
+ * function declaration here
+ */
+int aml_pmu_write  (int add, uint8_t  val);                             // single byte write
+int aml_pmu_write16(int add, uint16_t val);                             // 16 bits register write
+int aml_pmu_writes (int add, uint8_t *buff, int len);                   // block write
+int aml_pmu_read   (int add, uint8_t  *val);
+int aml_pmu_read16 (int add, uint16_t *val);
+int aml_pmu_reads  (int add, uint8_t *buff, int len);
+int aml_pmu_set_bits(int32_t addr, uint8_t bits, uint8_t mask);         // set bis in mask
+
+int aml_pmu_set_dcin(int enable);                                       // enable / disable dcin power path
+int aml_pmu_set_gpio(int pin, int val);                                 // set gpio value
+int aml_pmu_get_gpio(int pin, int *val);                                // get gpio value
+
+int aml_pmu_get_voltage(void);                                          // return battery voltage
+int aml_pmu_get_current(void);                                          // return battery current
+int aml_pmu_get_battery_percent(void);                                  // return battery capacity now, -1 means error
+
+// bc_mode, indicate usb is conneted to PC or adatper, please see <mach/usbclock.h>
+int aml_pmu_set_usb_current_limit(int curr, int bc_mode);               // set usb current limit, in mA
+int aml_pmu_set_usb_voltage_limit(int voltage);                         // set usb voltage limit, in mV
+int aml_pmu_set_charge_current(int chg_cur);                            // set charge current, in uA
+int aml_pmu_set_charge_voltage(int voltage);                            // set charge target voltage, in uA
+int aml_pmu_set_charge_end_rate(int rate);                              // set charge end rate, 10% or 20%
+int aml_pmu_set_adc_freq(int freq);                                     // SAR ADC auto-sample frequent, for coulomb
+int aml_pmu_set_precharge_time(int minute);                             // set pre-charge time when battery voltage is very low
+int aml_pmu_set_fastcharge_time(int minute);                            // set fast charge time when in CC period
+int aml_pmu_set_charge_enable(int en);                                  // enable or disable charge 
+
+void aml_pmu_set_voltage(int dcdc, int voltage);                        // set dcdc voltage, in mV
+void aml_pmu_poweroff(void);                                            // power off PMU
+
+void aml_pmu_clear_coulomb(void);                                       // clear coulomb register
+
+/*
+ * @soft_limit_to99: flag for if we need to restrict battery capacity to 99% when have charge current,
+ *                   even battery voltage is over ocv_full;
+ * @para:            parameters for call back funtions, user implement;
+ * @pmu_call_back:   call back function for axp_charging_monitor, you can add anything you want to do
+ *                   in this function, this funtion will be called every 2 seconds by default
+ */
+struct amlogic_pmu_init {
+    int   soft_limit_to99;                          // software limit battery volume to 99% when have charge current
+    int   charge_timeout_retry;                     // retry charge count when charge timeout
+    int   vbus_dcin_short_connect;                  // if VBUS and DCIN are short connected
+    struct battery_parameter *board_battery;        // battery parameter
+};
+
+struct aml1212_supply {
+    struct aml_charger aml_charger;
+	int32_t  interval;                                                  // PMU work cycle
+    int32_t  usb_connect_type;
+    int32_t  irq;
+
+	struct power_supply batt;                                           // power supply sysfs
+	struct power_supply	ac;
+	struct power_supply	usb;
+	struct power_supply_info *battery_info;
+	struct delayed_work work;                                           // work struct
+    struct work_struct  irq_work;                                       // work for IRQ 
+
+	struct device *master;
+};
+
+extern struct aml1212_supply *g1212_supply;                             // export global charger struct
+
+#endif /* __AML_PMU_H__ */
+
diff --git a/include/linux/amlogic/battery_parameter.h b/include/linux/amlogic/battery_parameter.h
old mode 100644
new mode 100755
index f77c3d5973c9..9ce9b98b6202
--- a/include/linux/amlogic/battery_parameter.h
+++ b/include/linux/amlogic/battery_parameter.h
@@ -4,6 +4,10 @@
 #define UBOOT_BATTERY_PARA_SUCCESS      1                       // battery parameters has got from uboot
 #define UBOOT_BATTERY_PARA_FAILED       0                       // battery parameters has not got from uboot
 
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
 /*
  * add for customer battery parameters
  */
-- 
2.19.0

