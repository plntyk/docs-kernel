From b8017fecd81b6329f40f28f79c76c3e802bfb4cb Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Fri, 3 Jan 2014 18:48:14 +0800
Subject: [PATCH 2874/5965] sync m6 lcd driver to 3.10 branch

Conflicts:

	drivers/amlogic/display/vout/lcdoutc.c
---
 arch/arm/boot/dts/amlogic/meson6_g24.dtd     | 167 ++++++++++---------
 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd  | 167 ++++++++++---------
 drivers/amlogic/display/backlight/Kconfig    |   2 +-
 drivers/amlogic/display/vout/Kconfig         |   2 +-
 drivers/amlogic/display/vout/edp_drv.h       |   3 +-
 drivers/amlogic/display/vout/lcdoutc.c       | 136 ++++++++-------
 drivers/amlogic/display/vout/mipi_dsi_util.c |  22 +--
 drivers/amlogic/display/vout/mipi_dsi_util.h |  32 ++--
 8 files changed, 272 insertions(+), 259 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson6_g24.dtd b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
index 2f0fbc55f016..ffe39761253e 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g24.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
@@ -401,23 +401,27 @@
 	backlight{
 		compatible = "amlogic,backlight";
 		dev_name = "backlight";
+		status = "okay";
 		pinctrl-names = "default";
 		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
 		
-		bl_level_default=<102>;	/** default backlight level when enter kernel */
+		bl_level_default_uboot_kernel=<20 128>;	/** default brightness level for uboot & kernel */
+		bl_level_middle_mapping=<102 70>;	/** brightness middle level mapping to a new level*/
+		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
 		
-		//backlight power ctrl
-		bl_ctrl_method="gpio";	/** gpio, pwm_negative, pwm_positive */
+		/* backlight power ctrl */
+		bl_ctrl_method=<0>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. decided by hardware design) */
 		bl_gpio_port="GPIOD_1";	/** backlight control gpio port */
-		bl_gpio_dim_max_min=<0x0 0xf>;	/** backlight brightness diming level for gpio control method, 0x0~0xf, negative logic */
-		bl_pwm_port_gpio_used="PWM_D","0";	/** pwm_gpio_used: 0 for no use gpio; 1 for use bl_gpio_port to enable/disable backlight */
-		bl_pwm_cnt_div=<60000 0>;	/** pwm_cnt<=65536, pwm_cnt=(pwm_high+pwm_low); pwm_freq=24M/pwm_cnt/(pwm_div+1) */
-		bl_pwm_duty_max_min=<100 20>;	/** backlight brightness diminig level for pwm control method, unit: % */
+		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
+		bl_pwm_port_gpio_used="PWM_D","0";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
+		bl_pwm_freq=<400>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<100 20>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
 	};
 	
 	lcd{
 		compatible = "amlogic,lcd";
 		dev_name = "lcd";
+		status = "okay";
 		pinctrl-names = "ttl_6bit_hvsync_de_on","ttl_6bit_hvsync_on","ttl_6bit_de_on","ttl_8bit_hvsync_de_on","ttl_8bit_hvsync_on","ttl_8bit_de_on",
 						"ttl_6bit_hvsync_de_off","ttl_8bit_hvsync_de_off";
 		pinctrl-0 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
@@ -431,24 +435,23 @@
 		
 		lcd_model_name ="lcd_LP097X02";	/** lcd model name for uboot driver */
 		lcd_model_config = <&lcd_LP097X02>;	/** choose panel model config */
-		lcd_bits=<6>;	/** 6 or 8, desided by hardware design; only valid when lcd_bits_option=1 */
+		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
 		
 		/* below configs are decided by hardware design, you can modify them if needed. */
 		//ttl config
-		ttl_rb_bit_swap=<0 0>;	/** 0 for normal, 1 for swap */
+		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
 		//lvds config
-		lvds_channel_pn_swap=<0>;	/** 0 for normal, 1 for swap */
+		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
 		
 		/* recommend settings, you can modify them if needed. */
-		valid_hvsync_de=<0 1>;	/** 0 for disable signal, 1 for enable signal */
-		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** "sign-offset" is a pair; sign: 1 for positive, 0 for negative */
+		valid_hvsync_de=<0 1>;	/** hvsync_signal_valid, DE_signal_valid : (0=disable signal, 1=enable signal) */
+		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** hsign, hoffset, vsign, voffset :("sign-offset" is a pair. sign: 0 for negative, 1 for positive) */
 		
-		dither_user_ctrl=<0 0x600>;	/** user define dither control, for special condition */
-		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust control */
+		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
+		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en: 1 for enable gamma table, 0 for disable gamma table; gamma_revert: 1 for revert gamma table */
-		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi: 0 for single gamma, means RGB use the same gamma; 1 for multi gamma, means RGB use different gamma */
-		/** gamma_coeff unit: % */
+		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
 				32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
@@ -460,94 +463,94 @@
 				224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
 		
 		/* default settings, don't modify them unless there is display problem */
-		clock_spread_spectrum=<0>;	/** ss_level: 0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5% */
-		clock_auto_generation=<1>;	/** 1 for auto generate clock parameters by lcd_clock, 0 for using customer clock parameters, as clk_pll_div_clk_ctrl defined */
-		clk_pll_div_clk_ctrl=<0x10220 0x18803 0x1111>;	/** only valid when clock_auto=0 */
-		lvds_phy_ctrl=<0xaf40>; /** lvds signals voltage control */
-		lvds_user_repack=<0 0>;	/** user define lvds data mapping, only valid when user=1, for special condition */
-		rgb_base_coeff=<0xf0 0x74a>;	/** rgb base & coeff control */
-		video_on_pixel_line=<80 32>;	/** cpu internal video hold time */
+		clock_spread_spectrum=<0>;	/** ss_level(0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5%) */
+		clock_auto_generation=<1>;	/** clk_auto_generation(0=use customer clock parameters, as clk_pll_div_clk_ctrl defined, 1=auto generate clock parameters by lcd_clock) */
+		clk_pll_div_clk_ctrl=<0x10220 0x18803 0x1111>;	/** pll_ctrl, div_ctrl, clk_ctrl : (only valid when clk_auto_generation=0) */
+		lvds_vswing=<1>;	/** lvds_vswing_level(default level=1, support level 0,1,2,3,4) */
+		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
+		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
+		video_on_pixel_line=<120 32>;	/** video_on_pixel, video_on_line */
 		
 		//lcd power ctrl	//support up to 15 steps for each sequence
-		power_on_uboot="null";	/** only for uboot, ahead of lcd_power_on, no need config delay */
-		power_on_step_1="cpu","GPIOA_27","output_high";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_2="axp202","GPIO3","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_3="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_4="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_5="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_delay=<20 20 200>;	/** power on delay after each step */
-		power_off_step_1="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_2="axp202","GPIO3","input";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_3="cpu","GPIOA_27","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_4="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_5="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_delay=<30 20 100>;	/** power off delay after each step */
-		power_off_uboot="null";	/** only for uboot, at the end of lcd_power_off, no need config delay */
+		power_on_uboot="n","n","n";	/** only for uboot, ahead of lcd_power_on, no need config delay */
+		power_on_step_1="cpu","GPIOA_27","1";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_2="pmu","GPIO3","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_3="signal","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_4="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_5="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_6="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_7="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_8="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_9="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_10="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_11="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_12="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_13="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_14="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_15="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_delay=<20 20 200 0 0 0 0 0 0 0 0 0 0 0 0>;	/** power on delay after each step */
+		power_off_step_1="signal","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_2="pmu","GPIO3","2";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_3="cpu","GPIOA_27","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_4="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_5="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_6="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_7="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_8="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_9="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_10="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_11="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_12="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_13="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_14="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_15="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_delay=<30 20 100 0 0 0 0 0 0 0 0 0 0 0 0>;	/** power off delay after each step */
+		power_off_uboot="n","n","n";	/** only for uboot, at the end of lcd_power_off, no need config delay */
 	};
 
 	lcd_CLAP070NJ02:lcd_CLAP070NJ02{	//g33
 		model_name="CLAP070NJ02";	/** lcd model name */
-		interface="ttl";			/** mipi, lvds, edp, ttl */
-		active_area=<154 86>;		/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
-		lcd_bits_option=<8 1>;		/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		interface="ttl";			/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<154 86>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 		
 		resolution=<1024 600>;	/** horizontal resolution, vertical resolution */
-		period=<1344 635>;		/** horizontal period, vertical period */		
+		period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
 		
-		clock_hz_pol=<42700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
-		hsync_width_backporch=<10 160>;	/** hsync_backporch include hsync_width */
-		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
-		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+		clock_hz_pol=<42700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 160>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 	};
 	
 	lcd_TN070TN92:lcd_TN070TN92{	//800*480
 		model_name="TN070TN92";	/** lcd model name */
-		interface="ttl";	/** mipi, lvds, edp, ttl */
-		active_area=<154 86>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
-		lcd_bits_option=<8 1>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		interface="ttl";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<154 86>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 		
 		resolution=<800 480>;	/** horizontal resolution, vertical resolution */
-		period=<1056 525>;		/** horizontal period, vertical period */		
+		period=<1056 525>;		/** horizontal period(htotal), vertical period(vtotal) */
 		
-		clock_hz_pol=<33300000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
-		hsync_width_backporch=<10 46>;	/** hsync_backporch include hsync_width */
-		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
-		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+		clock_hz_pol=<33300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 46>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 	};
 	
 	lcd_LP097X02:lcd_LP097X02{	//g24
 		model_name="LP097X02";	/** lcd model name */
-		interface="lvds";	/** mipi, lvds, edp, ttl */
-		active_area=<197 147>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
-		lcd_bits_option=<6 0>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<197 147>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<6 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 		
 		resolution=<1024 768>;	/** horizontal resolution, vertical resolution */
-		period=<2084 810>;		/** horizontal period, vertical period */		
+		period=<2084 810>;		/** horizontal period(htotal), vertical period(vtotal) */
 		
-		clock_hz_pol=<85700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
-		hsync_width_backporch=<10 70>;	/** hsync_backporch include hsync_width */
-		vsync_width_backporch=<3 30>;	/** vsync_backporch include vsync_width */
-		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+		clock_hz_pol=<85700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<3 30>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 	};
 		
 	efuse{
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
index 2243e6a70d86..16a15ad02a89 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
@@ -421,23 +421,27 @@
 	backlight{
 		compatible = "amlogic,backlight";
 		dev_name = "backlight";
+		status = "okay";
 		pinctrl-names = "default";
 		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm pinmux */
 		
-		bl_level_default=<102>;	/** default backlight level when enter kernel */
+		bl_level_default_uboot_kernel=<20 128>;	/** default brightness level for uboot & kernel */
+		bl_level_middle_mapping=<102 70>;	/** brightness middle level mapping to a new level*/
+		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
 		
-		//backlight power ctrl
-		bl_ctrl_method="gpio";	/** gpio, pwm_negative, pwm_positive */
+		/* backlight power ctrl */
+		bl_ctrl_method=<0>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. decided by hardware design) */
 		bl_gpio_port="GPIOD_1";	/** backlight control gpio port */
-		bl_gpio_dim_max_min=<0x0 0xf>;	/** backlight brightness diming level for gpio control method, 0x0~0xf, negative logic */
-		bl_pwm_port_gpio_used="PWM_D","0";	/** pwm_gpio_used: 0 for no use gpio; 1 for use bl_gpio_port to enable/disable backlight */
-		bl_pwm_cnt_div=<60000 0>;	/** pwm_cnt<=65536, pwm_cnt=(pwm_high+pwm_low); pwm_freq=24M/pwm_cnt/(pwm_div+1) */
-		bl_pwm_duty_max_min=<100 20>;	/** backlight brightness diminig level for pwm control method, unit: % */
+		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
+		bl_pwm_port_gpio_used="PWM_D","0";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
+		bl_pwm_freq=<400>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<100 20>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
 	};
 	
 	lcd{
 		compatible = "amlogic,lcd";
 		dev_name = "lcd";
+		status = "okay";
 		pinctrl-names = "ttl_6bit_hvsync_de_on","ttl_6bit_hvsync_on","ttl_6bit_de_on","ttl_8bit_hvsync_de_on","ttl_8bit_hvsync_on","ttl_8bit_de_on",
 						"ttl_6bit_hvsync_de_off","ttl_8bit_hvsync_de_off";
 		pinctrl-0 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
@@ -451,24 +455,23 @@
 		
 		lcd_model_name ="lcd_CLAP070NJ02";	/** lcd model name for uboot driver */
 		lcd_model_config = <&lcd_CLAP070NJ02>;	/** choose panel model config */
-		lcd_bits=<6>;	/** 6 or 8, desided by hardware design; only valid when lcd_bits_option=1 */
+		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
 		
 		/* below configs are decided by hardware design, you can modify them if needed. */
 		//ttl config
-		ttl_rb_bit_swap=<0 0>;	/** 0 for normal, 1 for swap */
+		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
 		//lvds config
-		lvds_channel_pn_swap=<0>;	/** 0 for normal, 1 for swap */
+		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
 		
 		/* recommend settings, you can modify them if needed. */
-		valid_hvsync_de=<0 1>;	/** 0 for disable signal, 1 for enable signal */
-		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** "sign-offset" is a pair; sign: 1 for positive, 0 for negative */
+		valid_hvsync_de=<0 1>;	/** hvsync_signal_valid, DE_signal_valid : (0=disable signal, 1=enable signal) */
+		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** hsign, hoffset, vsign, voffset :("sign-offset" is a pair. sign: 0 for negative, 1 for positive) */
 		
-		dither_user_ctrl=<0 0x600>;	/** user define dither control, for special condition */
-		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust control */
+		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
+		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en: 1 for enable gamma table, 0 for disable gamma table; gamma_revert: 1 for revert gamma table */
-		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi: 0 for single gamma, means RGB use the same gamma; 1 for multi gamma, means RGB use different gamma */
-		/** gamma_coeff unit: % */
+		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
 				32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
@@ -480,94 +483,94 @@
 				224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
 		
 		/* default settings, don't modify them unless there is display problem */
-		clock_spread_spectrum=<0>;	/** ss_level: 0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5% */
-		clock_auto_generation=<1>;	/** 1 for auto generate clock parameters by lcd_clock, 0 for using customer clock parameters, as clk_pll_div_clk_ctrl defined */
-		clk_pll_div_clk_ctrl=<0x10220 0x18803 0x1111>;	/** only valid when clock_auto=0 */
-		lvds_phy_ctrl=<0xaf40>; /** lvds signals voltage control */
-		lvds_user_repack=<0 0>;	/** user define lvds data mapping, only valid when user=1, for special condition */
-		rgb_base_coeff=<0xf0 0x74a>;	/** rgb base & coeff control */
-		video_on_pixel_line=<80 32>;	/** cpu internal video hold time */
+		clock_spread_spectrum=<0>;	/** ss_level(0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5%) */
+		clock_auto_generation=<1>;	/** clk_auto_generation(0=use customer clock parameters, as clk_pll_div_clk_ctrl defined, 1=auto generate clock parameters by lcd_clock) */
+		clk_pll_div_clk_ctrl=<0x10220 0x18803 0x1111>;	/** pll_ctrl, div_ctrl, clk_ctrl : (only valid when clk_auto_generation=0) */
+		lvds_vswing=<1>;	/** lvds_vswing_level(default level=1, support level 0,1,2,3,4) */
+		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
+		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
+		video_on_pixel_line=<120 32>;	/** video_on_pixel, video_on_line */
 		
 		//lcd power ctrl	//support up to 15 steps for each sequence
-		power_on_uboot="axp202","GPIO1","output_low";	/** only for uboot, ahead of lcd_power_on, no need config delay */
-		power_on_step_1="cpu","GPIOD_8","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_2="cpu","GPIOA_27","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_3="cpu","GPIOD_8","output_high";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_4="axp202","GPIO3","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_5="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_on_delay=<0 10 20 10 200>;	/** power on delay after each step */
-		power_off_step_1="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_2="axp202","GPIO3","input";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_3="cpu","GPIOD_8","output_low";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_4="cpu","GPIOA_27","input";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_5="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_6="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_7="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_8="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_9="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_10="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_11="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_12="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_13="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_14="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_step_15="null";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
-		power_off_delay=<200 20 10 100>;	/** power off delay after each step */
-		power_off_uboot="axp202","GPIO1","input";	/** only for uboot, at the end of lcd_power_off, no need config delay */
+		power_on_uboot="pmu","GPIO1","0";	/** only for uboot, ahead of lcd_power_on, no need config delay */
+		power_on_step_1="cpu","GPIOD_8","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_2="cpu","GPIOA_27","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_3="cpu","GPIOD_8","1";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_4="pmu","GPIO3","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_5="signal","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_6="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_7="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_8="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_9="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_10="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_11="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_12="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_13="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_14="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_15="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_delay=<0 10 20 10 200 0 0 0 0 0 0 0 0 0 0>;	/** power on delay after each step */
+		power_off_step_1="signal";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_2="pmu","GPIO3","2";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_3="cpu","GPIOD_8","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_4="cpu","GPIOA_27","2";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_5="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_6="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_7="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_8="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_9="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_10="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_11="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_12="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_13="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_14="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_15="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_delay=<200 20 10 100 0 0 0 0 0 0 0 0 0 0 0>;	/** power off delay after each step */
+		power_off_uboot="pmu","GPIO1","2";	/** only for uboot, at the end of lcd_power_off, no need config delay */
 	};
 
 	lcd_CLAP070NJ02:lcd_CLAP070NJ02{	//g33
 		model_name="CLAP070NJ02";	/** lcd model name */
-		interface="ttl";			/** mipi, lvds, edp, ttl */
-		active_area=<154 86>;		/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
-		lcd_bits_option=<8 1>;		/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		interface="ttl";			/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<154 86>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 		
 		resolution=<1024 600>;	/** horizontal resolution, vertical resolution */
-		period=<1344 635>;		/** horizontal period, vertical period */		
+		period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
 		
-		clock_hz_pol=<42700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
-		hsync_width_backporch=<10 160>;	/** hsync_backporch include hsync_width */
-		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
-		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+		clock_hz_pol=<42700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 160>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 	};
 	
 	lcd_TN070TN92:lcd_TN070TN92{	//800*480
 		model_name="TN070TN92";	/** lcd model name */
-		interface="ttl";	/** mipi, lvds, edp, ttl */
-		active_area=<154 86>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
-		lcd_bits_option=<8 1>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		interface="ttl";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<154 86>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 		
 		resolution=<800 480>;	/** horizontal resolution, vertical resolution */
-		period=<1056 525>;		/** horizontal period, vertical period */		
+		period=<1056 525>;		/** horizontal period(htotal), vertical period(vtotal) */
 		
-		clock_hz_pol=<33300000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
-		hsync_width_backporch=<10 46>;	/** hsync_backporch include hsync_width */
-		vsync_width_backporch=<5 23>;	/** vsync_backporch include vsync_width */
-		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+		clock_hz_pol=<33300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 46>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 	};
 	
 	lcd_LP097X02:lcd_LP097X02{	//g24
 		model_name="LP097X02";	/** lcd model name */
-		interface="lvds";	/** mipi, lvds, edp, ttl */
-		active_area=<197 147>;	/** lcd active area (display area) size, unit: mm; you can find it on the home page of lcd spec */
-		lcd_bits_option=<6 0>;	/** option=0, means this lcd don't support 6/8bit switch, only support one bit mode */
+		interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<197 147>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<6 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 		
 		resolution=<1024 768>;	/** horizontal resolution, vertical resolution */
-		period=<2084 810>;		/** horizontal period, vertical period */		
+		period=<2084 810>;		/** horizontal period(htotal), vertical period(vtotal) */
 		
-		clock_hz_pol=<85700000 0>;	/** clock unit: Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate; clk_pol is only valid for TTL */
-		hsync_width_backporch=<10 70>;	/** hsync_backporch include hsync_width */
-		vsync_width_backporch=<3 30>;	/** vsync_backporch include vsync_width */
-		pol_hsync_vsync=<0 0>;	/** 0 for negative, 1 for positive */
+		clock_hz_pol=<85700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<3 30>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 	};
 	
 	efuse{
diff --git a/drivers/amlogic/display/backlight/Kconfig b/drivers/amlogic/display/backlight/Kconfig
index bcdc4b49d7c2..939e7a02cac8 100755
--- a/drivers/amlogic/display/backlight/Kconfig
+++ b/drivers/amlogic/display/backlight/Kconfig
@@ -4,7 +4,7 @@ menu "Amlogic Backlight Support"
 config AMLOGIC_BACKLIGHT
 	bool "Amlogic backlight support"
 	select BACKLIGHT_CLASS_DEVICE
-	default n
+	default y
 	help
 	  Say Y here if you want to use the Amlogic backlight management.
 
diff --git a/drivers/amlogic/display/vout/Kconfig b/drivers/amlogic/display/vout/Kconfig
index d3376ea05b53..bbe5b0646512 100755
--- a/drivers/amlogic/display/vout/Kconfig
+++ b/drivers/amlogic/display/vout/Kconfig
@@ -11,7 +11,7 @@ config AM_TV_OUTPUT
 
 config AM_LCD_OUTPUT
 	tristate "LCD output" 
-	default n
+	default y
 	help  
 		LCD output module
 
diff --git a/drivers/amlogic/display/vout/edp_drv.h b/drivers/amlogic/display/vout/edp_drv.h
index 3654d64c2c0d..9111e0ba2e7c 100755
--- a/drivers/amlogic/display/vout/edp_drv.h
+++ b/drivers/amlogic/display/vout/edp_drv.h
@@ -174,7 +174,7 @@
 #define VAL_EDP_TX_OPERATION_FAILED				0x00FF
 #define VAL_EDP_TX_OPERATION_SUCCESS			0x0000
 //********************************************************//
-
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 typedef enum {
 	EDP_HPD_STATE_DISCONNECTED = 0,
 	EDP_HPD_STATE_CONNECTED,
@@ -245,7 +245,6 @@ typedef struct {
 #define EDP_TX_LINK_CAPACITY_270	2160	//Mbps
 #define EDP_TX_LINK_CAPACITY_540	4320	//Mbps
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 extern int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm);
 extern int dplpm_link_off(void);
 extern void edp_probe(void);
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 94164984ee25..9dabebbd137f 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -653,10 +653,9 @@ static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
 static void set_tcon_lcd(Lcd_Config_t *pConf)
 {
 	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
-	Lcd_Control_Config_t *p = &pConf->lcd_control;
 	unsigned hs_pol, vs_pol;
-	int lcd_type;                                                                                                                                                                                                                                                                                            
-	lcd_type                = pConf->lcd_basic.lcd_type;     
+	int lcd_type;
+	lcd_type = pConf->lcd_basic.lcd_type;
 	DBG_PRINT("%s\n", __FUNCTION__);
 	
 	set_gamma_table_lcd(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pConf->lcd_effect.gamma_r_coeff);
@@ -682,30 +681,30 @@ static void set_tcon_lcd(Lcd_Config_t *pConf)
 	hs_pol = ((pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1);	//0 for low active, 1 for high active
 	vs_pol = ((pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1);	//0 for low active, 1 for high active
 	
-	if(lcd_type==LCD_DIGITAL_MIPI) {                                                                                                              
-			;                                                                                                                                          
-	}                                                                                                                                            
-	else {                                                                                                                                        
+	if(lcd_type==LCD_DIGITAL_MIPI) {
+		;
+	}
+	else {
 		WRITE_LCD_REG(L_POL_CNTL_ADDR,   ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL))); //enable tcon DE, Hsync, Vsync 
-		SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((0 << LCD_DE_POL) | (vs_pol << LCD_VS_POL) | (hs_pol << LCD_HS_POL)));	//adjust hvsync pol                          
-		//DE signal                                                                                                                                  
-		WRITE_LCD_REG(L_DE_HS_ADDR,		tcon_adr->oeh_hs_addr);                                                                                        
-		WRITE_LCD_REG(L_DE_HE_ADDR,		tcon_adr->oeh_he_addr);                                                                                        
-		WRITE_LCD_REG(L_DE_VS_ADDR,		tcon_adr->oeh_vs_addr);                                                                                        
-		WRITE_LCD_REG(L_DE_VE_ADDR,		tcon_adr->oeh_ve_addr);                                                                                        
-		                                                                                                                                             
-		//Hsync signal                                                                                                                               
-		WRITE_LCD_REG(L_HSYNC_HS_ADDR,	tcon_adr->sth1_hs_addr);                                                                                     
-		WRITE_LCD_REG(L_HSYNC_HE_ADDR,	tcon_adr->sth1_he_addr);                                                                                     
-		WRITE_LCD_REG(L_HSYNC_VS_ADDR,	tcon_adr->sth1_vs_addr);                                                                                     
-		WRITE_LCD_REG(L_HSYNC_VE_ADDR,	tcon_adr->sth1_ve_addr);                                                                                     
-		                                                                                                                                             
-		//Vsync signal                                                                                                                               
-		WRITE_LCD_REG(L_VSYNC_HS_ADDR,	tcon_adr->stv1_hs_addr);                                                                                     
-		WRITE_LCD_REG(L_VSYNC_HE_ADDR,	tcon_adr->stv1_he_addr);                                                                                     
-		WRITE_LCD_REG(L_VSYNC_VS_ADDR,	tcon_adr->stv1_vs_addr);                                                                                     
-		WRITE_LCD_REG(L_VSYNC_VE_ADDR,	tcon_adr->stv1_ve_addr);                                                                                     
-	}                        
+		SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((0 << LCD_DE_POL) | (vs_pol << LCD_VS_POL) | (hs_pol << LCD_HS_POL)));	//adjust hvsync pol
+		//DE signal
+		WRITE_LCD_REG(L_DE_HS_ADDR,		tcon_adr->oeh_hs_addr);
+		WRITE_LCD_REG(L_DE_HE_ADDR,		tcon_adr->oeh_he_addr);
+		WRITE_LCD_REG(L_DE_VS_ADDR,		tcon_adr->oeh_vs_addr);
+		WRITE_LCD_REG(L_DE_VE_ADDR,		tcon_adr->oeh_ve_addr);
+	
+		//Hsync signal
+		WRITE_LCD_REG(L_HSYNC_HS_ADDR,	tcon_adr->sth1_hs_addr);
+		WRITE_LCD_REG(L_HSYNC_HE_ADDR,	tcon_adr->sth1_he_addr);
+		WRITE_LCD_REG(L_HSYNC_VS_ADDR,	tcon_adr->sth1_vs_addr);
+		WRITE_LCD_REG(L_HSYNC_VE_ADDR,	tcon_adr->sth1_ve_addr);
+	
+		//Vsync signal
+		WRITE_LCD_REG(L_VSYNC_HS_ADDR,	tcon_adr->stv1_hs_addr);
+		WRITE_LCD_REG(L_VSYNC_HE_ADDR,	tcon_adr->stv1_he_addr);
+		WRITE_LCD_REG(L_VSYNC_VS_ADDR,	tcon_adr->stv1_vs_addr);
+		WRITE_LCD_REG(L_VSYNC_VE_ADDR,	tcon_adr->stv1_ve_addr);
+	}
 
 	if(vpp2_sel)
 		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
@@ -1076,7 +1075,9 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 	unsigned pll_level = 0, pll_frac = 0;
 	int wait_loop = PLL_WAIT_LOCK_CNT;
 	unsigned pll_lock = 0;
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	unsigned tmp;
+#endif
 	unsigned long flags = 0;
 	spin_lock_irqsave(&lcd_clk_lock, flags);
 	
@@ -1320,19 +1321,21 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 	lcd_type = pConf->lcd_basic.lcd_type;
 	
 	switch(lcd_type){
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_MIPI:
-      ss_level = (((clk_reg >> CLK_CTRL_SS) & 0xf) > 0 ? 1 : 0);
+			ss_level = (((clk_reg >> CLK_CTRL_SS) & 0xf) > 0 ? 1 : 0);
 			break;
+		case LCD_DIGITAL_EDP:
+			ss_level = ((ss_level > 0) ? 1 : 0);
+			xd = 1;
+			break;
+#endif
 		case LCD_DIGITAL_LVDS:
 			xd = 1;
 			pll_div_post = 7;
 			phy_clk_div2 = 0;
 			div_reg = (div_reg | (1 << 8) | (1 << 11) | ((pll_div_post-1) << 12) | (phy_clk_div2 << 10));
 			break;
-		case LCD_DIGITAL_EDP:
-			ss_level = ((ss_level > 0) ? 1 : 0);
-			xd = 1;
-			break;
 		case LCD_DIGITAL_TTL:
 			break;
 		default:
@@ -1344,6 +1347,7 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 	set_lcd_spread_spectrum(ss_level);
 	
 	switch(lcd_type){
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_MIPI:
         WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4))   |
                           (1  << 4)               |
@@ -1354,6 +1358,9 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
         WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
         WRITE_LCD_REG( MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock                   
 			break;
+		case LCD_DIGITAL_EDP:
+			break;
+#endif
 		case LCD_DIGITAL_LVDS:
 			clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
 			//    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
@@ -1368,8 +1375,6 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 			udelay(5);
 			WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
 			break;
-		case LCD_DIGITAL_EDP:
-			break;
 		case LCD_DIGITAL_TTL:
 			break;
 		default:
@@ -1684,9 +1689,10 @@ static void set_venc_mlvds(Lcd_Config_t *pConf)
 
 static void set_venc_lcd(Lcd_Config_t *pConf)
 {
-	DBG_PRINT("%s\n",__FUNCTION__);
 	int lcd_type;
-	lcd_type = pConf->lcd_basic.lcd_type; 
+	lcd_type = pConf->lcd_basic.lcd_type;
+	
+	DBG_PRINT("%s\n",__FUNCTION__);
 	
 	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
 #ifdef CONFIG_AM_TV_OUTPUT2
@@ -2149,16 +2155,20 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
 	unsigned edp_phy_div0 = 0, edp_phy_div1 = 0, vid_div_pre = 0;
 	unsigned crt_xd = 0;
 
-	unsigned m, n, od, od_fb=0, edp_div0, edp_div1, div_pre, div_post, xd;
-	unsigned od_sel, edp_div0_sel, edp_div1_sel, pre_div_sel;
+	unsigned m, n, od, div_pre, div_post, xd;
+	unsigned od_sel, pre_div_sel;
 	unsigned div_pre_sel_max, crt_xd_max;
-	unsigned f_ref, pll_vco, fout_pll, edp_tx_phy_out, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;	
+	unsigned f_ref, pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
 	unsigned min_error = MAX_ERROR;
 	unsigned error = MAX_ERROR;
 	unsigned clk_num = 0;
 	unsigned tmp;
-        unsigned int    dsi_clk_div=0, dsi_clk_max=0, dsi_clk_min=0;
-	
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+	unsigned od_fb=0, edp_div0, edp_div1;
+	unsigned edp_div0_sel, edp_div1_sel;
+	unsigned edp_tx_phy_out;
+	unsigned int dsi_clk_div=0, dsi_clk_max=0, dsi_clk_min=0;
+#endif
 	unsigned fin = FIN_FREQ;
 	unsigned fout = pConf->lcd_timing.lcd_clk;
 	
@@ -2846,11 +2856,11 @@ static void _init_lcd_driver(Lcd_Config_t *pConf)	//before power on lcd
 	switch(lcd_type){
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_MIPI:
-      set_pll_lcd(pConf);
-      init_dphy(pConf); //analog
-      set_control_mipi(pConf); //2step
-      set_venc_lcd(pConf);
-      set_tcon_lcd(pConf);
+			set_pll_lcd(pConf);
+			init_dphy(pConf); //analog
+			set_control_mipi(pConf); //2step
+			set_venc_lcd(pConf);
+			set_tcon_lcd(pConf);
 			break;
 		case LCD_DIGITAL_EDP:
 			set_pll_lcd(pConf);
@@ -3064,11 +3074,13 @@ static int lcd_set_current_vmode(vmode_t mode)
 	WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
 
 	if( !(mode&VMODE_LOGO_BIT_MASK) ){
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
+#endif
 		_lcd_module_enable();
 	}
 	if (VMODE_INIT_NULL == pDev->lcd_info.mode)
-        	pDev->lcd_info.mode = VMODE_LCD;
+		pDev->lcd_info.mode = VMODE_LCD;
 	_enable_backlight();
 	mutex_unlock(&lcd_vout_mutex);
 	return 0;
@@ -3086,7 +3098,9 @@ static int lcd_set_current_vmode2(vmode_t mode)
 
     WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
 	
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
+#endif
     _lcd_module_enable();
     if (VMODE_INIT_NULL == pDev->lcd_info.mode)
         pDev->lcd_info.mode = VMODE_LCD;
@@ -3116,7 +3130,9 @@ static int lcd_vout_disable(vmode_t cur_vmod)
 	mutex_lock(&lcd_vout_mutex);
 	_disable_backlight();
 	_lcd_module_disable();
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	release_vpu_clk_vmod(pDev->lcd_info.mode);
+#endif
 	mutex_unlock(&lcd_vout_mutex);
 	return 0;
 }
@@ -3200,7 +3216,9 @@ static void _lcd_init(Lcd_Config_t *pConf)
 {
 	//logo_object_t  *init_logo_obj=NULL;
 	_init_vout(pDev);
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
+#endif
 	//init_logo_obj = get_current_logo_obj();    
 	//if(NULL==init_logo_obj ||!init_logo_obj->para.loaded)
 		//_lcd_module_enable();
@@ -3208,7 +3226,7 @@ static void _lcd_init(Lcd_Config_t *pConf)
 
 static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
  {
-	printk("[%s]: %u\n", __FUNCTION__, state);
+	printk("[%s]: %lu\n", __FUNCTION__, state);
 	_disable_backlight();
 	_lcd_module_disable();
 
@@ -3435,8 +3453,8 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
         if (buf[1] == 'r') {
             ret = sscanf(buf, "fr %u", &i);
             i &= 0xff;
-            for (i=0; i<256; i++) {
-                pDev->pConf->lcd_effect.GammaTableR[i] = i<<2;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
             }
 			set_gamma_coeff(100, 0, 0);
             printk("with R fixed value %u finished.\n", i);
@@ -3444,8 +3462,8 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
         else if (buf[1] == 'g') {
             ret = sscanf(buf, "fg %u", &i);
             i &= 0xff; 
-            for (i=0; i<256; i++) {
-                pDev->pConf->lcd_effect.GammaTableG[i] = i<<2;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
             }
             set_gamma_coeff(0, 100, 0);
             printk("with G fixed value %u finished.\n", i);
@@ -3453,8 +3471,8 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
         else if (buf[1] == 'b') {
             ret = sscanf(buf, "fb %u", &i);
             i &= 0xff;
-            for (i=0; i<256; i++) {
-                pDev->pConf->lcd_effect.GammaTableB[i] = i<<2;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
             }
             set_gamma_coeff(0, 0, 100);
             printk("with B fixed value %u finished.\n", i);
@@ -3462,10 +3480,10 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
         else {
             ret = sscanf(buf, "fw %u", &i);
             i &= 0xff;
-            for (i=0; i<256; i++) {
-                pDev->pConf->lcd_effect.GammaTableR[i] = i<<2;
-                pDev->pConf->lcd_effect.GammaTableG[i] = i<<2;
-                pDev->pConf->lcd_effect.GammaTableB[i] = i<<2;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
+                pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
+                pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
             }
             set_gamma_coeff(100, 100, 100);
             printk("with fixed value %u finished.\n", i);
@@ -4140,6 +4158,7 @@ static inline int _get_lcd_model_timing(struct platform_device *pdev)
 		}
 		DBG_PRINT("pol hsync = %u, vsync = %u\n", (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1, (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1);
 /////////////////////////////////////
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		if (LCD_DIGITAL_MIPI == pDev->pConf->lcd_basic.lcd_type) {
 
         DSI_Config_t *cfg = pDev->pConf->lcd_control.mipi_config;
@@ -4172,7 +4191,8 @@ static inline int _get_lcd_model_timing(struct platform_device *pdev)
         }
         DBG_PRINT("denominator= %d, numerator=%d\n",  cfg->denominator, cfg->numerator);
 
-     }
+                }
+#endif
 /////////////////////////////////////
    }
 	return ret;
diff --git a/drivers/amlogic/display/vout/mipi_dsi_util.c b/drivers/amlogic/display/vout/mipi_dsi_util.c
index 6edfb63294f4..c2a24b2f341c 100755
--- a/drivers/amlogic/display/vout/mipi_dsi_util.c
+++ b/drivers/amlogic/display/vout/mipi_dsi_util.c
@@ -1,8 +1,8 @@
 #include <linux/types.h>
 #include <mach/cpu.h>
 #include <plat/cpu.h>
-#include <linux/amlogic/vout/lcdoutc.h>
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+#include <linux/amlogic/vout/lcdoutc.h>
 #include <linux/kernel.h>
 #include "mipi_dsi_util.h"
 #include "mipi_dsi_phy_reg.h"
@@ -13,6 +13,13 @@
 #include <plat/io.h>
 #include <linux/delay.h>
 
+//#define PRINT_DEBUG_INFO
+#ifdef PRINT_DEBUG_INFO
+#define DPRINT(...)		printk(__VA_ARGS__)
+#else
+#define DPRINT(...)
+#endif
+
 #ifndef VPP_OUT_SATURATE
 #define VPP_OUT_SATURATE            (1 << 0)
 #endif
@@ -1413,18 +1420,5 @@ U_BOOT_CMD(
 	  );
 //****************************************
 #endif
-#else
-void lcd_ports_ctrl_mipi(Lcd_Config_t *p, Bool_t status){}
-
-void set_pll_mipi(Lcd_Config_t *p){}
-
-void set_control_mipi(Lcd_Config_t *p){}
-
-void set_venc_mipi(Lcd_Config_t *pConf){}
-
-void set_tcon_mipi(Lcd_Config_t *p){}
-
-void init_phy_mipi(Lcd_Config_t *pConf){}
 
-void dsi_probe( Lcd_Config_t *pConf){}
 #endif
diff --git a/drivers/amlogic/display/vout/mipi_dsi_util.h b/drivers/amlogic/display/vout/mipi_dsi_util.h
index 012d8c59363b..65c4b64377ad 100755
--- a/drivers/amlogic/display/vout/mipi_dsi_util.h
+++ b/drivers/amlogic/display/vout/mipi_dsi_util.h
@@ -3,18 +3,12 @@
 
 //#include <asm/arch/register.h>
 #include <mach/register.h>
-
+#include <mach/cpu.h>
 #include "mipi_dsi_phy_reg.h"
 #include <linux/amlogic/vout/lcdoutc.h>
 //#include <asm/arch/lcdoutc.h>
 
-//#define PRINT_DEBUG_INFO
-#ifdef PRINT_DEBUG_INFO
-#define DPRINT(...)		printk(__VA_ARGS__)
-#else
-#define DPRINT(...)
-#endif
-
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 // --------------------------------------------------------
 // MIPI DSI Data Type/ MIPI DCS Command Type Definitions
 // --------------------------------------------------------
@@ -567,12 +561,12 @@ int set_lcd_clk(unsigned int display_w, unsigned int display_h,
                 */
 void init_mipi_dsi_phy(Lcd_Config_t *pConf);
 
-extern void start_mipi_dsi_host();                                             // close the default reset
+extern void start_mipi_dsi_host(void);                                             // close the default reset
 
-extern void powerup_mipi_dsi_dphy();                                           // power up mipi_dsi and dphy
-extern void powerdown_mipi_dsi_dphy();                                         // power down mipi_dsi and dphy
+extern void powerup_mipi_dsi_dphy(void);                                           // power up mipi_dsi and dphy
+extern void powerdown_mipi_dsi_dphy(void);                                         // power down mipi_dsi and dphy
 
-extern void set_mipi_int();                                                    // configure mipi interrupt registers
+extern void set_mipi_int(void);                                                    // configure mipi interrupt registers
 extern void set_mipi_dcs(int trans_type,                                       // 0: high speed, 1: low power
                 int ack_req,                                          // 1: request ack, 0: do not need ack
                 int tear_en                                           // 1: enable tear ack, 0: disable tear ack
@@ -589,16 +583,16 @@ extern void set_mipi_edpi(unsigned int edpi_allowed_cmd_size,                  /
                 unsigned int color_code                              // color code
                 );
 
-extern void check_phy_st();                                                    // Check the status of the dphy: phylock and stopstateclklane
+extern void check_phy_st(void);                                                    // Check the status of the dphy: phylock and stopstateclklane
 
 extern void delay_us(int us);
 extern void config_video_para(tv_enc_lcd_type_t output_type,
                 unsigned int    color_code,                   // Configure video parameter such HFP/HSA/HBP/HACT...
                 Lcd_Config_t    *pConf);
 
-extern void wait_bta_ack();                                                    // wait ack from bta
-extern void wait_cmd_fifo_empty();                                             // wait generic fifo empty
-extern unsigned int wait_for_generic_read_response();                          // wait read response
+extern void wait_bta_ack(void);                                                    // wait ack from bta
+extern void wait_cmd_fifo_empty(void);                                             // wait generic fifo empty
+extern unsigned int wait_for_generic_read_response(void);                          // wait read response
 
 extern unsigned int generic_if_wr(unsigned int address, unsigned int data_in); // Generic Interface Write
 extern unsigned int generic_if_rd(unsigned int address);                       // Generic Interface Read
@@ -632,9 +626,9 @@ extern void DCS_long_write_packet(unsigned int data_type,                      /
 
 extern void check_mipi_dsi_color_config (unsigned int venc_color_type, unsigned int dpi_color_type);
 
-void startup_mipi_dsi_host();
+void startup_mipi_dsi_host(void);
 
-extern void auo_panel_init();
+extern void auo_panel_init(void);
 
 // DCS COMMAND LIST
 #define DCS_CMD_CODE_ENTER_IDLE_MODE      0x0
@@ -678,5 +672,5 @@ void dsi_probe(Lcd_Config_t *pConf);
 //****************************************************************************************************/
 //      from test_prm.h
 //****************************************************************************************************/
-
+#endif
 #endif
-- 
2.19.0

