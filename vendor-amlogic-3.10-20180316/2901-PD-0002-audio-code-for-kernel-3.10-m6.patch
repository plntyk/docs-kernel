From ab53a5c96ac96eb7b0c8e5d8b84c95de4aeb734d Mon Sep 17 00:00:00 2001
From: "chengshun.wang" <chengshun.wang@amlogic.com>
Date: Mon, 16 Dec 2013 14:14:30 +0800
Subject: [PATCH 2901/5965] PD #0002 : audio code for kernel 3.10 + m6

Conflicts:

	arch/arm/configs/meson8_defconfig
	sound/soc/aml/Kconfig
	sound/soc/aml/Makefile
	sound/soc/aml/aml_audio_hw.c
	sound/soc/aml/aml_audio_hw.h
	sound/soc/aml/aml_i2s.c
	sound/soc/aml/aml_i2s_dai.c
	sound/soc/aml/aml_m8.c
	sound/soc/aml/aml_spdif_dai.c

Conflicts:

	sound/soc/aml/aml_i2s_dai.c
---
 arch/arm/boot/dts/amlogic/meson6_g18.dtd    |  116 +-
 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd |   87 +-
 arch/arm/configs/meson6_defconfig           |    3 +
 include/sound/wm8960.h                      |   16 +
 sound/soc/aml/Kconfig                       |  132 +-
 sound/soc/aml/Makefile                      |   98 +-
 sound/soc/aml/aml.dtd                       |   59 -
 sound/soc/aml/aml_alsa_common.h             |   12 -
 sound/soc/aml/aml_audio_hw.c                | 1287 ---------------
 sound/soc/aml/aml_audio_hw.h                |  158 --
 sound/soc/aml/aml_audio_hw_pcm2bt.c         |  314 ----
 sound/soc/aml/aml_audio_hw_pcm2bt.h         |   21 -
 sound/soc/aml/aml_i2s.c                     | 1140 -------------
 sound/soc/aml/aml_i2s.h                     |   77 -
 sound/soc/aml/aml_i2s_dai.c                 |  389 -----
 sound/soc/aml/aml_i2s_dai.h                 |    6 -
 sound/soc/aml/aml_m1.c                      |  156 --
 sound/soc/aml/aml_m1_armdev_wm8900.c        |  446 -----
 sound/soc/aml/aml_m1_codec.c                |  509 ------
 sound/soc/aml/aml_m1_codec.h                |    7 -
 sound/soc/aml/aml_m1_mid_cs42l52.c          |  340 ----
 sound/soc/aml/aml_m1_mid_rt5621.c           |  351 ----
 sound/soc/aml/aml_m1_mid_wm8900.c           |  338 ----
 sound/soc/aml/aml_m3.c                      |  352 ----
 sound/soc/aml/aml_m3_codec.c                |  970 -----------
 sound/soc/aml/aml_m3_codec.h                |    7 -
 sound/soc/aml/aml_m6_rt3261.c               |  651 --------
 sound/soc/aml/aml_m6_rt5631.c               |  536 ------
 sound/soc/aml/aml_m6_wm8960.c               |  624 -------
 sound/soc/aml/aml_m6tv_audio.c              |  338 ----
 sound/soc/aml/aml_m8.c                      |  694 --------
 sound/soc/aml/aml_m_dummy.c                 |  360 ----
 sound/soc/aml/aml_mixer.c                   |  371 -----
 sound/soc/aml/aml_notify.c                  |   43 -
 sound/soc/aml/aml_pcm.c                     |  698 --------
 sound/soc/aml/aml_pcm.h                     |   23 -
 sound/soc/aml/aml_pcm_dai.c                 |  268 ---
 sound/soc/aml/aml_pcm_dai.h                 |    6 -
 sound/soc/aml/aml_spdif_codec.c             |  101 --
 sound/soc/aml/aml_spdif_dai.c               |  457 ------
 sound/soc/aml/aml_spdif_dai.h               |   16 -
 sound/soc/aml/aml_syno9629_codec.c          | 1213 --------------
 sound/soc/aml/aml_syno9629_codec.h          |  215 ---
 sound/soc/codecs/rt5631.c                   |  142 +-
 sound/soc/codecs/rt5631.h                   |    4 +
 sound/soc/codecs/wm8960.c                   | 1643 ++++++++++---------
 46 files changed, 1104 insertions(+), 14690 deletions(-)
 delete mode 100755 sound/soc/aml/aml.dtd
 delete mode 100644 sound/soc/aml/aml_alsa_common.h
 delete mode 100755 sound/soc/aml/aml_audio_hw.c
 delete mode 100755 sound/soc/aml/aml_audio_hw.h
 delete mode 100755 sound/soc/aml/aml_audio_hw_pcm2bt.c
 delete mode 100755 sound/soc/aml/aml_audio_hw_pcm2bt.h
 delete mode 100755 sound/soc/aml/aml_i2s.c
 delete mode 100755 sound/soc/aml/aml_i2s.h
 delete mode 100755 sound/soc/aml/aml_i2s_dai.c
 delete mode 100755 sound/soc/aml/aml_i2s_dai.h
 delete mode 100644 sound/soc/aml/aml_m1.c
 delete mode 100644 sound/soc/aml/aml_m1_armdev_wm8900.c
 delete mode 100644 sound/soc/aml/aml_m1_codec.c
 delete mode 100644 sound/soc/aml/aml_m1_codec.h
 delete mode 100644 sound/soc/aml/aml_m1_mid_cs42l52.c
 delete mode 100644 sound/soc/aml/aml_m1_mid_rt5621.c
 delete mode 100644 sound/soc/aml/aml_m1_mid_wm8900.c
 delete mode 100644 sound/soc/aml/aml_m3.c
 delete mode 100644 sound/soc/aml/aml_m3_codec.c
 delete mode 100644 sound/soc/aml/aml_m3_codec.h
 delete mode 100755 sound/soc/aml/aml_m6_rt3261.c
 delete mode 100755 sound/soc/aml/aml_m6_rt5631.c
 delete mode 100644 sound/soc/aml/aml_m6_wm8960.c
 delete mode 100644 sound/soc/aml/aml_m6tv_audio.c
 delete mode 100755 sound/soc/aml/aml_m8.c
 delete mode 100755 sound/soc/aml/aml_m_dummy.c
 delete mode 100644 sound/soc/aml/aml_mixer.c
 delete mode 100644 sound/soc/aml/aml_notify.c
 delete mode 100755 sound/soc/aml/aml_pcm.c
 delete mode 100755 sound/soc/aml/aml_pcm.h
 delete mode 100755 sound/soc/aml/aml_pcm_dai.c
 delete mode 100755 sound/soc/aml/aml_pcm_dai.h
 delete mode 100755 sound/soc/aml/aml_spdif_codec.c
 delete mode 100755 sound/soc/aml/aml_spdif_dai.c
 delete mode 100755 sound/soc/aml/aml_spdif_dai.h
 delete mode 100644 sound/soc/aml/aml_syno9629_codec.c
 delete mode 100644 sound/soc/aml/aml_syno9629_codec.h

diff --git a/arch/arm/boot/dts/amlogic/meson6_g18.dtd b/arch/arm/boot/dts/amlogic/meson6_g18.dtd
index 670d90927614..e897a8eba475 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g18.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g18.dtd
@@ -452,115 +452,17 @@
 		pinctrl-0=<&remote_pins>;
 	};
 	
-	/// ***************************************************************************************
-/// -   Audio
-//$$ MODULE="Audio"
-//$$ DEVICE="audio_i2s"
-//$$ L2 PROP_STR = "status"
-    audio_platform{
-        compatible = "amlogic,aml-i2s";
-        dev_name = "aml-i2s.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_i2s_dai"
-//$$ L2 PROP_STR = "status"
-    audio_dai{
-        compatible = "amlogic,aml-i2s-dai";
-        dev_name = "aml-i2s-dai.0";
-        status = "okay";
-    };
-    audio_spdif_dai{
-        compatible = "amlogic,aml-spdif-dai";
-        dev_name = "aml-spdif-dai.0";
-        status = "okay";
-    };
-
-audio_spdif_codec{
-        compatible = "amlogic,aml-spdif-codec";
-        dev_name = "spdif-dit.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_pcm2BT_codec"
-//$$ L2 PROP_STR = "status"
-    audio_pcm2BT_codec{
-        compatible = "amlogic,pcm2BT-codec";
-        dev_name = "pcm2bt.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_pcm_dai"
-//$$ L2 PROP_STR = "status"
-    audio_pcm_dai{
-        compatible = "amlogic,aml-pcm-dai";
-        dev_name = "aml-pcm-dai.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_pcm"
-//$$ L2 PROP_STR = "status"
-    audio_pcm{
-        compatible = "amlogic,aml-pcm";
-        dev_name = "aml-pcm.0";
-        status = "okay";
-    };
-    
-    wm8960_sound_card{
-        compatible = "sound_card,wm8960";
-        aml,sound_card = "AML-WM8960";
-        //aml,audio-codec = <&wm8960>;
-        aml,codec_dai = "wm8960-hifi";
-        aml,audio-routing =
-            "Ext Spk","SPK_LP",
-            "Ext Spk","SPK_LN",
-            "Ext Spk","SPK_RP",
-            "Ext Spk","SPK_RN",
-            "HP","HP_L",
-            "HP","HP_R",
-            "MICB","Mic",
-            "LINPUT1","MICB",
-            "LINPUT2","MICB",
-            "RINPUT1","MICB",
-            "RINPUT2","MICB";
-            
-        capless = <1>; 
-        dres = <2>; /*WM8960_DRES_600R*/
-        dis_hp_det = <0>;
-        pinctrl-names = "wm8960_audio";
-        pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
-        wm8960_gpio = "GPIOA_19";
-        hp_det_inv;
-        status = "disabled";
-        
-    };
+	audio{
+		compatible = "amlogic,aml-audio";
+		dev_name = "aml-audio.0";
+	};
 
-    rt5631_sound_card{
-        compatible = "sound_card,rt5631";
-        aml,sound_card = "AML-RT5631";
-        //aml,audio-codec = <&rt5631>;
-        aml,codec_dai = "rt5631-hifi";
-        aml,audio-routing =
-            "Ext Spk", "SPOL",
-            "Ext Spk","SPOR",
-            "HP","HPOL",
-            "HP","HPOR",
-            "MIC1","MIC Bias1",
-            "MIC Bias1","MAIN MIC";
-        
-        /*dev_name = "aml_sound_card";*/
-        /*reg = <0 0>;*/
-        capless = <0>;
-        spk_watt = <0>;     /*RT5631_SPK_1_0W*/
-        spk_output = <2>;   /*RT5631_SPK_RIGHT*/
-        mic_input = <0>;    /*RT5631_MIC_DIFFERENTIAL*/
-        pinctrl-names = "rt5631_audio";
-        pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
-        rt5631_gpio = "GPIOA_19";
-        hp_det_inv;
-        status = "disabled";
-    };
+	audio_dai{
+		compatible = "amlogic,aml-dai";
+		dev_name = "aml-dai.0";
+	};
 
+	
 	dummy_codec_audio{
         status = "okay";
         compatible = "amlogic,aml_dummy_codec_audio";
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
index 1c9d8603eb49..383ff2a3e928 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
@@ -745,60 +745,34 @@
 		pinctrl-0=<&remote_pins>;
 	};
 
-/// ***************************************************************************************
-/// -   Audio
-//$$ MODULE="Audio"
-//$$ DEVICE="audio_i2s"
-//$$ L2 PROP_STR = "status"
+    aml_audio_codc{
+        compatible = "amlogic,audio_codec";
+        codec_rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <0>;
+            status = "disabled";    
+        };  
+        codec_wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+            status = "okay";
+        };
+    };
+    
     audio_platform{
-        compatible = "amlogic,aml-i2s";
-        dev_name = "aml-i2s.0";
-        status = "okay";
+        compatible = "amlogic,aml-audio";
+        dev_name = "aml-audio.0";
     };
 
-//$$ DEVICE="audio_i2s_dai"
-//$$ L2 PROP_STR = "status"
     audio_dai{
-        compatible = "amlogic,aml-i2s-dai";
-        dev_name = "aml-i2s-dai.0";
-        status = "okay";
-    };
-    audio_spdif_dai{
-        compatible = "amlogic,aml-spdif-dai";
-        dev_name = "aml-spdif-dai.0";
-        status = "okay";
+        compatible = "amlogic,aml-dai";
+        dev_name = "aml-dai.0";
     };
 
-audio_spdif_codec{
-        compatible = "amlogic,aml-spdif-codec";
-        dev_name = "spdif-dit.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_pcm2BT_codec"
-//$$ L2 PROP_STR = "status"
-    audio_pcm2BT_codec{
-        compatible = "amlogic,pcm2BT-codec";
-        dev_name = "pcm2bt.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_pcm_dai"
-//$$ L2 PROP_STR = "status"
-    audio_pcm_dai{
-        compatible = "amlogic,aml-pcm-dai";
-        dev_name = "aml-pcm-dai.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_pcm"
-//$$ L2 PROP_STR = "status"
-    audio_pcm{
-        compatible = "amlogic,aml-pcm";
-        dev_name = "aml-pcm.0";
-        status = "okay";
-    };
-    
     wm8960_sound_card{
         compatible = "sound_card,wm8960";
         aml,sound_card = "AML-WM8960";
@@ -824,8 +798,7 @@ audio_spdif_codec{
         pinctrl-0 = <&aml_i2s_pins &config_aml_hp_det_pins>;
         wm8960_gpio = "GPIOA_19";
         hp_det_inv;
-        status = "disabled";
-        
+        status = "okay";
     };
 
     rt5631_sound_card{
@@ -853,20 +826,6 @@ audio_spdif_codec{
         hp_det_inv;
         status = "disabled";
     };
-
-	dummy_codec_audio{
-        status = "okay";
-        compatible = "amlogic,aml_dummy_codec_audio";
-        dev_name = "aml_dummy_codec_audio.0";
-        pinctrl-names = "dummy_codec_audio";
-        pinctrl-0 = <&aml_dummy_codec_pins>;
-    };
-    
-    dummy_codec{
-        status = "okay";
-        compatible = "amlogic,aml_dummy_codec";
-        dev_name = "dummy_codec.0";
-    };
     
     touch{
         compatible = "amlogic,aml_touch";
diff --git a/arch/arm/configs/meson6_defconfig b/arch/arm/configs/meson6_defconfig
index 81f10abce646..af95ce042a20 100755
--- a/arch/arm/configs/meson6_defconfig
+++ b/arch/arm/configs/meson6_defconfig
@@ -219,7 +219,10 @@ CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_SOC=y
 CONFIG_SND_AML_SOC=y
+CONFIG_SND_AML_M6_SOC=y
 CONFIG_SND_AML_M_DUMMY_CODEC=y
+CONFIG_SND_AML_M6_WM8960=y
+CONFIG_SND_AML_M6_RT5631=y
 CONFIG_UHID=y
 CONFIG_USB=y
 CONFIG_USB_ACM=y
diff --git a/include/sound/wm8960.h b/include/sound/wm8960.h
index e8ce8ee7d62d..8a7d16fdf208 100644
--- a/include/sound/wm8960.h
+++ b/include/sound/wm8960.h
@@ -19,6 +19,22 @@ struct wm8960_data {
 	bool capless;  /* Headphone outputs configured in capless mode */
 
 	bool shared_lrclk;  /* DAC and ADC LRCLKs are wired together */
+    /* Disable Headphone detect through codec*/
+	bool dis_hp_det; 
+	/* Headphone detect polarity, only be useful when hp_jack_det=1
+	* 0----High = Speaker; 1---High = Headphone;
+	*/
+	bool hp_det_pol;
+	/* Discharge resistance for headphone outputs */
+	int dres;
+	/* return value:
+	* 0::no headphone plugged;
+	* 1::three ports headphone plugged with no mic;
+	* 2::four ports headphone plugged with mic
+	*/
+    int (*hp_detect)(void);
+    void (*device_init)(void);
+    void (*device_uninit)(void);
 };
 
 #endif
diff --git a/sound/soc/aml/Kconfig b/sound/soc/aml/Kconfig
index f8a3b5c22f8c..bed2423b3223 100755
--- a/sound/soc/aml/Kconfig
+++ b/sound/soc/aml/Kconfig
@@ -1,128 +1,28 @@
-config SND_AML_SOC
-	tristate "Audio for Amlogic Meson SoC"
+menuconfig SND_AML_M6_SOC
+	tristate "Audio for Amlogic Meson6 SoC"
 	depends on PLAT_MESON
 	help
 	  Say Y or M if you want to add support for codecs attached to
 	  the Amlogic I2S interface. You will also need
 	  to select the audio interfaces to support below.
 
-config SND_AML_M1
-	tristate "M1 evaluation board with internel audio dac"
-	depends on SND_AML_SOC
-	depends on ARCH_MESON1
-
-config SND_AML_M1_MID_WM8900
-	tristate "AML6236 MID board with WM8900"
-	depends on SND_AML_SOC
-        select SND_SOC_WM8900 if SND_AML_M1_MID_WM8900
-
-config SND_AML_M1_ARMDEV_WM8900
-	tristate "AML8726M ARM Dev board with WM8900"
-	depends on SND_AML_SOC
-	select SND_SOC_WM8900 if SND_AML_M1_ARMDEV_WM8900
-
-config SND_AML_M1_MID_RT5621
-	tristate "AML8726M MID board with RT5621"
-	depends on SND_AML_SOC
-	select SND_SOC_RT5621 if SND_AML_M1_MID_RT5621
+menuconfig SND_AML_M8_SOC
+	tristate "Audio for Amlogic Meson8 SoC"
+	depends on PLAT_MESON
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the Amlogic I2S interface. You will also need
+	  to select the audio interfaces to support below.
 
-config SND_AML_M2
-	tristate "M2 evaluation board with internal audio codec"
-	depends on SND_AML_SOC
-	depends on ARCH_MESON2
+if SND_AML_M6_SOC
 
-config SND_AML_M3
-	tristate "M3 evaluation board with internal audio codec"
-	depends on SND_AML_SOC
-	depends on ARCH_MESON3
+# for Amlogic m6 SoC
+source "sound/soc/aml/m6/Kconfig"
 
-config SND_AML_M6_RT5631
-	tristate "M6 evaluation board with RT5631"
-	depends on SND_AML_SOC
-	select SND_SOC_RT5631 if SND_AML_M6_RT5631
+endif  # SND_AML_M6_SOC
 
-config SND_AML_M6_RT5616
-	tristate "M6 evaluation board with RT5616"
-	depends on SND_AML_SOC
-	select SND_SOC_RT5616 if SND_AML_M6_RT5616
+if SND_AML_M8_SOC
 
-config SND_AML_M6_RT3261
-	tristate "M6 evaluation board with RT3261"
-	depends on SND_AML_SOC
-	select SND_SOC_RT3261 if SND_AML_M6_RT3261
-	select SND_HWDEP
-config SND_AML_M6_WM8960
-	tristate "M6 evaluation board with WM8960"
-	depends on SND_AML_SOC
-	select SND_SOC_WM8960 if SND_AML_M6_WM8960
-config SND_AML_M6_PCM2BT
-	tristate "M6 evaluation board with PCM2BT"
-	depends on SND_AML_SOC
-	select SND_SOC_PCM2BT
-	
-config SND_AML_M_DUMMY_CODEC
-    tristate "AML M series board with DUMMY_CODEC"
-    depends on SND_AML_SOC
-    select SND_SOC_DUMMY_CODEC if SND_AML_M_DUMMY_CODEC
-config SND_AML_M6TV_AUDIO_CODEC
-	tristate "AML M6TV evaluation board,this must be selected for all m6tv board"
-	depends on SND_AML_SOC
-config SND_AML_M6TV_SYNOPSYS9629_CODEC
-	tristate "AML M6TV  board with internal syno9629 codec"
-	depends on SND_AML_M6TV_AUDIO_CODEC 
-config SND_AML_M6TV_RT5631
-	tristate "AML M6TV board with RT5631 codec"
-	depends on SND_AML_M6TV_AUDIO_CODEC
-	select SND_SOC_RT5631 if SND_AML_M6TV_RT5631	
-config SND_AML_M6TV_STA380
-	tristate "AML M6TV board with STA380 codec"
-	depends on SND_AML_M6TV_AUDIO_CODEC
-	select SND_SOC_STA380 if SND_AML_M6TV_STA380	
-config SND_AML_M6TV_TAS5711
-	tristate "AML M6TV board with TAS5711 codec"	
-	depends on SND_AML_M6TV_AUDIO_CODEC	
-	select SND_SOC_TAS5711 if SND_AML_M6TV_TAS5711
-if SND_AML_M6TV_TAS5711
-choice        
-	prompt "TAS5711 work mode"        
-	default TAS5711_2_CHANNEL
-config TAS5711_2_CHANNEL        
-	bool "2 BTL channel mode"
-config TAS5711_2_PLUS_1_CHANNEL
-	bool "2.1 channel mode"
-config TAS5711_2_SUBWOOFER_CHANNEL        
-	bool "2 BTL subwoofer channel"
-endchoice
-endif
-config SND_AML_M6TV_TAS5707
-	tristate "AML M6TV board with TAS5707 codec"	
-	depends on SND_AML_M6TV_AUDIO_CODEC	
-	select SND_SOC_TAS5707 if SND_AML_M6TV_TAS5707
-if SND_AML_M6TV_TAS5707
-choice        
-	prompt "TAS5707 work mode"        
-	default TAS5707_2_CHANNEL
-config TAS5707_2_CHANNEL        
-	bool "2 BTL channel mode"
-config TAS5707_2_SUBWOOFER_CHANNEL        
-	bool "2 BTL subwoofer channel"
-endchoice
-endif
+source "sound/soc/aml/m8/Kconfig"
 
-#config  SND_AML_SPDIF
-#	tristate "Amlogic S/PDIF codec support"
-#	depends on SND_AML_SOC
-#	select SND_SOC_AML_SPDIF_CODEC if SND_AML_SPDIF
-config SND_AML_M8
-	tristate "AML-SND-M8 Board"
-	depends on SND_AML_SOC && SWITCH
-	select SND_SOC_AML_M8_CODEC if SND_AML_M8
-	
-config SND_AML_M8_PCM
-	tristate "M8 evaluation board with PCM2BT"
-	depends on SND_AML_SOC
-	select SND_SOC_PCM2BT if SND_AML_M8_PCM
-config SND_AML_M8_RT5616
-tristate "M8 evaluation board with RT5616"
-depends on SND_AML_SOC
-select SND_SOC_RT5616 if SND_AML_M8_RT5616
+endif # SND_AML_M8_SOC
diff --git a/sound/soc/aml/Makefile b/sound/soc/aml/Makefile
index 2819d2cc76fc..469a4f12aa6a 100755
--- a/sound/soc/aml/Makefile
+++ b/sound/soc/aml/Makefile
@@ -1,96 +1,2 @@
-# AML Platform Support
-snd-soc-aml-pcm-objs := aml_pcm.o
-snd-soc-aml-i2s-objs := aml_i2s.o
-#snd-soc-aml-platform-pcm2bt-objs := aml_platform_pcm2bt.o
-snd-soc-aml-i2s-dai-objs := aml_i2s_dai.o
-snd-soc-aml-pcm-dai-objs := aml_pcm_dai.o
-snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
-snd-soc-aml-hw-objs  := aml_audio_hw.o
-snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
-#snd-soc-aml-platform-objs := aml_platform.o
-
-
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-pcm.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-i2s.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-i2s-dai.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-pcm-dai.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw.o
-obj-$(CONFIG_SND_AML_SOC) += aml_notify.o
-#obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform.o
-#obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-platform-pcm2bt.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-hw-pcm2bt.o
-
-
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-spdif-dai.o
-#AML M1 Machine support
-
-snd-soc-aml-m1-objs := aml_m1.o
-snd-soc-aml-codec-objs := aml_m1_codec.o
-
-obj-$(CONFIG_SND_AML_M1) += snd-soc-aml-m1.o
-obj-$(CONFIG_SND_AML_M1) += snd-soc-aml-codec.o
-
-#AML M1 MID with WM8900 support
-
-snd-soc-aml-m1-mid-wm8900-objs := aml_m1_mid_wm8900.o
-obj-$(CONFIG_SND_AML_M1_MID_WM8900) += snd-soc-aml-m1-mid-wm8900.o
-
-#AML M1 ARM DEV Board with wm8900 support
-
-snd-soc-aml-m1-armdev-wm8900-objs := aml_m1_armdev_wm8900.o
-obj-$(CONFIG_SND_AML_M1_ARMDEV_WM8900) += snd-soc-aml-m1-armdev-wm8900.o
-
-#AML M1 MID with RT5621 support
-snd-soc-aml-m1-mid-rt5621-objs := aml_m1_mid_rt5621.o
-obj-$(CONFIG_SND_AML_M1_MID_RT5621) += snd-soc-aml-m1-mid-rt5621.o
-
-
-# AML M2 Machine support
-
-snd-soc-aml-m2-objs := aml_m2.o
-snd-soc-aml-codec-objs := aml_m2_codec.o
-obj-$(CONFIG_SND_AML_M2) += snd-soc-aml-m2.o
-obj-$(CONFIG_SND_AML_M2) += snd-soc-aml-codec.o
-
-# AML M3 Machine support
-
-snd-soc-aml-m3-objs := aml_m3.o
-snd-soc-aml-codec-objs := aml_m3_codec.o
-obj-$(CONFIG_SND_AML_M3) += snd-soc-aml-m3.o
-obj-$(CONFIG_SND_AML_M3) += snd-soc-aml-codec.o
-
-#AML M6 Machine support
-snd-soc-aml-m6-rt5631-objs := aml_m6_rt5631.o
-obj-$(CONFIG_SND_AML_M6_RT5631) += snd-soc-aml-m6-rt5631.o
-
-#AML M6 Machine support
-snd-soc-aml-m6-rt5616-objs := aml_m6_rt5616.o
-obj-$(CONFIG_SND_AML_M6_RT5616) += snd-soc-aml-m6-rt5616.o
-
-#AML M6 Machine support
-snd-soc-aml-m6-rt3261-objs := aml_m6_rt3261.o
-obj-$(CONFIG_SND_AML_M6_RT3261) += snd-soc-aml-m6-rt3261.o
-snd-soc-aml-m6-wm8960-objs := aml_m6_wm8960.o
-obj-$(CONFIG_SND_AML_M6_WM8960) += snd-soc-aml-m6-wm8960.o
-
-#AML M series with dummy codec support
-snd-soc-aml-m-dummy-objs := aml_m_dummy.o
-obj-$(CONFIG_SND_AML_M_DUMMY_CODEC) += snd-soc-aml-m-dummy.o
-
-# AML M6TV Machine support
-snd-soc-aml-m6tv-audio-objs := aml_m6tv_audio.o
-snd-soc-aml-syno9629-codec-objs := aml_syno9629_codec.o
-obj-$(CONFIG_SND_AML_M6TV_AUDIO_CODEC) += snd-soc-aml-m6tv-audio.o
-obj-$(CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC) += snd-soc-aml-syno9629-codec.o
-
-#AML spdif codec support
-snd-soc-aml-spdif-codec-objs := aml_spdif_codec.o
-#obj-$(CONFIG_SND_SOC_AML_SPDIF_CODEC) += snd-soc-aml-spdif-codec.o
-obj-$(CONFIG_SND_AML_SOC) += snd-soc-aml-spdif-codec.o
-#AML M8 Machine support
-snd-soc-aml-m8-objs := aml_m8.o
-obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
-
-#AML M8 Machine support
-snd-soc-aml-m8-rt5616-objs := aml_m8_rt5616.o
-obj-$(CONFIG_SND_AML_M8_RT5616) += snd-soc-aml-m8-rt5616.o
+obj-$(CONFIG_SND_AML_M6_SOC)	+= m6/
+obj-$(CONFIG_SND_AML_M8_SOC)	+= m8/
diff --git a/sound/soc/aml/aml.dtd b/sound/soc/aml/aml.dtd
deleted file mode 100755
index 7e3011a4642c..000000000000
--- a/sound/soc/aml/aml.dtd
+++ /dev/null
@@ -1,59 +0,0 @@
-#ifdef CONFIG_SND_AML_SOC
-//$$ DEVICE="audio_platform"
-//$$ L2 PROP_STR = "status"
-    audio_platform{
-        compatible = "amlogic,aml-audio";
-        dev_name = "aml-audio.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_dai"
-//$$ L2 PROP_STR = "status"
-    audio_dai{
-        compatible = "amlogic,aml-dai";
-        dev_name = "aml-dai.0";
-        status = "okay";
-    };
-
-//$$ DEVICE="audio_m8_audio"
-//$$ L2 PROP_STR = "status"
-    audio_m8_audio{
-        compatible = "amlogic,m8_audio_codec";
-        dev_name = "aml_m8_codec.0";
-        status = "okay";
-    };
-#endif        
-
-#ifdef CONFIG_SND_AML_M8
-//$$ DEVICE="aml_m8_sound_card"
-//$$ L2 PROP_STR = "aml,sound_card"
-//$$ L2 PROP_STR = "aml,codec_dai"
-//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
-//$$ L2 PROP_STR = "mute_gpio"
-//$$ L2 PROP_U32 5 = "hp_paraments"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_STR = "pinctrl-names"
-//$$ L2 PROP_CHOICE "Audio_pin_0_match" = "pinctrl-0"
-    aml_m8_sound_card{
-        compatible = "sound_card, aml_snd_m8";
-        aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8";
-        aml,audio-routing =
-            "Ext Spk","LINEOUTL",
-            "Ext Spk","LINEOUTR",
-            "HP","HP_L",
-            "HP","HP_R",
-            "MICBIAS","MAIN MIC",
-            "LINPUT1","MICBIAS";
-        mute_gpio = "GPIOY_15";
-        //mute_inv;
-        hp_paraments = <800 713 300 5 1>;
-        pinctrl-names = "aml_snd_m8";
-        pinctrl-0 = <&audio_pins>;
-        status = "okay";
-        
-    };
-#endif
-
-
-
diff --git a/sound/soc/aml/aml_alsa_common.h b/sound/soc/aml/aml_alsa_common.h
deleted file mode 100644
index 31d8a768faa4..000000000000
--- a/sound/soc/aml/aml_alsa_common.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef __AML_ALSA_COMMOM_H__
-#define __AML_ALSA_COMMON_H__
-
-#define VOLUME_SCALE	100
-#define VOLUME_SHIFT	15
-
-extern int aml_alsa_create_ctrl(struct snd_card *card, void *p_value);
-
-extern int get_mixer_output_volume(void);
-
-extern int set_mixer_output_volume(int volume);
-#endif
diff --git a/sound/soc/aml/aml_audio_hw.c b/sound/soc/aml/aml_audio_hw.c
deleted file mode 100755
index aa667944d3a2..000000000000
--- a/sound/soc/aml/aml_audio_hw.c
+++ /dev/null
@@ -1,1287 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <mach/am_regs.h>
-#include <linux/clk.h>
-#include <linux/module.h>
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-//#include <mach/utils.h>
-#endif
-
-#include "aml_audio_hw.h"
-
-#ifndef MREG_AIU_958_chstat0
-#define AIU_958_chstat0	AIU_958_CHSTAT_L0
-#endif
-
-#ifndef MREG_AIU_958_chstat1
-#define AIU_958_chstat1	AIU_958_CHSTAT_L1
-#endif
-
-
-unsigned ENABLE_IEC958 = 1;
-unsigned IEC958_MODE   = AIU_958_MODE_PCM16;
-unsigned I2S_MODE      = AIU_I2S_MODE_PCM16;
-
-
-int  audio_in_buf_ready = 0;
-int audio_out_buf_ready = 0;
-
-unsigned int IEC958_bpf = 0x7dd;
-unsigned int IEC958_brst = 0xc;
-unsigned int IEC958_length = 0x7dd*8;
-unsigned int IEC958_padsize = 0x8000;
-unsigned int IEC958_mode = 1;
-unsigned int IEC958_syncword1 = 0x7ffe;
-unsigned int IEC958_syncword2 = 0x8001;
-unsigned int IEC958_syncword3 = 0;
-unsigned int IEC958_syncword1_mask = 0;
-unsigned int IEC958_syncword2_mask = 0;
-unsigned int IEC958_syncword3_mask = 0xffff;
-unsigned int IEC958_chstat0_l = 0x1902 ;
-unsigned int IEC958_chstat0_r = 0x1902 ;
-unsigned int IEC958_chstat1_l = 0x200;
-unsigned int IEC958_chstat1_r = 0x200;
-unsigned int IEC958_mode_raw = 0;
-/*
- 0 --  other formats except(DD,DD+,DTS)
- 1 --  DTS
- 2 --  DD
- 3 -- DTS with 958 PCM RAW package mode
- 4 -- DD+
-*/
-unsigned int IEC958_mode_codec;
-/*
-bit 0:soc in slave mode for adc;
-bit 1:audio in data source from spdif in;
-bit 2:adc & spdif in work at the same time;
-*/
-unsigned audioin_mode = I2SIN_MASTER_MODE;
-
-EXPORT_SYMBOL(IEC958_bpf);
-EXPORT_SYMBOL(IEC958_brst);
-EXPORT_SYMBOL(IEC958_length);
-EXPORT_SYMBOL(IEC958_padsize);
-EXPORT_SYMBOL(IEC958_mode);
-EXPORT_SYMBOL(IEC958_syncword1);
-EXPORT_SYMBOL(IEC958_syncword2);
-EXPORT_SYMBOL(IEC958_syncword3);
-EXPORT_SYMBOL(IEC958_syncword1_mask);
-EXPORT_SYMBOL(IEC958_syncword2_mask);
-EXPORT_SYMBOL(IEC958_syncword3_mask);
-EXPORT_SYMBOL(IEC958_chstat0_l);
-EXPORT_SYMBOL(IEC958_chstat0_r);
-EXPORT_SYMBOL(IEC958_chstat1_l);
-EXPORT_SYMBOL(IEC958_chstat1_r);
-EXPORT_SYMBOL(IEC958_mode_raw);
-EXPORT_SYMBOL(IEC958_mode_codec);
-
-// Bit 3:  mute constant
-//         0 => 'h0000000
-//         1 => 'h800000
-unsigned int dac_mute_const = 0x800000;
-
-/*
-                                fIn * (M)
-            Fout   =  -----------------------------
-                      		(N) * (OD+1) * (XD)
-*/
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-int audio_clock_config_table[][12][2]=
-{
-	/*{HIU Reg , XD - 1)
-	   //7.875k, 8K, 11.025k, 12k, 16k, 22.05k, 24k, 32k, 44.1k, 48k, 96k, 192k
-	*/
-	{
-	//256
-#if OVERCLOCK == 0
-		{0x0004f880, (50-1)},  // 32
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8	
-		{0x0005e965, (40-1)}, //44.1	
-		{0x0004c9a0,	(50-1)},	//48K
-#else		
-		{0x0004cdf3, (42-1)},  // 44.1
-		{0x0007c4e6, (23-1)},  // 48
-#endif	
-		{0x0006d0a4, (13-1)},  // 96
-		{0x0004e15a, (9 -1)},   // 192
-		{0x0007f400, (125-1)}, // 8k
-		{0x0006c6f6, (116-1)}, // 11.025
-		{0x0007e47f, (86-1)},  // 12
-		{0x0004f880, (100-1)}, // 16
-		{0x0004c4a4, (87-1)},  // 22.05
-		{0x0007e47f, (43-1)},  // 24
-		{0x0007f3f0, (127-1)}, // 7875
-#else
-	//512FS
-		{0x0004f880, (25-1)},  // 32
-		{0x0004cdf3, (21-1)},  // 44.1
-		{0x0006d0a4, (13-1)},  // 48
-		{0x0004e15a, (9 -1)},  // 96
-		{0x0006f207, (3 -1)},   // 192
-		{0x0004f880, (100-1)}, // 8k
-		{0x0004c4a4, (87-1)}, // 11.025
-		{0x0007e47f, (43-1)},  // 12
-		{0x0004f880, (50-1)}, // 16
-		{0x0004cdf3, (42-1)},  // 22.05
-		{0x0007c4e6, (23-1)},  // 24
-		{0x0006e1b6, (76-1)}, // 7875
-#endif
-	},
-	{
-	//384
-		{0x0007c4e6, (23-1)},  // 32
-		{0x0004c4a4, (29-1)},  // 44.1
-		{0x0004cb18, (26-1)},  // 48
-		{0x0004cb18, (13-1)},  // 96
-		{0x0004e15a, (6 -1)},   // 192
-		{0x0007e47f, (86-1)},  // 8k
-		{0x0007efa5, (61-1)},  // 11.025
-		{0x0006de98, (67-1)},  // 12
-		{0x0007e47f, (43-1)},  // 16
-		{0x0004c4a4, (58-1)},  // 22.05
-		{0x0004c60e, (53-1)},  // 24
-		{0x0007fdfa, (83-1)},  // 7875
-	}
-};
-#else
-int audio_clock_config_table[][11][2]=
-{
-  // 128*Fs
-  //
-	/*{M, N, OD, XD-1*/
-	{
-	//24M
-        {(64<<0) | (3<<9) | (0<<14) , (125-1)}, // 32K, 4.096M
-#if OVERCLOCK==0
-        {(147<<0) | (5<<9) | (0<<14) , (125-1)}, // 44.1K, 5.6448M
-        {(32<<0) | (1<<9) | (0<<14) , (125-1)}, // 48K, 6.144M
-#else
-        {(143<<0) | (8<<9) | (0<<14) , (19-1)}, // 44.1K, 5.6448M*4=22.5792M
-        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, // 48K, 6.144M*4=24.576M
-#endif
-        {(128<<0) | (5<<9) | (1<<14) , (25-1)}, // 96K, 12.288M
-        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, //192K, 24.576M
-        {(64<<0) | (3<<9) | (1<<14) , (250-1)}, // 8K, 1.024M
-        {(147<<0) | (5<<9) | (1<<14) , (250-1)}, //11.025K,1.4112M
-        {(32<<0) | (1<<9) | (1<<14) , (250-1)}, // 12K, 1.536M
-        {(64<<0) | (3<<9) | (1<<14) , (125-1)}, // 16K, 2.048M
-        {(147<<0) | (5<<9) | (1<<14) , (125-1)}, //22.050K, 2.8224M
-        {(32<<0) | (1<<9) | (1<<14) , (125-1)}, // 24K, 3.072M
-	},
-	{
-	//25M
-        {(29<<0) | (1<<9) | (0<<14) , (177-1)}, // 32K, 4.096M
-#if OVERCLOCK==0
-        {(21<<0) | (1<<9) | (0<<14) , (93-1)}, // 44.1K, 5.6448M
-        {(29<<0) | (1<<9) | (1<<14) , (59-1)}, // 48K, 6.144M
-#else
-        {(28<<0) | (1<<9) | (0<<14) , (31-1)}, // 44.1K, 5.6448M*4=22.5792M
-        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, // 48K, 6.144M*4=24.576M
-#endif
-        {(29<<0) | (1<<9) | (0<<14) , (59-1)}, // 96K, 12.288M
-        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, //192K, 24.576M
-        {(58<<0) | (3<<9) | (1<<14) , (236-1)}, // 8K, 1.024M
-        {(162<<0) | (7<<9) | (1<<14) , (205-1)}, //11.025K,1.4112M
-        {(29<<0) | (1<<9) | (1<<14) , (236-1)}, // 12K, 1.536M
-        {(29<<0) | (1<<9) | (1<<14) , (177-1)}, // 16K, 2.048M
-        {(162<<0) | (7<<9) | (0<<14) , (205-1)}, //22.050K, 2.8224M
-        {(29<<0) | (1<<9) | (1<<14) , (118-1)}, // 24K, 3.072M
-	}
-};
-#endif
-
-
-void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
-{
-	printk("====== %s ======\n",__FUNCTION__);
-    WRITE_MPEG_REG(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
-    WRITE_MPEG_REG(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
-    if(channel == 8)
-		WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 256); 
-	else
-    WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);   //this is for 16bit 2 channel
-
-    WRITE_MPEG_REG(AIU_I2S_MISC,		0x0004);	// Hold I2S
-	WRITE_MPEG_REG(AIU_I2S_MUTE_SWAP,	0x0000);	// No mute, no swap
-	// As the default amclk is 24.576MHz, set i2s and iec958 divisor appropriately so as not to exceed the maximum sample rate.
-	WRITE_MPEG_REG(AIU_I2S_MISC,		0x0010 );	// Release hold and force audio data to left or right
-
-	if(channel == 8){
-		printk(" %s channel == 8\n",__FUNCTION__);
-	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
-								(0xff << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
-								(0xff << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
-		}
-	else 
-	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
-								(0x3 << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
-								(0x3 << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
-
-    // 16 bit PCM mode
-    //  WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
-	// Set init high then low to initilize the I2S memory logic
-	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1 );
-	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1 );
-
-	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
-	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
-
-    audio_out_buf_ready = 1;
-}
-
-void audio_set_958outbuf(u32 addr, u32 size,int flag)
-{
-    if (ENABLE_IEC958) {
-        WRITE_MPEG_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
-	  	if(READ_MPEG_REG(AIU_MEM_IEC958_START_PTR) == READ_MPEG_REG(AIU_MEM_I2S_START_PTR)){
-			WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, READ_MPEG_REG(AIU_MEM_I2S_RD_PTR));
-		}
-		else
-        WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
-        if(flag == 0){
-          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);    // this is for 16bit 2 channel
-        }else{
-          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 1);    // this is for RAW mode
-        }
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, 0x303, 0, 16);
-
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
-        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
-
-        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
-        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
-    }
-}
-/*
-i2s mode 0: master 1: slave
-*/
-static void i2sin_fifo0_set_buf(u32 addr, u32 size,u32 i2s_mode,u32 i2s_sync)
-{
-	unsigned char  mode = 0;
-    unsigned int sync_mode = 0;
-    if(i2s_sync)
-        sync_mode = i2s_sync;
-	if(i2s_mode &I2SIN_SLAVE_MODE)
-		mode = 1;
-	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
-	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
-	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
-
-	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
-    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
-								|(1<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
-	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
-									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
-								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
-								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
-		    						|(0<<16)	//to DDR
-                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
-                                                       |(0<<17)    // Overflow Interrupt mask
-                                                       |(0<<18)    // Audio in INT
-			                                	//|(1<<19)	//hold 0 enable
-								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
-				  );
-
-    WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,    0 << 4                       // fifo0_dest_sel
-                                       | 2 << 2                       // fifo0_din_byte_num
-                                       | 0 << 0);                      // fifo0_din_pos
-
-
-	WRITE_MPEG_REG(AUDIN_I2SIN_CTRL, //(0<<I2SIN_SIZE)			///*bit8*/  16bit
-									 (3<<I2SIN_SIZE)
-									|(1<<I2SIN_CHAN_EN)		/*bit10~13*/ //2 channel
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-									|(sync_mode<<I2SIN_POS_SYNC)
-#else
-									|(1<<I2SIN_POS_SYNC)
-#endif
-									|(1<<I2SIN_LRCLK_SKEW)
-                                    				|(1<<I2SIN_LRCLK_INVT)
-									|(!mode<<I2SIN_CLK_SEL)
-									|(!mode<<I2SIN_LRCLK_SEL)
-				    				|(!mode<<I2SIN_DIR)
-				  );
-
-}
-static void spdifin_fifo1_set_buf(u32 addr, u32 size)
-{
-	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffffff);
-	WRITE_MPEG_REG(AUDIN_FIFO1_START, addr & 0xffffffc0);
-	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, (addr&0xffffffc0));
-	WRITE_MPEG_REG(AUDIN_FIFO1_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
-	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1<<AUDIN_FIFO1_EN)	// FIFO0_EN
-    								|(1<<AUDIN_FIFO1_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
-								|(0<<AUDIN_FIFO1_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
-	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
-									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
-								|(4<<AUDIN_FIFO1_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
-								|(2<<AUDIN_FIFO1_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
-		    						|(0<<16)	//to DDR
-                                                       |(1<<AUDIN_FIFO1_UG)    // Urgent request.  DDR SDRAM urgent request enable.
-                                                       |(0<<17)    // Overflow Interrupt mask
-                                                       |(0<<18)    // Audio in INT
-			                                	//|(1<<19)	//hold 0 enable
-								|(0<<AUDIN_FIFO1_UG)	// hold0 to aififo
-				  );
-	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1,0xc);
-}
-void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode, u32 i2s_sync)
-{
-	printk("i2sin_fifo0_set_buf \n");		
-	i2sin_fifo0_set_buf(addr,size,i2s_mode,i2s_sync);
-	audio_in_buf_ready = 1;
-}
-void audio_in_spdif_set_buf(u32 addr, u32 size)
-{
-	printk("spdifin_fifo1_set_buf \n");			
-	spdifin_fifo1_set_buf(addr,size);
-	
-}
-//extern void audio_in_enabled(int flag);
-
-void audio_in_i2s_enable(int flag)
-{
-  	int rd = 0, start=0;
-	if(flag){
-          /* reset only when start i2s input */
-reset_again:
-	     WRITE_MPEG_REG_BITS(AUDIN_FIFO0_CTRL, 1, 1, 1); // reset FIFO 0
-            WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 0);
-            rd = READ_MPEG_REG(AUDIN_FIFO0_PTR);
-            start = READ_MPEG_REG(AUDIN_FIFO0_START);
-            if(rd != start){
-              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
-              goto reset_again;
-            }
-			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 1, I2SIN_EN, 1);
-
-	}else{
-			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 0, I2SIN_EN, 1);
-	}
-}
-
-
-void audio_in_spdif_enable(int flag)
-{
-  int rd = 0, start=0;
-
-	if(flag){
-reset_again:
-	     WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1); // reset FIFO 0
-            WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
-            rd = READ_MPEG_REG(AUDIN_FIFO1_PTR);
-            start = READ_MPEG_REG(AUDIN_FIFO1_START);
-            if(rd != start){
-              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
-              goto reset_again;
-            }
-		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));		
-	}else{
-		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));				
-	}
-}
-int if_audio_in_i2s_enable()
-{
-	return READ_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, I2SIN_EN, 1);
-}
-int if_audio_in_spdif_enable()
-{
-	return READ_MPEG_REG_BITS(AUDIN_SPDIF_MODE, 31, 1);
-}
-unsigned int audio_in_i2s_rd_ptr(void)
-{
-	unsigned int val;
-	val = READ_MPEG_REG(AUDIN_FIFO0_RDPTR);
-	printk("audio in i2s rd ptr: %x\n", val);
-	return val;
-}
-unsigned int audio_in_spdif_rd_ptr(void)
-{
-	unsigned int val;
-	val = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
-	printk("audio in spdif rd ptr: %x\n", val);
-	return val;
-}
-unsigned int audio_in_i2s_wr_ptr(void)
-{
-	unsigned int val;
-      WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 1);
-	val = READ_MPEG_REG(AUDIN_FIFO0_PTR);
-	return (val)&(~0x3F);
-	//return val&(~0x7);
-}
-unsigned int audio_in_spdif_wr_ptr(void)
-{
-	unsigned int val;
-      WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
-	val = READ_MPEG_REG(AUDIN_FIFO1_PTR);
-	return (val)&(~0x3F);
-}
-void audio_in_i2s_set_wrptr(unsigned int val)
-{
-	WRITE_MPEG_REG(AUDIN_FIFO0_RDPTR, val);
-}
-void audio_in_spdif_set_wrptr(unsigned int val)
-{
-	WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, val);
-}
-void audio_set_i2s_mode(u32 mode)
-{
-    const unsigned short mask[4] = {
-        0x303,                  /* 2x16 */
-        0x303,                  /* 2x24 */
-        0x303,                 /* 8x24 */
-        0x303,                  /* 2x32 */
-    };
-
-    if (mode < sizeof(mask)/ sizeof(unsigned short)) {
-       /* four two channels stream */
-        WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 1);
-
-        if (mode == AIU_I2S_MODE_PCM16) {
-            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
-            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 0, 5, 1);
-        } else if(mode == AIU_I2S_MODE_PCM32){
-            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
-            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
-        }else if(mode == AIU_I2S_MODE_PCM24){
-            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
-            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
-        }
-
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
-
-        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1);
-        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1);
-
-        if (ENABLE_IEC958) {
-       //     WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, mask[mode], 0,
-             //                   16);
-            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
-            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
-        }
-    }
-}
-
-/**
- *  if normal clock, i2s clock is twice of 958 clock, so the divisor for i2s is 8, but 4 for 958
- *  if over clock, the devisor for i2s is 8, but for 958 should be 1, because 958 should be 4 times speed according to i2s
- *  This is dolby digital plus's spec
- * */
-
-void audio_util_set_dac_format(unsigned format)
-{
-  	WRITE_MPEG_REG(AIU_CLK_CTRL,		 (0 << 12) | // 958 divisor more, if true, divided by 2, 4, 6, 8.
-							(1 <<  8) | // alrclk skew: 1=alrclk transitions on the cycle before msb is sent
-							(1 <<  6) | // invert aoclk
-							(1 <<  7) | // invert lrclk
-#if OVERCLOCK == 1
-							(3 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
-							(3 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
-#else
-							(1 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
-							(2 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
-#endif
-							(1 <<  1) | // enable 958 clock
-							(1 <<  0)); // enable I2S clock
-    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
-        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
-    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
-        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
-    }
- 	if(dac_mute_const == 0x800000)
-    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
-    else
-    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
-	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel
-}
-
-// iec958 and i2s clock are separated after M6TV.
-void audio_util_set_dac_958_format(unsigned format)
-{
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,0,12,1);// 958 divisor more, if true, divided by 2, 4, 6, 8
-#if IEC958_OVERCLOCK == 1
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
-#else
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
-#endif
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,1,1);// enable 958 clock
-}
-
-void audio_util_set_dac_i2s_format(unsigned format)
-{	
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,6,1);//invert aoclk
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,7,1);//invert lrclk
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,8,2);// alrclk skew: 1=alrclk transitions on the cycle before msb is sent
-#if OVERCLOCK == 1
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,2,2);// i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
-#else
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,2,2,2); // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
-#endif
-	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,0,1);// enable I2S clock
-	
-    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
-        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
-    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
-        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
-    }
- 	if(dac_mute_const == 0x800000)
-    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
-    else
-    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
-	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel	
-}
-
-extern unsigned int get_ddr_pll_clk(void);
-
-void audio_set_clk(unsigned freq, unsigned fs_config)
-{
-    int i;
-    int xtal = 0;
-
-    int (*audio_clock_config)[2];
-
-   // if (fs_config == AUDIO_CLK_256FS) {
-   if(1){
-		int index=0;
-		switch(freq)
-		{
-			case AUDIO_CLK_FREQ_192:
-				index=4;
-				break;
-			case AUDIO_CLK_FREQ_96:
-				index=3;
-				break;
-			case AUDIO_CLK_FREQ_48:
-				index=2;
-				break;
-			case AUDIO_CLK_FREQ_441:
-				index=1;
-				break;
-			case AUDIO_CLK_FREQ_32:
-				index=0;
-				break;
-			case AUDIO_CLK_FREQ_8:
-				index = 5;
-				break;
-			case AUDIO_CLK_FREQ_11:
-				index = 6;
-				break;
-			case AUDIO_CLK_FREQ_12:
-				index = 7;
-				break;
-			case AUDIO_CLK_FREQ_16:
-				index = 8;
-				break;
-			case AUDIO_CLK_FREQ_22:
-				index = 9;
-				break;
-			case AUDIO_CLK_FREQ_24:
-				index = 10;
-				break;
-			default:
-				index=0;
-				break;
-		};
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
-	// get system crystal freq
-		clk=clk_get_sys("clk_xtal", NULL);
-		if(!clk)
-		{
-			printk(KERN_ERR "can't find clk %s for AUDIO PLL SETTING!\n\n","clk_xtal");
-			//return -1;
-		}
-		else
-		{
-			xtal=clk_get_rate(clk);
-			xtal=xtal/1000000;
-			if(xtal>=24 && xtal <=25)/*current only support 24,25*/
-			{
-				xtal-=24;
-			}
-			else
-			{
-				printk(KERN_WARNING "UNsupport xtal setting for audio xtal=%d,default to 24M\n",xtal);
-				xtal=0;
-			}
-		}
-
-		audio_clock_config = audio_clock_config_table[xtal];
-#endif
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	if (fs_config == AUDIO_CLK_256FS) {
-		// divide 256
-		xtal = 0;
-	}
-	else if (fs_config == AUDIO_CLK_384FS) {
-	    // divide 384
-		xtal = 1;
-	}
-	audio_clock_config = audio_clock_config_table[xtal];
-#endif
-
-#ifdef CONFIG_SND_AML_M3
-	if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==516000000)&&(index=2))) // 48k
-	{
-		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
-		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 516/42
-		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
-		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-		printk(KERN_INFO "audio 48k clock from ddr pll %dM\n", 516);
-		return;
-	}
-	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==508000000)&&(index=1))) // 44.1k
-	{
-		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
-		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 45-1, 0, 8); // 508/45
-		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
-		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 508);
-		return;
-	}
-	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==486000000)&&(index=1))) // 44.1k
-	{
-		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
-		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 43-1, 0, 8); // 486/42
-		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
-		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 486);
-		return;
-	}
-	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==474000000)&&(index=1))) // 44.1k
-	{
-		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
-		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
-		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 474/42
-		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
-		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
-		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 474);
-		return;
-	}
-#endif
-
-    // gate the clock off
-    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
-
-//#ifdef CONFIG_SND_AML_M3
-#ifdef CONFIG_ARCH_MESON3
-	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL2, 0x065e31ff);
-	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL3, 0x9649a941);
-	// select Audio PLL as MCLK source
-	//WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 9));
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 9, 3);
-	//WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 25-1, 0, 8);
-
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 13-1, 0, 8);
-#endif
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-  WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
-#endif
-
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
-    // Put the PLL to sleep
-    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15));//found
-
-//#ifdef CONFIG_SND_AML_M3
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
-	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
-	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
-#endif
-    // Bring out of reset but keep bypassed to allow to stablize
-    //Wr( HHI_AUD_PLL_CNTL, (1 << 15) | (0 << 14) | (hiu_reg & 0x3FFF) );
-    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, (1 << 15) | (audio_clock_config[index][0] & 0x7FFF) );//found
-    // Set the XD value
-    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, (READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(0xff << 0)) | audio_clock_config[index][1]);//found
-    // delay 5uS
-	//udelay(5);
-	for (i = 0; i < 500000; i++) ;
-    // Bring the PLL out of sleep
-    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));//found
-
-    // gate the clock on
-    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));//found
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
-	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));// gate audac_clkpi
-#endif
-#else // endif CONFIG_ARCH_MESON6
-    WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
-	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
-	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
-
-	// Select Multi-Phase PLL2 as clock source
-	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 3);
-
-	// Configure Multi-Phase PLL2
-	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
-	// Set the XD value
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
-	// delay 5uS
-	//udelay(5);
-	for (i = 0; i < 500000; i++) ;
-	// gate the clock on
-	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV
-	//Audio DAC Clock enable
-	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
-/* ADC clock  configuration */
-// Disable mclk
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 8, 1);
-
-    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 3, 9, 2);
-
-    // Set pll over mclk ratio
-    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
-#if OVERCLOCK == 0
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 0, 8);
-#else
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)*2-1, 0, 8);
-#endif
-
-    // Set mclk over sclk ratio
-    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
-
-    // Set sclk over lrclk ratio
-    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);
-
-    // Enable sclk
-    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
-    // Enable mclk
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 8, 1);
-#endif
-
-#endif // endif CONFIG_ARCH_MESON6
-    // delay 2uS
-	//udelay(2);
-	for (i = 0; i < 200000; i++) ;
-
-    } else if (fs_config == AUDIO_CLK_384FS) {
-    }
-}
-
-// iec958 and i2s clock are separated after M6TV. Use PLL2 for i2s DAC & ADC clock
-void audio_set_i2s_clk(unsigned freq, unsigned fs_config)
-{
-    int i;
-    int xtal = 0;
-
-    int (*audio_clock_config)[2];
-
-	int index=0;
-	switch(freq)
-	{
-		case AUDIO_CLK_FREQ_192:
-			index=4;
-			break;
-		case AUDIO_CLK_FREQ_96:
-			index=3;
-			break;
-		case AUDIO_CLK_FREQ_48:
-			index=2;
-			break;
-		case AUDIO_CLK_FREQ_441:
-			index=1;
-			break;
-		case AUDIO_CLK_FREQ_32:
-			index=0;
-			break;
-		case AUDIO_CLK_FREQ_8:
-			index = 5;
-			break;
-		case AUDIO_CLK_FREQ_11:
-			index = 6;
-			break;
-		case AUDIO_CLK_FREQ_12:
-			index = 7;
-			break;
-		case AUDIO_CLK_FREQ_16:
-			index = 8;
-			break;
-		case AUDIO_CLK_FREQ_22:
-			index = 9;
-			break;
-		case AUDIO_CLK_FREQ_24:
-			index = 10;
-			break;
-		default:
-			index=0;
-			break;
-	};
-
-	if (fs_config == AUDIO_CLK_256FS) {
-		// divide 256
-		xtal = 0;
-	}
-	else if (fs_config == AUDIO_CLK_384FS) {
-	    // divide 384
-		xtal = 1;
-	}
-	audio_clock_config = audio_clock_config_table[xtal];
-
-    // gate the clock off
-    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
-	WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
-	
-	//Set filter register
-	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
-
-	/*--- DAC clock  configuration--- */
-	// Disable mclk
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
-	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
-	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 2);
-
-	// Configure Multi-Phase PLL2
-	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
-	// Set the XD value
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
-
-	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk--64fs
-	
-	// delay 5uS
-	//udelay(5);
-	for (i = 0; i < 500000; i++) ;
-	// gate the clock on
-	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-
-	//Audio DAC Clock enable
-	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
-	
-	/* ---ADC clock  configuration--- */
-	// Disable mclk
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
-
-    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 3, 9, 2);
-
-    // Set pll over mclk ratio
-    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
-#if OVERCLOCK == 0
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
-#else
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, (audio_clock_config[index][1]+1)*2-1, 0, 8);
-#endif
-
-    // Set mclk over sclk ratio
-    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
-
-    // Set sclk over lrclk ratio
-    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12); //set codec adc ratio---lrclk--64fs
-
-    // Enable sclk
-    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
-    // Enable mclk
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 8, 1);
-
-    // delay 2uS
-	//udelay(2);
-	for (i = 0; i < 200000; i++) ;
-}
-
-// iec958 and i2s clock are separated after M6TV. Use PLL1 for iec958 clock
-void audio_set_958_clk(unsigned freq, unsigned fs_config)
-{
-    int i;
-    int xtal = 0;
-
-    int (*audio_clock_config)[2];
-
-	int index=0;
-	switch(freq)
-	{
-		case AUDIO_CLK_FREQ_192:
-			index=4;
-			break;
-		case AUDIO_CLK_FREQ_96:
-			index=3;
-			break;
-		case AUDIO_CLK_FREQ_48:
-			index=2;
-			break;
-		case AUDIO_CLK_FREQ_441:
-			index=1;
-			break;
-		case AUDIO_CLK_FREQ_32:
-			index=0;
-			break;
-		case AUDIO_CLK_FREQ_8:
-			index = 5;
-			break;
-		case AUDIO_CLK_FREQ_11:
-			index = 6;
-			break;
-		case AUDIO_CLK_FREQ_12:
-			index = 7;
-			break;
-		case AUDIO_CLK_FREQ_16:
-			index = 8;
-			break;
-		case AUDIO_CLK_FREQ_22:
-			index = 9;
-			break;
-		case AUDIO_CLK_FREQ_24:
-			index = 10;
-			break;
-		default:
-			index=0;
-			break;
-	};
-
-	if (fs_config == AUDIO_CLK_256FS) {
-		// divide 256
-		xtal = 0;
-	}
-	else if (fs_config == AUDIO_CLK_384FS) {
-	    // divide 384
-		xtal = 1;
-	}
-	audio_clock_config = audio_clock_config_table[xtal];
-
-    // gate the clock off
-    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
-	//WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
-	
-	//Set filter register
-	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
-
-	/*--- IEC958 clock  configuration, use MPLL1--- */
-	// Disable mclk
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 24, 1);
-	//IEC958_USE_CNTL
-	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 1, 27, 1);
-	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
-	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 2, 25, 2);
-
-	// Configure Multi-Phase PLL1
-	WRITE_MPEG_REG(HHI_MPLL_CNTL8, audio_clock_config[index][0]);
-	// Set the XD value
-#if IEC958_OVERCLOCK	==1
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)/2 -1, 16, 8);
-#else
-	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 16, 8);
-#endif
-
-	// delay 5uS
-	//udelay(5);
-	for (i = 0; i < 500000; i++) ;
-	// gate the clock on
-	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
-	// Enable mclk
-    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 24, 1);
-}
-
-//extern void audio_out_enabled(int flag);
-void audio_hw_958_raw(void);
-
-void audio_enable_ouput(int flag)
-{
-    if (flag) {
-        WRITE_MPEG_REG(AIU_RST_SOFT, 0x05);
-        READ_MPEG_REG(AIU_I2S_SYNC);
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
-
-        if (0/*ENABLE_IEC958*/) {
-            if(IEC958_MODE == AIU_958_MODE_RAW)
-            {
-              //audio_hw_958_raw();
-            }
-            //else
-            {
-              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
-              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
-              //WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 1);
-
-              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
-            }
-        }
-        // Maybe cause POP noise
-        // audio_i2s_unmute();
-    } else {
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
-
-        if (0/*ENABLE_IEC958*/) {
-            WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
-        }
-        // Maybe cause POP noise
-        // audio_i2s_mute();
-    }
-    //audio_out_enabled(flag);
-}
-
-int if_audio_out_enable()
-{
-	return READ_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 2);
-}
-
-unsigned int read_i2s_rd_ptr(void)
-{
-    unsigned int val;
-    val = READ_MPEG_REG(AIU_MEM_I2S_RD_PTR);
-    return val;
-}
-unsigned int read_iec958_rd_ptr(void)
-{
-    unsigned int val;
-    val = READ_MPEG_REG(AIU_MEM_IEC958_RD_PTR);
-    return val;
-}
-void audio_i2s_unmute(void)
-{
-    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0, 8, 8);
-    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 0, 3, 2);
-}
-
-void audio_i2s_mute(void)
-{
-    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0xff, 8, 8);
-    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 3, 3, 2);
-}
-
-void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
-{
-	WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL,0);
-    WRITE_MPEG_REG(AIU_RST_SOFT,
-                   (slow_domain << 3) | (fast_domain << 2));
-}
-
-void audio_hw_958_raw()
-{
-    if (ENABLE_IEC958) {
-         WRITE_MPEG_REG(AIU_958_MISC, 1);
-         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
-         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
-         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
-    }
-
-    WRITE_MPEG_REG(AIU_958_BPF, IEC958_bpf);
-    WRITE_MPEG_REG(AIU_958_BRST, IEC958_brst);
-    WRITE_MPEG_REG(AIU_958_LENGTH, IEC958_length);
-    WRITE_MPEG_REG(AIU_958_PADDSIZE, IEC958_padsize);
-    WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 2, 2);// disable int
-
-    if(IEC958_mode == 1){ // search in byte
-      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 7, 4, 3);
-    }else if(IEC958_mode == 2) { // search in word
-      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 5, 4, 3);
-    }else{
-      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 4, 3);
-    }
-    WRITE_MPEG_REG(AIU_958_CHSTAT_L0, IEC958_chstat0_l);
-    WRITE_MPEG_REG(AIU_958_CHSTAT_L1, IEC958_chstat1_l);
-    WRITE_MPEG_REG(AIU_958_CHSTAT_R0, IEC958_chstat0_r);
-    WRITE_MPEG_REG(AIU_958_CHSTAT_R1, IEC958_chstat1_r);
-
-    WRITE_MPEG_REG(AIU_958_SYNWORD1, IEC958_syncword1);
-    WRITE_MPEG_REG(AIU_958_SYNWORD2, IEC958_syncword2);
-    WRITE_MPEG_REG(AIU_958_SYNWORD3, IEC958_syncword3);
-    WRITE_MPEG_REG(AIU_958_SYNWORD1_MASK, IEC958_syncword1_mask);
-    WRITE_MPEG_REG(AIU_958_SYNWORD2_MASK, IEC958_syncword2_mask);
-    WRITE_MPEG_REG(AIU_958_SYNWORD3_MASK, IEC958_syncword3_mask);
-
-    printk("%s: %d\n", __func__, __LINE__);
-    printk("\tBPF: %x\n", IEC958_bpf);
-    printk("\tBRST: %x\n", IEC958_brst);
-    printk("\tLENGTH: %x\n", IEC958_length);
-    printk("\tPADDSIZE: %x\n", IEC958_length);
-    printk("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1, IEC958_syncword2, IEC958_syncword3);
-
-}
-
-void set_958_channel_status(_aiu_958_channel_status_t * set)
-{
-    if (set) {
-		WRITE_MPEG_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
-		WRITE_MPEG_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
-		WRITE_MPEG_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
-		WRITE_MPEG_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
-    }
-}
-
-static void audio_hw_set_958_pcm24(_aiu_958_raw_setting_t * set)
-{
-    WRITE_MPEG_REG(AIU_958_BPF, 0x80); /* in pcm mode, set bpf to 128 */
-    set_958_channel_status(set->chan_stat);
-}
-
-void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set)
-{
-    if(mode == AIU_958_MODE_PCM_RAW){
-    	mode = AIU_958_MODE_PCM16; //use 958 raw pcm mode
-       WRITE_MPEG_REG(AIU_958_VALID_CTRL,3);//enable 958 invalid bit	
-    } 
-    else
-	WRITE_MPEG_REG(AIU_958_VALID_CTRL,0);
-    if (mode == AIU_958_MODE_RAW) {
-
-        audio_hw_958_raw();
-        if (ENABLE_IEC958) {
-            WRITE_MPEG_REG(AIU_958_MISC, 1);
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
-        }
-
-        printk("IEC958 RAW\n");
-    }else if(mode == AIU_958_MODE_PCM32){
-        audio_hw_set_958_pcm24(set);
-        if(ENABLE_IEC958){
-            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
-        }
-        printk("IEC958 PCM32 \n");
-    }else if (mode == AIU_958_MODE_PCM24) {
-        audio_hw_set_958_pcm24(set);
-        if (ENABLE_IEC958) {
-            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
-
-        }
-        printk("IEC958 24bit\n");
-    } else if (mode == AIU_958_MODE_PCM16) {
-        audio_hw_set_958_pcm24(set);
-        if (ENABLE_IEC958) {
-            WRITE_MPEG_REG(AIU_958_MISC, 0x2042);
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);  // 16bit
-            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
-
-        }
-        printk("IEC958 16bit\n");
-    }
-    audio_hw_958_reset(0, 1);
-
-    WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 1);
-}
-void audio_out_i2s_enable(unsigned flag)
-{
-    if (flag) {
-        WRITE_MPEG_REG(AIU_RST_SOFT, 0x01);
-        READ_MPEG_REG(AIU_I2S_SYNC);
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
-        // Maybe cause POP noise
-        // audio_i2s_unmute();
-    } else {
-        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
-
-        // Maybe cause POP noise
-        // audio_i2s_mute();
-    }
-    //audio_out_enabled(flag);
-}
-void audio_hw_958_enable(unsigned flag)
-{
-    if (ENABLE_IEC958)
-    {
-    		if(flag){
-        		WRITE_MPEG_REG(AIU_RST_SOFT, 0x04);
-	              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
-	              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
-	              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
-    		}
-		else{
-	             WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
-	             WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);			
-		}	
-    }
-}
-
-unsigned int read_i2s_mute_swap_reg(void)
-{
-	unsigned int val;
-    	val = READ_MPEG_REG(AIU_I2S_MUTE_SWAP);
-    	return val;
-}
-
-void audio_i2s_swap_left_right(unsigned int flag)
-{
-	if (ENABLE_IEC958)
-	{
-		WRITE_MPEG_REG_BITS(AIU_958_CTRL, flag, 1, 2);
-	}
-	WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, flag, 0, 2);
-}
-unsigned int audio_hdmi_init_ready()
-{
-	return 	READ_MPEG_REG_BITS(AIU_HDMI_CLK_DATA_CTRL, 0, 2);
-}
-
-#ifdef CONFIG_ARCH_MESON8
-
-/* power gate control for iec958 audio out */
-unsigned audio_spdifout_pg_enable(unsigned char enable)
-{
-	if(enable){
-			WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);					
-			AUDIO_CLK_GATE_ON(AIU_IEC958);
-			AUDIO_CLK_GATE_ON(AIU_ICE958_AMCLK);
-	}
-	else{
-			AUDIO_CLK_GATE_OFF(AIU_IEC958);
-			AUDIO_CLK_GATE_OFF(AIU_ICE958_AMCLK);	
-			WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);								
-	}
-	return 0;
-}
-/*
-	power gate control for normal aiu  domain including i2s in/out
-	TODO: move i2s out /adc related gate to i2s cpu dai driver 
-*/
-unsigned audio_aiu_pg_enable(unsigned char enable)
-{
-	if(enable){
-		AUDIO_CLK_GATE_ON(AIU_AMCLK_MEASURE);
-		AUDIO_CLK_GATE_ON(AIU_AIFIFO2);
-		AUDIO_CLK_GATE_ON(AIU_AUD_MIXER);
-		AUDIO_CLK_GATE_ON(AIU_MIXER_REG);
-		AUDIO_CLK_GATE_ON(AIU_AI_TOP_GLUE);
-		AUDIO_CLK_GATE_ON(AIU_AOCLK);   		
-		AUDIO_CLK_GATE_ON(AIU_I2S_OUT);
-		AUDIO_CLK_GATE_ON(AIU_ADC);		
-        AUDIO_CLK_GATE_ON(AUD_IN);
-        AUDIO_CLK_GATE_ON(AIU_IEC958);
-        AUDIO_CLK_GATE_ON(AIU_PCLK);
-        AUDIO_CLK_GATE_ON(AIU_ICE958_AMCLK);
-        AUDIO_CLK_GATE_ON(AIU_TOP_LEVEL);
-	}
-	else{
-		AUDIO_CLK_GATE_OFF(AIU_AMCLK_MEASURE);
-		AUDIO_CLK_GATE_OFF(AIU_AIFIFO2);
-		AUDIO_CLK_GATE_OFF(AIU_AUD_MIXER);
-		AUDIO_CLK_GATE_OFF(AIU_MIXER_REG);
-		AUDIO_CLK_GATE_OFF(AIU_AI_TOP_GLUE);
-		AUDIO_CLK_GATE_OFF(AIU_AOCLK);   		
-		AUDIO_CLK_GATE_OFF(AIU_I2S_OUT);
-		AUDIO_CLK_GATE_OFF(AIU_ADC);			
-        AUDIO_CLK_GATE_OFF(AUD_IN);
-        AUDIO_CLK_GATE_OFF(AIU_IEC958);
-        AUDIO_CLK_GATE_OFF(AIU_PCLK);
-        AUDIO_CLK_GATE_OFF(AIU_ICE958_AMCLK);   
-        AUDIO_CLK_GATE_OFF(AIU_TOP_LEVEL);
-	}
-}
-#endif
diff --git a/sound/soc/aml/aml_audio_hw.h b/sound/soc/aml/aml_audio_hw.h
deleted file mode 100755
index 398cb559435e..000000000000
--- a/sound/soc/aml/aml_audio_hw.h
+++ /dev/null
@@ -1,158 +0,0 @@
-#ifndef __AML_AUDIO_HW_H__
-#define __AML_AUDIO_HW_H__
-#include <mach/power_gate.h>
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
-#define AUDIO_CLK_GATE_ON(a)
-#define AUDIO_CLK_GATE_OFF(a)
-#else
-#define AUDIO_CLK_GATE_ON(a) CLK_GATE_ON(a)
-#define AUDIO_CLK_GATE_OFF(a) CLK_GATE_OFF(a)
-#endif
-
-typedef struct {
-    unsigned short pll;
-    unsigned short mux;
-    unsigned short devisor;
-} _aiu_clk_setting_t;
-
-typedef struct {
-    unsigned short chstat0_l;
-    unsigned short chstat1_l;
-    unsigned short chstat0_r;
-    unsigned short chstat1_r;
-} _aiu_958_channel_status_t;
-
-typedef struct {
-    /* audio clock */
-    unsigned short clock;
-    /* analog output */
-    unsigned short i2s_mode;
-    unsigned short i2s_dac_mode;
-    unsigned short i2s_preemphsis;
-    /* digital output */
-    unsigned short i958_buf_start_addr;
-    unsigned short i958_buf_blksize;
-    unsigned short i958_int_flag;
-    unsigned short i958_mode;
-    unsigned short i958_sync_mode;
-    unsigned short i958_preemphsis;
-    unsigned short i958_copyright;
-    unsigned short bpf;
-    unsigned short brst;
-    unsigned short length;
-    unsigned short paddsize;
-    _aiu_958_channel_status_t chan_status;
-} audio_output_config_t;
-
-typedef struct {
-    unsigned short int_flag;
-    unsigned short bpf;
-    unsigned short brst;
-    unsigned short length;
-    unsigned short paddsize;
-    _aiu_958_channel_status_t *chan_stat;
-} _aiu_958_raw_setting_t;
-
-enum {
-	I2SIN_MASTER_MODE = 0,
-	I2SIN_SLAVE_MODE  =   1<<0,
-	SPDIFIN_MODE   = 1<<1,
-};
-enum {
-	AML_AUDIO_NA = 0,	
-	AML_AUDIO_SPDIFIN = 1<<0,
-	AML_AUDIO_SPDIFOUT = 1<<1,
-	AML_AUDIO_I2SIN = 1<<2,
-	AML_AUDIO_I2SOUT = 1<<3,
-	AML_AUDIO_PCMIN = 1<<4,
-	AML_AUDIO_PCMOUT = 1<<5,				
-};
-#define AUDIO_CLK_256FS             0
-#define AUDIO_CLK_384FS             1
-
-#define AUDIO_CLK_FREQ_192  0
-#define AUDIO_CLK_FREQ_1764 1
-#define AUDIO_CLK_FREQ_96   2
-#define AUDIO_CLK_FREQ_882  3
-#define AUDIO_CLK_FREQ_48   4
-#define AUDIO_CLK_FREQ_441  5
-#define AUDIO_CLK_FREQ_32   6
-
-#define AUDIO_CLK_FREQ_8		7
-#define AUDIO_CLK_FREQ_11		8
-#define AUDIO_CLK_FREQ_12		9
-#define AUDIO_CLK_FREQ_16		10
-#define AUDIO_CLK_FREQ_22		11
-#define AUDIO_CLK_FREQ_24		12
-
-
-#define AIU_958_MODE_RAW    0
-#define AIU_958_MODE_PCM16  1
-#define AIU_958_MODE_PCM24  2
-#define AIU_958_MODE_PCM32  3
-#define AIU_958_MODE_PCM_RAW  4
-
-#define AIU_I2S_MODE_PCM16   0
-#define AIU_I2S_MODE_PCM24   2
-#define AIU_I2S_MODE_PCM32   3
-
-#define AUDIO_ALGOUT_DAC_FORMAT_DSP             0
-#define AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY    1
-
-extern unsigned ENABLE_IEC958;
-extern unsigned IEC958_MODE;
-extern unsigned I2S_MODE;
-
-void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
-void audio_set_958outbuf(u32 addr, u32 size, int flag);
-void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode, u32 i2s_sync);
-void audio_in_spdif_set_buf(u32 addr, u32 size);
-void audio_in_i2s_enable(int flag);
-void audio_in_spdif_enable(int flag);
-unsigned int audio_in_i2s_rd_ptr(void);
-unsigned int audio_in_i2s_wr_ptr(void);
-unsigned int audio_in_spdif_wr_ptr(void);
-void audio_set_i2s_mode(u32 mode);
-void audio_set_clk(unsigned freq, unsigned fs_config);
-void audio_set_i2s_clk(unsigned freq, unsigned fs_config);
-void audio_set_958_clk(unsigned freq, unsigned fs_config);
-void audio_enable_ouput(int flag);
-unsigned int read_i2s_rd_ptr(void);
-void audio_i2s_unmute(void);
-void audio_i2s_mute(void);
-void audio_util_set_dac_format(unsigned format);
-void audio_util_set_dac_i2s_format(unsigned format);
-void audio_util_set_dac_958_format(unsigned format);
-void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set);
-unsigned int read_i2s_mute_swap_reg(void);
-void audio_i2s_swap_left_right(unsigned int flag);
-int if_audio_out_enable(void);
-int if_audio_in_i2s_enable(void);
-int if_audio_in_spdif_enable(void);
-void audio_out_i2s_enable(unsigned flag);
-void audio_hw_958_enable(unsigned flag);
-void audio_out_enabled(int flag);
-void audio_util_set_dac_format(unsigned format);
-unsigned int audio_hdmi_init_ready(void);
-unsigned int read_iec958_rd_ptr(void);
-void audio_in_spdif_enable(int flag);
-unsigned audio_spdifout_pg_enable(unsigned char enable);
-unsigned audio_aiu_pg_enable(unsigned char enable);
-
-#include "mach/cpu.h"
-
-/*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-#define OVERCLOCK 0
-#define IEC958_OVERCLOCK 1
-#else
-#define OVERCLOCK 1
-#endif
-
-#if (OVERCLOCK == 1)
-#define MCLKFS_RATIO 512
-#else
-#define MCLKFS_RATIO 256
-#endif
-
-#endif
diff --git a/sound/soc/aml/aml_audio_hw_pcm2bt.c b/sound/soc/aml/aml_audio_hw_pcm2bt.c
deleted file mode 100755
index adfa4bda6574..000000000000
--- a/sound/soc/aml/aml_audio_hw_pcm2bt.c
+++ /dev/null
@@ -1,314 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <mach/am_regs.h>
-#include <linux/clk.h>
-
-#include "aml_audio_hw_pcm2bt.h"
-
-//#define PCM_DEBUG
-
-#ifdef PCM_DEBUG
-#define pcm_debug           pr_info
-#else
-#define pcm_debug(fmt, ...) \
-        do {} while(0)
-#endif
-
-static unsigned int pcmin_buffer_addr = 0;
-static unsigned int pcmin_buffer_size = 0;
-
-static unsigned int pcmout_buffer_addr = 0;
-static unsigned int pcmout_buffer_size = 0;
-
-static void pcm_in_register_show(void)
-{
-    pcm_debug("PCMIN registers show:\n");
-    pcm_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START, READ_MPEG_REG(AUDIN_FIFO1_START));
-    pcm_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END, READ_MPEG_REG(AUDIN_FIFO1_END));
-    pcm_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR, READ_MPEG_REG(AUDIN_FIFO1_PTR));
-    pcm_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR, READ_MPEG_REG(AUDIN_FIFO1_RDPTR));
-    pcm_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL, READ_MPEG_REG(AUDIN_FIFO1_CTRL));
-    pcm_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1, READ_MPEG_REG(AUDIN_FIFO1_CTRL1));
-    pcm_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0, READ_MPEG_REG(PCMIN_CTRL0));
-    pcm_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1, READ_MPEG_REG(PCMIN_CTRL1));
-}
-
-void pcm_in_enable(int flag)
-{
-    /* reset fifo */
-RESET_FIFO:    
-    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1);
-    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
-    if (READ_MPEG_REG(AUDIN_FIFO1_PTR) != READ_MPEG_REG(AUDIN_FIFO1_START))
-        goto RESET_FIFO;
-    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 1, 1);
-
-    /* reset pcmin */
-    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 1, 30, 1);
-    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 30, 1);
-
-    /* disable fifo */
-    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 0, 1);
-
-    /* disable pcmin */
-    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 31, 1);
-
-    if (flag) {
-        /* set buffer start ptr end */
-    	WRITE_MPEG_REG(AUDIN_FIFO1_START, pcmin_buffer_addr);
-    	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
-    	WRITE_MPEG_REG(AUDIN_FIFO1_END, pcmin_buffer_addr + pcmin_buffer_size - 8);
-
-        /* fifo control */
-        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1 << 15) |    // urgent request
-                                         (1 << 11) |    // channel
-                                         (6 << 8) |     // endian
-                                         //(0 << 8) |     // endian
-                                         (2 << 3) |     // PCMIN input selection
-                                         (1 << 2) |     // load address
-                                         (0 << 1) |     // reset fifo
-                                         (1 << 0)       // fifo enable
-                        );
-
-        /* fifo control1 */
-        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1, (0 << 4) |    // data destination DDR
-                                          (1 << 2) |    // 16bits
-                                          (0 << 0)      // data position
-                        );
-
-        /* pcmin control1 */
-        WRITE_MPEG_REG(PCMIN_CTRL1, (0 << 29) |         // external chip
-                                    (0 << 28) |         // external chip
-                                    (1 << 27) |         // using negedge of PCM clock to latch the input data
-                                    (15 << 21) |        // slot bit msb 16 clocks per slot
-                                    (15 << 16) |        // data msb 16bits data
-                                    (1 << 0)            // slot valid
-                        );
-
-        /* pcmin control0 */
-        WRITE_MPEG_REG(PCMIN_CTRL0, (1 << 31) |         // pcmin enable
-                                    (1 << 29) |         // sync on clock posedge
-                                    (0 << 16) |         // FS SKEW
-                                    (0 << 4) |          // waithing 1 system clock cycles then sample the PCMIN singals
-                                    (0 << 3) |          // use clock counter to do the sample
-                                    (0 << 2) |          // fs not inverted. H = left, L = right
-                                    (1 << 1) |          // msb first
-                                    (1 << 0)            // left justified
-                        );
-    }
-
-    pcm_debug("PCMIN %s\n", flag ? "enable" : "disable");
-    pcm_in_register_show();
-}
-
-void pcm_in_set_buf(unsigned int addr, unsigned int size)
-{
-    pcmin_buffer_addr = addr;
-    pcmin_buffer_size = size;
-
-    pcm_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n", pcmin_buffer_addr, pcmin_buffer_size);
-}
-
-int pcm_in_is_enable(void)
-{
-    int value = (READ_MPEG_REG_BITS(PCMIN_CTRL0, 31, 1) & 0x01);
-
-    return value;
-}
-
-unsigned int pcm_in_rd_ptr(void)
-{
-    unsigned int value = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
-    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
-
-    return value;
-}
-
-unsigned int pcm_in_set_rd_ptr(unsigned int value)
-{
-    unsigned int old = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
-    WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, value);
-    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
-
-    return old;
-}
-
-unsigned int pcm_in_wr_ptr(void)
-{
-	unsigned int writing = READ_MPEG_REG(AUDIN_FIFO1_PTR);
-    unsigned int written = 0;
-    unsigned int value = 0;
-
-    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
-	written = READ_MPEG_REG(AUDIN_FIFO1_PTR);
-    pcm_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
-
-    //value = written;
-    value = written & (~0x07);
-    return value;
-}
-
-unsigned int pcm_in_fifo_int(void)
-{
-    unsigned int value = 0;
-    value = READ_MPEG_REG(AUDIN_FIFO_INT);
-    pcm_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
-
-    return value;
-}
-
-static void pcm_out_register_show(void)
-{
-    pcm_debug("PCMOUT registers show:\n");
-    pcm_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA, READ_MPEG_REG(AUDOUT_BUF0_STA));
-    pcm_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA, READ_MPEG_REG(AUDOUT_BUF0_EDA));
-    pcm_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR, READ_MPEG_REG(AUDOUT_BUF0_WPTR));
-    pcm_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR, READ_MPEG_REG(AUDOUT_FIFO_RPTR));
-    pcm_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL, READ_MPEG_REG(AUDOUT_CTRL));
-    pcm_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1, READ_MPEG_REG(AUDOUT_CTRL1));
-    pcm_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0, READ_MPEG_REG(PCMOUT_CTRL0));
-    pcm_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1, READ_MPEG_REG(PCMOUT_CTRL1));
-    pcm_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2, READ_MPEG_REG(PCMOUT_CTRL2));
-    pcm_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3, READ_MPEG_REG(PCMOUT_CTRL3));
-}
-
-void pcm_out_enable(int flag)
-{
-    /* reset fifo */
-    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 1, 30, 1);
-    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 30, 1);
-
-    /* reset pcmout */
-    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 1, 30, 1);
-    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 30, 1);
-
-    /* disable fifo */
-    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 31, 1);
-
-    /* disable pcmout */
-    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 31, 1);
-
-    if (flag) {
-        /* set buffer start ptr end */
-    	WRITE_MPEG_REG(AUDOUT_BUF0_STA, pcmout_buffer_addr);
-    	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
-    	WRITE_MPEG_REG(AUDOUT_BUF0_EDA, pcmout_buffer_addr + pcmout_buffer_size - 8);
-
-        /* fifo control */
-        WRITE_MPEG_REG(AUDOUT_CTRL, (0 << 31) |     // fifo enable
-                                    (0 << 30) |     // soft reset
-                                    (1 << 29) |     // load address
-                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
-                                    (52 << 15) |    // data request size
-                                    (64 << 8) |     // buffer level to keep
-                                    (0 << 7) |      // buffer level control
-                                    (1 << 6) |      // DMA mode
-                                    (1 << 5) |      // circular buffer
-                                    (0 << 4) |      // use register set 0 always
-                                    (1 << 3) |       // urgent request
-                                    (6 << 0)         //endian
-                        );
-
-        WRITE_MPEG_REG(AUDOUT_CTRL, (1 << 31) |     // fifo enable
-                                    (0 << 30) |     // soft reset
-                                    (0 << 29) |     // load address
-                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
-                                    (52 << 15) |    // data request size
-                                    (64 << 8) |     // buffer level to keep
-                                    (0 << 7) |      // buffer level control
-                                    (1 << 6) |      // DMA mode
-                                    (1 << 5) |      // circular buffer
-                                    (0 << 4) |      // use register set 0 always
-                                    (1 << 3) |       // urgent request
-                                    (6 << 0)         //endian
-                                    
-                        );
-        /* pcmout control3 */
-        WRITE_MPEG_REG(PCMOUT_CTRL3, 0);            // mute constant
-
-        /* pcmout control2 */
-        WRITE_MPEG_REG(PCMOUT_CTRL2,(0 << 29) |     // underrun use mute constant
-                                    (0 << 22) |     // 1 channel per frame
-                                    (15 << 16) |    // 16 bits per slot
-                                    (1 << 0)        // enable 1 slot
-                        );
-
-        /* pcmout control1 */
-        WRITE_MPEG_REG(PCMOUT_CTRL1,(1 << 30) |     // data byte numbe n - 1?
-                                    (0 << 28) |     // use posedge of PCM clock to output data
-                                    (1 << 27)       // use negedge of pcm clock to check the fs
-                        );
-
-        /* pcmout control0 */
-        WRITE_MPEG_REG(PCMOUT_CTRL0,(1 << 31) |     // enable
-                                    (0 << 29) |     // slave
-                                    (1 << 28) |     // sync on clock rising edge
-                                    (0 << 27) |     // data sample mode
-                                    (1 << 15) |     // sync on 4 system clock later ?
-                                    (1 << 14) |     // msb first
-                                    (1 << 13) |     // left justified
-                                    (0 << 12) |     // data position
-                                    (3 << 6) |      // sync fs with the slot bit counter.
-                                    (0 << 0)        // sync fs with frame slot counter.
-                        );
-    }
-
-    pcm_debug("PCMOUT %s\n", flag ? "enable" : "disable");
-    pcm_out_register_show();
-}
-
-void pcm_out_mute(int flag)
-{
-    int value = flag ? 1: 0;
-    WRITE_MPEG_REG_BITS(PCMOUT_CTRL2, value, 31, 1);
-}
-
-void pcm_out_set_buf(unsigned int addr, unsigned int size)
-{
-    pcmout_buffer_addr = addr;
-    pcmout_buffer_size = size;
-
-    pcm_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n", pcmout_buffer_addr, pcmout_buffer_size);
-}
-
-int pcm_out_is_enable(void)
-{
-    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL0, 31, 1) & 0x01);
-
-    return value;
-}
-
-int  pcm_out_is_mute(void)
-{
-    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL2, 31, 1) & 0x01);
-
-    return value;
-}
-
-unsigned int pcm_out_rd_ptr(void)
-{
-    unsigned int value = READ_MPEG_REG(AUDOUT_FIFO_RPTR);
-    pcm_debug("PCMOUT read pointer: 0x%08x\n", value);
-
-    return value;
-}
-
-unsigned int pcm_out_wr_ptr(void)
-{
-    unsigned int value = 0;
- 	value = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
-    pcm_debug("PCMOUT write pointer: 0x%08x\n", value);
-    return value;
-}
-
-unsigned int pcm_out_set_wr_ptr(unsigned int value)
-{
-    unsigned int old = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
- 	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, value);
-    pcm_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
-
-    return old;
-}
-
diff --git a/sound/soc/aml/aml_audio_hw_pcm2bt.h b/sound/soc/aml/aml_audio_hw_pcm2bt.h
deleted file mode 100755
index 4afc8d6a6425..000000000000
--- a/sound/soc/aml/aml_audio_hw_pcm2bt.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#ifndef __AML_PCM_HW_H__
-#define __AML_PCM_HW_H__
-
-void pcm_in_enable(int flag);
-void pcm_in_set_buf(unsigned int addr, unsigned int size);
-int  pcm_in_is_enable(void);
-unsigned int pcm_in_rd_ptr(void);
-unsigned int pcm_in_wr_ptr(void);
-unsigned int pcm_in_set_rd_ptr(unsigned int value);
-unsigned int pcm_in_fifo_int(void);
-
-void pcm_out_enable(int flag);
-void pcm_out_mute(int flag);
-void pcm_out_set_buf(unsigned int addr, unsigned int size);
-int  pcm_out_is_enable(void);
-int  pcm_out_is_mute(void);
-unsigned int pcm_out_rd_ptr(void);
-unsigned int pcm_out_wr_ptr(void);
-unsigned int pcm_out_set_wr_ptr(unsigned int value);
-
-#endif
diff --git a/sound/soc/aml/aml_i2s.c b/sound/soc/aml/aml_i2s.c
deleted file mode 100755
index feab7d136b70..000000000000
--- a/sound/soc/aml/aml_i2s.c
+++ /dev/null
@@ -1,1140 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/ioctl.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/soundcard.h>
-#include <linux/timer.h>
-#include <linux/hrtimer.h>
-#include <linux/debugfs.h>
-#include <linux/major.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/control.h>
-#include <sound/soc.h>
-#include <sound/pcm_params.h>
-#include <linux/amlogic/rt5631.h>
-
-#include <mach/am_regs.h>
-#include <mach/pinmux.h>
-
-#include <linux/amlogic/amports/amaudio.h>
-
-#include <mach/mod_gate.h>
-
-#include "aml_i2s.h"
-#include "aml_audio_hw.h"
-#define USE_HRTIMER 0
-#define HRTIMER_PERIOD (1000000000UL/1000)
-//#define DEBUG_ALSA_PLATFRORM
-
-#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-platform]" fmt,##args)
-#ifdef DEBUG_ALSA_PLATFRORM
-#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-platform]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-platform] enter func %s,line %d\n",__FUNCTION__,__LINE__);
-#else
-#define ALSA_DEBUG(fmt,args...) 
-#define ALSA_TRACE()   
-#endif
-
-
-unsigned int aml_i2s_playback_start_addr = 0;
-unsigned int aml_i2s_capture_start_addr  = 0;
-
-unsigned int aml_i2s_playback_end_addr = 0;
-unsigned int aml_i2s_capture_end_addr = 0;
-
-unsigned int aml_i2s_capture_start_phy = 0;
-unsigned int aml_i2s_capture_buf_size = 0;
-unsigned int aml_i2s_playback_phy_start_addr = 0;
-unsigned int aml_i2s_capture_phy_start_addr  = 0;
-unsigned int aml_i2s_playback_phy_end_addr = 0;
-unsigned int aml_i2s_capture_phy_end_addr = 0;
-unsigned int aml_i2s_playback_off = 0;
-unsigned int aml_i2s_playback_enable = 1;
-
-unsigned int aml_iec958_playback_start_addr = 0;
-unsigned int aml_iec958_playback_start_phy = 0;
-unsigned int aml_iec958_playback_size = 0;  // in bytes
-
-
-static int audio_type_info = -1;
-static int audio_sr_info = -1;
-extern unsigned audioin_mode;
-
-static DEFINE_MUTEX(gate_mutex);
-static unsigned audio_gate_status = 0;
-
-EXPORT_SYMBOL(aml_i2s_playback_start_addr);
-EXPORT_SYMBOL(aml_i2s_capture_start_addr);
-EXPORT_SYMBOL(aml_i2s_playback_off);
-EXPORT_SYMBOL(aml_i2s_playback_enable);
-
-
-/*--------------------------------------------------------------------------*\
- * Hardware definition
-\*--------------------------------------------------------------------------*/
-/* TODO: These values were taken from the AML platform driver, check
- *	 them against real values for AML
- */
-static const struct snd_pcm_hardware aml_i2s_hardware = {
-	.info			= SNDRV_PCM_INFO_INTERLEAVED|
-							SNDRV_PCM_INFO_BLOCK_TRANSFER|
-							SNDRV_PCM_INFO_PAUSE,
-
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE,
-
-	.period_bytes_min	= 64,
-	.period_bytes_max	= 32 * 1024,
-	.periods_min		= 2,
-	.periods_max		= 1024,
-	.buffer_bytes_max	= 128 * 1024,
-
-	.rate_min = 8000,
-	.rate_max = 48000,
-	.channels_min = 2,
-	.channels_max = 8,
-	.fifo_size = 0,
-};
-
-static const struct snd_pcm_hardware aml_i2s_capture = {
-	.info			= SNDRV_PCM_INFO_INTERLEAVED|
-							SNDRV_PCM_INFO_BLOCK_TRANSFER|
-							SNDRV_PCM_INFO_MMAP |
-						 	SNDRV_PCM_INFO_MMAP_VALID |
-						  SNDRV_PCM_INFO_PAUSE,
-
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
-	.period_bytes_min	= 64,
-	.period_bytes_max	= 32 * 1024,
-	.periods_min		= 2,
-	.periods_max		= 1024,
-	.buffer_bytes_max	= 64 * 1024,
-
-	.rate_min = 8000,
-	.rate_max = 48000,
-	.channels_min = 2,
-	.channels_max = 8,
-	.fifo_size = 0,
-};
-
-static char snd_i2s_tmp[32*1024];
-
-
-static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
-
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
-	.count = ARRAY_SIZE(period_sizes),
-	.list = period_sizes,
-	.mask = 0
-};
-
-/*--------------------------------------------------------------------------*/
-/*--------------------------------------------------------------------------*\
- * Helper functions
-\*--------------------------------------------------------------------------*/
-static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
-	int stream)
-{
-	ALSA_TRACE();
-	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;
-
-	size_t size = 0;
-	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		    size = aml_i2s_hardware.buffer_bytes_max;
-		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		    buf->dev.dev = pcm->card->dev;
-		    buf->private_data = NULL;
-            /* one size for i2s output, another for 958, and 128 for alignment */
-		    buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
-					  &buf->addr, GFP_KERNEL);
-		    printk("aml-i2s %d:"
-		    "playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
-		    (void *) buf->area,
-		    (void *) buf->addr,
-		    size);
-        }else{
-
-		size = aml_i2s_capture.buffer_bytes_max;
-		buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		buf->dev.dev = pcm->card->dev;
-		buf->private_data = NULL;
-		buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
-					  &buf->addr, GFP_KERNEL);
-		    printk("aml-i2s %d:"
-		    "capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
-		    (void *) buf->area,
-		    (void *) buf->addr,
-		    size);
-	    }
-
-	    if (!buf->area)
-		    return -ENOMEM;
-    
-	    buf->bytes = size;
-	    return 0;
-
-}
-/*--------------------------------------------------------------------------*\
- * ISR
-\*--------------------------------------------------------------------------*/
-
-
-/*--------------------------------------------------------------------------*\
- * i2s operations
-\*--------------------------------------------------------------------------*/
-static int aml_i2s_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-//	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
-	audio_stream_t *s = &prtd->s;
-
-	/* this may get called several times by oss emulation
-	 * with different params */
-
-	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
-	runtime->dma_bytes = params_buffer_bytes(params);
-	ALSA_PRINT("runtime dma_bytes %d,stream type \n",runtime->dma_bytes,substream->stream);
-	s->I2S_addr = runtime->dma_addr;
-
-    /*
-     * Both capture and playback need to reset the last ptr to the start address,
-       playback and capture use different address calculate, so we reset the different
-       start address to the last ptr
-   * */
-    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-        /* s->last_ptr must initialized as dma buffer's start addr */
-        s->last_ptr = runtime->dma_addr;
-    }else{
-
-	s->last_ptr = 0;
-    }
-
-	return 0;
-}
-
-static int aml_i2s_hw_free(struct snd_pcm_substream *substream)
-{
-	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	struct aml_i2s_dma_params *params = prtd->params;
-	if (params != NULL) {
-
-	}
-
-	return 0;
-}
-
-
-static int aml_i2s_prepare(struct snd_pcm_substream *substream)
-{
-	ALSA_TRACE();
-	return 0;
-}
-
-static int aml_i2s_trigger(struct snd_pcm_substream *substream,
-	int cmd)
-{
-	ALSA_TRACE();
-	struct snd_pcm_runtime *rtd = substream->runtime;
-	struct aml_runtime_data *prtd = rtd->private_data;
-	audio_stream_t *s = &prtd->s;
-	int ret = 0;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:		
-
-#if USE_HRTIMER == 0
-	  del_timer_sync(&prtd->timer);
-#endif      
-	  spin_lock(&s->lock);
-#if USE_HRTIMER == 0
-	  prtd->timer.expires = jiffies + 1;
-	  del_timer(&prtd->timer);
-	  add_timer(&prtd->timer);
-#endif
-
-	  s->active = 1;
-	  spin_unlock(&s->lock);
-	  break;		/* SNDRV_PCM_TRIGGER_START */
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-	case SNDRV_PCM_TRIGGER_STOP:
-		// TODO
-	    spin_lock(&s->lock);
-	    s->active = 0;
-	    spin_unlock(&s->lock);
-	    break;
-	default:
-		ret = -EINVAL;
-	}
-/*	if(clock_gating_status&clock_gating_playback){
-		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			aml_pcm_work.substream = substream;
-	}
-	else
-		aml_pcm_work.substream = substream;
-
-
-	if(clock_gating_status)
-	{
-		schedule_work(&aml_pcm_work.aml_codec_workqueue);
-	}
-	*/
-	//schedule_work(&aml_pcm_work.aml_codec_workqueue);
-	return ret;
-}
-
-static snd_pcm_uframes_t aml_i2s_pointer(
-	struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;
-
-	unsigned int addr, ptr;
-
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		if(s->device_type == AML_AUDIO_I2SOUT)
-			ptr = read_i2s_rd_ptr();
-		else
-			ptr = read_iec958_rd_ptr();
-	    addr = ptr - s->I2S_addr;
-	    return bytes_to_frames(runtime, addr);
-	}else{
-		if(s->device_type == AML_AUDIO_I2SIN)
-			ptr = audio_in_i2s_wr_ptr();
-		else
-			ptr = audio_in_spdif_wr_ptr();				
-			addr = ptr - s->I2S_addr;
-			return bytes_to_frames(runtime, addr)/2;
-	}
-
-	return 0;
-}	
-static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
-{
-  struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
-  audio_stream_t* s = &prtd->s;
-  struct snd_pcm_substream* substream = prtd->substream;
-  struct snd_pcm_runtime* runtime= substream->runtime;
-  
-  unsigned int last_ptr, size;
-  unsigned long flag;
-  //printk("------------->hrtimer start\n");
-  if(s->active == 0){
-    hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-    return HRTIMER_RESTART;
-  }
-  //spin_lock_irqsave(&s->lock, flag);
-
-  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-      last_ptr = read_i2s_rd_ptr();
-      if(last_ptr < s->last_ptr){
-        size = runtime->dma_bytes + last_ptr - s->last_ptr;
-      }else{
-        size = last_ptr - s->last_ptr;
-      }
-      s->last_ptr = last_ptr;
-      s->size += bytes_to_frames(substream->runtime, size);
-      if(s->size >= runtime->period_size){
-        s->size %= runtime->period_size;
-        snd_pcm_period_elapsed(substream);
-      }
-  }else{
-      last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) /2;
-      if(last_ptr < s->last_ptr){
-        size = runtime->dma_bytes + last_ptr - s->last_ptr;
-      }else{
-        size = last_ptr - s->last_ptr;
-      }
-      s->last_ptr = last_ptr;
-      s->size += bytes_to_frames(runtime, size);
-      if(s->size >= runtime->period_size){
-        s->size %= runtime->period_size;
-        snd_pcm_period_elapsed(substream);
-      }
-  }
-  //spin_unlock_irqrestore(&s->lock, flag);
-  hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
-  return HRTIMER_RESTART;
-}
-
-static void aml_i2s_timer_callback(unsigned long data)
-{
-    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_runtime_data *prtd = runtime->private_data;
-		audio_stream_t *s = &prtd->s;
-
-    unsigned int last_ptr, size;
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-	{
-		if(s->active == 1)
-		{
-			spin_lock(&s->lock);
-			if(s->device_type == AML_AUDIO_I2SOUT)
-				last_ptr = read_i2s_rd_ptr();
-			else
-				last_ptr = read_iec958_rd_ptr();							
-						if (last_ptr < s->last_ptr) {
-				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
-				    } else {
-				        size = last_ptr - (s->last_ptr);
-				    }
-    				s->last_ptr = last_ptr;
-    				s->size += bytes_to_frames(substream->runtime, size);
-    				if (s->size >= runtime->period_size) {
-				        s->size %= runtime->period_size;
-				        spin_unlock(&s->lock);
-				        snd_pcm_period_elapsed(substream);
-				        spin_lock(&s->lock);
-				    }
-				    mod_timer(&prtd->timer, jiffies + 1);
-   					spin_unlock(&s->lock);
-				}else{
-						 mod_timer(&prtd->timer, jiffies + 1);
-				}
-		}
-	else
-	{
-		if(s->active == 1)
-		{
-			spin_lock(&s->lock);
-			if(s->device_type == AML_AUDIO_I2SIN)			
-				last_ptr = audio_in_i2s_wr_ptr() ;
-			else
-				last_ptr = audio_in_spdif_wr_ptr();				
-			if (last_ptr < s->last_ptr) {
-				size = runtime->dma_bytes + (last_ptr - (s->last_ptr))/2;
-			} else {
-				size = (last_ptr - (s->last_ptr))/2;
-			}
-			s->last_ptr = last_ptr;
-			s->size += bytes_to_frames(substream->runtime, size);
-			if (s->size >= runtime->period_size) {
-				s->size %= runtime->period_size;
-				spin_unlock(&s->lock);
-				snd_pcm_period_elapsed(substream);
-				spin_lock(&s->lock);
-			}
-			mod_timer(&prtd->timer, jiffies + 1);
-			spin_unlock(&s->lock);
-		}
-		else
-		{
-			mod_timer(&prtd->timer, jiffies + 1);
-		}
-	}
-}
-
-static int num_clk_gate = 0;
-static int aml_i2s_open(struct snd_pcm_substream *substream)
-{
-	ALSA_TRACE();
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s ;		
-	int ret = 0;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		snd_soc_set_runtime_hwparams(substream, &aml_i2s_hardware);
-	}else{
-		snd_soc_set_runtime_hwparams(substream, &aml_i2s_capture);
-	}
-
-    /* ensure that peroid size is a multiple of 32bytes */
-	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
-	if (ret < 0)
-	{
-		printk("set period bytes constraint error\n");
-		goto out;
-	}
-
-	/* ensure that buffer size is a multiple of period size */
-	ret = snd_pcm_hw_constraint_integer(runtime,
-						SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret < 0)
-	{
-		printk("set period error\n");
-		goto out;
-	}
-	if(!prtd){
-		prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
-		if (prtd == NULL) {
-			printk("alloc aml_runtime_data error\n");
-			ret = -ENOMEM;
-			goto out;
-		}
-		prtd->substream = substream;
-		runtime->private_data = prtd;
-	}
-//	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);
-#if USE_HRTIMER == 0    
-	prtd->timer.function = &aml_i2s_timer_callback;
-	prtd->timer.data = (unsigned long)substream;
-	init_timer(&prtd->timer);
-#else
-    hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-    prtd->hrtimer.function = aml_i2s_hrtimer_callback;
-    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
-
-
-    printk("hrtimer inited..\n");
-#endif
-
-	spin_lock_init(&prtd->s.lock);
-	s= &prtd->s;
-	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
-	mutex_lock(&gate_mutex);
-#ifdef CONFIG_ARCH_MESON8
-	if(audio_gate_status == 0){
-		audio_aiu_pg_enable(1);
-		ALSA_DEBUG("aml_pcm_open  device type %x \n", s->device_type);
-		
-	}
-#endif
-	audio_gate_status  |= s->device_type;
-	mutex_unlock(&gate_mutex);		
- out:
-	return ret;
-}
-
-static int aml_i2s_close(struct snd_pcm_substream *substream)
-{
-	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	audio_stream_t *s = &prtd->s;	
-	ALSA_TRACE();
-	mutex_lock(&gate_mutex);
-	audio_gate_status  &= ~s->device_type;
-#ifdef CONFIG_ARCH_MESON8
-	if(audio_gate_status == 0){
-		ALSA_DEBUG("aml_pcm_close  device type %x \n", s->device_type);		
-		//audio_aiu_pg_enable(0);
-	}
-#endif
-	mutex_unlock(&gate_mutex);		
-//	if(s->device_type == AML_AUDIO_SPDIFOUT)
-//		WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);			
-#if USE_HRTIMER == 0
-	del_timer_sync(&prtd->timer);
-#else
-    hrtimer_cancel(&prtd->hrtimer);
-#endif
-	if(prtd)
-		kfree(prtd);
-	return 0;
-}
-
-
-static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
-{
-    int res = 0;
-    int n;
-    int i = 0, j = 0;
-    int  align = runtime->channels * 32 / runtime->byte_align;
-    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
-    n = frames_to_bytes(runtime, count);
-    if(aml_i2s_playback_enable == 0)
-      return res;
-	if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count)))
-	{
-		if(1/*runtime->channels == 2*/){
-			if(runtime->format == SNDRV_PCM_FORMAT_S16_LE ){
-        int16_t * tfrom, *to, *left, *right;
-        tfrom = (int16_t*)buf;
-        to = (int16_t*)hwbuf;
-
-        left = to;
-		right = to + 16;
-		if (pos % align) {
-		    printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-		}
-		for (j = 0; j < n; j += 64) {
-		    for (i = 0; i < 16; i++) {
-	          *left++ = (*tfrom++) ;
-	          *right++ = (*tfrom++);
-		    }
-		    left += 16;
-		    right += 16;
-		 }
-      }else if(runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24){
-        int32_t *tfrom, *to, *left, *right;
-        tfrom = (int32_t*)buf;
-        to = (int32_t*) hwbuf;
-
-        left = to;
-        right = to + 8;
-
-        if(pos % align){
-          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-        }
-        for(j=0; j< n; j+= 64){
-          for(i=0; i<8; i++){
-            *left++  =  (*tfrom ++);
-            *right++  = (*tfrom ++);
-          }
-          left += 8;
-          right += 8;
-        }
-
-      }else if(runtime->format == SNDRV_PCM_FORMAT_S32_LE && I2S_MODE == AIU_I2S_MODE_PCM32){
-        int32_t *tfrom, *to, *left, *right;
-        tfrom = (int32_t*)buf;
-        to = (int32_t*) hwbuf;
-
-        left = to;
-        right = to + 8;
-
-        if(pos % align){
-          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
-        }
-		
-		if(runtime->channels == 8){
-			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-			lf  = to;
-			cf  = to + 8*1;
-			rf  = to + 8*2;
-			ls  = to + 8*3;
-			rs  = to + 8*4;
-			lef = to + 8*5;
-			sbl = to + 8*6;
-			sbr = to + 8*7;
-			for (j = 0; j < n; j += 256) {
-		    	for (i = 0; i < 8; i++) {
-	         		*lf++  = (*tfrom ++)>>8;
-	          		*cf++  = (*tfrom ++)>>8;
-					*rf++  = (*tfrom ++)>>8;
-					*ls++  = (*tfrom ++)>>8;
-					*rs++  = (*tfrom ++)>>8;
-					*lef++ = (*tfrom ++)>>8;
-					*sbl++ = (*tfrom ++)>>8;
-					*sbr++ = (*tfrom ++)>>8;
-		    	}
-		    	lf  += 7*8;
-		    	cf  += 7*8;
-				rf  += 7*8;
-				ls  += 7*8;
-				rs  += 7*8;
-				lef += 7*8;
-				sbl += 7*8;
-				sbr += 7*8;
-		 	}
-		}
-		else {
-        for(j=0; j< n; j+= 64){
-          for(i=0; i<8; i++){
-            *left++  =  (*tfrom ++)>>8;
-            *right++  = (*tfrom ++)>>8;
-          }
-          left += 8;
-          right += 8;
-        }
-      	}
-      }
-
-	}else{
-	  res = -EFAULT;
-	}
-
-	return res;
-    }
-}
-
-
-static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
-{
-		unsigned int *tfrom, *left, *right;
-		unsigned short *to;
-		int res = 0;
-		int n;
-    int i = 0, j = 0;
-    unsigned int t1, t2;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;	   
-    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
-    unsigned char r_shift = 8;	
-	if(s->device_type == AML_AUDIO_SPDIFIN) //spdif in
-    {
-    	r_shift = 12;
-    }
-    to = (unsigned short *)snd_i2s_tmp;//buf;
-    tfrom = (unsigned int *)hwbuf;	// 32bit buffer
-    n = frames_to_bytes(runtime, count);
-    if(n > 32*1024){
-		printk("Too many datas to read,please enlarge the snd_i2s_tmp buffer size\n");
-      return -EINVAL;
-    }
-	if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count)))
-	{
-		if(runtime->channels == 2){
-				left = tfrom;
-		    right = tfrom + 8;
-		    if (pos % 8) {
-		        printk("audio data unligned\n");
-		    }
-		    if((n*2)%64){
-		    		printk("audio data unaligned 64 bytes\n");
-		    }
-		    for (j = 0; j < n*2 ; j += 64) {
-		        for (i = 0; i < 8; i++) {
-		        	t1 = (*left++);
-		        	t2 = (*right++);
-		        	//printk("%08x,%08x,", t1, t2);
-	              *to++ = (unsigned short)((t1>>r_shift)&0xffff);
-	           //   *to++ = (unsigned short)((t1>>8)&0xffff);//copy left channel to right
-	              *to++ = (unsigned short)((t2>>r_shift)&0xffff);
-		         }
-		         //printk("\n");
-		        left += 8;
-		        right += 8;
-			}
-		}
-		else{
-		    }
-		}
-        res = copy_to_user(buf, snd_i2s_tmp,n);
-		return res;
-}
-
-static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
-		    snd_pcm_uframes_t pos,
-		    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    int ret = 0;
-
- 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
- 		ret = aml_i2s_copy_playback(runtime, channel,pos, buf, count);
- 	}else{
- 		ret = aml_i2s_copy_capture(runtime, channel,pos, buf, count);
- 	}
-    return ret;
-}
-
-int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
-		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
-{
-	ALSA_TRACE();
-		char* ppos;
-		int n;
-		struct snd_pcm_runtime *runtime = substream->runtime;
-
-		n = frames_to_bytes(runtime, count);
-		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
-		memset(ppos, 0, n);
-		return 0;
-}
-
-static struct snd_pcm_ops aml_i2s_ops = {
-	.open		= aml_i2s_open,
-	.close		= aml_i2s_close,
-	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= aml_i2s_hw_params,
-	.hw_free	= aml_i2s_hw_free,
-	.prepare	= aml_i2s_prepare,
-	.trigger	= aml_i2s_trigger,
-	.pointer	= aml_i2s_pointer,
-	.copy 		= aml_i2s_copy,
-	.silence	=	aml_i2s_silence,
-};
-
-
-/*--------------------------------------------------------------------------*\
- * ASoC platform driver
-\*--------------------------------------------------------------------------*/
-static u64 aml_i2s_dmamask = 0xffffffff;
-
-static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
-{
-	ALSA_TRACE();
-	int ret = 0;
-       struct snd_soc_card *card = rtd->card;
-       struct snd_pcm *pcm =rtd->pcm ;  
-	if (!card->dev->dma_mask)
-		card->dev->dma_mask = &aml_i2s_dmamask;
-	if (!card->dev->coherent_dma_mask)
-		card->dev->coherent_dma_mask = 0xffffffff;
-
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
-		ret = aml_i2s_preallocate_dma_buffer(pcm,
-			SNDRV_PCM_STREAM_PLAYBACK);
-		if (ret)
-			goto out;
-	}
-
-	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		pr_debug("aml-i2s:"
-				"Allocating i2s capture DMA buffer\n");
-		ret = aml_i2s_preallocate_dma_buffer(pcm,
-			SNDRV_PCM_STREAM_CAPTURE);
-		if (ret)
-			goto out;
-	}
-
- out:
-	return ret;
-}
-
-static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
-{
-	ALSA_TRACE();
-	struct snd_pcm_substream *substream;
-	struct snd_dma_buffer *buf;
-	int stream;
-	for (stream = 0; stream < 2; stream++) {
-		substream = pcm->streams[stream].substream;
-		if (!substream)
-			continue;
-
-		buf = &substream->dma_buffer;
-		if (!buf->area)
-			continue;
-		dma_free_coherent(pcm->card->dev, buf->bytes,
-				  buf->area, buf->addr);
-		buf->area = NULL;
-	}
-}
-
-#ifdef CONFIG_PM
-static int aml_i2s_suspend(struct snd_soc_dai *dai)
-{
-	struct snd_pcm_runtime *runtime = dai->runtime;
-	struct aml_runtime_data *prtd;
-	struct aml_i2s_dma_params *params;
-	if (!runtime)
-		return 0;
-
-	prtd = runtime->private_data;
-	params = prtd->params;
-
-	/* disable the PDC and save the PDC registers */
-	// TODO
-	printk("aml i2s suspend\n");
-
-	return 0;
-}
-
-static int aml_i2s_resume(struct snd_soc_dai *dai)
-{
-	struct snd_pcm_runtime *runtime = dai->runtime;
-	struct aml_runtime_data *prtd;
-	struct aml_i2s_dma_params *params;
-	if (!runtime)
-		return 0;
-
-	prtd = runtime->private_data;
-	params = prtd->params;
-
-	/* restore the PDC registers and enable the PDC */
-	// TODO
-	printk("aml i2s resume\n");
-	return 0;
-}
-#else
-#define aml_i2s_suspend	NULL
-#define aml_i2s_resume	NULL
-#endif
-
-#ifdef CONFIG_DEBUG_FS
-
-static struct dentry *debugfs_root;
-static struct dentry *debugfs_regs;
-static struct dentry *debugfs_mems;
-
-static int regs_open_file(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-/**
- *	cat regs
- */
-static ssize_t regs_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = sprintf(buf, "Usage: \n"
-										 "	echo base reg val >regs\t(set the register)\n"
-										 "	echo base reg >regs\t(show the register)\n"
-										 "	base -> c(cbus), x(aix), p(apb), h(ahb) \n"
-									);
-
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-	kfree(buf);
-
-	return ret;
-}
-
-static int read_regs(char base, int reg)
-{
-	int val = 0;
-	switch(base){
-		case 'c':
-			val = READ_CBUS_REG(reg);
-			break;
-		case 'x':
-			val = READ_AXI_REG(reg);
-			break;
-		case 'p':
-			val = READ_APB_REG(reg);
-			break;
-		case 'h':
-			//val = READ_AHB_REG(reg);
-			break;
-		default:
-			break;
-	};
-	printk("\tReg %x = %x\n", reg, val);
-	return val;
-}
-
-static void write_regs(char base, int reg, int val)
-{
-	switch(base){
-		case 'c':
-			WRITE_CBUS_REG(reg, val);
-			break;
-		case 'x':
-			WRITE_AXI_REG(reg, val);
-			break;
-		case 'p':
-			WRITE_APB_REG(reg, val);
-			break;
-		case 'h':
-			//WRITE_AHB_REG(reg, val);
-			break;
-		default:
-			break;
-	};
-	printk("Write reg:%x = %x\n", reg, val);
-}
-static ssize_t regs_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[32];
-	int buf_size = 0;
-	char *start = buf;
-	unsigned long reg, value;
-	char base;
-
-	buf_size = min(count, (sizeof(buf)-1));
-
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-	while (*start == ' ')
-		start++;
-
-	base = *start;
-	start ++;
-	if(!(base =='c' || base == 'x' || base == 'p' || base == 'h')){
-		return -EINVAL;
-	}
-
-	while (*start == ' ')
-		start++;
-
-	reg = simple_strtoul(start, &start, 16);
-
-	while (*start == ' ')
-		start++;
-
-	if (strict_strtoul(start, 16, &value))
-	{
-			read_regs(base, reg);
-			return -EINVAL;
-	}
-
-	write_regs(base, reg, value);
-
-	return buf_size;
-}
-
-static const struct file_operations regs_fops = {
-	.open = regs_open_file,
-	.read = regs_read_file,
-	.write = regs_write_file,
-};
-
-static int mems_open_file(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-static ssize_t mems_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = sprintf(buf, "Usage: \n"
-										 "	echo vmem >mems\t(read 64 bytes from vmem)\n"
-										 "	echo vmem val >mems (write int value to vmem\n"
-									);
-
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-	kfree(buf);
-
-	return ret;
-}
-
-static ssize_t mems_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[256];
-	int buf_size = 0;
-	char *start = buf;
-	unsigned long mem, value;
-	int i=0;
-	unsigned* addr = 0;
-
-	buf_size = min(count, (sizeof(buf)-1));
-
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	while (*start == ' ')
-		start++;
-
-	mem = simple_strtoul(start, &start, 16);
-
-	while (*start == ' ')
-		start++;
-
-	if (strict_strtoul(start, 16, &value))
-	{
-			addr = (unsigned*)mem;
-			printk("%p: ", addr);
-			for(i = 0; i< 8; i++){
-				printk("%08x, ", addr[i]);
-			}
-			printk("\n");
-			return -EINVAL;
-	}
-	addr = (unsigned*)mem;
-	printk("%p: %08x\n", addr, *addr);
-	*addr = value;
-	printk("%p: %08x^\n", addr, *addr);
-
-	return buf_size;
-}
-static const struct file_operations mems_fops={
-	.open = mems_open_file,
-	.read = mems_read_file,
-	.write = mems_write_file,
-};
-
-static void aml_i2s_init_debugfs(void)
-{
-	    debugfs_root = debugfs_create_dir("aml",NULL);
-		if (IS_ERR(debugfs_root) || !debugfs_root) {
-			printk("aml: Failed to create debugfs directory\n");
-			debugfs_root = NULL;
-		}
-
-		debugfs_regs = debugfs_create_file("regs", 0644, debugfs_root, NULL, &regs_fops);
-		if(!debugfs_regs){
-			printk("aml: Failed to create debugfs file\n");
-		}
-
-		debugfs_mems = debugfs_create_file("mems", 0644, debugfs_root, NULL, &mems_fops);
-		if(!debugfs_mems){
-			printk("aml: Failed to create debugfs file\n");
-		}
-}
-static void aml_i2s_cleanup_debugfs(void)
-{
-	debugfs_remove_recursive(debugfs_root);
-}
-#else
-static void aml_i2s_init_debugfs(void)
-{
-}
-static void aml_i2s_cleanup_debugfs(void)
-{
-}
-#endif
-
-struct snd_soc_platform_driver aml_soc_platform = {
-	.ops 	= &aml_i2s_ops,
-	.pcm_new	= aml_i2s_new,
-	.pcm_free	= aml_i2s_free_dma_buffers,
-	.suspend	= aml_i2s_suspend,
-	.resume		= aml_i2s_resume,
-};
-
-EXPORT_SYMBOL_GPL(aml_soc_platform);
-
-static int aml_soc_platform_probe(struct platform_device *pdev)
-{
-    ALSA_TRACE();	
-	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
-}
-
-static int aml_soc_platform_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_platform(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id amlogic_audio_dt_match[]={
-	{	.compatible = "amlogic,aml-i2s",
-	},
-	{},
-};
-#else
-#define amlogic_audio_dt_match NULL
-#endif
-
-static struct platform_driver aml_i2s_driver = {
-	.driver = {
-			.name = "aml-i2s",
-			.owner = THIS_MODULE,
-			.of_match_table = amlogic_audio_dt_match,
-	},
-
-	.probe = aml_soc_platform_probe,
-	.remove = aml_soc_platform_remove,
-};
-
-static int __init aml_alsa_audio_init(void)
-{
-	aml_i2s_init_debugfs();
-	return platform_driver_register(&aml_i2s_driver);
-}
-
-static void __exit aml_alsa_audio_exit(void)
-{
-	aml_i2s_cleanup_debugfs();
-    platform_driver_unregister(&aml_i2s_driver);
-}
-
-module_init(aml_alsa_audio_init);
-module_exit(aml_alsa_audio_exit);
-
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("AML audio driver for ALSA");
diff --git a/sound/soc/aml/aml_i2s.h b/sound/soc/aml/aml_i2s.h
deleted file mode 100755
index e194fb8743d2..000000000000
--- a/sound/soc/aml/aml_i2s.h
+++ /dev/null
@@ -1,77 +0,0 @@
-#ifndef __AML_PCM_H__
-#define __AML_PCM_H__
-
-//#define debug_printk
-#ifdef debug_printk
-#define dug_printk(fmt, args...)  printk (fmt, ## args)
-#else
-#define dug_printk(fmt, args...)
-#endif
-
-typedef struct audio_stream {
-    int stream_id;
-    int active;
-    unsigned int last_ptr;
-    unsigned int size;
-    unsigned int sample_rate;
-    unsigned int I2S_addr;
-    spinlock_t lock;
-    struct snd_pcm_substream *stream;
-	unsigned i2s_mode; //0:master, 1:slave,
-    unsigned device_type;
-} audio_stream_t;
-
-typedef struct aml_audio {
-    struct snd_card *card;
-    struct snd_pcm *pcm;
-    audio_stream_t s[2];
-} aml_audio_t;
-
-typedef struct audio_mixer_control {
-    int output_devide;
-    int input_device;
-    int direction;
-    int input_volume;
-    int output_volume;
-} audio_mixer_control_t;
-
-typedef struct audio_tone_control {
-    unsigned short * tone_source;
-    unsigned short * tone_data;
-    int tone_data_len;
-    int tone_count;
-    int tone_flag;
-}audio_tone_control_t;
-
-struct aml_pcm_dma_params{
-		char *name;			/* stream identifier */
-		struct snd_pcm_substream *substream;
-		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
-	
-};
-typedef struct aml_dai_info {
-	unsigned i2s_mode; //0:master, 1:slave,
-} aml_dai_info_t;
-enum {
-	I2S_MASTER_MODE = 0,
-	I2S_SLAVE_MODE,	
-};
-/*--------------------------------------------------------------------------*\
- * Data types
-\*--------------------------------------------------------------------------*/
-struct aml_runtime_data {
-	struct aml_pcm_dma_params *params;
-	dma_addr_t dma_buffer;		/* physical address of dma buffer */
-	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
-
-	struct snd_pcm *pcm;
-	struct snd_pcm_substream *substream;
-	audio_stream_t s;	
-	struct timer_list timer;	// timeer for playback and capture
-    struct hrtimer hrtimer;
-};
-
-extern struct snd_soc_platform_driver aml_soc_platform;
-//extern struct aml_audio_interface aml_i2s_interface;
-
-#endif
diff --git a/sound/soc/aml/aml_i2s_dai.c b/sound/soc/aml/aml_i2s_dai.c
deleted file mode 100755
index 06c1524e9d04..000000000000
--- a/sound/soc/aml/aml_i2s_dai.c
+++ /dev/null
@@ -1,389 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/ioctl.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/soundcard.h>
-#include <linux/timer.h>
-#include <linux/debugfs.h>
-#include <linux/major.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/control.h>
-#include <sound/soc.h>
-#include <sound/pcm_params.h>
-#include <mach/am_regs.h>
-#include <mach/pinmux.h>
-#include "aml_i2s_dai.h"
-#include "aml_pcm.h"
-#include "aml_i2s.h"
-#include "aml_audio_hw.h"
-#include <linux/of.h>
-
-static aml_dai_info_t dai_info[3] = {{0}};
-static int i2s_pos_sync = 0;
-#define AML_DAI_DEBUG
-//#define AML_DAI_PCM_SUPPORT 
-
-
-#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
-#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
-#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-i2s-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
-#else
-#define ALSA_DEBUG(fmt,args...) 
-#define ALSA_TRACE()   
-#endif
-
-/*
-the I2S hw  and IEC958 PCM output initation,958 initation here,
-for the case that only use our ALSA driver for PCM s/pdif output.
-*/
-static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
-{
-
-		unsigned i2s_mode;
-		switch(runtime->format){
-		case SNDRV_PCM_FORMAT_S32_LE:
-			i2s_mode = AIU_I2S_MODE_PCM32;
-			break;
-		case SNDRV_PCM_FORMAT_S24_LE:
-			i2s_mode = AIU_I2S_MODE_PCM24;
-			break;
-		case SNDRV_PCM_FORMAT_S16_LE:
-			i2s_mode = AIU_I2S_MODE_PCM16;
-			break;
-		}
-		audio_set_i2s_mode(i2s_mode);
-		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,runtime->channels);
-		ALSA_PRINT("i2s dma %x,phy addr %x \n",(unsigned)runtime->dma_area,(unsigned)runtime->dma_addr);
-		//memset((void*)runtime->dma_area,0,runtime->dma_bytes);
-		ALSA_PRINT("I2S hw init,i2s mode %d\n",i2s_mode);
-
-}
-static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{	  	
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	int ret = 0;
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-    	struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
-	audio_stream_t *s;	
-	if(prtd == NULL){
-		prtd = (struct aml_runtime_data *)kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
-		if (prtd == NULL) {
-			printk("alloc aml_runtime_data error\n");
-			ret = -ENOMEM;
-			goto out;
-		}
-		prtd->substream = substream;
-		runtime->private_data = prtd;		
-	}
-	s = &prtd->s; 
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		s->device_type = AML_AUDIO_I2SOUT;
-	}	
-	else{
-		s->device_type = AML_AUDIO_I2SIN;	
-	}	
-	return 0;
-out:
-	return ret;
-}
-
-static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-}
-static unsigned set_clock = 0;
-static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_runtime_data *prtd = runtime->private_data;
-	unsigned sample_rate = AUDIO_CLK_FREQ_48;
-	audio_stream_t *s = &prtd->s;	
-	switch(runtime->rate){
-		case 192000:
-			sample_rate	=	AUDIO_CLK_FREQ_192;
-			break;
-		case 176400:
-			sample_rate	=	AUDIO_CLK_FREQ_1764;
-			break;
-		case 96000:
-			sample_rate	=	AUDIO_CLK_FREQ_96;
-			break;
-		case 88200:
-			sample_rate	=	AUDIO_CLK_FREQ_882;
-			break;
-		case 48000:
-			sample_rate	=	AUDIO_CLK_FREQ_48;
-			break;
-		case 44100:
-			sample_rate	=	AUDIO_CLK_FREQ_441;
-			break;
-		case 32000:
-			sample_rate	=	AUDIO_CLK_FREQ_32;
-			break;
-		case 8000:
-			sample_rate	=	AUDIO_CLK_FREQ_8;
-			break;
-		case 11025:
-			sample_rate	=	AUDIO_CLK_FREQ_11;
-			break;
-		case 16000:
-			sample_rate	=	AUDIO_CLK_FREQ_16;
-			break;
-		case 22050:
-			sample_rate	=	AUDIO_CLK_FREQ_22;
-			break;
-		case 12000:
-			sample_rate	=	AUDIO_CLK_FREQ_12;
-			break;
-		case 24000:
-			sample_rate	=	AUDIO_CLK_FREQ_22;
-			break;
-		default:
-			sample_rate	=	AUDIO_CLK_FREQ_441;
-			break;
-	};
-
-    printk(KERN_INFO "enterd %s,set_clock:%d,sample_rate=%d\n",__func__,set_clock,sample_rate);
-    if(set_clock != sample_rate ){
-        set_clock = sample_rate;
-        audio_set_i2s_clk(sample_rate, AUDIO_CLK_256FS);
-    }
-    audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP); 
-    
-    if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-    {
-        s->i2s_mode = dai_info[dai->id].i2s_mode;
-        audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes*2,0,i2s_pos_sync);
-        memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
-        {
-            int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
-            ppp[0] = 0x78787878;
-            ppp[1] = 0x78787878;
-        }
-        s->device_type = AML_AUDIO_I2SIN;       
-    }
-    else{       
-        s->device_type = AML_AUDIO_I2SOUT;
-        aml_hw_i2s_init(runtime);
-    }
-    return 0;
-}
-static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
-				struct snd_soc_dai *dai)
-{
-	ALSA_DEBUG();
-    //printk("****aml_dai_i2s_trigger******\n");
-	struct snd_pcm_runtime *rtd = substream->runtime;
-	switch (cmd) {
-		case SNDRV_PCM_TRIGGER_START:
-		case SNDRV_PCM_TRIGGER_RESUME:
-		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-			// TODO
-			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-				printk("aiu i2s playback enable\n\n");
-				audio_out_i2s_enable(1);
-			}else{
-				audio_in_i2s_enable(1);
-				int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
-				ppp[0] = 0x78787878;
-				ppp[1] = 0x78787878;
-			}
-			break;
-		case SNDRV_PCM_TRIGGER_STOP:
-		case SNDRV_PCM_TRIGGER_SUSPEND:
-		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-				printk("aiu i2s playback disable\n\n");
-				audio_out_i2s_enable(0);
-			}else{
-				audio_in_i2s_enable(0);
-			}
-			break;
-		default:
-			return -EINVAL;
-	}
-
-	return 0;
-}	
-
-static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *params,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	
-		
-	return 0;
-}
-
-static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai,
-					unsigned int fmt)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	if(fmt&SND_SOC_DAIFMT_CBS_CFS)//slave mode 
-		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
-    
-    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-    case SND_SOC_DAIFMT_NB_NF:
-         i2s_pos_sync = 0;
-        break;
-    case SND_SOC_DAIFMT_IB_NF:
-         i2s_pos_sync = 1;
-        break;
-    default:
-        return -EINVAL;
-    }
-	return 0;
-}
-
-static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
-					int clk_id, unsigned int freq, int dir)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
-{
-		
-  printk("***Entered %s:%s\n", __FILE__,__func__);
-  return 0;
-}
-
-static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
-{
-  printk("***Entered %s:%s\n", __FILE__,__func__);
-  return 0;
-}
-
-#else /* CONFIG_PM */
-#define aml_dai_i2s_suspend	NULL
-#define aml_dai_i2s_resume	NULL
-#endif /* CONFIG_PM */
-
-
-
-#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_96000)
-#define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-
-
-static struct snd_soc_dai_ops aml_dai_i2s_ops = {
-	.startup	= aml_dai_i2s_startup,
-	.shutdown	= aml_dai_i2s_shutdown,
-	.prepare	= aml_dai_i2s_prepare,
-	.trigger = aml_dai_i2s_trigger,
-	.hw_params	= aml_dai_i2s_hw_params,
-	.set_fmt	= aml_dai_set_i2s_fmt,
-	.set_sysclk	= aml_dai_set_i2s_sysclk,
-};
-
-
-
-struct snd_soc_dai_driver aml_i2s_dai[] = {
-	{	.name = "aml-i2s-dai",
-		.id = 0,
-		.suspend = aml_dai_i2s_suspend,
-		.resume = aml_dai_i2s_resume,
-		.playback = {
-			.channels_min = 1,
-			.channels_max = 8,
-			.rates = AML_DAI_I2S_RATES,
-			.formats = AML_DAI_I2S_FORMATS,},
-		.capture = {
-			.channels_min = 1,
-			.channels_max = 8,
-			.rates = AML_DAI_I2S_RATES,
-			.formats = AML_DAI_I2S_FORMATS,},
-		.ops = &aml_dai_i2s_ops,
-	},
-
-};
-
-EXPORT_SYMBOL_GPL(aml_i2s_dai);
-
-static const struct snd_soc_component_driver aml_component= {
-	.name		= "aml-i2s-dai",
-};
-static int aml_i2s_dai_probe(struct platform_device *pdev)
-{
-	printk(KERN_DEBUG "enter %s\n", __func__);
-#if 0
-	BUG_ON(pdev->id < 0);
-	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
-	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
-#else
-	return snd_soc_register_component(&pdev->dev, &aml_component,
-					 aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
-
-#endif
-}
-
-static int aml_i2s_dai_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_component(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_dai_dt_match[]={
-	{	.compatible = "amlogic,aml-i2s-dai",
-	},
-	{},
-};
-#else
-#define amlogic_dai_dt_match NULL
-#endif
-
-static struct platform_driver aml_i2s_dai_driver = {
-	.driver = {
-		.name = "aml-i2s-dai",
-		.owner = THIS_MODULE,
-		.of_match_table = amlogic_dai_dt_match,
-	},
-
-	.probe = aml_i2s_dai_probe,
-	.remove = aml_i2s_dai_remove,
-};
-
-static int __init aml_i2s_dai_modinit(void)
-{
-	return platform_driver_register(&aml_i2s_dai_driver);
-}
-module_init(aml_i2s_dai_modinit);
-
-static void __exit aml_i2s_dai_modexit(void)
-{
-	platform_driver_unregister(&aml_i2s_dai_driver);
-}
-module_exit(aml_i2s_dai_modexit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML DAI driver for ALSA");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_i2s_dai.h b/sound/soc/aml/aml_i2s_dai.h
deleted file mode 100755
index 332f1da65d9d..000000000000
--- a/sound/soc/aml/aml_i2s_dai.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef AML_DAI_H
-#define AML_DAI_H
-
-extern struct snd_soc_dai_driver aml_dai[];
-
-#endif
diff --git a/sound/soc/aml/aml_m1.c b/sound/soc/aml/aml_m1.c
deleted file mode 100644
index 8e362d34876d..000000000000
--- a/sound/soc/aml/aml_m1.c
+++ /dev/null
@@ -1,156 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "aml_m1_codec.h"
-
-	
-static int aml_m1_set_bias_level(struct snd_soc_card *card,
-					enum snd_soc_bias_level level)
-{
-	int ret = 0;
-    //struct snd_soc_codec *codec = card->codec;
-    switch(level){
-      case SND_SOC_BIAS_ON:
-      case SND_SOC_BIAS_PREPARE:
-        break;
-      case SND_SOC_BIAS_OFF:
-      case SND_SOC_BIAS_STANDBY:
-        break;
-    }
-	return ret;
-}
-
-static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_LINE("HP", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-    {"Ext Spk", NULL, "LINEOUTL"},
-    {"Ext Spk", NULL, "LINEOUTR"},
-    {"HP", NULL, "HP_L"},
-    {"HP", NULL, "HP_R"},
-};
-
-static int aml_m1_codec_init(struct snd_soc_codec *codec)
-{
-    struct snd_soc_card *card = codec->socdev->card;
-    int err;
-    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
-    if(err){
-      dev_warn(card->dev, "Failed to register DAPM widgets\n");
-      return 0;
-    }
-    err = snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
-    if(err){
-      dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
-      return 0;
-    }
-    snd_soc_dapm_enable_pin(codec, "Ext Spk");
-    snd_soc_dapm_enable_pin(codec, "HP");
-    snd_soc_dapm_sync(codec);
-	return 0;
-}
-
-
-static struct snd_soc_dai_link aml_m1_dai = {
-	.name = "AML-M1",
-	.stream_name = "AML M1 PCM",
-	.cpu_dai = &aml_dai[0],  //////
-	.codec_dai = &aml_m1_codec_dai,
-	.init = aml_m1_codec_init,
-};
-
-static struct snd_soc_card snd_soc_aml_m1 = {
-	.name = "AML-M1",
-	.platform = &aml_soc_platform,
-	.dai_link = &aml_m1_dai,
-	.num_links = 1,
-	.set_bias_level = aml_m1_set_bias_level,
-};
-
-static struct snd_soc_device aml_m1_snd_devdata = {
-	.card = &snd_soc_aml_m1,
-	.codec_dev = &soc_codec_dev_aml_m1,
-};
-
-static struct platform_device *aml_m1_snd_device;
-static struct platform_device *aml_m1_platform_device;
-
-static int aml_m1_audio_probe(struct platform_device *pdev)
-{
-		int ret;
-		aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
-		if (!aml_m1_snd_device) {
-			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-			ret = -ENOMEM;
-		}
-	
-		platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
-		aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
-	
-		ret = platform_device_add(aml_m1_snd_device);
-		if (ret) {
-			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-			goto error;
-		}
-		
-		aml_m1_platform_device = platform_device_register_simple("aml_m1_codec",
-								-1, NULL, 0);
-		return 0;							
-error:								
-		platform_device_put(aml_m1_snd_device);								
-		return ret;
-}
-
-static int aml_m1_audio_remove(struct platform_device *pdev)
-{
-printk("***Entered %s:%s\n", __FILE__,__func__);
-		platform_device_unregister(aml_m1_snd_device);
-		return 0;
-}
-
-static struct platform_driver aml_m1_audio_driver = {
-	.probe  = aml_m1_audio_probe,
-	.remove = aml_m1_audio_remove,
-	.driver = {
-		.name = "aml_m1_audio",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init aml_m1_init(void)
-{
-		return platform_driver_register(&aml_m1_audio_driver);
-}
-
-static void __exit aml_m1_exit(void)
-{
-		platform_driver_unregister(&aml_m1_audio_driver);
-}
-
-module_init(aml_m1_init);
-module_exit(aml_m1_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_armdev_wm8900.c b/sound/soc/aml/aml_m1_armdev_wm8900.c
deleted file mode 100644
index fd4b41a6cd39..000000000000
--- a/sound/soc/aml/aml_m1_armdev_wm8900.c
+++ /dev/null
@@ -1,446 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "../codecs/wm8900.h"
-
-#define HP_DET	0//1
-
-#if HP_DET
-static struct timer_list timer;
-#endif
-
-static int aml_m1_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-		struct snd_soc_pcm_runtime *rtd = substream->private_data;
-		struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
-		struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
-		int ret;
-		// TODO
-printk("***Entered %s:%s\n", __FILE__,__func__);				
-		
-		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-		if(ret<0)
-			return ret;
-			
-		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-		if(ret<0)
-			return ret;
-		
-		
-	return 0;
-}
-	
-static struct snd_soc_ops aml_m1_ops = {
-	.hw_params = aml_m1_hw_params,
-};
-
-static int aml_m1_set_bias_level(struct snd_soc_card *card,
-					enum snd_soc_bias_level level)
-{
-	int ret = 0;
-	// TODO
-printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-	case SND_SOC_BIAS_PREPARE:
-#if HP_DET		
-		del_timer_sync(&timer);
-		timer.expires = jiffies + HZ*1;
-		del_timer(&timer);
-		add_timer(&timer);
-#endif		
-		break;
-	case SND_SOC_BIAS_OFF:
-	case SND_SOC_BIAS_STANDBY:
-#if HP_DET		
-		del_timer(&timer);
-#endif		
-		break;
-	};
-	
-	return ret;
-}
-
-static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
-	SND_SOC_DAPM_SPK("AVout Jack", NULL),
-	SND_SOC_DAPM_HP("Headphone Jack", NULL),
-	SND_SOC_DAPM_MIC("Headphone Mic", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-
-	/* speaker connected to LINEOUT */
-	{"AVout Jack", NULL, "LINEOUT1L"},
-	{"AVout Jack", NULL, "LINEOUT1R"},
-	
-	{"Headphone Jack", NULL, "HP_L"},
-	{"Headphone Jack", NULL, "HP_R"},
-	
-	/* input */
-/*
-	{"RINPUT2", NULL, "Mic Bias"},
-	{"LINPUT2", NULL, "Headphone Mic"},
-	{"Mic Bias", NULL, "Headphone Mic"},	
-*/	
-};
-
-#if HP_DET
-
-/* Hook switch */
-
-static struct snd_soc_jack hp_jack;
-
-static struct snd_soc_jack_pin hp_jack_pins[] = {
-	{ .pin = "Headphone Jack", .mask = SND_JACK_HEADSET },
-};
-
-static struct snd_soc_jack av_jack;
-
-static struct snd_soc_jack_pin av_jack_pins[] = {
-	{ .pin = "AVout Jack", .mask = SND_JACK_AVOUT },
-};
-
-// use LED_CS1 as detect pin
-
-/*
- * inner_cs_input_level
- * VGHL B/LCS0/1.
- * : AML8726-M_DEV_BOARD 2010-10-11_V1.0
- * P4(VGHL_CS0/1)   T2(LED_CS1)  T1(LED_CS0)
- * 0.7V0.4V
- * 
- * 
-       level[12]  <-->  VGHL_CS1
-       level[ 8]  <-->  VGHL_CS0
-       level[ 4]  <-->  LED_CS1
-       level[ 0]  <-->  LED_CS0
- */
-#define PWM_TCNT        (600-1)
-#define PWM_MAX_VAL    (420)
- 
-static unsigned int inner_cs_input_level()
-{
-		unsigned int level = 0;
-    unsigned int cs_no = 0;
-    //pin64 LED_CS0
-    CLEAR_CBUS_REG_MASK(PERIPHS_PIN_MUX_0, (3<<21));
-    // Enable VBG_EN
-    WRITE_CBUS_REG_BITS(PREG_AM_ANALOG_ADDR, 1, 0, 1);
-    // pin mux 
-    // wire            pm_gpioA_7_led_pwm          = pin_mux_reg0[22];
-    WRITE_CBUS_REG(LED_PWM_REG0, 0);
-    WRITE_CBUS_REG(LED_PWM_REG1, 0);
-    WRITE_CBUS_REG(LED_PWM_REG2, 0);
-    WRITE_CBUS_REG(LED_PWM_REG3, 0);
-    WRITE_CBUS_REG(LED_PWM_REG4, 0);
-    WRITE_CBUS_REG(LED_PWM_REG0,  (0 << 31)           |       // disable the overall circuit
-                            (0 << 30)           |       // 1:Closed Loop  0:Open Loop
-                            (PWM_TCNT << 16)    |       // PWM total count
-                            (0 << 13)           |       // Enable
-                            (1 << 12)           |       // enable
-                            (0 << 10)           |       // test
-                            (7 << 7)            |       // CS0 REF, Voltage FeedBack: about 0.505V
-                            (7 << 4)            |       // CS1 REF, Current FeedBack: about 0.505V
-                            (0 << 0)                   // DIMCTL Analog dimmer
-                      );
-     WRITE_CBUS_REG(LED_PWM_REG1,   (1 << 30)           |       // enable high frequency clock
-                            (PWM_MAX_VAL << 16) |       // MAX PWM value
-                            (0  << 0)                  // MIN PWM value
-                      );
-     WRITE_CBUS_REG(LED_PWM_REG2,    (0 << 31)       |       // disable timeout test mode
-                            (0 << 30)       |       // timeout based on the comparator output
-                            (0 << 16)       |       // timeout = 10uS
-                            (0 << 13)       |       // Select oscillator as the clock (just for grins)
-                            (1 << 11)       |       // 1:Enable OverCurrent Portection  0:Disable
-                            (3 << 8)        |       // Filter: shift every 3 ticks
-                            (0 << 6)        |       // Filter: count 1uS ticks
-                            (0 << 5)        |       // PWM polarity : negative
-                            (0 << 4)        |       // comparator: negative, Different with NikeD3
-                            (1 << 0)               // +/- 1
-                      );
-    WRITE_CBUS_REG(LED_PWM_REG3,  (   1 << 16) |    // Feedback down-sampling = PWM_freq/1 = PWM_freq
-                          (   1 << 14) |    // enable to re-write MATCH_VAL
-                          (   210 <<  0)   // preset PWM_duty = 50%
-                      );
-    WRITE_CBUS_REG(LED_PWM_REG4,  (   0 << 30) |    // 1:Digital Dimmer  0:Analog Dimmer
-                          (   2 << 28) |    // dimmer_timebase = 1uS
-                          (1000 << 14) |    // Digital dimmer_duty = 0%, the most darkness
-                          (1000 <<  0)     // dimmer_freq = 1KHz
-                      );
-    cs_no = READ_CBUS_REG(LED_PWM_REG3);
-    
-    if(cs_no &(1<<14))
-      level |= (1<<0);
-    if(cs_no &(1<<15))
-      level |= (1<<4);
-      
-    WRITE_CBUS_REG(VGHL_PWM_REG0, 0);
-    WRITE_CBUS_REG(VGHL_PWM_REG1, 0);
-    WRITE_CBUS_REG(VGHL_PWM_REG2, 0);
-    WRITE_CBUS_REG(VGHL_PWM_REG3, 0);
-    WRITE_CBUS_REG(VGHL_PWM_REG4, 0);
-    WRITE_CBUS_REG(VGHL_PWM_REG0, (0 << 31)           |       // disable the overall circuit
-                            (0 << 30)           |       // 1:Closed Loop  0:Open Loop
-                            (PWM_TCNT << 16)    |       // PWM total count
-                            (0 << 13)           |       // Enable
-                            (1 << 12)           |       // enable
-                            (0 << 10)           |       // test
-                            (7 << 7)            |       // CS0 REF, Voltage FeedBack: about 0.505V
-                            (7 << 4)            |       // CS1 REF, Current FeedBack: about 0.505V
-                            (0 << 0)                   // DIMCTL Analog dimmer
-                       );
-     WRITE_CBUS_REG(VGHL_PWM_REG1,   (1 << 30)           |       // enable high frequency clock
-                            (PWM_MAX_VAL << 16) |       // MAX PWM value
-                            (0  << 0)                  // MIN PWM value
-                       );
-     WRITE_CBUS_REG(VGHL_PWM_REG2,   (0 << 31)       |       // disable timeout test mode
-                            (0 << 30)       |       // timeout based on the comparator output
-                            (0 << 16)       |       // timeout = 10uS
-                            (0 << 13)       |       // Select oscillator as the clock (just for grins)
-                            (1 << 11)       |       // 1:Enable OverCurrent Portection  0:Disable
-                            (3 << 8)        |       // Filter: shift every 3 ticks
-                            (0 << 6)        |       // Filter: count 1uS ticks
-                            (0 << 5)        |       // PWM polarity : negative
-                            (0 << 4)        |       // comparator: negative, Different with NikeD3
-                            (1 << 0)               // +/- 1
-                       );
-    WRITE_CBUS_REG (VGHL_PWM_REG3,  (   1 << 16) |    // Feedback down-sampling = PWM_freq/1 = PWM_freq
-                          (   1 << 14) |    // enable to re-write MATCH_VAL
-                          (   210 <<  0)   // preset PWM_duty = 50%
-                       );
-    WRITE_CBUS_REG(VGHL_PWM_REG4,  (   0 << 30) |    // 1:Digital Dimmer  0:Analog Dimmer
-                          (   2 << 28) |    // dimmer_timebase = 1uS
-                          (1000 << 14) |    // Digital dimmer_duty = 0%, the most darkness
-                          (1000 <<  0)     // dimmer_freq = 1KHz
-                       );
-    cs_no = READ_CBUS_REG(VGHL_PWM_REG3);
-    
-    if(cs_no &(1<<14))
-      level |= (1<<8);
-    if(cs_no &(1<<15))
-      level |= (1<<12);
-
-    return level;
-}
-
-static int hp_detect_flag = 0;
-static spinlock_t lock;
-static void wm8900_hp_detect_queue(struct work_struct*);
-static struct wm8900_work_t{
-   unsigned long data;
-   struct work_struct wm8900_workqueue;
-}wm8900_work;
-
-static void wm8900_hp_detect_queue(struct work_struct* work)
-{
-	int level = inner_cs_input_level();
-	struct wm8900_work_t* pwork = container_of(work,struct wm8900_work_t, wm8900_workqueue);
-	struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
-		
-		if(level == 0x1 && hp_detect_flag!= 0x1){	// HP
-			snd_soc_dapm_disable_pin(codec, "AVout Jack");
-	   		snd_soc_dapm_sync(codec);
-			snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
-			hp_detect_flag = 0x1;
-		}else if(level == 0x10 && hp_detect_flag != 0x10){	// AV
-			
-			snd_soc_jack_report(&av_jack, SND_JACK_AVOUT, SND_JACK_AVOUT);
-			hp_detect_flag = 0x10;
-		}else if(level != hp_detect_flag){	// HDMI
-			snd_soc_dapm_disable_pin(codec, "AVout Jack");
-			snd_soc_dapm_disable_pin(codec, "Headphone Jack");
-	   		snd_soc_dapm_sync(codec);
-			hp_detect_flag = level;
-		}
-}
-
-static void wm8900_hp_detect_timer(unsigned long data)
-{
-		struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
-		wm8900_work.data = (unsigned long)codec;
-		schedule_work(&wm8900_work.wm8900_workqueue);
-		mod_timer(&timer, jiffies + HZ*1);
-}
-
-#endif
-
-static int aml_m1_codec_init(struct snd_soc_codec *codec)
-{
-		struct snd_soc_dai *codec_dai = codec->dai;
-		struct snd_soc_card *card = codec->socdev->card;
-	
-		int err;
- 
-		//Add board specific DAPM widgets and routes
-		err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
-		if(err){
-			dev_warn(card->dev, "Failed to register DAPM widgets\n");
-			return 0;
-		}
-		
-		err = snd_soc_dapm_add_routes(codec, intercon,
-				      ARRAY_SIZE(intercon));
-		if(err){
-			dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
-			return 0;
-		}
-		
-		//hook switch
-#if HP_DET
-		hp_detect_flag = 0;
-				
-		err = snd_soc_jack_new(card, "hp_switch",
-				SND_JACK_HEADSET, &hp_jack);
-		if(err){
-			dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
-		}else{
-				err = snd_soc_jack_add_pins(&hp_jack,
-						ARRAY_SIZE(hp_jack_pins),
-						hp_jack_pins);
-				if(err){
-						dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
-				}
-		}
-		
-		err =	snd_soc_jack_new(card, "av_switch",
-				SND_JACK_HEADSET, &av_jack);
-		if(err){
-				dev_warn(card->dev, "Failed to alloc resource for av hook switch\n");
-		}else{		
-			err = snd_soc_jack_add_pins(&av_jack,
-						ARRAY_SIZE(av_jack_pins),
-						av_jack_pins);
-				if(err){
-						dev_warn(card->dev, "Failed to setup hook av jack pin\n");
-				}			
-		}		
-		// create a timer to poll the HP IN status
-		timer.function = &wm8900_hp_detect_timer;
-  	timer.data = (unsigned long)codec;
-  	timer.expires = jiffies + HZ*1;
-  	init_timer(&timer);
-#endif 
-		snd_soc_dapm_nc_pin(codec,"LINPUT1");
-		snd_soc_dapm_nc_pin(codec,"RINPUT1");
-		
-		snd_soc_dapm_enable_pin(codec, "AVout Jack");
-		snd_soc_dapm_disable_pin(codec, "Headphone Jack");
-		snd_soc_dapm_disable_pin(codec, "Headphone Mic");
-		
-		snd_soc_dapm_sync(codec);
-
-		return 0;
-}
-
-
-static struct snd_soc_dai_link aml_m1_dai = {
-	.name = "AML-M1",
-	.stream_name = "AML M1 PCM",
-	.cpu_dai = &aml_dai[0],  //////
-	.codec_dai = &wm8900_dai,
-	.init = aml_m1_codec_init,
-	.ops = &aml_m1_ops,
-};
-
-static struct snd_soc_card snd_soc_aml_m1 = {
-	.name = "AML-M1",
-	.platform = &aml_soc_platform,
-	.dai_link = &aml_m1_dai,
-	.num_links = 1,
-	.set_bias_level = aml_m1_set_bias_level,
-};
-
-static struct snd_soc_device aml_m1_snd_devdata = {
-	.card = &snd_soc_aml_m1,
-	.codec_dev = &soc_codec_dev_wm8900,
-};
-
-static struct platform_device *aml_m1_snd_device;
-static struct platform_device *aml_m1_platform_device;
-
-static int aml_m1_audio_probe(struct platform_device *pdev)
-{
-		int ret;
-		//pdev->dev.platform_data;
-		// TODO
-printk("***Entered %s:%s\n", __FILE__,__func__);
-		aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
-		if (!aml_m1_snd_device) {
-			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-			ret = -ENOMEM;
-		}
-	
-		platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
-		aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
-	
-		ret = platform_device_add(aml_m1_snd_device);
-		if (ret) {
-			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-			goto error;
-		}
-		
-		aml_m1_platform_device = platform_device_register_simple("aml_m1_codec",
-								-1, NULL, 0);
-		return 0;							
-error:								
-		platform_device_put(aml_m1_snd_device);								
-		return ret;
-}
-
-static int aml_m1_audio_remove(struct platform_device *pdev)
-{
-printk("***Entered %s:%s\n", __FILE__,__func__);
-
-#if HP_DET		
-		del_timer_sync(&timer);
-#endif
-		platform_device_unregister(aml_m1_snd_device);
-		return 0;
-}
-
-static struct platform_driver aml_m1_audio_driver = {
-	.probe  = aml_m1_audio_probe,
-	.remove = aml_m1_audio_remove,
-	.driver = {
-		.name = "aml_m1_audio_wm8900",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init aml_m1_init(void)
-{
-		return platform_driver_register(&aml_m1_audio_driver);
-}
-
-static void __exit aml_m1_exit(void)
-{
-		platform_driver_unregister(&aml_m1_audio_driver);
-}
-
-module_init(aml_m1_init);
-module_exit(aml_m1_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_codec.c b/sound/soc/aml/aml_m1_codec.c
deleted file mode 100644
index 4faedebe297c..000000000000
--- a/sound/soc/aml/aml_m1_codec.c
+++ /dev/null
@@ -1,509 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-
-#include <mach/am_regs.h>
-#include "aml_audio_hw.h"
-
-#define APB_BASE	0x5000
-
-#define ADAC_RESET                		0x00
-#define ADAC_LATCH                		0x01
-#define ADAC_CLOCK                		0x02
-// 0x03-0x0b  reserved
-#define ADAC_I2S_CONFIG_REG1      		0x0c
-#define ADAC_I2S_CONFIG_REG2      		0x0d
-// 0x0e - 0x0f reserved
-#define ADAC_POWER_CTRL_REG1      		0x10
-#define ADAC_POWER_CTRL_REG2      		0x11
-#define ADAC_POWER_CTRL_REG3      		0x12
-// 0x13-0x17 reserved
-#define ADAC_MUTE_CTRL_REG1       		0x18
-#define ADAC_MUTE_CTRL_REG2						0x19
-#define ADAC_DAC_ADC_MIXER        		0x1a
-// 0x1b-0x1f reserved
-#define ADAC_PLAYBACK_VOL_CTRL_LSB              0x20
-#define ADAC_PLAYBACK_VOL_CTRL_MSB              0x21
-#define ADAC_STEREO_HS_VOL_CTRL_LSB             0x22
-#define ADAC_STEREO_HS_VOL_CTRL_MSB             0x23
-
-#define ADAC_MAXREG	0x24
-
-struct snd_soc_codec_device soc_codec_dev_aml_m1;
-static struct snd_soc_codec *aml_m1_codec;
-
-/* codec private data */
-struct aml_m1_codec_priv {
-	struct snd_soc_codec codec;
-	u16 reg_cache[ADAC_MAXREG];
-	unsigned int sysclk;
-};
-
-void latch (struct snd_soc_codec* codec)
-{
-    int latch;
-    latch = 1;
-    snd_soc_write(codec, ADAC_LATCH, latch);
-    latch = 0;
-    snd_soc_write(codec, ADAC_LATCH, latch);
-}
-
-void aml_m1_reset(struct snd_soc_codec* codec, bool first_time)
-{
-	unsigned long   data32;
-    if(first_time){
-      /* initialize clock for audiodac */
-	  audio_set_clk(AUDIO_CLK_FREQ_48,0);
-      /* power up pll */
-  	  WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));
-      /* enable audiodac clock */
-	  WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 23, 1); 
-      msleep(100);
-      
-	  data32  = 0;
-      data32 |= 0 << 15;  // [15]  audac_soft_reset_n
-      data32 |= 0 << 14;  // [14]  audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
-      data32 |= 0 << 9;   // [9]   delay_rd_en
-      data32 |= 0 << 8;   // [8]   audac_reg_clk_inv
-      data32 |= 0 << 1;   // [7:1] audac_i2caddr
-      data32 |= 0 << 0;   // [0]   audac_intfsel: 0=use host bus; 1=use I2C.
-      WRITE_MPEG_REG(AIU_AUDAC_CTRL0, data32);
-      // Enable APB3 fail on error
-      data32  = 0;
-      data32 |= 1     << 15;  // [15]     err_en
-      data32 |= 255   << 0;   // [11:0]   max_err
-      WRITE_MPEG_REG(AIU_AUDAC_CTRL1, data32);
-	
-      snd_soc_write(codec, ADAC_RESET, (0<<1));
-      snd_soc_write(codec, ADAC_RESET, (0<<1));
-	  snd_soc_write(codec, ADAC_RESET, (0<<1));
-	  snd_soc_write(codec, ADAC_RESET, (0<<1));
-	  snd_soc_write(codec, ADAC_RESET, (0<<1));
-	  msleep(100);
-	  snd_soc_write(codec,ADAC_CLOCK, 0);
-	  snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, 6);	
-	  snd_soc_write(codec, ADAC_I2S_CONFIG_REG2, 1|(1<<3)); 		// I2S, split
-	
-	  snd_soc_write(codec, ADAC_POWER_CTRL_REG1, 0xc3);
-	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0);
-	  snd_soc_write(codec, ADAC_MUTE_CTRL_REG1,0);
-	  snd_soc_write(codec,ADAC_DAC_ADC_MIXER, 0);
-      snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_LSB, 0x54);
-      snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_MSB, 0x54);
-      snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_LSB, 0x28);
-      snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_MSB, 0x28); 
-
-      latch(codec);
-	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (0<<7));
-      latch(codec);
-	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (1<<7));
-      latch(codec);
-    }else{
- 
-      latch(codec);
-	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (0<<7));
-      latch(codec);
-	  snd_soc_write(codec, ADAC_POWER_CTRL_REG2, (1<<7));
-      latch(codec);
-    }
-  
-	snd_soc_write(codec, ADAC_RESET, (0<<1));
-    latch(codec);
-	snd_soc_write(codec, ADAC_RESET, (1<<1));
-    latch(codec);
-    msleep(100);
-}
-
-
-static const DECLARE_TLV_DB_SCALE(dac_volume, -12600, 150, 0);
-static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
-
-static const struct snd_kcontrol_new amlm1_snd_controls[] = {
-	SOC_DOUBLE_R_TLV("Master Playback Volume", ADAC_PLAYBACK_VOL_CTRL_LSB, ADAC_PLAYBACK_VOL_CTRL_MSB,
-	       0, 84, 0, dac_volume),
-	      
-	SOC_DOUBLE_R_TLV("HeadSet Driver Volume", ADAC_STEREO_HS_VOL_CTRL_LSB, ADAC_STEREO_HS_VOL_CTRL_MSB,
-	       0, 46, 0, hs_volume),
-
-    SOC_DOUBLE("Loud Speaker Mute", ADAC_MUTE_CTRL_REG1, 0, 1, 1, 0),
-    SOC_DOUBLE("Head Set Mute", ADAC_MUTE_CTRL_REG1, 6, 7, 1, 0),
-};
-
-static const struct snd_soc_dapm_widget amlm1_dapm_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
-	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
-	SND_SOC_DAPM_OUTPUT("HP_L"),
-	SND_SOC_DAPM_OUTPUT("HP_R"),
-	
-	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
-	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
-	
-	SND_SOC_DAPM_PGA("HeadSet Switch Left", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("HeadSet Switch Right", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
-};
-
-/* Target, Path, Source */
-
-static const struct snd_soc_dapm_route audio_map[] = {
-	{"LINEOUTL", NULL, "DACL"},
-	{"LINEOUTR", NULL, "DACR"},
-	{"HP_L", NULL, "HeadSet Switch Left"},
-	{"HP_R", NULL, "HeadSet Switch Right"},
-    {"HeadSet Switch Left", NULL, "DACL"},    
-    {"HeadSet Switch Right", NULL, "DACR"},
-};
-
-static int amlm1_add_widgets(struct snd_soc_codec *codec)
-{
-	snd_soc_dapm_new_controls(codec, amlm1_dapm_widgets,
-				  ARRAY_SIZE(amlm1_dapm_widgets));
-
-	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
-
-	return 0;
-}
-static int aml_m1_volatile_register(unsigned int reg)
-{
-	return 0;
-}
-static int aml_m1_write(struct snd_soc_codec *codec, unsigned int reg,
-							unsigned int value)
-{
-	u16 *reg_cache = codec->reg_cache;
-
-	if (reg >= codec->reg_cache_size)
-		return -EINVAL;
-	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
-	reg_cache[reg] = value;
-	return 0;
-}
-
-static unsigned int aml_m1_read(struct snd_soc_codec *codec,
-							unsigned int reg)
-{
-	return READ_APB_REG(APB_BASE+(reg<<2));
-}
-
-static int aml_m1_codec_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_codec *codec = socdev->card->codec;
-	//struct aml_m1_codec_priv *aml = codec->private_data;
-    u16 reg, val;
-    
-    switch(params_rate(params)){
-      case 8000:    val=0;  break;
-      case 11025:   val=1;  break;
-      case 12000:   val=2;  break;
-      case 16000:   val=3;  break;
-      case 22050:   val=4;  break;
-      case 24000:   val=5;  break;
-      case 32000:   val=6;  break;
-      case 44100:   val=7;  break;
-      case 48000:   val=8;  break;
-      case 88200:   val=9;  break;
-      case 96000:   val=10; break;
-      case 19200:   val=11; break;
-      default:  val=8; break;
-    }
-    reg = snd_soc_read(codec, ADAC_I2S_CONFIG_REG1);
-    reg &= ~0xf;
-    reg |= val;
-    snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, reg);
-
-    snd_soc_write(codec, ADAC_RESET, (0<<1));
-    latch(codec);
-	snd_soc_write(codec, ADAC_RESET, (1<<1));
-    latch(codec);
-
-	return 0;
-}
-
-static int aml_m1_codec_mute(struct snd_soc_dai *dai, int mute)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	u16 reg;
-
-	reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
-	if(mute){
-		reg |= 3|(3<<6);    /* mute hs and ls*/
-	}
-	else{
-		reg &= ~(3|(3<<6));
-	}
-	snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg);
-
-	snd_soc_write(codec, ADAC_RESET, (0<<1));
-    latch(codec);
-	snd_soc_write(codec, ADAC_RESET, (1<<1));
-    latch(codec);
-
-	return 0;
-}
-
-
-#define AML_RATES SNDRV_PCM_RATE_8000_96000
-
-#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
-	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-
-
-static struct snd_soc_dai_ops aml_m1_codec_dai_ops = {
-	.hw_params	= aml_m1_codec_hw_params,
-	.digital_mute	= aml_m1_codec_mute,
-};
-
-struct snd_soc_dai aml_m1_codec_dai = {
-	.name = "AML-M1",
-	.playback = {
-		.stream_name = "Playback",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = AML_RATES,
-		.formats = AML_FORMATS,},
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = AML_RATES,
-		.formats = AML_FORMATS,},
-	.ops = &aml_m1_codec_dai_ops,
-	.symmetric_rates = 1,
-};
-EXPORT_SYMBOL_GPL(aml_m1_codec_dai);
-
-static int aml_m1_set_bias_level(struct snd_soc_codec *codec,
-				 enum snd_soc_bias_level level)
-{
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-        aml_m1_reset(codec, false);
-		break;
-    case SND_SOC_BIAS_PREPARE:
-        break;
-	case SND_SOC_BIAS_STANDBY:
-   	case SND_SOC_BIAS_OFF:
-        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
-        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
-	    break;
-	default:
-	    break;
-	}
-	codec->bias_level = level;
-	return 0;
-}
-
-static int aml_m1_codec_probe(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec;
-	int ret = 0;
-
-	if (!aml_m1_codec) {
-		dev_err(&pdev->dev, "AML_M1_CODEC not yet discovered\n");
-		return -ENODEV;
-	}
-	codec = aml_m1_codec;			
-	socdev->card->codec = codec;	
-	
-	/* register pcms */
-	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
-	if (ret < 0) {
-		kfree(codec);
-		dev_err(codec->dev, "aml m1 codec: failed to create pcms: %d\n", ret);
-		goto pcm_err;
-	}
-	
-    snd_soc_add_controls(codec, amlm1_snd_controls,
-				ARRAY_SIZE(amlm1_snd_controls));
-	amlm1_add_widgets(codec);
-pcm_err:
-
-	return 0;
-}
-
-
-static int aml_m1_codec_remove(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-//	struct snd_soc_codec *codec = socdev->card->codec;
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int aml_m1_codec_suspend(struct platform_device* pdev)
-{
-	if (!aml_m1_codec) {
-		dev_err(&pdev->dev, "AML_M1_CODEC not yet discovered\n");
-		return -ENODEV;
-	}
-	struct snd_soc_codec *codec;
-    codec = aml_m1_codec;
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
-    return 0;
-}
-
-static int aml_m1_codec_resume(struct platform_device* pdev)
-{
-	if (!aml_m1_codec) {
-		dev_err(&pdev->dev, "AML_M1_CODEC not yet discovered\n");
-		return -ENODEV;
-	}
-	struct snd_soc_codec *codec;
-    codec = aml_m1_codec;
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0<<7);
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 1<<7);
-    return 0;
-}
-#endif
-
-struct snd_soc_codec_device soc_codec_dev_aml_m1 = {
-	.probe =	aml_m1_codec_probe,
-	.remove =	aml_m1_codec_remove,
-#ifdef CONFIG_PM	
-	.suspend = aml_m1_codec_suspend,
-	.resume = aml_m1_codec_resume,
-#else
-	.suspend = NULL,
-	.resume = NULL,
-#endif
-};
-EXPORT_SYMBOL_GPL(soc_codec_dev_aml_m1);
-
-static int aml_m1_register(struct aml_m1_codec_priv* aml_m1)
-{
-	struct snd_soc_codec* codec = &aml_m1->codec;
-	int ret;
-		
-	mutex_init(&codec->mutex);
-	INIT_LIST_HEAD(&codec->dapm_widgets);
-	INIT_LIST_HEAD(&codec->dapm_paths);
-
-	codec->name = "AML_M1_CODEC";
-	codec->owner = THIS_MODULE;
-	codec->private_data = aml_m1;
-
-	codec->dai = &aml_m1_codec_dai;
-	codec->num_dai = 1;
-
-	codec->reg_cache = &aml_m1->reg_cache;
-	codec->reg_cache_size = ARRAY_SIZE(aml_m1->reg_cache);
-	codec->read = aml_m1_read;
-	codec->write = aml_m1_write;
-	codec->volatile_register = aml_m1_volatile_register;
-	
-	codec->bias_level = SND_SOC_BIAS_OFF;
-	codec->set_bias_level = aml_m1_set_bias_level;
-	aml_m1_codec_dai.dev = codec->dev;
-	aml_m1_reset(codec, true);
-
-	aml_m1_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	aml_m1_codec = codec;
-
-	ret = snd_soc_register_codec(codec);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
-		goto err;
-	}
-
-	ret = snd_soc_register_dai(&aml_m1_codec_dai);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to register DAI: %d\n", ret);
-		goto err_codec;
-	}
-
-	return 0;
-
-err_codec:
-	snd_soc_unregister_codec(codec);
-err:
-	aml_m1_codec = NULL;
-	kfree(aml_m1);
-	return ret;
-		
-}
-
-static void aml_m1_unregister(struct aml_m1_codec_priv *aml_m1)
-{
-	snd_soc_unregister_dai(&aml_m1_codec_dai);
-	snd_soc_unregister_codec(&aml_m1->codec);
-	aml_m1_codec = NULL;
-	kfree(aml_m1);
-}
-
-static int aml_m1_codec_platform_probe(struct platform_device *pdev)
-{
-	struct aml_m1_codec_priv *aml_m1;
-	struct snd_soc_codec *codec;
-
-	aml_m1 = kzalloc(sizeof(struct aml_m1_codec_priv), GFP_KERNEL);
-	if (aml_m1 == NULL)
-		return -ENOMEM;
-
-	codec = &aml_m1->codec;
-
-	codec->control_data = NULL;
-	codec->hw_write = NULL;
-	codec->pop_time = 0;
-
-	codec->dev = &pdev->dev;
-	platform_set_drvdata(pdev, aml_m1);
-
-	return aml_m1_register(aml_m1);
-}
-
-static int __exit aml_m1_codec_platform_remove(struct platform_device *pdev)
-{
-	struct aml_m1_codec_priv *aml_m1 = platform_get_drvdata(pdev);
-
-	aml_m1_unregister(aml_m1);
-	return 0;
-}
-
-static struct platform_driver aml_m1_codec_platform_driver = {
-	.driver = {
-		.name = "aml_m1_codec",
-		.owner = THIS_MODULE,
-		},
-	.probe = aml_m1_codec_platform_probe,
-	.remove = __exit_p(aml_m1_codec_platform_remove),
-};
-
-static int __init aml_m1_codec_modinit(void)
-{
-        printk("****%s %d*****", __func__, __LINE__);
-		return platform_driver_register(&aml_m1_codec_platform_driver);
-}
-
-static void __exit aml_m1_codec_exit(void)
-{
-		platform_driver_unregister(&aml_m1_codec_platform_driver);
-}
-
-module_init(aml_m1_codec_modinit);
-module_exit(aml_m1_codec_exit);
-
-
-MODULE_DESCRIPTION("ASoC AML M1 codec driver");
-MODULE_AUTHOR("AMLogic Inc.");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_codec.h b/sound/soc/aml/aml_m1_codec.h
deleted file mode 100644
index b2ac8bef007f..000000000000
--- a/sound/soc/aml/aml_m1_codec.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef _AML_M1_CODEC_H
-#define _AML_M1_CODEC_H
-
-extern struct snd_soc_dai aml_m1_codec_dai;
-extern struct snd_soc_codec_device soc_codec_dev_aml_m1;
-
-#endif
diff --git a/sound/soc/aml/aml_m1_mid_cs42l52.c b/sound/soc/aml/aml_m1_mid_cs42l52.c
deleted file mode 100644
index a56b8ac91ae0..000000000000
--- a/sound/soc/aml/aml_m1_mid_cs42l52.c
+++ /dev/null
@@ -1,340 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/cs42l52.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "../codecs/cs42l52.h"
-
-//#define HP_DET 1
-
-#if HP_DET
-static struct timer_list timer;
-static int hp_detect_flag = 0;
-void mute_spk(struct snd_soc_codec* codec, int flag);
-#endif
-
-static int aml_m1_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
-    int ret;
-    // TODO
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-    if(ret<0)
-        return ret;
-
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-    if(ret<0)
-        return ret;
-
-    return 0;
-}
-    
-static struct snd_soc_ops aml_m1_ops = {
-    .hw_params = aml_m1_hw_params,
-};
-
-static int aml_m1_set_bias_level(struct snd_soc_card *card,
-    enum snd_soc_bias_level level)
-{
-    int ret = 0;
-    struct snd_soc_codec *codec = card->codec;
-    // TODO
-    printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-    case SND_SOC_BIAS_PREPARE:
-#if HP_DET
-        del_timer_sync(&timer);
-        timer.expires = jiffies + HZ*5;
-        del_timer(&timer);
-        add_timer(&timer);
-        hp_detect_flag = 0xf0000000;
-#endif
-        break;
-    case SND_SOC_BIAS_OFF:
-    case SND_SOC_BIAS_STANDBY:
-#if HP_DET
-        del_timer(&timer);
-        hp_detect_flag = 0xf0000000;        
-        mute_spk(codec,1);
-#endif
-        break;
-    };
-
-    return ret;
-}
-
-static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("MIC IN", NULL),
-    SND_SOC_DAPM_MIC("HP MIC", NULL),
-    SND_SOC_DAPM_LINE("FM IN", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-
-    /* speaker connected to LINEOUT */
-    {"Ext Spk", NULL, "LINEOUT1L"},
-    {"Ext Spk", NULL, "LINEOUT1R"},
-    /* mic is connected to Mic Jack, with WM8731 Mic Bias */
-    {"HP", NULL, "HP_L"},
-    {"HP", NULL, "HP_R"},
-    {"LINPUT2", NULL, "Mic Bias"},
-    {"Mic Bias", NULL, "MIC IN"},
-    {"RINPUT2", NULL, "Mic Bias"},
-    {"Mic Bias", NULL, "HP MIC"},
-    {"LINPUT3", NULL, "FM IN"},
-    {"RINPUT3", NULL, "FM IN"},
-};
-
-#if HP_DET
-
-/* Hook switch */
-
-static struct snd_soc_jack hp_jack;
-
-static struct snd_soc_jack_pin hp_jack_pins[] = {
-    { .pin = "HP", .mask = SND_JACK_HEADSET },
-};
-
-static spinlock_t lock;
-static void cs42l52_hp_detect_queue(struct work_struct*);
-static struct cs42l52_work_t{
-unsigned long data;
-struct work_struct cs42l52_workqueue;
-}cs42l52_work;
-
-void mute_spk(struct snd_soc_codec* codec, int flag)
-{
-    /*
-    int gpio_status = 0;
-    if(flag){
-        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
-        gpio_status &= ~(7<<4);
-        gpio_status |= (6<<4);
-        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
-    }else{
-        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
-        gpio_status &= ~(7<<4);
-        gpio_status |= (7<<4);
-        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
-    }
-    */
-}
-
-static void cs42l52_hp_detect_queue(struct work_struct* work)
-{
-    int level = 0x0;
-    struct cs42l52_work_t* pwork = container_of(work,struct cs42l52_work_t, cs42l52_workqueue);
-    struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
-
-    if ((soc_cs42l52_dai.ac97_pdata) && ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged)
-        level = ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged();
-
-    //printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
-    if(level == 0x1 && hp_detect_flag!= 0x1){ // HP
-        printk("Headphone pluged in\n");
-        snd_soc_dapm_disable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-        snd_soc_dapm_sync(codec);
-        // pull down the gpio to mute spk
-        mute_spk(codec, 1);
-        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
-        hp_detect_flag = level;
-    }else if(level != hp_detect_flag){ // HDMI
-        printk("Headphone unpluged\n");
-        snd_soc_dapm_enable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-        snd_soc_dapm_sync(codec);
-        snd_soc_jack_report(&hp_jack,0, SND_JACK_HEADSET);
-        hp_detect_flag = level;
-        mute_spk(codec, 0);
-    }
-}
-
-static void cs42l52_hp_detect_timer(unsigned long data)
-{
-    struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
-    cs42l52_work.data = (unsigned long)codec;
-    schedule_work(&cs42l52_work.cs42l52_workqueue);
-    mod_timer(&timer, jiffies + HZ*1);
-}
-
-#endif
-
-static int aml_m1_codec_init(struct snd_soc_codec *codec)
-{
-    struct snd_soc_card *card = codec->socdev->card;
-
-    int err;
-    //Add board specific DAPM widgets and routes
-    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
-    if(err){
-        dev_warn(card->dev, "Failed to register DAPM widgets\n");
-        return 0;
-    }
-
-    err = snd_soc_dapm_add_routes(codec, intercon,
-        ARRAY_SIZE(intercon));
-    if(err){
-        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
-        return 0;
-    }
-
-#if HP_DET
-    if ((soc_cs42l52_dai.ac97_pdata) && ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged)
-        hp_detect_flag = ((struct cs42l52_platform_data *) (soc_cs42l52_dai.ac97_pdata))->is_hp_pluged() ? (0) : (1);
-    else
-        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
-
-    err = snd_soc_jack_new(card, "hp_switch",
-        SND_JACK_HEADSET, &hp_jack);
-    if(err){
-        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
-    }else{
-        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
-        if(err){
-            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
-        }
-    }
-
-    // create a timer to poll the HP IN status
-    spin_lock_init(&lock);
-    timer.function = &cs42l52_hp_detect_timer;
-    timer.data = (unsigned long)codec;
-    timer.expires = jiffies + HZ*10;
-    init_timer(&timer);
-    INIT_WORK(&cs42l52_work.cs42l52_workqueue, cs42l52_hp_detect_queue);
-#endif
-
-    snd_soc_dapm_nc_pin(codec,"LINPUT1");
-    snd_soc_dapm_nc_pin(codec,"RINPUT1");
-
-    snd_soc_dapm_enable_pin(codec, "Ext Spk");
-    snd_soc_dapm_disable_pin(codec, "HP");
-    snd_soc_dapm_enable_pin(codec, "MIC IN");
-    snd_soc_dapm_disable_pin(codec, "HP MIC");
-    snd_soc_dapm_disable_pin(codec, "FM IN");
-
-    snd_soc_dapm_sync(codec);
-
-    return 0;
-}
-
-
-static struct snd_soc_dai_link aml_m1_dai = {
-    .name = "AML-M1",
-    .stream_name = "AML M1 PCM",
-    .cpu_dai = &aml_dai[0],  //////
-    .codec_dai = &soc_cs42l52_dai,
-    .init = aml_m1_codec_init,
-    .ops = &aml_m1_ops,
-};
-
-static struct snd_soc_card snd_soc_aml_m1 = {
-    .name = "AML-M1",
-    .platform = &aml_soc_platform,
-    .dai_link = &aml_m1_dai,
-    .num_links = 1,
-    .set_bias_level = aml_m1_set_bias_level,
-};
-
-static struct snd_soc_device aml_m1_snd_devdata = {
-    .card = &snd_soc_aml_m1,
-    .codec_dev = &soc_codec_cs42l52_dev,
-};
-
-static struct platform_device *aml_m1_snd_device;
-static struct platform_device *aml_m1_platform_device;
-
-static int aml_m1_audio_probe(struct platform_device *pdev)
-{
-    int ret;
-
-    // TODO
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-    aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
-    if (!aml_m1_snd_device) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        ret = -ENOMEM;
-    }
-
-    platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
-    aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
-
-    ret = platform_device_add(aml_m1_snd_device);
-    if (ret) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        goto error;
-    }
-
-    aml_m1_platform_device = platform_device_register_simple("aml_m1_codec", -1, NULL, 0);
-    return 0;
-error:
-    platform_device_put(aml_m1_snd_device);
-    return ret;
-}
-
-static int aml_m1_audio_remove(struct platform_device *pdev)
-{
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-#if HP_DET
-    del_timer_sync(&timer);
-    
-#endif
-    platform_device_unregister(aml_m1_snd_device);
-    return 0;
-}
-
-static struct platform_driver aml_m1_audio_driver = {
-    .probe  = aml_m1_audio_probe,
-    .remove = aml_m1_audio_remove,
-    .driver = {
-        .name = "aml_m1_audio_cs42l52",
-        .owner = THIS_MODULE,
-    },
-};
-
-static int __init aml_m1_init(void)
-{
-    return platform_driver_register(&aml_m1_audio_driver);
-}
-
-static void __exit aml_m1_exit(void)
-{
-    platform_driver_unregister(&aml_m1_audio_driver);
-}
-
-module_init(aml_m1_init);
-module_exit(aml_m1_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
-MODULE_LICENSE("GPL");
-
diff --git a/sound/soc/aml/aml_m1_mid_rt5621.c b/sound/soc/aml/aml_m1_mid_rt5621.c
deleted file mode 100644
index 9807ea3b0699..000000000000
--- a/sound/soc/aml/aml_m1_mid_rt5621.c
+++ /dev/null
@@ -1,351 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/rt5621.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "../codecs/rt5621.h"
-
-#define HP_DET	1
-
-#if HP_DET
-static struct timer_list timer;
-#endif
-
-static int aml_m1_hw_params(struct snd_pcm_substream *substream,
-                            struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
-    int ret;
-    // TODO
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-    if (ret<0)
-        return ret;
-
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-    if (ret<0)
-        return ret;
-
-    return 0;
-}
-
-static struct snd_soc_ops aml_m1_ops = {
-    .hw_params = aml_m1_hw_params,
-};
-
-static int aml_m1_set_bias_level(struct snd_soc_card *card,
-                                 enum snd_soc_bias_level level)
-{
-    int ret = 0;
-    struct snd_soc_codec *codec = card->codec;
-    // TODO
-    printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-    case SND_SOC_BIAS_PREPARE:
-        #if HP_DET		
-		del_timer_sync(&timer);
-		timer.expires = jiffies + HZ*1;
-		del_timer(&timer);
-		add_timer(&timer);
-		switch_audio(0);
-       #endif
-        break;
-    case SND_SOC_BIAS_OFF:
-    case SND_SOC_BIAS_STANDBY:
-        #if HP_DET		
-		del_timer(&timer);
-		switch_audio(1);
-        #endif
-        break;
-    };
-
-    return ret;
-}
-
-static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("MIC IN", NULL),
-    SND_SOC_DAPM_MIC("HP MIC", NULL),
-    SND_SOC_DAPM_LINE("FM IN", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-
-    /* speaker connected to LINEOUT */
-    {"Ext Spk", NULL, "LINEOUT1L"},
-    {"Ext Spk", NULL, "LINEOUT1R"},
-    /* mic is connected to Mic Jack, with WM8731 Mic Bias */
-    {"HP", NULL, "HP_L"},
-    {"HP", NULL, "HP_R"},
-    {"LINPUT2", NULL, "Mic Bias"},
-    {"Mic Bias", NULL, "MIC IN"},
-    {"RINPUT2", NULL, "Mic Bias"},
-    {"Mic Bias", NULL, "HP MIC"},
-    {"LINPUT3", NULL, "FM IN"},
-    {"RINPUT3", NULL, "FM IN"},
-};
-
-#if HP_DET
-
-/* Hook switch */
-
-static struct snd_soc_jack hp_jack;
-
-static struct snd_soc_jack_pin hp_jack_pins[] = {
-	{ .pin = "HP", .mask = SND_JACK_HEADSET },
-};
-
-static int hp_detect_flag = 0x0;
-static spinlock_t lock;
-static void rt5621_hp_detect_queue(struct work_struct*);
-static struct rt5621_work_t{
-   unsigned long data;
-   struct work_struct rt5621_workqueue;
-}rt5621_work;
-
-static void rt5621_hp_detect_queue(struct work_struct* work)
-{
-    int level = 0x0;
-	struct rt5621_work_t* pwork = container_of(work,struct rt5621_work_t, rt5621_workqueue);
-	struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
-
-    if ((rt5621_dai.ac97_pdata) && ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged)
-        level = ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged();
-
-    //printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
-    if(level == 0x1 && hp_detect_flag!= 0x1){ // HP OUT
-        printk("Headphone pluged in\n");
-	    snd_soc_dapm_disable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-	    snd_soc_dapm_sync(codec);
-	    // pull down the gpio to mute spk
-	    switch_audio(1);
-        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
-        hp_detect_flag = level;
-    }else if(level != hp_detect_flag){ // AUX OUT
-        printk("Headphone unpluged\n");
-	    snd_soc_dapm_enable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-	    snd_soc_dapm_sync(codec);
-        snd_soc_jack_report(&hp_jack, 0, SND_JACK_HEADSET);
-        hp_detect_flag = level;
-	    switch_audio(0);
-    } 
-}
-
-static void rt5621_hp_detect_timer(unsigned long data)
-{
-	struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
-	rt5621_work.data = (unsigned long)codec;
-	schedule_work(&rt5621_work.rt5621_workqueue);
-	mod_timer(&timer, jiffies + HZ*1);
-}
-
-#endif
-static int Init_Aux_Hp(struct snd_soc_codec *codec)
-{
-    if (hp_detect_flag==1){
-    	printk("Init: Headphone has been pluged\n");
-	    snd_soc_dapm_disable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-	    snd_soc_dapm_sync(codec);
-	    // pull down the gpio to mute spk
-	    switch_audio(1);
-        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
-    }else if(hp_detect_flag==0){
-    	printk("Init: Headphone has been unpluged\n");
-	    snd_soc_dapm_enable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-	    snd_soc_dapm_sync(codec);
-        snd_soc_jack_report(&hp_jack, 0, SND_JACK_HEADSET);
-	    switch_audio(0);
-    }
-}
-static int aml_m1_codec_init(struct snd_soc_codec *codec)
-{
-    struct snd_soc_card *card = codec->socdev->card;
-
-    int err;
-
-    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
-    if(err){
-	    dev_warn(card->dev, "Failed to register DAPM widgets\n");
-		return 0;
-	}
-/*
-    err = snd_soc_dapm_add_routes(codec, intercon,
-        ARRAY_SIZE(intercon));
-    if(err){
-        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
-        return 0;
-    }
-*/
-
-#if HP_DET
-    if ((rt5621_dai.ac97_pdata) && ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged)
-        hp_detect_flag = ((struct rt5621_platform_data *) (rt5621_dai.ac97_pdata))->is_hp_pluged() ? (0) : (1);
-    else
-        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
-
-    err = snd_soc_jack_new(card, "hp_switch",
-        SND_JACK_HEADSET, &hp_jack);
-    if(err){
-        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
-    }else{
-        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
-        if(err){
-            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
-        }
-    }
-
-    // create a timer to poll the HP IN status
-    spin_lock_init(&lock);
-    timer.function = &rt5621_hp_detect_timer;
-    timer.data = (unsigned long)codec;
-    timer.expires = jiffies + HZ*1;
-    init_timer(&timer);
-	INIT_WORK(&rt5621_work.rt5621_workqueue, rt5621_hp_detect_queue);
-	add_timer(&timer);
-#endif
-
-    snd_soc_dapm_nc_pin(codec,"LINPUT1");
-    snd_soc_dapm_nc_pin(codec,"RINPUT1");
-
-    snd_soc_dapm_enable_pin(codec, "Ext Spk");
-    snd_soc_dapm_disable_pin(codec, "HP");
-    snd_soc_dapm_enable_pin(codec, "MIC IN");
-    snd_soc_dapm_disable_pin(codec, "HP MIC");
-    snd_soc_dapm_disable_pin(codec, "FM IN");
-
-//    snd_soc_dapm_sync(codec);
-	Init_Aux_Hp(codec);    
-    return 0;
-}
-
-
-static struct snd_soc_dai_link aml_m1_dai = {
-    .name = "AML-M1",
-    .stream_name = "AML M1 PCM",
-    .cpu_dai = &aml_dai[0],  //////
-    .codec_dai = &rt5621_dai,
-    .init = aml_m1_codec_init,
-    .ops = &aml_m1_ops,
-};
-
-static struct snd_soc_card snd_soc_aml_m1 = {
-    .name = "AML-M1",
-    .platform = &aml_soc_platform,
-    .dai_link = &aml_m1_dai,
-    .num_links = 1,
-    .set_bias_level = aml_m1_set_bias_level,
-};
-
-//flove111810_S
-static struct rt5621_setup_data aml_rt5621_setup =
-{
-    .i2c_address = RT5621_I2C_ADDR,
-    .i2c_bus = 0,
-};
-//flove111810_E
-
-static struct snd_soc_device aml_m1_snd_devdata =
-{
-    .card = &snd_soc_aml_m1,
-    .codec_dev = &soc_codec_dev_rt5621,
-    .codec_data = &aml_rt5621_setup,	//flove111810
-};
-
-static struct platform_device *aml_m1_snd_device;
-static struct platform_device *aml_m1_platform_device;
-
-static int aml_m1_audio_probe(struct platform_device *pdev)
-{
-    int ret;
-    //pdev->dev.platform_data;
-    // TODO
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-    aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
-    if (!aml_m1_snd_device) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        ret = -ENOMEM;
-    }
-
-    platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
-    aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
-
-    ret = platform_device_add(aml_m1_snd_device);
-    if (ret) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        goto error;
-    }
-
-    aml_m1_platform_device = platform_device_register_simple("aml_m1_codec", -1, NULL, 0);
-    return 0;
-error:
-    platform_device_put(aml_m1_snd_device);
-    return ret;
-}
-
-static int aml_m1_audio_remove(struct platform_device *pdev)
-{
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-
-#if HP_DET
-    del_timer_sync(&timer);
-    
-#endif
-    platform_device_unregister(aml_m1_snd_device);
-    return 0;
-}
-
-static struct platform_driver aml_m1_audio_driver =
-{
-    .probe  = aml_m1_audio_probe,
-    .remove = aml_m1_audio_remove,
-    .driver = {
-        .name = "aml_m1_audio_rt5621",
-        .owner = THIS_MODULE,
-    },
-};
-
-static int __init aml_m1_init(void)
-{
-    return platform_driver_register(&aml_m1_audio_driver);
-}
-
-static void __exit aml_m1_exit(void)
-{
-    platform_driver_unregister(&aml_m1_audio_driver);
-}
-
-module_init(aml_m1_init);
-module_exit(aml_m1_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m1_mid_wm8900.c b/sound/soc/aml/aml_m1_mid_wm8900.c
deleted file mode 100644
index e46506f42954..000000000000
--- a/sound/soc/aml/aml_m1_mid_wm8900.c
+++ /dev/null
@@ -1,338 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/wm8900.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "../codecs/wm8900.h"
-
-#define HP_DET 1
-
-#if HP_DET
-static struct timer_list timer;
-static int hp_detect_flag = 0;
-void mute_spk(struct snd_soc_codec* codec, int flag);
-#endif
-
-static int aml_m1_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
-    int ret;
-    // TODO
-printk("***Entered %s:%s\n", __FILE__,__func__);
-
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-    if(ret<0)
-        return ret;
-
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-    if(ret<0)
-        return ret;
-
-    return 0;
-}
-    
-static struct snd_soc_ops aml_m1_ops = {
-    .hw_params = aml_m1_hw_params,
-};
-
-static int aml_m1_set_bias_level(struct snd_soc_card *card,
-    enum snd_soc_bias_level level)
-{
-    int ret = 0;
-    struct snd_soc_codec *codec = card->codec;
-    // TODO
-printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-    case SND_SOC_BIAS_PREPARE:
-#if HP_DET
-        del_timer_sync(&timer);
-        timer.expires = jiffies + HZ*5;
-        del_timer(&timer);
-        add_timer(&timer);
-        hp_detect_flag = 0xf0000000;
-#endif
-        break;
-    case SND_SOC_BIAS_OFF:
-    case SND_SOC_BIAS_STANDBY:
-#if HP_DET
-        del_timer(&timer);
-        hp_detect_flag = 0xf0000000;        
-        mute_spk(codec,1);
-#endif
-        break;
-    };
-
-    return ret;
-}
-
-static const struct snd_soc_dapm_widget aml_m1_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("MIC IN", NULL),
-    SND_SOC_DAPM_MIC("HP MIC", NULL),
-    SND_SOC_DAPM_LINE("FM IN", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-
-    /* speaker connected to LINEOUT */
-    {"Ext Spk", NULL, "LINEOUT1L"},
-    {"Ext Spk", NULL, "LINEOUT1R"},
-    /* mic is connected to Mic Jack, with WM8731 Mic Bias */
-    {"HP", NULL, "HP_L"},
-    {"HP", NULL, "HP_R"},
-    {"LINPUT2", NULL, "Mic Bias"},
-    {"Mic Bias", NULL, "MIC IN"},
-    {"RINPUT2", NULL, "Mic Bias"},
-    {"Mic Bias", NULL, "HP MIC"},
-    {"LINPUT3", NULL, "FM IN"},
-    {"RINPUT3", NULL, "FM IN"},
-};
-
-#if HP_DET
-
-/* Hook switch */
-
-static struct snd_soc_jack hp_jack;
-
-static struct snd_soc_jack_pin hp_jack_pins[] = {
-    { .pin = "HP", .mask = SND_JACK_HEADSET },
-};
-
-static spinlock_t lock;
-static void wm8900_hp_detect_queue(struct work_struct*);
-static struct wm8900_work_t{
-unsigned long data;
-struct work_struct wm8900_workqueue;
-}wm8900_work;
-
-void mute_spk(struct snd_soc_codec* codec, int flag)
-{
-    int gpio_status = 0;
-    if(flag){
-        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
-        gpio_status &= ~(7<<4);
-        gpio_status |= (6<<4);
-        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
-    }else{
-        gpio_status = snd_soc_read(codec, WM8900_REG_GPIO);
-        gpio_status &= ~(7<<4);
-        gpio_status |= (7<<4);
-        snd_soc_write(codec, WM8900_REG_GPIO, gpio_status);
-    }
-}
-
-static void wm8900_hp_detect_queue(struct work_struct* work)
-{
-    int level = 0x0;
-    struct wm8900_work_t* pwork = container_of(work,struct wm8900_work_t, wm8900_workqueue);
-    struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
-
-    if ((wm8900_dai.ac97_pdata) && ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged)
-        level = ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged();
-
-    //printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
-    if(level == 0x1 && hp_detect_flag!= 0x1){ // HP
-        printk("Headphone pluged in\n");
-        snd_soc_dapm_disable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-        snd_soc_dapm_sync(codec);
-        // pull down the gpio to mute spk
-        mute_spk(codec, 1);
-        snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
-        hp_detect_flag = level;
-    }else if(level != hp_detect_flag){ // HDMI
-        printk("Headphone unpluged\n");
-        snd_soc_dapm_enable_pin(codec, "Ext Spk");
-        snd_soc_dapm_enable_pin(codec, "MIC IN");
-        snd_soc_dapm_sync(codec);
-        snd_soc_jack_report(&hp_jack,0, SND_JACK_HEADSET);
-        hp_detect_flag = level;
-        mute_spk(codec, 0);
-    }
-}
-
-static void wm8900_hp_detect_timer(unsigned long data)
-{
-    struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
-    wm8900_work.data = (unsigned long)codec;
-    schedule_work(&wm8900_work.wm8900_workqueue);
-    mod_timer(&timer, jiffies + HZ*1);
-}
-
-#endif
-
-static int aml_m1_codec_init(struct snd_soc_codec *codec)
-{
-    struct snd_soc_card *card = codec->socdev->card;
-
-    int err;
-    //Add board specific DAPM widgets and routes
-    err = snd_soc_dapm_new_controls(codec, aml_m1_dapm_widgets, ARRAY_SIZE(aml_m1_dapm_widgets));
-    if(err){
-        dev_warn(card->dev, "Failed to register DAPM widgets\n");
-        return 0;
-    }
-
-    err = snd_soc_dapm_add_routes(codec, intercon,
-        ARRAY_SIZE(intercon));
-    if(err){
-        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
-        return 0;
-    }
-
-#if HP_DET
-    if ((wm8900_dai.ac97_pdata) && ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged)
-        hp_detect_flag = ((struct wm8900_platform_data *) (wm8900_dai.ac97_pdata))->is_hp_pluged() ? (0) : (1);
-    else
-        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
-
-    err = snd_soc_jack_new(card, "hp_switch",
-        SND_JACK_HEADSET, &hp_jack);
-    if(err){
-        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
-    }else{
-        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
-        if(err){
-            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
-        }
-    }
-
-    // create a timer to poll the HP IN status
-    spin_lock_init(&lock);
-    timer.function = &wm8900_hp_detect_timer;
-    timer.data = (unsigned long)codec;
-    timer.expires = jiffies + HZ*10;
-    init_timer(&timer);
-    INIT_WORK(&wm8900_work.wm8900_workqueue, wm8900_hp_detect_queue);
-#endif
-
-    snd_soc_dapm_nc_pin(codec,"LINPUT1");
-    snd_soc_dapm_nc_pin(codec,"RINPUT1");
-
-    snd_soc_dapm_enable_pin(codec, "Ext Spk");
-    snd_soc_dapm_disable_pin(codec, "HP");
-    snd_soc_dapm_enable_pin(codec, "MIC IN");
-    snd_soc_dapm_disable_pin(codec, "HP MIC");
-    snd_soc_dapm_disable_pin(codec, "FM IN");
-
-    snd_soc_dapm_sync(codec);
-
-    return 0;
-}
-
-
-static struct snd_soc_dai_link aml_m1_dai = {
-    .name = "AML-M1",
-    .stream_name = "AML M1 PCM",
-    .cpu_dai = &aml_dai[0],  //////
-    .codec_dai = &wm8900_dai,
-    .init = aml_m1_codec_init,
-    .ops = &aml_m1_ops,
-};
-
-static struct snd_soc_card snd_soc_aml_m1 = {
-    .name = "AML-M1",
-    .platform = &aml_soc_platform,
-    .dai_link = &aml_m1_dai,
-    .num_links = 1,
-    .set_bias_level = aml_m1_set_bias_level,
-};
-
-static struct snd_soc_device aml_m1_snd_devdata = {
-    .card = &snd_soc_aml_m1,
-    .codec_dev = &soc_codec_dev_wm8900,
-};
-
-static struct platform_device *aml_m1_snd_device;
-static struct platform_device *aml_m1_platform_device;
-
-static int aml_m1_audio_probe(struct platform_device *pdev)
-{
-    int ret;
-
-    // TODO
-    printk("***Entered %s:%s\n", __FILE__,__func__);
-    aml_m1_snd_device = platform_device_alloc("soc-audio", -1);
-    if (!aml_m1_snd_device) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        ret = -ENOMEM;
-    }
-
-    platform_set_drvdata(aml_m1_snd_device,&aml_m1_snd_devdata);
-    aml_m1_snd_devdata.dev = &aml_m1_snd_device->dev;
-
-    ret = platform_device_add(aml_m1_snd_device);
-    if (ret) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        goto error;
-    }
-
-    aml_m1_platform_device = platform_device_register_simple("aml_m1_codec", -1, NULL, 0);
-    return 0;
-error:
-    platform_device_put(aml_m1_snd_device);
-    return ret;
-}
-
-static int aml_m1_audio_remove(struct platform_device *pdev)
-{
-printk("***Entered %s:%s\n", __FILE__,__func__);
-
-#if HP_DET
-    del_timer_sync(&timer);
-    
-#endif
-    platform_device_unregister(aml_m1_snd_device);
-    return 0;
-}
-
-static struct platform_driver aml_m1_audio_driver = {
-    .probe  = aml_m1_audio_probe,
-    .remove = aml_m1_audio_remove,
-    .driver = {
-    .name = "aml_m1_audio_wm8900",
-    .owner = THIS_MODULE,
-    },
-};
-
-static int __init aml_m1_init(void)
-{
-    return platform_driver_register(&aml_m1_audio_driver);
-}
-
-static void __exit aml_m1_exit(void)
-{
-    platform_driver_unregister(&aml_m1_audio_driver);
-}
-
-module_init(aml_m1_init);
-module_exit(aml_m1_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ALSA SoC AML M1 AUDIO");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m3.c b/sound/soc/aml/aml_m3.c
deleted file mode 100644
index 6600f67ede33..000000000000
--- a/sound/soc/aml/aml_m3.c
+++ /dev/null
@@ -1,352 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/workqueue.h>
-#include <linux/switch.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/gpio.h>
-#include <sound/aml_platform.h>
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "aml_m3_codec.h"
-#include "aml_audio_hw.h"
-#define HP_DET 1
-
-
-static struct aml_audio_platform * audio_platform_data = NULL;
-
-#if HP_DET
-static struct snd_soc_jack hp_jack;
-
-static struct snd_soc_jack_pin hp_jack_pins[] = {
-    { .pin = "HP", .mask = SND_JACK_HEADSET },
-    { .pin = "HP_L", .mask = SND_JACK_HEADSET },
-    { .pin = "HP_R", .mask = SND_JACK_HEADSET },
-    { .pin = "HP_L Switch", .mask = SND_JACK_HEADSET },
-    { .pin = "HP_R Switch", .mask = SND_JACK_HEADSET },
-};
-
-static struct timer_list timer;
-static int hp_detect_flag = 0;
-static struct switch_dev sdev;
-#endif
-
-static int aml_m3_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-		struct snd_soc_pcm_runtime *rtd = substream->private_data;
-		struct snd_soc_dai *codec_dai = rtd->codec_dai;
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-		int ret;
-		// TODO
-#ifdef _AML_M3_HW_DEBUG_
-printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-		
-		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-		if(ret<0)
-			return ret;
-			
-		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S|SND_SOC_DAIFMT_NB_NF|SND_SOC_DAIFMT_CBS_CFS);
-		if(ret<0)
-			return ret;
-		
-	return 0;
-}
-	
-static struct snd_soc_ops aml_m3_ops = {
-	.hw_params = aml_m3_hw_params,
-};
-
-static int aml_m3_set_bias_level(struct snd_soc_card *card,
-					enum snd_soc_bias_level level)
-{
-    int ret = 0;
-    //struct snd_soc_codec *codec = card->dapm.codec;
-    // TODO
-
-#ifdef _AML_M3_HW_DEBUG_
-printk("***Entered %s:%s: %d\n", __FILE__,__func__, level);
-#endif
-
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-    case SND_SOC_BIAS_PREPARE:
-#if HP_DET
-        del_timer_sync(&timer);
-        timer.expires = jiffies + HZ*5;
-        del_timer(&timer);
-        add_timer(&timer);
-        hp_detect_flag = 0xf0000000;
-#endif
-        break;
-    case SND_SOC_BIAS_OFF:
-    case SND_SOC_BIAS_STANDBY:
-#if HP_DET
-        del_timer(&timer);
-        hp_detect_flag = 0xf0000000;        
-        if(audio_platform_data->mute_spk)
-          audio_platform_data->mute_spk(1);
-#endif
-        break;
-    };
-
-    return ret;
-}
-
-static const struct snd_soc_dapm_widget aml_m3_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("MIC IN", NULL),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-
-	{"Ext Spk", NULL, "LINEOUTL"},
-    {"Ext Spk", NULL, "LINEOUTR"},
-    {"HP", NULL, "HP_L"},
-    {"HP", NULL, "HP_R"},
-	//{"LINEINL", "MICBIAS", "MIC IN"},
-	//{"LINEINR", "MICBIAS", "MIC IN"},
-		
-	{"MICBIAS", NULL, "MIC IN"},
-	{"LINEINR", NULL, "MICBIAS"},
-	{"LINEINL", NULL, "MICBIAS"},
-};
-
-#if HP_DET
-
-/* Hook switch */
-
-static spinlock_t lock;
-static void aml_m3_hp_detect_queue(struct work_struct*);
-static struct aml_m3_work_t{
-	unsigned long data;
-	struct work_struct aml_m3_workqueue;
-}aml_m3_work;
-
-extern void latch_(struct snd_soc_codec* codec);
-
-static void aml_m3_hp_detect_queue(struct work_struct* work)
-{
-	int level = 0x0;
-	u16 reg;
-	struct aml_m3_work_t* pwork = container_of(work,struct aml_m3_work_t, aml_m3_workqueue);
-    struct snd_soc_codec* codec = (struct snd_soc_codec*)(pwork->data);
-
-    //if ((aml_dai[1].ac97_pdata) && ((struct aml_m3_pdata *) (aml_dai[1].ac97_pdata))->is_hp_pluged)
-        //level = ((struct aml_m3_pdata *) (aml_dai[1].ac97_pdata))->is_hp_pluged();
-    if(audio_platform_data->is_hp_pluged)
-    	level = audio_platform_data->is_hp_pluged();
-	//printk("level = %x, hp_detect_flag = %x\n", level, hp_detect_flag);
-
-	if(level == 0x1 && hp_detect_flag!= 0x1){ // HP
-		printk("Headphone pluged in\n");
-		snd_soc_jack_report(&hp_jack, SND_JACK_HEADSET, SND_JACK_HEADSET);
-		reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
-		reg &= ~0xc0;
-		snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg); //unmute HP
-        if(audio_platform_data->mute_spk)
-        	audio_platform_data->mute_spk(1);
-    	latch_(codec);
-		hp_detect_flag = level;
-		switch_set_state(&sdev, 1);
-	}else if(level != hp_detect_flag){ // HDMI
-		printk("Headphone unpluged\n");
-        snd_soc_jack_report(&hp_jack,0, SND_JACK_HEADSET);
-		reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
-		reg |= 0xc0;
-		snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg);//mute HP
-        if(audio_platform_data->mute_spk)
-    		audio_platform_data->mute_spk(0);
-		latch_(codec);
-		hp_detect_flag = level;
-		switch_set_state(&sdev, 0);
-	}
-}
-
-static void aml_m3_hp_detect_timer(unsigned long data)
-{
-    struct snd_soc_codec *codec = (struct snd_soc_codec*) data;
-    aml_m3_work.data = (unsigned long)codec;
-    schedule_work(&aml_m3_work.aml_m3_workqueue);
-    mod_timer(&timer, jiffies + HZ*1);
-}
-
-#endif
-
-static int aml_m3_codec_init(struct snd_soc_pcm_runtime *runtime)
-{
-    struct snd_soc_codec* codec = runtime->codec;
-    struct snd_soc_card *card = codec->card;
-  struct snd_soc_dapm_context* dapm = &codec->dapm;
-	int err;
-	printk("***Entered %s:%s:\n", __FILE__,__func__);
-   
-    //Add board specific DAPM widgets and routes
-    err = snd_soc_dapm_new_controls(&codec->dapm, aml_m3_dapm_widgets, ARRAY_SIZE(aml_m3_dapm_widgets));
-    if(err){
-        dev_warn(card->dev, "Failed to register DAPM widgets\n");
-        return 0;
-    }
-
-    err = snd_soc_dapm_add_routes(&codec->dapm, intercon,
-        ARRAY_SIZE(intercon));
-    if(err){
-        dev_warn(card->dev, "Failed to setup dapm widgets routine\n");
-        return 0;
-    }
-
-#if HP_DET
-        hp_detect_flag = 1; // If is_hp_pluged function is not registered in bsp, set speaker as default.
-
-    err = snd_soc_jack_new(codec, "hp_switch",
-        SND_JACK_HEADSET, &hp_jack);
-    if(err){
-        dev_warn(card->dev, "Failed to alloc resource for hook switch\n");
-    }else{
-        err = snd_soc_jack_add_pins(&hp_jack, ARRAY_SIZE(hp_jack_pins), hp_jack_pins);
-        if(err){
-            dev_warn(card->dev, "Failed to setup hook hp jack pin\n");
-        }
-    }
-	/**/
-    // create a timer to poll the HP IN status
-    spin_lock_init(&lock);
-    timer.function = &aml_m3_hp_detect_timer;
-    timer.data = (unsigned long)codec;
-    timer.expires = jiffies + HZ*10;
-    init_timer(&timer);
-    INIT_WORK(&aml_m3_work.aml_m3_workqueue, aml_m3_hp_detect_queue);
-#endif
-
-    snd_soc_dapm_nc_pin(dapm,"LINPUT1");
-    snd_soc_dapm_nc_pin(dapm,"RINPUT1");
-
-    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
-    snd_soc_dapm_disable_pin(dapm, "HP");
-    snd_soc_dapm_enable_pin(dapm, "MIC IN");
-    snd_soc_dapm_disable_pin(dapm, "HP MIC");
-    snd_soc_dapm_disable_pin(dapm, "FM IN");
-
-    snd_soc_dapm_sync(dapm);
-	/**/
-    return 0;
-}
-
-
-static struct snd_soc_dai_link aml_m3_dai = {
-	.name = "AML-M3",
-	.stream_name = "AML M3 PCM",
-	.codec_name = "aml_m3_codec",
-	.platform_name = "aml-audio",
-	.cpu_dai_name = "aml-dai0",
-	.codec_dai_name = "AML-M3",
-	.init = aml_m3_codec_init,
-	.ops = &aml_m3_ops,
-};
-
-static struct snd_soc_card snd_soc_aml_m3 = {
-	.name = "AML-M3",
-	.dai_link = &aml_m3_dai,
-	.num_links = 1,
-	.set_bias_level = aml_m3_set_bias_level,
-};
-
-static struct platform_device *aml_m3_snd_device;
-static struct platform_device *aml_m3_platform_device;
-static int aml_m3_audio_probe(struct platform_device *pdev)
-{
-		int ret;
-		//pdev->dev.platform_data;
-		// TODO
-printk("***Entered %s:%s\n", __FILE__,__func__);
-		aml_m3_snd_device = platform_device_alloc("soc-audio", -1);
-		if (!aml_m3_snd_device) {
-			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-			ret = -ENOMEM;
-		}
-
-		audio_platform_data = (struct aml_audio_platform*) pdev->dev.platform_data;
-
-		platform_set_drvdata(aml_m3_snd_device, &snd_soc_aml_m3);
-
-		ret = platform_device_add(aml_m3_snd_device);
-		if (ret) {
-			printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-			goto error2;
-		}
-		
-		aml_m3_platform_device = platform_device_register_simple("aml_m3_codec",
-								-1, NULL, 0);
-#if HP_DET
-		sdev.name = "h2w";//for report headphone to android
-		ret = switch_dev_register(&sdev);
-		if (ret < 0){
-			printk(KERN_ERR "ASoC: register switch dev failed\n");
-			goto error1;
-		}
-#endif
-		return 0;
-error1:
-		platform_device_unregister(aml_m3_snd_device);
-error2:
-		platform_device_put(aml_m3_snd_device);
-		return ret;
-}
-
-static int aml_m3_audio_remove(struct platform_device *pdev)
-{
-printk("***Entered %s:%s\n", __FILE__,__func__);
-
-#if HP_DET
-    del_timer_sync(&timer);
-    switch_dev_unregister(&sdev);
-#endif
-    platform_device_unregister(aml_m3_snd_device);
-    return 0;
-}
-
-static struct platform_driver aml_m3_audio_driver = {
-	.probe  = aml_m3_audio_probe,
-	.remove = aml_m3_audio_remove,
-	.driver = {
-		.name = "aml_m3_audio",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init aml_m3_init(void)
-{
-		return platform_driver_register(&aml_m3_audio_driver);
-}
-
-static void __exit aml_m3_exit(void)
-{
-		platform_driver_unregister(&aml_m3_audio_driver);
-}
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(aml_m3_init);
-#else
-module_init(aml_m3_init);
-#endif
-module_exit(aml_m3_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ALSA SoC AML M3 AUDIO");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m3_codec.c b/sound/soc/aml/aml_m3_codec.c
deleted file mode 100644
index 9daadcdacb37..000000000000
--- a/sound/soc/aml/aml_m3_codec.c
+++ /dev/null
@@ -1,970 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-
-#include <mach/am_regs.h>
-#include "aml_audio_hw.h"
-
-static struct snd_soc_codec *aml_m3_codec;
-
-static int (*is_hp_pluged)(void) = NULL;
-static void (*mute_spk)(struct snd_soc_codec* codec, int flag) = NULL;
-
-/* codec private data */
-struct aml_m3_codec_priv {
-	struct snd_soc_codec codec;
-	u16 reg_cache[ADAC_MAXREG];
-	unsigned int sysclk;
-};
-
-u16 aml_m3_reg[ADAC_MAXREG] = {0};
-
-unsigned long aml_rate_table[] = {
-    8000, 11025, 12000, 16000, 22050, 24000, 32000, 
-    44100, 48000, 88200, 96000, 192000
-};
-
-void latch_ (struct snd_soc_codec* codec)
-{
-    int latch;
-    latch = 1;
-    snd_soc_write(codec, ADAC_LATCH, latch);
-    latch = 0;
-    snd_soc_write(codec, ADAC_LATCH, latch);
-}
-
-
-typedef enum  {
-    AML_PWR_DOWN,
-    AML_PWR_UP,
-    AML_PWR_KEEP,
-} AML_PATH_SET_TYPE;
-
-void aml_reset_path(struct snd_soc_codec* codec, AML_PATH_SET_TYPE type)
-{
-    unsigned int pwr_reg2 = snd_soc_read(codec, ADAC_POWER_CTRL_REG2);
-    latch_(codec);
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
-    latch_(codec);
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2|(1<<7));
-    latch_(codec);
-     
-    if (AML_PWR_DOWN == type)
-    {
-        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
-        latch_(codec);
-    }
-    
-    if (AML_PWR_KEEP == type)
-    {
-        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2);
-        latch_(codec);
-    }
-}
-
-void aml_m3_reset(struct snd_soc_codec* codec, bool first_time)
-{
-	unsigned long   data32;
-
-	if (first_time)
-	{
-        //audio_set_clk(AUDIO_CLK_FREQ_48,0);
-        audio_set_clk(AUDIO_CLK_FREQ_192,0);
-	 	set_acodec_source(AIU_I2SOUT_TO_DAC);   // 0=no clock to CODEC; 1=pcmout to DAC; 2=Aiu I2S out to DAC.
-
-    	// --------------------------------------------------------
-    	// Configure audio DAC control interface
-    	// --------------------------------------------------------
-
-	    data32  = 0;
-	    data32 |= 0     << 15;  // [15]     audac_soft_reset_n
-	    data32 |= 0     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
-	    data32 |= 0     << 9;   // [9]      delay_rd_en
-	    data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
-	    data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
-	    data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
-	    WRITE_MPEG_REG(AIU_AUDAC_CTRL0, data32);
-			
-			
-	    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));
-	    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 23, 1);
-	    WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
-	    msleep(100);
-	 
-	    // Enable APB3 fail on error
-	    data32  = 0;
-	    data32 |= 1     << 15;  // [15]     err_en
-	    data32 |= 255   << 0;   // [11:0]   max_err
-	    WRITE_MPEG_REG(AIU_AUDAC_CTRL1, data32);
-	    // Check read back data
-	    data32 = READ_MPEG_REG(AIU_AUDAC_CTRL0);
-	    if (data32 != (0x55 << 1)) {
-			printk("audiocodec init error: AIU_AUDAC_CTRL0 = %lx\n", data32);
-		}
-			
-		data32 = READ_MPEG_REG(AIU_AUDAC_CTRL1);
-		if (data32 != 0x80ff) {
-			printk("audiocodec init error: AIU_AUDAC_CTRL1 = %lx\n", data32);
-		}
-
-		wr_regbank (0,			// rstdpz: active low.
-					0,			// mclksel[3:0]: master clock freq sel. 0=256Fs, 1=384Fs, ... 
-					8,		    // i2sfsadc[3:0]: sample freq sel. 0=8kHz, 1=11.025k, 2=12k, 3=16k, 4=22.05k, 5=24k, 6=32k, 7=44.1k, 8=48k, 9=88.2k, 10=96k, 11=192k, >11=Rsrv.
-					8,		    // i2sfsdac[3:0]: sample freq sel. 0=8kHz, 1=11.025k, 2=12k, 3=16k, 4=22.05k, 5=24k, 6=32k, 7=44.1k, 8=48k, 9=88.2k, 10=96k, 11=192k, >11=Rsrv.
-					1,			// i2ssplit: 0=single mode, 1=dual mode.
-					1,			// i2smode[2:0]: Data format sel. 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
-					1,			// pdauxdrvrz: 0=power down active, 1=normal.
-					1,			// pdauxdrvlz: 0=power down active, 1=normal.
-					1,			// pdhsdrvrz: 0=power down active, 1=normal.
-					1,			// pdhsdrvlz: 0=power down active, 1=normal.
-					1,			// pdlsdrvz: 0=power down active, 1=normal.
-					1,			// pddacrz: 0=power down active, 1=normal.
-					1,			// pddaclz: 0=power down active, 1=normal.
-					0,			// pdz: 0=power down active, 1=normal.
-					1,			// pdmbiasz: 0=power down active, 1=normal.
-					1,			// pdvcmbufz: 0=power down active, 1=normal.
-					1,			// pdrpgaz: 0=power down active, 1=normal.
-					1,			// pdlpgaz: 0=power down active, 1=normal.
-					1,			// pdadcrz: 0=power down active, 1=normal.
-					1,			// pdadclz: 0=power down active, 1=normal.
-					0,			// hsmute[1:0]: bit[1] Analog playback right channel mute, bit[0] Analog playback left channel mute.
-					0,			// recmute[1:0]: bit[1] Digital record right channel mute, bit[0] Digital record left channel mute.
-					0,			// micmute[1:0]: bit[1] Input PGA right channel mute, bit[0] Input PGA left channel mute.
-					0,			// lmmute[1:0]: bit[1] Digital playback right channel mute, bit[0] Digital playback left channel mute.
-					0,			// lsmute: loud speaker mute.
-					0,			// lmmix: Playback digital mixer sel.
-					0,			// recmix: Record digital mixer sel.
-					0,			// ctr[1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
-					1,			// enhp: Record channel high pass filter enable.
-					0x5454, 	// lmvol[15:0]: Digital playback volumn control, [15:8] control right channel, [7:0] control left channel.
-								// 0=-126dB, 1=-124.5dB, ..., 0x53=-1.5dB, 0x54=0dB, >=0x55 Rsrv.
-					0x2828, 	// hsvol[15:0]: Analog playback headset volumn control, [15:8] control right channel, [7:0] control left channel.
-								// 0=-40dB, 1=-39dB, ..., 0x28=0dB, ..., 0x2e=6dB, >=0x2f Rsrv.
-					0,			// pbmix[15:0]: Playback channel mixing sel. [15:8] control right channel, [7:0] control left channel.
-								// 0=Left(Right) digital source only, 1=Analog source only, 2=Analog + left(right) digital,
-								// 3=Right(Left) digital sourcd only, 4=Left(Right) digital + right(left) digital, 5=Analog + right(left) digital,
-								// 6=Analog + left(right) digital + right(left) digital, >=7 Rsrv.
-					0x0001, 	// lsmix[15:0]
-					0x1212, 	// micvol[15:0]: Input PGA volume control. [15:8] control right channel, [7:0] control left channel.
-								// 0=-6dB, 1=-4.5dB, ..., 4=0dB, ..., 0x11=19.5dB, 0x12=21dB, >=0x13 Rsrv.
-					0x1111, 	// recvol[15:0]: Digital record channel master volume control. [15:8] control right channel, [7:0] control left channel.
-								// 0=30dB, 1=28.5dB, ..., 0x13=1.5dB, 0x14=0dB, 0x15=-1.5dB, ..., 0x54=-96dB, >=0x55 Rsrv.
-					0x0101);	// recsel[15:0]: Input PGA selection. [15:8] control right channel, [7:0] control left channel.
-								// 0x01=input1, 0x03=input2, 0x05=input3, 0x09=input4,
-								// 0x11=input5, 0x21=input6, 0x41=input7, 0x81=input8, others=Rsrv.
-        adac_power_up_mode_2();
-        adac_startup_seq();
-
-	    udelay(10);
-	    
-	    if(is_hp_pluged && is_hp_pluged()) {
-	    	data32 = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
-		    data32 &= ~0xc0;
-		    snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, data32); //unmute HP
-    	    if(mute_spk)
-              mute_spk(codec, 1);
-    	    latch_(codec);
-    	}
-    	else {
-    		data32 = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
-	    	data32 |= 0xc0;
-		    snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, data32);//mute HP
-    		if(mute_spk)
-              mute_spk(codec, 0);
-	    	latch_(codec);
-        }
-	    
-/*			snd_soc_write(codec, ADAC_RESET, (0<<1));
-	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
-	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
-	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
-	    	snd_soc_write(codec, ADAC_RESET, (0<<1));
-	    	msleep(100);
-	        
-
-	    	snd_soc_write(codec,ADAC_CLOCK, 0); // 256fs
-	    	snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, (7<<4)|7);	 // samplerate for ADC&DAC
-	    	snd_soc_write(codec, ADAC_I2S_CONFIG_REG2, 1|(1<<3)); 		// I2S | split
-
-	        snd_soc_write(codec, ADAC_MUTE_CTRL_REG1,0);
-	    	snd_soc_write(codec, ADAC_MUTE_CTRL_REG2, 0);
-	        
-	        snd_soc_write(codec,ADAC_DAC_ADC_MIXER, 0);
-
-	        snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_LSB, 0x54);
-	        snd_soc_write(codec,ADAC_PLAYBACK_VOL_CTRL_MSB, 0x54);
-	        snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_LSB, 0x28);
-	        snd_soc_write(codec,ADAC_STEREO_HS_VOL_CTRL_MSB, 0x28); 
-
-	        snd_soc_write(codec, ADAC_PLAYBACK_MIX_CTRL_LSB, 0);
-	        snd_soc_write(codec, ADAC_PLAYBACK_MIX_CTRL_MSB, 0);
-
-	        snd_soc_write(codec, ADAC_STEREO_PGA_VOL_LSB, 4);
-	        snd_soc_write(codec, ADAC_STEREO_PGA_VOL_MSB, 4);
-
-	        snd_soc_write(codec, ADAC_RECVOL_CTRL_LSB, 0x14);
-	        snd_soc_write(codec, ADAC_RECVOL_CTRL_MSB, 0x14);
-
-	        snd_soc_write(codec, ADAC_REC_CH_SEL_LSB, 1|(1<<(1-1)));// 1|(1<<(channel-1))
-	        snd_soc_write(codec, ADAC_REC_CH_SEL_MSB, 1|(1<<(1-1)));// 1|(1<<(channel-1))
-
-	        snd_soc_write(codec, ADAC_POWER_CTRL_REG1, 0xf7);
-	      	snd_soc_write(codec, ADAC_POWER_CTRL_REG2, 0x2f);
-
-	        snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
-	        snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
-	   
-	    	aml_reset_path(codec, AML_PWR_UP);
-	        aml_reset_path(codec, AML_PWR_DOWN);
-*/
-
-	}
-    else
-    {
-        snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
-        snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
-        aml_reset_path(codec, AML_PWR_UP);
-
-    	latch_(codec);
-	    snd_soc_write(codec, ADAC_RESET, (0<<1));
-        latch_(codec);
-	    latch_(codec);
-    	latch_(codec);
-	    snd_soc_write(codec, ADAC_RESET, (1<<1));
-        latch_(codec);
-	    latch_(codec);
-    }
-    msleep(200);
-}
-
-
-int audio_dac_set(unsigned freq)
-{
-  return 0;
-}
-
-static int post_reset(struct snd_soc_dapm_widget *w,
-	    struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-    
-	if (SND_SOC_DAPM_POST_PMU == event)
-		{
-        aml_m3_reset(codec,false);
-        }
-    else if (SND_SOC_DAPM_POST_PMD == event && codec->active == 0)
-        aml_reset_path(codec, AML_PWR_DOWN);
-	return 0;
-}
-
-static int aml_switch_get_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-    struct snd_soc_dapm_widget *w;
-    //struct snd_soc_dapm_context * dapm = &codec->dapm;
-    char *lname = NULL;
-    char *rname = NULL;
-
-    switch (e->reg)
-    {
-    case ADAC_POWER_CTRL_REG1:
-        if (6 == e->shift_l)
-        {
-            lname = "LINEOUTL";
-            rname = "LINEOUTR";
-        }
-        else if (4 == e->shift_l)
-        {
-            lname = "HP_L";
-            rname = "HP_R";
-        }
-        else if (2 == e->shift_l)
-        {
-            lname = "SPEAKER";
-        }
-    break;
-    case ADAC_POWER_CTRL_REG2:
-        if (2 == e->shift_l)
-        {
-            lname = "LINEINL";
-            rname = "LINEINR";
-        }
-    break;
-    default:
-    break;
-    }
-    
-	list_for_each_entry(w, &codec->card->widgets, list) {
-        if (lname && !strcmp(lname, w->name))
-            ucontrol->value.enumerated.item[0] = w->connected;
-        if (rname && !strcmp(rname, w->name))
-            ucontrol->value.enumerated.item[0] = w->connected;
-	}
-
-	return 0;
-}
-
-static int aml_switch_put_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-    struct snd_soc_dapm_widget *w;
-    char *lname = NULL;
-    char *rname = NULL;
-    unsigned int pwr_reg;
-
-    switch (e->reg)
-    {
-    case ADAC_POWER_CTRL_REG1:
-        if (6 == e->shift_l)
-        {
-            lname = "LINEOUTL";
-            rname = "LINEOUTR";
-        }
-        else if (4 == e->shift_l)
-        {
-            lname = "HP_L";
-            rname = "HP_R";
-        }
-        else if (2 == e->shift_l)
-        {
-            lname = "SPEAKER";
-        }
-    break;
-    case ADAC_POWER_CTRL_REG2:
-        if (2 == e->shift_l)
-        {
-            lname = "LINEINL";
-            rname = "LINEINR";
-        }
-    break;
-    default:
-    break;
-    }
-
-    pwr_reg = snd_soc_read(codec, e->reg);
-    if(ucontrol->value.enumerated.item[0] == 0){
-    snd_soc_write(codec, e->reg, (pwr_reg&(~(0x1<<(e->shift_l)|0x1<<(e->shift_r)))));
-    }
-    else{
-    snd_soc_write(codec, e->reg, (pwr_reg|(0x1<<(e->shift_l)|0x1<<(e->shift_r))));
-    }
-
-	list_for_each_entry(w, &codec->card->widgets, list) {
-        if (lname && !strcmp(lname, w->name))
-        {
-            w->connected = ucontrol->value.enumerated.item[0];
-            printk("%s:connect=%d\n",w->name,w->connected);
-        }
-        if (rname && !strcmp(rname, w->name))
-        {
-            w->connected = ucontrol->value.enumerated.item[0];
-            printk("%s:connect=%d\n",w->name,w->connected);
-        }
-	}
-
-	return 0;
-}
-
-static int aml_put_volsw_2r(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    int err = snd_soc_put_volsw_2r(kcontrol, ucontrol);
-    if (err < 0)
-        return err;
-
-    aml_reset_path(codec, AML_PWR_KEEP);
-    return 0;
-}
-
-static int aml_ai_source_get_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-    //struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-
-    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 0)
-        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
-    
-    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 1) 
-        ucontrol->value.enumerated.item[0] = 0;// linein
-    else
-        ucontrol->value.enumerated.item[0] = 1;//hdmi
-        
-    return 0;
-}
-
-static int aml_ai_source_put_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-    
-    if (ucontrol->value.enumerated.item[0] == 0)
-        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
-    else
-        WRITE_MPEG_REG(AUDIN_SOURCE_SEL,    (1<<4) | (2 << 0));    // Select HDMI RX output as AUDIN source
-
-    snd_soc_write(codec, ADAC_RESET, (0<<1));
-    latch_(codec);
-    snd_soc_write(codec, ADAC_RESET, (1<<1));
-    latch_(codec);
-    
-    return 0;
-}
-
-void aml_linein_start(void)
-{
-    // power up adc
-    unsigned int pwr_reg2 = snd_soc_read(aml_m3_codec, ADAC_POWER_CTRL_REG2);
-    snd_soc_write(aml_m3_codec, ADAC_POWER_CTRL_REG2, pwr_reg2|0xF);
-    latch_(aml_m3_codec);
-    // power up codec
-    aml_reset_path(aml_m3_codec, AML_PWR_UP);
-    snd_soc_write(aml_m3_codec, ADAC_RESET, (0<<1));
-    latch_(aml_m3_codec);
-    snd_soc_write(aml_m3_codec, ADAC_RESET, (1<<1));
-    latch_(aml_m3_codec);
-}
-
-void aml_linein_stop(void)
-{
-    // power down adc
-    unsigned int pwr_reg2 = snd_soc_read(aml_m3_codec, ADAC_POWER_CTRL_REG2);
-    snd_soc_write(aml_m3_codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~0xF));
-    latch_(aml_m3_codec);
-    // power down codec
-    if (aml_m3_codec->active == 0)
-        aml_reset_path(aml_m3_codec, AML_PWR_DOWN);
-}
-
-static const DECLARE_TLV_DB_SCALE(lineout_volume, -12600, 150, 0);
-static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
-static const DECLARE_TLV_DB_SCALE(linein_volume, -9600, 150, 0);
-
-static const char *left_linein_texts[] = {
-	"Left Line In 1", "Left Line In 2", "Left Line In 3", "Left Line In 4",
-	"Left Line In 5", "Left Line In 6", "Left Line In 7", "Left Line In 8"
-	};
-
-static const char *right_linein_texts[] = {
-	"Right Line In 1", "Right Line In 2", "Right Line In 3", "Right Line In 4",
-	"Right Line In 5", "Right Line In 6", "Right Line In 7", "Right Line In 8"
-	};
-
-static const unsigned int linein_values[] = {
-    1|(1<<(1-1)),
-    1|(1<<(2-1)),
-    1|(1<<(3-1)),
-    1|(1<<(4-1)),
-    1|(1<<(5-1)),
-    1|(1<<(6-1)),
-    1|(1<<(7-1)),
-    1|(1<<(8-1))
-    };
-
-static const char *iis_split_texts[] = {
-	"iis_not_split", "iis_split"
-	};
-
-static const unsigned int iis_split_values[] = {
-	0,
-	1
-    };
-
-
-static const SOC_VALUE_ENUM_SINGLE_DECL(left_linein_select, ADAC_REC_CH_SEL_LSB,
-		0, 0xff, left_linein_texts, linein_values);
-static const SOC_VALUE_ENUM_SINGLE_DECL(right_linein_select, ADAC_REC_CH_SEL_MSB,
-		0, 0xff, right_linein_texts, linein_values);
-static const SOC_VALUE_ENUM_SINGLE_DECL(iis_split_select, ADAC_I2S_CONFIG_REG2,
-		3, 0xff, iis_split_texts, iis_split_values);
-
-static const char *switch_op_modes_texts[] = {
-	"OFF", "ON"
-};
-static const struct soc_enum lineout_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG1, 6, 7,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-static const struct soc_enum hp_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG1, 4, 5,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-static const struct soc_enum linein_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG2, 2, 2,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-static const struct soc_enum sp_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL_REG1, 2, 3,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-
-static const char *audio_in_source_texts[] = {
-	"LINEIN", "HDMI"
-};
-static const struct soc_enum audio_in_source_enum =
-	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
-			ARRAY_SIZE(audio_in_source_texts),
-			audio_in_source_texts);
-
-
-static const struct snd_kcontrol_new amlm3_snd_controls[] = {
-	SOC_DOUBLE_R_EXT_TLV("LINEOUT Playback Volume", ADAC_PLAYBACK_VOL_CTRL_LSB, ADAC_PLAYBACK_VOL_CTRL_MSB,
-	       0, 84, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, lineout_volume),
-	      
-	 SOC_DOUBLE_R_EXT_TLV("HeadSet Playback Volume", ADAC_STEREO_HS_VOL_CTRL_LSB, ADAC_STEREO_HS_VOL_CTRL_MSB,
-	       0, 46, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, hs_volume),
-
-    SOC_DOUBLE_R_EXT_TLV("LINEIN Capture Volume", ADAC_RECVOL_CTRL_LSB, ADAC_RECVOL_CTRL_MSB,
-	       0, 84, 1, snd_soc_get_volsw_2r, aml_put_volsw_2r, linein_volume),
-
-	SOC_VALUE_ENUM("Left LINEIN Select",left_linein_select),
-	SOC_VALUE_ENUM("Right LINEIN Select",right_linein_select),
-	SOC_VALUE_ENUM("IIS Split Select", iis_split_select),
-
-    SOC_ENUM_EXT("LOUT Playback Switch", lineout_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-		
-    SOC_ENUM_EXT("HP Playback Switch", hp_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-		
-	SOC_ENUM_EXT("LIN Capture Switch", linein_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-		
-	SOC_ENUM_EXT("SP Playback Switch", sp_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-
-    SOC_ENUM_EXT("Audio In Source", audio_in_source_enum,
-        aml_ai_source_get_enum,aml_ai_source_put_enum),
-
-};
-
-static const struct snd_kcontrol_new lineoutl_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 0, 1, 1);
-static const struct snd_kcontrol_new lineoutr_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 1, 1, 1);
-static const struct snd_kcontrol_new hsl_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 6, 1, 1);
-static const struct snd_kcontrol_new hsr_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 7, 1, 1);
-static const struct snd_kcontrol_new spk_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 2, 1, 1);
-
-static const struct snd_kcontrol_new lineinl_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 4, 1, 1);
-static const struct snd_kcontrol_new lineinr_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 5, 1, 1);
-
-static const struct snd_soc_dapm_widget aml_m3_dapm_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
-	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
-	SND_SOC_DAPM_OUTPUT("HP_L"),
-	SND_SOC_DAPM_OUTPUT("HP_R"),
-	SND_SOC_DAPM_OUTPUT("SPEAKER"),
-
-	SND_SOC_DAPM_INPUT("LINEINL"),
-	SND_SOC_DAPM_INPUT("LINEINR"),
-	
-	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
-	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
-	SND_SOC_DAPM_ADC("ADCL", "Left ADC Capture", ADAC_POWER_CTRL_REG2, 0, 0),
-	SND_SOC_DAPM_ADC("ADCR", "Right ADC Capture", ADAC_POWER_CTRL_REG2, 1, 0),
-
-	SND_SOC_DAPM_SWITCH("LINEOUTL Switch", ADAC_POWER_CTRL_REG1, 6, 0,
-			    &lineoutl_switch_controls),
-	SND_SOC_DAPM_SWITCH("LINEOUTR Switch", ADAC_POWER_CTRL_REG1, 7, 0,
-			    &lineoutr_switch_controls),
-	SND_SOC_DAPM_SWITCH("HP_L Switch", ADAC_POWER_CTRL_REG1, 4, 0,
-			    &hsl_switch_controls),
-	SND_SOC_DAPM_SWITCH("HP_R Switch", ADAC_POWER_CTRL_REG1, 5, 0,
-			    &hsr_switch_controls),
-	SND_SOC_DAPM_SWITCH("SPEAKER Switch", ADAC_POWER_CTRL_REG1, 2, 0,
-			    &spk_switch_controls),
-
-	SND_SOC_DAPM_SWITCH("LINEINL Switch", ADAC_POWER_CTRL_REG2, 2, 0,
-			    &lineinl_switch_controls),
-	SND_SOC_DAPM_SWITCH("LINEINR Switch", ADAC_POWER_CTRL_REG2, 3, 0,
-			    &lineinr_switch_controls),
-
-    SND_SOC_DAPM_POST("RESET", post_reset),
-	
-	//SND_SOC_DAPM_PGA("HSL", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
-	//SND_SOC_DAPM_PGA("HSR", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
-	
-	//SND_SOC_DAPM_PGA("PDZ", ADAC_POWER_CTRL_REG2, 7, 0, NULL, 0),
-	SND_SOC_DAPM_MICBIAS("MICBIAS", ADAC_POWER_CTRL_REG2, 5, 0)
-};
-
-/* Target, Path, Source */
-
-static const struct snd_soc_dapm_route aml_m3_audio_map[] = {
-	{"LINEOUTL", NULL, "LINEOUTL Switch"},
-	{"LINEOUTL Switch", NULL, "DACL"},
-	{"LINEOUTR", NULL, "LINEOUTR Switch"},
-	{"LINEOUTR Switch", NULL, "DACR"},
-	
-	{"HP_L", NULL, "HP_L Switch"},
-	{"HP_L Switch", NULL, "DACL"},
-	{"HP_R", NULL, "HP_R Switch"},
-	{"HP_R Switch", NULL, "DACR"},
-
-	{"SPEAKER", NULL, "SPEAKER Switch"},
-	{"SPEAKER Switch", NULL, "DACL"},
-	{"SPEAKER Switch", NULL, "DACR"},
-
-    {"ADCL", NULL, "LINEINL Switch"},
-    {"LINEINL Switch", NULL, "LINEINL"},
-	{"ADCR", NULL, "LINEINR Switch"},
-	{"LINEINR Switch", NULL, "LINEINR"},
-};
-
-static int aml_m3_write(struct snd_soc_codec *codec, unsigned int reg,
-							unsigned int value)
-{
-    u16 *reg_cache = codec->reg_cache;
-	
-	//printk("***Entered %s:%s:\nWriting reg is %#x; value=%#x\n",__FILE__,__func__, reg, value);
-	if (reg >= codec->reg_size/sizeof(u16))
-		return -EINVAL;
-	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
-	reg_cache[reg] = value;
-
-//printk("Read back reg is %#x value=%#x\n", reg, READ_APB_REG(APB_BASE+(reg<<2)));
-
-	return 0;
-}
-
-static unsigned int aml_m3_read(struct snd_soc_codec *codec,
-							unsigned int reg)
-{
-	//u16 *reg_cache = codec->reg_cache;
-	if (reg >= codec->reg_size/sizeof(u16))
-		return -EINVAL;
-	
-	return READ_APB_REG(APB_BASE+(reg<<2));
-	//return reg_cache[reg];
-}
-
-static int aml_m3_codec_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-    unsigned int i2sfs;
-    unsigned long rate = params_rate(params);
-    int rate_idx = 0;
-
-    for (rate_idx = 0; rate_idx < ARRAY_SIZE(aml_rate_table); rate_idx++)
-        if (aml_rate_table[rate_idx] == rate)
-            break;
-    if (ARRAY_SIZE(aml_rate_table) == rate_idx)
-        rate_idx = 0;
-
-    i2sfs = snd_soc_read(codec, ADAC_I2S_CONFIG_REG1);
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-        snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, (i2sfs&0x0f)|(rate_idx<<4));
-    else
-        snd_soc_write(codec, ADAC_I2S_CONFIG_REG1, (i2sfs&0xf0)|rate_idx);
-
-    aml_reset_path(codec, AML_PWR_KEEP);
-	return 0;
-}
-
-
-static int aml_m3_codec_pcm_prepare(struct snd_pcm_substream *substream,
-			      struct snd_soc_dai *dai)
-{
-	//struct snd_soc_codec *codec = dai->codec;
-	/* set active */
-	
-	// TODO
-
-	return 0;
-}
-
-static void aml_m3_codec_shutdown(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	/* deactivate */
-	if (!codec->active) {
-		udelay(50);
-		
-		// TODO
-	}
-}
-
-static int aml_m3_codec_mute(struct snd_soc_dai *dai, int mute)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	u16 reg;
-	// TODO
-
-	reg = snd_soc_read(codec, ADAC_MUTE_CTRL_REG1);
-	if(mute){
-		reg |= 3;
-	}
-	else{
-		reg &= ~3;
-	}
-	printk("aml_m3_codec_mute mute=%d\n",mute);
-//	snd_soc_write(codec, ADAC_MUTE_CTRL_REG1, reg);
-	return 0;
-}
-
-static int aml_m3_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
-		int clk_id, unsigned int freq, int dir)
-{
-	//struct snd_soc_codec *codec = codec_dai->codec;
-	unsigned long data = 0;
-	
-	switch (freq) {
-	case 32000:
-		data = 6;
-		break;
-	case 44100:
-		data = 7;
-		break;
-	case 48000:
-		data = 8;
-		break;
-	case 96000:
-		data = 10;
-		break;
-	default:
-		data = 6;
-		break;
-	}
-	//snd_soc_write(codec,ADAC_CLOCK, 0);
-	//snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, data);
-	return 0;
-}
-
-
-static int aml_m3_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
-		unsigned int fmt)
-{
-	//struct snd_soc_codec *codec = codec_dai->codec;
-	u16 iface = 0;
-	/* set master/slave audio interface */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		iface |= 0x0040;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* interface format */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		iface |= 0x0002;
-		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		iface |= 0x0001;
-		break;
-	case SND_SOC_DAIFMT_DSP_A:
-		iface |= 0x0003;
-		break;
-	case SND_SOC_DAIFMT_DSP_B:
-		iface |= 0x0013;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* clock inversion */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		iface |= 0x0090;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		iface |= 0x0080;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		iface |= 0x0010;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* set iface */
-	
-	// TODO
-	
-	return 0;
-}
-
-#define AML_RATES SNDRV_PCM_RATE_8000_96000
-
-#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
-	SNDRV_PCM_FMTBIT_S24_LE)
-
-
-static struct snd_soc_dai_ops aml_m3_codec_dai_ops = {
-	.prepare	= aml_m3_codec_pcm_prepare,
-	.hw_params	= aml_m3_codec_hw_params,
-	.shutdown	= aml_m3_codec_shutdown,
-	.digital_mute	= aml_m3_codec_mute,
-	.set_sysclk	= aml_m3_codec_set_dai_sysclk,
-	.set_fmt	= aml_m3_codec_set_dai_fmt,
-};
-
-struct snd_soc_dai_driver aml_m3_codec_dai = {
-	.name = "AML-M3",
-	.playback = {
-		.stream_name = "Playback",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = AML_RATES,
-		.formats = AML_FORMATS,},
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = AML_RATES,
-		.formats = AML_FORMATS,},
-	.ops = &aml_m3_codec_dai_ops,
-	.symmetric_rates = 1,
-};
-EXPORT_SYMBOL_GPL(aml_m3_codec_dai);
-
-static int aml_m3_set_bias_level(struct snd_soc_codec *codec,
-				 enum snd_soc_bias_level level)
-{
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		break;
-	case SND_SOC_BIAS_PREPARE:
-		break;
-	case SND_SOC_BIAS_STANDBY:
-		break;
-	case SND_SOC_BIAS_OFF:
-	    break;
-	default:
-	    break;
-	}
-	codec->dapm.bias_level = level;
-	return 0;
-}
-
-static int aml_m3_soc_probe(struct snd_soc_codec *codec){
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	
-	aml_m3_reset(codec, true);
-	aml_m3_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-	
-	snd_soc_add_controls(codec, amlm3_snd_controls,
-				ARRAY_SIZE(amlm3_snd_controls));
-	
-	snd_soc_dapm_new_controls(dapm, aml_m3_dapm_widgets,
-				  ARRAY_SIZE(aml_m3_dapm_widgets));
-
-	snd_soc_dapm_add_routes(dapm, aml_m3_audio_map, ARRAY_SIZE(aml_m3_audio_map));
-	
-    aml_m3_codec = codec;                
-    return 0;
-}
-static int aml_m3_soc_remove(struct snd_soc_codec *codec){
-	return 0;
-}
-static int aml_m3_soc_suspend(struct snd_soc_codec *codec,	pm_message_t state){
-	printk("aml_m3_codec_suspend\n");
-	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)&~(1 << 2));
-    aml_reset_path(codec, AML_PWR_DOWN);	
-    return 0;
-}
-
-static int aml_m3_soc_resume(struct snd_soc_codec *codec){
-	printk("aml_m3_codec resume\n");
-
-    WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)|(1 << 2));
-    aml_m3_reset(codec, true);	
-    return 0;
-}
-
-static struct snd_soc_codec_driver soc_codec_dev_m3 = {
-	.probe = 	aml_m3_soc_probe,
-	.remove = 	aml_m3_soc_remove,
-	.suspend =	aml_m3_soc_suspend,
-	.resume = 	aml_m3_soc_resume,
-	.read = aml_m3_read,
-	.write = aml_m3_write,
-	.set_bias_level = aml_m3_set_bias_level,
-	.reg_cache_size = ARRAY_SIZE(aml_m3_reg),
-	.reg_word_size = sizeof(u16),
-	.reg_cache_step = 2,
-	.reg_cache_default = aml_m3_reg,
-	.dapm_widgets = aml_m3_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(aml_m3_dapm_widgets),
-	.dapm_routes = aml_m3_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(aml_m3_audio_map),
-};
-
-static int aml_m3_codec_platform_probe(struct platform_device *pdev)
-{
-	return snd_soc_register_codec(&pdev->dev, 
-		&soc_codec_dev_m3, &aml_m3_codec_dai, 1);
-}
-
-static int __exit aml_m3_codec_platform_remove(struct platform_device *pdev)
-{	
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-
-static struct platform_driver aml_m3_codec_platform_driver = {
-	.driver = {
-		.name = "aml_m3_codec",
-		.owner = THIS_MODULE,
-		},
-	.probe = aml_m3_codec_platform_probe,
-	.remove = __exit_p(aml_m3_codec_platform_remove),
-};
-
-static int __init aml_m3_codec_modinit(void)
-{
-		return platform_driver_register(&aml_m3_codec_platform_driver);
-}
-
-static void __exit aml_m3_codec_exit(void)
-{
-		platform_driver_unregister(&aml_m3_codec_platform_driver);
-}
-
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(aml_m3_codec_modinit);
-#else
-module_init(aml_m3_codec_modinit);
-#endif
-module_exit(aml_m3_codec_exit);
-
-
-MODULE_DESCRIPTION("ASoC AML M3 codec driver");
-MODULE_AUTHOR("AMLogic Inc.");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m3_codec.h b/sound/soc/aml/aml_m3_codec.h
deleted file mode 100644
index b35e33e5350a..000000000000
--- a/sound/soc/aml/aml_m3_codec.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef _AML_M3_CODEC_H
-#define _AML_M3_CODEC_H
-
-extern struct snd_soc_dai aml_m3_codec_dai;
-extern struct snd_soc_codec_device soc_codec_dev_aml_m3;
-
-#endif
diff --git a/sound/soc/aml/aml_m6_rt3261.c b/sound/soc/aml/aml_m6_rt3261.c
deleted file mode 100755
index fa166478528f..000000000000
--- a/sound/soc/aml/aml_m6_rt3261.c
+++ /dev/null
@@ -1,651 +0,0 @@
-/*
- * aml_m6_rt3261.c  --  SoC audio for AML M6
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/rt3261.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-
-#include <linux/switch.h>
-
-
-#include "../codecs/rt3261/rt3261.h"
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "aml_audio_hw.h"
-
-#define HP_DET                  1
-
-struct rt3261_private_data {
-    int bias_level;
-    int clock_en;
-#if HP_DET
-    int timer_en;
-    int detect_flag;
-    struct timer_list timer;
-    struct work_struct work;
-    struct mutex lock;
-    struct snd_soc_jack jack;
-    void* data;
-    struct switch_dev sdev; // for android
-#endif
-};
-
-#define DEBUG	1
-//#undef DEBUG
-#ifdef DEBUG
-#define dprintk(msg...) printk(msg)
-#else
-#define dprintk(msg...) while(0){}
-#endif
-
-static struct rt3261_platform_data *rt3261_snd_pdata = NULL;
-static struct rt3261_private_data* rt3261_snd_priv = NULL;
-
-static void rt3261_dev_init(void)
-{
-    if (rt3261_snd_pdata->device_init) {
-        rt3261_snd_pdata->device_init();
-    }
-}
-
-static void rt3261_dev_uninit(void)
-{
-    if (rt3261_snd_pdata->device_uninit) {
-        rt3261_snd_pdata->device_uninit();
-    }
-}
-
-static void rt3261_set_clock(int enable)
-{
-    /* set clock gating */
-    rt3261_snd_priv->clock_en = enable;
-
-    return ;
-}
-
-static void rt3261_set_output(struct snd_soc_codec *codec)
-{
-    struct snd_soc_dapm_context *dapm = &codec->dapm;
-#if 0
-    if (rt3261_snd_pdata->spk_output != RT3261_SPK_STEREO) {
-        if (rt3261_snd_pdata->spk_output == RT3261_SPK_RIGHT) {
-            snd_soc_dapm_nc_pin(dapm, "SPOL");
-
-            snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
-                0xf000,
-                RT3261_M_SPKVOL_L_TO_SPOL_MIXER | RT3261_M_SPKVOL_R_TO_SPOL_MIXER);
-        } else {
-            snd_soc_dapm_nc_pin(dapm, "SPOR");
-
-            snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
-                0xf000,
-                RT3261_M_SPKVOL_L_TO_SPOR_MIXER | RT3261_M_SPKVOL_R_TO_SPOR_MIXER);
-        }
-
-        snd_soc_update_bits(codec, RT3261_SPK_MONO_HP_OUT_CTRL,
-            RT3261_SPK_L_MUX_SEL_MASK | RT3261_SPK_R_MUX_SEL_MASK | RT3261_HP_L_MUX_SEL_MASK | RT3261_HP_R_MUX_SEL_MASK,
-            RT3261_SPK_L_MUX_SEL_SPKMIXER_L | RT3261_SPK_R_MUX_SEL_SPKMIXER_R | RT3261_HP_L_MUX_SEL_HPVOL_L | RT3261_HP_R_MUX_SEL_HPVOL_R);
-    } else {
-        snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
-            0xf000,
-            RT3261_M_SPKVOL_R_TO_SPOL_MIXER | RT3261_M_SPKVOL_L_TO_SPOR_MIXER);
-
-        snd_soc_update_bits(codec, RT3261_SPK_MONO_HP_OUT_CTRL,
-            RT3261_SPK_L_MUX_SEL_MASK | RT3261_SPK_R_MUX_SEL_MASK | RT3261_HP_L_MUX_SEL_MASK | RT3261_HP_R_MUX_SEL_MASK,
-            RT3261_SPK_L_MUX_SEL_SPKMIXER_L | RT3261_SPK_R_MUX_SEL_SPKMIXER_R | RT3261_HP_L_MUX_SEL_HPVOL_L | RT3261_HP_R_MUX_SEL_HPVOL_R);
-    }
-#endif
-}
-
-static void rt3261_set_input(struct snd_soc_codec *codec)
-{
-#if 0
-    if (rt3261_snd_pdata->mic_input == RT3261_MIC_SINGLEENDED) {
-        /* single-ended input mode */
-        snd_soc_update_bits(codec, RT3261_MIC_CTRL_1,
-            RT3261_MIC1_DIFF_INPUT_CTRL,
-            0);
-    } else {
-        /* differential input mode */
-        snd_soc_update_bits(codec, RT3261_MIC_CTRL_1,
-            RT3261_MIC1_DIFF_INPUT_CTRL,
-            RT3261_MIC1_DIFF_INPUT_CTRL);
-    }
-#endif
-}
-
-#if HP_DET
-static int rt3261_detect_hp(void)
-{
-    int flag = -1;
-
-    if (rt3261_snd_pdata->hp_detect)
-    {
-        flag = rt3261_snd_pdata->hp_detect();
-    }
-
-    return flag;
-}
-
-static void rt3261_start_timer(unsigned long delay)
-{
-    rt3261_snd_priv->timer.expires = jiffies + delay;
-    rt3261_snd_priv->timer.data = (unsigned long)rt3261_snd_priv;
-    rt3261_snd_priv->detect_flag = -1;
-    add_timer(&rt3261_snd_priv->timer);
-    rt3261_snd_priv->timer_en = 1;
-}
-
-static void rt3261_stop_timer(void)
-{
-    del_timer_sync(&rt3261_snd_priv->timer);
-    cancel_work_sync(&rt3261_snd_priv->work);
-    rt3261_snd_priv->timer_en = 0;
-    rt3261_snd_priv->detect_flag = -1;
-}
-
-static void rt3261_work_func(struct work_struct *work)
-{
-    struct rt3261_private_data *pdata = NULL;
-    struct snd_soc_codec *codec = NULL;
-    int jack_type = 0;
-    int flag = -1;
-	int status = SND_JACK_HEADPHONE;
-
-    pdata = container_of(work, struct rt3261_private_data, work);
-    codec = (struct snd_soc_codec *)pdata->data;
-
-    flag = rt3261_detect_hp();
-    if(pdata->detect_flag != flag) {
-        if (flag == 1) {
-	    jack_type = rt3261_headset_detect(codec, 1);
-            dprintk(KERN_INFO "rt3261 hp pluged jack_type: %d\n", jack_type);
-            snd_soc_jack_report(&pdata->jack, status, SND_JACK_HEADPHONE);
-            switch_set_state(&pdata->sdev, 1); 
-        } else {
-            dprintk(KERN_INFO "rt3261 hp unpluged\n");
-	    rt3261_headset_detect(codec, 0);
-            snd_soc_jack_report(&pdata->jack, 0, SND_JACK_HEADPHONE);
-            switch_set_state(&pdata->sdev, 0);
-        }
-
-        pdata->detect_flag = flag;
-    }
-}
-
-
-static void rt3261_timer_func(unsigned long data)
-{
-    struct rt3261_private_data *pdata = (struct rt3261_private_data *)data;
-    unsigned long delay = msecs_to_jiffies(200);
-
-    schedule_work(&pdata->work);
-    mod_timer(&pdata->timer, jiffies + delay);
-}
-#endif
-
-static int rt3261_prepare(struct snd_pcm_substream *substream)
-{
-    dprintk(KERN_INFO "enter %s stream: %s\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture");
-#if HP_DET
-    mutex_lock(&rt3261_snd_priv->lock);
-    if (!rt3261_snd_priv->timer_en) {
-        rt3261_start_timer(msecs_to_jiffies(100));
-    }
-    mutex_unlock(&rt3261_snd_priv->lock);
-#endif
-    return 0;
-}
-
-static int rt3261_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-
-    dprintk(KERN_INFO "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set codec DAI clock */
-    //ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
-    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * MCLKFS_RATIO, SND_SOC_CLOCK_IN);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    /* set cpu DAI clock */
-    //ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * MCLKFS_RATIO, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    return 0;
-}
-
-static int rt3261_voice_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-
-    dprintk(KERN_INFO "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_A |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_DSP_A |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-    //bard 10-22 s
-    //ret = snd_soc_dai_set_pll(codec_dai, 0, RT3261_PLL1_S_MCLK, 12288000, 12288000);
-    ret = snd_soc_dai_set_pll(codec_dai, 0, RT3261_PLL1_S_MCLK, 24576000, 24576000);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set codec dai pll failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-    //bard 10-22 e
-
-    /* set codec DAI clock */
-    #if 0 //org
-    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256 * 6, SND_SOC_CLOCK_IN);
-    #else //bard 10-22
-    //ret = snd_soc_dai_set_sysclk(codec_dai, RT3261_SCLK_S_PLL1, params_rate(params) * 256 * 6, SND_SOC_CLOCK_IN);
-    ret = snd_soc_dai_set_sysclk(codec_dai, RT3261_SCLK_S_PLL1, params_rate(params) * 256 * 12, SND_SOC_CLOCK_IN);
-    #endif
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    /* set cpu DAI clock */
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        dprintk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    return 0;
-}
-
-static struct snd_soc_ops rt3261_soc_ops = {
-    .prepare   = rt3261_prepare,
-    .hw_params = rt3261_hw_params,
-};
-
-static struct snd_soc_ops rt3261_voice_ops = {
-	.prepare   = rt3261_prepare,
-	.hw_params = rt3261_voice_hw_params,
-};
-
-static int rt3261_set_bias_level(struct snd_soc_card *card,
-			      enum snd_soc_bias_level level)
-{
-    int ret = 0;
-
-    dprintk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
-
-    if (rt3261_snd_priv->bias_level == (int)level)
-        return 0;
-
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-#if HP_DET
-        mutex_lock(&rt3261_snd_priv->lock);
-        if (!rt3261_snd_priv->timer_en) {
-            rt3261_start_timer(msecs_to_jiffies(100));
-        }
-        mutex_unlock(&rt3261_snd_priv->lock);
-#endif
-        break;
-    case SND_SOC_BIAS_PREPARE:
-        /* clock enable */
-        if (!rt3261_snd_priv->clock_en) {
-            rt3261_set_clock(1);
-        }
-        break;
-
-    case SND_SOC_BIAS_OFF:
-    case SND_SOC_BIAS_STANDBY:
-        /* clock disable */
-        if (rt3261_snd_priv->clock_en) {
-            rt3261_set_clock(0);
-        }
-#if HP_DET
-        /* stop timer */
-        mutex_lock(&rt3261_snd_priv->lock);
-        if (rt3261_snd_priv->timer_en) {
-            rt3261_stop_timer();
-        }
-        mutex_unlock(&rt3261_snd_priv->lock);
-#endif
-        break;
-    default:
-        return ret;
-    }
-
-    rt3261_snd_priv->bias_level = (int)level;
-
-    return ret;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int rt3261_suspend_pre(struct snd_soc_card *card)
-{
-    dprintk(KERN_DEBUG "enter %s\n", __func__);
-#if HP_DET
-    /* stop timer */
-    mutex_lock(&rt3261_snd_priv->lock);
-    if (rt3261_snd_priv->timer_en) {
-        rt3261_stop_timer();
-    }
-    mutex_unlock(&rt3261_snd_priv->lock);
-#endif
-    return 0;
-}
-
-static int rt3261_suspend_post(struct snd_soc_card *card)
-{
-    dprintk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-
-static int rt3261_resume_pre(struct snd_soc_card *card)
-{
-    dprintk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-
-static int rt3261_resume_post(struct snd_soc_card *card)
-{
-    dprintk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-#else
-#define rt3261_suspend_pre  NULL
-#define rt3261_suspend_post NULL
-#define rt3261_resume_pre   NULL
-#define rt3261_resume_post  NULL
-#endif
-
-static const struct snd_soc_dapm_widget rt3261_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-};
-
-static const struct snd_soc_dapm_route rt3261_dapm_intercon[] = {
-    {"Ext Spk", NULL, "SPOL"},
-    {"Ext Spk", NULL, "SPOR"},
-
-    {"HP", NULL, "HPOL"},
-    {"HP", NULL, "HPOR"},
-};
-
-#if HP_DET
-static struct snd_soc_jack_pin jack_pins[] = {
-    {
-        .pin = "HP",
-        .mask = SND_JACK_HEADPHONE,
-    }
-};
-#endif
-static int rt3261_codec_init2(struct snd_soc_pcm_runtime *rtd)
-{
-    return 0;
-}
-
-static int rt3261_codec_init(struct snd_soc_pcm_runtime *rtd)
-{
-    struct snd_soc_codec *codec = rtd->codec;
-    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dapm_context *dapm = &codec->dapm;
-    int ret = 0;
-
-    dprintk(KERN_DEBUG "enter %s rt3261_snd_pdata: %p\n", __func__, rt3261_snd_pdata);
-
-    /* Add specific widgets */
-    snd_soc_dapm_new_controls(dapm, rt3261_dapm_widgets,
-                  ARRAY_SIZE(rt3261_dapm_widgets));
-    /* Set up specific audio path interconnects */
-    snd_soc_dapm_add_routes(dapm, rt3261_dapm_intercon, ARRAY_SIZE(rt3261_dapm_intercon));
-#if 0 //we have 3g, so do not set endpoint,add jf.s
-    /* Setup spk/hp/mono output */
-    rt3261_set_output(codec);
-
-    /* Setuo mic input */
-    rt3261_set_input(codec);
-#endif
-    /* not connected */
-    snd_soc_dapm_nc_pin(dapm, "MONO");
-    snd_soc_dapm_nc_pin(dapm, "AUXO2");
-
-    snd_soc_dapm_nc_pin(dapm, "DMIC");
-    snd_soc_dapm_nc_pin(dapm, "AXIL");
-    snd_soc_dapm_nc_pin(dapm, "AXIR");
-
-    /* always connected */
-    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
-
-    /* disable connected */
-    snd_soc_dapm_disable_pin(dapm, "HP");
-
-    snd_soc_dapm_sync(dapm);
-
-#if HP_DET
-    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &rt3261_snd_priv->jack);
-    if (ret) {
-        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
-    } else {
-        ret = snd_soc_jack_add_pins(&rt3261_snd_priv->jack, ARRAY_SIZE(jack_pins), jack_pins);
-        if (ret) {
-            dprintk(KERN_WARNING "Failed to setup hp pins\n");
-        }
-    }
-    rt3261_snd_priv->data= (void*)codec;
-
-    init_timer(&rt3261_snd_priv->timer);
-    rt3261_snd_priv->timer.function = rt3261_timer_func;
-    rt3261_snd_priv->timer.data = (unsigned long)rt3261_snd_priv;
-
-    INIT_WORK(&rt3261_snd_priv->work, rt3261_work_func);
-    mutex_init(&rt3261_snd_priv->lock);
-#endif
-
-    return 0;
-}
-
-static struct snd_soc_dai_link rt3261_dai_link[] = {
-    {
-        .name = "RT3261",
-        .stream_name = "RT3261 PCM",
-        .cpu_dai_name = "aml-dai0",
-        .codec_dai_name = "rt3261-aif1",
-        .init = rt3261_codec_init,
-        .platform_name = "aml-audio.0",
-        .codec_name = "rt3261.1-001c",
-        .ops = &rt3261_soc_ops,
-    },
-#if 1 //add jf.s
-    {
-        .name = "RT3261_BT_VOICE",
-        .stream_name = "RT3261 BT PCM",
-        .cpu_dai_name = "aml-dai0",
-        .codec_dai_name = "rt3261-aif2",
-        .init = rt3261_codec_init2,
-        .platform_name = "aml-audio.0",
-        .codec_name = "rt3261.1-001c",
-        .ops = &rt3261_voice_ops,
-    },
-#endif
-};
-#define POP_TIME  10   //10ms
-static struct snd_soc_card snd_soc_rt3261 = {
-    .name = "AML-RT3261",
-    .driver_name = "SOC-Audio",
-    .dai_link = &rt3261_dai_link[0],
-    .num_links = ARRAY_SIZE(rt3261_dai_link),
-    .set_bias_level = rt3261_set_bias_level,
-#ifdef CONFIG_PM_SLEEP
-	.suspend_pre    = rt3261_suspend_pre,
-	.suspend_post   = rt3261_suspend_post,
-	.resume_pre     = rt3261_resume_pre,
-	.resume_post    = rt3261_resume_post,
-#endif
-//	.pop_time 		= POP_TIME,   //add by jf.s for power up/down widgets
-};
-
-static struct platform_device *rt3261_snd_device = NULL;
-
-static int rt3261_audio_probe(struct platform_device *pdev)
-{
-    int ret = 0;
-
-    dprintk(KERN_DEBUG "enter %s\n", __func__);
-    printk("rt3261, rt3261_audio_probe\n");
-    rt3261_snd_pdata = pdev->dev.platform_data;
-    snd_BUG_ON(!rt3261_snd_pdata);
-
-    rt3261_snd_priv = (struct rt3261_private_data*)kzalloc(sizeof(struct rt3261_private_data), GFP_KERNEL);
-    if (!rt3261_snd_priv) {
-        dprintk(KERN_ERR "ASoC: Platform driver data allocation failed\n");
-        return -ENOMEM;
-    }
-
-    rt3261_snd_device = platform_device_alloc("soc-audio", -1);
-    if (!rt3261_snd_device) {
-        dprintk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        ret = -ENOMEM;
-        goto err;
-    }
-
-    platform_set_drvdata(rt3261_snd_device, &snd_soc_rt3261);
-
-    ret = platform_device_add(rt3261_snd_device);
-    if (ret) {
-        dprintk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        goto err_device_add;
-    }
-
-    rt3261_snd_priv->bias_level = SND_SOC_BIAS_OFF;
-    rt3261_snd_priv->clock_en = 0;
-
-#if HP_DET
-    rt3261_snd_priv->sdev.name = "h2w";//for report headphone to android
-    ret = switch_dev_register(&rt3261_snd_priv->sdev);
-    if (ret < 0){
-        printk(KERN_ERR "ASoC: register switch dev failed\n");
-        goto err;
-    }
-#endif
-
-
-    rt3261_dev_init();
-
-    return ret;
-
-err_device_add:
-    platform_device_put(rt3261_snd_device);
-
-err:
-    kfree(rt3261_snd_priv);
-
-    return ret;
-}
-
-static int rt3261_audio_remove(struct platform_device *pdev)
-{
-    int ret = 0;
-
-    rt3261_dev_uninit();
-
-    platform_device_put(rt3261_snd_device);
-    kfree(rt3261_snd_priv);
-
-    rt3261_snd_device = NULL;
-    rt3261_snd_priv = NULL;
-    rt3261_snd_pdata = NULL;
-
-    return ret;
-}
-
-static struct platform_driver aml_m6_rt3261_driver = {
-    .probe  = rt3261_audio_probe,
-    .remove = __devexit_p(rt3261_audio_remove),
-    .driver = {
-        .name = "aml_rt3261_audio",
-        .owner = THIS_MODULE,
-    },
-};
-
-static int __init aml_m6_rt3261_init(void)
-{
-    return platform_driver_register(&aml_m6_rt3261_driver);
-}
-
-static void __exit aml_m6_rt3261_exit(void)
-{
-    platform_driver_unregister(&aml_m6_rt3261_driver);
-}
-
-module_init(aml_m6_rt3261_init);
-module_exit(aml_m6_rt3261_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML RT3261 audio driver");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_m6_rt5631.c b/sound/soc/aml/aml_m6_rt5631.c
deleted file mode 100755
index 1c2582793dfc..000000000000
--- a/sound/soc/aml/aml_m6_rt5631.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * aml_m6_asoc_audio.c  --  SoC audio for AML M6
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/rt5631.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-
-#include <linux/switch.h>
-
-//#include "../codecs/rt5631.h"
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "aml_audio_hw.h"
-
-#ifdef CONFIG_USE_OF
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/of_gpio.h>
-#include <mach/pinmux.h>
-#include <plat/io.h>
-#endif
-
-#define DRV_NAME "aml_rt5631_card"
-#define HP_DET                  1
-#define HP_IRQ                  0
-struct aml_audio_private_data {
-    int bias_level;
-    int clock_en;
-	int gpio_hp_det;
-	bool det_pol_inv;
-	struct pinctrl *pin_ctl;
-
-    int timer_en;
-    int detect_flag;
-    struct timer_list timer;
-    struct work_struct work;
-    struct mutex lock;
-    struct snd_soc_jack jack;
-    void* data;
-
-	struct switch_dev sdev; // for android
-};
-
-static void aml_set_clock(int enable)
-{
-    /* set clock gating */
-    //p_aml_audio->clock_en = enable;
-
-    return ;
-}
-
-#if HP_DET
-static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
-{
-    p_aml_audio->timer.expires = jiffies + delay;
-    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-    p_aml_audio->detect_flag = -1;
-    add_timer(&p_aml_audio->timer);
-    p_aml_audio->timer_en = 1;
-}
-
-static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
-{
-    del_timer_sync(&p_aml_audio->timer);
-    cancel_work_sync(&p_aml_audio->work);
-    p_aml_audio->timer_en = 0;
-    p_aml_audio->detect_flag = -1;
-}
-
-static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
-{
-	int val = amlogic_get_value(p_aml_audio->gpio_hp_det,"rt5631");
-	return p_aml_audio->det_pol_inv ? (!val):val; 
-}
-
-
-static void aml_asoc_work_func(struct work_struct *work)
-{
-    struct aml_audio_private_data *p_aml_audio = NULL;
-    struct snd_soc_card *card = NULL;
-    int jack_type = 0;
-    int flag = -1;
-	int status = SND_JACK_HEADPHONE;
-    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
-    card = (struct snd_soc_card *)p_aml_audio->data;
-
-    flag = aml_audio_hp_detect(p_aml_audio);
-
-    if(p_aml_audio->detect_flag != flag) {
-        if (flag == 1) {
-			switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
-            printk(KERN_INFO "aml aduio hp pluged jack_type: %d\n", jack_type);
-            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
-        } else {
-            printk(KERN_INFO "aml audio hp unpluged\n");
-			switch_set_state(&p_aml_audio->sdev, 0);
-            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
-        }
-
-        p_aml_audio->detect_flag = flag;
-    }
-}
-
-
-static void aml_asoc_timer_func(unsigned long data)
-{
-    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
-    unsigned long delay = msecs_to_jiffies(200);
-
-    schedule_work(&p_aml_audio->work);
-    mod_timer(&p_aml_audio->timer, jiffies + delay);
-}
-#endif
-
-static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-
-    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set codec DAI clock */
-    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_IN);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    /* set cpu DAI clock */
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    return 0;
-}
-
-static struct snd_soc_ops aml_asoc_ops = {
-    .hw_params = aml_asoc_hw_params,
-};
-
-static int aml_set_bias_level(struct snd_soc_card *card,
-		struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
-{
-    int ret = 0;
-	struct aml_audio_private_data * p_aml_audio;
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-	printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
-
-    if (p_aml_audio->bias_level == (int)level)
-        return 0;
-
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-        break;
-    case SND_SOC_BIAS_PREPARE:
-        /* clock enable */
-        if (!p_aml_audio->clock_en) {
-            aml_set_clock(1);
-        }
-        break;
-
-    case SND_SOC_BIAS_OFF:
-        if (p_aml_audio->clock_en) {
-            aml_set_clock(0);
-        }
-
-        break;
-    case SND_SOC_BIAS_STANDBY:
-        /* clock disable */
-        if (p_aml_audio->clock_en) {
-            aml_set_clock(0);
-        }
-
-        break;
-    default:
-        return ret;
-    }
-
-    p_aml_audio->bias_level = (int)level;
-
-    return ret;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int aml_suspend_pre(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-#if 0//HP_DET
-    /* stop timer */
-    mutex_lock(&p_aml_audio->lock);
-    if (p_aml_audio->timer_en) {
-       // rt5631_stop_timer();
-    }
-    mutex_unlock(&p_aml_audio->lock);
-#endif
-    return 0;
-}
-
-static int aml_suspend_post(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-
-static int aml_resume_pre(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-
-static int aml_resume_post(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-#else
-#define aml_suspend_pre  NULL
-#define aml_suspend_post NULL
-#define aml_resume_pre   NULL
-#define aml_resume_post  NULL
-#endif
-
-static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("MAIN MIC", NULL),
-    SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
-};
-
-static struct snd_soc_jack_pin jack_pins[] = {
-    {
-        .pin = "HP",
-        .mask = SND_JACK_HEADPHONE,
-    }
-};
-#if HP_IRQ
-static struct snd_soc_jack_gpio aml_audio_hp_jack_gpio = {
-	.name = "Headset detection",
-	.report = SND_JACK_HEADSET,
-	.debounce_time = 150,
-};
-#endif
-static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_card *card = rtd->card;
-    struct snd_soc_codec *codec = rtd->codec;
-    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dapm_context *dapm = &codec->dapm;
-	struct aml_audio_private_data * p_aml_audio;
-    int ret = 0;
-	
-    printk(KERN_DEBUG "enter %s \n", __func__);
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-
-    /* Add specific widgets */
-    snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
-                  ARRAY_SIZE(aml_asoc_dapm_widgets));
-    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
-    if (ret) {
-        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
-    } else {
-        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
-        if (ret) {
-            printk(KERN_WARNING "Failed to setup hp pins\n");
-        }
-    }
-#if HP_IRQ	
-	p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"rt5631_gpio",0);
-
-	if (gpio_is_valid(p_aml_audio->gpio_hp_det)) {
-		aml_audio_hp_jack_gpio.gpio = p_aml_audio->gpio_hp_det;
-		snd_soc_jack_add_gpios(&p_aml_audio->jack,
-						1, &aml_audio_hp_jack_gpio);
-	}
-#endif
-#if HP_DET
-    init_timer(&p_aml_audio->timer);
-    p_aml_audio->timer.function = aml_asoc_timer_func;
-    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-    p_aml_audio->data= (void*)card;
-
-    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
-    mutex_init(&p_aml_audio->lock);
-
-    mutex_lock(&p_aml_audio->lock);
-    if (!p_aml_audio->timer_en) {
-        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
-    }
-    mutex_unlock(&p_aml_audio->lock);
-
-#endif
-
-    return 0;
-}
-
-static struct snd_soc_dai_link aml_codec_dai_link[] = {
-    {
-        .name = "RT5631",
-        .stream_name = "AML PCM",
-        .cpu_dai_name = "aml-dai0",
-        //.codec_dai_name = "rt5631-hifi",
-        .init = aml_asoc_init,
-        .platform_name = "aml-audio.0",
-        .codec_name = "rt5631.1-001a",
-        .ops = &aml_asoc_ops,
-    },
-};
-
-static struct snd_soc_card aml_snd_soc_card = {
-    //.name = "AML-RT5631",
-    .driver_name = "SOC-Audio",
-    .dai_link = &aml_codec_dai_link[0],
-    .num_links = ARRAY_SIZE(aml_codec_dai_link),
-    .set_bias_level = aml_set_bias_level,
-#ifdef CONFIG_PM_SLEEP
-	.suspend_pre    = aml_suspend_pre,
-	.suspend_post   = aml_suspend_post,
-	.resume_pre     = aml_resume_pre,
-	.resume_post    = aml_resume_post,
-#endif
-};
-
-static void aml_m6_pinmux_init(struct snd_soc_card *card)
-{
-	struct aml_audio_private_data *p_aml_audio;
-	const char *str;
-	int ret;
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-	p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "rt5631_audio");
-#if HP_DET
-	ret = of_property_read_string(card->dev->of_node, "rt5631_gpio", &str);
-	if (ret) {
-		printk("rt5631: faild to get gpio!\n");
-	}
-	p_aml_audio->gpio_hp_det = amlogic_gpio_name_map_num(str);
-//	p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"rt5631_gpio",0);
-	p_aml_audio->det_pol_inv = of_property_read_bool(card->dev->of_node,"hp_det_inv");
-	amlogic_gpio_request_one(p_aml_audio->gpio_hp_det,GPIOF_IN,"rt5631");
-#endif
-	printk("=%s==,aml_m6_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
-}
-
-static void aml_m6_pinmux_deinit(struct snd_soc_card *card)
-{
-	struct aml_audio_private_data *p_aml_audio;
-
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-
-	amlogic_gpio_free(p_aml_audio->gpio_hp_det,"rt5631");
-	devm_pinctrl_put(p_aml_audio->pin_ctl);
-}
-static int aml_m6_audio_probe(struct platform_device *pdev)
-{
-	//struct device_node *np = pdev->dev.of_node;
-	struct snd_soc_card *card = &aml_snd_soc_card;
-	struct aml_audio_private_data *p_aml_audio;
-    int ret = 0;
-
-    printk(KERN_DEBUG "enter %s\n", __func__);
-
-#ifdef CONFIG_USE_OF
-	p_aml_audio = devm_kzalloc(&pdev->dev,
-			sizeof(struct aml_audio_private_data), GFP_KERNEL);
-	if (!p_aml_audio) {
-		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	card->dev = &pdev->dev;
-	platform_set_drvdata(pdev, card);
-	snd_soc_card_set_drvdata(card, p_aml_audio);
-	if (!(pdev->dev.of_node)) {
-		dev_err(&pdev->dev, "Must be instantiated using device tree\n");
-		ret = -EINVAL;
-		goto err;
-	}
-
-	ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
-	if (ret)
-		goto err;
-	
-	ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
-			0, &aml_codec_dai_link[0].codec_dai_name);
-	if (ret)
-		goto err;
-
-	ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
-	if (ret)
-		goto err;
-
-//	aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
-//			pdev->dev.of_node, "aml,audio-codec", 0);
-
-	ret = snd_soc_register_card(card);
-	if (ret) {
-		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
-			ret);
-		goto err;
-	}
-
-	aml_m6_pinmux_init(card);
-
-	p_aml_audio->sdev.name = "h2w";//for report headphone to android
-	ret = switch_dev_register(&p_aml_audio->sdev);
-	if (ret < 0){
-			printk(KERN_ERR "ASoC: register switch dev failed\n");
-			goto err;
-	}
-
-	return 0;
-#endif
-
-err:
-    kfree(p_aml_audio);
-    return ret;
-}
-
-static int aml_m6_audio_remove(struct platform_device *pdev)
-{
-    int ret = 0;
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-	struct aml_audio_private_data *p_aml_audio;
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-#if HP_IRQ
-
-	snd_soc_jack_free_gpios(&p_aml_audio->jack, 1,//
-			&aml_audio_hp_jack_gpio);//
-#endif
-	snd_soc_unregister_card(card);
-#if HP_DET
-	/* stop timer */
-	mutex_lock(&p_aml_audio->lock);
-	if (p_aml_audio->timer_en) {
-		aml_audio_stop_timer(p_aml_audio);
-	}
-	mutex_unlock(&p_aml_audio->lock);
-#endif
-
-	aml_m6_pinmux_deinit(card);
-    kfree(p_aml_audio);
-    return ret;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_audio_dt_match[]={
-	{	.compatible = "sound_card,rt5631",//"amlogic,aml_rt5631_audio",
-	},
-	{},
-};
-#else
-#define amlogic_audio_dt_match NULL
-#endif
-
-static struct platform_driver aml_m6_rt5631_audio_driver = {
-    .probe  = aml_m6_audio_probe,
-    .remove = aml_m6_audio_remove,
-    .driver = {
-        .name = DRV_NAME,//"aml_rt5631_audio",
-        .owner = THIS_MODULE,
-        .pm = &snd_soc_pm_ops,
-        .of_match_table = amlogic_audio_dt_match,
-    },
-};
-
-static int __init aml_m6_rt5631_audio_init(void)
-{
-    return platform_driver_register(&aml_m6_rt5631_audio_driver);
-}
-
-static void __exit aml_m6_rt5631_audio_exit(void)
-{
-    platform_driver_unregister(&aml_m6_rt5631_audio_driver);
-}
-
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(aml_m6_rt5631_audio_init);
-#else
-module_init(aml_m6_rt5631_audio_init);
-#endif
-module_exit(aml_m6_rt5631_audio_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML_M6 audio machine Asoc driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
-
diff --git a/sound/soc/aml/aml_m6_wm8960.c b/sound/soc/aml/aml_m6_wm8960.c
deleted file mode 100644
index 5138b49ac767..000000000000
--- a/sound/soc/aml/aml_m6_wm8960.c
+++ /dev/null
@@ -1,624 +0,0 @@
-/*
- * aml_m6_asoc_audio.c  --  SoC audio for AML M6
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/wm8960.h>
-#include <linux/delay.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-
-#include <linux/switch.h>
-
-#include "../codecs/wm8960.h"
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "aml_audio_hw.h"
-
-#ifdef CONFIG_USE_OF
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/of_gpio.h>
-#include <mach/pinmux.h>
-#include <plat/io.h>
-#endif
-
-#define DRV_NAME "aml_wm8960_card"
-#define HP_DET                  1
-#define HP_IRQ                  0
-struct aml_audio_private_data {
-    int bias_level;
-    int clock_en;
-    int gpio_hp_det;
-    bool det_pol_inv;
-    bool dis_hp_det;  /* Disable Headphone detect through codec*/
-    struct pinctrl *pin_ctl;
-
-    int timer_en;
-    int detect_flag;
-    struct timer_list timer;
-    struct work_struct work;
-    struct mutex lock;
-    struct snd_soc_jack jack;
-    void* data;
-
-    struct switch_dev sdev; // for android
-};
-
-static void aml_set_clock(int enable)
-{
-    /* set clock gating */
-    //p_aml_audio->clock_en = enable;
-
-    return ;
-}
-
-#if HP_DET
-static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
-{
-    //printk("**********%s*************\n",__func__);
-    p_aml_audio->timer.expires = jiffies + delay;
-    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-    p_aml_audio->detect_flag = -1;
-    add_timer(&p_aml_audio->timer);
-    p_aml_audio->timer_en = 1;
-}
-
-static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
-{
-   // printk("**********%s*************\n",__func__);
-    del_timer_sync(&p_aml_audio->timer);
-    cancel_work_sync(&p_aml_audio->work);
-    p_aml_audio->timer_en = 0;
-    p_aml_audio->detect_flag = -1;
-}
-
-static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
-{
-    int val = amlogic_get_value(p_aml_audio->gpio_hp_det,"wm8960");
-    //printk("***********%s*****val=%d******\n",__func__,val);
-    return p_aml_audio->det_pol_inv ? val:(!val); 
-}
-
-
-static void aml_asoc_work_func(struct work_struct *work)
-{
-    struct aml_audio_private_data *p_aml_audio = NULL;
-    struct snd_soc_card *card = NULL;
-    int jack_type = 0;
-    int flag = -1;
-    int status = SND_JACK_HEADPHONE;
-    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
-    card = (struct snd_soc_card *)p_aml_audio->data;
-
-    flag = aml_audio_hp_detect(p_aml_audio);
-   // printk("******%s***flag=%d**\n",__func__,flag);
-    if(p_aml_audio->detect_flag != flag) {
-        if (flag == 1) {
-            switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
-            printk(KERN_INFO "aml aduio hp pluged jack_type: %d\n", jack_type);
-            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
-        } else {
-            printk(KERN_INFO "aml audio hp unpluged\n");
-            switch_set_state(&p_aml_audio->sdev, 0);
-            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
-        }
-
-        p_aml_audio->detect_flag = flag;
-    }
-}
-
-
-static void aml_asoc_timer_func(unsigned long data)
-{
-    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
-    unsigned long delay = msecs_to_jiffies(200);
-
-    schedule_work(&p_aml_audio->work);
-    mod_timer(&p_aml_audio->timer, jiffies + delay);
-}
-#endif
-
-static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-
-    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-    /*set codec DAI sysclk divider,now 512fs for MCLK,sysclk divide 2  */
-    snd_soc_dai_set_clkdiv(codec_dai,WM8960_SYSCLKDIV,WM8960_SYSCLK_DIV_2);
-    
-    /* set cpu DAI clock */
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    return 0;
-}
-
-static struct snd_soc_ops aml_asoc_ops = {
-    .hw_params = aml_asoc_hw_params,
-};
-
-static int aml_set_bias_level(struct snd_soc_card *card,
-        struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
-{
-    int ret = 0;
-    struct aml_audio_private_data * p_aml_audio;
-    p_aml_audio = snd_soc_card_get_drvdata(card);
-    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
-   // printk("*****enter %s level: %d\n", __func__, level);
-    if (p_aml_audio->bias_level == (int)level)
-        return 0;
-
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-        break;
-    case SND_SOC_BIAS_PREPARE:
-        /* clock enable */
-        if (!p_aml_audio->clock_en) {
-            aml_set_clock(1);
-        }
-        break;
-
-    case SND_SOC_BIAS_OFF:
-        if (p_aml_audio->clock_en) {
-            aml_set_clock(0);
-        }
-
-        break;
-    case SND_SOC_BIAS_STANDBY:
-        /* clock disable */
-        if (p_aml_audio->clock_en) {
-            aml_set_clock(0);
-        }
-
-        break;
-    default:
-        return ret;
-    }
-
-    p_aml_audio->bias_level = (int)level;
-   // dapm->bias_level = level;
-
-    //snd_soc_dapm_sync(dapm);
-
-   // printk("**pp**dapm->codec=%d*****\n",dapm->codec);
-
-    return ret;
-}
-
-
-#ifdef CONFIG_PM_SLEEP
-static int aml_suspend_pre(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-   // printk("*******enter %s\n", __func__);
-#if 0//HP_DET
-    /* stop timer */
-    mutex_lock(&p_aml_audio->lock);
-    if (p_aml_audio->timer_en) {
-       // rt5631_stop_timer();
-    }
-    mutex_unlock(&p_aml_audio->lock);
-#endif
-    return 0;
-}
-
-static int aml_suspend_post(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-   // printk("*******enter %s\n", __func__);
-    return 0;
-}
-
-static int aml_resume_pre(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-   // printk("*******enter %s\n", __func__);
-    return 0;
-}
-
-static int aml_resume_post(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-   // printk("*******enter %s\n", __func__);
-    return 0;
-}
-#else
-#define aml_suspend_pre  NULL
-#define aml_suspend_post NULL
-#define aml_resume_pre   NULL
-#define aml_resume_post  NULL
-#endif
-
-static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("Mic", NULL),
-};
-
-static struct snd_soc_jack_pin jack_pins[] = {
-    {
-        .pin = "HP",
-        .mask = SND_JACK_HEADSET,
-    }
-};
-#if HP_IRQ
-static struct snd_soc_jack_gpio aml_audio_hp_jack_gpio = {
-    .name = "Headset detection",
-    .report = SND_JACK_HEADPHONE,
-    .debounce_time = 150,
-};
-#endif
-static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
-{
-    struct snd_soc_card *card = rtd->card;
-    struct snd_soc_codec *codec = rtd->codec;
-    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dapm_context *dapm = &codec->dapm;
-    struct aml_audio_private_data * p_aml_audio;
-    int ret = 0;
-    
-    printk(KERN_DEBUG "enter %s \n", __func__);
-    p_aml_audio = snd_soc_card_get_drvdata(card);
-
-    /* Add specific widgets */
-  //  snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
- //                ARRAY_SIZE(aml_asoc_dapm_widgets));
-    /* set ADCLRC/GPIO1 Pin Function Select */
-    snd_soc_update_bits(codec, WM8960_IFACE2, (1 << 6), (1 << 6));
-
-    /* not connected */
-    snd_soc_dapm_nc_pin(dapm, "LINPUT3");
-    snd_soc_dapm_nc_pin(dapm, "RINPUT3");
-    
-    snd_soc_dapm_nc_pin(dapm, "OUT3");
-
-    /* always connected */
-    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
-    snd_soc_dapm_enable_pin(dapm, "Mic");
-
-    /* disable connected */
-    snd_soc_dapm_disable_pin(dapm, "HP");
-
-    snd_soc_dapm_sync(dapm);
-    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
-    if (ret) {
-        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
-    } else {
-        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
-        if (ret) {
-            printk(KERN_WARNING "Failed to setup hp pins\n");
-        }
-    }
-#if HP_IRQ  
-    p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"wm8960_gpio",0);
-
-    if (gpio_is_valid(p_aml_audio->gpio_hp_det)) {
-        aml_audio_hp_jack_gpio.gpio = p_aml_audio->gpio_hp_det;
-        snd_soc_jack_add_gpios(&p_aml_audio->jack,
-                        1, &aml_audio_hp_jack_gpio);
-    }
-#endif
-#if HP_DET
-    init_timer(&p_aml_audio->timer);
-    p_aml_audio->timer.function = aml_asoc_timer_func;
-    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-    p_aml_audio->data= (void*)card;
-
-    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
-    mutex_init(&p_aml_audio->lock);
-
-    mutex_lock(&p_aml_audio->lock);
-    if (!p_aml_audio->timer_en) {
-        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
-    }
-    mutex_unlock(&p_aml_audio->lock);
-
-#endif
-
-//p_aml_audio->dis_hp_det = of_property_read_bool(card->dev->of_node,"dis_hp_det");
-     ret = of_property_read_u32(card->dev->of_node,"dis_hp_det",&p_aml_audio->dis_hp_det);
-     printk("******p_aml_audio->dis_hp_det=%d***\n",p_aml_audio->dis_hp_det);
-    if(ret){
-        printk("don't find match dis_hp_det\n");
-        goto out1;
-    }
-  
-    if(!p_aml_audio->dis_hp_det){
-        printk("****mm**p_aml_audio->dis_hp_det\n");
-        //JD2 as headphone detect
-        snd_soc_update_bits(codec,27, 0x008, 0x008);// OUT3 buffer Enabled and disabled with HPL and HPR jack detect              
-        //INSERT_DELAY    [1] 
-        mdelay(1);      
-        ///GPIO1 output the "jack detect output"
-        snd_soc_update_bits(codec,48, 0x03A, 0x03A);// JD2 used for Jack Detect Input, GPIO function = jack detect output 
-
-        snd_soc_update_bits(codec,24, 0x040, 0x040);// HPDETECT LOW = Speaker 
-    
-        snd_soc_update_bits(codec, 23, 0x1D1, 0x1D1);
-        mdelay(500);
-
-    }
-out1:    
-   
-    return 0;
-}
-
-static struct snd_soc_dai_link aml_codec_dai_link[] = {
-    {
-        .name = "WM8960",
-        .stream_name = "AML PCM",
-        .cpu_dai_name = "aml-dai0",
-       // .codec_dai_name = "wm8960-hifi",
-        .init = aml_asoc_init,
-        .platform_name = "aml-audio.0",
-        .codec_name = "wm8960.1-001a",
-        .ops = &aml_asoc_ops,
-    },
-};
-
-static struct snd_soc_card aml_snd_soc_card = {
-    //.name = "AML-WM8960",
-    .driver_name = "SOC-Audio",
-    .dai_link = &aml_codec_dai_link[0],
-    .num_links = ARRAY_SIZE(aml_codec_dai_link),
-    .dapm_widgets = aml_asoc_dapm_widgets,
-    .num_dapm_widgets = ARRAY_SIZE(aml_asoc_dapm_widgets),
-    .set_bias_level = aml_set_bias_level,
-    //.set_bias_level_post = aml_set_bias_level_post,
-    .fully_routed = true,
-#ifdef CONFIG_PM_SLEEP
-    .suspend_pre    = aml_suspend_pre,
-    .suspend_post   = aml_suspend_post,
-    .resume_pre     = aml_resume_pre,
-    .resume_post    = aml_resume_post,
-#endif
-};
-
-static void aml_m6_pinmux_init(struct snd_soc_card *card)
-{
-    struct aml_audio_private_data *p_aml_audio;
-    const char *str;
-    int ret;
-    p_aml_audio = snd_soc_card_get_drvdata(card);
-    p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "wm8960_audio");
-#if HP_DET
-    //p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"wm8960_gpio",0);
-    ret = of_property_read_string(card->dev->of_node, "wm8960_gpio", &str);
-    if (ret) {
-        printk("wm8960: faild to get gpio!\n");
-    }
-    p_aml_audio->gpio_hp_det = amlogic_gpio_name_map_num(str);
-    p_aml_audio->det_pol_inv = of_property_read_bool(card->dev->of_node,"hp_det_inv");
-    amlogic_gpio_request_one(p_aml_audio->gpio_hp_det,GPIOF_IN,"wm8960");
-#endif
-    printk("=%s==,aml_m6_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
-}
-
-static void aml_m6_pinmux_deinit(struct snd_soc_card *card)
-{
-    struct aml_audio_private_data *p_aml_audio;
-
-    p_aml_audio = snd_soc_card_get_drvdata(card);
-
-    amlogic_gpio_free(p_aml_audio->gpio_hp_det,"wm8960");
-    devm_pinctrl_put(p_aml_audio->pin_ctl);
-}
-
-/*
-static struct device_node * find_avaliable_asoc_device(struct device_node *pnode,
-    const char *name)
-{
-    struct device_node *sound_cardp;
-    struct device_node *np;
-    printk(KERN_DEBUG "enter %s \n",__func__);
-    sound_cardp = pnode;
-
-    for (np = of_get_next_child(sound_cardp, NULL); np;
-            np = of_get_next_child(sound_cardp, np)) {
-        int status = of_device_is_available(np); 
-        if(status){
-            printk("find usable sound card in the parent node of %s\n",name);      
-            of_node_put(sound_cardp);
-            return np;
-        }else{
-            continue;
-        }   
-    }
-    return NULL;
-}
-
-*/       
-static int aml_m6_audio_probe(struct platform_device *pdev)
-{
-    struct device_node *np = pdev->dev.of_node;
-    struct device_node *npc;
-    struct snd_soc_card *card = &aml_snd_soc_card;
-    struct aml_audio_private_data *p_aml_audio;
-    int ret = 0;
-
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    printk("***enter %s\n", __func__);
-
-#ifdef CONFIG_USE_OF
-
-    p_aml_audio = devm_kzalloc(&pdev->dev,
-            sizeof(struct aml_audio_private_data), GFP_KERNEL);
-    if (!p_aml_audio) {
-        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
-        ret = -ENOMEM;
-        goto err;
-    }
-
-    card->dev = &pdev->dev;
-    platform_set_drvdata(pdev, card);
-    snd_soc_card_set_drvdata(card, p_aml_audio);
-    if (!(pdev->dev.of_node)) {
-        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
-        ret = -EINVAL;
-        goto err;
-    }
-
-    ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
-    if (ret)
-        goto err;
-
-    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
-            0, &aml_codec_dai_link[0].codec_dai_name);
-    if (ret)
-        goto err;
-
-    ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
-    if (ret)
-        goto err;
-
-  //  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
-  //          pdev->dev.of_node, "aml,audio-codec", 0);
-
-    ret = snd_soc_register_card(card);
-    if (ret) {
-        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
-            ret);
-        goto err;
-    }
-
-    aml_m6_pinmux_init(card);
-
-    p_aml_audio->sdev.name = "h2w";//for report headphone to android
-    ret = switch_dev_register(&p_aml_audio->sdev);
-    if (ret < 0){
-            printk(KERN_ERR "ASoC: register switch dev failed\n");
-            goto err;
-    }
-
-    return 0;
-#endif
-
-err:
-    kfree(p_aml_audio);
-    return ret;
-}
-
-static int aml_m6_audio_remove(struct platform_device *pdev)
-{
-    int ret = 0;
-    struct device_node *np = pdev->dev.of_node;
-    struct device_node *npc;
-    struct snd_soc_card *card;
-    struct aml_audio_private_data *p_aml_audio;
-
-    card = platform_get_drvdata(pdev);  
-    p_aml_audio = snd_soc_card_get_drvdata(card);
-#if HP_IRQ
-
-    snd_soc_jack_free_gpios(&p_aml_audio->jack, 1,//
-            &aml_audio_hp_jack_gpio);//
-#endif
-    snd_soc_unregister_card(card);
-#if HP_DET
-    /* stop timer */
-    mutex_lock(&p_aml_audio->lock);
-    if (p_aml_audio->timer_en) {
-        aml_audio_stop_timer(p_aml_audio);
-    }
-    mutex_unlock(&p_aml_audio->lock);
-#endif
-
-    aml_m6_pinmux_deinit(card);
-    kfree(p_aml_audio);
-    return ret;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_audio_dt_match[]={
-    {   .compatible = "sound_card,wm8960",//"amlogic,aml_rt5631_audio",
-    },
-    {},
-};
-#else
-#define amlogic_audio_dt_match NULL
-#endif
-
-static struct platform_driver aml_m6_wm8960_audio_driver = {
-    .probe  = aml_m6_audio_probe,
-    .remove = aml_m6_audio_remove,
-    .driver = {
-        .name = DRV_NAME,//"aml_rt5631_audio",
-        .owner = THIS_MODULE,
-        .pm = &snd_soc_pm_ops,
-        .of_match_table = amlogic_audio_dt_match,
-    },
-};
-
-static int __init aml_m6_wm8960_audio_init(void)
-{
-    return platform_driver_register(&aml_m6_wm8960_audio_driver);
-}
-
-static void __exit aml_m6_wm8960_audio_exit(void)
-{
-    platform_driver_unregister(&aml_m6_wm8960_audio_driver);
-}
-
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(aml_m6_wm8960_audio_init);
-#else
-module_init(aml_m6_wm8960_audio_init);
-#endif
-module_exit(aml_m6_wm8960_audio_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML_M6 audio machine Asoc driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
-
-
diff --git a/sound/soc/aml/aml_m6tv_audio.c b/sound/soc/aml/aml_m6tv_audio.c
deleted file mode 100644
index 79fb11041787..000000000000
--- a/sound/soc/aml/aml_m6tv_audio.c
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
-	amlogic  M6TV sound card machine   driver code.
-	it support multi-codec on board, one codec as the main codec,others as
-	aux devices.
-*/
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-
-#include <linux/switch.h>
-#include "aml_dai.h"
-#include "aml_pcm.h"
-#include "aml_audio_hw.h"
-#include <sound/aml_m6tv_audio.h>
-
-static struct platform_device *m6tv_audio_snd_device = NULL;
-static struct m6tv_audio_codec_platform_data *m6tv_audio_snd_pdata = NULL;
-//static struct m6tv_audio_private_data* m6tv_audio_snd_priv = NULL;
-#define CODEC_DEBUG  printk
-static void m6tv_audio_dev_init(void)
-{
-    if (m6tv_audio_snd_pdata->device_init) {
-        m6tv_audio_snd_pdata->device_init();
-    }
-}
-
-static void m6tv_audio_dev_uninit(void)
-{
-    if (m6tv_audio_snd_pdata->device_uninit) {
-        m6tv_audio_snd_pdata->device_uninit();
-    }
-}
-static int m6tv_audio_prepare(struct snd_pcm_substream *substream)
-{
-    CODEC_DEBUG( "enter %s stream: %s\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture");
-    return 0;
-}
-static int m6tv_audio_hw_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-    CODEC_DEBUG( "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        CODEC_DEBUG(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-    if (ret < 0) {
-        CODEC_DEBUG(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set codec DAI clock */
-    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_IN);
-    if (ret < 0) {
-        CODEC_DEBUG(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    /* set cpu DAI clock */
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        CODEC_DEBUG(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    return 0;
-}
-static struct snd_soc_ops m6tv_audio_soc_ops = {
-    .prepare   = m6tv_audio_prepare,
-    .hw_params = m6tv_audio_hw_params,
-};	
-
-
-static int m6tv_audio_set_bias_level(struct snd_soc_card *card,
-					enum snd_soc_bias_level level)
-{
-	int ret = 0;
-    	CODEC_DEBUG( "enter %s level: %d\n", __func__, level);
-	return ret;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int m6tv_audio_suspend_pre(struct snd_soc_card *card)
-{
-    CODEC_DEBUG( "enter %s\n", __func__);
-    return 0;
-}
-
-static int m6tv_audio_suspend_post(struct snd_soc_card *card)
-{
-    CODEC_DEBUG( "enter %s\n", __func__);
-    return 0;
-}
-
-static int m6tv_audio_resume_pre(struct snd_soc_card *card)
-{
-    CODEC_DEBUG( "enter %s\n", __func__);
-    return 0;
-}
-
-static int m6tv_audio_resume_post(struct snd_soc_card *card)
-{
-    CODEC_DEBUG( "enter %s\n", __func__);
-    return 0;
-}
-#else
-#define m6tv_audio_suspend_pre  NULL
-#define m6tv_audio_suspend_post NULL
-#define m6tv_audio_resume_pre   NULL
-#define m6tv_audio_resume_post  NULL
-#endif
-
-static int m6tv_audio_codec_init(struct snd_soc_pcm_runtime *rtd)
-{
-    struct snd_soc_codec *codec = rtd->codec;
-    struct snd_soc_dapm_context *dapm = &codec->dapm;
-    int ret = 0;
-
-    CODEC_DEBUG( "enter %s\n", __func__);
-
-  
-    return 0;
-}
-#ifdef CONFIG_SND_AML_M6TV_STA380
-static int m6tv_sta381xx_init(struct snd_soc_dapm_context *dapm)
-{
-	CODEC_DEBUG("~~~~%s\n", __func__);
-
-	snd_soc_codec_set_sysclk(dapm->codec, 1, 48000 * 512, 0);
-	return 0;
-}
-#endif
-#ifdef CONFIG_SND_AML_M6TV_TAS5711
-static int m6tv_tas5711_init(struct snd_soc_dapm_context *dapm)
-{
-	struct snd_soc_codec *codec = dapm->codec;
-	CODEC_DEBUG("~~~~%s\n", __func__);
-
-	return 0;
-}
-#endif
-static struct snd_soc_dai_link m6tv_audio_dai_link[] = {
-#ifdef CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC
-    {
-        .name = "syno9629",
-        .stream_name = "SYNO9629 PCM",
-        .cpu_dai_name = "aml-dai0",
-        .codec_dai_name = "syno9629-hifi",
-        .init = m6tv_audio_codec_init,
-        .platform_name = "aml-audio.0",
-        .codec_name = "syno9629.0",
-        .ops = &m6tv_audio_soc_ops,
-    },
-#endif    
-};
-struct snd_soc_aux_dev m6tv_audio_aux_dev[] = {
-#ifdef CONFIG_SND_AML_M6TV_RT5631	
-	{
-		.name = "rt5631",
-		.codec_name = "rt5631.0-001a",
-		.init = NULL,
-	},
-#endif	
-#ifdef CONFIG_SND_AML_M6TV_STA380
-	{
-		.name = "sta381xx",
-		.codec_name = "sta381xx.0-001c",
-		.init = m6tv_sta381xx_init,
-	},
-#endif
-#ifdef CONFIG_SND_AML_M6TV_TAS5711
-	{
-		.name = "tas5711",
-		.codec_name = "tas5711.0-001b",
-		.init = m6tv_tas5711_init,
-	},
-#endif
-};
-
-static struct snd_soc_codec_conf m6tv_audio_codec_conf[] = {
-#ifdef CONFIG_SND_AML_M6TV_RT5631	
-	
-	{
-		.dev_name = "rt5631.0-001a",
-		.name_prefix = "b",
-	},
-#endif
-#ifdef CONFIG_SND_AML_M6TV_STA380	
-	{
-		.dev_name = "sta381xx.0-001c",
-		.name_prefix = "AMP",
-	},
-#endif
-#ifdef CONFIG_SND_AML_M6TV_TAS5711	
-	{
-		.dev_name = "tas5711.0-001b",
-		.name_prefix = "AMP",
-	},
-#endif
-};
-static struct snd_soc_card snd_soc_m6tv_audio = {
-    .name = "AML-M6TV",
-    .driver_name = "SOC-Audio",
-    .dai_link = m6tv_audio_dai_link,
-    .num_links = ARRAY_SIZE(m6tv_audio_dai_link),
-    .set_bias_level = m6tv_audio_set_bias_level,
-    .aux_dev = m6tv_audio_aux_dev,
-    .num_aux_devs = ARRAY_SIZE(m6tv_audio_aux_dev),
-    .codec_conf = m6tv_audio_codec_conf,
-    .num_configs = ARRAY_SIZE(m6tv_audio_codec_conf),
-    
-#ifdef CONFIG_PM_SLEEP
-	.suspend_pre    = m6tv_audio_suspend_pre,
-	.suspend_post   = m6tv_audio_suspend_post,
-	.resume_pre     = m6tv_audio_resume_pre,
-	.resume_post    = m6tv_audio_resume_post,
-#endif
-};
-
-
-
-
-
-
-static int m6tv_audio_audio_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	m6tv_audio_snd_pdata = pdev->dev.platform_data;
-	snd_BUG_ON(!m6tv_audio_snd_pdata);
-#if 0
-	m6tv_audio_snd_priv = (struct m6tv_audio_private_data*)kzalloc(sizeof(struct m6tv_audio_private_data), GFP_KERNEL);
-	if (!m6tv_audio_snd_priv) {
-		CODEC_DEBUG(KERN_ERR "ASoC: Platform driver data allocation failed\n");
-		return -ENOMEM;
-	}
-#endif
-	m6tv_audio_snd_device = platform_device_alloc("soc-audio", -1);
-	if (!m6tv_audio_snd_device) {
-		CODEC_DEBUG(KERN_ERR "ASoC: Platform device allocation failed\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	platform_set_drvdata(m6tv_audio_snd_device, &snd_soc_m6tv_audio);
-	m6tv_audio_snd_device->dev.platform_data = m6tv_audio_snd_pdata;
-
-	ret = platform_device_add(m6tv_audio_snd_device);
-	if (ret) {
-		CODEC_DEBUG(KERN_ERR "ASoC: Platform device allocation failed\n");
-		goto err_device_add;
-	}
-
-//	m6tv_audio_snd_priv->bias_level = SND_SOC_BIAS_OFF;
-//	m6tv_audio_snd_priv->clock_en = 0;
-
-	m6tv_audio_dev_init();
-	return ret;
-err_device_add:
-	platform_device_put(m6tv_audio_snd_device);
-
-err:
-//	kfree(m6tv_audio_snd_priv);
-
-	return ret;
-}
-
-static int m6tv_audio_audio_remove(struct platform_device *pdev)
-{
-    int ret = 0;
-    m6tv_audio_dev_uninit();
-    platform_device_put(m6tv_audio_snd_device);
-//    kfree(m6tv_audio_snd_priv);
-    m6tv_audio_snd_device = NULL;
-//    m6tv_audio_snd_priv = NULL;
-    m6tv_audio_snd_pdata = NULL;
-    return ret;
-}
-
-static struct platform_driver aml_m6tv_audio_driver = {
-    .probe  = m6tv_audio_audio_probe,
-    .remove = __devexit_p(m6tv_audio_audio_remove),
-    .driver = {
-        .name = "aml_m6tv_audio",
-        .owner = THIS_MODULE,
-    },
-};
-
-static int __init aml_m6tv_audio_init(void)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-	return platform_driver_register(&aml_m6tv_audio_driver);
-}
-
-static void __exit aml_m6tv_audio_exit(void)
-{
-    platform_driver_unregister(&aml_m6tv_audio_driver);
-}
-
-module_init(aml_m6tv_audio_init);
-module_exit(aml_m6tv_audio_exit);
-
-/* Module information */
-MODULE_AUTHOR("jian.xu@amlogic.com AMLogic, Inc.");
-MODULE_DESCRIPTION("AML SYNO9629 ALSA machine layer driver");
-MODULE_LICENSE("GPL");
-
diff --git a/sound/soc/aml/aml_m8.c b/sound/soc/aml/aml_m8.c
deleted file mode 100755
index e8e46e87220b..000000000000
--- a/sound/soc/aml/aml_m8.c
+++ /dev/null
@@ -1,694 +0,0 @@
-/*
- * aml_m8.c  --  SoC audio for AML M8
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-
-#include <linux/switch.h>
-#include <linux/amlogic/saradc.h>
-
-#include "aml_i2s_dai.h"
-#include "aml_i2s.h"
-#include "aml_m8.h"
-#include "aml_audio_hw.h"
-#include "../codecs/aml_m8_codec.h"
-#include <mach/register.h>
-
-#ifdef CONFIG_USE_OF
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/of_gpio.h>
-#include <mach/pinmux.h>
-#include <plat/io.h>
-#endif
-
-#define USE_EXTERNAL_DAC 0
-#define DRV_NAME "aml_snd_m8"
-#define HP_DET                  1
-
-static void aml_set_clock(int enable)
-{
-    /* set clock gating */
-    //p_aml_audio->clock_en = enable;
-
-    return ;
-}
-
-#if HP_DET
-static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
-{
-    p_aml_audio->timer.expires = jiffies + delay;
-    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-    p_aml_audio->detect_flag = -1;
-    add_timer(&p_aml_audio->timer);
-    p_aml_audio->timer_en = 1;
-}
-
-static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
-{
-    del_timer_sync(&p_aml_audio->timer);
-    cancel_work_sync(&p_aml_audio->work);
-    p_aml_audio->timer_en = 0;
-    p_aml_audio->detect_flag = -1;
-}
-
-static int hp_det_adc_value(struct aml_audio_private_data *p_aml_audio)
-{
-    int ret,hp_value,hp_val_sum,loop_num;
-    hp_val_sum = 0;
-    loop_num = 0;
-    unsigned int mic_ret = 0;
-    
-    while(loop_num < 8){
-        hp_value = get_adc_sample(p_aml_audio->hp_adc_ch);
-        if(hp_value <0){
-            printk("hp detect get error adc value!\n");
-            continue;
-        }
-        hp_val_sum += hp_value;
-        loop_num ++;
-        msleep(15);
-    }
-    hp_val_sum = hp_val_sum >> 3;
-
-    if(hp_val_sum >= p_aml_audio->hp_val_h){
-        ret = 0;
-    }else if((hp_val_sum <= (p_aml_audio->hp_val_l))&& hp_val_sum >=0){
-        ret = 1;
-        if(p_aml_audio->mic_det){
-            if(hp_val_sum <=  p_aml_audio->mic_val){
-                mic_ret = 8;
-                ret |= mic_ret;
-            }
-        }
-    }else{
-        ret = 2;
-        if(p_aml_audio->mic_det){
-            ret = 0;
-            mic_ret = 8;
-            ret |= mic_ret; 
-        }
-            
-    }
-    
-    return ret;
-}
-
-
-static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
-{
-       // return 0;
-   int loop_num = 0;
-   int ret;
-
-    mutex_lock(&p_aml_audio->lock);
-
-    while(loop_num < 3){
-        ret = hp_det_adc_value(p_aml_audio);
-        if(p_aml_audio->hp_last_state != ret){
-            loop_num = 0;
-            msleep(50);
-            if(ret < 0){
-                ret = p_aml_audio->hp_last_state;
-            }else {
-                p_aml_audio->hp_last_state = ret;
-            }
-        }else{
-            msleep(50);
-            loop_num = loop_num + 1;
-        }
-    }
- 
-    mutex_unlock(&p_aml_audio->lock);
-
-    return ret; 
-}
-
-
-static void aml_asoc_work_func(struct work_struct *work)
-{
-    struct aml_audio_private_data *p_aml_audio = NULL;
-    struct snd_soc_card *card = NULL;
-    int jack_type = 0;
-    int flag = -1;
-	int status = SND_JACK_HEADPHONE;
-    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
-    card = (struct snd_soc_card *)p_aml_audio->data;
-
-    flag = aml_audio_hp_detect(p_aml_audio);
-
-    if(p_aml_audio->detect_flag != flag) {
-
-        p_aml_audio->detect_flag = flag;
-        
-        if (flag & 0x1) {
-            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
-            switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
-            adac_wr_reg (71, 0x0101); // use board mic
-            printk(KERN_INFO "aml aduio hp pluged 3 jack_type: %d\n", SND_JACK_HEADPHONE);
-           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
-
-           // mic port detect
-           if(p_aml_audio->mic_det){
-               if(flag & 0x8){
-                  switch_set_state(&p_aml_audio->mic_sdev, 1);
-                  adac_wr_reg (71, 0x0005); // use hp mic
-                  printk(KERN_INFO "aml aduio mic pluged jack_type: %d\n", SND_JACK_MICROPHONE);
-                  //snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
-              }
-           }
-
-        } else if(flag & 0x2){
-            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
-            switch_set_state(&p_aml_audio->sdev, 1);  // 1 :have mic ;  2 no mic
-            adac_wr_reg (71, 0x0005); // use hp mic
-            printk(KERN_INFO "aml aduio hp pluged 4 jack_type: %d\n", SND_JACK_HEADSET);
-           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
-        } else {
-            printk(KERN_INFO "aml audio hp unpluged\n");
-            amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
-            adac_wr_reg (71, 0x0101); // use board mic
-            switch_set_state(&p_aml_audio->sdev, 0);
-            //snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
-
-            // mic port detect
-            if(p_aml_audio->mic_det){
-                if(flag & 0x8){
-                   switch_set_state(&p_aml_audio->mic_sdev, 1);
-                   adac_wr_reg (71, 0x0005); // use hp mic
-                   printk(KERN_INFO "aml aduio mic pluged jack_type: %d\n", SND_JACK_MICROPHONE);
-                   //snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
-               }
-            }
-        }
-        
-    }
-}
-
-
-static void aml_asoc_timer_func(unsigned long data)
-{
-    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
-    unsigned long delay = msecs_to_jiffies(200);
-
-    schedule_work(&p_aml_audio->work);
-    mod_timer(&p_aml_audio->timer, jiffies + delay);
-}
-#endif
-
-static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-
-    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-#if 0
-    /* set codec DAI clock */
-    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    /* set cpu DAI clock */
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-#endif
-    return 0;
-}
-
-static struct snd_soc_ops aml_asoc_ops = {
-    .hw_params = aml_asoc_hw_params,
-};
-
-
-struct aml_audio_private_data *p_audio;
-
-static int aml_m8_spk_enabled;
-
-static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_value *ucontrol)
-{
-    aml_m8_spk_enabled = ucontrol->value.integer.value[0];
-    printk(KERN_INFO "aml_m8_set_spk: aml_m8_spk_enabled=%d\n",aml_m8_spk_enabled);
-
-    msleep(10);
-    amlogic_set_value(p_audio->gpio_mute, aml_m8_spk_enabled, "mute_spk");
-
-    if(aml_m8_spk_enabled ==1)
-        msleep(100);
-
-    return 0;
-}
-
-static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_value *ucontrol)
-{
-    //printk("***aml_m8_get_spk****aml_m8_spk_enabled=%d**\n",aml_m8_spk_enabled);
-    ucontrol->value.integer.value[0] = aml_m8_spk_enabled;
-    return 0;
-}
-
-static int aml_set_bias_level(struct snd_soc_card *card,
-        struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
-{
-    int ret = 0;
-    struct aml_audio_private_data * p_aml_audio;
-    p_aml_audio = snd_soc_card_get_drvdata(card);
-    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
-
-    int hp_state = p_aml_audio->detect_flag;
-    if (p_aml_audio->bias_level == (int)level)
-        return 0;
-
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-        break;
-    case SND_SOC_BIAS_PREPARE:
-        /* clock enable */
-        if (!p_aml_audio->clock_en) {
-            aml_set_clock(1);
-        }
-        break;
-
-    case SND_SOC_BIAS_OFF:
-        if (p_aml_audio->clock_en) {
-            aml_set_clock(0);
-        }
-
-        break;
-    case SND_SOC_BIAS_STANDBY:
-        /* clock disable */
-        if (p_aml_audio->clock_en) {
-            aml_set_clock(0);
-        }
-
-        break;
-    default:
-        return ret;
-    }
-
-    p_aml_audio->bias_level = (int)level;
-
-    return ret;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int aml_suspend_pre(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-#if HP_DET
-
-#endif
-    return 0;
-}
-
-static int aml_suspend_post(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-
-static int aml_resume_pre(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-
-static int aml_resume_post(struct snd_soc_card *card)
-{
-    printk(KERN_DEBUG "enter %s\n", __func__);
-    return 0;
-}
-#else
-#define aml_suspend_pre  NULL
-#define aml_suspend_post NULL
-#define aml_resume_pre   NULL
-#define aml_resume_post  NULL
-#endif
-
-static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
-    SND_SOC_DAPM_HP("HP", NULL),
-    SND_SOC_DAPM_MIC("MAIN MIC", NULL),
-    SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
-};
-
-static struct snd_soc_jack_pin jack_pins[] = {
-    {
-        .pin = "HP",
-        .mask = SND_JACK_HEADPHONE,
-    }
-};
-
-static const struct snd_kcontrol_new aml_m8_controls[] = {
-
-    SOC_SINGLE_BOOL_EXT("Amp Spk enable", 0,
-        aml_m8_get_spk,
-        aml_m8_set_spk),
-/*
-    SOC_SINGLE_BOOL_EXT("Audio MPLL9 Switch", 0,
-    aml_m8_get_MPLL9,
-    aml_m8_set_MPLL9),
-    */
-};
-static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_card *card = rtd->card;
-    struct snd_soc_codec *codec = rtd->codec;
-    struct snd_soc_dapm_context *dapm = &codec->dapm;
-	struct aml_audio_private_data * p_aml_audio;
-    int ret = 0;
-    int hp_paraments[5];
-	
-    printk(KERN_DEBUG "enter %s \n", __func__);
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-    ret = snd_soc_add_card_controls(codec->card, aml_m8_controls,
-                ARRAY_SIZE(aml_m8_controls));
-    if (ret)
-       return ret;
-
-    /* Add specific widgets */
-    //snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
-    //              ARRAY_SIZE(aml_asoc_dapm_widgets));
-    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
-    if (ret < 0) {
-        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
-    } else {
-        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
-        if (ret < 0) {
-            printk(KERN_WARNING "Failed to setup hp pins\n");
-        }
-    }
-
-#if HP_DET
-    p_aml_audio->mic_det = of_property_read_bool(card->dev->of_node,"mic_det");
-
-    printk("entern %s : mic_det=%d \n",__func__,p_aml_audio->mic_det);
-    ret = of_property_read_u32_array(card->dev->of_node, "hp_paraments", &hp_paraments[0], 5);
-    if(ret){
-        printk("falied to get hp detect paraments from dts file\n");
-    }else{
-        p_aml_audio->hp_val_h  = hp_paraments[0];  // hp adc value higher base, hp unplugged
-        p_aml_audio->hp_val_l  = hp_paraments[1];  // hp adc value low base, 3 section hp plugged.
-        p_aml_audio->mic_val   = hp_paraments[2];  // hp adc value mic detect value.
-        p_aml_audio->hp_detal  = hp_paraments[3];  // hp adc value test toerance
-        p_aml_audio->hp_adc_ch = hp_paraments[4];  // get adc value from which adc port for hp detect
-
-        printk("hp detect paraments: h=%d,l=%d,mic=%d,det=%d,ch=%d \n",p_aml_audio->hp_val_h,p_aml_audio->hp_val_l,
-            p_aml_audio->mic_val,p_aml_audio->hp_detal,p_aml_audio->hp_adc_ch);
-    }
-    init_timer(&p_aml_audio->timer);
-    p_aml_audio->timer.function = aml_asoc_timer_func;
-    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
-    p_aml_audio->data= (void*)card;
-
-    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
-    mutex_init(&p_aml_audio->lock);
-
-    mutex_lock(&p_aml_audio->lock);
-    if (!p_aml_audio->timer_en) {
-        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
-    }
-    mutex_unlock(&p_aml_audio->lock);
-
-#endif
-
-    return 0;
-}
-
-static struct snd_soc_dai_link aml_codec_dai_link[] = {
-    {
-        .name = "SND_M8",
-        .stream_name = "AML PCM",
-        .cpu_dai_name = "aml-i2s-dai.0",
-        .init = aml_asoc_init,
-        .platform_name = "aml-i2s.0",
-        .codec_name = "aml_m8_codec.0",
-        .ops = &aml_asoc_ops,
-    },
-#ifdef CONFIG_SND_SOC_PCM2BT
-    {
-        .name = "BT Voice",
-        .stream_name = "Voice PCM",
-        .cpu_dai_name = "aml-pcm-dai.0",
-        .codec_dai_name = "pcm2bt-pcm",
-        .platform_name = "aml-pcm.0",
-        .codec_name = "pcm2bt.0",
-        //.ops = &voice_soc_ops,
-    },
-#endif
-
-    {
-        .name = "AML-SPDIF",
-        .stream_name = "SPDIF PCM",
-        .cpu_dai_name = "aml-spdif-dai.0",
-        .codec_dai_name = "dit-hifi",
-        .init = NULL,
-        .platform_name = "aml-i2s.0",
-        .codec_name = "spdif-dit.0",
-        .ops = NULL,      
-    }, 
-
-};
-
-static struct snd_soc_card aml_snd_soc_card = {
-    .driver_name = "SOC-Audio",
-    .dai_link = &aml_codec_dai_link[0],
-    .num_links = ARRAY_SIZE(aml_codec_dai_link),
-    .set_bias_level = aml_set_bias_level,
-#ifdef CONFIG_PM_SLEEP
-	.suspend_pre    = aml_suspend_pre,
-	.suspend_post   = aml_suspend_post,
-	.resume_pre     = aml_resume_pre,
-	.resume_post    = aml_resume_post,
-#endif
-};
-
-static void aml_m8_pinmux_init(struct snd_soc_card *card)
-{
-	struct aml_audio_private_data *p_aml_audio;
-	const char *str=NULL;
-	int ret;
-	p_aml_audio = snd_soc_card_get_drvdata(card);   
-    p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "aml_snd_m8");
-    
-    p_audio = p_aml_audio;
- #if USE_EXTERNAL_DAC
-    //aml_write_reg32(P_AO_SECURE_REG1,0x00000000);
-    aml_clr_reg32_mask(P_AO_SECURE_REG1, ((1<<8) | (1<<1)));
- #endif
-	ret = of_property_read_string(card->dev->of_node, "mute_gpio", &str);
-	if (ret < 0) {
-		printk("aml_snd_m8: faild to get mute_gpio!\n");
-	}else{
-		p_aml_audio->gpio_mute = amlogic_gpio_name_map_num(str);
-		p_aml_audio->mute_inv = of_property_read_bool(card->dev->of_node,"mute_inv");
-		amlogic_gpio_request_one(p_aml_audio->gpio_mute,GPIOF_OUT_INIT_HIGH,"mute_spk");
-		amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
-	}
-
-	printk("=%s==,aml_m8_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
-}
-
-static void aml_m8_pinmux_deinit(struct snd_soc_card *card)
-{
-	struct aml_audio_private_data *p_aml_audio;
-
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-	if(p_aml_audio->gpio_hp_det)
-		amlogic_gpio_free(p_aml_audio->gpio_hp_det,"hp_det");
-	if(p_aml_audio->gpio_mute)
-		amlogic_gpio_free(p_aml_audio->gpio_mute,"mute_spk"); 
-    if(p_aml_audio->pin_ctl)
-        devm_pinctrl_put(p_aml_audio->pin_ctl);
-}
-static int aml_m8_audio_probe(struct platform_device *pdev)
-{
-    //struct device_node *np = pdev->dev.of_node;
-    struct snd_soc_card *card = &aml_snd_soc_card;
-    struct aml_audio_private_data *p_aml_audio;
-    int ret = 0;
-
-    printk(KERN_DEBUG "enter %s\n", __func__);
-
-#ifdef CONFIG_USE_OF
-    p_aml_audio = devm_kzalloc(&pdev->dev,
-            sizeof(struct aml_audio_private_data), GFP_KERNEL);
-    if (!p_aml_audio) {
-        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
-        ret = -ENOMEM;
-        goto err;
-    }
-
-    card->dev = &pdev->dev;
-    platform_set_drvdata(pdev, card);
-    snd_soc_card_set_drvdata(card, p_aml_audio);
-    if (!(pdev->dev.of_node)) {
-        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
-        ret = -EINVAL;
-        goto err;
-    }
-
-    ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
-    if (ret)
-        goto err;
-    
-    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
-            0, &aml_codec_dai_link[0].codec_dai_name);
-    if (ret)
-        goto err;
-
-    //ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
-    //if (ret)
-    //  goto err;
-
-//  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
-//          pdev->dev.of_node, "aml,audio-codec", 0);
-
-    ret = snd_soc_register_card(card);
-    if (ret) {
-        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
-            ret);
-        goto err;
-    }
-
-    aml_m8_pinmux_init(card);
-
-    p_aml_audio->sdev.name = "h2w";//for report headphone to android
-    ret = switch_dev_register(&p_aml_audio->sdev);
-    if (ret < 0){
-        printk(KERN_ERR "ASoC: register hp switch dev failed\n");
-        goto err;
-    }
-
-    p_aml_audio->mic_sdev.name = "mic_dev";//for micphone detect
-    ret = switch_dev_register(&p_aml_audio->mic_sdev);
-    if (ret < 0){
-        printk(KERN_ERR "ASoC: register mic switch dev failed\n");
-        goto err;
-    }
-
-    return 0;
-#endif
-
-err:
-    kfree(p_aml_audio);
-    return ret;
-}
-
-static int aml_m8_audio_remove(struct platform_device *pdev)
-{
-    int ret = 0;
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-	struct aml_audio_private_data *p_aml_audio;
-
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-	snd_soc_unregister_card(card);
-#if HP_DET
-	/* stop timer */
-	mutex_lock(&p_aml_audio->lock);
-	if (p_aml_audio->timer_en) {
-		aml_audio_stop_timer(p_aml_audio);
-	}
-	mutex_unlock(&p_aml_audio->lock);
-#endif
-
-	aml_m8_pinmux_deinit(card);
-    kfree(p_aml_audio);
-    return ret;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_audio_dt_match[]={
-	{ .compatible = "sound_card, aml_snd_m8", },
-	{},
-};
-#else
-#define amlogic_audio_dt_match NULL
-#endif
-
-static struct platform_driver aml_m8_audio_driver = {
-    .probe  = aml_m8_audio_probe,
-    .remove = aml_m8_audio_remove,
-    .driver = {
-        .name = DRV_NAME,
-        .owner = THIS_MODULE,
-        .pm = &snd_soc_pm_ops,
-        .of_match_table = amlogic_audio_dt_match,
-    },
-};
-
-static int __init aml_m8_audio_init(void)
-{
-    return platform_driver_register(&aml_m8_audio_driver);
-}
-
-static void __exit aml_m8_audio_exit(void)
-{
-    platform_driver_unregister(&aml_m8_audio_driver);
-}
-
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(aml_m8_audio_init);
-#else
-module_init(aml_m8_audio_init);
-#endif
-module_exit(aml_m8_audio_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML_M8 audio machine Asoc driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
-
diff --git a/sound/soc/aml/aml_m_dummy.c b/sound/soc/aml/aml_m_dummy.c
deleted file mode 100755
index 6aca7c0ed16b..000000000000
--- a/sound/soc/aml/aml_m_dummy.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * aml_m_dummy_codec.c  --  SoC audio for AML M series
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/jack.h>
-#include <sound/dummy_codec.h>
-
-#include <asm/mach-types.h>
-#include <mach/hardware.h>
-
-#include "aml_i2s_dai.h"
-#include "aml_i2s.h"
-#include "aml_audio_hw.h"
-
-#ifdef CONFIG_USE_OF
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/of_gpio.h>
-#include <mach/pinmux.h>
-#include <plat/io.h>
-#endif
-
-static struct dummy_codec_platform_data *dummy_codec_snd_pdata = NULL;
-
-#ifdef CONFIG_USE_OF
-static struct device_node *np = NULL;
-static struct dummy_codec_platform_data *dummy_codec_pdata = NULL;
-struct device *dummy_codec_dev = NULL;
-struct pinctrl *p = NULL;
-#endif
-static void dummy_codec_dev_init(void)
-{
-    if (dummy_codec_snd_pdata->device_init) {
-        dummy_codec_snd_pdata->device_init();
-    }
-}
-
-static void dummy_codec_dev_uninit(void)
-{
-    if (dummy_codec_snd_pdata->device_uninit) {
-        dummy_codec_snd_pdata->device_uninit();
-    }
-}
-
-static void dummy_codec_mute_speaker(int mute)
-{
-	if (dummy_codec_snd_pdata->mute_spk){
-		dummy_codec_snd_pdata->mute_spk(mute);
-	}
-}
-static int dummy_codec_hw_params(struct snd_pcm_substream *substream,
-    struct snd_pcm_hw_params *params)
-{
-    struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    struct snd_soc_dai *codec_dai = rtd->codec_dai;
-    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-    int ret;
-
-    printk(KERN_DEBUG "enter %s rate: %d format: %d\n", __func__, params_rate(params), params_format(params));
-
-    /* set codec DAI configuration */
-    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
-        return ret;
-    }
-
-    /* set cpu DAI configuration */
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-	{
-    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
-	}
-	else
-    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
-        return ret;
-    }
-#if 0   //no audio in
-    /* set codec DAI clock */
-    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-#endif
-    /* set cpu DAI clock */
-    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
-    if (ret < 0) {
-        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
-        return ret;
-    }
-
-    return 0;
-}
-
-static struct snd_soc_ops dummy_codec_soc_ops = {
-    .hw_params = dummy_codec_hw_params,
-};
-
-static int dummy_codec_set_bias_level(struct snd_soc_card *card,
-			      enum snd_soc_bias_level level)
-{
-    int ret = 0;
-
-    switch (level) {
-    case SND_SOC_BIAS_ON:
-        break;
-    case SND_SOC_BIAS_PREPARE:
-    	dummy_codec_mute_speaker(0);
-        break;
-
-    case SND_SOC_BIAS_OFF:
-    	break;
-    case SND_SOC_BIAS_STANDBY:
-        dummy_codec_mute_speaker(1);
-        break;
-    default:
-        return ret;
-    }
-    return 0;
-}
-
-static int dummy_codec_codec_init(struct snd_soc_pcm_runtime *rtd)
-{
-    return 0;
-}
-
-static struct snd_soc_dai_link dummy_codec_dai_link[] = {
-    {
-        .name = "DUMMY_CODEC",
-        .stream_name = "DUMMY_CODEC PCM",
-        .cpu_dai_name = "aml-i2s-dai.0",
-        .codec_dai_name = "dummy_codec",
-        .init = dummy_codec_codec_init,
-        .platform_name = "aml-i2s.0",
-        .codec_name = "dummy_codec.0",
-        .ops = &dummy_codec_soc_ops,
-    },
-
-	{
-        .name = "AML-SPDIF",
-        .stream_name = "SPDIF PCM",
-        .cpu_dai_name = "aml-spdif-dai.0",
-        .codec_dai_name = "dit-hifi",
-        .init = NULL,
-        .platform_name = "aml-i2s.0",
-        .codec_name = "spdif-dit.0",
-        .ops = NULL,      
-    },
-
-};
-
-static struct snd_soc_card snd_soc_dummy_codec = {
-    .name = "AML-DUMMY-CODEC",
-    .driver_name = "SOC-Audio",
-    .dai_link = &dummy_codec_dai_link[0],
-    .num_links = ARRAY_SIZE(dummy_codec_dai_link),
-    .set_bias_level = dummy_codec_set_bias_level,
-};
-
-#ifdef CONFIG_USE_OF
-static void dummy_codec_device_init(void)
-{
-#ifdef CONFIG_USE_OF
-	int ret;
-	struct pinctrl_state *s;
-	p = pinctrl_get(dummy_codec_dev);
-
-	if (IS_ERR(p))
-		return p;
-
-	s = pinctrl_lookup_state(p, "dummy_codec_audio");
-	if (IS_ERR(s)) {
-		pinctrl_put(p);
-		return ERR_PTR(PTR_ERR(s));
-	}
-
-	ret = pinctrl_select_state(p, s);
-	if (ret < 0) {
-		pinctrl_put(p);
-		return ERR_PTR(ret);
-	}
-	printk("=%s==,dummy_codec_audio init done\n",__func__);
-#else
-    /* audio pinmux */
-//    pinmux_set(&rt5631_pinmux_set);
-
-    /* GPIOA_19 PULL_UP_REG0 bit19 */
-//    aml_set_reg32_bits(P_PAD_PULL_UP_REG0, 1, 19, 1);
-#endif
-}
-
-static void dummy_codec_device_deinit(void)
-{
-#ifdef CONFIG_USE_OF
-	pinctrl_put(p);
-#else
-//    pinmux_clr(&rt5631_pinmux_set);
-#endif
-}
-#endif
-static struct platform_device *dummy_codec_snd_device = NULL;
-
-static int dummy_codec_audio_probe(struct platform_device *pdev)
-{
-    int ret = 0;
-		struct snd_soc_card *card = &snd_soc_dummy_codec;
-
-    //printk(KERN_DEBUG "enter %s\n", __func__);
-    printk("enter %s\n", __func__);
-#ifdef CONFIG_USE_OF
-		dummy_codec_pdata = kzalloc(sizeof(struct dummy_codec_platform_data), GFP_KERNEL);
-		if(!dummy_codec_pdata){
-           // kfree(dummy_codec_pdata);
-			return -1;
-		}
-
-		if (pdev->dev.of_node) {
-            np = pdev->dev.of_node;
-            ret = of_property_match_string(np,"status","okay");
-            if(ret){
-                printk("the platform not register this codec\n");
-				goto err1;
-            }
-		}
-		dummy_codec_dev=&pdev->dev;
-    dummy_codec_pdata->device_init = &dummy_codec_device_init;
-    dummy_codec_pdata->device_uninit = &dummy_codec_device_deinit;
-
-		pdev->dev.platform_data = dummy_codec_pdata;
-		dummy_codec_snd_pdata = pdev->dev.platform_data;
-#endif
-
-#if 1
-    card->dev = &pdev->dev;
-		platform_set_drvdata(pdev, card);
-		snd_soc_card_set_drvdata(card, dummy_codec_pdata);
-		if (!(pdev->dev.of_node)) {
-			dev_err(&pdev->dev, "Must be instantiated using device tree\n");
-			ret = -EINVAL;
-			goto err;
-		}
-
-    ret = snd_soc_register_card(card);
-		if (ret) {
-			dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
-			ret);
-		goto err;
-	}
-
-#endif
-#if 0
-    dummy_codec_snd_pdata = pdev->dev.platform_data;
-    snd_BUG_ON(!dummy_codec_snd_pdata);
-    dummy_codec_snd_device = platform_device_alloc("soc-audio", -1);
-    if (!dummy_codec_snd_device) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        ret = -ENOMEM;
-        goto err;
-    }
-
-    platform_set_drvdata(dummy_codec_snd_device, &snd_soc_dummy_codec);
-
-    ret = platform_device_add(dummy_codec_snd_device);
-    if (ret) {
-        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
-        goto err_device_add;
-    }
-#endif
-
-    dummy_codec_dev_init();
-
-    return ret;
-
-err_device_add:
-    platform_device_put(dummy_codec_snd_device);
-err:
-err1:
-    kfree(dummy_codec_pdata);
-    return ret;
-}
-
-static int dummy_codec_audio_remove(struct platform_device *pdev)
-{
-    int ret = 0;
-
-    dummy_codec_dev_uninit();
-
-    platform_device_put(dummy_codec_snd_device);
-    kfree(dummy_codec_pdata);
-
-    dummy_codec_snd_device = NULL;
-    dummy_codec_snd_pdata = NULL;
-
-    return ret;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id aml_dummy_codec_dt_match[]={
-	{	.compatible = "amlogic,aml_dummy_codec_audio",
-	},
-	{},
-};
-#else
-#define aml_dummy_codec_dt_match NULL
-#endif
-static struct platform_driver aml_m_dummy_codec_driver = {
-    .probe  = dummy_codec_audio_probe,
-    .remove = dummy_codec_audio_remove,
-    .driver = {
-        .name = "aml_dummy_codec_audio",
-        .owner = THIS_MODULE,
-        .of_match_table = aml_dummy_codec_dt_match,
-    },
-};
-
-static int __init aml_m_dummy_codec_init(void)
-{
-    return platform_driver_register(&aml_m_dummy_codec_driver);
-}
-
-static void __exit aml_m_dummy_codec_exit(void)
-{
-    platform_driver_unregister(&aml_m_dummy_codec_driver);
-}
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(aml_m_dummy_codec_init);
-#else
-module_init(aml_m_dummy_codec_init);
-#endif
-module_exit(aml_m_dummy_codec_exit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML dummy_codec audio driver");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_mixer.c b/sound/soc/aml/aml_mixer.c
deleted file mode 100644
index d7aab5661ee8..000000000000
--- a/sound/soc/aml/aml_mixer.c
+++ /dev/null
@@ -1,371 +0,0 @@
-#include <sound/core.h>
-#include <sound/control.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <linux/soundcard.h>
-
-#include "aml_pcm.h"
-#include "aml_alsa_common.h"
-#include "aml_audio_hw.h"
-
-extern audio_tone_control_t audio_tone_control;
-
-static int pcm_pb_volume_info(struct snd_kcontrol *kcontrol,
-                              struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 100;
-    uinfo->value.integer.step = 1;
-
-    return 0;
-}
-
-static int pcm_pb_volume_get(struct snd_kcontrol *kcontrol,
-                             struct snd_ctl_elem_value *uvalue)
-{
-    int val;
-
-    val = get_mixer_output_volume();
-    val = val & 0xff;
-    uvalue->value.integer.value[0] = val;
-
-    return 0;
-}
-
-static int pcm_pb_volume_put(struct snd_kcontrol *kcontrol,
-                             struct snd_ctl_elem_value *uvalue)
-{
-    int volume;
-
-    volume = uvalue->value.integer.value[0];
-  //  volume = volume | (volume << 8);
-    set_mixer_output_volume(volume);
-    return 0;
-}
-
-static int pcm_pb_mute_info(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 1;
-
-    return 0;
-}
-
-static int pcm_pb_mute_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *uvalue)
-{
-    return 0;
-}
-
-static int pcm_pb_mute_put(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     int flag;
-
-     flag = uvalue->value.integer.value[0];
-     if(flag)
-	 	audio_i2s_unmute();
-	 else
-	 	audio_i2s_mute();
-
-     return 0;
-}
-
-static int pcm_left_mono_info(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 1;
-
-    return 0;
-}
-
-static int pcm_left_mono_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *uvalue)
-{
-    return 0;
-}
-
-static int pcm_left_mono_put(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     int flag;
-
-     flag = uvalue->value.integer.value[0];
-     if(flag){
-	 	audio_i2s_swap_left_right(1);
-     }
-
-     return 0;
-}
-
-static int pcm_right_mono_info(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 1;
-
-    return 0;
-}
-
-static int pcm_right_mono_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *uvalue)
-{
-    return 0;
-}
-
-static int pcm_right_mono_put(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     int flag;
-
-     flag = uvalue->value.integer.value[0];
-     if(flag){
-	 	audio_i2s_swap_left_right(2);
-     }
-
-     return 0;
-}
-
-static int pcm_stereo_info(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 1;
-
-    return 0;
-}
-
-static int pcm_stereo_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *uvalue)
-{
-    return 0;
-}
-
-static int pcm_stereo_put(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     int flag;
-
-     flag = uvalue->value.integer.value[0];
-     if(flag){
-	 	audio_i2s_swap_left_right(0);
-     }
-
-     return 0;
-}
-
-static int pcm_swap_info(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 1;
-
-    return 0;
-}
-
-static int pcm_swap_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *uvalue)
-{
-    return 0;
-}
-
-static int pcm_swap_put(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     int flag;
-     unsigned int reg;
-
-     flag = uvalue->value.integer.value[0];
-     if(flag){
-		reg = read_i2s_mute_swap_reg();
-		if((reg & 0x3))
-			audio_i2s_swap_left_right(0);
-		else
-			audio_i2s_swap_left_right(3);
-     }
-
-     return 0;
-}
-
-static int pcm_pb_data_info(struct snd_kcontrol *kcontrol,
-						struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-    uinfo->count = 128;
-
-    return 0;
-}
-
-static int pcm_pb_data_get(struct snd_kcontrol *kcontrol,
-						struct snd_ctl_elem_value *uvalue)
-{
-    unsigned int rd_ptr;
-
-    rd_ptr = read_i2s_rd_ptr();
-    memcpy(uvalue->value.bytes.data, (unsigned char*)rd_ptr, 128);
-    return 0;
-}
-
-static int pcm_pb_tone_info(struct snd_kcontrol *kcontrol,
-						struct snd_ctl_elem_info *uinfo)
-{
-    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    uinfo->count = 1;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = 1;
-
-    return 0;
-}
-
-static int pcm_pb_tone_put(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     audio_tone_control.tone_flag = 1;
-	
-     return 0;
-}
-static int pcm_pb_tone_get(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_value *uvalue)
-{
-     return 0;
-}
-struct snd_kcontrol_new pcm_control_pb_vol = {
-    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-    .name = "Master Playback Volume",
-    .index = 0x00,
-    .info = pcm_pb_volume_info,
-    .get = pcm_pb_volume_get,
-    .put = pcm_pb_volume_put,
-    .private_value = 0x0,
-};
-
-struct snd_kcontrol_new pcm_switch_pb_mute = {
-     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-     .name = "switch playback mute",
-     .index = 0x00,
-     .info = pcm_pb_mute_info,
-     .get = pcm_pb_mute_get,
-     .put = pcm_pb_mute_put,
-     .private_value = 0xff,
-};
-
-struct snd_kcontrol_new pcm_pb_left_mono = {
-     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-     .name = "Playback Left Mono",
-     .index = 0x00,
-     .info = pcm_left_mono_info,
-     .get = pcm_left_mono_get,
-     .put = pcm_left_mono_put,
-     .private_value = 0xff,
-};
-
-struct snd_kcontrol_new pcm_pb_right_mono = {
-     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-     .name = "Playback Right Mono",
-     .index = 0x00,
-     .info = pcm_right_mono_info,
-     .get = pcm_right_mono_get,
-     .put = pcm_right_mono_put,
-     .private_value = 0xff,
-};
-
-struct snd_kcontrol_new pcm_pb_stereo = {
-     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-     .name = "Playback Stereo Out",
-     .index = 0x00,
-     .info = pcm_stereo_info,
-     .get = pcm_stereo_get,
-     .put = pcm_stereo_put,
-     .private_value = 0xff,
-};
-
-struct snd_kcontrol_new pcm_pb_swap = {
-     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-     .name = "Playback Swap Left Right",
-     .index = 0x00,
-     .info = pcm_swap_info,
-     .get = pcm_swap_get,
-     .put = pcm_swap_put,
-     .private_value = 0xff,
-};
-
-struct snd_kcontrol_new pcm_data_read = {
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = "Playback Data Get",
-	.info = pcm_pb_data_info,
-	.get = pcm_pb_data_get,
-	.access = (SNDRV_CTL_ELEM_ACCESS_READ |
-			  SNDRV_CTL_ELEM_ACCESS_VOLATILE),
-};
-
-struct snd_kcontrol_new pcm_tone_play = {
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = "Playback Tone",
-	.info = pcm_pb_tone_info,
-	.put = pcm_pb_tone_put,
-	.get = pcm_pb_tone_get,
-	.access = (SNDRV_CTL_ELEM_ACCESS_WRITE |
-	          SNDRV_CTL_ELEM_ACCESS_READ), 
-	          
-};
-
-int aml_alsa_create_ctrl(struct snd_card *card, void *p_value)
-{
-    int err = 0;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_control_pb_vol, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_switch_pb_mute, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_pb_left_mono, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_pb_right_mono, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_pb_stereo, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_pb_swap, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_data_read, p_value))) < 0)
-        return err;
-
-    if ((err =
-         snd_ctl_add(card,
-                     snd_ctl_new1(&pcm_tone_play, p_value))) < 0)
-        return err;
-	
-    return 0;
-}
diff --git a/sound/soc/aml/aml_notify.c b/sound/soc/aml/aml_notify.c
deleted file mode 100644
index d24962f6ed47..000000000000
--- a/sound/soc/aml/aml_notify.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- *  linux/drivers/video/apollo/aout_notify.c
- *
- *  Copyright (C) 2009 amlogic
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
- */
-#include <linux/module.h>
-
-static BLOCKING_NOTIFIER_HEAD(aout_notifier_list);
-/**
- *	aout_register_client - register a client notifier
- *	@nb: notifier block to callback on events
- */
-int aout_register_client(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&aout_notifier_list, nb);
-}
-EXPORT_SYMBOL(aout_register_client);
-
-/**
- *	aout_unregister_client - unregister a client notifier
- *	@nb: notifier block to callback on events
- */
-int aout_unregister_client(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&aout_notifier_list, nb);
-}
-EXPORT_SYMBOL(aout_unregister_client);
-
-/**
- * aout_notifier_call_chain - notify clients of fb_events
- *
- */
-int aout_notifier_call_chain(unsigned long val, void *v)
-{
-	return blocking_notifier_call_chain(&aout_notifier_list, val, v);
-}
-EXPORT_SYMBOL_GPL(aout_notifier_call_chain);
-
-
diff --git a/sound/soc/aml/aml_pcm.c b/sound/soc/aml/aml_pcm.c
deleted file mode 100755
index 0d632f36a512..000000000000
--- a/sound/soc/aml/aml_pcm.c
+++ /dev/null
@@ -1,698 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/ioctl.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/soundcard.h>
-#include <linux/timer.h>
-#include <linux/debugfs.h>
-#include <linux/major.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/control.h>
-#include <sound/soc.h>
-#include <sound/pcm_params.h>
-
-
-#include <mach/am_regs.h>
-#include <mach/pinmux.h>
-
-#include "aml_i2s.h" 
-#include "aml_pcm.h"
-#include "aml_audio_hw_pcm2bt.h"
-
-
-#define USE_HRTIMER 0
-#define HRTIMER_PERIOD (1000000000UL/1000)
-#define DEBUG_ALSA_PLATFRORM
-
-
-
-//#define PCM_DEBUG
-
-#ifdef PCM_DEBUG
-#define pcm_debug(fmt, args...)  printk (fmt, ## args)
-#else
-#define pcm_debug(fmt, args...)
-#endif
-
-
-/*--------------------------------------------------------------------------*\
- * Hardware definition
-\*--------------------------------------------------------------------------*/
-/* TODO: These values were taken from the AML platform driver, check
- *	 them against real values for AML
- */
-static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
-	.info			= SNDRV_PCM_INFO_INTERLEAVED|
-							SNDRV_PCM_INFO_BLOCK_TRANSFER|
-				  		    SNDRV_PCM_INFO_PAUSE,
-				  		
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
-
-	.period_bytes_min	= 32,
-	.period_bytes_max	= 8*1024,
-	.periods_min		= 2,
-	.periods_max		= 1024,
-	.buffer_bytes_max	= 64 * 1024,
-	
-	.rate_min = 8000,
-    .rate_max = 8000,
-    .channels_min = 1,
-    .channels_max = 1,
-};
-
-
-static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
-
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
-	.count = ARRAY_SIZE(period_sizes),
-	.list = period_sizes,
-	.mask = 0
-};
-
-unsigned int aml_pcm2bt_playback_buffer_addr = 0;
-unsigned int aml_pcm2bt_playback_buffer_size = 0;
-unsigned int aml_pcm2bt_capture_buffer_addr = 0;
-unsigned int aml_pcm2bt_capture_buffer_size = 0;
-
-unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
-unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
-unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
-unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
-
-#if 0
-static void aml_pcm_config_tx(u32 addr, u32 size)
-{
-    pcm_debug("****%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
-    pcm_out_set_buf(addr, size);
-}
-
-static void aml_pcm_config_rx(u32 addr, u32 size)
-{
-    pcm_debug("****%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
-    pcm_in_set_buf(addr, size);
-}
-
-static void aml_pcm_start_tx(void)
-{
-    pcm_debug( "***%s", __FUNCTION__);
-    pcm_out_enable(1);
-}
-
-static void aml_pcm_start_rx(void)
-{
-    pcm_debug("*****%s", __FUNCTION__);
-    pcm_in_enable(1);
-}
-
-static void aml_pcm_stop_tx(void)
-{
-    pcm_debug("*****%s", __FUNCTION__);
-    pcm_out_enable(0);
-}
-
-static void aml_pcm_stop_rx(void)
-{
-    pcm_debug("****%s", __FUNCTION__);
-    pcm_in_enable(0);
-}
-#endif
-static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
-{
-    unsigned int value = 0;
-    signed int diff = 0;
-
-    value = pcm_out_rd_ptr();
-    diff = value - prtd->buffer_start;
-    if (diff < 0)
-        diff = 0;
-    else if (diff >= prtd->buffer_size)
-        diff = prtd->buffer_size;
-
-    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
-    return (unsigned int)diff;
-}
-
-static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
-{
-    unsigned int value = 0;
-    signed int diff = 0;
-
-    value = pcm_in_wr_ptr();
-    diff = value - prtd->buffer_start;
-    if (diff < 0)
-        diff = 0;
-    else if (diff >= prtd->buffer_size)
-        diff = prtd->buffer_size;
-
-    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
-    return (unsigned int)diff;
-}
-
-static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
-{
-    struct snd_pcm_substream *substream = prtd->substream;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    unsigned int offset = 0;
-    unsigned int size = 0;
-    
-    if (prtd->running && snd_pcm_running(substream)) {
-    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-    		offset = aml_pcm_offset_tx(prtd);
-            if (offset < prtd->buffer_offset) {
-                size = prtd->buffer_size + offset - prtd->buffer_offset;
-            } else {
-                size = offset - prtd->buffer_offset;
-            }
-    	} else {
-            int rx_overflow = 0;
-    		offset = aml_pcm_offset_rx(prtd);
-            if (offset < prtd->buffer_offset) {
-                size = prtd->buffer_size + offset - prtd->buffer_offset;
-            } else {
-                size = offset - prtd->buffer_offset;
-            }
-            rx_overflow = pcm_in_fifo_int() & (1 << 2);
-            if (rx_overflow) {
-                printk(KERN_WARNING "%s AUDIN_FIFO overflow !!\n", __FUNCTION__);
-            }
-    	}
-    }
-
-    prtd->buffer_offset = offset;
-    prtd->data_size += size;
-    if (prtd->data_size >= frames_to_bytes(runtime, runtime->period_size)) {
-        prtd->peroid_elapsed++;
-    }
-
-    pcm_debug(KERN_DEBUG "%s buffer offset: %d data size: %d peroid size: %d peroid elapsed: %d\n",
-                __FUNCTION__, prtd->buffer_offset, prtd->data_size, frames_to_bytes(runtime, runtime->period_size), prtd->peroid_elapsed);
-}
-
-static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
-{
-    prtd->timer.expires = jiffies + prtd->timer_period;
-	add_timer(&prtd->timer);
-}
-
-static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
-{
-    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
-	spin_lock(&prtd->lock);
-	aml_pcm2bt_timer_rearm(prtd);
-    prtd->running = 1;
-	spin_unlock(&prtd->lock);
-	return 0;
-}
-
-static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
-{
-    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
-	spin_lock(&prtd->lock);
-    prtd->running = 0;
-	del_timer(&prtd->timer);
-	spin_unlock(&prtd->lock);
-	return 0;
-}
-
-
-static void aml_pcm2bt_timer_callback(unsigned long data)
-{
-    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	unsigned long flags;
-	unsigned int elapsed = 0;
-    unsigned int datasize = 0;
-	
-	spin_lock_irqsave(&prtd->lock, flags);
-    aml_pcm2bt_timer_update(prtd);
-    aml_pcm2bt_timer_rearm(prtd);
-	elapsed = prtd->peroid_elapsed;
-    datasize = prtd->data_size;
-    if (elapsed) {
-        prtd->peroid_elapsed--;
-        prtd->data_size -= frames_to_bytes(runtime, runtime->period_size);
-    }
-	spin_unlock_irqrestore(&prtd->lock, flags);
-	if (elapsed) {
-        if (elapsed > 1) {
-            printk(KERN_WARNING "PCM timer callback not fast enough (elapsed periods: %d data_bytes: %d period_bytes: %d)!",
-                    elapsed, datasize, frames_to_bytes(runtime, runtime->period_size));
-        }
-		snd_pcm_period_elapsed(prtd->substream);
-    }
-}
-
-static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-
-    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
-	init_timer(&prtd->timer);
-    prtd->timer_period = 1;
-	prtd->timer.data = (unsigned long)substream;
-	prtd->timer.function = aml_pcm2bt_timer_callback;
-    prtd->running = 0;
-	return 0;
-}
-
-static int aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
-			      struct snd_pcm_hw_params *params)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	size_t size = params_buffer_bytes(params);
-    int ret = 0;
-
-	ret = snd_pcm_lib_malloc_pages(substream, size);
-    if (ret < 0) {
-        printk(KERN_ERR "%s snd_pcm_lib_malloc_pages return: %d\n", __FUNCTION__, ret);
-    } else {
-        prtd->buffer_start = runtime->dma_addr;
-        prtd->buffer_size = runtime->dma_bytes;
-        pcm_debug(KERN_DEBUG "%s dma_addr: 0x%08x dma_bytes: 0x%x\n", __FUNCTION__, runtime->dma_addr, runtime->dma_bytes);
-
-        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-            aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
-            aml_pcm2bt_playback_phy_buffer_size = runtime->dma_bytes;
-        } else {
-            aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
-            aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
-        }
-    }
-
-    return ret;
-}
-
-static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	snd_pcm_lib_free_pages(substream);
-
-    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        aml_pcm2bt_playback_phy_buffer_addr = 0;
-        aml_pcm2bt_playback_phy_buffer_size = 0;
-    } else {
-        aml_pcm2bt_capture_phy_buffer_addr = 0;
-        aml_pcm2bt_capture_phy_buffer_size = 0;
-    }
-
-    return 0;
-}
-
-static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-    return 0;
-#if 0
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        pcm_debug(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
-        aml_pcm_config_tx(prtd->buffer_start, prtd->buffer_size);
-       // aml_pcm2bt_playback_buffer_addr = (unsigned int)runtime->dma_area;
-       // aml_pcm2bt_playback_buffer_size = runtime->dma_bytes;
-	} else {
-	    pcm_debug(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
-        aml_pcm_config_rx(prtd->buffer_start, prtd->buffer_size);
-        //aml_pcm2bt_capture_buffer_addr = (unsigned int)runtime->dma_area;
-        //aml_pcm2bt_capture_buffer_size = runtime->dma_bytes;
-	}
-
-    memset(runtime->dma_area, 0, runtime->dma_bytes);
-    prtd->buffer_offset = 0;
-    prtd->data_size = 0;
-    prtd->peroid_elapsed = 0;
-#endif
-	return 0;
-}
-
-static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	int ret = 0;
-
-	switch (cmd) {
-    	case SNDRV_PCM_TRIGGER_START:
-        case SNDRV_PCM_TRIGGER_RESUME:
-        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-/*    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-    			aml_pcm_start_tx();
-    		else
-    			aml_pcm_start_rx();
- */   			
-            aml_pcm2bt_timer_start(prtd);
-    		break;
-    	case SNDRV_PCM_TRIGGER_STOP:
-    	case SNDRV_PCM_TRIGGER_SUSPEND:
-    	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-            aml_pcm2bt_timer_stop(prtd);
-/*    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-    			aml_pcm_stop_tx();
-    		else
-    			aml_pcm_stop_rx();
-*/
-    		break;
-    	default:
-    		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-    snd_pcm_uframes_t frames;
-        
-	pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-    frames = bytes_to_frames(runtime, (ssize_t)prtd->buffer_offset);
-
-	return frames;
-}
-
-static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd;
-	int ret;
-
-	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
-
-    /* Ensure that peroid size is a multiple of 32bytes */
-	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
-	if (ret < 0) {
-		printk(KERN_ERR "set period bytes constraint error\n");
-		goto out;
-	}
-
-	/* Ensure that buffer size is a multiple of period size */
-	ret = snd_pcm_hw_constraint_integer(runtime,
-					    SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret < 0) {
-        printk(KERN_ERR "set periods constraint error\n");
-		goto out;
-    }
-
-	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
-	if (prtd == NULL) {
-        printk(KERN_ERR "out of memory\n");
-		ret = -ENOMEM;
-		goto out;
-	}
-
-    runtime->private_data = prtd;
-    aml_pcm2bt_timer_create(substream);
-    prtd->substream = substream;
-	spin_lock_init(&prtd->lock);
-
-    return 0;
-out:
-	return ret;
-}
-
-
-static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-   
-    printk(KERN_INFO "enter %s type: %d\n", __FUNCTION__, substream->stream);
-    if (prtd)
-	    kfree(runtime->private_data);
-	return 0;
-}
-
-
-static int aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
-    snd_pcm_uframes_t pos,
-    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-    unsigned char* hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
-    unsigned int wrptr = 0;
-    int ret = 0;
-
-    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
-
-	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
-        printk(KERN_ERR "%s copy from user failed!\n", __FUNCTION__);
-		return -EFAULT;
-    } else {
-        wrptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
-        if (wrptr >= (prtd->buffer_start + prtd->buffer_size)) {
-            wrptr = prtd->buffer_start + prtd->buffer_size;
-        }
-        pcm_out_set_wr_ptr(wrptr);
-    }
-
-    return ret;
-}
-
-	
-
-
-static int aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
-    snd_pcm_uframes_t pos,
-    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct aml_pcm_runtime_data *prtd = runtime->private_data;
-    signed short *hwbuf = (signed short*)(runtime->dma_area + frames_to_bytes(runtime, pos));
-    unsigned int rdptr = 0;
-    int ret = 0;
-
-    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
-
-	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
-        printk(KERN_ERR "%s copy to user failed!\n", __FUNCTION__);
-		return -EFAULT;
-    } else {
-        //memset(hwbuf, 0xff, frames_to_bytes(runtime, count));
-        rdptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
-        if (rdptr >= (prtd->buffer_start + prtd->buffer_size)) {
-            rdptr = prtd->buffer_start + prtd->buffer_size;
-        }
-        pcm_in_set_rd_ptr(rdptr);
-    }
-    return ret;
-}
-
-static int aml_pcm2bt_copy(struct snd_pcm_substream *substream, int channel,
-    snd_pcm_uframes_t pos,
-    void __user *buf, snd_pcm_uframes_t count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    int ret = 0;
-
-    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        ret = aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
-    } else {
-        ret = aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
-    }
-
-    return ret;
-}
-
-
-static int aml_pcm2bt_silence(struct snd_pcm_substream *substream, int channel, 
-    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    unsigned char* ppos = NULL;
-    ssize_t n;
-
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-    n = frames_to_bytes(runtime, count);
-    ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
-    memset(ppos, 0, n);
-
-    return 0;
-}
-                        
-static struct snd_pcm_ops aml_pcm2bt_ops = {
-	.open		= aml_pcm2bt_open,
-	.close		= aml_pcm2bt_close,
-	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= aml_pcm2bt_hw_params,
-	.hw_free	= aml_pcm2bt_hw_free,
-	.prepare	= aml_pcm2bt_prepare,
-	.trigger	= aml_pcm2bt_trigger,
-	.pointer	= aml_pcm2bt_pointer,
-	.copy 		= aml_pcm2bt_copy,
-	.silence	= aml_pcm2bt_silence,
-};
-
-
-/*--------------------------------------------------------------------------*\
- * ASoC platform driver
-\*--------------------------------------------------------------------------*/
-
-static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
-
-static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
-	int stream)
-{
-	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;
-    //struct aml_pcm_runtime_data *prtd = runtime->private_data;
-	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
-
-    printk(KERN_DEBUG "enter %s stream: %d\n", __FUNCTION__, stream);
-    
-	buf->dev.type = SNDRV_DMA_TYPE_DEV;
-	buf->dev.dev = pcm->card->dev;
-	buf->private_data = NULL;
-	buf->area = dma_alloc_coherent(pcm->card->dev, size,
-					   &buf->addr, GFP_KERNEL);
-	if (!buf->area) {
-        printk(KERN_ERR "%s dma_alloc_coherent failed (size: %d)!\n", __FUNCTION__, size);
-		return -ENOMEM;
-    }
-
-	buf->bytes = size;
-    printk(KERN_INFO "%s allcoate buf->area: %p buf->addr: 0x%x buf->bytes: %d\n",
-                __FUNCTION__, buf->area, buf->addr, buf->bytes);  
-	return 0;
-}
-
-static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	int ret = 0;
-       struct snd_soc_card *card = rtd->card;
-       struct snd_pcm *pcm =rtd->pcm ;  
-       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
-       pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
-    
-	if (!card->dev->dma_mask)
-		card->dev->dma_mask = &aml_pcm2bt_dmamask;
-	if (!card->dev->coherent_dma_mask)
-		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
-
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
-		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
-			SNDRV_PCM_STREAM_PLAYBACK);
-		if (ret)
-			goto out;
-	}
-
-	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
-			SNDRV_PCM_STREAM_CAPTURE);
-		if (ret)
-			goto out;
-	}
-
-out:
-	return ret;
-}
-
-static void aml_pcm2bt_free(struct snd_pcm *pcm)
-{
-	struct snd_pcm_substream *substream;
-	struct snd_dma_buffer *buf;
-	int stream;
-
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	for (stream = 0; stream < 2; stream++) {
-		substream = pcm->streams[stream].substream;
-		if (!substream)
-			continue;
-
-		buf = &substream->dma_buffer;
-		if (!buf->area)
-			continue;
-
-		dma_free_coherent(pcm->card->dev, buf->bytes,
-				      buf->area, buf->addr);
-		buf->area = NULL;
-	}
-}
-
-#if 0
-struct aml_audio_interface aml_pcm_interface = {
-    .id = AML_AUDIO_PCM,
-    .name = "PCM",
-    .pcm_ops = &aml_pcm2bt_ops,
-    .pcm_new = aml_pcm2bt_new,
-    .pcm_free =  aml_pcm2bt_free,
-};
-
-#endif
-
-struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
-	.ops 	= &aml_pcm2bt_ops,
-	.pcm_new	= aml_pcm2bt_new,
-	.pcm_free	= aml_pcm2bt_free,
-	//.suspend	= aml_pcm_suspend,
-	//.resume		= aml_pcm_resume,
-};
-EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
-
-static int aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
-	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
-}
-
-static int aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_platform(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id amlogic_audio_dt_match[]={
-	{	.compatible = "amlogic,aml-pcm",
-	},
-	{},
-};
-#else
-#define amlogic_audio_dt_match NULL
-#endif
-
-
-static struct platform_driver aml_platform_pcm2bt_driver = {
-	.driver = {
-			.name = "aml-pcm",
-			.owner = THIS_MODULE,
-			.of_match_table = amlogic_audio_dt_match,
-	},
-
-	.probe = aml_soc_platform_pcm2bt_probe,
-	.remove = aml_soc_platform_pcm2bt_remove,
-};
-
-static int __init aml_alsa_bt_init(void)
-{
-	//aml_pcm_init_debugfs();		
-	return platform_driver_register(&aml_platform_pcm2bt_driver);
-}
-
-static void __exit aml_alsa_bt_exit(void)
-{
-	//aml_pcm_cleanup_debugfs();
-    platform_driver_unregister(&aml_platform_pcm2bt_driver);
-}
-
-module_init(aml_alsa_bt_init);
-module_exit(aml_alsa_bt_exit);
-
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("AML audio driver for ALSA");
-
diff --git a/sound/soc/aml/aml_pcm.h b/sound/soc/aml/aml_pcm.h
deleted file mode 100755
index 73d68658df6b..000000000000
--- a/sound/soc/aml/aml_pcm.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef __AML_PCM_BT_H__
-#define __AML_PCM_BT_H__
-
-struct aml_pcm_runtime_data {
-	spinlock_t			lock;
-
-    dma_addr_t          buffer_start;
-    unsigned int        buffer_size;
-
-    unsigned int        buffer_offset;
-
-    unsigned int        data_size;
-
-    unsigned int        running;
-    unsigned int        timer_period;
-    unsigned int        peroid_elapsed;
-
-    struct timer_list   timer;
-    struct snd_pcm_substream *substream;
-};
-
-
-#endif
diff --git a/sound/soc/aml/aml_pcm_dai.c b/sound/soc/aml/aml_pcm_dai.c
deleted file mode 100755
index 875e5609abbc..000000000000
--- a/sound/soc/aml/aml_pcm_dai.c
+++ /dev/null
@@ -1,268 +0,0 @@
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/initval.h>
-#include <sound/soc.h>
-
-#include <mach/hardware.h>
-//#include <sound/soc-dai.h>
-
-#include "aml_pcm_dai.h"
-#include "aml_pcm.h"
-#include "aml_i2s.h"
-#include "aml_audio_hw_pcm2bt.h"
-
-
-#include <linux/of.h>
-
-#define DEV_NAME "aml-pcm-dai"
-
-//static aml_dai_info_t dai_info[3] = {{0}};
-#define AML_DAI_DEBUG
-
-
-
-#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
-#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
-#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-pcm-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
-#else
-#define ALSA_DEBUG(fmt,args...) 
-#define ALSA_TRACE()   
-#endif
-
-
-static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{	  	
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-}
-
-static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-//#if 1
-    struct snd_pcm_runtime *runtime = substream->runtime;
-	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-        printk(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
-        pcm_out_set_buf(prtd->buffer_start, prtd->buffer_size);
-	} else {
-	    printk(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
-        pcm_in_set_buf(prtd->buffer_start, prtd->buffer_size);
-	}
-
-    memset(runtime->dma_area, 0, runtime->dma_bytes);
-    prtd->buffer_offset = 0;
-    prtd->data_size = 0;
-    prtd->peroid_elapsed = 0;
-//#endif
-	return 0;
-}
-
-static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
-				struct snd_soc_dai *dai)
-{
-	ALSA_DEBUG();
-	struct snd_pcm_runtime *rtd = substream->runtime;
-	switch (cmd) {
-		case SNDRV_PCM_TRIGGER_START:
-		case SNDRV_PCM_TRIGGER_RESUME:
-		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-			// TODO
-			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-				printk("aiu pcm playback enable\n\n");
-				pcm_out_enable(1);
-			}else{        
-                pcm_in_enable(1);
-			}
-			break;
-		case SNDRV_PCM_TRIGGER_STOP:
-		case SNDRV_PCM_TRIGGER_SUSPEND:
-		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-				printk("aiu pcm playback disable\n\n");
-				pcm_out_enable(0);
-			}else{		
-                pcm_in_enable(0);
-				
-			}
-			break;
-		default:
-			return -EINVAL;
-	}
-
-	return 0;
-}	
-
-
-static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *params,
-					struct snd_soc_dai *dai)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai,
-					unsigned int fmt)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	if(fmt&SND_SOC_DAIFMT_CBS_CFS)
-	snd_soc_dai_get_drvdata(dai);		
-	return 0;
-}
-
-static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
-					int clk_id, unsigned int freq, int dir)
-{
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
-{
-		
-  printk("***Entered %s:%s\n", __FILE__,__func__);
-  return 0;
-}
-
-static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
-{
-  printk("***Entered %s:%s\n", __FILE__,__func__);
-  return 0;
-}
-
-#else /* CONFIG_PM */
-#define aml_dai_pcm_suspend	NULL
-#define aml_dai_pcm_resume	NULL
-#endif /* CONFIG_PM */
-
-
-#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
-#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-
-
-static struct snd_soc_dai_ops aml_dai_pcm_ops = {
-	.startup	= aml_dai_pcm_startup,
-	.shutdown	= aml_dai_pcm_shutdown,
-	.prepare	= aml_dai_pcm_prepare,
-	.trigger = aml_dai_pcm_trigger,
-	.hw_params	= aml_dai_pcm_hw_params,
-	.set_fmt	= aml_dai_set_pcm_fmt,
-	.set_sysclk	= aml_dai_set_pcm_sysclk,
-};
-
-
-struct snd_soc_dai_driver aml_pcm_dai[] = {
-	{	.name = DEV_NAME,
-		.id = 0,
-		.suspend = aml_dai_pcm_suspend,
-		.resume = aml_dai_pcm_resume,
-		.playback = {
-			.channels_min = 1,
-			.channels_max = 1,
-			.rates = AML_DAI_PCM_RATES,
-			.formats = AML_DAI_PCM_FORMATS,},
-		.capture = {
-			.channels_min = 1,
-			.channels_max = 1,
-			.rates = AML_DAI_PCM_RATES,
-			.formats = AML_DAI_PCM_FORMATS,},
-		.ops = &aml_dai_pcm_ops,
-	},
-
-};
-
-EXPORT_SYMBOL_GPL(aml_pcm_dai);
-
-static const struct snd_soc_component_driver aml_component= {
-	.name		= DEV_NAME,
-};
-static int aml_pcm_dai_probe(struct platform_device *pdev)
-{
-	printk(KERN_DEBUG "enter %s\n", __func__);
-#if 0
-	BUG_ON(pdev->id < 0);
-	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
-	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
-#else
-	return snd_soc_register_component(&pdev->dev, &aml_component,
-					 aml_pcm_dai, ARRAY_SIZE(aml_pcm_dai));
-//    return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
-
-#endif
-}
-
-static int aml_pcm_dai_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_component(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_dai_dt_match[]={
-	{	.compatible = "amlogic,aml-pcm-dai",
-	},
-	{},
-};
-#else
-#define amlogic_dai_dt_match NULL
-#endif
-
-static struct platform_driver aml_pcm_dai_driver = {
-	.driver = {
-		.name = DEV_NAME,
-		.owner = THIS_MODULE,
-		.of_match_table = amlogic_dai_dt_match,
-	},
-
-	.probe = aml_pcm_dai_probe,
-	.remove = aml_pcm_dai_remove,
-};
-
-static int __init aml_dai_modinit(void)
-{
-	return platform_driver_register(&aml_pcm_dai_driver);
-}
-module_init(aml_dai_modinit);
-
-static void __exit aml_dai_modexit(void)
-{
-	platform_driver_unregister(&aml_pcm_dai_driver);
-}
-module_exit(aml_dai_modexit);
-
-/* Module information */
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("AML DAI driver for ALSA");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_pcm_dai.h b/sound/soc/aml/aml_pcm_dai.h
deleted file mode 100755
index 332f1da65d9d..000000000000
--- a/sound/soc/aml/aml_pcm_dai.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef AML_DAI_H
-#define AML_DAI_H
-
-extern struct snd_soc_dai_driver aml_dai[];
-
-#endif
diff --git a/sound/soc/aml/aml_spdif_codec.c b/sound/soc/aml/aml_spdif_codec.c
deleted file mode 100755
index b0253d4a0f51..000000000000
--- a/sound/soc/aml/aml_spdif_codec.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * ALSA SoC SPDIF CODEC driver
- *
- *  This driver is used by controllers which can operate in DIT (SPDI/F) where
- *  no codec is needed.  This file provides stub codec that can be used
- *  in these configurations. TI DaVinci Audio controller uses this driver.
- *
- * Author:      Steve Chen,  <schen@mvista.com>
- * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
- * Copyright:   (C) 2009  Texas Instruments, India
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/slab.h>
-#include <sound/soc.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <linux/of.h>
-
-
-#define DRV_NAME "spdif-dit"
-
-#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
-#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
-
-
-static struct snd_soc_codec_driver soc_codec_spdif_dit;
-
-static struct snd_soc_dai_driver dit_stub_dai = {
-	.name		= "dit-hifi",
-	.playback 	= {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 8,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},
-	.capture 	= {
-		.stream_name	= "Capture",
-		.channels_min	= 1,
-		.channels_max	= 8,
-		.rates		= STUB_RATES,
-		.formats	= STUB_FORMATS,
-	},	
-};
-
-static int spdif_dit_probe(struct platform_device *pdev)
-{
-	printk("enter spdif_dit_probe \n");
-	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
-			&dit_stub_dai, 1);
-}
-static int spdif_dit_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_spdif_codec_dt_match[]={
-	{	.compatible = "amlogic,aml-spdif-codec",
-	},
-	{},
-};
-#else
-#define amlogic_spdif_codec_dt_match NULL
-#endif
-
-
-static struct platform_driver spdif_dit_driver = {
-	.probe		= spdif_dit_probe,
-	.remove		= spdif_dit_remove,
-	.driver		= {
-		.name	= DRV_NAME,
-		.owner	= THIS_MODULE,
-		.of_match_table = amlogic_spdif_codec_dt_match,
-	},
-};
-static int __init spdif_codec_init(void)
-{
-	return platform_driver_register(&spdif_dit_driver);
-}
-
-static void __exit spdif_codec_exit(void)
-{
-	platform_driver_unregister(&spdif_dit_driver);
-}
-
-module_init(spdif_codec_init);
-module_exit(spdif_codec_exit);
-
-MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
-MODULE_DESCRIPTION("SPDIF dummy codec driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
-
diff --git a/sound/soc/aml/aml_spdif_dai.c b/sound/soc/aml/aml_spdif_dai.c
deleted file mode 100755
index edba4bdabad3..000000000000
--- a/sound/soc/aml/aml_spdif_dai.c
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
-	Amlogic S/PDIF(HDMI)  Soc dai driver
-	author:jian.xu@amlogic.com
-*/
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/ioctl.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-#include <linux/soundcard.h>
-#include <linux/timer.h>
-#include <linux/debugfs.h>
-#include <linux/major.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/initval.h>
-#include <sound/control.h>
-#include <sound/soc.h>
-#include <sound/pcm_params.h>
-#include <mach/am_regs.h>
-#include <mach/pinmux.h>
-#include "aml_audio_hw.h"
-#include "aml_spdif_dai.h"
-#include "aml_i2s.h"
-#include <linux/of.h>
-
-#define DEBUG_ALSA_SPDIF_DAI
-#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
-#ifdef DEBUG_ALSA_SPDIF_DAI
-#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-spdif-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
-#else
-#define ALSA_DEBUG(fmt,args...) 
-#define ALSA_TRACE()   
-#endif
-extern int aout_notifier_call_chain(unsigned long val, void *v);
-static  unsigned  playback_substream_handle = 0 ;
-extern unsigned int IEC958_mode_codec;
-static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
-				int clk_id, unsigned int freq, int dir)
-{
-	return 0;
-}
-
-static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
-				struct snd_soc_dai *dai)
-{
-	ALSA_DEBUG();
-    ALSA_TRACE();
-	struct snd_soc_pcm_runtime *rtd = NULL;
-	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
-	switch (cmd) {
-		case SNDRV_PCM_TRIGGER_START:
-		case SNDRV_PCM_TRIGGER_RESUME:
-		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-			if(substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
-				ALSA_PRINT("aiu 958 playback enable\n");
-				audio_hw_958_enable(1);
-			}
-			else{
-				ALSA_PRINT("spdif in capture enable\n");				
-				audio_in_spdif_enable(1);
-			}
-			break;
-		case SNDRV_PCM_TRIGGER_STOP:
-		case SNDRV_PCM_TRIGGER_SUSPEND:
-		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-			if(substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
-				ALSA_PRINT("aiu 958 playback disable \n");				
-				audio_hw_958_enable(0);
-			}
-			else{
-				ALSA_PRINT("spdif in capture disable\n");												
-				audio_in_spdif_enable(0);
-			}	
-			break;
-		default:
-			return -EINVAL;
-	}
-
-	return 0;
-}
-/*
-special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
-1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
-2)PCM  output for  all audio, when pcm mode is selected by user .
-3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
-*/
-static unsigned set_clock = 0;
-static void aml_hw_iec958_init(struct snd_pcm_substream *substream)
-{
-	ALSA_DEBUG();
-    ALSA_TRACE();
-	_aiu_958_raw_setting_t set;
-	_aiu_958_channel_status_t chstat;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;	
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-    if(buf==NULL && runtime==NULL){
-        printk("buf/0x%x runtime/0x%x\n",(unsigned )buf,(unsigned )runtime);
-        return;
-    }
-	unsigned i2s_mode,iec958_mode;	
-	unsigned start,size,sample_rate;
-	sample_rate = AUDIO_CLK_FREQ_48;
-	memset((void*)(&set), 0, sizeof(set));
-	memset((void*)(&chstat), 0, sizeof(chstat));
-	set.chan_stat = &chstat;
-	switch(runtime->rate){
-		case 192000:
-			sample_rate	=	AUDIO_CLK_FREQ_192;
-			break;
-		case 176400:
-			sample_rate	=	AUDIO_CLK_FREQ_1764;
-			break;
-		case 96000:
-			sample_rate	=	AUDIO_CLK_FREQ_96;
-			break;
-		case 88200:
-			sample_rate	=	AUDIO_CLK_FREQ_882;
-			break;
-		case 48000:
-			sample_rate	=	AUDIO_CLK_FREQ_48;
-			break;
-		case 44100:
-			sample_rate	=	AUDIO_CLK_FREQ_441;
-			break;
-		case 32000:
-			sample_rate	=	AUDIO_CLK_FREQ_32;
-			break;
-		case 8000:
-			sample_rate	=	AUDIO_CLK_FREQ_8;
-			break;
-		case 11025:
-			sample_rate	=	AUDIO_CLK_FREQ_11;
-			break;
-		case 16000:
-			sample_rate	=	AUDIO_CLK_FREQ_16;
-			break;
-		case 22050:
-			sample_rate	=	AUDIO_CLK_FREQ_22;
-			break;
-		case 12000:
-			sample_rate	=	AUDIO_CLK_FREQ_12;
-			break;
-		case 24000:
-			sample_rate	=	AUDIO_CLK_FREQ_22;
-			break;
-		default:
-			sample_rate	=	AUDIO_CLK_FREQ_441;
-			break;
-	};		
-    printk(KERN_INFO "enterd %s,set_clock:%d,sample_rate=%d\n",__func__,set_clock,sample_rate);
-    if(set_clock != sample_rate){
-        set_clock = sample_rate;
-        audio_set_958_clk(sample_rate, AUDIO_CLK_256FS);
-    }
-	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
-
-	switch(runtime->format){
-	case SNDRV_PCM_FORMAT_S32_LE:
-		i2s_mode = AIU_I2S_MODE_PCM32;
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		i2s_mode = AIU_I2S_MODE_PCM24;
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		i2s_mode = AIU_I2S_MODE_PCM16;
-		break;
-	}	
-	
-	//audio_set_i2s_mode(i2s_mode);
-	/* case 1,raw mode enabled */
-	if(IEC958_mode_codec){
-		if(IEC958_mode_codec == 1){ //dts, use raw sync-word mode
-			iec958_mode = AIU_958_MODE_RAW;
-			printk("iec958 mode RAW\n");
-		}
-		else{ //ac3,use the same pcm mode as i2s configuration
-			iec958_mode = AIU_958_MODE_PCM_RAW;
-			printk("iec958 mode %s\n",(i2s_mode == AIU_I2S_MODE_PCM32)?"PCM32_RAW":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24_RAW":"PCM16_RAW"));
-		}
-	}
-	else{
-		if(i2s_mode == AIU_I2S_MODE_PCM32)
-				iec958_mode = AIU_958_MODE_PCM32;
-		else if(i2s_mode == AIU_I2S_MODE_PCM24)
-				iec958_mode = AIU_958_MODE_PCM24;
-		else
-				iec958_mode = AIU_958_MODE_PCM16;
-		printk("iec958 mode %s\n",(i2s_mode == AIU_I2S_MODE_PCM32)?"PCM32":((i2s_mode == AIU_I2S_MODE_PCM24)?"PCM24":"PCM16"));
-	}
-	if(iec958_mode == AIU_958_MODE_PCM16 || iec958_mode == AIU_958_MODE_PCM24 ||
-		iec958_mode == AIU_958_MODE_PCM32){
-		set.chan_stat->chstat0_l = 0x0100;
-		set.chan_stat->chstat0_r = 0x0100;
-		set.chan_stat->chstat1_l = 0X200;
-		set.chan_stat->chstat1_r = 0X200;
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);
-		audio_set_958outbuf(start, size, 0);
-		//audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
-		//audio_set_aiubuf(start, size);		
-	}else{
-		set.chan_stat->chstat0_l = 0x1902;//NONE-PCM
-		set.chan_stat->chstat0_r = 0x1902;
-		set.chan_stat->chstat1_l = 0X200;
-		set.chan_stat->chstat1_r = 0X200;
-		start = buf->addr;
-		size = snd_pcm_lib_buffer_bytes(substream);;
-		audio_set_958outbuf(start, size, (iec958_mode == AIU_958_MODE_RAW)?1:0);
-		memset((void*)buf->area,0,size);
-	}
-	printk("aiu 958 pcm buffer size %d \n",size);	
-	audio_set_958_mode(iec958_mode, &set);
-	if(IEC958_mode_codec == 4)  //dd+
-		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2); // 4x than i2s
-	else
-#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1	
-		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);//512fs divide 4 == 128fs
-#else
-		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 4, 2); //256fs divide 2 == 128fs
-#endif
-        if(IEC958_mode_codec == 2){
-                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3,substream);
-        }
-        else if(IEC958_mode_codec == 3){
-                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS,substream);
-        }
-        else if(IEC958_mode_codec == 4){
-                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,substream);
-        }
-        else{
-	        aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,substream);
-        }
-}
-/*
-special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
-1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
-2)PCM  output for  all audio, when pcm mode is selected by user .
-3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
-*/
-
-
-void	aml_alsa_hw_reprepare(void)
-{
-    ALSA_TRACE();
-	/* diable 958 module before call initiation */
-	audio_hw_958_enable(0);
-   if(playback_substream_handle!=0)
-  	aml_hw_iec958_init((struct snd_pcm_substream *)playback_substream_handle);
-}
-static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{	  	
-	ALSA_DEBUG();
-    	ALSA_TRACE();	
-	int ret = 0;
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-    	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s;	
-	if(!prtd){
-		prtd = (struct aml_runtime_data *)kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
-		if (prtd == NULL) {
-			printk("alloc aml_runtime_data error\n");
-			ret = -ENOMEM;
-			goto out;
-		}
-		prtd->substream = substream;
-		runtime->private_data = prtd;		
-	}
-	s = &prtd->s; 
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		s->device_type = AML_AUDIO_SPDIFOUT;
-#ifdef CONFIG_ARCH_MESON8
-		audio_spdifout_pg_enable(1);
-#endif
-	}	
-	else{
-		s->device_type = AML_AUDIO_SPDIFIN;
-	}	
-		
-	return 0;
-out:
-	return ret;
-}
-static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
-				struct snd_soc_dai *dai)
-{
-	ALSA_DEBUG();
-    	ALSA_TRACE();	
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;	
-		
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		memset((void*)runtime->dma_area,0,snd_pcm_lib_buffer_bytes(substream));
-#ifdef CONFIG_ARCH_MESON8
-		audio_spdifout_pg_enable(0);	
-#endif
-	}
-	
-}
-
-
-static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai)
-{
-	ALSA_DEBUG();
-    ALSA_TRACE();
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-    	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;	
-	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-		if(playback_substream_handle != (unsigned)substream)
-			playback_substream_handle = (unsigned)substream;
-		aml_hw_iec958_init((struct snd_pcm_substream *)playback_substream_handle);		
-	}	
-	else{
-		audio_in_spdif_set_buf(runtime->dma_addr, runtime->dma_bytes*2);
-		memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
-		{
-			int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
-			ppp[0] = 0x78787878;
-			ppp[1] = 0x78787878;
-		}		
-	}	
-
-	return 0;
-}
-static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
-				struct snd_pcm_hw_params *params,
-				struct snd_soc_dai *socdai)
-{
-	ALSA_DEBUG();
-    ALSA_TRACE();
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-    	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;
-	return 0;
-}
-
-
-
-#ifdef CONFIG_PM
-static int aml_dai_spdif_suspend(struct snd_soc_dai *cpu_dai)
-{
-
-	return 0;
-}
-
-static int aml_dai_spdif_resume(struct snd_soc_dai *cpu_dai)
-{
-
-
-	return 0;
-}
-#else
-#define aml_spdif_suspend NULL
-#define aml_spdif_resume NULL
-#endif
-
-static struct snd_soc_dai_ops spdif_dai_ops = {
-	.set_sysclk	= aml_dai_spdif_set_sysclk,
-	.trigger	= aml_dai_spdif_trigger,
-	.prepare = aml_dai_spdif_prepare,
-	.hw_params	= aml_dai_spdif_hw_params,
-	.shutdown	= aml_dai_spdif_shutdown,
-	.startup	= aml_dai_spdif_startup,	
-};
-
-static struct snd_soc_dai_driver aml_spdif_dai[] = {
-	{
-		.name = "aml-spdif-dai",
-		.playback = {
-			.stream_name = "S/PDIF Playback",
-			.channels_min = 1,
-			.channels_max = 8,
-			.rates = (
-					SNDRV_PCM_RATE_32000 |
-					SNDRV_PCM_RATE_44100 |
-					SNDRV_PCM_RATE_48000 |
-					SNDRV_PCM_RATE_96000),
-			.formats = SNDRV_PCM_FMTBIT_S16_LE, },
-		.capture = {
-			.stream_name = "S/PDIF Capture",
-			.channels_min = 1,
-			.channels_max = 8,
-			.rates = (SNDRV_PCM_RATE_32000 |
-					SNDRV_PCM_RATE_44100 |
-					SNDRV_PCM_RATE_48000 |
-					SNDRV_PCM_RATE_96000),
-			.formats = SNDRV_PCM_FMTBIT_S16_LE, },			
-		.ops = &spdif_dai_ops,
-		.suspend = aml_dai_spdif_suspend,
-		.resume = aml_dai_spdif_resume,
-	}	
-};
-static const struct snd_soc_component_driver aml_component= {
-	.name		= "aml-spdif-dai",
-};
-static  int aml_dai_spdif_probe(struct platform_device *pdev)
-{
-	printk("aml_spdif_probe \n");
-	return snd_soc_register_component(&pdev->dev, &aml_component,
-					 aml_spdif_dai, ARRAY_SIZE(aml_spdif_dai));}
-
-static  int aml_dai_spdif_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_component(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_spdif_dai_dt_match[]={
-	{	.compatible = "amlogic,aml-spdif-dai",
-	},
-	{},
-};
-#else
-#define amlogic_spdif_dai_dt_match NULL
-#endif
-
-static struct platform_driver aml_spdif_dai_driver = {
-	.probe	= aml_dai_spdif_probe,
-	.remove	= aml_dai_spdif_remove,
-	.driver	= {
-		.name	= "aml-spdif-dai",
-		.owner	= THIS_MODULE,
-		.of_match_table = amlogic_spdif_dai_dt_match,
-	},
-};
-
-static int __init aml_dai_spdif_init(void)
-{
-	printk("enter aml_dai_spdif_init \n");
-	return platform_driver_register(&aml_spdif_dai_driver);
-}
-module_init(aml_dai_spdif_init);
-
-static void __exit aml_dai_spdif_exit(void)
-{
-	platform_driver_unregister(&aml_spdif_dai_driver);
-}
-module_exit(aml_dai_spdif_exit);
-
-MODULE_AUTHOR("jian.xu, <jian.xu@amlogic.com>");
-MODULE_DESCRIPTION("Amlogic S/PDIF<HDMI> Controller Driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:aml-spdif");
-
-
diff --git a/sound/soc/aml/aml_spdif_dai.h b/sound/soc/aml/aml_spdif_dai.h
deleted file mode 100755
index ee5c08a5c58c..000000000000
--- a/sound/soc/aml/aml_spdif_dai.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* HDMI audio stream type ID */
-#define AOUT_EVENT_IEC_60958_PCM                0x1
-#define AOUT_EVENT_RAWDATA_AC_3                 0x2
-#define AOUT_EVENT_RAWDATA_MPEG1                0x3
-#define AOUT_EVENT_RAWDATA_MP3                  0x4
-#define AOUT_EVENT_RAWDATA_MPEG2                0x5
-#define AOUT_EVENT_RAWDATA_AAC                  0x6
-#define AOUT_EVENT_RAWDATA_DTS                  0x7
-#define AOUT_EVENT_RAWDATA_ATRAC                0x8
-#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
-#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
-#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
-#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
-#define AOUT_EVENT_RAWDATA_DST                  0xD
-#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
-
diff --git a/sound/soc/aml/aml_syno9629_codec.c b/sound/soc/aml/aml_syno9629_codec.c
deleted file mode 100644
index 88911db98db2..000000000000
--- a/sound/soc/aml/aml_syno9629_codec.c
+++ /dev/null
@@ -1,1213 +0,0 @@
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/consumer.h>
-#include <linux/spi/spi.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-
-#include <mach/am_regs.h>
-#include "aml_audio_hw.h"
-#include "aml_syno9629_codec.h"
-
-#define CODEC_DEBUG  printk
-#define stimulus_print  //printk
-#define Wr WRITE_MPEG_REG
-#define Rd  READ_MPEG_REG
-static struct snd_soc_codec *aml_syno9629_codec;
-
-static int (*is_hp_pluged)(void) = NULL;
-static void (*mute_spk)(struct snd_soc_codec* codec, int flag) = NULL;
-static void latch (void);
-static void acodec_delay_us (int us);
-
-/* codec private data */
-struct aml_syno9629_codec_priv {
-	struct snd_soc_codec codec;
-	u16 reg_cache[ADAC_MAXREG];
-	unsigned int sysclk;
-};
-
-u16 aml_syno9629_reg[ADAC_MAXREG] = {0};
-static const unsigned int linein_values[] = {
-    1|(1<<(1-1)),
-    1|(1<<(2-1)),
-    1|(1<<(3-1)),
-    1|(1<<(4-1)),
-    1|(1<<(5-1)),
-    1|(1<<(6-1)),
-    1|(1<<(7-1)),
-    1|(1<<(8-1))
-    };
-
-unsigned long aml_rate_table[] = {
-    8000, 11025, 12000, 16000, 22050, 24000, 32000, 
-    44100, 48000, 88200, 96000, 192000
-};
-static unsigned int acodec_regbank[ADAC_MAXREG] = {
-									0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg   0 -   9
-                                    0x00, 0x00, 0x08, 0x08, 0x01, 0x00, 0x00, 0xae, 0x00, 0x00, // Reg  10 -  19
-                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg  20 -  29
-                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x04, 0x04, // Reg  30 -  39
-                                    0x12, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg  40 -  49
-                                    0x00, 0x00, 0x54, 0x54, 0xff, 0xff, 0x28, 0x28, 0xff, 0xff, // Reg  50 -  59
-                                    0x28, 0x28, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg  60 -  69
-                                    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, // Reg  70 -  79
-                                    0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x01, 0x01, 0x02, // Reg  80 -  89
-                                    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, // Reg  90 -  99
-                                    0x00, 0x12, 0x12, 0x3c, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, // Reg 100 - 109
-                                    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2e, 0x2e, // Reg 110 - 119
-                                    0xff, 0xff, 0x2e, 0x2e, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg 120 - 129
-                                    0x00, 0x00, 0x04, 0x04, 0x12, 0x12, 0xff, 0xff, 0xff, 0xff, // Reg 130 - 139
-                                    0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x28, 0x28, // Reg 140 - 149
-                                    0xff, 0xff, 0x28, 0x28, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg 150 - 159
-                                    0x00, 0x00, 0x03, 0xf3, 0x00, 0x04, 0x03, 0x08, 0x00, 0x0c, // Reg 160 - 169
-                                    0x00, 0x10, 0x00, 0x14, 0x00, 0x18, 0x01, 0x1c, 0x00, 0x20, // Reg 170 - 179
-                                    0x00, 0x24, 0x00, 0x28, 0x7f, 0x2c, 0x24, 0x2c, 0x56, 0x30, // Reg 180 - 189
-                                    0x00, 0x34, 0x37, 0x38, 0x7f, 0x3c, 0x01, 0x01, 0x00, 0x00, // Reg 190 - 199
-                                    0x00, 0x06, 0x00, 0x06, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg 200 - 209
-                                    0x00, 0x00, 0x00, 0x03, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg 210 - 219
-                                    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x40, 0x01, 0x00, 0x00, // Reg 220 - 229
-                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg 230 - 239
-                                    0x02, 0x02, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x49, 0xfc, // Reg 240 - 249
-                                    0x50, 0x84, 0x00, 0x00, 0x00, 0x00 							// Reg 250 - 255
-                                   };
-
-typedef enum  {
-    AML_PWR_DOWN,
-    AML_PWR_UP,
-    AML_PWR_KEEP,
-} AML_PATH_SET_TYPE;
-
-static void set_acodec_source (unsigned int src)
-{
-    unsigned long data32;
-    unsigned int i;
-    
-    // Disable acodec clock input and its DAC input
-    data32  = 0;
-    data32 |= 0     << 4;   // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= 0     << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
-
-    // Enable acodec clock from the selected source
-    data32  = 0;
-    data32 |= 0      << 4;  // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= src   << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
-    
-    // Wait until clock change is settled
-    i = 0;
-    while ( (((Rd(AIU_CODEC_CLK_DATA_CTRL)) >> 8) & 0x3) != src ) {
-        if (i > 255) {
-            stimulus_print("[TEST.C] Error: set_acodec_source timeout!\n");
-           // stimulus_finish_fail(10);
-        }
-        i ++;
-    }
-
-    // Enable acodec DAC input from the selected source
-    data32  = 0;
-    data32 |= src   << 4;   // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= src   << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
-
-    // Wait until data change is settled
-    while ( (((Rd(AIU_CODEC_CLK_DATA_CTRL)) >> 12) & 0x3) != src) {}
-} /* set_acodec_source */
-
-static void adac_wr_reg (unsigned long addr, unsigned long data)
-{
-    WRITE_APB_REG((APB_BASE+(addr<<2)), data);
-    acodec_regbank[addr] = data;
-} /* adac_wr_reg */
-
-static unsigned long adac_rd_reg (unsigned long addr)
-{
-    unsigned long data;
-    data = READ_APB_REG((APB_BASE+(addr<<2)));
-    return (data);
-} /* adac_rd_reg */
-
-static void adac_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = adac_rd_reg(addr);
-    if ((rd_data | mask) != (exp_data | mask)) {
-        stimulus_print("[TEST.C] Error: audio CODEC register read data mismatch!\n");
-        stimulus_print("addr=0x%x ,",addr);
-        stimulus_print(" rd_data=0x%x ,",rd_data);
-        stimulus_print(" exp_data=0x%x\n",exp_data);
-    }
-} /* adac_rd_check_reg */
-
-static void acodec_startup_sequence (void)
-{
-    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- Begin\n");
-/*  
-1.	select the master clock mode mclksel[3:0] bit
-2.	start the master clock
-3.	set pdz bit to high
-4.	select the sampling rate
-5.	reset the signal path (rstdpz pin to low and back to high after 100ns)
-6.	start the individual codec blocks
-
-	7.1.1	Pop free start up recommendations
-	To obtain a pop-free start-up for the playback channel, the corresponding 
-	blocks in the desired playback signal path must also be enable when setting
-	the master power up control active, as per the start-up sequence step 3 
-	(above).
-
-	For example, when setting pdz bit to high, pddacl/rz bit, pdhsdrvl/rz bit 
-	and/or pdauxdrvl/rz bit should also be set to high at the same time to
-	obtain a clean, pop-free start up.
-	By using the latch signal properly, it is possible to guarantee that all the
-	required power control, signals are loaded to the Audio Codec IP
-	simultaneously.*/
-
-	// Init at zero (In power Down and In Reset)
-    //data32  = 0;
-    //data32 |= 1     << 15;  // [15]     audac_soft_reset_n
-    //data32 |= 1     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
-    //data32 |= 0     << 9;   // [9]      delay_rd_en
-    //data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
-    //data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
-    //data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
-    Wr(AIU_AUDAC_CTRL0, Rd(AIU_AUDAC_CTRL0) | (1<<15) | (1<<14));
-//    adac_wr_reg(0x15, 0x00);
-//    latch();
-    acodec_delay_us(3000);
-    
-    // Disable system reset (In power Down and Out of Reset)
-    Wr(AIU_AUDAC_CTRL0, Rd(AIU_AUDAC_CTRL0) & (~(1<<15)));
-    acodec_delay_us(3000);
-    
-    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- End\n");
-} /* acodec_startup_sequence */
-
-static void acodec_config (unsigned long mclkseladc,   // [3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
-                    unsigned long mclkseldac,   // [3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
-                    unsigned long i2sfsadc,     // [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
-                    unsigned long i2sfsdac,     // [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
-                    unsigned long i2smsmode,    // 0=slave mode; 1=master mode.
-                    unsigned long i2smode,      // [2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
-                    unsigned long pgamute,      // [1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
-                    unsigned long recmute,      // [1:0]: [0] Recording left channel digital mute; [1] Recording right channel digital mute. 0=un-mute; 1=mute.
-                    unsigned long hs1mute,      // [1:0]: [0] Headset left channel analog mute; [1] Headset right channel analog mute. 0=un-mute; 1=mute.
-                    unsigned long lmmute,       // [1:0]: [0] Playback left channel digital mute; [1] Playback right channel digital mute. 0=un-mute; 1=mute.
-                    unsigned long ldr1outmute,  // [1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
-                    unsigned long recvol,       // [15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0x14=0dB.
-                    unsigned long pgavol,       // [15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x04=0dB.
-                    unsigned long lmvol,        // [15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0x54=0dB.
-                    unsigned long hs1vol,       // [15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x28=0dB.
-                    unsigned long pgasel,       // [15:0]: Left PGA input selection. [7:0] Left; [15:8] Right. 0x01=Input1, 0x03=Input2, 0x05=Input3, 0x09=Input4, 0x11=Input5, 0x21=Input6, 0x41=Input7, 0x81=Input8, others=Rsrv.
-                    unsigned long ldr1sel,      // [15:0]: Playback analog mixer input selection. [7:0] Left; [15:8] Right. [0]:1=Enable left DAC output; [1]:1=Enable left PGA; [2]:1=Enable right DAC output.
-                    unsigned long ctr,          // [1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
-                    unsigned long recmix,       // [1:0]: Record digital mixer sel.
-                    unsigned long enhp,         // Record channel high pass filter enable.
-                    unsigned long lmmix)        // [1:0]: Playback digital mixer sel.
-{
-    stimulus_print("[TEST.C] audio CODEC register config -- Begin\n");
-    adac_wr_reg(ADC_MCLK_SEL, mclkseladc);
-    adac_wr_reg(DAC_MCLK_SEL, mclkseldac); //256fs
-    adac_wr_reg(ADC_I2S_FS_SEL, i2sfsadc);
-    adac_wr_reg(DAC_I2S_FS_SEL, i2sfsdac); //48k
-    adac_wr_reg(ADAC_I2S_MODE_SEL, (i2smsmode<<3) | i2smode); //slave mode ,i2s 
-    adac_wr_reg(ADAC_MUTE_CTRL0, (pgamute<<2) | recmute); //un mute
-    adac_wr_reg(ADAC_MUTE_CTRL2, (hs1mute<<4) | lmmute);  //un mute
-    adac_wr_reg(ADAC_MUTE_CTRL4, (ldr1outmute<<2));
-    adac_wr_reg(ADC_REC_MVOL_LSB_CTRL, recvol&0xff);
-    adac_wr_reg(ADC_REC_MVOL_MSB_CTRL, recvol>>8);
-    adac_wr_reg(ADC_PGA_VOL_LSB_CTRL, pgavol&0xff);
-    adac_wr_reg(ADC_PGA_VOL_MSB_CTRL, pgavol>>8);
-    adac_wr_reg(DAC_PLYBACK_MVOL_LSB_CTRL, lmvol&0xff);
-    adac_wr_reg(DAC_PLYBACK_MVOL_MSB_CTRL, lmvol>>8);
-    adac_wr_reg(DAC_HS_VOL_LSB_CTRL, hs1vol&0xff);
-    adac_wr_reg(DAC_HS_VOL_MSB_CTRL, hs1vol>>8);
-    adac_wr_reg(ADC_REC_INPUT_CH_LSB_SEL, pgasel&0xff);
-    adac_wr_reg(ADC_REC_INPUT_CH_MSB_SEL, pgasel>>8);
-    adac_wr_reg(DAC_PLYBACK_MIXER_LSB_CTRL, ldr1sel&0xff);
-    adac_wr_reg(DAC_PLYBACK_MIXER_MSB_CTRL, ldr1sel>>8);
-    adac_wr_reg(ADAC_DIGITAL_TEST_MODE_SEL, ctr);
-    adac_wr_reg(ADC_REC_PATH_MIXER_SEL, (enhp<<2) | recmix);
-    adac_wr_reg(DAC_PLYBACK_DIG_MIXER_SEL, lmmix);
-    latch();
-    stimulus_print("[TEST.C] audio CODEC register config -- End\n");
-}
-
-static void acodec_prepare_register (void)
-{
-    stimulus_print("[TEST.C] acodec_prepare_register -- Begin\n");
-    adac_wr_reg(ADAC_POWER_CTRL0, 0xfe);
-    adac_wr_reg(ADAC_POWER_CTRL1, 0xff);
-    //adac_wr_reg(0x17, 0xff);
-    adac_wr_reg(ADAC_POWER_CTRL3, 0xff);
-  //  adac_wr_reg(0x19, 0xff);
-    // Config the not power down
-   // adac_wr_reg(0x11, 0x80); // configure the bypass prechage
-
-    // Setup the lssel to 11, enable the line output
-    //adac_wr_reg(0x55, 0x01);
-    //adac_wr_reg(0x56, 0x01);
-    //latch();
-    //acodec_delay_us(4000); // wait for 4 ms.
-
-    // Set bias current to 1/40 of the nominal current
-    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x0b); 
-    latch();
-    stimulus_print("[TEST.C] acodec_prepare_register -- End\n");
-} /* acodec_prepare_register */
-
-void acodec_powerup_fastcharge (void)
-{
-    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- Begin\n");
-
-    // Disable the bypass fast charger
-    adac_wr_reg(ADAC_DIG_ASS_TEST_REG2, 0x00);
-    // test1 register, bit[2:1] to configure the charge time for VCM, when 0 100ms, when 1, 1s
-    adac_wr_reg(ADAC_DIG_ASS_TEST_REG1, 0x00);
-    // Enable the new FSM for power up, bit[7] for enable the original FSM
-    // Configure the vcmok, bit[1:0] for vcm ok configuration, when 11, 1.65v, when 01, lower
-    adac_wr_reg(ADAC_VCM_RAMP_CTRL, 0x83);
-    latch();
-    acodec_delay_us(4000); // wait for 4 ms
-
-    // reset data path
-    adac_wr_reg(ADAC_RESET, 0x00);
-    latch();
-    adac_wr_reg(ADAC_RESET, 0x03);
-    latch();
-    // Out of power Down and Out of Reset
-    adac_wr_reg(ADAC_POWER_CTRL0, 0x05);
-    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x05);
-    latch();
-
-    acodec_delay_us(1050000); // wait for 1.05 sec
-    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- End\n");
-} /* acodec_powerup_fastcharge */
-static void acodec_powerup_bypassfastcharge (void)
-{
-    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- Begin\n");
-    adac_wr_reg(ADAC_DIG_ASS_TEST_REG1, 0x00);
-    // Bypass power up sequence
-    // [0]--bypasspwrseq
-    // [1]--cfgprechanaref
-    adac_wr_reg(ADAC_DIG_ASS_TEST_REG2, 0x01);
-    // Disable soft ramping
-    adac_wr_reg(ADAC_DIG_ASS_TEST_REG4, 0x80);
-
-    // [7]--enprechanaref
-    adac_wr_reg(ADAC_ANALOG_TEST_REG3, 0x84);
-    // Enable the new FSM for power up, bit[7] for enable the original FSM
-    // Configure the vcmok, bit[1:0] for vcm ok configuration, when 11, 1.65v, when 01, lower
-    adac_wr_reg(ADAC_VCM_RAMP_CTRL, 0x83);
-
-    // Power up block and bias generator
-    latch();
-
-
-    // reset data path
-    adac_wr_reg(ADAC_RESET, 0x00);
-    latch();
-    adac_wr_reg(ADAC_RESET, 0x03);
-    latch();	
-    //acodec_delay_us(4000); // wait for 4 ms.
-    adac_wr_reg(ADAC_POWER_CTRL0, 0x0f);
-    latch();
-
-    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x05);
-    latch();
-    acodec_delay_us(5000);
-    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- End\n");
-} /* acodec_powerup_bypassfastcharge */
-
-static void latch (void)
-{
-    int latch;
-    latch = 1;
-    adac_wr_reg(ADAC_LATCH, latch);
-    adac_rd_check_reg(ADAC_LATCH, latch, 0);
-    latch = 0;
-    adac_wr_reg(ADAC_LATCH, latch);
-    adac_rd_check_reg(ADAC_LATCH, latch, 0);
-} /* latch */
-static void latch_ (struct snd_soc_codec* codec)
-{
-    int latch;
-    latch = 1;
-    snd_soc_write(codec, ADAC_LATCH, latch);
-    latch = 0;
-    snd_soc_write(codec, ADAC_LATCH, latch);
-}
-static void acodec_delay_us (int us)
-{
-	msleep(us/1000);
-} /* acodec_delay_us */
-
-static void aml_reset_path(struct snd_soc_codec* codec, AML_PATH_SET_TYPE type)
-{
-    CODEC_DEBUG( "enter %s\n", __func__);
-
-    return ;
-#if 0	
-    unsigned int pwr_reg2 = snd_soc_read(codec, ADAC_POWER_CTRL_REG2);
-    latch_(codec);
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
-    latch_(codec);
-    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2|(1<<7));
-    latch_(codec);
-     
-    if (AML_PWR_DOWN == type)
-    {
-        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
-        latch_(codec);
-    }
-    
-    if (AML_PWR_KEEP == type)
-    {
-        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2);
-        latch_(codec);
-    }
-#endif	
-}
-
-static void aml_syno9629_reset(struct snd_soc_codec* codec, bool first_time)
-{
-	unsigned long   data32;
-	int i;
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	if (first_time)
-	{
-		CODEC_DEBUG( " first time enter %s\n", __func__);
-	
-		audio_set_clk(AUDIO_CLK_FREQ_48,0);
-		set_acodec_source(2);
-		WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
-		//msleep(100);
-		data32  = 0;
-		// --------------------------------------------------------
-		// Configure audio DAC control interface
-		// --------------------------------------------------------
-		data32  = 0;
-		data32 |= 0     << 15;  // [15]     audac_soft_reset_n
-		data32 |= 1     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
-		data32 |= 0     << 9;   // [9]      delay_rd_en
-		data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
-		data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
-		data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
-		Wr(AIU_AUDAC_CTRL0, data32);
-		// Enable APB3 fail on error
-		data32  = 0;
-		data32 |= 1     << 15;  // [15]     err_en
-		data32 |= 255   << 0;   // [11:0]   max_err
-		Wr(AIU_AUDAC_CTRL1, data32);
-		// Check read back data
-		data32 = Rd(AIU_AUDAC_CTRL0);
-		if (data32 != ((1<<14) | (0x55<<1))) {
-			stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL0 read data mismatch!");
-			//stimulus_finish_fail(10);
-		}
-		data32 = Rd(AIU_AUDAC_CTRL1);
-		if (data32 != 0x80ff) {
-			stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL1 read data mismatch!");
-			//stimulus_finish_fail(10);
-		}
-
-		// Check audio CODEC default register default values
-		stimulus_print("[TEST.C] Checking audio CODEC default register default values ...\n");
-		for (i = 0; i < 252; i ++) {
-			adac_rd_check_reg(i, acodec_regbank[i], 0);
-		}
-		stimulus_print("[TEST.C] ... Done checking audio CODEC default register values\n");
-
-		// --------------------------------------
-		// Setup Audio CODEC
-		// --------------------------------------
-		stimulus_print("[TEST.C] Setup audio CODEC ...\n");
-
-		acodec_startup_sequence(); //reset rstz  ?
-
-		acodec_config(  0,      // mclkseladc[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
-		    0,      // mclkseldac[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
-		    8,     // i2sfsadc[3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
-		    8,      // i2sfsdac[3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
-		    0,      // i2smsmode: 0=slave mode; 1=master mode.
-		    1,      // i2smode[2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
-		    0,      // pgamute[1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
-		    0,      // recmute[1:0]: [0] Recording left channel digital mute; [1] Recording right channel digital mute. 0=un-mute; 1=mute.
-		    0,      // hs1mute[1:0]: [0] Headset left channel analog mute; [1] Headset right channel analog mute. 0=un-mute; 1=mute.
-		    0,      // lmmute[1:0]: [0] Playback left channel digital mute; [1] Playback right channel digital mute. 0=un-mute; 1=mute.
-		    0,      // ldr1outmute[1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
-		    0x1414, // recvol[15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0x14=0dB.
-		    0x0404, // pgavol[15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x04=0dB.
-		    0x5454, // lmvol[15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0x54=0dB.
-		    0x2828, // hs1vol[15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x28=0dB.
-		    0x0909, // pgasel[15:0]: Left PGA input selection. [7:0] Left; [15:8] Right. 0x01=Input1, 0x03=Input2, 0x05=Input3, 0x09=Input4, 0x11=Input5, 0x21=Input6, 0x41=Input7, 0x81=Input8, others=Rsrv.
-		    0x0202, // ldr1sel[15:0]: Playback analog mixer input selection. [7:0] Left; [15:8] Right. [0]:1=Enable left DAC output; [1]:1=Enable left PGA; [2]:1=Enable right DAC output.
-		    0,      // ctr[1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
-		    0,      // recmix[1:0]: Record digital mixer sel.
-		    0,      // enhp: Record channel high pass filter enable.
-		    0);     // lmmix[1:0]: Playback digital mixer sel.
-		acodec_prepare_register();
-
-		acodec_powerup_bypassfastcharge();
-		//acodec_powerup_fastcharge();	
-		// Check audio DAC register read-back values
-		stimulus_print("[TEST.C] Checking audio DAC register read-back values ...\n");
-		for (i = 0; i < 252; i ++) {
-			adac_rd_check_reg(i, acodec_regbank[i], 0);
-		}
-#if 0		
-		adac_wr_reg(0,  0); //rstadzpdz,rstdaczpdz  low
-		latch();
-		adac_wr_reg(0, 3);//rstadzpdz,rstdaczpdz  high
-		latch();
-#endif		
-		stimulus_print("[TEST.C] ... Done audio CODEC power-up bypass fast charge\n");
-	}
-	if (0)
-	{
-		CODEC_DEBUG( "  enter %s\n", __func__);	
-	//	snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
-	//	snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
-		aml_reset_path(codec, AML_PWR_UP);
-
-		latch_(codec);
-		snd_soc_write(codec, ADAC_RESET, (0<<1));
-		latch_(codec);
-		latch_(codec);
-		latch_(codec);
-		snd_soc_write(codec, ADAC_RESET, (1<<1));
-		latch_(codec);
-		latch_(codec);
-	}
-
-	//msleep(200);
-}
-
-
-static int audio_dac_set(unsigned freq)
-{
-	return 0;
-}
-
-static int post_reset(struct snd_soc_dapm_widget *w,
-	    struct snd_kcontrol *kcontrol, int event)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	struct snd_soc_codec *codec = w->codec;
-
-	if (SND_SOC_DAPM_POST_PMU == event)
-	{
-		aml_syno9629_reset(codec,false);
-	}
-	else if (SND_SOC_DAPM_POST_PMD == event && codec->active == 0)
-		aml_reset_path(codec, AML_PWR_DOWN);
-	return 0;
-}
-
-static int aml_switch_get_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-#if 0
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	struct snd_soc_dapm_widget *w;
-	//struct snd_soc_dapm_context * dapm = &codec->dapm;
-	char *lname = NULL;
-	char *rname = NULL;
-
-    switch (e->reg)
-    {
-    case ADAC_POWER_CTRL_REG1:
-        if (6 == e->shift_l)
-        {
-            lname = "LINEOUTL";
-            rname = "LINEOUTR";
-        }
-        else if (4 == e->shift_l)
-        {
-            lname = "HP_L";
-            rname = "HP_R";
-        }
-        else if (2 == e->shift_l)
-        {
-            lname = "SPEAKER";
-        }
-    break;
-    case ADAC_POWER_CTRL_REG2:
-        if (2 == e->shift_l)
-        {
-            lname = "LINEINL";
-            rname = "LINEINR";
-        }
-    break;
-    default:
-    break;
-    }
-    
-	list_for_each_entry(w, &codec->card->widgets, list) {
-        if (lname && !strcmp(lname, w->name))
-            ucontrol->value.enumerated.item[0] = w->connected;
-        if (rname && !strcmp(rname, w->name))
-            ucontrol->value.enumerated.item[0] = w->connected;
-	}
-#endif
-	return 0;
-}
-
-static int aml_switch_put_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-#if 0
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-    struct snd_soc_dapm_widget *w;
-    char *lname = NULL;
-    char *rname = NULL;
-    unsigned int pwr_reg;
-
-    switch (e->reg)
-    {
-    case ADAC_POWER_CTRL_REG1:
-        if (6 == e->shift_l)
-        {
-            lname = "LINEOUTL";
-            rname = "LINEOUTR";
-        }
-        else if (4 == e->shift_l)
-        {
-            lname = "HP_L";
-            rname = "HP_R";
-        }
-        else if (2 == e->shift_l)
-        {
-            lname = "SPEAKER";
-        }
-    break;
-    case ADAC_POWER_CTRL_REG2:
-        if (2 == e->shift_l)
-        {
-            lname = "LINEINL";
-            rname = "LINEINR";
-        }
-    break;
-    default:
-    break;
-    }
-
-    pwr_reg = snd_soc_read(codec, e->reg);
-    if(ucontrol->value.enumerated.item[0] == 0){
-    snd_soc_write(codec, e->reg, (pwr_reg&(~(0x1<<(e->shift_l)|0x1<<(e->shift_r)))));
-    }
-    else{
-    snd_soc_write(codec, e->reg, (pwr_reg|(0x1<<(e->shift_l)|0x1<<(e->shift_r))));
-    }
-
-	list_for_each_entry(w, &codec->card->widgets, list) {
-        if (lname && !strcmp(lname, w->name))
-        {
-            w->connected = ucontrol->value.enumerated.item[0];
-            CODEC_DEBUG("%s:connect=%d\n",w->name,w->connected);
-        }
-        if (rname && !strcmp(rname, w->name))
-        {
-            w->connected = ucontrol->value.enumerated.item[0];
-            CODEC_DEBUG("%s:connect=%d\n",w->name,w->connected);
-        }
-	}
-#endif
-	return 0;
-}
-
-static int aml_put_volsw_2r(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    int err = snd_soc_put_volsw_2r(kcontrol, ucontrol);
-    if (err < 0)
-        return err;
-
-    aml_reset_path(codec, AML_PWR_KEEP);
-    return 0;
-}
-
-static int aml_ai_source_get_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-    //struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 0)
-        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
-    
-    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 1) 
-        ucontrol->value.enumerated.item[0] = 0;// linein
-    else
-        ucontrol->value.enumerated.item[0] = 1;//hdmi
-        
-    return 0;
-}
-
-static int aml_ai_source_put_enum(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-    
-    if (ucontrol->value.enumerated.item[0] == 0)
-        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
-    else{
-  	 WRITE_MPEG_REG(AUDIN_SOURCE_SEL,(0  <<12)   | // [14:12]cntl_hdmirx_chsts_sel: 0=Report chan1 status; 1=Report chan2 status; ...; 
-
-                                            (0xf<<8)    | // [11:8] cntl_hdmirx_chsts_en
-
-                                            (1  <<4)    | // [5:4]  spdif_src_sel: 1=Select HDMIRX SPDIF output as AUDIN source
-
-                                            (2 << 0));    // [1:0]  i2sin_src_sel: 2=Select HDMIRX I2S output as AUDIN source
-
-    }    
-	// reset adc data path
-    snd_soc_write(codec, ADAC_RESET, 1);
-    snd_soc_write(codec, ADAC_RESET, 3);
-    
-    return 0;
-}
-
-
-
-static const DECLARE_TLV_DB_SCALE(lineout_volume, -12600, 150, 0);
-static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
-static const DECLARE_TLV_DB_SCALE(linein_volume, -9600, 150, 0);
-
-static const char *left_linein_texts[] = {
-	"Left Line In 1", "Left Line In 2", "Left Line In 3", "Left Line In 4",
-	"Left Line In 5", "Left Line In 6", "Left Line In 7", "Left Line In 8"
-	};
-
-static const char *right_linein_texts[] = {
-	"Right Line In 1", "Right Line In 2", "Right Line In 3", "Right Line In 4",
-	"Right Line In 5", "Right Line In 6", "Right Line In 7", "Right Line In 8"
-	};
-
-
-
-static const char *iis_split_texts[] = {
-	"iis_not_split", "iis_split"
-	};
-
-static const unsigned int iis_split_values[] = {
-	0,
-	1
-    };
-
-
-static const SOC_VALUE_ENUM_SINGLE_DECL(left_linein_select, ADAC_REC_CH_SEL_LSB,
-		0, 0xff, left_linein_texts, linein_values);
-static const SOC_VALUE_ENUM_SINGLE_DECL(right_linein_select, ADAC_REC_CH_SEL_MSB,
-		0, 0xff, right_linein_texts, linein_values);
-static const SOC_VALUE_ENUM_SINGLE_DECL(iis_split_select, DAC_I2S_FS_SEL,
-		3, 0xff, iis_split_texts, iis_split_values);
-
-static const char *switch_op_modes_texts[] = {
-	"OFF", "ON"
-};
-//Left/Right DAC power-down/up
-static const struct soc_enum lineout_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 0, 1,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-//left/Right headset power-down signal
-static const struct soc_enum hp_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 4, 5,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-//Left/Right PGA power-down signal
-static const struct soc_enum linein_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL1, 2,3,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-//
-static const struct soc_enum sp_op_modes_enum =
-	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 0, 1,
-			ARRAY_SIZE(switch_op_modes_texts),
-			switch_op_modes_texts);
-
-static const char *audio_in_source_texts[] = {
-	"LINEIN", "HDMI"
-};
-static const struct soc_enum audio_in_source_enum =
-	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
-			ARRAY_SIZE(audio_in_source_texts),
-			audio_in_source_texts);
-
-
-static const struct snd_kcontrol_new amlsyno9629_snd_controls[] = {
-	SOC_DOUBLE_R_EXT_TLV("LINEOUT Playback Volume", DAC_PLYBACK_MVOL_LSB_CTRL, DAC_PLYBACK_MVOL_MSB_CTRL,
-	       0, 84, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, lineout_volume),
-	      
-	 SOC_DOUBLE_R_EXT_TLV("HeadSet Playback Volume", DAC_HS_VOL_LSB_CTRL, DAC_HS_VOL_MSB_CTRL,
-	       0, 46, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, hs_volume),
-
-    SOC_DOUBLE_R_EXT_TLV("LINEIN Capture Volume", ADC_REC_MVOL_LSB_CTRL, ADC_REC_MVOL_MSB_CTRL,
-	       0, 84, 1, snd_soc_get_volsw_2r, aml_put_volsw_2r, linein_volume),
-
-	SOC_VALUE_ENUM("Left LINEIN Select",left_linein_select),
-	SOC_VALUE_ENUM("Right LINEIN Select",right_linein_select),
-	SOC_VALUE_ENUM("IIS Split Select", iis_split_select),
-
-    SOC_ENUM_EXT("LOUT Playback Switch", lineout_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-		
-    SOC_ENUM_EXT("HP Playback Switch", hp_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-		
-	SOC_ENUM_EXT("LIN Capture Switch", linein_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-		
-	SOC_ENUM_EXT("SP Playback Switch", sp_op_modes_enum,
-		aml_switch_get_enum,aml_switch_put_enum),
-
-    SOC_ENUM_EXT("Audio In Source", audio_in_source_enum,
-        aml_ai_source_get_enum,aml_ai_source_put_enum),
-
-};
-#if 0
-static const struct snd_kcontrol_new lineoutl_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 0, 1, 1);
-static const struct snd_kcontrol_new lineoutr_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 1, 1, 1);
-static const struct snd_kcontrol_new hsl_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 6, 1, 1);
-static const struct snd_kcontrol_new hsr_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 7, 1, 1);
-static const struct snd_kcontrol_new spk_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 2, 1, 1);
-
-static const struct snd_kcontrol_new lineinl_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 4, 1, 1);
-static const struct snd_kcontrol_new lineinr_switch_controls =
-	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 5, 1, 1);
-
-static const struct snd_soc_dapm_widget aml_syno9629_dapm_widgets[] = {
-	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
-	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
-	SND_SOC_DAPM_OUTPUT("HP_L"),
-	SND_SOC_DAPM_OUTPUT("HP_R"),
-	SND_SOC_DAPM_OUTPUT("SPEAKER"),
-
-	SND_SOC_DAPM_INPUT("LINEINL"),
-	SND_SOC_DAPM_INPUT("LINEINR"),
-	
-	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
-	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
-	SND_SOC_DAPM_ADC("ADCL", "Left ADC Capture", ADAC_POWER_CTRL_REG2, 0, 0),
-	SND_SOC_DAPM_ADC("ADCR", "Right ADC Capture", ADAC_POWER_CTRL_REG2, 1, 0),
-
-	SND_SOC_DAPM_SWITCH("LINEOUTL Switch", ADAC_POWER_CTRL_REG1, 6, 0,
-			    &lineoutl_switch_controls),
-	SND_SOC_DAPM_SWITCH("LINEOUTR Switch", ADAC_POWER_CTRL_REG1, 7, 0,
-			    &lineoutr_switch_controls),
-	SND_SOC_DAPM_SWITCH("HP_L Switch", ADAC_POWER_CTRL_REG1, 4, 0,
-			    &hsl_switch_controls),
-	SND_SOC_DAPM_SWITCH("HP_R Switch", ADAC_POWER_CTRL_REG1, 5, 0,
-			    &hsr_switch_controls),
-	SND_SOC_DAPM_SWITCH("SPEAKER Switch", ADAC_POWER_CTRL_REG1, 2, 0,
-			    &spk_switch_controls),
-
-	SND_SOC_DAPM_SWITCH("LINEINL Switch", ADAC_POWER_CTRL_REG2, 2, 0,
-			    &lineinl_switch_controls),
-	SND_SOC_DAPM_SWITCH("LINEINR Switch", ADAC_POWER_CTRL_REG2, 3, 0,
-			    &lineinr_switch_controls),
-
-       SND_SOC_DAPM_POST("RESET", post_reset),
-	
-	//SND_SOC_DAPM_PGA("HSL", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
-	//SND_SOC_DAPM_PGA("HSR", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
-	
-	//SND_SOC_DAPM_PGA("PDZ", ADAC_POWER_CTRL_REG2, 7, 0, NULL, 0),
-	SND_SOC_DAPM_MICBIAS("MICBIAS", ADAC_POWER_CTRL_REG2, 5, 0)
-};
-
-/* Target, Path, Source */
-
-static const struct snd_soc_dapm_route aml_syno9629_audio_map[] = {
-	{"LINEOUTL", NULL, "LINEOUTL Switch"},
-	{"LINEOUTL Switch", NULL, "DACL"},
-	{"LINEOUTR", NULL, "LINEOUTR Switch"},
-	{"LINEOUTR Switch", NULL, "DACR"},
-	
-	{"HP_L", NULL, "HP_L Switch"},
-	{"HP_L Switch", NULL, "DACL"},
-	{"HP_R", NULL, "HP_R Switch"},
-	{"HP_R Switch", NULL, "DACR"},
-
-	{"SPEAKER", NULL, "SPEAKER Switch"},
-	{"SPEAKER Switch", NULL, "DACL"},
-	{"SPEAKER Switch", NULL, "DACR"},
-
-       {"ADCL", NULL, "LINEINL Switch"},
-       {"LINEINL Switch", NULL, "LINEINL"},
-	{"ADCR", NULL, "LINEINR Switch"},
-	{"LINEINR Switch", NULL, "LINEINR"},
-};
-#endif
-static int aml_syno9629_write(struct snd_soc_codec *codec, unsigned int reg,
-							unsigned int value)
-{
-       u16 *reg_cache = codec->reg_cache;
-	CODEC_DEBUG("***Entered %s:%s:\nWriting reg is %#x; value=%#x\n",__FILE__,__func__, reg, value);
-	if (reg >= codec->reg_size/sizeof(u16))
-		return -EINVAL;
-	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
-	reg_cache[reg] = value;
-	latch();
-
-      CODEC_DEBUG("Read back reg is %#x value=%#x\n", reg, READ_APB_REG(APB_BASE+(reg<<2)));
-
-	return 0;
-}
-
-static unsigned int aml_syno9629_read(struct snd_soc_codec *codec,
-							unsigned int reg)
-{
-	//u16 *reg_cache = codec->reg_cache;
-	if (reg >= codec->reg_size/sizeof(u16))
-		return -EINVAL;
-	
-	return READ_APB_REG(APB_BASE+(reg<<2));
-	//return reg_cache[reg];
-}
-
-static int aml_syno9629_codec_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	struct snd_soc_codec *codec = dai->codec;
-	unsigned int i2sfs;
-	unsigned long rate = params_rate(params);
-	int rate_idx = 0;
-
-	for (rate_idx = 0; rate_idx < ARRAY_SIZE(aml_rate_table); rate_idx++){
-		if (aml_rate_table[rate_idx] == rate)
-			break;
-	}	
-	if (ARRAY_SIZE(aml_rate_table) == rate_idx){
-		printk(" sample rate not supported by codec \n");
-		rate_idx = 0x8; //48k
-	}	
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_write(codec, DAC_I2S_FS_SEL, rate_idx);
-	else
-		snd_soc_write(codec, ADC_I2S_FS_SEL, rate_idx);
-//	aml_reset_path(codec, AML_PWR_KEEP);
-	return 0;
-}
-
-
-static int aml_syno9629_codec_pcm_prepare(struct snd_pcm_substream *substream,
-			      struct snd_soc_dai *dai)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	//struct snd_soc_codec *codec = dai->codec;
-	/* set active */
-	
-	// TODO
-
-	return 0;
-}
-
-static void aml_syno9629_codec_shutdown(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	struct snd_soc_codec *codec = dai->codec;
-	/* deactivate */
-	if (!codec->active) {
-		udelay(50);
-		
-		// TODO
-	}
-}
-
-static int aml_syno9629_codec_mute(struct snd_soc_dai *dai, int mute)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	struct snd_soc_codec *codec = dai->codec;
-	u16 reg;
-	// TODO
-
-	reg = snd_soc_read(codec, ADAC_MUTE_CTRL4);
-	if(mute){
-		reg |= 3<<2;
-	}
-	else{
-		reg &= ~(3<<2);
-	}
-	CODEC_DEBUG("aml_syno9629_codec_mute mute=%d\n",mute);
-	snd_soc_write(codec, ADAC_MUTE_CTRL4, reg);
-	return 0;
-}
-
-static int aml_syno9629_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
-		int clk_id, unsigned int freq, int dir)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	//struct snd_soc_codec *codec = codec_dai->codec;
-	unsigned long data = 0;
-	
-	switch (freq) {
-	case 32000:
-		data = 6;
-		break;
-	case 44100:
-		data = 7;
-		break;
-	case 48000:
-		data = 8;
-		break;
-	case 96000:
-		data = 10;
-		break;
-	default:
-		data = 6;
-		break;
-	}
-	//snd_soc_write(codec,ADAC_CLOCK, 0);
-	//snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, data);
-	return 0;
-}
-
-
-static int aml_syno9629_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
-		unsigned int fmt)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	//struct snd_soc_codec *codec = codec_dai->codec;
-	u16 iface = 0;
-	/* set master/slave audio interface */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		iface |= 0x0040;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* interface format */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		iface |= 0x0002;
-		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		iface |= 0x0001;
-		break;
-	case SND_SOC_DAIFMT_DSP_A:
-		iface |= 0x0003;
-		break;
-	case SND_SOC_DAIFMT_DSP_B:
-		iface |= 0x0013;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* clock inversion */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		iface |= 0x0090;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		iface |= 0x0080;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		iface |= 0x0010;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* set iface */
-	
-	// TODO
-	
-	return 0;
-}
-
-#define AML_RATES SNDRV_PCM_RATE_8000_96000
-
-#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
-	SNDRV_PCM_FMTBIT_S24_LE)
-
-
-static struct snd_soc_dai_ops aml_syno9629_codec_dai_ops = {
-	.prepare	= aml_syno9629_codec_pcm_prepare,
-	.hw_params	= aml_syno9629_codec_hw_params,
-	.shutdown	= aml_syno9629_codec_shutdown,
-	.digital_mute	= aml_syno9629_codec_mute,
-	.set_sysclk	= aml_syno9629_codec_set_dai_sysclk,
-	.set_fmt	= aml_syno9629_codec_set_dai_fmt,
-};
-
-struct snd_soc_dai_driver aml_syno9629_codec_dai = {
-	.name = "syno9629-hifi",
-	.playback = {
-		.stream_name = "Playback",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = AML_RATES,
-		.formats = AML_FORMATS,},
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = AML_RATES,
-		.formats = AML_FORMATS,},
-	.ops = &aml_syno9629_codec_dai_ops,
-	.symmetric_rates = 1,
-};
-EXPORT_SYMBOL_GPL(aml_syno9629_codec_dai);
-
-static int aml_syno9629_set_bias_level(struct snd_soc_codec *codec,
-				 enum snd_soc_bias_level level)
-{
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		break;
-	case SND_SOC_BIAS_PREPARE:
-		break;
-	case SND_SOC_BIAS_STANDBY:
-		break;
-	case SND_SOC_BIAS_OFF:
-	    break;
-	default:
-	    break;
-	}
-	codec->dapm.bias_level = level;
-	return 0;
-}
-
-static int aml_syno9629_soc_probe(struct snd_soc_codec *codec){
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	CODEC_DEBUG( "enter %s\n", __func__);	
-	aml_syno9629_reset(codec, true);
-	aml_syno9629_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-	
-	snd_soc_add_controls(codec, amlsyno9629_snd_controls,
-				ARRAY_SIZE(amlsyno9629_snd_controls));
-#if 0	
-	snd_soc_dapm_new_controls(dapm, aml_syno9629_dapm_widgets,
-				  ARRAY_SIZE(aml_syno9629_dapm_widgets));
-
-	snd_soc_dapm_add_routes(dapm, aml_syno9629_audio_map, ARRAY_SIZE(aml_syno9629_audio_map));
-#endif	
-      aml_syno9629_codec = codec;                
-    return 0;
-}
-static int aml_syno9629_soc_remove(struct snd_soc_codec *codec){
-	return 0;
-}
-static int aml_syno9629_soc_suspend(struct snd_soc_codec *codec,	pm_message_t state){
-	CODEC_DEBUG( "enter %s\n", __func__);
-	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)&~(1 << 2));
-	aml_reset_path(codec, AML_PWR_DOWN);	
-	return 0;
-}
-
-static int aml_syno9629_soc_resume(struct snd_soc_codec *codec){
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)|(1 << 2));
-	aml_syno9629_reset(codec, true);	
-	return 0;
-}
-
-static struct snd_soc_codec_driver soc_codec_dev_syno9629 = {
-	.probe = 	aml_syno9629_soc_probe,
-	.remove = 	aml_syno9629_soc_remove,
-	.suspend =	aml_syno9629_soc_suspend,
-	.resume = 	aml_syno9629_soc_resume,
-	.read = aml_syno9629_read,
-	.write = aml_syno9629_write,
-	.set_bias_level = aml_syno9629_set_bias_level,
-	.reg_cache_size = ARRAY_SIZE(aml_syno9629_reg),
-	.reg_word_size = sizeof(u16),
-	.reg_cache_step = 1,
-	.reg_cache_default = aml_syno9629_reg,
-	.dapm_widgets = 0,//aml_syno9629_dapm_widgets,
-	.num_dapm_widgets = 0,//ARRAY_SIZE(aml_syno9629_dapm_widgets),
-	.dapm_routes =  0,//aml_syno9629_audio_map,
-	.num_dapm_routes = 0,//ARRAY_SIZE(aml_syno9629_audio_map),
-};
-
-static int aml_syno9629_codec_platform_probe(struct platform_device *pdev)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-	return snd_soc_register_codec(&pdev->dev, 
-		&soc_codec_dev_syno9629, &aml_syno9629_codec_dai, 1);
-}
-
-static int __exit aml_syno9629_codec_platform_remove(struct platform_device *pdev)
-{	
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-
-static struct platform_driver aml_syno9629_codec_platform_driver = {
-	.driver = {
-		.name = "syno9629",
-		.owner = THIS_MODULE,
-		},
-	.probe = aml_syno9629_codec_platform_probe,
-	.remove = __exit_p(aml_syno9629_codec_platform_remove),
-};
-
-static int __init aml_syno9629_codec_modinit(void)
-{
-	CODEC_DEBUG( "enter %s\n", __func__);
-
-	return platform_driver_register(&aml_syno9629_codec_platform_driver);
-}
-
-static void __exit aml_syno9629_codec_exit(void)
-{
-		platform_driver_unregister(&aml_syno9629_codec_platform_driver);
-}
-
-module_init(aml_syno9629_codec_modinit);
-module_exit(aml_syno9629_codec_exit);
-
-
-MODULE_DESCRIPTION("ASoC AML synopsys 9629  codec driver");
-MODULE_AUTHOR("jian.xu@amlogic.com AMLogic Inc.");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/aml_syno9629_codec.h b/sound/soc/aml/aml_syno9629_codec.h
deleted file mode 100644
index b3e9940a2487..000000000000
--- a/sound/soc/aml/aml_syno9629_codec.h
+++ /dev/null
@@ -1,215 +0,0 @@
-#ifndef _AML_SYNO9629_CODEC_H
-#define _AML_SYNO9629_CODEC_H
-
-#define APB_BASE					0x4000
-
-// data path reset register. bit 0 rstdacdpz,bit 1  rstadcdpz  
-// when i2s reconfiguration, reset data path recommanded
-#define ADAC_RESET                		0x00
-//bit 0 latch
-#define ADAC_LATCH                		0x01
-/* 
-[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 
-		8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
-*/
-#define ADC_MCLK_SEL                		0x02
-#define DAC_MCLK_SEL                		0x03
-//
-// [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
-#define ADC_I2S_FS_SEL      				0x0c
-#define DAC_I2S_FS_SEL      				0x0d
-/*
-i2smode[2:0]:default:1h
-Data format select:
-000: Right justified
-001: I2S justified
-010: Left justified
-011: Burst 1 format
-100: Burst 2 format
-101: Mono Burst 1 format
-110: Mono Burst 2 format
-111: Reserved
-i2smsmode[3] default:0
-I2S slave/master:
-0: slave mode
-1: master mode
-*/
-#define ADAC_I2S_MODE_SEL   			0x0e
-
-/*
-acodec standby/sleep control. [0] ensleep .default:0xAEh
-*/
-#define ADAC_STAND_SLEEP_CTRL      		0x11
-/*
-Power consumption management;cfgiref[3:0] default:0
-*/
-#define ADAC_POWER_CUM_CTRL     		0x12
-/*
-[0] pdz Overall power-down signal
-[2] pdmbias1z Microphone Bias 1 power-down signal
-*/
-#define ADAC_POWER_CTRL0				0x15
-/*
-[0] pdadclz Left ADC power-down signal
-[1] pdadcrz Right ADC power-down signal
-[2]pdpgalz Left PGA power-down signal
-[3] pdpgarz Right PGA power-down signal
-*/
-#define ADAC_POWER_CTRL1				0x16
-/*
-R24 (18h) 0 pddaclz Left DAC power-down signal 0h
-R24 (18h) 1 pddacrz Right DAC power-down signal 0h
-R24 (18h) 4 pdhs1rz Right headset power-down signal 0h
-R24 (18h) 5 pdhs1lz Left headset power-down signal 0h
-R24 (18h) 6 pdldr1rz Right single-end line driver 1 power-down signal 0h
-R24 (18h) 7 pdldr1lz Left single-end line driver 1 power-down signal
-*/
-#define ADAC_POWER_CTRL3				0x18
-
-/*
-R29 (1Dh)
-[0]
-recmute[0]
-Recording left channel digital mute:
-0: un-mute
-1: mute
-0h
-R29 (1Dh)
-[1]
-recmute[1]
-Recording right channel digital mute:
-0: un-mute
-1: mute
-*/
-#define ADAC_MUTE_CTRL0       		        0x1d
-/*
-R31 (1Fh)
-[4]
-hs1mute[0]
-Headset left channel analog mute:
-0: un-mute
-1: mute
-0h
-R31 (1Fh)
-[5]
-hs1mute[1]
-Headset right channel analog mute:
-0: un-mute
-1: mute
-*/
-#define ADAC_MUTE_CTRL2			        0x1f
-/*
-R33 (21h)
-[2]
-ldr1outmute[0]
-Playback left channel analog mute:
-0: un-mute
-1: mute
-0h
-R33 (21h)
-[3]
-ldr1outmute[1]
-Playback right channel analog mute:
-0: un-mute
-1: mute
-*/
-#define ADAC_MUTE_CTRL4        		        0x21
-/*
-Recording digital master volume control:
-The least significant 8 bits control the left channel:
-00000000: 30dB
-00000001 to 0010011: 28.5dB to 1.5dB
-00010100: 0dB
-00010101 to 1010011: -1.5dB to C94.5dB
-01010100: -96dB
-01010101 to 01111111: Reserved
-The most significant 8 bits control the right channel:
-00000000: 30dB
-00000001 to 0010011: 28.5dB to 1.5dB
-00010100: 0dB
-00010101 to 1010011: -1.5dB to C94.5dB
-01010100: -96dB
-01010101 to 1111111: Reserved
-*/
-#define ADC_REC_MVOL_LSB_CTRL  		0x24
-#define ADC_REC_MVOL_MSB_CTRL  		0x25
-/*
-Input PGA volume control:
-The least significant 8 bits control the left channel:
-00000000: -6 dB
-00000001: -4.5 dB
-K: K
-00000100: 0 dB
-K: K
-00010001: 19.5 dB
-00010010: 21 dB
-d00010011: Reserved
-The most significant 8 bits control the right channel:
-00000000: -6 dB
-00000001: -4.5 dB
-K: K
-00000100: 0 dB
-K: K
-00010001: 19.5 dB
-00010010: 21 dB
-d00010011: Reserved
-*/
-#define ADC_PGA_VOL_LSB_CTRL  			0x26
-#define ADC_PGA_VOL_MSB_CTRL  		0x27
-
-#define DAC_PLYBACK_MVOL_LSB_CTRL  	0x34
-#define DAC_PLYBACK_MVOL_MSB_CTRL  	0x35
-#define DAC_HS_VOL_LSB_CTRL  			0x38
-#define DAC_HS_VOL_MSB_CTRL  			0x39
-#define ADC_REC_INPUT_CH_LSB_SEL			0x47
-#define ADC_REC_INPUT_CH_MSB_SEL			0x48
-#define DAC_PLYBACK_MIXER_LSB_CTRL		0x59
-#define DAC_PLYBACK_MIXER_MSB_CTRL		0x5a
-
-#define ADAC_REC_CH_SEL_LSB			0x47
-#define ADAC_REC_CH_SEL_MSB			0x48
-#define ADAC_DIGITAL_TEST_MODE_SEL 	0xd2
-#define ADC_REC_PATH_MIXER_SEL 		0xd3 
-#define DAC_PLYBACK_DIG_MIXER_SEL 	0xd4
-/*
-VCM ramp up settle register
-*/
- #define ADAC_VCM_RAMP_CTRL      		0xa2
-/*
-VCM pre-charge time control definition
-*/
-#define ADAC_DIG_ASS_TEST_REG1      				0xf0
-/*
-Digital-assisted analog test reg. Bypass power up/down sequences
-*/
-#define ADAC_DIG_ASS_TEST_REG2  	     				0xf1
-#define ADAC_DIG_ASS_TEST_REG3  	     				0xf2
-
-
-/*
-Digital-assisted analog test reg. 4
-*/
-#define ADAC_DIG_ASS_TEST_REG4  					0xf3
-#define ADAC_DIG_ASS_TEST_REG5  					0xf3
-/*
-Pure analog test reg. 3
-*/
-#define ADAC_ANALOG_TEST_REG3 					0xfb
-
-#define ADAC_VCM_REG1		0x80
-#define ADAC_VCM_REG2		0x81
-
-#define ADAC_TEST_REG1	0xe0
-#define ADAC_TEST_REG2	0xe1
-#define ADAC_TEST_REG3	0xe2
-#define ADAC_TEST_REG4	0xe3
-
-#define ADAC_MAXREG	256
-
-#define NO_CLOCK_TO_CODEC   0
-#define PCMOUT_TO_DAC           1
-#define AIU_I2SOUT_TO_DAC    2
-
-
-
-#endif
diff --git a/sound/soc/codecs/rt5631.c b/sound/soc/codecs/rt5631.c
index 912c9cbc2724..9a75b305d7e4 100644
--- a/sound/soc/codecs/rt5631.c
+++ b/sound/soc/codecs/rt5631.c
@@ -26,6 +26,9 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 #include <sound/tlv.h>
+#include <linux/amlogic/aml_audio_codec_probe.h>
+
+
 
 #include "rt5631.h"
 
@@ -40,16 +43,23 @@ struct rt5631_priv {
 };
 
 static const struct reg_default rt5631_reg[] = {
+    { RT5631_RESET, 0x0001 },
 	{ RT5631_SPK_OUT_VOL, 0x8888 },
 	{ RT5631_HP_OUT_VOL, 0x8080 },
 	{ RT5631_MONO_AXO_1_2_VOL, 0xa080 },
 	{ RT5631_AUX_IN_VOL, 0x0808 },
+    { RT5631_STEREO_DAC_VOL_1,0x0000 },
+    { RT5631_MIC_CTRL_1, 0x0000 },
+    { RT5631_STEREO_DAC_VOL_2, 0x0000 },
+    { RT5631_ADC_CTRL_1,0x0000 },
 	{ RT5631_ADC_REC_MIXER, 0xf0f0 },
+    { RT5631_ADC_CTRL_2, 0x0000 },
 	{ RT5631_VDAC_DIG_VOL, 0x0010 },
 	{ RT5631_OUTMIXER_L_CTRL, 0xffc0 },
 	{ RT5631_OUTMIXER_R_CTRL, 0xffc0 },
 	{ RT5631_AXO1MIXER_CTRL, 0x88c0 },
 	{ RT5631_AXO2MIXER_CTRL, 0x88c0 },
+    { RT5631_MIC_CTRL_2, 0x0000 },
 	{ RT5631_DIG_MIC_CTRL, 0x3000 },
 	{ RT5631_MONO_INPUT_VOL, 0x8808 },
 	{ RT5631_SPK_MIXER_CTRL, 0xf8f8 },
@@ -58,16 +68,31 @@ static const struct reg_default rt5631_reg[] = {
 	{ RT5631_SDP_CTRL, 0x8000 },
 	{ RT5631_MONO_SDP_CTRL, 0x8000 },
 	{ RT5631_STEREO_AD_DA_CLK_CTRL, 0x2010 },
+    { RT5631_PWR_MANAG_ADD1, 0x0000 },
+    { RT5631_PWR_MANAG_ADD2, 0x0000 },
+    { RT5631_PWR_MANAG_ADD3, 0x0000 },
+    { RT5631_PWR_MANAG_ADD4, 0x0000 },
 	{ RT5631_GEN_PUR_CTRL_REG, 0x0e00 },
+    { RT5631_GLOBAL_CLK_CTRL, 0x0000 },
+    { RT5631_PLL_CTRL, 0x0000 },
+    { RT5631_INT_ST_IRQ_CTRL_1, 0x0000},
 	{ RT5631_INT_ST_IRQ_CTRL_2, 0x071a },
 	{ RT5631_MISC_CTRL, 0x2040 },
+    { RT5631_DEPOP_FUN_CTRL_1, 0x0000 },
 	{ RT5631_DEPOP_FUN_CTRL_2, 0x8000 },
+    { RT5631_JACK_DET_CTRL, 0x0000 },
 	{ RT5631_SOFT_VOL_CTRL, 0x07e0 },
 	{ RT5631_ALC_CTRL_1, 0x0206 },
+    { RT5631_ALC_CTRL_2, 0x0000 },
 	{ RT5631_ALC_CTRL_3, 0x2000 },
 	{ RT5631_PSEUDO_SPATL_CTRL, 0x0553 },
+    { RT5631_INDEX_ADD, 0x0000 },
+    { RT5631_INDEX_DATA, 0x0000 },
 };
 
+struct snd_soc_codec *rt5631_codec = NULL;
+
+
 /**
  * rt5631_write_index - write index register of 2nd layer
  */
@@ -170,6 +195,66 @@ static bool rt5631_readable_register(struct device *dev, unsigned int reg)
 	}
 }
 
+/**
+ * rt5631_headset_detect - Detect headset.
+ * @codec: SoC audio codec device.
+ * @jack_insert: Jack insert or not.
+ *
+ * Detect whether is headset or not when jack inserted.
+ *
+ * Returns detect status.
+ */
+int rt5631_headset_detect(struct snd_soc_codec *codec, int jack_insert)
+{
+    int jack_type;
+
+    if(jack_insert) {
+        //snd_soc_update_bits(codec, RT5631_SPK_OUT_VOL,
+        //    RT5631_L_MUTE | RT5631_R_MUTE,
+        //    RT5631_L_MUTE | RT5631_R_MUTE);
+
+        snd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD2,
+            RT5631_PWR_MICBIAS1_VOL, RT5631_PWR_MICBIAS1_VOL);
+        snd_soc_update_bits(codec, RT5631_MIC_CTRL_2,
+            RT5631_MICBIAS1_S_C_DET_MASK |
+            RT5631_MICBIAS1_SHORT_CURR_DET_MASK,
+            RT5631_MICBIAS1_S_C_DET_ENA |
+            RT5631_MICBIAS1_SHORT_CURR_DET_600UA);
+        msleep(50);
+        if (rt5631_read_index(codec, 0x4a) & 0x2)
+            jack_type = RT5631_HEADPHO_DET;
+        else
+            jack_type = RT5631_HEADSET_DET;
+
+#if EQ_FUNC
+        rt5631_hw_eq(codec, HFREQ);
+#endif
+
+      /*  snd_soc_update_bits(codec, RT5631_HP_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE,
+            0);*/
+    } else {
+     /*   snd_soc_update_bits(codec, RT5631_HP_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE,
+            RT5631_L_MUTE | RT5631_R_MUTE);
+
+        snd_soc_update_bits(codec, RT5631_MIC_CTRL_2,
+            RT5631_MICBIAS1_S_C_DET_MASK,
+            RT5631_MICBIAS1_S_C_DET_DIS);   */
+        jack_type = RT5631_NO_JACK;
+
+#if EQ_FUNC
+        rt5631_hw_eq(codec, SPK_FR);
+#endif
+
+     /*   snd_soc_update_bits(codec, RT5631_SPK_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE,
+            0); */
+    }
+
+    return jack_type;
+}
+EXPORT_SYMBOL(rt5631_headset_detect);
 static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -4650, 150, 0);
 static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -95625, 375, 0);
 static const DECLARE_TLV_DB_SCALE(in_vol_tlv, -3450, 150, 0);
@@ -1357,6 +1442,30 @@ static int get_coeff(int mclk, int rate, int timesofbclk)
 	return -EINVAL;
 }
 
+#if 1
+static int rt5631_codec_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	if(mute){
+        snd_soc_update_bits(codec, RT5631_SPK_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE,
+            RT5631_L_MUTE | RT5631_R_MUTE);
+        snd_soc_update_bits(codec, RT5631_HP_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE,
+            RT5631_L_MUTE | RT5631_R_MUTE);
+		msleep(50);
+	}else{
+		msleep(50);
+        snd_soc_update_bits(codec, RT5631_SPK_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE, 0);
+        snd_soc_update_bits(codec, RT5631_HP_OUT_VOL,
+            RT5631_L_MUTE | RT5631_R_MUTE, 0);
+	}
+	return 0;
+}
+
+#endif
+
 static int rt5631_hifi_pcm_params(struct snd_pcm_substream *substream,
 		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
 {
@@ -1589,6 +1698,8 @@ static int rt5631_probe(struct snd_soc_codec *codec)
 
 	codec->control_data = rt5631->regmap;
 
+    rt5631_codec = codec;
+
 	ret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);
 	if (ret != 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
@@ -1643,15 +1754,26 @@ static int rt5631_remove(struct snd_soc_codec *codec)
 }
 
 #ifdef CONFIG_PM
-static int rt5631_suspend(struct snd_soc_codec *codec)
+
+static int rt5631_suspend(struct device *dev)
 {
-	rt5631_set_bias_level(codec, SND_SOC_BIAS_OFF);
+    if(!is_rt5631)
+        return 0;
+    struct rt5631_priv *rt5631 = dev_get_drvdata(dev);
+    
+	rt5631_set_bias_level(rt5631_codec, SND_SOC_BIAS_OFF);
+    regcache_mark_dirty(rt5631->regmap);
 	return 0;
 }
 
-static int rt5631_resume(struct snd_soc_codec *codec)
+static int rt5631_resume(struct device *dev)
 {
-	rt5631_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+    if(!is_rt5631)
+        return 0;
+    struct rt5631_priv *rt5631 = dev_get_drvdata(dev);
+    regcache_sync(rt5631->regmap);
+    
+	rt5631_set_bias_level(rt5631_codec, SND_SOC_BIAS_STANDBY);
 	return 0;
 }
 #else
@@ -1670,6 +1792,7 @@ static const struct snd_soc_dai_ops rt5631_ops = {
 	.set_fmt = rt5631_hifi_codec_set_dai_fmt,
 	.set_sysclk = rt5631_hifi_codec_set_dai_sysclk,
 	.set_pll = rt5631_codec_set_dai_pll,
+	.digital_mute = rt5631_codec_digital_mute,
 };
 
 static struct snd_soc_dai_driver rt5631_dai[] = {
@@ -1697,8 +1820,8 @@ static struct snd_soc_dai_driver rt5631_dai[] = {
 static struct snd_soc_codec_driver soc_codec_dev_rt5631 = {
 	.probe = rt5631_probe,
 	.remove = rt5631_remove,
-	.suspend = rt5631_suspend,
-	.resume = rt5631_resume,
+	//.suspend = rt5631_suspend,
+	//.resume = rt5631_resume,
 	.set_bias_level = rt5631_set_bias_level,
 	.controls = rt5631_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5631_snd_controls),
@@ -1708,6 +1831,12 @@ static struct snd_soc_codec_driver soc_codec_dev_rt5631 = {
 	.num_dapm_routes = ARRAY_SIZE(rt5631_dapm_routes),
 };
 
+static struct dev_pm_ops rt5631_pm = {
+	.suspend_late = rt5631_suspend,
+    .resume_early = rt5631_resume,
+};
+
+
 static const struct i2c_device_id rt5631_i2c_id[] = {
 	{ "rt5631", 0 },
 	{ }
@@ -1758,6 +1887,7 @@ static struct i2c_driver rt5631_i2c_driver = {
 	.driver = {
 		.name = "rt5631",
 		.owner = THIS_MODULE,
+		.pm = &rt5631_pm,
 	},
 	.probe = rt5631_i2c_probe,
 	.remove   = rt5631_i2c_remove,
diff --git a/sound/soc/codecs/rt5631.h b/sound/soc/codecs/rt5631.h
index 13401581b0df..f1845d240192 100644
--- a/sound/soc/codecs/rt5631.h
+++ b/sound/soc/codecs/rt5631.h
@@ -698,4 +698,8 @@
 #define RT5631_EN_HW_EQ_LPF				(0x1 << 0)
 
 
+#define RT5631_NO_JACK		BIT(0)
+#define RT5631_HEADSET_DET	BIT(1)
+#define RT5631_HEADPHO_DET	BIT(2)
+int rt5631_headset_detect(struct snd_soc_codec *codec, int jack_insert);
 #endif /* __RTCODEC5631_H__ */
diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c
index 0a4ffdd1d2a7..e04cc54dffcc 100644
--- a/sound/soc/codecs/wm8960.c
+++ b/sound/soc/codecs/wm8960.c
@@ -1,8 +1,6 @@
 /*
  * wm8960.c  --  WM8960 ALSA SoC Audio driver
  *
- * Copyright 2007-11 Wolfson Microelectronics, plc
- *
  * Author: Liam Girdwood
  *
  * This program is free software; you can redistribute it and/or modify
@@ -16,6 +14,7 @@
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/i2c.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -24,17 +23,22 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <sound/wm8960.h>
+#include <linux/amlogic/aml_audio_codec_probe.h>
+
+
 
 #include "wm8960.h"
 
+#define AUDIO_NAME "wm8960"
+#define WM8960_CAPLESS_MODE
 /* R25 - Power 1 */
 #define WM8960_VMID_MASK 0x180
 #define WM8960_VREF      0x40
 
 /* R26 - Power 2 */
-#define WM8960_PWR2_LOUT1	0x40
-#define WM8960_PWR2_ROUT1	0x20
-#define WM8960_PWR2_OUT3	0x02
+#define WM8960_PWR2_LOUT1   0x40
+#define WM8960_PWR2_ROUT1   0x20
+#define WM8960_PWR2_OUT3    0x02
 
 /* R28 - Anti-pop 1 */
 #define WM8960_POBCTRL   0x80
@@ -52,189 +56,187 @@
  * We can't read the WM8960 register space when we are
  * using 2 wire for device control, so we cache them instead.
  */
-static const struct reg_default wm8960_reg_defaults[] = {
-	{  0x0, 0x00a7 },
-	{  0x1, 0x00a7 },
-	{  0x2, 0x0000 },
-	{  0x3, 0x0000 },
-	{  0x4, 0x0000 },
-	{  0x5, 0x0008 },
-	{  0x6, 0x0000 },
-	{  0x7, 0x000a },
-	{  0x8, 0x01c0 },
-	{  0x9, 0x0000 },
-	{  0xa, 0x00ff },
-	{  0xb, 0x00ff },
-
-	{ 0x10, 0x0000 },
-	{ 0x11, 0x007b },
-	{ 0x12, 0x0100 },
-	{ 0x13, 0x0032 },
-	{ 0x14, 0x0000 },
-	{ 0x15, 0x00c3 },
-	{ 0x16, 0x00c3 },
-	{ 0x17, 0x01c0 },
-	{ 0x18, 0x0000 },
-	{ 0x19, 0x0000 },
-	{ 0x1a, 0x0000 },
-	{ 0x1b, 0x0000 },
-	{ 0x1c, 0x0000 },
-	{ 0x1d, 0x0000 },
-
-	{ 0x20, 0x0100 },
-	{ 0x21, 0x0100 },
-	{ 0x22, 0x0050 },
-
-	{ 0x25, 0x0050 },
-	{ 0x26, 0x0000 },
-	{ 0x27, 0x0000 },
-	{ 0x28, 0x0000 },
-	{ 0x29, 0x0000 },
-	{ 0x2a, 0x0040 },
-	{ 0x2b, 0x0000 },
-	{ 0x2c, 0x0000 },
-	{ 0x2d, 0x0050 },
-	{ 0x2e, 0x0050 },
-	{ 0x2f, 0x0000 },
-	{ 0x30, 0x0002 },
-	{ 0x31, 0x0037 },
-
-	{ 0x33, 0x0080 },
-	{ 0x34, 0x0008 },
-	{ 0x35, 0x0031 },
-	{ 0x36, 0x0026 },
-	{ 0x37, 0x00e9 },
+static const u16 wm8960_reg[WM8960_CACHEREGNUM] = {
+    0x0097, 0x0097, 0x0000, 0x0000,
+    0x0000, 0x0008, 0x0000, 0x000a,
+    0x01c0, 0x0000, 0x00ff, 0x00ff,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x007b, 0x0100, 0x0032,
+    0x0000, 0x00c3, 0x00c3, 0x01c0,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000,
+    0x0100, 0x0100, 0x0050, 0x0050,
+    0x0050, 0x0050, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0040, 0x0000,
+    0x0000, 0x0050, 0x0050, 0x0000,
+    0x0002, 0x0037, 0x004d, 0x0080,
+    0x0008, 0x0031, 0x0026, 0x00e9,
 };
 
-static bool wm8960_volatile(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case WM8960_RESET:
-		return true;
-	default:
-		return false;
-	}
-}
-
 struct wm8960_priv {
-	struct regmap *regmap;
-	int (*set_bias_level)(struct snd_soc_codec *,
-			      enum snd_soc_bias_level level);
-	struct snd_soc_dapm_widget *lout1;
-	struct snd_soc_dapm_widget *rout1;
-	struct snd_soc_dapm_widget *out3;
-	bool deemph;
-	int playback_fs;
+    enum snd_soc_control_type control_type;
+    int (*set_bias_level)(struct snd_soc_codec *,
+                  enum snd_soc_bias_level level);
+    struct snd_soc_dapm_widget *lout1;
+    struct snd_soc_dapm_widget *rout1;
+    struct snd_soc_dapm_widget *out3;
+    bool deemph;
+    int playback_fs;
+    struct wm8960_data *pdata;
 };
+struct snd_soc_codec *wm8960_codec =NULL;
+struct wm8960_data *pdata_wm8960 = NULL;
+
 
-#define wm8960_reset(c)	snd_soc_write(c, WM8960_RESET, 0)
+#define wm8960_reset(c) snd_soc_write(c, WM8960_RESET, 0)
 
 /* enumerated controls */
 static const char *wm8960_polarity[] = {"No Inversion", "Left Inverted",
-	"Right Inverted", "Stereo Inversion"};
+    "Right Inverted", "Stereo Inversion"};
 static const char *wm8960_3d_upper_cutoff[] = {"High", "Low"};
 static const char *wm8960_3d_lower_cutoff[] = {"Low", "High"};
 static const char *wm8960_alcfunc[] = {"Off", "Right", "Left", "Stereo"};
 static const char *wm8960_alcmode[] = {"ALC", "Limiter"};
 
 static const struct soc_enum wm8960_enum[] = {
-	SOC_ENUM_SINGLE(WM8960_DACCTL1, 5, 4, wm8960_polarity),
-	SOC_ENUM_SINGLE(WM8960_DACCTL2, 5, 4, wm8960_polarity),
-	SOC_ENUM_SINGLE(WM8960_3D, 6, 2, wm8960_3d_upper_cutoff),
-	SOC_ENUM_SINGLE(WM8960_3D, 5, 2, wm8960_3d_lower_cutoff),
-	SOC_ENUM_SINGLE(WM8960_ALC1, 7, 4, wm8960_alcfunc),
-	SOC_ENUM_SINGLE(WM8960_ALC3, 8, 2, wm8960_alcmode),
+    SOC_ENUM_SINGLE(WM8960_DACCTL1, 5, 4, wm8960_polarity),
+    SOC_ENUM_SINGLE(WM8960_DACCTL2, 5, 4, wm8960_polarity),
+    SOC_ENUM_SINGLE(WM8960_3D, 6, 2, wm8960_3d_upper_cutoff),
+    SOC_ENUM_SINGLE(WM8960_3D, 5, 2, wm8960_3d_lower_cutoff),
+    SOC_ENUM_SINGLE(WM8960_ALC1, 7, 4, wm8960_alcfunc),
+    SOC_ENUM_SINGLE(WM8960_ALC3, 8, 2, wm8960_alcmode),
 };
 
 static const int deemph_settings[] = { 0, 32000, 44100, 48000 };
 
 static int wm8960_set_deemph(struct snd_soc_codec *codec)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	int val, i, best;
-
-	/* If we're using deemphasis select the nearest available sample
-	 * rate.
-	 */
-	if (wm8960->deemph) {
-		best = 1;
-		for (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {
-			if (abs(deemph_settings[i] - wm8960->playback_fs) <
-			    abs(deemph_settings[best] - wm8960->playback_fs))
-				best = i;
-		}
-
-		val = best << 1;
-	} else {
-		val = 0;
-	}
-
-	dev_dbg(codec->dev, "Set deemphasis %d\n", val);
-
-	return snd_soc_update_bits(codec, WM8960_DACCTL1,
-				   0x6, val);
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    int val, i, best;
+
+    /* If we're using deemphasis select the nearest available sample
+     * rate.
+     */
+    if (wm8960->deemph) {
+        best = 1;
+        for (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {
+            if (abs(deemph_settings[i] - wm8960->playback_fs) <
+                abs(deemph_settings[best] - wm8960->playback_fs))
+                best = i;
+        }
+
+        val = best << 1;
+    } else {
+        val = 0;
+    }
+
+    dev_dbg(codec->dev, "Set deemphasis %d\n", val);
+
+    return snd_soc_update_bits(codec, WM8960_DACCTL1,
+                   0x6, val);
 }
 
 static int wm8960_get_deemph(struct snd_kcontrol *kcontrol,
-			     struct snd_ctl_elem_value *ucontrol)
+                 struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = wm8960->deemph;
-	return 0;
+    ucontrol->value.enumerated.item[0] = wm8960->deemph;
+    return 0;
 }
 
 static int wm8960_put_deemph(struct snd_kcontrol *kcontrol,
-			     struct snd_ctl_elem_value *ucontrol)
+                 struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    int deemph = ucontrol->value.enumerated.item[0];
 
-	if (deemph > 1)
-		return -EINVAL;
+    if (deemph > 1)
+        return -EINVAL;
 
-	wm8960->deemph = deemph;
+    wm8960->deemph = deemph;
 
-	return wm8960_set_deemph(codec);
+    return wm8960_set_deemph(codec);
 }
 
+static int outmixer_ev(struct snd_soc_dapm_widget *w,
+    struct snd_kcontrol *kcontrol, int event)
+{
+    struct snd_soc_codec *codec = w->codec;
+    unsigned int mask = 1<<w->shift;
+    //printk(KERN_ERR "Amlogic <> %s(%d):name %s , event(%d)\n",__func__, __LINE__, w->name, event);
+    snd_soc_update_bits(codec, WM8960_POWER3, mask, mask);
+    return 0;
+}
+static int classD_ev(struct snd_soc_dapm_widget *w,
+    struct snd_kcontrol *kcontrol, int event)
+{
+    struct snd_soc_codec *codec = w->codec;
+    unsigned int mask = 1<<w->shift;
+    //printk(KERN_ERR "Amlogic <> %s(%d):name %s , event(%d)\n",__func__, __LINE__, w->name, event);
+    snd_soc_update_bits(codec, WM8960_CLASSD1, mask, mask);
+    return 0;
+}
+
+static int dac_ev(struct snd_soc_dapm_widget *w,
+    struct snd_kcontrol *kcontrol, int event)
+{
+    struct snd_soc_codec *codec = w->codec;
+    static unsigned int lout1,rout1;
+    unsigned int mask = 1<<w->shift;
+    //printk(KERN_ERR "Amlogic <> %s(%d):name %s , event(%d)\n",__func__, __LINE__, w->name, event);
+    snd_soc_update_bits(codec, WM8960_POWER2, mask, mask);
+    switch(event) {
+        case SND_SOC_DAPM_PRE_PMD:
+        //snd_soc_update_bits(codec, WM8960_LOUT1,0x100,0x100);
+        //snd_soc_update_bits(codec, WM8960_ROUT1,0x100,0x100);
+        //snd_soc_update_bits(codec, WM8960_LOUT2,0x100,0x100);
+        //snd_soc_update_bits(codec, WM8960_ROUT2,0x100,0x100);
+        break;
+        case SND_SOC_DAPM_POST_PMD:
+
+            break;
+        case SND_SOC_DAPM_PRE_PMU:
+          // lout1 = snd_soc_read(codec, WM8960_LOUT1);
+          // rout1 = snd_soc_read(codec, WM8960_ROUT1);
+          // snd_soc_write(codec, WM8960_ROUT1, 0x100);
+          // snd_soc_write(codec, WM8960_ROUT1, 0x100);
+           break;
+       case SND_SOC_DAPM_POST_PMU:
+          // snd_soc_write(codec, WM8960_ROUT1,lout1|0x100);
+          // snd_soc_write(codec, WM8960_ROUT1,rout1|0x100);
+           break;
+        }
+    return 0;
+}
 static const DECLARE_TLV_DB_SCALE(adc_tlv, -9700, 50, 0);
 static const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 50, 1);
 static const DECLARE_TLV_DB_SCALE(bypass_tlv, -2100, 300, 0);
 static const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);
-static const DECLARE_TLV_DB_SCALE(boost_tlv, -1200, 300, 1);
+static const DECLARE_TLV_DB_MINMAX(input_pag_tlv, 0, 2900);
 
 static const struct snd_kcontrol_new wm8960_snd_controls[] = {
 SOC_DOUBLE_R_TLV("Capture Volume", WM8960_LINVOL, WM8960_RINVOL,
-		 0, 63, 0, adc_tlv),
+         0, 63, 0, adc_tlv),
 SOC_DOUBLE_R("Capture Volume ZC Switch", WM8960_LINVOL, WM8960_RINVOL,
-	6, 1, 0),
+    6, 1, 0),
 SOC_DOUBLE_R("Capture Switch", WM8960_LINVOL, WM8960_RINVOL,
-	7, 1, 0),
-
-SOC_SINGLE_TLV("Right Input Boost Mixer RINPUT3 Volume",
-	       WM8960_INBMIX1, 4, 7, 0, boost_tlv),
-SOC_SINGLE_TLV("Right Input Boost Mixer RINPUT2 Volume",
-	       WM8960_INBMIX1, 1, 7, 0, boost_tlv),
-SOC_SINGLE_TLV("Left Input Boost Mixer LINPUT3 Volume",
-	       WM8960_INBMIX2, 4, 7, 0, boost_tlv),
-SOC_SINGLE_TLV("Left Input Boost Mixer LINPUT2 Volume",
-	       WM8960_INBMIX2, 1, 7, 0, boost_tlv),
+    7, 1, 0),
 
 SOC_DOUBLE_R_TLV("Playback Volume", WM8960_LDAC, WM8960_RDAC,
-		 0, 255, 0, dac_tlv),
+         0, 255, 0, dac_tlv),
 
 SOC_DOUBLE_R_TLV("Headphone Playback Volume", WM8960_LOUT1, WM8960_ROUT1,
-		 0, 127, 0, out_tlv),
+         0, 127, 0, out_tlv),
 SOC_DOUBLE_R("Headphone Playback ZC Switch", WM8960_LOUT1, WM8960_ROUT1,
-	7, 1, 0),
+    7, 1, 0),
 
 SOC_DOUBLE_R_TLV("Speaker Playback Volume", WM8960_LOUT2, WM8960_ROUT2,
-		 0, 127, 0, out_tlv),
+         0, 127, 0, out_tlv),
 SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8960_LOUT2, WM8960_ROUT2,
-	7, 1, 0),
+    7, 1, 0),
 SOC_SINGLE("Speaker DC Volume", WM8960_CLASSD3, 3, 5, 0),
 SOC_SINGLE("Speaker AC Volume", WM8960_CLASSD3, 0, 5, 0),
 
@@ -244,7 +246,7 @@ SOC_SINGLE("ADC High Pass Filter Switch", WM8960_DACCTL1, 0, 1, 0),
 
 SOC_ENUM("DAC Polarity", wm8960_enum[2]),
 SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
-		    wm8960_get_deemph, wm8960_put_deemph),
+            wm8960_get_deemph, wm8960_put_deemph),
 
 SOC_ENUM("3D Filter Upper Cut-Off", wm8960_enum[2]),
 SOC_ENUM("3D Filter Lower Cut-Off", wm8960_enum[3]),
@@ -263,17 +265,26 @@ SOC_SINGLE("ALC Attack", WM8960_ALC3, 0, 15, 0),
 SOC_SINGLE("Noise Gate Threshold", WM8960_NOISEG, 3, 31, 0),
 SOC_SINGLE("Noise Gate Switch", WM8960_NOISEG, 0, 1, 0),
 
+#if 0
 SOC_DOUBLE_R("ADC PCM Capture Volume", WM8960_LINPATH, WM8960_RINPATH,
-	0, 127, 0),
+    0, 127, 0),
+#else
+SOC_DOUBLE_R_TLV("ADC PCM Capture Volume", WM8960_LINPATH, WM8960_RINPATH,
+    4, 3, 0, input_pag_tlv),
+#endif
 
 SOC_SINGLE_TLV("Left Output Mixer Boost Bypass Volume",
-	       WM8960_BYPASS1, 4, 7, 1, bypass_tlv),
+           WM8960_BYPASS1, 4, 7, 1, bypass_tlv),
 SOC_SINGLE_TLV("Left Output Mixer LINPUT3 Volume",
-	       WM8960_LOUTMIX, 4, 7, 1, bypass_tlv),
+           WM8960_LOUTMIX, 4, 7, 1, bypass_tlv),
 SOC_SINGLE_TLV("Right Output Mixer Boost Bypass Volume",
-	       WM8960_BYPASS2, 4, 7, 1, bypass_tlv),
+           WM8960_BYPASS2, 4, 7, 1, bypass_tlv),
 SOC_SINGLE_TLV("Right Output Mixer RINPUT3 Volume",
-	       WM8960_ROUTMIX, 4, 7, 1, bypass_tlv),
+           WM8960_ROUTMIX, 4, 7, 1, bypass_tlv),
+
+SOC_SINGLE("DAC Mono Mix", WM8960_ADDCTL1, 4, 1, 0),
+
+SOC_SINGLE("ADC Output Select", WM8960_ADDCTL1, 2, 3, 0),
 };
 
 static const struct snd_kcontrol_new wm8960_lin_boost[] = {
@@ -321,36 +332,54 @@ SND_SOC_DAPM_INPUT("RINPUT2"),
 SND_SOC_DAPM_INPUT("LINPUT3"),
 SND_SOC_DAPM_INPUT("RINPUT3"),
 
-SND_SOC_DAPM_SUPPLY("MICB", WM8960_POWER1, 1, 0, NULL, 0),
+SND_SOC_DAPM_MICBIAS("MICB", WM8960_POWER1, 1, 0),
 
 SND_SOC_DAPM_MIXER("Left Boost Mixer", WM8960_POWER1, 5, 0,
-		   wm8960_lin_boost, ARRAY_SIZE(wm8960_lin_boost)),
+           wm8960_lin_boost, ARRAY_SIZE(wm8960_lin_boost)),
 SND_SOC_DAPM_MIXER("Right Boost Mixer", WM8960_POWER1, 4, 0,
-		   wm8960_rin_boost, ARRAY_SIZE(wm8960_rin_boost)),
+           wm8960_rin_boost, ARRAY_SIZE(wm8960_rin_boost)),
 
 SND_SOC_DAPM_MIXER("Left Input Mixer", WM8960_POWER3, 5, 0,
-		   wm8960_lin, ARRAY_SIZE(wm8960_lin)),
+           wm8960_lin, ARRAY_SIZE(wm8960_lin)),
 SND_SOC_DAPM_MIXER("Right Input Mixer", WM8960_POWER3, 4, 0,
-		   wm8960_rin, ARRAY_SIZE(wm8960_rin)),
+           wm8960_rin, ARRAY_SIZE(wm8960_rin)),
 
 SND_SOC_DAPM_ADC("Left ADC", "Capture", WM8960_POWER1, 3, 0),
 SND_SOC_DAPM_ADC("Right ADC", "Capture", WM8960_POWER1, 2, 0),
 
-SND_SOC_DAPM_DAC("Left DAC", "Playback", WM8960_POWER2, 8, 0),
-SND_SOC_DAPM_DAC("Right DAC", "Playback", WM8960_POWER2, 7, 0),
+//SND_SOC_DAPM_DAC("Left DAC", "Playback", WM8960_POWER2, 8, 0),
+//SND_SOC_DAPM_DAC("Right DAC", "Playback", WM8960_POWER2, 7, 0),
+
+SND_SOC_DAPM_DAC_E("Left DAC", "Playback", SND_SOC_NOPM, 8, 0, dac_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU|SND_SOC_DAPM_POST_PMD),
+SND_SOC_DAPM_DAC_E("Right DAC", "Playback", SND_SOC_NOPM, 7, 0,dac_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU|SND_SOC_DAPM_POST_PMD),
+
+/*
 
 SND_SOC_DAPM_MIXER("Left Output Mixer", WM8960_POWER3, 3, 0,
-	&wm8960_loutput_mixer[0],
-	ARRAY_SIZE(wm8960_loutput_mixer)),
+    &wm8960_loutput_mixer[0],
+    ARRAY_SIZE(wm8960_loutput_mixer)),
 SND_SOC_DAPM_MIXER("Right Output Mixer", WM8960_POWER3, 2, 0,
-	&wm8960_routput_mixer[0],
-	ARRAY_SIZE(wm8960_routput_mixer)),
+    &wm8960_routput_mixer[0],
+    ARRAY_SIZE(wm8960_routput_mixer)),
+*/
+
 
-SND_SOC_DAPM_PGA("LOUT1 PGA", WM8960_POWER2, 6, 0, NULL, 0),
-SND_SOC_DAPM_PGA("ROUT1 PGA", WM8960_POWER2, 5, 0, NULL, 0),
+    
 
-SND_SOC_DAPM_PGA("Left Speaker PGA", WM8960_POWER2, 4, 0, NULL, 0),
-SND_SOC_DAPM_PGA("Right Speaker PGA", WM8960_POWER2, 3, 0, NULL, 0),
+SND_SOC_DAPM_MIXER_E("Left Output Mixer", SND_SOC_NOPM, 3, 0,
+        &wm8960_loutput_mixer[0],
+        ARRAY_SIZE(wm8960_loutput_mixer), outmixer_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU),
+SND_SOC_DAPM_MIXER_E("Right Output Mixer", SND_SOC_NOPM, 2, 0,
+        &wm8960_routput_mixer[0],
+        ARRAY_SIZE(wm8960_routput_mixer), outmixer_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU),
+
+SND_SOC_DAPM_PGA_E("LOUT1 PGA", SND_SOC_NOPM, 6, 0, NULL, 0, dac_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU),
+SND_SOC_DAPM_PGA_E("ROUT1 PGA", SND_SOC_NOPM, 5, 0, NULL, 0, dac_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU),
+
+    SND_SOC_DAPM_PGA("Left Speaker PGA", WM8960_POWER2, 4, 0, NULL, 0),
+    SND_SOC_DAPM_PGA("Right Speaker PGA", WM8960_POWER2, 3, 0, NULL, 0),
+    //SND_SOC_DAPM_PGA_E("Left Speaker PGA", SND_SOC_NOPM, 4, 0, NULL, 0, dac_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU),
+    //SND_SOC_DAPM_PGA_E("Right Speaker PGA", SND_SOC_NOPM, 3, 0, NULL, 0, dac_ev, SND_SOC_DAPM_PRE_PMD|SND_SOC_DAPM_PRE_PMU),
 
 SND_SOC_DAPM_PGA("Right Speaker Output", WM8960_CLASSD1, 7, 0, NULL, 0),
 SND_SOC_DAPM_PGA("Left Speaker Output", WM8960_CLASSD1, 6, 0, NULL, 0),
@@ -366,8 +395,8 @@ SND_SOC_DAPM_OUTPUT("OUT3"),
 
 static const struct snd_soc_dapm_widget wm8960_dapm_widgets_out3[] = {
 SND_SOC_DAPM_MIXER("Mono Output Mixer", WM8960_POWER2, 1, 0,
-	&wm8960_mono_out[0],
-	ARRAY_SIZE(wm8960_mono_out)),
+    &wm8960_mono_out[0],
+    ARRAY_SIZE(wm8960_mono_out)),
 };
 
 /* Represent OUT3 as a PGA so that it gets turned on with LOUT1/ROUT1 */
@@ -376,405 +405,423 @@ SND_SOC_DAPM_PGA("OUT3 VMID", WM8960_POWER2, 1, 0, NULL, 0),
 };
 
 static const struct snd_soc_dapm_route audio_paths[] = {
-	{ "Left Boost Mixer", "LINPUT1 Switch", "LINPUT1" },
-	{ "Left Boost Mixer", "LINPUT2 Switch", "LINPUT2" },
-	{ "Left Boost Mixer", "LINPUT3 Switch", "LINPUT3" },
+    { "Left Boost Mixer", "LINPUT1 Switch", "LINPUT1" },
+    { "Left Boost Mixer", "LINPUT2 Switch", "LINPUT2" },
+    { "Left Boost Mixer", "LINPUT3 Switch", "LINPUT3" },
 
-	{ "Left Input Mixer", "Boost Switch", "Left Boost Mixer", },
-	{ "Left Input Mixer", NULL, "LINPUT1", },  /* Really Boost Switch */
-	{ "Left Input Mixer", NULL, "LINPUT2" },
-	{ "Left Input Mixer", NULL, "LINPUT3" },
+    { "Left Input Mixer", "Boost Switch", "Left Boost Mixer", },
+    { "Left Input Mixer", NULL, "LINPUT1", },  /* Really Boost Switch */
+    { "Left Input Mixer", NULL, "LINPUT2" },
+    { "Left Input Mixer", NULL, "LINPUT3" },
 
-	{ "Right Boost Mixer", "RINPUT1 Switch", "RINPUT1" },
-	{ "Right Boost Mixer", "RINPUT2 Switch", "RINPUT2" },
-	{ "Right Boost Mixer", "RINPUT3 Switch", "RINPUT3" },
+    { "Right Boost Mixer", "RINPUT1 Switch", "RINPUT1" },
+    { "Right Boost Mixer", "RINPUT2 Switch", "RINPUT2" },
+    { "Right Boost Mixer", "RINPUT3 Switch", "RINPUT3" },
 
-	{ "Right Input Mixer", "Boost Switch", "Right Boost Mixer", },
-	{ "Right Input Mixer", NULL, "RINPUT1", },  /* Really Boost Switch */
-	{ "Right Input Mixer", NULL, "RINPUT2" },
-	{ "Right Input Mixer", NULL, "LINPUT3" },
+    { "Right Input Mixer", "Boost Switch", "Right Boost Mixer", },
+    { "Right Input Mixer", NULL, "RINPUT1", },  /* Really Boost Switch */
+    { "Right Input Mixer", NULL, "RINPUT2" },
+    { "Right Input Mixer", NULL, "LINPUT3" },
 
-	{ "Left ADC", NULL, "Left Input Mixer" },
-	{ "Right ADC", NULL, "Right Input Mixer" },
+    { "Left ADC", NULL, "Left Input Mixer" },
+    { "Right ADC", NULL, "Right Input Mixer" },
 
-	{ "Left Output Mixer", "LINPUT3 Switch", "LINPUT3" },
-	{ "Left Output Mixer", "Boost Bypass Switch", "Left Boost Mixer"} ,
-	{ "Left Output Mixer", "PCM Playback Switch", "Left DAC" },
+    { "Left Output Mixer", "LINPUT3 Switch", "LINPUT3" },
+    { "Left Output Mixer", "Boost Bypass Switch", "Left Boost Mixer"} ,
+    { "Left Output Mixer", "PCM Playback Switch", "Left DAC" },
 
-	{ "Right Output Mixer", "RINPUT3 Switch", "RINPUT3" },
-	{ "Right Output Mixer", "Boost Bypass Switch", "Right Boost Mixer" } ,
-	{ "Right Output Mixer", "PCM Playback Switch", "Right DAC" },
+    { "Right Output Mixer", "RINPUT3 Switch", "RINPUT3" },
+    { "Right Output Mixer", "Boost Bypass Switch", "Right Boost Mixer" } ,
+    { "Right Output Mixer", "PCM Playback Switch", "Right DAC" },
 
-	{ "LOUT1 PGA", NULL, "Left Output Mixer" },
-	{ "ROUT1 PGA", NULL, "Right Output Mixer" },
+    { "LOUT1 PGA", NULL, "Left Output Mixer" },
+    { "ROUT1 PGA", NULL, "Right Output Mixer" },
 
-	{ "HP_L", NULL, "LOUT1 PGA" },
-	{ "HP_R", NULL, "ROUT1 PGA" },
+    { "HP_L", NULL, "LOUT1 PGA" },
+    { "HP_R", NULL, "ROUT1 PGA" },
 
-	{ "Left Speaker PGA", NULL, "Left Output Mixer" },
-	{ "Right Speaker PGA", NULL, "Right Output Mixer" },
+    { "Left Speaker PGA", NULL, "Left Output Mixer" },
+    { "Right Speaker PGA", NULL, "Right Output Mixer" },
 
-	{ "Left Speaker Output", NULL, "Left Speaker PGA" },
-	{ "Right Speaker Output", NULL, "Right Speaker PGA" },
+    { "Left Speaker Output", NULL, "Left Speaker PGA" },
+    { "Right Speaker Output", NULL, "Right Speaker PGA" },
 
-	{ "SPK_LN", NULL, "Left Speaker Output" },
-	{ "SPK_LP", NULL, "Left Speaker Output" },
-	{ "SPK_RN", NULL, "Right Speaker Output" },
-	{ "SPK_RP", NULL, "Right Speaker Output" },
+    { "SPK_LN", NULL, "Left Speaker Output" },
+    { "SPK_LP", NULL, "Left Speaker Output" },
+    { "SPK_RN", NULL, "Right Speaker Output" },
+    { "SPK_RP", NULL, "Right Speaker Output" },
 };
 
 static const struct snd_soc_dapm_route audio_paths_out3[] = {
-	{ "Mono Output Mixer", "Left Switch", "Left Output Mixer" },
-	{ "Mono Output Mixer", "Right Switch", "Right Output Mixer" },
+    { "Mono Output Mixer", "Left Switch", "Left Output Mixer" },
+    { "Mono Output Mixer", "Right Switch", "Right Output Mixer" },
 
-	{ "OUT3", NULL, "Mono Output Mixer", }
+    { "OUT3", NULL, "Mono Output Mixer", }
 };
 
 static const struct snd_soc_dapm_route audio_paths_capless[] = {
-	{ "HP_L", NULL, "OUT3 VMID" },
-	{ "HP_R", NULL, "OUT3 VMID" },
+    { "HP_L", NULL, "OUT3 VMID" },
+    { "HP_R", NULL, "OUT3 VMID" },
 
-	{ "OUT3 VMID", NULL, "Left Output Mixer" },
-	{ "OUT3 VMID", NULL, "Right Output Mixer" },
+    { "OUT3 VMID", NULL, "Left Output Mixer" },
+    { "OUT3 VMID", NULL, "Right Output Mixer" },
 };
 
 static int wm8960_add_widgets(struct snd_soc_codec *codec)
 {
-	struct wm8960_data *pdata = codec->dev->platform_data;
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	struct snd_soc_dapm_widget *w;
-
-	snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets,
-				  ARRAY_SIZE(wm8960_dapm_widgets));
-
-	snd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));
-
-	/* In capless mode OUT3 is used to provide VMID for the
-	 * headphone outputs, otherwise it is used as a mono mixer.
-	 */
-	if (pdata && pdata->capless) {
-		snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_capless,
-					  ARRAY_SIZE(wm8960_dapm_widgets_capless));
-
-		snd_soc_dapm_add_routes(dapm, audio_paths_capless,
-					ARRAY_SIZE(audio_paths_capless));
-	} else {
-		snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_out3,
-					  ARRAY_SIZE(wm8960_dapm_widgets_out3));
-
-		snd_soc_dapm_add_routes(dapm, audio_paths_out3,
-					ARRAY_SIZE(audio_paths_out3));
-	}
-
-	/* We need to power up the headphone output stage out of
-	 * sequence for capless mode.  To save scanning the widget
-	 * list each time to find the desired power state do so now
-	 * and save the result.
-	 */
-	list_for_each_entry(w, &codec->card->widgets, list) {
-		if (w->dapm != &codec->dapm)
-			continue;
-		if (strcmp(w->name, "LOUT1 PGA") == 0)
-			wm8960->lout1 = w;
-		if (strcmp(w->name, "ROUT1 PGA") == 0)
-			wm8960->rout1 = w;
-		if (strcmp(w->name, "OUT3 VMID") == 0)
-			wm8960->out3 = w;
-	}
-	
-	return 0;
+    struct wm8960_data *pdata = codec->dev->platform_data;
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    //struct wm8960_data *pdata = pdata_wm8960;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    struct snd_soc_dapm_widget *w;
+
+    snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets,
+                  ARRAY_SIZE(wm8960_dapm_widgets));
+
+    snd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));
+
+    /* In capless mode OUT3 is used to provide VMID for the
+     * headphone outputs, otherwise it is used as a mono mixer.
+     */
+    if (pdata && pdata->capless) {
+        snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_capless,
+                      ARRAY_SIZE(wm8960_dapm_widgets_capless));
+
+        snd_soc_dapm_add_routes(dapm, audio_paths_capless,
+                    ARRAY_SIZE(audio_paths_capless));
+    } else {
+        snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_out3,
+                      ARRAY_SIZE(wm8960_dapm_widgets_out3));
+
+        snd_soc_dapm_add_routes(dapm, audio_paths_out3,
+                    ARRAY_SIZE(audio_paths_out3));
+    }
+
+    /* We need to power up the headphone output stage out of
+     * sequence for capless mode.  To save scanning the widget
+     * list each time to find the desired power state do so now
+     * and save the result.
+     */
+    list_for_each_entry(w, &codec->card->widgets, list) {
+        if (w->dapm != &codec->dapm)
+            continue;
+        if (strcmp(w->name, "LOUT1 PGA") == 0)
+            wm8960->lout1 = w;
+        if (strcmp(w->name, "ROUT1 PGA") == 0)
+            wm8960->rout1 = w;
+        if (strcmp(w->name, "OUT3 VMID") == 0)
+            wm8960->out3 = w;
+    }
+
+    return 0;
 }
 
 static int wm8960_set_dai_fmt(struct snd_soc_dai *codec_dai,
-		unsigned int fmt)
+        unsigned int fmt)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	u16 iface = 0;
-
-	/* set master/slave audio interface */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		iface |= 0x0040;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* interface format */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		iface |= 0x0002;
-		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		iface |= 0x0001;
-		break;
-	case SND_SOC_DAIFMT_DSP_A:
-		iface |= 0x0003;
-		break;
-	case SND_SOC_DAIFMT_DSP_B:
-		iface |= 0x0013;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* clock inversion */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		iface |= 0x0090;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		iface |= 0x0080;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		iface |= 0x0010;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* set iface */
-	snd_soc_write(codec, WM8960_IFACE1, iface);
-	return 0;
+    struct snd_soc_codec *codec = codec_dai->codec;
+    u16 iface = 0;
+
+    /* set master/slave audio interface */
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBM_CFM:
+        iface |= 0x0040;
+        break;
+    case SND_SOC_DAIFMT_CBS_CFS:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* interface format */
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_I2S:
+        iface |= 0x0002;
+        break;
+    case SND_SOC_DAIFMT_RIGHT_J:
+        break;
+    case SND_SOC_DAIFMT_LEFT_J:
+        iface |= 0x0001;
+        break;
+    case SND_SOC_DAIFMT_DSP_A:
+        iface |= 0x0003;
+        break;
+    case SND_SOC_DAIFMT_DSP_B:
+        iface |= 0x0013;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* clock inversion */
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+    case SND_SOC_DAIFMT_NB_NF:
+        break;
+    case SND_SOC_DAIFMT_IB_IF:
+        iface |= 0x0090;
+        break;
+    case SND_SOC_DAIFMT_IB_NF:
+        iface |= 0x0080;
+        break;
+    case SND_SOC_DAIFMT_NB_IF:
+        iface |= 0x0010;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* set iface */
+    snd_soc_write(codec, WM8960_IFACE1, iface);
+    return 0;
 }
 
 static struct {
-	int rate;
-	unsigned int val;
+    int rate;
+    unsigned int val;
 } alc_rates[] = {
-	{ 48000, 0 },
-	{ 44100, 0 },
-	{ 32000, 1 },
-	{ 22050, 2 },
-	{ 24000, 2 },
-	{ 16000, 3 },
-	{ 11250, 4 },
-	{ 12000, 4 },
-	{  8000, 5 },
+    { 48000, 0 },
+    { 44100, 0 },
+    { 32000, 1 },
+    { 22050, 2 },
+    { 24000, 2 },
+    { 16000, 3 },
+    { 11250, 4 },
+    { 12000, 4 },
+    {  8000, 5 },
 };
 
 static int wm8960_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
+                struct snd_pcm_hw_params *params,
+                struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	u16 iface = snd_soc_read(codec, WM8960_IFACE1) & 0xfff3;
-	snd_pcm_format_t format = params_format(params);
-	int i;
-
-	/* bit size */
-	switch (format) {
-	case SNDRV_PCM_FORMAT_S16_LE:
-	case SNDRV_PCM_FORMAT_S16_BE:
-		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-	case SNDRV_PCM_FORMAT_S20_3BE:
-		iface |= 0x0004;
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-	case SNDRV_PCM_FORMAT_S24_BE:
-		iface |= 0x0008;
-		break;
-	default:
-		dev_err(codec->dev, "unsupported format %i\n", format);
-		return -EINVAL;
-	}
-
-	/* Update filters for the new rate */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		wm8960->playback_fs = params_rate(params);
-		wm8960_set_deemph(codec);
-	} else {
-		for (i = 0; i < ARRAY_SIZE(alc_rates); i++)
-			if (alc_rates[i].rate == params_rate(params))
-				snd_soc_update_bits(codec,
-						    WM8960_ADDCTL3, 0x7,
-						    alc_rates[i].val);
-	}
-
-	/* set iface */
-	snd_soc_write(codec, WM8960_IFACE1, iface);
-	return 0;
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_codec *codec = rtd->codec;
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    u16 iface = snd_soc_read(codec, WM8960_IFACE1) & 0xfff3;
+    int i;
+
+    /* bit size */
+    switch (params_format(params)) {
+    case SNDRV_PCM_FORMAT_S16_LE:
+        break;
+    case SNDRV_PCM_FORMAT_S20_3LE:
+        iface |= 0x0004;
+        break;
+    case SNDRV_PCM_FORMAT_S24_LE:
+        iface |= 0x0008;
+        break;
+    }
+
+    /* Update filters for the new rate */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        wm8960->playback_fs = params_rate(params);
+        wm8960_set_deemph(codec);
+    } else {
+        for (i = 0; i < ARRAY_SIZE(alc_rates); i++)
+            if (alc_rates[i].rate == params_rate(params))
+                snd_soc_update_bits(codec,
+                            WM8960_ADDCTL3, 0x7,
+                            alc_rates[i].val);
+    }
+
+    /* set iface */
+    snd_soc_write(codec, WM8960_IFACE1, iface);
+    return 0;
 }
 
 static int wm8960_mute(struct snd_soc_dai *dai, int mute)
 {
-	struct snd_soc_codec *codec = dai->codec;
-
-	if (mute)
-		snd_soc_update_bits(codec, WM8960_DACCTL1, 0x8, 0x8);
-	else
-		snd_soc_update_bits(codec, WM8960_DACCTL1, 0x8, 0);
-	return 0;
+    struct snd_soc_codec *codec = dai->codec;
+    u16 mute_reg = snd_soc_read(codec, WM8960_DACCTL1) & 0xfff7;
+    u16 mute_reg1 = snd_soc_read(codec, WM8960_LINVOL) & 0xff7f;
+    if(dai->playback_active){
+        if (mute){
+            snd_soc_write(codec, WM8960_DACCTL1, mute_reg | 0x8);
+        }else{
+            snd_soc_write(codec, WM8960_DACCTL1, mute_reg);
+        }
+    }
+    if(dai->capture_active){
+        if (mute){
+            //snd_soc_write(codec, WM8960_LINVOL, mute_reg1 | 0x80);
+        }else{
+            msleep(400);
+            snd_soc_write(codec, WM8960_LINVOL, mute_reg1);
+        }
+    }
+    return 0;
 }
 
 static int wm8960_set_bias_level_out3(struct snd_soc_codec *codec,
-				      enum snd_soc_bias_level level)
+                      enum snd_soc_bias_level level)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		break;
-
-	case SND_SOC_BIAS_PREPARE:
-		/* Set VMID to 2x50k */
-		snd_soc_update_bits(codec, WM8960_POWER1, 0x180, 0x80);
-		break;
-
-	case SND_SOC_BIAS_STANDBY:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
-			regcache_sync(wm8960->regmap);
-
-			/* Enable anti-pop features */
-			snd_soc_write(codec, WM8960_APOP1,
-				      WM8960_POBCTRL | WM8960_SOFT_ST |
-				      WM8960_BUFDCOPEN | WM8960_BUFIOEN);
-
-			/* Enable & ramp VMID at 2x50k */
-			snd_soc_update_bits(codec, WM8960_POWER1, 0x80, 0x80);
-			msleep(100);
-
-			/* Enable VREF */
-			snd_soc_update_bits(codec, WM8960_POWER1, WM8960_VREF,
-					    WM8960_VREF);
-
-			/* Disable anti-pop features */
-			snd_soc_write(codec, WM8960_APOP1, WM8960_BUFIOEN);
-		}
-
-		/* Set VMID to 2x250k */
-		snd_soc_update_bits(codec, WM8960_POWER1, 0x180, 0x100);
-		break;
-
-	case SND_SOC_BIAS_OFF:
-		/* Enable anti-pop features */
-		snd_soc_write(codec, WM8960_APOP1,
-			     WM8960_POBCTRL | WM8960_SOFT_ST |
-			     WM8960_BUFDCOPEN | WM8960_BUFIOEN);
-
-		/* Disable VMID and VREF, let them discharge */
-		snd_soc_write(codec, WM8960_POWER1, 0);
-		msleep(600);
-		break;
-	}
-
-	codec->dapm.bias_level = level;
-
-	return 0;
+    u16 reg;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+
+    case SND_SOC_BIAS_PREPARE:
+        /* Set VMID to 2x50k */
+        reg = snd_soc_read(codec, WM8960_POWER1);
+        reg &= ~0x180;
+        reg |= 0x80;
+        snd_soc_write(codec, WM8960_POWER1, reg);
+        break;
+
+    case SND_SOC_BIAS_STANDBY:
+        if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+            snd_soc_cache_sync(codec);
+
+            /* Enable anti-pop features */
+            snd_soc_write(codec, WM8960_APOP1,
+                      WM8960_POBCTRL | WM8960_SOFT_ST |
+                      WM8960_BUFDCOPEN | WM8960_BUFIOEN);
+
+            /* Enable & ramp VMID at 2x50k */
+            reg = snd_soc_read(codec, WM8960_POWER1);
+            reg |= 0x80;
+            snd_soc_write(codec, WM8960_POWER1, reg);
+            msleep(100);
+
+            /* Enable VREF and Mic Bias */
+            reg = snd_soc_read(codec, WM8960_POWER1);
+            snd_soc_write(codec, WM8960_POWER1, reg | WM8960_VREF | (1 << 1));
+
+            /* Disable anti-pop features */
+            snd_soc_write(codec, WM8960_APOP1, WM8960_BUFIOEN);
+        }
+
+        /* Set VMID to 2x250k */
+        reg = snd_soc_read(codec, WM8960_POWER1);
+        reg &= ~0x180;
+        reg |= 0x100;
+        snd_soc_write(codec, WM8960_POWER1, reg);
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        /* Enable anti-pop features */
+        snd_soc_write(codec, WM8960_APOP1,
+                 WM8960_POBCTRL | WM8960_SOFT_ST |
+                 WM8960_BUFDCOPEN | WM8960_BUFIOEN);
+
+        /* Disable VMID and VREF, let them discharge */
+        snd_soc_write(codec, WM8960_POWER1, 0);
+        msleep(600);
+        break;
+    }
+
+    codec->dapm.bias_level = level;
+    return 0;
 }
 
 static int wm8960_set_bias_level_capless(struct snd_soc_codec *codec,
-					 enum snd_soc_bias_level level)
+                     enum snd_soc_bias_level level)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	int reg;
-
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		break;
-
-	case SND_SOC_BIAS_PREPARE:
-		switch (codec->dapm.bias_level) {
-		case SND_SOC_BIAS_STANDBY:
-			/* Enable anti pop mode */
-			snd_soc_update_bits(codec, WM8960_APOP1,
-					    WM8960_POBCTRL | WM8960_SOFT_ST |
-					    WM8960_BUFDCOPEN,
-					    WM8960_POBCTRL | WM8960_SOFT_ST |
-					    WM8960_BUFDCOPEN);
-
-			/* Enable LOUT1, ROUT1 and OUT3 if they're enabled */
-			reg = 0;
-			if (wm8960->lout1 && wm8960->lout1->power)
-				reg |= WM8960_PWR2_LOUT1;
-			if (wm8960->rout1 && wm8960->rout1->power)
-				reg |= WM8960_PWR2_ROUT1;
-			if (wm8960->out3 && wm8960->out3->power)
-				reg |= WM8960_PWR2_OUT3;
-			snd_soc_update_bits(codec, WM8960_POWER2,
-					    WM8960_PWR2_LOUT1 |
-					    WM8960_PWR2_ROUT1 |
-					    WM8960_PWR2_OUT3, reg);
-
-			/* Enable VMID at 2*50k */
-			snd_soc_update_bits(codec, WM8960_POWER1,
-					    WM8960_VMID_MASK, 0x80);
-
-			/* Ramp */
-			msleep(100);
-
-			/* Enable VREF */
-			snd_soc_update_bits(codec, WM8960_POWER1,
-					    WM8960_VREF, WM8960_VREF);
-
-			msleep(100);
-			break;
-
-		case SND_SOC_BIAS_ON:
-			/* Enable anti-pop mode */
-			snd_soc_update_bits(codec, WM8960_APOP1,
-					    WM8960_POBCTRL | WM8960_SOFT_ST |
-					    WM8960_BUFDCOPEN,
-					    WM8960_POBCTRL | WM8960_SOFT_ST |
-					    WM8960_BUFDCOPEN);
-
-			/* Disable VMID and VREF */
-			snd_soc_update_bits(codec, WM8960_POWER1,
-					    WM8960_VREF | WM8960_VMID_MASK, 0);
-			break;
-
-		case SND_SOC_BIAS_OFF:
-			regcache_sync(wm8960->regmap);
-			break;
-		default:
-			break;
-		}
-		break;
-
-	case SND_SOC_BIAS_STANDBY:
-		switch (codec->dapm.bias_level) {
-		case SND_SOC_BIAS_PREPARE:
-			/* Disable HP discharge */
-			snd_soc_update_bits(codec, WM8960_APOP2,
-					    WM8960_DISOP | WM8960_DRES_MASK,
-					    0);
-
-			/* Disable anti-pop features */
-			snd_soc_update_bits(codec, WM8960_APOP1,
-					    WM8960_POBCTRL | WM8960_SOFT_ST |
-					    WM8960_BUFDCOPEN,
-					    WM8960_POBCTRL | WM8960_SOFT_ST |
-					    WM8960_BUFDCOPEN);
-			break;
-
-		default:
-			break;
-		}
-		break;
-
-	case SND_SOC_BIAS_OFF:
-		break;
-	}
-
-	codec->dapm.bias_level = level;
-
-	return 0;
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    int reg;
+    //printk("****%s******level=%d**\n",__func__,level);
+   // printk("****codec->dapm.bias_level=%d****\n",codec->dapm.bias_level);
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+
+    case SND_SOC_BIAS_PREPARE:
+        switch (codec->dapm.bias_level) {
+        case SND_SOC_BIAS_STANDBY:
+            /* Enable anti pop mode */
+            snd_soc_update_bits(codec, WM8960_APOP1,
+                        WM8960_POBCTRL | WM8960_SOFT_ST |
+                        WM8960_BUFDCOPEN,
+                        WM8960_POBCTRL | WM8960_SOFT_ST |
+                        WM8960_BUFDCOPEN);
+
+            /* Enable LOUT1, ROUT1 and OUT3 if they're enabled */
+            reg = 0;
+            if (wm8960->lout1 && wm8960->lout1->power)
+                reg |= WM8960_PWR2_LOUT1|WM8960_PWR2_ROUT1;
+            if (wm8960->rout1 && wm8960->rout1->power)
+                reg |= WM8960_PWR2_ROUT1;
+            if (wm8960->out3 && wm8960->out3->power)
+                reg |= WM8960_PWR2_OUT3;
+            snd_soc_update_bits(codec, WM8960_POWER2,
+                        WM8960_PWR2_LOUT1 |
+                        WM8960_PWR2_ROUT1 |
+                        WM8960_PWR2_OUT3, reg);
+
+            /* Enable VMID at 2*50k */
+            snd_soc_update_bits(codec, WM8960_POWER1,
+                        WM8960_VMID_MASK, 0x80);
+
+            /* Ramp */
+            msleep(100);
+
+            /* Enable VREF */
+            snd_soc_update_bits(codec, WM8960_POWER1,
+                        WM8960_VREF, WM8960_VREF);
+
+            msleep(100);
+            break;
+
+        case SND_SOC_BIAS_ON:
+            /* Enable anti-pop mode */
+            snd_soc_update_bits(codec, WM8960_APOP1,
+                        WM8960_POBCTRL | WM8960_SOFT_ST |
+                        WM8960_BUFDCOPEN,
+                        WM8960_POBCTRL | WM8960_SOFT_ST |
+                        WM8960_BUFDCOPEN);
+
+            /* Disable VMID and VREF */
+        /*  snd_soc_update_bits(codec, WM8960_POWER1,
+                        WM8960_VREF | WM8960_VMID_MASK, 0);*/
+            break;
+
+        case SND_SOC_BIAS_OFF:
+            snd_soc_cache_sync(codec);
+            break;
+        default:
+            break;
+        }
+        break;
+
+    case SND_SOC_BIAS_STANDBY:
+        switch (codec->dapm.bias_level) {
+        case SND_SOC_BIAS_PREPARE:
+            /* Disable HP discharge */
+            snd_soc_update_bits(codec, WM8960_APOP2,
+                        WM8960_DISOP | WM8960_DRES_MASK,
+                        0);
+
+            /* Disable anti-pop features */
+            snd_soc_update_bits(codec, WM8960_APOP1,
+                        WM8960_POBCTRL | WM8960_SOFT_ST |
+                        WM8960_BUFDCOPEN,
+                        WM8960_POBCTRL | WM8960_SOFT_ST |
+                        WM8960_BUFDCOPEN);
+                        
+            break;
+        case SND_SOC_BIAS_OFF:
+            snd_soc_cache_sync(codec);
+            break;
+        default:
+            break;
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        break;
+    }
+
+    codec->dapm.bias_level = level;
+
+    return 0;
 }
 
 /* PLL divisors */
 struct _pll_div {
-	u32 pre_div:1;
-	u32 n:4;
-	u32 k:24;
+    u32 pre_div:1;
+    u32 n:4;
+    u32 k:24;
 };
 
 /* The size in bits of the pll divide multiplied by 10
@@ -782,319 +829,419 @@ struct _pll_div {
 #define FIXED_PLL_SIZE ((1 << 24) * 10)
 
 static int pll_factors(unsigned int source, unsigned int target,
-		       struct _pll_div *pll_div)
+               struct _pll_div *pll_div)
 {
-	unsigned long long Kpart;
-	unsigned int K, Ndiv, Nmod;
+    unsigned long long Kpart;
+    unsigned int K, Ndiv, Nmod;
 
-	pr_debug("WM8960 PLL: setting %dHz->%dHz\n", source, target);
+    pr_debug("WM8960 PLL: setting %dHz->%dHz\n", source, target);
 
-	/* Scale up target to PLL operating frequency */
-	target *= 4;
+    /* Scale up target to PLL operating frequency */
+    target *= 4;
 
-	Ndiv = target / source;
-	if (Ndiv < 6) {
-		source >>= 1;
-		pll_div->pre_div = 1;
-		Ndiv = target / source;
-	} else
-		pll_div->pre_div = 0;
+    Ndiv = target / source;
+    if (Ndiv < 6) {
+        source >>= 1;
+        pll_div->pre_div = 1;
+        Ndiv = target / source;
+    } else
+        pll_div->pre_div = 0;
 
-	if ((Ndiv < 6) || (Ndiv > 12)) {
-		pr_err("WM8960 PLL: Unsupported N=%d\n", Ndiv);
-		return -EINVAL;
-	}
+    if ((Ndiv < 6) || (Ndiv > 12)) {
+        pr_err("WM8960 PLL: Unsupported N=%d\n", Ndiv);
+        return -EINVAL;
+    }
 
-	pll_div->n = Ndiv;
-	Nmod = target % source;
-	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
+    pll_div->n = Ndiv;
+    Nmod = target % source;
+    Kpart = FIXED_PLL_SIZE * (long long)Nmod;
 
-	do_div(Kpart, source);
+    do_div(Kpart, source);
 
-	K = Kpart & 0xFFFFFFFF;
+    K = Kpart & 0xFFFFFFFF;
 
-	/* Check if we need to round */
-	if ((K % 10) >= 5)
-		K += 5;
+    /* Check if we need to round */
+    if ((K % 10) >= 5)
+        K += 5;
 
-	/* Move down to proper range now rounding is done */
-	K /= 10;
+    /* Move down to proper range now rounding is done */
+    K /= 10;
 
-	pll_div->k = K;
+    pll_div->k = K;
 
-	pr_debug("WM8960 PLL: N=%x K=%x pre_div=%d\n",
-		 pll_div->n, pll_div->k, pll_div->pre_div);
+    pr_debug("WM8960 PLL: N=%x K=%x pre_div=%d\n",
+         pll_div->n, pll_div->k, pll_div->pre_div);
 
-	return 0;
+    return 0;
 }
 
 static int wm8960_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
-		int source, unsigned int freq_in, unsigned int freq_out)
+        int source, unsigned int freq_in, unsigned int freq_out)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	u16 reg;
-	static struct _pll_div pll_div;
-	int ret;
-
-	if (freq_in && freq_out) {
-		ret = pll_factors(freq_in, freq_out, &pll_div);
-		if (ret != 0)
-			return ret;
-	}
-
-	/* Disable the PLL: even if we are changing the frequency the
-	 * PLL needs to be disabled while we do so. */
-	snd_soc_update_bits(codec, WM8960_CLOCK1, 0x1, 0);
-	snd_soc_update_bits(codec, WM8960_POWER2, 0x1, 0);
-
-	if (!freq_in || !freq_out)
-		return 0;
-
-	reg = snd_soc_read(codec, WM8960_PLL1) & ~0x3f;
-	reg |= pll_div.pre_div << 4;
-	reg |= pll_div.n;
-
-	if (pll_div.k) {
-		reg |= 0x20;
-
-		snd_soc_write(codec, WM8960_PLL2, (pll_div.k >> 18) & 0x3f);
-		snd_soc_write(codec, WM8960_PLL3, (pll_div.k >> 9) & 0x1ff);
-		snd_soc_write(codec, WM8960_PLL4, pll_div.k & 0x1ff);
-	}
-	snd_soc_write(codec, WM8960_PLL1, reg);
-
-	/* Turn it on */
-	snd_soc_update_bits(codec, WM8960_POWER2, 0x1, 0x1);
-	msleep(250);
-	snd_soc_update_bits(codec, WM8960_CLOCK1, 0x1, 0x1);
-
-	return 0;
+    struct snd_soc_codec *codec = codec_dai->codec;
+    u16 reg;
+    static struct _pll_div pll_div;
+    int ret;
+
+    if (freq_in && freq_out) {
+        ret = pll_factors(freq_in, freq_out, &pll_div);
+        if (ret != 0)
+            return ret;
+    }
+
+    /* Disable the PLL: even if we are changing the frequency the
+     * PLL needs to be disabled while we do so. */
+    snd_soc_write(codec, WM8960_CLOCK1,
+             snd_soc_read(codec, WM8960_CLOCK1) & ~1);
+    snd_soc_write(codec, WM8960_POWER2,
+             snd_soc_read(codec, WM8960_POWER2) & ~1);
+
+    if (!freq_in || !freq_out)
+        return 0;
+
+    reg = snd_soc_read(codec, WM8960_PLL1) & ~0x3f;
+    reg |= pll_div.pre_div << 4;
+    reg |= pll_div.n;
+
+    if (pll_div.k) {
+        reg |= 0x20;
+
+        snd_soc_write(codec, WM8960_PLL2, (pll_div.k >> 18) & 0x3f);
+        snd_soc_write(codec, WM8960_PLL3, (pll_div.k >> 9) & 0x1ff);
+        snd_soc_write(codec, WM8960_PLL4, pll_div.k & 0x1ff);
+    }
+    snd_soc_write(codec, WM8960_PLL1, reg);
+
+    /* Turn it on */
+    snd_soc_write(codec, WM8960_POWER2,
+             snd_soc_read(codec, WM8960_POWER2) | 1);
+    msleep(250);
+    snd_soc_write(codec, WM8960_CLOCK1,
+             snd_soc_read(codec, WM8960_CLOCK1) | 1);
+
+    return 0;
 }
 
 static int wm8960_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
-		int div_id, int div)
+        int div_id, int div)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	u16 reg;
-
-	switch (div_id) {
-	case WM8960_SYSCLKDIV:
-		reg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1f9;
-		snd_soc_write(codec, WM8960_CLOCK1, reg | div);
-		break;
-	case WM8960_DACDIV:
-		reg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1c7;
-		snd_soc_write(codec, WM8960_CLOCK1, reg | div);
-		break;
-	case WM8960_OPCLKDIV:
-		reg = snd_soc_read(codec, WM8960_PLL1) & 0x03f;
-		snd_soc_write(codec, WM8960_PLL1, reg | div);
-		break;
-	case WM8960_DCLKDIV:
-		reg = snd_soc_read(codec, WM8960_CLOCK2) & 0x03f;
-		snd_soc_write(codec, WM8960_CLOCK2, reg | div);
-		break;
-	case WM8960_TOCLKSEL:
-		reg = snd_soc_read(codec, WM8960_ADDCTL1) & 0x1fd;
-		snd_soc_write(codec, WM8960_ADDCTL1, reg | div);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
+    struct snd_soc_codec *codec = codec_dai->codec;
+    u16 reg;
+
+    switch (div_id) {
+    case WM8960_SYSCLKDIV:
+        reg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1f9;
+        snd_soc_write(codec, WM8960_CLOCK1, reg | div);
+        break;
+    case WM8960_DACDIV:
+        reg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1c7;
+        snd_soc_write(codec, WM8960_CLOCK1, reg | div);
+        break;
+    case WM8960_OPCLKDIV:
+        reg = snd_soc_read(codec, WM8960_PLL1) & 0x03f;
+        snd_soc_write(codec, WM8960_PLL1, reg | div);
+        break;
+    case WM8960_DCLKDIV:
+        reg = snd_soc_read(codec, WM8960_CLOCK2) & 0x03f;
+        snd_soc_write(codec, WM8960_CLOCK2, reg | div);
+        break;
+    case WM8960_TOCLKSEL:
+        reg = snd_soc_read(codec, WM8960_ADDCTL1) & 0x1fd;
+        snd_soc_write(codec, WM8960_ADDCTL1, reg | div);
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
 }
 
 static int wm8960_set_bias_level(struct snd_soc_codec *codec,
-				 enum snd_soc_bias_level level)
+                 enum snd_soc_bias_level level)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
-	return wm8960->set_bias_level(codec, level);
+    return wm8960->set_bias_level(codec, level);
 }
 
 #define WM8960_RATES SNDRV_PCM_RATE_8000_48000
 
 #define WM8960_FORMATS \
-	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
-	SNDRV_PCM_FMTBIT_S24_LE)
-
-static const struct snd_soc_dai_ops wm8960_dai_ops = {
-	.hw_params = wm8960_hw_params,
-	.digital_mute = wm8960_mute,
-	.set_fmt = wm8960_set_dai_fmt,
-	.set_clkdiv = wm8960_set_dai_clkdiv,
-	.set_pll = wm8960_set_dai_pll,
+    (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+    SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops wm8960_dai_ops = {
+    .hw_params = wm8960_hw_params,
+    .digital_mute = wm8960_mute,
+    .set_fmt = wm8960_set_dai_fmt,
+    .set_clkdiv = wm8960_set_dai_clkdiv,
+    .set_pll = wm8960_set_dai_pll,
 };
 
 static struct snd_soc_dai_driver wm8960_dai = {
-	.name = "wm8960-hifi",
-	.playback = {
-		.stream_name = "Playback",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = WM8960_RATES,
-		.formats = WM8960_FORMATS,},
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = WM8960_RATES,
-		.formats = WM8960_FORMATS,},
-	.ops = &wm8960_dai_ops,
-	.symmetric_rates = 1,
+    .name = "wm8960-hifi",
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 1,
+        .channels_max = 2,
+        .rates = WM8960_RATES,
+        .formats = WM8960_FORMATS,},
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 1,
+        .channels_max = 2,
+        .rates = WM8960_RATES,
+        .formats = WM8960_FORMATS,},
+    .ops = &wm8960_dai_ops,
+    .symmetric_rates = 1,
 };
 
-static int wm8960_suspend(struct snd_soc_codec *codec)
+static int wm8960_suspend(struct snd_soc_codec *codec, pm_message_t state)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    if(!is_wm8960)
+        return 0;
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
-	wm8960->set_bias_level(codec, SND_SOC_BIAS_OFF);
-	return 0;
+    wm8960->set_bias_level(codec, SND_SOC_BIAS_OFF);
+    return 0;
 }
 
 static int wm8960_resume(struct snd_soc_codec *codec)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    if(!is_wm8960)
+        return 0;
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+
+    //wm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+    return 0;
+}
 
-	wm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-	return 0;
+#if 0
+static int wm8960_set_pdata_from_of(struct i2c_client *i2c,
+                    struct wm8960_data *pdata)
+{
+    const struct device_node *np = i2c->dev.of_node;
+    u32 val32;
+    int i,ret;
+
+    printk("******wm8960_set_pdata_from_of*****\n");
+
+    ret = of_property_read_u32(np,"capless",&val32);
+    if(ret){
+        printk("don't find match capless\n");
+        return -ENOMEM;
+    }
+    printk("**********val32=%d***************\n",val32);
+    pdata->capless = val32;
+    
+
+    return 0;
 }
+#endif
 
 static int wm8960_probe(struct snd_soc_codec *codec)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	struct wm8960_data *pdata = dev_get_platdata(codec->dev);
-	int ret;
-
-	wm8960->set_bias_level = wm8960_set_bias_level_out3;
-
-	if (!pdata) {
-		dev_warn(codec->dev, "No platform data supplied\n");
-	} else {
-		if (pdata->capless)
-			wm8960->set_bias_level = wm8960_set_bias_level_capless;
-	}
-
-	ret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);
-	if (ret < 0) {
-		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-		return ret;
-	}
-
-	ret = wm8960_reset(codec);
-	if (ret < 0) {
-		dev_err(codec->dev, "Failed to issue reset\n");
-		return ret;
-	}
-
-	wm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	/* Latch the update bits */
-	snd_soc_update_bits(codec, WM8960_LINVOL, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_RINVOL, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_LADC, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_RADC, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_LDAC, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_RDAC, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_LOUT1, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_ROUT1, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_LOUT2, 0x100, 0x100);
-	snd_soc_update_bits(codec, WM8960_ROUT2, 0x100, 0x100);
-
-	snd_soc_add_codec_controls(codec, wm8960_snd_controls,
-				     ARRAY_SIZE(wm8960_snd_controls));
-	wm8960_add_widgets(codec);
-
-	return 0;
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    struct wm8960_data *pdata = dev_get_platdata(codec->dev);
+    //struct wm8960_data *pdata = pdata_wm8960;
+    int ret;
+    u16 reg;
+
+    wm8960->set_bias_level = wm8960_set_bias_level_out3;
+
+    if (!pdata) {
+        dev_warn(codec->dev, "No platform data supplied\n");
+    } else {
+        if (pdata->dres > WM8960_DRES_MAX) {
+            dev_err(codec->dev, "Invalid DRES: %d\n", pdata->dres);
+            pdata->dres = 0;
+        }
+
+        if (pdata->capless)
+            wm8960->set_bias_level = wm8960_set_bias_level_capless;
+    }
+    wm8960_codec = codec;
+    ret = snd_soc_codec_set_cache_io(codec, 7, 9, wm8960->control_type);
+    if (ret < 0) {
+        dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+        return ret;
+    }
+
+    ret = wm8960_reset(codec);
+    if (ret < 0) {
+        dev_err(codec->dev, "Failed to issue reset\n");
+        return ret;
+    }
+
+    wm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+    /* Latch the update bits */
+    reg = snd_soc_read(codec, WM8960_LINVOL);
+    snd_soc_write(codec, WM8960_LINVOL, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_RINVOL);
+    snd_soc_write(codec, WM8960_RINVOL, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_LADC);
+    snd_soc_write(codec, WM8960_LADC, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_RADC);
+    snd_soc_write(codec, WM8960_RADC, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_LDAC);
+    snd_soc_write(codec, WM8960_LDAC, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_RDAC);
+    snd_soc_write(codec, WM8960_RDAC, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_LOUT1);
+    snd_soc_write(codec, WM8960_LOUT1, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_ROUT1);
+    snd_soc_write(codec, WM8960_ROUT1, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_LOUT2);
+    snd_soc_write(codec, WM8960_LOUT2, reg | 0x100);
+    reg = snd_soc_read(codec, WM8960_ROUT2);
+    snd_soc_write(codec, WM8960_ROUT2, reg | 0x100);
+#if 1
+    reg = snd_soc_read(codec, WM8960_POWER2);
+    snd_soc_write(codec, WM8960_POWER2, reg | 0x1e0);
+#endif
+
+    snd_soc_add_codec_controls(codec, wm8960_snd_controls,
+                     ARRAY_SIZE(wm8960_snd_controls));
+    wm8960_add_widgets(codec);
+
+    return 0;
 }
 
 /* power down chip */
 static int wm8960_remove(struct snd_soc_codec *codec)
 {
-	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
-	wm8960->set_bias_level(codec, SND_SOC_BIAS_OFF);
-	return 0;
+    wm8960->set_bias_level(codec, SND_SOC_BIAS_OFF);
+    return 0;
 }
 
 static struct snd_soc_codec_driver soc_codec_dev_wm8960 = {
-	.probe =	wm8960_probe,
-	.remove =	wm8960_remove,
-	.suspend =	wm8960_suspend,
-	.resume =	wm8960_resume,
-	.set_bias_level = wm8960_set_bias_level,
+    .probe =    wm8960_probe,
+    .remove =   wm8960_remove,
+    .suspend =  wm8960_suspend,
+    .resume =   wm8960_resume,
+    .set_bias_level = wm8960_set_bias_level,
+    .reg_cache_size = ARRAY_SIZE(wm8960_reg),
+    .reg_word_size = sizeof(u16),
+    .reg_cache_default = wm8960_reg,
 };
 
-static const struct regmap_config wm8960_regmap = {
-	.reg_bits = 7,
-	.val_bits = 9,
-	.max_register = WM8960_PLL4,
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+static int wm8960_i2c_probe(struct i2c_client *i2c,
+                      const struct i2c_device_id *id)
+{
+    struct wm8960_data *pdata = dev_get_platdata(&i2c->dev);
+    struct wm8960_priv *wm8960;
+    int ret;
+
+    wm8960 = kzalloc(sizeof(struct wm8960_priv), GFP_KERNEL);
+    if (wm8960 == NULL)
+        return -ENOMEM;
+
+    i2c_set_clientdata(i2c, wm8960);
+    wm8960->control_type = SND_SOC_I2C;
+
+    /* If no platform data was supplied, create storage for defaults */
+  /*      if (pdata) {
+            wm8960->pdata = pdata;
+        } else {
+            wm8960->pdata = devm_kzalloc(&i2c->dev,
+                        sizeof(struct wm8960_data),
+                        GFP_KERNEL);
+            if (wm8960->pdata == NULL) {
+                dev_err(&i2c->dev, "Failed to allocate pdata\n");
+                return -ENOMEM;
+            }
+            
+            if (i2c->dev.of_node) {
+                ret = wm8960_set_pdata_from_of(i2c, wm8960->pdata);
+                if (ret != 0)
+                    return ret;
+            }
+        }
+    */
+      //  pdata = wm8960->pdata;
+    
+       // pdata_wm8960 = wm8960->pdata;
+
+    ret = snd_soc_register_codec(&i2c->dev,
+            &soc_codec_dev_wm8960, &wm8960_dai, 1);
+    if (ret < 0)
+        kfree(wm8960);
+    return ret;
+}
+static void wm8960_i2c_shutdown(struct i2c_client *client)
+{
+    struct snd_soc_codec *codec = wm8960_codec;
 
-	.reg_defaults = wm8960_reg_defaults,
-	.num_reg_defaults = ARRAY_SIZE(wm8960_reg_defaults),
-	.cache_type = REGCACHE_RBTREE,
+    /* Mute Headphone */
+    snd_soc_update_bits(codec, WM8960_LOUT1, 0x7f, 0);
+    snd_soc_update_bits(codec, WM8960_ROUT1, 0x7f, 0);
+    /*Mute DAC*/
+    snd_soc_update_bits(codec, WM8960_DACCTL1, 1<<3, 1<<3);
+ snd_soc_write(codec, WM8960_RESET, 0x000);//  Reset WM8960
 
-	.volatile_reg = wm8960_volatile,
-};
+    snd_soc_update_bits(codec,24, 0x040, 0);// HPDETECT LOW = Speaker
 
-static int wm8960_i2c_probe(struct i2c_client *i2c,
-			    const struct i2c_device_id *id)
-{
-	struct wm8960_data *pdata = dev_get_platdata(&i2c->dev);
-	struct wm8960_priv *wm8960;
-	int ret;
-
-	wm8960 = devm_kzalloc(&i2c->dev, sizeof(struct wm8960_priv),
-			      GFP_KERNEL);
-	if (wm8960 == NULL)
-		return -ENOMEM;
-
-	wm8960->regmap = devm_regmap_init_i2c(i2c, &wm8960_regmap);
-	if (IS_ERR(wm8960->regmap))
-		return PTR_ERR(wm8960->regmap);
-
-	if (pdata && pdata->shared_lrclk) {
-		ret = regmap_update_bits(wm8960->regmap, WM8960_ADDCTL2,
-					 0x4, 0x4);
-		if (ret != 0) {
-			dev_err(&i2c->dev, "Failed to enable LRCM: %d\n",
-				ret);
-			return ret;
-		}
-	}
-
-	i2c_set_clientdata(i2c, wm8960);
-
-	ret = snd_soc_register_codec(&i2c->dev,
-			&soc_codec_dev_wm8960, &wm8960_dai, 1);
-
-	return ret;
+    snd_soc_update_bits(codec,27, 0x008, 0);// OUT3 buffer Enabled and disabled with HPL and HPR jack detect
+
+    snd_soc_update_bits(codec,48, 0x03A, 0);// JD2 used for Jack Detect Input, GPIO function = jack detect output
 }
 
 static int wm8960_i2c_remove(struct i2c_client *client)
 {
-	snd_soc_unregister_codec(&client->dev);
-	return 0;
+    snd_soc_unregister_codec(&client->dev);
+    kfree(i2c_get_clientdata(client));
+    return 0;
 }
-
+/*
+static const struct of_device_id wm8960_of_dt_match[] = {
+    { .compatible = "asoc,wm8960", },
+    {},
+};
+*/
 static const struct i2c_device_id wm8960_i2c_id[] = {
-	{ "wm8960", 0 },
-	{ }
+    { "wm8960", 0 },
+    { }
 };
 MODULE_DEVICE_TABLE(i2c, wm8960_i2c_id);
 
 static struct i2c_driver wm8960_i2c_driver = {
-	.driver = {
-		.name = "wm8960",
-		.owner = THIS_MODULE,
-	},
-	.probe =    wm8960_i2c_probe,
-	.remove =   wm8960_i2c_remove,
-	.id_table = wm8960_i2c_id,
+    .driver = {
+        .name = "wm8960",
+        .owner = THIS_MODULE,
+        //.of_match_table = wm8960_of_dt_match,
+    },
+    .probe =    wm8960_i2c_probe,
+    .remove =   wm8960_i2c_remove,
+    .shutdown = wm8960_i2c_shutdown,
+    .id_table = wm8960_i2c_id,
 };
+#endif
+
+static int __init wm8960_modinit(void)
+{
+    int ret = 0;
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+    ret = i2c_add_driver(&wm8960_i2c_driver);
+    if (ret != 0) {
+        printk(KERN_ERR "Failed to register WM8960 I2C driver: %d\n",
+               ret);
+    }
+#endif
+    return ret;
+}
+module_init(wm8960_modinit);
 
-module_i2c_driver(wm8960_i2c_driver);
+static void __exit wm8960_exit(void)
+{
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+    i2c_del_driver(&wm8960_i2c_driver);
+#endif
+}
+module_exit(wm8960_exit);
 
 MODULE_DESCRIPTION("ASoC WM8960 driver");
 MODULE_AUTHOR("Liam Girdwood");
-- 
2.19.0

