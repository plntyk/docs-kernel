From c0b46ac5e86b2677dc15aa2dbd14ad53baba2490 Mon Sep 17 00:00:00 2001
From: "qi.duan" <qi.duan@amlogic.com>
Date: Mon, 16 Dec 2013 14:28:37 +0800
Subject: [PATCH 2902/5965] PD #0002 :(2) audio code for kernel 3.10 + m6

---
 include/sound/rt5631.h                 |   32 +
 sound/soc/aml/m6/Kconfig               |   73 ++
 sound/soc/aml/m6/Makefile              |   41 +
 sound/soc/aml/m6/aml.dtd               |   59 +
 sound/soc/aml/m6/aml_alsa_common.h     |   12 +
 sound/soc/aml/m6/aml_audio_hw.c        | 1191 +++++++++++++++++
 sound/soc/aml/m6/aml_audio_hw.h        |  202 +++
 sound/soc/aml/m6/aml_audio_hw_pcm2bt.c |  314 +++++
 sound/soc/aml/m6/aml_audio_hw_pcm2bt.h |   21 +
 sound/soc/aml/m6/aml_dai.c             |  314 +++++
 sound/soc/aml/m6/aml_dai.h             |    6 +
 sound/soc/aml/m6/aml_m6_rt3261.c       |  651 ++++++++++
 sound/soc/aml/m6/aml_m6_rt5631.c       |  536 ++++++++
 sound/soc/aml/m6/aml_m6_wm8960.c       |  624 +++++++++
 sound/soc/aml/m6/aml_m6tv_audio.c      |  338 +++++
 sound/soc/aml/m6/aml_m_dummy.c         |  338 +++++
 sound/soc/aml/m6/aml_mixer.c           |  371 ++++++
 sound/soc/aml/m6/aml_notify.c          |   43 +
 sound/soc/aml/m6/aml_pcm.c             | 1630 ++++++++++++++++++++++++
 sound/soc/aml/m6/aml_pcm.h             |   75 ++
 sound/soc/aml/m6/aml_platform.c        |  573 +++++++++
 sound/soc/aml/m6/aml_platform.h        |   36 +
 sound/soc/aml/m6/aml_platform_pcm2bt.c |  687 ++++++++++
 sound/soc/aml/m6/aml_platform_pcm2bt.h |    6 +
 sound/soc/aml/m6/aml_syno9629_codec.c  | 1213 ++++++++++++++++++
 sound/soc/aml/m6/aml_syno9629_codec.h  |  215 ++++
 sound/soc/aml/m8/Kconfig               |   13 +
 sound/soc/aml/m8/Makefile              |   29 +
 sound/soc/aml/m8/aml.dtd               |   59 +
 sound/soc/aml/m8/aml_alsa_common.h     |   12 +
 sound/soc/aml/m8/aml_audio_hw.c        | 1283 +++++++++++++++++++
 sound/soc/aml/m8/aml_audio_hw.h        |  158 +++
 sound/soc/aml/m8/aml_audio_hw_pcm2bt.c |  314 +++++
 sound/soc/aml/m8/aml_audio_hw_pcm2bt.h |   21 +
 sound/soc/aml/m8/aml_i2s.c             | 1139 +++++++++++++++++
 sound/soc/aml/m8/aml_i2s.h             |   77 ++
 sound/soc/aml/m8/aml_i2s_dai.c         |  376 ++++++
 sound/soc/aml/m8/aml_i2s_dai.h         |    6 +
 sound/soc/aml/m8/aml_m8.c              |  721 +++++++++++
 sound/soc/aml/m8/aml_m_dummy.c         |  360 ++++++
 sound/soc/aml/m8/aml_mixer.c           |  371 ++++++
 sound/soc/aml/m8/aml_notify.c          |   43 +
 sound/soc/aml/m8/aml_pcm.c             |  698 ++++++++++
 sound/soc/aml/m8/aml_pcm.h             |   23 +
 sound/soc/aml/m8/aml_pcm_dai.c         |  268 ++++
 sound/soc/aml/m8/aml_pcm_dai.h         |    6 +
 sound/soc/aml/m8/aml_spdif_codec.c     |  101 ++
 sound/soc/aml/m8/aml_spdif_dai.c       |  454 +++++++
 sound/soc/aml/m8/aml_spdif_dai.h       |   16 +
 49 files changed, 16149 insertions(+)
 create mode 100644 include/sound/rt5631.h
 create mode 100644 sound/soc/aml/m6/Kconfig
 create mode 100644 sound/soc/aml/m6/Makefile
 create mode 100644 sound/soc/aml/m6/aml.dtd
 create mode 100644 sound/soc/aml/m6/aml_alsa_common.h
 create mode 100644 sound/soc/aml/m6/aml_audio_hw.c
 create mode 100644 sound/soc/aml/m6/aml_audio_hw.h
 create mode 100644 sound/soc/aml/m6/aml_audio_hw_pcm2bt.c
 create mode 100644 sound/soc/aml/m6/aml_audio_hw_pcm2bt.h
 create mode 100644 sound/soc/aml/m6/aml_dai.c
 create mode 100644 sound/soc/aml/m6/aml_dai.h
 create mode 100644 sound/soc/aml/m6/aml_m6_rt3261.c
 create mode 100644 sound/soc/aml/m6/aml_m6_rt5631.c
 create mode 100644 sound/soc/aml/m6/aml_m6_wm8960.c
 create mode 100644 sound/soc/aml/m6/aml_m6tv_audio.c
 create mode 100644 sound/soc/aml/m6/aml_m_dummy.c
 create mode 100644 sound/soc/aml/m6/aml_mixer.c
 create mode 100644 sound/soc/aml/m6/aml_notify.c
 create mode 100644 sound/soc/aml/m6/aml_pcm.c
 create mode 100644 sound/soc/aml/m6/aml_pcm.h
 create mode 100644 sound/soc/aml/m6/aml_platform.c
 create mode 100644 sound/soc/aml/m6/aml_platform.h
 create mode 100644 sound/soc/aml/m6/aml_platform_pcm2bt.c
 create mode 100644 sound/soc/aml/m6/aml_platform_pcm2bt.h
 create mode 100644 sound/soc/aml/m6/aml_syno9629_codec.c
 create mode 100644 sound/soc/aml/m6/aml_syno9629_codec.h
 create mode 100644 sound/soc/aml/m8/Kconfig
 create mode 100644 sound/soc/aml/m8/Makefile
 create mode 100644 sound/soc/aml/m8/aml.dtd
 create mode 100644 sound/soc/aml/m8/aml_alsa_common.h
 create mode 100644 sound/soc/aml/m8/aml_audio_hw.c
 create mode 100644 sound/soc/aml/m8/aml_audio_hw.h
 create mode 100644 sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
 create mode 100644 sound/soc/aml/m8/aml_audio_hw_pcm2bt.h
 create mode 100644 sound/soc/aml/m8/aml_i2s.c
 create mode 100644 sound/soc/aml/m8/aml_i2s.h
 create mode 100644 sound/soc/aml/m8/aml_i2s_dai.c
 create mode 100644 sound/soc/aml/m8/aml_i2s_dai.h
 create mode 100644 sound/soc/aml/m8/aml_m8.c
 create mode 100644 sound/soc/aml/m8/aml_m_dummy.c
 create mode 100644 sound/soc/aml/m8/aml_mixer.c
 create mode 100644 sound/soc/aml/m8/aml_notify.c
 create mode 100644 sound/soc/aml/m8/aml_pcm.c
 create mode 100644 sound/soc/aml/m8/aml_pcm.h
 create mode 100644 sound/soc/aml/m8/aml_pcm_dai.c
 create mode 100644 sound/soc/aml/m8/aml_pcm_dai.h
 create mode 100644 sound/soc/aml/m8/aml_spdif_codec.c
 create mode 100644 sound/soc/aml/m8/aml_spdif_dai.c
 create mode 100644 sound/soc/aml/m8/aml_spdif_dai.h

diff --git a/include/sound/rt5631.h b/include/sound/rt5631.h
new file mode 100644
index 000000000000..ed5889a5941f
--- /dev/null
+++ b/include/sound/rt5631.h
@@ -0,0 +1,32 @@
+/**
+ * struct rt5631_platform_data - platform-specific RT5631 data
+ */
+
+#ifndef _RT5631_H_
+#define _RT5631_H_
+
+/* platform speaker watt */
+#define RT5631_SPK_1_0W     0
+#define RT5631_SPK_0_5W     1
+#define RT5631_SPK_1_5W     2
+
+/* platform speaker mode */
+#define RT5631_SPK_STEREO   0
+#define RT5631_SPK_LEFT     1
+#define RT5631_SPK_RIGHT    2
+
+/* platform mic input mode */
+#define RT5631_MIC_DIFFERENTIAL     0
+#define RT5631_MIC_SINGLEENDED      1
+
+struct rt5631_platform_data {
+    int (*hp_detect)(void);
+    void (*device_init)(void);
+    void (*device_uninit)(void); 
+
+    int  spk_watt;
+    int  spk_output;
+    int  mic_input;
+};
+
+#endif
diff --git a/sound/soc/aml/m6/Kconfig b/sound/soc/aml/m6/Kconfig
new file mode 100644
index 000000000000..48f2722d57a6
--- /dev/null
+++ b/sound/soc/aml/m6/Kconfig
@@ -0,0 +1,73 @@
+config SND_AML_M6_RT5631
+	tristate "M6 evaluation board with RT5631"
+	depends on SND_AML_M6_SOC
+	select SND_SOC_RT5631 if SND_AML_M6_RT5631
+
+config SND_AML_M6_RT5616
+	tristate "M6 evaluation board with RT5616"
+	depends on SND_AML_M6_SOC
+	select SND_SOC_RT5616 if SND_AML_M6_RT5616
+
+config SND_AML_M6_RT3261
+	tristate "M6 evaluation board with RT3261"
+	depends on SND_AML_M6_SOC
+	select SND_SOC_RT3261 if SND_AML_M6_RT3261
+	select SND_HWDEP
+config SND_AML_M6_WM8960
+	tristate "M6 evaluation board with WM8960"
+	depends on SND_AML_M6_SOC
+	select SND_SOC_WM8960 if SND_AML_M6_WM8960
+config SND_AML_M6_PCM2BT
+	tristate "M6 evaluation board with PCM2BT"
+	depends on SND_AML_M6_SOC
+	select SND_SOC_PCM2BT
+	
+config SND_AML_M_DUMMY_CODEC
+    tristate "AML M series board with DUMMY_CODEC"
+    depends on SND_AML_M6_SOC
+    select SND_SOC_DUMMY_CODEC if SND_AML_M_DUMMY_CODEC
+config SND_AML_M6TV_AUDIO_CODEC
+	tristate "AML M6TV evaluation board,this must be selected for all m6tv board"
+	depends on SND_AML_M6_SOC
+config SND_AML_M6TV_SYNOPSYS9629_CODEC
+	tristate "AML M6TV  board with internal syno9629 codec"
+	depends on SND_AML_M6TV_AUDIO_CODEC 
+config SND_AML_M6TV_RT5631
+	tristate "AML M6TV board with RT5631 codec"
+	depends on SND_AML_M6TV_AUDIO_CODEC
+	select SND_SOC_RT5631 if SND_AML_M6TV_RT5631	
+config SND_AML_M6TV_STA380
+	tristate "AML M6TV board with STA380 codec"
+	depends on SND_AML_M6TV_AUDIO_CODEC
+	select SND_SOC_STA380 if SND_AML_M6TV_STA380	
+config SND_AML_M6TV_TAS5711
+	tristate "AML M6TV board with TAS5711 codec"	
+	depends on SND_AML_M6TV_AUDIO_CODEC	
+	select SND_SOC_TAS5711 if SND_AML_M6TV_TAS5711
+if SND_AML_M6TV_TAS5711
+choice        
+	prompt "TAS5711 work mode"        
+	default TAS5711_2_CHANNEL
+config TAS5711_2_CHANNEL        
+	bool "2 BTL channel mode"
+config TAS5711_2_PLUS_1_CHANNEL
+	bool "2.1 channel mode"
+config TAS5711_2_SUBWOOFER_CHANNEL        
+	bool "2 BTL subwoofer channel"
+endchoice
+endif
+config SND_AML_M6TV_TAS5707
+	tristate "AML M6TV board with TAS5707 codec"	
+	depends on SND_AML_M6TV_AUDIO_CODEC	
+	select SND_SOC_TAS5707 if SND_AML_M6TV_TAS5707
+if SND_AML_M6TV_TAS5707
+choice        
+	prompt "TAS5707 work mode"        
+	default TAS5707_2_CHANNEL
+config TAS5707_2_CHANNEL        
+	bool "2 BTL channel mode"
+config TAS5707_2_SUBWOOFER_CHANNEL        
+	bool "2 BTL subwoofer channel"
+endchoice
+endif
+
diff --git a/sound/soc/aml/m6/Makefile b/sound/soc/aml/m6/Makefile
new file mode 100644
index 000000000000..9fad46a1ac6e
--- /dev/null
+++ b/sound/soc/aml/m6/Makefile
@@ -0,0 +1,41 @@
+# AML Platform Support
+snd-soc-aml-pcm-objs := aml_pcm.o
+snd-soc-aml-platform-pcm2bt-objs := aml_platform_pcm2bt.o
+snd-soc-aml-dai-objs := aml_dai.o
+snd-soc-aml-hw-objs  := aml_audio_hw.o
+snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
+snd-soc-aml-platform-objs := aml_platform.o
+
+obj-$(CONFIG_SND_AML_M6_SOC) += snd-soc-aml-pcm.o
+obj-$(CONFIG_SND_AML_M6_SOC) += snd-soc-aml-dai.o
+obj-$(CONFIG_SND_AML_M6_SOC) += snd-soc-aml-hw.o
+obj-$(CONFIG_SND_AML_M6_SOC) += aml_notify.o
+obj-$(CONFIG_SND_AML_M6_SOC) += snd-soc-aml-platform.o
+obj-$(CONFIG_SND_AML_M6_SOC) += snd-soc-aml-platform-pcm2bt.o
+obj-$(CONFIG_SND_AML_M6_SOC) += snd-soc-aml-hw-pcm2bt.o
+
+#AML M6 Machine support
+snd-soc-aml-m6-rt5631-objs := aml_m6_rt5631.o
+obj-$(CONFIG_SND_AML_M6_RT5631) += snd-soc-aml-m6-rt5631.o
+
+#AML M6 Machine support
+snd-soc-aml-m6-rt5616-objs := aml_m6_rt5616.o
+obj-$(CONFIG_SND_AML_M6_RT5616) += snd-soc-aml-m6-rt5616.o
+
+#AML M6 Machine support
+snd-soc-aml-m6-rt3261-objs := aml_m6_rt3261.o
+obj-$(CONFIG_SND_AML_M6_RT3261) += snd-soc-aml-m6-rt3261.o
+snd-soc-aml-m6-wm8960-objs := aml_m6_wm8960.o
+obj-$(CONFIG_SND_AML_M6_WM8960) += snd-soc-aml-m6-wm8960.o
+
+#AML M series with dummy codec support
+snd-soc-aml-m-dummy-objs := aml_m_dummy.o
+obj-$(CONFIG_SND_AML_M_DUMMY_CODEC) += snd-soc-aml-m-dummy.o
+
+# AML M6TV Machine support
+snd-soc-aml-m6tv-audio-objs := aml_m6tv_audio.o
+snd-soc-aml-syno9629-codec-objs := aml_syno9629_codec.o
+obj-$(CONFIG_SND_AML_M6TV_AUDIO_CODEC) += snd-soc-aml-m6tv-audio.o
+obj-$(CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC) += snd-soc-aml-syno9629-codec.o
+
+
diff --git a/sound/soc/aml/m6/aml.dtd b/sound/soc/aml/m6/aml.dtd
new file mode 100644
index 000000000000..7e3011a4642c
--- /dev/null
+++ b/sound/soc/aml/m6/aml.dtd
@@ -0,0 +1,59 @@
+#ifdef CONFIG_SND_AML_SOC
+//$$ DEVICE="audio_platform"
+//$$ L2 PROP_STR = "status"
+    audio_platform{
+        compatible = "amlogic,aml-audio";
+        dev_name = "aml-audio.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_dai"
+//$$ L2 PROP_STR = "status"
+    audio_dai{
+        compatible = "amlogic,aml-dai";
+        dev_name = "aml-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_m8_audio"
+//$$ L2 PROP_STR = "status"
+    audio_m8_audio{
+        compatible = "amlogic,m8_audio_codec";
+        dev_name = "aml_m8_codec.0";
+        status = "okay";
+    };
+#endif        
+
+#ifdef CONFIG_SND_AML_M8
+//$$ DEVICE="aml_m8_sound_card"
+//$$ L2 PROP_STR = "aml,sound_card"
+//$$ L2 PROP_STR = "aml,codec_dai"
+//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
+//$$ L2 PROP_STR = "mute_gpio"
+//$$ L2 PROP_U32 5 = "hp_paraments"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Audio_pin_0_match" = "pinctrl-0"
+    aml_m8_sound_card{
+        compatible = "sound_card, aml_snd_m8";
+        aml,sound_card = "AML-M8AUDIO";
+        aml,codec_dai = "AML-M8";
+        aml,audio-routing =
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
+        mute_gpio = "GPIOY_15";
+        //mute_inv;
+        hp_paraments = <800 713 300 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
+        status = "okay";
+        
+    };
+#endif
+
+
+
diff --git a/sound/soc/aml/m6/aml_alsa_common.h b/sound/soc/aml/m6/aml_alsa_common.h
new file mode 100644
index 000000000000..31d8a768faa4
--- /dev/null
+++ b/sound/soc/aml/m6/aml_alsa_common.h
@@ -0,0 +1,12 @@
+#ifndef __AML_ALSA_COMMOM_H__
+#define __AML_ALSA_COMMON_H__
+
+#define VOLUME_SCALE	100
+#define VOLUME_SHIFT	15
+
+extern int aml_alsa_create_ctrl(struct snd_card *card, void *p_value);
+
+extern int get_mixer_output_volume(void);
+
+extern int set_mixer_output_volume(int volume);
+#endif
diff --git a/sound/soc/aml/m6/aml_audio_hw.c b/sound/soc/aml/m6/aml_audio_hw.c
new file mode 100644
index 000000000000..90df8bc52a8d
--- /dev/null
+++ b/sound/soc/aml/m6/aml_audio_hw.c
@@ -0,0 +1,1191 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <mach/am_regs.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+//#include <mach/utils.h>
+#endif
+
+#include "aml_audio_hw.h"
+
+#ifndef MREG_AIU_958_chstat0
+#define AIU_958_chstat0	AIU_958_CHSTAT_L0
+#endif
+
+#ifndef MREG_AIU_958_chstat1
+#define AIU_958_chstat1	AIU_958_CHSTAT_L1
+#endif
+
+
+unsigned ENABLE_IEC958 = 1;
+unsigned IEC958_MODE   = AIU_958_MODE_PCM16;
+unsigned I2S_MODE      = AIU_I2S_MODE_PCM16;
+
+
+int  audio_in_buf_ready = 0;
+int audio_out_buf_ready = 0;
+
+unsigned int IEC958_bpf = 0x7dd;
+unsigned int IEC958_brst = 0xc;
+unsigned int IEC958_length = 0x7dd*8;
+unsigned int IEC958_padsize = 0x8000;
+unsigned int IEC958_mode = 1;
+unsigned int IEC958_syncword1 = 0x7ffe;
+unsigned int IEC958_syncword2 = 0x8001;
+unsigned int IEC958_syncword3 = 0;
+unsigned int IEC958_syncword1_mask = 0;
+unsigned int IEC958_syncword2_mask = 0;
+unsigned int IEC958_syncword3_mask = 0xffff;
+unsigned int IEC958_chstat0_l = 0x1902 ;
+unsigned int IEC958_chstat0_r = 0x1902 ;
+unsigned int IEC958_chstat1_l = 0x200;
+unsigned int IEC958_chstat1_r = 0x200;
+unsigned int IEC958_mode_raw = 0;
+/*
+ 0 --  other formats except(DD,DD+,DTS)
+ 1 --  DTS
+ 2 --  DD
+ 3 -- DTS with 958 PCM RAW package mode
+ 4 -- DD+
+*/
+unsigned int IEC958_mode_codec;
+/*
+bit 0:soc in slave mode for adc;
+bit 1:audio in data source from spdif in;
+bit 2:adc & spdif in work at the same time;
+*/
+unsigned audioin_mode = I2SIN_MASTER_MODE;
+
+EXPORT_SYMBOL(IEC958_bpf);
+EXPORT_SYMBOL(IEC958_brst);
+EXPORT_SYMBOL(IEC958_length);
+EXPORT_SYMBOL(IEC958_padsize);
+EXPORT_SYMBOL(IEC958_mode);
+EXPORT_SYMBOL(IEC958_syncword1);
+EXPORT_SYMBOL(IEC958_syncword2);
+EXPORT_SYMBOL(IEC958_syncword3);
+EXPORT_SYMBOL(IEC958_syncword1_mask);
+EXPORT_SYMBOL(IEC958_syncword2_mask);
+EXPORT_SYMBOL(IEC958_syncword3_mask);
+EXPORT_SYMBOL(IEC958_chstat0_l);
+EXPORT_SYMBOL(IEC958_chstat0_r);
+EXPORT_SYMBOL(IEC958_chstat1_l);
+EXPORT_SYMBOL(IEC958_chstat1_r);
+EXPORT_SYMBOL(IEC958_mode_raw);
+EXPORT_SYMBOL(IEC958_mode_codec);
+
+// Bit 3:  mute constant
+//         0 => 'h0000000
+//         1 => 'h800000
+unsigned int dac_mute_const = 0x800000;
+
+/*
+                                fIn * (M)
+            Fout   =  -----------------------------
+                      		(N) * (OD+1) * (XD)
+*/
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+int audio_clock_config_table[][12][2]=
+{
+	/*{HIU Reg , XD - 1)
+	   //7.875k, 8K, 11.025k, 12k, 16k, 22.05k, 24k, 32k, 44.1k, 48k, 96k, 192k
+	*/
+	{
+	//256
+#if OVERCLOCK == 0
+		{0x0004f880, (50-1)},  // 32
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8	
+		{0x0005e965, (40-1)}, //44.1	
+		{0x0004c9a0,	(50-1)},	//48K
+#else		
+		{0x0004cdf3, (42-1)},  // 44.1
+		{0x0007c4e6, (23-1)},  // 48
+#endif	
+		{0x0006d0a4, (13-1)},  // 96
+		{0x0004e15a, (9 -1)},   // 192
+		{0x0007f400, (125-1)}, // 8k
+		{0x0006c6f6, (116-1)}, // 11.025
+		{0x0007e47f, (86-1)},  // 12
+		{0x0004f880, (100-1)}, // 16
+		{0x0004c4a4, (87-1)},  // 22.05
+		{0x0007e47f, (43-1)},  // 24
+		{0x0007f3f0, (127-1)}, // 7875
+#else
+	//512FS
+		{0x0004f880, (25-1)},  // 32
+		{0x0004cdf3, (21-1)},  // 44.1
+		{0x0006d0a4, (13-1)},  // 48
+		{0x0004e15a, (9 -1)},  // 96
+		{0x0006f207, (3 -1)},   // 192
+		{0x0004f880, (100-1)}, // 8k
+		{0x0004c4a4, (87-1)}, // 11.025
+		{0x0007e47f, (43-1)},  // 12
+		{0x0004f880, (50-1)}, // 16
+		{0x0004cdf3, (42-1)},  // 22.05
+		{0x0007c4e6, (23-1)},  // 24
+		{0x0006e1b6, (76-1)}, // 7875
+#endif
+	},
+	{
+	//384
+		{0x0007c4e6, (23-1)},  // 32
+		{0x0004c4a4, (29-1)},  // 44.1
+		{0x0004cb18, (26-1)},  // 48
+		{0x0004cb18, (13-1)},  // 96
+		{0x0004e15a, (6 -1)},   // 192
+		{0x0007e47f, (86-1)},  // 8k
+		{0x0007efa5, (61-1)},  // 11.025
+		{0x0006de98, (67-1)},  // 12
+		{0x0007e47f, (43-1)},  // 16
+		{0x0004c4a4, (58-1)},  // 22.05
+		{0x0004c60e, (53-1)},  // 24
+		{0x0007fdfa, (83-1)},  // 7875
+	}
+};
+#else
+int audio_clock_config_table[][11][2]=
+{
+  // 128*Fs
+  //
+	/*{M, N, OD, XD-1*/
+	{
+	//24M
+        {(64<<0) | (3<<9) | (0<<14) , (125-1)}, // 32K, 4.096M
+#if OVERCLOCK==0
+        {(147<<0) | (5<<9) | (0<<14) , (125-1)}, // 44.1K, 5.6448M
+        {(32<<0) | (1<<9) | (0<<14) , (125-1)}, // 48K, 6.144M
+#else
+        {(143<<0) | (8<<9) | (0<<14) , (19-1)}, // 44.1K, 5.6448M*4=22.5792M
+        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, // 48K, 6.144M*4=24.576M
+#endif
+        {(128<<0) | (5<<9) | (1<<14) , (25-1)}, // 96K, 12.288M
+        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, //192K, 24.576M
+        {(64<<0) | (3<<9) | (1<<14) , (250-1)}, // 8K, 1.024M
+        {(147<<0) | (5<<9) | (1<<14) , (250-1)}, //11.025K,1.4112M
+        {(32<<0) | (1<<9) | (1<<14) , (250-1)}, // 12K, 1.536M
+        {(64<<0) | (3<<9) | (1<<14) , (125-1)}, // 16K, 2.048M
+        {(147<<0) | (5<<9) | (1<<14) , (125-1)}, //22.050K, 2.8224M
+        {(32<<0) | (1<<9) | (1<<14) , (125-1)}, // 24K, 3.072M
+	},
+	{
+	//25M
+        {(29<<0) | (1<<9) | (0<<14) , (177-1)}, // 32K, 4.096M
+#if OVERCLOCK==0
+        {(21<<0) | (1<<9) | (0<<14) , (93-1)}, // 44.1K, 5.6448M
+        {(29<<0) | (1<<9) | (1<<14) , (59-1)}, // 48K, 6.144M
+#else
+        {(28<<0) | (1<<9) | (0<<14) , (31-1)}, // 44.1K, 5.6448M*4=22.5792M
+        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, // 48K, 6.144M*4=24.576M
+#endif
+        {(29<<0) | (1<<9) | (0<<14) , (59-1)}, // 96K, 12.288M
+        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, //192K, 24.576M
+        {(58<<0) | (3<<9) | (1<<14) , (236-1)}, // 8K, 1.024M
+        {(162<<0) | (7<<9) | (1<<14) , (205-1)}, //11.025K,1.4112M
+        {(29<<0) | (1<<9) | (1<<14) , (236-1)}, // 12K, 1.536M
+        {(29<<0) | (1<<9) | (1<<14) , (177-1)}, // 16K, 2.048M
+        {(162<<0) | (7<<9) | (0<<14) , (205-1)}, //22.050K, 2.8224M
+        {(29<<0) | (1<<9) | (1<<14) , (118-1)}, // 24K, 3.072M
+	}
+};
+#endif
+
+
+void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
+{
+	printk("====== %s ======\n",__FUNCTION__);
+    WRITE_MPEG_REG(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
+    WRITE_MPEG_REG(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+    if(channel == 8)
+		WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 256); 
+	else
+    WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);   //this is for 16bit 2 channel
+
+    WRITE_MPEG_REG(AIU_I2S_MISC,		0x0004);	// Hold I2S
+	WRITE_MPEG_REG(AIU_I2S_MUTE_SWAP,	0x0000);	// No mute, no swap
+	// As the default amclk is 24.576MHz, set i2s and iec958 divisor appropriately so as not to exceed the maximum sample rate.
+	WRITE_MPEG_REG(AIU_I2S_MISC,		0x0010 );	// Release hold and force audio data to left or right
+
+	if(channel == 8){
+		printk(" %s channel == 8\n",__FUNCTION__);
+	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
+								(0xff << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+								(0xff << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+		}
+	else 
+	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
+								(0x3 << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+								(0x3 << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+
+    // 16 bit PCM mode
+    //  WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
+	// Set init high then low to initilize the I2S memory logic
+	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1 );
+	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1 );
+
+	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
+	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
+
+    audio_out_buf_ready = 1;
+}
+
+void audio_set_958outbuf(u32 addr, u32 size,int flag)
+{
+    if (ENABLE_IEC958) {
+        WRITE_MPEG_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+	  	if(READ_MPEG_REG(AIU_MEM_IEC958_START_PTR) == READ_MPEG_REG(AIU_MEM_I2S_START_PTR)){
+			WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, READ_MPEG_REG(AIU_MEM_I2S_RD_PTR));
+		}
+		else
+        WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
+        if(flag == 0){
+          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);    // this is for 16bit 2 channel
+        }else{
+          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 1);    // this is for RAW mode
+        }
+
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
+
+        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
+        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
+    }
+}
+/*
+i2s mode 0: master 1: slave
+*/
+static void i2sin_fifo0_set_buf(u32 addr, u32 size,u32 i2s_mode)
+{
+	unsigned char  mode = 0;
+	if(i2s_mode &I2SIN_SLAVE_MODE)
+		mode = 1;
+	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(1<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
+									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
+								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+		    						|(0<<16)	//to DDR
+                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(0<<17)    // Overflow Interrupt mask
+                                                       |(0<<18)    // Audio in INT
+			                                	//|(1<<19)	//hold 0 enable
+								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
+				  );
+
+    WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,    0 << 4                       // fifo0_dest_sel
+                                       | 2 << 2                       // fifo0_din_byte_num
+                                       | 0 << 0);                      // fifo0_din_pos
+
+
+	WRITE_MPEG_REG(AUDIN_I2SIN_CTRL, //(0<<I2SIN_SIZE)			///*bit8*/  16bit
+									 (3<<I2SIN_SIZE)
+									|(1<<I2SIN_CHAN_EN)		/*bit10~13*/ //2 channel
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+									|(0<<I2SIN_POS_SYNC)
+#else
+									|(1<<I2SIN_POS_SYNC)
+#endif
+									|(1<<I2SIN_LRCLK_SKEW)
+                                    				|(1<<I2SIN_LRCLK_INVT)
+									|(!mode<<I2SIN_CLK_SEL)
+									|(!mode<<I2SIN_LRCLK_SEL)
+				    				|(!mode<<I2SIN_DIR)
+				  );
+
+}
+static void spdifin_fifo1_set_buf(u32 addr, u32 size)
+{
+	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffffff);
+	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(0<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
+									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
+								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+		    						|(0<<16)	//to DDR
+                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(0<<17)    // Overflow Interrupt mask
+                                                       |(0<<18)    // Audio in INT
+			                                	//|(1<<19)	//hold 0 enable
+								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
+				  );
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,0xc);
+}
+void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode)
+{
+	if(i2s_mode&SPDIFIN_MODE){ //spdif in ,use fifo1
+		printk("spdifin_fifo1_set_buf \n");			
+		spdifin_fifo1_set_buf(addr,size);
+	}
+	else{
+		printk("i2sin_fifo0_set_buf \n");		
+		i2sin_fifo0_set_buf(addr,size,i2s_mode);
+	}	
+       audio_in_buf_ready = 1;
+
+}
+void audio_in_spdif_set_buf(u32 addr, u32 size)
+{
+}
+//extern void audio_in_enabled(int flag);
+
+void audio_in_i2s_enable(int flag)
+{
+  	int rd = 0, start=0;
+	if(flag){
+          /* reset only when start i2s input */
+reset_again:
+	     WRITE_MPEG_REG_BITS(AUDIN_FIFO0_CTRL, 1, 1, 1); // reset FIFO 0
+            WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 0);
+            rd = READ_MPEG_REG(AUDIN_FIFO0_PTR);
+            start = READ_MPEG_REG(AUDIN_FIFO0_START);
+            if(rd != start){
+              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
+              goto reset_again;
+            }
+		if(audioin_mode == 	SPDIFIN_MODE)
+			WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));
+		else
+			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 1, I2SIN_EN, 1);
+
+	}else{
+		if(audioin_mode == 	SPDIFIN_MODE)	
+			WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));
+		else
+			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 0, I2SIN_EN, 1);
+	}
+}
+
+int if_audio_in_i2s_enable()
+{
+	return READ_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, I2SIN_EN, 1);
+}
+
+void audio_in_spdif_enable(int flag)
+{
+  int rd = 0, start=0;
+
+	if(flag){
+reset_again:
+#if 0	
+	     WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1); // reset FIFO 0
+            WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
+            rd = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+            start = READ_MPEG_REG(AUDIN_FIFO1_START);
+            if(rd != start){
+              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
+              goto reset_again;
+            }
+#endif			
+		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));		
+	}else{
+		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));				
+	}
+}
+unsigned int audio_in_i2s_rd_ptr(void)
+{
+	unsigned int val;
+	val = READ_MPEG_REG(AUDIN_FIFO0_RDPTR);
+	printk("audio in i2s rd ptr: %x\n", val);
+	return val;
+}
+unsigned int audio_in_i2s_wr_ptr(void)
+{
+	unsigned int val;
+      WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 1);
+	val = READ_MPEG_REG(AUDIN_FIFO0_PTR);
+	return (val)&(~0x3F);
+	//return val&(~0x7);
+}
+void audio_in_i2s_set_wrptr(unsigned int val)
+{
+	WRITE_MPEG_REG(AUDIN_FIFO0_RDPTR, val);
+}
+
+void audio_set_i2s_mode(u32 mode)
+{
+    const unsigned short mask[4] = {
+        0x303,                  /* 2x16 */
+        0x303,                  /* 2x24 */
+        0x303,                 /* 8x24 */
+        0x303,                  /* 2x32 */
+    };
+
+    if (mode < sizeof(mask)/ sizeof(unsigned short)) {
+       /* four two channels stream */
+        WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 1);
+
+        if (mode == AIU_I2S_MODE_PCM16) {
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 0, 5, 1);
+        } else if(mode == AIU_I2S_MODE_PCM32){
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
+        }else if(mode == AIU_I2S_MODE_PCM24){
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
+        }
+
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
+
+        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1);
+        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1);
+
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, mask[mode], 0,
+                                16);
+            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
+            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
+        }
+    }
+}
+
+/**
+ *  if normal clock, i2s clock is twice of 958 clock, so the divisor for i2s is 8, but 4 for 958
+ *  if over clock, the devisor for i2s is 8, but for 958 should be 1, because 958 should be 4 times speed according to i2s
+ *  This is dolby digital plus's spec
+ * */
+
+void audio_util_set_dac_format(unsigned format)
+{
+  	WRITE_MPEG_REG(AIU_CLK_CTRL,		 (0 << 12) | // 958 divisor more, if true, divided by 2, 4, 6, 8.
+							(1 <<  8) | // alrclk skew: 1=alrclk transitions on the cycle before msb is sent
+							(1 <<  6) | // invert aoclk
+							(1 <<  7) | // invert lrclk
+#if OVERCLOCK == 1
+							(3 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+							(3 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#else
+							(1 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+							(2 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#endif
+							(1 <<  1) | // enable 958 clock
+							(1 <<  0)); // enable I2S clock
+    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
+    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
+    }
+ 	if(dac_mute_const == 0x800000)
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
+    else
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
+	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel
+}
+
+// iec958 and i2s clock are separated after M6TV.
+void audio_util_set_dac_958_format(unsigned format)
+{
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,0,12,1);// 958 divisor more, if true, divided by 2, 4, 6, 8
+#if IEC958_OVERCLOCK == 1
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+#else
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+#endif.
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,1,1);// enable 958 clock
+}
+
+void audio_util_set_dac_i2s_format(unsigned format)
+{	
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,6,1);//invert aoclk
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,7,1);//invert lrclk
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,8,2);// alrclk skew: 1=alrclk transitions on the cycle before msb is sent
+#if OVERCLOCK == 1
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,2,2);// i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#else
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,2,2,2); // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#endif
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,0,1);// enable I2S clock
+	
+    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
+    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
+    }
+ 	if(dac_mute_const == 0x800000)
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
+    else
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
+	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel	
+}
+
+extern unsigned int get_ddr_pll_clk(void);
+
+void audio_set_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+   // if (fs_config == AUDIO_CLK_256FS) {
+   if(1){
+		int index=0;
+		switch(freq)
+		{
+			case AUDIO_CLK_FREQ_192:
+				index=4;
+				break;
+			case AUDIO_CLK_FREQ_96:
+				index=3;
+				break;
+			case AUDIO_CLK_FREQ_48:
+				index=2;
+				break;
+			case AUDIO_CLK_FREQ_441:
+				index=1;
+				break;
+			case AUDIO_CLK_FREQ_32:
+				index=0;
+				break;
+			case AUDIO_CLK_FREQ_8:
+				index = 5;
+				break;
+			case AUDIO_CLK_FREQ_11:
+				index = 6;
+				break;
+			case AUDIO_CLK_FREQ_12:
+				index = 7;
+				break;
+			case AUDIO_CLK_FREQ_16:
+				index = 8;
+				break;
+			case AUDIO_CLK_FREQ_22:
+				index = 9;
+				break;
+			case AUDIO_CLK_FREQ_24:
+				index = 10;
+				break;
+			default:
+				index=0;
+				break;
+		};
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+	// get system crystal freq
+		clk=clk_get_sys("clk_xtal", NULL);
+		if(!clk)
+		{
+			printk(KERN_ERR "can't find clk %s for AUDIO PLL SETTING!\n\n","clk_xtal");
+			//return -1;
+		}
+		else
+		{
+			xtal=clk_get_rate(clk);
+			xtal=xtal/1000000;
+			if(xtal>=24 && xtal <=25)/*current only support 24,25*/
+			{
+				xtal-=24;
+			}
+			else
+			{
+				printk(KERN_WARNING "UNsupport xtal setting for audio xtal=%d,default to 24M\n",xtal);
+				xtal=0;
+			}
+		}
+
+		audio_clock_config = audio_clock_config_table[xtal];
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+#endif
+
+#ifdef CONFIG_SND_AML_M3
+	if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==516000000)&&(index=2))) // 48k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 516/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 48k clock from ddr pll %dM\n", 516);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==508000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 45-1, 0, 8); // 508/45
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 508);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==486000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 43-1, 0, 8); // 486/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 486);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==474000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 474/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 474);
+		return;
+	}
+#endif
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+
+//#ifdef CONFIG_SND_AML_M3
+#ifdef CONFIG_ARCH_MESON3
+	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL2, 0x065e31ff);
+	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL3, 0x9649a941);
+	// select Audio PLL as MCLK source
+	//WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 9));
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 9, 3);
+	//WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 25-1, 0, 8);
+
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 13-1, 0, 8);
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+  WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+#endif
+
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+    // Put the PLL to sleep
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15));//found
+
+//#ifdef CONFIG_SND_AML_M3
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
+	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+#endif
+    // Bring out of reset but keep bypassed to allow to stablize
+    //Wr( HHI_AUD_PLL_CNTL, (1 << 15) | (0 << 14) | (hiu_reg & 0x3FFF) );
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, (1 << 15) | (audio_clock_config[index][0] & 0x7FFF) );//found
+    // Set the XD value
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, (READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(0xff << 0)) | audio_clock_config[index][1]);//found
+    // delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+    // Bring the PLL out of sleep
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));//found
+
+    // gate the clock on
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));//found
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));// gate audac_clkpi
+#endif
+#else // endif CONFIG_ARCH_MESON6
+    WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+
+	// Select Multi-Phase PLL2 as clock source
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 3);
+
+	// Configure Multi-Phase PLL2
+	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
+	// Set the XD value
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV
+	//Audio DAC Clock enable
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
+/* ADC clock  configuration */
+// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 8, 1);
+
+    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 3, 9, 2);
+
+    // Set pll over mclk ratio
+    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
+#if OVERCLOCK == 0
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 0, 8);
+#else
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)*2-1, 0, 8);
+#endif
+
+    // Set mclk over sclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
+
+    // Set sclk over lrclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);
+
+    // Enable sclk
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
+    // Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 8, 1);
+#endif
+
+#endif // endif CONFIG_ARCH_MESON6
+    // delay 2uS
+	//udelay(2);
+	for (i = 0; i < 200000; i++) ;
+
+    } else if (fs_config == AUDIO_CLK_384FS) {
+    }
+}
+
+// iec958 and i2s clock are separated after M6TV. Use PLL2 for i2s DAC & ADC clock
+void audio_set_i2s_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+	int index=0;
+	switch(freq)
+	{
+		case AUDIO_CLK_FREQ_192:
+			index=4;
+			break;
+		case AUDIO_CLK_FREQ_96:
+			index=3;
+			break;
+		case AUDIO_CLK_FREQ_48:
+			index=2;
+			break;
+		case AUDIO_CLK_FREQ_441:
+			index=1;
+			break;
+		case AUDIO_CLK_FREQ_32:
+			index=0;
+			break;
+		case AUDIO_CLK_FREQ_8:
+			index = 5;
+			break;
+		case AUDIO_CLK_FREQ_11:
+			index = 6;
+			break;
+		case AUDIO_CLK_FREQ_12:
+			index = 7;
+			break;
+		case AUDIO_CLK_FREQ_16:
+			index = 8;
+			break;
+		case AUDIO_CLK_FREQ_22:
+			index = 9;
+			break;
+		case AUDIO_CLK_FREQ_24:
+			index = 10;
+			break;
+		default:
+			index=0;
+			break;
+	};
+
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+	WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	
+	//Set filter register
+	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+
+	/*--- DAC clock  configuration--- */
+	// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 2);
+
+	// Configure Multi-Phase PLL2
+	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
+	// Set the XD value
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk--64fs
+	
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+
+	//Audio DAC Clock enable
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
+	
+	/* ---ADC clock  configuration--- */
+	// Disable mclk
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
+
+    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 3, 9, 2);
+
+    // Set pll over mclk ratio
+    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
+#if OVERCLOCK == 0
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+#else
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, (audio_clock_config[index][1]+1)*2-1, 0, 8);
+#endif
+
+    // Set mclk over sclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
+
+    // Set sclk over lrclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12); //set codec adc ratio---lrclk--64fs
+
+    // Enable sclk
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
+    // Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 8, 1);
+
+    // delay 2uS
+	//udelay(2);
+	for (i = 0; i < 200000; i++) ;
+}
+
+// iec958 and i2s clock are separated after M6TV. Use PLL1 for iec958 clock
+void audio_set_958_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+	int index=0;
+	switch(freq)
+	{
+		case AUDIO_CLK_FREQ_192:
+			index=4;
+			break;
+		case AUDIO_CLK_FREQ_96:
+			index=3;
+			break;
+		case AUDIO_CLK_FREQ_48:
+			index=2;
+			break;
+		case AUDIO_CLK_FREQ_441:
+			index=1;
+			break;
+		case AUDIO_CLK_FREQ_32:
+			index=0;
+			break;
+		case AUDIO_CLK_FREQ_8:
+			index = 5;
+			break;
+		case AUDIO_CLK_FREQ_11:
+			index = 6;
+			break;
+		case AUDIO_CLK_FREQ_12:
+			index = 7;
+			break;
+		case AUDIO_CLK_FREQ_16:
+			index = 8;
+			break;
+		case AUDIO_CLK_FREQ_22:
+			index = 9;
+			break;
+		case AUDIO_CLK_FREQ_24:
+			index = 10;
+			break;
+		default:
+			index=0;
+			break;
+	};
+
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+	//WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	
+	//Set filter register
+	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+
+	/*--- IEC958 clock  configuration, use MPLL1--- */
+	// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 24, 1);
+	//IEC958_USE_CNTL
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 1, 27, 1);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 2, 25, 2);
+
+	// Configure Multi-Phase PLL1
+	WRITE_MPEG_REG(HHI_MPLL_CNTL8, audio_clock_config[index][0]);
+	// Set the XD value
+#if IEC958_OVERCLOCK	==1
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)/2 -1, 16, 8);
+#else
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 16, 8);
+#endif
+
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+	// Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 24, 1);
+}
+
+//extern void audio_out_enabled(int flag);
+void audio_hw_958_raw(void);
+
+void audio_enable_ouput(int flag)
+{
+    if (flag) {
+        WRITE_MPEG_REG(AIU_RST_SOFT, 0x05);
+        READ_MPEG_REG(AIU_I2S_SYNC);
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
+
+        if (ENABLE_IEC958) {
+            if(IEC958_MODE == AIU_958_MODE_RAW)
+            {
+              //audio_hw_958_raw();
+            }
+            //else
+            {
+              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
+              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+              //WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 1);
+
+              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+            }
+        }
+        // Maybe cause POP noise
+        // audio_i2s_unmute();
+    } else {
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
+
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
+        }
+        // Maybe cause POP noise
+        // audio_i2s_mute();
+    }
+    //audio_out_enabled(flag);
+}
+
+int if_audio_out_enable()
+{
+	return READ_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 2);
+}
+
+unsigned int read_i2s_rd_ptr(void)
+{
+    unsigned int val;
+    val = READ_MPEG_REG(AIU_MEM_I2S_RD_PTR);
+    return val;
+}
+
+void audio_i2s_unmute(void)
+{
+    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0, 8, 8);
+    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 0, 3, 2);
+}
+
+void audio_i2s_mute(void)
+{
+    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0xff, 8, 8);
+    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 3, 3, 2);
+}
+
+void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
+{
+	WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL,0);
+    WRITE_MPEG_REG(AIU_RST_SOFT,
+                   (slow_domain << 3) | (fast_domain << 2));
+}
+
+void audio_hw_958_raw()
+{
+    if (ENABLE_IEC958) {
+         WRITE_MPEG_REG(AIU_958_MISC, 1);
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
+    }
+
+    WRITE_MPEG_REG(AIU_958_BPF, IEC958_bpf);
+    WRITE_MPEG_REG(AIU_958_BRST, IEC958_brst);
+    WRITE_MPEG_REG(AIU_958_LENGTH, IEC958_length);
+    WRITE_MPEG_REG(AIU_958_PADDSIZE, IEC958_padsize);
+    WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 2, 2);// disable int
+
+    if(IEC958_mode == 1){ // search in byte
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 7, 4, 3);
+    }else if(IEC958_mode == 2) { // search in word
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 5, 4, 3);
+    }else{
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 4, 3);
+    }
+    WRITE_MPEG_REG(AIU_958_CHSTAT_L0, IEC958_chstat0_l);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_L1, IEC958_chstat1_l);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_R0, IEC958_chstat0_r);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_R1, IEC958_chstat1_r);
+
+    WRITE_MPEG_REG(AIU_958_SYNWORD1, IEC958_syncword1);
+    WRITE_MPEG_REG(AIU_958_SYNWORD2, IEC958_syncword2);
+    WRITE_MPEG_REG(AIU_958_SYNWORD3, IEC958_syncword3);
+    WRITE_MPEG_REG(AIU_958_SYNWORD1_MASK, IEC958_syncword1_mask);
+    WRITE_MPEG_REG(AIU_958_SYNWORD2_MASK, IEC958_syncword2_mask);
+    WRITE_MPEG_REG(AIU_958_SYNWORD3_MASK, IEC958_syncword3_mask);
+
+    printk("%s: %d\n", __func__, __LINE__);
+    printk("\tBPF: %x\n", IEC958_bpf);
+    printk("\tBRST: %x\n", IEC958_brst);
+    printk("\tLENGTH: %x\n", IEC958_length);
+    printk("\tPADDSIZE: %x\n", IEC958_length);
+    printk("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1, IEC958_syncword2, IEC958_syncword3);
+
+}
+
+void set_958_channel_status(_aiu_958_channel_status_t * set)
+{
+    if (set) {
+		WRITE_MPEG_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
+    }
+}
+
+static void audio_hw_set_958_pcm24(_aiu_958_raw_setting_t * set)
+{
+    WRITE_MPEG_REG(AIU_958_BPF, 0x80); /* in pcm mode, set bpf to 128 */
+    set_958_channel_status(set->chan_stat);
+}
+
+void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set)
+{
+    if(mode == AIU_958_MODE_PCM_RAW){
+    	mode = AIU_958_MODE_PCM16; //use 958 raw pcm mode
+       WRITE_MPEG_REG(AIU_958_VALID_CTRL,3);//enable 958 invalid bit	
+    } 
+    else
+	WRITE_MPEG_REG(AIU_958_VALID_CTRL,0);
+    if (mode == AIU_958_MODE_RAW) {
+
+        audio_hw_958_raw();
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 1);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
+        }
+
+        printk("IEC958 RAW\n");
+    }else if(mode == AIU_958_MODE_PCM32){
+        audio_hw_set_958_pcm24(set);
+        if(ENABLE_IEC958){
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+        }
+        printk("IEC958 PCM32 \n");
+    }else if (mode == AIU_958_MODE_PCM24) {
+        audio_hw_set_958_pcm24(set);
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+
+        }
+        printk("IEC958 24bit\n");
+    } else if (mode == AIU_958_MODE_PCM16) {
+        audio_hw_set_958_pcm24(set);
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2042);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+
+        }
+        printk("IEC958 16bit\n");
+    }
+
+    audio_hw_958_reset(0, 1);
+
+    WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 1);
+}
+
+void audio_hw_958_enable(unsigned flag)
+{
+    if (ENABLE_IEC958) {
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 2, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 1, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, flag, 0, 1);
+    }
+}
+
+unsigned int read_i2s_mute_swap_reg(void)
+{
+	unsigned int val;
+    	val = READ_MPEG_REG(AIU_I2S_MUTE_SWAP);
+    	return val;
+}
+
+void audio_i2s_swap_left_right(unsigned int flag)
+{
+	if (ENABLE_IEC958)
+	{
+		WRITE_MPEG_REG_BITS(AIU_958_CTRL, flag, 1, 2);
+	}
+	WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, flag, 0, 2);
+}
+unsigned int audio_hdmi_init_ready()
+{
+	return 	READ_MPEG_REG_BITS(AIU_HDMI_CLK_DATA_CTRL, 0, 2);
+}
diff --git a/sound/soc/aml/m6/aml_audio_hw.h b/sound/soc/aml/m6/aml_audio_hw.h
new file mode 100644
index 000000000000..378b36feb745
--- /dev/null
+++ b/sound/soc/aml/m6/aml_audio_hw.h
@@ -0,0 +1,202 @@
+#ifndef __AML_AUDIO_HW_H__
+#define __AML_AUDIO_HW_H__
+
+#if defined (CONFIG_ARCH_MESON) || defined (CONFIG_ARCH_MESON2) || defined (CONFIG_ARCH_MESON3)
+
+
+/* assumming PLL source is 24M */
+
+#define AUDIO_384FS_PLL_192K        0x507d  /* 36.864M */
+#define AUDIO_384FS_PLL_192K_MUX    12
+#define AUDIO_384FS_CLK_192K        0x5eb
+
+#define AUDIO_384FS_PLL_176K        0x0e7c  /* 33.8688M */
+#define AUDIO_384FS_PLL_176K_MUX    25
+#define AUDIO_384FS_CLK_176K        0x5eb
+
+#define AUDIO_384FS_PLL_96K         0x507d  /* 36.864M */
+#define AUDIO_384FS_PLL_96K_MUX     12
+#define AUDIO_384FS_CLK_96K         0x5ef
+
+#define AUDIO_384FS_PLL_88K         0x0e7c  /* 33.8688M */
+#define AUDIO_384FS_PLL_88K_MUX     25
+#define AUDIO_384FS_CLK_88K         0x5ef
+
+#define AUDIO_384FS_PLL_48K         0x487d  /* 18.432M */
+#define AUDIO_384FS_PLL_48K_MUX     12
+#define AUDIO_384FS_CLK_48K_AC3     0x5ed
+#define AUDIO_384FS_CLK_48K         0x5ef
+
+#define AUDIO_384FS_PLL_44K         0x0aa3  /* 16.9344M */
+#define AUDIO_384FS_PLL_44K_MUX     23
+#define AUDIO_384FS_CLK_44K         0x5ef
+
+#define AUDIO_384FS_PLL_32K         0x1480  /* 12.288M */
+#define AUDIO_384FS_PLL_32K_MUX     24
+#define AUDIO_384FS_CLK_32K         0x5ef
+
+#define AUDIO_384FS_DAC_CFG         0x6
+
+#define AUDIO_256FS_PLL_192K        0x0a53  /* 24.576M */
+#define AUDIO_256FS_PLL_192K_MUX    17
+#define AUDIO_256FS_CLK_192K        0x5c7
+
+#define AUDIO_256FS_PLL_176K        0x0eba  /* 22.5792M */
+#define AUDIO_256FS_PLL_176K_MUX    25
+#define AUDIO_256FS_CLK_176K        0x5c7
+
+#define AUDIO_256FS_PLL_96K         0x0a53  /* 24.576M */
+#define AUDIO_256FS_PLL_96K_MUX     17
+#define AUDIO_256FS_CLK_96K         0x5db
+
+#define AUDIO_256FS_PLL_88K         0x0eba  /* 22.5792M */
+#define AUDIO_256FS_PLL_88K_MUX     25
+#define AUDIO_256FS_CLK_88K         0x5db
+
+#define AUDIO_256FS_PLL_48K         0x08d3  /* 12.288M */
+#define AUDIO_256FS_PLL_48K_MUX     27
+#define AUDIO_256FS_CLK_48K_AC3     0x5d9
+#define AUDIO_256FS_CLK_48K         0x5db
+
+#define AUDIO_256FS_PLL_44K         0x06b9  /* 11.2896M */
+#define AUDIO_256FS_PLL_44K_MUX     29
+#define AUDIO_256FS_CLK_44K         0x5db
+
+#define AUDIO_256FS_PLL_32K         0x4252  /* 8.192M */
+#define AUDIO_256FS_PLL_32K_MUX     14
+#define AUDIO_256FS_CLK_32K         0x5db
+#define AUDIO_256FS_DAC_CFG         0x7
+
+#endif
+
+typedef struct {
+    unsigned short pll;
+    unsigned short mux;
+    unsigned short devisor;
+} _aiu_clk_setting_t;
+
+typedef struct {
+    unsigned short chstat0_l;
+    unsigned short chstat1_l;
+    unsigned short chstat0_r;
+    unsigned short chstat1_r;
+} _aiu_958_channel_status_t;
+
+typedef struct {
+    /* audio clock */
+    unsigned short clock;
+    /* analog output */
+    unsigned short i2s_mode;
+    unsigned short i2s_dac_mode;
+    unsigned short i2s_preemphsis;
+    /* digital output */
+    unsigned short i958_buf_start_addr;
+    unsigned short i958_buf_blksize;
+    unsigned short i958_int_flag;
+    unsigned short i958_mode;
+    unsigned short i958_sync_mode;
+    unsigned short i958_preemphsis;
+    unsigned short i958_copyright;
+    unsigned short bpf;
+    unsigned short brst;
+    unsigned short length;
+    unsigned short paddsize;
+    _aiu_958_channel_status_t chan_status;
+} audio_output_config_t;
+
+typedef struct {
+    unsigned short int_flag;
+    unsigned short bpf;
+    unsigned short brst;
+    unsigned short length;
+    unsigned short paddsize;
+    _aiu_958_channel_status_t *chan_stat;
+} _aiu_958_raw_setting_t;
+
+enum {
+	I2SIN_MASTER_MODE = 0,
+	I2SIN_SLAVE_MODE  =   1<<0,
+	SPDIFIN_MODE   = 1<<1,
+};
+#define AUDIO_CLK_256FS             0
+#define AUDIO_CLK_384FS             1
+
+#define AUDIO_CLK_FREQ_192  0
+#define AUDIO_CLK_FREQ_1764 1
+#define AUDIO_CLK_FREQ_96   2
+#define AUDIO_CLK_FREQ_882  3
+#define AUDIO_CLK_FREQ_48   4
+#define AUDIO_CLK_FREQ_441  5
+#define AUDIO_CLK_FREQ_32   6
+
+#define AUDIO_CLK_FREQ_8		7
+#define AUDIO_CLK_FREQ_11		8
+#define AUDIO_CLK_FREQ_12		9
+#define AUDIO_CLK_FREQ_16		10
+#define AUDIO_CLK_FREQ_22		11
+#define AUDIO_CLK_FREQ_24		12
+
+
+#define AIU_958_MODE_RAW    0
+#define AIU_958_MODE_PCM16  1
+#define AIU_958_MODE_PCM24  2
+#define AIU_958_MODE_PCM32  3
+#define AIU_958_MODE_PCM_RAW  4
+
+#define AIU_I2S_MODE_PCM16   0
+#define AIU_I2S_MODE_PCM24   2
+#define AIU_I2S_MODE_PCM32   3
+
+#define AUDIO_ALGOUT_DAC_FORMAT_DSP             0
+#define AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY    1
+
+extern unsigned ENABLE_IEC958;
+extern unsigned IEC958_MODE;
+extern unsigned I2S_MODE;
+
+void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
+void audio_set_958outbuf(u32 addr, u32 size, int flag);
+void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode);
+void audio_in_spdif_set_buf(u32 addr, u32 size);
+void audio_in_i2s_enable(int flag);
+void audio_in_spdif_enable(int flag);
+unsigned int audio_in_i2s_rd_ptr(void);
+unsigned int audio_in_i2s_wr_ptr(void);
+void audio_set_i2s_mode(u32 mode);
+void audio_set_clk(unsigned freq, unsigned fs_config);
+void audio_set_i2s_clk(unsigned freq, unsigned fs_config);
+void audio_set_958_clk(unsigned freq, unsigned fs_config);
+void audio_enable_ouput(int flag);
+unsigned int read_i2s_rd_ptr(void);
+void audio_i2s_unmute(void);
+void audio_i2s_mute(void);
+void audio_util_set_dac_format(unsigned format);
+void audio_util_set_dac_i2s_format(unsigned format);
+void audio_util_set_dac_958_format(unsigned format);
+void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set);
+unsigned int read_i2s_mute_swap_reg(void);
+void audio_i2s_swap_left_right(unsigned int flag);
+int if_audio_out_enable(void);
+int if_audio_in_i2s_enable(void);
+void audio_hw_958_enable(unsigned flag);
+void audio_out_enabled(int flag);
+void audio_util_set_dac_format(unsigned format);
+unsigned int audio_hdmi_init_ready(void);
+
+#include "mach/cpu.h"
+
+/*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+#define OVERCLOCK 0
+#define IEC958_OVERCLOCK 1
+#else
+#define OVERCLOCK 1
+#endif
+
+#if (OVERCLOCK == 1)
+#define MCLKFS_RATIO 512
+#else
+#define MCLKFS_RATIO 256
+#endif
+
+#endif
diff --git a/sound/soc/aml/m6/aml_audio_hw_pcm2bt.c b/sound/soc/aml/m6/aml_audio_hw_pcm2bt.c
new file mode 100644
index 000000000000..adfa4bda6574
--- /dev/null
+++ b/sound/soc/aml/m6/aml_audio_hw_pcm2bt.c
@@ -0,0 +1,314 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <mach/am_regs.h>
+#include <linux/clk.h>
+
+#include "aml_audio_hw_pcm2bt.h"
+
+//#define PCM_DEBUG
+
+#ifdef PCM_DEBUG
+#define pcm_debug           pr_info
+#else
+#define pcm_debug(fmt, ...) \
+        do {} while(0)
+#endif
+
+static unsigned int pcmin_buffer_addr = 0;
+static unsigned int pcmin_buffer_size = 0;
+
+static unsigned int pcmout_buffer_addr = 0;
+static unsigned int pcmout_buffer_size = 0;
+
+static void pcm_in_register_show(void)
+{
+    pcm_debug("PCMIN registers show:\n");
+    pcm_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START, READ_MPEG_REG(AUDIN_FIFO1_START));
+    pcm_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END, READ_MPEG_REG(AUDIN_FIFO1_END));
+    pcm_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR, READ_MPEG_REG(AUDIN_FIFO1_PTR));
+    pcm_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR, READ_MPEG_REG(AUDIN_FIFO1_RDPTR));
+    pcm_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL, READ_MPEG_REG(AUDIN_FIFO1_CTRL));
+    pcm_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1, READ_MPEG_REG(AUDIN_FIFO1_CTRL1));
+    pcm_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0, READ_MPEG_REG(PCMIN_CTRL0));
+    pcm_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1, READ_MPEG_REG(PCMIN_CTRL1));
+}
+
+void pcm_in_enable(int flag)
+{
+    /* reset fifo */
+RESET_FIFO:    
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1);
+    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
+    if (READ_MPEG_REG(AUDIN_FIFO1_PTR) != READ_MPEG_REG(AUDIN_FIFO1_START))
+        goto RESET_FIFO;
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 1, 1);
+
+    /* reset pcmin */
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 30, 1);
+
+    /* disable fifo */
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 0, 1);
+
+    /* disable pcmin */
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 31, 1);
+
+    if (flag) {
+        /* set buffer start ptr end */
+    	WRITE_MPEG_REG(AUDIN_FIFO1_START, pcmin_buffer_addr);
+    	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+    	WRITE_MPEG_REG(AUDIN_FIFO1_END, pcmin_buffer_addr + pcmin_buffer_size - 8);
+
+        /* fifo control */
+        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1 << 15) |    // urgent request
+                                         (1 << 11) |    // channel
+                                         (6 << 8) |     // endian
+                                         //(0 << 8) |     // endian
+                                         (2 << 3) |     // PCMIN input selection
+                                         (1 << 2) |     // load address
+                                         (0 << 1) |     // reset fifo
+                                         (1 << 0)       // fifo enable
+                        );
+
+        /* fifo control1 */
+        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1, (0 << 4) |    // data destination DDR
+                                          (1 << 2) |    // 16bits
+                                          (0 << 0)      // data position
+                        );
+
+        /* pcmin control1 */
+        WRITE_MPEG_REG(PCMIN_CTRL1, (0 << 29) |         // external chip
+                                    (0 << 28) |         // external chip
+                                    (1 << 27) |         // using negedge of PCM clock to latch the input data
+                                    (15 << 21) |        // slot bit msb 16 clocks per slot
+                                    (15 << 16) |        // data msb 16bits data
+                                    (1 << 0)            // slot valid
+                        );
+
+        /* pcmin control0 */
+        WRITE_MPEG_REG(PCMIN_CTRL0, (1 << 31) |         // pcmin enable
+                                    (1 << 29) |         // sync on clock posedge
+                                    (0 << 16) |         // FS SKEW
+                                    (0 << 4) |          // waithing 1 system clock cycles then sample the PCMIN singals
+                                    (0 << 3) |          // use clock counter to do the sample
+                                    (0 << 2) |          // fs not inverted. H = left, L = right
+                                    (1 << 1) |          // msb first
+                                    (1 << 0)            // left justified
+                        );
+    }
+
+    pcm_debug("PCMIN %s\n", flag ? "enable" : "disable");
+    pcm_in_register_show();
+}
+
+void pcm_in_set_buf(unsigned int addr, unsigned int size)
+{
+    pcmin_buffer_addr = addr;
+    pcmin_buffer_size = size;
+
+    pcm_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n", pcmin_buffer_addr, pcmin_buffer_size);
+}
+
+int pcm_in_is_enable(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMIN_CTRL0, 31, 1) & 0x01);
+
+    return value;
+}
+
+unsigned int pcm_in_rd_ptr(void)
+{
+    unsigned int value = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
+
+    return value;
+}
+
+unsigned int pcm_in_set_rd_ptr(unsigned int value)
+{
+    unsigned int old = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+    WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, value);
+    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
+
+    return old;
+}
+
+unsigned int pcm_in_wr_ptr(void)
+{
+	unsigned int writing = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+    unsigned int written = 0;
+    unsigned int value = 0;
+
+    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
+	written = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+    pcm_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
+
+    //value = written;
+    value = written & (~0x07);
+    return value;
+}
+
+unsigned int pcm_in_fifo_int(void)
+{
+    unsigned int value = 0;
+    value = READ_MPEG_REG(AUDIN_FIFO_INT);
+    pcm_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
+
+    return value;
+}
+
+static void pcm_out_register_show(void)
+{
+    pcm_debug("PCMOUT registers show:\n");
+    pcm_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA, READ_MPEG_REG(AUDOUT_BUF0_STA));
+    pcm_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA, READ_MPEG_REG(AUDOUT_BUF0_EDA));
+    pcm_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR, READ_MPEG_REG(AUDOUT_BUF0_WPTR));
+    pcm_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR, READ_MPEG_REG(AUDOUT_FIFO_RPTR));
+    pcm_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL, READ_MPEG_REG(AUDOUT_CTRL));
+    pcm_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1, READ_MPEG_REG(AUDOUT_CTRL1));
+    pcm_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0, READ_MPEG_REG(PCMOUT_CTRL0));
+    pcm_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1, READ_MPEG_REG(PCMOUT_CTRL1));
+    pcm_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2, READ_MPEG_REG(PCMOUT_CTRL2));
+    pcm_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3, READ_MPEG_REG(PCMOUT_CTRL3));
+}
+
+void pcm_out_enable(int flag)
+{
+    /* reset fifo */
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 30, 1);
+
+    /* reset pcmout */
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 30, 1);
+
+    /* disable fifo */
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 31, 1);
+
+    /* disable pcmout */
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 31, 1);
+
+    if (flag) {
+        /* set buffer start ptr end */
+    	WRITE_MPEG_REG(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+    	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+    	WRITE_MPEG_REG(AUDOUT_BUF0_EDA, pcmout_buffer_addr + pcmout_buffer_size - 8);
+
+        /* fifo control */
+        WRITE_MPEG_REG(AUDOUT_CTRL, (0 << 31) |     // fifo enable
+                                    (0 << 30) |     // soft reset
+                                    (1 << 29) |     // load address
+                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
+                                    (52 << 15) |    // data request size
+                                    (64 << 8) |     // buffer level to keep
+                                    (0 << 7) |      // buffer level control
+                                    (1 << 6) |      // DMA mode
+                                    (1 << 5) |      // circular buffer
+                                    (0 << 4) |      // use register set 0 always
+                                    (1 << 3) |       // urgent request
+                                    (6 << 0)         //endian
+                        );
+
+        WRITE_MPEG_REG(AUDOUT_CTRL, (1 << 31) |     // fifo enable
+                                    (0 << 30) |     // soft reset
+                                    (0 << 29) |     // load address
+                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
+                                    (52 << 15) |    // data request size
+                                    (64 << 8) |     // buffer level to keep
+                                    (0 << 7) |      // buffer level control
+                                    (1 << 6) |      // DMA mode
+                                    (1 << 5) |      // circular buffer
+                                    (0 << 4) |      // use register set 0 always
+                                    (1 << 3) |       // urgent request
+                                    (6 << 0)         //endian
+                                    
+                        );
+        /* pcmout control3 */
+        WRITE_MPEG_REG(PCMOUT_CTRL3, 0);            // mute constant
+
+        /* pcmout control2 */
+        WRITE_MPEG_REG(PCMOUT_CTRL2,(0 << 29) |     // underrun use mute constant
+                                    (0 << 22) |     // 1 channel per frame
+                                    (15 << 16) |    // 16 bits per slot
+                                    (1 << 0)        // enable 1 slot
+                        );
+
+        /* pcmout control1 */
+        WRITE_MPEG_REG(PCMOUT_CTRL1,(1 << 30) |     // data byte numbe n - 1?
+                                    (0 << 28) |     // use posedge of PCM clock to output data
+                                    (1 << 27)       // use negedge of pcm clock to check the fs
+                        );
+
+        /* pcmout control0 */
+        WRITE_MPEG_REG(PCMOUT_CTRL0,(1 << 31) |     // enable
+                                    (0 << 29) |     // slave
+                                    (1 << 28) |     // sync on clock rising edge
+                                    (0 << 27) |     // data sample mode
+                                    (1 << 15) |     // sync on 4 system clock later ?
+                                    (1 << 14) |     // msb first
+                                    (1 << 13) |     // left justified
+                                    (0 << 12) |     // data position
+                                    (3 << 6) |      // sync fs with the slot bit counter.
+                                    (0 << 0)        // sync fs with frame slot counter.
+                        );
+    }
+
+    pcm_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+    pcm_out_register_show();
+}
+
+void pcm_out_mute(int flag)
+{
+    int value = flag ? 1: 0;
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL2, value, 31, 1);
+}
+
+void pcm_out_set_buf(unsigned int addr, unsigned int size)
+{
+    pcmout_buffer_addr = addr;
+    pcmout_buffer_size = size;
+
+    pcm_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n", pcmout_buffer_addr, pcmout_buffer_size);
+}
+
+int pcm_out_is_enable(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL0, 31, 1) & 0x01);
+
+    return value;
+}
+
+int  pcm_out_is_mute(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL2, 31, 1) & 0x01);
+
+    return value;
+}
+
+unsigned int pcm_out_rd_ptr(void)
+{
+    unsigned int value = READ_MPEG_REG(AUDOUT_FIFO_RPTR);
+    pcm_debug("PCMOUT read pointer: 0x%08x\n", value);
+
+    return value;
+}
+
+unsigned int pcm_out_wr_ptr(void)
+{
+    unsigned int value = 0;
+ 	value = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
+    pcm_debug("PCMOUT write pointer: 0x%08x\n", value);
+    return value;
+}
+
+unsigned int pcm_out_set_wr_ptr(unsigned int value)
+{
+    unsigned int old = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
+ 	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, value);
+    pcm_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
+
+    return old;
+}
+
diff --git a/sound/soc/aml/m6/aml_audio_hw_pcm2bt.h b/sound/soc/aml/m6/aml_audio_hw_pcm2bt.h
new file mode 100644
index 000000000000..4afc8d6a6425
--- /dev/null
+++ b/sound/soc/aml/m6/aml_audio_hw_pcm2bt.h
@@ -0,0 +1,21 @@
+#ifndef __AML_PCM_HW_H__
+#define __AML_PCM_HW_H__
+
+void pcm_in_enable(int flag);
+void pcm_in_set_buf(unsigned int addr, unsigned int size);
+int  pcm_in_is_enable(void);
+unsigned int pcm_in_rd_ptr(void);
+unsigned int pcm_in_wr_ptr(void);
+unsigned int pcm_in_set_rd_ptr(unsigned int value);
+unsigned int pcm_in_fifo_int(void);
+
+void pcm_out_enable(int flag);
+void pcm_out_mute(int flag);
+void pcm_out_set_buf(unsigned int addr, unsigned int size);
+int  pcm_out_is_enable(void);
+int  pcm_out_is_mute(void);
+unsigned int pcm_out_rd_ptr(void);
+unsigned int pcm_out_wr_ptr(void);
+unsigned int pcm_out_set_wr_ptr(unsigned int value);
+
+#endif
diff --git a/sound/soc/aml/m6/aml_dai.c b/sound/soc/aml/m6/aml_dai.c
new file mode 100644
index 000000000000..baa2eab4d96e
--- /dev/null
+++ b/sound/soc/aml/m6/aml_dai.c
@@ -0,0 +1,314 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include <linux/of.h>
+
+static aml_dai_info_t dai_info[3] = {{0}};
+//#define AML_DAI_DEBUG
+
+#define AML_DAI_PCM_SUPPORT
+
+static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+
+static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	{
+		s->i2s_mode = dai_info[dai->id].i2s_mode;
+	}
+	return 0;
+}
+
+static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)//slave mode 
+		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
+	return 0;
+}
+
+static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#  define aml_dai_i2s_suspend	NULL
+#  define aml_dai_i2s_resume	NULL
+#endif /* CONFIG_PM */
+
+#ifdef AML_DAI_PCM_SUPPORT
+
+static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+
+static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)
+	snd_soc_dai_get_drvdata(dai);		
+	return 0;
+}
+
+static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#  define aml_dai_pcm_suspend	NULL
+#  define aml_dai_pcm_resume	NULL
+#endif /* CONFIG_PM */
+
+#endif
+
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_96000)
+#define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+#ifdef AML_DAI_PCM_SUPPORT
+#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
+#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#endif
+
+static struct snd_soc_dai_ops aml_dai_i2s_ops = {
+	.startup	= aml_dai_i2s_startup,
+	.shutdown	= aml_dai_i2s_shutdown,
+	.prepare	= aml_dai_i2s_prepare,
+	.hw_params	= aml_dai_i2s_hw_params,
+	.set_fmt	= aml_dai_set_i2s_fmt,
+	.set_sysclk	= aml_dai_set_i2s_sysclk,
+};
+
+#ifdef AML_DAI_PCM_SUPPORT
+static struct snd_soc_dai_ops aml_dai_pcm_ops = {
+	.startup	= aml_dai_pcm_startup,
+	.shutdown	= aml_dai_pcm_shutdown,
+	.prepare	= aml_dai_pcm_prepare,
+	.hw_params	= aml_dai_pcm_hw_params,
+	.set_fmt	= aml_dai_set_pcm_fmt,
+	.set_sysclk	= aml_dai_set_pcm_sysclk,
+};
+#endif
+
+struct snd_soc_dai_driver aml_dai[] = {
+	{	.name = "aml-dai0",
+		.id = 0,
+		.suspend = aml_dai_i2s_suspend,
+		.resume = aml_dai_i2s_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = AML_DAI_I2S_RATES,
+			.formats = AML_DAI_I2S_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = AML_DAI_I2S_RATES,
+			.formats = AML_DAI_I2S_FORMATS,},
+		.ops = &aml_dai_i2s_ops,
+	},
+#ifdef AML_DAI_PCM_SUPPORT
+	{	.name = "aml-dai1",
+		.id = 1,
+		.suspend = aml_dai_pcm_suspend,
+		.resume = aml_dai_pcm_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.ops = &aml_dai_pcm_ops,
+	},
+#endif
+};
+
+EXPORT_SYMBOL_GPL(aml_dai);
+
+static const struct snd_soc_component_driver aml_component= {
+	.name		= "aml-dai",
+};
+
+static int aml_dai_probe(struct platform_device *pdev)
+{
+	printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0
+	BUG_ON(pdev->id < 0);
+	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
+	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
+#else
+	//return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
+	return snd_soc_register_component(&pdev->dev, &aml_component,
+					 aml_dai, ARRAY_SIZE(aml_dai));
+#endif
+}
+
+static int aml_dai_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-dai",
+	},
+	{},
+};
+#else
+#define amlogic_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_dai_driver = {
+	.driver = {
+		.name = "aml-dai",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_dai_dt_match,
+	},
+
+	.probe = aml_dai_probe,
+	.remove = aml_dai_remove,
+};
+
+static int __init aml_dai_modinit(void)
+{
+	return platform_driver_register(&aml_dai_driver);
+}
+module_init(aml_dai_modinit);
+
+static void __exit aml_dai_modexit(void)
+{
+	platform_driver_unregister(&aml_dai_driver);
+}
+module_exit(aml_dai_modexit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML DAI driver for ALSA");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m6/aml_dai.h b/sound/soc/aml/m6/aml_dai.h
new file mode 100644
index 000000000000..332f1da65d9d
--- /dev/null
+++ b/sound/soc/aml/m6/aml_dai.h
@@ -0,0 +1,6 @@
+#ifndef AML_DAI_H
+#define AML_DAI_H
+
+extern struct snd_soc_dai_driver aml_dai[];
+
+#endif
diff --git a/sound/soc/aml/m6/aml_m6_rt3261.c b/sound/soc/aml/m6/aml_m6_rt3261.c
new file mode 100644
index 000000000000..fa166478528f
--- /dev/null
+++ b/sound/soc/aml/m6/aml_m6_rt3261.c
@@ -0,0 +1,651 @@
+/*
+ * aml_m6_rt3261.c  --  SoC audio for AML M6
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/rt3261.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+
+
+#include "../codecs/rt3261/rt3261.h"
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#define HP_DET                  1
+
+struct rt3261_private_data {
+    int bias_level;
+    int clock_en;
+#if HP_DET
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+    struct switch_dev sdev; // for android
+#endif
+};
+
+#define DEBUG	1
+//#undef DEBUG
+#ifdef DEBUG
+#define dprintk(msg...) printk(msg)
+#else
+#define dprintk(msg...) while(0){}
+#endif
+
+static struct rt3261_platform_data *rt3261_snd_pdata = NULL;
+static struct rt3261_private_data* rt3261_snd_priv = NULL;
+
+static void rt3261_dev_init(void)
+{
+    if (rt3261_snd_pdata->device_init) {
+        rt3261_snd_pdata->device_init();
+    }
+}
+
+static void rt3261_dev_uninit(void)
+{
+    if (rt3261_snd_pdata->device_uninit) {
+        rt3261_snd_pdata->device_uninit();
+    }
+}
+
+static void rt3261_set_clock(int enable)
+{
+    /* set clock gating */
+    rt3261_snd_priv->clock_en = enable;
+
+    return ;
+}
+
+static void rt3261_set_output(struct snd_soc_codec *codec)
+{
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+#if 0
+    if (rt3261_snd_pdata->spk_output != RT3261_SPK_STEREO) {
+        if (rt3261_snd_pdata->spk_output == RT3261_SPK_RIGHT) {
+            snd_soc_dapm_nc_pin(dapm, "SPOL");
+
+            snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
+                0xf000,
+                RT3261_M_SPKVOL_L_TO_SPOL_MIXER | RT3261_M_SPKVOL_R_TO_SPOL_MIXER);
+        } else {
+            snd_soc_dapm_nc_pin(dapm, "SPOR");
+
+            snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
+                0xf000,
+                RT3261_M_SPKVOL_L_TO_SPOR_MIXER | RT3261_M_SPKVOL_R_TO_SPOR_MIXER);
+        }
+
+        snd_soc_update_bits(codec, RT3261_SPK_MONO_HP_OUT_CTRL,
+            RT3261_SPK_L_MUX_SEL_MASK | RT3261_SPK_R_MUX_SEL_MASK | RT3261_HP_L_MUX_SEL_MASK | RT3261_HP_R_MUX_SEL_MASK,
+            RT3261_SPK_L_MUX_SEL_SPKMIXER_L | RT3261_SPK_R_MUX_SEL_SPKMIXER_R | RT3261_HP_L_MUX_SEL_HPVOL_L | RT3261_HP_R_MUX_SEL_HPVOL_R);
+    } else {
+        snd_soc_update_bits(codec, RT3261_SPK_MONO_OUT_CTRL,
+            0xf000,
+            RT3261_M_SPKVOL_R_TO_SPOL_MIXER | RT3261_M_SPKVOL_L_TO_SPOR_MIXER);
+
+        snd_soc_update_bits(codec, RT3261_SPK_MONO_HP_OUT_CTRL,
+            RT3261_SPK_L_MUX_SEL_MASK | RT3261_SPK_R_MUX_SEL_MASK | RT3261_HP_L_MUX_SEL_MASK | RT3261_HP_R_MUX_SEL_MASK,
+            RT3261_SPK_L_MUX_SEL_SPKMIXER_L | RT3261_SPK_R_MUX_SEL_SPKMIXER_R | RT3261_HP_L_MUX_SEL_HPVOL_L | RT3261_HP_R_MUX_SEL_HPVOL_R);
+    }
+#endif
+}
+
+static void rt3261_set_input(struct snd_soc_codec *codec)
+{
+#if 0
+    if (rt3261_snd_pdata->mic_input == RT3261_MIC_SINGLEENDED) {
+        /* single-ended input mode */
+        snd_soc_update_bits(codec, RT3261_MIC_CTRL_1,
+            RT3261_MIC1_DIFF_INPUT_CTRL,
+            0);
+    } else {
+        /* differential input mode */
+        snd_soc_update_bits(codec, RT3261_MIC_CTRL_1,
+            RT3261_MIC1_DIFF_INPUT_CTRL,
+            RT3261_MIC1_DIFF_INPUT_CTRL);
+    }
+#endif
+}
+
+#if HP_DET
+static int rt3261_detect_hp(void)
+{
+    int flag = -1;
+
+    if (rt3261_snd_pdata->hp_detect)
+    {
+        flag = rt3261_snd_pdata->hp_detect();
+    }
+
+    return flag;
+}
+
+static void rt3261_start_timer(unsigned long delay)
+{
+    rt3261_snd_priv->timer.expires = jiffies + delay;
+    rt3261_snd_priv->timer.data = (unsigned long)rt3261_snd_priv;
+    rt3261_snd_priv->detect_flag = -1;
+    add_timer(&rt3261_snd_priv->timer);
+    rt3261_snd_priv->timer_en = 1;
+}
+
+static void rt3261_stop_timer(void)
+{
+    del_timer_sync(&rt3261_snd_priv->timer);
+    cancel_work_sync(&rt3261_snd_priv->work);
+    rt3261_snd_priv->timer_en = 0;
+    rt3261_snd_priv->detect_flag = -1;
+}
+
+static void rt3261_work_func(struct work_struct *work)
+{
+    struct rt3261_private_data *pdata = NULL;
+    struct snd_soc_codec *codec = NULL;
+    int jack_type = 0;
+    int flag = -1;
+	int status = SND_JACK_HEADPHONE;
+
+    pdata = container_of(work, struct rt3261_private_data, work);
+    codec = (struct snd_soc_codec *)pdata->data;
+
+    flag = rt3261_detect_hp();
+    if(pdata->detect_flag != flag) {
+        if (flag == 1) {
+	    jack_type = rt3261_headset_detect(codec, 1);
+            dprintk(KERN_INFO "rt3261 hp pluged jack_type: %d\n", jack_type);
+            snd_soc_jack_report(&pdata->jack, status, SND_JACK_HEADPHONE);
+            switch_set_state(&pdata->sdev, 1); 
+        } else {
+            dprintk(KERN_INFO "rt3261 hp unpluged\n");
+	    rt3261_headset_detect(codec, 0);
+            snd_soc_jack_report(&pdata->jack, 0, SND_JACK_HEADPHONE);
+            switch_set_state(&pdata->sdev, 0);
+        }
+
+        pdata->detect_flag = flag;
+    }
+}
+
+
+static void rt3261_timer_func(unsigned long data)
+{
+    struct rt3261_private_data *pdata = (struct rt3261_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&pdata->work);
+    mod_timer(&pdata->timer, jiffies + delay);
+}
+#endif
+
+static int rt3261_prepare(struct snd_pcm_substream *substream)
+{
+    dprintk(KERN_INFO "enter %s stream: %s\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture");
+#if HP_DET
+    mutex_lock(&rt3261_snd_priv->lock);
+    if (!rt3261_snd_priv->timer_en) {
+        rt3261_start_timer(msecs_to_jiffies(100));
+    }
+    mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+    return 0;
+}
+
+static int rt3261_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    dprintk(KERN_INFO "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set codec DAI clock */
+    //ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * MCLKFS_RATIO, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    //ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * MCLKFS_RATIO, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static int rt3261_voice_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    dprintk(KERN_INFO "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_A |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_DSP_A |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+    //bard 10-22 s
+    //ret = snd_soc_dai_set_pll(codec_dai, 0, RT3261_PLL1_S_MCLK, 12288000, 12288000);
+    ret = snd_soc_dai_set_pll(codec_dai, 0, RT3261_PLL1_S_MCLK, 24576000, 24576000);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai pll failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+    //bard 10-22 e
+
+    /* set codec DAI clock */
+    #if 0 //org
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256 * 6, SND_SOC_CLOCK_IN);
+    #else //bard 10-22
+    //ret = snd_soc_dai_set_sysclk(codec_dai, RT3261_SCLK_S_PLL1, params_rate(params) * 256 * 6, SND_SOC_CLOCK_IN);
+    ret = snd_soc_dai_set_sysclk(codec_dai, RT3261_SCLK_S_PLL1, params_rate(params) * 256 * 12, SND_SOC_CLOCK_IN);
+    #endif
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        dprintk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops rt3261_soc_ops = {
+    .prepare   = rt3261_prepare,
+    .hw_params = rt3261_hw_params,
+};
+
+static struct snd_soc_ops rt3261_voice_ops = {
+	.prepare   = rt3261_prepare,
+	.hw_params = rt3261_voice_hw_params,
+};
+
+static int rt3261_set_bias_level(struct snd_soc_card *card,
+			      enum snd_soc_bias_level level)
+{
+    int ret = 0;
+
+    dprintk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+
+    if (rt3261_snd_priv->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+#if HP_DET
+        mutex_lock(&rt3261_snd_priv->lock);
+        if (!rt3261_snd_priv->timer_en) {
+            rt3261_start_timer(msecs_to_jiffies(100));
+        }
+        mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!rt3261_snd_priv->clock_en) {
+            rt3261_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (rt3261_snd_priv->clock_en) {
+            rt3261_set_clock(0);
+        }
+#if HP_DET
+        /* stop timer */
+        mutex_lock(&rt3261_snd_priv->lock);
+        if (rt3261_snd_priv->timer_en) {
+            rt3261_stop_timer();
+        }
+        mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+        break;
+    default:
+        return ret;
+    }
+
+    rt3261_snd_priv->bias_level = (int)level;
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rt3261_suspend_pre(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+#if HP_DET
+    /* stop timer */
+    mutex_lock(&rt3261_snd_priv->lock);
+    if (rt3261_snd_priv->timer_en) {
+        rt3261_stop_timer();
+    }
+    mutex_unlock(&rt3261_snd_priv->lock);
+#endif
+    return 0;
+}
+
+static int rt3261_suspend_post(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int rt3261_resume_pre(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int rt3261_resume_post(struct snd_soc_card *card)
+{
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define rt3261_suspend_pre  NULL
+#define rt3261_suspend_post NULL
+#define rt3261_resume_pre   NULL
+#define rt3261_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget rt3261_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+};
+
+static const struct snd_soc_dapm_route rt3261_dapm_intercon[] = {
+    {"Ext Spk", NULL, "SPOL"},
+    {"Ext Spk", NULL, "SPOR"},
+
+    {"HP", NULL, "HPOL"},
+    {"HP", NULL, "HPOR"},
+};
+
+#if HP_DET
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADPHONE,
+    }
+};
+#endif
+static int rt3261_codec_init2(struct snd_soc_pcm_runtime *rtd)
+{
+    return 0;
+}
+
+static int rt3261_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_codec *codec = rtd->codec;
+    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    int ret = 0;
+
+    dprintk(KERN_DEBUG "enter %s rt3261_snd_pdata: %p\n", __func__, rt3261_snd_pdata);
+
+    /* Add specific widgets */
+    snd_soc_dapm_new_controls(dapm, rt3261_dapm_widgets,
+                  ARRAY_SIZE(rt3261_dapm_widgets));
+    /* Set up specific audio path interconnects */
+    snd_soc_dapm_add_routes(dapm, rt3261_dapm_intercon, ARRAY_SIZE(rt3261_dapm_intercon));
+#if 0 //we have 3g, so do not set endpoint,add jf.s
+    /* Setup spk/hp/mono output */
+    rt3261_set_output(codec);
+
+    /* Setuo mic input */
+    rt3261_set_input(codec);
+#endif
+    /* not connected */
+    snd_soc_dapm_nc_pin(dapm, "MONO");
+    snd_soc_dapm_nc_pin(dapm, "AUXO2");
+
+    snd_soc_dapm_nc_pin(dapm, "DMIC");
+    snd_soc_dapm_nc_pin(dapm, "AXIL");
+    snd_soc_dapm_nc_pin(dapm, "AXIR");
+
+    /* always connected */
+    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+
+    /* disable connected */
+    snd_soc_dapm_disable_pin(dapm, "HP");
+
+    snd_soc_dapm_sync(dapm);
+
+#if HP_DET
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &rt3261_snd_priv->jack);
+    if (ret) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&rt3261_snd_priv->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret) {
+            dprintk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+    rt3261_snd_priv->data= (void*)codec;
+
+    init_timer(&rt3261_snd_priv->timer);
+    rt3261_snd_priv->timer.function = rt3261_timer_func;
+    rt3261_snd_priv->timer.data = (unsigned long)rt3261_snd_priv;
+
+    INIT_WORK(&rt3261_snd_priv->work, rt3261_work_func);
+    mutex_init(&rt3261_snd_priv->lock);
+#endif
+
+    return 0;
+}
+
+static struct snd_soc_dai_link rt3261_dai_link[] = {
+    {
+        .name = "RT3261",
+        .stream_name = "RT3261 PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "rt3261-aif1",
+        .init = rt3261_codec_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "rt3261.1-001c",
+        .ops = &rt3261_soc_ops,
+    },
+#if 1 //add jf.s
+    {
+        .name = "RT3261_BT_VOICE",
+        .stream_name = "RT3261 BT PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "rt3261-aif2",
+        .init = rt3261_codec_init2,
+        .platform_name = "aml-audio.0",
+        .codec_name = "rt3261.1-001c",
+        .ops = &rt3261_voice_ops,
+    },
+#endif
+};
+#define POP_TIME  10   //10ms
+static struct snd_soc_card snd_soc_rt3261 = {
+    .name = "AML-RT3261",
+    .driver_name = "SOC-Audio",
+    .dai_link = &rt3261_dai_link[0],
+    .num_links = ARRAY_SIZE(rt3261_dai_link),
+    .set_bias_level = rt3261_set_bias_level,
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = rt3261_suspend_pre,
+	.suspend_post   = rt3261_suspend_post,
+	.resume_pre     = rt3261_resume_pre,
+	.resume_post    = rt3261_resume_post,
+#endif
+//	.pop_time 		= POP_TIME,   //add by jf.s for power up/down widgets
+};
+
+static struct platform_device *rt3261_snd_device = NULL;
+
+static int rt3261_audio_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    dprintk(KERN_DEBUG "enter %s\n", __func__);
+    printk("rt3261, rt3261_audio_probe\n");
+    rt3261_snd_pdata = pdev->dev.platform_data;
+    snd_BUG_ON(!rt3261_snd_pdata);
+
+    rt3261_snd_priv = (struct rt3261_private_data*)kzalloc(sizeof(struct rt3261_private_data), GFP_KERNEL);
+    if (!rt3261_snd_priv) {
+        dprintk(KERN_ERR "ASoC: Platform driver data allocation failed\n");
+        return -ENOMEM;
+    }
+
+    rt3261_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!rt3261_snd_device) {
+        dprintk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    platform_set_drvdata(rt3261_snd_device, &snd_soc_rt3261);
+
+    ret = platform_device_add(rt3261_snd_device);
+    if (ret) {
+        dprintk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto err_device_add;
+    }
+
+    rt3261_snd_priv->bias_level = SND_SOC_BIAS_OFF;
+    rt3261_snd_priv->clock_en = 0;
+
+#if HP_DET
+    rt3261_snd_priv->sdev.name = "h2w";//for report headphone to android
+    ret = switch_dev_register(&rt3261_snd_priv->sdev);
+    if (ret < 0){
+        printk(KERN_ERR "ASoC: register switch dev failed\n");
+        goto err;
+    }
+#endif
+
+
+    rt3261_dev_init();
+
+    return ret;
+
+err_device_add:
+    platform_device_put(rt3261_snd_device);
+
+err:
+    kfree(rt3261_snd_priv);
+
+    return ret;
+}
+
+static int rt3261_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    rt3261_dev_uninit();
+
+    platform_device_put(rt3261_snd_device);
+    kfree(rt3261_snd_priv);
+
+    rt3261_snd_device = NULL;
+    rt3261_snd_priv = NULL;
+    rt3261_snd_pdata = NULL;
+
+    return ret;
+}
+
+static struct platform_driver aml_m6_rt3261_driver = {
+    .probe  = rt3261_audio_probe,
+    .remove = __devexit_p(rt3261_audio_remove),
+    .driver = {
+        .name = "aml_rt3261_audio",
+        .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m6_rt3261_init(void)
+{
+    return platform_driver_register(&aml_m6_rt3261_driver);
+}
+
+static void __exit aml_m6_rt3261_exit(void)
+{
+    platform_driver_unregister(&aml_m6_rt3261_driver);
+}
+
+module_init(aml_m6_rt3261_init);
+module_exit(aml_m6_rt3261_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML RT3261 audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m6/aml_m6_rt5631.c b/sound/soc/aml/m6/aml_m6_rt5631.c
new file mode 100644
index 000000000000..89ce46ce7a0e
--- /dev/null
+++ b/sound/soc/aml/m6/aml_m6_rt5631.c
@@ -0,0 +1,536 @@
+/*
+ * aml_m6_asoc_audio.c  --  SoC audio for AML M6
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/rt5631.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+
+//#include "../codecs/rt5631.h"
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+#define DRV_NAME "aml_rt5631_card"
+#define HP_DET                  1
+#define HP_IRQ                  0
+struct aml_audio_private_data {
+    int bias_level;
+    int clock_en;
+	int gpio_hp_det;
+	bool det_pol_inv;
+	struct pinctrl *pin_ctl;
+
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+
+	struct switch_dev sdev; // for android
+};
+
+static void aml_set_clock(int enable)
+{
+    /* set clock gating */
+    //p_aml_audio->clock_en = enable;
+
+    return ;
+}
+
+#if HP_DET
+static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
+{
+    p_aml_audio->timer.expires = jiffies + delay;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->detect_flag = -1;
+    add_timer(&p_aml_audio->timer);
+    p_aml_audio->timer_en = 1;
+}
+
+static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
+{
+    del_timer_sync(&p_aml_audio->timer);
+    cancel_work_sync(&p_aml_audio->work);
+    p_aml_audio->timer_en = 0;
+    p_aml_audio->detect_flag = -1;
+}
+
+static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
+{
+	int val = amlogic_get_value(p_aml_audio->gpio_hp_det,"rt5631");
+	return p_aml_audio->det_pol_inv ? (!val):val; 
+}
+
+
+static void aml_asoc_work_func(struct work_struct *work)
+{
+    struct aml_audio_private_data *p_aml_audio = NULL;
+    struct snd_soc_card *card = NULL;
+    int jack_type = 0;
+    int flag = -1;
+	int status = SND_JACK_HEADPHONE;
+    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
+    card = (struct snd_soc_card *)p_aml_audio->data;
+
+    flag = aml_audio_hp_detect(p_aml_audio);
+
+    if(p_aml_audio->detect_flag != flag) {
+        if (flag == 1) {
+			switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
+            printk(KERN_INFO "aml aduio hp pluged jack_type: %d\n", jack_type);
+            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+        } else {
+            printk(KERN_INFO "aml audio hp unpluged\n");
+			switch_set_state(&p_aml_audio->sdev, 0);
+            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+        }
+
+        p_aml_audio->detect_flag = flag;
+    }
+}
+
+
+static void aml_asoc_timer_func(unsigned long data)
+{
+    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&p_aml_audio->work);
+    mod_timer(&p_aml_audio->timer, jiffies + delay);
+}
+#endif
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+    .hw_params = aml_asoc_hw_params,
+};
+
+static int aml_set_bias_level(struct snd_soc_card *card,
+		struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+    int ret = 0;
+	struct aml_audio_private_data * p_aml_audio;
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+
+    if (p_aml_audio->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!p_aml_audio->clock_en) {
+            aml_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    default:
+        return ret;
+    }
+
+    p_aml_audio->bias_level = (int)level;
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0//HP_DET
+    /* stop timer */
+    mutex_lock(&p_aml_audio->lock);
+    if (p_aml_audio->timer_en) {
+       // rt5631_stop_timer();
+    }
+    mutex_unlock(&p_aml_audio->lock);
+#endif
+    return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define aml_suspend_pre  NULL
+#define aml_suspend_post NULL
+#define aml_resume_pre   NULL
+#define aml_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MAIN MIC", NULL),
+    SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADPHONE,
+    }
+};
+#if HP_IRQ
+static struct snd_soc_jack_gpio aml_audio_hp_jack_gpio = {
+	.name = "Headset detection",
+	.report = SND_JACK_HEADSET,
+	.debounce_time = 150,
+};
+#endif
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+    struct snd_soc_codec *codec = rtd->codec;
+    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aml_audio_private_data * p_aml_audio;
+    int ret = 0;
+	
+    printk(KERN_DEBUG "enter %s \n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    /* Add specific widgets */
+    snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+                  ARRAY_SIZE(aml_asoc_dapm_widgets));
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
+    if (ret) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret) {
+            printk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+#if HP_IRQ	
+	p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"rt5631_gpio",0);
+
+	if (gpio_is_valid(p_aml_audio->gpio_hp_det)) {
+		aml_audio_hp_jack_gpio.gpio = p_aml_audio->gpio_hp_det;
+		snd_soc_jack_add_gpios(&p_aml_audio->jack,
+						1, &aml_audio_hp_jack_gpio);
+	}
+#endif
+#if HP_DET
+    init_timer(&p_aml_audio->timer);
+    p_aml_audio->timer.function = aml_asoc_timer_func;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->data= (void*)card;
+
+    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
+    mutex_init(&p_aml_audio->lock);
+
+    mutex_lock(&p_aml_audio->lock);
+    if (!p_aml_audio->timer_en) {
+        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
+    }
+    mutex_unlock(&p_aml_audio->lock);
+
+#endif
+
+    return 0;
+}
+
+static struct snd_soc_dai_link aml_codec_dai_link[] = {
+    {
+        .name = "RT5631",
+        .stream_name = "AML PCM",
+        .cpu_dai_name = "aml-dai0",
+        //.codec_dai_name = "rt5631-hifi",
+        .init = aml_asoc_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "rt5631.2-001a",
+        .ops = &aml_asoc_ops,
+    },
+};
+
+static struct snd_soc_card aml_snd_soc_card = {
+    //.name = "AML-RT5631",
+    .driver_name = "SOC-Audio",
+    .dai_link = &aml_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(aml_codec_dai_link),
+    .set_bias_level = aml_set_bias_level,
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = aml_suspend_pre,
+	.suspend_post   = aml_suspend_post,
+	.resume_pre     = aml_resume_pre,
+	.resume_post    = aml_resume_post,
+#endif
+};
+
+static void aml_m6_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+	const char *str;
+	int ret;
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "rt5631_audio");
+#if HP_DET
+	ret = of_property_read_string(card->dev->of_node, "rt5631_gpio", &str);
+	if (ret) {
+		printk("rt5631: faild to get gpio!\n");
+	}
+	p_aml_audio->gpio_hp_det = amlogic_gpio_name_map_num(str);
+//	p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"rt5631_gpio",0);
+	p_aml_audio->det_pol_inv = of_property_read_bool(card->dev->of_node,"hp_det_inv");
+	amlogic_gpio_request_one(p_aml_audio->gpio_hp_det,GPIOF_IN,"rt5631");
+#endif
+	printk("=%s==,aml_m6_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
+}
+
+static void aml_m6_pinmux_deinit(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	amlogic_gpio_free(p_aml_audio->gpio_hp_det,"rt5631");
+	devm_pinctrl_put(p_aml_audio->pin_ctl);
+}
+static int aml_m6_audio_probe(struct platform_device *pdev)
+{
+	//struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &aml_snd_soc_card;
+	struct aml_audio_private_data *p_aml_audio;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s\n", __func__);
+
+#ifdef CONFIG_USE_OF
+	p_aml_audio = devm_kzalloc(&pdev->dev,
+			sizeof(struct aml_audio_private_data), GFP_KERNEL);
+	if (!p_aml_audio) {
+		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+	snd_soc_card_set_drvdata(card, p_aml_audio);
+	if (!(pdev->dev.of_node)) {
+		dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
+	if (ret)
+		goto err;
+	
+	ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
+			0, &aml_codec_dai_link[0].codec_dai_name);
+	if (ret)
+		goto err;
+
+	ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+	if (ret)
+		goto err;
+
+//	aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+//			pdev->dev.of_node, "aml,audio-codec", 0);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+			ret);
+		goto err;
+	}
+
+	aml_m6_pinmux_init(card);
+
+	p_aml_audio->sdev.name = "h2w";//for report headphone to android
+	ret = switch_dev_register(&p_aml_audio->sdev);
+	if (ret < 0){
+			printk(KERN_ERR "ASoC: register switch dev failed\n");
+			goto err;
+	}
+
+	return 0;
+#endif
+
+err:
+    kfree(p_aml_audio);
+    return ret;
+}
+
+static int aml_m6_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct aml_audio_private_data *p_aml_audio;
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+#if HP_IRQ
+
+	snd_soc_jack_free_gpios(&p_aml_audio->jack, 1,//
+			&aml_audio_hp_jack_gpio);//
+#endif
+	snd_soc_unregister_card(card);
+#if HP_DET
+	/* stop timer */
+	mutex_lock(&p_aml_audio->lock);
+	if (p_aml_audio->timer_en) {
+		aml_audio_stop_timer(p_aml_audio);
+	}
+	mutex_unlock(&p_aml_audio->lock);
+#endif
+
+	aml_m6_pinmux_deinit(card);
+    kfree(p_aml_audio);
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "sound_card,rt5631",//"amlogic,aml_rt5631_audio",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_m6_rt5631_audio_driver = {
+    .probe  = aml_m6_audio_probe,
+    .remove = aml_m6_audio_remove,
+    .driver = {
+        .name = DRV_NAME,//"aml_rt5631_audio",
+        .owner = THIS_MODULE,
+        .pm = &snd_soc_pm_ops,
+        .of_match_table = amlogic_audio_dt_match,
+    },
+};
+
+static int __init aml_m6_rt5631_audio_init(void)
+{
+    return platform_driver_register(&aml_m6_rt5631_audio_driver);
+}
+
+static void __exit aml_m6_rt5631_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m6_rt5631_audio_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m6_rt5631_audio_init);
+#else
+module_init(aml_m6_rt5631_audio_init);
+#endif
+module_exit(aml_m6_rt5631_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_M6 audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
+
diff --git a/sound/soc/aml/m6/aml_m6_wm8960.c b/sound/soc/aml/m6/aml_m6_wm8960.c
new file mode 100644
index 000000000000..833e4ad39350
--- /dev/null
+++ b/sound/soc/aml/m6/aml_m6_wm8960.c
@@ -0,0 +1,624 @@
+/*
+ * aml_m6_asoc_audio.c  --  SoC audio for AML M6
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/wm8960.h>
+#include <linux/delay.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+
+#include "../../codecs/wm8960.h"
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+#define DRV_NAME "aml_wm8960_card"
+#define HP_DET                  1
+#define HP_IRQ                  0
+struct aml_audio_private_data {
+    int bias_level;
+    int clock_en;
+    int gpio_hp_det;
+    bool det_pol_inv;
+    bool dis_hp_det;  /* Disable Headphone detect through codec*/
+    struct pinctrl *pin_ctl;
+
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+
+    struct switch_dev sdev; // for android
+};
+
+static void aml_set_clock(int enable)
+{
+    /* set clock gating */
+    //p_aml_audio->clock_en = enable;
+
+    return ;
+}
+
+#if HP_DET
+static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
+{
+    //printk("**********%s*************\n",__func__);
+    p_aml_audio->timer.expires = jiffies + delay;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->detect_flag = -1;
+    add_timer(&p_aml_audio->timer);
+    p_aml_audio->timer_en = 1;
+}
+
+static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
+{
+   // printk("**********%s*************\n",__func__);
+    del_timer_sync(&p_aml_audio->timer);
+    cancel_work_sync(&p_aml_audio->work);
+    p_aml_audio->timer_en = 0;
+    p_aml_audio->detect_flag = -1;
+}
+
+static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
+{
+    int val = amlogic_get_value(p_aml_audio->gpio_hp_det,"wm8960");
+    //printk("***********%s*****val=%d******\n",__func__,val);
+    return p_aml_audio->det_pol_inv ? val:(!val); 
+}
+
+
+static void aml_asoc_work_func(struct work_struct *work)
+{
+    struct aml_audio_private_data *p_aml_audio = NULL;
+    struct snd_soc_card *card = NULL;
+    int jack_type = 0;
+    int flag = -1;
+    int status = SND_JACK_HEADPHONE;
+    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
+    card = (struct snd_soc_card *)p_aml_audio->data;
+
+    flag = aml_audio_hp_detect(p_aml_audio);
+   // printk("******%s***flag=%d**\n",__func__,flag);
+    if(p_aml_audio->detect_flag != flag) {
+        if (flag == 1) {
+            switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
+            printk(KERN_INFO "aml aduio hp pluged jack_type: %d\n", jack_type);
+            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+        } else {
+            printk(KERN_INFO "aml audio hp unpluged\n");
+            switch_set_state(&p_aml_audio->sdev, 0);
+            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+        }
+
+        p_aml_audio->detect_flag = flag;
+    }
+}
+
+
+static void aml_asoc_timer_func(unsigned long data)
+{
+    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&p_aml_audio->work);
+    mod_timer(&p_aml_audio->timer, jiffies + delay);
+}
+#endif
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+    /*set codec DAI sysclk divider,now 512fs for MCLK,sysclk divide 2  */
+    snd_soc_dai_set_clkdiv(codec_dai,WM8960_SYSCLKDIV,WM8960_SYSCLK_DIV_2);
+    
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+    .hw_params = aml_asoc_hw_params,
+};
+
+static int aml_set_bias_level(struct snd_soc_card *card,
+        struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct aml_audio_private_data * p_aml_audio;
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+   // printk("*****enter %s level: %d\n", __func__, level);
+    if (p_aml_audio->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!p_aml_audio->clock_en) {
+            aml_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    default:
+        return ret;
+    }
+
+    p_aml_audio->bias_level = (int)level;
+   // dapm->bias_level = level;
+
+    //snd_soc_dapm_sync(dapm);
+
+   // printk("**pp**dapm->codec=%d*****\n",dapm->codec);
+
+    return ret;
+}
+
+
+#ifdef CONFIG_PM_SLEEP
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+#if 0//HP_DET
+    /* stop timer */
+    mutex_lock(&p_aml_audio->lock);
+    if (p_aml_audio->timer_en) {
+       // rt5631_stop_timer();
+    }
+    mutex_unlock(&p_aml_audio->lock);
+#endif
+    return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+   // printk("*******enter %s\n", __func__);
+    return 0;
+}
+#else
+#define aml_suspend_pre  NULL
+#define aml_suspend_post NULL
+#define aml_resume_pre   NULL
+#define aml_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("Mic", NULL),
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADSET,
+    }
+};
+#if HP_IRQ
+static struct snd_soc_jack_gpio aml_audio_hp_jack_gpio = {
+    .name = "Headset detection",
+    .report = SND_JACK_HEADPHONE,
+    .debounce_time = 150,
+};
+#endif
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_card *card = rtd->card;
+    struct snd_soc_codec *codec = rtd->codec;
+    //struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    struct aml_audio_private_data * p_aml_audio;
+    int ret = 0;
+    
+    printk(KERN_DEBUG "enter %s \n", __func__);
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    /* Add specific widgets */
+  //  snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+ //                ARRAY_SIZE(aml_asoc_dapm_widgets));
+    /* set ADCLRC/GPIO1 Pin Function Select */
+    snd_soc_update_bits(codec, WM8960_IFACE2, (1 << 6), (1 << 6));
+
+    /* not connected */
+    snd_soc_dapm_nc_pin(dapm, "LINPUT3");
+    snd_soc_dapm_nc_pin(dapm, "RINPUT3");
+    
+    snd_soc_dapm_nc_pin(dapm, "OUT3");
+
+    /* always connected */
+    snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+    snd_soc_dapm_enable_pin(dapm, "Mic");
+
+    /* disable connected */
+    snd_soc_dapm_disable_pin(dapm, "HP");
+
+    snd_soc_dapm_sync(dapm);
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
+    if (ret) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret) {
+            printk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+#if HP_IRQ  
+    p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"wm8960_gpio",0);
+
+    if (gpio_is_valid(p_aml_audio->gpio_hp_det)) {
+        aml_audio_hp_jack_gpio.gpio = p_aml_audio->gpio_hp_det;
+        snd_soc_jack_add_gpios(&p_aml_audio->jack,
+                        1, &aml_audio_hp_jack_gpio);
+    }
+#endif
+#if HP_DET
+    init_timer(&p_aml_audio->timer);
+    p_aml_audio->timer.function = aml_asoc_timer_func;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->data= (void*)card;
+
+    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
+    mutex_init(&p_aml_audio->lock);
+
+    mutex_lock(&p_aml_audio->lock);
+    if (!p_aml_audio->timer_en) {
+        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
+    }
+    mutex_unlock(&p_aml_audio->lock);
+
+#endif
+
+//p_aml_audio->dis_hp_det = of_property_read_bool(card->dev->of_node,"dis_hp_det");
+     ret = of_property_read_u32(card->dev->of_node,"dis_hp_det",&p_aml_audio->dis_hp_det);
+     printk("******p_aml_audio->dis_hp_det=%d***\n",p_aml_audio->dis_hp_det);
+    if(ret){
+        printk("don't find match dis_hp_det\n");
+        goto out1;
+    }
+  
+    if(!p_aml_audio->dis_hp_det){
+        printk("****mm**p_aml_audio->dis_hp_det\n");
+        //JD2 as headphone detect
+        snd_soc_update_bits(codec,27, 0x008, 0x008);// OUT3 buffer Enabled and disabled with HPL and HPR jack detect              
+        //INSERT_DELAY    [1] 
+        mdelay(1);      
+        ///GPIO1 output the "jack detect output"
+        snd_soc_update_bits(codec,48, 0x03A, 0x03A);// JD2 used for Jack Detect Input, GPIO function = jack detect output 
+
+        snd_soc_update_bits(codec,24, 0x040, 0x040);// HPDETECT LOW = Speaker 
+    
+        snd_soc_update_bits(codec, 23, 0x1D1, 0x1D1);
+        mdelay(500);
+
+    }
+out1:    
+   
+    return 0;
+}
+
+static struct snd_soc_dai_link aml_codec_dai_link[] = {
+    {
+        .name = "WM8960",
+        .stream_name = "AML PCM",
+        .cpu_dai_name = "aml-dai0",
+       // .codec_dai_name = "wm8960-hifi",
+        .init = aml_asoc_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "wm8960.2-001a",
+        .ops = &aml_asoc_ops,
+    },
+};
+
+static struct snd_soc_card aml_snd_soc_card = {
+    //.name = "AML-WM8960",
+    .driver_name = "SOC-Audio",
+    .dai_link = &aml_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(aml_codec_dai_link),
+    .dapm_widgets = aml_asoc_dapm_widgets,
+    .num_dapm_widgets = ARRAY_SIZE(aml_asoc_dapm_widgets),
+    .set_bias_level = aml_set_bias_level,
+    //.set_bias_level_post = aml_set_bias_level_post,
+    .fully_routed = true,
+#ifdef CONFIG_PM_SLEEP
+    .suspend_pre    = aml_suspend_pre,
+    .suspend_post   = aml_suspend_post,
+    .resume_pre     = aml_resume_pre,
+    .resume_post    = aml_resume_post,
+#endif
+};
+
+static void aml_m6_pinmux_init(struct snd_soc_card *card)
+{
+    struct aml_audio_private_data *p_aml_audio;
+    const char *str;
+    int ret;
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+    p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "wm8960_audio");
+#if HP_DET
+    //p_aml_audio->gpio_hp_det = of_get_named_gpio(card->dev->of_node,"wm8960_gpio",0);
+    ret = of_property_read_string(card->dev->of_node, "wm8960_gpio", &str);
+    if (ret) {
+        printk("wm8960: faild to get gpio!\n");
+    }
+    p_aml_audio->gpio_hp_det = amlogic_gpio_name_map_num(str);
+    p_aml_audio->det_pol_inv = of_property_read_bool(card->dev->of_node,"hp_det_inv");
+    amlogic_gpio_request_one(p_aml_audio->gpio_hp_det,GPIOF_IN,"wm8960");
+#endif
+    printk("=%s==,aml_m6_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
+}
+
+static void aml_m6_pinmux_deinit(struct snd_soc_card *card)
+{
+    struct aml_audio_private_data *p_aml_audio;
+
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+
+    amlogic_gpio_free(p_aml_audio->gpio_hp_det,"wm8960");
+    devm_pinctrl_put(p_aml_audio->pin_ctl);
+}
+
+/*
+static struct device_node * find_avaliable_asoc_device(struct device_node *pnode,
+    const char *name)
+{
+    struct device_node *sound_cardp;
+    struct device_node *np;
+    printk(KERN_DEBUG "enter %s \n",__func__);
+    sound_cardp = pnode;
+
+    for (np = of_get_next_child(sound_cardp, NULL); np;
+            np = of_get_next_child(sound_cardp, np)) {
+        int status = of_device_is_available(np); 
+        if(status){
+            printk("find usable sound card in the parent node of %s\n",name);      
+            of_node_put(sound_cardp);
+            return np;
+        }else{
+            continue;
+        }   
+    }
+    return NULL;
+}
+
+*/       
+static int aml_m6_audio_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *npc;
+    struct snd_soc_card *card = &aml_snd_soc_card;
+    struct aml_audio_private_data *p_aml_audio;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    printk("***enter %s\n", __func__);
+
+#ifdef CONFIG_USE_OF
+
+    p_aml_audio = devm_kzalloc(&pdev->dev,
+            sizeof(struct aml_audio_private_data), GFP_KERNEL);
+    if (!p_aml_audio) {
+        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    card->dev = &pdev->dev;
+    platform_set_drvdata(pdev, card);
+    snd_soc_card_set_drvdata(card, p_aml_audio);
+    if (!(pdev->dev.of_node)) {
+        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
+    if (ret)
+        goto err;
+
+    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
+            0, &aml_codec_dai_link[0].codec_dai_name);
+    if (ret)
+        goto err;
+
+    ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+    if (ret)
+        goto err;
+
+  //  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+  //          pdev->dev.of_node, "aml,audio-codec", 0);
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+            ret);
+        goto err;
+    }
+
+    aml_m6_pinmux_init(card);
+
+    p_aml_audio->sdev.name = "h2w";//for report headphone to android
+    ret = switch_dev_register(&p_aml_audio->sdev);
+    if (ret < 0){
+            printk(KERN_ERR "ASoC: register switch dev failed\n");
+            goto err;
+    }
+
+    return 0;
+#endif
+
+err:
+    kfree(p_aml_audio);
+    return ret;
+}
+
+static int aml_m6_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+    struct device_node *np = pdev->dev.of_node;
+    struct device_node *npc;
+    struct snd_soc_card *card;
+    struct aml_audio_private_data *p_aml_audio;
+
+    card = platform_get_drvdata(pdev);  
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+#if HP_IRQ
+
+    snd_soc_jack_free_gpios(&p_aml_audio->jack, 1,//
+            &aml_audio_hp_jack_gpio);//
+#endif
+    snd_soc_unregister_card(card);
+#if HP_DET
+    /* stop timer */
+    mutex_lock(&p_aml_audio->lock);
+    if (p_aml_audio->timer_en) {
+        aml_audio_stop_timer(p_aml_audio);
+    }
+    mutex_unlock(&p_aml_audio->lock);
+#endif
+
+    aml_m6_pinmux_deinit(card);
+    kfree(p_aml_audio);
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+    {   .compatible = "sound_card,wm8960",//"amlogic,aml_rt5631_audio",
+    },
+    {},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_m6_wm8960_audio_driver = {
+    .probe  = aml_m6_audio_probe,
+    .remove = aml_m6_audio_remove,
+    .driver = {
+        .name = DRV_NAME,//"aml_rt5631_audio",
+        .owner = THIS_MODULE,
+        .pm = &snd_soc_pm_ops,
+        .of_match_table = amlogic_audio_dt_match,
+    },
+};
+
+static int __init aml_m6_wm8960_audio_init(void)
+{
+    return platform_driver_register(&aml_m6_wm8960_audio_driver);
+}
+
+static void __exit aml_m6_wm8960_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m6_wm8960_audio_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m6_wm8960_audio_init);
+#else
+module_init(aml_m6_wm8960_audio_init);
+#endif
+module_exit(aml_m6_wm8960_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_M6 audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
+
+
diff --git a/sound/soc/aml/m6/aml_m6tv_audio.c b/sound/soc/aml/m6/aml_m6tv_audio.c
new file mode 100644
index 000000000000..79fb11041787
--- /dev/null
+++ b/sound/soc/aml/m6/aml_m6tv_audio.c
@@ -0,0 +1,338 @@
+/*
+	amlogic  M6TV sound card machine   driver code.
+	it support multi-codec on board, one codec as the main codec,others as
+	aux devices.
+*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+#include <sound/aml_m6tv_audio.h>
+
+static struct platform_device *m6tv_audio_snd_device = NULL;
+static struct m6tv_audio_codec_platform_data *m6tv_audio_snd_pdata = NULL;
+//static struct m6tv_audio_private_data* m6tv_audio_snd_priv = NULL;
+#define CODEC_DEBUG  printk
+static void m6tv_audio_dev_init(void)
+{
+    if (m6tv_audio_snd_pdata->device_init) {
+        m6tv_audio_snd_pdata->device_init();
+    }
+}
+
+static void m6tv_audio_dev_uninit(void)
+{
+    if (m6tv_audio_snd_pdata->device_uninit) {
+        m6tv_audio_snd_pdata->device_uninit();
+    }
+}
+static int m6tv_audio_prepare(struct snd_pcm_substream *substream)
+{
+    CODEC_DEBUG( "enter %s stream: %s\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture");
+    return 0;
+}
+static int m6tv_audio_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+    CODEC_DEBUG( "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 512, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        CODEC_DEBUG(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+static struct snd_soc_ops m6tv_audio_soc_ops = {
+    .prepare   = m6tv_audio_prepare,
+    .hw_params = m6tv_audio_hw_params,
+};	
+
+
+static int m6tv_audio_set_bias_level(struct snd_soc_card *card,
+					enum snd_soc_bias_level level)
+{
+	int ret = 0;
+    	CODEC_DEBUG( "enter %s level: %d\n", __func__, level);
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int m6tv_audio_suspend_pre(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+
+static int m6tv_audio_suspend_post(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+
+static int m6tv_audio_resume_pre(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+
+static int m6tv_audio_resume_post(struct snd_soc_card *card)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define m6tv_audio_suspend_pre  NULL
+#define m6tv_audio_suspend_post NULL
+#define m6tv_audio_resume_pre   NULL
+#define m6tv_audio_resume_post  NULL
+#endif
+
+static int m6tv_audio_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    struct snd_soc_codec *codec = rtd->codec;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+    int ret = 0;
+
+    CODEC_DEBUG( "enter %s\n", __func__);
+
+  
+    return 0;
+}
+#ifdef CONFIG_SND_AML_M6TV_STA380
+static int m6tv_sta381xx_init(struct snd_soc_dapm_context *dapm)
+{
+	CODEC_DEBUG("~~~~%s\n", __func__);
+
+	snd_soc_codec_set_sysclk(dapm->codec, 1, 48000 * 512, 0);
+	return 0;
+}
+#endif
+#ifdef CONFIG_SND_AML_M6TV_TAS5711
+static int m6tv_tas5711_init(struct snd_soc_dapm_context *dapm)
+{
+	struct snd_soc_codec *codec = dapm->codec;
+	CODEC_DEBUG("~~~~%s\n", __func__);
+
+	return 0;
+}
+#endif
+static struct snd_soc_dai_link m6tv_audio_dai_link[] = {
+#ifdef CONFIG_SND_AML_M6TV_SYNOPSYS9629_CODEC
+    {
+        .name = "syno9629",
+        .stream_name = "SYNO9629 PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "syno9629-hifi",
+        .init = m6tv_audio_codec_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "syno9629.0",
+        .ops = &m6tv_audio_soc_ops,
+    },
+#endif    
+};
+struct snd_soc_aux_dev m6tv_audio_aux_dev[] = {
+#ifdef CONFIG_SND_AML_M6TV_RT5631	
+	{
+		.name = "rt5631",
+		.codec_name = "rt5631.0-001a",
+		.init = NULL,
+	},
+#endif	
+#ifdef CONFIG_SND_AML_M6TV_STA380
+	{
+		.name = "sta381xx",
+		.codec_name = "sta381xx.0-001c",
+		.init = m6tv_sta381xx_init,
+	},
+#endif
+#ifdef CONFIG_SND_AML_M6TV_TAS5711
+	{
+		.name = "tas5711",
+		.codec_name = "tas5711.0-001b",
+		.init = m6tv_tas5711_init,
+	},
+#endif
+};
+
+static struct snd_soc_codec_conf m6tv_audio_codec_conf[] = {
+#ifdef CONFIG_SND_AML_M6TV_RT5631	
+	
+	{
+		.dev_name = "rt5631.0-001a",
+		.name_prefix = "b",
+	},
+#endif
+#ifdef CONFIG_SND_AML_M6TV_STA380	
+	{
+		.dev_name = "sta381xx.0-001c",
+		.name_prefix = "AMP",
+	},
+#endif
+#ifdef CONFIG_SND_AML_M6TV_TAS5711	
+	{
+		.dev_name = "tas5711.0-001b",
+		.name_prefix = "AMP",
+	},
+#endif
+};
+static struct snd_soc_card snd_soc_m6tv_audio = {
+    .name = "AML-M6TV",
+    .driver_name = "SOC-Audio",
+    .dai_link = m6tv_audio_dai_link,
+    .num_links = ARRAY_SIZE(m6tv_audio_dai_link),
+    .set_bias_level = m6tv_audio_set_bias_level,
+    .aux_dev = m6tv_audio_aux_dev,
+    .num_aux_devs = ARRAY_SIZE(m6tv_audio_aux_dev),
+    .codec_conf = m6tv_audio_codec_conf,
+    .num_configs = ARRAY_SIZE(m6tv_audio_codec_conf),
+    
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = m6tv_audio_suspend_pre,
+	.suspend_post   = m6tv_audio_suspend_post,
+	.resume_pre     = m6tv_audio_resume_pre,
+	.resume_post    = m6tv_audio_resume_post,
+#endif
+};
+
+
+
+
+
+
+static int m6tv_audio_audio_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	m6tv_audio_snd_pdata = pdev->dev.platform_data;
+	snd_BUG_ON(!m6tv_audio_snd_pdata);
+#if 0
+	m6tv_audio_snd_priv = (struct m6tv_audio_private_data*)kzalloc(sizeof(struct m6tv_audio_private_data), GFP_KERNEL);
+	if (!m6tv_audio_snd_priv) {
+		CODEC_DEBUG(KERN_ERR "ASoC: Platform driver data allocation failed\n");
+		return -ENOMEM;
+	}
+#endif
+	m6tv_audio_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!m6tv_audio_snd_device) {
+		CODEC_DEBUG(KERN_ERR "ASoC: Platform device allocation failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	platform_set_drvdata(m6tv_audio_snd_device, &snd_soc_m6tv_audio);
+	m6tv_audio_snd_device->dev.platform_data = m6tv_audio_snd_pdata;
+
+	ret = platform_device_add(m6tv_audio_snd_device);
+	if (ret) {
+		CODEC_DEBUG(KERN_ERR "ASoC: Platform device allocation failed\n");
+		goto err_device_add;
+	}
+
+//	m6tv_audio_snd_priv->bias_level = SND_SOC_BIAS_OFF;
+//	m6tv_audio_snd_priv->clock_en = 0;
+
+	m6tv_audio_dev_init();
+	return ret;
+err_device_add:
+	platform_device_put(m6tv_audio_snd_device);
+
+err:
+//	kfree(m6tv_audio_snd_priv);
+
+	return ret;
+}
+
+static int m6tv_audio_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+    m6tv_audio_dev_uninit();
+    platform_device_put(m6tv_audio_snd_device);
+//    kfree(m6tv_audio_snd_priv);
+    m6tv_audio_snd_device = NULL;
+//    m6tv_audio_snd_priv = NULL;
+    m6tv_audio_snd_pdata = NULL;
+    return ret;
+}
+
+static struct platform_driver aml_m6tv_audio_driver = {
+    .probe  = m6tv_audio_audio_probe,
+    .remove = __devexit_p(m6tv_audio_audio_remove),
+    .driver = {
+        .name = "aml_m6tv_audio",
+        .owner = THIS_MODULE,
+    },
+};
+
+static int __init aml_m6tv_audio_init(void)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+	return platform_driver_register(&aml_m6tv_audio_driver);
+}
+
+static void __exit aml_m6tv_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m6tv_audio_driver);
+}
+
+module_init(aml_m6tv_audio_init);
+module_exit(aml_m6tv_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("jian.xu@amlogic.com AMLogic, Inc.");
+MODULE_DESCRIPTION("AML SYNO9629 ALSA machine layer driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/aml/m6/aml_m_dummy.c b/sound/soc/aml/m6/aml_m_dummy.c
new file mode 100644
index 000000000000..d99e480ef84b
--- /dev/null
+++ b/sound/soc/aml/m6/aml_m_dummy.c
@@ -0,0 +1,338 @@
+/*
+ * aml_m_dummy_codec.c  --  SoC audio for AML M series
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/dummy_codec.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "aml_dai.h"
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+static struct dummy_codec_platform_data *dummy_codec_snd_pdata = NULL;
+
+#ifdef CONFIG_USE_OF
+static struct device_node *np = NULL;
+static struct dummy_codec_platform_data *dummy_codec_pdata = NULL;
+struct device *dummy_codec_dev = NULL;
+struct pinctrl *p = NULL;
+#endif
+static void dummy_codec_dev_init(void)
+{
+    if (dummy_codec_snd_pdata->device_init) {
+        dummy_codec_snd_pdata->device_init();
+    }
+}
+
+static void dummy_codec_dev_uninit(void)
+{
+    if (dummy_codec_snd_pdata->device_uninit) {
+        dummy_codec_snd_pdata->device_uninit();
+    }
+}
+
+static void dummy_codec_mute_speaker(int mute)
+{
+	if (dummy_codec_snd_pdata->mute_spk){
+		dummy_codec_snd_pdata->mute_spk(mute);
+	}
+}
+static int dummy_codec_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s rate: %d format: %d\n", __func__, params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	}
+	else
+    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+#if 0   //no audio in
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+#endif
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops dummy_codec_soc_ops = {
+    .hw_params = dummy_codec_hw_params,
+};
+
+static int dummy_codec_set_bias_level(struct snd_soc_card *card,
+			      enum snd_soc_bias_level level)
+{
+    int ret = 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+    	dummy_codec_mute_speaker(0);
+        break;
+
+    case SND_SOC_BIAS_OFF:
+    	break;
+    case SND_SOC_BIAS_STANDBY:
+        dummy_codec_mute_speaker(1);
+        break;
+    default:
+        return ret;
+    }
+    return 0;
+}
+
+static int dummy_codec_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    return 0;
+}
+
+static struct snd_soc_dai_link dummy_codec_dai_link[] = {
+    {
+        .name = "DUMMY_CODEC",
+        .stream_name = "DUMMY_CODEC PCM",
+        .cpu_dai_name = "aml-dai0",
+        .codec_dai_name = "dummy_codec",
+        .init = dummy_codec_codec_init,
+        .platform_name = "aml-audio.0",
+        .codec_name = "dummy_codec.0",
+        .ops = &dummy_codec_soc_ops,
+    },
+#ifdef CONFIG_SND_SOC_PCM2BT
+    {
+        .name = "BT Voice",
+        .stream_name = "Voice PCM",
+        .cpu_dai_name = "aml-dai1",
+        .codec_dai_name = "pcm2bt-pcm",
+        .platform_name = "aml-audio.0",
+        .codec_name = "pcm2bt.0",
+        //.ops = &voice_soc_ops,
+    },
+#endif
+};
+
+static struct snd_soc_card snd_soc_dummy_codec = {
+    .name = "AML-DUMMY-CODEC",
+    .driver_name = "SOC-Audio",
+    .dai_link = &dummy_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(dummy_codec_dai_link),
+    .set_bias_level = dummy_codec_set_bias_level,
+};
+
+#ifdef CONFIG_USE_OF
+static void dummy_codec_device_init(void)
+{
+#ifdef CONFIG_USE_OF
+	int ret;
+	struct pinctrl_state *s;
+	p = pinctrl_get(dummy_codec_dev);
+
+	if (IS_ERR(p))
+		return p;
+			
+	s = pinctrl_lookup_state(p, "dummy_codec_audio");
+	if (IS_ERR(s)) {
+		pinctrl_put(p);
+		return ERR_PTR(PTR_ERR(s));
+	}
+		
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+	printk("=%s==,dummy_codec_audio init done\n",__func__);
+#else
+    /* audio pinmux */
+//    pinmux_set(&rt5631_pinmux_set);
+
+    /* GPIOA_19 PULL_UP_REG0 bit19 */
+//    aml_set_reg32_bits(P_PAD_PULL_UP_REG0, 1, 19, 1);
+#endif
+}
+
+static void dummy_codec_device_deinit(void)
+{
+#ifdef CONFIG_USE_OF
+	pinctrl_put(p);
+#else
+//    pinmux_clr(&rt5631_pinmux_set);
+#endif
+}
+#endif
+static struct platform_device *dummy_codec_snd_device = NULL;
+
+static int dummy_codec_audio_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    //printk(KERN_DEBUG "enter %s\n", __func__);
+    printk("enter %s\n", __func__);
+#ifdef CONFIG_USE_OF		
+		dummy_codec_pdata = kzalloc(sizeof(struct dummy_codec_platform_data), GFP_KERNEL);
+		if(!dummy_codec_pdata){
+           // kfree(dummy_codec_pdata);
+			return -1;
+		}
+
+		if (pdev->dev.of_node) {
+            np = pdev->dev.of_node;
+            ret = of_property_match_string(np,"status","okay");
+            if(ret){
+                printk("the platform not register this codec\n");
+				goto err1;
+            }
+		}
+		dummy_codec_dev=&pdev->dev;		
+    dummy_codec_pdata->device_init = &dummy_codec_device_init;
+    dummy_codec_pdata->device_uninit = &dummy_codec_device_deinit;
+         
+		pdev->dev.platform_data = dummy_codec_pdata;
+#endif
+
+    dummy_codec_snd_pdata = pdev->dev.platform_data;
+    snd_BUG_ON(!dummy_codec_snd_pdata);
+    dummy_codec_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!dummy_codec_snd_device) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    platform_set_drvdata(dummy_codec_snd_device, &snd_soc_dummy_codec);
+
+    ret = platform_device_add(dummy_codec_snd_device);
+    if (ret) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto err_device_add;
+    }
+
+
+    dummy_codec_dev_init();
+
+    return ret;
+
+err_device_add:
+    platform_device_put(dummy_codec_snd_device);
+err:
+err1:
+    kfree(dummy_codec_pdata);
+    return ret;
+}
+
+static int dummy_codec_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    dummy_codec_dev_uninit();
+
+    platform_device_put(dummy_codec_snd_device);
+    kfree(dummy_codec_pdata);
+
+    dummy_codec_snd_device = NULL;
+    dummy_codec_snd_pdata = NULL;
+
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_dummy_codec_dt_match[]={
+	{	.compatible = "amlogic,aml_dummy_codec_audio",
+	},
+	{},
+};
+#else
+#define aml_dummy_codec_dt_match NULL
+#endif
+static struct platform_driver aml_m_dummy_codec_driver = {
+    .probe  = dummy_codec_audio_probe,
+    .remove = dummy_codec_audio_remove,
+    .driver = {
+        .name = "aml_dummy_codec_audio",
+        .owner = THIS_MODULE,
+        .of_match_table = aml_dummy_codec_dt_match,
+    },
+};
+
+static int __init aml_m_dummy_codec_init(void)
+{
+    return platform_driver_register(&aml_m_dummy_codec_driver);
+}
+
+static void __exit aml_m_dummy_codec_exit(void)
+{
+    platform_driver_unregister(&aml_m_dummy_codec_driver);
+}
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m_dummy_codec_init);
+#else
+module_init(aml_m_dummy_codec_init);
+#endif
+module_exit(aml_m_dummy_codec_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML dummy_codec audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m6/aml_mixer.c b/sound/soc/aml/m6/aml_mixer.c
new file mode 100644
index 000000000000..d7aab5661ee8
--- /dev/null
+++ b/sound/soc/aml/m6/aml_mixer.c
@@ -0,0 +1,371 @@
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/soundcard.h>
+
+#include "aml_pcm.h"
+#include "aml_alsa_common.h"
+#include "aml_audio_hw.h"
+
+extern audio_tone_control_t audio_tone_control;
+
+static int pcm_pb_volume_info(struct snd_kcontrol *kcontrol,
+                              struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 100;
+    uinfo->value.integer.step = 1;
+
+    return 0;
+}
+
+static int pcm_pb_volume_get(struct snd_kcontrol *kcontrol,
+                             struct snd_ctl_elem_value *uvalue)
+{
+    int val;
+
+    val = get_mixer_output_volume();
+    val = val & 0xff;
+    uvalue->value.integer.value[0] = val;
+
+    return 0;
+}
+
+static int pcm_pb_volume_put(struct snd_kcontrol *kcontrol,
+                             struct snd_ctl_elem_value *uvalue)
+{
+    int volume;
+
+    volume = uvalue->value.integer.value[0];
+  //  volume = volume | (volume << 8);
+    set_mixer_output_volume(volume);
+    return 0;
+}
+
+static int pcm_pb_mute_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_pb_mute_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_pb_mute_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag)
+	 	audio_i2s_unmute();
+	 else
+	 	audio_i2s_mute();
+
+     return 0;
+}
+
+static int pcm_left_mono_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_left_mono_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_left_mono_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(1);
+     }
+
+     return 0;
+}
+
+static int pcm_right_mono_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_right_mono_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_right_mono_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(2);
+     }
+
+     return 0;
+}
+
+static int pcm_stereo_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_stereo_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_stereo_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(0);
+     }
+
+     return 0;
+}
+
+static int pcm_swap_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_swap_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_swap_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+     unsigned int reg;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+		reg = read_i2s_mute_swap_reg();
+		if((reg & 0x3))
+			audio_i2s_swap_left_right(0);
+		else
+			audio_i2s_swap_left_right(3);
+     }
+
+     return 0;
+}
+
+static int pcm_pb_data_info(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+    uinfo->count = 128;
+
+    return 0;
+}
+
+static int pcm_pb_data_get(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_value *uvalue)
+{
+    unsigned int rd_ptr;
+
+    rd_ptr = read_i2s_rd_ptr();
+    memcpy(uvalue->value.bytes.data, (unsigned char*)rd_ptr, 128);
+    return 0;
+}
+
+static int pcm_pb_tone_info(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_pb_tone_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     audio_tone_control.tone_flag = 1;
+	
+     return 0;
+}
+static int pcm_pb_tone_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     return 0;
+}
+struct snd_kcontrol_new pcm_control_pb_vol = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "Master Playback Volume",
+    .index = 0x00,
+    .info = pcm_pb_volume_info,
+    .get = pcm_pb_volume_get,
+    .put = pcm_pb_volume_put,
+    .private_value = 0x0,
+};
+
+struct snd_kcontrol_new pcm_switch_pb_mute = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "switch playback mute",
+     .index = 0x00,
+     .info = pcm_pb_mute_info,
+     .get = pcm_pb_mute_get,
+     .put = pcm_pb_mute_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_left_mono = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Left Mono",
+     .index = 0x00,
+     .info = pcm_left_mono_info,
+     .get = pcm_left_mono_get,
+     .put = pcm_left_mono_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_right_mono = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Right Mono",
+     .index = 0x00,
+     .info = pcm_right_mono_info,
+     .get = pcm_right_mono_get,
+     .put = pcm_right_mono_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_stereo = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Stereo Out",
+     .index = 0x00,
+     .info = pcm_stereo_info,
+     .get = pcm_stereo_get,
+     .put = pcm_stereo_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_swap = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Swap Left Right",
+     .index = 0x00,
+     .info = pcm_swap_info,
+     .get = pcm_swap_get,
+     .put = pcm_swap_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_data_read = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Playback Data Get",
+	.info = pcm_pb_data_info,
+	.get = pcm_pb_data_get,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_VOLATILE),
+};
+
+struct snd_kcontrol_new pcm_tone_play = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Playback Tone",
+	.info = pcm_pb_tone_info,
+	.put = pcm_pb_tone_put,
+	.get = pcm_pb_tone_get,
+	.access = (SNDRV_CTL_ELEM_ACCESS_WRITE |
+	          SNDRV_CTL_ELEM_ACCESS_READ), 
+	          
+};
+
+int aml_alsa_create_ctrl(struct snd_card *card, void *p_value)
+{
+    int err = 0;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_control_pb_vol, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_switch_pb_mute, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_left_mono, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_right_mono, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_stereo, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_swap, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_data_read, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_tone_play, p_value))) < 0)
+        return err;
+	
+    return 0;
+}
diff --git a/sound/soc/aml/m6/aml_notify.c b/sound/soc/aml/m6/aml_notify.c
new file mode 100644
index 000000000000..d24962f6ed47
--- /dev/null
+++ b/sound/soc/aml/m6/aml_notify.c
@@ -0,0 +1,43 @@
+/*
+ *  linux/drivers/video/apollo/aout_notify.c
+ *
+ *  Copyright (C) 2009 amlogic
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+
+static BLOCKING_NOTIFIER_HEAD(aout_notifier_list);
+/**
+ *	aout_register_client - register a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int aout_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&aout_notifier_list, nb);
+}
+EXPORT_SYMBOL(aout_register_client);
+
+/**
+ *	aout_unregister_client - unregister a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int aout_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&aout_notifier_list, nb);
+}
+EXPORT_SYMBOL(aout_unregister_client);
+
+/**
+ * aout_notifier_call_chain - notify clients of fb_events
+ *
+ */
+int aout_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&aout_notifier_list, val, v);
+}
+EXPORT_SYMBOL_GPL(aout_notifier_call_chain);
+
+
diff --git a/sound/soc/aml/m6/aml_pcm.c b/sound/soc/aml/m6/aml_pcm.c
new file mode 100644
index 000000000000..d89860061fa5
--- /dev/null
+++ b/sound/soc/aml/m6/aml_pcm.c
@@ -0,0 +1,1630 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/hrtimer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+//#include <sound/rt5631.h>
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include <linux/amlogic/amports/amaudio.h>
+
+#include <mach/mod_gate.h>
+
+#include "aml_pcm.h"
+#include "aml_audio_hw.h"
+#include "aml_platform.h"
+
+//#define _AML_PCM_DEBUG_
+//
+
+#define USE_HRTIMER 0
+#define HRTIMER_PERIOD (1000000000UL/48000)
+
+#define AOUT_EVENT_IEC_60958_PCM                0x1
+#define AOUT_EVENT_RAWDATA_AC_3                 0x2
+#define AOUT_EVENT_RAWDATA_MPEG1                0x3
+#define AOUT_EVENT_RAWDATA_MP3                  0x4
+#define AOUT_EVENT_RAWDATA_MPEG2                0x5
+#define AOUT_EVENT_RAWDATA_AAC                  0x6
+#define AOUT_EVENT_RAWDATA_DTS                  0x7
+#define AOUT_EVENT_RAWDATA_ATRAC                0x8
+#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
+#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
+#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
+#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
+#define AOUT_EVENT_RAWDATA_DST                  0xD
+#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
+
+extern int aout_notifier_call_chain(unsigned long val, void *v);
+extern void	aml_alsa_hw_reprepare(void);
+
+extern unsigned IEC958_mode_raw;
+extern unsigned IEC958_mode_codec;
+
+unsigned int aml_i2s_playback_start_addr = 0;
+unsigned int aml_i2s_capture_start_addr  = 0;
+
+unsigned int aml_pcm_playback_end_addr = 0;
+unsigned int aml_pcm_capture_end_addr = 0;
+
+unsigned int aml_i2s_capture_start_phy = 0;
+unsigned int aml_i2s_capture_buf_size = 0;
+unsigned int aml_pcm_playback_phy_start_addr = 0;
+unsigned int aml_pcm_capture_phy_start_addr  = 0;
+unsigned int aml_pcm_playback_phy_end_addr = 0;
+unsigned int aml_pcm_capture_phy_end_addr = 0;
+unsigned int aml_pcm_playback_off = 0;
+unsigned int aml_i2s_playback_enable = 1;
+
+unsigned int aml_iec958_playback_start_addr = 0;
+unsigned int aml_iec958_playback_start_phy = 0;
+unsigned int aml_iec958_playback_size = 0;  // in bytes
+
+static  unsigned  playback_substream_handle = 0 ;
+/*to keep the pcm status for clockgating*/
+static unsigned clock_gating_status = 0;
+static unsigned clock_gating_playback = 1;
+static unsigned clock_gating_capture = 2;
+static int audio_type_info = -1;
+static int audio_sr_info = -1;
+extern unsigned audioin_mode;
+
+
+static int audio_ch_info = -1;
+
+//static struct rt5631_platform_data *rt5631_snd_pdata = NULL;
+static struct aml_pcm_work_t{
+	struct snd_pcm_substream *substream;
+	struct work_struct aml_codec_workqueue;
+}aml_pcm_work;
+
+int codec_power=1;
+unsigned int flag=0;
+static int num=0;
+
+static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int status);
+
+EXPORT_SYMBOL(aml_i2s_playback_start_addr);
+EXPORT_SYMBOL(aml_i2s_capture_start_addr);
+EXPORT_SYMBOL(aml_pcm_playback_off);
+EXPORT_SYMBOL(aml_i2s_playback_enable);
+
+static void aml_codec_power_switch_queue(struct work_struct* work)
+{
+
+#ifdef _AML_PCM_DEBUG_
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	// disable power down/up, which caused pop noise
+	//codec_power_switch(substream, clock_gating_status);
+}
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE,
+
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 128 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static const struct snd_pcm_hardware aml_pcm_capture = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_MMAP |
+						 	SNDRV_PCM_INFO_MMAP_VALID |
+						  SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static char snd_pcm_tmp[32*1024];
+
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+/*--------------------------------------------------------------------------*\
+ * audio clock gating
+\*--------------------------------------------------------------------------*/
+#if 0
+static void aml_audio_clock_gating_disable(void)
+{
+#ifdef _AML_PCM_DEBUG_
+			printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+/*
+	aml_clr_reg32_mask(P_HHI_GCLK_MPEG0, (1<<18));
+	aml_clr_reg32_mask(P_HHI_GCLK_MPEG1, (1<<2)
+										|(0xba<<6)
+								    	);
+	aml_clr_reg32_mask(P_HHI_GCLK_OTHER, (1<<18)
+										|(0x6<<14)
+								    	);
+ */   aml_clr_reg32_mask( P_HHI_AUD_CLK_CNTL, (1 << 8));
+
+	//printk("P_HHI_GCLK_MPEG0=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG0));
+	//printk("P_HHI_GCLK_MPEG1=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG1));
+	//printk("P_HHI_GCLK_OTHER=disable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_OTHER));
+}
+
+static void aml_audio_clock_gating_enable(void)
+{
+#ifdef _AML_PCM_DEBUG_
+			printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+/*	aml_set_reg32_mask(P_HHI_GCLK_MPEG0, (1<<18));
+	aml_set_reg32_mask(P_HHI_GCLK_MPEG1, (1<<2)
+								    	|(0xba<<6)
+								   		 );
+	aml_set_reg32_mask(P_HHI_GCLK_OTHER, (1<<18)
+								    	|(0x6<<14)
+								    	);
+*/    aml_set_reg32_mask( P_HHI_AUD_CLK_CNTL, (1 << 8));
+	//printk("P_HHI_GCLK_MPEG0=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG0));
+	//printk("P_HHI_GCLK_MPEG1=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_MPEG1));
+	//printk("P_HHI_GCLK_OTHER=enable--%#x\n\n", aml_read_reg32(P_HHI_GCLK_OTHER));
+}
+#endif
+
+#if 0
+static void aml_clock_gating(unsigned int status)
+{
+//printk("-----status=%d\n\n",status);
+	if(status){
+		aml_audio_clock_gating_enable();
+	}
+	else{
+		aml_audio_clock_gating_disable();
+	}
+}
+#endif
+/*--------------------------------------------------------------------------*\
+ * audio codec power management
+\*--------------------------------------------------------------------------*/
+#if 0
+static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int status)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+#ifdef _AML_PCM_DEBUG_
+			printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(status && codec_dai->driver->ops->startup)
+			codec_dai->driver->ops->startup(substream, codec_dai);
+
+	if((flag)&& (!status) && (codec_dai->driver->ops->shutdown))
+			codec_dai->driver->ops->shutdown(substream, codec_dai);
+	return 0;
+}
+#endif
+/*--------------------------------------------------------------------------*\
+ * Helper functions
+\*--------------------------------------------------------------------------*/
+static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+	size_t size = 0;
+
+    if(pcm->device == 0)
+    {
+	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		    size = aml_pcm_hardware.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+            /* one size for i2s output, another for 958, and 128 for alignment */
+		    buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-pcm %d:"
+		    "playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+
+            /* alloc iec958 buffer */
+
+            aml_i2s_playback_start_addr = (unsigned int)buf->area;
+		    aml_pcm_playback_end_addr = (unsigned int)buf->area + size;
+
+		aml_pcm_playback_phy_start_addr = buf->addr;
+		aml_pcm_playback_phy_end_addr = buf->addr+size;
+
+        /* alloc iec958 buffer */
+        aml_iec958_playback_start_addr = (unsigned int)dma_alloc_coherent(pcm->card->dev, size*4,
+           (dma_addr_t *)(&aml_iec958_playback_start_phy), GFP_KERNEL);
+        if(aml_iec958_playback_start_addr == 0){
+          printk("aml-pcm %d: alloc iec958 buffer failed\n", stream);
+          return -ENOMEM;
+        }
+        aml_iec958_playback_size = size*4;
+        printk("iec958 %d: preallocate dma buffer start=%p, size=%x\n", stream, (void*)aml_iec958_playback_start_addr, size*4);
+	}else{
+		size = aml_pcm_capture.buffer_bytes_max;
+		buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		buf->dev.dev = pcm->card->dev;
+		buf->private_data = NULL;
+		buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-pcm %d:"
+		    "capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+
+            aml_i2s_capture_start_addr = (unsigned int)buf->area;
+		    aml_pcm_capture_end_addr = (unsigned int)buf->area+size;
+		    aml_i2s_capture_start_phy = buf->addr;
+		    aml_i2s_capture_buf_size = size;
+		    aml_pcm_capture_phy_start_addr = buf->addr;
+		    aml_pcm_capture_phy_end_addr = buf->addr+size;
+	    }
+
+	    if (!buf->area)
+		    return -ENOMEM;
+
+	    buf->bytes = size;
+	    return 0;
+    }
+    else
+    {
+	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		    size = aml_pcm_hardware.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+            /* one size for i2s output, another for 958, and 128 for alignment */
+		    //buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
+					  //&buf->addr, GFP_KERNEL);
+            buf->area = aml_i2s_playback_start_addr;
+            buf->addr = aml_pcm_playback_phy_start_addr;
+		    printk("aml-pcm %d:"
+		    "dev>0 playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+
+        }else{
+		    size = aml_pcm_capture.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+		    //buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
+		    //			  &buf->addr, GFP_KERNEL);
+		    buf->area = aml_i2s_capture_start_addr;
+            buf->addr = aml_pcm_capture_phy_start_addr;
+		    printk("aml-pcm %d:"
+		    "dev>0 capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+	    }
+
+	    if (!buf->area)
+		    return -ENOMEM;
+
+	    buf->bytes = size;
+	    return 0;
+
+    }
+}
+/*--------------------------------------------------------------------------*\
+ * ISR
+\*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*\
+ * PCM operations
+\*--------------------------------------------------------------------------*/
+static int aml_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+//	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	audio_stream_t *s = &prtd->s;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		aml_iec958_playback_size = runtime->dma_bytes*4;
+	s->I2S_addr = runtime->dma_addr;
+
+    /*
+     * Both capture and playback need to reset the last ptr to the start address,
+       playback and capture use different address calculate, so we reset the different
+       start address to the last ptr
+   * */
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+        /* s->last_ptr must initialized as dma buffer's start addr */
+        s->last_ptr = runtime->dma_addr;
+    }else{
+
+	s->last_ptr = 0;
+    }
+
+	return 0;
+}
+
+static int aml_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	struct aml_pcm_dma_params *params = prtd->params;
+	if (params != NULL) {
+
+	}
+
+	return 0;
+}
+/*
+the I2S hw  and IEC958 PCM output initation,958 initation here,
+for the case that only use our ALSA driver for PCM s/pdif output.
+*/
+static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
+{
+
+
+		switch(runtime->format){
+		case SNDRV_PCM_FORMAT_S32_LE:
+			I2S_MODE = AIU_I2S_MODE_PCM32;
+		// IEC958_MODE = AIU_958_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			I2S_MODE = AIU_I2S_MODE_PCM24;
+		// IEC958_MODE = AIU_958_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16_LE:
+			I2S_MODE = AIU_I2S_MODE_PCM16;
+		// IEC958_MODE = AIU_958_MODE_PCM16;
+			break;
+		}
+		audio_set_i2s_mode(I2S_MODE);
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, runtime->channels);
+		memset((void*)runtime->dma_area,0,runtime->dma_bytes + 4096);
+		/* update the i2s hw buffer end addr as android may update that */
+		aml_pcm_playback_phy_end_addr = aml_pcm_playback_phy_start_addr+runtime->dma_bytes;
+		printk("I2S hw init,i2s mode %d\n",I2S_MODE);
+
+}
+/*add audio_hdmi_init_ready check ,as hdmi audio may init fails:
+AIU_HDMI_CLK_DATA_CTRL can be writen sucessfully when audio PLL OFF.
+so notify HDMI to set audio parameter every time when HDMI AUDIO not ready
+*/
+
+static int audio_notify_hdmi_info(int audio_type, void *v){
+    	struct snd_pcm_substream *substream =(struct snd_pcm_substream*)v;
+	if(substream->runtime->rate != audio_sr_info || audio_type_info != audio_type || !audio_hdmi_init_ready()
+		|| substream->runtime->channels != audio_ch_info)
+	{
+		printk("audio info changed.notify to hdmi: type %d,sr %d,ch %d\n",audio_type,substream->runtime->rate,
+			substream->runtime->channels);
+		aout_notifier_call_chain(audio_type,v);
+	}
+	audio_sr_info = substream->runtime->rate;
+	audio_ch_info = substream->runtime->channels;
+	audio_type_info = audio_type;
+
+}
+static void iec958_notify_hdmi_info(void)
+{
+	unsigned audio_type = AOUT_EVENT_IEC_60958_PCM;
+	if(playback_substream_handle){
+		if(IEC958_mode_codec == 2) //dd
+			audio_type = AOUT_EVENT_RAWDATA_AC_3;
+		else if(IEC958_mode_codec == 4)//dd+
+			audio_type = AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS;
+		else if(IEC958_mode_codec == 1|| IEC958_mode_codec == 3)//dts
+			audio_type = AOUT_EVENT_RAWDATA_DTS;
+		else
+			audio_type = AOUT_EVENT_IEC_60958_PCM;
+		printk("iec958 nodify hdmi audio type %d\n",	audio_type);
+		audio_notify_hdmi_info(audio_type, (struct snd_pcm_substream *)playback_substream_handle);
+	}
+	else{
+		printk("substream for playback NULL\n");
+	}
+
+}
+/*
+special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
+1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
+2)PCM  output for  all audio, when pcm mode is selected by user .
+3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
+*/
+static void aml_hw_iec958_init(void)
+{
+    _aiu_958_raw_setting_t set;
+    _aiu_958_channel_status_t chstat;
+    unsigned start,size;
+	memset((void*)(&set), 0, sizeof(set));
+	memset((void*)(&chstat), 0, sizeof(chstat));
+	set.chan_stat = &chstat;
+   	/* case 1,raw mode enabled */
+	if(IEC958_mode_codec){
+	  if(IEC958_mode_codec == 1){ //dts, use raw sync-word mode
+	    	IEC958_MODE = AIU_958_MODE_RAW;
+		printk("iec958 mode RAW\n");
+	  }
+	  else{ //ac3,use the same pcm mode as i2s configuration
+		IEC958_MODE = AIU_958_MODE_PCM_RAW;
+		printk("iec958 mode %s\n",(I2S_MODE == AIU_I2S_MODE_PCM32)?"PCM32_RAW":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24_RAW":"PCM16_RAW"));
+	  }
+	}else{	/* case 2,3 */
+	  if(I2S_MODE == AIU_I2S_MODE_PCM32)
+	  	IEC958_MODE = AIU_958_MODE_PCM32;
+	  else if(I2S_MODE == AIU_I2S_MODE_PCM24)
+	  	IEC958_MODE = AIU_958_MODE_PCM24;
+	  else
+	  	IEC958_MODE = AIU_958_MODE_PCM16;
+  	  printk("iec958 mode %s\n",(I2S_MODE == AIU_I2S_MODE_PCM32)?"PCM32":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24":"PCM16"));
+	}
+
+	if(IEC958_MODE == AIU_958_MODE_PCM16 || IEC958_MODE == AIU_958_MODE_PCM24 ||
+	  IEC958_MODE == AIU_958_MODE_PCM32){
+	    set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+        start = (aml_pcm_playback_phy_start_addr);
+        size = aml_pcm_playback_phy_end_addr - aml_pcm_playback_phy_start_addr;
+		audio_set_958outbuf(start, size, 0);
+	  }else{
+		set.chan_stat->chstat0_l = 0x1902;//NONE-PCM
+		set.chan_stat->chstat0_r = 0x1902;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+        // start = ((aml_pcm_playback_phy_end_addr + 4096)&(~127));
+        // size  = aml_pcm_playback_phy_end_addr - aml_pcm_playback_phy_start_addr;
+        start = aml_iec958_playback_start_phy;
+        size = aml_iec958_playback_size;
+		audio_set_958outbuf(start, size, (IEC958_MODE == AIU_958_MODE_RAW)?1:0);
+		memset((void*)aml_iec958_playback_start_addr,0,size);
+
+	}
+	audio_set_958_mode(IEC958_MODE, &set);
+	if(IEC958_mode_codec == 4)  //dd+
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2); // 4x than i2s
+	else
+#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1	
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);//512fs divide 4 == 128fs
+#else
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 4, 2); //256fs divide 2 == 128fs
+#endif
+	iec958_notify_hdmi_info();
+
+
+}
+
+void	aml_alsa_hw_reprepare(void)
+{
+	/* diable 958 module before call initiation */
+	audio_hw_958_enable(0);
+  aml_hw_iec958_init();
+
+}
+
+static int aml_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+    int iec958 = 0;
+
+	if(prtd == 0)
+		return 0;
+
+	switch(runtime->rate){
+		case 192000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_192;
+			break;
+		case 176400:
+			s->sample_rate	=	AUDIO_CLK_FREQ_1764;
+			break;
+		case 96000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_96;
+			break;
+		case 88200:
+			s->sample_rate	=	AUDIO_CLK_FREQ_882;
+			break;
+		case 48000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_48;
+            iec958 = 2;
+			break;
+		case 44100:
+			s->sample_rate	=	AUDIO_CLK_FREQ_441;
+            iec958 = 0;
+			break;
+		case 32000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_32;
+            iec958 = 3;
+			break;
+		case 8000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_8;
+			break;
+		case 11025:
+			s->sample_rate	=	AUDIO_CLK_FREQ_11;
+			break;
+		case 16000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_16;
+			break;
+		case 22050:
+			s->sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		case 12000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_12;
+			break;
+		case 24000:
+			s->sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		default:
+			s->sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+	};
+	// iec958 and i2s clock are separated after M6TV
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6TV	
+	audio_set_clk(s->sample_rate, AUDIO_CLK_256FS);
+	audio_util_set_dac_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#else
+	audio_set_i2s_clk(s->sample_rate, AUDIO_CLK_256FS);
+	audio_set_958_clk(s->sample_rate, AUDIO_CLK_256FS);
+	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+#endif
+	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+			aml_hw_i2s_init(runtime);
+		  aml_hw_iec958_init();
+	}
+	else{
+			//printk("aml_pcm_prepare SNDRV_PCM_STREAM_CAPTURE: dma_addr=%x, dma_bytes=%x\n", runtime->dma_addr, runtime->dma_bytes);
+			audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes*2,audioin_mode);
+			memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
+            {
+			  int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
+			  ppp[0] = 0x78787878;
+			  ppp[1] = 0x78787878;
+            }
+	}
+    if( IEC958_MODE == AIU_958_MODE_PCM_RAW){
+		if(IEC958_mode_codec == 4 ){ // need Over clock for dd+
+		    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2);	// 4x than i2s
+		    audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS, substream);
+		}else if(IEC958_mode_codec == 3 ||IEC958_mode_codec == 1 ){ // no-over clock for dts pcm mode
+		    audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DTS, substream);
+		}
+		else  //dd
+			audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_AC_3, substream);
+
+    }else if(IEC958_mode_codec == 1){
+        audio_notify_hdmi_info(AOUT_EVENT_RAWDATA_DTS, substream);
+    }else{
+				audio_notify_hdmi_info(AOUT_EVENT_IEC_60958_PCM, substream);
+    }
+
+#if 0
+	printk("Audio Parameters:\n");
+	printk("\tsample rate: %d\n", runtime->rate);
+	printk("\tchannel: %d\n", runtime->channels);
+	printk("\tsample bits: %d\n", runtime->sample_bits);
+  printk("\tformat: %s\n", snd_pcm_format_name(runtime->format));
+	printk("\tperiod size: %ld\n", runtime->period_size);
+	printk("\tperiods: %d\n", runtime->periods);
+  printk("\tiec958 mode: %d, raw=%d, codec=%d\n", IEC958_MODE, IEC958_mode_raw, IEC958_mode_codec);
+#endif
+
+	return 0;
+}
+
+static int aml_pcm_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct aml_runtime_data *prtd = rtd->private_data;
+	audio_stream_t *s = &prtd->s;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	 //witch_mod_gate_by_type(MOD_AUDIO, 1);
+#endif
+
+#if USE_HRTIMER == 0
+	  del_timer_sync(&prtd->timer);
+#endif      
+	  spin_lock(&s->lock);
+#if USE_HRTIMER == 0
+	  prtd->timer.expires = jiffies + 1;
+	  del_timer(&prtd->timer);
+	  add_timer(&prtd->timer);
+#endif
+	  // TODO
+	  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+	        //printk("aml_pcm_trigger: playback start\n");
+			//clock_gating_status |= clock_gating_playback;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+		    audio_enable_ouput(1);
+	  }else{
+	  		//printk("aml_pcm_trigger: capture start\n");
+			//clock_gating_status |= clock_gating_capture;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+			audio_in_i2s_enable(1);
+	      {
+		  int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+		  ppp[0] = 0x78787878;
+		  ppp[1] = 0x78787878;
+	      }
+
+	  }
+
+	  s->active = 1;
+	  spin_unlock(&s->lock);
+	  break;		/* SNDRV_PCM_TRIGGER_START */
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		// TODO
+	    spin_lock(&s->lock);
+	    s->active = 0;
+	    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+            //printk("aml_pcm_trigger: playback stop\n");
+	  		audio_enable_ouput(0);
+		//	clock_gating_status &= ~clock_gating_playback;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+	    }else{
+            //printk("aml_pcm_trigger: capture stop\n");
+		//	clock_gating_status &= ~clock_gating_capture;
+
+			audio_in_i2s_enable(0);
+	    }
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	//  switch_mod_gate_by_type(MOD_AUDIO, 0);
+#endif
+
+	    spin_unlock(&s->lock);
+	    break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		// TODO
+	    spin_lock(&s->lock);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	  //switch_mod_gate_by_type(MOD_AUDIO, 1);
+#endif
+	    s->active = 1;
+	    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+            //printk("aml_pcm_trigger: playback resume\n");
+			audio_enable_ouput(1);
+		//	clock_gating_status |= clock_gating_playback;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+	    }else{
+            //printk("aml_pcm_trigger: capture resume\n");
+	        audio_in_i2s_enable(1);
+		//	clock_gating_status |= clock_gating_capture;
+			//aml_clock_gating(clock_gating_status);
+			//codec_power_switch(substream, clock_gating_status);
+		{
+		    int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+		    ppp[0] = 0x78787878;
+		    ppp[1] = 0x78787878;
+	        }
+	    }
+	    spin_unlock(&s->lock);
+	    break;
+	default:
+		ret = -EINVAL;
+	}
+/*	if(clock_gating_status&clock_gating_playback){
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			aml_pcm_work.substream = substream;
+	}
+	else
+		aml_pcm_work.substream = substream;
+
+
+	if(clock_gating_status)
+	{
+		schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	}
+	*/
+	//schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_pcm_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+
+	unsigned int addr, ptr;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+			ptr = read_i2s_rd_ptr();
+	    addr = ptr - s->I2S_addr;
+	    return bytes_to_frames(runtime, addr);
+	}else{
+			ptr = audio_in_i2s_wr_ptr();
+			addr = ptr - s->I2S_addr;
+			return bytes_to_frames(runtime, addr)/2;
+	}
+
+	return 0;
+}
+
+static enum hrtimer_restart aml_pcm_hrtimer_callback(struct hrtimer* timer)
+{
+  struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
+  audio_stream_t* s = &prtd->s;
+  struct snd_pcm_substream* substream = prtd->substream;
+  struct snd_pcm_runtime* runtime= substream->runtime;
+  
+  unsigned int last_ptr, size;
+  unsigned long flag;
+  //printk("------------->hrtimer start\n");
+  if(s->active == 0){
+    hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+    return HRTIMER_RESTART;
+  }
+  //spin_lock_irqsave(&s->lock, flag);
+
+  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+      last_ptr = read_i2s_rd_ptr();
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(substream->runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }else{
+      last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) /2;
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }
+  //spin_unlock_irqrestore(&s->lock, flag);
+  hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+  return HRTIMER_RESTART;
+}
+
+static void aml_pcm_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = runtime->private_data;
+		audio_stream_t *s = &prtd->s;
+
+    unsigned int last_ptr, size;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				if(s->active == 1){
+						spin_lock(&s->lock);
+						last_ptr = read_i2s_rd_ptr();
+						if (last_ptr < s->last_ptr) {
+				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
+				    } else {
+				        size = last_ptr - (s->last_ptr);
+				    }
+    				s->last_ptr = last_ptr;
+    				s->size += bytes_to_frames(substream->runtime, size);
+    				if (s->size >= runtime->period_size) {
+				        s->size %= runtime->period_size;
+				        spin_unlock(&s->lock);
+				        snd_pcm_period_elapsed(substream);
+				        spin_lock(&s->lock);
+				    }
+				    mod_timer(&prtd->timer, jiffies + 1);
+					//codec_power = 1;
+   					spin_unlock(&s->lock);
+				}else{
+
+						 mod_timer(&prtd->timer, jiffies + 1);
+						// codec_power = 0;
+
+				}
+
+		}else{
+				if(s->active == 1){
+						spin_lock(&s->lock);
+						last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) / 2;
+						if (last_ptr < s->last_ptr) {
+				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
+				    } else {
+				        size = last_ptr - (s->last_ptr);
+				    }
+    				s->last_ptr = last_ptr;
+    				s->size += bytes_to_frames(substream->runtime, size);
+    				if (s->size >= runtime->period_size) {
+				        s->size %= runtime->period_size;
+				        spin_unlock(&s->lock);
+				        snd_pcm_period_elapsed(substream);
+				        spin_lock(&s->lock);
+				    }
+				    mod_timer(&prtd->timer, jiffies + 1);
+   					spin_unlock(&s->lock);
+				}else{
+						 mod_timer(&prtd->timer, jiffies + 1);
+				}
+		}
+	/*	if((codec_power==0) && (num==500))
+		{
+			num=0;
+	   		flag=1;
+			schedule_work(&aml_pcm_work.aml_codec_workqueue);
+		}
+	   else if((codec_power==1) && (num <= 500))
+	   	{
+	   		num=0;
+			flag = 0;
+	   	}
+	   else if((codec_power==0) && (num<500))
+	   	{
+	   	    if(flag==1)
+	   	    {}
+			else
+			{
+				num++;
+			}
+	   	} */
+}
+
+
+static int aml_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd;
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		playback_substream_handle = (unsigned long)substream;
+		snd_soc_set_runtime_hwparams(substream, &aml_pcm_hardware);
+	}else{
+		snd_soc_set_runtime_hwparams(substream, &aml_pcm_capture);
+	}
+
+    /* ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0)
+	{
+		printk("set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+						SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+	{
+		printk("set period error\n");
+		goto out;
+	}
+
+	prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		printk("alloc aml_runtime_data error\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	prtd->substream = substream;
+#if USE_HRTIMER == 0    
+	prtd->timer.function = &aml_pcm_timer_callback;
+	prtd->timer.data = (unsigned long)substream;
+	init_timer(&prtd->timer);
+#else
+    hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    prtd->hrtimer.function = aml_pcm_hrtimer_callback;
+    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
+
+
+    printk("hrtimer inited..\n");
+#endif
+	runtime->private_data = prtd;
+
+	spin_lock_init(&prtd->s.lock);
+ out:
+	return ret;
+}
+
+static int aml_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+
+#if USE_HRTIMER == 0
+	del_timer_sync(&prtd->timer);
+#else
+    hrtimer_cancel(&prtd->hrtimer);
+#endif
+	kfree(prtd);
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		playback_substream_handle = 0;
+	return 0;
+}
+
+
+static int aml_pcm_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    int res = 0;
+    int n;
+    int i = 0, j = 0;
+    int  align = runtime->channels * 32 / runtime->byte_align;
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    n = frames_to_bytes(runtime, count);
+    if(aml_i2s_playback_enable == 0)
+      return res;
+    if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))){
+	  if(runtime->format == SNDRV_PCM_FORMAT_S16_LE && I2S_MODE == AIU_I2S_MODE_PCM16){
+        int16_t * tfrom, *to, *left, *right;
+        tfrom = (int16_t*)buf;
+        to = (int16_t*)hwbuf;
+
+        left = to;
+		right = to + 16;
+		if (pos % align) {
+		    printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+		}
+		for (j = 0; j < n; j += 64) {
+		    for (i = 0; i < 16; i++) {
+	          *left++ = (*tfrom++) ;
+	          *right++ = (*tfrom++);
+		    }
+		    left += 16;
+		    right += 16;
+		 }
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++);
+            *right++  = (*tfrom ++);
+          }
+          left += 8;
+          right += 8;
+        }
+
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S32_LE && I2S_MODE == AIU_I2S_MODE_PCM32){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+		
+		if(runtime->channels == 8){
+			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+			lf  = to;
+			cf  = to + 8*1;
+			rf  = to + 8*2;
+			ls  = to + 8*3;
+			rs  = to + 8*4;
+			lef = to + 8*5;
+			sbl = to + 8*6;
+			sbr = to + 8*7;
+			for (j = 0; j < n; j += 256) {
+		    	for (i = 0; i < 8; i++) {
+	         		*lf++  = (*tfrom ++)>>8;
+	          		*cf++  = (*tfrom ++)>>8;
+					*rf++  = (*tfrom ++)>>8;
+					*ls++  = (*tfrom ++)>>8;
+					*rs++  = (*tfrom ++)>>8;
+					*lef++ = (*tfrom ++)>>8;
+					*sbl++ = (*tfrom ++)>>8;
+					*sbr++ = (*tfrom ++)>>8;
+		    	}
+		    	lf  += 7*8;
+		    	cf  += 7*8;
+				rf  += 7*8;
+				ls  += 7*8;
+				rs  += 7*8;
+				lef += 7*8;
+				sbl += 7*8;
+				sbr += 7*8;
+		 	}
+		}
+		else {
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++)>>8;
+            *right++  = (*tfrom ++)>>8;
+          }
+          left += 8;
+          right += 8;
+        }
+      	}
+      }
+
+	}else{
+	  res = -EFAULT;
+	}
+
+	return res;
+}
+
+
+static int aml_pcm_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+		unsigned int *tfrom, *left, *right;
+		unsigned short *to;
+		int res = 0;
+		int n;
+    int i = 0, j = 0;
+    unsigned int t1, t2;
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
+    unsigned char r_shift = 8;	
+    if(audioin_mode&SPDIFIN_MODE) //spdif in
+    {
+    	r_shift = 12;
+    }
+    to = (unsigned short *)snd_pcm_tmp;//buf;
+    tfrom = (unsigned int *)hwbuf;	// 32bit buffer
+    n = frames_to_bytes(runtime, count);
+    if(n > 32*1024){
+      printk("Too many datas to read\n");
+      return -EINVAL;
+    }
+
+		if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count))){
+				left = tfrom;
+		    right = tfrom + 8;
+		    if (pos % 8) {
+		        printk("audio data unligned\n");
+		    }
+		    if((n*2)%64){
+		    		printk("audio data unaligned 64 bytes\n");
+		    }
+		    for (j = 0; j < n*2 ; j += 64) {
+		        for (i = 0; i < 8; i++) {
+		        	t1 = (*left++);
+		        	t2 = (*right++);
+		        	//printk("%08x,%08x,", t1, t2);
+	              *to++ = (unsigned short)((t1>>r_shift)&0xffff);
+	           //   *to++ = (unsigned short)((t1>>8)&0xffff);//copy left channel to right
+	              *to++ = (unsigned short)((t2>>r_shift)&0xffff);
+		         }
+		         //printk("\n");
+		        left += 8;
+		        right += 8;
+		    }
+		}
+        res = copy_to_user(buf, snd_pcm_tmp,n);
+		return res;
+}
+
+static int aml_pcm_copy(struct snd_pcm_substream *substream, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+ 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+ 		ret = aml_pcm_copy_playback(runtime, channel,pos, buf, count);
+ 	}else{
+ 		ret = aml_pcm_copy_capture(runtime, channel,pos, buf, count);
+ 	}
+    return ret;
+}
+
+int aml_pcm_silence(struct snd_pcm_substream *substream, int channel,
+		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+		char* ppos;
+		int n;
+		struct snd_pcm_runtime *runtime = substream->runtime;
+
+		n = frames_to_bytes(runtime, count);
+		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+		memset(ppos, 0, n);
+		return 0;
+}
+
+static struct snd_pcm_ops aml_pcm_ops = {
+	.open		= aml_pcm_open,
+	.close		= aml_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_pcm_hw_params,
+	.hw_free	= aml_pcm_hw_free,
+	.prepare	= aml_pcm_prepare,
+	.trigger	= aml_pcm_trigger,
+	.pointer	= aml_pcm_pointer,
+	.copy 		= aml_pcm_copy,
+	.silence	=	aml_pcm_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+static u64 aml_pcm_dmamask = 0xffffffff;
+
+static int aml_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		pr_debug("aml-pcm:"
+				"Allocating PCM capture DMA buffer\n");
+		ret = aml_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	return ret;
+}
+
+static void aml_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+		buf->area = NULL;
+	}
+    aml_i2s_playback_start_addr = 0;
+    aml_i2s_capture_start_addr  = 0;
+
+    if(aml_iec958_playback_start_addr){
+      dma_free_coherent(pcm->card->dev, aml_iec958_playback_size, ( void *)aml_iec958_playback_start_addr, aml_iec958_playback_start_phy);
+      aml_iec958_playback_start_addr = 0;
+    }
+}
+
+#ifdef CONFIG_PM
+static int aml_pcm_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_pcm_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* disable the PDC and save the PDC registers */
+	// TODO
+	printk("aml pcm suspend\n");
+
+	return 0;
+}
+
+static int aml_pcm_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_pcm_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* restore the PDC registers and enable the PDC */
+	// TODO
+	printk("aml pcm resume\n");
+	return 0;
+}
+#else
+#define aml_pcm_suspend	NULL
+#define aml_pcm_resume	NULL
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+
+static struct dentry *debugfs_root;
+static struct dentry *debugfs_regs;
+static struct dentry *debugfs_mems;
+
+static int regs_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/**
+ *	cat regs
+ */
+static ssize_t regs_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo base reg val >regs\t(set the register)\n"
+										 "	echo base reg >regs\t(show the register)\n"
+										 "	base -> c(cbus), x(aix), p(apb), h(ahb) \n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static int read_regs(char base, int reg)
+{
+	int val = 0;
+	switch(base){
+		case 'c':
+			val = READ_CBUS_REG(reg);
+			break;
+		case 'x':
+			val = READ_AXI_REG(reg);
+			break;
+		case 'p':
+			val = READ_APB_REG(reg);
+			break;
+		case 'h':
+			//val = READ_AHB_REG(reg);
+			break;
+		default:
+			break;
+	};
+	printk("\tReg %x = %x\n", reg, val);
+	return val;
+}
+
+static void write_regs(char base, int reg, int val)
+{
+	switch(base){
+		case 'c':
+			WRITE_CBUS_REG(reg, val);
+			break;
+		case 'x':
+			WRITE_AXI_REG(reg, val);
+			break;
+		case 'p':
+			WRITE_APB_REG(reg, val);
+			break;
+		case 'h':
+			//WRITE_AHB_REG(reg, val);
+			break;
+		default:
+			break;
+	};
+	printk("Write reg:%x = %x\n", reg, val);
+}
+static ssize_t regs_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long reg, value;
+	char base;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+	while (*start == ' ')
+		start++;
+
+	base = *start;
+	start ++;
+	if(!(base =='c' || base == 'x' || base == 'p' || base == 'h')){
+		return -EINVAL;
+	}
+
+	while (*start == ' ')
+		start++;
+
+	reg = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			read_regs(base, reg);
+			return -EINVAL;
+	}
+
+	write_regs(base, reg, value);
+
+	return buf_size;
+}
+
+static const struct file_operations regs_fops = {
+	.open = regs_open_file,
+	.read = regs_read_file,
+	.write = regs_write_file,
+};
+
+static int mems_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t mems_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo vmem >mems\t(read 64 bytes from vmem)\n"
+										 "	echo vmem val >mems (write int value to vmem\n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t mems_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[256];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long mem, value;
+	int i=0;
+	unsigned* addr = 0;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	while (*start == ' ')
+		start++;
+
+	mem = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			addr = (unsigned*)mem;
+			printk("%p: ", addr);
+			for(i = 0; i< 8; i++){
+				printk("%08x, ", addr[i]);
+			}
+			printk("\n");
+			return -EINVAL;
+	}
+	addr = (unsigned*)mem;
+	printk("%p: %08x\n", addr, *addr);
+	*addr = value;
+	printk("%p: %08x^\n", addr, *addr);
+
+	return buf_size;
+}
+static const struct file_operations mems_fops={
+	.open = mems_open_file,
+	.read = mems_read_file,
+	.write = mems_write_file,
+};
+
+static void aml_pcm_init_debugfs(void)
+{
+		debugfs_root = debugfs_create_dir("aml",NULL);
+		if (IS_ERR(debugfs_root) || !debugfs_root) {
+			printk("aml: Failed to create debugfs directory\n");
+			debugfs_root = NULL;
+		}
+
+		debugfs_regs = debugfs_create_file("regs", 0644, debugfs_root, NULL, &regs_fops);
+		if(!debugfs_regs){
+			printk("aml: Failed to create debugfs file\n");
+		}
+
+		debugfs_mems = debugfs_create_file("mems", 0644, debugfs_root, NULL, &mems_fops);
+		if(!debugfs_mems){
+			printk("aml: Failed to create debugfs file\n");
+		}
+}
+static void aml_pcm_cleanup_debugfs(void)
+{
+	debugfs_remove_recursive(debugfs_root);
+}
+#else
+static void aml_pcm_init_debugfs(void)
+{
+}
+static void aml_pcm_cleanup_debugfs(void)
+{
+}
+#endif
+
+struct aml_audio_interface aml_i2s_interface = {
+    .id = AML_AUDIO_I2S,
+    .name = "I2S",
+    .pcm_ops = &aml_pcm_ops,
+    .pcm_new = aml_pcm_new,
+    .pcm_free =  aml_pcm_free_dma_buffers,
+};
+#if 0
+struct snd_soc_platform_driver aml_soc_platform = {
+	.ops 	= &aml_pcm_ops,
+	.pcm_new	= aml_pcm_new,
+	.pcm_free	= aml_pcm_free_dma_buffers,
+	.suspend	= aml_pcm_suspend,
+	.resume		= aml_pcm_resume,
+};
+
+EXPORT_SYMBOL_GPL(aml_soc_platform);
+
+static int aml_soc_platform_probe(struct platform_device *pdev)
+{
+	INIT_WORK(&aml_pcm_work.aml_codec_workqueue, aml_codec_power_switch_queue);
+	/* get audioin cfg data from board */
+	if(pdev->dev.platform_data){
+		audioin_mode = *(unsigned *)pdev->dev.platform_data;
+		printk("AML soc audio in mode =============   %d \n",audioin_mode);
+	}	
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
+}
+
+static int aml_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-audio",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_pcm_driver = {
+	.driver = {
+			.name = "aml-audio",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,
+	},
+
+	.probe = aml_soc_platform_probe,
+	.remove = aml_soc_platform_remove,
+};
+
+static int __init aml_alsa_audio_init(void)
+{
+	aml_pcm_init_debugfs();
+	return platform_driver_register(&aml_pcm_driver);
+}
+
+static void __exit aml_alsa_audio_exit(void)
+{
+	aml_pcm_cleanup_debugfs();
+    platform_driver_unregister(&aml_pcm_driver);
+}
+
+module_init(aml_alsa_audio_init);
+module_exit(aml_alsa_audio_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
+#endif
diff --git a/sound/soc/aml/m6/aml_pcm.h b/sound/soc/aml/m6/aml_pcm.h
new file mode 100644
index 000000000000..bb4e2b16d8b9
--- /dev/null
+++ b/sound/soc/aml/m6/aml_pcm.h
@@ -0,0 +1,75 @@
+#ifndef __AML_PCM_H__
+#define __AML_PCM_H__
+
+//#define debug_printk
+#ifdef debug_printk
+#define dug_printk(fmt, args...)  printk (fmt, ## args)
+#else
+#define dug_printk(fmt, args...)
+#endif
+
+typedef struct audio_stream {
+    int stream_id;
+    int active;
+    unsigned int last_ptr;
+    unsigned int size;
+    unsigned int sample_rate;
+    unsigned int I2S_addr;
+    spinlock_t lock;
+    struct snd_pcm_substream *stream;
+	unsigned i2s_mode; //0:master, 1:slave,
+} audio_stream_t;
+
+typedef struct aml_audio {
+    struct snd_card *card;
+    struct snd_pcm *pcm;
+    audio_stream_t s[2];
+} aml_audio_t;
+
+typedef struct audio_mixer_control {
+    int output_devide;
+    int input_device;
+    int direction;
+    int input_volume;
+    int output_volume;
+} audio_mixer_control_t;
+
+typedef struct audio_tone_control {
+    unsigned short * tone_source;
+    unsigned short * tone_data;
+    int tone_data_len;
+    int tone_count;
+    int tone_flag;
+}audio_tone_control_t;
+
+struct aml_pcm_dma_params{
+		char *name;			/* stream identifier */
+		struct snd_pcm_substream *substream;
+		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
+	
+};
+typedef struct aml_dai_info {
+	unsigned i2s_mode; //0:master, 1:slave,
+} aml_dai_info_t;
+enum {
+	I2S_MASTER_MODE = 0,
+	I2S_SLAVE_MODE,	
+};
+/*--------------------------------------------------------------------------*\
+ * Data types
+\*--------------------------------------------------------------------------*/
+struct aml_runtime_data {
+	struct aml_pcm_dma_params *params;
+	dma_addr_t dma_buffer;		/* physical address of dma buffer */
+	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
+
+	struct snd_pcm_substream *substream;
+	audio_stream_t s;	
+	struct timer_list timer;	// timeer for playback and capture
+    struct hrtimer hrtimer;
+};
+
+extern struct snd_soc_platform_driver aml_soc_platform;
+extern struct aml_audio_interface aml_i2s_interface;
+
+#endif
diff --git a/sound/soc/aml/m6/aml_platform.c b/sound/soc/aml/m6/aml_platform.c
new file mode 100644
index 000000000000..5dace9fc1b5a
--- /dev/null
+++ b/sound/soc/aml/m6/aml_platform.c
@@ -0,0 +1,573 @@
+/*
+ * aml_platform.c  --  ALSA audio platform interface for the AML Meson SoC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#include "aml_platform_pcm2bt.h"
+#include "aml_pcm.h"
+#include "aml_platform.h"
+#include <linux/of.h>
+
+#ifndef ARRY_SIZE
+#define ARRY_SIZE(A)    (sizeof(A) /sizeof(A[0]))
+#endif
+
+static LIST_HEAD(stream_list);
+static DEFINE_SPINLOCK(platform_lock);
+    
+struct aml_platform_stream{
+    struct list_head list;
+    struct aml_audio_interface *interface;
+    struct snd_pcm_substream *substream;
+};
+
+static struct aml_audio_interface *audio_interfaces[] = {
+    &aml_i2s_interface,
+    &aml_pcm_interface,
+};
+
+static inline struct aml_audio_interface *find_audio_interface(int id)
+{
+    struct aml_audio_interface *interface = NULL;
+    int i = 0;
+
+    for (i=0; i<ARRAY_SIZE(audio_interfaces); i++) {
+        if (audio_interfaces[i]->id == id) {
+            interface = audio_interfaces[i];
+            break;
+        }
+    }
+
+    return interface;
+}
+
+static inline struct aml_platform_stream *find_platform_stream(struct snd_pcm_substream *substream)
+{
+    struct aml_platform_stream *plat_stream = NULL;
+    struct list_head *entry = NULL;
+
+    list_for_each(entry, &stream_list) {
+        plat_stream = list_entry(entry, struct aml_platform_stream, list);
+        if (plat_stream->substream == substream) {
+            return plat_stream;
+        }
+    }
+
+    return NULL;
+}
+
+static void dump_platform_stream(void)
+{
+    struct aml_platform_stream *plat_stream = NULL;
+    struct list_head *entry = NULL;
+    int n = 0;
+
+    list_for_each(entry, &stream_list) {
+        plat_stream = list_entry(entry, struct aml_platform_stream, list);
+        printk(KERN_INFO "substream#%d ptr: %p type: %s name: %s interface: %s\n",
+                        n,
+                        plat_stream->substream,
+                        (plat_stream->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture",
+                        plat_stream->substream->name,
+                        plat_stream->interface->name);
+        n++;
+    }
+}
+
+static int aml_platform_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    aud_interface = find_audio_interface(cpu_dai->id);
+    if (unlikely(NULL == aud_interface)) {
+        printk(KERN_ERR "aml-platform: no such audio interface!");
+        ret = -ENODEV;
+        goto out;
+    }
+
+    BUG_ON(aud_interface->pcm_ops->open == NULL);
+
+	plat_stream = kzalloc(sizeof(struct aml_platform_stream), GFP_KERNEL);
+	if (unlikely(plat_stream == NULL)) {
+        printk(KERN_ERR "aml-platform: out of memory!");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+    ret = aud_interface->pcm_ops->open(substream);
+    if (ret >= 0) {
+        INIT_LIST_HEAD(&plat_stream->list);
+        plat_stream->substream = substream;
+        plat_stream->interface = aud_interface;
+
+        spin_lock(&platform_lock);
+        list_add_tail(&plat_stream->list, &stream_list);
+        spin_unlock(&platform_lock);
+
+        dump_platform_stream();
+    } else {
+        printk(KERN_ERR "aml-platform: open pcm substream failed ret: %d!", ret);
+    }
+
+out:
+    return ret;
+}
+
+static int aml_platform_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->close == NULL);
+
+        ret = aud_interface->pcm_ops->close(substream);
+        if (ret >= 0) {
+            spin_lock(&platform_lock);
+            list_del(&plat_stream->list);
+            spin_unlock(&platform_lock);
+            kfree(plat_stream);
+        } else {
+            printk(KERN_ERR "aml-platform: close pcm substream failed ret: %d!", ret);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_ioctl(struct snd_pcm_substream * substream,
+                unsigned int cmd, void *arg)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->ioctl) {
+            ret = aud_interface->pcm_ops->ioctl(substream, cmd, arg);
+        } else {
+            ret = snd_pcm_lib_ioctl(substream, cmd, arg);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_hw_params(struct snd_pcm_substream *substream,
+		 struct snd_pcm_hw_params *params)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->hw_params == NULL);
+
+        ret = aud_interface->pcm_ops->hw_params(substream, params);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_hw_free(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->hw_free == NULL);
+
+        ret = aud_interface->pcm_ops->hw_free(substream);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_prepare(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->prepare == NULL);
+
+        ret = aud_interface->pcm_ops->prepare(substream);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->trigger == NULL);
+        ret = aud_interface->pcm_ops->trigger(substream, cmd);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static snd_pcm_uframes_t aml_platform_pointer(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    snd_pcm_uframes_t ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->pointer == NULL);    
+        ret = aud_interface->pcm_ops->pointer(substream);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+
+static int aml_platform_copy(struct snd_pcm_substream *substream, int channel,
+        	    snd_pcm_uframes_t pos,
+        	    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        BUG_ON(aud_interface->pcm_ops->copy == NULL);
+
+        ret = aud_interface->pcm_ops->copy(substream, channel, pos, buf, count);
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int aml_platform_silence(struct snd_pcm_substream *substream, int channel, 
+                snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    unsigned char* ppos = NULL;
+    ssize_t n = 0;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->silence) {
+            ret = aud_interface->pcm_ops->silence(substream, channel, pos, count);
+        } else {
+            n = frames_to_bytes(runtime, count);
+            ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+            memset(ppos, 0, n);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static struct page *aml_platform_page(struct snd_pcm_substream *substream,
+                        unsigned long offset)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    struct page *ret = NULL;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->page) {
+            ret = aud_interface->pcm_ops->page(substream, offset);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+
+static int aml_platform_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->mmap) {
+            ret = aud_interface->pcm_ops->mmap(substream, vma);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+
+static int aml_platform_ack(struct snd_pcm_substream *substream)
+{
+    struct aml_audio_interface *aud_interface = NULL;
+    struct aml_platform_stream *plat_stream = NULL;
+    int ret = 0;
+
+    plat_stream = find_platform_stream(substream);
+    if (likely(plat_stream != NULL)) {
+        aud_interface = plat_stream->interface;
+        if (aud_interface->pcm_ops->ack) {
+            ret = aud_interface->pcm_ops->ack(substream);
+        }
+    } else {
+        printk(KERN_ERR "aml-platform: substream %p invalid!", substream);
+        dump_platform_stream();
+    }
+
+    return ret;
+}
+    
+static struct snd_pcm_ops aml_platform_ops = {
+	.open		= aml_platform_open,
+	.close		= aml_platform_close,
+	.ioctl		= aml_platform_ioctl,
+	.hw_params	= aml_platform_hw_params,
+	.hw_free	= aml_platform_hw_free,
+	.prepare	= aml_platform_prepare,
+	.trigger	= aml_platform_trigger,
+	.pointer	= aml_platform_pointer,
+	.copy       = aml_platform_copy,
+	.silence    = aml_platform_silence,
+	.page       = aml_platform_page,
+	.mmap       = aml_platform_mmap,
+	.ack        = aml_platform_ack,
+};
+
+static int aml_platform_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+    printk("rtd %x \n",	(unsigned)rtd);
+	
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    printk("cpu_dai %x \n",	(unsigned)cpu_dai);
+	
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    printk("codec_dai %x \n",	(unsigned)codec_dai);
+	
+    struct aml_audio_interface *aud_interface = NULL;
+    struct snd_pcm *pcm =rtd->pcm ;
+    struct snd_soc_card *card = rtd->card;
+	
+	int ret = 0;
+
+    printk(KERN_DEBUG"enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    aud_interface = find_audio_interface(cpu_dai->id);
+    if (unlikely(NULL == aud_interface)) {
+        printk(KERN_ERR "aml-platform: no such audio interface!");
+        ret = -ENODEV;
+        goto out;
+    }
+
+    BUG_ON(aud_interface->pcm_new == NULL);
+    ret = aud_interface->pcm_new(rtd);
+out:
+	return ret;
+}
+
+static void aml_platform_pcm_free(struct snd_pcm *pcm)
+{
+    struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct aml_audio_interface *aud_interface = NULL;
+
+    printk(KERN_DEBUG "enter %s (codec_dai: %s %d cpu_dai: %s %d)\n",
+                    __FUNCTION__, codec_dai->name, codec_dai->id, cpu_dai->name, cpu_dai->id);
+
+    aud_interface = find_audio_interface(cpu_dai->id);
+    if (unlikely(NULL == aud_interface)) {
+        printk(KERN_ERR "aml-platform: no such audio interface!");
+        return;
+    }
+
+    BUG_ON(aud_interface->pcm_free == NULL);
+    aud_interface->pcm_free(pcm);
+
+	return;
+}
+
+static int aml_platform_suspend(struct snd_soc_dai *dai)
+{
+
+	/* disable the PDC and save the PDC registers */
+	// TODO
+	printk("aml pcm suspend\n");	
+
+	return 0;
+}
+
+static int aml_platform_resume(struct snd_soc_dai *dai)
+{
+	/* restore the PDC registers and enable the PDC */
+	// TODO
+	printk("aml pcm resume\n");
+	return 0;
+}
+
+struct snd_soc_platform_driver aml_soc_platform2 = {
+	.ops 	= &aml_platform_ops,
+	.pcm_new	= aml_platform_pcm_new,
+	.pcm_free	= aml_platform_pcm_free,
+
+	.suspend	= aml_platform_suspend,
+	.resume		= aml_platform_resume,
+};
+
+static int  aml_soc_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform2);
+}
+
+static int  aml_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-audio",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_soc_platform_driver = {
+	.driver = {
+			.name = "aml-audio",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,			
+	},
+
+	.probe = aml_soc_platform_probe,
+	.remove = aml_soc_platform_remove,
+};
+
+static int __init aml_soc_platform_init(void)
+{
+	return platform_driver_register(&aml_soc_platform_driver);
+}
+
+static void __exit aml_soc_platform_exit(void)
+{
+    platform_driver_unregister(&aml_soc_platform_driver);
+}
+
+module_init(aml_soc_platform_init);
+
+module_exit(aml_soc_platform_exit);
+
+MODULE_AUTHOR("Amlogic, Inc.");
+MODULE_DESCRIPTION("Amlogic ASoC platform driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/aml/m6/aml_platform.h b/sound/soc/aml/m6/aml_platform.h
new file mode 100644
index 000000000000..d51694d2f0d9
--- /dev/null
+++ b/sound/soc/aml/m6/aml_platform.h
@@ -0,0 +1,36 @@
+/*
+ * aml_platform.h  --  ALSA audio platform interface for the AML Meson SoC
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#ifndef _AML_PLATFORM_H
+#define _AML_PLATFORM_H
+
+#define AML_AUDIO_I2S       0
+#define AML_AUDIO_PCM       1
+
+struct aml_audio_interface
+{
+    unsigned int id;
+    char    *name;
+    struct  snd_pcm_ops *pcm_ops;
+
+	int     (*pcm_new)(struct snd_soc_pcm_runtime *rtd);
+	void    (*pcm_free)(struct snd_pcm *);
+};
+
+#endif /* _AML_PLATFORM_H */
diff --git a/sound/soc/aml/m6/aml_platform_pcm2bt.c b/sound/soc/aml/m6/aml_platform_pcm2bt.c
new file mode 100644
index 000000000000..39475697d9ba
--- /dev/null
+++ b/sound/soc/aml/m6/aml_platform_pcm2bt.c
@@ -0,0 +1,687 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include "aml_platform_pcm2bt.h"
+#include "aml_audio_hw_pcm2bt.h"
+#include "aml_pcm.h"
+#include "aml_platform.h"
+
+//#define PCM_DEBUG
+
+#ifdef PCM_DEBUG
+#define pcm_debug(fmt, args...)  printk (fmt, ## args)
+#else
+#define pcm_debug(fmt, args...)
+#endif
+
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+				  		    SNDRV_PCM_INFO_PAUSE,
+				  		
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8*1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+	
+	.rate_min = 8000,
+    .rate_max = 8000,
+    .channels_min = 1,
+    .channels_max = 1,
+};
+
+struct aml_pcm_runtime_data {
+	spinlock_t			lock;
+
+    dma_addr_t          buffer_start;
+    unsigned int        buffer_size;
+
+    unsigned int        buffer_offset;
+
+    unsigned int        data_size;
+
+    unsigned int        running;
+    unsigned int        timer_period;
+    unsigned int        peroid_elapsed;
+
+    struct timer_list   timer;
+    struct snd_pcm_substream *substream;
+};
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+unsigned int aml_pcm2bt_playback_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_buffer_size = 0;
+
+unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
+
+static void aml_pcm_config_tx(u32 addr, u32 size)
+{
+    pcm_debug(KERN_DEBUG "%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_out_set_buf(addr, size);
+}
+
+static void aml_pcm_config_rx(u32 addr, u32 size)
+{
+    pcm_debug(KERN_DEBUG "%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_in_set_buf(addr, size);
+}
+
+static void aml_pcm_start_tx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_out_enable(1);
+}
+
+static void aml_pcm_start_rx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_in_enable(1);
+}
+
+static void aml_pcm_stop_tx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_out_enable(0);
+}
+
+static void aml_pcm_stop_rx(void)
+{
+    pcm_debug(KERN_DEBUG "%s", __FUNCTION__);
+    pcm_in_enable(0);
+}
+
+static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_out_rd_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_in_wr_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
+{
+    struct snd_pcm_substream *substream = prtd->substream;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned int offset = 0;
+    unsigned int size = 0;
+    
+    if (prtd->running && snd_pcm_running(substream)) {
+    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    		offset = aml_pcm_offset_tx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+    	} else {
+            int rx_overflow = 0;
+    		offset = aml_pcm_offset_rx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+            rx_overflow = pcm_in_fifo_int() & (1 << 2);
+            if (rx_overflow) {
+                printk(KERN_WARNING "%s AUDIN_FIFO overflow !!\n", __FUNCTION__);
+            }
+    	}
+    }
+
+    prtd->buffer_offset = offset;
+    prtd->data_size += size;
+    if (prtd->data_size >= frames_to_bytes(runtime, runtime->period_size)) {
+        prtd->peroid_elapsed++;
+    }
+
+    pcm_debug(KERN_DEBUG "%s buffer offset: %d data size: %d peroid size: %d peroid elapsed: %d\n",
+                __FUNCTION__, prtd->buffer_offset, prtd->data_size, frames_to_bytes(runtime, runtime->period_size), prtd->peroid_elapsed);
+}
+
+static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
+{
+    prtd->timer.expires = jiffies + prtd->timer_period;
+	add_timer(&prtd->timer);
+}
+
+static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+	aml_pcm2bt_timer_rearm(prtd);
+    prtd->running = 1;
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+    prtd->running = 0;
+	del_timer(&prtd->timer);
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+
+static void aml_pcm2bt_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	unsigned long flags;
+	unsigned int elapsed = 0;
+    unsigned int datasize = 0;
+	
+	spin_lock_irqsave(&prtd->lock, flags);
+    aml_pcm2bt_timer_update(prtd);
+    aml_pcm2bt_timer_rearm(prtd);
+	elapsed = prtd->peroid_elapsed;
+    datasize = prtd->data_size;
+    if (elapsed) {
+        prtd->peroid_elapsed--;
+        prtd->data_size -= frames_to_bytes(runtime, runtime->period_size);
+    }
+	spin_unlock_irqrestore(&prtd->lock, flags);
+	if (elapsed) {
+        if (elapsed > 1) {
+            printk(KERN_WARNING "PCM timer callback not fast enough (elapsed periods: %d data_bytes: %d period_bytes: %d)!",
+                    elapsed, datasize, frames_to_bytes(runtime, runtime->period_size));
+        }
+		snd_pcm_period_elapsed(prtd->substream);
+    }
+}
+
+static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	init_timer(&prtd->timer);
+    prtd->timer_period = 1;
+	prtd->timer.data = (unsigned long)substream;
+	prtd->timer.function = aml_pcm2bt_timer_callback;
+    prtd->running = 0;
+	return 0;
+}
+
+static int aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	size_t size = params_buffer_bytes(params);
+    int ret = 0;
+
+	ret = snd_pcm_lib_malloc_pages(substream, size);
+    if (ret < 0) {
+        printk(KERN_ERR "%s snd_pcm_lib_malloc_pages return: %d\n", __FUNCTION__, ret);
+    } else {
+        prtd->buffer_start = runtime->dma_addr;
+        prtd->buffer_size = runtime->dma_bytes;
+        pcm_debug(KERN_DEBUG "%s dma_addr: 0x%08x dma_bytes: 0x%x\n", __FUNCTION__, runtime->dma_addr, runtime->dma_bytes);
+
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_playback_phy_buffer_size = runtime->dma_bytes;
+        } else {
+            aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
+        }
+    }
+
+    return ret;
+}
+
+static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	snd_pcm_lib_free_pages(substream);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        aml_pcm2bt_playback_phy_buffer_addr = 0;
+        aml_pcm2bt_playback_phy_buffer_size = 0;
+    } else {
+        aml_pcm2bt_capture_phy_buffer_addr = 0;
+        aml_pcm2bt_capture_phy_buffer_size = 0;
+    }
+
+    return 0;
+}
+
+static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        pcm_debug(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_tx(prtd->buffer_start, prtd->buffer_size);
+        aml_pcm2bt_playback_buffer_addr = (unsigned int)runtime->dma_area;
+        aml_pcm2bt_playback_buffer_size = runtime->dma_bytes;
+	} else {
+	    pcm_debug(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_rx(prtd->buffer_start, prtd->buffer_size);
+        aml_pcm2bt_capture_buffer_addr = (unsigned int)runtime->dma_area;
+        aml_pcm2bt_capture_buffer_size = runtime->dma_bytes;
+	}
+
+    memset(runtime->dma_area, 0, runtime->dma_bytes);
+    prtd->buffer_offset = 0;
+    prtd->data_size = 0;
+    prtd->peroid_elapsed = 0;
+
+	return 0;
+}
+
+static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+    	case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_RESUME:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_start_tx();
+    		else
+    			aml_pcm_start_rx();
+            aml_pcm2bt_timer_start(prtd);
+    		break;
+    	case SNDRV_PCM_TRIGGER_STOP:
+    	case SNDRV_PCM_TRIGGER_SUSPEND:
+    	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            aml_pcm2bt_timer_stop(prtd);
+    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_stop_tx();
+    		else
+    			aml_pcm_stop_rx();
+    		break;
+    	default:
+    		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    snd_pcm_uframes_t frames;
+        
+	pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    frames = bytes_to_frames(runtime, (ssize_t)prtd->buffer_offset);
+
+	return frames;
+}
+
+static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
+
+    /* Ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0) {
+		printk(KERN_ERR "set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* Ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+        printk(KERN_ERR "set periods constraint error\n");
+		goto out;
+    }
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+        printk(KERN_ERR "out of memory\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+    runtime->private_data = prtd;
+    aml_pcm2bt_timer_create(substream);
+    prtd->substream = substream;
+	spin_lock_init(&prtd->lock);
+
+    return 0;
+out:
+	return ret;
+}
+
+
+static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+   
+    printk(KERN_INFO "enter %s type: %d\n", __FUNCTION__, substream->stream);
+    if (prtd)
+	    kfree(runtime->private_data);
+	return 0;
+}
+
+
+static int aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    unsigned char* hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    unsigned int wrptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy from user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        wrptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (wrptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            wrptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_out_set_wr_ptr(wrptr);
+    }
+
+    return ret;
+}
+
+	
+
+
+static int aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    signed short *hwbuf = (signed short*)(runtime->dma_area + frames_to_bytes(runtime, pos));
+    unsigned int rdptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy to user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        //memset(hwbuf, 0xff, frames_to_bytes(runtime, count));
+        rdptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (rdptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            rdptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_in_set_rd_ptr(rdptr);
+    }
+    return ret;
+}
+
+static int aml_pcm2bt_copy(struct snd_pcm_substream *substream, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        ret = aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
+    } else {
+        ret = aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
+    }
+
+    return ret;
+}
+
+
+static int aml_pcm2bt_silence(struct snd_pcm_substream *substream, int channel, 
+    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned char* ppos = NULL;
+    ssize_t n;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    n = frames_to_bytes(runtime, count);
+    ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+    memset(ppos, 0, n);
+
+    return 0;
+}
+                        
+static struct snd_pcm_ops aml_pcm2bt_ops = {
+	.open		= aml_pcm2bt_open,
+	.close		= aml_pcm2bt_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_pcm2bt_hw_params,
+	.hw_free	= aml_pcm2bt_hw_free,
+	.prepare	= aml_pcm2bt_prepare,
+	.trigger	= aml_pcm2bt_trigger,
+	.pointer	= aml_pcm2bt_pointer,
+	.copy 		= aml_pcm2bt_copy,
+	.silence	= aml_pcm2bt_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+
+static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
+
+static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
+
+    printk(KERN_DEBUG "enter %s stream: %d\n", __FUNCTION__, stream);
+    
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area) {
+        printk(KERN_ERR "%s dma_alloc_coherent failed (size: %d)!\n", __FUNCTION__, size);
+		return -ENOMEM;
+    }
+
+	buf->bytes = size;
+    printk(KERN_INFO "%s allcoate buf->area: %p buf->addr: 0x%x buf->bytes: %d\n",
+                __FUNCTION__, buf->area, buf->addr, buf->bytes);
+	return 0;
+}
+
+static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
+       pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
+    
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_pcm2bt_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void aml_pcm2bt_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+struct aml_audio_interface aml_pcm_interface = {
+    .id = AML_AUDIO_PCM,
+    .name = "PCM",
+    .pcm_ops = &aml_pcm2bt_ops,
+    .pcm_new = aml_pcm2bt_new,
+    .pcm_free =  aml_pcm2bt_free,
+};
+
+
+#if 0
+struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
+	.ops 	= &aml_pcm2bt_ops,
+	.pcm_new	= aml_pcm2bt_new,
+	.pcm_free	= aml_pcm2bt_free,
+	//.suspend	= aml_pcm_suspend,
+	//.resume		= aml_pcm_resume,
+};
+EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
+
+static int __devinit aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
+{
+	//INIT_WORK(&aml_pcm_work.aml_codec_workqueue, aml_codec_power_switch_queue);
+	printk("shaoshuai, snd_soc_register_platform\n");
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
+}
+
+static int __devexit aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver aml_platform_pcm2bt_driver = {
+	.driver = {
+			.name = "aml-bt",
+			.owner = THIS_MODULE,
+	},
+
+	.probe = aml_soc_platform_pcm2bt_probe,
+	.remove = __devexit_p(aml_soc_platform_pcm2bt_remove),
+};
+
+static int __init aml_alsa_bt_init(void)
+{
+	//aml_pcm_init_debugfs();		
+	return platform_driver_register(&aml_platform_pcm2bt_driver);
+}
+
+static void __exit aml_alsa_bt_exit(void)
+{
+	//aml_pcm_cleanup_debugfs();
+    platform_driver_unregister(&aml_platform_pcm2bt_driver);
+}
+
+module_init(aml_alsa_bt_init);
+module_exit(aml_alsa_bt_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
+#endif
diff --git a/sound/soc/aml/m6/aml_platform_pcm2bt.h b/sound/soc/aml/m6/aml_platform_pcm2bt.h
new file mode 100644
index 000000000000..233f906574c6
--- /dev/null
+++ b/sound/soc/aml/m6/aml_platform_pcm2bt.h
@@ -0,0 +1,6 @@
+#ifndef __AML_PCM_BT_H__
+#define __AML_PCM_BT_H__
+
+extern struct aml_audio_interface aml_pcm_interface;
+
+#endif
diff --git a/sound/soc/aml/m6/aml_syno9629_codec.c b/sound/soc/aml/m6/aml_syno9629_codec.c
new file mode 100644
index 000000000000..88911db98db2
--- /dev/null
+++ b/sound/soc/aml/m6/aml_syno9629_codec.c
@@ -0,0 +1,1213 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include <mach/am_regs.h>
+#include "aml_audio_hw.h"
+#include "aml_syno9629_codec.h"
+
+#define CODEC_DEBUG  printk
+#define stimulus_print  //printk
+#define Wr WRITE_MPEG_REG
+#define Rd  READ_MPEG_REG
+static struct snd_soc_codec *aml_syno9629_codec;
+
+static int (*is_hp_pluged)(void) = NULL;
+static void (*mute_spk)(struct snd_soc_codec* codec, int flag) = NULL;
+static void latch (void);
+static void acodec_delay_us (int us);
+
+/* codec private data */
+struct aml_syno9629_codec_priv {
+	struct snd_soc_codec codec;
+	u16 reg_cache[ADAC_MAXREG];
+	unsigned int sysclk;
+};
+
+u16 aml_syno9629_reg[ADAC_MAXREG] = {0};
+static const unsigned int linein_values[] = {
+    1|(1<<(1-1)),
+    1|(1<<(2-1)),
+    1|(1<<(3-1)),
+    1|(1<<(4-1)),
+    1|(1<<(5-1)),
+    1|(1<<(6-1)),
+    1|(1<<(7-1)),
+    1|(1<<(8-1))
+    };
+
+unsigned long aml_rate_table[] = {
+    8000, 11025, 12000, 16000, 22050, 24000, 32000, 
+    44100, 48000, 88200, 96000, 192000
+};
+static unsigned int acodec_regbank[ADAC_MAXREG] = {
+									0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg   0 -   9
+                                    0x00, 0x00, 0x08, 0x08, 0x01, 0x00, 0x00, 0xae, 0x00, 0x00, // Reg  10 -  19
+                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg  20 -  29
+                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x04, 0x04, // Reg  30 -  39
+                                    0x12, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg  40 -  49
+                                    0x00, 0x00, 0x54, 0x54, 0xff, 0xff, 0x28, 0x28, 0xff, 0xff, // Reg  50 -  59
+                                    0x28, 0x28, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg  60 -  69
+                                    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, // Reg  70 -  79
+                                    0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x01, 0x01, 0x02, // Reg  80 -  89
+                                    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, // Reg  90 -  99
+                                    0x00, 0x12, 0x12, 0x3c, 0x3c, 0xff, 0xff, 0xff, 0xff, 0xff, // Reg 100 - 109
+                                    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2e, 0x2e, // Reg 110 - 119
+                                    0xff, 0xff, 0x2e, 0x2e, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg 120 - 129
+                                    0x00, 0x00, 0x04, 0x04, 0x12, 0x12, 0xff, 0xff, 0xff, 0xff, // Reg 130 - 139
+                                    0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x28, 0x28, // Reg 140 - 149
+                                    0xff, 0xff, 0x28, 0x28, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, // Reg 150 - 159
+                                    0x00, 0x00, 0x03, 0xf3, 0x00, 0x04, 0x03, 0x08, 0x00, 0x0c, // Reg 160 - 169
+                                    0x00, 0x10, 0x00, 0x14, 0x00, 0x18, 0x01, 0x1c, 0x00, 0x20, // Reg 170 - 179
+                                    0x00, 0x24, 0x00, 0x28, 0x7f, 0x2c, 0x24, 0x2c, 0x56, 0x30, // Reg 180 - 189
+                                    0x00, 0x34, 0x37, 0x38, 0x7f, 0x3c, 0x01, 0x01, 0x00, 0x00, // Reg 190 - 199
+                                    0x00, 0x06, 0x00, 0x06, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg 200 - 209
+                                    0x00, 0x00, 0x00, 0x03, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, // Reg 210 - 219
+                                    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x40, 0x01, 0x00, 0x00, // Reg 220 - 229
+                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg 230 - 239
+                                    0x02, 0x02, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x49, 0xfc, // Reg 240 - 249
+                                    0x50, 0x84, 0x00, 0x00, 0x00, 0x00 							// Reg 250 - 255
+                                   };
+
+typedef enum  {
+    AML_PWR_DOWN,
+    AML_PWR_UP,
+    AML_PWR_KEEP,
+} AML_PATH_SET_TYPE;
+
+static void set_acodec_source (unsigned int src)
+{
+    unsigned long data32;
+    unsigned int i;
+    
+    // Disable acodec clock input and its DAC input
+    data32  = 0;
+    data32 |= 0     << 4;   // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= 0     << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
+
+    // Enable acodec clock from the selected source
+    data32  = 0;
+    data32 |= 0      << 4;  // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= src   << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
+    
+    // Wait until clock change is settled
+    i = 0;
+    while ( (((Rd(AIU_CODEC_CLK_DATA_CTRL)) >> 8) & 0x3) != src ) {
+        if (i > 255) {
+            stimulus_print("[TEST.C] Error: set_acodec_source timeout!\n");
+           // stimulus_finish_fail(10);
+        }
+        i ++;
+    }
+
+    // Enable acodec DAC input from the selected source
+    data32  = 0;
+    data32 |= src   << 4;   // [5:4]    acodec_data_sel: 00=disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= src   << 0;   // [1:0]    acodec_clk_sel: 00=Disable acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    Wr(AIU_CODEC_CLK_DATA_CTRL, data32);
+
+    // Wait until data change is settled
+    while ( (((Rd(AIU_CODEC_CLK_DATA_CTRL)) >> 12) & 0x3) != src) {}
+} /* set_acodec_source */
+
+static void adac_wr_reg (unsigned long addr, unsigned long data)
+{
+    WRITE_APB_REG((APB_BASE+(addr<<2)), data);
+    acodec_regbank[addr] = data;
+} /* adac_wr_reg */
+
+static unsigned long adac_rd_reg (unsigned long addr)
+{
+    unsigned long data;
+    data = READ_APB_REG((APB_BASE+(addr<<2)));
+    return (data);
+} /* adac_rd_reg */
+
+static void adac_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask)
+{
+    unsigned long rd_data;
+    rd_data = adac_rd_reg(addr);
+    if ((rd_data | mask) != (exp_data | mask)) {
+        stimulus_print("[TEST.C] Error: audio CODEC register read data mismatch!\n");
+        stimulus_print("addr=0x%x ,",addr);
+        stimulus_print(" rd_data=0x%x ,",rd_data);
+        stimulus_print(" exp_data=0x%x\n",exp_data);
+    }
+} /* adac_rd_check_reg */
+
+static void acodec_startup_sequence (void)
+{
+    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- Begin\n");
+/*  
+1.	select the master clock mode mclksel[3:0] bit
+2.	start the master clock
+3.	set pdz bit to high
+4.	select the sampling rate
+5.	reset the signal path (rstdpz pin to low and back to high after 100ns)
+6.	start the individual codec blocks
+
+	7.1.1	Pop free start up recommendations
+	To obtain a pop-free start-up for the playback channel, the corresponding 
+	blocks in the desired playback signal path must also be enable when setting
+	the master power up control active, as per the start-up sequence step 3 
+	(above).
+
+	For example, when setting pdz bit to high, pddacl/rz bit, pdhsdrvl/rz bit 
+	and/or pdauxdrvl/rz bit should also be set to high at the same time to
+	obtain a clean, pop-free start up.
+	By using the latch signal properly, it is possible to guarantee that all the
+	required power control, signals are loaded to the Audio Codec IP
+	simultaneously.*/
+
+	// Init at zero (In power Down and In Reset)
+    //data32  = 0;
+    //data32 |= 1     << 15;  // [15]     audac_soft_reset_n
+    //data32 |= 1     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
+    //data32 |= 0     << 9;   // [9]      delay_rd_en
+    //data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
+    //data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
+    //data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
+    Wr(AIU_AUDAC_CTRL0, Rd(AIU_AUDAC_CTRL0) | (1<<15) | (1<<14));
+//    adac_wr_reg(0x15, 0x00);
+//    latch();
+    acodec_delay_us(3000);
+    
+    // Disable system reset (In power Down and Out of Reset)
+    Wr(AIU_AUDAC_CTRL0, Rd(AIU_AUDAC_CTRL0) & (~(1<<15)));
+    acodec_delay_us(3000);
+    
+    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- End\n");
+} /* acodec_startup_sequence */
+
+static void acodec_config (unsigned long mclkseladc,   // [3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+                    unsigned long mclkseldac,   // [3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+                    unsigned long i2sfsadc,     // [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+                    unsigned long i2sfsdac,     // [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+                    unsigned long i2smsmode,    // 0=slave mode; 1=master mode.
+                    unsigned long i2smode,      // [2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
+                    unsigned long pgamute,      // [1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
+                    unsigned long recmute,      // [1:0]: [0] Recording left channel digital mute; [1] Recording right channel digital mute. 0=un-mute; 1=mute.
+                    unsigned long hs1mute,      // [1:0]: [0] Headset left channel analog mute; [1] Headset right channel analog mute. 0=un-mute; 1=mute.
+                    unsigned long lmmute,       // [1:0]: [0] Playback left channel digital mute; [1] Playback right channel digital mute. 0=un-mute; 1=mute.
+                    unsigned long ldr1outmute,  // [1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
+                    unsigned long recvol,       // [15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0x14=0dB.
+                    unsigned long pgavol,       // [15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x04=0dB.
+                    unsigned long lmvol,        // [15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0x54=0dB.
+                    unsigned long hs1vol,       // [15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x28=0dB.
+                    unsigned long pgasel,       // [15:0]: Left PGA input selection. [7:0] Left; [15:8] Right. 0x01=Input1, 0x03=Input2, 0x05=Input3, 0x09=Input4, 0x11=Input5, 0x21=Input6, 0x41=Input7, 0x81=Input8, others=Rsrv.
+                    unsigned long ldr1sel,      // [15:0]: Playback analog mixer input selection. [7:0] Left; [15:8] Right. [0]:1=Enable left DAC output; [1]:1=Enable left PGA; [2]:1=Enable right DAC output.
+                    unsigned long ctr,          // [1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
+                    unsigned long recmix,       // [1:0]: Record digital mixer sel.
+                    unsigned long enhp,         // Record channel high pass filter enable.
+                    unsigned long lmmix)        // [1:0]: Playback digital mixer sel.
+{
+    stimulus_print("[TEST.C] audio CODEC register config -- Begin\n");
+    adac_wr_reg(ADC_MCLK_SEL, mclkseladc);
+    adac_wr_reg(DAC_MCLK_SEL, mclkseldac); //256fs
+    adac_wr_reg(ADC_I2S_FS_SEL, i2sfsadc);
+    adac_wr_reg(DAC_I2S_FS_SEL, i2sfsdac); //48k
+    adac_wr_reg(ADAC_I2S_MODE_SEL, (i2smsmode<<3) | i2smode); //slave mode ,i2s 
+    adac_wr_reg(ADAC_MUTE_CTRL0, (pgamute<<2) | recmute); //un mute
+    adac_wr_reg(ADAC_MUTE_CTRL2, (hs1mute<<4) | lmmute);  //un mute
+    adac_wr_reg(ADAC_MUTE_CTRL4, (ldr1outmute<<2));
+    adac_wr_reg(ADC_REC_MVOL_LSB_CTRL, recvol&0xff);
+    adac_wr_reg(ADC_REC_MVOL_MSB_CTRL, recvol>>8);
+    adac_wr_reg(ADC_PGA_VOL_LSB_CTRL, pgavol&0xff);
+    adac_wr_reg(ADC_PGA_VOL_MSB_CTRL, pgavol>>8);
+    adac_wr_reg(DAC_PLYBACK_MVOL_LSB_CTRL, lmvol&0xff);
+    adac_wr_reg(DAC_PLYBACK_MVOL_MSB_CTRL, lmvol>>8);
+    adac_wr_reg(DAC_HS_VOL_LSB_CTRL, hs1vol&0xff);
+    adac_wr_reg(DAC_HS_VOL_MSB_CTRL, hs1vol>>8);
+    adac_wr_reg(ADC_REC_INPUT_CH_LSB_SEL, pgasel&0xff);
+    adac_wr_reg(ADC_REC_INPUT_CH_MSB_SEL, pgasel>>8);
+    adac_wr_reg(DAC_PLYBACK_MIXER_LSB_CTRL, ldr1sel&0xff);
+    adac_wr_reg(DAC_PLYBACK_MIXER_MSB_CTRL, ldr1sel>>8);
+    adac_wr_reg(ADAC_DIGITAL_TEST_MODE_SEL, ctr);
+    adac_wr_reg(ADC_REC_PATH_MIXER_SEL, (enhp<<2) | recmix);
+    adac_wr_reg(DAC_PLYBACK_DIG_MIXER_SEL, lmmix);
+    latch();
+    stimulus_print("[TEST.C] audio CODEC register config -- End\n");
+}
+
+static void acodec_prepare_register (void)
+{
+    stimulus_print("[TEST.C] acodec_prepare_register -- Begin\n");
+    adac_wr_reg(ADAC_POWER_CTRL0, 0xfe);
+    adac_wr_reg(ADAC_POWER_CTRL1, 0xff);
+    //adac_wr_reg(0x17, 0xff);
+    adac_wr_reg(ADAC_POWER_CTRL3, 0xff);
+  //  adac_wr_reg(0x19, 0xff);
+    // Config the not power down
+   // adac_wr_reg(0x11, 0x80); // configure the bypass prechage
+
+    // Setup the lssel to 11, enable the line output
+    //adac_wr_reg(0x55, 0x01);
+    //adac_wr_reg(0x56, 0x01);
+    //latch();
+    //acodec_delay_us(4000); // wait for 4 ms.
+
+    // Set bias current to 1/40 of the nominal current
+    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x0b); 
+    latch();
+    stimulus_print("[TEST.C] acodec_prepare_register -- End\n");
+} /* acodec_prepare_register */
+
+void acodec_powerup_fastcharge (void)
+{
+    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- Begin\n");
+
+    // Disable the bypass fast charger
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG2, 0x00);
+    // test1 register, bit[2:1] to configure the charge time for VCM, when 0 100ms, when 1, 1s
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG1, 0x00);
+    // Enable the new FSM for power up, bit[7] for enable the original FSM
+    // Configure the vcmok, bit[1:0] for vcm ok configuration, when 11, 1.65v, when 01, lower
+    adac_wr_reg(ADAC_VCM_RAMP_CTRL, 0x83);
+    latch();
+    acodec_delay_us(4000); // wait for 4 ms
+
+    // reset data path
+    adac_wr_reg(ADAC_RESET, 0x00);
+    latch();
+    adac_wr_reg(ADAC_RESET, 0x03);
+    latch();
+    // Out of power Down and Out of Reset
+    adac_wr_reg(ADAC_POWER_CTRL0, 0x05);
+    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x05);
+    latch();
+
+    acodec_delay_us(1050000); // wait for 1.05 sec
+    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- End\n");
+} /* acodec_powerup_fastcharge */
+static void acodec_powerup_bypassfastcharge (void)
+{
+    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- Begin\n");
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG1, 0x00);
+    // Bypass power up sequence
+    // [0]--bypasspwrseq
+    // [1]--cfgprechanaref
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG2, 0x01);
+    // Disable soft ramping
+    adac_wr_reg(ADAC_DIG_ASS_TEST_REG4, 0x80);
+
+    // [7]--enprechanaref
+    adac_wr_reg(ADAC_ANALOG_TEST_REG3, 0x84);
+    // Enable the new FSM for power up, bit[7] for enable the original FSM
+    // Configure the vcmok, bit[1:0] for vcm ok configuration, when 11, 1.65v, when 01, lower
+    adac_wr_reg(ADAC_VCM_RAMP_CTRL, 0x83);
+
+    // Power up block and bias generator
+    latch();
+
+
+    // reset data path
+    adac_wr_reg(ADAC_RESET, 0x00);
+    latch();
+    adac_wr_reg(ADAC_RESET, 0x03);
+    latch();	
+    //acodec_delay_us(4000); // wait for 4 ms.
+    adac_wr_reg(ADAC_POWER_CTRL0, 0x0f);
+    latch();
+
+    adac_wr_reg(ADAC_POWER_CUM_CTRL, 0x05);
+    latch();
+    acodec_delay_us(5000);
+    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- End\n");
+} /* acodec_powerup_bypassfastcharge */
+
+static void latch (void)
+{
+    int latch;
+    latch = 1;
+    adac_wr_reg(ADAC_LATCH, latch);
+    adac_rd_check_reg(ADAC_LATCH, latch, 0);
+    latch = 0;
+    adac_wr_reg(ADAC_LATCH, latch);
+    adac_rd_check_reg(ADAC_LATCH, latch, 0);
+} /* latch */
+static void latch_ (struct snd_soc_codec* codec)
+{
+    int latch;
+    latch = 1;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+    latch = 0;
+    snd_soc_write(codec, ADAC_LATCH, latch);
+}
+static void acodec_delay_us (int us)
+{
+	msleep(us/1000);
+} /* acodec_delay_us */
+
+static void aml_reset_path(struct snd_soc_codec* codec, AML_PATH_SET_TYPE type)
+{
+    CODEC_DEBUG( "enter %s\n", __func__);
+
+    return ;
+#if 0	
+    unsigned int pwr_reg2 = snd_soc_read(codec, ADAC_POWER_CTRL_REG2);
+    latch_(codec);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
+    latch_(codec);
+    snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2|(1<<7));
+    latch_(codec);
+     
+    if (AML_PWR_DOWN == type)
+    {
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2&(~(1<<7)));
+        latch_(codec);
+    }
+    
+    if (AML_PWR_KEEP == type)
+    {
+        snd_soc_write(codec, ADAC_POWER_CTRL_REG2, pwr_reg2);
+        latch_(codec);
+    }
+#endif	
+}
+
+static void aml_syno9629_reset(struct snd_soc_codec* codec, bool first_time)
+{
+	unsigned long   data32;
+	int i;
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	if (first_time)
+	{
+		CODEC_DEBUG( " first time enter %s\n", __func__);
+	
+		audio_set_clk(AUDIO_CLK_FREQ_48,0);
+		set_acodec_source(2);
+		WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+		//msleep(100);
+		data32  = 0;
+		// --------------------------------------------------------
+		// Configure audio DAC control interface
+		// --------------------------------------------------------
+		data32  = 0;
+		data32 |= 0     << 15;  // [15]     audac_soft_reset_n
+		data32 |= 1     << 14;  // [14]     audac_reset_ctrl: 0=use audac_reset_n pulse from reset module; 1=use audac_soft_reset_n.
+		data32 |= 0     << 9;   // [9]      delay_rd_en
+		data32 |= 0     << 8;   // [8]      audac_reg_clk_inv
+		data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
+		data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
+		Wr(AIU_AUDAC_CTRL0, data32);
+		// Enable APB3 fail on error
+		data32  = 0;
+		data32 |= 1     << 15;  // [15]     err_en
+		data32 |= 255   << 0;   // [11:0]   max_err
+		Wr(AIU_AUDAC_CTRL1, data32);
+		// Check read back data
+		data32 = Rd(AIU_AUDAC_CTRL0);
+		if (data32 != ((1<<14) | (0x55<<1))) {
+			stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL0 read data mismatch!");
+			//stimulus_finish_fail(10);
+		}
+		data32 = Rd(AIU_AUDAC_CTRL1);
+		if (data32 != 0x80ff) {
+			stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL1 read data mismatch!");
+			//stimulus_finish_fail(10);
+		}
+
+		// Check audio CODEC default register default values
+		stimulus_print("[TEST.C] Checking audio CODEC default register default values ...\n");
+		for (i = 0; i < 252; i ++) {
+			adac_rd_check_reg(i, acodec_regbank[i], 0);
+		}
+		stimulus_print("[TEST.C] ... Done checking audio CODEC default register values\n");
+
+		// --------------------------------------
+		// Setup Audio CODEC
+		// --------------------------------------
+		stimulus_print("[TEST.C] Setup audio CODEC ...\n");
+
+		acodec_startup_sequence(); //reset rstz  ?
+
+		acodec_config(  0,      // mclkseladc[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+		    0,      // mclkseldac[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+		    8,     // i2sfsadc[3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+		    8,      // i2sfsdac[3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+		    0,      // i2smsmode: 0=slave mode; 1=master mode.
+		    1,      // i2smode[2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
+		    0,      // pgamute[1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
+		    0,      // recmute[1:0]: [0] Recording left channel digital mute; [1] Recording right channel digital mute. 0=un-mute; 1=mute.
+		    0,      // hs1mute[1:0]: [0] Headset left channel analog mute; [1] Headset right channel analog mute. 0=un-mute; 1=mute.
+		    0,      // lmmute[1:0]: [0] Playback left channel digital mute; [1] Playback right channel digital mute. 0=un-mute; 1=mute.
+		    0,      // ldr1outmute[1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
+		    0x1414, // recvol[15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0x14=0dB.
+		    0x0404, // pgavol[15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x04=0dB.
+		    0x5454, // lmvol[15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0x54=0dB.
+		    0x2828, // hs1vol[15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x28=0dB.
+		    0x0909, // pgasel[15:0]: Left PGA input selection. [7:0] Left; [15:8] Right. 0x01=Input1, 0x03=Input2, 0x05=Input3, 0x09=Input4, 0x11=Input5, 0x21=Input6, 0x41=Input7, 0x81=Input8, others=Rsrv.
+		    0x0202, // ldr1sel[15:0]: Playback analog mixer input selection. [7:0] Left; [15:8] Right. [0]:1=Enable left DAC output; [1]:1=Enable left PGA; [2]:1=Enable right DAC output.
+		    0,      // ctr[1:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback.
+		    0,      // recmix[1:0]: Record digital mixer sel.
+		    0,      // enhp: Record channel high pass filter enable.
+		    0);     // lmmix[1:0]: Playback digital mixer sel.
+		acodec_prepare_register();
+
+		acodec_powerup_bypassfastcharge();
+		//acodec_powerup_fastcharge();	
+		// Check audio DAC register read-back values
+		stimulus_print("[TEST.C] Checking audio DAC register read-back values ...\n");
+		for (i = 0; i < 252; i ++) {
+			adac_rd_check_reg(i, acodec_regbank[i], 0);
+		}
+#if 0		
+		adac_wr_reg(0,  0); //rstadzpdz,rstdaczpdz  low
+		latch();
+		adac_wr_reg(0, 3);//rstadzpdz,rstdaczpdz  high
+		latch();
+#endif		
+		stimulus_print("[TEST.C] ... Done audio CODEC power-up bypass fast charge\n");
+	}
+	if (0)
+	{
+		CODEC_DEBUG( "  enter %s\n", __func__);	
+	//	snd_soc_write(codec, ADAC_LS_MIX_CTRL_LSB, 1);
+	//	snd_soc_write(codec, ADAC_LS_MIX_CTRL_MSB, 0);
+		aml_reset_path(codec, AML_PWR_UP);
+
+		latch_(codec);
+		snd_soc_write(codec, ADAC_RESET, (0<<1));
+		latch_(codec);
+		latch_(codec);
+		latch_(codec);
+		snd_soc_write(codec, ADAC_RESET, (1<<1));
+		latch_(codec);
+		latch_(codec);
+	}
+
+	//msleep(200);
+}
+
+
+static int audio_dac_set(unsigned freq)
+{
+	return 0;
+}
+
+static int post_reset(struct snd_soc_dapm_widget *w,
+	    struct snd_kcontrol *kcontrol, int event)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = w->codec;
+
+	if (SND_SOC_DAPM_POST_PMU == event)
+	{
+		aml_syno9629_reset(codec,false);
+	}
+	else if (SND_SOC_DAPM_POST_PMD == event && codec->active == 0)
+		aml_reset_path(codec, AML_PWR_DOWN);
+	return 0;
+}
+
+static int aml_switch_get_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+#if 0
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct snd_soc_dapm_widget *w;
+	//struct snd_soc_dapm_context * dapm = &codec->dapm;
+	char *lname = NULL;
+	char *rname = NULL;
+
+    switch (e->reg)
+    {
+    case ADAC_POWER_CTRL_REG1:
+        if (6 == e->shift_l)
+        {
+            lname = "LINEOUTL";
+            rname = "LINEOUTR";
+        }
+        else if (4 == e->shift_l)
+        {
+            lname = "HP_L";
+            rname = "HP_R";
+        }
+        else if (2 == e->shift_l)
+        {
+            lname = "SPEAKER";
+        }
+    break;
+    case ADAC_POWER_CTRL_REG2:
+        if (2 == e->shift_l)
+        {
+            lname = "LINEINL";
+            rname = "LINEINR";
+        }
+    break;
+    default:
+    break;
+    }
+    
+	list_for_each_entry(w, &codec->card->widgets, list) {
+        if (lname && !strcmp(lname, w->name))
+            ucontrol->value.enumerated.item[0] = w->connected;
+        if (rname && !strcmp(rname, w->name))
+            ucontrol->value.enumerated.item[0] = w->connected;
+	}
+#endif
+	return 0;
+}
+
+static int aml_switch_put_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+#if 0
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    struct snd_soc_dapm_widget *w;
+    char *lname = NULL;
+    char *rname = NULL;
+    unsigned int pwr_reg;
+
+    switch (e->reg)
+    {
+    case ADAC_POWER_CTRL_REG1:
+        if (6 == e->shift_l)
+        {
+            lname = "LINEOUTL";
+            rname = "LINEOUTR";
+        }
+        else if (4 == e->shift_l)
+        {
+            lname = "HP_L";
+            rname = "HP_R";
+        }
+        else if (2 == e->shift_l)
+        {
+            lname = "SPEAKER";
+        }
+    break;
+    case ADAC_POWER_CTRL_REG2:
+        if (2 == e->shift_l)
+        {
+            lname = "LINEINL";
+            rname = "LINEINR";
+        }
+    break;
+    default:
+    break;
+    }
+
+    pwr_reg = snd_soc_read(codec, e->reg);
+    if(ucontrol->value.enumerated.item[0] == 0){
+    snd_soc_write(codec, e->reg, (pwr_reg&(~(0x1<<(e->shift_l)|0x1<<(e->shift_r)))));
+    }
+    else{
+    snd_soc_write(codec, e->reg, (pwr_reg|(0x1<<(e->shift_l)|0x1<<(e->shift_r))));
+    }
+
+	list_for_each_entry(w, &codec->card->widgets, list) {
+        if (lname && !strcmp(lname, w->name))
+        {
+            w->connected = ucontrol->value.enumerated.item[0];
+            CODEC_DEBUG("%s:connect=%d\n",w->name,w->connected);
+        }
+        if (rname && !strcmp(rname, w->name))
+        {
+            w->connected = ucontrol->value.enumerated.item[0];
+            CODEC_DEBUG("%s:connect=%d\n",w->name,w->connected);
+        }
+	}
+#endif
+	return 0;
+}
+
+static int aml_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    int err = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+    if (err < 0)
+        return err;
+
+    aml_reset_path(codec, AML_PWR_KEEP);
+    return 0;
+}
+
+static int aml_ai_source_get_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    //struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 0)
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+    
+    if (READ_MPEG_REG(AUDIN_SOURCE_SEL) == 1) 
+        ucontrol->value.enumerated.item[0] = 0;// linein
+    else
+        ucontrol->value.enumerated.item[0] = 1;//hdmi
+        
+    return 0;
+}
+
+static int aml_ai_source_put_enum(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    //struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+    
+    if (ucontrol->value.enumerated.item[0] == 0)
+        WRITE_MPEG_REG(AUDIN_SOURCE_SEL, (1<<0)); // select audio codec output as I2S source
+    else{
+  	 WRITE_MPEG_REG(AUDIN_SOURCE_SEL,(0  <<12)   | // [14:12]cntl_hdmirx_chsts_sel: 0=Report chan1 status; 1=Report chan2 status; ...; 
+
+                                            (0xf<<8)    | // [11:8] cntl_hdmirx_chsts_en
+
+                                            (1  <<4)    | // [5:4]  spdif_src_sel: 1=Select HDMIRX SPDIF output as AUDIN source
+
+                                            (2 << 0));    // [1:0]  i2sin_src_sel: 2=Select HDMIRX I2S output as AUDIN source
+
+    }    
+	// reset adc data path
+    snd_soc_write(codec, ADAC_RESET, 1);
+    snd_soc_write(codec, ADAC_RESET, 3);
+    
+    return 0;
+}
+
+
+
+static const DECLARE_TLV_DB_SCALE(lineout_volume, -12600, 150, 0);
+static const DECLARE_TLV_DB_SCALE(hs_volume, -4000, 100, 0);
+static const DECLARE_TLV_DB_SCALE(linein_volume, -9600, 150, 0);
+
+static const char *left_linein_texts[] = {
+	"Left Line In 1", "Left Line In 2", "Left Line In 3", "Left Line In 4",
+	"Left Line In 5", "Left Line In 6", "Left Line In 7", "Left Line In 8"
+	};
+
+static const char *right_linein_texts[] = {
+	"Right Line In 1", "Right Line In 2", "Right Line In 3", "Right Line In 4",
+	"Right Line In 5", "Right Line In 6", "Right Line In 7", "Right Line In 8"
+	};
+
+
+
+static const char *iis_split_texts[] = {
+	"iis_not_split", "iis_split"
+	};
+
+static const unsigned int iis_split_values[] = {
+	0,
+	1
+    };
+
+
+static const SOC_VALUE_ENUM_SINGLE_DECL(left_linein_select, ADAC_REC_CH_SEL_LSB,
+		0, 0xff, left_linein_texts, linein_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(right_linein_select, ADAC_REC_CH_SEL_MSB,
+		0, 0xff, right_linein_texts, linein_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(iis_split_select, DAC_I2S_FS_SEL,
+		3, 0xff, iis_split_texts, iis_split_values);
+
+static const char *switch_op_modes_texts[] = {
+	"OFF", "ON"
+};
+//Left/Right DAC power-down/up
+static const struct soc_enum lineout_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 0, 1,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+//left/Right headset power-down signal
+static const struct soc_enum hp_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 4, 5,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+//Left/Right PGA power-down signal
+static const struct soc_enum linein_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL1, 2,3,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+//
+static const struct soc_enum sp_op_modes_enum =
+	SOC_ENUM_DOUBLE(ADAC_POWER_CTRL3, 0, 1,
+			ARRAY_SIZE(switch_op_modes_texts),
+			switch_op_modes_texts);
+
+static const char *audio_in_source_texts[] = {
+	"LINEIN", "HDMI"
+};
+static const struct soc_enum audio_in_source_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
+			ARRAY_SIZE(audio_in_source_texts),
+			audio_in_source_texts);
+
+
+static const struct snd_kcontrol_new amlsyno9629_snd_controls[] = {
+	SOC_DOUBLE_R_EXT_TLV("LINEOUT Playback Volume", DAC_PLYBACK_MVOL_LSB_CTRL, DAC_PLYBACK_MVOL_MSB_CTRL,
+	       0, 84, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, lineout_volume),
+	      
+	 SOC_DOUBLE_R_EXT_TLV("HeadSet Playback Volume", DAC_HS_VOL_LSB_CTRL, DAC_HS_VOL_MSB_CTRL,
+	       0, 46, 0, snd_soc_get_volsw_2r, aml_put_volsw_2r, hs_volume),
+
+    SOC_DOUBLE_R_EXT_TLV("LINEIN Capture Volume", ADC_REC_MVOL_LSB_CTRL, ADC_REC_MVOL_MSB_CTRL,
+	       0, 84, 1, snd_soc_get_volsw_2r, aml_put_volsw_2r, linein_volume),
+
+	SOC_VALUE_ENUM("Left LINEIN Select",left_linein_select),
+	SOC_VALUE_ENUM("Right LINEIN Select",right_linein_select),
+	SOC_VALUE_ENUM("IIS Split Select", iis_split_select),
+
+    SOC_ENUM_EXT("LOUT Playback Switch", lineout_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+    SOC_ENUM_EXT("HP Playback Switch", hp_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+	SOC_ENUM_EXT("LIN Capture Switch", linein_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+		
+	SOC_ENUM_EXT("SP Playback Switch", sp_op_modes_enum,
+		aml_switch_get_enum,aml_switch_put_enum),
+
+    SOC_ENUM_EXT("Audio In Source", audio_in_source_enum,
+        aml_ai_source_get_enum,aml_ai_source_put_enum),
+
+};
+#if 0
+static const struct snd_kcontrol_new lineoutl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 0, 1, 1);
+static const struct snd_kcontrol_new lineoutr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 1, 1, 1);
+static const struct snd_kcontrol_new hsl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 6, 1, 1);
+static const struct snd_kcontrol_new hsr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG1, 7, 1, 1);
+static const struct snd_kcontrol_new spk_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 2, 1, 1);
+
+static const struct snd_kcontrol_new lineinl_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 4, 1, 1);
+static const struct snd_kcontrol_new lineinr_switch_controls =
+	SOC_DAPM_SINGLE("Switch", ADAC_MUTE_CTRL_REG2, 5, 1, 1);
+
+static const struct snd_soc_dapm_widget aml_syno9629_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+	SND_SOC_DAPM_OUTPUT("HP_L"),
+	SND_SOC_DAPM_OUTPUT("HP_R"),
+	SND_SOC_DAPM_OUTPUT("SPEAKER"),
+
+	SND_SOC_DAPM_INPUT("LINEINL"),
+	SND_SOC_DAPM_INPUT("LINEINR"),
+	
+	SND_SOC_DAPM_DAC("DACL", "Left DAC Playback", ADAC_POWER_CTRL_REG1, 0, 0),
+	SND_SOC_DAPM_DAC("DACR", "Right DAC Playback", ADAC_POWER_CTRL_REG1, 1, 0),
+	SND_SOC_DAPM_ADC("ADCL", "Left ADC Capture", ADAC_POWER_CTRL_REG2, 0, 0),
+	SND_SOC_DAPM_ADC("ADCR", "Right ADC Capture", ADAC_POWER_CTRL_REG2, 1, 0),
+
+	SND_SOC_DAPM_SWITCH("LINEOUTL Switch", ADAC_POWER_CTRL_REG1, 6, 0,
+			    &lineoutl_switch_controls),
+	SND_SOC_DAPM_SWITCH("LINEOUTR Switch", ADAC_POWER_CTRL_REG1, 7, 0,
+			    &lineoutr_switch_controls),
+	SND_SOC_DAPM_SWITCH("HP_L Switch", ADAC_POWER_CTRL_REG1, 4, 0,
+			    &hsl_switch_controls),
+	SND_SOC_DAPM_SWITCH("HP_R Switch", ADAC_POWER_CTRL_REG1, 5, 0,
+			    &hsr_switch_controls),
+	SND_SOC_DAPM_SWITCH("SPEAKER Switch", ADAC_POWER_CTRL_REG1, 2, 0,
+			    &spk_switch_controls),
+
+	SND_SOC_DAPM_SWITCH("LINEINL Switch", ADAC_POWER_CTRL_REG2, 2, 0,
+			    &lineinl_switch_controls),
+	SND_SOC_DAPM_SWITCH("LINEINR Switch", ADAC_POWER_CTRL_REG2, 3, 0,
+			    &lineinr_switch_controls),
+
+       SND_SOC_DAPM_POST("RESET", post_reset),
+	
+	//SND_SOC_DAPM_PGA("HSL", ADAC_POWER_CTRL_REG1, 4, 0, NULL, 0),
+	//SND_SOC_DAPM_PGA("HSR", ADAC_POWER_CTRL_REG1, 5, 0, NULL, 0),
+	
+	//SND_SOC_DAPM_PGA("PDZ", ADAC_POWER_CTRL_REG2, 7, 0, NULL, 0),
+	SND_SOC_DAPM_MICBIAS("MICBIAS", ADAC_POWER_CTRL_REG2, 5, 0)
+};
+
+/* Target, Path, Source */
+
+static const struct snd_soc_dapm_route aml_syno9629_audio_map[] = {
+	{"LINEOUTL", NULL, "LINEOUTL Switch"},
+	{"LINEOUTL Switch", NULL, "DACL"},
+	{"LINEOUTR", NULL, "LINEOUTR Switch"},
+	{"LINEOUTR Switch", NULL, "DACR"},
+	
+	{"HP_L", NULL, "HP_L Switch"},
+	{"HP_L Switch", NULL, "DACL"},
+	{"HP_R", NULL, "HP_R Switch"},
+	{"HP_R Switch", NULL, "DACR"},
+
+	{"SPEAKER", NULL, "SPEAKER Switch"},
+	{"SPEAKER Switch", NULL, "DACL"},
+	{"SPEAKER Switch", NULL, "DACR"},
+
+       {"ADCL", NULL, "LINEINL Switch"},
+       {"LINEINL Switch", NULL, "LINEINL"},
+	{"ADCR", NULL, "LINEINR Switch"},
+	{"LINEINR Switch", NULL, "LINEINR"},
+};
+#endif
+static int aml_syno9629_write(struct snd_soc_codec *codec, unsigned int reg,
+							unsigned int value)
+{
+       u16 *reg_cache = codec->reg_cache;
+	CODEC_DEBUG("***Entered %s:%s:\nWriting reg is %#x; value=%#x\n",__FILE__,__func__, reg, value);
+	if (reg >= codec->reg_size/sizeof(u16))
+		return -EINVAL;
+	WRITE_APB_REG((APB_BASE+(reg<<2)), value);
+	reg_cache[reg] = value;
+	latch();
+
+      CODEC_DEBUG("Read back reg is %#x value=%#x\n", reg, READ_APB_REG(APB_BASE+(reg<<2)));
+
+	return 0;
+}
+
+static unsigned int aml_syno9629_read(struct snd_soc_codec *codec,
+							unsigned int reg)
+{
+	//u16 *reg_cache = codec->reg_cache;
+	if (reg >= codec->reg_size/sizeof(u16))
+		return -EINVAL;
+	
+	return READ_APB_REG(APB_BASE+(reg<<2));
+	//return reg_cache[reg];
+}
+
+static int aml_syno9629_codec_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned int i2sfs;
+	unsigned long rate = params_rate(params);
+	int rate_idx = 0;
+
+	for (rate_idx = 0; rate_idx < ARRAY_SIZE(aml_rate_table); rate_idx++){
+		if (aml_rate_table[rate_idx] == rate)
+			break;
+	}	
+	if (ARRAY_SIZE(aml_rate_table) == rate_idx){
+		printk(" sample rate not supported by codec \n");
+		rate_idx = 0x8; //48k
+	}	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_write(codec, DAC_I2S_FS_SEL, rate_idx);
+	else
+		snd_soc_write(codec, ADC_I2S_FS_SEL, rate_idx);
+//	aml_reset_path(codec, AML_PWR_KEEP);
+	return 0;
+}
+
+
+static int aml_syno9629_codec_pcm_prepare(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	//struct snd_soc_codec *codec = dai->codec;
+	/* set active */
+	
+	// TODO
+
+	return 0;
+}
+
+static void aml_syno9629_codec_shutdown(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = dai->codec;
+	/* deactivate */
+	if (!codec->active) {
+		udelay(50);
+		
+		// TODO
+	}
+}
+
+static int aml_syno9629_codec_mute(struct snd_soc_dai *dai, int mute)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	struct snd_soc_codec *codec = dai->codec;
+	u16 reg;
+	// TODO
+
+	reg = snd_soc_read(codec, ADAC_MUTE_CTRL4);
+	if(mute){
+		reg |= 3<<2;
+	}
+	else{
+		reg &= ~(3<<2);
+	}
+	CODEC_DEBUG("aml_syno9629_codec_mute mute=%d\n",mute);
+	snd_soc_write(codec, ADAC_MUTE_CTRL4, reg);
+	return 0;
+}
+
+static int aml_syno9629_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	//struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned long data = 0;
+	
+	switch (freq) {
+	case 32000:
+		data = 6;
+		break;
+	case 44100:
+		data = 7;
+		break;
+	case 48000:
+		data = 8;
+		break;
+	case 96000:
+		data = 10;
+		break;
+	default:
+		data = 6;
+		break;
+	}
+	//snd_soc_write(codec,ADAC_CLOCK, 0);
+	//snd_soc_write(codec,ADAC_I2S_CONFIG_REG1, data);
+	return 0;
+}
+
+
+static int aml_syno9629_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	//struct snd_soc_codec *codec = codec_dai->codec;
+	u16 iface = 0;
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set iface */
+	
+	// TODO
+	
+	return 0;
+}
+
+#define AML_RATES SNDRV_PCM_RATE_8000_96000
+
+#define AML_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+
+static struct snd_soc_dai_ops aml_syno9629_codec_dai_ops = {
+	.prepare	= aml_syno9629_codec_pcm_prepare,
+	.hw_params	= aml_syno9629_codec_hw_params,
+	.shutdown	= aml_syno9629_codec_shutdown,
+	.digital_mute	= aml_syno9629_codec_mute,
+	.set_sysclk	= aml_syno9629_codec_set_dai_sysclk,
+	.set_fmt	= aml_syno9629_codec_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver aml_syno9629_codec_dai = {
+	.name = "syno9629-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AML_RATES,
+		.formats = AML_FORMATS,},
+	.ops = &aml_syno9629_codec_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL_GPL(aml_syno9629_codec_dai);
+
+static int aml_syno9629_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		break;
+	case SND_SOC_BIAS_OFF:
+	    break;
+	default:
+	    break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static int aml_syno9629_soc_probe(struct snd_soc_codec *codec){
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	CODEC_DEBUG( "enter %s\n", __func__);	
+	aml_syno9629_reset(codec, true);
+	aml_syno9629_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	
+	snd_soc_add_controls(codec, amlsyno9629_snd_controls,
+				ARRAY_SIZE(amlsyno9629_snd_controls));
+#if 0	
+	snd_soc_dapm_new_controls(dapm, aml_syno9629_dapm_widgets,
+				  ARRAY_SIZE(aml_syno9629_dapm_widgets));
+
+	snd_soc_dapm_add_routes(dapm, aml_syno9629_audio_map, ARRAY_SIZE(aml_syno9629_audio_map));
+#endif	
+      aml_syno9629_codec = codec;                
+    return 0;
+}
+static int aml_syno9629_soc_remove(struct snd_soc_codec *codec){
+	return 0;
+}
+static int aml_syno9629_soc_suspend(struct snd_soc_codec *codec,	pm_message_t state){
+	CODEC_DEBUG( "enter %s\n", __func__);
+	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)&~(1 << 2));
+	aml_reset_path(codec, AML_PWR_DOWN);	
+	return 0;
+}
+
+static int aml_syno9629_soc_resume(struct snd_soc_codec *codec){
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	WRITE_MPEG_REG( HHI_GCLK_MPEG1, READ_MPEG_REG(HHI_GCLK_MPEG1)|(1 << 2));
+	aml_syno9629_reset(codec, true);	
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_syno9629 = {
+	.probe = 	aml_syno9629_soc_probe,
+	.remove = 	aml_syno9629_soc_remove,
+	.suspend =	aml_syno9629_soc_suspend,
+	.resume = 	aml_syno9629_soc_resume,
+	.read = aml_syno9629_read,
+	.write = aml_syno9629_write,
+	.set_bias_level = aml_syno9629_set_bias_level,
+	.reg_cache_size = ARRAY_SIZE(aml_syno9629_reg),
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 1,
+	.reg_cache_default = aml_syno9629_reg,
+	.dapm_widgets = 0,//aml_syno9629_dapm_widgets,
+	.num_dapm_widgets = 0,//ARRAY_SIZE(aml_syno9629_dapm_widgets),
+	.dapm_routes =  0,//aml_syno9629_audio_map,
+	.num_dapm_routes = 0,//ARRAY_SIZE(aml_syno9629_audio_map),
+};
+
+static int aml_syno9629_codec_platform_probe(struct platform_device *pdev)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+	return snd_soc_register_codec(&pdev->dev, 
+		&soc_codec_dev_syno9629, &aml_syno9629_codec_dai, 1);
+}
+
+static int __exit aml_syno9629_codec_platform_remove(struct platform_device *pdev)
+{	
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver aml_syno9629_codec_platform_driver = {
+	.driver = {
+		.name = "syno9629",
+		.owner = THIS_MODULE,
+		},
+	.probe = aml_syno9629_codec_platform_probe,
+	.remove = __exit_p(aml_syno9629_codec_platform_remove),
+};
+
+static int __init aml_syno9629_codec_modinit(void)
+{
+	CODEC_DEBUG( "enter %s\n", __func__);
+
+	return platform_driver_register(&aml_syno9629_codec_platform_driver);
+}
+
+static void __exit aml_syno9629_codec_exit(void)
+{
+		platform_driver_unregister(&aml_syno9629_codec_platform_driver);
+}
+
+module_init(aml_syno9629_codec_modinit);
+module_exit(aml_syno9629_codec_exit);
+
+
+MODULE_DESCRIPTION("ASoC AML synopsys 9629  codec driver");
+MODULE_AUTHOR("jian.xu@amlogic.com AMLogic Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m6/aml_syno9629_codec.h b/sound/soc/aml/m6/aml_syno9629_codec.h
new file mode 100644
index 000000000000..b3e9940a2487
--- /dev/null
+++ b/sound/soc/aml/m6/aml_syno9629_codec.h
@@ -0,0 +1,215 @@
+#ifndef _AML_SYNO9629_CODEC_H
+#define _AML_SYNO9629_CODEC_H
+
+#define APB_BASE					0x4000
+
+// data path reset register. bit 0 rstdacdpz,bit 1  rstadcdpz  
+// when i2s reconfiguration, reset data path recommanded
+#define ADAC_RESET                		0x00
+//bit 0 latch
+#define ADAC_LATCH                		0x01
+/* 
+[3:0]: 0=256*Fs; 1=384*Fs; 2=12M; 3=24M; 4=12.288M; 5=24.576M; 6=11.2896M; 7=22.5792M; 
+		8=18.432M; 9=36.864M; 10=16.9344M; 11=33.8688M; >=12:Reserved.
+*/
+#define ADC_MCLK_SEL                		0x02
+#define DAC_MCLK_SEL                		0x03
+//
+// [3:0]: 0=8k; 1=11.025k; 2=12; 3=16k; 4=22.05k; 5=24k; 6=32k, 7=44.1k, 8=48k; 9=88.2k; 10=96k; 11=192k; >=12:Reserved.
+#define ADC_I2S_FS_SEL      				0x0c
+#define DAC_I2S_FS_SEL      				0x0d
+/*
+i2smode[2:0]:default:1h
+Data format select:
+000: Right justified
+001: I2S justified
+010: Left justified
+011: Burst 1 format
+100: Burst 2 format
+101: Mono Burst 1 format
+110: Mono Burst 2 format
+111: Reserved
+i2smsmode[3] default:0
+I2S slave/master:
+0: slave mode
+1: master mode
+*/
+#define ADAC_I2S_MODE_SEL   			0x0e
+
+/*
+acodec standby/sleep control. [0] ensleep .default:0xAEh
+*/
+#define ADAC_STAND_SLEEP_CTRL      		0x11
+/*
+Power consumption management;cfgiref[3:0] default:0
+*/
+#define ADAC_POWER_CUM_CTRL     		0x12
+/*
+[0] pdz Overall power-down signal
+[2] pdmbias1z Microphone Bias 1 power-down signal
+*/
+#define ADAC_POWER_CTRL0				0x15
+/*
+[0] pdadclz Left ADC power-down signal
+[1] pdadcrz Right ADC power-down signal
+[2]pdpgalz Left PGA power-down signal
+[3] pdpgarz Right PGA power-down signal
+*/
+#define ADAC_POWER_CTRL1				0x16
+/*
+R24 (18h) 0 pddaclz Left DAC power-down signal 0h
+R24 (18h) 1 pddacrz Right DAC power-down signal 0h
+R24 (18h) 4 pdhs1rz Right headset power-down signal 0h
+R24 (18h) 5 pdhs1lz Left headset power-down signal 0h
+R24 (18h) 6 pdldr1rz Right single-end line driver 1 power-down signal 0h
+R24 (18h) 7 pdldr1lz Left single-end line driver 1 power-down signal
+*/
+#define ADAC_POWER_CTRL3				0x18
+
+/*
+R29 (1Dh)
+[0]
+recmute[0]
+Recording left channel digital mute:
+0: un-mute
+1: mute
+0h
+R29 (1Dh)
+[1]
+recmute[1]
+Recording right channel digital mute:
+0: un-mute
+1: mute
+*/
+#define ADAC_MUTE_CTRL0       		        0x1d
+/*
+R31 (1Fh)
+[4]
+hs1mute[0]
+Headset left channel analog mute:
+0: un-mute
+1: mute
+0h
+R31 (1Fh)
+[5]
+hs1mute[1]
+Headset right channel analog mute:
+0: un-mute
+1: mute
+*/
+#define ADAC_MUTE_CTRL2			        0x1f
+/*
+R33 (21h)
+[2]
+ldr1outmute[0]
+Playback left channel analog mute:
+0: un-mute
+1: mute
+0h
+R33 (21h)
+[3]
+ldr1outmute[1]
+Playback right channel analog mute:
+0: un-mute
+1: mute
+*/
+#define ADAC_MUTE_CTRL4        		        0x21
+/*
+Recording digital master volume control:
+The least significant 8 bits control the left channel:
+00000000: 30dB
+00000001 to 0010011: 28.5dB to 1.5dB
+00010100: 0dB
+00010101 to 1010011: -1.5dB to C94.5dB
+01010100: -96dB
+01010101 to 01111111: Reserved
+The most significant 8 bits control the right channel:
+00000000: 30dB
+00000001 to 0010011: 28.5dB to 1.5dB
+00010100: 0dB
+00010101 to 1010011: -1.5dB to C94.5dB
+01010100: -96dB
+01010101 to 1111111: Reserved
+*/
+#define ADC_REC_MVOL_LSB_CTRL  		0x24
+#define ADC_REC_MVOL_MSB_CTRL  		0x25
+/*
+Input PGA volume control:
+The least significant 8 bits control the left channel:
+00000000: -6 dB
+00000001: -4.5 dB
+K: K
+00000100: 0 dB
+K: K
+00010001: 19.5 dB
+00010010: 21 dB
+d00010011: Reserved
+The most significant 8 bits control the right channel:
+00000000: -6 dB
+00000001: -4.5 dB
+K: K
+00000100: 0 dB
+K: K
+00010001: 19.5 dB
+00010010: 21 dB
+d00010011: Reserved
+*/
+#define ADC_PGA_VOL_LSB_CTRL  			0x26
+#define ADC_PGA_VOL_MSB_CTRL  		0x27
+
+#define DAC_PLYBACK_MVOL_LSB_CTRL  	0x34
+#define DAC_PLYBACK_MVOL_MSB_CTRL  	0x35
+#define DAC_HS_VOL_LSB_CTRL  			0x38
+#define DAC_HS_VOL_MSB_CTRL  			0x39
+#define ADC_REC_INPUT_CH_LSB_SEL			0x47
+#define ADC_REC_INPUT_CH_MSB_SEL			0x48
+#define DAC_PLYBACK_MIXER_LSB_CTRL		0x59
+#define DAC_PLYBACK_MIXER_MSB_CTRL		0x5a
+
+#define ADAC_REC_CH_SEL_LSB			0x47
+#define ADAC_REC_CH_SEL_MSB			0x48
+#define ADAC_DIGITAL_TEST_MODE_SEL 	0xd2
+#define ADC_REC_PATH_MIXER_SEL 		0xd3 
+#define DAC_PLYBACK_DIG_MIXER_SEL 	0xd4
+/*
+VCM ramp up settle register
+*/
+ #define ADAC_VCM_RAMP_CTRL      		0xa2
+/*
+VCM pre-charge time control definition
+*/
+#define ADAC_DIG_ASS_TEST_REG1      				0xf0
+/*
+Digital-assisted analog test reg. Bypass power up/down sequences
+*/
+#define ADAC_DIG_ASS_TEST_REG2  	     				0xf1
+#define ADAC_DIG_ASS_TEST_REG3  	     				0xf2
+
+
+/*
+Digital-assisted analog test reg. 4
+*/
+#define ADAC_DIG_ASS_TEST_REG4  					0xf3
+#define ADAC_DIG_ASS_TEST_REG5  					0xf3
+/*
+Pure analog test reg. 3
+*/
+#define ADAC_ANALOG_TEST_REG3 					0xfb
+
+#define ADAC_VCM_REG1		0x80
+#define ADAC_VCM_REG2		0x81
+
+#define ADAC_TEST_REG1	0xe0
+#define ADAC_TEST_REG2	0xe1
+#define ADAC_TEST_REG3	0xe2
+#define ADAC_TEST_REG4	0xe3
+
+#define ADAC_MAXREG	256
+
+#define NO_CLOCK_TO_CODEC   0
+#define PCMOUT_TO_DAC           1
+#define AIU_I2SOUT_TO_DAC    2
+
+
+
+#endif
diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
new file mode 100644
index 000000000000..23aeff87ee22
--- /dev/null
+++ b/sound/soc/aml/m8/Kconfig
@@ -0,0 +1,13 @@
+#config  SND_AML_SPDIF
+#	tristate "Amlogic S/PDIF codec support"
+#	depends on SND_AML_M8_SOC
+#	select SND_SOC_AML_SPDIF_CODEC if SND_AML_SPDIF
+config SND_AML_M8
+	tristate "AML-SND-M8 Board"
+	depends on SND_AML_M8_SOC && SWITCH
+	select SND_SOC_AML_M8_CODEC if SND_AML_M8
+	
+config SND_AML_M8_PCM
+	tristate "M8 evaluation board with PCM2BT"
+	depends on SND_AML_M8_SOC
+	select SND_SOC_PCM2BT if SND_AML_M8_PCM
\ No newline at end of file
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
new file mode 100644
index 000000000000..89565733064b
--- /dev/null
+++ b/sound/soc/aml/m8/Makefile
@@ -0,0 +1,29 @@
+# AML Platform Support
+snd-soc-aml-pcm-objs := aml_pcm.o
+snd-soc-aml-i2s-objs := aml_i2s.o
+#snd-soc-aml-platform-pcm2bt-objs := aml_platform_pcm2bt.o
+snd-soc-aml-i2s-dai-objs := aml_i2s_dai.o
+snd-soc-aml-pcm-dai-objs := aml_pcm_dai.o
+snd-soc-aml-spdif-dai-objs  := aml_spdif_dai.o
+snd-soc-aml-hw-objs  := aml_audio_hw.o
+snd-soc-aml-hw-pcm2bt-objs  := aml_audio_hw_pcm2bt.o
+#snd-soc-aml-platform-objs := aml_platform.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-pcm.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-i2s.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-i2s-dai.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-pcm-dai.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-hw.o
+obj-$(CONFIG_SND_AML_M8_SOC) += aml_notify.o
+#obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-platform.o
+#obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-platform-pcm2bt.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-hw-pcm2bt.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-spdif-dai.o
+
+#AML spdif codec support
+snd-soc-aml-spdif-codec-objs := aml_spdif_codec.o
+#obj-$(CONFIG_SND_SOC_AML_SPDIF_CODEC) += snd-soc-aml-spdif-codec.o
+obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-spdif-codec.o
+#AML M8 Machine support
+snd-soc-aml-m8-objs := aml_m8.o
+obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
+
diff --git a/sound/soc/aml/m8/aml.dtd b/sound/soc/aml/m8/aml.dtd
new file mode 100644
index 000000000000..7e3011a4642c
--- /dev/null
+++ b/sound/soc/aml/m8/aml.dtd
@@ -0,0 +1,59 @@
+#ifdef CONFIG_SND_AML_SOC
+//$$ DEVICE="audio_platform"
+//$$ L2 PROP_STR = "status"
+    audio_platform{
+        compatible = "amlogic,aml-audio";
+        dev_name = "aml-audio.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_dai"
+//$$ L2 PROP_STR = "status"
+    audio_dai{
+        compatible = "amlogic,aml-dai";
+        dev_name = "aml-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_m8_audio"
+//$$ L2 PROP_STR = "status"
+    audio_m8_audio{
+        compatible = "amlogic,m8_audio_codec";
+        dev_name = "aml_m8_codec.0";
+        status = "okay";
+    };
+#endif        
+
+#ifdef CONFIG_SND_AML_M8
+//$$ DEVICE="aml_m8_sound_card"
+//$$ L2 PROP_STR = "aml,sound_card"
+//$$ L2 PROP_STR = "aml,codec_dai"
+//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
+//$$ L2 PROP_STR = "mute_gpio"
+//$$ L2 PROP_U32 5 = "hp_paraments"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Audio_pin_0_match" = "pinctrl-0"
+    aml_m8_sound_card{
+        compatible = "sound_card, aml_snd_m8";
+        aml,sound_card = "AML-M8AUDIO";
+        aml,codec_dai = "AML-M8";
+        aml,audio-routing =
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
+        mute_gpio = "GPIOY_15";
+        //mute_inv;
+        hp_paraments = <800 713 300 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
+        status = "okay";
+        
+    };
+#endif
+
+
+
diff --git a/sound/soc/aml/m8/aml_alsa_common.h b/sound/soc/aml/m8/aml_alsa_common.h
new file mode 100644
index 000000000000..31d8a768faa4
--- /dev/null
+++ b/sound/soc/aml/m8/aml_alsa_common.h
@@ -0,0 +1,12 @@
+#ifndef __AML_ALSA_COMMOM_H__
+#define __AML_ALSA_COMMON_H__
+
+#define VOLUME_SCALE	100
+#define VOLUME_SHIFT	15
+
+extern int aml_alsa_create_ctrl(struct snd_card *card, void *p_value);
+
+extern int get_mixer_output_volume(void);
+
+extern int set_mixer_output_volume(int volume);
+#endif
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
new file mode 100644
index 000000000000..52d1b586f8d3
--- /dev/null
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -0,0 +1,1283 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <mach/am_regs.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+//#include <mach/utils.h>
+#endif
+
+#include "aml_audio_hw.h"
+
+#ifndef MREG_AIU_958_chstat0
+#define AIU_958_chstat0	AIU_958_CHSTAT_L0
+#endif
+
+#ifndef MREG_AIU_958_chstat1
+#define AIU_958_chstat1	AIU_958_CHSTAT_L1
+#endif
+
+
+unsigned ENABLE_IEC958 = 1;
+unsigned IEC958_MODE   = AIU_958_MODE_PCM16;
+unsigned I2S_MODE      = AIU_I2S_MODE_PCM16;
+
+
+int  audio_in_buf_ready = 0;
+int audio_out_buf_ready = 0;
+
+unsigned int IEC958_bpf = 0x7dd;
+unsigned int IEC958_brst = 0xc;
+unsigned int IEC958_length = 0x7dd*8;
+unsigned int IEC958_padsize = 0x8000;
+unsigned int IEC958_mode = 1;
+unsigned int IEC958_syncword1 = 0x7ffe;
+unsigned int IEC958_syncword2 = 0x8001;
+unsigned int IEC958_syncword3 = 0;
+unsigned int IEC958_syncword1_mask = 0;
+unsigned int IEC958_syncword2_mask = 0;
+unsigned int IEC958_syncword3_mask = 0xffff;
+unsigned int IEC958_chstat0_l = 0x1902 ;
+unsigned int IEC958_chstat0_r = 0x1902 ;
+unsigned int IEC958_chstat1_l = 0x200;
+unsigned int IEC958_chstat1_r = 0x200;
+unsigned int IEC958_mode_raw = 0;
+/*
+ 0 --  other formats except(DD,DD+,DTS)
+ 1 --  DTS
+ 2 --  DD
+ 3 -- DTS with 958 PCM RAW package mode
+ 4 -- DD+
+*/
+unsigned int IEC958_mode_codec;
+/*
+bit 0:soc in slave mode for adc;
+bit 1:audio in data source from spdif in;
+bit 2:adc & spdif in work at the same time;
+*/
+unsigned audioin_mode = I2SIN_MASTER_MODE;
+
+EXPORT_SYMBOL(IEC958_bpf);
+EXPORT_SYMBOL(IEC958_brst);
+EXPORT_SYMBOL(IEC958_length);
+EXPORT_SYMBOL(IEC958_padsize);
+EXPORT_SYMBOL(IEC958_mode);
+EXPORT_SYMBOL(IEC958_syncword1);
+EXPORT_SYMBOL(IEC958_syncword2);
+EXPORT_SYMBOL(IEC958_syncword3);
+EXPORT_SYMBOL(IEC958_syncword1_mask);
+EXPORT_SYMBOL(IEC958_syncword2_mask);
+EXPORT_SYMBOL(IEC958_syncword3_mask);
+EXPORT_SYMBOL(IEC958_chstat0_l);
+EXPORT_SYMBOL(IEC958_chstat0_r);
+EXPORT_SYMBOL(IEC958_chstat1_l);
+EXPORT_SYMBOL(IEC958_chstat1_r);
+EXPORT_SYMBOL(IEC958_mode_raw);
+EXPORT_SYMBOL(IEC958_mode_codec);
+
+// Bit 3:  mute constant
+//         0 => 'h0000000
+//         1 => 'h800000
+unsigned int dac_mute_const = 0x800000;
+
+/*
+                                fIn * (M)
+            Fout   =  -----------------------------
+                      		(N) * (OD+1) * (XD)
+*/
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+int audio_clock_config_table[][12][2]=
+{
+	/*{HIU Reg , XD - 1)
+	   //7.875k, 8K, 11.025k, 12k, 16k, 22.05k, 24k, 32k, 44.1k, 48k, 96k, 192k
+	*/
+	{
+	//256
+#if OVERCLOCK == 0
+		{0x0004f880, (50-1)},  // 32
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8	
+		{0x0005e965, (40-1)}, //44.1	
+		{0x0004c9a0,	(50-1)},	//48K
+#else		
+		{0x0004cdf3, (42-1)},  // 44.1
+		{0x0007c4e6, (23-1)},  // 48
+#endif	
+		{0x0006d0a4, (13-1)},  // 96
+		{0x0004e15a, (9 -1)},   // 192
+		{0x0007f400, (125-1)}, // 8k
+		{0x0006c6f6, (116-1)}, // 11.025
+		{0x0007e47f, (86-1)},  // 12
+		{0x0004f880, (100-1)}, // 16
+		{0x0004c4a4, (87-1)},  // 22.05
+		{0x0007e47f, (43-1)},  // 24
+		{0x0007f3f0, (127-1)}, // 7875
+#else
+	//512FS
+		{0x0004f880, (25-1)},  // 32
+		{0x0004cdf3, (21-1)},  // 44.1
+		{0x0006d0a4, (13-1)},  // 48
+		{0x0004e15a, (9 -1)},  // 96
+		{0x0006f207, (3 -1)},   // 192
+		{0x0004f880, (100-1)}, // 8k
+		{0x0004c4a4, (87-1)}, // 11.025
+		{0x0007e47f, (43-1)},  // 12
+		{0x0004f880, (50-1)}, // 16
+		{0x0004cdf3, (42-1)},  // 22.05
+		{0x0007c4e6, (23-1)},  // 24
+		{0x0006e1b6, (76-1)}, // 7875
+#endif
+	},
+	{
+	//384
+		{0x0007c4e6, (23-1)},  // 32
+		{0x0004c4a4, (29-1)},  // 44.1
+		{0x0004cb18, (26-1)},  // 48
+		{0x0004cb18, (13-1)},  // 96
+		{0x0004e15a, (6 -1)},   // 192
+		{0x0007e47f, (86-1)},  // 8k
+		{0x0007efa5, (61-1)},  // 11.025
+		{0x0006de98, (67-1)},  // 12
+		{0x0007e47f, (43-1)},  // 16
+		{0x0004c4a4, (58-1)},  // 22.05
+		{0x0004c60e, (53-1)},  // 24
+		{0x0007fdfa, (83-1)},  // 7875
+	}
+};
+#else
+int audio_clock_config_table[][11][2]=
+{
+  // 128*Fs
+  //
+	/*{M, N, OD, XD-1*/
+	{
+	//24M
+        {(64<<0) | (3<<9) | (0<<14) , (125-1)}, // 32K, 4.096M
+#if OVERCLOCK==0
+        {(147<<0) | (5<<9) | (0<<14) , (125-1)}, // 44.1K, 5.6448M
+        {(32<<0) | (1<<9) | (0<<14) , (125-1)}, // 48K, 6.144M
+#else
+        {(143<<0) | (8<<9) | (0<<14) , (19-1)}, // 44.1K, 5.6448M*4=22.5792M
+        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, // 48K, 6.144M*4=24.576M
+#endif
+        {(128<<0) | (5<<9) | (1<<14) , (25-1)}, // 96K, 12.288M
+        {(128<<0) | (5<<9) | (0<<14) , (25-1)}, //192K, 24.576M
+        {(64<<0) | (3<<9) | (1<<14) , (250-1)}, // 8K, 1.024M
+        {(147<<0) | (5<<9) | (1<<14) , (250-1)}, //11.025K,1.4112M
+        {(32<<0) | (1<<9) | (1<<14) , (250-1)}, // 12K, 1.536M
+        {(64<<0) | (3<<9) | (1<<14) , (125-1)}, // 16K, 2.048M
+        {(147<<0) | (5<<9) | (1<<14) , (125-1)}, //22.050K, 2.8224M
+        {(32<<0) | (1<<9) | (1<<14) , (125-1)}, // 24K, 3.072M
+	},
+	{
+	//25M
+        {(29<<0) | (1<<9) | (0<<14) , (177-1)}, // 32K, 4.096M
+#if OVERCLOCK==0
+        {(21<<0) | (1<<9) | (0<<14) , (93-1)}, // 44.1K, 5.6448M
+        {(29<<0) | (1<<9) | (1<<14) , (59-1)}, // 48K, 6.144M
+#else
+        {(28<<0) | (1<<9) | (0<<14) , (31-1)}, // 44.1K, 5.6448M*4=22.5792M
+        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, // 48K, 6.144M*4=24.576M
+#endif
+        {(29<<0) | (1<<9) | (0<<14) , (59-1)}, // 96K, 12.288M
+        {(173<<0) | (8<<9) | (1<<14) , (11-1)}, //192K, 24.576M
+        {(58<<0) | (3<<9) | (1<<14) , (236-1)}, // 8K, 1.024M
+        {(162<<0) | (7<<9) | (1<<14) , (205-1)}, //11.025K,1.4112M
+        {(29<<0) | (1<<9) | (1<<14) , (236-1)}, // 12K, 1.536M
+        {(29<<0) | (1<<9) | (1<<14) , (177-1)}, // 16K, 2.048M
+        {(162<<0) | (7<<9) | (0<<14) , (205-1)}, //22.050K, 2.8224M
+        {(29<<0) | (1<<9) | (1<<14) , (118-1)}, // 24K, 3.072M
+	}
+};
+#endif
+
+
+void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
+{
+	printk("====== %s ======\n",__FUNCTION__);
+    WRITE_MPEG_REG(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
+    WRITE_MPEG_REG(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+    if(channel == 8)
+		WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 256); 
+	else
+    WRITE_MPEG_REG(AIU_MEM_I2S_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);   //this is for 16bit 2 channel
+
+    WRITE_MPEG_REG(AIU_I2S_MISC,		0x0004);	// Hold I2S
+	WRITE_MPEG_REG(AIU_I2S_MUTE_SWAP,	0x0000);	// No mute, no swap
+	// As the default amclk is 24.576MHz, set i2s and iec958 divisor appropriately so as not to exceed the maximum sample rate.
+	WRITE_MPEG_REG(AIU_I2S_MISC,		0x0010 );	// Release hold and force audio data to left or right
+
+	if(channel == 8){
+		printk(" %s channel == 8\n",__FUNCTION__);
+	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
+								(0xff << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+								(0xff << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+		}
+	else 
+	WRITE_MPEG_REG(AIU_MEM_I2S_MASKS,		(24 << 16) |	// [31:16] IRQ block.
+								(0x3 << 8) |	// [15: 8] chan_mem_mask. Each bit indicates which channels exist in memory
+								(0x3 << 0));	// [ 7: 0] chan_rd_mask.  Each bit indicates which channels are READ from memory
+
+    // 16 bit PCM mode
+    //  WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
+	// Set init high then low to initilize the I2S memory logic
+	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1 );
+	WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1 );
+
+	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
+	WRITE_MPEG_REG(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
+
+    audio_out_buf_ready = 1;
+}
+
+void audio_set_958outbuf(u32 addr, u32 size,int flag)
+{
+    if (ENABLE_IEC958) {
+        WRITE_MPEG_REG(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+	  	if(READ_MPEG_REG(AIU_MEM_IEC958_START_PTR) == READ_MPEG_REG(AIU_MEM_I2S_START_PTR)){
+			WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, READ_MPEG_REG(AIU_MEM_I2S_RD_PTR));
+		}
+		else
+        WRITE_MPEG_REG(AIU_MEM_IEC958_RD_PTR, addr & 0xffffffc0);
+        if(flag == 0){
+          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);    // this is for 16bit 2 channel
+        }else{
+          WRITE_MPEG_REG(AIU_MEM_IEC958_END_PTR, (addr & 0xffffffc0) + (size & 0xffffffc0) - 1);    // this is for RAW mode
+        }
+
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
+        WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
+
+        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
+        WRITE_MPEG_REG(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
+    }
+}
+/*
+i2s mode 0: master 1: slave
+*/
+static void i2sin_fifo0_set_buf(u32 addr, u32 size,u32 i2s_mode)
+{
+	unsigned char  mode = 0;
+	if(i2s_mode &I2SIN_SLAVE_MODE)
+		mode = 1;
+	WRITE_MPEG_REG(AUDIN_FIFO0_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO0_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO0_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+
+	WRITE_MPEG_REG(AUDIN_FIFO0_CTRL, (1<<AUDIN_FIFO0_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO0_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(1<<AUDIN_FIFO0_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
+									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
+								|(4<<AUDIN_FIFO0_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO0_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+		    						|(0<<16)	//to DDR
+                                                       |(1<<AUDIN_FIFO0_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(0<<17)    // Overflow Interrupt mask
+                                                       |(0<<18)    // Audio in INT
+			                                	//|(1<<19)	//hold 0 enable
+								|(0<<AUDIN_FIFO0_UG)	// hold0 to aififo
+				  );
+
+    WRITE_MPEG_REG(AUDIN_FIFO0_CTRL1,    0 << 4                       // fifo0_dest_sel
+                                       | 2 << 2                       // fifo0_din_byte_num
+                                       | 0 << 0);                      // fifo0_din_pos
+
+
+	WRITE_MPEG_REG(AUDIN_I2SIN_CTRL, //(0<<I2SIN_SIZE)			///*bit8*/  16bit
+									 (3<<I2SIN_SIZE)
+									|(1<<I2SIN_CHAN_EN)		/*bit10~13*/ //2 channel
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+									|(0<<I2SIN_POS_SYNC)
+#else
+									|(1<<I2SIN_POS_SYNC)
+#endif
+									|(1<<I2SIN_LRCLK_SKEW)
+                                    				|(1<<I2SIN_LRCLK_INVT)
+									|(!mode<<I2SIN_CLK_SEL)
+									|(!mode<<I2SIN_LRCLK_SEL)
+				    				|(!mode<<I2SIN_DIR)
+				  );
+
+}
+static void spdifin_fifo1_set_buf(u32 addr, u32 size)
+{
+	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffffff);
+	WRITE_MPEG_REG(AUDIN_FIFO1_START, addr & 0xffffffc0);
+	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, (addr&0xffffffc0));
+	WRITE_MPEG_REG(AUDIN_FIFO1_END, (addr&0xffffffc0) + (size&0xffffffc0)-8);
+	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1<<AUDIN_FIFO1_EN)	// FIFO0_EN
+    								|(1<<AUDIN_FIFO1_LOAD)	// load start address./* AUDIN_FIFO0_LOAD */
+								|(0<<AUDIN_FIFO1_DIN_SEL)	// DIN from i2sin./* AUDIN_FIFO0_DIN_SEL */
+	    							//|(1<<6)	// 32 bits data in./*AUDIN_FIFO0_D32b */
+									//|(0<<7)	// put the 24bits data to  low 24 bits./* AUDIN_FIFO0_h24b */16bit
+								|(4<<AUDIN_FIFO1_ENDIAN)	// /*AUDIN_FIFO0_ENDIAN */
+								|(2<<AUDIN_FIFO1_CHAN)//2 channel./* AUDIN_FIFO0_CHAN*/
+		    						|(0<<16)	//to DDR
+                                                       |(1<<AUDIN_FIFO1_UG)    // Urgent request.  DDR SDRAM urgent request enable.
+                                                       |(0<<17)    // Overflow Interrupt mask
+                                                       |(0<<18)    // Audio in INT
+			                                	//|(1<<19)	//hold 0 enable
+								|(0<<AUDIN_FIFO1_UG)	// hold0 to aififo
+				  );
+	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1,0xc);
+}
+void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode)
+{
+	printk("i2sin_fifo0_set_buf \n");		
+	i2sin_fifo0_set_buf(addr,size,i2s_mode);
+	audio_in_buf_ready = 1;
+}
+void audio_in_spdif_set_buf(u32 addr, u32 size)
+{
+	printk("spdifin_fifo1_set_buf \n");			
+	spdifin_fifo1_set_buf(addr,size);
+	
+}
+//extern void audio_in_enabled(int flag);
+
+void audio_in_i2s_enable(int flag)
+{
+  	int rd = 0, start=0;
+	if(flag){
+          /* reset only when start i2s input */
+reset_again:
+	     WRITE_MPEG_REG_BITS(AUDIN_FIFO0_CTRL, 1, 1, 1); // reset FIFO 0
+            WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 0);
+            rd = READ_MPEG_REG(AUDIN_FIFO0_PTR);
+            start = READ_MPEG_REG(AUDIN_FIFO0_START);
+            if(rd != start){
+              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
+              goto reset_again;
+            }
+			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 1, I2SIN_EN, 1);
+
+	}else{
+			WRITE_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, 0, I2SIN_EN, 1);
+	}
+}
+
+
+void audio_in_spdif_enable(int flag)
+{
+  int rd = 0, start=0;
+
+	if(flag){
+reset_again:
+	     WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1); // reset FIFO 0
+            WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
+            rd = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+            start = READ_MPEG_REG(AUDIN_FIFO1_START);
+            if(rd != start){
+              printk("error %08x, %08x !!!!!!!!!!!!!!!!!!!!!!!!\n", rd, start);
+              goto reset_again;
+            }
+		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)| (1<<31));		
+	}else{
+		WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)& ~(1<<31));				
+	}
+}
+int if_audio_in_i2s_enable()
+{
+	return READ_MPEG_REG_BITS(AUDIN_I2SIN_CTRL, I2SIN_EN, 1);
+}
+int if_audio_in_spdif_enable()
+{
+	return READ_MPEG_REG_BITS(AUDIN_SPDIF_MODE, 31, 1);
+}
+unsigned int audio_in_i2s_rd_ptr(void)
+{
+	unsigned int val;
+	val = READ_MPEG_REG(AUDIN_FIFO0_RDPTR);
+	printk("audio in i2s rd ptr: %x\n", val);
+	return val;
+}
+unsigned int audio_in_spdif_rd_ptr(void)
+{
+	unsigned int val;
+	val = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+	printk("audio in spdif rd ptr: %x\n", val);
+	return val;
+}
+unsigned int audio_in_i2s_wr_ptr(void)
+{
+	unsigned int val;
+      WRITE_MPEG_REG(AUDIN_FIFO0_PTR, 1);
+	val = READ_MPEG_REG(AUDIN_FIFO0_PTR);
+	return (val)&(~0x3F);
+	//return val&(~0x7);
+}
+unsigned int audio_in_spdif_wr_ptr(void)
+{
+	unsigned int val;
+      WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
+	val = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+	return (val)&(~0x3F);
+}
+void audio_in_i2s_set_wrptr(unsigned int val)
+{
+	WRITE_MPEG_REG(AUDIN_FIFO0_RDPTR, val);
+}
+void audio_in_spdif_set_wrptr(unsigned int val)
+{
+	WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, val);
+}
+void audio_set_i2s_mode(u32 mode)
+{
+    const unsigned short mask[4] = {
+        0x303,                  /* 2x16 */
+        0x303,                  /* 2x24 */
+        0x303,                 /* 8x24 */
+        0x303,                  /* 2x32 */
+    };
+
+    if (mode < sizeof(mask)/ sizeof(unsigned short)) {
+       /* four two channels stream */
+        WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 1);
+
+        if (mode == AIU_I2S_MODE_PCM16) {
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 0, 5, 1);
+        } else if(mode == AIU_I2S_MODE_PCM32){
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
+        }else if(mode == AIU_I2S_MODE_PCM24){
+            WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 6, 1);
+            WRITE_MPEG_REG_BITS(AIU_I2S_SOURCE_DESC, 1, 5, 1);
+        }
+
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_MASKS, mask[mode], 0, 16);
+
+        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 0, 1);
+        //WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 0, 1);
+
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_MASKS, mask[mode], 0,
+                                16);
+            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 0, 1);
+            //WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 0, 1);
+        }
+    }
+}
+
+/**
+ *  if normal clock, i2s clock is twice of 958 clock, so the divisor for i2s is 8, but 4 for 958
+ *  if over clock, the devisor for i2s is 8, but for 958 should be 1, because 958 should be 4 times speed according to i2s
+ *  This is dolby digital plus's spec
+ * */
+
+void audio_util_set_dac_format(unsigned format)
+{
+  	WRITE_MPEG_REG(AIU_CLK_CTRL,		 (0 << 12) | // 958 divisor more, if true, divided by 2, 4, 6, 8.
+							(1 <<  8) | // alrclk skew: 1=alrclk transitions on the cycle before msb is sent
+							(1 <<  6) | // invert aoclk
+							(1 <<  7) | // invert lrclk
+#if OVERCLOCK == 1
+							(3 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+							(3 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#else
+							(1 <<  4) | // 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+							(2 <<  2) | // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#endif
+							(1 <<  1) | // enable 958 clock
+							(1 <<  0)); // enable I2S clock
+    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
+    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
+    }
+ 	if(dac_mute_const == 0x800000)
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
+    else
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
+	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel
+}
+
+// iec958 and i2s clock are separated after M6TV.
+void audio_util_set_dac_958_format(unsigned format)
+{
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,0,12,1);// 958 divisor more, if true, divided by 2, 4, 6, 8
+#if IEC958_OVERCLOCK == 1
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+#else
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,4,2);// 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4.
+#endif
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,1,1);// enable 958 clock
+}
+
+void audio_util_set_dac_i2s_format(unsigned format)
+{	
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,6,1);//invert aoclk
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,7,1);//invert lrclk
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,8,2);// alrclk skew: 1=alrclk transitions on the cycle before msb is sent
+#if OVERCLOCK == 1
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,3,2,2);// i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#else
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,2,2,2); // i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8.
+#endif
+	WRITE_MPEG_REG_BITS(AIU_CLK_CTRL,1,0,1);// enable I2S clock
+	
+    if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 8, 2);
+    } else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY) {
+        WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 8, 2);
+    }
+ 	if(dac_mute_const == 0x800000)
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x000f);	// Payload 24-bit, Msb first, alrclk = aoclk/64.mute const 0x800000
+    else
+    	WRITE_MPEG_REG(AIU_I2S_DAC_CFG, 	0x0007);	// Payload 24-bit, Msb first, alrclk = aoclk/64
+	WRITE_MPEG_REG(AIU_I2S_SOURCE_DESC, 0x0001);	// four 2-channel	
+}
+
+extern unsigned int get_ddr_pll_clk(void);
+
+void audio_set_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+   // if (fs_config == AUDIO_CLK_256FS) {
+   if(1){
+		int index=0;
+		switch(freq)
+		{
+			case AUDIO_CLK_FREQ_192:
+				index=4;
+				break;
+			case AUDIO_CLK_FREQ_96:
+				index=3;
+				break;
+			case AUDIO_CLK_FREQ_48:
+				index=2;
+				break;
+			case AUDIO_CLK_FREQ_441:
+				index=1;
+				break;
+			case AUDIO_CLK_FREQ_32:
+				index=0;
+				break;
+			case AUDIO_CLK_FREQ_8:
+				index = 5;
+				break;
+			case AUDIO_CLK_FREQ_11:
+				index = 6;
+				break;
+			case AUDIO_CLK_FREQ_12:
+				index = 7;
+				break;
+			case AUDIO_CLK_FREQ_16:
+				index = 8;
+				break;
+			case AUDIO_CLK_FREQ_22:
+				index = 9;
+				break;
+			case AUDIO_CLK_FREQ_24:
+				index = 10;
+				break;
+			default:
+				index=0;
+				break;
+		};
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+	// get system crystal freq
+		clk=clk_get_sys("clk_xtal", NULL);
+		if(!clk)
+		{
+			printk(KERN_ERR "can't find clk %s for AUDIO PLL SETTING!\n\n","clk_xtal");
+			//return -1;
+		}
+		else
+		{
+			xtal=clk_get_rate(clk);
+			xtal=xtal/1000000;
+			if(xtal>=24 && xtal <=25)/*current only support 24,25*/
+			{
+				xtal-=24;
+			}
+			else
+			{
+				printk(KERN_WARNING "UNsupport xtal setting for audio xtal=%d,default to 24M\n",xtal);
+				xtal=0;
+			}
+		}
+
+		audio_clock_config = audio_clock_config_table[xtal];
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+#endif
+
+#ifdef CONFIG_SND_AML_M3
+	if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==516000000)&&(index=2))) // 48k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 516/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 48k clock from ddr pll %dM\n", 516);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==508000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 45-1, 0, 8); // 508/45
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 508);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==486000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 43-1, 0, 8); // 486/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 486);
+		return;
+	}
+	else if (((clk_get_rate(clk)==24000000)&&(get_ddr_pll_clk()==474000000)&&(index=1))) // 44.1k
+	{
+		WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8)); // audio clock off
+		WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15)); // audio pll off
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 4, 9, 3); // select ddr
+		WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 42-1, 0, 8); // 474/42
+		WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+		WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1<<23));// gate audac_clkpi
+		WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+		printk(KERN_INFO "audio 44.1k clock from ddr pll %dM\n", 474);
+		return;
+	}
+#endif
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+
+//#ifdef CONFIG_SND_AML_M3
+#ifdef CONFIG_ARCH_MESON3
+	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL2, 0x065e31ff);
+	WRITE_MPEG_REG(HHI_AUD_PLL_CNTL3, 0x9649a941);
+	// select Audio PLL as MCLK source
+	//WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 9));
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 9, 3);
+	//WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 25-1, 0, 8);
+
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 13-1, 0, 8);
+#endif
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+  WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+#endif
+
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+    // Put the PLL to sleep
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) | (1 << 15));//found
+
+//#ifdef CONFIG_SND_AML_M3
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
+	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+#endif
+    // Bring out of reset but keep bypassed to allow to stablize
+    //Wr( HHI_AUD_PLL_CNTL, (1 << 15) | (0 << 14) | (hiu_reg & 0x3FFF) );
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, (1 << 15) | (audio_clock_config[index][0] & 0x7FFF) );//found
+    // Set the XD value
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, (READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(0xff << 0)) | audio_clock_config[index][1]);//found
+    // delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+    // Bring the PLL out of sleep
+    WRITE_MPEG_REG( HHI_AUD_PLL_CNTL, READ_MPEG_REG(HHI_AUD_PLL_CNTL) & ~(1 << 15));//found
+
+    // gate the clock on
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));//found
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON3
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));// gate audac_clkpi
+#endif
+#else // endif CONFIG_ARCH_MESON6
+    WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);//set codec adc ratio---lrclk
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk
+
+	// Select Multi-Phase PLL2 as clock source
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 3);
+
+	// Configure Multi-Phase PLL2
+	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
+	// Set the XD value
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV
+	//Audio DAC Clock enable
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
+/* ADC clock  configuration */
+// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 8, 1);
+
+    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 3, 9, 2);
+
+    // Set pll over mclk ratio
+    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
+#if OVERCLOCK == 0
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 0, 8);
+#else
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)*2-1, 0, 8);
+#endif
+
+    // Set mclk over sclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
+
+    // Set sclk over lrclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12);
+
+    // Enable sclk
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
+    // Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 8, 1);
+#endif
+
+#endif // endif CONFIG_ARCH_MESON6
+    // delay 2uS
+	//udelay(2);
+	for (i = 0; i < 200000; i++) ;
+
+    } else if (fs_config == AUDIO_CLK_384FS) {
+    }
+}
+
+// iec958 and i2s clock are separated after M6TV. Use PLL2 for i2s DAC & ADC clock
+void audio_set_i2s_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+	int index=0;
+	switch(freq)
+	{
+		case AUDIO_CLK_FREQ_192:
+			index=4;
+			break;
+		case AUDIO_CLK_FREQ_96:
+			index=3;
+			break;
+		case AUDIO_CLK_FREQ_48:
+			index=2;
+			break;
+		case AUDIO_CLK_FREQ_441:
+			index=1;
+			break;
+		case AUDIO_CLK_FREQ_32:
+			index=0;
+			break;
+		case AUDIO_CLK_FREQ_8:
+			index = 5;
+			break;
+		case AUDIO_CLK_FREQ_11:
+			index = 6;
+			break;
+		case AUDIO_CLK_FREQ_12:
+			index = 7;
+			break;
+		case AUDIO_CLK_FREQ_16:
+			index = 8;
+			break;
+		case AUDIO_CLK_FREQ_22:
+			index = 9;
+			break;
+		case AUDIO_CLK_FREQ_24:
+			index = 10;
+			break;
+		default:
+			index=0;
+			break;
+	};
+
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+	WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	
+	//Set filter register
+	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+
+	/*--- DAC clock  configuration--- */
+	// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL, 3, 9, 2);
+
+	// Configure Multi-Phase PLL2
+	WRITE_MPEG_REG(HHI_MPLL_CNTL9, audio_clock_config[index][0]);
+	// Set the XD value
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+
+	WRITE_MPEG_REG_BITS(AIU_CODEC_DAC_LRCLK_CTRL, 64-1, 0, 12);//set codec dac ratio---lrclk--64fs
+	
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+
+	//Audio DAC Clock enable
+	WRITE_MPEG_REG(HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) |(1<<23));
+	
+	/* ---ADC clock  configuration--- */
+	// Disable mclk
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 0, 8, 1);
+
+    // Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 3, 9, 2);
+
+    // Set pll over mclk ratio
+    //we want 256fs ADC MLCK,so for over clock mode,divide more 2 than I2S  DAC CLOCK
+#if OVERCLOCK == 0
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, audio_clock_config[index][1], 0, 8);
+#else
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, (audio_clock_config[index][1]+1)*2-1, 0, 8);
+#endif
+
+    // Set mclk over sclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 4-1, 8, 6);
+
+    // Set sclk over lrclk ratio
+    WRITE_MPEG_REG_BITS(AIU_CODEC_ADC_LRCLK_CTRL, 64-1, 0, 12); //set codec adc ratio---lrclk--64fs
+
+    // Enable sclk
+    WRITE_MPEG_REG_BITS(AIU_CLK_CTRL_MORE, 1, 14, 1);
+    // Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL, 1, 8, 1);
+
+    // delay 2uS
+	//udelay(2);
+	for (i = 0; i < 200000; i++) ;
+}
+
+// iec958 and i2s clock are separated after M6TV. Use PLL1 for iec958 clock
+void audio_set_958_clk(unsigned freq, unsigned fs_config)
+{
+    int i;
+    int xtal = 0;
+
+    int (*audio_clock_config)[2];
+
+	int index=0;
+	switch(freq)
+	{
+		case AUDIO_CLK_FREQ_192:
+			index=4;
+			break;
+		case AUDIO_CLK_FREQ_96:
+			index=3;
+			break;
+		case AUDIO_CLK_FREQ_48:
+			index=2;
+			break;
+		case AUDIO_CLK_FREQ_441:
+			index=1;
+			break;
+		case AUDIO_CLK_FREQ_32:
+			index=0;
+			break;
+		case AUDIO_CLK_FREQ_8:
+			index = 5;
+			break;
+		case AUDIO_CLK_FREQ_11:
+			index = 6;
+			break;
+		case AUDIO_CLK_FREQ_12:
+			index = 7;
+			break;
+		case AUDIO_CLK_FREQ_16:
+			index = 8;
+			break;
+		case AUDIO_CLK_FREQ_22:
+			index = 9;
+			break;
+		case AUDIO_CLK_FREQ_24:
+			index = 10;
+			break;
+		default:
+			index=0;
+			break;
+	};
+
+	if (fs_config == AUDIO_CLK_256FS) {
+		// divide 256
+		xtal = 0;
+	}
+	else if (fs_config == AUDIO_CLK_384FS) {
+	    // divide 384
+		xtal = 1;
+	}
+	audio_clock_config = audio_clock_config_table[xtal];
+
+    // gate the clock off
+    WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) & ~(1 << 8));
+	//WRITE_MPEG_REG(AIU_CLK_CTRL_MORE, 0);
+	
+	//Set filter register
+	//WRITE_MPEG_REG(HHI_MPLL_CNTL3, 0x26e1250);
+
+	/*--- IEC958 clock  configuration, use MPLL1--- */
+	// Disable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 0, 24, 1);
+	//IEC958_USE_CNTL
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 1, 27, 1);
+	// Select clk source, 0=ddr_pll; 1=Multi-Phase PLL0; 2=Multi-Phase PLL1; 3=Multi-Phase PLL2.
+	WRITE_MPEG_REG_BITS( HHI_AUD_CLK_CNTL2, 2, 25, 2);
+
+	// Configure Multi-Phase PLL1
+	WRITE_MPEG_REG(HHI_MPLL_CNTL8, audio_clock_config[index][0]);
+	// Set the XD value
+#if IEC958_OVERCLOCK	==1
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, (audio_clock_config[index][1]+1)/2 -1, 16, 8);
+#else
+	WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, audio_clock_config[index][1], 16, 8);
+#endif
+
+	// delay 5uS
+	//udelay(5);
+	for (i = 0; i < 500000; i++) ;
+	// gate the clock on
+	WRITE_MPEG_REG( HHI_AUD_CLK_CNTL, READ_MPEG_REG(HHI_AUD_CLK_CNTL) | (1 << 8));
+	// Enable mclk
+    WRITE_MPEG_REG_BITS(HHI_AUD_CLK_CNTL2, 1, 24, 1);
+}
+
+//extern void audio_out_enabled(int flag);
+void audio_hw_958_raw(void);
+
+void audio_enable_ouput(int flag)
+{
+    if (flag) {
+        WRITE_MPEG_REG(AIU_RST_SOFT, 0x05);
+        READ_MPEG_REG(AIU_I2S_SYNC);
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
+
+        if (0/*ENABLE_IEC958*/) {
+            if(IEC958_MODE == AIU_958_MODE_RAW)
+            {
+              //audio_hw_958_raw();
+            }
+            //else
+            {
+              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
+              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+              //WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 1);
+
+              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+            }
+        }
+        // Maybe cause POP noise
+        // audio_i2s_unmute();
+    } else {
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
+
+        if (0/*ENABLE_IEC958*/) {
+            WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);
+        }
+        // Maybe cause POP noise
+        // audio_i2s_mute();
+    }
+    //audio_out_enabled(flag);
+}
+
+int if_audio_out_enable()
+{
+	return READ_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 1, 2);
+}
+
+unsigned int read_i2s_rd_ptr(void)
+{
+    unsigned int val;
+    val = READ_MPEG_REG(AIU_MEM_I2S_RD_PTR);
+    return val;
+}
+unsigned int read_iec958_rd_ptr(void)
+{
+    unsigned int val;
+    val = READ_MPEG_REG(AIU_MEM_IEC958_RD_PTR);
+    return val;
+}
+void audio_i2s_unmute(void)
+{
+    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0, 8, 8);
+    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 0, 3, 2);
+}
+
+void audio_i2s_mute(void)
+{
+    WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, 0xff, 8, 8);
+    WRITE_MPEG_REG_BITS(AIU_958_CTRL, 3, 3, 2);
+}
+
+void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
+{
+	WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL,0);
+    WRITE_MPEG_REG(AIU_RST_SOFT,
+                   (slow_domain << 3) | (fast_domain << 2));
+}
+
+void audio_hw_958_raw()
+{
+    if (ENABLE_IEC958) {
+         WRITE_MPEG_REG(AIU_958_MISC, 1);
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
+         WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
+    }
+
+    WRITE_MPEG_REG(AIU_958_BPF, IEC958_bpf);
+    WRITE_MPEG_REG(AIU_958_BRST, IEC958_brst);
+    WRITE_MPEG_REG(AIU_958_LENGTH, IEC958_length);
+    WRITE_MPEG_REG(AIU_958_PADDSIZE, IEC958_padsize);
+    WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 2, 2);// disable int
+
+    if(IEC958_mode == 1){ // search in byte
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 7, 4, 3);
+    }else if(IEC958_mode == 2) { // search in word
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 5, 4, 3);
+    }else{
+      WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 0, 4, 3);
+    }
+    WRITE_MPEG_REG(AIU_958_CHSTAT_L0, IEC958_chstat0_l);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_L1, IEC958_chstat1_l);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_R0, IEC958_chstat0_r);
+    WRITE_MPEG_REG(AIU_958_CHSTAT_R1, IEC958_chstat1_r);
+
+    WRITE_MPEG_REG(AIU_958_SYNWORD1, IEC958_syncword1);
+    WRITE_MPEG_REG(AIU_958_SYNWORD2, IEC958_syncword2);
+    WRITE_MPEG_REG(AIU_958_SYNWORD3, IEC958_syncword3);
+    WRITE_MPEG_REG(AIU_958_SYNWORD1_MASK, IEC958_syncword1_mask);
+    WRITE_MPEG_REG(AIU_958_SYNWORD2_MASK, IEC958_syncword2_mask);
+    WRITE_MPEG_REG(AIU_958_SYNWORD3_MASK, IEC958_syncword3_mask);
+
+    printk("%s: %d\n", __func__, __LINE__);
+    printk("\tBPF: %x\n", IEC958_bpf);
+    printk("\tBRST: %x\n", IEC958_brst);
+    printk("\tLENGTH: %x\n", IEC958_length);
+    printk("\tPADDSIZE: %x\n", IEC958_length);
+    printk("\tsyncword: %x, %x, %x\n\n", IEC958_syncword1, IEC958_syncword2, IEC958_syncword3);
+
+}
+
+void set_958_channel_status(_aiu_958_channel_status_t * set)
+{
+    if (set) {
+		WRITE_MPEG_REG(AIU_958_CHSTAT_L0, set->chstat0_l);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_L1, set->chstat1_l);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_R0, set->chstat0_r);
+		WRITE_MPEG_REG(AIU_958_CHSTAT_R1, set->chstat1_r);
+    }
+}
+
+static void audio_hw_set_958_pcm24(_aiu_958_raw_setting_t * set)
+{
+    WRITE_MPEG_REG(AIU_958_BPF, 0x80); /* in pcm mode, set bpf to 128 */
+    set_958_channel_status(set->chan_stat);
+}
+
+void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set)
+{
+    if(mode == AIU_958_MODE_PCM_RAW){
+    	mode = AIU_958_MODE_PCM16; //use 958 raw pcm mode
+       WRITE_MPEG_REG(AIU_958_VALID_CTRL,3);//enable 958 invalid bit	
+    } 
+    else
+	WRITE_MPEG_REG(AIU_958_VALID_CTRL,0);
+    if (mode == AIU_958_MODE_RAW) {
+
+        audio_hw_958_raw();
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 1);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 8, 1);  // raw
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 8bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 3, 3); // endian
+        }
+
+        printk("IEC958 RAW\n");
+    }else if(mode == AIU_958_MODE_PCM32){
+        audio_hw_set_958_pcm24(set);
+        if(ENABLE_IEC958){
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+        }
+        printk("IEC958 PCM32 \n");
+    }else if (mode == AIU_958_MODE_PCM24) {
+        audio_hw_set_958_pcm24(set);
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2020 | (1 << 7));
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+
+        }
+        printk("IEC958 24bit\n");
+    } else if (mode == AIU_958_MODE_PCM16) {
+        audio_hw_set_958_pcm24(set);
+        if (ENABLE_IEC958) {
+            WRITE_MPEG_REG(AIU_958_MISC, 0x2042);
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 8, 1);  // pcm
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 1, 7, 1);  // 16bit
+            WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 3, 3); // endian
+
+        }
+        printk("IEC958 16bit\n");
+    }
+
+    audio_hw_958_reset(0, 1);
+
+    WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 1);
+}
+void audio_out_i2s_enable(unsigned flag)
+{
+    if (flag) {
+        WRITE_MPEG_REG(AIU_RST_SOFT, 0x05);
+        READ_MPEG_REG(AIU_I2S_SYNC);
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 3, 1, 2);
+        // Maybe cause POP noise
+        // audio_i2s_unmute();
+    } else {
+        WRITE_MPEG_REG_BITS(AIU_MEM_I2S_CONTROL, 0, 1, 2);
+
+        // Maybe cause POP noise
+        // audio_i2s_mute();
+    }
+    //audio_out_enabled(flag);
+}
+void audio_hw_958_enable(unsigned flag)
+{
+    if (ENABLE_IEC958)
+    {
+    		if(flag){
+	              WRITE_MPEG_REG(AIU_958_FORCE_LEFT, 0);
+	              WRITE_MPEG_REG_BITS(AIU_958_DCU_FF_CTRL, 1, 0, 1);
+	              WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 3, 1, 2);
+    		}
+		else{
+	             WRITE_MPEG_REG(AIU_958_DCU_FF_CTRL, 0);
+	             WRITE_MPEG_REG_BITS(AIU_MEM_IEC958_CONTROL, 0, 1, 2);			
+		}	
+    }
+}
+
+unsigned int read_i2s_mute_swap_reg(void)
+{
+	unsigned int val;
+    	val = READ_MPEG_REG(AIU_I2S_MUTE_SWAP);
+    	return val;
+}
+
+void audio_i2s_swap_left_right(unsigned int flag)
+{
+	if (ENABLE_IEC958)
+	{
+		WRITE_MPEG_REG_BITS(AIU_958_CTRL, flag, 1, 2);
+	}
+	WRITE_MPEG_REG_BITS(AIU_I2S_MUTE_SWAP, flag, 0, 2);
+}
+unsigned int audio_hdmi_init_ready()
+{
+	return 	READ_MPEG_REG_BITS(AIU_HDMI_CLK_DATA_CTRL, 0, 2);
+}
+
+#ifdef CONFIG_ARCH_MESON8
+
+/* power gate control for iec958 audio out */
+unsigned audio_spdifout_pg_enable(unsigned char enable)
+{
+	if(enable){
+			WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);					
+			AUDIO_CLK_GATE_ON(AIU_IEC958);
+			AUDIO_CLK_GATE_ON(AIU_ICE958_AMCLK);
+	}
+	else{
+			AUDIO_CLK_GATE_OFF(AIU_IEC958);
+			AUDIO_CLK_GATE_OFF(AIU_ICE958_AMCLK);	
+			WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);								
+	}
+	return 0;
+}
+/*
+	power gate control for normal aiu  domain including i2s in/out
+	TODO: move i2s out /adc related gate to i2s cpu dai driver 
+*/
+unsigned audio_aiu_pg_enable(unsigned char enable)
+{
+	if(enable){
+		AUDIO_CLK_GATE_ON(AIU_AMCLK_MEASURE);
+		AUDIO_CLK_GATE_ON(AIU_AIFIFO2);
+		AUDIO_CLK_GATE_ON(AIU_AUD_MIXER);
+		AUDIO_CLK_GATE_ON(AIU_MIXER_REG);
+		AUDIO_CLK_GATE_ON(AIU_AI_TOP_GLUE);
+		AUDIO_CLK_GATE_ON(AIU_AOCLK);   		
+		AUDIO_CLK_GATE_ON(AIU_I2S_OUT);
+		AUDIO_CLK_GATE_ON(AIU_ADC);		
+        AUDIO_CLK_GATE_ON(AUD_IN);
+        AUDIO_CLK_GATE_ON(AIU_IEC958);
+        AUDIO_CLK_GATE_ON(AIU_PCLK);
+        AUDIO_CLK_GATE_ON(AIU_ICE958_AMCLK);
+        AUDIO_CLK_GATE_ON(AIU_TOP_LEVEL);
+	}
+	else{
+		AUDIO_CLK_GATE_OFF(AIU_AMCLK_MEASURE);
+		AUDIO_CLK_GATE_OFF(AIU_AIFIFO2);
+		AUDIO_CLK_GATE_OFF(AIU_AUD_MIXER);
+		AUDIO_CLK_GATE_OFF(AIU_MIXER_REG);
+		AUDIO_CLK_GATE_OFF(AIU_AI_TOP_GLUE);
+		AUDIO_CLK_GATE_OFF(AIU_AOCLK);   		
+		AUDIO_CLK_GATE_OFF(AIU_I2S_OUT);
+		AUDIO_CLK_GATE_OFF(AIU_ADC);			
+        AUDIO_CLK_GATE_OFF(AUD_IN);
+        AUDIO_CLK_GATE_OFF(AIU_IEC958);
+        AUDIO_CLK_GATE_OFF(AIU_PCLK);
+        AUDIO_CLK_GATE_OFF(AIU_ICE958_AMCLK);   
+        AUDIO_CLK_GATE_OFF(AIU_TOP_LEVEL);
+	}
+}
+#endif
diff --git a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
new file mode 100644
index 000000000000..587b9c7f75a3
--- /dev/null
+++ b/sound/soc/aml/m8/aml_audio_hw.h
@@ -0,0 +1,158 @@
+#ifndef __AML_AUDIO_HW_H__
+#define __AML_AUDIO_HW_H__
+#include <mach/power_gate.h>
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
+#define AUDIO_CLK_GATE_ON(a)
+#define AUDIO_CLK_GATE_OFF(a)
+#else
+#define AUDIO_CLK_GATE_ON(a) CLK_GATE_ON(a)
+#define AUDIO_CLK_GATE_OFF(a) CLK_GATE_OFF(a)
+#endif
+
+typedef struct {
+    unsigned short pll;
+    unsigned short mux;
+    unsigned short devisor;
+} _aiu_clk_setting_t;
+
+typedef struct {
+    unsigned short chstat0_l;
+    unsigned short chstat1_l;
+    unsigned short chstat0_r;
+    unsigned short chstat1_r;
+} _aiu_958_channel_status_t;
+
+typedef struct {
+    /* audio clock */
+    unsigned short clock;
+    /* analog output */
+    unsigned short i2s_mode;
+    unsigned short i2s_dac_mode;
+    unsigned short i2s_preemphsis;
+    /* digital output */
+    unsigned short i958_buf_start_addr;
+    unsigned short i958_buf_blksize;
+    unsigned short i958_int_flag;
+    unsigned short i958_mode;
+    unsigned short i958_sync_mode;
+    unsigned short i958_preemphsis;
+    unsigned short i958_copyright;
+    unsigned short bpf;
+    unsigned short brst;
+    unsigned short length;
+    unsigned short paddsize;
+    _aiu_958_channel_status_t chan_status;
+} audio_output_config_t;
+
+typedef struct {
+    unsigned short int_flag;
+    unsigned short bpf;
+    unsigned short brst;
+    unsigned short length;
+    unsigned short paddsize;
+    _aiu_958_channel_status_t *chan_stat;
+} _aiu_958_raw_setting_t;
+
+enum {
+	I2SIN_MASTER_MODE = 0,
+	I2SIN_SLAVE_MODE  =   1<<0,
+	SPDIFIN_MODE   = 1<<1,
+};
+enum {
+	AML_AUDIO_NA = 0,	
+	AML_AUDIO_SPDIFIN = 1<<0,
+	AML_AUDIO_SPDIFOUT = 1<<1,
+	AML_AUDIO_I2SIN = 1<<2,
+	AML_AUDIO_I2SOUT = 1<<3,
+	AML_AUDIO_PCMIN = 1<<4,
+	AML_AUDIO_PCMOUT = 1<<5,				
+};
+#define AUDIO_CLK_256FS             0
+#define AUDIO_CLK_384FS             1
+
+#define AUDIO_CLK_FREQ_192  0
+#define AUDIO_CLK_FREQ_1764 1
+#define AUDIO_CLK_FREQ_96   2
+#define AUDIO_CLK_FREQ_882  3
+#define AUDIO_CLK_FREQ_48   4
+#define AUDIO_CLK_FREQ_441  5
+#define AUDIO_CLK_FREQ_32   6
+
+#define AUDIO_CLK_FREQ_8		7
+#define AUDIO_CLK_FREQ_11		8
+#define AUDIO_CLK_FREQ_12		9
+#define AUDIO_CLK_FREQ_16		10
+#define AUDIO_CLK_FREQ_22		11
+#define AUDIO_CLK_FREQ_24		12
+
+
+#define AIU_958_MODE_RAW    0
+#define AIU_958_MODE_PCM16  1
+#define AIU_958_MODE_PCM24  2
+#define AIU_958_MODE_PCM32  3
+#define AIU_958_MODE_PCM_RAW  4
+
+#define AIU_I2S_MODE_PCM16   0
+#define AIU_I2S_MODE_PCM24   2
+#define AIU_I2S_MODE_PCM32   3
+
+#define AUDIO_ALGOUT_DAC_FORMAT_DSP             0
+#define AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY    1
+
+extern unsigned ENABLE_IEC958;
+extern unsigned IEC958_MODE;
+extern unsigned I2S_MODE;
+
+void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
+void audio_set_958outbuf(u32 addr, u32 size, int flag);
+void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode);
+void audio_in_spdif_set_buf(u32 addr, u32 size);
+void audio_in_i2s_enable(int flag);
+void audio_in_spdif_enable(int flag);
+unsigned int audio_in_i2s_rd_ptr(void);
+unsigned int audio_in_i2s_wr_ptr(void);
+unsigned int audio_in_spdif_wr_ptr(void);
+void audio_set_i2s_mode(u32 mode);
+void audio_set_clk(unsigned freq, unsigned fs_config);
+void audio_set_i2s_clk(unsigned freq, unsigned fs_config);
+void audio_set_958_clk(unsigned freq, unsigned fs_config);
+void audio_enable_ouput(int flag);
+unsigned int read_i2s_rd_ptr(void);
+void audio_i2s_unmute(void);
+void audio_i2s_mute(void);
+void audio_util_set_dac_format(unsigned format);
+void audio_util_set_dac_i2s_format(unsigned format);
+void audio_util_set_dac_958_format(unsigned format);
+void audio_set_958_mode(unsigned mode, _aiu_958_raw_setting_t * set);
+unsigned int read_i2s_mute_swap_reg(void);
+void audio_i2s_swap_left_right(unsigned int flag);
+int if_audio_out_enable(void);
+int if_audio_in_i2s_enable(void);
+int if_audio_in_spdif_enable(void);
+void audio_out_i2s_enable(unsigned flag);
+void audio_hw_958_enable(unsigned flag);
+void audio_out_enabled(int flag);
+void audio_util_set_dac_format(unsigned format);
+unsigned int audio_hdmi_init_ready(void);
+unsigned int read_iec958_rd_ptr(void);
+void audio_in_spdif_enable(int flag);
+unsigned audio_spdifout_pg_enable(unsigned char enable);
+unsigned audio_aiu_pg_enable(unsigned char enable);
+
+#include "mach/cpu.h"
+
+/*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+#define OVERCLOCK 0
+#define IEC958_OVERCLOCK 1
+#else
+#define OVERCLOCK 1
+#endif
+
+#if (OVERCLOCK == 1)
+#define MCLKFS_RATIO 512
+#else
+#define MCLKFS_RATIO 256
+#endif
+
+#endif
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
new file mode 100644
index 000000000000..adfa4bda6574
--- /dev/null
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
@@ -0,0 +1,314 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <mach/am_regs.h>
+#include <linux/clk.h>
+
+#include "aml_audio_hw_pcm2bt.h"
+
+//#define PCM_DEBUG
+
+#ifdef PCM_DEBUG
+#define pcm_debug           pr_info
+#else
+#define pcm_debug(fmt, ...) \
+        do {} while(0)
+#endif
+
+static unsigned int pcmin_buffer_addr = 0;
+static unsigned int pcmin_buffer_size = 0;
+
+static unsigned int pcmout_buffer_addr = 0;
+static unsigned int pcmout_buffer_size = 0;
+
+static void pcm_in_register_show(void)
+{
+    pcm_debug("PCMIN registers show:\n");
+    pcm_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START, READ_MPEG_REG(AUDIN_FIFO1_START));
+    pcm_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END, READ_MPEG_REG(AUDIN_FIFO1_END));
+    pcm_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR, READ_MPEG_REG(AUDIN_FIFO1_PTR));
+    pcm_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR, READ_MPEG_REG(AUDIN_FIFO1_RDPTR));
+    pcm_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL, READ_MPEG_REG(AUDIN_FIFO1_CTRL));
+    pcm_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1, READ_MPEG_REG(AUDIN_FIFO1_CTRL1));
+    pcm_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0, READ_MPEG_REG(PCMIN_CTRL0));
+    pcm_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1, READ_MPEG_REG(PCMIN_CTRL1));
+}
+
+void pcm_in_enable(int flag)
+{
+    /* reset fifo */
+RESET_FIFO:    
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 1, 1, 1);
+    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 0);
+    if (READ_MPEG_REG(AUDIN_FIFO1_PTR) != READ_MPEG_REG(AUDIN_FIFO1_START))
+        goto RESET_FIFO;
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 1, 1);
+
+    /* reset pcmin */
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 30, 1);
+
+    /* disable fifo */
+    WRITE_MPEG_REG_BITS(AUDIN_FIFO1_CTRL, 0, 0, 1);
+
+    /* disable pcmin */
+    WRITE_MPEG_REG_BITS(PCMIN_CTRL0, 0, 31, 1);
+
+    if (flag) {
+        /* set buffer start ptr end */
+    	WRITE_MPEG_REG(AUDIN_FIFO1_START, pcmin_buffer_addr);
+    	WRITE_MPEG_REG(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+    	WRITE_MPEG_REG(AUDIN_FIFO1_END, pcmin_buffer_addr + pcmin_buffer_size - 8);
+
+        /* fifo control */
+        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL, (1 << 15) |    // urgent request
+                                         (1 << 11) |    // channel
+                                         (6 << 8) |     // endian
+                                         //(0 << 8) |     // endian
+                                         (2 << 3) |     // PCMIN input selection
+                                         (1 << 2) |     // load address
+                                         (0 << 1) |     // reset fifo
+                                         (1 << 0)       // fifo enable
+                        );
+
+        /* fifo control1 */
+        WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1, (0 << 4) |    // data destination DDR
+                                          (1 << 2) |    // 16bits
+                                          (0 << 0)      // data position
+                        );
+
+        /* pcmin control1 */
+        WRITE_MPEG_REG(PCMIN_CTRL1, (0 << 29) |         // external chip
+                                    (0 << 28) |         // external chip
+                                    (1 << 27) |         // using negedge of PCM clock to latch the input data
+                                    (15 << 21) |        // slot bit msb 16 clocks per slot
+                                    (15 << 16) |        // data msb 16bits data
+                                    (1 << 0)            // slot valid
+                        );
+
+        /* pcmin control0 */
+        WRITE_MPEG_REG(PCMIN_CTRL0, (1 << 31) |         // pcmin enable
+                                    (1 << 29) |         // sync on clock posedge
+                                    (0 << 16) |         // FS SKEW
+                                    (0 << 4) |          // waithing 1 system clock cycles then sample the PCMIN singals
+                                    (0 << 3) |          // use clock counter to do the sample
+                                    (0 << 2) |          // fs not inverted. H = left, L = right
+                                    (1 << 1) |          // msb first
+                                    (1 << 0)            // left justified
+                        );
+    }
+
+    pcm_debug("PCMIN %s\n", flag ? "enable" : "disable");
+    pcm_in_register_show();
+}
+
+void pcm_in_set_buf(unsigned int addr, unsigned int size)
+{
+    pcmin_buffer_addr = addr;
+    pcmin_buffer_size = size;
+
+    pcm_debug("PCMIN buffer start: 0x%08x size: 0x%08x\n", pcmin_buffer_addr, pcmin_buffer_size);
+}
+
+int pcm_in_is_enable(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMIN_CTRL0, 31, 1) & 0x01);
+
+    return value;
+}
+
+unsigned int pcm_in_rd_ptr(void)
+{
+    unsigned int value = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
+
+    return value;
+}
+
+unsigned int pcm_in_set_rd_ptr(unsigned int value)
+{
+    unsigned int old = READ_MPEG_REG(AUDIN_FIFO1_RDPTR);
+    WRITE_MPEG_REG(AUDIN_FIFO1_RDPTR, value);
+    pcm_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
+
+    return old;
+}
+
+unsigned int pcm_in_wr_ptr(void)
+{
+	unsigned int writing = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+    unsigned int written = 0;
+    unsigned int value = 0;
+
+    WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
+	written = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+    pcm_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
+
+    //value = written;
+    value = written & (~0x07);
+    return value;
+}
+
+unsigned int pcm_in_fifo_int(void)
+{
+    unsigned int value = 0;
+    value = READ_MPEG_REG(AUDIN_FIFO_INT);
+    pcm_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
+
+    return value;
+}
+
+static void pcm_out_register_show(void)
+{
+    pcm_debug("PCMOUT registers show:\n");
+    pcm_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA, READ_MPEG_REG(AUDOUT_BUF0_STA));
+    pcm_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA, READ_MPEG_REG(AUDOUT_BUF0_EDA));
+    pcm_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR, READ_MPEG_REG(AUDOUT_BUF0_WPTR));
+    pcm_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR, READ_MPEG_REG(AUDOUT_FIFO_RPTR));
+    pcm_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL, READ_MPEG_REG(AUDOUT_CTRL));
+    pcm_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1, READ_MPEG_REG(AUDOUT_CTRL1));
+    pcm_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0, READ_MPEG_REG(PCMOUT_CTRL0));
+    pcm_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1, READ_MPEG_REG(PCMOUT_CTRL1));
+    pcm_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2, READ_MPEG_REG(PCMOUT_CTRL2));
+    pcm_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3, READ_MPEG_REG(PCMOUT_CTRL3));
+}
+
+void pcm_out_enable(int flag)
+{
+    /* reset fifo */
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 30, 1);
+
+    /* reset pcmout */
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 1, 30, 1);
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 30, 1);
+
+    /* disable fifo */
+    WRITE_MPEG_REG_BITS(AUDOUT_CTRL, 0, 31, 1);
+
+    /* disable pcmout */
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL0, 0, 31, 1);
+
+    if (flag) {
+        /* set buffer start ptr end */
+    	WRITE_MPEG_REG(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+    	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+    	WRITE_MPEG_REG(AUDOUT_BUF0_EDA, pcmout_buffer_addr + pcmout_buffer_size - 8);
+
+        /* fifo control */
+        WRITE_MPEG_REG(AUDOUT_CTRL, (0 << 31) |     // fifo enable
+                                    (0 << 30) |     // soft reset
+                                    (1 << 29) |     // load address
+                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
+                                    (52 << 15) |    // data request size
+                                    (64 << 8) |     // buffer level to keep
+                                    (0 << 7) |      // buffer level control
+                                    (1 << 6) |      // DMA mode
+                                    (1 << 5) |      // circular buffer
+                                    (0 << 4) |      // use register set 0 always
+                                    (1 << 3) |       // urgent request
+                                    (6 << 0)         //endian
+                        );
+
+        WRITE_MPEG_REG(AUDOUT_CTRL, (1 << 31) |     // fifo enable
+                                    (0 << 30) |     // soft reset
+                                    (0 << 29) |     // load address
+                                    (0 << 22) |     // use cbus AUDOUT BUFFER0 write pointer as the AUDOUT FIFO write pointer
+                                    (52 << 15) |    // data request size
+                                    (64 << 8) |     // buffer level to keep
+                                    (0 << 7) |      // buffer level control
+                                    (1 << 6) |      // DMA mode
+                                    (1 << 5) |      // circular buffer
+                                    (0 << 4) |      // use register set 0 always
+                                    (1 << 3) |       // urgent request
+                                    (6 << 0)         //endian
+                                    
+                        );
+        /* pcmout control3 */
+        WRITE_MPEG_REG(PCMOUT_CTRL3, 0);            // mute constant
+
+        /* pcmout control2 */
+        WRITE_MPEG_REG(PCMOUT_CTRL2,(0 << 29) |     // underrun use mute constant
+                                    (0 << 22) |     // 1 channel per frame
+                                    (15 << 16) |    // 16 bits per slot
+                                    (1 << 0)        // enable 1 slot
+                        );
+
+        /* pcmout control1 */
+        WRITE_MPEG_REG(PCMOUT_CTRL1,(1 << 30) |     // data byte numbe n - 1?
+                                    (0 << 28) |     // use posedge of PCM clock to output data
+                                    (1 << 27)       // use negedge of pcm clock to check the fs
+                        );
+
+        /* pcmout control0 */
+        WRITE_MPEG_REG(PCMOUT_CTRL0,(1 << 31) |     // enable
+                                    (0 << 29) |     // slave
+                                    (1 << 28) |     // sync on clock rising edge
+                                    (0 << 27) |     // data sample mode
+                                    (1 << 15) |     // sync on 4 system clock later ?
+                                    (1 << 14) |     // msb first
+                                    (1 << 13) |     // left justified
+                                    (0 << 12) |     // data position
+                                    (3 << 6) |      // sync fs with the slot bit counter.
+                                    (0 << 0)        // sync fs with frame slot counter.
+                        );
+    }
+
+    pcm_debug("PCMOUT %s\n", flag ? "enable" : "disable");
+    pcm_out_register_show();
+}
+
+void pcm_out_mute(int flag)
+{
+    int value = flag ? 1: 0;
+    WRITE_MPEG_REG_BITS(PCMOUT_CTRL2, value, 31, 1);
+}
+
+void pcm_out_set_buf(unsigned int addr, unsigned int size)
+{
+    pcmout_buffer_addr = addr;
+    pcmout_buffer_size = size;
+
+    pcm_debug("PCMOUT buffer addr: 0x%08x end: 0x%08x\n", pcmout_buffer_addr, pcmout_buffer_size);
+}
+
+int pcm_out_is_enable(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL0, 31, 1) & 0x01);
+
+    return value;
+}
+
+int  pcm_out_is_mute(void)
+{
+    int value = (READ_MPEG_REG_BITS(PCMOUT_CTRL2, 31, 1) & 0x01);
+
+    return value;
+}
+
+unsigned int pcm_out_rd_ptr(void)
+{
+    unsigned int value = READ_MPEG_REG(AUDOUT_FIFO_RPTR);
+    pcm_debug("PCMOUT read pointer: 0x%08x\n", value);
+
+    return value;
+}
+
+unsigned int pcm_out_wr_ptr(void)
+{
+    unsigned int value = 0;
+ 	value = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
+    pcm_debug("PCMOUT write pointer: 0x%08x\n", value);
+    return value;
+}
+
+unsigned int pcm_out_set_wr_ptr(unsigned int value)
+{
+    unsigned int old = READ_MPEG_REG(AUDOUT_BUF0_WPTR);
+ 	WRITE_MPEG_REG(AUDOUT_BUF0_WPTR, value);
+    pcm_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
+
+    return old;
+}
+
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.h b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.h
new file mode 100644
index 000000000000..4afc8d6a6425
--- /dev/null
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.h
@@ -0,0 +1,21 @@
+#ifndef __AML_PCM_HW_H__
+#define __AML_PCM_HW_H__
+
+void pcm_in_enable(int flag);
+void pcm_in_set_buf(unsigned int addr, unsigned int size);
+int  pcm_in_is_enable(void);
+unsigned int pcm_in_rd_ptr(void);
+unsigned int pcm_in_wr_ptr(void);
+unsigned int pcm_in_set_rd_ptr(unsigned int value);
+unsigned int pcm_in_fifo_int(void);
+
+void pcm_out_enable(int flag);
+void pcm_out_mute(int flag);
+void pcm_out_set_buf(unsigned int addr, unsigned int size);
+int  pcm_out_is_enable(void);
+int  pcm_out_is_mute(void);
+unsigned int pcm_out_rd_ptr(void);
+unsigned int pcm_out_wr_ptr(void);
+unsigned int pcm_out_set_wr_ptr(unsigned int value);
+
+#endif
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
new file mode 100644
index 000000000000..807102ddddd9
--- /dev/null
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -0,0 +1,1139 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/hrtimer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/amlogic/rt5631.h>
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include <linux/amlogic/amports/amaudio.h>
+
+#include <mach/mod_gate.h>
+
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+#define USE_HRTIMER 0
+#define HRTIMER_PERIOD (1000000000UL/1000)
+//#define DEBUG_ALSA_PLATFRORM
+
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s]" fmt,##args)
+#ifdef DEBUG_ALSA_PLATFRORM
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-i2s]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-i2s] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+
+
+unsigned int aml_i2s_playback_start_addr = 0;
+unsigned int aml_i2s_capture_start_addr  = 0;
+
+unsigned int aml_i2s_playback_end_addr = 0;
+unsigned int aml_i2s_capture_end_addr = 0;
+
+unsigned int aml_i2s_capture_start_phy = 0;
+unsigned int aml_i2s_capture_buf_size = 0;
+unsigned int aml_i2s_playback_phy_start_addr = 0;
+unsigned int aml_i2s_capture_phy_start_addr  = 0;
+unsigned int aml_i2s_playback_phy_end_addr = 0;
+unsigned int aml_i2s_capture_phy_end_addr = 0;
+unsigned int aml_i2s_playback_off = 0;
+unsigned int aml_i2s_playback_enable = 1;
+
+unsigned int aml_iec958_playback_start_addr = 0;
+unsigned int aml_iec958_playback_start_phy = 0;
+unsigned int aml_iec958_playback_size = 0;  // in bytes
+
+
+static int audio_type_info = -1;
+static int audio_sr_info = -1;
+extern unsigned audioin_mode;
+
+static DEFINE_MUTEX(gate_mutex);
+static unsigned audio_gate_status = 0;
+
+EXPORT_SYMBOL(aml_i2s_playback_start_addr);
+EXPORT_SYMBOL(aml_i2s_capture_start_addr);
+EXPORT_SYMBOL(aml_i2s_playback_off);
+EXPORT_SYMBOL(aml_i2s_playback_enable);
+
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_i2s_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE,
+
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 128 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static const struct snd_pcm_hardware aml_i2s_capture = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+							SNDRV_PCM_INFO_MMAP |
+						 	SNDRV_PCM_INFO_MMAP_VALID |
+						  SNDRV_PCM_INFO_PAUSE,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 32 * 1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.fifo_size = 0,
+};
+
+static char snd_i2s_tmp[32*1024];
+
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+/*--------------------------------------------------------------------------*/
+/*--------------------------------------------------------------------------*\
+ * Helper functions
+\*--------------------------------------------------------------------------*/
+static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	ALSA_TRACE();
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+	size_t size = 0;
+	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		    size = aml_i2s_hardware.buffer_bytes_max;
+		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		    buf->dev.dev = pcm->card->dev;
+		    buf->private_data = NULL;
+            /* one size for i2s output, another for 958, and 128 for alignment */
+		    buf->area = dma_alloc_coherent(pcm->card->dev, size+4096,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-i2s %d:"
+		    "playback preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+        }else{
+
+		size = aml_i2s_capture.buffer_bytes_max;
+		buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		buf->dev.dev = pcm->card->dev;
+		buf->private_data = NULL;
+		buf->area = dma_alloc_coherent(pcm->card->dev, size*2,
+					  &buf->addr, GFP_KERNEL);
+		    printk("aml-i2s %d:"
+		    "capture preallocate_dma_buffer: area=%p, addr=%p, size=%d\n", stream,
+		    (void *) buf->area,
+		    (void *) buf->addr,
+		    size);
+	    }
+
+	    if (!buf->area)
+		    return -ENOMEM;
+    
+	    buf->bytes = size;
+	    return 0;
+
+}
+/*--------------------------------------------------------------------------*\
+ * ISR
+\*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*\
+ * i2s operations
+\*--------------------------------------------------------------------------*/
+static int aml_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+//	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	audio_stream_t *s = &prtd->s;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+	ALSA_PRINT("runtime dma_bytes %d,stream type \n",runtime->dma_bytes,substream->stream);
+	s->I2S_addr = runtime->dma_addr;
+
+    /*
+     * Both capture and playback need to reset the last ptr to the start address,
+       playback and capture use different address calculate, so we reset the different
+       start address to the last ptr
+   * */
+    if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+        /* s->last_ptr must initialized as dma buffer's start addr */
+        s->last_ptr = runtime->dma_addr;
+    }else{
+
+	s->last_ptr = 0;
+    }
+
+	return 0;
+}
+
+static int aml_i2s_hw_free(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	struct aml_i2s_dma_params *params = prtd->params;
+	if (params != NULL) {
+
+	}
+
+	return 0;
+}
+
+
+static int aml_i2s_prepare(struct snd_pcm_substream *substream)
+{
+	ALSA_TRACE();
+	return 0;
+}
+
+static int aml_i2s_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	ALSA_TRACE();
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct aml_runtime_data *prtd = rtd->private_data;
+	audio_stream_t *s = &prtd->s;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:		
+
+#if USE_HRTIMER == 0
+	  del_timer_sync(&prtd->timer);
+#endif      
+	  spin_lock(&s->lock);
+#if USE_HRTIMER == 0
+	  prtd->timer.expires = jiffies + 1;
+	  del_timer(&prtd->timer);
+	  add_timer(&prtd->timer);
+#endif
+
+	  s->active = 1;
+	  spin_unlock(&s->lock);
+	  break;		/* SNDRV_PCM_TRIGGER_START */
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		// TODO
+	    spin_lock(&s->lock);
+	    s->active = 0;
+	    spin_unlock(&s->lock);
+	    break;
+	default:
+		ret = -EINVAL;
+	}
+/*	if(clock_gating_status&clock_gating_playback){
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			aml_pcm_work.substream = substream;
+	}
+	else
+		aml_pcm_work.substream = substream;
+
+
+	if(clock_gating_status)
+	{
+		schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	}
+	*/
+	//schedule_work(&aml_pcm_work.aml_codec_workqueue);
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_i2s_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+
+	unsigned int addr, ptr;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		if(s->device_type == AML_AUDIO_I2SOUT)
+			ptr = read_i2s_rd_ptr();
+		else
+			ptr = read_iec958_rd_ptr();
+	    addr = ptr - s->I2S_addr;
+	    return bytes_to_frames(runtime, addr);
+	}else{
+		if(s->device_type == AML_AUDIO_I2SIN)
+			ptr = audio_in_i2s_wr_ptr();
+		else
+			ptr = audio_in_spdif_wr_ptr();				
+			addr = ptr - s->I2S_addr;
+			return bytes_to_frames(runtime, addr)/2;
+	}
+
+	return 0;
+}	
+static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
+{
+  struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
+  audio_stream_t* s = &prtd->s;
+  struct snd_pcm_substream* substream = prtd->substream;
+  struct snd_pcm_runtime* runtime= substream->runtime;
+  
+  unsigned int last_ptr, size;
+  unsigned long flag;
+  //printk("------------->hrtimer start\n");
+  if(s->active == 0){
+    hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+    return HRTIMER_RESTART;
+  }
+  //spin_lock_irqsave(&s->lock, flag);
+
+  if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+      last_ptr = read_i2s_rd_ptr();
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(substream->runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }else{
+      last_ptr = (audio_in_i2s_wr_ptr() - s->I2S_addr) /2;
+      if(last_ptr < s->last_ptr){
+        size = runtime->dma_bytes + last_ptr - s->last_ptr;
+      }else{
+        size = last_ptr - s->last_ptr;
+      }
+      s->last_ptr = last_ptr;
+      s->size += bytes_to_frames(runtime, size);
+      if(s->size >= runtime->period_size){
+        s->size %= runtime->period_size;
+        snd_pcm_period_elapsed(substream);
+      }
+  }
+  //spin_unlock_irqrestore(&s->lock, flag);
+  hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
+  return HRTIMER_RESTART;
+}
+
+static void aml_i2s_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_runtime_data *prtd = runtime->private_data;
+		audio_stream_t *s = &prtd->s;
+
+    unsigned int last_ptr, size;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		if(s->active == 1)
+		{
+			spin_lock(&s->lock);
+			if(s->device_type == AML_AUDIO_I2SOUT)
+				last_ptr = read_i2s_rd_ptr();
+			else
+				last_ptr = read_iec958_rd_ptr();							
+						if (last_ptr < s->last_ptr) {
+				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
+				    } else {
+				        size = last_ptr - (s->last_ptr);
+				    }
+    				s->last_ptr = last_ptr;
+    				s->size += bytes_to_frames(substream->runtime, size);
+    				if (s->size >= runtime->period_size) {
+				        s->size %= runtime->period_size;
+				        spin_unlock(&s->lock);
+				        snd_pcm_period_elapsed(substream);
+				        spin_lock(&s->lock);
+				    }
+				    mod_timer(&prtd->timer, jiffies + 1);
+   					spin_unlock(&s->lock);
+				}else{
+						 mod_timer(&prtd->timer, jiffies + 1);
+				}
+		}
+	else
+	{
+		if(s->active == 1)
+		{
+			spin_lock(&s->lock);
+			if(s->device_type == AML_AUDIO_I2SIN)			
+				last_ptr = audio_in_i2s_wr_ptr() ;
+			else
+				last_ptr = audio_in_spdif_wr_ptr();				
+			if (last_ptr < s->last_ptr) {
+				size = runtime->dma_bytes + (last_ptr - (s->last_ptr))/2;
+			} else {
+				size = (last_ptr - (s->last_ptr))/2;
+			}
+			s->last_ptr = last_ptr;
+			s->size += bytes_to_frames(substream->runtime, size);
+			if (s->size >= runtime->period_size) {
+				s->size %= runtime->period_size;
+				spin_unlock(&s->lock);
+				snd_pcm_period_elapsed(substream);
+				spin_lock(&s->lock);
+			}
+			mod_timer(&prtd->timer, jiffies + 1);
+			spin_unlock(&s->lock);
+		}
+		else
+		{
+			mod_timer(&prtd->timer, jiffies + 1);
+		}
+	}
+}
+
+static int num_clk_gate = 0;
+static int aml_i2s_open(struct snd_pcm_substream *substream)
+{
+	ALSA_TRACE();
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s ;		
+	int ret = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		snd_soc_set_runtime_hwparams(substream, &aml_i2s_hardware);
+	}else{
+		snd_soc_set_runtime_hwparams(substream, &aml_i2s_capture);
+	}
+
+    /* ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0)
+	{
+		printk("set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+						SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+	{
+		printk("set period error\n");
+		goto out;
+	}
+	if(!prtd){
+		prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+		if (prtd == NULL) {
+			printk("alloc aml_runtime_data error\n");
+			ret = -ENOMEM;
+			goto out;
+		}
+		prtd->substream = substream;
+		runtime->private_data = prtd;
+	}
+//	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);
+#if USE_HRTIMER == 0    
+	prtd->timer.function = &aml_i2s_timer_callback;
+	prtd->timer.data = (unsigned long)substream;
+	init_timer(&prtd->timer);
+#else
+    hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    prtd->hrtimer.function = aml_i2s_hrtimer_callback;
+    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
+
+
+    printk("hrtimer inited..\n");
+#endif
+
+	spin_lock_init(&prtd->s.lock);
+	s= &prtd->s;
+	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL9, 1,14, 1);
+	mutex_lock(&gate_mutex);
+	if(!num_clk_gate){
+        num_clk_gate = 1;
+    	if(audio_gate_status == 0){
+    		audio_aiu_pg_enable(1);
+    		ALSA_DEBUG("aml_pcm_open  device type %x \n", s->device_type);
+    		
+    	}
+    }
+	audio_gate_status  |= s->device_type;
+	mutex_unlock(&gate_mutex);		
+ out:
+	return ret;
+}
+
+static int aml_i2s_close(struct snd_pcm_substream *substream)
+{
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	audio_stream_t *s = &prtd->s;	
+	ALSA_TRACE();
+	mutex_lock(&gate_mutex);
+	audio_gate_status  &= ~s->device_type;	
+	if(audio_gate_status == 0){
+		ALSA_DEBUG("aml_pcm_close  device type %x \n", s->device_type);		
+		//audio_aiu_pg_enable(0);
+	}
+	mutex_unlock(&gate_mutex);		
+//	if(s->device_type == AML_AUDIO_SPDIFOUT)
+//		WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);			
+#if USE_HRTIMER == 0
+	del_timer_sync(&prtd->timer);
+#else
+    hrtimer_cancel(&prtd->hrtimer);
+#endif
+	if(prtd)
+		kfree(prtd);
+	return 0;
+}
+
+
+static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    int res = 0;
+    int n;
+    int i = 0, j = 0;
+    int  align = runtime->channels * 32 / runtime->byte_align;
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    n = frames_to_bytes(runtime, count);
+    if(aml_i2s_playback_enable == 0)
+      return res;
+	if(access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count)))
+	{
+		if(1/*runtime->channels == 2*/){
+			if(runtime->format == SNDRV_PCM_FORMAT_S16_LE ){
+        int16_t * tfrom, *to, *left, *right;
+        tfrom = (int16_t*)buf;
+        to = (int16_t*)hwbuf;
+
+        left = to;
+		right = to + 16;
+		if (pos % align) {
+		    printk("audio data unligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+		}
+		for (j = 0; j < n; j += 64) {
+		    for (i = 0; i < 16; i++) {
+	          *left++ = (*tfrom++) ;
+	          *right++ = (*tfrom++);
+		    }
+		    left += 16;
+		    right += 16;
+		 }
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S24_LE && I2S_MODE == AIU_I2S_MODE_PCM24){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++);
+            *right++  = (*tfrom ++);
+          }
+          left += 8;
+          right += 8;
+        }
+
+      }else if(runtime->format == SNDRV_PCM_FORMAT_S32_LE && I2S_MODE == AIU_I2S_MODE_PCM32){
+        int32_t *tfrom, *to, *left, *right;
+        tfrom = (int32_t*)buf;
+        to = (int32_t*) hwbuf;
+
+        left = to;
+        right = to + 8;
+
+        if(pos % align){
+          printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
+        }
+		
+		if(runtime->channels == 8){
+			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+			lf  = to;
+			cf  = to + 8*1;
+			rf  = to + 8*2;
+			ls  = to + 8*3;
+			rs  = to + 8*4;
+			lef = to + 8*5;
+			sbl = to + 8*6;
+			sbr = to + 8*7;
+			for (j = 0; j < n; j += 256) {
+		    	for (i = 0; i < 8; i++) {
+	         		*lf++  = (*tfrom ++)>>8;
+	          		*cf++  = (*tfrom ++)>>8;
+					*rf++  = (*tfrom ++)>>8;
+					*ls++  = (*tfrom ++)>>8;
+					*rs++  = (*tfrom ++)>>8;
+					*lef++ = (*tfrom ++)>>8;
+					*sbl++ = (*tfrom ++)>>8;
+					*sbr++ = (*tfrom ++)>>8;
+		    	}
+		    	lf  += 7*8;
+		    	cf  += 7*8;
+				rf  += 7*8;
+				ls  += 7*8;
+				rs  += 7*8;
+				lef += 7*8;
+				sbl += 7*8;
+				sbr += 7*8;
+		 	}
+		}
+		else {
+        for(j=0; j< n; j+= 64){
+          for(i=0; i<8; i++){
+            *left++  =  (*tfrom ++)>>8;
+            *right++  = (*tfrom ++)>>8;
+          }
+          left += 8;
+          right += 8;
+        }
+      	}
+      }
+
+	}else{
+	  res = -EFAULT;
+	}
+
+	return res;
+    }
+}
+
+
+static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+		unsigned int *tfrom, *left, *right;
+		unsigned short *to;
+		int res = 0;
+		int n;
+    int i = 0, j = 0;
+    unsigned int t1, t2;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;	   
+    char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
+    unsigned char r_shift = 8;	
+	if(s->device_type == AML_AUDIO_SPDIFIN) //spdif in
+    {
+    	r_shift = 12;
+    }
+    to = (unsigned short *)snd_i2s_tmp;//buf;
+    tfrom = (unsigned int *)hwbuf;	// 32bit buffer
+    n = frames_to_bytes(runtime, count);
+    if(n > 32*1024){
+		printk("Too many datas to read,please enlarge the snd_i2s_tmp buffer size\n");
+      return -EINVAL;
+    }
+	if(access_ok(VERIFY_WRITE, buf, frames_to_bytes(runtime, count)))
+	{
+		if(runtime->channels == 2){
+				left = tfrom;
+		    right = tfrom + 8;
+		    if (pos % 8) {
+		        printk("audio data unligned\n");
+		    }
+		    if((n*2)%64){
+		    		printk("audio data unaligned 64 bytes\n");
+		    }
+		    for (j = 0; j < n*2 ; j += 64) {
+		        for (i = 0; i < 8; i++) {
+		        	t1 = (*left++);
+		        	t2 = (*right++);
+		        	//printk("%08x,%08x,", t1, t2);
+	              *to++ = (unsigned short)((t1>>r_shift)&0xffff);
+	           //   *to++ = (unsigned short)((t1>>8)&0xffff);//copy left channel to right
+	              *to++ = (unsigned short)((t2>>r_shift)&0xffff);
+		         }
+		         //printk("\n");
+		        left += 8;
+		        right += 8;
+			}
+		}
+		else{
+		    }
+		}
+        res = copy_to_user(buf, snd_i2s_tmp,n);
+		return res;
+}
+
+static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+ 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+ 		ret = aml_i2s_copy_playback(runtime, channel,pos, buf, count);
+ 	}else{
+ 		ret = aml_i2s_copy_capture(runtime, channel,pos, buf, count);
+ 	}
+    return ret;
+}
+
+int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
+		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+	ALSA_TRACE();
+		char* ppos;
+		int n;
+		struct snd_pcm_runtime *runtime = substream->runtime;
+
+		n = frames_to_bytes(runtime, count);
+		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+		memset(ppos, 0, n);
+		return 0;
+}
+
+static struct snd_pcm_ops aml_i2s_ops = {
+	.open		= aml_i2s_open,
+	.close		= aml_i2s_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_i2s_hw_params,
+	.hw_free	= aml_i2s_hw_free,
+	.prepare	= aml_i2s_prepare,
+	.trigger	= aml_i2s_trigger,
+	.pointer	= aml_i2s_pointer,
+	.copy 		= aml_i2s_copy,
+	.silence	=	aml_i2s_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+static u64 aml_i2s_dmamask = 0xffffffff;
+
+static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
+{
+	ALSA_TRACE();
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_i2s_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_i2s_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		pr_debug("aml-i2s:"
+				"Allocating i2s capture DMA buffer\n");
+		ret = aml_i2s_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	return ret;
+}
+
+static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
+{
+	ALSA_TRACE();
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+#ifdef CONFIG_PM
+static int aml_i2s_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_i2s_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* disable the PDC and save the PDC registers */
+	// TODO
+	printk("aml i2s suspend\n");
+
+	return 0;
+}
+
+static int aml_i2s_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct aml_runtime_data *prtd;
+	struct aml_i2s_dma_params *params;
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* restore the PDC registers and enable the PDC */
+	// TODO
+	printk("aml i2s resume\n");
+	return 0;
+}
+#else
+#define aml_i2s_suspend	NULL
+#define aml_i2s_resume	NULL
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+
+static struct dentry *debugfs_root;
+static struct dentry *debugfs_regs;
+static struct dentry *debugfs_mems;
+
+static int regs_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/**
+ *	cat regs
+ */
+static ssize_t regs_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo base reg val >regs\t(set the register)\n"
+										 "	echo base reg >regs\t(show the register)\n"
+										 "	base -> c(cbus), x(aix), p(apb), h(ahb) \n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static int read_regs(char base, int reg)
+{
+	int val = 0;
+	switch(base){
+		case 'c':
+			val = READ_CBUS_REG(reg);
+			break;
+		case 'x':
+			val = READ_AXI_REG(reg);
+			break;
+		case 'p':
+			val = READ_APB_REG(reg);
+			break;
+		case 'h':
+			//val = READ_AHB_REG(reg);
+			break;
+		default:
+			break;
+	};
+	printk("\tReg %x = %x\n", reg, val);
+	return val;
+}
+
+static void write_regs(char base, int reg, int val)
+{
+	switch(base){
+		case 'c':
+			WRITE_CBUS_REG(reg, val);
+			break;
+		case 'x':
+			WRITE_AXI_REG(reg, val);
+			break;
+		case 'p':
+			WRITE_APB_REG(reg, val);
+			break;
+		case 'h':
+			//WRITE_AHB_REG(reg, val);
+			break;
+		default:
+			break;
+	};
+	printk("Write reg:%x = %x\n", reg, val);
+}
+static ssize_t regs_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long reg, value;
+	char base;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+	while (*start == ' ')
+		start++;
+
+	base = *start;
+	start ++;
+	if(!(base =='c' || base == 'x' || base == 'p' || base == 'h')){
+		return -EINVAL;
+	}
+
+	while (*start == ' ')
+		start++;
+
+	reg = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			read_regs(base, reg);
+			return -EINVAL;
+	}
+
+	write_regs(base, reg, value);
+
+	return buf_size;
+}
+
+static const struct file_operations regs_fops = {
+	.open = regs_open_file,
+	.read = regs_read_file,
+	.write = regs_write_file,
+};
+
+static int mems_open_file(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t mems_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = sprintf(buf, "Usage: \n"
+										 "	echo vmem >mems\t(read 64 bytes from vmem)\n"
+										 "	echo vmem val >mems (write int value to vmem\n"
+									);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t mems_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[256];
+	int buf_size = 0;
+	char *start = buf;
+	unsigned long mem, value;
+	int i=0;
+	unsigned* addr = 0;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	while (*start == ' ')
+		start++;
+
+	mem = simple_strtoul(start, &start, 16);
+
+	while (*start == ' ')
+		start++;
+
+	if (strict_strtoul(start, 16, &value))
+	{
+			addr = (unsigned*)mem;
+			printk("%p: ", addr);
+			for(i = 0; i< 8; i++){
+				printk("%08x, ", addr[i]);
+			}
+			printk("\n");
+			return -EINVAL;
+	}
+	addr = (unsigned*)mem;
+	printk("%p: %08x\n", addr, *addr);
+	*addr = value;
+	printk("%p: %08x^\n", addr, *addr);
+
+	return buf_size;
+}
+static const struct file_operations mems_fops={
+	.open = mems_open_file,
+	.read = mems_read_file,
+	.write = mems_write_file,
+};
+
+static void aml_i2s_init_debugfs(void)
+{
+	    debugfs_root = debugfs_create_dir("aml",NULL);
+		if (IS_ERR(debugfs_root) || !debugfs_root) {
+			printk("aml: Failed to create debugfs directory\n");
+			debugfs_root = NULL;
+		}
+
+		debugfs_regs = debugfs_create_file("regs", 0644, debugfs_root, NULL, &regs_fops);
+		if(!debugfs_regs){
+			printk("aml: Failed to create debugfs file\n");
+		}
+
+		debugfs_mems = debugfs_create_file("mems", 0644, debugfs_root, NULL, &mems_fops);
+		if(!debugfs_mems){
+			printk("aml: Failed to create debugfs file\n");
+		}
+}
+static void aml_i2s_cleanup_debugfs(void)
+{
+	debugfs_remove_recursive(debugfs_root);
+}
+#else
+static void aml_i2s_init_debugfs(void)
+{
+}
+static void aml_i2s_cleanup_debugfs(void)
+{
+}
+#endif
+
+struct snd_soc_platform_driver aml_soc_platform = {
+	.ops 	= &aml_i2s_ops,
+	.pcm_new	= aml_i2s_new,
+	.pcm_free	= aml_i2s_free_dma_buffers,
+	.suspend	= aml_i2s_suspend,
+	.resume		= aml_i2s_resume,
+};
+
+EXPORT_SYMBOL_GPL(aml_soc_platform);
+
+static int aml_soc_platform_probe(struct platform_device *pdev)
+{
+    ALSA_TRACE();	
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
+}
+
+static int aml_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-i2s",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_i2s_driver = {
+	.driver = {
+			.name = "aml-i2s",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,
+	},
+
+	.probe = aml_soc_platform_probe,
+	.remove = aml_soc_platform_remove,
+};
+
+static int __init aml_alsa_audio_init(void)
+{
+	aml_i2s_init_debugfs();
+	return platform_driver_register(&aml_i2s_driver);
+}
+
+static void __exit aml_alsa_audio_exit(void)
+{
+	aml_i2s_cleanup_debugfs();
+    platform_driver_unregister(&aml_i2s_driver);
+}
+
+module_init(aml_alsa_audio_init);
+module_exit(aml_alsa_audio_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
diff --git a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
new file mode 100644
index 000000000000..e194fb8743d2
--- /dev/null
+++ b/sound/soc/aml/m8/aml_i2s.h
@@ -0,0 +1,77 @@
+#ifndef __AML_PCM_H__
+#define __AML_PCM_H__
+
+//#define debug_printk
+#ifdef debug_printk
+#define dug_printk(fmt, args...)  printk (fmt, ## args)
+#else
+#define dug_printk(fmt, args...)
+#endif
+
+typedef struct audio_stream {
+    int stream_id;
+    int active;
+    unsigned int last_ptr;
+    unsigned int size;
+    unsigned int sample_rate;
+    unsigned int I2S_addr;
+    spinlock_t lock;
+    struct snd_pcm_substream *stream;
+	unsigned i2s_mode; //0:master, 1:slave,
+    unsigned device_type;
+} audio_stream_t;
+
+typedef struct aml_audio {
+    struct snd_card *card;
+    struct snd_pcm *pcm;
+    audio_stream_t s[2];
+} aml_audio_t;
+
+typedef struct audio_mixer_control {
+    int output_devide;
+    int input_device;
+    int direction;
+    int input_volume;
+    int output_volume;
+} audio_mixer_control_t;
+
+typedef struct audio_tone_control {
+    unsigned short * tone_source;
+    unsigned short * tone_data;
+    int tone_data_len;
+    int tone_count;
+    int tone_flag;
+}audio_tone_control_t;
+
+struct aml_pcm_dma_params{
+		char *name;			/* stream identifier */
+		struct snd_pcm_substream *substream;
+		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
+	
+};
+typedef struct aml_dai_info {
+	unsigned i2s_mode; //0:master, 1:slave,
+} aml_dai_info_t;
+enum {
+	I2S_MASTER_MODE = 0,
+	I2S_SLAVE_MODE,	
+};
+/*--------------------------------------------------------------------------*\
+ * Data types
+\*--------------------------------------------------------------------------*/
+struct aml_runtime_data {
+	struct aml_pcm_dma_params *params;
+	dma_addr_t dma_buffer;		/* physical address of dma buffer */
+	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
+
+	struct snd_pcm *pcm;
+	struct snd_pcm_substream *substream;
+	audio_stream_t s;	
+	struct timer_list timer;	// timeer for playback and capture
+    struct hrtimer hrtimer;
+};
+
+extern struct snd_soc_platform_driver aml_soc_platform;
+//extern struct aml_audio_interface aml_i2s_interface;
+
+#endif
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
new file mode 100644
index 000000000000..9bf499e581fb
--- /dev/null
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -0,0 +1,376 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+#include "aml_i2s_dai.h"
+#include "aml_pcm.h"
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+#include <linux/of.h>
+
+static aml_dai_info_t dai_info[3] = {{0}};
+#define AML_DAI_DEBUG
+//#define AML_DAI_PCM_SUPPORT 
+
+
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
+#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-i2s-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+
+/*
+the I2S hw  and IEC958 PCM output initation,958 initation here,
+for the case that only use our ALSA driver for PCM s/pdif output.
+*/
+static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
+{
+
+		unsigned i2s_mode;
+		switch(runtime->format){
+		case SNDRV_PCM_FORMAT_S32_LE:
+			i2s_mode = AIU_I2S_MODE_PCM32;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			i2s_mode = AIU_I2S_MODE_PCM24;
+			break;
+		case SNDRV_PCM_FORMAT_S16_LE:
+			i2s_mode = AIU_I2S_MODE_PCM16;
+			break;
+		}
+		audio_set_i2s_mode(i2s_mode);
+		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,runtime->channels);
+		ALSA_PRINT("i2s dma %x,phy addr %x \n",(unsigned)runtime->dma_area,(unsigned)runtime->dma_addr);
+		//memset((void*)runtime->dma_area,0,runtime->dma_bytes);
+		ALSA_PRINT("I2S hw init,i2s mode %d\n",i2s_mode);
+
+}
+static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	int ret = 0;
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    	struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
+	audio_stream_t *s;	
+	if(prtd == NULL){
+		prtd = (struct aml_runtime_data *)kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+		if (prtd == NULL) {
+			printk("alloc aml_runtime_data error\n");
+			ret = -ENOMEM;
+			goto out;
+		}
+		prtd->substream = substream;
+		runtime->private_data = prtd;		
+	}
+	s = &prtd->s; 
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		s->device_type = AML_AUDIO_I2SOUT;
+	}	
+	else{
+		s->device_type = AML_AUDIO_I2SIN;	
+	}	
+	return 0;
+out:
+	return ret;
+}
+
+static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+static unsigned set_clock = 0;
+static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_runtime_data *prtd = runtime->private_data;
+	unsigned sample_rate = AUDIO_CLK_FREQ_48;
+	audio_stream_t *s = &prtd->s;	
+	switch(runtime->rate){
+		case 192000:
+			sample_rate	=	AUDIO_CLK_FREQ_192;
+			break;
+		case 176400:
+			sample_rate	=	AUDIO_CLK_FREQ_1764;
+			break;
+		case 96000:
+			sample_rate	=	AUDIO_CLK_FREQ_96;
+			break;
+		case 88200:
+			sample_rate	=	AUDIO_CLK_FREQ_882;
+			break;
+		case 48000:
+			sample_rate	=	AUDIO_CLK_FREQ_48;
+			break;
+		case 44100:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+		case 32000:
+			sample_rate	=	AUDIO_CLK_FREQ_32;
+			break;
+		case 8000:
+			sample_rate	=	AUDIO_CLK_FREQ_8;
+			break;
+		case 11025:
+			sample_rate	=	AUDIO_CLK_FREQ_11;
+			break;
+		case 16000:
+			sample_rate	=	AUDIO_CLK_FREQ_16;
+			break;
+		case 22050:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		case 12000:
+			sample_rate	=	AUDIO_CLK_FREQ_12;
+			break;
+		case 24000:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		default:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+	};
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	{
+		s->i2s_mode = dai_info[dai->id].i2s_mode;
+		audio_in_i2s_set_buf(runtime->dma_addr, runtime->dma_bytes*2,0);
+		memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
+		{
+			int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
+		}
+		s->device_type = AML_AUDIO_I2SIN;		
+	}
+	else{
+        printk(KERN_INFO "enterd %s,set_clock:%d,sample_rate=%d\n",__func__,set_clock,sample_rate);
+        if(set_clock != sample_rate ){
+            set_clock = sample_rate;
+            audio_set_i2s_clk(sample_rate, AUDIO_CLK_256FS);
+        }
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);	
+		
+		s->device_type = AML_AUDIO_I2SOUT;
+		aml_hw_i2s_init(runtime);
+	}
+	return 0;
+}
+static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    //printk("****aml_dai_i2s_trigger******\n");
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			// TODO
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu i2s playback enable\n\n");
+				audio_out_i2s_enable(1);
+			}else{
+				audio_in_i2s_enable(1);
+				int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+				ppp[0] = 0x78787878;
+				ppp[1] = 0x78787878;
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu i2s playback disable\n\n");
+				audio_out_i2s_enable(0);
+			}else{
+				audio_in_i2s_enable(0);
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}	
+
+static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	
+		
+	return 0;
+}
+
+static int aml_dai_set_i2s_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)//slave mode 
+		dai_info[dai->id].i2s_mode = I2S_SLAVE_MODE;
+	return 0;
+}
+
+static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#define aml_dai_i2s_suspend	NULL
+#define aml_dai_i2s_resume	NULL
+#endif /* CONFIG_PM */
+
+
+
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_96000)
+#define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+
+static struct snd_soc_dai_ops aml_dai_i2s_ops = {
+	.startup	= aml_dai_i2s_startup,
+	.shutdown	= aml_dai_i2s_shutdown,
+	.prepare	= aml_dai_i2s_prepare,
+	.trigger = aml_dai_i2s_trigger,
+	.hw_params	= aml_dai_i2s_hw_params,
+	.set_fmt	= aml_dai_set_i2s_fmt,
+	.set_sysclk	= aml_dai_set_i2s_sysclk,
+};
+
+
+
+struct snd_soc_dai_driver aml_i2s_dai[] = {
+	{	.name = "aml-i2s-dai",
+		.id = 0,
+		.suspend = aml_dai_i2s_suspend,
+		.resume = aml_dai_i2s_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = AML_DAI_I2S_RATES,
+			.formats = AML_DAI_I2S_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = AML_DAI_I2S_RATES,
+			.formats = AML_DAI_I2S_FORMATS,},
+		.ops = &aml_dai_i2s_ops,
+	},
+
+};
+
+EXPORT_SYMBOL_GPL(aml_i2s_dai);
+
+static const struct snd_soc_component_driver aml_component= {
+	.name		= "aml-i2s-dai",
+};
+static int aml_i2s_dai_probe(struct platform_device *pdev)
+{
+	printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0
+	BUG_ON(pdev->id < 0);
+	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
+	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
+#else
+	return snd_soc_register_component(&pdev->dev, &aml_component,
+					 aml_i2s_dai, ARRAY_SIZE(aml_i2s_dai));
+
+#endif
+}
+
+static int aml_i2s_dai_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-i2s-dai",
+	},
+	{},
+};
+#else
+#define amlogic_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_i2s_dai_driver = {
+	.driver = {
+		.name = "aml-i2s-dai",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_dai_dt_match,
+	},
+
+	.probe = aml_i2s_dai_probe,
+	.remove = aml_i2s_dai_remove,
+};
+
+static int __init aml_i2s_dai_modinit(void)
+{
+	return platform_driver_register(&aml_i2s_dai_driver);
+}
+module_init(aml_i2s_dai_modinit);
+
+static void __exit aml_i2s_dai_modexit(void)
+{
+	platform_driver_unregister(&aml_i2s_dai_driver);
+}
+module_exit(aml_i2s_dai_modexit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML DAI driver for ALSA");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m8/aml_i2s_dai.h b/sound/soc/aml/m8/aml_i2s_dai.h
new file mode 100644
index 000000000000..332f1da65d9d
--- /dev/null
+++ b/sound/soc/aml/m8/aml_i2s_dai.h
@@ -0,0 +1,6 @@
+#ifndef AML_DAI_H
+#define AML_DAI_H
+
+extern struct snd_soc_dai_driver aml_dai[];
+
+#endif
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
new file mode 100644
index 000000000000..577a86af14fe
--- /dev/null
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -0,0 +1,721 @@
+/*
+ * aml_m8.c  --  SoC audio for AML M8
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include <linux/switch.h>
+#include <linux/amlogic/saradc.h>
+
+#include "aml_i2s_dai.h"
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+#include "../../codecs/aml_m8_codec.h"
+#include <mach/register.h>
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+#define USE_EXTERNAL_DAC 1
+#define DRV_NAME "aml_snd_m8"
+#define HP_DET                  1
+struct aml_audio_private_data {
+    int bias_level;
+    int clock_en;
+	int gpio_hp_det;
+	bool det_pol_inv;
+	int gpio_mute;
+	bool mute_inv;
+	struct pinctrl *pin_ctl;
+    int hp_last_state;
+    unsigned int hp_val_h;
+    unsigned int hp_val_l;
+    unsigned int mic_val;
+    unsigned int hp_detal;
+    unsigned int hp_adc_ch;
+
+    bool mic_det;
+    
+
+    int timer_en;
+    int detect_flag;
+    struct timer_list timer;
+    struct work_struct work;
+    struct mutex lock;
+    struct snd_soc_jack jack;
+    void* data;
+
+	struct switch_dev sdev; // for android
+	struct switch_dev mic_sdev; // for android
+};
+
+static void aml_set_clock(int enable)
+{
+    /* set clock gating */
+    //p_aml_audio->clock_en = enable;
+
+    return ;
+}
+
+#if HP_DET
+static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio, unsigned long delay)
+{
+    p_aml_audio->timer.expires = jiffies + delay;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->detect_flag = -1;
+    add_timer(&p_aml_audio->timer);
+    p_aml_audio->timer_en = 1;
+}
+
+static void aml_audio_stop_timer(struct aml_audio_private_data *p_aml_audio)
+{
+    del_timer_sync(&p_aml_audio->timer);
+    cancel_work_sync(&p_aml_audio->work);
+    p_aml_audio->timer_en = 0;
+    p_aml_audio->detect_flag = -1;
+}
+
+static int hp_det_adc_value(struct aml_audio_private_data *p_aml_audio)
+{
+    int ret,hp_value,hp_val_sum,loop_num;
+    hp_val_sum = 0;
+    loop_num = 0;
+    unsigned int mic_ret = 0;
+    
+    while(loop_num < 8){
+        hp_value = get_adc_sample(p_aml_audio->hp_adc_ch);
+        if(hp_value <0){
+            printk("hp detect get error adc value!\n");
+            continue;
+        }
+        hp_val_sum += hp_value;
+        loop_num ++;
+        msleep(15);
+    }
+    hp_val_sum = hp_val_sum >> 3;
+
+    if(hp_val_sum >= p_aml_audio->hp_val_h){
+        ret = 0;
+    }else if((hp_val_sum <= (p_aml_audio->hp_val_l))&& hp_val_sum >=0){
+        ret = 1;
+        if(p_aml_audio->mic_det){
+            if(hp_val_sum <=  p_aml_audio->mic_val){
+                mic_ret = 8;
+                ret |= mic_ret;
+            }
+        }
+    }else{
+        ret = 2;
+        if(p_aml_audio->mic_det){
+            ret = 0;
+            mic_ret = 8;
+            ret |= mic_ret; 
+        }
+            
+    }
+    
+    return ret;
+}
+
+
+static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
+{
+       // return 0;
+   int loop_num = 0;
+   int ret;
+
+    mutex_lock(&p_aml_audio->lock);
+
+    while(loop_num < 3){
+        ret = hp_det_adc_value(p_aml_audio);
+        if(p_aml_audio->hp_last_state != ret){
+            loop_num = 0;
+            msleep(50);
+            if(ret < 0){
+                ret = p_aml_audio->hp_last_state;
+            }else {
+                p_aml_audio->hp_last_state = ret;
+            }
+        }else{
+            msleep(50);
+            loop_num = loop_num + 1;
+        }
+    }
+ 
+    mutex_unlock(&p_aml_audio->lock);
+
+    return ret; 
+}
+
+
+static void aml_asoc_work_func(struct work_struct *work)
+{
+    struct aml_audio_private_data *p_aml_audio = NULL;
+    struct snd_soc_card *card = NULL;
+    int jack_type = 0;
+    int flag = -1;
+	int status = SND_JACK_HEADPHONE;
+    p_aml_audio = container_of(work, struct aml_audio_private_data, work);
+    card = (struct snd_soc_card *)p_aml_audio->data;
+
+    flag = aml_audio_hp_detect(p_aml_audio);
+
+    if(p_aml_audio->detect_flag != flag) {
+
+        p_aml_audio->detect_flag = flag;
+        
+        if (flag & 0x1) {
+            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
+            adac_wr_reg (71, 0x0101); // use board mic
+            printk(KERN_INFO "aml aduio hp pluged 3 jack_type: %d\n", SND_JACK_HEADPHONE);
+           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+
+           // mic port detect
+           if(p_aml_audio->mic_det){
+               if(flag & 0x8){
+                  switch_set_state(&p_aml_audio->mic_sdev, 1);
+                  adac_wr_reg (71, 0x0005); // use hp mic
+                  printk(KERN_INFO "aml aduio mic pluged jack_type: %d\n", SND_JACK_MICROPHONE);
+                  //snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+              }
+           }
+
+        } else if(flag & 0x2){
+            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            switch_set_state(&p_aml_audio->sdev, 1);  // 1 :have mic ;  2 no mic
+            adac_wr_reg (71, 0x0005); // use hp mic
+            printk(KERN_INFO "aml aduio hp pluged 4 jack_type: %d\n", SND_JACK_HEADSET);
+           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+        } else {
+            printk(KERN_INFO "aml audio hp unpluged\n");
+            amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+            adac_wr_reg (71, 0x0101); // use board mic
+            switch_set_state(&p_aml_audio->sdev, 0);
+            //snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+
+            // mic port detect
+            if(p_aml_audio->mic_det){
+                if(flag & 0x8){
+                   switch_set_state(&p_aml_audio->mic_sdev, 1);
+                   adac_wr_reg (71, 0x0005); // use hp mic
+                   printk(KERN_INFO "aml aduio mic pluged jack_type: %d\n", SND_JACK_MICROPHONE);
+                   //snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+               }
+            }
+        }
+        
+    }
+}
+
+
+static void aml_asoc_timer_func(unsigned long data)
+{
+    struct aml_audio_private_data *p_aml_audio = (struct aml_audio_private_data *)data;
+    unsigned long delay = msecs_to_jiffies(200);
+
+    schedule_work(&p_aml_audio->work);
+    mod_timer(&p_aml_audio->timer, jiffies + delay);
+}
+#endif
+
+static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s stream: %s rate: %d format: %d\n", __func__, (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? "playback" : "capture", params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+    ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+        SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+#if 0
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+#endif
+    return 0;
+}
+
+static struct snd_soc_ops aml_asoc_ops = {
+    .hw_params = aml_asoc_hw_params,
+};
+
+
+struct aml_audio_private_data *p_audio;
+
+static int aml_m8_spk_enabled;
+
+static int aml_m8_set_spk(struct snd_kcontrol *kcontrol,
+    struct snd_ctl_elem_value *ucontrol)
+{
+    aml_m8_spk_enabled = ucontrol->value.integer.value[0];
+    printk(KERN_INFO "aml_m8_set_spk: aml_m8_spk_enabled=%d\n",aml_m8_spk_enabled);
+
+    msleep(10);
+    amlogic_set_value(p_audio->gpio_mute, aml_m8_spk_enabled, "mute_spk");
+
+    if(aml_m8_spk_enabled ==1)
+        msleep(100);
+
+    return 0;
+}
+
+static int aml_m8_get_spk(struct snd_kcontrol *kcontrol,
+    struct snd_ctl_elem_value *ucontrol)
+{
+    //printk("***aml_m8_get_spk****aml_m8_spk_enabled=%d**\n",aml_m8_spk_enabled);
+    ucontrol->value.integer.value[0] = aml_m8_spk_enabled;
+    return 0;
+}
+
+static int aml_set_bias_level(struct snd_soc_card *card,
+        struct snd_soc_dapm_context *dapm, enum snd_soc_bias_level level)
+{
+    int ret = 0;
+    struct aml_audio_private_data * p_aml_audio;
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+    printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+
+    int hp_state = p_aml_audio->detect_flag;
+    if (p_aml_audio->bias_level == (int)level)
+        return 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+        /* clock enable */
+        if (!p_aml_audio->clock_en) {
+            aml_set_clock(1);
+        }
+        break;
+
+    case SND_SOC_BIAS_OFF:
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    case SND_SOC_BIAS_STANDBY:
+        /* clock disable */
+        if (p_aml_audio->clock_en) {
+            aml_set_clock(0);
+        }
+
+        break;
+    default:
+        return ret;
+    }
+
+    p_aml_audio->bias_level = (int)level;
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int aml_suspend_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+#if HP_DET
+
+#endif
+    return 0;
+}
+
+static int aml_suspend_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_pre(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+
+static int aml_resume_post(struct snd_soc_card *card)
+{
+    printk(KERN_DEBUG "enter %s\n", __func__);
+    return 0;
+}
+#else
+#define aml_suspend_pre  NULL
+#define aml_suspend_post NULL
+#define aml_resume_pre   NULL
+#define aml_resume_post  NULL
+#endif
+
+static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
+    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_HP("HP", NULL),
+    SND_SOC_DAPM_MIC("MAIN MIC", NULL),
+    SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+    {
+        .pin = "HP",
+        .mask = SND_JACK_HEADPHONE,
+    }
+};
+
+static const struct snd_kcontrol_new aml_m8_controls[] = {
+
+    SOC_SINGLE_BOOL_EXT("Amp Spk enable", 0,
+        aml_m8_get_spk,
+        aml_m8_set_spk),
+/*
+    SOC_SINGLE_BOOL_EXT("Audio MPLL9 Switch", 0,
+    aml_m8_get_MPLL9,
+    aml_m8_set_MPLL9),
+    */
+};
+static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+    struct snd_soc_codec *codec = rtd->codec;
+    struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aml_audio_private_data * p_aml_audio;
+    int ret = 0;
+    int hp_paraments[5];
+	
+    printk(KERN_DEBUG "enter %s \n", __func__);
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+    ret = snd_soc_add_card_controls(codec->card, aml_m8_controls,
+                ARRAY_SIZE(aml_m8_controls));
+    if (ret)
+       return ret;
+
+    /* Add specific widgets */
+    //snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+    //              ARRAY_SIZE(aml_asoc_dapm_widgets));
+    ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
+    if (ret < 0) {
+        printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
+    } else {
+        ret = snd_soc_jack_add_pins(&p_aml_audio->jack, ARRAY_SIZE(jack_pins), jack_pins);
+        if (ret < 0) {
+            printk(KERN_WARNING "Failed to setup hp pins\n");
+        }
+    }
+
+#if HP_DET
+    p_aml_audio->mic_det = of_property_read_bool(card->dev->of_node,"mic_det");
+
+    printk("entern %s : mic_det=%d \n",__func__,p_aml_audio->mic_det);
+    ret = of_property_read_u32_array(card->dev->of_node, "hp_paraments", &hp_paraments[0], 5);
+    if(ret){
+        printk("falied to get hp detect paraments from dts file\n");
+    }else{
+        p_aml_audio->hp_val_h  = hp_paraments[0];  // hp adc value higher base, hp unplugged
+        p_aml_audio->hp_val_l  = hp_paraments[1];  // hp adc value low base, 3 section hp plugged.
+        p_aml_audio->mic_val   = hp_paraments[2];  // hp adc value mic detect value.
+        p_aml_audio->hp_detal  = hp_paraments[3];  // hp adc value test toerance
+        p_aml_audio->hp_adc_ch = hp_paraments[4];  // get adc value from which adc port for hp detect
+
+        printk("hp detect paraments: h=%d,l=%d,mic=%d,det=%d,ch=%d \n",p_aml_audio->hp_val_h,p_aml_audio->hp_val_l,
+            p_aml_audio->mic_val,p_aml_audio->hp_detal,p_aml_audio->hp_adc_ch);
+    }
+    init_timer(&p_aml_audio->timer);
+    p_aml_audio->timer.function = aml_asoc_timer_func;
+    p_aml_audio->timer.data = (unsigned long)p_aml_audio;
+    p_aml_audio->data= (void*)card;
+
+    INIT_WORK(&p_aml_audio->work, aml_asoc_work_func);
+    mutex_init(&p_aml_audio->lock);
+
+    mutex_lock(&p_aml_audio->lock);
+    if (!p_aml_audio->timer_en) {
+        aml_audio_start_timer(p_aml_audio, msecs_to_jiffies(100));
+    }
+    mutex_unlock(&p_aml_audio->lock);
+
+#endif
+
+    return 0;
+}
+
+static struct snd_soc_dai_link aml_codec_dai_link[] = {
+    {
+        .name = "SND_M8",
+        .stream_name = "AML PCM",
+        .cpu_dai_name = "aml-i2s-dai.0",
+        .init = aml_asoc_init,
+        .platform_name = "aml-i2s.0",
+        .codec_name = "aml_m8_codec.0",
+        .ops = &aml_asoc_ops,
+    },
+#ifdef CONFIG_SND_SOC_PCM2BT
+    {
+        .name = "BT Voice",
+        .stream_name = "Voice PCM",
+        .cpu_dai_name = "aml-pcm-dai.0",
+        .codec_dai_name = "pcm2bt-pcm",
+        .platform_name = "aml-pcm.0",
+        .codec_name = "pcm2bt.0",
+        //.ops = &voice_soc_ops,
+    },
+#endif
+
+    {
+        .name = "AML-SPDIF",
+        .stream_name = "SPDIF PCM",
+        .cpu_dai_name = "aml-spdif-dai.0",
+        .codec_dai_name = "dit-hifi",
+        .init = NULL,
+        .platform_name = "aml-i2s.0",
+        .codec_name = "spdif-dit.0",
+        .ops = NULL,      
+    }, 
+
+};
+
+static struct snd_soc_card aml_snd_soc_card = {
+    .driver_name = "SOC-Audio",
+    .dai_link = &aml_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(aml_codec_dai_link),
+    .set_bias_level = aml_set_bias_level,
+#ifdef CONFIG_PM_SLEEP
+	.suspend_pre    = aml_suspend_pre,
+	.suspend_post   = aml_suspend_post,
+	.resume_pre     = aml_resume_pre,
+	.resume_post    = aml_resume_post,
+#endif
+};
+
+static void aml_m8_pinmux_init(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+	const char *str=NULL;
+	int ret;
+	p_aml_audio = snd_soc_card_get_drvdata(card);   
+    p_aml_audio->pin_ctl = devm_pinctrl_get_select(card->dev, "aml_snd_m8");
+    
+    p_audio = p_aml_audio;
+ #if USE_EXTERNAL_DAC
+    aml_write_reg32(P_AO_SECURE_REG1,0x00000000);
+ #endif
+	ret = of_property_read_string(card->dev->of_node, "mute_gpio", &str);
+	if (ret < 0) {
+		printk("aml_snd_m8: faild to get mute_gpio!\n");
+	}else{
+		p_aml_audio->gpio_mute = amlogic_gpio_name_map_num(str);
+		p_aml_audio->mute_inv = of_property_read_bool(card->dev->of_node,"mute_inv");
+		amlogic_gpio_request_one(p_aml_audio->gpio_mute,GPIOF_OUT_INIT_HIGH,"mute_spk");
+		amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+	}
+
+	printk("=%s==,aml_m8_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
+}
+
+static void aml_m8_pinmux_deinit(struct snd_soc_card *card)
+{
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	if(p_aml_audio->gpio_hp_det)
+		amlogic_gpio_free(p_aml_audio->gpio_hp_det,"hp_det");
+	if(p_aml_audio->gpio_mute)
+		amlogic_gpio_free(p_aml_audio->gpio_mute,"mute_spk"); 
+    if(p_aml_audio->pin_ctl)
+        devm_pinctrl_put(p_aml_audio->pin_ctl);
+}
+static int aml_m8_audio_probe(struct platform_device *pdev)
+{
+    //struct device_node *np = pdev->dev.of_node;
+    struct snd_soc_card *card = &aml_snd_soc_card;
+    struct aml_audio_private_data *p_aml_audio;
+    int ret = 0;
+
+    printk(KERN_DEBUG "enter %s\n", __func__);
+
+#ifdef CONFIG_USE_OF
+    p_aml_audio = devm_kzalloc(&pdev->dev,
+            sizeof(struct aml_audio_private_data), GFP_KERNEL);
+    if (!p_aml_audio) {
+        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    card->dev = &pdev->dev;
+    platform_set_drvdata(pdev, card);
+    snd_soc_card_set_drvdata(card, p_aml_audio);
+    if (!(pdev->dev.of_node)) {
+        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
+    if (ret)
+        goto err;
+    
+    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
+            0, &aml_codec_dai_link[0].codec_dai_name);
+    if (ret)
+        goto err;
+
+    //ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+    //if (ret)
+    //  goto err;
+
+//  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+//          pdev->dev.of_node, "aml,audio-codec", 0);
+
+    ret = snd_soc_register_card(card);
+    if (ret) {
+        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+            ret);
+        goto err;
+    }
+
+    aml_m8_pinmux_init(card);
+
+    p_aml_audio->sdev.name = "h2w";//for report headphone to android
+    ret = switch_dev_register(&p_aml_audio->sdev);
+    if (ret < 0){
+        printk(KERN_ERR "ASoC: register hp switch dev failed\n");
+        goto err;
+    }
+
+    p_aml_audio->mic_sdev.name = "mic_dev";//for micphone detect
+    ret = switch_dev_register(&p_aml_audio->mic_sdev);
+    if (ret < 0){
+        printk(KERN_ERR "ASoC: register mic switch dev failed\n");
+        goto err;
+    }
+
+    return 0;
+#endif
+
+err:
+    kfree(p_aml_audio);
+    return ret;
+}
+
+static int aml_m8_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct aml_audio_private_data *p_aml_audio;
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+	snd_soc_unregister_card(card);
+#if HP_DET
+	/* stop timer */
+	mutex_lock(&p_aml_audio->lock);
+	if (p_aml_audio->timer_en) {
+		aml_audio_stop_timer(p_aml_audio);
+	}
+	mutex_unlock(&p_aml_audio->lock);
+#endif
+
+	aml_m8_pinmux_deinit(card);
+    kfree(p_aml_audio);
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{ .compatible = "sound_card, aml_snd_m8", },
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+static struct platform_driver aml_m8_audio_driver = {
+    .probe  = aml_m8_audio_probe,
+    .remove = aml_m8_audio_remove,
+    .driver = {
+        .name = DRV_NAME,
+        .owner = THIS_MODULE,
+        .pm = &snd_soc_pm_ops,
+        .of_match_table = amlogic_audio_dt_match,
+    },
+};
+
+static int __init aml_m8_audio_init(void)
+{
+    return platform_driver_register(&aml_m8_audio_driver);
+}
+
+static void __exit aml_m8_audio_exit(void)
+{
+    platform_driver_unregister(&aml_m8_audio_driver);
+}
+
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m8_audio_init);
+#else
+module_init(aml_m8_audio_init);
+#endif
+module_exit(aml_m8_audio_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML_M8 audio machine Asoc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, amlogic_audio_dt_match);
+
diff --git a/sound/soc/aml/m8/aml_m_dummy.c b/sound/soc/aml/m8/aml_m_dummy.c
new file mode 100644
index 000000000000..6aca7c0ed16b
--- /dev/null
+++ b/sound/soc/aml/m8/aml_m_dummy.c
@@ -0,0 +1,360 @@
+/*
+ * aml_m_dummy_codec.c  --  SoC audio for AML M series
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <sound/dummy_codec.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "aml_i2s_dai.h"
+#include "aml_i2s.h"
+#include "aml_audio_hw.h"
+
+#ifdef CONFIG_USE_OF
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+#include <plat/io.h>
+#endif
+
+static struct dummy_codec_platform_data *dummy_codec_snd_pdata = NULL;
+
+#ifdef CONFIG_USE_OF
+static struct device_node *np = NULL;
+static struct dummy_codec_platform_data *dummy_codec_pdata = NULL;
+struct device *dummy_codec_dev = NULL;
+struct pinctrl *p = NULL;
+#endif
+static void dummy_codec_dev_init(void)
+{
+    if (dummy_codec_snd_pdata->device_init) {
+        dummy_codec_snd_pdata->device_init();
+    }
+}
+
+static void dummy_codec_dev_uninit(void)
+{
+    if (dummy_codec_snd_pdata->device_uninit) {
+        dummy_codec_snd_pdata->device_uninit();
+    }
+}
+
+static void dummy_codec_mute_speaker(int mute)
+{
+	if (dummy_codec_snd_pdata->mute_spk){
+		dummy_codec_snd_pdata->mute_spk(mute);
+	}
+}
+static int dummy_codec_hw_params(struct snd_pcm_substream *substream,
+    struct snd_pcm_hw_params *params)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    struct snd_soc_dai *codec_dai = rtd->codec_dai;
+    struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+    int ret;
+
+    printk(KERN_DEBUG "enter %s rate: %d format: %d\n", __func__, params_rate(params), params_format(params));
+
+    /* set codec DAI configuration */
+    ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai fmt failed!\n", __func__);
+        return ret;
+    }
+
+    /* set cpu DAI configuration */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	}
+	else
+    	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
+        return ret;
+    }
+#if 0   //no audio in
+    /* set codec DAI clock */
+    ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set codec dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+#endif
+    /* set cpu DAI clock */
+    ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_OUT);
+    if (ret < 0) {
+        printk(KERN_ERR "%s: set cpu dai sysclk failed (rate: %d)!\n", __func__, params_rate(params));
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct snd_soc_ops dummy_codec_soc_ops = {
+    .hw_params = dummy_codec_hw_params,
+};
+
+static int dummy_codec_set_bias_level(struct snd_soc_card *card,
+			      enum snd_soc_bias_level level)
+{
+    int ret = 0;
+
+    switch (level) {
+    case SND_SOC_BIAS_ON:
+        break;
+    case SND_SOC_BIAS_PREPARE:
+    	dummy_codec_mute_speaker(0);
+        break;
+
+    case SND_SOC_BIAS_OFF:
+    	break;
+    case SND_SOC_BIAS_STANDBY:
+        dummy_codec_mute_speaker(1);
+        break;
+    default:
+        return ret;
+    }
+    return 0;
+}
+
+static int dummy_codec_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+    return 0;
+}
+
+static struct snd_soc_dai_link dummy_codec_dai_link[] = {
+    {
+        .name = "DUMMY_CODEC",
+        .stream_name = "DUMMY_CODEC PCM",
+        .cpu_dai_name = "aml-i2s-dai.0",
+        .codec_dai_name = "dummy_codec",
+        .init = dummy_codec_codec_init,
+        .platform_name = "aml-i2s.0",
+        .codec_name = "dummy_codec.0",
+        .ops = &dummy_codec_soc_ops,
+    },
+
+	{
+        .name = "AML-SPDIF",
+        .stream_name = "SPDIF PCM",
+        .cpu_dai_name = "aml-spdif-dai.0",
+        .codec_dai_name = "dit-hifi",
+        .init = NULL,
+        .platform_name = "aml-i2s.0",
+        .codec_name = "spdif-dit.0",
+        .ops = NULL,      
+    },
+
+};
+
+static struct snd_soc_card snd_soc_dummy_codec = {
+    .name = "AML-DUMMY-CODEC",
+    .driver_name = "SOC-Audio",
+    .dai_link = &dummy_codec_dai_link[0],
+    .num_links = ARRAY_SIZE(dummy_codec_dai_link),
+    .set_bias_level = dummy_codec_set_bias_level,
+};
+
+#ifdef CONFIG_USE_OF
+static void dummy_codec_device_init(void)
+{
+#ifdef CONFIG_USE_OF
+	int ret;
+	struct pinctrl_state *s;
+	p = pinctrl_get(dummy_codec_dev);
+
+	if (IS_ERR(p))
+		return p;
+
+	s = pinctrl_lookup_state(p, "dummy_codec_audio");
+	if (IS_ERR(s)) {
+		pinctrl_put(p);
+		return ERR_PTR(PTR_ERR(s));
+	}
+
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+	printk("=%s==,dummy_codec_audio init done\n",__func__);
+#else
+    /* audio pinmux */
+//    pinmux_set(&rt5631_pinmux_set);
+
+    /* GPIOA_19 PULL_UP_REG0 bit19 */
+//    aml_set_reg32_bits(P_PAD_PULL_UP_REG0, 1, 19, 1);
+#endif
+}
+
+static void dummy_codec_device_deinit(void)
+{
+#ifdef CONFIG_USE_OF
+	pinctrl_put(p);
+#else
+//    pinmux_clr(&rt5631_pinmux_set);
+#endif
+}
+#endif
+static struct platform_device *dummy_codec_snd_device = NULL;
+
+static int dummy_codec_audio_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+		struct snd_soc_card *card = &snd_soc_dummy_codec;
+
+    //printk(KERN_DEBUG "enter %s\n", __func__);
+    printk("enter %s\n", __func__);
+#ifdef CONFIG_USE_OF
+		dummy_codec_pdata = kzalloc(sizeof(struct dummy_codec_platform_data), GFP_KERNEL);
+		if(!dummy_codec_pdata){
+           // kfree(dummy_codec_pdata);
+			return -1;
+		}
+
+		if (pdev->dev.of_node) {
+            np = pdev->dev.of_node;
+            ret = of_property_match_string(np,"status","okay");
+            if(ret){
+                printk("the platform not register this codec\n");
+				goto err1;
+            }
+		}
+		dummy_codec_dev=&pdev->dev;
+    dummy_codec_pdata->device_init = &dummy_codec_device_init;
+    dummy_codec_pdata->device_uninit = &dummy_codec_device_deinit;
+
+		pdev->dev.platform_data = dummy_codec_pdata;
+		dummy_codec_snd_pdata = pdev->dev.platform_data;
+#endif
+
+#if 1
+    card->dev = &pdev->dev;
+		platform_set_drvdata(pdev, card);
+		snd_soc_card_set_drvdata(card, dummy_codec_pdata);
+		if (!(pdev->dev.of_node)) {
+			dev_err(&pdev->dev, "Must be instantiated using device tree\n");
+			ret = -EINVAL;
+			goto err;
+		}
+
+    ret = snd_soc_register_card(card);
+		if (ret) {
+			dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
+			ret);
+		goto err;
+	}
+
+#endif
+#if 0
+    dummy_codec_snd_pdata = pdev->dev.platform_data;
+    snd_BUG_ON(!dummy_codec_snd_pdata);
+    dummy_codec_snd_device = platform_device_alloc("soc-audio", -1);
+    if (!dummy_codec_snd_device) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    platform_set_drvdata(dummy_codec_snd_device, &snd_soc_dummy_codec);
+
+    ret = platform_device_add(dummy_codec_snd_device);
+    if (ret) {
+        printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+        goto err_device_add;
+    }
+#endif
+
+    dummy_codec_dev_init();
+
+    return ret;
+
+err_device_add:
+    platform_device_put(dummy_codec_snd_device);
+err:
+err1:
+    kfree(dummy_codec_pdata);
+    return ret;
+}
+
+static int dummy_codec_audio_remove(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    dummy_codec_dev_uninit();
+
+    platform_device_put(dummy_codec_snd_device);
+    kfree(dummy_codec_pdata);
+
+    dummy_codec_snd_device = NULL;
+    dummy_codec_snd_pdata = NULL;
+
+    return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_dummy_codec_dt_match[]={
+	{	.compatible = "amlogic,aml_dummy_codec_audio",
+	},
+	{},
+};
+#else
+#define aml_dummy_codec_dt_match NULL
+#endif
+static struct platform_driver aml_m_dummy_codec_driver = {
+    .probe  = dummy_codec_audio_probe,
+    .remove = dummy_codec_audio_remove,
+    .driver = {
+        .name = "aml_dummy_codec_audio",
+        .owner = THIS_MODULE,
+        .of_match_table = aml_dummy_codec_dt_match,
+    },
+};
+
+static int __init aml_m_dummy_codec_init(void)
+{
+    return platform_driver_register(&aml_m_dummy_codec_driver);
+}
+
+static void __exit aml_m_dummy_codec_exit(void)
+{
+    platform_driver_unregister(&aml_m_dummy_codec_driver);
+}
+#ifdef CONFIG_DEFERRED_MODULE_INIT
+deferred_module_init(aml_m_dummy_codec_init);
+#else
+module_init(aml_m_dummy_codec_init);
+#endif
+module_exit(aml_m_dummy_codec_exit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML dummy_codec audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m8/aml_mixer.c b/sound/soc/aml/m8/aml_mixer.c
new file mode 100644
index 000000000000..d7aab5661ee8
--- /dev/null
+++ b/sound/soc/aml/m8/aml_mixer.c
@@ -0,0 +1,371 @@
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/soundcard.h>
+
+#include "aml_pcm.h"
+#include "aml_alsa_common.h"
+#include "aml_audio_hw.h"
+
+extern audio_tone_control_t audio_tone_control;
+
+static int pcm_pb_volume_info(struct snd_kcontrol *kcontrol,
+                              struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 100;
+    uinfo->value.integer.step = 1;
+
+    return 0;
+}
+
+static int pcm_pb_volume_get(struct snd_kcontrol *kcontrol,
+                             struct snd_ctl_elem_value *uvalue)
+{
+    int val;
+
+    val = get_mixer_output_volume();
+    val = val & 0xff;
+    uvalue->value.integer.value[0] = val;
+
+    return 0;
+}
+
+static int pcm_pb_volume_put(struct snd_kcontrol *kcontrol,
+                             struct snd_ctl_elem_value *uvalue)
+{
+    int volume;
+
+    volume = uvalue->value.integer.value[0];
+  //  volume = volume | (volume << 8);
+    set_mixer_output_volume(volume);
+    return 0;
+}
+
+static int pcm_pb_mute_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_pb_mute_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_pb_mute_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag)
+	 	audio_i2s_unmute();
+	 else
+	 	audio_i2s_mute();
+
+     return 0;
+}
+
+static int pcm_left_mono_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_left_mono_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_left_mono_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(1);
+     }
+
+     return 0;
+}
+
+static int pcm_right_mono_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_right_mono_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_right_mono_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(2);
+     }
+
+     return 0;
+}
+
+static int pcm_stereo_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_stereo_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_stereo_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+	 	audio_i2s_swap_left_right(0);
+     }
+
+     return 0;
+}
+
+static int pcm_swap_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_swap_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *uvalue)
+{
+    return 0;
+}
+
+static int pcm_swap_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     int flag;
+     unsigned int reg;
+
+     flag = uvalue->value.integer.value[0];
+     if(flag){
+		reg = read_i2s_mute_swap_reg();
+		if((reg & 0x3))
+			audio_i2s_swap_left_right(0);
+		else
+			audio_i2s_swap_left_right(3);
+     }
+
+     return 0;
+}
+
+static int pcm_pb_data_info(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+    uinfo->count = 128;
+
+    return 0;
+}
+
+static int pcm_pb_data_get(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_value *uvalue)
+{
+    unsigned int rd_ptr;
+
+    rd_ptr = read_i2s_rd_ptr();
+    memcpy(uvalue->value.bytes.data, (unsigned char*)rd_ptr, 128);
+    return 0;
+}
+
+static int pcm_pb_tone_info(struct snd_kcontrol *kcontrol,
+						struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+
+    return 0;
+}
+
+static int pcm_pb_tone_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     audio_tone_control.tone_flag = 1;
+	
+     return 0;
+}
+static int pcm_pb_tone_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *uvalue)
+{
+     return 0;
+}
+struct snd_kcontrol_new pcm_control_pb_vol = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "Master Playback Volume",
+    .index = 0x00,
+    .info = pcm_pb_volume_info,
+    .get = pcm_pb_volume_get,
+    .put = pcm_pb_volume_put,
+    .private_value = 0x0,
+};
+
+struct snd_kcontrol_new pcm_switch_pb_mute = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "switch playback mute",
+     .index = 0x00,
+     .info = pcm_pb_mute_info,
+     .get = pcm_pb_mute_get,
+     .put = pcm_pb_mute_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_left_mono = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Left Mono",
+     .index = 0x00,
+     .info = pcm_left_mono_info,
+     .get = pcm_left_mono_get,
+     .put = pcm_left_mono_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_right_mono = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Right Mono",
+     .index = 0x00,
+     .info = pcm_right_mono_info,
+     .get = pcm_right_mono_get,
+     .put = pcm_right_mono_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_stereo = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Stereo Out",
+     .index = 0x00,
+     .info = pcm_stereo_info,
+     .get = pcm_stereo_get,
+     .put = pcm_stereo_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_pb_swap = {
+     .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+     .name = "Playback Swap Left Right",
+     .index = 0x00,
+     .info = pcm_swap_info,
+     .get = pcm_swap_get,
+     .put = pcm_swap_put,
+     .private_value = 0xff,
+};
+
+struct snd_kcontrol_new pcm_data_read = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Playback Data Get",
+	.info = pcm_pb_data_info,
+	.get = pcm_pb_data_get,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_VOLATILE),
+};
+
+struct snd_kcontrol_new pcm_tone_play = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Playback Tone",
+	.info = pcm_pb_tone_info,
+	.put = pcm_pb_tone_put,
+	.get = pcm_pb_tone_get,
+	.access = (SNDRV_CTL_ELEM_ACCESS_WRITE |
+	          SNDRV_CTL_ELEM_ACCESS_READ), 
+	          
+};
+
+int aml_alsa_create_ctrl(struct snd_card *card, void *p_value)
+{
+    int err = 0;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_control_pb_vol, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_switch_pb_mute, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_left_mono, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_right_mono, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_stereo, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_pb_swap, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_data_read, p_value))) < 0)
+        return err;
+
+    if ((err =
+         snd_ctl_add(card,
+                     snd_ctl_new1(&pcm_tone_play, p_value))) < 0)
+        return err;
+	
+    return 0;
+}
diff --git a/sound/soc/aml/m8/aml_notify.c b/sound/soc/aml/m8/aml_notify.c
new file mode 100644
index 000000000000..d24962f6ed47
--- /dev/null
+++ b/sound/soc/aml/m8/aml_notify.c
@@ -0,0 +1,43 @@
+/*
+ *  linux/drivers/video/apollo/aout_notify.c
+ *
+ *  Copyright (C) 2009 amlogic
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+
+static BLOCKING_NOTIFIER_HEAD(aout_notifier_list);
+/**
+ *	aout_register_client - register a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int aout_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&aout_notifier_list, nb);
+}
+EXPORT_SYMBOL(aout_register_client);
+
+/**
+ *	aout_unregister_client - unregister a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int aout_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&aout_notifier_list, nb);
+}
+EXPORT_SYMBOL(aout_unregister_client);
+
+/**
+ * aout_notifier_call_chain - notify clients of fb_events
+ *
+ */
+int aout_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&aout_notifier_list, val, v);
+}
+EXPORT_SYMBOL_GPL(aout_notifier_call_chain);
+
+
diff --git a/sound/soc/aml/m8/aml_pcm.c b/sound/soc/aml/m8/aml_pcm.c
new file mode 100644
index 000000000000..0d632f36a512
--- /dev/null
+++ b/sound/soc/aml/m8/aml_pcm.c
@@ -0,0 +1,698 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+
+#include "aml_i2s.h" 
+#include "aml_pcm.h"
+#include "aml_audio_hw_pcm2bt.h"
+
+
+#define USE_HRTIMER 0
+#define HRTIMER_PERIOD (1000000000UL/1000)
+#define DEBUG_ALSA_PLATFRORM
+
+
+
+//#define PCM_DEBUG
+
+#ifdef PCM_DEBUG
+#define pcm_debug(fmt, args...)  printk (fmt, ## args)
+#else
+#define pcm_debug(fmt, args...)
+#endif
+
+
+/*--------------------------------------------------------------------------*\
+ * Hardware definition
+\*--------------------------------------------------------------------------*/
+/* TODO: These values were taken from the AML platform driver, check
+ *	 them against real values for AML
+ */
+static const struct snd_pcm_hardware aml_pcm2bt_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED|
+							SNDRV_PCM_INFO_BLOCK_TRANSFER|
+				  		    SNDRV_PCM_INFO_PAUSE,
+				  		
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8*1024,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 64 * 1024,
+	
+	.rate_min = 8000,
+    .rate_max = 8000,
+    .channels_min = 1,
+    .channels_max = 1,
+};
+
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+unsigned int aml_pcm2bt_playback_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_buffer_size = 0;
+
+unsigned int aml_pcm2bt_playback_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_playback_phy_buffer_size = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_addr = 0;
+unsigned int aml_pcm2bt_capture_phy_buffer_size = 0;
+
+#if 0
+static void aml_pcm_config_tx(u32 addr, u32 size)
+{
+    pcm_debug("****%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_out_set_buf(addr, size);
+}
+
+static void aml_pcm_config_rx(u32 addr, u32 size)
+{
+    pcm_debug("****%s addr: 0x%08x size: 0x%x\n", __FUNCTION__, addr, size);
+    pcm_in_set_buf(addr, size);
+}
+
+static void aml_pcm_start_tx(void)
+{
+    pcm_debug( "***%s", __FUNCTION__);
+    pcm_out_enable(1);
+}
+
+static void aml_pcm_start_rx(void)
+{
+    pcm_debug("*****%s", __FUNCTION__);
+    pcm_in_enable(1);
+}
+
+static void aml_pcm_stop_tx(void)
+{
+    pcm_debug("*****%s", __FUNCTION__);
+    pcm_out_enable(0);
+}
+
+static void aml_pcm_stop_rx(void)
+{
+    pcm_debug("****%s", __FUNCTION__);
+    pcm_in_enable(0);
+}
+#endif
+static unsigned int aml_pcm_offset_tx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_out_rd_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static unsigned int aml_pcm_offset_rx(struct aml_pcm_runtime_data *prtd)
+{
+    unsigned int value = 0;
+    signed int diff = 0;
+
+    value = pcm_in_wr_ptr();
+    diff = value - prtd->buffer_start;
+    if (diff < 0)
+        diff = 0;
+    else if (diff >= prtd->buffer_size)
+        diff = prtd->buffer_size;
+
+    pcm_debug(KERN_DEBUG "%s value: 0x%08x offset: 0x%08x\n", __FUNCTION__, value, diff);
+    return (unsigned int)diff;
+}
+
+static void aml_pcm2bt_timer_update(struct aml_pcm_runtime_data *prtd)
+{
+    struct snd_pcm_substream *substream = prtd->substream;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned int offset = 0;
+    unsigned int size = 0;
+    
+    if (prtd->running && snd_pcm_running(substream)) {
+    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    		offset = aml_pcm_offset_tx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+    	} else {
+            int rx_overflow = 0;
+    		offset = aml_pcm_offset_rx(prtd);
+            if (offset < prtd->buffer_offset) {
+                size = prtd->buffer_size + offset - prtd->buffer_offset;
+            } else {
+                size = offset - prtd->buffer_offset;
+            }
+            rx_overflow = pcm_in_fifo_int() & (1 << 2);
+            if (rx_overflow) {
+                printk(KERN_WARNING "%s AUDIN_FIFO overflow !!\n", __FUNCTION__);
+            }
+    	}
+    }
+
+    prtd->buffer_offset = offset;
+    prtd->data_size += size;
+    if (prtd->data_size >= frames_to_bytes(runtime, runtime->period_size)) {
+        prtd->peroid_elapsed++;
+    }
+
+    pcm_debug(KERN_DEBUG "%s buffer offset: %d data size: %d peroid size: %d peroid elapsed: %d\n",
+                __FUNCTION__, prtd->buffer_offset, prtd->data_size, frames_to_bytes(runtime, runtime->period_size), prtd->peroid_elapsed);
+}
+
+static void aml_pcm2bt_timer_rearm(struct aml_pcm_runtime_data *prtd)
+{
+    prtd->timer.expires = jiffies + prtd->timer_period;
+	add_timer(&prtd->timer);
+}
+
+static int aml_pcm2bt_timer_start(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+	aml_pcm2bt_timer_rearm(prtd);
+    prtd->running = 1;
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static int aml_pcm2bt_timer_stop(struct aml_pcm_runtime_data *prtd)
+{
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	spin_lock(&prtd->lock);
+    prtd->running = 0;
+	del_timer(&prtd->timer);
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+
+static void aml_pcm2bt_timer_callback(unsigned long data)
+{
+    struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	unsigned long flags;
+	unsigned int elapsed = 0;
+    unsigned int datasize = 0;
+	
+	spin_lock_irqsave(&prtd->lock, flags);
+    aml_pcm2bt_timer_update(prtd);
+    aml_pcm2bt_timer_rearm(prtd);
+	elapsed = prtd->peroid_elapsed;
+    datasize = prtd->data_size;
+    if (elapsed) {
+        prtd->peroid_elapsed--;
+        prtd->data_size -= frames_to_bytes(runtime, runtime->period_size);
+    }
+	spin_unlock_irqrestore(&prtd->lock, flags);
+	if (elapsed) {
+        if (elapsed > 1) {
+            printk(KERN_WARNING "PCM timer callback not fast enough (elapsed periods: %d data_bytes: %d period_bytes: %d)!",
+                    elapsed, datasize, frames_to_bytes(runtime, runtime->period_size));
+        }
+		snd_pcm_period_elapsed(prtd->substream);
+    }
+}
+
+static int aml_pcm2bt_timer_create(struct snd_pcm_substream *substream)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+    pcm_debug(KERN_DEBUG "%s\n", __FUNCTION__);
+	init_timer(&prtd->timer);
+    prtd->timer_period = 1;
+	prtd->timer.data = (unsigned long)substream;
+	prtd->timer.function = aml_pcm2bt_timer_callback;
+    prtd->running = 0;
+	return 0;
+}
+
+static int aml_pcm2bt_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	size_t size = params_buffer_bytes(params);
+    int ret = 0;
+
+	ret = snd_pcm_lib_malloc_pages(substream, size);
+    if (ret < 0) {
+        printk(KERN_ERR "%s snd_pcm_lib_malloc_pages return: %d\n", __FUNCTION__, ret);
+    } else {
+        prtd->buffer_start = runtime->dma_addr;
+        prtd->buffer_size = runtime->dma_bytes;
+        pcm_debug(KERN_DEBUG "%s dma_addr: 0x%08x dma_bytes: 0x%x\n", __FUNCTION__, runtime->dma_addr, runtime->dma_bytes);
+
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            aml_pcm2bt_playback_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_playback_phy_buffer_size = runtime->dma_bytes;
+        } else {
+            aml_pcm2bt_capture_phy_buffer_addr = runtime->dma_addr;
+            aml_pcm2bt_capture_phy_buffer_size = runtime->dma_bytes;
+        }
+    }
+
+    return ret;
+}
+
+static int aml_pcm2bt_hw_free(struct snd_pcm_substream *substream)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	snd_pcm_lib_free_pages(substream);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        aml_pcm2bt_playback_phy_buffer_addr = 0;
+        aml_pcm2bt_playback_phy_buffer_size = 0;
+    } else {
+        aml_pcm2bt_capture_phy_buffer_addr = 0;
+        aml_pcm2bt_capture_phy_buffer_size = 0;
+    }
+
+    return 0;
+}
+
+static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    return 0;
+#if 0
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        pcm_debug(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_tx(prtd->buffer_start, prtd->buffer_size);
+       // aml_pcm2bt_playback_buffer_addr = (unsigned int)runtime->dma_area;
+       // aml_pcm2bt_playback_buffer_size = runtime->dma_bytes;
+	} else {
+	    pcm_debug(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        aml_pcm_config_rx(prtd->buffer_start, prtd->buffer_size);
+        //aml_pcm2bt_capture_buffer_addr = (unsigned int)runtime->dma_area;
+        //aml_pcm2bt_capture_buffer_size = runtime->dma_bytes;
+	}
+
+    memset(runtime->dma_area, 0, runtime->dma_bytes);
+    prtd->buffer_offset = 0;
+    prtd->data_size = 0;
+    prtd->peroid_elapsed = 0;
+#endif
+	return 0;
+}
+
+static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+    	case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_RESUME:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+/*    	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_start_tx();
+    		else
+    			aml_pcm_start_rx();
+ */   			
+            aml_pcm2bt_timer_start(prtd);
+    		break;
+    	case SNDRV_PCM_TRIGGER_STOP:
+    	case SNDRV_PCM_TRIGGER_SUSPEND:
+    	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            aml_pcm2bt_timer_stop(prtd);
+/*    		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    			aml_pcm_stop_tx();
+    		else
+    			aml_pcm_stop_rx();
+*/
+    		break;
+    	default:
+    		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    snd_pcm_uframes_t frames;
+        
+	pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    frames = bytes_to_frames(runtime, (ssize_t)prtd->buffer_offset);
+
+	return frames;
+}
+
+static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
+
+    /* Ensure that peroid size is a multiple of 32bytes */
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_sizes);
+	if (ret < 0) {
+		printk(KERN_ERR "set period bytes constraint error\n");
+		goto out;
+	}
+
+	/* Ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+        printk(KERN_ERR "set periods constraint error\n");
+		goto out;
+    }
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+        printk(KERN_ERR "out of memory\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+    runtime->private_data = prtd;
+    aml_pcm2bt_timer_create(substream);
+    prtd->substream = substream;
+	spin_lock_init(&prtd->lock);
+
+    return 0;
+out:
+	return ret;
+}
+
+
+static int aml_pcm2bt_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+   
+    printk(KERN_INFO "enter %s type: %d\n", __FUNCTION__, substream->stream);
+    if (prtd)
+	    kfree(runtime->private_data);
+	return 0;
+}
+
+
+static int aml_pcm2bt_copy_playback(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    unsigned char* hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+    unsigned int wrptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy from user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        wrptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (wrptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            wrptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_out_set_wr_ptr(wrptr);
+    }
+
+    return ret;
+}
+
+	
+
+
+static int aml_pcm2bt_copy_capture(struct snd_pcm_runtime *runtime, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct aml_pcm_runtime_data *prtd = runtime->private_data;
+    signed short *hwbuf = (signed short*)(runtime->dma_area + frames_to_bytes(runtime, pos));
+    unsigned int rdptr = 0;
+    int ret = 0;
+
+    pcm_debug(KERN_DEBUG "enter %s channel: %d pos: %ld count: %ld\n", __FUNCTION__, channel, pos, count);
+
+	if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, count))) {
+        printk(KERN_ERR "%s copy to user failed!\n", __FUNCTION__);
+		return -EFAULT;
+    } else {
+        //memset(hwbuf, 0xff, frames_to_bytes(runtime, count));
+        rdptr = prtd->buffer_start + frames_to_bytes(runtime, pos) + frames_to_bytes(runtime, count);
+        if (rdptr >= (prtd->buffer_start + prtd->buffer_size)) {
+            rdptr = prtd->buffer_start + prtd->buffer_size;
+        }
+        pcm_in_set_rd_ptr(rdptr);
+    }
+    return ret;
+}
+
+static int aml_pcm2bt_copy(struct snd_pcm_substream *substream, int channel,
+    snd_pcm_uframes_t pos,
+    void __user *buf, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    int ret = 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        ret = aml_pcm2bt_copy_playback(runtime, channel, pos, buf, count);
+    } else {
+        ret = aml_pcm2bt_copy_capture(runtime, channel, pos, buf, count);
+    }
+
+    return ret;
+}
+
+
+static int aml_pcm2bt_silence(struct snd_pcm_substream *substream, int channel, 
+    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+    struct snd_pcm_runtime *runtime = substream->runtime;
+    unsigned char* ppos = NULL;
+    ssize_t n;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    n = frames_to_bytes(runtime, count);
+    ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+    memset(ppos, 0, n);
+
+    return 0;
+}
+                        
+static struct snd_pcm_ops aml_pcm2bt_ops = {
+	.open		= aml_pcm2bt_open,
+	.close		= aml_pcm2bt_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aml_pcm2bt_hw_params,
+	.hw_free	= aml_pcm2bt_hw_free,
+	.prepare	= aml_pcm2bt_prepare,
+	.trigger	= aml_pcm2bt_trigger,
+	.pointer	= aml_pcm2bt_pointer,
+	.copy 		= aml_pcm2bt_copy,
+	.silence	= aml_pcm2bt_silence,
+};
+
+
+/*--------------------------------------------------------------------------*\
+ * ASoC platform driver
+\*--------------------------------------------------------------------------*/
+
+static u64 aml_pcm2bt_dmamask = DMA_BIT_MASK(32);
+
+static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+    //struct aml_pcm_runtime_data *prtd = runtime->private_data;
+	size_t size = aml_pcm2bt_hardware.buffer_bytes_max;
+
+    printk(KERN_DEBUG "enter %s stream: %d\n", __FUNCTION__, stream);
+    
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area) {
+        printk(KERN_ERR "%s dma_alloc_coherent failed (size: %d)!\n", __FUNCTION__, size);
+		return -ENOMEM;
+    }
+
+	buf->bytes = size;
+    printk(KERN_INFO "%s allcoate buf->area: %p buf->addr: 0x%x buf->bytes: %d\n",
+                __FUNCTION__, buf->area, buf->addr, buf->bytes);  
+	return 0;
+}
+
+static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	int ret = 0;
+       struct snd_soc_card *card = rtd->card;
+       struct snd_pcm *pcm =rtd->pcm ;  
+       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
+       pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
+    
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &aml_pcm2bt_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = aml_pcm2bt_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void aml_pcm2bt_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+#if 0
+struct aml_audio_interface aml_pcm_interface = {
+    .id = AML_AUDIO_PCM,
+    .name = "PCM",
+    .pcm_ops = &aml_pcm2bt_ops,
+    .pcm_new = aml_pcm2bt_new,
+    .pcm_free =  aml_pcm2bt_free,
+};
+
+#endif
+
+struct snd_soc_platform_driver aml_soc_platform_pcm2bt = {
+	.ops 	= &aml_pcm2bt_ops,
+	.pcm_new	= aml_pcm2bt_new,
+	.pcm_free	= aml_pcm2bt_free,
+	//.suspend	= aml_pcm_suspend,
+	//.resume		= aml_pcm_resume,
+};
+EXPORT_SYMBOL_GPL(aml_soc_platform_pcm2bt);
+
+static int aml_soc_platform_pcm2bt_probe(struct platform_device *pdev)
+{
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
+}
+
+static int aml_soc_platform_pcm2bt_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_audio_dt_match[]={
+	{	.compatible = "amlogic,aml-pcm",
+	},
+	{},
+};
+#else
+#define amlogic_audio_dt_match NULL
+#endif
+
+
+static struct platform_driver aml_platform_pcm2bt_driver = {
+	.driver = {
+			.name = "aml-pcm",
+			.owner = THIS_MODULE,
+			.of_match_table = amlogic_audio_dt_match,
+	},
+
+	.probe = aml_soc_platform_pcm2bt_probe,
+	.remove = aml_soc_platform_pcm2bt_remove,
+};
+
+static int __init aml_alsa_bt_init(void)
+{
+	//aml_pcm_init_debugfs();		
+	return platform_driver_register(&aml_platform_pcm2bt_driver);
+}
+
+static void __exit aml_alsa_bt_exit(void)
+{
+	//aml_pcm_cleanup_debugfs();
+    platform_driver_unregister(&aml_platform_pcm2bt_driver);
+}
+
+module_init(aml_alsa_bt_init);
+module_exit(aml_alsa_bt_exit);
+
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AML audio driver for ALSA");
+
diff --git a/sound/soc/aml/m8/aml_pcm.h b/sound/soc/aml/m8/aml_pcm.h
new file mode 100644
index 000000000000..73d68658df6b
--- /dev/null
+++ b/sound/soc/aml/m8/aml_pcm.h
@@ -0,0 +1,23 @@
+#ifndef __AML_PCM_BT_H__
+#define __AML_PCM_BT_H__
+
+struct aml_pcm_runtime_data {
+	spinlock_t			lock;
+
+    dma_addr_t          buffer_start;
+    unsigned int        buffer_size;
+
+    unsigned int        buffer_offset;
+
+    unsigned int        data_size;
+
+    unsigned int        running;
+    unsigned int        timer_period;
+    unsigned int        peroid_elapsed;
+
+    struct timer_list   timer;
+    struct snd_pcm_substream *substream;
+};
+
+
+#endif
diff --git a/sound/soc/aml/m8/aml_pcm_dai.c b/sound/soc/aml/m8/aml_pcm_dai.c
new file mode 100644
index 000000000000..875e5609abbc
--- /dev/null
+++ b/sound/soc/aml/m8/aml_pcm_dai.c
@@ -0,0 +1,268 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+//#include <sound/soc-dai.h>
+
+#include "aml_pcm_dai.h"
+#include "aml_pcm.h"
+#include "aml_i2s.h"
+#include "aml_audio_hw_pcm2bt.h"
+
+
+#include <linux/of.h>
+
+#define DEV_NAME "aml-pcm-dai"
+
+//static aml_dai_info_t dai_info[3] = {{0}};
+#define AML_DAI_DEBUG
+
+
+
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
+#ifdef DEBUG_ALSA_SOC_DAI_SPDIF
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-pcm-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+
+
+static int aml_dai_pcm_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+}
+
+static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+//#if 1
+    struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aml_pcm_runtime_data *prtd = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        printk(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        pcm_out_set_buf(prtd->buffer_start, prtd->buffer_size);
+	} else {
+	    printk(KERN_DEBUG "%s capture stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
+        pcm_in_set_buf(prtd->buffer_start, prtd->buffer_size);
+	}
+
+    memset(runtime->dma_area, 0, runtime->dma_bytes);
+    prtd->buffer_offset = 0;
+    prtd->data_size = 0;
+    prtd->peroid_elapsed = 0;
+//#endif
+	return 0;
+}
+
+static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			// TODO
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu pcm playback enable\n\n");
+				pcm_out_enable(1);
+			}else{        
+                pcm_in_enable(1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				printk("aiu pcm playback disable\n\n");
+				pcm_out_enable(0);
+			}else{		
+                pcm_in_enable(0);
+				
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}	
+
+
+static int aml_dai_pcm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+static int aml_dai_set_pcm_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	if(fmt&SND_SOC_DAIFMT_CBS_CFS)
+	snd_soc_dai_get_drvdata(dai);		
+	return 0;
+}
+
+static int aml_dai_set_pcm_sysclk(struct snd_soc_dai *dai,
+					int clk_id, unsigned int freq, int dir)
+{
+#ifdef AML_DAI_DEBUG
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_dai_pcm_suspend(struct snd_soc_dai *dai)
+{
+		
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+static int aml_dai_pcm_resume(struct snd_soc_dai *dai)
+{
+  printk("***Entered %s:%s\n", __FILE__,__func__);
+  return 0;
+}
+
+#else /* CONFIG_PM */
+#define aml_dai_pcm_suspend	NULL
+#define aml_dai_pcm_resume	NULL
+#endif /* CONFIG_PM */
+
+
+#define AML_DAI_PCM_RATES		(SNDRV_PCM_RATE_8000)
+#define AML_DAI_PCM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+
+static struct snd_soc_dai_ops aml_dai_pcm_ops = {
+	.startup	= aml_dai_pcm_startup,
+	.shutdown	= aml_dai_pcm_shutdown,
+	.prepare	= aml_dai_pcm_prepare,
+	.trigger = aml_dai_pcm_trigger,
+	.hw_params	= aml_dai_pcm_hw_params,
+	.set_fmt	= aml_dai_set_pcm_fmt,
+	.set_sysclk	= aml_dai_set_pcm_sysclk,
+};
+
+
+struct snd_soc_dai_driver aml_pcm_dai[] = {
+	{	.name = DEV_NAME,
+		.id = 0,
+		.suspend = aml_dai_pcm_suspend,
+		.resume = aml_dai_pcm_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = AML_DAI_PCM_RATES,
+			.formats = AML_DAI_PCM_FORMATS,},
+		.ops = &aml_dai_pcm_ops,
+	},
+
+};
+
+EXPORT_SYMBOL_GPL(aml_pcm_dai);
+
+static const struct snd_soc_component_driver aml_component= {
+	.name		= DEV_NAME,
+};
+static int aml_pcm_dai_probe(struct platform_device *pdev)
+{
+	printk(KERN_DEBUG "enter %s\n", __func__);
+#if 0
+	BUG_ON(pdev->id < 0);
+	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
+	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
+#else
+	return snd_soc_register_component(&pdev->dev, &aml_component,
+					 aml_pcm_dai, ARRAY_SIZE(aml_pcm_dai));
+//    return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
+
+#endif
+}
+
+static int aml_pcm_dai_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-pcm-dai",
+	},
+	{},
+};
+#else
+#define amlogic_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_pcm_dai_driver = {
+	.driver = {
+		.name = DEV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_dai_dt_match,
+	},
+
+	.probe = aml_pcm_dai_probe,
+	.remove = aml_pcm_dai_remove,
+};
+
+static int __init aml_dai_modinit(void)
+{
+	return platform_driver_register(&aml_pcm_dai_driver);
+}
+module_init(aml_dai_modinit);
+
+static void __exit aml_dai_modexit(void)
+{
+	platform_driver_unregister(&aml_pcm_dai_driver);
+}
+module_exit(aml_dai_modexit);
+
+/* Module information */
+MODULE_AUTHOR("AMLogic, Inc.");
+MODULE_DESCRIPTION("AML DAI driver for ALSA");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/aml/m8/aml_pcm_dai.h b/sound/soc/aml/m8/aml_pcm_dai.h
new file mode 100644
index 000000000000..332f1da65d9d
--- /dev/null
+++ b/sound/soc/aml/m8/aml_pcm_dai.h
@@ -0,0 +1,6 @@
+#ifndef AML_DAI_H
+#define AML_DAI_H
+
+extern struct snd_soc_dai_driver aml_dai[];
+
+#endif
diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
new file mode 100644
index 000000000000..b0253d4a0f51
--- /dev/null
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -0,0 +1,101 @@
+/*
+ * ALSA SoC SPDIF CODEC driver
+ *
+ *  This driver is used by controllers which can operate in DIT (SPDI/F) where
+ *  no codec is needed.  This file provides stub codec that can be used
+ *  in these configurations. TI DaVinci Audio controller uses this driver.
+ *
+ * Author:      Steve Chen,  <schen@mvista.com>
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+
+
+#define DRV_NAME "spdif-dit"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_96000
+#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
+
+
+static struct snd_soc_codec_driver soc_codec_spdif_dit;
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "dit-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+	.capture 	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},	
+};
+
+static int spdif_dit_probe(struct platform_device *pdev)
+{
+	printk("enter spdif_dit_probe \n");
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
+			&dit_stub_dai, 1);
+}
+static int spdif_dit_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_spdif_codec_dt_match[]={
+	{	.compatible = "amlogic,aml-spdif-codec",
+	},
+	{},
+};
+#else
+#define amlogic_spdif_codec_dt_match NULL
+#endif
+
+
+static struct platform_driver spdif_dit_driver = {
+	.probe		= spdif_dit_probe,
+	.remove		= spdif_dit_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = amlogic_spdif_codec_dt_match,
+	},
+};
+static int __init spdif_codec_init(void)
+{
+	return platform_driver_register(&spdif_dit_driver);
+}
+
+static void __exit spdif_codec_exit(void)
+{
+	platform_driver_unregister(&spdif_dit_driver);
+}
+
+module_init(spdif_codec_init);
+module_exit(spdif_codec_exit);
+
+MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
+MODULE_DESCRIPTION("SPDIF dummy codec driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
new file mode 100644
index 000000000000..79feaf05dff5
--- /dev/null
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -0,0 +1,454 @@
+/*
+	Amlogic S/PDIF(HDMI)  Soc dai driver
+	author:jian.xu@amlogic.com
+*/
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/soundcard.h>
+#include <linux/timer.h>
+#include <linux/debugfs.h>
+#include <linux/major.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+#include "aml_audio_hw.h"
+#include "aml_spdif_dai.h"
+#include "aml_i2s.h"
+#include <linux/of.h>
+
+#define DEBUG_ALSA_SPDIF_DAI
+#define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
+#ifdef DEBUG_ALSA_SPDIF_DAI
+#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
+#define ALSA_TRACE()     			printk("[aml-spdif-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#else
+#define ALSA_DEBUG(fmt,args...) 
+#define ALSA_TRACE()   
+#endif
+extern int aout_notifier_call_chain(unsigned long val, void *v);
+static  unsigned  playback_substream_handle = 0 ;
+extern unsigned int IEC958_mode_codec;
+static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
+				int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	struct snd_soc_pcm_runtime *rtd = NULL;
+	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if(substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
+				ALSA_PRINT("aiu 958 playback enable\n");
+				audio_hw_958_enable(1);
+			}
+			else{
+				ALSA_PRINT("spdif in capture enable\n");				
+				audio_in_spdif_enable(1);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if(substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
+				ALSA_PRINT("aiu 958 playback disable \n");				
+				audio_hw_958_enable(0);
+			}
+			else{
+				ALSA_PRINT("spdif in capture disable\n");												
+				audio_in_spdif_enable(0);
+			}	
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+/*
+special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
+1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
+2)PCM  output for  all audio, when pcm mode is selected by user .
+3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
+*/
+static unsigned set_clock = 0;
+static void aml_hw_iec958_init(struct snd_pcm_substream *substream)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	_aiu_958_raw_setting_t set;
+	_aiu_958_channel_status_t chstat;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;	
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    if(buf==NULL && runtime==NULL){
+        printk("buf/0x%x runtime/0x%x\n",(unsigned )buf,(unsigned )runtime);
+        return;
+    }
+	unsigned i2s_mode,iec958_mode;	
+	unsigned start,size,sample_rate;
+	sample_rate = AUDIO_CLK_FREQ_48;
+	memset((void*)(&set), 0, sizeof(set));
+	memset((void*)(&chstat), 0, sizeof(chstat));
+	set.chan_stat = &chstat;
+	switch(runtime->rate){
+		case 192000:
+			sample_rate	=	AUDIO_CLK_FREQ_192;
+			break;
+		case 176400:
+			sample_rate	=	AUDIO_CLK_FREQ_1764;
+			break;
+		case 96000:
+			sample_rate	=	AUDIO_CLK_FREQ_96;
+			break;
+		case 88200:
+			sample_rate	=	AUDIO_CLK_FREQ_882;
+			break;
+		case 48000:
+			sample_rate	=	AUDIO_CLK_FREQ_48;
+			break;
+		case 44100:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+		case 32000:
+			sample_rate	=	AUDIO_CLK_FREQ_32;
+			break;
+		case 8000:
+			sample_rate	=	AUDIO_CLK_FREQ_8;
+			break;
+		case 11025:
+			sample_rate	=	AUDIO_CLK_FREQ_11;
+			break;
+		case 16000:
+			sample_rate	=	AUDIO_CLK_FREQ_16;
+			break;
+		case 22050:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		case 12000:
+			sample_rate	=	AUDIO_CLK_FREQ_12;
+			break;
+		case 24000:
+			sample_rate	=	AUDIO_CLK_FREQ_22;
+			break;
+		default:
+			sample_rate	=	AUDIO_CLK_FREQ_441;
+			break;
+	};		
+    printk(KERN_INFO "enterd %s,set_clock:%d,sample_rate=%d\n",__func__,set_clock,sample_rate);
+    if(set_clock != sample_rate){
+        set_clock = sample_rate;
+        audio_set_958_clk(sample_rate, AUDIO_CLK_256FS);
+    }
+	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+
+	switch(runtime->format){
+	case SNDRV_PCM_FORMAT_S32_LE:
+		i2s_mode = AIU_I2S_MODE_PCM32;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s_mode = AIU_I2S_MODE_PCM24;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		i2s_mode = AIU_I2S_MODE_PCM16;
+		break;
+	}	
+	printk("DEBUG-->call audio_set_i2s_mode()\n");
+	//audio_set_i2s_mode(i2s_mode);
+	/* case 1,raw mode enabled */
+	if(IEC958_mode_codec){
+		if(IEC958_mode_codec == 1){ //dts, use raw sync-word mode
+			iec958_mode = AIU_958_MODE_RAW;
+			printk("iec958 mode RAW\n");
+		}
+		else{ //ac3,use the same pcm mode as i2s configuration
+			iec958_mode = AIU_958_MODE_PCM_RAW;
+			printk("iec958 mode %s\n",(i2s_mode == AIU_I2S_MODE_PCM32)?"PCM32_RAW":((I2S_MODE == AIU_I2S_MODE_PCM24)?"PCM24_RAW":"PCM16_RAW"));
+		}
+	}
+	else{
+		if(i2s_mode == AIU_I2S_MODE_PCM32)
+				iec958_mode = AIU_958_MODE_PCM32;
+		else if(i2s_mode == AIU_I2S_MODE_PCM24)
+				iec958_mode = AIU_958_MODE_PCM24;
+		else
+				iec958_mode = AIU_958_MODE_PCM16;
+		printk("iec958 mode %s\n",(i2s_mode == AIU_I2S_MODE_PCM32)?"PCM32":((i2s_mode == AIU_I2S_MODE_PCM24)?"PCM24":"PCM16"));
+	}
+	if(iec958_mode == AIU_958_MODE_PCM16 || iec958_mode == AIU_958_MODE_PCM24 ||
+		iec958_mode == AIU_958_MODE_PCM32){
+		set.chan_stat->chstat0_l = 0x0100;
+		set.chan_stat->chstat0_r = 0x0100;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		start = buf->addr;
+		size = snd_pcm_lib_buffer_bytes(substream);
+		audio_set_958outbuf(start, size, 0);
+		//audio_set_i2s_mode(AIU_I2S_MODE_PCM16);
+		//audio_set_aiubuf(start, size);		
+	}else{
+		set.chan_stat->chstat0_l = 0x1902;//NONE-PCM
+		set.chan_stat->chstat0_r = 0x1902;
+		set.chan_stat->chstat1_l = 0X200;
+		set.chan_stat->chstat1_r = 0X200;
+		start = buf->addr;
+		size = snd_pcm_lib_buffer_bytes(substream);;
+		audio_set_958outbuf(start, size, (iec958_mode == AIU_958_MODE_RAW)?1:0);
+		memset((void*)buf->area,0,size);
+	}
+	printk("aiu 958 pcm buffer size %d \n",size);	
+	audio_set_958_mode(iec958_mode, &set);
+	if(IEC958_mode_codec == 4)  //dd+
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 0, 4, 2); // 4x than i2s
+	else
+#if OVERCLOCK == 1 || IEC958_OVERCLOCK == 1	
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 3, 4, 2);//512fs divide 4 == 128fs
+#else
+		WRITE_MPEG_REG_BITS(AIU_CLK_CTRL, 1, 4, 2); //256fs divide 2 == 128fs
+#endif
+        if(IEC958_mode_codec == 2){
+                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_AC_3,substream);
+        }
+        else if(IEC958_mode_codec == 3){
+                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS,substream);
+        }
+        else if(IEC958_mode_codec == 4){
+                aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS,substream);
+        }
+        else{
+	        aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,substream);
+        }
+}
+/*
+special call by the audiodsp,add these code,as there are three cases for 958 s/pdif output
+1)NONE-PCM  raw output ,only available when ac3/dts audio,when raw output mode is selected by user.
+2)PCM  output for  all audio, when pcm mode is selected by user .
+3)PCM  output for audios except ac3/dts,when raw output mode is selected by user
+*/
+
+
+void	aml_alsa_hw_reprepare(void)
+{
+    ALSA_TRACE();
+	/* diable 958 module before call initiation */
+	audio_hw_958_enable(0);
+   if(playback_substream_handle!=0)
+  	aml_hw_iec958_init((struct snd_pcm_substream *)playback_substream_handle);
+}
+static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{	  	
+	ALSA_DEBUG();
+    	ALSA_TRACE();	
+	int ret = 0;
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s;	
+	if(!prtd){
+		prtd = (struct aml_runtime_data *)kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
+		if (prtd == NULL) {
+			printk("alloc aml_runtime_data error\n");
+			ret = -ENOMEM;
+			goto out;
+		}
+		prtd->substream = substream;
+		runtime->private_data = prtd;		
+	}
+	s = &prtd->s; 
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		s->device_type = AML_AUDIO_SPDIFOUT;
+		audio_spdifout_pg_enable(1);
+	}	
+	else{
+		s->device_type = AML_AUDIO_SPDIFIN;
+	}	
+		
+	return 0;
+out:
+	return ret;
+}
+static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    	ALSA_TRACE();	
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;	
+		
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		memset((void*)runtime->dma_area,0,snd_pcm_lib_buffer_bytes(substream));
+
+		audio_spdifout_pg_enable(0);	
+	}
+	
+}
+
+
+static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;	
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		if(playback_substream_handle != (unsigned)substream)
+			playback_substream_handle = (unsigned)substream;
+		aml_hw_iec958_init((struct snd_pcm_substream *)playback_substream_handle);		
+	}	
+	else{
+		audio_in_spdif_set_buf(runtime->dma_addr, runtime->dma_bytes*2);
+		memset((void*)runtime->dma_area,0,runtime->dma_bytes*2);
+		{
+			int * ppp = (int*)(runtime->dma_area+runtime->dma_bytes*2-8);
+			ppp[0] = 0x78787878;
+			ppp[1] = 0x78787878;
+		}		
+	}	
+
+	return 0;
+}
+static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *socdai)
+{
+	ALSA_DEBUG();
+    ALSA_TRACE();
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    	struct snd_pcm_runtime *runtime = substream->runtime;
+    	struct aml_runtime_data *prtd = runtime->private_data;
+	audio_stream_t *s = &prtd->s;
+	return 0;
+}
+
+
+
+#ifdef CONFIG_PM
+static int aml_dai_spdif_suspend(struct snd_soc_dai *cpu_dai)
+{
+
+	return 0;
+}
+
+static int aml_dai_spdif_resume(struct snd_soc_dai *cpu_dai)
+{
+
+
+	return 0;
+}
+#else
+#define aml_spdif_suspend NULL
+#define aml_spdif_resume NULL
+#endif
+
+static struct snd_soc_dai_ops spdif_dai_ops = {
+	.set_sysclk	= aml_dai_spdif_set_sysclk,
+	.trigger	= aml_dai_spdif_trigger,
+	.prepare = aml_dai_spdif_prepare,
+	.hw_params	= aml_dai_spdif_hw_params,
+	.shutdown	= aml_dai_spdif_shutdown,
+	.startup	= aml_dai_spdif_startup,	
+};
+
+static struct snd_soc_dai_driver aml_spdif_dai[] = {
+	{
+		.name = "aml-spdif-dai",
+		.playback = {
+			.stream_name = "S/PDIF Playback",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = (
+					SNDRV_PCM_RATE_32000 |
+					SNDRV_PCM_RATE_44100 |
+					SNDRV_PCM_RATE_48000 |
+					SNDRV_PCM_RATE_96000),
+			.formats = SNDRV_PCM_FMTBIT_S16_LE, },
+		.capture = {
+			.stream_name = "S/PDIF Capture",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = (SNDRV_PCM_RATE_32000 |
+					SNDRV_PCM_RATE_44100 |
+					SNDRV_PCM_RATE_48000 |
+					SNDRV_PCM_RATE_96000),
+			.formats = SNDRV_PCM_FMTBIT_S16_LE, },			
+		.ops = &spdif_dai_ops,
+		.suspend = aml_dai_spdif_suspend,
+		.resume = aml_dai_spdif_resume,
+	}	
+};
+static const struct snd_soc_component_driver aml_component= {
+	.name		= "aml-spdif-dai",
+};
+static  int aml_dai_spdif_probe(struct platform_device *pdev)
+{
+	printk("aml_spdif_probe \n");
+	return snd_soc_register_component(&pdev->dev, &aml_component,
+					 aml_spdif_dai, ARRAY_SIZE(aml_spdif_dai));}
+
+static  int aml_dai_spdif_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_spdif_dai_dt_match[]={
+	{	.compatible = "amlogic,aml-spdif-dai",
+	},
+	{},
+};
+#else
+#define amlogic_spdif_dai_dt_match NULL
+#endif
+
+static struct platform_driver aml_spdif_dai_driver = {
+	.probe	= aml_dai_spdif_probe,
+	.remove	= aml_dai_spdif_remove,
+	.driver	= {
+		.name	= "aml-spdif-dai",
+		.owner	= THIS_MODULE,
+		.of_match_table = amlogic_spdif_dai_dt_match,
+	},
+};
+
+static int __init aml_dai_spdif_init(void)
+{
+	printk("enter aml_dai_spdif_init \n");
+	return platform_driver_register(&aml_spdif_dai_driver);
+}
+module_init(aml_dai_spdif_init);
+
+static void __exit aml_dai_spdif_exit(void)
+{
+	platform_driver_unregister(&aml_spdif_dai_driver);
+}
+module_exit(aml_dai_spdif_exit);
+
+MODULE_AUTHOR("jian.xu, <jian.xu@amlogic.com>");
+MODULE_DESCRIPTION("Amlogic S/PDIF<HDMI> Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:aml-spdif");
+
+
diff --git a/sound/soc/aml/m8/aml_spdif_dai.h b/sound/soc/aml/m8/aml_spdif_dai.h
new file mode 100644
index 000000000000..ee5c08a5c58c
--- /dev/null
+++ b/sound/soc/aml/m8/aml_spdif_dai.h
@@ -0,0 +1,16 @@
+/* HDMI audio stream type ID */
+#define AOUT_EVENT_IEC_60958_PCM                0x1
+#define AOUT_EVENT_RAWDATA_AC_3                 0x2
+#define AOUT_EVENT_RAWDATA_MPEG1                0x3
+#define AOUT_EVENT_RAWDATA_MP3                  0x4
+#define AOUT_EVENT_RAWDATA_MPEG2                0x5
+#define AOUT_EVENT_RAWDATA_AAC                  0x6
+#define AOUT_EVENT_RAWDATA_DTS                  0x7
+#define AOUT_EVENT_RAWDATA_ATRAC                0x8
+#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
+#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
+#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
+#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
+#define AOUT_EVENT_RAWDATA_DST                  0xD
+#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
+
-- 
2.19.0

