From 12870ce9bc903720a9545ecd91036d4ddb27c966 Mon Sep 17 00:00:00 2001
From: "tao.zeng" <tao.zeng@amlogic.com>
Date: Tue, 17 Dec 2013 20:36:39 +0800
Subject: [PATCH 2911/5965] PD #00002: Import dvfs for M6

Conflicts:

	arch/arm/configs/meson6_defconfig
---
 arch/arm/boot/dts/amlogic/meson6_g18.dtd      |  124 +-
 arch/arm/boot/dts/amlogic/meson6_g24.dtd      |  104 +-
 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd   |  127 +-
 arch/arm/boot/dts/amlogic/meson6_skt.dtd      |  124 +-
 arch/arm/configs/meson6_defconfig             |    5 +
 drivers/amlogic/cpufreq/meson-cpufreq.c       |    4 +-
 drivers/amlogic/power/aml_dvfs/aml_dvfs.c     |  124 +-
 .../meson_cs_dcdc_regulator.c                 | 1438 ++++++++++-------
 .../linux/amlogic/meson_cs_dcdc_regulator.h   |   30 +
 9 files changed, 1277 insertions(+), 803 deletions(-)
 create mode 100755 include/linux/amlogic/meson_cs_dcdc_regulator.h

diff --git a/arch/arm/boot/dts/amlogic/meson6_g18.dtd b/arch/arm/boot/dts/amlogic/meson6_g18.dtd
index e897a8eba475..600457351819 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g18.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g18.dtd
@@ -203,62 +203,78 @@
 		compatible = "amlogic,pm";
 		dev_name = "aml_pm";
 	};
-	
-	meson-cs-regulator{
-		compatible = "amlogic,meson-cs-regulator";
-		dev_name = "meson-cs-regulator";
-		default_uV = <1110000>;
-		consumer_supplies-supply = "vcck-armcore";
-		init-data = <&vcck_init_data>;
-		vcck-table = <&vcck_opp_table>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&aml_pwm_pins>;
-			
-		voltage_step_table = <
-			1400000 1380000 1350000 1330000
-			1300000 1280000 1260000 1240000
-			1210000 1180000 1140000 1110000
-			1070000 1040000 1010000   970000
-		>;
-
-		vcck_pwm_table = <
-		    0x00001c 0x01001b 0x030019 0x040018
-	        0x060016 0x070015 0x080014 0x090013
-	        0x0b0011 0x0d000f 0x0f000d 0x11000b 
-	        0x130009 0x150007 0x170005 0x190003
-		>;
-			
-		vcck_init_data: vcck_init_data{
-			cons_name = "vcck";
-			min_uV = <1010000>;
-			max_uV = <1380000>;
-			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
-			num = <1>;	/*the number of vcck_data-supply*/
-			vcck_data-supply = "vcck-armcore";	
-		};
-			
-		vcck_opp_table: vcck_opp_table{
-			num = <11>;
-			table = <
-			1500000 1330000 1330000
-			1320000 1330000 1330000
-			1200000 1260000 1260000
-			1080000 1240000 1240000
-			1000000 1140000 1140000
-			  984000 1140000 1140000
-			  840000 1110000 1110000
-			  816000 1110000 1110000
-			  792000 1040000 1040000
-			  600000 1040000 1040000
-			  200000 1040000 1040000
-			>;
-		};
-	};
 
     cpufreq-meson{
-		compatible = "amlogic,cpufreq-meson";
-		cpufreq_info = <&vcck_opp_table>;
-	};
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+
+    meson_vcck_dvfs_driver{
+        compatible = "amlogic, meson_vcck_dvfs";
+        default_uV = <1110000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&aml_pwm_pins>;
+        use_pwm = <1>; 
+        table_count = <16>;
+        cs_voltage_table = <
+        /*   
+         * Note: This table is hardware depended, If your hardware use PWM method,
+         * then first line in this table is PWM register value, second line is
+         * voltage of VCCK according this PWM register value. If your platform use
+         * constant-current source to adjust vcck voltage, then the first line should 
+         * set to 0, means not valid, member 'use_pwm' in this node should set to 0.
+         *
+         *  ---- This table must be in ascending order by voltage ----
+         *    
+         *  PWM value       VCCK voltage 
+         */   
+            0x190003         970000
+            0x170005        1010000
+            0x150007        1040000
+            0x130009        1070000
+            0x11000b        1110000
+            0x0f000d        1140000
+            0x0d000f        1180000
+            0x0b0011        1210000
+            0x090013        1240000
+            0x080014        1260000
+            0x070015        1280000
+            0x060016        1300000
+            0x040018        1330000
+            0x030019        1350000
+            0x01001b        1380000
+            0x00001c        1400000
+        >;   
+    };   
+
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <11>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+                /* NOTE: frequent in this table must be ascending order */
+                /* frequent(Khz)    min_uV      max_uV                  */
+                 200000             1040000     1040000
+                 600000             1040000     1040000
+                 792000             1040000     1040000
+                 816000             1110000     1110000
+                 840000             1110000     1110000
+                 984000             1140000     1140000
+                1000000             1140000     1140000
+                1080000             1240000     1240000
+                1200000             1260000     1260000
+                1320000             1330000     1330000
+                1500000             1330000     1330000
+            >;
+
+    };
+
+
 	
 	i2c@c8100500{ /*I2C-AO*/
 		compatible = "amlogic,aml_i2c";
diff --git a/arch/arm/boot/dts/amlogic/meson6_g24.dtd b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
index db0fc6eca3cc..9c1dc2e74173 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g24.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
@@ -185,48 +185,70 @@
 		compatible = "amlogic,pm";
 		dev_name = "aml_pm";
 	};
-	meson-cs-regulator{
-		compatible = "amlogic,meson-cs-regulator";
-		dev_name = "meson-cs-regulator";
-		default_uV = <1307000>;
-		consumer_supplies-supply = "vcck-armcore";
-		init-data = <&vcck_init_data>;
-		vcck-table = <&vcck_opp_table>;
-			
-		voltage_step_table = <
-			1307000 1298000 1277000 1255000
-			1234000 1212000 1190000 1169000
-			1147000 1126000 1104000 1082000
-			1061000 1039000 1018000  996000
-		>;
-					
-		vcck_init_data: vcck_init_data{
-			cons_name = "vcck";
-			min_uV = <996000>;
-			max_uV = <1307000>;
-			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
-			num = <1>;	/*the number of vcck_data-supply*/
-			vcck_data-supply = "vcck-armcore";	
-		};
-			
-		vcck_opp_table: vcck_opp_table{
-			num = <7>;
-			table = <
-			1500000 1307000 1307000
-			1320000 1298000 1298000
-			1200000 1212000 1212000
-			1080000 1147000 1147000
-			840000  1104000 1104000
-			600000  1039000 1039000
-			200000  996000  996000
-			>;
-		};
-	};
+    cpufreq-meson{
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+    meson_vcck_dvfs_driver{
+        compatible = "amlogic, meson_vcck_dvfs";
+        default_uV = <1307000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&aml_pwm_pins>;
+        use_pwm = <0>; 
+        table_count = <16>;
+        cs_voltage_table = <
+        /*   
+         * Note: This table is hardware depended, If your hardware use PWM method,
+         * then first line in this table is PWM register value, second line is
+         * voltage of VCCK according this PWM register value. If your platform use
+         * constant-current source to adjust vcck voltage, then the first line should 
+         * set to 0, means not valid, member 'use_pwm' in this node should set to 0.
+         *
+         *  ---- This table must be in ascending order by voltage ----
+         *    
+         *  PWM value       VCCK voltage 
+         */   
+            0x0              996000
+            0x0             1018000
+            0x0             1039000
+            0x0             1061000
+            0x0             1082000
+            0x0             1104000
+            0x0             1126000
+            0x0             1147000
+            0x0             1169000
+            0x0             1190000
+            0x0             1212000
+            0x0             1234000
+            0x0             1255000
+            0x0             1277000
+            0x0             1298000
+            0x0             1307000
+        >;   
+    };   
 
-	cpufreq-meson{
-		compatible = "amlogic,cpufreq-meson";
-		cpufreq_info = <&vcck_opp_table>;
-	};
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <7>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+                /* NOTE: frequent in this table must be ascending order */
+                /* frequent(Khz)    min_uV      max_uV                  */
+                 200000              996000      996000
+                 600000             1039000     1039000
+                 840000             1104000     1104000
+                1080000             1147000     1147000
+                1200000             1212000     1212000
+                1320000             1298000     1298000
+                1500000             1307000     1307000
+            >;
+        };
+    };
 
     battery_parameter:battery_parameter{
         pmu_twi_id = <2>;                   /* AXP20_I2CBUS                         */
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
index 3dd9623519ca..ef5b3d9188b7 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
@@ -202,62 +202,77 @@
 		compatible = "amlogic,pm";
 		dev_name = "aml_pm";
 	};
- 	meson-cs-regulator{
- 		compatible = "amlogic,meson-cs-regulator";
- 		dev_name = "meson-cs-regulator";
-		default_uV = <1280000>;
- 		consumer_supplies-supply = "vcck-armcore";
- 		init-data = <&vcck_init_data>;
- 		vcck-table = <&vcck_opp_table>;
- 		pinctrl-names = "default";
-		pinctrl-0 = <&aml_pwm_pins>;
- 			
- 		vcck_pwm_table = <	
- 		    0x040018 0x050017 0x060016 0x070015 
-	        0x080014 0x090013 0x0a0012 0x0b0011
-	        0x0c0010 0x0d000f 0x0e000e 0x0f000d
-	        0x10000c 0x11000b 0x12000a 0x130009
-	    >;
-		
- 		voltage_step_table = <
-			1320000 1300000 1280000 1270000
-			1240000 1220000 1210000 1190000
-			1170000 1150000 1130000 1110000
-			1090000 1070000 1050000 1010000
- 		>;
- 					
- 		vcck_init_data: vcck_init_data{
- 			cons_name = "vcck";
-			min_uV = <1000000>;
-			max_uV = <1400000>;
- 			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
- 			num = <1>;	/*the number of vcck_data-supply*/
- 			vcck_data-supply = "vcck-armcore";	
- 		};
- 			
- 		vcck_opp_table: vcck_opp_table{
-			num = <11>;
- 			table = <
-			1500000 1320000 1320000
-			1320000 1320000 1320000
-			1200000 1240000 1240000
-			1080000 1220000 1220000
-			1000000 1110000 1110000
-			  984000 1110000 1110000
-			  840000 1110000 1110000
-			  816000 1110000 1110000
-			  792000 1010000 1010000
-			  600000 1010000 1010000
-			  200000 1010000 1010000
- 			>;
- 		};
- 	};
- 	
- 	 cpufreq-meson{
-		compatible = "amlogic,cpufreq-meson";
-//		cpufreq_info = <&vcck_opp_table>;
-	};
- 	
+
+    cpufreq-meson{
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+
+    meson_vcck_dvfs_driver{
+        compatible = "amlogic, meson_vcck_dvfs";
+        default_uV = <1280000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&aml_pwm_pins>;
+        use_pwm = <1>; 
+        table_count = <16>;
+        cs_voltage_table = <
+        /*   
+         * Note: This table is hardware depended, If your hardware use PWM method,
+         * then first line in this table is PWM register value, second line is
+         * voltage of VCCK according this PWM register value. If your platform use
+         * constant-current source to adjust vcck voltage, then the first line should 
+         * set to 0, means not valid, member 'use_pwm' in this node should set to 0.
+         *
+         *  ---- This table must be in ascending order by voltage ----
+         *    
+         *  PWM value       VCCK voltage 
+         */   
+            0x130009        1010000
+            0x12000a        1050000
+            0x11000b        1070000
+            0x10000c        1090000
+            0x0f000d        1110000
+            0x0e000e        1130000
+            0x0d000f        1150000
+            0x0c0010        1170000
+            0x0b0011        1190000
+            0x0a0012        1210000
+            0x090013        1220000
+            0x080014        1240000
+            0x070015        1270000
+            0x060016        1280000
+            0x050017        1300000
+            0x040018        1320000
+        >;   
+    };   
+
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <11>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+                /* NOTE: frequent in this table must be ascending order */
+                /* frequent(Khz)    min_uV      max_uV                  */
+                 200000             1010000     1010000
+                 600000             1010000     1010000
+                 792000             1010000     1010000
+                 816000             1110000     1110000
+                 840000             1110000     1110000
+                 984000             1110000     1110000
+                1000000             1110000     1110000
+                1080000             1220000     1220000
+                1200000             1240000     1240000
+                1320000             1320000     1320000
+                1500000             1320000     1320000
+            >;
+        };
+    };
+
     battery_parameter:battery_parameter{
         pmu_twi_id = <2>;                   /* AXP20_I2CBUS                         */
         pmu_irq_id = <0>;                   /* INT_WATCHDOG                         */
diff --git a/arch/arm/boot/dts/amlogic/meson6_skt.dtd b/arch/arm/boot/dts/amlogic/meson6_skt.dtd
index a3c6ba9a2e64..9149db616573 100755
--- a/arch/arm/boot/dts/amlogic/meson6_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_skt.dtd
@@ -202,62 +202,78 @@
 		compatible = "amlogic,pm";
 		dev_name = "aml_pm";
 	};
-	
-	meson-cs-regulator{
-		compatible = "amlogic,meson-cs-regulator";
-		dev_name = "meson-cs-regulator";
-		default_uV = <1110000>;
-		consumer_supplies-supply = "vcck-armcore";
-		init-data = <&vcck_init_data>;
-		vcck-table = <&vcck_opp_table>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&aml_pwm_pins>;
-			
-		voltage_step_table = <
-			1400000 1380000 1350000 1330000
-			1300000 1280000 1260000 1240000
-			1210000 1180000 1140000 1110000
-			1070000 1040000 1010000   970000
-		>;
-
-		vcck_pwm_table = <
-		    0x00001c 0x01001b 0x030019 0x040018
-	        0x060016 0x070015 0x080014 0x090013
-	        0x0b0011 0x0d000f 0x0f000d 0x11000b 
-	        0x130009 0x150007 0x170005 0x190003
-		>;
-			
-		vcck_init_data: vcck_init_data{
-			cons_name = "vcck";
-			min_uV = <1010000>;
-			max_uV = <1380000>;
-			valid_ops_mask = <0x9>; /*REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS */
-			num = <1>;	/*the number of vcck_data-supply*/
-			vcck_data-supply = "vcck-armcore";	
-		};
-			
-		vcck_opp_table: vcck_opp_table{
-			num = <11>;
-			table = <
-			1500000 1330000 1330000
-			1320000 1330000 1330000
-			1200000 1260000 1260000
-			1080000 1240000 1240000
-			1000000 1140000 1140000
-			  984000 1140000 1140000
-			  840000 1110000 1110000
-			  816000 1110000 1110000
-			  792000 1040000 1040000
-			  600000 1040000 1040000
-			  200000 1040000 1040000
-			>;
-		};
-	};
 
     cpufreq-meson{
-		compatible = "amlogic,cpufreq-meson";
-		cpufreq_info = <&vcck_opp_table>;
-	};
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+
+    meson_vcck_dvfs_driver{
+        compatible = "amlogic, meson_vcck_dvfs";
+        default_uV = <1110000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&aml_pwm_pins>;
+        use_pwm = <1>; 
+        table_count = <16>;
+        cs_voltage_table = <
+        /*   
+         * Note: This table is hardware depended, If your hardware use PWM method,
+         * then first line in this table is PWM register value, second line is
+         * voltage of VCCK according this PWM register value. If your platform use
+         * constant-current source to adjust vcck voltage, then the first line should 
+         * set to 0, means not valid, member 'use_pwm' in this node should set to 0.
+         *
+         *  ---- This table must be in ascending order by voltage ----
+         *    
+         *  PWM value       VCCK voltage 
+         */   
+            0x190003         970000
+            0x170005        1010000
+            0x150007        1040000
+            0x130009        1070000
+            0x11000b        1110000
+            0x0f000d        1140000
+            0x0d000f        1180000
+            0x0b0011        1210000
+            0x090013        1240000
+            0x080014        1260000
+            0x070015        1280000
+            0x060016        1300000
+            0x040018        1330000
+            0x030019        1350000
+            0x01001b        1380000
+            0x00001c        1400000
+        >;   
+    };   
+
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <11>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+                /* NOTE: frequent in this table must be ascending order */
+                /* frequent(Khz)    min_uV      max_uV                  */
+                 200000             1040000     1040000
+                 600000             1040000     1040000
+                 792000             1040000     1040000
+                 816000             1110000     1110000
+                 840000             1110000     1110000
+                 984000             1140000     1140000
+                1000000             1140000     1140000
+                1080000             1240000     1240000
+                1200000             1260000     1260000
+                1320000             1330000     1330000
+                1500000             1330000     1330000
+            >;
+
+    };
+
+
 	
 	i2c@c8100500{ /*I2C-AO*/
 		compatible = "amlogic,aml_i2c";
diff --git a/arch/arm/configs/meson6_defconfig b/arch/arm/configs/meson6_defconfig
index 1d771b1611c8..877f01673432 100755
--- a/arch/arm/configs/meson6_defconfig
+++ b/arch/arm/configs/meson6_defconfig
@@ -23,6 +23,11 @@ CONFIG_HIGHMEM=y
 # CONFIG_COMPACTION is not set
 CONFIG_CPU_FREQ=y
 CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE=y
+CONFIG_AMLOGIC_MESON_CPUFREQ=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
 # CONFIG_CPU_FREQ_GOV_HOTPLUG is not set
 CONFIG_VFP=y
 CONFIG_NEON=y
diff --git a/drivers/amlogic/cpufreq/meson-cpufreq.c b/drivers/amlogic/cpufreq/meson-cpufreq.c
index e99c02cf11e1..2945711a49ef 100755
--- a/drivers/amlogic/cpufreq/meson-cpufreq.c
+++ b/drivers/amlogic/cpufreq/meson-cpufreq.c
@@ -394,8 +394,8 @@ static int __init meson_cpufreq_probe(struct platform_device *pdev)
 
 static int __exit meson_cpufreq_remove(struct platform_device *pdev)
 {
-#ifdef CONFIGG_USE_OF
-	kfree(pdev->dev->platform_data);
+#ifdef CONFIG_USE_OF
+	kfree(pdev->dev.platform_data);
 	//kfree(vcck_opp_table);
 #endif
 
diff --git a/drivers/amlogic/power/aml_dvfs/aml_dvfs.c b/drivers/amlogic/power/aml_dvfs/aml_dvfs.c
index f0914bc4fbce..0b1cb443173b 100755
--- a/drivers/amlogic/power/aml_dvfs/aml_dvfs.c
+++ b/drivers/amlogic/power/aml_dvfs/aml_dvfs.c
@@ -5,6 +5,12 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/sched.h>
 
 #define DVFS_DBG(format, args...) \
     if (1) printk(KERN_ERR "[DVFS]"format, ##args)
@@ -195,6 +201,119 @@ struct aml_dvfs_driver aml_dummy_dvfs_driver = {
     .get_voltage = NULL,
 };
 
+static ssize_t dvfs_help(struct class *class, struct class_attribute *attr,   char *buf)
+{
+    return sprintf(buf, 
+                   "HELP:\n"
+                   "    echo r [name] > dvfs            ---- read voltage of [name]\n"
+                   "    echo w [name] [value] > dvfs    ---- write voltage of [name] to [value]\n"
+                   "\n"
+                   "EXAMPLE:\n"
+                   "    echo r vcck > dvfs              ---- read current voltage of vcck\n"
+                   "    echo w vcck 1100000 > dvfs      ---- set voltage of vcck to 1.1v\n"
+                   "\n"
+                   "Supported names:\n"
+                   "    vcck    ---- voltage of ARM core\n"
+                   "    vddee   ---- voltage of VDDEE(everything else)\n"
+                   "    ddr     ---- voltage of DDR\n"
+    );
+}
+
+static int get_dvfs_id_by_name(char *str)
+{
+    if (!strncmp(str, "vcck", 4)) {
+        return AML_DVFS_ID_VCCK;    
+    } else if (!strncmp(str, "vddee", 5)) {
+        return AML_DVFS_ID_VDDEE;    
+    } else if (!strncmp(str, "ddr", 3)) {
+        return AML_DVFS_ID_DDR;    
+    }
+    return -1;
+}
+
+static ssize_t dvfs_class_write(struct class *class, struct class_attribute *attr,   const char *buf, size_t count)
+{
+    int ret = -1;
+    int  id, i;
+    unsigned int uV;
+    char *arg[3] = {}, *para, *buf_work, *p;
+    struct aml_dvfs_master  *master;
+    struct list_head        *element;
+
+    buf_work = kstrdup(buf, GFP_KERNEL);
+    p = buf_work;
+    for (i = 0; i < 3; i++) {
+        para = strsep(&p, " ");
+        if (para == NULL) {
+            break;
+        }    
+        arg[i] = para;
+    }    
+    if (i < 2 || i > 3) { 
+        ret = 1; 
+        goto error;
+    } 
+
+    switch (arg[0][0]) {
+    case 'r':
+        id = get_dvfs_id_by_name(arg[1]);
+        if (id < 0) {
+            goto error;    
+        }
+        list_for_each(element, &__aml_dvfs_list) {
+            master = list_entry(element, struct aml_dvfs_master, list); 
+            if (master->id == id) {
+                mutex_lock(&master->mutex);
+                if (master->driver->get_voltage) {
+                    ret = master->driver->get_voltage(id, &uV);
+                } 
+                mutex_unlock(&master->mutex);
+            }
+        }
+        if (ret < 0) {
+            printk("get voltage of %s failed\n", arg[1]);    
+        } else {
+            printk("voltage of %s is %d\n", arg[1], uV); 
+        }
+        break;
+
+    case 'w':
+        if (i != 3) {
+            goto error;    
+        }
+        id = get_dvfs_id_by_name(arg[1]);
+        if (id < 0) {
+            goto error;    
+        }
+        uV = simple_strtoul(arg[2], NULL, 10); 
+        list_for_each(element, &__aml_dvfs_list) {
+            master = list_entry(element, struct aml_dvfs_master, list); 
+            if (master->id == id) {
+                mutex_lock(&master->mutex);
+                if (master->driver->set_voltage) {
+                    ret = master->driver->set_voltage(id, uV, uV);
+                } 
+                mutex_unlock(&master->mutex);
+            }
+        }
+        if (ret < 0) {
+            printk("set vcck to %d uV failed\n", uV);    
+        } else {
+            printk("set vcck to %d uV success\n", uV);    
+        }
+        break;
+    }
+error:
+    kfree(buf_work);
+    if (ret) {
+        printk(" error\n");    
+    }
+    return count; 
+}
+
+static CLASS_ATTR(dvfs, S_IWUSR | S_IRUGO, dvfs_help, dvfs_class_write);
+struct class *aml_dvfs_class;
+
 struct cpufreq_frequency_table *aml_dvfs_get_freq_table(unsigned int id)
 {
     struct aml_dvfs_master  *master;
@@ -298,7 +417,8 @@ static int aml_dvfs_probe(struct platform_device *pdev)
         }
     }
 
-    return 0;
+    aml_dvfs_class = class_create(THIS_MODULE, "dvfs");
+    return class_create_file(aml_dvfs_class, &class_attr_dvfs);
 }
 
 static int aml_dvfs_remove(struct platform_device *pdev)
@@ -306,13 +426,13 @@ static int aml_dvfs_remove(struct platform_device *pdev)
     struct list_head *element;
     struct aml_dvfs_master *master;
 
+    class_destroy(aml_dvfs_class); 
     list_for_each(element, &__aml_dvfs_list) {
         master = list_entry(element, struct aml_dvfs_master, list);
         kfree(master->freq_table);
         kfree(master->table);
         kfree(master);
     }
-    
     return 0;
 }
 
diff --git a/drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c b/drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c
index 7ec186e8e6de..f0a70736d7d9 100755
--- a/drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c
+++ b/drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c
@@ -1,594 +1,844 @@
-/*
- * meson_cs_dcdc_regulator.c
- *
- * Support for Meson current source DCDC voltage regulator
- *
- * Copyright (C) 2012 Elvis Yu <elvis.yu@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
- * whether express or implied; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/driver.h>
-#include <linux/regulator/machine.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <mach/am_regs.h>
-#include <linux/regulator/meson_cs_dcdc_regulator.h>
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-
-static struct meson_cs_pdata_t* g_vcck_voltage = NULL;
-static unsigned int *vcck_pwm_table;
-
-
-static int set_voltage(int from, int to)
-{
-	if(to<0 || to>MESON_CS_MAX_STEPS)
-	{
-		printk(KERN_ERR "%s: to(%d) out of range!\n", __FUNCTION__, to);
-		return -EINVAL;
-	}
-	if(from<0 || from>MESON_CS_MAX_STEPS)
-	{
-		if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-			g_vcck_voltage->set_voltage(to);
-		else
-			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
-		udelay(200);
-
-	}
-	else if(to < from)
-	{
-		// going to higher voltage
-		// lower index is higher voltage.
-		if (from - to > 3) {
-			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-				g_vcck_voltage->set_voltage(to+3);
-			else
-				aml_set_reg32_bits(P_VGHL_PWM_REG0, to + 3, 0, 4);
-			udelay(100);
-		}
-		if (from - to > 1) {
-			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-				g_vcck_voltage->set_voltage(to+1);
-			else
-				aml_set_reg32_bits(P_VGHL_PWM_REG0, to + 1, 0, 4);
-			udelay(100);
-		}
-		if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-			g_vcck_voltage->set_voltage(to);
-		else
-			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
-		udelay(100);
-	}
-	else if(to > from)
-	{
-		// going to lower voltage
-		if (to - from > 3) {
-			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-				g_vcck_voltage->set_voltage(to-3);
-			else
-				aml_set_reg32_bits(P_VGHL_PWM_REG0, to - 3, 0, 4);
-			udelay(100);
-		}
-		if (to - from > 1) {
-			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-				g_vcck_voltage->set_voltage(to-1);
-			else
-				aml_set_reg32_bits(P_VGHL_PWM_REG0, to - 1, 0, 4);
-			udelay(100);
-		}
-		if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
-			g_vcck_voltage->set_voltage(to);
-		else
-			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
-		// don't need to delay when going down since freq will
-		// already be lowered
-	}
-	return 0;
-}
-
-
-static int meson_cs_dcdc_get_voltage(struct regulator_dev *dev)
-{
-	struct meson_cs_regulator_dev *meson_cs_regulator = rdev_get_drvdata(dev);
-	u32 reg_val;
-	int data;
-	mutex_lock(&meson_cs_regulator->io_lock);
-
-	if(g_vcck_voltage && (g_vcck_voltage->get_voltage)) {
-		reg_val = g_vcck_voltage->get_voltage();
-		if(reg_val < 0) {
-			data = -1;
-			goto out;
-		}
-	}
-	else {
-		reg_val = aml_read_reg32(P_VGHL_PWM_REG0);
-
-		if ((reg_val>>12&3) != 1) {
-			dev_err(&dev->dev, "Error getting voltage\n");
-			data = -1;
-			goto out;
-		}
-
-	}
-	/* Convert the data from table & step to microvolts */
-	data = meson_cs_regulator->voltage_step_table[reg_val & 0xf];
-
-out:
-	mutex_unlock(&meson_cs_regulator->io_lock);
-	return data;
-}
-
-static int meson_cs_dcdc_set_voltage(struct regulator_dev *dev,
-				int minuV, int maxuV,
-				unsigned *selector)
-{
-	struct meson_cs_regulator_dev *meson_cs_regulator = rdev_get_drvdata(dev);
-	int cur_idx, last_idx;
-	
-	if (minuV < meson_cs_regulator->voltage_step_table[MESON_CS_MAX_STEPS-1] || minuV > meson_cs_regulator->voltage_step_table[0])
-		return -EINVAL;
-	if (maxuV < meson_cs_regulator->voltage_step_table[MESON_CS_MAX_STEPS-1] || maxuV > meson_cs_regulator->voltage_step_table[0])
-		return -EINVAL;
-
-	for(last_idx=0; last_idx<MESON_CS_MAX_STEPS; last_idx++)
-	{
-		if(meson_cs_regulator->cur_uV >= meson_cs_regulator->voltage_step_table[last_idx])
-		{
-			break;
-		}
-	}
-
-	for(cur_idx=0; cur_idx<MESON_CS_MAX_STEPS; cur_idx++)
-	{
-		if(minuV >= meson_cs_regulator->voltage_step_table[cur_idx])
-		{
-			break;
-		}
-	}
-
-	*selector = cur_idx;
-	
-	if(meson_cs_regulator->voltage_step_table[cur_idx] != minuV)
-	{
-		printk("set voltage to %d; selector=%d\n", meson_cs_regulator->voltage_step_table[cur_idx], cur_idx);
-	}
-	mutex_lock(&meson_cs_regulator->io_lock);
-
-	set_voltage(last_idx, cur_idx);
-
-	meson_cs_regulator->cur_uV = meson_cs_regulator->voltage_step_table[cur_idx];
-	mutex_unlock(&meson_cs_regulator->io_lock);
-	return 0;
-}
-
-static int meson_cs_dcdc_list_voltage(struct regulator_dev *dev, unsigned selector)
-{
-	struct meson_cs_regulator_dev *meson_cs_regulator = rdev_get_drvdata(dev);
-	return meson_cs_regulator->voltage_step_table[selector];
-}
-
-static struct regulator_ops meson_cs_ops = {
-	.get_voltage	= meson_cs_dcdc_get_voltage,
-	.set_voltage	= meson_cs_dcdc_set_voltage,
-	.list_voltage	= meson_cs_dcdc_list_voltage,
-};
-
-
-
-
-
-
-static void update_voltage_constraints(struct meson_cs_regulator_dev *data)
-{
-	int ret;
-
-	if (data->min_uV && data->max_uV
-	    && data->min_uV <= data->max_uV) {
-		ret = regulator_set_voltage(data->regulator,
-					    data->min_uV, data->max_uV);
-		if (ret != 0) {
-			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
-			       ret);
-			return;
-		}
-	}
-}
-
-static ssize_t show_min_uV(struct device *dev,
-			   struct device_attribute *attr, char *buf)
-{
-	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", data->min_uV);
-}
-
-static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
-			  const char *buf, size_t count)
-{
-	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
-	long val;
-
-	if (strict_strtol(buf, 10, &val) != 0)
-		return count;
-
-	data->min_uV = val;
-	update_voltage_constraints(data);
-
-	return count;
-}
-
-static ssize_t show_max_uV(struct device *dev,
-			   struct device_attribute *attr, char *buf)
-{
-	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", data->max_uV);
-}
-
-static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
-			  const char *buf, size_t count)
-{
-	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
-	long val;
-
-	if (strict_strtol(buf, 10, &val) != 0)
-		return count;
-
-	data->max_uV = val;
-	update_voltage_constraints(data);
-
-	return count;
-}
-
-static DEVICE_ATTR(min_microvolts, 0644, show_min_uV, set_min_uV);
-static DEVICE_ATTR(max_microvolts, 0644, show_max_uV, set_max_uV);
-
-
-static struct device_attribute *attributes_virtual[] = {
-	&dev_attr_min_microvolts,
-	&dev_attr_max_microvolts,
-};
-
-
-static int of_get_voltage() {
-	//printk("***vcck: get_voltage\n");	 
-	int i;    
-	unsigned int reg = aml_read_reg32(P_PWM_PWM_C);	  
-	for(i=0; i<MESON_CS_MAX_STEPS; i++) { 	   
-		if(reg == *(vcck_pwm_table+i)) 	 
-			break;    
-		}	
-    //printk("reg is %d\n",reg);
-    //printk("i is %d\n",i);
-	if(i >= MESON_CS_MAX_STEPS) 	   
-		return -1;	 
-	else		  
-		return i;
-}
-
-static int of_set_voltage(unsigned int level) {
-	//printk("***vcck: set_voltage\n");	 
-	//printk("level is %d  *(vcck_pwm_table+level) is %d\n",level,*(vcck_pwm_table+level));
-	aml_write_reg32(P_PWM_PWM_C, *(vcck_pwm_table+level));
-}
-
-
-int get_dt_vcck_init_data(struct device_node *np, struct regulator_init_data *vcck_init_data)
-{
-	int ret;
-	ret = of_property_read_string(np,"cons_name",&(vcck_init_data->constraints.name));
-	if(ret){
-			printk("don't find constraints-name\n");
-			return 1;
-	}
-
-	ret = of_property_read_u32(np,"min_uV",&(vcck_init_data->constraints.min_uV));
-	if(ret){
-			printk("don't find constraints-min_uV\n");
-			return 1;
-	}
-
-	ret = of_property_read_u32(np,"max_uV",&(vcck_init_data->constraints.max_uV));
-	if(ret){
-			printk("don't find constraints-max_uV\n");
-			return 1;
-	}
-
-	ret = of_property_read_u32(np,"valid_ops_mask",&(vcck_init_data->constraints.valid_ops_mask));
-	if(ret){
-			printk("don't find constraints-valid_ops_mask\n");
-			return 1;
-	}
-
-	ret = of_property_read_u32(np,"num",&(vcck_init_data->num_consumer_supplies));
-	if(ret){
-			printk("don't find num_consumer_supplies\n");
-			return 1;
-	}
-
-	vcck_init_data->consumer_supplies = kzalloc(sizeof(struct regulator_consumer_supply)*(vcck_init_data->num_consumer_supplies), GFP_KERNEL);
-	if(!vcck_init_data->consumer_supplies)
-	{
-		printk("vcck_init_data->consumer_supplies can not get mem\n");
-		return -1;
-	}
-		
-	ret = of_property_read_string(np,"vcck_data-supply",&(vcck_init_data->consumer_supplies->supply));
-	if(ret){
-			printk("don't find consumer_supplies->supply\n");
-			kfree(vcck_init_data->consumer_supplies);
-			return 1;
-	}
-
-	return 0;
-}
-
-
-static void vcck_pwm_init(struct device * dev) {
-	printk("***vcck: vcck_pwm_init\n");    
-	//enable pwm clk & pwm output    
-	aml_write_reg32(P_PWM_MISC_REG_CD, (aml_read_reg32(P_PWM_MISC_REG_CD) & ~(0x7f << 8)) | ((1 << 15) | (0 << 8) | (1 << 0)));    
-	aml_write_reg32(P_PWM_PWM_C, *(vcck_pwm_table+0));    
-	//enable pwm_C pinmux    1<<3 pwm_D    
-
-	//pinmux_set(&vcck_pwm_set);    
-    if (IS_ERR(devm_pinctrl_get_select_default(dev))) {
-		printk("did not get pins for pwm--------\n");
-	}
-	else
-	    printk("get pin for pwm--------\n");
-	//aml_write_reg32(P_PERIPHS_PIN_MUX_2, aml_read_reg32(P_PERIPHS_PIN_MUX_2) | (1 << 2));
-}
-
-static 
-int meson_cs_probe(struct platform_device *pdev)
-{
-	
-	printk("======================enter %s done!\n",__func__);
-#ifdef CONFIG_USE_OF
-	struct device_node *np = pdev->dev.of_node;
-	struct device_node *np_init_data;
-	struct meson_cs_pdata_t *vcck_pdata;
-	phandle phandle;
-	int val=0;
-	int ret;
-
-	if (pdev->dev.of_node) {
-		vcck_pdata = kzalloc(sizeof(struct meson_cs_pdata_t), GFP_KERNEL);
-		if(!vcck_pdata)
-		{
-			printk("vcck_pdata can not get mem\n");
-			return -1;
-		}
-			
-		ret = of_property_read_u32(np,"default_uV",&(vcck_pdata->default_uV));
-		if(ret){
-			printk("don't find  match default_uV\n");
-			goto err;
-		}
-
-		ret = of_property_read_u32_array(np,"voltage_step_table",&(vcck_pdata->voltage_step_table),(MESON_CS_MAX_STEPS)*sizeof(int)/sizeof(&vcck_pdata->voltage_step_table));
-		if(ret){
-			printk("don't find  match voltage_step_table\n");
-			goto err;
-		}
-			
-		ret = of_property_read_u32(np,"init-data",&val);
-		if(ret){
-			printk("don't find  match init-data\n");
-			goto err;
-		}
-		if(ret==0){
-			phandle=val;
-			np_init_data = of_find_node_by_phandle(phandle);
-			if(!np_init_data){
-				printk("%s:%d,can't find device node\n",__func__,__LINE__);
-				goto err;
-			}
-
-			vcck_pdata->meson_cs_init_data = kzalloc(sizeof(struct regulator_init_data), GFP_KERNEL);
-			if(!vcck_pdata->meson_cs_init_data)
-			{
-				printk("vcck_pdata->meson_cs_init_data can not get mem\n");
-				goto err;
-			}
-			
-			ret = get_dt_vcck_init_data(np_init_data,(vcck_pdata->meson_cs_init_data));
-			if(ret){
-				printk("don't find meson_cs_init_data\n");
-				kfree(vcck_pdata->meson_cs_init_data);
-				goto err;
-			}
-		}
-
-		if(of_find_property(pdev->dev.of_node,"vcck_pwm_table",NULL))
-		{
-			vcck_pwm_table=kzalloc(sizeof(int) * MESON_CS_MAX_STEPS, GFP_KERNEL);
-			ret=of_property_read_u32_array(np,"vcck_pwm_table",vcck_pwm_table,(MESON_CS_MAX_STEPS)*sizeof(int)/sizeof(vcck_pwm_table));
-			if(ret){
-			    printk("don't find  match vcck_pwm_table\n");
-			    goto err;
-		    }
-			printk("*(vcck_pwm_table+15) is %d\n *(vcck_pwm_table+16) is %d\n",*(vcck_pwm_table+15),*(vcck_pwm_table+16));
-			vcck_pdata->set_voltage = of_set_voltage;
-			vcck_pdata->get_voltage = of_get_voltage;
-			
-			vcck_pwm_init(&(pdev->dev));
-		}
-		else
-		{
-		printk("can not get vcck_pwm_table\n");
-			vcck_pdata->set_voltage = NULL;
-			vcck_pdata->get_voltage = NULL;
-		}
-		
-		pdev->dev.platform_data = vcck_pdata;	
-	}
-#endif
-
-	struct meson_cs_pdata_t *meson_cs_pdata  = pdev->dev.platform_data;
-	struct meson_cs_regulator_dev *meson_cs_regulator;
-	int error = 0, i, cur_idx;
-	struct regulator_config *meson_regulator_config;
-       g_vcck_voltage = meson_cs_pdata;
-	meson_cs_regulator = kzalloc(sizeof(struct meson_cs_regulator_dev), GFP_KERNEL);
-	if (!meson_cs_regulator)
-		return -ENOMEM;
-
-	meson_cs_regulator->rdev = NULL;
-	meson_cs_regulator->regulator = NULL;
-	meson_cs_regulator->voltage_step_table = meson_cs_pdata->voltage_step_table;
-
-	meson_cs_regulator->desc.name = "meson_cs_desc";
-	meson_cs_regulator->desc.id = 0;
-	meson_cs_regulator->desc.n_voltages = MESON_CS_MAX_STEPS;
-	meson_cs_regulator->desc.ops = &meson_cs_ops;
-	meson_cs_regulator->desc.type = REGULATOR_VOLTAGE;
-	meson_cs_regulator->desc.owner = THIS_MODULE;
-
-	mutex_init(&meson_cs_regulator->io_lock);
-
-	aml_set_reg32_bits(P_VGHL_PWM_REG0, 1, 12, 2);		//Enable
-	meson_regulator_config = devm_kzalloc(&pdev->dev, sizeof(*meson_regulator_config), GFP_KERNEL);
-	meson_regulator_config->dev=&pdev->dev;
-	meson_regulator_config->init_data=meson_cs_pdata->meson_cs_init_data;
-	meson_regulator_config->driver_data=meson_cs_regulator;
-	meson_regulator_config->of_node=pdev->dev.of_node;
-	meson_cs_regulator->rdev = regulator_register(&meson_cs_regulator->desc, meson_regulator_config);
-	if (IS_ERR(meson_cs_regulator->rdev)) {
-			dev_err(&pdev->dev,
-				"failed to register %s regulator\n",
-				pdev->name);
-			error = PTR_ERR(meson_cs_regulator->rdev);
-			goto fail;
-	}
-
-	meson_cs_regulator->regulator = regulator_get(NULL,
-		meson_cs_pdata->meson_cs_init_data->consumer_supplies->supply);
-
-	if (IS_ERR(meson_cs_regulator->regulator)) {
-			dev_err(&pdev->dev,
-				"failed to get %s regulator\n",
-				pdev->name);
-			error = PTR_ERR(meson_cs_regulator->rdev);
-			goto fail;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
-		error = device_create_file(&pdev->dev, attributes_virtual[i]);
-		if (error != 0)
-			goto fail;
-	}
-
-	platform_set_drvdata(pdev, meson_cs_regulator);		//Elvis
-
-	for(cur_idx=0; cur_idx<MESON_CS_MAX_STEPS; cur_idx++)
-	{
-		if(meson_cs_pdata->default_uV >= meson_cs_regulator->voltage_step_table[cur_idx])
-		{
-			break;
-		}
-	}
-
-	if(set_voltage(0, cur_idx))
-	{
-		goto fail;
-	}
-
-	meson_cs_regulator->cur_uV = meson_cs_regulator->voltage_step_table[cur_idx];
-
-	
-	printk("================init %s done!\n",__func__);
-	return 0;
-
-err:
-	kfree(vcck_pdata);
-	return -1;
-	
-fail:
-
-	if(meson_cs_regulator->rdev)
-		regulator_unregister(meson_cs_regulator->rdev);
-	
-	if(meson_cs_regulator->regulator)
-		regulator_put(meson_cs_regulator->regulator);
-	
-	kfree(meson_cs_regulator);
-	return error;
-}
-
-static int  meson_cs_remove(struct platform_device *pdev)
-{
-	struct meson_cs_regulator_dev *meson_cs_regulator = platform_get_drvdata(pdev);
-#ifdef CONFIG_USE_OF
-	struct meson_cs_pdata_t *meson_cs_pdata;
-#endif 
-	if(meson_cs_regulator->rdev)
-		regulator_unregister(meson_cs_regulator->rdev);
-	
-	if(meson_cs_regulator->regulator)
-		regulator_put(meson_cs_regulator->regulator);
-
-#ifdef CONFIG_USE_OF
-	meson_cs_pdata = container_of(meson_cs_regulator->voltage_step_table,struct meson_cs_pdata_t,voltage_step_table);
-	kfree(meson_cs_pdata->meson_cs_init_data->consumer_supplies);
-	kfree(meson_cs_pdata->meson_cs_init_data);
-	kfree(meson_cs_pdata);
-	kfree(meson_cs_regulator);
-#endif 
-	return 0;
-}
-
-
-#ifdef CONFIG_OF
-static const struct of_device_id amlogic_meson_cs_dt_match[]={
-	{	.compatible = "amlogic,meson-cs-regulator",
-	},
-	{},
-};
-#else
-#define amlogic_meson_cs_dt_match NULL
-#endif
-
-static struct platform_driver meson_cs_driver = {
-	.driver = {
-		.name = "meson-cs-regulator",
-		.owner = THIS_MODULE,
-		.of_match_table = amlogic_meson_cs_dt_match,
-	},
-	.probe = meson_cs_probe,
-	.remove = meson_cs_remove,
-};
-
-
-static int __init meson_cs_init(void)
-{
-	return platform_driver_register(&meson_cs_driver);
-}
-
-static void __exit meson_cs_cleanup(void)
-{
-	platform_driver_unregister(&meson_cs_driver);
-}
-
-subsys_initcall(meson_cs_init);
-module_exit(meson_cs_cleanup);
-
-MODULE_AUTHOR("Elvis Yu <elvis.yu@amlogic.com>");
-MODULE_DESCRIPTION("Amlogic Meson current source voltage regulator driver");
-MODULE_LICENSE("GPL v2");
+/*
+ * meson_cs_dcdc_regulator.c
+ *
+ * Support for Meson current source DCDC voltage regulator
+ *
+ * Copyright (C) 2012 Elvis Yu <elvis.yu@amlogic.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/meson_cs_dcdc_regulator.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+
+static struct meson_cs_pdata_t* g_vcck_voltage = NULL;
+static unsigned int *vcck_pwm_table;
+
+
+static int set_voltage(int from, int to)
+{
+	if(to<0 || to>MESON_CS_MAX_STEPS)
+	{
+		printk(KERN_ERR "%s: to(%d) out of range!\n", __FUNCTION__, to);
+		return -EINVAL;
+	}
+	if(from<0 || from>MESON_CS_MAX_STEPS)
+	{
+		if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+			g_vcck_voltage->set_voltage(to);
+		else
+			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
+		udelay(200);
+
+	}
+	else if(to < from)
+	{
+		// going to higher voltage
+		// lower index is higher voltage.
+		if (from - to > 3) {
+			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+				g_vcck_voltage->set_voltage(to+3);
+			else
+				aml_set_reg32_bits(P_VGHL_PWM_REG0, to + 3, 0, 4);
+			udelay(100);
+		}
+		if (from - to > 1) {
+			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+				g_vcck_voltage->set_voltage(to+1);
+			else
+				aml_set_reg32_bits(P_VGHL_PWM_REG0, to + 1, 0, 4);
+			udelay(100);
+		}
+		if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+			g_vcck_voltage->set_voltage(to);
+		else
+			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
+		udelay(100);
+	}
+	else if(to > from)
+	{
+		// going to lower voltage
+		if (to - from > 3) {
+			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+				g_vcck_voltage->set_voltage(to-3);
+			else
+				aml_set_reg32_bits(P_VGHL_PWM_REG0, to - 3, 0, 4);
+			udelay(100);
+		}
+		if (to - from > 1) {
+			if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+				g_vcck_voltage->set_voltage(to-1);
+			else
+				aml_set_reg32_bits(P_VGHL_PWM_REG0, to - 1, 0, 4);
+			udelay(100);
+		}
+		if(g_vcck_voltage && (g_vcck_voltage->set_voltage))
+			g_vcck_voltage->set_voltage(to);
+		else
+			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
+		// don't need to delay when going down since freq will
+		// already be lowered
+	}
+	return 0;
+}
+
+
+static int meson_cs_dcdc_get_voltage(struct regulator_dev *dev)
+{
+	struct meson_cs_regulator_dev *meson_cs_regulator = rdev_get_drvdata(dev);
+	u32 reg_val;
+	int data;
+	mutex_lock(&meson_cs_regulator->io_lock);
+
+	if(g_vcck_voltage && (g_vcck_voltage->get_voltage)) {
+		reg_val = g_vcck_voltage->get_voltage();
+		if(reg_val < 0) {
+			data = -1;
+			goto out;
+		}
+	}
+	else {
+		reg_val = aml_read_reg32(P_VGHL_PWM_REG0);
+
+		if ((reg_val>>12&3) != 1) {
+			dev_err(&dev->dev, "Error getting voltage\n");
+			data = -1;
+			goto out;
+		}
+
+	}
+	/* Convert the data from table & step to microvolts */
+	data = meson_cs_regulator->voltage_step_table[reg_val & 0xf];
+
+out:
+	mutex_unlock(&meson_cs_regulator->io_lock);
+	return data;
+}
+
+static int meson_cs_dcdc_set_voltage(struct regulator_dev *dev,
+				int minuV, int maxuV,
+				unsigned *selector)
+{
+	struct meson_cs_regulator_dev *meson_cs_regulator = rdev_get_drvdata(dev);
+	int cur_idx, last_idx;
+	
+	if (minuV < meson_cs_regulator->voltage_step_table[MESON_CS_MAX_STEPS-1] || minuV > meson_cs_regulator->voltage_step_table[0])
+		return -EINVAL;
+	if (maxuV < meson_cs_regulator->voltage_step_table[MESON_CS_MAX_STEPS-1] || maxuV > meson_cs_regulator->voltage_step_table[0])
+		return -EINVAL;
+
+	for(last_idx=0; last_idx<MESON_CS_MAX_STEPS; last_idx++)
+	{
+		if(meson_cs_regulator->cur_uV >= meson_cs_regulator->voltage_step_table[last_idx])
+		{
+			break;
+		}
+	}
+
+	for(cur_idx=0; cur_idx<MESON_CS_MAX_STEPS; cur_idx++)
+	{
+		if(minuV >= meson_cs_regulator->voltage_step_table[cur_idx])
+		{
+			break;
+		}
+	}
+
+	*selector = cur_idx;
+	
+	if(meson_cs_regulator->voltage_step_table[cur_idx] != minuV)
+	{
+		printk("set voltage to %d; selector=%d\n", meson_cs_regulator->voltage_step_table[cur_idx], cur_idx);
+	}
+	mutex_lock(&meson_cs_regulator->io_lock);
+
+	set_voltage(last_idx, cur_idx);
+
+	meson_cs_regulator->cur_uV = meson_cs_regulator->voltage_step_table[cur_idx];
+	mutex_unlock(&meson_cs_regulator->io_lock);
+	return 0;
+}
+
+static int meson_cs_dcdc_list_voltage(struct regulator_dev *dev, unsigned selector)
+{
+	struct meson_cs_regulator_dev *meson_cs_regulator = rdev_get_drvdata(dev);
+	return meson_cs_regulator->voltage_step_table[selector];
+}
+
+static struct regulator_ops meson_cs_ops = {
+	.get_voltage	= meson_cs_dcdc_get_voltage,
+	.set_voltage	= meson_cs_dcdc_set_voltage,
+	.list_voltage	= meson_cs_dcdc_list_voltage,
+};
+
+
+static void update_voltage_constraints(struct meson_cs_regulator_dev *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct meson_cs_regulator_dev *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0644, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0644, show_max_uV, set_max_uV);
+
+
+static struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+};
+
+
+static int of_get_voltage(void) {
+	//printk("***vcck: get_voltage\n");	 
+	int i;    
+	unsigned int reg = aml_read_reg32(P_PWM_PWM_C);	  
+	for(i=0; i<MESON_CS_MAX_STEPS; i++) { 	   
+		if(reg == *(vcck_pwm_table+i)) 	 
+			break;    
+		}	
+    //printk("reg is %d\n",reg);
+    //printk("i is %d\n",i);
+	if(i >= MESON_CS_MAX_STEPS) 	   
+		return -1;	 
+	else		  
+		return i;
+}
+
+static int of_set_voltage(unsigned int level) {
+	//printk("***vcck: set_voltage\n");	 
+	//printk("level is %d  *(vcck_pwm_table+level) is %d\n",level,*(vcck_pwm_table+level));
+	aml_write_reg32(P_PWM_PWM_C, *(vcck_pwm_table+level));
+    return 0;
+}
+
+
+int get_dt_vcck_init_data(struct device_node *np, struct regulator_init_data *vcck_init_data)
+{
+	int ret;
+	ret = of_property_read_string(np,"cons_name",&(vcck_init_data->constraints.name));
+	if(ret){
+			printk("don't find constraints-name\n");
+			return 1;
+	}
+
+	ret = of_property_read_u32(np,"min_uV",&(vcck_init_data->constraints.min_uV));
+	if(ret){
+			printk("don't find constraints-min_uV\n");
+			return 1;
+	}
+
+	ret = of_property_read_u32(np,"max_uV",&(vcck_init_data->constraints.max_uV));
+	if(ret){
+			printk("don't find constraints-max_uV\n");
+			return 1;
+	}
+
+	ret = of_property_read_u32(np,"valid_ops_mask",&(vcck_init_data->constraints.valid_ops_mask));
+	if(ret){
+			printk("don't find constraints-valid_ops_mask\n");
+			return 1;
+	}
+
+	ret = of_property_read_u32(np,"num",&(vcck_init_data->num_consumer_supplies));
+	if(ret){
+			printk("don't find num_consumer_supplies\n");
+			return 1;
+	}
+
+	vcck_init_data->consumer_supplies = kzalloc(sizeof(struct regulator_consumer_supply)*(vcck_init_data->num_consumer_supplies), GFP_KERNEL);
+	if(!vcck_init_data->consumer_supplies)
+	{
+		printk("vcck_init_data->consumer_supplies can not get mem\n");
+		return -1;
+	}
+		
+	ret = of_property_read_string(np,"vcck_data-supply",&(vcck_init_data->consumer_supplies->supply));
+	if(ret){
+			printk("don't find consumer_supplies->supply\n");
+			kfree(vcck_init_data->consumer_supplies);
+			return 1;
+	}
+
+	return 0;
+}
+
+
+static void vcck_pwm_init(struct device * dev) {
+	printk("***vcck: vcck_pwm_init\n");    
+	//enable pwm clk & pwm output    
+	aml_write_reg32(P_PWM_MISC_REG_CD, (aml_read_reg32(P_PWM_MISC_REG_CD) & ~(0x7f << 8)) | ((1 << 15) | (0 << 8) | (1 << 0)));    
+	aml_write_reg32(P_PWM_PWM_C, *(vcck_pwm_table+0));    
+	//enable pwm_C pinmux    1<<3 pwm_D    
+
+	//pinmux_set(&vcck_pwm_set);    
+    if (IS_ERR(devm_pinctrl_get_select_default(dev))) {
+		printk("did not get pins for pwm--------\n");
+	}
+	else
+	    printk("get pin for pwm--------\n");
+	//aml_write_reg32(P_PERIPHS_PIN_MUX_2, aml_read_reg32(P_PERIPHS_PIN_MUX_2) | (1 << 2));
+}
+
+static 
+int meson_cs_probe(struct platform_device *pdev)
+{
+	
+	printk("======================enter %s done!\n",__func__);
+#ifdef CONFIG_USE_OF
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *np_init_data;
+	struct meson_cs_pdata_t *vcck_pdata;
+	phandle phandle;
+	int val=0;
+	int ret;
+
+	if (pdev->dev.of_node) {
+		vcck_pdata = kzalloc(sizeof(struct meson_cs_pdata_t), GFP_KERNEL);
+		if(!vcck_pdata)
+		{
+			printk("vcck_pdata can not get mem\n");
+			return -1;
+		}
+			
+		ret = of_property_read_u32(np,"default_uV",&(vcck_pdata->default_uV));
+		if(ret){
+			printk("don't find  match default_uV\n");
+			goto err;
+		}
+
+		ret = of_property_read_u32_array(np,"voltage_step_table",&(vcck_pdata->voltage_step_table),(MESON_CS_MAX_STEPS)*sizeof(int)/sizeof(&vcck_pdata->voltage_step_table));
+		if(ret){
+			printk("don't find  match voltage_step_table\n");
+			goto err;
+		}
+			
+		ret = of_property_read_u32(np,"init-data",&val);
+		if(ret){
+			printk("don't find  match init-data\n");
+			goto err;
+		}
+		if(ret==0){
+			phandle=val;
+			np_init_data = of_find_node_by_phandle(phandle);
+			if(!np_init_data){
+				printk("%s:%d,can't find device node\n",__func__,__LINE__);
+				goto err;
+			}
+
+			vcck_pdata->meson_cs_init_data = kzalloc(sizeof(struct regulator_init_data), GFP_KERNEL);
+			if(!vcck_pdata->meson_cs_init_data)
+			{
+				printk("vcck_pdata->meson_cs_init_data can not get mem\n");
+				goto err;
+			}
+			
+			ret = get_dt_vcck_init_data(np_init_data,(vcck_pdata->meson_cs_init_data));
+			if(ret){
+				printk("don't find meson_cs_init_data\n");
+				kfree(vcck_pdata->meson_cs_init_data);
+				goto err;
+			}
+		}
+
+		if(of_find_property(pdev->dev.of_node,"vcck_pwm_table",NULL))
+		{
+			vcck_pwm_table=kzalloc(sizeof(int) * MESON_CS_MAX_STEPS, GFP_KERNEL);
+			ret=of_property_read_u32_array(np,"vcck_pwm_table",vcck_pwm_table,(MESON_CS_MAX_STEPS)*sizeof(int)/sizeof(vcck_pwm_table));
+			if(ret){
+			    printk("don't find  match vcck_pwm_table\n");
+			    goto err;
+		    }
+			printk("*(vcck_pwm_table+15) is %d\n *(vcck_pwm_table+16) is %d\n",*(vcck_pwm_table+15),*(vcck_pwm_table+16));
+			vcck_pdata->set_voltage = of_set_voltage;
+			vcck_pdata->get_voltage = of_get_voltage;
+			
+			vcck_pwm_init(&(pdev->dev));
+		}
+		else
+		{
+		printk("can not get vcck_pwm_table\n");
+			vcck_pdata->set_voltage = NULL;
+			vcck_pdata->get_voltage = NULL;
+		}
+		
+		pdev->dev.platform_data = vcck_pdata;	
+	}
+#endif
+
+	struct meson_cs_pdata_t *meson_cs_pdata  = pdev->dev.platform_data;
+	struct meson_cs_regulator_dev *meson_cs_regulator;
+	int error = 0, i, cur_idx;
+	struct regulator_config *meson_regulator_config;
+       g_vcck_voltage = meson_cs_pdata;
+	meson_cs_regulator = kzalloc(sizeof(struct meson_cs_regulator_dev), GFP_KERNEL);
+	if (!meson_cs_regulator)
+		return -ENOMEM;
+
+	meson_cs_regulator->rdev = NULL;
+	meson_cs_regulator->regulator = NULL;
+	meson_cs_regulator->voltage_step_table = meson_cs_pdata->voltage_step_table;
+
+	meson_cs_regulator->desc.name = "meson_cs_desc";
+	meson_cs_regulator->desc.id = 0;
+	meson_cs_regulator->desc.n_voltages = MESON_CS_MAX_STEPS;
+	meson_cs_regulator->desc.ops = &meson_cs_ops;
+	meson_cs_regulator->desc.type = REGULATOR_VOLTAGE;
+	meson_cs_regulator->desc.owner = THIS_MODULE;
+
+	mutex_init(&meson_cs_regulator->io_lock);
+
+	aml_set_reg32_bits(P_VGHL_PWM_REG0, 1, 12, 2);		//Enable
+	meson_regulator_config = devm_kzalloc(&pdev->dev, sizeof(*meson_regulator_config), GFP_KERNEL);
+	meson_regulator_config->dev=&pdev->dev;
+	meson_regulator_config->init_data=meson_cs_pdata->meson_cs_init_data;
+	meson_regulator_config->driver_data=meson_cs_regulator;
+	meson_regulator_config->of_node=pdev->dev.of_node;
+	meson_cs_regulator->rdev = regulator_register(&meson_cs_regulator->desc, meson_regulator_config);
+	if (IS_ERR(meson_cs_regulator->rdev)) {
+			dev_err(&pdev->dev,
+				"failed to register %s regulator\n",
+				pdev->name);
+			error = PTR_ERR(meson_cs_regulator->rdev);
+			goto fail;
+	}
+
+	meson_cs_regulator->regulator = regulator_get(NULL,
+		meson_cs_pdata->meson_cs_init_data->consumer_supplies->supply);
+
+	if (IS_ERR(meson_cs_regulator->regulator)) {
+			dev_err(&pdev->dev,
+				"failed to get %s regulator\n",
+				pdev->name);
+			error = PTR_ERR(meson_cs_regulator->rdev);
+			goto fail;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		error = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (error != 0)
+			goto fail;
+	}
+
+	platform_set_drvdata(pdev, meson_cs_regulator);		//Elvis
+
+	for(cur_idx=0; cur_idx<MESON_CS_MAX_STEPS; cur_idx++)
+	{
+		if(meson_cs_pdata->default_uV >= meson_cs_regulator->voltage_step_table[cur_idx])
+		{
+			break;
+		}
+	}
+
+	if(set_voltage(0, cur_idx))
+	{
+		goto fail;
+	}
+
+	meson_cs_regulator->cur_uV = meson_cs_regulator->voltage_step_table[cur_idx];
+
+	
+	printk("================init %s done!\n",__func__);
+	return 0;
+
+err:
+	kfree(vcck_pdata);
+	return -1;
+	
+fail:
+
+	if(meson_cs_regulator->rdev)
+		regulator_unregister(meson_cs_regulator->rdev);
+	
+	if(meson_cs_regulator->regulator)
+		regulator_put(meson_cs_regulator->regulator);
+	
+	kfree(meson_cs_regulator);
+	return error;
+}
+
+static int  meson_cs_remove(struct platform_device *pdev)
+{
+	struct meson_cs_regulator_dev *meson_cs_regulator = platform_get_drvdata(pdev);
+#ifdef CONFIG_USE_OF
+	struct meson_cs_pdata_t *meson_cs_pdata;
+#endif 
+	if(meson_cs_regulator->rdev)
+		regulator_unregister(meson_cs_regulator->rdev);
+	
+	if(meson_cs_regulator->regulator)
+		regulator_put(meson_cs_regulator->regulator);
+
+#ifdef CONFIG_USE_OF
+	meson_cs_pdata = container_of(meson_cs_regulator->voltage_step_table,struct meson_cs_pdata_t,voltage_step_table);
+	kfree(meson_cs_pdata->meson_cs_init_data->consumer_supplies);
+	kfree(meson_cs_pdata->meson_cs_init_data);
+	kfree(meson_cs_pdata);
+	kfree(meson_cs_regulator);
+#endif 
+	return 0;
+}
+
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_meson_cs_dt_match[]={
+	{	.compatible = "amlogic,meson-cs-regulator",
+	},
+	{},
+};
+#else
+#define amlogic_meson_cs_dt_match NULL
+#endif
+
+static struct platform_driver meson_cs_driver = {
+	.driver = {
+		.name = "meson-cs-regulator",
+		.owner = THIS_MODULE,
+		.of_match_table = amlogic_meson_cs_dt_match,
+	},
+	.probe = meson_cs_probe,
+	.remove = meson_cs_remove,
+};
+
+
+static int __init meson_cs_init(void)
+{
+	return platform_driver_register(&meson_cs_driver);
+}
+
+static void __exit meson_cs_cleanup(void)
+{
+	platform_driver_unregister(&meson_cs_driver);
+}
+
+subsys_initcall(meson_cs_init);
+module_exit(meson_cs_cleanup);
+
+#ifdef CONFIG_AML_DVFS
+#include <linux/amlogic/aml_dvfs.h>
+
+struct cs_voltage {
+    int pwm_value;
+    int voltage;
+};
+
+static struct cs_voltage *g_table = NULL;
+static int g_table_cnt = 0;
+static int use_pwm = 0;
+
+static int dvfs_get_voltage_step(void)
+{
+    int i = 0;
+    unsigned int reg_val;
+
+    if (use_pwm) {
+        reg_val = aml_read_reg32(P_PWM_PWM_C); 
+        for (i = 0; i < g_table_cnt; i++) {
+            if (g_table[i].pwm_value == reg_val) {
+                return i;    
+            }
+        }
+        if (i >= g_table_cnt) {
+            return -1;    
+        }
+    } else {
+		reg_val = aml_read_reg32(P_VGHL_PWM_REG0);
+		if ((reg_val>>12&3) != 1) {
+			return -1;
+		}
+        return reg_val & 0xf;
+    }
+}
+
+static int dvfs_set_voltage(int from, int to)
+{
+    int cur;
+
+	if (to < 0 || to > g_table_cnt) {
+		printk(KERN_ERR "%s: to(%d) out of range!\n", __FUNCTION__, to);
+		return -EINVAL;
+	} 
+	if (from < 0 || from > g_table_cnt) {
+        if (use_pwm) {
+            /*
+             * use PMW method to adjust vcck voltage
+             */
+            aml_write_reg32(P_PWM_PWM_C, g_table[to].pwm_value);
+        } else {
+            /*
+             * use constant-current source to adjust vcck voltage
+             */
+			aml_set_reg32_bits(P_VGHL_PWM_REG0, to, 0, 4);
+        }
+		udelay(200);
+        return 0;
+	}
+    cur = from;
+    while (cur != to) {
+        /*
+         * if target step is far away from current step, don't change 
+         * voltage by one-step-done. You should change voltage step by
+         * step to make sure voltage output is stable
+         */
+        if (cur < to) {
+            if (cur < to - 3) {
+                cur += 3;    
+            } else {
+                cur = to;    
+            }
+        } else {
+            if (cur > to + 3) {
+                cur -= 3;    
+            } else {
+                cur = to;    
+            }
+        }
+        if (use_pwm) {
+            aml_write_reg32(P_PWM_PWM_C, g_table[cur].pwm_value);    
+        } else {
+			aml_set_reg32_bits(P_VGHL_PWM_REG0, cur, 0, 4);
+        }
+        udelay(100);
+    }
+    return 0;
+}
+
+static int meson_cs_set_voltage(uint32_t id, uint32_t min_uV, uint32_t max_uV)
+{
+    uint32_t vol = 0;
+    int      i;
+    int      cur;
+
+    if (min_uV > max_uV || !g_table) {
+        printk("%s, invalid voltage or NULL table\n", __func__);
+        return -1;    
+    }   
+    vol = (min_uV + max_uV) / 2;
+    for (i = 0; i < g_table_cnt; i++) {
+        if (g_table[i].voltage >= vol) {
+            break;
+        }
+    }
+    if (i == g_table_cnt) {
+        printk("%s, voltage is too large:%d\n", __func__, vol);    
+        return -EINVAL;
+    }
+
+    cur = dvfs_get_voltage_step();
+    return dvfs_set_voltage(cur, i);
+}
+
+static int meson_cs_get_voltage(uint32_t id, uint32_t *uV)
+{
+    int cur;
+
+    if (!g_table) {
+        printk("%s, no voltage table\n", __func__);
+        return -1;
+    }
+    cur = dvfs_get_voltage_step(); 
+    if (cur < 0) {
+        return cur;
+    } else {
+        *uV = g_table[cur].voltage; 
+        return 0;
+    }
+}
+
+struct aml_dvfs_driver aml_cs_dvfs_driver = { 
+    .name        = "meson-cs-dvfs",
+    .id_mask     = (AML_DVFS_ID_VCCK),
+    .set_voltage = meson_cs_set_voltage, 
+    .get_voltage = meson_cs_get_voltage,
+};
+
+#define DEBUG_PARSE 1
+#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)        \
+    if (of_property_read_u32(node, prop_name, (u32*)(&value))) {        \
+        printk("failed to get property: %s\n", prop_name);              \
+        goto exception;                                                 \
+    }                                                                   \
+    if (DEBUG_PARSE) {                                                  \
+        printk("get property:%25s, value:0x%08x, dec:%8d\n",            \
+            prop_name, value, value);                                   \
+    }
+
+#ifdef CONFIG_OF
+static const struct of_device_id amlogic_meson_cs_dvfs_match[]={
+	{	.compatible = "amlogic, meson_vcck_dvfs",
+	},
+	{},
+};
+#endif
+
+static void dvfs_vcck_pwm_init(struct device * dev) {
+	aml_write_reg32(P_PWM_MISC_REG_CD, (aml_read_reg32(P_PWM_MISC_REG_CD) & ~(0x7f << 8)) | ((1 << 15) | (0 << 8) | (1 << 0)));    
+	aml_write_reg32(P_PWM_PWM_C, g_table[g_table_cnt - 1].pwm_value);    
+
+    if (IS_ERR(devm_pinctrl_get_select_default(dev))) {
+		printk("did not get pins for pwm--------\n");
+	} else {
+	    printk("get pin for pwm--------\n");
+    }
+}
+
+static int meson_cs_dvfs_probe(struct platform_device *pdev)
+{
+    int ret;    
+	struct device_node *np = pdev->dev.of_node;
+    int default_uv = 0;
+    int i = 0;
+
+    if (!np) {
+        return -ENODEV;
+    }
+    PARSE_UINT32_PROPERTY(np, "use_pwm", use_pwm, out);
+    PARSE_UINT32_PROPERTY(np, "table_count", g_table_cnt, out);
+    g_table = kzalloc(sizeof(struct cs_voltage) * g_table_cnt, GFP_KERNEL);
+    if (g_table == NULL) {
+        printk("%s, allocate memory failed\n", __func__);    
+        return -ENOMEM;
+    }
+    ret = of_property_read_u32_array(np, 
+                                     "cs_voltage_table", 
+                                     g_table, 
+                                     (sizeof(struct cs_voltage) * g_table_cnt) / sizeof(int));
+    if (ret < 0) {
+        printk("%s, failed to read 'cs_voltage_table', ret:%d\n", __func__, ret);
+        goto out;
+    }
+    printk("%s, table count:%d, use_pwm:%d\n", __func__, g_table_cnt, use_pwm);
+    for (i = 0; i < g_table_cnt; i++) {
+        printk("%2d, %08x, %7d\n", i, g_table[i].pwm_value, g_table[i].voltage);    
+    }
+
+    PARSE_UINT32_PROPERTY(np, "default_uV", default_uv, next);
+    if (default_uv) {
+        meson_cs_set_voltage(AML_DVFS_ID_VCCK, default_uv, default_uv); 
+    }
+next:
+    if (use_pwm) {
+        dvfs_vcck_pwm_init(&pdev->dev);
+    }
+    aml_dvfs_register_driver(&aml_cs_dvfs_driver);
+    return 0;
+out:
+    if (g_table) {
+        kfree(g_table);
+        g_table = NULL;
+    }
+    return -1;
+}
+
+static int meson_cs_dvfs_remove(struct platform_device *pdev)
+{
+    if (g_table) {
+        kfree(g_table);    
+    } 
+    aml_dvfs_unregister_driver(&aml_cs_dvfs_driver);
+    return 0;
+}
+
+static struct platform_driver meson_cs_dvfs_driver = {
+	.driver = {
+		.name = "meson_vcck_dvfs",
+		.owner = THIS_MODULE,
+    #ifdef CONFIG_OF
+		.of_match_table = amlogic_meson_cs_dvfs_match,
+    #endif
+	},
+	.probe = meson_cs_dvfs_probe,
+	.remove = meson_cs_dvfs_remove,
+};
+
+
+static int __init meson_cs_dvfs_init(void)
+{
+	return platform_driver_register(&meson_cs_dvfs_driver);
+}
+
+static void __exit meson_cs_dvfs_cleanup(void)
+{
+	platform_driver_unregister(&meson_cs_driver);
+}
+
+subsys_initcall(meson_cs_dvfs_init);
+module_exit(meson_cs_dvfs_cleanup);
+
+#endif      /* CONFIG_AML_DVFS */
+
+MODULE_AUTHOR("Elvis Yu <elvis.yu@amlogic.com>");
+MODULE_DESCRIPTION("Amlogic Meson current source voltage regulator driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/amlogic/meson_cs_dcdc_regulator.h b/include/linux/amlogic/meson_cs_dcdc_regulator.h
new file mode 100755
index 000000000000..a09c1d617028
--- /dev/null
+++ b/include/linux/amlogic/meson_cs_dcdc_regulator.h
@@ -0,0 +1,30 @@
+#ifndef MESON_CS_DCDC_REGULATOR_H
+#define MESON_CS_DCDC_REGULATOR_H
+#include <linux/regulator/driver.h>
+
+#define MESON_CS_MAX_STEPS 16
+
+struct meson_cs_pdata_t {
+	struct regulator_init_data *meson_cs_init_data;
+	int voltage_step_table[MESON_CS_MAX_STEPS];
+	int default_uV;
+       int (*get_voltage)(void);
+       int (*set_voltage)(unsigned int);
+};
+
+
+struct meson_cs_regulator_dev {
+	struct regulator *regulator;
+	struct regulator_desc desc;
+	struct regulator_dev *rdev;
+	int min_uV;
+	int max_uV;
+	int cur_uV;
+	struct mutex io_lock;
+	int *voltage_step_table;
+};
+
+int meson_cs_dcdc_set_voltage_global(int minuV, int maxuV);
+int meson_cs_dcdc_get_voltage_global(void);
+
+#endif
-- 
2.19.0

