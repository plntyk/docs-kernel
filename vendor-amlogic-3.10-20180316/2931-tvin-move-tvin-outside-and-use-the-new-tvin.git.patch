From fe845b42e80caa39cccc7bd33881288f09752796 Mon Sep 17 00:00:00 2001
From: "bo.yang" <bo.yang@amlogic.com>
Date: Tue, 7 Jan 2014 20:44:54 +0800
Subject: [PATCH 2931/5965] tvin: move tvin outside and use the new tvin.git

branch amlogic-3.10-bringup of tvin for amlogic kernel branch amlogic-3.10-bringup.
branch amlogic-pd-00002     of tvin for amlogic kernel branch amlogic-pd-00002.

Conflicts:

	drivers/amlogic/tvin/isp/isp_drv.c
	drivers/amlogic/tvin/isp/isp_drv.h
	drivers/amlogic/tvin/isp/isp_hw.c
	drivers/amlogic/tvin/isp/isp_hw.h
	drivers/amlogic/tvin/isp/isp_sm.c
	drivers/amlogic/tvin/vdin/vdin_ctl.c
	drivers/amlogic/tvin/vdin/vdin_drv.c
	drivers/amlogic/tvin/viu/viuin.c
---
 drivers/amlogic/Kconfig                       |    2 +-
 drivers/amlogic/Makefile                      |    2 +-
 drivers/amlogic/tvin/Kconfig                  |   21 -
 drivers/amlogic/tvin/Makefile                 |   15 -
 drivers/amlogic/tvin/aml.dtd                  |   29 -
 drivers/amlogic/tvin/bt656/Kconfig            |   11 -
 drivers/amlogic/tvin/bt656/Makefile           |    2 -
 drivers/amlogic/tvin/bt656/bt656_601_in.c     |  832 ---
 drivers/amlogic/tvin/bt656/bt656_601_in.h     |   50 -
 drivers/amlogic/tvin/csi/Kconfig              |   11 -
 drivers/amlogic/tvin/csi/Makefile             |    2 -
 drivers/amlogic/tvin/csi/csi.c                |  705 ---
 drivers/amlogic/tvin/csi/csi.h                |   52 -
 drivers/amlogic/tvin/csi/mipi_hw.c            |  209 -
 drivers/amlogic/tvin/hdmirx/Kconfig           |   10 -
 drivers/amlogic/tvin/hdmirx/Makefile          |    6 -
 drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c      | 1219 -----
 drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h     |  703 ---
 drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c | 2518 ---------
 drivers/amlogic/tvin/hdmirx/hdmirx_drv.c      |  994 ----
 drivers/amlogic/tvin/hdmirx/hdmirx_drv.h      |  450 --
 drivers/amlogic/tvin/hdmirx/hdmirx_test.c     |  852 ---
 drivers/amlogic/tvin/hdmirx/test/hdmi.c       |  755 ---
 drivers/amlogic/tvin/hdmirx/test/hdmi.h       |   98 -
 .../amlogic/tvin/hdmirx/test/hdmi_parameter.h |  878 ----
 drivers/amlogic/tvin/hdmirx/test/hdmirx.c     | 1570 ------
 drivers/amlogic/tvin/hdmirx/test/hdmirx.h     |  194 -
 .../tvin/hdmirx/test/hdmirx_parameter.h       |  480 --
 drivers/amlogic/tvin/hdmirx/test/test.c       |  127 -
 drivers/amlogic/tvin/hdmirx/test/test_prm.h   |  403 --
 drivers/amlogic/tvin/isp/Kconfig              |    5 -
 drivers/amlogic/tvin/isp/Makefile             |    2 -
 drivers/amlogic/tvin/isp/isp_drv.c            | 1474 ------
 drivers/amlogic/tvin/isp/isp_drv.h            |  217 -
 drivers/amlogic/tvin/isp/isp_hw.c             | 1400 -----
 drivers/amlogic/tvin/isp/isp_hw.h             |  129 -
 drivers/amlogic/tvin/isp/isp_parm.c           | 2995 -----------
 drivers/amlogic/tvin/isp/isp_regs.h           | 2213 --------
 drivers/amlogic/tvin/isp/isp_sm.c             | 1557 ------
 drivers/amlogic/tvin/isp/isp_sm.h             |  215 -
 drivers/amlogic/tvin/isp/isp_tool.h           |    0
 drivers/amlogic/tvin/it660x/Kconfig           |   14 -
 drivers/amlogic/tvin/it660x/Makefile          |    5 -
 drivers/amlogic/tvin/it660x/config.h          |   38 -
 drivers/amlogic/tvin/it660x/csc.c             |   86 -
 drivers/amlogic/tvin/it660x/debug.h           |   62 -
 drivers/amlogic/tvin/it660x/dvin.h            |   71 -
 drivers/amlogic/tvin/it660x/edid.c            |  532 --
 drivers/amlogic/tvin/it660x/edid.h            |   45 -
 drivers/amlogic/tvin/it660x/hdmirx.c          | 4645 -----------------
 drivers/amlogic/tvin/it660x/hdmirx.h          | 1226 -----
 drivers/amlogic/tvin/it660x/hdmirx_repeater.c |  356 --
 drivers/amlogic/tvin/it660x/io.h              |   64 -
 drivers/amlogic/tvin/it660x/it660x_drv.c      | 1584 ------
 drivers/amlogic/tvin/it660x/it660x_fe.c       |  296 --
 drivers/amlogic/tvin/it660x/it660x_i2c.c      |  284 -
 drivers/amlogic/tvin/it660x/mcu.h             |   95 -
 drivers/amlogic/tvin/it660x/sha1.c            |  152 -
 drivers/amlogic/tvin/it660x/sha1.h            |   45 -
 drivers/amlogic/tvin/it660x/typedef.h         |  738 ---
 drivers/amlogic/tvin/it660x/version.h         |   17 -
 drivers/amlogic/tvin/tvafe/Kconfig            |   23 -
 drivers/amlogic/tvin/tvafe/Makefile           |    7 -
 drivers/amlogic/tvin/tvafe/tvafe.c            | 1500 ------
 drivers/amlogic/tvin/tvafe/tvafe.h            |   78 -
 drivers/amlogic/tvin/tvafe/tvafe_adc.c        | 1589 ------
 drivers/amlogic/tvin/tvafe/tvafe_adc.h        |  100 -
 drivers/amlogic/tvin/tvafe/tvafe_cvd.c        | 2132 --------
 drivers/amlogic/tvin/tvafe/tvafe_cvd.h        |  162 -
 drivers/amlogic/tvin/tvafe/tvafe_general.c    | 3196 ------------
 drivers/amlogic/tvin/tvafe/tvafe_general.h    |   87 -
 drivers/amlogic/tvin/tvafe/tvafe_regs.h       | 4185 ---------------
 drivers/amlogic/tvin/tvafe/tvin_vbi.c         | 1199 -----
 drivers/amlogic/tvin/tvafe/tvin_vbi.h         |  214 -
 drivers/amlogic/tvin/tvin_format_table.c      | 3263 ------------
 drivers/amlogic/tvin/tvin_format_table.h      |   46 -
 drivers/amlogic/tvin/tvin_frontend.c          |  156 -
 drivers/amlogic/tvin/tvin_frontend.h          |   86 -
 drivers/amlogic/tvin/tvin_global.c            |  341 --
 drivers/amlogic/tvin/tvin_global.h            |  199 -
 drivers/amlogic/tvin/tvin_regs.h              |   23 -
 drivers/amlogic/tvin/vdin/Kconfig             |   11 -
 drivers/amlogic/tvin/vdin/Makefile            |    6 -
 drivers/amlogic/tvin/vdin/vdin_canvas.c       |  186 -
 drivers/amlogic/tvin/vdin/vdin_canvas.h       |   33 -
 drivers/amlogic/tvin/vdin/vdin_ctl.c          | 2093 --------
 drivers/amlogic/tvin/vdin/vdin_ctl.h          |  173 -
 drivers/amlogic/tvin/vdin/vdin_drv.c          | 2975 -----------
 drivers/amlogic/tvin/vdin/vdin_drv.h          |  191 -
 drivers/amlogic/tvin/vdin/vdin_regs.h         | 1303 -----
 drivers/amlogic/tvin/vdin/vdin_sm.c           |  511 --
 drivers/amlogic/tvin/vdin/vdin_sm.h           |   45 -
 drivers/amlogic/tvin/vdin/vdin_vf.c           |  821 ---
 drivers/amlogic/tvin/vdin/vdin_vf.h           |  171 -
 drivers/amlogic/tvin/viu/Kconfig              |   14 -
 drivers/amlogic/tvin/viu/Makefile             |    2 -
 drivers/amlogic/tvin/viu/viuin.c              |  751 ---
 97 files changed, 2 insertions(+), 61632 deletions(-)
 delete mode 100755 drivers/amlogic/tvin/Kconfig
 delete mode 100755 drivers/amlogic/tvin/Makefile
 delete mode 100755 drivers/amlogic/tvin/aml.dtd
 delete mode 100755 drivers/amlogic/tvin/bt656/Kconfig
 delete mode 100755 drivers/amlogic/tvin/bt656/Makefile
 delete mode 100755 drivers/amlogic/tvin/bt656/bt656_601_in.c
 delete mode 100755 drivers/amlogic/tvin/bt656/bt656_601_in.h
 delete mode 100755 drivers/amlogic/tvin/csi/Kconfig
 delete mode 100755 drivers/amlogic/tvin/csi/Makefile
 delete mode 100755 drivers/amlogic/tvin/csi/csi.c
 delete mode 100755 drivers/amlogic/tvin/csi/csi.h
 delete mode 100755 drivers/amlogic/tvin/csi/mipi_hw.c
 delete mode 100755 drivers/amlogic/tvin/hdmirx/Kconfig
 delete mode 100755 drivers/amlogic/tvin/hdmirx/Makefile
 delete mode 100755 drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
 delete mode 100755 drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h
 delete mode 100755 drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
 delete mode 100755 drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
 delete mode 100755 drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
 delete mode 100755 drivers/amlogic/tvin/hdmirx/hdmirx_test.c
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/hdmi.c
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/hdmi.h
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/hdmi_parameter.h
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/hdmirx.c
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/hdmirx.h
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/hdmirx_parameter.h
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/test.c
 delete mode 100644 drivers/amlogic/tvin/hdmirx/test/test_prm.h
 delete mode 100644 drivers/amlogic/tvin/isp/Kconfig
 delete mode 100644 drivers/amlogic/tvin/isp/Makefile
 delete mode 100755 drivers/amlogic/tvin/isp/isp_drv.c
 delete mode 100755 drivers/amlogic/tvin/isp/isp_drv.h
 delete mode 100755 drivers/amlogic/tvin/isp/isp_hw.c
 delete mode 100755 drivers/amlogic/tvin/isp/isp_hw.h
 delete mode 100755 drivers/amlogic/tvin/isp/isp_parm.c
 delete mode 100755 drivers/amlogic/tvin/isp/isp_regs.h
 delete mode 100755 drivers/amlogic/tvin/isp/isp_sm.c
 delete mode 100755 drivers/amlogic/tvin/isp/isp_sm.h
 delete mode 100644 drivers/amlogic/tvin/isp/isp_tool.h
 delete mode 100755 drivers/amlogic/tvin/it660x/Kconfig
 delete mode 100755 drivers/amlogic/tvin/it660x/Makefile
 delete mode 100755 drivers/amlogic/tvin/it660x/config.h
 delete mode 100755 drivers/amlogic/tvin/it660x/csc.c
 delete mode 100755 drivers/amlogic/tvin/it660x/debug.h
 delete mode 100755 drivers/amlogic/tvin/it660x/dvin.h
 delete mode 100755 drivers/amlogic/tvin/it660x/edid.c
 delete mode 100755 drivers/amlogic/tvin/it660x/edid.h
 delete mode 100755 drivers/amlogic/tvin/it660x/hdmirx.c
 delete mode 100755 drivers/amlogic/tvin/it660x/hdmirx.h
 delete mode 100755 drivers/amlogic/tvin/it660x/hdmirx_repeater.c
 delete mode 100755 drivers/amlogic/tvin/it660x/io.h
 delete mode 100755 drivers/amlogic/tvin/it660x/it660x_drv.c
 delete mode 100755 drivers/amlogic/tvin/it660x/it660x_fe.c
 delete mode 100755 drivers/amlogic/tvin/it660x/it660x_i2c.c
 delete mode 100755 drivers/amlogic/tvin/it660x/mcu.h
 delete mode 100755 drivers/amlogic/tvin/it660x/sha1.c
 delete mode 100755 drivers/amlogic/tvin/it660x/sha1.h
 delete mode 100755 drivers/amlogic/tvin/it660x/typedef.h
 delete mode 100755 drivers/amlogic/tvin/it660x/version.h
 delete mode 100755 drivers/amlogic/tvin/tvafe/Kconfig
 delete mode 100755 drivers/amlogic/tvin/tvafe/Makefile
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe.c
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe.h
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_adc.c
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_adc.h
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_cvd.c
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_cvd.h
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_general.c
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_general.h
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvafe_regs.h
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvin_vbi.c
 delete mode 100755 drivers/amlogic/tvin/tvafe/tvin_vbi.h
 delete mode 100755 drivers/amlogic/tvin/tvin_format_table.c
 delete mode 100755 drivers/amlogic/tvin/tvin_format_table.h
 delete mode 100755 drivers/amlogic/tvin/tvin_frontend.c
 delete mode 100755 drivers/amlogic/tvin/tvin_frontend.h
 delete mode 100755 drivers/amlogic/tvin/tvin_global.c
 delete mode 100755 drivers/amlogic/tvin/tvin_global.h
 delete mode 100755 drivers/amlogic/tvin/tvin_regs.h
 delete mode 100755 drivers/amlogic/tvin/vdin/Kconfig
 delete mode 100755 drivers/amlogic/tvin/vdin/Makefile
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_canvas.c
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_canvas.h
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_ctl.c
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_ctl.h
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_drv.c
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_drv.h
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_regs.h
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_sm.c
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_sm.h
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_vf.c
 delete mode 100755 drivers/amlogic/tvin/vdin/vdin_vf.h
 delete mode 100644 drivers/amlogic/tvin/viu/Kconfig
 delete mode 100644 drivers/amlogic/tvin/viu/Makefile
 delete mode 100755 drivers/amlogic/tvin/viu/viuin.c

diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index a58b62c5cb85..a8bb7ec18c92 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -77,7 +77,7 @@ source "drivers/amlogic/amports/Kconfig"
 source "drivers/amlogic/canvas/Kconfig"
 source "drivers/amlogic/display/Kconfig"
 source "drivers/amlogic/hdmi/Kconfig"
-source "drivers/amlogic/tvin/Kconfig"
+isource "../hardware/tvin/Kconfig"
 #source "drivers/amlogic/cmem/Kconfig"
 #source "drivers/amlogic/jpeglogo/Kconfig"
 #source "drivers/amlogic/dvb/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 2eb496ffee11..8a43b9679ff7 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -74,7 +74,7 @@ obj-y += power/
 #obj-$(CONFIG_AM_GPIO) +=gpio/
 
 obj-y += tvin_v4l2/
-obj-y += tvin/
+obj-$(CONFIG_TVIN) += ../../../hardware/tvin/
 
 obj-y += thermal/
 
diff --git a/drivers/amlogic/tvin/Kconfig b/drivers/amlogic/tvin/Kconfig
deleted file mode 100755
index ccb50bb1738e..000000000000
--- a/drivers/amlogic/tvin/Kconfig
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# Amlogic tvin devices configuration
-#
-
-menuconfig TVIN
-	tristate "Amlogic TVIN support"
-	default n
-
-if TVIN
-
-source "drivers/amlogic/tvin/vdin/Kconfig"
-source "drivers/amlogic/tvin/tvafe/Kconfig"
-source "drivers/amlogic/tvin/hdmirx/Kconfig"
-source "drivers/amlogic/tvin/bt656/Kconfig"
-source "drivers/amlogic/tvin/csi/Kconfig"
-source "drivers/amlogic/tvin/viu/Kconfig"
-source "drivers/amlogic/tvin/it660x/Kconfig"
-source "drivers/amlogic/tvin/isp/Kconfig"
-
-endif
-
diff --git a/drivers/amlogic/tvin/Makefile b/drivers/amlogic/tvin/Makefile
deleted file mode 100755
index 1f55fb776cd0..000000000000
--- a/drivers/amlogic/tvin/Makefile
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# Makefile for TVIN.
-#
-
-obj-$(CONFIG_TVIN) += tvin_common.o
-tvin_common-objs := tvin_format_table.o tvin_frontend.o tvin_global.o
-
-obj-$(CONFIG_TVIN_VDIN)	  += vdin/
-obj-$(CONFIG_TVIN_AFE)	  += tvafe/
-obj-$(CONFIG_TVIN_HDMI)	  += hdmirx/
-obj-$(CONFIG_TVIN_BT656)  += bt656/
-obj-$(CONFIG_TVIN_CSI)    += csi/
-obj-$(CONFIG_VIUIN)	  += viu/
-obj-$(CONFIG_TVIN_IT660X) += it660x/
-obj-$(CONFIG_TVIN_ISP)    += isp/
diff --git a/drivers/amlogic/tvin/aml.dtd b/drivers/amlogic/tvin/aml.dtd
deleted file mode 100755
index 19af6f39dd95..000000000000
--- a/drivers/amlogic/tvin/aml.dtd
+++ /dev/null
@@ -1,29 +0,0 @@
-#ifdef CONFIG_TVIN_VDIN
-//$$ DEVICE="vdin0"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 2 = "reg"
-//$$ L2 PROP_U32 = "irq"
-//$$ L2 PROP_U32 = "vdin_id"
-    vdin0{
-        compatible = "amlogic,vdin";
-        dev_name = "vdin0";
-        status = "ok";
-        reg = <0x11b00000 0x04000000>;
-        irq = <115>;
-        vdin_id = <0>;
-	};
-	
-//$$ DEVICE="vdin1"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 2 = "reg"
-//$$ L2 PROP_U32 = "irq"
-//$$ L2 PROP_U32 = "vdin_id"
-    vdin1{
-        compatible = "amlogic,vdin";
-        dev_name = "vdin1";
-        status = "ok";
-        reg = <0x15b00000 0x04000000>;
-        irq = <117>;
-        vdin_id = <1>;
-	};
-#endif
\ No newline at end of file
diff --git a/drivers/amlogic/tvin/bt656/Kconfig b/drivers/amlogic/tvin/bt656/Kconfig
deleted file mode 100755
index deaac039589f..000000000000
--- a/drivers/amlogic/tvin/bt656/Kconfig
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# BT656 Device Driver Configuration
-#
-
-
-config TVIN_BT656
-	tristate "Amlogic BT656 device driver"
-	default y
-	help
-	  BT656 device driver.
-
diff --git a/drivers/amlogic/tvin/bt656/Makefile b/drivers/amlogic/tvin/bt656/Makefile
deleted file mode 100755
index e75d06f9f5ef..000000000000
--- a/drivers/amlogic/tvin/bt656/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-$(CONFIG_TVIN_BT656) +=tvin_bt656.o
-tvin_bt656-objs := bt656_601_in.o
diff --git a/drivers/amlogic/tvin/bt656/bt656_601_in.c b/drivers/amlogic/tvin/bt656/bt656_601_in.c
deleted file mode 100755
index 667aa5c0e0f0..000000000000
--- a/drivers/amlogic/tvin/bt656/bt656_601_in.c
+++ /dev/null
@@ -1,832 +0,0 @@
-/*
- * Amlogic M1 & M2
- * frame buffer driver  -------bt656 & 601 input
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/etherdevice.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/dma-mapping.h>
-#include <asm/delay.h>
-#include <asm/atomic.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/platform_device.h>
-
-#include <linux/amlogic/amports/amstream.h>
-#include <linux/amlogic/amports/ptsserv.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <mach/am_regs.h>
-#include <mach/mod_gate.h>
-
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "../tvin_frontend.h"
-#include "bt656_601_in.h"
-
-#define DEV_NAME  "amvdec_656in"
-#define DRV_NAME  "amvdec_656in"
-#define CLS_NAME  "amvdec_656in"
-#define MOD_NAME  "amvdec_656in"
-
-//#define HANDLE_BT656IN_IRQ
-
-#define BT656_MAX_DEVS             1
-//#define BT656IN_ANCI_DATA_SIZE        0x4000
-
-#define BT656_VER "2013/11/12"
-
-/* Per-device (per-bank) structure */
-
-//static struct am656in_dev_t am656in_dev_;
-static dev_t am656in_devno;
-static struct class *am656in_clsp;
-//static struct am656in_dev_s *am656in_devp[BT656_MAX_DEVS];
-
-#ifdef HANDLE_BT656IN_IRQ
-static const char bt656in_dec_id[] = "bt656in-dev";
-#endif
-
-static void init_656in_dec_parameter(struct am656in_dev_s *devp)
-{
-	enum tvin_sig_fmt_e fmt;
-        const struct tvin_format_s * fmt_info_p;
-        fmt = devp->para.fmt;
-        fmt_info_p = tvin_get_fmt_info(fmt);
-
-    if(!fmt_info_p) {
-        printk("[bt656..]%s:invaild fmt %d.\n",__func__, fmt);
-        return;
-    }
-
-	if(fmt < TVIN_SIG_FMT_MAX)
-	{
-		devp->para.v_active    = fmt_info_p->v_active;
-		devp->para.h_active    = fmt_info_p->h_active;
-                devp->para.hsync_phase = 0;
-                devp->para.vsync_phase = 0;
-                devp->para.hs_bp       = 0;
-                devp->para.vs_bp       = 0;
-	}
-}
-
-static void reset_bt656in_module(void)
-{
-	int temp_data;
-
-	temp_data = RD(BT_CTRL);
-	temp_data &= ~( 1 << BT_EN_BIT );
-	WR(BT_CTRL, temp_data); //disable BT656 input
-
-	// reset BT656in module.
-	temp_data = RD(BT_CTRL);
-	temp_data |= ( 1 << BT_SOFT_RESET );
-	WR(BT_CTRL, temp_data);
-
-	temp_data = RD(BT_CTRL);
-	temp_data &= ~( 1 << BT_SOFT_RESET );
-	WR(BT_CTRL, temp_data);
-
-}
-
-/*
-   NTSC or PAL input(interlace mode): CLOCK + D0~D7(with SAV + EAV )
- */
-static void reinit_bt656in_dec(struct am656in_dev_s *devp)
-{
-	reset_bt656in_module();
-
-	WR(BT_FIELDSADR, (4 << 16) | 4);    // field 0/1 start lcnt: default value
-	// configuration the BT PORT control
-	// For standaREAD_CBUS_REG bt656 in stream, there's no HSYNC VSYNC pins.
-	// So we don't need to configure the port.
-	WR(BT_PORT_CTRL, 1 << BT_D8B);  // data itself is 8 bits.
-
-	WR(BT_SWAP_CTRL,    ( 4 << 0 ) |        //POS_Y1_IN
-			( 5 << 4 ) |        //POS_Cr0_IN
-			( 6 << 8 ) |        //POS_Y0_IN
-			( 7 << 12 ));       //POS_CB0_IN
-
-	WR(BT_LINECTRL , 0)  ;
-	//there is no use anci in m2
-	// ANCI is the field blanking data, like close caption. If it connected to digital camara interface, the jpeg bitstream also use this ANCI FIFO.
-	//WR(BT_ANCISADR, devp->mem_start);
-	//WR(BT_ANCIEADR, 0); //devp->mem_start + devp->mem_size);
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-
-#else
-	WR(BT_AFIFO_CTRL,   (1 <<31) |     // load start and end address to afifo.
-			(1 << 6) |     // fill _en;
-			(1 << 3)) ;     // urgent
-#endif
-
-	WR(BT_INT_CTRL ,   // (1 << 5) |    //ancififo done int.
-			//                      (1 << 4) |    //SOF interrupt enable.
-			//                      (1 << 3) |      //EOF interrupt enable.
-			(1 << 1)); // |      //input overflow interrupt enable.
-	//                      (1 << 0));      //bt656 controller error interrupt enable.
-
-	WR(BT_ERR_CNT, (626 << 16) | (1760));
-
-	if(devp->para.fmt== TVIN_SIG_FMT_BT656IN_576I_50HZ) //input is PAL
-	{
-		WR(BT_VBIEND,   22 | (22 << 16));       //field 0/1 VBI last line number
-		WR(BT_VIDEOSTART,   23 | (23 << 16));   //Line number of the first video start line in field 0/1.
-		WR(BT_VIDEOEND ,    312 |          //  Line number of the last video line in field 1. added video end for avoid overflow.
-				(312 <<16));                    // Line number of the last video line in field 0
-		WR(BT_CTRL ,    (0 << BT_UPDATE_ST_SEL) |  //Update bt656 status register when end of frame.
-				(1 << BT_COLOR_REPEAT) | //Repeated the color data when do 4:2:2 -> 4:4:4 data transfer.
-				(1 << BT_AUTO_FMT ) |           //use haREAD_CBUS_REGware to check the PAL/NTSC format input format if it's standaREAD_CBUS_REG BT656 input format.
-				(1 << BT_MODE_BIT     ) | // BT656 standaREAD_CBUS_REG interface.
-				(1 << BT_EN_BIT       ) |    // enable BT moduale.
-				(1 << BT_REF_MODE_BIT ) |    // timing reference is from bit stream.
-				(1 << BT_CLK27_SEL_BIT) |    // use external xclk27.
-				(1 << BT_XCLK27_EN_BIT)) ;    // xclk27 is input.
-		WR(VDIN_WR_V_START_END, 287 |     //v end
-				(0 << 16) );   // v start
-
-	}
-	else //if(am656in_dec_info.para.fmt  == TVIN_SIG_FMT_BT656IN_480I) //input is PAL   //input is NTSC
-	{
-		WR(BT_VBIEND,   21 | (21 << 16));       //field 0/1 VBI last line number
-		WR(BT_VIDEOSTART,   18 | (18 << 16));   //Line number of the first video start line in field 0/1.
-		WR(BT_VIDEOEND ,    257 |          //  Line number of the last video line in field 1. added video end for avoid overflow.
-				(257 <<16));                    // Line number of the last video line in field 0
-		WR(BT_CTRL ,    (0 << BT_UPDATE_ST_SEL) |  //Update bt656 status register when end of frame.
-				(1 << BT_COLOR_REPEAT) | //Repeated the color data when do 4:2:2 -> 4:4:4 data transfer.
-				(1 << BT_AUTO_FMT ) |       //use haREAD_CBUS_REGware to check the PAL/NTSC format input format if it's standaREAD_CBUS_REG BT656 input format.
-				(1 << BT_MODE_BIT     ) | // BT656 standaREAD_CBUS_REG interface.
-				(1 << BT_EN_BIT       ) |    // enable BT moduale.
-				(1 << BT_REF_MODE_BIT ) |    // timing reference is from bit stream.
-				(1 << BT_CLK27_SEL_BIT) |    // use external xclk27.
-				(1 << BT_XCLK27_EN_BIT) |       // xclk27 is input.
-				(1 << BT_FMT_MODE_BIT));   //input format is NTSC
-		WR(VDIN_WR_V_START_END, 239 |     //v end
-				(0 << 16) );   // v start
-
-	}
-
-	return;
-}
-
-//NTSC or PAL input(interlace mode): CLOCK + D0~D7 + HSYNC + VSYNC + FID
-static void reinit_bt601in_dec(struct am656in_dev_s *devp)
-{
-	reset_bt656in_module();
-
-	WR(BT_PORT_CTRL,    (0 << BT_IDQ_EN )   |     // use external idq pin.
-			(1 << BT_IDQ_PHASE )   |
-			( 1 << BT_FID_HSVS ) |         // FID came from HS VS.
-			( 1 << BT_HSYNC_PHASE ) |
-			(1 << BT_D8B )     |
-			(4 << BT_FID_DELAY ) |
-			(5 << BT_VSYNC_DELAY) |
-			(5 << BT_HSYNC_DELAY));
-
-	WR(BT_601_CTRL2 , ( 10 << 16));     // FID field check done point.
-
-	WR(BT_SWAP_CTRL,    ( 4 << 0 ) | // suppose the input bitstream format is Cb0 Y0 Cr0 Y1.
-			( 5 << 4 ) |
-			( 6 << 8 ) |
-			( 7 << 13 ) );
-
-	WR(BT_LINECTRL , ( 1 << 31 ) |   //software line ctrl enable.
-			(1644 << 16 ) |    //1440 + 204
-			220 )  ;
-
-	// ANCI is the field blanking data, like close caption. If it connected to digital camara interface, the jpeg bitstream also use this ANCI FIFO.
-	//WR(BT_ANCISADR, devp->mem_start);
-	//WR(BT_ANCIEADR, 0);//devp->mem_start + devp->mem_size);
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-
-#else
-	WR(BT_AFIFO_CTRL,   (1 <<31) |     // load start and end address to afifo.
-			(1 << 6) |     // fill _en;
-			(1 << 3)) ;     // urgent
-#endif
-	WR(BT_INT_CTRL ,   // (1 << 5) |    //ancififo done int.
-			//                      (1 << 4) |    //SOF interrupt enable.
-			//                      (1 << 3) |      //EOF interrupt enable.
-			(1 << 1)); // |      //input overflow interrupt enable.
-	//                      (1 << 0));      //bt656 controller error interrupt enable.
-	WR(BT_ERR_CNT, (626 << 16) | (2000));
-	//otherwise there is always error flag,
-	//because the camera input use HREF ont HSYNC,
-	//there are some lines without HREF sometime
-	WR(BT_FIELDSADR, (1 << 16) | 1);    // field 0/1 start lcnt
-
-	if(devp->para.fmt == TVIN_SIG_FMT_BT601IN_576I_50HZ) //input is PAL
-	{
-		WR(BT_VBIEND, 22 | (22 << 16));     //field 0/1 VBI last line number
-		WR(BT_VIDEOSTART, 23 | (23 << 16)); //Line number of the first video start line in field 0/1.
-		WR(BT_VIDEOEND , 312 |          //  Line number of the last video line in field 1. added video end for avoid overflow.
-				(312 <<16));                    // Line number of the last video line in field 0
-		WR(BT_CTRL ,    (0 << BT_MODE_BIT     ) |    // BT656 standaREAD_CBUS_REG interface.
-				(1 << BT_AUTO_FMT )     |
-				(1 << BT_EN_BIT       ) |    // enable BT moduale.
-				(0 << BT_REF_MODE_BIT ) |    // timing reference is from bit stream.
-				(0 << BT_FMT_MODE_BIT ) |     //PAL
-				(1 << BT_SLICE_MODE_BIT )|    // no ancillay flag.
-				(0 << BT_FID_EN_BIT )   |     // use external fid pin.
-				(1 << BT_CLK27_SEL_BIT) |  // use external xclk27.
-				(1 << BT_XCLK27_EN_BIT) );   // xclk27 is input.
-		WR(VDIN_WR_V_START_END, 287 |     //v end
-				(0 << 16) );   // v start
-	}
-	else //if(am656in_dec_info.para.fmt == TVIN_SIG_FMT_BT601IN_480I)   //input is NTSC
-	{
-		WR(BT_VBIEND, 21 | (21 << 16));     //field 0/1 VBI last line number
-		WR(BT_VIDEOSTART, 18 | (18 << 16)); //Line number of the first video start line in field 0/1.
-		WR(BT_VIDEOEND , 257 |          //  Line number of the last video line in field 1. added video end for avoid overflow.
-				(257 <<16));        // Line number of the last video line in field 0
-		WR(BT_CTRL ,(0 << BT_MODE_BIT     ) |    // BT656 standaREAD_CBUS_REG interface.
-				(1 << BT_AUTO_FMT )     |
-				(1 << BT_EN_BIT       ) |    // enablem656in_star BT moduale.
-				(0 << BT_REF_MODE_BIT ) |    // timing reference is from bit stream.
-				(1 << BT_FMT_MODE_BIT ) |     // NTSC
-				(1 << BT_SLICE_MODE_BIT )|    // no ancillay flag.
-				(0 << BT_FID_EN_BIT )   |     // use external fid pin.
-				(1 << BT_CLK27_SEL_BIT) |  // use external xclk27.
-				(1 << BT_XCLK27_EN_BIT) );   // xclk27 is input.
-		WR(VDIN_WR_V_START_END, 239 |     //v end
-				(0 << 16) );   // v start
-
-	}
-
-	return;
-}
-
-//CAMERA input(progressive mode): CLOCK + D0~D7 + HREF + VSYNC
-static void reinit_camera_dec(struct am656in_dev_s *devp)
-{
-	//reset_bt656in_module();
-	unsigned int temp_data;
-	unsigned char hsync_enable = devp->para.hsync_phase;
-	unsigned char vsync_enable = devp->para.vsync_phase;
-        unsigned short hs_bp       = devp->para.hs_bp;
-        unsigned short vs_bp       = devp->para.vs_bp;
-	//disable 656,reset
-	WR(BT_CTRL, 1<<31);
-
-	/*WR(BT_VIDEOSTART, 1 | (1 << 16));   //Line number of the first video start line in field 0/1.there is a blank
-	  WR(BT_VIDEOEND , (am656in_dec_info.active_line )|          //  Line number of the last video line in field 1. added video end for avoid overflow.
-	  ((am656in_dec_info.active_line ) << 16));      */             // Line number of the last video line in field 0
-	WR(BT_PORT_CTRL, (0 << BT_IDQ_EN )   |     // use external idq pin.
-			(0 << BT_IDQ_PHASE )   |
-			(0 << BT_FID_HSVS )    |         // FID came from HS VS.
-			(vsync_enable << BT_VSYNC_PHASE) |
-			(hsync_enable << BT_HSYNC_PHASE) |
-			(0 << BT_D8B )         |
-			(4 << BT_FID_DELAY )   |
-			(0 << BT_VSYNC_DELAY)  |
-			(2 << BT_HSYNC_DELAY)
-
-		      );
-	//WRITE_CBUS_REG(BT_PORT_CTRL,0x421001); 
-
-	WR(BT_601_CTRL2 , ( 10 << 16));     // FID field check done point.
-
-	WR(BT_SWAP_CTRL,
-			( 7 << 0 ) |        //POS_Cb0_IN
-			( 4 << 4 ) |        //POS_Y0_IN
-			( 5 << 8 ) |        //POS_Cr0_IN
-			( 6 << 12 ));       //POS_Y1_IN
-
-	WR(BT_LINECTRL , ( 1<< 31) |   //software line ctrl enable.
-			((devp->para.h_active<< 1)<< 16 ) |    //the number of active data per line
-			hs_bp);//horizontal active data start offset
-
-	// ANCI is the field blanking data, like close caption. If it connected to digital camara interface, the jpeg bitstream also use this ANCI FIFO.
-	//WR(BT_ANCISADR, devp->mem_start);
-	//WR(BT_ANCIEADR, 0);//devp->mem_start + devp->mem_size);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-
-#else
-	WR(BT_AFIFO_CTRL,   (1 <<31) |     // load start and end address to afifo.
-			(1 << 6) |     // fill _en;
-			(1 << 3)) ;     // urgent
-#endif
-	WR(BT_INT_CTRL ,    //(1 << 5) |    //ancififo done int.
-			//(1 << 4) |    //SOF interrupt enable.
-			//(1 << 3) |      //EOF interrupt enable.
-			(1 << 1));      //input overflow interrupt enable.
-	//(1 << 0));      //bt656 controller error interrupt enable.
-
-	WR(BT_ERR_CNT, ((2000) << 16) | (2000 * 10));   //total lines per frame and total pixel per line
-	//otherwise there is always error flag,
-	//because the camera input use HREF ont HSYNC,
-	//there are some lines without HREF sometime
-
-	WR(BT_FIELDSADR, (1 << 16) | 1);    // field 0/1 start lcnt
-
-	WR(BT_VBISTART, 1 | (1 << 16));       //field 0/1 VBI last line number
-	WR(BT_VBIEND,   1 | (1 << 16));       //field 0/1 VBI last line number
-
-
-	WR(BT_VIDEOSTART, vs_bp | (vs_bp << 16));   //Line number of the first video start line in field 0/1.there is a blank
-	WR(BT_VIDEOEND , (devp->para.v_active + vs_bp) |          //  Line number of the last video line in field 1. added video end for avoid overflow.
-			 ((devp->para.v_active + vs_bp) << 16));                   // Line number of the last video line in field 0
-
-	//enable BTR656 interface
-	#if (defined CONFIG_ARCH_MESON6)
-	WR(BT_CTRL , (1 << BT_EN_BIT)    // enable BT moduale.
-			|(0 << BT_REF_MODE_BIT )      // timing reference is from bit stream.
-			|(0 << BT_FMT_MODE_BIT )      //PAL
-			|(1 << BT_SLICE_MODE_BIT )   // no ancillay flag.
-			|(0 << BT_MODE_BIT)              // BT656 standard interface.
-			|(1 << BT_CLOCK_ENABLE)      // enable 656 clock.
-			|(0 << BT_FID_EN_BIT)            // use external fid pin.
-			|(1 << BT_XCLK27_EN_BIT)     // xclk27 is input.
-			|(1 << BT_PROG_MODE ) 
-			|(0 << BT_AUTO_FMT)  
-			|(1 << BT_CAMERA_MODE)     // enable camera mode
-			|(1 << BT_656CLOCK_RESET) 
-			|(1 << BT_SYSCLOCK_RESET) 
-		      );
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_7,0) ;  //disable XIF function. it's shared with gpioZ_3.
-	temp_data = READ_CBUS_REG(PERIPHS_PIN_MUX_9);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_9, temp_data|(1 << 13) |    // gpioZ 11 to bt656 clk;
-			(1 << 14) |    // enable gpioZ 10:3 to be bt656 dt_in
-			(1 << 15) |
-			(1 << 16));
-	#elif (defined CONFIG_ARCH_MESON8)
-	if(devp->para.isp_fe_port == TVIN_PORT_CAMERA) {		
-	        temp_data = (1 << BT_EN_BIT)    // enable BT moduale.
-			|(0 << BT_REF_MODE_BIT )      // timing reference is from bit stream.
-			|(0 << BT_FMT_MODE_BIT )      //PAL
-			|(0 << BT_SLICE_MODE_BIT )   // no ancillay flag.
-			|(0 << BT_MODE_BIT)              // BT656 standard interface.
-			|(1 << BT_CLOCK_ENABLE)      // enable 656 clock.
-			|(0 << BT_FID_EN_BIT)            // use external fid pin.
-			//|(0 << BT_XCLK27_EN_BIT)     // xclk27 is input. change to Raw_mode setting from M8
-			|(0 << BT_PROG_MODE ) 
-			|(0 << BT_AUTO_FMT)  
-			|(0 << BT_CAMERA_MODE)     // enable camera mode
-			|(1 << BT_656CLOCK_RESET) 
-			|(1 << BT_SYSCLOCK_RESET) 
-			|(1<<9)					//enable raw data output
-			|(1<<27)				//enable raw data to isp
-			|(0<<28)				//enable csi2 pin
-		    ;
-	} else {	
-	        temp_data = (1 << BT_EN_BIT)    // enable BT moduale.
-			|(0 << BT_REF_MODE_BIT )      // timing reference is from bit stream.
-			|(0 << BT_FMT_MODE_BIT )      //PAL
-			|(1 << BT_SLICE_MODE_BIT )   // no ancillay flag.
-			|(0 << BT_MODE_BIT)              // BT656 standard interface.
-			|(1 << BT_CLOCK_ENABLE)      // enable 656 clock.
-			|(0 << BT_FID_EN_BIT)            // use external fid pin.
-			//|(1 << BT_XCLK27_EN_BIT)     // xclk27 is input. change to Raw_mode setting from M8
-			|(1 << BT_PROG_MODE ) 
-			|(0 << BT_AUTO_FMT)  
-			|(1 << BT_CAMERA_MODE)     // enable camera mode
-			|(1 << BT_656CLOCK_RESET) 
-			|(1 << BT_SYSCLOCK_RESET) 
-			;
-	}
-	if(devp->para.bt_path == BT_PATH_GPIO) {
-		temp_data &= (~(1<<28));
-		WR(BT_CTRL,temp_data);
-	} else if(devp->para.bt_path == BT_PATH_CSI2){
-		temp_data |= (1<<28);
-		WR(BT_CTRL,temp_data);
-		//power on mipi csi phy
-		WRITE_CBUS_REG(HHI_CSI_PHY_CNTL0,0xfdc1ff81);
-		WRITE_CBUS_REG(HHI_CSI_PHY_CNTL1,0x3fffff);
-	        temp_data = READ_CBUS_REG(HHI_CSI_PHY_CNTL2);
-                temp_data &= 0x7ff00000;
-                temp_data |= 0x80000fc0;
-                WRITE_CBUS_REG(HHI_CSI_PHY_CNTL2,temp_data);
-	}
-		
-	#endif
-
-	return;
-}
-
-static void start_amvdec_656_601_camera_in(struct am656in_dev_s *devp)
-{
-	enum tvin_port_e port =  devp->para.port;
-        if(devp->dec_status & TVIN_AM656_RUNING){
-                printk("[bt656..] %s bt656 have started alreadly.\n",__func__);
-                return;
-        }
-        devp->dec_status = TVIN_AM656_RUNING; 
-	//NTSC or PAL input(interlace mode): D0~D7(with SAV + EAV )
-	if(port == TVIN_PORT_BT656){
-		devp->para.fmt=TVIN_SIG_FMT_BT656IN_576I_50HZ;
-		init_656in_dec_parameter(devp);
-		reinit_bt656in_dec(devp);
-		//reset_656in_dec_parameter();
-		devp->dec_status = TVIN_AM656_RUNING;
-	}
-	else if(port == TVIN_PORT_BT601){
-		devp->para.fmt=TVIN_SIG_FMT_BT601IN_576I_50HZ;
-		init_656in_dec_parameter(devp);
-		reinit_bt601in_dec(devp);
-		devp->dec_status = TVIN_AM656_RUNING;
-
-	}
-	else if(port == TVIN_PORT_CAMERA){
-		init_656in_dec_parameter(devp);
-		reinit_camera_dec(devp);
-		devp->dec_status = TVIN_AM656_RUNING;
-	}
-	else
-	{
-		devp->para.fmt  = TVIN_SIG_FMT_NULL;
-		devp->para.port = TVIN_PORT_NULL;
-		printk("[bt656..]%s: input is not selected, please try again. \n",__func__);
-		return;
-	}
-    printk("[bt656(%s)]: %s input port: %s fmt: %s.\n",BT656_VER,__func__,
-            tvin_port_str(devp->para.port),tvin_sig_fmt_str(devp->para.fmt));
-	
-	return;
-}
-
-static void stop_amvdec_656_601_camera_in(struct am656in_dev_s *devp)
-{
-	if(devp->dec_status & TVIN_AM656_RUNING){
-		reset_bt656in_module();
-		devp->dec_status = TVIN_AM656_STOP;
-	}
-	else{
-		printk("[bt656..] %s device is not started yet. \n",__func__);
-	}
-	return;
-}
-
-/*
-   return true when need skip frame otherwise return false
- */
-static bool am656_check_skip_frame(struct tvin_frontend_s * fe)
-{
-	struct am656in_dev_s * devp =  container_of(fe, am656in_dev_t, frontend);
-	if(devp->skip_vdin_frame_count > 0)
-	{
-		devp->skip_vdin_frame_count--;
-		return true;
-	}
-	else
-		return false;
-}
-int am656in_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	if((port < TVIN_PORT_BT601) ||(port > TVIN_PORT_CAMERA))
-		return -1;
-	else
-		return 0;
-}
-
-static int am656in_open(struct inode *node, struct file *file)
-{
-	am656in_dev_t *bt656_in_devp;
-	/* Get the per-device structure that contains this cdev */
-	bt656_in_devp = container_of(node->i_cdev, am656in_dev_t, cdev);
-	file->private_data = bt656_in_devp;
-	return 0;
-
-}
-static int am656in_release(struct inode *node, struct file *file)
-{    
-	file->private_data = NULL;
-	return 0;
-}
-
-static struct file_operations am656in_fops = {
-	.owner    = THIS_MODULE,
-	.open     = am656in_open,
-	.release  = am656in_release,
-};
-/*called by vdin && sever for v4l2 framework*/
-
-void am656in_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-	struct am656in_dev_s *am656_devp;
-	am656_devp = container_of(fe, am656in_dev_t, frontend);
-	start_amvdec_656_601_camera_in(am656_devp);
-
-}
-static void am656in_stop(struct tvin_frontend_s * fe, enum tvin_port_e port)
-{
-	struct am656in_dev_s *devp = container_of(fe, am656in_dev_t, frontend);
-	if((port < TVIN_PORT_BT656)||(port > TVIN_PORT_CAMERA)){
-		printk("[bt656..]%s:invaild port %d.\n",__func__, port);
-		return;
-	}
-	stop_amvdec_656_601_camera_in(devp);
-	pr_info("[bt656..] %s stop device stop ok. \n", __func__);
-}
-static void am656in_get_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-	struct am656in_dev_s *devp = container_of(fe, am656in_dev_t, frontend);
-	prop->color_format = devp->para.cfmt;
-	prop->dest_cfmt    = devp->para.dfmt;
-	prop->pixel_repeat = 0;
-}
-
-/*as use the spin_lock,
- *1--there is no sleep,
- *2--it is better to shorter the time,
- */
-int am656in_isr(struct tvin_frontend_s *fe, unsigned int hcnt)
-{
-	unsigned int ccir656_status = 0;
-	struct am656in_dev_s *devp = container_of(fe, am656in_dev_t, frontend);
-	ccir656_status = RD(BT_STATUS);
-	if(ccir656_status & 0xf0)   //AFIFO OVERFLOW
-		devp->overflow_cnt++;
-	if(devp->overflow_cnt > 5)
-	{
-		devp->overflow_cnt = 0;
-		if(devp->para.port == TVIN_PORT_BT656)  //NTSC or PAL input(interlace mode): D0~D7(with SAV + EAV )
-			reinit_bt656in_dec(devp);
-		else if(devp->para.port == TVIN_PORT_BT601)
-			reinit_bt601in_dec(devp);
-		else //if(am656in_dec_info.para.port == TVIN_PORT_CAMERA)
-			reinit_camera_dec(devp);
-		WR(BT_STATUS, ccir656_status | (1 << 9));   //WRITE_CBUS_REGite 1 to clean the SOF interrupt bit
-		printk("[bt656..] %s bt656in fifo overflow. \n",__func__);
-	}
-	return 0;
-}
-/*
-*power on 656 module&init the parameters,such as color fmt...,will be used by vdin
-*/
-static int am656in_feopen(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	struct am656in_dev_s *am656_devp = container_of(fe, am656in_dev_t, frontend);
-	struct vdin_parm_s *parm = fe->private_data;
-	if((port < TVIN_PORT_BT656)||(port > TVIN_PORT_CAMERA)){
-		printk("[bt656..]%s:invaild port %d.\n",__func__, port);
-		return -1;
-	}
-	if( TVIN_PORT_CAMERA == port ){
-		am656_devp->skip_vdin_frame_count = parm->skip_count;
-	}
-	/*copy the param from vdin to bt656*/
-	if(!memcpy(&am656_devp->para, parm, sizeof(vdin_parm_t))){
-		printk("[bt656..]%s memcpy error.\n",__func__);
-		return -1;
-	}
-	/*avoidint the param port is't equal with port*/
-	am656_devp->para.port = port;
-        printk("[bt656..] %s color format %s,hsync phase %u,vsync phase %u,"\
-                "frame rate %u,hs_bp %u,vs_bp %u.\n", __func__,
-                tvin_color_fmt_str(parm->cfmt),parm->hsync_phase,
-                parm->vsync_phase,parm->frame_rate,parm->hs_bp,parm->vs_bp);
-	#ifdef CONFIG_ARCH_MESON6
-	switch_mod_gate_by_name("bt656", 1);
-	#endif
-	return 0;
-
-}
-/*
-*power off the 656 module,clear the parameters
-*/
-static void am656in_feclose(struct tvin_frontend_s *fe)
-{
-
-	struct am656in_dev_s *devp = container_of(fe, am656in_dev_t, frontend);
-        enum tvin_port_e port = devp->para.port;
-	if((port < TVIN_PORT_BT656)||(port > TVIN_PORT_CAMERA)){
-		printk("[bt656..]%s:invaild port %d.\n",__func__, port);
-		return;
-	}
-	#ifdef CONFIG_ARCH_MESON6
-	switch_mod_gate_by_name("bt656", 0);
-	#endif
-	memset(&devp->para, 0, sizeof(vdin_parm_t));
-}
-static struct tvin_state_machine_ops_s am656_machine_ops = {
-	.nosig               = NULL,
-	.fmt_changed         = NULL,
-	.get_fmt             = NULL,
-	.fmt_config          = NULL,
-	.adc_cal             = NULL,
-	.pll_lock            = NULL,
-	.get_sig_propery     = am656in_get_sig_propery,
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-	.set_cvbs_fmt_pos    = NULL,
-#endif
-	.vga_set_param       = NULL,
-	.vga_get_param       = NULL,
-	.check_frame_skip    = am656_check_skip_frame,
-};
-static struct tvin_decoder_ops_s am656_decoder_ops_s = {
-	.support                = am656in_support,
-	.open                   = am656in_feopen,
-	.start                  = am656in_start,
-	.stop                   = am656in_stop,
-	.close                  = am656in_feclose,
-	.decode_isr             = am656in_isr,
-};
-
-static int bt656_add_cdev(struct cdev *cdevp,struct file_operations *fops,int minor)
-{
-	int ret;
-	dev_t devno=MKDEV(MAJOR(am656in_devno),minor);
-	cdev_init(cdevp,fops);
-	cdevp->owner=THIS_MODULE;
-	ret=cdev_add(cdevp,devno,1);
-	return ret;
-}
-
-
-static struct device *bt656_create_device(struct device *parent,int minor)
-{
-	dev_t devno = MKDEV(MAJOR(am656in_devno),minor);
-	return  device_create(am656in_clsp,parent,devno,NULL,"%s%d",
-			DEV_NAME,minor);
-}
-
-static void bt656_delete_device(int minor)
-{
-	dev_t devno =MKDEV(MAJOR(am656in_devno),minor);
-	device_destroy(am656in_clsp,devno);
-}
-
-static int amvdec_656in_probe(struct platform_device *pdev)
-{
-	int ret;
-	struct am656in_dev_s *devp;
-	//struct resource *res;
-	ret = 0;
-
-	//malloc dev
-	devp = kmalloc(sizeof(struct am656in_dev_s),GFP_KERNEL);
-	if(!devp){
-		pr_err("%s: failed to allocate memory\n", __func__);
-		goto fail_kmalloc_dev;
-	}
-	memset(devp,0,sizeof(struct am656in_dev_s));
-
-//	am656in_devp[pdev->id] = devp;
-
-	//create cdev and register with sysfs
-	ret = bt656_add_cdev(&devp->cdev, &am656in_fops, 0);
-	if (ret) {
-		pr_err("%s: failed to add cdev\n", __func__);
-		goto fail_add_cdev;
-	}
-	devp->dev = bt656_create_device(&pdev->dev, 0);
-	if (IS_ERR(devp->dev)) {
-		pr_err("%s: failed to create device\n", __func__);
-		ret = PTR_ERR(devp->dev);
-		goto fail_create_device;
-	}
-	/* get device memory */
-	//res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	//if (!res) {
-	//	pr_err("%s: can't get memory resource........................................\n", __func__);
-	//	ret = -EFAULT;
-	//	goto fail_get_resource_mem;
-	//} else {
-	//    devp->mem_start = res->start;
-	//    devp->mem_size = res->end - res->start + 1;
-	//    pr_info("%s: mem_start: 0x%x, mem_size: 0x%x ............................... \n", __func__,
-	//		    devp->mem_start,
-	//		    devp->mem_size);
-    //}
-    
-    
-	/*register frontend */
-    sprintf(devp->frontend.name, "%s", DEV_NAME);
-	//tvin_frontend_init(&devp->frontend, &am656_decoder_ops_s, &am656_machine_ops, pdev->id);
-    if(!tvin_frontend_init(&devp->frontend,&am656_decoder_ops_s,&am656_machine_ops, pdev->id)) {
-        if(tvin_reg_frontend(&devp->frontend))
-            printk(" %s register frontend error \n",__func__);
-    }        
-
-	/*set pinmux for ITU601 A and ITU601 B*/
-	/* set drvdata */
-	dev_set_drvdata(devp->dev, devp);
-	platform_set_drvdata(pdev, devp);
-	printk("amvdec_656in probe ok.\n");
-	return ret;
-//fail_get_resource_mem:
-fail_create_device:
-	cdev_del(&devp->cdev);
-fail_add_cdev:
-	kfree(devp);
-fail_kmalloc_dev:
-	return ret;
-
-}
-
-static int amvdec_656in_remove(struct platform_device *pdev)
-{	
-	struct am656in_dev_s *devp;
-	devp = platform_get_drvdata(pdev);
-
-	tvin_unreg_frontend(&devp->frontend);
-	bt656_delete_device(pdev->id);
-	cdev_del(&devp->cdev);
-	kfree((const void *)devp);
-	/* free drvdata */
-	dev_set_drvdata(devp->dev, NULL);
-	platform_set_drvdata(pdev, NULL);       
-	return 0;
-}
-//#ifdef CONFIG_OF
-//static const struct of_device_id bt656_dt_match[]={
-//        {       .compatible = "amlogic,amvdec_656in",   },
-//        {},
-//};
-//#else
-//#define bt656_dt_match NULL
-//#endif
-static struct platform_driver amvdec_656in_driver = {
-	.probe      = amvdec_656in_probe,
-	.remove     = amvdec_656in_remove,
-	.driver     = {
-		.name   = DRV_NAME,
-		//.of_match_table = bt656_dt_match,
-	}
-};
-
-static int __init amvdec_656in_init_module(void)
-{       
-        int ret = 0;
-        struct platform_device *pdev;
-        printk("amvdec_656in module: init.\n");
-        ret=alloc_chrdev_region(&am656in_devno, 0, BT656_MAX_DEVS, DEV_NAME);
-        if(ret<0){
-                printk("%s:failed to alloc major number\n",__func__);
-                goto fail_alloc_cdev_region;
-        }
-        printk("%s:major %d\n",__func__,MAJOR(am656in_devno));
-        am656in_clsp=class_create(THIS_MODULE,CLS_NAME);
-        if(IS_ERR(am656in_clsp)){
-                ret=PTR_ERR(am656in_clsp);
-                printk("%s:failed to create class\n",__func__);
-                goto fail_class_create;
-        }
-#if 1
-        pdev = platform_device_alloc(DEV_NAME,0);
-        if(IS_ERR(pdev)){
-                printk("[bt656..]%s alloc platform device error.\n", __func__);
-                goto fail_pdev_create;
-        }
-        if(platform_device_add(pdev)){
-                printk("[bt656..]%s failed register platform device.\n", __func__);
-                goto fail_pdev_register;
-        }
-#endif
-        if (0 != platform_driver_register(&amvdec_656in_driver)){
-                printk("failed to register amvdec_656in driver\n");
-                goto fail_pdrv_register;
-        }
-                        
-        return 0;        
-fail_pdrv_register:
-        platform_device_unregister(pdev);
-fail_pdev_register:
-        platform_device_del(pdev);
-fail_pdev_create:
-        class_destroy(am656in_clsp);
-fail_class_create:
-        unregister_chrdev_region(am656in_devno,BT656_MAX_DEVS);
-fail_alloc_cdev_region:
-        return ret;
-
-}
-
-static void __exit amvdec_656in_exit_module(void)
-{
-	printk("amvdec_656in module remove.\n");
-	class_destroy(am656in_clsp);
-	unregister_chrdev_region(am656in_devno, BT656_MAX_DEVS);
-	platform_driver_unregister(&amvdec_656in_driver);
-	return ;
-}
-
-module_init(amvdec_656in_init_module);
-module_exit(amvdec_656in_exit_module);
-
-MODULE_DESCRIPTION("AMLOGIC BT656_601 input driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("2.0.0");
-
diff --git a/drivers/amlogic/tvin/bt656/bt656_601_in.h b/drivers/amlogic/tvin/bt656/bt656_601_in.h
deleted file mode 100755
index fffbae415859..000000000000
--- a/drivers/amlogic/tvin/bt656/bt656_601_in.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * BT656IN Driver
- *
- * Author: Xintan Chen <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __BT656_601_INPUT_H
-#define __BT656_601_INPUT_H
-#include <linux/cdev.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include <mach/pinmux.h>
-#include "../tvin_frontend.h"
-#include "../tvin_global.h"
-
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-#define WR(x,val)                         WRITE_CBUS_REG(x,val)
-#define WR_BITS(x,val,start,length)       WRITE_CBUS_REG_BITS(x,val,start,length)
-#define RD(x)                             READ_CBUS_REG(x)
-#define RD_BITS(x,start,length)           READ_CBUS_REG_BITS(x,start,length)
-#else
-#define WR(x,val)                         WRITE_VCBUS_REG(x,val)
-#define WR_BITS(x,val,start,length)       WRITE_VCBUS_REG_BITS(x,val,start,length)
-#define RD(x)                             READ_VCBUS_REG(x)
-#define RD_BITS(x,start,length)           READ_VCBUS_REG_BITS(x,start,length)
-#endif
-
-enum am656_status_e{
-        TVIN_AM656_STOP,
-        TVIN_AM656_RUNING,
-};
-typedef struct am656in_dev_s{
-        int                     index;
-        dev_t                   devt;           
-        struct cdev             cdev;
-        struct device          *dev;
-        unsigned int            overflow_cnt;
-        unsigned int            skip_vdin_frame_count;
-        enum am656_status_e     dec_status;
-        struct vdin_parm_s      para;
-        struct tvin_frontend_s  frontend; 
-}am656in_dev_t;
-#endif
-
diff --git a/drivers/amlogic/tvin/csi/Kconfig b/drivers/amlogic/tvin/csi/Kconfig
deleted file mode 100755
index adc934301eab..000000000000
--- a/drivers/amlogic/tvin/csi/Kconfig
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# CSI Device Driver Configuration
-#
-
-
-config TVIN_CSI
-	tristate "Amlogic CSI device driver"
-	default y
-	help
-	  CSI device driver.
-
diff --git a/drivers/amlogic/tvin/csi/Makefile b/drivers/amlogic/tvin/csi/Makefile
deleted file mode 100755
index 079f51a6ab58..000000000000
--- a/drivers/amlogic/tvin/csi/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-$(CONFIG_TVIN_CSI) +=tvin_csi.o
-tvin_csi-objs := csi.o mipi_hw.o
diff --git a/drivers/amlogic/tvin/csi/csi.c b/drivers/amlogic/tvin/csi/csi.c
deleted file mode 100755
index 719ba4a27d06..000000000000
--- a/drivers/amlogic/tvin/csi/csi.c
+++ /dev/null
@@ -1,705 +0,0 @@
-/*
- * Amlogic M6 & M8
- * camera serial input driver  -------CSI
- * Copyright (C) 2013 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/etherdevice.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/dma-mapping.h>
-#include <asm/delay.h>
-#include <asm/atomic.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-
-#include <mach/am_regs.h>
-#include <mach/mod_gate.h>
-
-#include <mach/am_regs.h>
-#include <mach/mipi_phy_reg.h>
-#include <linux/amlogic/mipi/am_mipi_csi2.h>
-
-#include "../tvin_global.h"
-#include "../vdin/vdin_regs.h"
-#include "../vdin/vdin_drv.h"
-#include "../vdin/vdin_ctl.h"
-#include "../tvin_format_table.h"
-#include "../tvin_frontend.h"
-#include "csi.h"
-
-#define DEV_NAME  "amvdec_csi"
-#define DRV_NAME  "amvdec_csi"
-#define CLS_NAME  "amvdec_csi"
-#define MOD_NAME  "amvdec_csi"
-
-#define CSI_MAX_DEVS             1
-#define WDG_STEP_JIFFIES        10
-
-/* Per-device (per-bank) structure */
-static dev_t amcsi_devno;
-static struct class *amcsi_clsp;
-static void csi2_timer_func(unsigned long arg);
-
-static void init_csi_dec_parameter(struct amcsi_dev_s *devp)
-{
-        enum tvin_sig_fmt_e fmt;
-        const struct tvin_format_s * fmt_info_p;
-        fmt = devp->para.fmt;
-        fmt_info_p = tvin_get_fmt_info(fmt);
-
-        if(!fmt_info_p) {
-                DPRINT("[amcsi..]%s:invaild fmt %d.\n",__func__, fmt);
-                return;
-        }
-
-        if(fmt < TVIN_SIG_FMT_MAX)
-        {
-                devp->para.v_active    = fmt_info_p->v_active;
-                devp->para.h_active    = fmt_info_p->h_active;
-                devp->para.hsync_phase = 0;
-                devp->para.vsync_phase = 0;
-                devp->para.hs_bp       = 0;
-                devp->para.vs_bp       = 0;
-        }
-}
-
-static void reset_btcsi_module(void)
-{
-        DPRINT("%s, %d\n", __func__, __LINE__);
-        return;
-}
-
-/*
-   NTSC or PAL input(interlace mode): CLOCK + D0~D7(with SAV + EAV )
-   */
-static void reinit_csi_dec(struct amcsi_dev_s *devp)
-{
-        DPRINT("%s, %d\n", __func__, __LINE__);
-        return;
-}
-
-static void start_amvdec_csi(struct amcsi_dev_s *devp)
-{
-        enum tvin_port_e port =  devp->para.port;
-        if(devp->dec_status & TVIN_AMCSI_RUNNING){
-                DPRINT("[csi..] %s csi have started alreadly.\n",__func__);
-                return;
-        }
-        devp->dec_status = TVIN_AMCSI_RUNNING;
-        if(port == TVIN_PORT_MIPI){
-                init_csi_dec_parameter(devp);
-                reinit_csi_dec(devp);
-        }
-        else
-        {
-                devp->para.fmt  = TVIN_SIG_FMT_NULL;
-                devp->para.port = TVIN_PORT_NULL;
-                DPRINT("[csi..]%s: input is not selected, please try again. \n",__func__);
-                return;
-        }
-        devp->dec_status = TVIN_AMCSI_RUNNING;
-        return;
-}
-
-static void stop_amvdec_csi(struct amcsi_dev_s *devp)
-{
-        if(devp->dec_status & TVIN_AMCSI_RUNNING){
-                reset_btcsi_module();
-                devp->dec_status = TVIN_AMCSI_STOP;
-        }
-        else{
-                DPRINT("[csi..] %s device is not started yet. \n",__func__);
-        }
-        return;
-}
-
-/*
-   return true when need skip frame otherwise return false
-   */
-static bool amcsi_check_skip_frame(struct tvin_frontend_s * fe)
-{
-        struct amcsi_dev_s * devp =  container_of(fe, amcsi_dev_t, frontend);
-
-        return false;
-        if(devp->csi_parm.skip_frames > 0)
-        {
-                devp->csi_parm.skip_frames--;
-                return true;
-        }
-        else
-                return false;
-}
-int amcsi_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        if((port != TVIN_PORT_MIPI)) {
-                DPRINT("this is not MIPI port\n");
-                return -1;
-        } else {
-                return 0;
-        }
-}
-
-static int amcsi_open(struct inode *node, struct file *file)
-{
-        amcsi_dev_t *csi_devp;
-
-        /* Get the per-device structure that contains this cdev */
-        csi_devp = container_of(node->i_cdev, amcsi_dev_t, cdev);
-        file->private_data = csi_devp;
-
-        return 0;
-
-}
-static int amcsi_release(struct inode *node, struct file *file)
-{
-        file->private_data = NULL;
-        return 0;
-}
-
-static struct file_operations amcsi_fops = {
-        .owner    = THIS_MODULE,
-        .open     = amcsi_open,
-        .release  = amcsi_release,
-};
-/*called by vdin && sever for v4l2 framework*/
-
-void amcsi_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-        struct amcsi_dev_s *csi_devp;
-
-        csi_devp = container_of(fe, amcsi_dev_t, frontend);
-        start_amvdec_csi( csi_devp );
-
-}
-static void amcsi_stop(struct tvin_frontend_s * fe, enum tvin_port_e port)
-{
-        struct amcsi_dev_s *devp = container_of(fe, amcsi_dev_t, frontend);
-        if((port != TVIN_PORT_MIPI)){
-                DPRINT("%s:invaild port %d.\n",__func__, port);
-                return;
-        }
-        stop_amvdec_csi(devp);
-}
-static void amcsi_get_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-        struct amcsi_dev_s *devp = container_of(fe, amcsi_dev_t, frontend);
-        prop->color_format = devp->para.cfmt;//devp->csi_parm.csi_ofmt;
-        prop->dest_cfmt = devp->para.dfmt;
-        printk("TVIN_NV21=%d, TVIN_YUV422=%d, devp->para.cfmt=%d, devp->para.dfmt=%d\n",
-                        TVIN_NV21, TVIN_YUV422, devp->para.cfmt, devp->para.dfmt);
-        prop->dest_cfmt =TVIN_NV21;
-        prop->pixel_repeat = 0;
-}
-
-/*as use the spin_lock,
- *1--there is no sleep,
- *2--it is better to shorter the time,
- */
-int amcsi_isr(struct tvin_frontend_s *fe, unsigned int hcnt)
-{
-        struct amcsi_dev_s *devp = container_of(fe, amcsi_dev_t, frontend);
-        unsigned data1 = 0;
-        unsigned data2 = 0;
-        am_csi2_frame_t frame;
-
-        frame.w = aml_get_reg32_bits( P_CSI2_PIC_SIZE_STAT, 0, 16);
-        frame.h = aml_get_reg32_bits( P_CSI2_PIC_SIZE_STAT, 16,16);
-        frame.err = aml_read_reg32( P_CSI2_ERR_STAT0 );
-        data1 = aml_read_reg32( P_CSI2_DATA_TYPE_IN_MEM);
-        data2 = aml_read_reg32( P_CSI2_GEN_STAT0);
-
-        if(frame.err){
-                mipi_error("%s,error---pixel cnt:%d, line cnt:%d. error state:0x%x.mem type:0x%x, status:0x%x\n",
-                                __func__, frame.w, frame.h, frame.err, data1, data2);
-                devp->overflow_cnt ++;
-                aml_write_reg32( P_CSI2_ERR_STAT0, 0);
-        }
-        if( devp->overflow_cnt > 4){
-                DPRINT("should reset mipi\n");
-                devp->overflow_cnt = 0;
-                return 0;
-        }
-        devp->reset = 0;
-
-        return 0;
-}
-
-static ssize_t csi_attr_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-        ssize_t len = 0;
-        struct amcsi_dev_s *csi_devp;
-        int i;
-
-        csi_devp = dev_get_drvdata(dev);
-        if(csi_devp->dec_status != TVIN_AMCSI_RUNNING){
-                len += sprintf(buf+len, "csi does not start\n");
-                return len;
-        }
-
-        len += sprintf(buf+len, "csi parameters below\n");
-        len += sprintf(buf+len, "\tlanes=%d, channel=%d, clk_channel=%d\n"
-                        "\tmode=%d, clock_lane_mode=%d, active_pixel=%d\n"
-                        "\tactive_line=%d, frame_size=%d, ui_val=%dns\n"
-                        "\ths_freq=%dhz, urgent=%d\n",
-                        csi_devp->csi_parm.lanes,
-                        csi_devp->csi_parm.channel,
-                        csi_devp->csi_parm.clk_channel,
-                        csi_devp->csi_parm.mode,
-                        csi_devp->csi_parm.clock_lane_mode, // 0 clock gate 1: always on
-                        csi_devp->csi_parm.active_pixel,
-                        csi_devp->csi_parm.active_line,
-                        csi_devp->csi_parm.frame_size,
-                        csi_devp->csi_parm.ui_val, //ns
-                        csi_devp->csi_parm.hs_freq, //hz
-                        csi_devp->csi_parm.urgent);
-        len += sprintf(buf+len, "\treset=%d, left jiffies=%ld, reset_count=%d\n"
-                                "\tcsi_devp->t.data=%p, csi_devp=%p\n"
-                                "\tcsi_devp->t.function=%p, csi2_timer_func=%p\n",
-                                 csi_devp->reset, csi_devp->t.expires - jiffies,
-                                 csi_devp->reset_count,
-                                 csi_devp->t.data, csi_devp,
-                                 csi_devp->t.function, csi2_timer_func);
-
-        len += sprintf(buf+len, "csi adapter register below\n");
-        for( i = CSI_ADPT_START_REG; i <= CSI_ADPT_END_REG; i ++ )
-        {
-                len += sprintf(buf+len, "\t[0x%04x]=0x%08x\n",
-                               i-CSI_ADPT_START_REG, READ_CSI_ADPT_REG(i));
-        }
-
-        len += sprintf(buf+len, "csi phy register below\n");
-        for( i = CSI_PHY_START_REG; i <= CSI_PHY_END_REG; i ++ )
-        {
-                len += sprintf(buf+len, "\t[0x%04x]=0x%08x\n",
-                                i, READ_CSI_PHY_REG(i));
-        }
-
-        len += sprintf(buf+len, "csi host register below\n");
-        for( i = CSI_HST_START_REG; i <= CSI_HST_END_REG; i ++ )
-        {
-                len += sprintf(buf+len, "\t[0x%04x]=0x%08x\n",
-                               i<<2, READ_CSI_HST_REG(i));
-        }
-
-        return len;
-}
-
-static ssize_t csi_attr_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t len)
-{
-        struct amcsi_dev_s *csi_devp;
-
-        unsigned int n=0, fps=0;
-
-        unsigned char ret=0;
-        char *buf_orig, *ps, *token;
-        char *parm[6] = {NULL};
-
-        if(!buf)
-                return len;
-        buf_orig = kstrdup(buf, GFP_KERNEL);
-        //printk(KERN_INFO "input cmd : %s",buf_orig);
-        csi_devp = dev_get_drvdata(dev);
-
-        ps = buf_orig;
-        while (1) {
-                if ( n >=ARRAY_SIZE(parm) ){
-                        printk("parm array overflow, n=%d, ARRAY_SIZE(parm)=%d\n", n, ARRAY_SIZE(parm));
-                        return len;
-                }
-                token = strsep(&ps, " \n");
-                if (token == NULL)
-                        break;
-                if (*token == '\0')
-                        continue;
-                parm[n++] = token;
-        }
-
-        if ( 0 == strcmp(parm[0],"reset")){
-                printk("reset\n");
-                am_mipi_csi2_init(&csi_devp->csi_parm);
-        } else if ( 0 == strcmp(parm[0],"init")){
-                printk("init mipi measure clock\n");
-                init_am_mipi_csi2_clock();// init mipi csi measure clock
-        } else if ( 0 == strcmp(parm[0],"min")){
-                csi_devp->min_frmrate =  simple_strtol(parm[1], NULL, 16);
-                if (HZ < csi_devp->min_frmrate * WDG_STEP_JIFFIES){
-                        csi_devp->min_frmrate = HZ/WDG_STEP_JIFFIES;
-                }
-                printk("min_frmrate=%d\n", csi_devp->min_frmrate);
-        }
-
-        kfree(buf_orig);
-        return len;
-}
-
-static DEVICE_ATTR(hw_info, 0664, csi_attr_show, csi_attr_store);
-#if 0
-static irqreturn_t csi_hst_isr(int irq, void *arg)
-{
-        amcsi_dev_t *csi_devp = (amcsi_dev_t *)arg;
-        int ret = 0;
-
-        if(!csi_devp)
-                return IRQ_HANDLED;
-
-        //DPRINT("host isr MIPI_CSI2_HOST_ERR1=%x, MIPI_CSI2_HOST_ERR2=%x\n",
-        //        READ_CSI_HST_REG(MIPI_CSI2_HOST_ERR1), READ_CSI_HST_REG(MIPI_CSI2_HOST_ERR2));
-#if 0
-        if (irq == INT_CSI2_HOST){
-                ret = READ_CSI_HST_REG(MIPI_CSI2_HOST_ERR1);//, READ_CSI_HST_REG(MIPI_CSI2_HOST_ERR2));
-        } else {
-                ret = READ_CSI_HST_REG(MIPI_CSI2_HOST_ERR2);//, READ_CSI_HST_REG(MIPI_CSI2_HOST_ERR2));
-        }
-#else
-        if (irq == INT_MIPI_PHY){
-                ret = READ_CSI_PHY_REG(MIPI_PHY_INT_STS);
-        }
-#endif
-        printk("line:%d, irq=%d, state=%x\n", __LINE__, irq, ret);
-
-        if ( 0 == (ret & 0x0330))
-        {
-#if 0
-                if ( 0 == (ret & 0x1111000))
-                {
-                        printk("other, ret=%x\n",ret);
-                }else{
-                        printk("0x100, 0x10\n");
-                }
-#endif
-                return IRQ_HANDLED;
-        }
-        if (csi_devp->reset){
-                printk("already request\n");
-                return IRQ_HANDLED;
-        }
-        csi_devp->reset = 1;
-        csi_devp->t.expires = jiffies + 10; //reset after 50ms=5jiffies
-        add_timer(&csi_devp->t);
-
-	return IRQ_HANDLED;
-}
-#endif
-
-static void csi2_timer_func(unsigned long arg)
-{
-        struct amcsi_dev_s *csi_devp = (struct amcsi_dev_s *) arg;
-        if( csi_devp->period >= jiffies_to_msecs(WDG_STEP_JIFFIES) ){
-                csi_devp->t.expires = jiffies + WDG_STEP_JIFFIES;//msecs_to_jiffies(csi_devp->period);
-                csi_devp->period -= jiffies_to_msecs(WDG_STEP_JIFFIES);
-        }else if(0 == csi_devp->period){
-                if(1 == csi_devp->reset){
-                        printk("reset csi\n");
-                        am_mipi_csi2_init(&csi_devp->csi_parm);
-                        csi_devp->reset_count ++;
-                        printk("period=%d, jiffies=%d\n", csi_devp->period, msecs_to_jiffies(csi_devp->period));
-                }
-                //printk("min_frmrate=%d\n", csi_devp->min_frmrate);
-                csi_devp->period = 1000 / csi_devp->min_frmrate;
-                csi_devp->t.expires = jiffies + WDG_STEP_JIFFIES;
-                csi_devp->period -= jiffies_to_msecs(WDG_STEP_JIFFIES);
-                csi_devp->reset = 1;
-        }else if( csi_devp->period < jiffies_to_msecs(WDG_STEP_JIFFIES) ){
-                csi_devp->t.expires = jiffies + msecs_to_jiffies(csi_devp->period);
-                csi_devp->period = 0;
-        }
-        //printk("left period=%d\n", csi_devp->period);
-        add_timer(&csi_devp->t);
-}
-/*
- *power on mipi module&init the parameters,such as color fmt...,will be used by vdin
- */
-static int amcsi_feopen(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        struct amcsi_dev_s *csi_devp = container_of(fe, amcsi_dev_t, frontend);
-        struct vdin_parm_s *parm = fe->private_data;
-        csi_parm_t *p = &csi_devp->csi_parm;
-        int ret;
-
-        if((port != TVIN_PORT_MIPI)){
-                DPRINT("[mipi..]%s:invaild port %d.\n",__func__, port);
-                return -1;
-        }
-        /*copy the param from vdin to csi*/
-        if(!memcpy(&csi_devp->para, parm, sizeof(vdin_parm_t))){
-                DPRINT("[mipi..]%s memcpy error.\n",__func__);
-                return -1;
-        }
-
-        init_am_mipi_csi2_clock();// init mipi csi measure clock
-        csi_devp->para.port = port;
-
-        memcpy( &csi_devp->csi_parm, &parm->csi_hw_info, sizeof( csi_parm_t));
-        csi_devp->csi_parm.skip_frames = parm->skip_count;
-
-        csi_devp->reset = 0;
-        csi_devp->reset_count = 0;
-
-#if 0
-        csi_devp->irq_num = INT_MIPI_PHY; //INT_CSI2_HOST;
-        ret = request_irq(csi_devp->irq_num, csi_hst_isr, IRQF_SHARED, "csi-hst1"/*devp->irq_name*/, csi_devp);
-        //SET_CSI_HST_REG_MASK(MIPI_CSI2_HOST_MASK1, ~((1<< p->lanes) - 1));
-        //WRITE_CSI_HST_REG_BITS(MIPI_CSI2_HOST_MASK1, 0, 28, 1); // enable err_ecc_double
-
-        //SET_CSI_HST_REG_MASK(MIPI_CSI2_HOST_MASK1, ~((1<< p->lanes) - 1));
-        DPRINT("INT_CSI2_HOST = %d, INT_CSI2_HOST_2=%d\n", INT_CSI2_HOST, INT_CSI2_HOST_2)
-        DPRINT("mask1=%x\n", ~((1<< p->lanes) - 1));
-#if 0
-        csi_devp->irq_num = INT_CSI2_HOST_2;
-        ret = request_irq(csi_devp->irq_num, csi_hst_isr, IRQF_SHARED, "csi-hst2"/*devp->irq_name*/, csi_devp);
-#endif
-        if( ret < 0 ){
-                printk("failed to request csi_adapter irq \n");
-        }
-#endif
-
-        init_timer (&csi_devp->t);
-        csi_devp->t.data = csi_devp;
-        csi_devp->t.function = csi2_timer_func;
-        csi_devp->t.expires = jiffies + WDG_STEP_JIFFIES; //reset after 50ms=5jiffies
-        if(0 == csi_devp->min_frmrate){
-                csi_devp->min_frmrate = 1;
-        }
-        csi_devp->period = 1000 / parm->frame_rate;
-        //printk("period=%d, jiffies=%d\n", csi_devp->period, msecs_to_jiffies(csi_devp->period));
-        if(csi_devp->period <= jiffies_to_msecs(WDG_STEP_JIFFIES))
-        {
-                csi_devp->period = 0;
-        }else{
-                csi_devp->period -= jiffies_to_msecs(WDG_STEP_JIFFIES);
-        }
-
-        add_timer(&csi_devp->t);
-        am_mipi_csi2_init(&csi_devp->csi_parm);
-        return 0;
-        //csi_devp->skip_vdin_frame_count = parm->reserved;
-}
-/*
- *power off the csi module,clear the parameters
- */
-static void amcsi_feclose(struct tvin_frontend_s *fe)
-{
-        struct amcsi_dev_s *devp = container_of(fe, amcsi_dev_t, frontend);
-        enum tvin_port_e port = devp->para.port;
-
-        if((port != TVIN_PORT_MIPI)){
-                DPRINT("[mipi..]%s:invaild port %d.\n",__func__, port);
-                return;
-        }
-
-#if 0
-        devp->irq_num = INT_MIPI_PHY; //INT_CSI2_HOST;
-        free_irq(devp->irq_num, (void *)devp);
-#if 0
-        devp->irq_num = INT_CSI2_HOST_2;
-        free_irq(devp->irq_num, (void *)devp);
-#endif
-#endif
-        devp->reset = 0;
-        devp->reset_count = 0;
-
-        del_timer_sync(&devp->t);
-        am_mipi_csi2_uninit();
-
-        memset(&devp->para, 0, sizeof(vdin_parm_t));
-}
-static struct tvin_state_machine_ops_s amcsi_machine_ops = {
-        .nosig               = NULL,
-        .fmt_changed         = NULL,
-        .get_fmt             = NULL,
-        .fmt_config          = NULL,
-        .adc_cal             = NULL,
-        .pll_lock            = NULL,
-        .get_sig_propery     = amcsi_get_sig_propery,
-        .vga_set_param       = NULL,
-        .vga_get_param       = NULL,
-        .check_frame_skip    = amcsi_check_skip_frame,
-};
-static struct tvin_decoder_ops_s amcsi_decoder_ops_s = {
-        .support                = amcsi_support,
-        .open                   = amcsi_feopen,
-        .start                  = amcsi_start,
-        .stop                   = amcsi_stop,
-        .close                  = amcsi_feclose,
-        .decode_isr             = amcsi_isr,
-};
-
-static int csi_add_cdev(struct cdev *cdevp,struct file_operations *fops,int minor)
-{
-        int ret;
-        dev_t devno=MKDEV(MAJOR(amcsi_devno),minor);
-        cdev_init(cdevp,fops);
-        cdevp->owner=THIS_MODULE;
-        ret=cdev_add(cdevp,devno,1);
-        return ret;
-}
-
-
-static struct device *csi_create_device(struct device *parent,int minor)
-{
-        dev_t devno = MKDEV(MAJOR(amcsi_devno),minor);
-        return  device_create(amcsi_clsp,parent,devno,NULL,"%s%d",
-                        DEV_NAME,minor);
-}
-
-static void csi_delete_device(int minor)
-{
-        dev_t devno =MKDEV(MAJOR(amcsi_devno),minor);
-        device_destroy(amcsi_clsp,devno);
-}
-
-static int amvdec_csi_probe(struct platform_device *pdev)
-{
-        int ret;
-        struct amcsi_dev_s *devp;
-
-        ret = 0;
-
-        //malloc dev
-        devp = kmalloc(sizeof(struct amcsi_dev_s),GFP_KERNEL);
-        if(!devp){
-                pr_err("%s: failed to allocate memory\n", __func__);
-                goto fail_kmalloc_dev;
-        }
-        memset(devp,0,sizeof(struct amcsi_dev_s));
-
-        //create cdev and register with sysfs
-        ret = csi_add_cdev(&devp->cdev, &amcsi_fops, 0);
-        if (ret) {
-                pr_err("%s: failed to add cdev\n", __func__);
-                goto fail_add_cdev;
-        }
-        devp->dev = csi_create_device(&pdev->dev, 0);
-        if (IS_ERR(devp->dev)) {
-                pr_err("%s: failed to create device\n", __func__);
-                ret = PTR_ERR(devp->dev);
-                goto fail_create_device;
-        }
-        ret = device_create_file(devp->dev,&dev_attr_hw_info);
-
-        /*register frontend */
-        sprintf(devp->frontend.name, "%s", DEV_NAME);
-        tvin_frontend_init(&devp->frontend, &amcsi_decoder_ops_s, &amcsi_machine_ops, pdev->id);
-        tvin_reg_frontend(&devp->frontend);
-        /*set pinmux for ITU601 A and ITU601 B*/
-        /* set drvdata */
-        dev_set_drvdata(devp->dev, devp);
-        platform_set_drvdata(pdev, devp);
-        printk("amvdec_csi probe ok.\n");
-        return ret;
-fail_create_device:
-        cdev_del(&devp->cdev);
-fail_add_cdev:
-        kfree(devp);
-fail_kmalloc_dev:
-        return ret;
-
-}
-
-static int amvdec_csi_remove(struct platform_device *pdev)
-{
-        struct amcsi_dev_s *devp;
-
-        devp = (struct amcsi_dev_s *)platform_get_drvdata(pdev);
-
-        tvin_unreg_frontend(&devp->frontend);
-
-        device_remove_file(devp->dev,&dev_attr_hw_info);
-
-        csi_delete_device(pdev->id);
-        cdev_del(&devp->cdev);
-        kfree((const void *)devp);
-        /* free drvdata */
-        dev_set_drvdata(devp->dev, NULL);
-        platform_set_drvdata(pdev, NULL);
-        return 0;
-}
-
-static struct platform_driver amvdec_csi_driver = {
-        .probe      = amvdec_csi_probe,
-        .remove     = amvdec_csi_remove,
-        .driver     = {
-                .name   = DRV_NAME,
-        }
-};
-
-static int __init amvdec_csi_init_module(void)
-{
-        int ret = 0;
-        struct platform_device *pdev;
-        DPRINT("amvdec_csi module: init.\n");
-        ret=alloc_chrdev_region(&amcsi_devno, 0, CSI_MAX_DEVS, DEV_NAME);
-        if(ret<0){
-                printk("%s:failed to alloc major number\n",__func__);
-                goto fail_alloc_cdev_region;
-        }
-        DPRINT("%s:major %d\n",__func__,MAJOR(amcsi_devno));
-        amcsi_clsp=class_create(THIS_MODULE,CLS_NAME);
-        if(IS_ERR(amcsi_clsp)){
-                ret=PTR_ERR(amcsi_clsp);
-                printk("%s:failed to create class\n",__func__);
-                goto fail_class_create;
-        }
-        pdev = platform_device_alloc(DEV_NAME,0);
-        if(IS_ERR(pdev)){
-                printk("[csi..]%s alloc platform device error.\n", __func__);
-                goto fail_pdev_create;
-        }
-        if(platform_device_add(pdev)){
-                printk("[csi..]%s failed register platform device.\n", __func__);
-                goto fail_pdev_register;
-        }
-        if (0 != platform_driver_register(&amvdec_csi_driver)){
-                printk("failed to register amvdec_csi driver\n");
-                goto fail_pdrv_register;
-        }
-
-        DPRINT("amvdec_csi module: init. ok\n");
-        return 0;
-fail_pdrv_register:
-        platform_device_unregister(pdev);
-fail_pdev_register:
-        platform_device_del(pdev);
-fail_pdev_create:
-        class_destroy(amcsi_clsp);
-fail_class_create:
-        unregister_chrdev_region(amcsi_devno,CSI_MAX_DEVS);
-fail_alloc_cdev_region:
-        printk("amvdec_csi module: init failed, ret=%d\n", ret);
-        return ret;
-
-}
-
-static void __exit amvdec_csi_exit_module(void)
-{
-        printk("amvdec_csi module remove.\n");
-        DPRINT("%s, %d\n", __func__, __LINE__);
-        class_destroy(amcsi_clsp);
-        unregister_chrdev_region(amcsi_devno, CSI_MAX_DEVS);
-        platform_driver_unregister(&amvdec_csi_driver);
-        return ;
-}
-
-module_init(amvdec_csi_init_module);
-module_exit(amvdec_csi_exit_module);
-
-MODULE_DESCRIPTION("AMLOGIC CSI input driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0.0");
diff --git a/drivers/amlogic/tvin/csi/csi.h b/drivers/amlogic/tvin/csi/csi.h
deleted file mode 100755
index 2106296d6265..000000000000
--- a/drivers/amlogic/tvin/csi/csi.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * CSI Driver
- *
- * Author: Xintan Chen <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __CSI_INPUT_H
-#define __CSI_INPUT_H
-#include <linux/cdev.h>
-#include <mach/pinmux.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include <linux/amlogic/mipi/am_mipi_csi2.h>
-#include "../tvin_frontend.h"
-#include "../tvin_global.h"
-#ifdef PRINT_DEBUG_INFO
-#define DPRINT(...)		printk(__VA_ARGS__)
-#else
-#define DPRINT(...)
-#endif
-
-enum amcsi_status_e{
-        TVIN_AMCSI_STOP,
-        TVIN_AMCSI_RUNNING,
-        TVIN_AMCSI_START,
-};
-
-typedef struct amcsi_dev_s{
-        int                     index;
-        dev_t                   devt;           
-        struct cdev             cdev;
-        struct device          *dev;
-        unsigned int            overflow_cnt;
-        enum amcsi_status_e     dec_status;
-        struct vdin_parm_s      para;
-        csi_parm_t              csi_parm;
-        unsigned char           reset;
-        unsigned int            reset_count;
-        unsigned int            irq_num;
-        struct tvin_frontend_s  frontend; 
-        unsigned int            period;
-        unsigned int            min_frmrate;
-        struct timer_list       t;
-}amcsi_dev_t;
-//unsigned long msecs_to_jiffies(const unsigned int m);
-#endif
diff --git a/drivers/amlogic/tvin/csi/mipi_hw.c b/drivers/amlogic/tvin/csi/mipi_hw.c
deleted file mode 100755
index 84d817b920ff..000000000000
--- a/drivers/amlogic/tvin/csi/mipi_hw.c
+++ /dev/null
@@ -1,209 +0,0 @@
-/*******************************************************************
- *
- *  Copyright C 2012 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *
- *  Author: Amlogic Software
- *  Created: 2012/3/13   19:46
- *
- *******************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/etherdevice.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <mach/am_regs.h>
-#include <mach/mipi_phy_reg.h>
-#include <linux/amlogic/mipi/am_mipi_csi2.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include "csi.h"
-
-void init_am_mipi_csi2_clock(void)
-{
-        WRITE_CBUS_REG( HHI_MIPI_PHY_CLK_CNTL,  ((3 << 9)  |   // select 400Mhz (fclk_div5)
-                                (1 << 8)  |   // Enable gated clock
-                                (1 << 0)) );  // Divide output by 2
-        return;
-}
-
-
-static void init_am_mipi_csi2_host(csi_parm_t* info)
-{
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_CSI2_RESETN,    0); // csi2 reset
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_CSI2_RESETN,    0xffffffff); // release csi2 reset
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_DPHY_RSTZ,    0xffffffff); // release DPHY reset
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_N_LANES, (info->lanes-1)&3);  //set lanes
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_PHY_SHUTDOWNZ,    0xffffffff); // enable power
-        return;
-}
-
-static int init_am_mipi_csi2_adapter(csi_parm_t* info)
-{
-        unsigned data32;
-        WRITE_CSI_ADPT_REG(CSI2_CLK_RESET, 1<<CSI2_CFG_SW_RESET); //reset first
-        WRITE_CSI_ADPT_REG(CSI2_CLK_RESET, (0<<CSI2_CFG_SW_RESET)|(0<<CSI2_CFG_CLK_AUTO_GATE_OFF)); // Bring out of reset
-
-        data32  = 0;
-        data32 |= 0<< CSI2_CFG_CLR_WRRSP; 
-        data32 |= 0x3f<< CSI2_CFG_A_BRST_NUM;
-        data32 |= 3<<CSI2_CFG_A_ID;  // ?? why is 3
-        data32 |= info->urgent<<CSI2_CFG_URGENT_EN;
-        data32 |= 0<<CSI2_CFG_DDR_ADDR_LPBK;
-
-        if(info->mode == AM_CSI2_VDIN){
-                data32 |= 1<< CSI2_CFG_DDR_EN;  ///testtest 1
-                data32 |= 1<<CSI2_CFG_BUFFER_PIC_SIZE;
-                data32 |= 0<<CSI2_CFG_422TO444_MODE;///testtest 1
-                data32 |= 0<<CSI2_CFG_INV_FIELD ;
-                data32 |= 0<<CSI2_CFG_INTERLACE_EN; 
-                data32 |= 1<<CSI2_CFG_FORCE_LINE_COUNT;
-                data32 |= 1<<CSI2_CFG_FORCE_PIX_COUNT;
-                data32 |= 1<<CSI2_CFG_COLOR_EXPAND;
-                data32 |= 0<<CSI2_CFG_ALL_TO_MEM;
-        }else{
-                data32 |= 1<< CSI2_CFG_DDR_EN; 
-                data32 |= 0<<CSI2_CFG_BUFFER_PIC_SIZE;
-                data32 |= 0<<CSI2_CFG_422TO444_MODE;
-                data32 |= 0<<CSI2_CFG_INV_FIELD ;
-                data32 |= 0<<CSI2_CFG_INTERLACE_EN; 
-                data32 |= 0<<CSI2_CFG_FORCE_LINE_COUNT;
-                data32 |= 0<<CSI2_CFG_FORCE_PIX_COUNT;
-                data32 |= 0<<CSI2_CFG_COLOR_EXPAND;
-                data32 |= 1<<CSI2_CFG_ALL_TO_MEM;
-        }
-
-        data32 |= info->channel<<CSI2_CFG_VIRTUAL_CHANNEL_EN; //??how to set
-        WRITE_CSI_ADPT_REG(CSI2_GEN_CTRL0, data32);
-
-        if(info->mode == AM_CSI2_VDIN)
-                WRITE_CSI_ADPT_REG(CSI2_FORCE_PIC_SIZE, (info->active_line << CSI2_CFG_LINE_COUNT) | (info->active_pixel<<CSI2_CFG_PIX_COUNT));
-
-#if 0
-        if(info->frame){
-                WRITE_CSI_ADPT_REG(CSI2_DDR_START_ADDR, info->frame->ddr_address);
-                WRITE_CSI_ADPT_REG(CSI2_DDR_END_ADDR, info->frame->ddr_address+info->frame_size);
-        }else{
-                DPRINT("info->frame=%p\n", info->frame);
-        }
-#endif
-
-        if(info->mode == AM_CSI2_ALL_MEM)
-                WRITE_CSI_ADPT_REG(CSI2_INTERRUPT_CTRL_STAT,    1<<CSI2_CFG_VS_FAIL_INTERRUPT);///testtest appear in vdin 2165
-
-        WRITE_CSI_ADPT_REG(CSI2_CLK_RESET,     (0<<CSI2_CFG_SW_RESET) |
-                        (0<<CSI2_CFG_CLK_AUTO_GATE_OFF)|
-                        (1<<CSI2_CFG_CLK_ENABLE)|  // Enable clock
-                        (1<<CSI2_CFG_CLK_ENABLE_DWC));  // Enable host clock
-        return 0;
-}
-
-//mipi phy run by 200MHZ ---1 cycle = 1/200000000.  timing= (reg value+1)*cycle*1000000000 ns
-
-static void init_am_mipi_phy(csi_parm_t* info)
-{
-        u32 data32 = 0x80000000;
-        u32 temp_data;
-        u32 cycle_time = 5;//5 ns
-        u32 settle = (85 + 145 + (16*info->ui_val))/2;
-        settle = settle/cycle_time;
-        DPRINT("(85 + 145 + (16*%d))/2/5.4945 == settle=%d\n", info->ui_val, settle);
-        DPRINT("%s, %d\n", __func__, __LINE__);
-        DPRINT("settle=%d\n", settle);
-        settle = 25;
-        //mipi_dbg("[mipi_hw]:init_am_mipi_phy ---- mipi cycle:%d ns, hs settle:%d ns,\n",cycle_time,(settle*cycle_time));
-
-        //if(info->clock_lane_mode==1){
-        //    //use always on mode
-        //}
-        WRITE_CSI_PHY_REG(MIPI_PHY_CTRL, data32);   //soft reset bit
-        WRITE_CSI_PHY_REG(MIPI_PHY_CTRL,   0);   //release soft reset bit   
-        WRITE_CSI_PHY_REG(MIPI_PHY_CLK_LANE_CTRL ,0xd8);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TCLK_MISS ,0x8);  // clck miss = 50 ns --(x< 60 ns)
-        WRITE_CSI_PHY_REG(MIPI_PHY_TCLK_SETTLE ,0x1c);  // clck settle = 160 ns --(95ns< x < 300 ns)
-        WRITE_CSI_PHY_REG(MIPI_PHY_THS_EXIT ,0x1c);   // hs exit = 160 ns --(x>100ns)
-        WRITE_CSI_PHY_REG(MIPI_PHY_THS_SKIP ,0x9);   // hs skip = 55 ns --(40ns<x<55ns+4*UI)
-        WRITE_CSI_PHY_REG(MIPI_PHY_THS_SETTLE ,settle);   // hs settle = 160 ns --(85 ns + 6*UI<x<145 ns + 10*UI)
-        WRITE_CSI_PHY_REG(MIPI_PHY_TINIT ,0x4e20);  // >100us
-        WRITE_CSI_PHY_REG(MIPI_PHY_TMBIAS ,0x100);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TULPS_C ,0x1000);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TULPS_S ,0x100);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TLP_EN_W ,0x0c);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TLPOK ,0x100);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TWD_INIT ,0x400000);
-        WRITE_CSI_PHY_REG(MIPI_PHY_TWD_HS ,0x400000);
-        WRITE_CSI_PHY_REG(MIPI_PHY_DATA_LANE_CTRL , 0x0);
-        WRITE_CSI_PHY_REG(MIPI_PHY_DATA_LANE_CTRL1 , 0x3 | (0x1f << 2 ) | (0x3 << 7));     // enable data lanes pipe line and hs sync bit err.
-#ifdef CONFIG_ARCH_MESON6
-        WRITE_CSI_PHY_REG(MIPI_PHY_AN_CTRL0,0xa3a9); //MIPI_COMMON<15:0>=<1010,0011,1010,1001>
-        WRITE_CSI_PHY_REG(MIPI_PHY_AN_CTRL1,0xcf25); //MIPI_CHCTL1<15:0>=<1100,1111,0010,0101> 
-        WRITE_CSI_PHY_REG(MIPI_PHY_AN_CTRL2,0x0667); //MIPI_CHCTL2<15:0>=<0000,0110,0110,0111> 
-#else
-        DPRINT("HHI_GCLK_MPEG1=%x, csi2_dig_clkin=%d\n", READ_CBUS_REG(HHI_GCLK_MPEG1), (READ_CBUS_REG(HHI_GCLK_MPEG1) >> 18)&0x1);
-        WRITE_CBUS_REG(HHI_CSI_PHY_CNTL0, 0xfdc1 << 16 | 0xfd01); 
-        WRITE_CBUS_REG(HHI_CSI_PHY_CNTL1, 0x3f << 16 | 0xffff); 
-        temp_data = READ_CBUS_REG(HHI_CSI_PHY_CNTL2);//
-        //printk("temp_data=%x, == 0x8000 0fc0", temp_data);
-        //printk(" MIPI_CSI2_HOST_BASE_ADDR=%x\n", MIPI_CSI2_HOST_BASE_ADDR);
-#endif
-        //data32 =((~(info->channel))&0xf)|(0 << 4); //enable lanes digital clock
-        //data32 |= ((info->channel)<<5); //mipi_chpu  to analog
-        WRITE_CSI_PHY_REG(MIPI_PHY_CTRL,  info->clk_channel<<21);// data32);
-        return;
-}
-
-
-
-static void reset_am_mipi_csi2_host(void)
-{
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_PHY_SHUTDOWNZ,    0); // enable power
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_DPHY_RSTZ,    0); // release DPHY reset
-        WRITE_CSI_HST_REG(MIPI_CSI2_HOST_CSI2_RESETN,    0); // csi2 reset
-        return;
-}
-
-static void reset_am_mipi_csi2_adapter(void)
-{
-        unsigned data32 = READ_CSI_ADPT_REG(CSI2_GEN_CTRL0);
-        data32 &=((~0xf)<<CSI2_CFG_VIRTUAL_CHANNEL_EN);
-        WRITE_CSI_ADPT_REG(CSI2_GEN_CTRL0,data32);  // disable virtual channel
-        WRITE_CSI_ADPT_REG(CSI2_INTERRUPT_CTRL_STAT,   0x7<<CSI2_CFG_FIELD_DONE_INTERRUPT_CLR); // clear status,disable interrupt
-        WRITE_CSI_ADPT_REG(CSI2_CLK_RESET, (1<<CSI2_CFG_SW_RESET) |
-                        (1<<CSI2_CFG_CLK_AUTO_GATE_OFF)); // disable auto gate and clock
-
-        //WRITE_CBUS_REG_BITS( HHI_MIPI_PHY_CLK_CNTL,  0, 8, 1);    // disable gated clock
-        WRITE_CBUS_REG( HHI_MIPI_PHY_CLK_CNTL,  0);    // disable gated clock
-        return;
-}
-
-static void reset_am_mipi_phy(void)
-{
-        u32 data32;
-        data32 =0x1f; //disable lanes digital clock
-        data32 |= 0x1<<31; //soft reset bit
-        WRITE_CSI_PHY_REG(MIPI_PHY_CTRL,   data32);   
-#if 1
-        WRITE_CBUS_REG(HHI_CSI_PHY_CNTL0, 0xfcc1 << 16 | 0xf780); 
-        WRITE_CBUS_REG(HHI_CSI_PHY_CNTL1, 0x0 << 16 | 0xffff); 
-        WRITE_CBUS_REG(HHI_CSI_PHY_CNTL2, 0x0); 
-#endif
-        return;
-}
-
-void am_mipi_csi2_init(csi_parm_t* info)
-{
-        init_am_mipi_phy(info);
-        init_am_mipi_csi2_host(info);
-        init_am_mipi_csi2_adapter(info);
-        return;
-}
-
-void am_mipi_csi2_uninit(void)
-{
-        reset_am_mipi_phy();
-        reset_am_mipi_csi2_host();
-        reset_am_mipi_csi2_adapter();
-        return;
-}
diff --git a/drivers/amlogic/tvin/hdmirx/Kconfig b/drivers/amlogic/tvin/hdmirx/Kconfig
deleted file mode 100755
index d9dc053565c3..000000000000
--- a/drivers/amlogic/tvin/hdmirx/Kconfig
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# HDMI Rx Device Driver Configuration
-#
-
-
-config TVIN_HDMI
-    tristate "Amlogic HDMI RX device driver"
-    default n
-    help
-      HDMI RX device driver.
diff --git a/drivers/amlogic/tvin/hdmirx/Makefile b/drivers/amlogic/tvin/hdmirx/Makefile
deleted file mode 100755
index e2f7aee92915..000000000000
--- a/drivers/amlogic/tvin/hdmirx/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-#
-# Makefile for HDMI_RX.
-#
-
-obj-$(CONFIG_TVIN_HDMI) += tvin_hdmirx.o
-tvin_hdmirx-objs := hdmi_rx_wrapper.o hdmi_rx_hw.o hdmirx_drv.o hdmirx_test.o
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
deleted file mode 100755
index 82e6b35adf4b..000000000000
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_hw.c
+++ /dev/null
@@ -1,1219 +0,0 @@
-/*
- * Amlogic M6TV
- * HDMI RX
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-//#include <linux/amports/canvas.h>
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <mach/regs.h>
-#include <mach/clock.h>
-#include <mach/register.h>
-#include <mach/power_gate.h>
-
-#include <linux/amlogic/tvin/tvin.h>
-/* Local include */
-#include "hdmirx_drv.h"
-#include "hdmi_rx_reg.h"
-
-#define EDID_AUTO_CHECKSUM_ENABLE   0               // Checksum byte selection: 0=Use data stored in MEM; 1=Use checksum calculated by HW.
-#define EDID_CLK_DIVIDE_M1          2               // EDID I2C clock = sysclk / (1+EDID_CLK_DIVIDE_M1).
-#define EDID_AUTO_CEC_ENABLE        0
-#define ACR_MODE            0                       // Select which ACR scheme:
-                                                    // 0=Analog PLL based ACR;
-                                                    // 1=Digital ACR.
-
-
-#define Wr_reg_bits(reg, val, start, len) \
-  WRITE_MPEG_REG(reg, (READ_MPEG_REG(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
-
-
-#define P_HDMIRX_CTRL_PORT    0xc800e008  // TOP CTRL_PORT: 0xc800e008; DWC CTRL_PORT: 0xc800e018
-#define HDMIRX_ADDR_PORT    (0xe000)  // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-#define HDMIRX_DATA_PORT    (0xe004)  // TOP DATA_PORT: 0xc800e004; DWC DATA_PORT: 0xc800e014
-#define HDMIRX_CTRL_PORT    (0xe008)  // TOP CTRL_PORT: 0xc800e008; DWC CTRL_PORT: 0xc800e018
-
-
-static DEFINE_SPINLOCK(reg_rw_lock);
-
-static int auto_aclk_mute = 2;
-MODULE_PARM_DESC(auto_aclk_mute, "\n auto_aclk_mute \n");
-module_param(auto_aclk_mute, int, 0664);
-
-static int aud_avmute_en = 0;
-MODULE_PARM_DESC(aud_avmute_en, "\n aud_avmute_en \n");
-module_param(aud_avmute_en, int, 0664);
-
-static int aud_mute_sel = 0;
-MODULE_PARM_DESC(aud_mute_sel, "\n aud_mute_sel \n");
-module_param(aud_mute_sel, int, 0664);
-
-static bool pwr_gpio_pull_down = true;
-MODULE_PARM_DESC(pwr_gpio_pull_down, "\n pwr_gpio_pull_down \n");
-module_param(pwr_gpio_pull_down, bool, 0664);
-
-/**
- * Read data from HDMI RX CTRL
- * @param[in] addr register address
- * @return data read value
- */
-uint32_t hdmirx_rd_dwc(uint16_t addr)
-{
-    ulong flags;
-	unsigned long dev_offset = 0x10;    // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-	unsigned long data;
-	spin_lock_irqsave(&reg_rw_lock, flags);
-	WRITE_APB_REG((HDMIRX_ADDR_PORT | dev_offset), addr);
-	data = READ_APB_REG((HDMIRX_DATA_PORT | dev_offset)); 
-	spin_unlock_irqrestore(&reg_rw_lock, flags);
-	return (data);
-} /* hdmirx_rd_DWC */
-
-/**
- * Write data to HDMI RX CTRL
- * @param[in] addr register address
- * @param[in] data new register value
- */
-void hdmirx_wr_dwc(uint16_t addr, uint32_t data)
-{ 
-	/* log_info("%04X:%08X", addr, data); */
-    ulong flags;
-	unsigned long dev_offset = 0x10;    // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-    spin_lock_irqsave(&reg_rw_lock, flags);
-	WRITE_APB_REG((HDMIRX_ADDR_PORT | dev_offset), addr);
-	WRITE_APB_REG((HDMIRX_DATA_PORT | dev_offset), data);
-    spin_unlock_irqrestore(&reg_rw_lock, flags);
-	if(hdmirx_log_flag & 0x2){
-	    printk("Write DWC Reg 0x%08x <= 0x%08x\n", addr, data);
-	}
-} /* hdmirx_wr_only_DWC */
-
-
-
-uint32_t hdmirx_rd_bits_dwc( uint16_t addr, uint32_t mask)
-{
-	return get(hdmirx_rd_dwc(addr), mask);
-}
-
-
-void hdmirx_wr_bits_dwc( uint16_t addr, uint32_t mask, uint32_t value)
-{
-		hdmirx_wr_dwc(addr, set(hdmirx_rd_dwc(addr), mask, value));
-}
-
-uint16_t hdmirx_rd_phy(uint8_t reg_address)
-{
-	int cnt = 0;
-
-	//hdmirx_wr_dwc(RA_I2CM_PHYG3_SLAVE, 0x39);
-	hdmirx_wr_dwc(RA_I2CM_PHYG3_ADDRESS, reg_address);
-	hdmirx_wr_dwc(RA_I2CM_PHYG3_OPERATION, 0x02); /* read op */
-	do{ //wait i2cmpdone
-		if(hdmirx_rd_dwc(RA_HDMI_ISTS)&(1<<28)){
-		hdmirx_wr_dwc(RA_HDMI_ICLR, 1<<28);
-		break;
-	}
-	cnt++;
-	if(cnt>10000){
-		printk("[HDMIRX error]: %s(%x,%x) timeout\n", __func__, 0x39, reg_address);
-		break;
-	}
-	}while(1);
-
-	return (uint16_t)(hdmirx_rd_dwc(RA_I2CM_PHYG3_DATAI));
-}
-
-
-int hdmirx_wr_phy(uint8_t reg_address, uint16_t data)
-{
-	int error = 0;
-	int cnt = 0;
-
-	//hdmirx_wr_dwc(RA_I2CM_PHYG3_SLAVE, 0x39);
-	hdmirx_wr_dwc(RA_I2CM_PHYG3_ADDRESS, reg_address);
-	hdmirx_wr_dwc(RA_I2CM_PHYG3_DATAO, data);
-	hdmirx_wr_dwc(RA_I2CM_PHYG3_OPERATION, 0x01); /* write op */
-
-	do{ //wait i2cmpdone
-		if(hdmirx_rd_dwc(RA_HDMI_ISTS)&(1<<28)){
-		hdmirx_wr_dwc(RA_HDMI_ICLR, 1<<28);
-		break;
-	}
-	cnt++;
-	if(cnt>10000){
-		printk("[HDMIRX error]: %s(%x,%x,%x) timeout\n", __func__, 0x39, reg_address, data);
-		break;
-	}
-	}while(1);
-
-	if(hdmirx_log_flag & 0x2){
-	    printk("Write PHY Reg 0x%08x <= 0x%08x\n", reg_address, data);
-	}
-
-	return error;
-}
-
-
-
-void hdmirx_wr_top (unsigned long addr, unsigned long data)
-{
-    ulong flags;
-	unsigned long dev_offset = 0;       // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-    spin_lock_irqsave(&reg_rw_lock, flags);
-	WRITE_APB_REG((HDMIRX_ADDR_PORT | dev_offset), addr);
-	WRITE_APB_REG((HDMIRX_DATA_PORT | dev_offset), data);
-    spin_unlock_irqrestore(&reg_rw_lock, flags);
-
-	if(hdmirx_log_flag & 0x2){
-	    printk("Write TOP Reg 0x%08x <= 0x%08x\n", addr, data);
-	}
-} /* hdmirx_wr_only_TOP */
-
-unsigned long hdmirx_rd_top (unsigned long addr)
-{
-    ulong flags;
-	unsigned long dev_offset = 0;       // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-	unsigned long data;
-    spin_lock_irqsave(&reg_rw_lock, flags);
-	WRITE_APB_REG((HDMIRX_ADDR_PORT | dev_offset), addr);
-	data = READ_APB_REG((HDMIRX_DATA_PORT | dev_offset)); 
-    spin_unlock_irqrestore(&reg_rw_lock, flags);
-	return (data);
-} /* hdmirx_rd_TOP */
-
-
-/**************************
-    phy functions
-***************************/
-/** PHY GEN 3 I2C slave address (Testchip E205) */
-//#define PHY_GEN3_I2C_SLAVE_ADDR			(0x39UL)
-#define PHY_GEN3_I2C_SLAVE_ADDR			(0x69UL)
-//#define PHY_GEN3_GLUE_I2C_SLAVE_ADDR	(0x48UL)
-static void phy_set_cfgclk_freq(int cfgclk)
-{
-	hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(2,4), cfgclk);
-}
-
-static void phy_wrapper_svsretmode(int enable)
-{
-	hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(1,6), enable);
-}
-
-void hdmirx_phy_reset(bool enable)
-{
-	hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(1,0), enable);
-}
-
-void hdmirx_phy_pddq(int enable)
-{
-	hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(1,1), enable);
-}
-
-static void hdmi_rx_phy_fast_switching( int enable)
-{
-	hdmirx_wr_phy(REG_HDMI_PHY_SYSTEM_CONFIG, hdmirx_rd_phy(REG_HDMI_PHY_SYSTEM_CONFIG) | ((enable & 1) << 11));
-}
-
-static void hdmirx_phy_restart(void)
-{
-    hdmirx_phy_reset(true);
-    mdelay(1);
-    hdmirx_phy_reset(false);
-    mdelay(1);
-    hdmirx_phy_pddq(1);
-    mdelay(1);
-    phy_wrapper_svsretmode(1);
-#if 1
-    phy_set_cfgclk_freq(1);
-#endif
-    /* power up */
-    hdmirx_phy_pddq(0);
-        
-}
-
-/**************************
-    hw functions
-***************************/
-
-void phy_init(int rx_port_sel, int dcm)
-{
-	unsigned int data32;
-
-    // PDDQ = 1'b1; PHY_RESET = 1'b1;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 1             << 1;   // [1]      phypddq
-    data32 |= 1             << 0;   // [0]      phyreset
-    hdmirx_wr_dwc(RA_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-    mdelay(1);
-
-    // PDDQ = 1'b1; PHY_RESET = 1'b0;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 1             << 1;   // [1]      phypddq
-    data32 |= 0             << 0;   // [0]      phyreset
-    hdmirx_wr_dwc(RA_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    // Configuring PHY's MPLL
-    hdmirx_wr_phy(MPLL_PARAMETERS2,    0x2594);
-    hdmirx_wr_phy(MPLL_PARAMETERS3,    0x395B);
-    hdmirx_wr_phy(MPLL_PARAMETERS4,    0x3723);
-    hdmirx_wr_phy(MPLL_PARAMETERS5,    0x54BC);
-    hdmirx_wr_phy(MPLL_PARAMETERS6,    0x3A9C);
-    hdmirx_wr_phy(MPLL_PARAMETERS7,    0x310E);
-    hdmirx_wr_phy(MPLL_PARAMETERS8,    0x2520);
-
-	// Configuring I2C to work in fastmode
-	hdmirx_wr_dwc(RA_I2CM_PHYG3_MODE,    0x1);
-
-	/* write timebase override and override enable */
-	hdmirx_wr_phy(OVL_PROT_CTRL, 0x2); //disable overload protect for Philips DVD
-	hdmirx_wr_phy(REG_HDMI_PHY_CMU_CONFIG, 
-	(rx.phy.phy_cmu_config_force_val != 0) ? rx.phy.phy_cmu_config_force_val :
-	((rx.phy.lock_thres << 10) | (1 << 9) | (((1 << 9) - 1) & ((rx.phy.cfg_clk * 4) / 1000))));
-
-	data32  = 0;
-	data32 |= 0                     << 15;  // [15]     mpll_short_power_up
-	data32 |= 0                     << 13;  // [14:13]  mpll_mult
-	data32 |= 0                     << 12;  // [12]     dis_off_lp
-	data32 |= rx.phy.fast_switching << 11;  // [11]     fast_switching
-	data32 |= 0                     << 10;  // [10]     bypass_afe
-	data32 |= rx.phy.fsm_enhancement<< 9;   // [9]      fsm_enhancement
-	data32 |= 0                     << 8;   // [8]      low_freq_eq
-	data32 |= 0                     << 7;   // [7]      bypass_aligner
-	data32 |= dcm                   << 5;   // [6:5]    color_depth: 0=8-bit; 1=10-bit; 2=12-bit; 3=16-bit.
-	data32 |= 0                     << 3;   // [4:3]    sel_tmdsclk: 0=Use chan0 clk; 1=Use chan1 clk; 2=Use chan2 clk; 3=Rsvd.
-	data32 |= rx.phy.port_select_ovr_en   << 2;   // [2]      port_select_ovr_en
-	data32 |= rx_port_sel           << 0;   // [1:0]    port_select_ovr
-	hdmirx_wr_phy(REG_HDMI_PHY_SYSTEM_CONFIG,
-	(rx.phy.phy_system_config_force_val != 0) ? rx.phy.phy_system_config_force_val : data32);
-
-    // PDDQ = 1'b0; PHY_RESET = 1'b0;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 0             << 1;   // [1]      phypddq
-    data32 |= 0             << 0;   // [0]      phyreset
-    hdmirx_wr_dwc(RA_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-}   
-
-void hdmirx_phy_hw_reset(void)
-{
-    hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(2,0), 0x3);
-    mdelay(1);
-    hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(2,0), 0x2);
-    mdelay(1);
-    hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, MSK(2,0), 0x0);
-}
-
-int hdmirx_interrupts_cfg( bool enable)
-{
-	int error = 0;
-
-	if (enable) {
-		/* set enable */
-		hdmirx_wr_dwc(RA_PDEC_IEN_SET, ~0);
-		hdmirx_wr_dwc(RA_AUD_CLK_IEN_SET, ~0);
-		hdmirx_wr_dwc(RA_AUD_FIFO_IEN_SET, ~0);
-		hdmirx_wr_dwc(RA_MD_IEN_SET, ~0);
-		hdmirx_wr_dwc(RA_HDMI_IEN_SET, ~0);
-
-	} else {
-		/* clear enable */
-		hdmirx_wr_dwc(RA_PDEC_IEN_CLR, ~0);
-		hdmirx_wr_dwc(RA_AUD_CLK_IEN_CLR, ~0);
-		hdmirx_wr_dwc(RA_AUD_FIFO_IEN_CLR, ~0);
-		hdmirx_wr_dwc(RA_MD_IEN_CLR, ~0);
-		hdmirx_wr_dwc(RA_HDMI_IEN_CLR, ~0);
-		/* clear status */
-		hdmirx_wr_dwc(RA_PDEC_ICLR, ~0);
-		hdmirx_wr_dwc(RA_AUD_CLK_ICLR, ~0);
-		hdmirx_wr_dwc(RA_AUD_FIFO_ICLR, ~0);
-		hdmirx_wr_dwc(RA_MD_ICLR, ~0);
-		hdmirx_wr_dwc(RA_HDMI_ICLR, ~0);
-	}
-	return error;
-}
-
-int hdmirx_interrupts_hpd( bool enable)
-{
-	int error = 0;
-
-	if (enable) {
-		/* set enable */
-		//hdmirx_wr_dwc(RA_PDEC_IEN_SET, DVIDET|AIF_CKS_CHG|AVI_CKS_CHG|VSI_CKS_CHG|PD_FIFO_NEW_ENTRY|PD_FIFO_OVERFL);
-		hdmirx_wr_dwc(RA_PDEC_IEN_SET, DVIDET|AVI_CKS_CHG|VSI_CKS_CHG);
-
-		hdmirx_wr_dwc(RA_AUD_FIFO_IEN_SET, AFIF_OVERFL|AFIF_UNDERFL);
-		hdmirx_wr_dwc(RA_MD_IEN_SET, VIDEO_MODE);
-
-		//hdmirx_wr_dwc(RA_HDMI_IEN_SET, AKSV_RCV|DCM_CURRENT_MODE_CHG|CLK_CHANGE);
-		hdmirx_wr_dwc(RA_HDMI_IEN_SET, DCM_CURRENT_MODE_CHG|CLK_CHANGE);
-	} else {
-		/* clear enable */
-		hdmirx_wr_dwc(RA_PDEC_IEN_CLR, DVIDET|AVI_CKS_CHG|VSI_CKS_CHG);
-		hdmirx_wr_dwc(RA_AUD_FIFO_IEN_CLR, AFIF_OVERFL|AFIF_UNDERFL);
-		hdmirx_wr_dwc(RA_MD_IEN_CLR, VIDEO_MODE);
-		hdmirx_wr_dwc(RA_HDMI_IEN_CLR, DCM_CURRENT_MODE_CHG|CLK_CHANGE);
-		/* clear status */
-		hdmirx_wr_dwc(RA_PDEC_ICLR, DVIDET|AVI_CKS_CHG|VSI_CKS_CHG);
-		hdmirx_wr_dwc(RA_AUD_FIFO_ICLR, AFIF_OVERFL|AFIF_UNDERFL);
-		hdmirx_wr_dwc(RA_MD_ICLR, VIDEO_MODE);
-		hdmirx_wr_dwc(RA_HDMI_ICLR, DCM_CURRENT_MODE_CHG|CLK_CHANGE);
-	}
-	return error;
-}
-
-static int audio_init(void)
-{
-	int err = 0;
-  unsigned int data32;
-	//hdmirx_wr_bits_dwc(RA_AUD_MUTE_CTRL, AUD_MUTE_SEL, AUD_MUTE_FORCE_UN);
-
-    data32  = 0;
-    data32 |= 3     << 21;  // [22:21]  aport_shdw_ctrl
-    data32 |= auto_aclk_mute     << 19;  // [20:19]  auto_aclk_mute
-    data32 |= 1     << 10;  // [16:10]  aud_mute_speed
-    data32 |= aud_avmute_en     << 7;   // [7]      aud_avmute_en
-    data32 |= aud_mute_sel     << 5;   // [6:5]    aud_mute_sel
-    data32 |= 1     << 3;   // [4:3]    aud_mute_mode
-    data32 |= 0     << 1;   // [2:1]    aud_ttone_fs_sel
-    data32 |= 0     << 0;   // [0]      testtone_en 
-    hdmirx_wr_dwc( RA_AUD_MUTE_CTRL,  data32); // DEFAULT: {9'd0, 2'd0, 2'd0, 2'd0, 7'd48, 2'd0, 1'b1, 2'd3, 2'd3, 2'd0, 1'b0}
-	
-    data32  = 0;
-    data32 |= 0     << 4;   // [11:4]   audio_fmt_chg_thres
-    data32 |= 0     << 1;   // [2:1]    audio_fmt
-    data32 |= 0     << 0;   // [0]      audio_fmt_sel
-    hdmirx_wr_dwc( RA_AUD_PAO_CTRL,   data32); // DEFAULT: {20'd0, 8'd176, 1'b0, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 0     << 8;   // [8]      fc_lfe_exchg: 1=swap channel 3 and 4
-    hdmirx_wr_dwc( RA_PDEC_AIF_CTRL,  data32); // DEFAULT: {23'd0, 1'b0, 8'd0}
-
-    data32  = 0;
-    data32 |= 0 << 2;   // [4:2]    deltacts_irqtrig
-    data32 |= 0 << 0;   // [1:0]    cts_n_meas_mode
-    hdmirx_wr_dwc( RA_PDEC_ACRM_CTRL, data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-	
-	/* enable all outputs and select 32-bit for I2S */
-	hdmirx_wr_dwc(RA_AUD_SAO_CTRL, 1);
-
-	return err;
-}
-
-void hdmirx_audio_enable(bool en)
-{
-    unsigned int val = hdmirx_rd_dwc(RA_AUD_SAO_CTRL);
-
-    if (en) {
-        if (val != 1)
-            hdmirx_wr_dwc(RA_AUD_SAO_CTRL, 1);
-    } else {
-        if (val != 0x7ff)
-            hdmirx_wr_dwc(RA_AUD_SAO_CTRL, 0x7ff);
-    }
-}
-
-int hdmirx_audio_fifo_rst(void)
-{
-	int error = 0;
-
-	hdmirx_wr_bits_dwc(RA_AUD_FIFO_CTRL, AFIF_INIT, 1);
-	hdmirx_wr_bits_dwc(RA_AUD_FIFO_CTRL, AFIF_INIT, 0);
-	return error;
-}
-
-int hdmirx_control_clk_range(unsigned long min, unsigned long max)
-{
-	int error = 0;
-	unsigned evaltime = 0;
-	unsigned long ref_clk;
-
-	ref_clk = rx.ctrl.md_clk;
-	evaltime = (ref_clk * 4095) / 158000;
-	min = (min * evaltime) / ref_clk;
-	max = (max * evaltime) / ref_clk;
-	hdmirx_wr_bits_dwc(RA_HDMI_CKM_F, MINFREQ, min);
-	hdmirx_wr_bits_dwc(RA_HDMI_CKM_F, CKM_MAXFREQ, max);
-	return error;
-}
-
-static int packet_init(void)
-{
-	int error = 0;
-
-	hdmirx_wr_dwc(RA_PDEC_CTRL, PFIFO_STORE_FILTER_EN|PD_FIFO_WE|PDEC_BCH_EN);
-	hdmirx_wr_dwc(RA_PDEC_ASP_CTRL, AUTO_VMUTE|AUTO_SPFLAT_MUTE);
-	return error;
-}
-
-int hdmirx_packet_fifo_rst(void)
-{
-	int error = 0;
-
-	hdmirx_wr_bits_dwc(RA_PDEC_CTRL, PD_FIFO_FILL_INFO_CLR|PD_FIFO_CLR, ~0);
-	hdmirx_wr_bits_dwc(RA_PDEC_CTRL, PD_FIFO_FILL_INFO_CLR|PD_FIFO_CLR,  0);
-	return error;
-}
-
-static void control_init_more(void)
-{
-#define VSYNC_POLARITY      1                       // TX VSYNC polarity: 0=low active; 1=high active.
-   unsigned long   data32;
-
-    data32  = 0;
-    data32 |= 0                         << 13;  // [   13]  checksum_init_mode
-    data32 |= EDID_AUTO_CHECKSUM_ENABLE << 12;  // [   12]  auto_checksum_enable
-    data32 |= EDID_AUTO_CEC_ENABLE      << 11;  // [   11]  auto_cec_enable
-    data32 |= 0                         << 10;  // [   10]  scl_stretch_trigger_config
-    data32 |= 0                         << 9;   // [    9]  force_scl_stretch_trigger
-    data32 |= 1                         << 8;   // [    8]  scl_stretch_enable
-    data32 |= EDID_CLK_DIVIDE_M1 << 0;   // [ 7: 0]  clk_divide_m1
-    hdmirx_wr_top(HDMIRX_TOP_EDID_GEN_CNTL,  data32);
-
-#if 0    
-    data32  = 0;
-    data32 |= VSYNC_POLARITY    << 3;   // [4:3]    vs_pol_adj_mode:0=invert input VS; 1=no invert; 2=auto convert to high active; 3=no invert.
-    data32 |= 2                 << 1;   // [2:1]    hs_pol_adj_mode:0=invert input VS; 1=no invert; 2=auto convert to high active; 3=no invert.
-    hdmirx_wr_dwc( RA_HDMI_SYNC_CTRL,     data32); // DEFAULT: {27'd0, 2'd0, 2'd0, 1'b0}
-#endif
-
-#define interlace_mode 1    
-    data32  = 0;
-    data32 |= 1                 << 4;   // [4]      v_offs_lin_mode
-    data32 |= 1                 << 1;   // [1]      v_edge
-    data32 |= interlace_mode    << 0;   // [0]      v_mode
-    hdmirx_wr_dwc( RA_MD_VCTRL,   data32); // DEFAULT: {27'd0, 1'b0, 2'd0, 1'b1, 1'b0}
-
-    data32  = 0;
-    data32 |= 0     << 20;  // [20]     rg_block_off:1=Enable HS/VS/CTRL filtering during active video
-    data32 |= 1     << 19;  // [19]     block_off:1=Enable HS/VS/CTRL passing during active video
-    data32 |= 5     << 16;  // [18:16]  valid_mode
-    data32 |= 0     << 12;  // [13:12]  ctrl_filt_sens
-    data32 |= 3     << 10;  // [11:10]  vs_filt_sens
-    data32 |= 0     << 8;   // [9:8]    hs_filt_sens
-    data32 |= 2     << 6;   // [7:6]    de_measure_mode
-    data32 |= 0     << 5;   // [5]      de_regen
-    data32 |= 3     << 3;   // [4:3]    de_filter_sens 
-    hdmirx_wr_dwc( RA_HDMI_ERRORA_PROTECT, data32); // DEFAULT: {11'd0, 1'b0, 1'b0, 3'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 1'b0, 2'd0, 3'd0}
-
-    data32  = 0;
-    data32 |= 0     << 8;   // [10:8]   hact_pix_ith
-    data32 |= 0     << 5;   // [5]      hact_pix_src
-    data32 |= 1     << 4;   // [4]      htot_pix_src
-    hdmirx_wr_dwc( RA_MD_HCTRL1,  data32); // DEFAULT: {21'd0, 3'd1, 2'd0, 1'b0, 1'b1, 4'd0}
-
-    data32  = 0;
-    data32 |= 1     << 12;  // [14:12]  hs_clk_ith
-    data32 |= 7     << 8;   // [10:8]   htot32_clk_ith
-    data32 |= 1     << 5;   // [5]      vs_act_time
-    data32 |= 3     << 3;   // [4:3]    hs_act_time
-    data32 |= 0     << 0;   // [1:0]    h_start_pos
-    hdmirx_wr_dwc( RA_MD_HCTRL2,  data32); // DEFAULT: {17'd0, 3'd2, 1'b0, 3'd1, 2'd0, 1'b0, 2'd0, 1'b0, 2'd2}
-
-    data32  = 0;
-    data32 |= 1 << 10;  // [11:10]  vofs_lin_ith
-    data32 |= 3 << 8;   // [9:8]    vact_lin_ith 
-    data32 |= 0 << 6;   // [7:6]    vtot_lin_ith
-    data32 |= 7 << 3;   // [5:3]    vs_clk_ith
-    data32 |= 2 << 0;   // [2:0]    vtot_clk_ith
-    hdmirx_wr_dwc( RA_MD_VTH,     data32); // DEFAULT: {20'd0, 2'd2, 2'd0, 2'd0, 3'd2, 3'd2}
-
-    data32  = 0;
-    data32 |= 1 << 2;   // [2]      fafielddet_en
-    data32 |= 0 << 0;   // [1:0]    field_pol_mode
-    hdmirx_wr_dwc( RA_MD_IL_POL,  data32); // DEFAULT: {29'd0, 1'b0, 2'd0}
-
-    data32  = 0;
-    data32 |= 0                 << 1;   // [4:1]    man_vid_derepeat
-    data32 |= 1                 << 0;   // [0]      auto_derepeat
-    hdmirx_wr_dwc( RA_HDMI_RESMPL_CTRL,   data32); // DEFAULT: {27'd0, 4'd0, 1'b1}
-}
-
-static int control_init(unsigned port)
-{
-	int err = 0;
-	unsigned evaltime = 0;
-	
-  evaltime = (rx.ctrl.md_clk * 4095) / 158000;
-	hdmirx_wr_dwc(RA_HDMI_OVR_CTRL, ~0);	/* enable all */
-	hdmirx_wr_bits_dwc(RA_HDMI_SYNC_CTRL, VS_POL_ADJ_MODE, VS_POL_ADJ_AUTO);
-	hdmirx_wr_bits_dwc(RA_HDMI_SYNC_CTRL, HS_POL_ADJ_MODE, HS_POL_ADJ_AUTO);
-	hdmirx_wr_bits_dwc(RA_HDMI_CKM_EVLTM, EVAL_TIME, evaltime);
-	hdmirx_control_clk_range(TMDS_CLK_MIN, TMDS_CLK_MAX);
-	/* bit field shared between phy and controller */
-	hdmirx_wr_bits_dwc(RA_HDMI_PCB_CTRL, INPUT_SELECT, port);
-	hdmirx_wr_bits_dwc(RA_SNPS_PHYG3_CTRL, ((1 << 2) - 1) << 2, port);
-	
-	control_init_more();
-	return err;
-}
-
-
-#define HDCP_KEY_WR_TRIES		(5)
-static void hdmi_rx_ctrl_hdcp_config( const struct hdmi_rx_ctrl_hdcp *hdcp)
-{
-	int error = 0;
-	unsigned i = 0;
-	unsigned k = 0;
-
-	hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 0);
-	//hdmirx_wr_bits_dwc(ctx, RA_HDCP_CTRL, KEY_DECRYPT_ENABLE, 1);
-	hdmirx_wr_bits_dwc( RA_HDCP_CTRL, KEY_DECRYPT_ENABLE, 0);
-	hdmirx_wr_dwc(RA_HDCP_SEED, hdcp->seed);
-	for (i = 0; i < HDCP_KEYS_SIZE; i += 2) {
-		for (k = 0; k < HDCP_KEY_WR_TRIES; k++) {
-			if (hdmirx_rd_bits_dwc( RA_HDCP_STS, HDCP_KEY_WR_OK_STS) != 0) {
-				break;
-			}
-		}
-		if (k < HDCP_KEY_WR_TRIES) {
-			hdmirx_wr_dwc(RA_HDCP_KEY1, hdcp->keys[i + 0]);
-			hdmirx_wr_dwc(RA_HDCP_KEY0, hdcp->keys[i + 1]);
-		} else {
-			error = -EAGAIN;
-			break;
-		}
-	}
-	hdmirx_wr_dwc(RA_HDCP_BKSV1, hdcp->bksv[0]);
-	hdmirx_wr_dwc(RA_HDCP_BKSV0, hdcp->bksv[1]);
-	hdmirx_wr_bits_dwc( RA_HDCP_RPT_CTRL, REPEATER, hdcp->repeat? 1 : 0);
-	hdmirx_wr_dwc(RA_HDCP_RPT_BSTATUS, 0);	/* nothing attached downstream */
-
-  hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 1);
-	
-}
-
-#if 0
-static void hdmi_rx_ctrl_hpd(bool enable)
-{
-	hdmirx_wr_bits_dwc(RA_HDMI_SETUP_CTRL, HOT_PLUG_DETECT, enable? 1 : 0);
-}
-#endif
-
-void hdmirx_set_hpd(int port, unsigned char val)
-{
-#ifdef USE_GPIO_FOR_HPD
-    int bitpos = 1;
-    switch(port){
-        case 0:
-            bitpos=1;
-            break;
-        case 1:
-            bitpos=5;
-            break;
-        case 2:
-            bitpos=9;
-            break;
-        case 3:
-            bitpos=13;
-            break;
-    }
-    if(val){
-        WRITE_CBUS_REG(PREG_PAD_GPIO5_O, READ_CBUS_REG(PREG_PAD_GPIO5_O) & (~(1<<bitpos)));
-    }
-    else{
-        WRITE_CBUS_REG(PREG_PAD_GPIO5_O, READ_CBUS_REG(PREG_PAD_GPIO5_O) | (1<<bitpos));
-    }
-#else
-    if(val){
-        hdmirx_wr_top( HDMIRX_TOP_HPD_PWR5V,  hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)|(1<<rx.port));
-    }
-    else{
-        hdmirx_wr_top( HDMIRX_TOP_HPD_PWR5V,  hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)&(~(1<<rx.port)));
-    }
-#endif
-    hdmirx_print("%s(%d,%d)\n", __func__, port, val);
-    
-}
-
-
-static void control_reset(unsigned char seq)
-{
-    unsigned long   data32;
-
-    if (seq == 0) {
-        //DWC reset default to be active, until reg HDMIRX_TOP_SW_RESET[0] is set to 0.
-        //hdmirx_rd_check_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_SW_RESET, 0x1, 0x0);
-        // IP reset
-        //hdmirx_wr_top( HDMIRX_TOP_SW_RESET, 0x3f);
-        //mdelay(50);
-        // Release IP reset
-        hdmirx_wr_top( HDMIRX_TOP_SW_RESET, 0x0);
-
-    /* add delay for audio problem */
-        mdelay(2);
-    
-    // Enable functional modules
-    data32  = 0;
-    data32 |= 0 << 5;   // [5]      cec_enable
-    data32 |= 1 << 4;   // [4]      aud_enable
-    data32 |= 1 << 3;   // [3]      bus_enable
-    data32 |= 1 << 2;   // [2]      hdmi_enable
-    data32 |= 1 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_dwc(RA_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    mdelay(1);
-    // Reset functional modules
-    hdmirx_wr_dwc(RA_DMI_SW_RST,     0x0000007F);
-
-    mdelay(1);
-
-    //hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_DMI_SW_RST,   0, 0);
-
-    // RX Reset
-    }
-    else{
-    data32  = 0;
-    data32 |= 0 << 5;   // [5]      cec_enable
-    data32 |= 0 << 4;   // [4]      aud_enable
-    data32 |= 0 << 3;   // [3]      bus_enable
-    data32 |= 0 << 2;   // [2]      hdmi_enable
-    data32 |= 0 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_dwc(RA_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    mdelay(1);
-
-    //--------------------------------------------------------------------------
-    // Bring up RX
-    //--------------------------------------------------------------------------
-    data32  = 0;
-    data32 |= 0 << 5;   // [5]      cec_enable
-    data32 |= 1 << 4;   // [4]      aud_enable
-    data32 |= 1 << 3;   // [3]      bus_enable
-    data32 |= 1 << 2;   // [2]      hdmi_enable
-    data32 |= 1 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_dwc(RA_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    mdelay(1);
-    }
-}
-
-void hdmirx_set_pinmux(void)
-{
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0 , READ_CBUS_REG(PERIPHS_PIN_MUX_0 )|
-				( (1 << 27)   |   // pm_gpioW_0_hdmirx_5V_A  
-				(1 << 26)   |   // pm_gpioW_1_hdmirx_HPD_A 
-				(1 << 25)   |   // pm_gpioW_2_hdmirx_scl_A 
-				(1 << 24)   |   // pm_gpioW_3_hdmirx_sda_A 
-				(1 << 23)   |   // pm_gpioW_4_hdmirx_5V_B  
-				(1 << 22)   |   // pm_gpioW_5_hdmirx_HPD_B 
-				(1 << 21)   |   // pm_gpioW_6_hdmirx_scl_B 
-				(1 << 20)   |   // pm_gpioW_7_hdmirx_sda_B 
-				(1 << 19)   |   // pm_gpioW_8_hdmirx_5V_C  
-				(1 << 18)   |   // pm_gpioW_9_hdmirx_HPD_C 
-				(1 << 17)   |   // pm_gpioW_10_hdmirx_scl_C
-				(1 << 16)   |   // pm_gpioW_11_hdmirx_sda_C
-				(1 << 15)   |   // pm_gpioW_12_hdmirx_5V_D 
-				(1 << 14)   |   // pm_gpioW_13_hdmirx_HPD_D
-				(1 << 13)   |   // pm_gpioW_14_hdmirx_scl_D
-				(1 << 12)   |   // pm_gpioW_15_hdmirx_sda_D
-				(1 << 11)));     // pm_gpioW_16_hdmirx_cec  
-#ifdef USE_GPIO_FOR_HPD
-    if (pwr_gpio_pull_down)
-        WRITE_CBUS_REG(PAD_PULL_UP_REG2, READ_CBUS_REG(PAD_PULL_UP_REG2) |
-	            ((1<<0)|(1<<4)|(1<<8)|(1<<12)));
-
-    WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0 ) &
-                (~((1<<26)|(1<<22)|(1<<18)|(1<<14))));
-                
-    WRITE_CBUS_REG(PREG_PAD_GPIO5_EN_N, READ_CBUS_REG(PREG_PAD_GPIO5_EN_N) &
-                (~((1<<1)|(1<<5)|(1<<9)|(1<<13))));
-
-    WRITE_CBUS_REG(PREG_PAD_GPIO5_O, READ_CBUS_REG(PREG_PAD_GPIO5_O) |
-                ((1<<1)|(1<<5)|(1<<9)|(1<<13)));
-#endif
-
-#if 0
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_1 , READ_CBUS_REG(PERIPHS_PIN_MUX_1 )|
-				( (1 << 2)    |   // pm_gpioW_17_hdmirx_tmds_clk
-				(1 << 1)    |   // pm_gpioW_18_hdmirx_pix_clk 
-				(1 << 0)));      // pm_gpioW_19_hdmirx_audmeas 
-#endif
-
-}    
-
-void clk_off(void)
-{
-
-    WRITE_MPEG_REG(HHI_HDMIRX_AUD_CLK_CNTL, 0x0);
-    WRITE_MPEG_REG(HHI_HDMIRX_CLK_CNTL,     0x0);
-    Wr_reg_bits(HHI_GCLK_MPEG0, 0, 21, 1);  // Turn 0ff clk_hdmirx_pclk, also = sysclk
-}
-
-void clk_init(void)
-{
-    unsigned int data32;
-
-
-    /* DWC clock enable */
-
-    Wr_reg_bits(HHI_GCLK_MPEG0, 1, 21, 1);  // Turn on clk_hdmirx_pclk, also = sysclk
-
-    // Enable APB3 fail on error
-    *((volatile unsigned long *) P_HDMIRX_CTRL_PORT)          |= (1 << 15);   // APB3 to HDMIRX-TOP err_en
-    *((volatile unsigned long *) (P_HDMIRX_CTRL_PORT+0x10))   |= (1 << 15);   // APB3 to HDMIRX-DWC err_en
-
-    //turn on clocks: md, cfg...
-
-    data32  = 0;
-    data32 |= 0 << 25;  // [26:25] HDMIRX mode detection clock mux select: osc_clk
-    data32 |= 1 << 24;  // [24]    HDMIRX mode detection clock enable
-    data32 |= 0 << 16;  // [22:16] HDMIRX mode detection clock divider
-    data32 |= 3 << 9;   // [10: 9] HDMIRX config clock mux select: fclk_div5=400MHz
-    data32 |= 1 << 8;   // [    8] HDMIRX config clock enable
-    data32 |= 3 << 0;   // [ 6: 0] HDMIRX config clock divider: 400/4=100MHz
-    WRITE_MPEG_REG(HHI_HDMIRX_CLK_CNTL,     data32);
-
-    data32  = 0;
-    data32 |= 2             << 25;  // [26:25] HDMIRX ACR ref clock mux select: fclk_div5
-    data32 |= rx.ctrl.acr_mode      << 24;  // [24]    HDMIRX ACR ref clock enable
-    data32 |= 0             << 16;  // [22:16] HDMIRX ACR ref clock divider
-    data32 |= 2             << 9;   // [10: 9] HDMIRX audmeas clock mux select: fclk_div5
-    data32 |= 1             << 8;   // [    8] HDMIRX audmeas clock enable
-    data32 |= 1             << 0;   // [ 6: 0] HDMIRX audmeas clock divider: 400/2 = 200MHz
-    WRITE_MPEG_REG(HHI_HDMIRX_AUD_CLK_CNTL, data32);
-
-    data32  = 0;
-    data32 |= 1 << 17;  // [17]     audfifo_rd_en
-    data32 |= 1 << 16;  // [16]     pktfifo_rd_en
-    data32 |= 1 << 2;   // [2]      hdmirx_cecclk_en
-    data32 |= 0 << 1;   // [1]      bus_clk_inv
-    data32 |= 0 << 0;   // [0]      hdmi_clk_inv
-    hdmirx_wr_top( HDMIRX_TOP_CLK_CNTL, data32);    // DEFAULT: {32'h0}
-  
-
-}
-
-void hdmirx_hw_config(void)
-{
-	hdmirx_print("%s %d\n", __func__, rx.port);
-	WRITE_CBUS_REG(RESET0_REGISTER, 0x8); //reset HDMIRX module
-	mdelay(10);
-	clk_init();
-	hdmirx_wr_top(HDMIRX_TOP_INTR_MASKN, 0); //disable top interrupt gate
-	control_reset(0);
-	hdmirx_wr_top( HDMIRX_TOP_PORT_SEL,   (1<<rx.port));  //EDID port select
-	hdmirx_interrupts_cfg(false); //disable dwc interrupt
-	if(hdcp_enable){
-		hdmi_rx_ctrl_hdcp_config(&rx.hdcp);
-	} else {
-		hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 0);
-	}
-
-	/*phy config*/
-	//hdmirx_phy_restart();
-	//hdmi_rx_phy_fast_switching(1);
-	phy_init(rx.port, 0); //port, dcm
-	/**/
-
-	/* control config */    
-	control_init(rx.port);
-	audio_init();
-	packet_init();
-	hdmirx_audio_fifo_rst();
-	hdmirx_packet_fifo_rst();
-	/**/
-	control_reset(1);
-
-	/*enable irq */
-    hdmirx_wr_top(HDMIRX_TOP_INTR_STAT_CLR, ~0);
-    hdmirx_wr_top(HDMIRX_TOP_INTR_MASKN, 0x00001fff);
-    hdmirx_interrupts_hpd(true);
-	/**/
-
-#ifndef USE_GPIO_FOR_HPD
-	hdmi_rx_ctrl_hpd(true);
-	hdmirx_wr_top( HDMIRX_TOP_HPD_PWR5V, (1<<5)|(1<<4)); //invert HDP output
-#endif
-
-	/* wait at least 4 video frames (at 24Hz) : 167ms for the mode detection
-	recover the video mode */
-	mdelay(200);
-
-	/* Check If HDCP engine is in Idle state, if not wait for authentication time.
-	200ms is enough if no Ri errors */
-    if (hdmirx_rd_dwc(0xe0) != 0)
-    {
-        mdelay(200);
-    }
-
-}
-
-void hdmirx_hw_reset(void)
-{
-    hdmirx_print("%s %d\n", __func__, rx.port);
-    //WRITE_CBUS_REG(RESET0_REGISTER, 0x8); //reset HDMIRX module
-    //mdelay(10);
-    //clk_init();
-    hdmirx_wr_top(HDMIRX_TOP_INTR_MASKN, 0); //disable top interrupt gate
-    hdmirx_wr_top( HDMIRX_TOP_SW_RESET, 0x3f);
-    mdelay(1);
-    control_reset(0);
-    hdmirx_wr_top( HDMIRX_TOP_PORT_SEL,   (1<<rx.port));  //EDID port select
-    hdmirx_interrupts_cfg(false); //disable dwc interrupt
-    if(hdcp_enable){
-        hdmi_rx_ctrl_hdcp_config(&rx.hdcp);
-    } else {
-        hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 0);
-    }
-
-    /*phy config*/
-    //hdmirx_phy_restart();
-    //hdmi_rx_phy_fast_switching(1);
-    phy_init(rx.port, 0); //port, dcm
-    /**/
-
-    /* control config */
-    control_init(rx.port);
-    audio_init();
-    packet_init();
-    hdmirx_audio_fifo_rst();
-    hdmirx_packet_fifo_rst();
-    /**/
-    control_reset(1);
-
-    /*enable irq */
-    hdmirx_wr_top(HDMIRX_TOP_INTR_STAT_CLR, ~0);
-    hdmirx_wr_top(HDMIRX_TOP_INTR_MASKN, 0x00001fff);
-    hdmirx_interrupts_hpd(true);
-    /**/
-
-#ifndef USE_GPIO_FOR_HPD
-    hdmi_rx_ctrl_hpd(true);
-    hdmirx_wr_top( HDMIRX_TOP_HPD_PWR5V, (1<<5)|(1<<4)); //invert HDP output
-#endif
-
-    /* wait at least 4 video frames (at 24Hz) : 167ms for the mode detection
-    recover the video mode */
-    mdelay(200);
-
-    /* Check If HDCP engine is in Idle state, if not wait for authentication time.
-    200ms is enough if no Ri errors */
-    if (hdmirx_rd_dwc(0xe0) != 0)
-    {
-        mdelay(200);
-    }
-
-}
-
-/***********************
-   get infor and config:
-hdmirx_packet_get_avi
-hdmirx_get_video_info
-************************/
-int hdmirx_packet_get_avi(struct hdmi_rx_ctrl_video *params)
-{
-	int error = 0;
-
-	params->video_format = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, VIDEO_FORMAT);
-	params->active_valid = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, ACT_INFO_PRESENT);
-	params->bar_valid = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, BAR_INFO_VALID);
-	params->scan_info = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, SCAN_INFO);
-	params->colorimetry = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, COLORIMETRY);
-	params->picture_ratio = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, PIC_ASPECT_RATIO);
-	params->active_ratio = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, ACT_ASPECT_RATIO);
-	params->it_content = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, IT_CONTENT);
-	params->ext_colorimetry = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, EXT_COLORIMETRY);
-	params->rgb_quant_range = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, RGB_QUANT_RANGE);
-	params->n_uniform_scale = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, NON_UNIF_SCALE);
-	params->video_mode = hdmirx_rd_bits_dwc(RA_PDEC_AVI_PB, VID_IDENT_CODE);
-	params->pixel_repetition = hdmirx_rd_bits_dwc(RA_PDEC_AVI_HB, PIX_REP_FACTOR);
-	/** @note HW does not support AVI YQ1-0, YCC quantization range */
-	/** @note HW does not support AVI CN1-0, IT content type */
-	params->bar_end_top = hdmirx_rd_bits_dwc(RA_PDEC_AVI_TBB, LIN_END_TOP_BAR);
-	params->bar_start_bottom = hdmirx_rd_bits_dwc(RA_PDEC_AVI_TBB, LIN_ST_BOT_BAR);
-	params->bar_end_left = hdmirx_rd_bits_dwc(RA_PDEC_AVI_LRB, PIX_END_LEF_BAR);
-	params->bar_start_right = hdmirx_rd_bits_dwc(RA_PDEC_AVI_LRB, PIX_ST_RIG_BAR);
-	return error;
-}
-
-int hdmirx_get_video_info(struct hdmi_rx_ctrl *ctx, struct hdmi_rx_ctrl_video *params)
-{
-	int error = 0;
-	const unsigned factor = 100;
-	unsigned divider = 0;
-	uint32_t tmp = 0;
-
-	/* DVI mode */
-	params->dvi = hdmirx_rd_bits_dwc(RA_PDEC_STS, DVIDET) != 0;
-	/* AVI parameters */
-	error |= hdmirx_packet_get_avi( params);
-	if (error != 0) {
-		goto exit;
-	}
-	/* pixel clock */
-	params->pixel_clk = ctx->tmds_clk;
-	/* refresh rate */
-	tmp = hdmirx_rd_bits_dwc( RA_MD_VTC, VTOT_CLK);
-	params->refresh_rate = (tmp == 0)? 0: (ctx->md_clk * 100000) / tmp;
-	/* image parameters */
-	params->interlaced = hdmirx_rd_bits_dwc( RA_MD_STS, ILACE) != 0;
-	params->voffset = hdmirx_rd_bits_dwc( RA_MD_VOL, VOFS_LIN);
-	params->vactive = hdmirx_rd_bits_dwc( RA_MD_VAL, VACT_LIN);
-	params->vtotal = hdmirx_rd_bits_dwc( RA_MD_VTL, VTOT_LIN);
-	if (params->interlaced)	{
-		//params->voffset <<= 1;
-		//params->vactive <<= 1;
-		//params->vtotal <<= 1;
-	}
-	params->hoffset = hdmirx_rd_bits_dwc( RA_MD_HT1, HOFS_PIX);
-	params->hactive = hdmirx_rd_bits_dwc( RA_MD_HACT_PX, HACT_PIX);
-	params->htotal = hdmirx_rd_bits_dwc( RA_MD_HT1, HTOT_PIX);
-	/* deep color mode */
-	tmp = hdmirx_rd_bits_dwc( RA_HDMI_STS, DCM_CURRENT_MODE);
-#if 0
-	if (hdmirx_rd_bits_dwc( RA_PDEC_ISTS, DVIDET|AVI_CKS_CHG) != 0
-		|| hdmirx_rd_bits_dwc( RA_MD_ISTS, VIDEO_MODE) != 0
-		|| hdmirx_rd_bits_dwc( RA_HDMI_ISTS, DCM_CURRENT_MODE_CHG) != 0) {
-		printk("%s error\n", __func__);
-		error = -EAGAIN;
-		goto exit;
-	}
-#endif	
-	switch (tmp) {
-	case DCM_CURRENT_MODE_48b:
-		params->deep_color_mode = 48;
-		divider = 2.00 * factor;	/* divide by 2 */
-		break;
-	case DCM_CURRENT_MODE_36b:
-		params->deep_color_mode = 36;
-		divider = 1.50 * factor;	/* divide by 1.5 */
-		break;
-	case DCM_CURRENT_MODE_30b:
-		params->deep_color_mode = 30;
-		divider = 1.25 * factor;	/* divide by 1.25 */
-		break;
-	default:
-		params->deep_color_mode = 24;
-		divider = 1.00 * factor;
-		break;
-	}
-	params->pixel_clk = (params->pixel_clk * factor) / divider;
-	params->hoffset = (params->hoffset * factor) / divider;
-	params->hactive	= (params->hactive * factor) / divider;
-	params->htotal = (params->htotal  * factor) / divider;
-
-exit:
-	return error;
-}
-
-
-void hdmirx_config_video(struct hdmi_rx_ctrl_video *video_params)
-{
-	int data32=0;
-
-	if ((video_params->sw_vic >= HDMI_3840_2160p) && (video_params->sw_vic <= HDMI_4096_2160p))
-	    data32 |= 1 << 23; //video_params.pixel_repetition << 23;  // [23]     hscale_half: 1=Horizontally scale down by half
-	else
-	    data32 |= 0 << 23; //video_params.pixel_repetition << 23;  // [23]     hscale_half: 1=Horizontally scale down by half
-
-    data32 |= 0                             << 22;  // [22]     force_vid_rate: 1=Force video output sample rate
-    data32 |= 0                             << 19;  // [21:19]  force_vid_rate_chroma_cfg : 0=Bypass, not rate change. Applicable only if force_vid_rate=1
-    data32 |= 0                             << 16;  // [18:16]  force_vid_rate_luma_cfg   : 0=Bypass, not rate change. Applicable only if force_vid_rate=1
-    data32 |= 0x7fff                        << 0;   // [14: 0]  hsizem1
-    hdmirx_wr_top( HDMIRX_TOP_VID_CNTL,   data32);
-}    
-
-int hdmirx_config_audio(void)
-{
-#define AUD_CLK_DELTA   2000
-#define RX_8_CHANNEL        1        // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
-int err = 0;
-unsigned long data32 = 0;
-#if 1
-    data32  = 0;
-    data32 |= 0         << 9;   // [9]      force_afif_status:1=Use cntl_audfifo_status_cfg as fifo status; 0=Use detected afif_status.
-    data32 |= 1         << 8;   // [8]      afif_status_auto:1=Enable audio FIFO status auto-exit EMPTY/FULL, if FIFO level is back to LipSync; 0=Once enters EMPTY/FULL, never exits.
-    data32 |= 1         << 6;   // [ 7: 6]  Audio FIFO nominal level :0=s_total/4;1=s_total/8;2=s_total/16;3=s_total/32.
-    data32 |= 3         << 4;   // [ 5: 4]  Audio FIFO critical level:0=s_total/4;1=s_total/8;2=s_total/16;3=s_total/32.
-    data32 |= 0         << 3;   // [3]      afif_status_clr:1=Clear audio FIFO status to IDLE.
-    data32 |= rx.ctrl.acr_mode  << 2;   // [2]      dig_acr_en
-    data32 |= 0         << 1;   // [1]      audmeas_clk_sel: 0=select aud_pll_clk; 1=select aud_acr_clk.
-    data32 |= rx.ctrl.acr_mode  << 0;   // [0]      aud_clk_sel: 0=select aud_pll_clk; 1=select aud_acr_clk.
-    hdmirx_wr_top( HDMIRX_TOP_ACR_CNTL_STAT, data32);
-
-    //hdmirx_wr_dwc( RA_AUDPLL_GEN_CTS, manual_acr_cts);
-    //hdmirx_wr_dwc( RA_AUDPLL_GEN_N,   manual_acr_n);
-#if 0
-    // Force N&CTS to start with, will switch to received values later on, for simulation speed up.
-    data32  = 0;
-    data32 |= 1 << 4;   // [4]      cts_n_ref: 0=used decoded; 1=use manual N&CTS.
-    hdmirx_wr_dwc( RA_AUD_CLK_CTRL,   data32);
-#endif
-    data32  = 0;
-    data32 |= 0 << 28;  // [28]     pll_lock_filter_byp
-    data32 |= 0 << 24;  // [27:24]  pll_lock_toggle_div
-    hdmirx_wr_dwc( RA_AUD_PLL_CTRL,   data32);    // DEFAULT: {1'b0, 3'd0, 4'd6, 4'd3, 4'd8, 1'b0, 1'b0, 1'b1, 1'b0, 12'd0}
-
-
-    data32  = 0;
-    data32 |= 144    << 18;  // [26:18]  afif_th_start
-    data32 |= 32     << 9;   // [17:9]   afif_th_max
-    data32 |= 32     << 0;   // [8:0]    afif_th_min
-    hdmirx_wr_dwc( RA_AUD_FIFO_TH,    data32);
-
-    data32  = 0;
-    data32 |= 1     << 16;  // [16]     afif_subpackets: 0=store all sp; 1=store only the ones' spX=1.
-    data32 |= 0     << 0;   // [0]      afif_init
-    hdmirx_wr_dwc( RA_AUD_FIFO_CTRL,  data32); // DEFAULT: {13'd0, 2'd0, 1'b1, 15'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= (RX_8_CHANNEL? 0x7 :0x0)  << 8;   // [10:8]   ch_map[7:5]
-    data32 |= 1                         << 7;   // [7]      ch_map_manual
-    data32 |= (RX_8_CHANNEL? 0x1f:0x3)  << 2;   // [6:2]    ch_map[4:0]
-    data32 |= 1                         << 0;   // [1:0]    aud_layout_ctrl:0/1=auto layout; 2=layout 0; 3=layout 1.
-    hdmirx_wr_dwc( RA_AUD_CHEXTRA_CTRL,    data32); // DEFAULT: {24'd0, 1'b0, 5'd0, 2'd0}
-#endif 
-/* amlogic HDMIRX audio module enable*/
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL,  0x60010000); 
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL2, 0x814d3928);
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL3, 0x6b425012);
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL4, 0x101);
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL5, 0x8550d20);
-	if(rx.aud_info.audio_recovery_clock > (96000 + AUD_CLK_DELTA)){
-		if(rx.ctrl.tmds_clk2 <= 36000000) {
-			printk("tmds_clk2 <= 36000000\n");
-			WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55013000);
-		} else if (rx.ctrl.tmds_clk2 <= 53000000) {
-			printk("tmds_clk2 <= 53000000\n");
-			WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55053000);
-		} else {
-			printk("tmds_clk2 > 53000000\n");
-			WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55153000);
-		}
-	} else {
-		printk("audio_recovery_clock < 98000\n");
-		WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55153000);
-	}
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL, 0x00010000);  //reset
-
-/**/
-#if 0
-    WRITE_MPEG_REG(AUDIN_SOURCE_SEL,    (0  <<12)   | // [14:12]cntl_hdmirx_chsts_sel: 0=Report chan1 status; 1=Report chan2 status; ...; 7=Report chan8 status.
-                            (0xf<<8)    | // [11:8] cntl_hdmirx_chsts_en
-                            (1  <<4)    | // [5:4]  spdif_src_sel: 1=Select HDMIRX SPDIF output as AUDIN source
-                            (2 << 0));    // [1:0]  i2sin_src_sel: 2=Select HDMIRX I2S output as AUDIN source
-#endif
-return err;
-}
-
-
-static unsigned long clk_util_clk_msr2( unsigned long   clk_mux, unsigned long   uS_gate_time )
-{
-    unsigned long dummy_rd;
-    unsigned long   measured_val;
-    unsigned long timeout = 0;
-    // Set the measurement gate to 100uS
-    WRITE_MPEG_REG(MSR_CLK_REG0, (READ_MPEG_REG(MSR_CLK_REG0) & ~(0xFFFF << 0)) | ((uS_gate_time-1) << 0) );
-    // Disable continuous measurement
-    // disable interrupts
-    WRITE_MPEG_REG(MSR_CLK_REG0, (READ_MPEG_REG(MSR_CLK_REG0) & ~((1 << 18) | (1 << 17))) );
-    WRITE_MPEG_REG(MSR_CLK_REG0, (READ_MPEG_REG(MSR_CLK_REG0) & ~(0xf << 20)) | ((clk_mux << 20) |  // Select MUX
-                                                          (1 << 19) |     // enable the clock
-                                                          (1 << 16)) );    // enable measuring
-    dummy_rd = READ_MPEG_REG(MSR_CLK_REG0);
-    // Wait for the measurement to be done
-    while( (READ_MPEG_REG(MSR_CLK_REG0) & (1 << 31)) ) {
-        mdelay(10);
-        timeout++;
-        if(timeout>10){
-            return 0;
-        }
-    }
-    // disable measuring
-    WRITE_MPEG_REG(MSR_CLK_REG0, (READ_MPEG_REG(MSR_CLK_REG0) & ~(1 << 16)) | (0 << 16) );
-
-    measured_val = READ_MPEG_REG(MSR_CLK_REG2);
-    if( measured_val == 65535 ) {
-        return(0);
-    } else {
-        // Return value in Hz
-        return(measured_val*(1000000/uS_gate_time));
-    }
-}
-
-int hdmirx_get_clock(int index)
-{
-    return clk_util_clk_msr2(index, 50);
-}    
-
-int hdmirx_get_tmds_clock(void)
-{
-    return clk_util_clk_msr2(57, 50);
-}    
-
-int hdmirx_get_pixel_clock(void)
-{
-    return clk_util_clk_msr2(58, 50);
-}    
-
-void hdmirx_read_audio_info(struct aud_info_s* audio_info)
-{
-	/*get AudioInfo */
-	audio_info->coding_type = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB0, CODING_TYPE);
-	audio_info->channel_count = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB0, CHANNEL_COUNT);
-	audio_info->sample_frequency = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB0, SAMPLE_FREQ);
-	audio_info->sample_size = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB0, SAMPLE_SIZE);
-	audio_info->coding_extension = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB0, AIF_DATA_BYTE_3);
-	audio_info->channel_allocation = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB0, CH_SPEAK_ALLOC);
-	audio_info->down_mix_inhibit = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB1, DWNMIX_INHIBIT);
-	audio_info->level_shift_value = hdmirx_rd_bits_dwc(RA_PDEC_AIF_PB1, LEVEL_SHIFT_VAL);
-
-  audio_info->cts = hdmirx_rd_dwc(RA_PDEC_ACR_CTS);
-  audio_info->n = hdmirx_rd_dwc(RA_PDEC_ACR_N);
-  if(audio_info->cts!=0){
-      audio_info->audio_recovery_clock = (hdmirx_get_tmds_clock()/audio_info->cts)
-                                            *audio_info->n/128;
-  }
-  else{
-      audio_info->audio_recovery_clock = 0;
-  }
-}    
-
-
-void hdmirx_read_vendor_specific_info_frame(struct vendor_specific_info_s* vs)
-{
-    vs->identifier = hdmirx_rd_bits_dwc(RA_PDEC_VSI_ST0, IEEE_REG_ID);
-    vs->hdmi_video_format = hdmirx_rd_bits_dwc(RA_PDEC_VSI_ST1, HDMI_VIDEO_FORMAT);
-    vs->_3d_structure = hdmirx_rd_bits_dwc(RA_PDEC_VSI_ST1, H3D_STRUCTURE);
-    vs->_3d_ext_data = hdmirx_rd_bits_dwc(RA_PDEC_VSI_ST1, H3D_EXT_DATA);
-}
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h b/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h
deleted file mode 100755
index 40fa7602f35d..000000000000
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_reg.h
+++ /dev/null
@@ -1,703 +0,0 @@
-/*
- * hdmirx_rx_reg.h brief registers address in HDMI RX module.
- * 
- * Copyright (C) 2012 AMLOGIC, INC. All Rights Reserved.
- * Author: Rain Zhang <rain.zhang@amlogic.com>
- * Author: Xiaofei Zhu <xiaofei.zhu@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-#ifndef HDMI_RX_REG_H_
-#define HDMI_RX_REG_H_ 
-
-#define HDMIRX_IRQ                              24
-
-/**
- * Bit field mask
- * @param m	width
- * @param n shift
- */
-#define MSK(m, n)		(((1 << (m)) - 1) << (n))
-/**
- * Bit mask
- * @param n shift
- */
-#define _BIT(n)			MSK(1, (n))
-
-
-/** register address: PHY Gen3 clock measurement unit configuration */
-#define REG_HDMI_PHY_CMU_CONFIG			(0x02UL)
-/** register address: PHY Gen3 system configuration */
-#define REG_HDMI_PHY_SYSTEM_CONFIG		(0x03UL)
-/** register address: PHY Gen3 main FSM status 1 */
-#define REG_HDMI_PHY_MAINFSM_STATUS1	   (0x09UL)
-/** PHY Gen3 Clock measurement lock threshold - default 8*/
-#define LOCK_THRES                      (0x08UL)
-
-#define OVL_PROT_CTRL                   (0x0DUL)
-#define MPLL_PARAMETERS2                (0x27UL)
-#define MPLL_PARAMETERS3                (0x28UL)
-#define MPLL_PARAMETERS4                (0x29UL)
-#define MPLL_PARAMETERS5                (0x2AUL)
-#define MPLL_PARAMETERS6                (0x2BUL)
-#define MPLL_PARAMETERS7                (0x2CUL)
-#define MPLL_PARAMETERS8                (0x2DUL)
-
-
-//------------------------------------------------------------------------------
-// TOP-level wrapper registers addresses
-//------------------------------------------------------------------------------
-
-#define HDMIRX_TOP_SW_RESET                     0x000
-#define HDMIRX_TOP_CLK_CNTL                     0x001
-#define HDMIRX_TOP_HPD_PWR5V                    0x002
-#define HDMIRX_TOP_PORT_SEL                     0x003
-#define HDMIRX_TOP_EDID_GEN_CNTL                0x004
-#define HDMIRX_TOP_EDID_ADDR_CEC                0x005
-#define HDMIRX_TOP_EDID_DATA_CEC_PORT01         0x006
-#define HDMIRX_TOP_EDID_DATA_CEC_PORT23         0x007
-#define HDMIRX_TOP_EDID_GEN_STAT                0x008
-#define HDMIRX_TOP_INTR_MASKN                   0x009
-#define HDMIRX_TOP_INTR_STAT                    0x00A
-#define HDMIRX_TOP_INTR_STAT_CLR                0x00B
-#define HDMIRX_TOP_VID_CNTL                     0x00C
-#define HDMIRX_TOP_VID_STAT                     0x00D
-#define HDMIRX_TOP_ACR_CNTL_STAT                0x00E
-#define HDMIRX_TOP_ACR_AUDFIFO                  0x00F
-#define HDMIRX_TOP_ARCTX_CNTL                   0x010
-#define HDMIRX_TOP_METER_HDMI_CNTL              0x011
-#define HDMIRX_TOP_METER_HDMI_STAT              0x012
-#define HDMIRX_TOP_EDID_OFFSET                  0x200
-
-
-/*
- * HDMI registers
- */
-/** Register address: setup control */
-#define RA_HDMI_SETUP_CTRL      (0x000UL)
-/** Hot plug detect signaled */
-#define 	HOT_PLUG_DETECT			_BIT(0)
-/** Register address: override control */
-#define RA_HDMI_OVR_CTRL        (0x004UL)
-/** Register address: timer control */
-#define RA_HDMI_TIMERA_CTRL     (0x008UL)
-/** Register address: resistor override */
-#define RA_HDMI_RES_OVR         (0x010UL)
-/** Register address: resistor status */
-#define RA_HDMI_RES_STS         (0x014UL)
-/** Register address: TMDS PLL control */
-#define RA_HDMI_PLL_CTRL        (0x018UL)
-/** Register address: TMDS PLL frequency range */
-#define RA_HDMI_PLL_FRQSET1     (0x01CUL)
-/** Register address: TMDS PLL frequency range */
-#define RA_HDMI_PLL_FRQSET2     (0x020UL)
-/** Register address: TMDS PLL PCP and ICP range */
-#define RA_HDMI_PLL_PAR1        (0x024UL)
-/** Register address: TMDS PLL PCP and ICP range */
-#define RA_HDMI_PLL_PAR2        (0x028UL)
-/** Register address: TMDS PLL KOSC and CCOLF range */
-#define RA_HDMI_PLL_PAR3        (0x02CUL)
-/** Register address: PLL post lock filter */
-#define RA_HDMI_PLL_LCK_STS     (0x030UL)
-/** Register address: PLL clock control */
-#define RA_HDMI_CLK_CTRL        (0x034UL)
-/** Register address: PCB diversity control */
-#define RA_HDMI_PCB_CTRL        (0x038UL)
-/** Input selector */
-#define		INPUT_SELECT			_BIT(16)
-/** Register address: phase control */
-#define RA_HDMI_PHS_CTRL        (0x040UL)
-/** Register address: used phases */
-#define RA_HDMI_PHS_USD         (0x044UL)
-/** Register address: miscellaneous operations control */
-#define RA_HDMI_MISC_CTRL       (0x048UL)
-/** Register address: EQ offset calibration */
-#define RA_HDMI_EQOFF_CTRL      (0x04CUL)
-/** Register address: EQ gain control */
-#define RA_HDMI_EQGAIN_CTRL     (0x050UL)
-/** Register address: EQ status */
-#define RA_HDMI_EQCAL_STS       (0x054UL)
-/** Register address: EQ results */
-#define RA_HDMI_EQRESULT        (0x058UL)
-/** Register address: EQ measurement control */
-#define RA_HDMI_EQ_MEAS_CTRL    (0x05CUL)
-/** Register address: HDMI mode recover */
-#define RA_HDMI_MODE_RECOVER    (0x080UL)
-/** Register address: HDMI error protection */
-#define RA_HDMI_ERRORA_PROTECT  (0x084UL)
-/** Register address: validation and production test */
-#define RA_HDMI_ERD_STS         (0x088UL)
-/** Register address: video output sync signals control */
-#define RA_HDMI_SYNC_CTRL       (0x090UL)
-/** VS polarity adjustment */
-#define		VS_POL_ADJ_MODE			MSK(2, 3)
-/** HS polarity adjustment automatic */
-#define		VS_POL_ADJ_AUTO			(2)
-/** HS polarity adjustment */
-#define		HS_POL_ADJ_MODE			MSK(2, 1)
-/** HS polarity adjustment automatic inversion */
-#define		HS_POL_ADJ_AUTO			(2)
-/** Register address: clock measurement */
-#define RA_HDMI_CKM_EVLTM       (0x094UL)
-/** Evaluation period */
-#define		EVAL_TIME				MSK(12, 4)
-/** active wait period for TMDS stabilisation */
-#define		TMDS_STABLE_TIMEOUT			(30)
-/** Register address: legal clock count */
-#define RA_HDMI_CKM_F           (0x098UL)
-/** Maximum count for legal count */
-#define 	CKM_MAXFREQ					MSK(16, 16)
-/** Minimum count for legal count */
-#define 	MINFREQ					MSK(16, 0)
-/** Register address: measured clock results */
-#define RA_HDMI_CKM_RESULT      (0x09CUL)
-/** Measured clock is stable */
-#define 	CLOCK_IN_RANGE			_BIT(17)
-/** Measured clock rate in bits */
-#define 	CLKRATE					MSK(16, 0)
-/** Register address: sub-sampling control */
-#define RA_HDMI_RESMPL_CTRL     (0x0A4UL)
-/** Register address: deep color mode control */
-#define RA_HDMI_DCM_CTRL        (0x0A8UL)
-/** Register address: video output mute configuration */
-#define RA_HDMI_VM_CFG_CH_0_1   (0x0B0UL)
-/** Register address: video output mute configuration */
-#define RA_HDMI_VM_CFG_CH2      (0x0B4UL)
-/** Register address: spare */
-#define RA_HDMI_SPARE           (0x0B8UL)
-/** Register address: HDMI status */
-#define RA_HDMI_STS             (0x0BCUL)
-/** Current deep color mode */
-#define		DCM_CURRENT_MODE		MSK(4, 28)
-/** Deep color mode, 24 bit */
-#define		DCM_CURRENT_MODE_24b	(4)
-/** Deep color mode, 30 bit */
-#define		DCM_CURRENT_MODE_30b	(5)
-/** Deep color mode, 36 bit */
-#define		DCM_CURRENT_MODE_36b	(6)
-/** Deep color mode, 48 bit */
-#define		DCM_CURRENT_MODE_48b	(7)
-/*
- * hdcp register
- */
-/** Register address: HDMI status */
-#define RA_HDCP_DBG             (0x0E0UL)
-/*
- * Video Mode registers
- */
-/** Register address: video mode control */
-#define RA_MD_HCTRL1            (0x140UL)
-/** Register address: video mode control */
-#define RA_MD_HCTRL2            (0x144UL)
-/** Register address: horizontal sync */
-#define RA_MD_HT0               (0x148UL)
-/** Register address: horizontal offset */
-#define RA_MD_HT1               (0x14CUL)
-/** Horizontal total length */
-#define 	HTOT_PIX				MSK(16, 16)
-/** Horizontal offset length */
-#define 	HOFS_PIX				MSK(16, 0)
-/** Register address: horizontal active length */
-#define RA_MD_HACT_PX           (0x150UL)
-/** Horizontal active length */
-#define 	HACT_PIX				MSK(16, 0)
-/** Register address: horizontal active time */
-#define RA_MD_HACT_PXA          (0x154UL)
-/** Register address: vertical control */
-#define RA_MD_VCTRL             (0x158UL)
-/** Register address: vertical timing - sync pulse duration */
-#define RA_MD_VSC               (0x15CUL)
-/** Register address: vertical timing - frame duration */
-#define RA_MD_VTC               (0x160UL)
-/** Frame duration */
-#define		VTOT_CLK				(~0)
-/** Register address: vertical offset length */
-#define RA_MD_VOL               (0x164UL)
-/** Vertical offset length */
-#define 	VOFS_LIN				MSK(16, 0)
-/** Register address: vertical active length */
-#define RA_MD_VAL               (0x168UL)
-/** Vertical active length */
-#define 	VACT_LIN				MSK(16, 0)
-/** Register address: vertical timing */
-#define RA_MD_VTH               (0x16CUL)
-/** Register address: vertical total length */
-#define RA_MD_VTL               (0x170UL)
-/** Vertical total length */
-#define 	VTOT_LIN				MSK(16, 0)
-/** Register address: skew measurement trigger */
-#define RA_MD_IL_CTRL           (0x174UL)
-/** Register address: VS and HS skew */
-#define RA_MD_IL_SKEW           (0x178UL)
-/** Register address: V&H skew and filed detection */
-#define RA_MD_IL_POL            (0x17CUL)
-/** Register address: video mode status */
-#define RA_MD_STS               (0x180UL)
-/** Interlace active status */
-#define 	ILACE					_BIT(3)
-/*
- * Audio registers
- */
-/** Register address: audio mode control */
-#define RA_AUD_CTRL             (0x200UL)
-/** Register address: audio PLL control */
-#define RA_AUD_PLL_CTRL         (0x208UL)
-/** Register address: audio PLL lock */
-#define RA_AUD_PLL_LOCK         (0x20CUL)
-/** Register address: DDS audio clock control */
-#define RA_AUD_PLL_RESET        (0x210UL)
-/** Register address: audio clock control */
-#define RA_AUD_CLK_CTRL         (0x214UL)
-/** Register address: ASP sync intervals */
-#define RA_AUD_CLK_MASP         (0x218UL)
-/** Register address: audio sync interval */
-#define RA_AUD_CLK_MAUD         (0x21CUL)
-/** Register address: sync interval reset */
-#define RA_AUD_FILT_CTRL1       (0x220UL)
-/** Register address: phase filter control */
-#define RA_AUD_FILT_CTRL2       (0x224UL)
-/** Register address: manual CTS control */
-#define RA_AUD_CTS_MAN          (0x228UL)
-/** Register address: manual N control */
-#define RA_AUD_N_MAN            (0x22CUL)
-/** Register address: audio clock status */
-#define RA_AUD_CLK_STS          (0x23CUL)
-/** Register address: audio FIFO control */
-#define RA_AUD_FIFO_CTRL        (0x240UL)
-/** Audio FIFO reset */
-#define 	AFIF_INIT				_BIT(0)
-/** Register address: audio FIFO threshold */
-#define RA_AUD_FIFO_TH          (0x244UL)
-/** Register address: audio FIFO fill */
-#define RA_AUD_FIFO_FILL_S      (0x248UL)
-/** Register address: audio FIFO fill minimum/maximum */
-#define RA_AUD_FIFO_CLRA_MM     (0x24CUL)
-/** Register address: audio FIFO fill status */
-#define RA_AUD_FIFO_FILLSTS     (0x250UL)
-/** Register address: audio output interface configuration */
-#define RA_AUD_CHEXTRA_CTRL     (0x254UL)
-/** Register address: audio mute control */
-#define RA_AUD_MUTE_CTRL        (0x258UL)
-/** Manual/automatic audio mute control */
-#define		AUD_MUTE_SEL			MSK(2, 5)
-/** Force unmute (overrules all) */
-#define		AUD_MUTE_FORCE_UN		(0)
-/** Automatic mute when FIFO thresholds are exceeded */
-#define		AUD_MUTE_FIFO_TH		(1)
-/** Automatic mute when FIFO over/underflows */
-#define		AUD_MUTE_FIFO_FL		(2)
-/** Force mute (overrules all) */
-#define		AUD_MUTE_FORCE			(3)
-/** Register address: serial audio output control */
-#define RA_AUD_SAO_CTRL         (0x260UL)
-/** Register address: parallel audio output control */
-#define RA_AUD_PAO_CTRL         (0x264UL)
-/** Register address: audio FIFO status */
-#define RA_AUD_FIFO_STS         (0x27CUL)
-
-#define RA_AUDPLL_GEN_CTS       (0x280UL)
-#define RA_AUDPLL_GEN_N         (0x284UL)
-
-/** Register address: lock detector threshold */
-#define RA_CI_PLLAUDIO_5        (0x28CUL)
-/** Register address: test mode selection */
-#define RA_CI_PLLAUDIO_4        (0x290UL)
-/** Register address: bypass divider control */
-#define RA_CI_PLLAUDIO_3        (0x294UL)
-/** Register address: monitoring */
-#define RA_CI_PLLAUDIO_2        (0x298UL)
-/** Register address: control */
-#define RA_CI_PLLAUDIO_1        (0x29CUL)
-/** Register address: SNPS PHY GEN3 control - starting version 1.30a */
-#define RA_SNPS_PHYG3_CTRL	(0x2C0UL)
-/** Register address:  I2C Master: slave address - starting version 1.30a */
-#define RA_I2CM_PHYG3_SLAVE 		(0x2C4UL)
-/** Register address: I2C Master: register address - starting version 1.30a */
-#define RA_I2CM_PHYG3_ADDRESS 		(0x2C8UL)
-/** Register address: I2C Master: data to write to slave-starting version 1.30a*/
-#define RA_I2CM_PHYG3_DATAO  		(0x2CCUL)
-/** Register address: I2C Master: data read from slave-starting version 1.30a*/
-#define RA_I2CM_PHYG3_DATAI  		(0x2D0UL)
-/** Register address: I2C Master: operation RD/WR - starting version 1.30a */
-#define RA_I2CM_PHYG3_OPERATION		(0x2D4UL)
-/** Register address: I2C Master: SS/HS mode - starting version 1.30a */
-#define RA_I2CM_PHYG3_MODE			(0x2D8UL)
-/** Register address: I2C Master: soft reset - starting version 1.30a */
-#define RA_I2CM_PHYG3_SOFTRST		(0x2DCUL)
-/** Register address: I2C Master: ss mode counters  - starting version 1.30a */
-#define RA_I2CM_PHYG3_SS_CNTS		(0x2E0UL)
-/** Register address:I2C Master:  hs mode counters  - starting version 1.30a */
-#define RA_I2CM_PHYG3_FS_HCNT		(0x2E4UL)
-/*
- * Packet Decoder and FIFO Control registers
- */
-/** Register address: packet decoder and FIFO control */
-#define RA_PDEC_CTRL            (0x300UL)
-/** Packet FIFO store filter enable */
-#define		PFIFO_STORE_FILTER_EN	_BIT(31)
-/** Packet FIFO store packet */
-#define		PFIFO_STORE_PACKET		_BIT(16)
-/** Packet FIFO clear min/max information */
-#define		PD_FIFO_FILL_INFO_CLR	_BIT(8)
-/** Packet FIFO skip one packet */
-#define		PD_FIFO_SKIP			_BIT(6)
-/** Packet FIFO clear */
-#define		PD_FIFO_CLR				_BIT(5)
-/** Packet FIFO write enable */
-#define		PD_FIFO_WE				_BIT(4)
-/** Packet error detection/correction enable */
-#define		PDEC_BCH_EN				_BIT(0)
-/** Register address: packet decoder and FIFO configuration */
-#define RA_PDEC_FIFO_CFG        (0x304UL)
-/** Register address: packet decoder and FIFO status */
-#define RA_PDEC_FIFO_STS        (0x308UL)
-/** Register address: packet decoder and FIFO byte data */
-#define RA_PDEC_FIFO_DATA       (0x30CUL)
-/** Register address: packet decoder and FIFO debug control */
-#define RA_PDEC_DBG_CTRL        (0x310UL)
-/** Register address: packet decoder and FIFO measured timing gap */
-#define RA_PDEC_DBG_TMAX        (0x314UL)
-/** Register address: CTS loop */
-#define RA_PDEC_DBG_CTS         (0x318UL)
-/** Register address: ACP frequency count */
-#define RA_PDEC_DBG_ACP         (0x31CUL)
-/** Register address: signal errors in data island packet */
-#define RA_PDEC_DBG_ERRA_CORR   (0x320UL)
-/** Register address: CTS reset measurement control */
-#define RA_PDEC_ACRM_CTRL       (0x330UL)
-/** Register address: maximum CTS div N value */
-#define RA_PDEC_ACRM_MAX        (0x334UL)
-/** Register address: minimum CTS div N value */
-#define RA_PDEC_ACRM_MIN        (0x338UL)
-/** Register address: audio sub packet control */
-#define RA_PDEC_ASP_CTRL        (0x340UL)
-/** Automatic mute all video channels */
-#define		AUTO_VMUTE				_BIT(6)
-/** Automatic mute audio sub packets */
-#define		AUTO_SPFLAT_MUTE		MSK(4, 2)
-/** Register address: audio sub packet errors */
-#define RA_PDEC_ASP_ERR         (0x344UL)
-/** Register address: packet decoder status, see packet interrupts */
-#define RA_PDEC_STS             (0x360UL)
-/** Register address: general control packet AV mute */
-#define RA_PDEC_GCP_AVMUTE      (0x380UL)
-/** Register address: audio clock regeneration */
-#define RA_PDEC_ACR_CTS        (0x390UL)
-/** Audio clock regeneration, CTS parameter */
-#define		CTS_DECODED				MSK(20, 0)
-/** Register address: audio clock regeneration */
-#define RA_PDEC_ACR_N         	(0x394UL)
-/** Audio clock regeneration, N parameter */
-#define		N_DECODED				MSK(20, 0)
-/** Register address: auxiliary video information info frame */
-#define RA_PDEC_AVI_HB         	(0x3A0UL)
-/** PR3-0, pixel repetition factor */
-#define 	PIX_REP_FACTOR			MSK(4, 24)
-/** Register address: auxiliary video information info frame */
-#define RA_PDEC_AVI_PB         	(0x3A4UL)
-/** VIC6-0, video mode identification code */
-#define 	VID_IDENT_CODE			MSK(7, 24)
-/** ITC, IT content */
-#define		IT_CONTENT				_BIT(23)
-/** EC2-0, extended colorimetry */
-#define		EXT_COLORIMETRY			MSK(3, 20)
-/** Q1-0, RGB quantization range */
-#define		RGB_QUANT_RANGE			MSK(2, 18)
-/** SC1-0, non-uniform scaling information */
-#define		NON_UNIF_SCALE			MSK(2, 16)
-/** C1-0, colorimetry information */
-#define		COLORIMETRY				MSK(2, 14)
-/** M1-0, picture aspect ratio */
-#define		PIC_ASPECT_RATIO		MSK(2, 12)
-/** R3-0, active format aspect ratio */
-#define		ACT_ASPECT_RATIO		MSK(4, 8)
-/** Y1-0, video format */
-#define		VIDEO_FORMAT			MSK(2, 5)
-/** A0, active format information present */
-#define		ACT_INFO_PRESENT		_BIT(4)
-/** B1-0, bar valid information */
-#define		BAR_INFO_VALID			MSK(2, 2)
-/** S1-0, scan information from packet extraction */
-#define		SCAN_INFO				MSK(2, 0)
-/** Register address: auxiliary video information info frame */
-#define RA_PDEC_AVI_TBB        	(0x3A8UL)
-/** Line number to start of bottom bar */
-#define		LIN_ST_BOT_BAR			MSK(16, 16)
-/** Line number to end of top bar */
-#define		LIN_END_TOP_BAR			MSK(16, 0)
-/** Register address: auxiliary video information info frame */
-#define RA_PDEC_AVI_LRB        	(0x3ACUL)
-/** Pixel number of start right bar */
-#define		PIX_ST_RIG_BAR			MSK(16, 16)
-/** Pixel number of end left bar */
-#define		PIX_END_LEF_BAR			MSK(16, 0)
-/** Register address: special audio layout control for multi-channel audio */
-#define RA_PDEC_AIF_CTRL       	(0x3C0UL)
-/** Register address: audio info frame */
-#define RA_PDEC_AIF_HB         	(0x3C4UL)
-/** Register address: audio info frame */
-#define RA_PDEC_AIF_PB0        	(0x3C8UL)
-/** CA7-0, channel/speaker allocation */
-#define 	CH_SPEAK_ALLOC			MSK(8, 24)
-/** CTX, coding extension */
-#define 	AIF_DATA_BYTE_3			MSK(8, 16)
-/** SF2-0, sample frequency */
-#define 	SAMPLE_FREQ				MSK(3, 10)
-/** SS1-0, sample size */
-#define 	SAMPLE_SIZE				MSK(2, 8)
-/** CT3-0, coding type */
-#define 	CODING_TYPE				MSK(4, 4)
-/** CC2-0, channel count */
-#define 	CHANNEL_COUNT			MSK(3, 0)
-/** Register address: audio info frame */
-#define RA_PDEC_AIF_PB1       	(0x3CCUL)
-/** DM_INH, down-mix inhibit */
-#define 	DWNMIX_INHIBIT			_BIT(7)
-/** LSV3-0, level shift value */
-#define 	LEVEL_SHIFT_VAL			MSK(4, 3)
-/** Register address: gamut sequence number */
-#define RA_PDEC_GMD_HB         	(0x3D0UL)
-/** Register address: gamut meta data */
-#define RA_PDEC_GMD_PB         	(0x3D4UL)
-
-/*
-* Vendor Specific Info Frame */
-#define RA_PDEC_VSI_ST0         (0x3E0UL)
-#define IEEE_REG_ID         MSK(24,0)
-
-#define RA_PDEC_VSI_ST1         (0x3E4UL)
-#define H3D_STRUCTURE       MSK(4,16)
-#define H3D_EXT_DATA        MSK(4,20)
-#define HDMI_VIDEO_FORMAT   MSK(3,5)
-
-/*
- * DTL Interface registers
- */
-/** Register address: dummy register for testing */
-#define RA_DUMMY_IP_REG        	(0xF00UL)
-/*
- * Packet Decoder Interrupt registers
- */
-/** Register address: packet decoder interrupt clear enable */
-#define RA_PDEC_IEN_CLR        	(0xF78UL)
-/** Register address: packet decoder interrupt set enable */
-#define RA_PDEC_IEN_SET        	(0xF7CUL)
-/** Register address: packet decoder interrupt status */
-#define RA_PDEC_ISTS           	(0xF80UL)
-/** Register address: packet decoder interrupt enable */
-#define RA_PDEC_IEN            	(0xF84UL)
-/** Register address: packet decoder interrupt clear status */
-#define RA_PDEC_ICLR           	(0xF88UL)
-/** Register address: packet decoder interrupt set status */
-#define RA_PDEC_ISET           	(0xF8CUL)
-/** DVI detection status */
-#define		DVIDET					_BIT(28)
-/** AIF checksum changed */
-#define		AIF_CKS_CHG				_BIT(25)
-/** AVI checksum changed */
-#define		AVI_CKS_CHG				_BIT(24)
-/** Vendor Specific Info frame changed */
-#define		VSI_CKS_CHG				_BIT(15)
-/** Packet FIFO new entry */
-#define		PD_FIFO_NEW_ENTRY		_BIT(8)
-/** Packet FIFO overflow */
-#define		PD_FIFO_OVERFL			_BIT(4)
-/** Packet FIFO underflow */
-#define		PD_FIFO_UNDERFL			_BIT(3)
-/*
- * Audio Clock Interrupt registers
- */
-/** Register address: audio clock interrupt clear enable */
-#define RA_AUD_CLK_IEN_CLR     	(0xF90UL)
-/** Register address: audio clock interrupt set enable */
-#define RA_AUD_CLK_IEN_SET     	(0xF94UL)
-/** Register address: audio clock interrupt status */
-#define RA_AUD_CLK_ISTS        	(0xF98UL)
-/** Register address: audio clock interrupt enable */
-#define RA_AUD_CLK_IEN         	(0xF9CUL)
-/** Register address: audio clock interrupt clear status */
-#define RA_AUD_CLK_ICLR        	(0xFA0UL)
-/** Register address: audio clock interrupt set status */
-#define RA_AUD_CLK_ISET        	(0xFA4UL)
-/*
- * Audio FIFO Interrupt registers
- */
-/** Register address: audio FIFO interrupt clear enable */
-#define RA_AUD_FIFO_IEN_CLR    	(0xFA8UL)
-/** Register address: audio FIFO interrupt set enable */
-#define RA_AUD_FIFO_IEN_SET    	(0xFACUL)
-/** Register address: audio FIFO interrupt status */
-#define RA_AUD_FIFO_ISTS       	(0xFB0UL)
-/** Register address: audio FIFO interrupt enable */
-#define RA_AUD_FIFO_IEN        	(0xFB4UL)
-/** Register address: audio FIFO interrupt clear status */
-#define RA_AUD_FIFO_ICLR       	(0xFB8UL)
-/** Register address: audio FIFO interrupt set status */
-#define RA_AUD_FIFO_ISET       	(0xFBCUL)
-/** Audio FIFO overflow interrupt */
-#define		AFIF_OVERFL				_BIT(4)
-/** Audio FIFO underflow interrupt */
-#define		AFIF_UNDERFL			_BIT(3)
-/*
- * Mode Detection Interrupt registers
- */
-/** Register address: mode detection interrupt clear enable */
-#define RA_MD_IEN_CLR          	(0xFC0UL)
-/** Register address: mode detection interrupt set enable */
-#define RA_MD_IEN_SET          	(0xFC4UL)
-/** Register address: mode detection interrupt status */
-#define RA_MD_ISTS             	(0xFC8UL)
-/** Register address: mode detection interrupt enable */
-#define RA_MD_IEN              	(0xFCCUL)
-/** Register address: mode detection interrupt clear status */
-#define RA_MD_ICLR             	(0xFD0UL)
-/** Register address: mode detection interrupt set status */
-#define RA_MD_ISET             	(0xFD4UL)
-/** Video mode interrupts */
-#define		VIDEO_MODE				(MSK(3,9)|MSK(2,6)|_BIT(3))
-/*
- * HDMI Interrupt registers
- */
-/** Register address: HDMI interrupt clear enable */
-#define RA_HDMI_IEN_CLR        	(0xFD8UL)
-/** Register address: HDMI interrupt set enable */
-#define RA_HDMI_IEN_SET        	(0xFDCUL)
-/** Register address: HDMI interrupt status */
-#define RA_HDMI_ISTS           	(0xFE0UL)
-/** Register address: HDMI interrupt enable */
-#define RA_HDMI_IEN            	(0xFE4UL)
-/** Register address: HDMI interrupt clear status */
-#define RA_HDMI_ICLR           	(0xFE8UL)
-/** Register address: HDMI interrupt set status */
-#define RA_HDMI_ISET           	(0xFECUL)
-/** AKSV receive interrupt */
-#define 	AKSV_RCV				_BIT(25)
-/** Deep color mode change interrupt */
-#define 	DCM_CURRENT_MODE_CHG	_BIT(16)
-/** Clock change interrupt */
-#define 	CLK_CHANGE				_BIT(6)
-/*
- * DMI registers
- */
-/** Register address: DMI software reset */
-#define RA_DMI_SW_RST          (0xFF0UL)
-/** Register address: DMI disable interface */
-#define RA_DMI_DISABLE_IF      (0xFF4UL)
-/** Register address: DMI module ID */
-#define RA_DMI_MODULE_ID       (0xFFCUL)
-
-/*
- * HDCP registers
- */
-/** Register address: control */
-#define RA_HDCP_CTRL			(0x0C0UL)
-/** HDCP key decryption */
-#define		KEY_DECRYPT_ENABLE		_BIT(1)
-/** HDCP activation */
-#define		HDCP_ENABLE				_BIT(0)
-/** Register address: configuration */
-#define RA_HDCP_SETTINGS		(0x0C4UL)
-/** Register address: key description seed */
-#define RA_HDCP_SEED			(0x0C8UL)
-/** Register address: receiver key selection */
-#define RA_HDCP_BKSV1			(0x0CCUL)
-/** Register address: receiver key selection */
-#define RA_HDCP_BKSV0 			(0x0D0UL)
-/** Register address: key index */
-#define RA_HDCP_KIDX			(0x0D4UL)
-/** Register address: encrypted key */
-#define RA_HDCP_KEY1			(0x0D8UL)
-/** Register address: encrypted key */
-#define RA_HDCP_KEY0			(0x0DCUL)
-/** Register address: debug */
-#define RA_HDCP_DBG				(0x0E0UL)
-/** Register address: transmitter key selection vector */
-#define RA_HDCP_AKSV1			(0x0E4UL)
-/** Register address: transmitter key selection vector */
-#define RA_HDCP_AKSV0 			(0x0E8UL)
-/** Register address: session random number */
-#define RA_HDCP_AN1				(0x0ECUL)
-/** Register address: session random number */
-#define RA_HDCP_AN0 			(0x0F0UL)
-/** Register address: EESS, WOO */
-#define RA_HDCP_EESS_WOO		(0x0F4UL)
-/** Register address: key set writing status */
-#define RA_HDCP_STS				(0x0FCUL)
-/** HDCP key set writing status */
-#define		HDCP_KEY_WR_OK_STS		_BIT(0)
-/** Register address: repeater KSV list control */
-#define	RA_HDCP_RPT_CTRL		(0x600UL)
-/** KSV list key set writing status */
-#define		KSV_HOLD				_BIT(6)
-/** KSV list waiting status */
-#define		WAITING_KSV				_BIT(5)
-/** Repeater capability */
-#define		REPEATER				_BIT(3)
-/** KSV list ready */
-#define		KSVLIST_READY			_BIT(2)
-/** Register address: repeater status */
-#define	RA_HDCP_RPT_BSTATUS		(0x604UL)
-/** Topology error indicator */
-#define		MAX_CASCADE_EXCEEDED	_BIT(11)
-/** Repeater cascade depth */
-#define		DEPTH					MSK(3, 8)
-/** Topology error indicator */
-#define		MAX_DEVS_EXCEEDED		_BIT(7)
-/** Attached downstream device count */
-#define		DEVICE_COUNT			MSK(7, 0)
-/** Register address: repeater KSV FIFO control */
-#define	RA_HDCP_RPT_KSVFIFOCTRL	(0x608UL)
-/** Register address: repeater KSV FIFO */
-#define	RA_HDCP_RPT_KSVFIFO1	(0x60CUL)
-/** Register address: repeater KSV FIFO */
-#define	RA_HDCP_RPT_KSVFIFO0	(0x610UL)
-
-// CEC Controller registers addresses
-#define HDMIRX_DWC_CEC_CTRL                     0x1F00
-#define HDMIRX_DWC_CEC_STAT                     0x1F04
-#define HDMIRX_DWC_CEC_MASK                     0x1F08
-#define HDMIRX_DWC_CEC_POLARITY                 0x1F0C
-#define HDMIRX_DWC_CEC_INT                      0x1F10
-#define HDMIRX_DWC_CEC_ADDR_L                   0x1F14
-#define HDMIRX_DWC_CEC_ADDR_H                   0x1F18
-#define HDMIRX_DWC_CEC_TX_CNT                   0x1F1C
-#define HDMIRX_DWC_CEC_RX_CNT                   0x1F20
-#define HDMIRX_DWC_CEC_TX_DATA0                 0x1F40
-#define HDMIRX_DWC_CEC_TX_DATA1                 0x1F44
-#define HDMIRX_DWC_CEC_TX_DATA2                 0x1F48
-#define HDMIRX_DWC_CEC_TX_DATA3                 0x1F4C
-#define HDMIRX_DWC_CEC_TX_DATA4                 0x1F50
-#define HDMIRX_DWC_CEC_TX_DATA5                 0x1F54
-#define HDMIRX_DWC_CEC_TX_DATA6                 0x1F58
-#define HDMIRX_DWC_CEC_TX_DATA7                 0x1F5C
-#define HDMIRX_DWC_CEC_TX_DATA8                 0x1F60
-#define HDMIRX_DWC_CEC_TX_DATA9                 0x1F64
-#define HDMIRX_DWC_CEC_TX_DATA10                0x1F68
-#define HDMIRX_DWC_CEC_TX_DATA11                0x1F6C
-#define HDMIRX_DWC_CEC_TX_DATA12                0x1F70
-#define HDMIRX_DWC_CEC_TX_DATA13                0x1F74
-#define HDMIRX_DWC_CEC_TX_DATA14                0x1F78
-#define HDMIRX_DWC_CEC_TX_DATA15                0x1F7C
-#define HDMIRX_DWC_CEC_RX_DATA0                 0x1F80
-#define HDMIRX_DWC_CEC_RX_DATA1                 0x1F84
-#define HDMIRX_DWC_CEC_RX_DATA2                 0x1F88
-#define HDMIRX_DWC_CEC_RX_DATA3                 0x1F8C
-#define HDMIRX_DWC_CEC_RX_DATA4                 0x1F90
-#define HDMIRX_DWC_CEC_RX_DATA5                 0x1F94
-#define HDMIRX_DWC_CEC_RX_DATA6                 0x1F98
-#define HDMIRX_DWC_CEC_RX_DATA7                 0x1F9C
-#define HDMIRX_DWC_CEC_RX_DATA8                 0x1FA0
-#define HDMIRX_DWC_CEC_RX_DATA9                 0x1FA4
-#define HDMIRX_DWC_CEC_RX_DATA10                0x1FA8
-#define HDMIRX_DWC_CEC_RX_DATA11                0x1FAC
-#define HDMIRX_DWC_CEC_RX_DATA12                0x1FB0
-#define HDMIRX_DWC_CEC_RX_DATA13                0x1FB4
-#define HDMIRX_DWC_CEC_RX_DATA14                0x1FB8
-#define HDMIRX_DWC_CEC_RX_DATA15                0x1FBC
-#define HDMIRX_DWC_CEC_LOCK                     0x1FC0
-#define HDMIRX_DWC_CEC_WKUPCTRL                 0x1FC4
-
-#endif
diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
deleted file mode 100755
index 6c490526fd04..000000000000
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
+++ /dev/null
@@ -1,2518 +0,0 @@
-/*
- * Amlogic M6TV
- * HDMI RX
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-//#include <linux/amports/canvas.h>
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <mach/regs.h>
-#include <mach/clock.h>
-#include <mach/register.h>
-#include <mach/power_gate.h>
-
-
-#include <linux/amlogic/tvin/tvin.h>
-/* Local include */
-#include "hdmirx_drv.h"
-#include "hdmi_rx_reg.h"
-
-#define HDMI_STATE_CHECK_FREQ     (20*5)
-#define HW_MONITOR_TIME_UNIT    (1000/HDMI_STATE_CHECK_FREQ)
-
-//static int init = 0;
-static int audio_enable = 1;
-static int sample_rate_change_th = 100;
-static int audio_stable_time = 1000; // audio_sample_rate is stable <--> enable audio gate
-static int audio_sample_rate_stable_count_th = 15; // audio change <--> audio_sample_rate is stable
-static unsigned local_port = 0;
-static int sig_unlock_count = 0;
-static int sig_lock_count = 0;
-static int pll_unlock_count = 0;
-static int sig_unstable_count = 0;
-static int sig_unready_cnt = 0;
-static int sig_stable2_ready_cnt = 0;
-
-/* threshold for state machine */
-static unsigned unlock2_stable_th = 10;
-static unsigned unready2_stable_th = 10;
-static unsigned unstable2_th = 200;
-static unsigned stable2_ready_th = 50;
-static unsigned sig_lock_th = 8;
-static unsigned pll_unlock_th = 100;
-
-/* timing diff offset */
-static unsigned diff_pixel_th = 2;
-static unsigned diff_line_th = 2;
-static unsigned diff_frame_th = 50; /* 50*10 khz offset */
-static unsigned chg_pixel_th = 50;
-static unsigned chg_line_th = 5;
-
-/**
- *  HDMI RX parameters
- */
-static int port_map = 0x3210;
-static int cfg_clk = 25*1000; //62500
-static int lock_thres = LOCK_THRES;
-static int fast_switching = 1;
-static int fsm_enhancement = 1;
-static int port_select_ovr_en = 0;
-static int phy_cmu_config_force_val = 0;
-static int phy_system_config_force_val = 0;
-static int acr_mode = 0;                         // Select which ACR scheme:
-                                                    // 0=Analog PLL based ACR;
-                                                    // 1=Digital ACR.
-static int edid_mode = 0;
-static int switch_mode = 0x1;
-static int force_vic = 0;
-static int force_ready = 0;
-static int force_state = 0;
-static int force_format = 0;
-static int force_audio_sample_rate = 0;
-static int audio_sample_rate = 0;
-static int audio_coding_type = 0;
-static int audio_channel_count = 0;
-static int frame_rate = 0;
-static int sm_pause = 0;
-int hdcp_enable = 1;
-int hdmirx_debug_flag = 0;
-/* bit 0, printk; bit 8 enable irq log */
-int hdmirx_log_flag = 0x1; //0x100--irq print; 0x200-other print
-static int sm_init_en = 0;  // enable/disable init sm in stop
-static bool frame_skip_en = 1;  //skip frame when signal unstable
-static bool use_frame_rate_check = 1; /* enable/disable frame rate check  */
-bool use_hw_hpd = true; /* enable/disable hw phd detection  */
-
-static int hw_cfg_mode = 0;  //0: brfore hpd high; 1: after hpd high
-static int cfg_wait_cnt = 0;
-static int cfg_wait_max = 50;
-//static int ip_irq_clr = 1;
-static int reset_mode = 1;  //0:power down reset; 1:sw reset
-static int last_color_fmt = 0;
-static bool sw_5v_sts = false;
-static int sw_pwr_cnt = 0;
-static int unstable_reset_cnt = 0;
-
-/*
-* unstable reset: bit0-reset when signal unstable
-*/
-static int reset_bits = 0;
-
-/***********************
-  TVIN driver interface
-************************/
-#define HDMIRX_HWSTATE_INIT                0
-#define HDMIRX_HWSTATE_5V_LOW             1
-#define HDMIRX_HWSTATE_5V_HIGH            2
-#define HDMIRX_HWSTATE_HPD_READY          3
-#define HDMIRX_HWSTATE_SIG_UNSTABLE        4
-#define HDMIRX_HWSTATE_SIG_STABLE          5
-#define HDMIRX_HWSTATE_SIG_READY           6
-
-/* counter defines */
-#define HDMIRX_SW_PWR_CNT               100
-
-
-struct rx rx;
-
-static unsigned long tmds_clock_old = 0;
-
-/** TMDS clock delta [kHz] */
-#define TMDS_CLK_DELTA			(125)
-/** Pixel clock minimum [kHz] */
-#define PIXEL_CLK_MIN			TMDS_CLK_MIN
-/** Pixel clock maximum [kHz] */
-#define PIXEL_CLK_MAX			TMDS_CLK_MAX
-/** Horizontal resolution minimum */
-#define HRESOLUTION_MIN			(320)
-/** Horizontal resolution maximum */
-#define HRESOLUTION_MAX			(4096)
-/** Vertical resolution minimum */
-#define VRESOLUTION_MIN			(240)
-/** Vertical resolution maximum */
-#define VRESOLUTION_MAX			(4455)
-/** Refresh rate minimum [Hz] */
-#define REFRESH_RATE_MIN		(100)
-/** Refresh rate maximum [Hz] */
-#define REFRESH_RATE_MAX		(25000)
-
-#define TMDS_TOLERANCE  (4000)
-
-
-
-int hdmi_rx_ctrl_edid_update(void);
-static void dump_state(unsigned char enable);
-static void dump_audio_info(unsigned char enable);
-static unsigned int get_vic_from_timing(struct hdmi_rx_ctrl_video* video_par);
-static unsigned int get_index_from_ref(struct hdmi_rx_ctrl_video* video_par);
-void hdmirx_hw_init2(void);
-
-
-
-
-/**
- * Clock event handler
- * @param[in,out] ctx context information
- * @return error code
- */
-
-static long hdmi_rx_ctrl_get_tmds_clk(struct hdmi_rx_ctrl *ctx)
-{
-	return ctx->tmds_clk;
-}
-
-static int clock_handler(struct hdmi_rx_ctrl *ctx)
-{
-	int error = 0;
-	unsigned long tclk = 0;
-
-    if (sm_pause) {
-        return 0;
-    }
-
-	if (ctx == 0)	{
-		return -EINVAL;
-	}
-	tclk = hdmi_rx_ctrl_get_tmds_clk(ctx);
-	//hdmirx_get_video_info(ctx, &rx.video_params);
-	if (((tmds_clock_old + TMDS_TOLERANCE) > tclk) &&
-		((tmds_clock_old - TMDS_TOLERANCE) < tclk)) {
-		return 0;
-	}
-	if ((tclk == 0) && (tmds_clock_old != 0)) {
-		//if(video_format_change())
-	    rx.change = unready2_stable_th;
-		if (hdmirx_log_flag & 0x100) {
-		    printk("[hdmirx clock_handler] clk change\n");
-	}
-		/* TODO Review if we need to turn off the display
-		video_if_mode(false, 0, 0, 0);
-		*/
-#if 0
-		/* workaround for sticky HDMI mode */
-		error |= rx_ctrl_config(ctx, rx.port, &rx.hdcp);
-#endif
-	}
-	else
-	{
-#if 0
-		error |= hdmi_rx_phy_config(&rx.phy, rx.port, tclk, v.deep_color_mode);
-#endif
-	}
-	tmds_clock_old = ctx->tmds_clk;
-//#if MESSAGES
-	//ctx->log_info("TMDS clock: %3u.%03uMHz",
-	//		ctx->tmds_clk / 1000, ctx->tmds_clk % 1000);
-//#endif
-	return error;
-}
-
-static unsigned char is_3d_sig(void)
-{
-	if((rx.vendor_specific_info.identifier == 0x000c03)&&
-	(rx.vendor_specific_info.hdmi_video_format == 0x2)){
-		return 1;
-	}
-		return 0;
-}
-
-#if 0
-/*
-*make sure if video format change
-*/
-bool video_format_change(void)
-{
-	if(is_3d_sig()){	//only for 3D sig
-		if (((rx.cur_video_params.hactive + 5) < (rx.reltime_video_params.hactive)) ||
-			((rx.cur_video_params.hactive - 5) > (rx.reltime_video_params.hactive)) ||
-			((rx.cur_video_params.vactive + 5) < (rx.reltime_video_params.vactive)) ||
-			((rx.cur_video_params.vactive - 5) > (rx.reltime_video_params.vactive)) ||
-			(rx.cur_video_params.pixel_repetition != rx.reltime_video_params.pixel_repetition)) {
-
-			if(hdmirx_log_flag&0x200){
-				printk("[hdmi] 3D timing change: hactive(%d=>%d), vactive(%d=>%d), pixel_repeat(%d=>%d), video_format(%d=>%d),video_VIC(%d=>%d)\n",
-				rx.cur_video_params.hactive, rx.reltime_video_params.hactive,
-				rx.cur_video_params.vactive, rx.reltime_video_params.vactive,
-				rx.cur_video_params.pixel_repetition, rx.reltime_video_params.pixel_repetition,
-				rx.cur_video_params.video_format, rx.reltime_video_params.video_format,
-				rx.cur_video_params.video_mode, rx.reltime_video_params.video_mode);
-			}
-			return true;
-
-		} else {
-			return false;
-		}
-	} else {	// for 2d sig
-		return true;
-	}
-}
-
-bool is_format_change(struct hdmi_rx_ctrl *ctx)
-{
-	int error = 0;
-	int vic = 0;
-	bool ret = false;
-	struct hdmi_rx_ctrl_video v;
-
-	if (ctx == 0) {
-		return -EINVAL;
-	}
-
-	error |= hdmirx_get_video_info(ctx, &v);
-	if ((error == 0) && (((rx.cur_video_params.hactive + 5) < (v.hactive)) ||
-			     ((rx.cur_video_params.hactive - 5) > (v.hactive)) ||
-			     ((rx.cur_video_params.vactive + 5) < (v.vactive)) ||
-			     ((rx.cur_video_params.vactive - 5) > (v.vactive)) ||
-			     (rx.cur_video_params.pixel_repetition != v.pixel_repetition)))
-	{
-		ret = true;
-		if(hdmirx_log_flag&0x200){
-			printk("HDMI mode change: hactive(%d=>%d), vactive(%d=>%d), pixel_repeat(%d=>%d), video_format(%d=>%d)\n",
-			rx.cur_video_params.hactive,		v.hactive,
-			rx.cur_video_params.vactive,		v.vactive,
-			rx.cur_video_params.pixel_repetition,	v.pixel_repetition,
-			rx.cur_video_params.video_format,	v.video_format);
-		}
-
-	}
-
-	return ret;
-}
-#endif
-
-/**
- * Video event handler
- * @param[in,out] ctx context information
- * @return error code
- */
-static int video_handler(struct hdmi_rx_ctrl *ctx)
-{
-	int error = 0;
-	struct hdmi_rx_ctrl_video v;
-	struct hdmi_rx_ctrl_video *pre = &rx.pre_video_params;
-
-	if(hdmirx_log_flag&0x100)
-	hdmirx_print("%s \n", __func__);
-
-    if(sm_pause){
-        return 0;
-    }
-
-	if (ctx == 0) {
-		return -EINVAL;
-	}
-
-#if 0
-	/* wait for the video mode is stable */
-	for (i = 0; i < 5000000; i++)
-	{
-		;
-	}
-#endif
-	error |= hdmirx_get_video_info(ctx, &v);
-	if ((error == 0) &&
-	    ((abs((signed int)pre->hactive -(signed int)v.hactive) > diff_pixel_th) ||
-	     (abs((signed int)pre->vactive -(signed int)v.vactive) > diff_line_th) ||
-	     (pre->pixel_repetition != v.pixel_repetition)))	{
-
-	    /* only state is ready need skip frame when signal change */
-	    if (rx.state != HDMIRX_HWSTATE_SIG_READY)
-	        return 0;
-	    rx.change = unready2_stable_th;
-	    /* need check ... */
-	    //if (get_vic_from_timing(&v) !=0) {
-	    if (hdmirx_log_flag&0x100) {
-	        printk("[HDMIrx video_handler] VIC(%d=>%d) hactive(%d=>%d), vactive(%d=>%d), pixel_repeat(%d=>%d), video_format(%d=>%d)\n",
-	             pre->video_mode, v.video_mode, pre->hactive, v.hactive,
-	             pre->vactive, v.vactive, pre->pixel_repetition, v.pixel_repetition,
-	             pre->video_format, v.video_format);
-	    }
-	}
-
-	return error;
-}
-
-static int vsi_handler(void)
-{
-    if (sm_pause) {
-        return 0;
-    }
-	//hdmirx_read_vendor_specific_info_frame(&rx.vendor_specific_info.identifier);
-	hdmirx_read_vendor_specific_info_frame(&rx.vendor_specific_info);
-	return 0;
-}
-
-/**
- * Audio event handler
- * @param[in,out] ctx context information
- * @return error code
- */
-#if 0
-static int audio_handler(struct hdmi_rx_ctrl *ctx)
-{
-	int error = 0;
-  /*
-	struct hdmi_rx_ctrl_audio a;
-  if(hdmirx_log_flag&0x100)
-    hdmirx_print("%s \n", __func__);
-
-	if (ctx == 0)
-	{
-		return -EINVAL;
-	}
-	error |= hdmi_rx_ctrl_get_audio(ctx, &a);
-	if (error == 0)
-	{
-		ctx->log_info("Audio: CT=%u CC=%u SF=%u SS=%u CA=%u",
-				a.coding_type, a.channel_count, a.sample_frequency,
-				a.sample_size, a.channel_allocation);
-	}
-	*/
-	//hdmirx_read_audio_info();
-
-	return error;
-}
-#endif
-
-static int hdmi_rx_ctrl_irq_handler(struct hdmi_rx_ctrl *ctx)
-{
-    int error = 0;
-    unsigned i = 0;
-    uint32_t intr_hdmi = 0;
-    uint32_t intr_md = 0;
-    uint32_t intr_pedc = 0;
-    //uint32_t intr_aud_clk = 0;
-    uint32_t intr_aud_fifo = 0;
-    uint32_t data = 0;
-    unsigned long tclk = 0;
-    unsigned long ref_clk;
-    unsigned evaltime = 0;
-
-    bool clk_handle_flag = false;
-    bool video_handle_flag = false;
-    //bool audio_handle_flag = false;
-    bool vsi_handle_flag = false;
-
-    ref_clk = ctx->md_clk;
-
-    /* clear interrupt quickly */
-    intr_hdmi = hdmirx_rd_dwc(RA_HDMI_ISTS) & hdmirx_rd_dwc(RA_HDMI_IEN);
-    if (intr_hdmi != 0) {
-        hdmirx_wr_dwc(RA_HDMI_ICLR, intr_hdmi);
-    }
-
-    intr_md = hdmirx_rd_dwc(RA_MD_ISTS) & hdmirx_rd_dwc(RA_MD_IEN);
-    if (intr_md != 0) {
-        hdmirx_wr_dwc(RA_MD_ICLR, intr_md);
-    }
-
-    intr_pedc = hdmirx_rd_dwc(RA_PDEC_ISTS) & hdmirx_rd_dwc(RA_PDEC_IEN);
-    if (intr_pedc != 0) {
-        hdmirx_wr_dwc(RA_PDEC_ICLR, intr_pedc);
-    }
-
-    //intr_aud_clk = hdmirx_rd_dwc(RA_AUD_CLK_ISTS) & hdmirx_rd_dwc(RA_AUD_CLK_IEN);
-    //if (intr_aud_clk != 0) {
-    //    hdmirx_wr_dwc(RA_AUD_CLK_ICLR, intr_aud_clk);
-    //}
-
-    intr_aud_fifo = hdmirx_rd_dwc(RA_AUD_FIFO_ISTS) & hdmirx_rd_dwc(RA_AUD_FIFO_IEN);
-    if (intr_aud_fifo != 0) {
-        hdmirx_wr_dwc(RA_AUD_FIFO_ICLR, intr_aud_fifo);
-    }
-
-    if (intr_hdmi != 0) {
-        if (get(intr_hdmi, CLK_CHANGE) != 0) {
-            clk_handle_flag = true;
-            evaltime = (ref_clk * 4095) / 158000;
-            data = hdmirx_rd_dwc(RA_HDMI_CKM_RESULT);
-            tclk = ((ref_clk * get(data, CLKRATE)) / evaltime);
-            if(hdmirx_log_flag&0x100)
-                hdmirx_print("[HDMIrx isr] CLK_CHANGE (%d) \n", tclk);
-            if (tclk == 0) {
-                //error |= hdmirx_interrupts_hpd(false);
-                error |= hdmirx_control_clk_range(TMDS_CLK_MIN, TMDS_CLK_MAX);
-            } else {
-                for (i = 0; i < TMDS_STABLE_TIMEOUT; i++) { /* time for TMDS to stabilise */
-                    ;
-                }
-                tclk = ((ref_clk * get(data, CLKRATE)) / evaltime);
-                error |= hdmirx_control_clk_range(tclk - TMDS_CLK_DELTA, tclk + TMDS_CLK_DELTA);
-                //error |= hdmirx_interrupts_hpd(true);
-            }
-            ctx->tmds_clk = tclk;
-        }
-        if (get(intr_hdmi, DCM_CURRENT_MODE_CHG) != 0) {
-            if(hdmirx_log_flag&0x400)
-                hdmirx_print("[HDMIrx isr] DMI DCM_CURRENT_MODE_CHG \n");
-            video_handle_flag = true;
-        }
-        //if (get(intr_hdmi, AKSV_RCV) != 0) {
-        //    if(hdmirx_log_flag&0x400)
-        //        hdmirx_print("[HDMIrx isr] AKSV_RCV \n");
-        //        //execute[hdmi_rx_ctrl_event_aksv_reception] = true;
-        //}
-        ctx->debug_irq_hdmi++;
-    }
-
-    if (intr_md != 0) {
-        if (get(intr_md, VIDEO_MODE) != 0) {
-            if(hdmirx_log_flag&0x400)
-                hdmirx_print("[HDMIrx isr] VIDEO_MODE: %x\n", intr_md);
-            video_handle_flag = true;
-        }
-        ctx->debug_irq_video_mode++;
-    }
-
-    if (intr_pedc != 0) {
-        //hdmirx_wr_dwc(RA_PDEC_ICLR, intr_pedc);
-        if (get(intr_pedc, DVIDET|AVI_CKS_CHG) != 0) {
-            if(hdmirx_log_flag&0x400)
-                hdmirx_print("[HDMIrx isr] AVI_CKS_CHG \n");
-            video_handle_flag = true;
-        }
-        if (get(intr_pedc, VSI_CKS_CHG) != 0) {
-            if(hdmirx_log_flag&0x400)
-                hdmirx_print("[HDMIrx isr] VSI_CKS_CHG \n");
-            vsi_handle_flag = true;
-        }
-        //if (get(intr_pedc, AIF_CKS_CHG) != 0) {
-        //    if(hdmirx_log_flag&0x400)
-        //        hdmirx_print("[HDMIrx isr] AIF_CKS_CHG \n");
-        //    audio_handle_flag = true;
-        //}
-        //if (get(intr_pedc, PD_FIFO_NEW_ENTRY) != 0) {
-        //    if(hdmirx_log_flag&0x400)
-        //        hdmirx_print("[HDMIrx isr] PD_FIFO_NEW_ENTRY \n");
-        //    //execute[hdmi_rx_ctrl_event_packet_reception] = true;
-        //}
-        if (get(intr_pedc, PD_FIFO_OVERFL) != 0) {
-            if(hdmirx_log_flag&0x100)
-                hdmirx_print("[HDMIrx isr] PD_FIFO_OVERFL \n");
-            error |= hdmirx_packet_fifo_rst();
-        }
-        ctx->debug_irq_packet_decoder++;
-    }
-
-    //if (intr_aud_clk != 0) {
-    //    if(hdmirx_log_flag&0x400)
-    //        hdmirx_print("[HDMIrx isr] RA_AUD_CLK \n");
-    //        ctx->debug_irq_audio_clock++;
-    //}
-
-    if (intr_aud_fifo != 0) {
-        if (get(intr_aud_fifo, AFIF_OVERFL|AFIF_UNDERFL) != 0) {
-            if(hdmirx_log_flag&0x100)
-                hdmirx_print("[HDMIrx isr] AFIF_OVERFL|AFIF_UNDERFL \n");
-            error |= hdmirx_audio_fifo_rst();
-        }
-        ctx->debug_irq_audio_fifo++;
-    }
-
-    if(clk_handle_flag){
-        clock_handler(ctx);
-    }
-    if(video_handle_flag){
-        video_handler(ctx);
-    }
-    if(vsi_handle_flag){
-        vsi_handler();
-    }
-    return error;
-}
-
-
-static irqreturn_t irq_handler(int irq, void *params)
-{
-    int error = 0;
-    unsigned long hdmirx_top_intr_stat;
-
-    if (params == 0) {
-        pr_info("%s: %s\n", __func__, "RX IRQ invalid parameter");
-        return IRQ_HANDLED;
-    }
-
-    hdmirx_top_intr_stat = hdmirx_rd_top(HDMIRX_TOP_INTR_STAT);
-reisr:    hdmirx_wr_top(HDMIRX_TOP_INTR_STAT_CLR, hdmirx_top_intr_stat); // clear interrupts in HDMIRX-TOP module
-
-    /* must clear ip interrupt quickly */
-    if(hdmirx_top_intr_stat & (1 << 31)){
-        error = hdmi_rx_ctrl_irq_handler(&((struct rx *)params)->ctrl);
-        if (error < 0) {
-            if (error != -EPERM) {
-                pr_info("%s: RX IRQ handler %d\n", __func__, error);
-            }
-        }
-    }
-
-    /* top interrupt handler */
-    if (hdmirx_top_intr_stat & (0xf << 2)) {    // [5:2] hdmirx_5v_rise
-        //rx.tx_5v_status = true;
-        if(hdmirx_log_flag&0x400)
-            printk("[HDMIrx isr] 5v rise \n");
-    } /* if (hdmirx_top_intr_stat & (0xf << 2)) // [5:2] hdmirx_5v_rise */
-
-    if (hdmirx_top_intr_stat & (0xf << 6)) {    // [9:6] hdmirx_5v_fall
-        //rx.tx_5v_status = false;
-        if(hdmirx_log_flag&0x400)
-            printk("[HDMIrx isr] 5v fall \n");
-    } /* if (hdmirx_top_intr_stat & (0xf << 6)) // [9:6] hdmirx_5v_fall */
-
-    /* check the ip interrupt again */
-    hdmirx_top_intr_stat = hdmirx_rd_top(HDMIRX_TOP_INTR_STAT);
-    if (hdmirx_top_intr_stat & (1 << 31)){
-        if(hdmirx_log_flag&0x1000)
-            printk("[HDMIrx isr] need clear ip irq--- \n");
-        goto reisr;
-        //ip_irq_clr = 0;
-    }   //else
-        //ip_irq_clr = 1;
-
-    return IRQ_HANDLED;
-
-}
-
-
-
-typedef struct{
-	unsigned int sample_rate;
-	unsigned char aud_info_sf;
-	unsigned char channel_status_id;
-}sample_rate_info_t;
-
-sample_rate_info_t sample_rate_info[]=
-{
-	{32000,  0x1,  0x3},
-	{44100,  0x2,  0x0},
-	{48000,  0x3,  0x2},
-	{88200,  0x4,  0x8},
-	{96000,  0x5,  0xa},
-	{176400, 0x6,  0xc},
-	{192000, 0x7,  0xe},
-	//{768000, 0, 0x9},
-	{0, 0, 0}
-};
-
-static int get_real_sample_rate(void)
-{
-    int i;
-    int ret_sample_rate = rx.aud_info.audio_recovery_clock;
-    for(i=0; sample_rate_info[i].sample_rate; i++){
-        if(rx.aud_info.audio_recovery_clock > sample_rate_info[i].sample_rate){
-            if((rx.aud_info.audio_recovery_clock-sample_rate_info[i].sample_rate)<sample_rate_change_th){
-                ret_sample_rate = sample_rate_info[i].sample_rate;
-                break;
-            }
-        }
-        else{
-            if((sample_rate_info[i].sample_rate - rx.aud_info.audio_recovery_clock)<sample_rate_change_th){
-                ret_sample_rate = sample_rate_info[i].sample_rate;
-                break;
-            }
-        }
-    }
-    return ret_sample_rate;
-}
-
-static unsigned char is_sample_rate_change(int sample_rate_pre, int sample_rate_cur)
-{
-    unsigned char ret = 0;
-    if((sample_rate_cur!=0)&&
-        (sample_rate_cur>31000)&&(sample_rate_cur<193000)){
-        if(sample_rate_pre > sample_rate_cur){
-            if((sample_rate_pre - sample_rate_cur)> sample_rate_change_th){
-                ret = 1;
-            }
-        }
-        else{
-            if((sample_rate_cur - sample_rate_pre)> sample_rate_change_th){
-                ret = 1;
-            }
-        }
-    }
-    return ret;
-}
-
-bool hdmirx_hw_check_frame_skip(void)
-{
-    if ((force_state&0x10) || (!frame_skip_en))
-        return false;
-    else if ((rx.state != HDMIRX_HWSTATE_SIG_READY) || (rx.change > 0)) {
-	    return true;
-    }
-
-    return false;
-}
-
-int hdmirx_hw_get_color_fmt(void)
-{
-	int color_format = 0;
-	int format = rx.video_params.video_format;
-	if(force_format&0x10){
-		format = force_format&0xf;
-	}
-	if (rx.change > 0)
-	    return last_color_fmt;
-	switch(format){
-	case 1:
-		color_format = 3; /* YUV422 */
-		break;
-	case 2:
-		color_format = 1; /* YUV444*/
-		break;
-	case 0:
-	default:
-		color_format = 0; /* RGB444 */
-		break;
-		}
-
-	last_color_fmt = color_format;
-
-	return color_format;
-}
-
-int hdmirx_hw_get_dvi_info(void)
-{
-	int ret = 0;
-
-	if(rx.video_params.sw_dvi){
-		ret = 1;
-	}
-	return ret;
-}
-
-int hdmirx_hw_get_3d_structure(unsigned char* _3d_structure, unsigned char* _3d_ext_data)
-{
-	if((rx.vendor_specific_info.identifier == 0x000c03)&&
-	(rx.vendor_specific_info.hdmi_video_format == 0x2)){
-	*_3d_structure = rx.vendor_specific_info._3d_structure;
-	*_3d_ext_data = rx.vendor_specific_info._3d_ext_data;
-	return 0;
-	}
-	return -1;
-}
-
-int hdmirx_hw_get_pixel_repeat(void)
-{
-    /* use hdmirx hscaler for 4k2k input */
-    if ((rx.video_params.sw_vic >= HDMI_3840_2160p) && (rx.video_params.sw_vic <= HDMI_4096_2160p))
-        return (2);
-    else
-        return (rx.video_params.pixel_repetition+1);
-}
-
-
-static unsigned char is_frame_packing(void)
-{
-
-#if 1
-    return (rx.video_params.sw_fp);
-#else
-    if((rx.vendor_specific_info.identifier == 0x000c03)&&
-    (rx.vendor_specific_info.hdmi_video_format == 0x2)&&
-    (rx.vendor_specific_info._3d_structure == 0x0)){
-    return 1;
-    }
-    return 0;
-#endif
-}
-
-static unsigned char is_alternative(void)
-{
-    return (rx.video_params.sw_alternative);
-}
-
-typedef struct{
-    unsigned int vic;
-    unsigned char vesa_format;
-    unsigned int ref_freq; /* 8 bit tmds clock */
-    unsigned int active_pixels;
-    unsigned int active_lines;
-    unsigned int active_lines_fp;
-    unsigned int active_lines_alternative;
-    //unsigned char frame_rate;
-}freq_ref_t;
-
-static freq_ref_t freq_ref[]=
-{
-/* basic format*/
-	{HDMI_640x480p60,  0,  25000,  640,  480,  480, 480},//, 60},
-	{HDMI_480p60,      0,  27000,  720,  480, 1005, 480},//, 60},
-	{HDMI_480p60_16x9, 0,  27000,  720,  480, 1005, 480},//, 60},
-	{HDMI_480i60,      0,  27000, 1440,  240,  240, 240},//, 60},
-	{HDMI_480i60_16x9, 0,  27000, 1440,  240,  240, 240},//, 60},
-	{HDMI_576p50,      0,  27000,  720,  576, 1201, 576},//, 50},
-	{HDMI_576p50_16x9, 0,  27000,  720,  576, 1201, 576},//, 50},
-	{HDMI_576i50,      0,  27000, 1440,  288,  288, 288},//, 50},
-	{HDMI_576i50_16x9, 0,  27000, 1440,  288,  288, 288},//, 50},
-	{HDMI_576i50_16x9, 0,  27000, 1440,  145,  145, 145},//, 50},
-	{HDMI_720p60,      0,  74250, 1280,  720, 1470, 720},//, 60},
-	{HDMI_720p50,      0,  74250, 1280,  720, 1470, 720},//, 50},
-	{HDMI_1080i60,     0,  74250, 1920,  540, 2228, 1103},//, 60},
-	{HDMI_1080i50,     0,  74250, 1920,  540, 2228, 1103},//, 50},
-	{HDMI_1080p60,     0, 148500, 1920, 1080, 1080, 2160},//, 60},
-	{HDMI_1080p24,     0,  74250, 1920, 1080, 2205, 2160},//, 24},
-	{HDMI_1080p25,     0,  74250, 1920, 1080, 2205, 2160},//, 25},
-	{HDMI_1080p30,     0,  74250, 1920, 1080, 2205, 2160},//, 30},
-	{HDMI_1080p50,     0, 148500, 1920, 1080, 1080, 2160},//, 50},
-/* extend format */
-	{HDMI_1440x240p60,      0, 27000, 1440, 240, 240, 240},//, 60},      //vic 8
-	{HDMI_1440x240p60_16x9, 0, 27000, 1440, 240, 240, 240},//, 60}, //vic 9
-	{HDMI_2880x480i60,      0, 54000, 2880, 240, 240, 240},//, 60},      //vic 10
-	{HDMI_2880x480i60_16x9, 0, 54000, 2880, 240, 240, 240},//, 60}, //vic 11
-	{HDMI_2880x240p60,      0, 54000, 2880, 240, 240, 240},//, 60},      //vic 12
-	{HDMI_2880x240p60_16x9, 0, 54000, 2880, 240, 240, 240},//, 60}, //vic 13
-	{HDMI_1440x480p60,      0, 54000, 1440, 480, 480, 480},//, 60},      //vic 14
-	{HDMI_1440x480p60_16x9, 0, 54000, 1440, 480, 480, 480},//, 60}, //vic 15
-
-	{HDMI_1440x288p50,      0, 27000, 1440, 288, 288, 288},//, 50},      //vic 23
-	{HDMI_1440x288p50_16x9, 0, 27000, 1440, 288, 288, 288},//, 50}, //vic 24
-	{HDMI_2880x576i50,      0, 54000, 2880, 288, 288, 288},//, 50},      //vic 25
-	{HDMI_2880x576i50_16x9, 0, 54000, 2880, 288, 288, 288},//, 50}, //vic 26
-	{HDMI_2880x288p50,      0, 54000, 2880, 288, 288, 288},//, 50},      //vic 27
-	{HDMI_2880x288p50_16x9, 0, 54000, 2880, 288, 288, 288},//, 50}, //vic 28
-	{HDMI_1440x576p50,      0, 54000, 1440, 576, 576, 576},//, 50},      //vic 29
-	{HDMI_1440x576p50_16x9, 0, 54000, 1440, 576, 576, 576},//, 50}, //vic 30
-
-	{HDMI_2880x480p60,      0, 108000, 2880, 480,  480, 480},//, 60},     //vic 35
-	{HDMI_2880x480p60_16x9, 0, 108000, 2880, 480,  480, 480},//, 60},//vic 36
-	{HDMI_2880x576p50,      0, 108000, 2880, 576,  576, 576},//, 50},     //vic 37
-	{HDMI_2880x576p50_16x9, 0, 108000, 2880, 576,  576, 576},//, 50},//vic 38
-	{HDMI_1080i50_1250,     0,  72000, 1920, 540,  540, 540},//, 50},     //vic 39
-	{HDMI_720p24,           0,  74250, 1280, 720, 1470, 720},//, 24},          //vic 60
-	{HDMI_720p30,           0,  74250, 1280, 720, 1470, 720},//, 30},          //vic 62
-
-/* vesa format*/
-	{HDMI_800_600,   1, 0,  800,  600,  600,  600},//, 0},
-	{HDMI_1024_768,  1, 0, 1024,  768,  768,  768},//, 0},
-	{HDMI_720_400,   1, 0,  720,  400,  400,  400},//, 0},
-	{HDMI_1280_768,  1, 0, 1280,  768,  768,  768},//, 0},
-	{HDMI_1280_800,  1, 0, 1280,  800,  800,  800},//, 0},
-	{HDMI_1280_960,  1, 0, 1280,  960,  960,  960},//, 0},
-	{HDMI_1280_1024, 1, 0, 1280, 1024, 1024, 1024},//, 0},
-	{HDMI_1360_768,  1, 0, 1360,  768,  768,  768},//, 0},
-	{HDMI_1366_768,  1, 0, 1366,  768,  768,  768},//, 0},
-	{HDMI_1600_1200, 1, 0, 1600, 1200, 1200, 1200},//, 0},
-	{HDMI_1920_1200, 1, 0, 1920, 1200, 1200, 1200},//, 0},
-	{HDMI_1440_900,  1, 0, 1440,  900,  900,  900},//, 0},
-	{HDMI_1400_1050, 1, 0, 1400, 1050, 1050, 1050},//, 0},
-	{HDMI_1680_1050, 1, 0, 1680, 1050, 1050, 1050},//, 0},          //vic 79
-    /* 4k2k mode */
-    {HDMI_3840_2160p, 0, 0, 3840, 2160, 2160, 2160},//
-    {HDMI_4096_2160p, 0, 0, 4096, 2160, 2160, 2160},//         /* 81 */
-
-
-	/* for AG-506 */
-	{HDMI_480p60, 0, 27000, 720, 483, 483, 483},//, 0},
-	{0, 0, 0, 0, 0, 0, 0}//, 0}
-};
-
-
-unsigned int get_vic_from_timing(struct hdmi_rx_ctrl_video* video_par)
-{
-	int i;
-	for(i = 0; freq_ref[i].vic; i++){
-		if((abs((signed int)video_par->hactive - (signed int)freq_ref[i].active_pixels) <= diff_pixel_th) &&
-		   ((abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines) <= diff_line_th) ||
-		    (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_fp) <= diff_line_th) ||
-            (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_alternative) <= diff_line_th)
-           )) {
-		    break;
-		}
-	}
-	return freq_ref[i].vic;
-}
-
-unsigned int get_index_from_ref(struct hdmi_rx_ctrl_video* video_par)
-{
-    int i;
-    for(i = 0; freq_ref[i].vic; i++){
-        if((abs((signed int)video_par->hactive - (signed int)freq_ref[i].active_pixels) <= diff_pixel_th) &&
-           ((abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines) <= diff_line_th) ||
-            (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_fp) <= diff_line_th) ||
-            (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_alternative) <= diff_line_th)
-           )) {
-            break;
-        }
-    }
-    return i;
-}
-
-enum tvin_sig_fmt_e hdmirx_hw_get_fmt(void)
-{
-	/* to do:
-	TVIN_SIG_FMT_HDMI_1280x720P_24Hz_FRAME_PACKING,
-	TVIN_SIG_FMT_HDMI_1280x720P_30Hz_FRAME_PACKING,
-
-	TVIN_SIG_FMT_HDMI_1920x1080P_24Hz_FRAME_PACKING,
-	TVIN_SIG_FMT_HDMI_1920x1080P_30Hz_FRAME_PACKING, // 150
-	*/
-	enum tvin_sig_fmt_e fmt = TVIN_SIG_FMT_NULL;
-	unsigned int vic = rx.video_params.sw_vic;
-
-	if(force_vic){
-		vic = force_vic;
-	}
-
-	switch(vic){
-		/* basic format */
-		case HDMI_640x480p60:		    /*1*/
-			fmt = TVIN_SIG_FMT_HDMI_640X480P_60HZ;
-			break;
-		case HDMI_480p60:                   /*2*/
-		case HDMI_480p60_16x9:              /*3*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_720X480P_60HZ_FRAME_PACKING;
-			}
-			else{
-				fmt = TVIN_SIG_FMT_HDMI_720X480P_60HZ;
-			}
-			break;
-		case HDMI_720p60:                   /*4*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_60HZ_FRAME_PACKING;
-			}
-			else{
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_60HZ;
-			}
-			break;
-		case HDMI_1080i60:                  /*5*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_FRAME_PACKING;
-			} else if (is_alternative()) {
-			    fmt = TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_ALTERNATIVE;
-			} else {
-				fmt = TVIN_SIG_FMT_HDMI_1920X1080I_60HZ;
-			}
-			break;
-		case HDMI_480i60:                   /*6*/
-		case HDMI_480i60_16x9:              /*7*/
-			fmt = TVIN_SIG_FMT_HDMI_1440X480I_60HZ;
-			break;
-		case HDMI_1080p60:		    /*16*/
-		    fmt = TVIN_SIG_FMT_HDMI_1920X1080P_60HZ;
-			break;
-		case HDMI_1080p24:		    /*32*/
-			if(is_frame_packing()){
-			    fmt = TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_FRAME_PACKING;
-			} else if (is_alternative()) {
-			    fmt = TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_ALTERNATIVE;
-			} else {
-			    fmt = TVIN_SIG_FMT_HDMI_1920X1080P_24HZ;
-			}
-			break;
-		case HDMI_576p50:		    /*17*/
-		case HDMI_576p50_16x9:		    /*18*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_720X576P_50HZ_FRAME_PACKING;
-			}
-			else{
-				fmt = TVIN_SIG_FMT_HDMI_720X576P_50HZ;
-			}
-			break;
-		case HDMI_720p50:		    /*19*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_50HZ_FRAME_PACKING;
-			}
-			else{
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_50HZ;
-			}
-			break;
-		case HDMI_1080i50:		    /*20*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_FRAME_PACKING;
-			} else if (is_alternative()) {
-			    fmt = TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_ALTERNATIVE;
-			} else {
-				fmt = TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_A;
-			}
-			break;
-		case HDMI_576i50:		   /*21*/
-		case HDMI_576i50_16x9:		   /*22*/
-			fmt = TVIN_SIG_FMT_HDMI_1440X576I_50HZ;
-			break;
-		case HDMI_1080p50:		   /*31*/
-			fmt = TVIN_SIG_FMT_HDMI_1920X1080P_50HZ;
-			break;
-		case HDMI_1080p25:		   /*33*/
-			fmt = TVIN_SIG_FMT_HDMI_1920X1080P_25HZ;
-			break;
-		case HDMI_1080p30:		   /*34*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_FRAME_PACKING;
-			} else if (is_alternative()) {
-			    fmt = TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_ALTERNATIVE;
-			} else {
-				fmt = TVIN_SIG_FMT_HDMI_1920X1080P_30HZ;
-			}
-			break;
-		case HDMI_720p24:		   /*60*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_24HZ_FRAME_PACKING;
-			}
-			else{
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_24HZ;
-			}
-			break;
-		case HDMI_720p30:		   /*62*/
-			if(is_frame_packing()){
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_30HZ_FRAME_PACKING;
-			}
-			else{
-				fmt = TVIN_SIG_FMT_HDMI_1280X720P_30HZ;
-			}
-			break;
-
-		/* extend format */
-		case HDMI_1440x240p60:
-		case HDMI_1440x240p60_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_1440X240P_60HZ;
-			break;
-		case HDMI_2880x480i60:
-		case HDMI_2880x480i60_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_2880X480I_60HZ;
-			break;
-		case HDMI_2880x240p60:
-		case HDMI_2880x240p60_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_2880X240P_60HZ;
-			break;
-		case HDMI_1440x480p60:
-		case HDMI_1440x480p60_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_1440X480P_60HZ;
-			break;
-		case HDMI_1440x288p50:
-		case HDMI_1440x288p50_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_1440X288P_50HZ;
-			break;
-		case HDMI_2880x576i50:
-		case HDMI_2880x576i50_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_2880X576I_50HZ;
-			break;
-		case HDMI_2880x288p50:
-		case HDMI_2880x288p50_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_2880X288P_50HZ;
-			break;
-		case HDMI_1440x576p50:
-		case HDMI_1440x576p50_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_1440X576P_50HZ;
-			break;
-
-		case HDMI_2880x480p60:
-		case HDMI_2880x480p60_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_2880X480P_60HZ;
-			break;
-		case HDMI_2880x576p50:
-		case HDMI_2880x576p50_16x9:
-			fmt = TVIN_SIG_FMT_HDMI_2880X576P_60HZ; //????, should be TVIN_SIG_FMT_HDMI_2880x576P_50Hz
-			break;
-		case HDMI_1080i50_1250:
-			fmt = TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_B;
-			break;
-		case HDMI_1080I120:	/*46*/
-			fmt = TVIN_SIG_FMT_HDMI_1920X1080I_120HZ;
-			break;
-		case HDMI_720p120:	/*47*/
-			fmt = TVIN_SIG_FMT_HDMI_1280X720P_120HZ;
-			break;
-		case HDMI_1080p120:	/*63*/
-			fmt = TVIN_SIG_FMT_HDMI_1920X1080P_120HZ;
-			break;
-
-		/* vesa format*/
-		case HDMI_800_600:	/*65*/
-			fmt = TVIN_SIG_FMT_HDMI_800X600_00HZ;
-			break;
-		case HDMI_1024_768:	/*66*/
-			fmt = TVIN_SIG_FMT_HDMI_1024X768_00HZ;
-			break;
-		case HDMI_720_400:
-			fmt = TVIN_SIG_FMT_HDMI_720X400_00HZ;
-			break;
-		case HDMI_1280_768:
-			fmt = TVIN_SIG_FMT_HDMI_1280X768_00HZ;
-			break;
-		case HDMI_1280_800:
-			fmt = TVIN_SIG_FMT_HDMI_1280X800_00HZ;
-			break;
-		case HDMI_1280_960:
-			fmt = TVIN_SIG_FMT_HDMI_1280X960_00HZ;
-			break;
-		case HDMI_1280_1024:
-			fmt = TVIN_SIG_FMT_HDMI_1280X1024_00HZ;
-			break;
-		case HDMI_1360_768:
-			fmt = TVIN_SIG_FMT_HDMI_1360X768_00HZ;
-			break;
-		case HDMI_1366_768:
-			fmt = TVIN_SIG_FMT_HDMI_1366X768_00HZ;
-			break;
-		case HDMI_1600_1200:
-			fmt = TVIN_SIG_FMT_HDMI_1600X1200_00HZ;
-			break;
-		case HDMI_1920_1200:
-			fmt = TVIN_SIG_FMT_HDMI_1920X1200_00HZ;
-			break;
-		case HDMI_1440_900:
-			fmt = TVIN_SIG_FMT_HDMI_1440X900_00HZ;
-			break;
-		case HDMI_1400_1050:
-			fmt = TVIN_SIG_FMT_HDMI_1400X1050_00HZ;
-			break;
-		case HDMI_1680_1050:
-			fmt = TVIN_SIG_FMT_HDMI_1680X1050_00HZ;
-			break;
-            /* 4k2k mode */
-		case HDMI_3840_2160p:
-		    fmt = TVIN_SIG_FMT_HDMI_3840_2160_00HZ;
-		    break;
-		case HDMI_4096_2160p:
-		    fmt = TVIN_SIG_FMT_HDMI_4096_2160_00HZ;
-		    break;
-		default:
-			break;
-		}
-
-	return fmt;
-}
-
-bool hdmirx_hw_pll_lock(void)
-{
-	return (rx.state==HDMIRX_HWSTATE_SIG_READY);
-}
-
-bool hdmirx_hw_is_nosig(void)
-{
-	return rx.no_signal;
-}
-
-/*
- * check timing info
- */
-static bool is_timing_stable(struct hdmi_rx_ctrl_video *pre, struct hdmi_rx_ctrl_video *cur)
-{
-    bool ret = true;
-    int pixel_clk = hdmirx_get_pixel_clock();
-
-    //frame_rate = (cur->htotal==0||cur->vtotal==0)?0:
-    //        (pixel_clk/cur->htotal)*100/cur->vtotal;
-    if (    /*video_par->pixel_clk < PIXEL_CLK_MIN || video_par->pixel_clk > PIXEL_CLK_MAX*/
-        (pixel_clk/1000) < PIXEL_CLK_MIN || (pixel_clk/1000) > PIXEL_CLK_MAX
-        || cur->hactive < HRESOLUTION_MIN
-        || cur->hactive > HRESOLUTION_MAX
-        || cur->htotal < (cur->hactive + cur->hoffset)
-        || cur->vactive < VRESOLUTION_MIN
-        || cur->vactive > VRESOLUTION_MAX
-        || cur->vtotal < (cur->vactive + cur->voffset)
-        /*|| cur->refresh_rate < REFRESH_RATE_MIN
-        || cur->refresh_rate > REFRESH_RATE_MAX
-        */) {
-            if(hdmirx_log_flag&0x200)
-                printk("%s timing error pixel clk %d hactive %d htotal %d(%d) vactive %d vtotal %d(%d) %ld\n", __func__,
-                    pixel_clk/1000,
-                    cur->hactive,  cur->htotal, cur->hactive+cur->hoffset,
-                    cur->vactive,  cur->vtotal, cur->vactive+cur->voffset,
-                    cur->refresh_rate);
-            return false;
-    }
-    if ((abs((signed int)pre->hactive - (signed int)cur->hactive) > diff_pixel_th) &&
-        (abs((signed int)pre->vactive - (signed int)cur->vactive) > diff_line_th) &&
-        (pre->pixel_repetition != cur->pixel_repetition)) {
-        ret = false;
-
-        if(hdmirx_log_flag&0x200){
-            printk("[hdmirx] timing unstable: hactive(%d=>%d), vactive(%d=>%d), pixel_repeat(%d=>%d), video_format(%d=>%d)\n",
-                    pre->hactive,        cur->hactive,
-                    pre->vactive,        cur->vactive,
-                    pre->pixel_repetition,   cur->pixel_repetition,
-                    pre->video_format,   cur->video_format);
-        }
-    }
-    return ret;
-}
-/*
- * check frame rate
- */
-static bool is_frame_rate_change(struct hdmi_rx_ctrl_video *pre, struct hdmi_rx_ctrl_video *cur)
-{
-    bool ret = false;
-    unsigned int pre_rate = (unsigned int)pre->refresh_rate * 2;
-    unsigned int cur_rate = (unsigned int)cur->refresh_rate * 2;
-
-    if ((abs((signed int)pre_rate - (signed int)cur_rate) > diff_frame_th)) {
-        ret = true;
-
-        if(hdmirx_log_flag&0x200){
-            printk("[hdmirx] frame rate change: refresh_rate(%ld=>%ld), frame_rate:%d\n",
-                    pre->refresh_rate,        cur->refresh_rate, cur_rate);
-        }
-    }
-    return ret;
-}
-
-/*
- * check timing info
- */
-static bool is_timing_change(struct hdmi_rx_ctrl_video *pre, struct hdmi_rx_ctrl_video *cur)
-{
-    bool ret = false;
-
-    if ((abs((signed int)pre->hactive - (signed int)cur->hactive) > chg_pixel_th) ||
-        (abs((signed int)pre->vactive - (signed int)cur->vactive) > chg_line_th)) {
-        ret = true;
-
-        if (hdmirx_log_flag&0x200) {
-            printk("[hdmirx] timing change: hactive(%d=>%d), vactive(%d=>%d), pixel_repeat(%d=>%d), video_format(%d=>%d)\n",
-                    pre->hactive,        cur->hactive,
-                    pre->vactive,        cur->vactive,
-                    pre->pixel_repetition,   cur->pixel_repetition,
-                    pre->video_format,   cur->video_format);
-        }
-    }
-
-    return ret;
-}
-
-static int get_timing_fmt(struct hdmi_rx_ctrl_video *video_par)
-{
-	int i;
-	int ret = 1;
-
-	video_par->sw_vic = 0;
-	video_par->sw_dvi = 0;
-	video_par->sw_fp = 0;
-	video_par->sw_alternative = 0;
-	frame_rate = video_par->refresh_rate * 2;
-
-	if ((frame_rate > 9000) && use_frame_rate_check) {
-        if(hdmirx_log_flag&0x200)
-            printk("[hdmirx] frame_rate not support,sw_vic:%d,hw_vic:%d, frame_rate:%d \n",
-                    video_par->sw_vic,video_par->video_mode,frame_rate);
-        return ret;
-	}
-    for (i = 0; freq_ref[i].vic; i++) {
-        if (freq_ref[i].vic == video_par->video_mode) {
-            if ((abs((signed int)video_par->hactive - (signed int)freq_ref[i].active_pixels) <= diff_pixel_th) &&
-                ((abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines) <= diff_line_th) ||
-                 (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_fp) <= diff_line_th) ||
-                 (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_alternative) <= diff_line_th)
-                   )) {
-            break;
-            }
-        }
-    }
-
-    /* hdmi mode */
-    if (freq_ref[i].vic != 0) {
-        /*found standard hdmi mode */
-        video_par->sw_vic = freq_ref[i].vic;
-        if ((freq_ref[i].active_lines != freq_ref[i].active_lines_fp)
-            && (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_fp) <= diff_line_th))
-            video_par->sw_fp = 1;
-        else if ((freq_ref[i].active_lines != freq_ref[i].active_lines_alternative)
-            && (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_alternative) <= diff_line_th))
-            video_par->sw_alternative = 1;
-        if(hdmirx_log_flag&0x200)
-            printk("[hdmirx] standard hdmi mode,sw_vic:%d,hw_vic:%d, frame_rate:%d \n",
-                    video_par->sw_vic,video_par->video_mode,frame_rate);
-        return ret;
-    }
-
-    /* check the timing information */
-    i = get_index_from_ref(video_par);
-    video_par->sw_vic = freq_ref[i].vic;
-
-    if (video_par->video_mode != 0) {
-        /* non standard vic mode */
-#if 0
-        if (video_par->sw_vic == 0) {
-            /* non standard timing info */
-            video_par->sw_vic = video_par->video_mode;
-        }
-        /* get the right frame rate????? */
-#endif
-        if ((freq_ref[i].active_lines != freq_ref[i].active_lines_fp)
-            && (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_fp) <= diff_line_th))
-            video_par->sw_fp = 1;
-        else if ((freq_ref[i].active_lines != freq_ref[i].active_lines_alternative)
-                && (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_alternative) <= diff_line_th))
-            video_par->sw_alternative = 1;
-        if(hdmirx_log_flag&0x200)
-            printk("[hdmirx] non standard hdmi mode,sw_vic:%d,hw_vic:%d, frame_rate:%d\n",
-                    video_par->sw_vic,video_par->video_mode,frame_rate);
-        return ret;
-    }
-
-    /* dvi mode */
-    video_par->sw_dvi = 1;
-    if (video_par->dvi != 0) {
-        if(hdmirx_log_flag&0x200)
-            printk("[hdmirx] dvi timing not support!!!,sw_vic:%d, frame_rate:%d\n",
-                    video_par->sw_vic,frame_rate);
-        return ret;
-    }
-
-    /* video mode is 0; dvi mode is 0 */
-    if ((freq_ref[i].active_lines != freq_ref[i].active_lines_fp)
-        && (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_fp) <= diff_line_th))
-            video_par->sw_fp = 1;
-    else if ((freq_ref[i].active_lines != freq_ref[i].active_lines_alternative)
-            && (abs((signed int)video_par->vactive - (signed int)freq_ref[i].active_lines_alternative) <= diff_line_th))
-        video_par->sw_alternative = 1;
-    video_par->sw_dvi = 0;  //set default to hdmi mode
-    if (video_par->sw_vic == 0) {
-        if(hdmirx_log_flag&0x200)
-            printk("[hdmirx] invalid timing !!!,sw_vic:%d, frame_rate:%d \n",
-                    video_par->sw_vic,frame_rate);
-    }
-		    //if (!unsupport_info)
-	return ret;
-}
-
-/*
- * init audio information
- */
-static void audio_status_init(void)
-{
-    audio_sample_rate = 0;
-    audio_coding_type = 0;
-    audio_channel_count = 0;
-}
-
-static void Signal_status_init(void)
-{
-    sig_unlock_count = 0;
-    sig_lock_count = 0;
-    pll_unlock_count = 0;
-    sig_unstable_count = 0;
-    sig_unready_cnt = 0;
-    sig_stable2_ready_cnt = 0;
-    sw_5v_sts = false;
-}
-
-bool pow_state(void)
-{
-	bool ret = false;
-	char sum_state = 0;
-
-	rx.pow5v_state[0] = rx.pow5v_state[1];
-	rx.pow5v_state[1] = rx.pow5v_state[2];
-	rx.pow5v_state[2] = rx.pow5v_state[3];
-	rx.pow5v_state[3] = rx.pow5v_state[4];
-	rx.pow5v_state[4] = rx.pow5v_state[5];
-	rx.pow5v_state[5] = rx.pow5v_state[6];
-	rx.pow5v_state[6] = rx.pow5v_state[7];
-	rx.pow5v_state[7] = rx.pow5v_state[8];
-	rx.pow5v_state[8] = rx.pow5v_state[9];
-	rx.pow5v_state[9] = (hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)>>(20 + rx.port)&0x1);
-	sum_state = rx.pow5v_state[0] + rx.pow5v_state[1] + rx.pow5v_state[2]
-		    + rx.pow5v_state[3] + rx.pow5v_state[4] + rx.pow5v_state[5] + rx.pow5v_state[6]
-		    + rx.pow5v_state[7] + rx.pow5v_state[8] + rx.pow5v_state[9];
-	if(sum_state <= 2) {
-		ret = false;
-	} else if (sum_state >= 5) {
-		ret = true;
-	}
-
-	return ret;
-}
-
-void hdmirx_hw_monitor(void)
-{
-    int pre_sample_rate;
-    bool tx_5v_status;
-//    unsigned long top_intr_stat = 0;
-//    int error = 0;
-
-  if(sm_pause)
-    return;
-
-    if (use_hw_hpd) {
-        //rx.tx_5v_status = (hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)>>(20 + rx.port)&0x1)==0x1;
-        //tx_5v_status = rx.tx_5v_status|rx.tx_5v_status_pre;
-        tx_5v_status = pow_state();
-        rx.tx_5v_status_pre = rx.tx_5v_status;
-    } else {
-        rx.tx_5v_status = 1;
-        tx_5v_status = 1;
-    }
-
-	switch(rx.state){
-	case HDMIRX_HWSTATE_INIT:
-	    audio_status_init();
-	    Signal_status_init();
-	    if (hw_cfg_mode == 0) {
-	        hdmirx_hw_config();
-	        hdmi_rx_ctrl_edid_update();
-	    }
-		rx.state = HDMIRX_HWSTATE_5V_LOW;
-		hdmirx_print("[HDMIRX State] init->5v low\n");
-		printk("Hdmirx driver version: %s\n", HDMIRX_VER);
-		break;
-	case HDMIRX_HWSTATE_5V_LOW:
-		if(tx_5v_status){
-			rx.state = HDMIRX_HWSTATE_5V_HIGH;
-			sw_pwr_cnt = 0;
-			hdmirx_print("[HDMIRX State] 5v low->5v high\n");
-		} else {
-		    if ((hdmirx_rd_dwc(RA_HDMI_PLL_LCK_STS) & 0x01)
-		            && (hdmirx_get_tmds_clock() > 0)) {
-		        if (sw_pwr_cnt++ > HDMIRX_SW_PWR_CNT) {
-		            rx.state = HDMIRX_HWSTATE_5V_HIGH;
-		            sw_pwr_cnt = 0;
-		            sw_5v_sts = true;
-		            hdmirx_print("[HDMIRX State]...pll lock, 5v low->5v high...\n");
-		        }
-		    } else {
-		        sw_pwr_cnt = 0;
-		        sw_5v_sts = false;
-			rx.no_signal = true;
-		    }
-		}
-		break;
-
-	case HDMIRX_HWSTATE_5V_HIGH:
-		if(!tx_5v_status && !sw_5v_sts){
-			rx.no_signal = true;
-			rx.state = HDMIRX_HWSTATE_INIT;
-			hdmirx_print("[HDMIRX State] 5v high->init\n");
-		} else {
-			hdmirx_set_hpd(rx.port, 1);
-			rx.state = HDMIRX_HWSTATE_HPD_READY;
-			rx.no_signal = false;
-			cfg_wait_cnt = 0;
-			hdmirx_print("[HDMIRX State] 5v high->hpd ready\n");
-		}
-		break;
-
-	case HDMIRX_HWSTATE_HPD_READY:
-		if(!tx_5v_status && !sw_5v_sts){
-			rx.no_signal = true;
-			rx.state = HDMIRX_HWSTATE_INIT;
-			hdmirx_set_hpd(rx.port, 0);
-			hdmirx_print("[HDMIRX State] hpd ready ->init\n");
-		} else {
-		    if (hw_cfg_mode == 1) {
-		        if (cfg_wait_cnt++ > cfg_wait_max) {
-		            cfg_wait_cnt = 0;
-		            hdmirx_hw_config();
-		            hdmi_rx_ctrl_edid_update();
-		            rx.state = HDMIRX_HWSTATE_SIG_UNSTABLE;
-		            sig_unstable_count = 0;
-		            hdmirx_print("[HDMIRX State] wait hpd ready->unstable\n");
-		        }
-		    } else {
-                rx.state = HDMIRX_HWSTATE_SIG_UNSTABLE;
-                sig_unstable_count = 0;
-                hdmirx_print("[HDMIRX State] hpd ready->unstable\n");
-	        }
-		}
-		break;
-
-	case HDMIRX_HWSTATE_SIG_UNSTABLE:
-		if(!tx_5v_status && !sw_5v_sts){
-			rx.no_signal = true;
-			rx.state = HDMIRX_HWSTATE_INIT;
-			sig_unstable_count = 0;
-			sig_lock_count = 0;
-			hdmirx_set_hpd(rx.port, 0);
-			hdmirx_print("[HDMIRX State] unstable->init\n");
-		} else {
-		    if ((hdmirx_rd_dwc(RA_HDMI_PLL_LCK_STS) & 0x01)
-			     && (hdmirx_get_tmds_clock() > 0)){
-				if(sig_lock_count++ > sig_lock_th){
-				rx.no_signal = false;
-				rx.video_wait_time = 0;
-                memset(&rx.vendor_specific_info, 0, sizeof(struct vendor_specific_info_s));
-				hdmirx_get_video_info(&rx.ctrl, &rx.cur_video_params);
-				rx.state = HDMIRX_HWSTATE_SIG_STABLE;
-				sig_unstable_count = 0;
-				sig_lock_count = 0;
-				hdmirx_print("[HDMIRX State] unstable->stable\n");
-				}
-		    } else {
-		        if(pll_unlock_count++ > pll_unlock_th)
-		        {
-                    pll_unlock_count = 0;
-                    hdmirx_print("[HDMIRX State] PLL unlock: HDMIRX reset!\n");
-                    hdmirx_hw_reset();
-		        }
-                sig_lock_count = 0;
-		        if(sig_unstable_count++ > unstable2_th) {
-		            sig_unstable_count = unstable2_th;
-		            rx.no_signal = true;
-                    sw_5v_sts = false;
-		        }
-		    }
-		}
-	break;
-
-	case HDMIRX_HWSTATE_SIG_STABLE:
-		if(!tx_5v_status && !sw_5v_sts){
-			rx.no_signal = true;
-			rx.state = HDMIRX_HWSTATE_INIT;
-			sig_stable2_ready_cnt = 0;
-			unstable_reset_cnt = 0;
-			reset_bits &= ~(1<<0);
-			hdmirx_set_hpd(rx.port, 0);
-			hdmirx_print("[HDMIRX State] stable->init\n");
-		} else if ((hdmirx_rd_dwc (RA_HDMI_PLL_LCK_STS) & 0x01) &&
-		            (hdmirx_get_tmds_clock() > 0)) {
-		    memcpy(&rx.pre_video_params, &rx.cur_video_params, sizeof(struct hdmi_rx_ctrl_video));
-		    hdmirx_get_video_info(&rx.ctrl, &rx.cur_video_params);
-		    if(is_timing_stable(&rx.pre_video_params, &rx.cur_video_params) || (force_ready)) {
-		        if (sig_stable2_ready_cnt++ > stable2_ready_th) {
-		            sig_stable2_ready_cnt = 0;
-		            rx.ctrl.tmds_clk2 = hdmirx_get_tmds_clock();
-		            rx.change = 0;
-		            rx.state = HDMIRX_HWSTATE_SIG_READY;
-		            rx.no_signal = false;
-		            unstable_reset_cnt = 0;
-		            reset_bits &= ~(1<<0);
-		            get_timing_fmt(&rx.pre_video_params);
-		            memcpy(&rx.video_params, &rx.pre_video_params, sizeof(struct hdmi_rx_ctrl_video));
-		            memset(&rx.aud_info, 0, sizeof(struct aud_info_s));
-		            hdmirx_config_video(&rx.video_params);
-		            hdmirx_print("[HDMIRX State] stable->ready\n");
-		            dump_state(0x1);
-		        }
-		    } else {
-		        sig_stable2_ready_cnt = 0;
-		    }
-		    if (unstable_reset_cnt++ > (stable2_ready_th<<2)) {
-		        unstable_reset_cnt = 0;
-                hdmirx_phy_reset(1);
-                mdelay(1);
-                hdmirx_phy_reset(0);
-                hdmirx_print("[HDMIRX State] Timing is unstable: PHY reset!\n");
-		    }
-		} else {
-			rx.state = HDMIRX_HWSTATE_SIG_UNSTABLE;
-			sig_stable2_ready_cnt = 0;
-			hdmirx_print("[HDMIRX State] stable->unstable\n");
-		}
-		break;
-	case HDMIRX_HWSTATE_SIG_READY:
-		if(!tx_5v_status && !sw_5v_sts){
-			rx.no_signal = true;
-			rx.state = HDMIRX_HWSTATE_INIT;
-			sig_unlock_count = 0;
-			sig_unready_cnt = 0;
-			audio_status_init();
-			hdmirx_set_hpd(rx.port, 0);
-			hdmirx_print("[HDMIRX State] ready->init\n");
-		} else if (((hdmirx_rd_dwc (RA_HDMI_PLL_LCK_STS) & 0x01) == 0)
-			         ||(hdmirx_get_tmds_clock() == 0)){
-
-		    sig_unlock_count++;
-		    if (sig_unlock_count >= unlock2_stable_th) {
-                audio_status_init();
-		        if (switch_mode & 0x1) {
-		            if (reset_mode == 1)
-		                hdmirx_hw_reset();
-		            else {
-		                hdmirx_hw_config();
-		                hdmi_rx_ctrl_edid_update();
-		            }
-		        }
-		        rx.state = HDMIRX_HWSTATE_SIG_UNSTABLE;
-		        sig_unlock_count = 0;
-		        sig_unready_cnt = 0;
-		        printk("[hdmi] pll unlock !! TMDS clock = %d, Pixel clock = %d\n", hdmirx_get_tmds_clock(), hdmirx_get_pixel_clock());
-		        hdmirx_print("[HDMIRX State] pll unlock ready->unstable\n");
-		    }
-		} else {
-		    sig_unlock_count = 0;
-		    hdmirx_get_video_info(&rx.ctrl, &rx.video_params);
-		    /* video info change */
-		    if (!is_timing_stable(&rx.pre_video_params, &rx.video_params) ||
-		        is_timing_change(&rx.pre_video_params, &rx.video_params)  ||
-		        is_frame_rate_change(&rx.pre_video_params, &rx.video_params)) {
-		        if (sig_unready_cnt++ > unready2_stable_th) {
-		            audio_status_init();
-		            sig_unlock_count = 0;
-		            sig_unready_cnt = 0;
-		            if (switch_mode & 0x1) {
-	                    if (reset_mode == 1)
-	                        hdmirx_hw_reset();
-	                    else {
-	                        hdmirx_hw_config();
-	                        hdmi_rx_ctrl_edid_update();
-	                        }
-		            }
-		            rx.state = HDMIRX_HWSTATE_SIG_STABLE;
-		            memset(&rx.vendor_specific_info, 0, sizeof(struct vendor_specific_info_s));
-		            hdmirx_print("[HDMIRX State] ready->stable, mode change\n");
-		            break;
-		        }
-		    } else {
-		        sig_unready_cnt = 0;
-		    }
-
-			//if (t3d_flash_flag != 1)
-			//    hdmirx_get_video_info(&rx.ctrl, &rx.video_params);
-
-			if (audio_enable) {
-			    pre_sample_rate = rx.aud_info.real_sample_rate;
-				hdmirx_read_audio_info(&rx.aud_info);
-				if (force_audio_sample_rate == 0)
-				    rx.aud_info.real_sample_rate = get_real_sample_rate();
-				else
-				    rx.aud_info.real_sample_rate = force_audio_sample_rate;
-				if((rx.aud_info.real_sample_rate<=31000)&&(rx.aud_info.real_sample_rate>=193000)
-				   && (abs((signed int)rx.aud_info.real_sample_rate-(signed int)pre_sample_rate)>sample_rate_change_th)
-                   ) {
-				    if(hdmirx_log_flag&0x200) {
-				        dump_audio_info(1);
-				    }
-				}
-
-				if(is_sample_rate_change(pre_sample_rate, rx.aud_info.real_sample_rate)){
-					//set_hdmi_audio_source_gate(0);
-				    if(hdmirx_log_flag&0x200) {
-				        printk("[hdmirx-audio]:sample_rate_chg,pre:%d,cur:%d\n", pre_sample_rate, rx.aud_info.real_sample_rate);
-				        dump_audio_info(1);
-				    }
-				    rx.audio_sample_rate_stable_count = 0;
-				} else {
-					if(rx.audio_sample_rate_stable_count < audio_sample_rate_stable_count_th){
-					    if(hdmirx_log_flag&0x200) {
-					        printk("[hdmirx-audio]:sample_rate_stable_count:%d\n", rx.audio_sample_rate_stable_count);
-					    }
-						rx.audio_sample_rate_stable_count++;
-						if(rx.audio_sample_rate_stable_count==audio_sample_rate_stable_count_th){
-							//mailbox_send_audiodsp(1, M2B_IRQ0_DSP_AUDIO_EFFECT, DSP_CMD_SET_HDMI_SR, (char *)&rx.aud_info.real_sample_rate,sizeof(rx.aud_info.real_sample_rate));
-							dump_state(0x2);
-							printk("[hdmirx-audio]:----audio stable\n");
-							hdmirx_config_audio();
-							hdmirx_audio_fifo_rst();
-
-							audio_sample_rate = rx.aud_info.real_sample_rate;
-							audio_coding_type = rx.aud_info.coding_type;
-							audio_channel_count = rx.aud_info.channel_count;
-							rx.audio_wait_time = audio_stable_time;
-						}
-					}
-				}
-
-				if(rx.audio_wait_time > 0 ){
-				    rx.audio_wait_time -= HW_MONITOR_TIME_UNIT;
-				    if(rx.audio_wait_time <= 0){
-				        //set_hdmi_audio_source_gate(1);
-				    }
-				}
-			}
-		}
-		if (rx.change > 0) {
-		    ////if (rx.change == unready2_stable_th)
-		    //    //printk("[hdmirx]:----skipe frame:%d\n", rx.change);
-		    rx.change--;
-		}
-		//for debug
-		//if ((hdmirx_rd_dwc (RA_HDMI_PLL_LCK_STS) & 0x01) == 0){
-		//	hdmirx_print("[HDMIRX State] ready->unstable, pll unlock\n");
-		//}
-
-		break;
-
-	default:
-		if(!tx_5v_status){
-			rx.no_signal = true;
-			rx.state = HDMIRX_HWSTATE_INIT;
-			hdmirx_set_hpd(rx.port, 0);
-		}
-		break;
-	}
-
-	if(force_state&0x10){
-		rx.state = force_state&0xf;
-	    if((force_state&0x20)==0){
-	        force_state = 0;
-	     }
-    }
-}
-/*
-* EDID & hdcp
-*/
-struct hdmi_rx_ctrl_hdcp init_hdcp_data;
-#define MAX_KEY_BUF_SIZE 512
-
-static char key_buf[MAX_KEY_BUF_SIZE];
-static int key_size = 0;
-
-#define MAX_EDID_BUF_SIZE 1024
-static char edid_buf[MAX_EDID_BUF_SIZE];
-static int edid_size = 0;
-
-#if defined(CONFIG_MACH_MESON6TV_H20)
-static unsigned char amlogic_hdmirx_edid_port1[] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x4d ,0x77 ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x53,
-0x6b ,0x79 ,0x77 ,0x6f ,0x72 ,0x74 ,0x68 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x3e,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x10 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x91
-};
-
-static unsigned char amlogic_hdmirx_edid_port2[] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x4d ,0x77 ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x53,
-0x6b ,0x79 ,0x77 ,0x6f ,0x72 ,0x74 ,0x68 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x3e,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x20 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x81
-};
-
-static unsigned char amlogic_hdmirx_edid_port3[] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x4d ,0x77 ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x53,
-0x6b ,0x79 ,0x77 ,0x6f ,0x72 ,0x74 ,0x68 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x3e,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x30 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x71
-};
-#else
-static unsigned char amlogic_hdmirx_edid_port1[] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x05 ,0xac ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x41,
-0x4d ,0x4c ,0x4f ,0x47 ,0x49 ,0x43 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x3e,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x10 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x91
-};
-
-static unsigned char amlogic_hdmirx_edid_port2[] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x05 ,0xac ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x41,
-0x4d ,0x4c ,0x4f ,0x47 ,0x49 ,0x43 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x3e,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x20 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x81
-};
-
-static unsigned char amlogic_hdmirx_edid_port3[] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x05 ,0xac ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x41,
-0x4d ,0x4c ,0x4f ,0x47 ,0x49 ,0x43 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x3e,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x30 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x71
-};
-#endif
-
-static unsigned char hdmirx_8bit_3d_edid_port1[] =
-{
-//8 bit only with 3D
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x4d ,0x77 ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x53,
-0x6b ,0x79 ,0x77 ,0x6f ,0x72 ,0x74 ,0x68 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0xdc,
-0x02 ,0x03 ,0x38 ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x23 ,0x09 ,0x07 ,0x01 ,0x83 ,0x01 ,0x00 ,0x00,
-0x74 ,0x03 ,0x0c ,0x00 ,0x10 ,0x00 ,0x88 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40 ,0x00 ,0x7f ,0x20,
-0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72 ,0x38 ,0x2d ,0x40,
-0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0xbc ,0x52 ,0xd0,
-0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x80 ,0xd0,
-0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x9e ,0x00 ,0x00,
-0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x8e
-};
-
-
-static unsigned char hdmirx_12bit_3d_edid_port1 [] =
-{
-0x00 ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x4d ,0xd9 ,0x02 ,0x2c ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x15 ,0x01 ,0x03 ,0x80 ,0x85 ,0x4b ,0x78 ,0x0a ,0x0d ,0xc9 ,0xa0 ,0x57 ,0x47 ,0x98 ,0x27,
-0x12 ,0x48 ,0x4c ,0x21 ,0x08 ,0x00 ,0x81 ,0x80 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01,
-0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x01 ,0x02 ,0x3a ,0x80 ,0x18 ,0x71 ,0x38 ,0x2d ,0x40 ,0x58 ,0x2c,
-0x45 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00 ,0x72 ,0x51 ,0xd0 ,0x1e ,0x20,
-0x6e ,0x28 ,0x55 ,0x00 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x00 ,0x00 ,0x00 ,0xfc ,0x00 ,0x53,
-0x4f ,0x4e ,0x59 ,0x20 ,0x54 ,0x56 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x00 ,0x00 ,0x00 ,0xfd,
-0x00 ,0x30 ,0x3e ,0x0e ,0x46 ,0x0f ,0x00 ,0x0a ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x01 ,0x1c,
-0x02 ,0x03 ,0x3b ,0xf0 ,0x53 ,0x1f ,0x10 ,0x14 ,0x05 ,0x13 ,0x04 ,0x20 ,0x22 ,0x3c ,0x3e ,0x12,
-0x16 ,0x03 ,0x07 ,0x11 ,0x15 ,0x02 ,0x06 ,0x01 ,0x26 ,0x09 ,0x07 ,0x07 ,0x15 ,0x07 ,0x50 ,0x83,
-0x01 ,0x00 ,0x00 ,0x74 ,0x03 ,0x0c ,0x00 ,0x20 ,0x00 ,0xb8 ,0x2d ,0x2f ,0xd0 ,0x0a ,0x01 ,0x40,
-0x00 ,0x7f ,0x20 ,0x30 ,0x70 ,0x80 ,0x90 ,0x76 ,0xe2 ,0x00 ,0xfb ,0x02 ,0x3a ,0x80 ,0xd0 ,0x72,
-0x38 ,0x2d ,0x40 ,0x10 ,0x2c ,0x45 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01 ,0x1d ,0x00,
-0xbc ,0x52 ,0xd0 ,0x1e ,0x20 ,0xb8 ,0x28 ,0x55 ,0x40 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00 ,0x1e ,0x01,
-0x1d ,0x80 ,0xd0 ,0x72 ,0x1c ,0x16 ,0x20 ,0x10 ,0x2c ,0x25 ,0x80 ,0x30 ,0xeb ,0x52 ,0x00 ,0x00,
-0x9e ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xd9,
-};
-
-int hdmi_rx_ctrl_edid_update(void)
-{
-	int i, ram_addr, byte_num;
-	unsigned int value;
-	unsigned char check_sum;
-	//printk("HDMI_OTHER_CTRL2=%x\n", hdmi_rd_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL2));
-
-	if(((edid_mode&0x100)==0) && edid_size>4 && edid_buf[0]=='E' && edid_buf[1]=='D' && edid_buf[2]=='I' && edid_buf[3]=='D'){
-		hdmirx_print("edid: use custom edid\n");
-		check_sum = 0;
-		for (i = 0; i < (edid_size-4); i++)
-		{
-			value = edid_buf[i+4];
-			if(((i+1)&0x7f)!=0){
-				check_sum += value;
-				check_sum &= 0xff;
-			}
-			else{
-				if(value != ((0x100-check_sum)&0xff)){
-					hdmirx_print("HDMIRX: origin edid[%d] checksum %x is incorrect, change to %x\n",
-					i, value, (0x100-check_sum)&0xff);
-				}
-				value = (0x100-check_sum)&0xff;
-				check_sum = 0;
-		 	}
-		    ram_addr = HDMIRX_TOP_EDID_OFFSET+i;
-		    hdmirx_wr_top(ram_addr, value);
-		}
-	}
-	else{
-		if((edid_mode&0xf) == 0){
-			unsigned char * p_edid_array;
-			byte_num = sizeof(amlogic_hdmirx_edid_port1)/sizeof(unsigned char);
-			p_edid_array =  amlogic_hdmirx_edid_port1;
-			if(rx.port == 1){
-				byte_num = sizeof(amlogic_hdmirx_edid_port1)/sizeof(unsigned char);
-				p_edid_array =  amlogic_hdmirx_edid_port1;
-			} else if (rx.port == 2) {
-				byte_num = sizeof(amlogic_hdmirx_edid_port2)/sizeof(unsigned char);
-				p_edid_array =  amlogic_hdmirx_edid_port2;
-			} else if (rx.port == 3) {
-				byte_num = sizeof(amlogic_hdmirx_edid_port3)/sizeof(unsigned char);
-				p_edid_array =  amlogic_hdmirx_edid_port3;
-			}
-
-			/*recalculate check sum*/
-			for(check_sum = 0,i=0;i<127;i++){
-				check_sum += p_edid_array[i];
-				check_sum &= 0xff;
-			}
-			p_edid_array[127] = (0x100-check_sum)&0xff;
-
-			for(check_sum = 0,i=128;i<255;i++){
-				check_sum += p_edid_array[i];
-				check_sum &= 0xff;
-			}
-			p_edid_array[255] = (0x100-check_sum)&0xff;
-			/**/
-
-			for (i = 0; i < byte_num; i++){
-				value = p_edid_array[i];
-				ram_addr = HDMIRX_TOP_EDID_OFFSET+i;
-				hdmirx_wr_top(ram_addr, value);
-			}
-		}
-		else if((edid_mode&0xf) == 1){
-			byte_num = sizeof(hdmirx_12bit_3d_edid_port1)/sizeof(unsigned char);
-
-			for (i = 0; i < byte_num; i++){
-				value = hdmirx_12bit_3d_edid_port1[i];
-				ram_addr = HDMIRX_TOP_EDID_OFFSET+i;
-				hdmirx_wr_top(ram_addr, value);
-			}
-		}
-	}
-	return 0;
-}
-
-static void set_hdcp(struct hdmi_rx_ctrl_hdcp *hdcp, const unsigned char* b_key)
-{
-    int i,j;
-    memset(&init_hdcp_data, 0, sizeof(struct hdmi_rx_ctrl_hdcp));
-    for(i=0,j=0; i<80; i+=2,j+=7){
-        hdcp->keys[i+1] = b_key[j]|(b_key[j+1]<<8)|(b_key[j+2]<<16)|(b_key[j+3]<<24);
-        hdcp->keys[i+0] = b_key[j+4]|(b_key[j+5]<<8)|(b_key[j+6]<<16);
-    }
-    hdcp->bksv[1] = b_key[j]|(b_key[j+1]<<8)|(b_key[j+2]<<16)|(b_key[j+3]<<24);
-    hdcp->bksv[0] = b_key[j+4];
-
-}
-
-int hdmirx_read_key_buf(char* buf, int max_size)
-{
-	if(key_size > max_size){
-		pr_err("Error: %s, key size %d is larger than the buf size of %d\n", __func__,  key_size, max_size);
-		return 0;
-	}
-	memcpy(buf, key_buf, key_size);
-	pr_info("HDMIRX: read key buf\n");
-	return key_size;
-}
-
-void hdmirx_fill_key_buf(const char* buf, int size)
-{
-	if(size > MAX_KEY_BUF_SIZE){
-		pr_err("Error: %s, key size %d is larger than the max size of %d\n", __func__,  size, MAX_KEY_BUF_SIZE);
-		return;
-	}
-	if(buf[0]=='k' && buf[1]=='e' && buf[2]=='y'){
-	    set_hdcp(&init_hdcp_data, buf+3);
-	}
-	else{
-		memcpy(key_buf, buf, size);
-		key_size = size;
-		pr_info("HDMIRX: fill key buf, size %d\n", size);
-	}
-}
-
-int hdmirx_read_edid_buf(char* buf, int max_size)
-{
-	if(edid_size > max_size){
-		pr_err("Error: %s, edid size %d is larger than the buf size of %d\n", __func__,  edid_size, max_size);
-		return 0;
-	}
-	memcpy(buf, edid_buf, edid_size);
-	pr_info("HDMIRX: read edid buf\n");
-	return edid_size;
-}
-
-void hdmirx_fill_edid_buf(const char* buf, int size)
-{
-	if(size > MAX_EDID_BUF_SIZE){
-		pr_err("Error: %s, edid size %d is larger than the max size of %d\n", __func__,  size, MAX_EDID_BUF_SIZE);
-		return;
-	}
-	memcpy(edid_buf, buf, size);
-	edid_size = size;
-	pr_info("HDMIRX: fill edid buf, size %d\n", size);
-}
-
-/********************
-    debug functions
-*********************/
-int hdmirx_hw_dump_reg(unsigned char* buf, int size)
-{
-	return 0;
-}
-
-static void dump_state(unsigned char enable)
-{
-	int error = 0;
-	//int i = 0;
-	struct hdmi_rx_ctrl_video v;
-  	static struct aud_info_s a;
-	struct vendor_specific_info_s vsi;
-  	if(enable&1){
-    		hdmirx_get_video_info(&rx.ctrl, &v);
-      		printk("[HDMI info]error %d video_format %d VIC %d dvi %d interlace %d\nhtotal %d vtotal %d hactive %d vactive %d pixel_repetition %d\npixel_clk %ld deep_color %d refresh_rate %ld\n",
-        		error,
-        		v.video_format, v.video_mode, v.dvi, v.interlaced,
-        		v.htotal, v.vtotal, v.hactive, v.vactive, v.pixel_repetition,
-        		v.pixel_clk, v.deep_color_mode, v.refresh_rate);
-     		hdmirx_read_vendor_specific_info_frame(&vsi);
-      		printk("Vendor Specific Info ID=%x, hdmi_video_format=%x, 3d_struct=%x, 3d_ext=%x\n",
-       		vsi.identifier, vsi.hdmi_video_format, vsi._3d_structure, vsi._3d_ext_data);
-  	}
-  	if(enable&2){
-      		hdmirx_read_audio_info(&a);
-    		printk("AudioInfo: CT=%u CC=%u SF=%u SS=%u CA=%u",
-    			a.coding_type, a.channel_count, a.sample_frequency,
-    			a.sample_size, a.channel_allocation);
-
-      		printk("CTS=%d, N=%d, recovery clock is %d\n", a.cts, a.n, a.audio_recovery_clock);
-  	}
- 	printk("TMDS clock = %d, Pixel clock = %d\n", hdmirx_get_tmds_clock(), hdmirx_get_pixel_clock());
-
-  	printk("rx.no_signal=%d, rx.state=%d, fmt=0x%x, sw_vic:%d, sw_dvi:%d, sw_fp:%d,, sw_alternative:%d\n",
-  	        rx.no_signal, rx.state, hdmirx_hw_get_fmt(),rx.video_params.sw_vic,rx.video_params.sw_dvi,rx.video_params.sw_fp\
-  	      ,rx.video_params.sw_alternative);
-
-  	printk("HDCP debug value=0x%x\n", hdmirx_rd_dwc(RA_HDCP_DBG));
-}
-
-static void dump_audio_info(unsigned char enable)
-{
-    static struct aud_info_s a;
-
-    if(enable){
-        hdmirx_read_audio_info(&a);
-        printk("AudioInfo: CT=%u CC=%u SF=%u SS=%u CA=%u",
-                a.coding_type, a.channel_count, a.sample_frequency,
-                a.sample_size, a.channel_allocation);
-        printk("[hdmirx]CTS=%d, N=%d, recovery clock is %d\n", a.cts, a.n, a.audio_recovery_clock);
-    }
-}
-
-void dump_reg(void)
-{
-	int i = 0;
-
-    printk("\n\n*******Top registers********\n");
-    printk("[addr ]  addr + 0x0,  addr + 0x1,  addr + 0x2,  addr + 0x3\n\n");
-    for(i = 0; i <= 0x12; ){
-        printk("[0x%-3x]  0x%-8x,  0x%-8x,  0x%-8x,  0x%-8x\n",i,(unsigned int)hdmirx_rd_top(i),(unsigned int)hdmirx_rd_top(i+1),(unsigned int)hdmirx_rd_top(i+2),(unsigned int)hdmirx_rd_top(i+3));
-        i = i + 4;
-    }
-    printk("\n\n*******EDID data********\n");
-    printk("[addr ]  addr + 0x0,  addr + 0x1,  addr + 0x2,  addr + 0x3\n\n");
-    for(i = 0; i < 256; ){
-        printk("[0x%-3x]  0x%-8x,  0x%-8x,  0x%-8x,  0x%-8x\n",i,
-                (unsigned int)hdmirx_rd_top(HDMIRX_TOP_EDID_OFFSET+i),(unsigned int)hdmirx_rd_top(HDMIRX_TOP_EDID_OFFSET+i+1),
-                (unsigned int)hdmirx_rd_top(HDMIRX_TOP_EDID_OFFSET+i+2),(unsigned int)hdmirx_rd_top(HDMIRX_TOP_EDID_OFFSET+i+3));
-        i = i + 4;
-    }
-	printk("\n\n*******Controller registers********\n");
-	printk("[addr ]  addr + 0x0,  addr + 0x4,  addr + 0x8,  addr + 0xc\n\n");
-	for(i = 0; i <= 0xffc; ){
-		printk("[0x%-3x]  0x%-8x,  0x%-8x,  0x%-8x,  0x%-8x\n",i,hdmirx_rd_dwc(i),hdmirx_rd_dwc(i+4),hdmirx_rd_dwc(i+8),hdmirx_rd_dwc(i+12));
-		i = i + 16;
-	}
-	printk("\n\n*******PHY registers********\n");
-	printk("[addr ]  addr + 0x0,  addr + 0x1,  addr + 0x2,  addr + 0x3\n\n");
-	for(i = 0; i <= 0x9a; ){
-		printk("[0x%-3x]  0x%-8x,  0x%-8x,  0x%-8x,  0x%-8x\n",i,hdmirx_rd_phy(i),hdmirx_rd_phy(i+1),hdmirx_rd_phy(i+2),hdmirx_rd_phy(i+3));
-		i = i + 4;
-	}
-}
-
-
-void dump_edid_reg(void)
-{
-	int i = 0;
-	int j = 0;
-	/* 1024 = 64*16 */
-	for (i = 0; i < 16; i++) {
-		printk("[%2d] ", i);
-		for (j = 0; j < 16; j++) {
-			printk("0x%02lx, ", hdmirx_rd_top(HDMIRX_TOP_EDID_OFFSET + (i*16 + j)));
-		}
-		printk("\n");
-	}
-}
-
-
-void timer_state(void)
-{
-	switch (rx.state) {
-		case HDMIRX_HWSTATE_INIT:
-			printk("timer state: HDMIRX_HWSTATE_INIT\n");
-		break;
-		case HDMIRX_HWSTATE_5V_LOW:
-			printk("timer state: HDMIRX_HWSTATE_5V_LOW\n");
-		break;
-		case HDMIRX_HWSTATE_5V_HIGH:
-			printk("timer state: HDMIRX_HWSTATE_5V_HIGH\n");
-		break;
-		case HDMIRX_HWSTATE_HPD_READY:
-			printk("timer state: HDMIRX_HWSTATE_HPD_READY\n");
-		break;
-		case HDMIRX_HWSTATE_SIG_UNSTABLE:
-			printk("timer state: HDMIRX_HWSTATE_SIG_UNSTABLE\n");
-		break;
-		case HDMIRX_HWSTATE_SIG_STABLE:
-			printk("timer state: HDMIRX_HWSTATE_SIG_STABLE\n");
-		break;
-		case HDMIRX_HWSTATE_SIG_READY:
-			printk("timer state: HDMIRX_HWSTATE_SIG_READY\n");
-		break;
-	}
-}
-
-void hdmirx_hw_config_ori(int rx_port_sel);
-
-int hdmirx_debug(const char* buf, int size)
-{
-	char tmpbuf[128];
-	int i = 0;
-	unsigned int adr;
-	unsigned int value = 0;
-
-	while((buf[i]) && (buf[i] != ',') && (buf[i] != ' ')) {
-		tmpbuf[i]=buf[i];
-		i++;
-	}
-	tmpbuf[i] = 0;
-	if(strncmp(tmpbuf, "hpd", 3)==0){
-        hdmirx_set_hpd(rx.port, tmpbuf[3]=='0'?0:1);
-  }
-	else if(strncmp(tmpbuf, "set_color_depth", 15) == 0) {
-		//hdmirx_config_color_depth(tmpbuf[15]-'0');
-		//printk("set color depth %c\n", tmpbuf[15]);
-	} else if (strncmp(tmpbuf, "reset", 5) == 0) {
-		if(tmpbuf[5] == '0') {
-		    printk(" hdmirx total reset \n");
-		    hdmirx_hw_config();
-		    hdmi_rx_ctrl_edid_update();
-		    hdmirx_config_video(&rx.video_params);
-			hdmirx_config_audio();
-		}
-		else if(tmpbuf[5] == '1') {
-		    printk(" hdmirx phy init \n");
-		    phy_init(rx.port, 0);
-		}
-		else if(tmpbuf[5] == '2') {
-		}
-		else if(tmpbuf[5] == '3') {
-		    hdmirx_hw_config_ori(rx.port);
-
-		}
-	} else if (strncmp(tmpbuf, "set_state", 9) == 0) {
-		//rx.state = simple_strtoul(tmpbuf+9, NULL, 10);
-		//printk("set state %d\n", rx.state);
-	} else if (strncmp(tmpbuf, "test", 4) == 0) {
-	       // printk("hdcp ctrl %x\n", hdmirx_rd_dwc(0xc0));
-            //test();
-		//test_flag = simple_strtoul(tmpbuf+4, NULL, 10);;
-		//printk("test %d\n", test_flag);
-	} else if (strncmp(tmpbuf, "state", 5) == 0) {
-		    dump_state(0xff);
-	} else if (strncmp(tmpbuf, "pause", 5) == 0) {
-		sm_pause = simple_strtoul(tmpbuf+5, NULL, 10);
-		printk("%s the state machine\n", sm_pause?"pause":"enable");
-	} else if (strncmp(tmpbuf, "reg", 3) == 0) {
-		dump_reg();
-	} else if (strncmp(tmpbuf, "edid", 4) == 0) {
-		dump_edid_reg();
-	} else if (strncmp(tmpbuf, "timer_state", 11) == 0) {
-		timer_state();
-	} else if (strncmp(tmpbuf, "log", 3) == 0) {
-
-	}  else if (strncmp(tmpbuf, "pinmux_on", strlen("pinmux_on")) == 0) {
-	     hdmirx_set_pinmux();
-		 printk("[hdmi]%s:hdmi pinmux is on \n",__func__);
-	} else if (strncmp(tmpbuf, "clock", 5) == 0) {
-		value = simple_strtoul(tmpbuf + 5, NULL, 10);
-		printk("clock[%d] = %d\n", value, hdmirx_get_clock(value));
-	} else if (strncmp(tmpbuf, "sample_rate", 11) == 0) {
-			//nothing
-	} else if (strncmp(tmpbuf, "prbs", 4) == 0) {
-	  //turn_on_prbs_mode(simple_strtoul(tmpbuf+4, NULL, 10));
-	} else if (tmpbuf[0] == 'w') {
-		adr = simple_strtoul(tmpbuf + 2, NULL, 16);
-		value = simple_strtoul(buf + i + 1, NULL, 16);
-		if(buf[1] == 'h') {
-    	adr = simple_strtoul(tmpbuf + 3, NULL, 16);
-			if(buf[2] == 't') {
-		    		hdmirx_wr_top(adr, value);
-				pr_info("write %x to hdmirx TOP reg[%x]\n",value,adr);
-			} else if (buf[2] == 'd') {
-		    		hdmirx_wr_dwc(adr, value);
-				pr_info("write %x to hdmirx DWC reg[%x]\n",value,adr);
-		    	} else if(buf[2] == 'p') {
-		    		hdmirx_wr_phy(adr, value);
-				pr_info("write %x to hdmirx PHY reg[%x]\n",value,adr);
-		    	}
-		} else if (buf[1] == 'c') {
-			WRITE_MPEG_REG(adr, value);
-			pr_info("write %x to CBUS reg[%x]\n",value,adr);
-		} else if (buf[1] == 'p') {
-			WRITE_APB_REG(adr, value);
-			pr_info("write %x to APB reg[%x]\n",value,adr);
-		}else if (buf[1] == 'l') {
-			WRITE_MPEG_REG(MDB_CTRL, 2);
-			WRITE_MPEG_REG(MDB_ADDR_REG, adr);
-			WRITE_MPEG_REG(MDB_DATA_REG, value);
-			pr_info("write %x to LMEM[%x]\n",value,adr);
-		}else if(buf[1] == 'r') {
-			WRITE_MPEG_REG(MDB_CTRL, 1);
-			WRITE_MPEG_REG(MDB_ADDR_REG, adr);
-			WRITE_MPEG_REG(MDB_DATA_REG, value);
-			pr_info("write %x to amrisc reg [%x]\n",value,adr);
-		}
-	} else if (tmpbuf[0] == 'r') {
-		adr = simple_strtoul(tmpbuf + 2, NULL, 16);
-		if(buf[1] == 'h') {
-		  adr = simple_strtoul(tmpbuf + 3, NULL, 16);
-			if(buf[2] == 't') {
-				value = hdmirx_rd_top(adr);
-				pr_info("hdmirx TOP reg[%x]=%x\n",adr, value);
-			} else if (buf[2] == 'd') {
-			    	value = hdmirx_rd_dwc(adr);
-				pr_info("hdmirx DWC reg[%x]=%x\n",adr, value);
-			} else if(buf[2] == 'p') {
-			    	value = hdmirx_rd_phy(adr);
-				pr_info("hdmirx PHY reg[%x]=%x\n",adr, value);
-			    }
-		}
-		else if (buf[1] == 'c') {
-		    value = READ_MPEG_REG(adr);
-		    pr_info("CBUS reg[%x]=%x\n", adr, value);
-		} else if (buf[1] == 'p') {
-		    value = READ_APB_REG(adr);
-		    pr_info("APB reg[%x]=%x\n", adr, value);
-		} else if (buf[1] == 'l') {
-		    WRITE_MPEG_REG(MDB_CTRL, 2);
-		    WRITE_MPEG_REG(MDB_ADDR_REG, adr);
-		    value = READ_MPEG_REG(MDB_DATA_REG);
-		    pr_info("LMEM[%x]=%x\n", adr, value);
-		} else if (buf[1]=='r') {
-		    WRITE_MPEG_REG(MDB_CTRL, 1);
-		    WRITE_MPEG_REG(MDB_ADDR_REG, adr);
-		    value = READ_MPEG_REG(MDB_DATA_REG);
-		    pr_info("amrisc reg[%x]=%x\n", adr, value);
-		}
-	    } else if (tmpbuf[0] == 'v'){
-		printk("------------------\n");
-		printk("Hdmirx driver version: %s\n", HDMIRX_VER);
-		printk("------------------\n");
-	    }
-	return 0;
-}
-
-void to_init_state(void)
-{
-
-    if(sm_pause){
-        return;
-    }
-
-    if (sm_init_en) {
-        //rx.state = HDMIRX_HWSTATE_INIT;
-        audio_status_init();
-    }
-}
-
-#if 0
-void hdmirx_hw_init2(void)
-{
-  if(sm_pause){
-    return;
-  }
-
-    memset(&rx, 0, sizeof(struct rx));
-    memset(&rx.pre_video_params, 0, sizeof(struct hdmi_rx_ctrl_video));
-    memcpy(&rx.hdcp, &init_hdcp_data, sizeof(struct hdmi_rx_ctrl_hdcp));
-
-    rx.phy.cfg_clk = cfg_clk;
-    rx.phy.lock_thres = lock_thres;
-    rx.phy.fast_switching = fast_switching;
-    rx.phy.fsm_enhancement = fsm_enhancement;
-    rx.phy.port_select_ovr_en = port_select_ovr_en;
-    rx.phy.phy_cmu_config_force_val = phy_cmu_config_force_val;
-    rx.phy.phy_system_config_force_val = phy_system_config_force_val;
-    rx.ctrl.md_clk = 24000;
-    rx.ctrl.tmds_clk = 0;
-    rx.ctrl.tmds_clk2 = 0;
-    rx.ctrl.acr_mode = acr_mode;
-
-    rx.port = local_port;
-
-    hdmirx_set_pinmux();
-    hdmirx_set_hpd(rx.port, 0);
-
-    hdmirx_print("%s %d\n", __func__, rx.port);
-
-}
-#endif
-
-/***********************
-    hdmirx_hw_init
-    hdmirx_hw_uninit
-    hdmirx_hw_enable
-    hdmirx_hw_disable
-    hdmirx_irq_init
-*************************/
-void hdmirx_hw_init(tvin_port_t port)
-{
-  if(sm_pause){
-    return;
-  }
-
-    memset(&rx, 0, sizeof(struct rx));
-    memset(rx.pow5v_state, 0, sizeof(rx.pow5v_state));
-    memset(&rx.pre_video_params, 0, sizeof(struct hdmi_rx_ctrl_video));
-    memcpy(&rx.hdcp, &init_hdcp_data, sizeof(struct hdmi_rx_ctrl_hdcp));
-
-    rx.phy.cfg_clk = cfg_clk;
-    rx.phy.lock_thres = lock_thres;
-    rx.phy.fast_switching = fast_switching;
-    rx.phy.fsm_enhancement = fsm_enhancement;
-    rx.phy.port_select_ovr_en = port_select_ovr_en;
-    rx.phy.phy_cmu_config_force_val = phy_cmu_config_force_val;
-    rx.phy.phy_system_config_force_val = phy_system_config_force_val;
-    rx.ctrl.md_clk = 24000;
-    rx.ctrl.tmds_clk = 0;
-    rx.ctrl.tmds_clk2 = 0;
-    rx.ctrl.acr_mode = acr_mode;
-
-    rx.port = (port_map>>((port - TVIN_PORT_HDMI0)<<2))&0xf;
-    local_port = rx.port;
-    hdmirx_set_pinmux();
-    hdmirx_set_hpd(rx.port, 0);
-
-    hdmirx_print("%s %d\n", __func__, rx.port);
-
-}
-
-
-void hdmirx_hw_uninit(void)
-{
-    if(sm_pause){
-        return;
-    }
-
-    /* set all hpd low  */
-    WRITE_CBUS_REG(PREG_PAD_GPIO5_O, READ_CBUS_REG(PREG_PAD_GPIO5_O) |
-              ((1<<1)|(1<<5)|(1<<9)|(1<<13)));
-
-    hdmirx_wr_top(HDMIRX_TOP_INTR_MASKN, 0);
-
-    hdmirx_interrupts_cfg(false);
-
-    audio_status_init();
-
-    rx.ctrl.status = 0;
-    rx.ctrl.tmds_clk = 0;
-    //ctx->bsp_reset(true);
-
-    hdmirx_phy_reset(true);
-    hdmirx_phy_pddq(1);
-}
-
-void hdmirx_hw_enable(void)
-{
-}
-
-void hdmirx_hw_disable(unsigned char flag)
-{
-}
-
-void hdmirx_default_hpd(bool high)
-{
-    WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0 ) &
-                (~((1<<26)|(1<<22)|(1<<18)|(1<<14))));
-
-    WRITE_CBUS_REG(PREG_PAD_GPIO5_EN_N, READ_CBUS_REG(PREG_PAD_GPIO5_EN_N) &
-                (~((1<<1)|(1<<5)|(1<<9)|(1<<13))));
-
-    if (high)
-        WRITE_CBUS_REG(PREG_PAD_GPIO5_O, READ_CBUS_REG(PREG_PAD_GPIO5_O) |
-                ((1<<1)|(1<<5)|(1<<9)|(1<<13)));
-    else
-        WRITE_CBUS_REG(PREG_PAD_GPIO5_O, READ_CBUS_REG(PREG_PAD_GPIO5_O) &
-                (~((1<<1)|(1<<5)|(1<<9)|(1<<13))));
-}
-
-void hdmirx_irq_init(void)
-{
-    if(request_irq(AM_IRQ1(HDMIRX_IRQ), &irq_handler, IRQF_SHARED, "hdmirx", (void *)&rx)){
-    	hdmirx_print(__func__, "RX IRQ request");
-    }
-}
-
-MODULE_PARM_DESC(port_map, "\n port_map \n");
-module_param(port_map, int, 0664);
-
-MODULE_PARM_DESC(cfg_clk, "\n cfg_clk \n");
-module_param(cfg_clk, int, 0664);
-
-MODULE_PARM_DESC(lock_thres, "\n lock_thres \n");
-module_param(lock_thres, int, 0664);
-
-MODULE_PARM_DESC(fast_switching, "\n fast_switching \n");
-module_param(fast_switching, int, 0664);
-
-MODULE_PARM_DESC(fsm_enhancement, "\n fsm_enhancement \n");
-module_param(fsm_enhancement, int, 0664);
-
-MODULE_PARM_DESC(port_select_ovr_en, "\n port_select_ovr_en \n");
-module_param(port_select_ovr_en, int, 0664);
-
-MODULE_PARM_DESC(phy_cmu_config_force_val, "\n phy_cmu_config_force_val \n");
-module_param(phy_cmu_config_force_val, int, 0664);
-
-MODULE_PARM_DESC(phy_system_config_force_val, "\n phy_system_config_force_val \n");
-module_param(phy_system_config_force_val, int, 0664);
-
-MODULE_PARM_DESC(acr_mode, "\n acr_mode \n");
-module_param(acr_mode, int, 0664);
-
-MODULE_PARM_DESC(hdcp_enable, "\n hdcp_enable \n");
-module_param(hdcp_enable, int, 0664);
-
-MODULE_PARM_DESC(audio_sample_rate, "\n audio_sample_rate \n");
-module_param(audio_sample_rate, int, 0664);
-
-MODULE_PARM_DESC(force_audio_sample_rate, "\n force_audio_sample_rate \n");
-module_param(force_audio_sample_rate, int, 0664);
-
-MODULE_PARM_DESC(audio_coding_type, "\n audio_coding_type \n");
-module_param(audio_coding_type, int, 0664);
-
-MODULE_PARM_DESC(audio_channel_count, "\n audio_channel_count \n");
-module_param(audio_channel_count, int, 0664);
-
-MODULE_PARM_DESC(frame_rate, "\n frame_rate \n");
-module_param(frame_rate, int, 0664);
-
-MODULE_PARM_DESC(edid_mode, "\n edid_mode \n");
-module_param(edid_mode, int, 0664);
-
-MODULE_PARM_DESC(switch_mode, "\n switch_mode \n");
-module_param(switch_mode, int, 0664);
-
-MODULE_PARM_DESC(force_vic, "\n force_vic \n");
-module_param(force_vic, int, 0664);
-
-MODULE_PARM_DESC(force_ready, "\n force_ready \n");
-module_param(force_ready, int, 0664);
-
-MODULE_PARM_DESC(force_state, "\n force_state \n");
-module_param(force_state, int, 0664);
-
-MODULE_PARM_DESC(force_format, "\n force_format \n");
-module_param(force_format, int, 0664);
-
-MODULE_PARM_DESC(hdmirx_log_flag, "\n hdmirx_log_flag \n");
-module_param(hdmirx_log_flag, int, 0664);
-
-MODULE_PARM_DESC(hdmirx_debug_flag, "\n hdmirx_debug_flag \n");
-module_param(hdmirx_debug_flag, int, 0664);
-
-MODULE_PARM_DESC(sm_init_en, "\n init sm in stop \n");
-module_param(sm_init_en, int, 0664);
-
-MODULE_PARM_DESC(frame_skip_en, "\n frame_skip_en \n");
-module_param(frame_skip_en, bool, 0664);
-
-MODULE_PARM_DESC(unlock2_stable_th, "\n unlock2_stable_th \n");
-module_param(unlock2_stable_th, int, 0664);
-
-MODULE_PARM_DESC(unready2_stable_th, "\n unready2_stable_th \n");
-module_param(unready2_stable_th, int, 0664);
-
-MODULE_PARM_DESC(unstable2_th, "\n unstable2_th \n");
-module_param(unstable2_th, int, 0664);
-
-MODULE_PARM_DESC(stable2_ready_th, "\n stable2_ready_th \n");
-module_param(stable2_ready_th, int, 0664);
-
-MODULE_PARM_DESC(sig_lock_th, "\n sig_lock_th \n");
-module_param(sig_lock_th, int, 0664);
-
-MODULE_PARM_DESC(pll_unlock_th, "\n pll_unlock_th \n");
-module_param(pll_unlock_th, int, 0664);
-
-MODULE_PARM_DESC(diff_pixel_th, "\n diff_pixel_th \n");
-module_param(diff_pixel_th, int, 0664);
-
-MODULE_PARM_DESC(diff_line_th, "\n diff_line_th \n");
-module_param(diff_line_th, int, 0664);
-
-MODULE_PARM_DESC(diff_frame_th, "\n diff_frame_th \n");
-module_param(diff_frame_th, int, 0664);
-
-MODULE_PARM_DESC(use_frame_rate_check, "\n use_frame_rate_check \n");
-module_param(use_frame_rate_check, bool, 0664);
-
-MODULE_PARM_DESC(use_hw_hpd, "\n use_hw_hpd \n");
-module_param(use_hw_hpd, bool, 0664);
-
-MODULE_PARM_DESC(sample_rate_change_th, "\n sample_rate_change_th \n");
-module_param(sample_rate_change_th, int, 0664);
-
-MODULE_PARM_DESC(chg_pixel_th, "\n chg_pixel_th \n");
-module_param(chg_pixel_th, int, 0664);
-
-MODULE_PARM_DESC(chg_line_th, "\n chg_line_th \n");
-module_param(chg_line_th, int, 0664);
-
-MODULE_PARM_DESC(hw_cfg_mode, "\n hw_cfg_mode \n");
-module_param(hw_cfg_mode, int, 0664);
-
-MODULE_PARM_DESC(cfg_wait_max, "\n cfg_wait_max \n");
-module_param(cfg_wait_max, int, 0664);
-
-MODULE_PARM_DESC(audio_sample_rate_stable_count_th, "\n audio_sample_rate_stable_count_th \n");
-module_param(audio_sample_rate_stable_count_th, int, 0664);
-
-MODULE_PARM_DESC(reset_mode, "\n reset_mode \n");
-module_param(reset_mode, int, 0664);
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
deleted file mode 100755
index 370816f06105..000000000000
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.c
+++ /dev/null
@@ -1,994 +0,0 @@
-/*
- * TVHDMI char device driver for M6TV chip of AMLOGIC INC.
- *
- * Copyright (C) 2012 AMLOGIC, INC. All Rights Reserved.
- * Author: Rain Zhang <rain.zhang@amlogic.com>
- * Author: Xiaofei Zhu <xiaofei.zhu@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-/* Standard Linux headers */
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/cdev.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/errno.h>
-#include <asm/uaccess.h>
-#include <linux/mutex.h>
-
-/* Amlogic headers */
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vframe_receiver.h>
-#include <linux/amlogic/tvin/tvin.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/amports/vframe.h>
-
-/* Local include */
-#include "../tvin_frontend.h"
-#include "hdmirx_drv.h"           /* For user used */
-#include "hdmi_rx_reg.h"
-
-
-#define TVHDMI_NAME               "hdmirx"
-#define TVHDMI_DRIVER_NAME        "hdmirx"
-#define TVHDMI_MODULE_NAME        "hdmirx"
-#define TVHDMI_DEVICE_NAME        "hdmirx"
-#define TVHDMI_CLASS_NAME         "hdmirx"
-#define INIT_FLAG_NOT_LOAD 0x80
-
-/* 50ms timer for hdmirx main loop (HDMI_STATE_CHECK_FREQ is 20) */
-#define TIMER_STATE_CHECK              (1*HZ/HDMI_STATE_CHECK_FREQ)
-
-
-static unsigned char init_flag = 0;
-static dev_t	hdmirx_devno;
-static struct class	*hdmirx_clsp;
-extern void clk_init(void);
-static int open_flage = 0;
-struct hdmirx_dev_s *devp_hdmirx_suspend;
-extern void clk_off(void);
-extern void hdmirx_wr_top (unsigned long addr, unsigned long data);
-int resume_flag = 0;
-MODULE_PARM_DESC(resume_flag, "\n resume_flag \n");
-module_param(resume_flag, int, 0664);
-
-
-
-typedef struct hdmirx_dev_s {
-	int                         index;
-	dev_t                       devt;
-	struct cdev                 cdev;
-	struct device               *dev;
-	struct tvin_parm_s          param;
-	struct timer_list           timer;
-	tvin_frontend_t             frontend;
-} hdmirx_dev_t;
-
-void hdmirx_timer_handler(unsigned long arg)
-{
-	struct hdmirx_dev_s *devp = (struct hdmirx_dev_s *)arg;
-
-	hdmirx_hw_monitor();
-	devp->timer.expires = jiffies + TIMER_STATE_CHECK;
-	add_timer(&devp->timer);
-}
-
-int hdmirx_dec_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	if ((port >= TVIN_PORT_HDMI0) && (port <= TVIN_PORT_HDMI7)) {
-		//pr_info("%s port:%x supported \n", __FUNCTION__, port);
-		return 0;
-	} else {
-		//pr_info("%s port:%x not supported \n", __FUNCTION__, port);
-		return -1;
-	}
-}
-
-int hdmirx_dec_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	struct hdmirx_dev_s *devp;
-	
-	open_flage = 1;
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	devp_hdmirx_suspend = container_of(fe, struct hdmirx_dev_s, frontend);
-	devp->param.port = port;
-	hdmirx_hw_enable();
-	hdmirx_hw_init(port);
-	/* timer */
-	init_timer(&devp->timer);
-	devp->timer.data = (ulong)devp;
-	devp->timer.function = hdmirx_timer_handler;
-	devp->timer.expires = jiffies + TIMER_STATE_CHECK;
-	add_timer(&devp->timer);
-	pr_info("%s port:%x ok\n",__FUNCTION__, port);
-	return 0;
-}
-
-void hdmirx_dec_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-	struct hdmirx_dev_s *devp;
-	struct tvin_parm_s *parm;
-	
-	open_flage = 1;
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	devp_hdmirx_suspend = container_of(fe, struct hdmirx_dev_s, frontend);
-	parm = &devp->param;
-	parm->info.fmt = fmt;
-	parm->info.status = TVIN_SIG_STATUS_STABLE;
-	pr_info("%s fmt:%d ok\n",__FUNCTION__, fmt);
-}
-
-void hdmirx_dec_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	struct hdmirx_dev_s *devp;
-	struct tvin_parm_s *parm;
-
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	parm = &devp->param;
-	parm->info.fmt = TVIN_SIG_FMT_NULL;
-	parm->info.status = TVIN_SIG_STATUS_NULL;
-	to_init_state();
-	pr_info("%s ok\n",__FUNCTION__);
-}
-
-void hdmirx_dec_close(struct tvin_frontend_s *fe)
-{
-	struct hdmirx_dev_s *devp;
-	struct tvin_parm_s *parm;
-
-	open_flage = 0;
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	parm = &devp->param;
-	del_timer_sync(&devp->timer);
-	hdmirx_hw_uninit();
-	hdmirx_hw_disable(0);
-	parm->info.fmt = TVIN_SIG_FMT_NULL;
-	parm->info.status = TVIN_SIG_STATUS_NULL;
-	pr_info("%s ok\n",__FUNCTION__);
-}
-
-/* interrupt handler */
-int hdmirx_dec_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
-{
-	struct hdmirx_dev_s *devp;
-	struct tvin_parm_s *parm;
-
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	parm = &devp->param;
-	/* if there is any error or overflow, do some reset, then rerurn -1;*/
-	if ((parm->info.status != TVIN_SIG_STATUS_STABLE) ||
-	    (parm->info.fmt == TVIN_SIG_FMT_NULL)) {
-		return -1;
-	}
-	return 0;
-}
-
-static int  hdmi_dec_callmaster(enum tvin_port_e port,struct tvin_frontend_s *fe)
-{
-
-	int status = 0;
-	switch(port)
-	{
-		case TVIN_PORT_HDMI0:
-			status = (hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)>>(20 + 0)&0x1)==0x1;
-			break;
-		case TVIN_PORT_HDMI1:
-			status = (hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)>>(20 + 1)&0x1)==0x1;
-			break;
-		case TVIN_PORT_HDMI2:
-			status = (hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)>>(20 + 2)&0x1)==0x1;
-			break;
-		case TVIN_PORT_HDMI3:
-		    status = (hdmirx_rd_top(HDMIRX_TOP_HPD_PWR5V)>>(20 + 3)&0x1)==0x1;
-		    break;
-		default:
-			status = 1;
-	}
-	return status;
-	
-}
-static struct tvin_decoder_ops_s hdmirx_dec_ops = {
-	.support    = hdmirx_dec_support,
-	.open       = hdmirx_dec_open,
-	.start      = hdmirx_dec_start,
-	.stop       = hdmirx_dec_stop,
-	.close      = hdmirx_dec_close,
-	.decode_isr = hdmirx_dec_isr,
-	.callmaster_det = hdmi_dec_callmaster,
-};
-
-bool hdmirx_is_nosig(struct tvin_frontend_s *fe)
-{
-	bool ret = 0;
-	
-	ret = hdmirx_hw_is_nosig();
-	return ret;
-}
-
-bool hdmirx_fmt_chg(struct tvin_frontend_s *fe)
-{
-    bool ret = false;
-	enum tvin_sig_fmt_e fmt = TVIN_SIG_FMT_NULL;
-	struct hdmirx_dev_s *devp;
-	struct tvin_parm_s *parm;
-
-#if 1
-
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	parm = &devp->param;
-	if (!hdmirx_hw_pll_lock()) {
-	    ret = true;
-	} else {
- 		fmt = hdmirx_hw_get_fmt();
-		if(fmt != parm->info.fmt)
-		{
-			pr_info("hdmirx fmt: %d --> %d\n", parm->info.fmt, fmt);
-			parm->info.fmt = fmt;
-			ret = true;
-#if 0
-			ret = true;
-#else
-#if 0
-			if (video_format_change()) {
-				printk("vic change, return ture\n");
-				ret = true;
-			} else {
-				printk("vic change, pixel not change, return false\n");
-				ret = false;
-			}
-#endif
-#endif
-		} else {
-		    ret = false;
-		}
-	}
-#else
-	devp = container_of(fe, struct hdmirx_dev_s, frontend);
-	parm = &devp->param;
-	if (!hdmirx_hw_pll_lock()) {
-	    ret = true;
-	} else {
-		ret = video_format_change();
-	}
-
-#endif
-	return ret;
-
-}
-
-bool hdmirx_pll_lock(struct tvin_frontend_s *fe)
-{
-	bool ret = true;
-
-	ret = hdmirx_hw_pll_lock();
-	return ret;
-}
-
-enum tvin_sig_fmt_e hdmirx_get_fmt(struct tvin_frontend_s *fe)
-{
-	enum tvin_sig_fmt_e fmt = TVIN_SIG_FMT_NULL;
-
-	fmt = hdmirx_hw_get_fmt();
-	return fmt;
-}
-
-enum tvin_color_fmt_e hdmirx_get_color_fmt(struct tvin_frontend_s *fe)
-{
-	enum tvin_color_fmt_e color_fmt = TVIN_RGB444;
-
-	switch (hdmirx_hw_get_color_fmt()) {
-	case 1:
-		color_fmt = TVIN_YUV444;
-		break;
-	case 3:
-		color_fmt = TVIN_YUYV422;
-		break;
-	case 0:
-	default:
-		color_fmt = TVIN_RGB444;
-		break;
-	}
-	return color_fmt;
-}
-
-void hdmirx_get_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-	unsigned char _3d_structure, _3d_ext_data;
-
-	prop->dvi_info = hdmirx_hw_get_dvi_info();
-	
-	switch (hdmirx_hw_get_color_fmt()) {
-	case 1:
-		prop->color_format = TVIN_YUV444;
-		break;
-	case 3:
-		prop->color_format = TVIN_YUYV422;
-		break;
-	case 0:
-	default:
-		prop->color_format = TVIN_RGB444;
-		break;
-	}
-	prop->trans_fmt = TVIN_TFMT_2D;
-	if (hdmirx_hw_get_3d_structure(&_3d_structure, &_3d_ext_data) >= 0) {
-		if (_3d_structure == 0x0) {        /* frame packing */
-			prop->trans_fmt = TVIN_TFMT_3D_FP;
-		} else if (_3d_structure == 0x1) {   /* field alternative */
-			prop->trans_fmt = TVIN_TFMT_3D_FA;
-		} else if (_3d_structure == 0x2) {   /* line alternative */
-			prop->trans_fmt = TVIN_TFMT_3D_LA;
-		} else if (_3d_structure == 0x3) {   /* side-by-side full */
-			prop->trans_fmt = TVIN_TFMT_3D_LRF;
-		} else if (_3d_structure == 0x4) {   /* L + depth */
-			prop->trans_fmt = TVIN_TFMT_3D_LD;
-		} else if (_3d_structure == 0x5) {   /* L + depth + graphics + graphics-depth */
-			prop->trans_fmt = TVIN_TFMT_3D_LDGD;
-		} else if (_3d_structure == 0x6) {   /* top-and-bot */
-			prop->trans_fmt = TVIN_TFMT_3D_TB;
-		} else if (_3d_structure == 0x8) {  /* Side-by-Side half */
-			switch (_3d_ext_data) {
-		        case 0x5:	/*Odd/Left picture, Even/Right picture*/
-				prop->trans_fmt = TVIN_TFMT_3D_LRH_OLER;
-				break;
-		        case 0x6:	/*Even/Left picture, Odd/Right picture*/
-				prop->trans_fmt = TVIN_TFMT_3D_LRH_ELOR;
-				break;
-		        case 0x7:	/*Even/Left picture, Even/Right picture*/
-				prop->trans_fmt = TVIN_TFMT_3D_LRH_ELER;
-				break;
-		        case 0x4:	/*Odd/Left picture, Odd/Right picture*/
-		        default:
-				prop->trans_fmt = TVIN_TFMT_3D_LRH_OLOR;
-				break;
-			}
-		}
-	}
-	/* 1: no repeat; 2: repeat 1 times; 3: repeat two; ... */
-	prop->pixel_repeat = hdmirx_hw_get_pixel_repeat();
-}
-
-bool hdmirx_check_frame_skip(struct tvin_frontend_s *fe)
-{
-	return hdmirx_hw_check_frame_skip();
-}
-
-static struct tvin_state_machine_ops_s hdmirx_sm_ops = {
-	.nosig            = hdmirx_is_nosig,
-	.fmt_changed      = hdmirx_fmt_chg,
-	.get_fmt          = hdmirx_get_fmt,
-	.fmt_config       = NULL,
-	.adc_cal          = NULL,
-	.pll_lock         = hdmirx_pll_lock,
-	.get_sig_propery  = hdmirx_get_sig_propery,
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-	.set_cvbs_fmt_pos = NULL,
-#endif
-	.vga_set_param    = NULL,
-	.vga_get_param    = NULL,
-	.check_frame_skip = hdmirx_check_frame_skip,
-};
-
-
-
-/**
- *hdmirx device driver
- */
-static int hdmirx_open(struct inode *inode, struct file *file)
-{
-	hdmirx_dev_t *devp;
-
-	devp = container_of(inode->i_cdev, hdmirx_dev_t, cdev);
-	file->private_data = devp;
-	return 0;
-}
-
-static int hdmirx_release(struct inode *inode, struct file *file)
-{
-	file->private_data = NULL;
-	return 0;
-}
-
-
-static long hdmirx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	long ret = 0;
-	return ret;
-}
-
-/* 
- * File operations structure
- * Defined in linux/fs.h
- */
-static struct file_operations hdmirx_fops = {
-	.owner		= THIS_MODULE,
-	.open		= hdmirx_open,
-	.release	= hdmirx_release,
-	.unlocked_ioctl	= hdmirx_ioctl,
-};
-
-/* attr */
-static unsigned char *hdmirx_log_buf     = NULL;
-static unsigned int  hdmirx_log_wr_pos   = 0;
-static unsigned int  hdmirx_log_rd_pos   = 0;
-static unsigned int  hdmirx_log_buf_size = 0;
-static DEFINE_SPINLOCK (hdmirx_print_lock);
-#define DEF_LOG_BUF_SIZE (1024*128)
-#define PRINT_TEMP_BUF_SIZE 128
-
-void hdmirx_powerdown(const char* buf, int size)
-{
-	char tmpbuf[128];
-	int i = 0;
-
-	while((buf[i]) && (buf[i] != ',') && (buf[i] != ' ')) {
-		tmpbuf[i]=buf[i];
-		i++;
-	}
-	tmpbuf[i] = 0;
-	if(strncmp(tmpbuf, "powerdown", 9)==0){
-		if (open_flage == 1) {
-			del_timer_sync(&devp_hdmirx_suspend->timer);
-			WRITE_MPEG_REG(HHI_HDMIRX_CLK_CNTL,0x0);
-		}
-		pr_info("[hdmirx]: hdmirx power down\n");
-  	}
-}
-
-int hdmirx_print_buf(char* buf, int len)
-{
-	unsigned long flags;
-	int pos;
-	int hdmirx_log_rd_pos_;
-	
-	if (hdmirx_log_buf_size == 0)
-		return 0;
-	spin_lock_irqsave(&hdmirx_print_lock, flags);
-	hdmirx_log_rd_pos_ = hdmirx_log_rd_pos;
-	if (hdmirx_log_wr_pos >= hdmirx_log_rd_pos)
-		hdmirx_log_rd_pos_ += hdmirx_log_buf_size;
-	for (pos = 0; pos < len && hdmirx_log_wr_pos < (hdmirx_log_rd_pos_ - 1); pos++, hdmirx_log_wr_pos++){
-		if (hdmirx_log_wr_pos >= hdmirx_log_buf_size)
-			hdmirx_log_buf[hdmirx_log_wr_pos - hdmirx_log_buf_size] = buf[pos];
-		else
-			hdmirx_log_buf[hdmirx_log_wr_pos] = buf[pos];
-	}
-	if (hdmirx_log_wr_pos >= hdmirx_log_buf_size)
-		hdmirx_log_wr_pos-=hdmirx_log_buf_size;
-	spin_unlock_irqrestore(&hdmirx_print_lock, flags);
-	return pos;
-}
-
-int hdmirx_print(const char *fmt, ...)
-{
-	va_list args;
-	int avail = PRINT_TEMP_BUF_SIZE;
-	char buf[PRINT_TEMP_BUF_SIZE];
-	int pos = 0;
-	int len = 0;
-
-	if (hdmirx_log_flag & 1) {
-		va_start(args, fmt);
-		vprintk(fmt, args);
-		va_end(args);
-		return 0;
-	}
-	if(hdmirx_log_buf_size == 0)
-		return 0;
-
-	//len += snprintf(buf+len, avail-len, "%d:",log_seq++);
-	len += snprintf(buf + len, avail - len, "[%u] ", (unsigned int)jiffies);
-	va_start(args, fmt);
-	len += vsnprintf(buf + len, avail - len, fmt, args);
-	va_end(args);
-	if ((avail-len) <= 0) {
-		buf[PRINT_TEMP_BUF_SIZE - 1] = '\0';
-	}
-	pos = hdmirx_print_buf(buf, len);
-	return pos;
-}
-
-static int log_init(int bufsize)
-{
-	if (bufsize == 0) {
-		if (hdmirx_log_buf) {
-			kfree(hdmirx_log_buf);
-			hdmirx_log_buf = NULL;
-			hdmirx_log_buf_size = 0;
-			hdmirx_log_rd_pos = 0;
-			hdmirx_log_wr_pos = 0;
-		}
-	}
-	if ((bufsize >= 1024) && (hdmirx_log_buf == NULL)) {
-		hdmirx_log_buf_size = 0;
-		hdmirx_log_rd_pos = 0;
-		hdmirx_log_wr_pos = 0;
-		hdmirx_log_buf = kmalloc(bufsize, GFP_KERNEL);
-		if (hdmirx_log_buf) {
-			hdmirx_log_buf_size = bufsize;
-		}
-	}
-	return 0;
-}
-
-static ssize_t show_log(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	unsigned long flags;
-	ssize_t read_size=0;
-
-	if (hdmirx_log_buf_size == 0)
-		return 0;
-	spin_lock_irqsave(&hdmirx_print_lock, flags);
-	if (hdmirx_log_rd_pos < hdmirx_log_wr_pos) {
-		read_size = hdmirx_log_wr_pos-hdmirx_log_rd_pos;
-	} else if (hdmirx_log_rd_pos > hdmirx_log_wr_pos) {
-		read_size = hdmirx_log_buf_size-hdmirx_log_rd_pos;
-	}
-	if (read_size > PAGE_SIZE)
-		read_size = PAGE_SIZE;
-	if (read_size > 0)
-		memcpy(buf, hdmirx_log_buf+hdmirx_log_rd_pos, read_size);
-	hdmirx_log_rd_pos += read_size;
-	if (hdmirx_log_rd_pos >= hdmirx_log_buf_size)
-		hdmirx_log_rd_pos = 0;
-	spin_unlock_irqrestore(&hdmirx_print_lock, flags);
-	return read_size;
-}
-
-static ssize_t store_log(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	int tmp;
-	unsigned long flags;
-	
-	if (strncmp(buf, "bufsize", 7) == 0) {
-		tmp = simple_strtoul(buf + 7, NULL, 10);
-		spin_lock_irqsave(&hdmirx_print_lock, flags);
-		log_init(tmp);
-		spin_unlock_irqrestore(&hdmirx_print_lock, flags);
-		printk("hdmirx_store:set bufsize tmp %d %d\n",tmp, hdmirx_log_buf_size);
-	} else {
-		hdmirx_print(0, "%s", buf);
-	}
-	return 16;
-}
-
-
-static ssize_t hdmirx_debug_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static ssize_t hdmirx_debug_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	hdmirx_debug(buf, count);
-	hdmirx_powerdown(buf, count);
-	return count;
-}
-
-static ssize_t hdmirx_edid_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return hdmirx_read_edid_buf(buf, PAGE_SIZE);
-}
-
-static ssize_t hdmirx_edid_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	hdmirx_fill_edid_buf(buf, count);
-	return count;
-}
-
-static ssize_t hdmirx_key_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return hdmirx_read_key_buf(buf, PAGE_SIZE);
-}
-
-static ssize_t hdmirx_key_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	hdmirx_fill_key_buf(buf, count);
-	return count;
-}
-
-static ssize_t show_reg(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return hdmirx_hw_dump_reg(buf, PAGE_SIZE);
-}
-
-static ssize_t cec_get_state(struct device *dev, struct device_attribute *attr, char *buf)
-{    
-	return 0;
-}
-
-static ssize_t cec_set_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-	return count;
-}
-
-static DEVICE_ATTR(debug, S_IWUSR | S_IWUGO | S_IWOTH , hdmirx_debug_show, hdmirx_debug_store);
-static DEVICE_ATTR(edid,  S_IWUSR | S_IRUGO, hdmirx_edid_show, hdmirx_edid_store);
-static DEVICE_ATTR(key,   S_IWUSR | S_IRUGO, hdmirx_key_show, hdmirx_key_store);
-static DEVICE_ATTR(log,   S_IWUGO | S_IRUGO, show_log, store_log);
-static DEVICE_ATTR(reg,   S_IWUGO | S_IRUGO, show_reg, NULL);
-static DEVICE_ATTR(cec,   S_IWUGO | S_IRUGO, cec_get_state, cec_set_state);
-
-static int hdmirx_add_cdev(struct cdev *cdevp, struct file_operations *fops,
-		int minor)
-{
-	int ret;
-	dev_t devno = MKDEV(MAJOR(hdmirx_devno), minor);
-	
-	cdev_init(cdevp, fops);
-	cdevp->owner = THIS_MODULE;
-	ret = cdev_add(cdevp, devno, 1);
-	return ret;
-}
-
-static struct device * hdmirx_create_device(struct device *parent, int id)
-{
-	dev_t devno = MKDEV(MAJOR(hdmirx_devno),  id);
-	return device_create(hdmirx_clsp, parent, devno, NULL, "%s0",
-			TVHDMI_DEVICE_NAME);
-	/* @to do this after Middleware API modified */
-	/*return device_create(hdmirx_clsp, parent, devno, NULL, "%s",
-	  TVHDMI_DEVICE_NAME); */
-}
-
-static void hdmirx_delete_device(int minor)
-{
-	dev_t devno = MKDEV(MAJOR(hdmirx_devno), minor);
-	device_destroy(hdmirx_clsp, devno);
-}
-
-static int hdmirx_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct hdmirx_dev_s *hdevp;
-
-
-	log_init(DEF_LOG_BUF_SIZE);
-
-	/* allocate memory for the per-device structure */
-	hdevp = kmalloc(sizeof(struct hdmirx_dev_s), GFP_KERNEL);
-	if (!hdevp) {
-		pr_info("hdmirx:failed to allocate memory for hdmirx device\n");
-		ret = -ENOMEM;
-		goto fail_kmalloc_hdev;
-	}
-	memset(hdevp, 0, sizeof(struct hdmirx_dev_s));
-	/*@to get from bsp*/
-	if(pdev->id == -1){
-		hdevp->index = 0;
-	} else {
-		pr_info("%s: failed to get device id\n", __func__);
-		goto fail_get_id;
-	}
-	/* create cdev and reigser with sysfs */
-	ret = hdmirx_add_cdev(&hdevp->cdev, &hdmirx_fops, hdevp->index);
-	if (ret) {
-		pr_info("%s: failed to add cdev\n", __func__);
-		goto fail_add_cdev;
-	}
-	/* create /dev nodes */
-	hdevp->dev = hdmirx_create_device(&pdev->dev, hdevp->index);
-	if (IS_ERR(hdevp->dev)) {
-		pr_info("hdmirx: failed to create device node\n");
-		ret = PTR_ERR(hdevp->dev);
-		goto fail_create_device;
-	}
-	/*create sysfs attribute files*/
-	ret = device_create_file(hdevp->dev, &dev_attr_debug);
-	if(ret < 0) {
-		pr_info("hdmirx: fail to create debug attribute file\n");
-		goto fail_create_debug_file;
-	}		
-	ret = device_create_file(hdevp->dev, &dev_attr_edid);
-	if(ret < 0) {
-		pr_info("hdmirx: fail to create edid attribute file\n");
-		goto fail_create_edid_file;
-	}		
-	ret = device_create_file(hdevp->dev, &dev_attr_key);
-	if(ret < 0) {
-		pr_info("hdmirx: fail to create key attribute file\n");
-		goto fail_create_key_file;
-	}	
-	ret = device_create_file(hdevp->dev, &dev_attr_log);
-	if(ret < 0) {
-		pr_info("hdmirx: fail to create log attribute file\n");
-		goto fail_create_log_file;
-	}
-	ret = device_create_file(hdevp->dev, &dev_attr_reg);
-	if(ret < 0) {
-		pr_info("hdmirx: fail to create reg attribute file\n");
-		goto fail_create_reg_file;
-	}
-	ret = device_create_file(hdevp->dev, &dev_attr_cec);
-	if(ret < 0) {
-		pr_info("hdmirx: fail to create cec attribute file\n");
-		goto fail_create_cec_file;
-	}
-	/* frontend */
-	tvin_frontend_init(&hdevp->frontend, &hdmirx_dec_ops, &hdmirx_sm_ops, hdevp->index);
-	sprintf(hdevp->frontend.name, "%s", TVHDMI_NAME);
-	tvin_reg_frontend(&hdevp->frontend);
-
-	hdmirx_hw_enable();
-    /* set all hpd status  */
-	hdmirx_default_hpd(1);
-
-	dev_set_drvdata(hdevp->dev, hdevp);
-	pr_info("hdmirx: driver probe ok\n");
-	return 0;
-
-
-fail_create_cec_file:
-	device_remove_file(hdevp->dev, &dev_attr_reg);
-fail_create_reg_file:
-	device_remove_file(hdevp->dev, &dev_attr_log);
-fail_create_log_file:
-	device_remove_file(hdevp->dev, &dev_attr_key);
-fail_create_key_file:
-	device_remove_file(hdevp->dev, &dev_attr_edid);
-fail_create_edid_file:
-	device_remove_file(hdevp->dev, &dev_attr_debug);
-fail_create_debug_file:
-	hdmirx_delete_device(hdevp->index);
-fail_create_device:
-	cdev_del(&hdevp->cdev);
-fail_add_cdev:
-fail_get_id:
-	kfree(hdevp);
-fail_kmalloc_hdev:
-	return ret;
-
-}
-
-static int hdmirx_remove(struct platform_device *pdev)
-{
-	struct hdmirx_dev_s *hdevp;
-
-	hdevp = platform_get_drvdata(pdev);
-	device_remove_file(hdevp->dev, &dev_attr_debug);
-	device_remove_file(hdevp->dev, &dev_attr_edid);
-	device_remove_file(hdevp->dev, &dev_attr_key);
-	device_remove_file(hdevp->dev, &dev_attr_log);
-	device_remove_file(hdevp->dev, &dev_attr_reg);
-	device_remove_file(hdevp->dev, &dev_attr_cec);
-	tvin_unreg_frontend(&hdevp->frontend);
-	hdmirx_delete_device(hdevp->index);
-	cdev_del(&hdevp->cdev);
-	kfree(hdevp);
-	pr_info("hdmirx: driver removed ok.\n");
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int hdmirx_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	int i = 0;
-	
-	pr_info("[hdmirx]: hdmirx_suspend\n");
-	if (open_flage == 1) {
-		pr_info("[hdmirx]: suspend--step1111\n");
-		if (resume_flag == 0)
-		del_timer_sync(&devp_hdmirx_suspend->timer);
-		pr_info("[hdmirx]: suspend--step2\n");
-		pr_info("[hdmirx]: suspend--step3\n");
-		for (i = 0; i < 5000; i++) {
-		}
-		pr_info("[hdmirx]: suspend--step4\n");
-	}
-	pr_info("[hdmirx]: suspend--step5\n");
-	clk_off();
-	pr_info("[hdmirx]: suspend success\n");
-	return 0;
-}
-
-static int hdmirx_resume(struct platform_device *pdev)
-{
-	unsigned int data32;
-	int i;
-
-	//hdmirx_hw_enable();
-	pr_info("hdmirx: resume module\n");
-
-	/* DWC clock enable */
-	//Wr_reg_bits(HHI_GCLK_MPEG0, 1, 21, 1);  // Turn on clk_hdmirx_pclk, also = sysclk
-	WRITE_MPEG_REG(HHI_GCLK_MPEG0, (READ_MPEG_REG(HHI_GCLK_MPEG0) | (1 << 21)));
-	// Enable APB3 fail on error
-	//*((volatile unsigned long *) P_HDMIRX_CTRL_PORT)          |= (1 << 15);   // APB3 to HDMIRX-TOP err_en
-	//*((volatile unsigned long *) (P_HDMIRX_CTRL_PORT+0x10))   |= (1 << 15);   // APB3 to HDMIRX-DWC err_en
-
-	//turn on clocks: md, cfg...
-
-	data32  = 0;
-	data32 |= 0 << 25;  // [26:25] HDMIRX mode detection clock mux select: osc_clk
-	data32 |= 1 << 24;  // [24]    HDMIRX mode detection clock enable
-	data32 |= 0 << 16;  // [22:16] HDMIRX mode detection clock divider
-	data32 |= 3 << 9;   // [10: 9] HDMIRX config clock mux select: fclk_div5=400MHz
-	data32 |= 1 << 8;   // [    8] HDMIRX config clock enable
-	data32 |= 3 << 0;   // [ 6: 0] HDMIRX config clock divider: 400/4=100MHz
-	WRITE_MPEG_REG(HHI_HDMIRX_CLK_CNTL,     data32);
-
-	data32  = 0;
-	data32 |= 2             << 25;  // [26:25] HDMIRX ACR ref clock mux select: fclk_div5
-	data32 |= rx.ctrl.acr_mode      << 24;  // [24]    HDMIRX ACR ref clock enable
-	data32 |= 0             << 16;  // [22:16] HDMIRX ACR ref clock divider
-	data32 |= 2             << 9;   // [10: 9] HDMIRX audmeas clock mux select: fclk_div5
-	data32 |= 1             << 8;   // [    8] HDMIRX audmeas clock enable
-	data32 |= 1             << 0;   // [ 6: 0] HDMIRX audmeas clock divider: 400/2 = 200MHz
-	WRITE_MPEG_REG(HHI_HDMIRX_AUD_CLK_CNTL, data32);
-	pr_info("hdmirx: resume module---1\n");
-
-	for (i = 0; i < 5000; i++) {
-	}
-
-	data32  = 0;
-	data32 |= 1 << 17;  // [17]     audfifo_rd_en
-	data32 |= 1 << 16;  // [16]     pktfifo_rd_en
-	data32 |= 1 << 2;   // [2]      hdmirx_cecclk_en
-	data32 |= 0 << 1;   // [1]      bus_clk_inv
-	data32 |= 0 << 0;   // [0]      hdmi_clk_inv
-	if (resume_flag == 0)
-	hdmirx_wr_top( 0x1, data32);    // DEFAULT: {32'h0}
-	pr_info("hdmirx: resume module---2\n");
-
-	for (i = 0; i < 5000; i++) {
-	}
-	if ((resume_flag == 0) && (open_flage == 1))
-	add_timer(&devp_hdmirx_suspend->timer);
-	pr_info("hdmirx: resume module---end,open_flage:%d\n",open_flage);
-
-	return 0;
-
-}
-#endif
-
-static struct platform_driver hdmirx_driver = {
-	.probe      = hdmirx_probe,
-	.remove     = hdmirx_remove,
-#ifdef CONFIG_PM
-	.suspend    = hdmirx_suspend,
-	.resume     = hdmirx_resume,
-#endif
-	.driver     = {
-	.name   = TVHDMI_DRIVER_NAME,
-	}
-};
-
-void hdmirx_irq_init(void);
-static int __init hdmirx_init(void)
-{
-	int ret = 0;
-	if(init_flag & INIT_FLAG_NOT_LOAD)
-		return 0;
-
-	ret = alloc_chrdev_region(&hdmirx_devno, 0, 1, TVHDMI_NAME);
-	if (ret < 0) {
-		pr_info("hdmirx: failed to allocate major number\n");
-		goto fail_alloc_cdev_region;
-	}
-
-	hdmirx_clsp = class_create(THIS_MODULE, TVHDMI_NAME);
-	if (IS_ERR(hdmirx_clsp)) {
-		pr_info(KERN_ERR "hdmirx: can't get hdmirx_clsp\n");
-		ret = PTR_ERR(hdmirx_clsp);
-		goto fail_class_create;
-	}
-	
-	ret = platform_driver_register(&hdmirx_driver);
-	if (ret != 0) {
-		pr_info("failed to register hdmirx module, error %d\n", ret);
-		ret = -ENODEV;
-		goto fail_pdrv_register;
-	}
-	pr_info("hdmirx: hdmirx_init.\n");
-	
-	hdmirx_irq_init();
-	return 0;
-
-fail_pdrv_register:
-	class_destroy(hdmirx_clsp);
-fail_class_create:
-	unregister_chrdev_region(hdmirx_devno, 1);
-fail_alloc_cdev_region:
-	return ret;
-
-}
-
-static void __exit hdmirx_exit(void)
-{
-	class_destroy(hdmirx_clsp);
-	unregister_chrdev_region(hdmirx_devno, 1);
-	platform_driver_unregister(&hdmirx_driver);
-	pr_info("hdmirx: hdmirx_exit.\n");
-}
-
-#if 0
-/**
-* besides characters defined in seperator, 
-* '\"' are used as seperator; 
-* and any characters in '\"' will not act as seperator 
-*/
-static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned offset, unsigned *token_len, unsigned *token_offset)
-{ 
-	char *pToken = NULL;
-	char last_seperator = 0;
-	char trans_char_flag = 0;
-	if(buf){
-		for (;offset<size;offset++){
-			int ii=0;
-			char ch;
-			if (buf[offset] == '\\'){
-				trans_char_flag = 1;
-				continue;
-			}
-			while(((ch=seperator[ii++])!=buf[offset])&&(ch)){
-			}
-			if (ch){
-				if (!pToken){
-					continue;
-				}
-				else {
-					if (last_seperator != '"'){
-						*token_len = (unsigned)(buf + offset - pToken);
-						*token_offset = offset;
-						return pToken;
-					}
-				}
-			}
-			else if (!pToken){
-				if (trans_char_flag&&(buf[offset] == '"'))
-				last_seperator = buf[offset];
-				pToken = &buf[offset];
-			}
-			else if ((trans_char_flag&&(buf[offset] == '"'))&&(last_seperator == '"')){
-				*token_len = (unsigned)(buf + offset - pToken - 2);
-				*token_offset = offset + 1;
-				return pToken + 1;
-			}
-			trans_char_flag = 0;
-		}
-		if (pToken) {
-			*token_len = (unsigned)(buf + offset - pToken);
-			*token_offset = offset;
-		}
-	}
-	return pToken;
-}
-
-static  int __init hdmirx_boot_para_setup(char *s)
-{
-	char separator[]={' ',',',';',0x0};
-	char *token;
-	unsigned token_len, token_offset, offset=0;
-	int size = strlen(s);
-	do{
-		token=next_token_ex(separator, s, size, offset, &token_len, &token_offset);
-		if(token){
-			if((token_len==3) && (strncmp(token, "off", token_len)==0)){
-				init_flag|=INIT_FLAG_NOT_LOAD;
-			}
-		}
-		offset=token_offset;
-	}while(token);
-	return 0;
-}
-
-__setup("hdmirx=",hdmirx_boot_para_setup);
-#endif
-
-module_init(hdmirx_init);
-module_exit(hdmirx_exit);
-
-MODULE_DESCRIPTION("AMLOGIC HDMIRX driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
deleted file mode 100755
index 2d38a4920bf8..000000000000
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * hdmirx_drv.h for HDMI device driver, and declare IO function,
- * structure, enum, used in TVIN AFE sub-module processing
- *
- * Copyright (C) 2012 AMLOGIC, INC. All Rights Reserved.
- * Author: Rain Zhang <rain.zhang@amlogic.com>
- * Author: Xiaofei Zhu <xiaofei.zhu@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-#ifndef _TVHDMI_H
-#define _TVHDMI_H
-
-
-#include <linux/amlogic/tvin/tvin.h>
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-
-#define HDMIRX_VER "Ref.2013/07/04-2"
-#define HDMI_STATE_CHECK_FREQ     (20*5)
-#define ABS(x) ((x)<0 ? -(x) : (x))
-
-/*
- * enum definitions
- */
-typedef enum hdmirx_src_type_e {
-	TVHDMI_SRC_TYPE_NULL = 0,
-} hdmirx_src_type_t;
-
-/* add new value at the end,
- * do not insert new value in the middle
- * to avoid wrong VIC value !!! 
- */
-typedef enum HDMI_Video_Type_ {
-
-	HDMI_Unkown = 0 ,
-	HDMI_640x480p60 = 1 ,
-	HDMI_480p60,
-	HDMI_480p60_16x9,
-	HDMI_720p60,
-	HDMI_1080i60,               /* 5 */
-
-	HDMI_480i60,
-	HDMI_480i60_16x9,
-	HDMI_1440x240p60,
-	HDMI_1440x240p60_16x9,
-	HDMI_2880x480i60,           /* 10 */
-
-	HDMI_2880x480i60_16x9,
-	HDMI_2880x240p60,
-	HDMI_2880x240p60_16x9,
-	HDMI_1440x480p60,
-	HDMI_1440x480p60_16x9,      /* 15 */
-
-	HDMI_1080p60,
-	HDMI_576p50,
-	HDMI_576p50_16x9,
-	HDMI_720p50,
-	HDMI_1080i50,               /* 20 */
-
-	HDMI_576i50,
-	HDMI_576i50_16x9,
-	HDMI_1440x288p50,
-	HDMI_1440x288p50_16x9,
-	HDMI_2880x576i50,           /* 25 */
-
-	HDMI_2880x576i50_16x9,
-	HDMI_2880x288p50,
-	HDMI_2880x288p50_16x9,
-	HDMI_1440x576p50,
-	HDMI_1440x576p50_16x9,      /* 30 */
-
-	HDMI_1080p50,
-	HDMI_1080p24,
-	HDMI_1080p25,
-	HDMI_1080p30,
-	HDMI_2880x480p60,           /* 35 */
-
-	HDMI_2880x480p60_16x9,
-	HDMI_2880x576p50,
-	HDMI_2880x576p50_16x9,
-	HDMI_1080i50_1250,          /* 39 */     
-
-   
-
-	HDMI_1080I120 = 46,
-	HDMI_720p120  = 47,
-
-	HDMI_720p24   = 60,
-	HDMI_720p30   = 62,
-	HDMI_1080p120 = 63,
-	HDMI_800_600  = 65,
-
-	HDMI_1024_768,              /* 66 */
-	HDMI_720_400,
-	HDMI_1280_768,
-	HDMI_1280_800,
-	HDMI_1280_960,              /* 70 */
-
-	HDMI_1280_1024,
-	HDMI_1360_768,
-	HDMI_1366_768,
-	HDMI_1600_900,
-	HDMI_1600_1200,             /* 75 */
-
-	HDMI_1920_1200,
-	HDMI_1440_900,
-	HDMI_1400_1050,
-	HDMI_1680_1050,             /* 79 */
-
-    /* 4k2k mode */
-    HDMI_3840_2160p,
-    HDMI_4096_2160p,            /* 81 */
-    HDMI_MAX_IS_UNSUPPORT,
-} HDMI_Video_Codes_t ;
-
-/*
-*/
-#define USE_GPIO_FOR_HPD
-
-/** TMDS clock minimum [kHz] */
-#define TMDS_CLK_MIN			(24000UL)//(25000UL)
-/** TMDS clock maximum [kHz] */
-#define TMDS_CLK_MAX			(340000UL)
-
-struct hdmi_rx_phy
-{
-	/** (@b user) Context status: closed (0), opened (<0) and configured (>0) */
-	int status;
-	/** (@b user) Configuration clock frequency [kHz], valid range 10MHz to 160MHz */
-	unsigned long cfg_clk;
-	/** Peaking configuration */
-	uint16_t peaking;
-	/** PLL configuration */
-	uint32_t pll_cfg;
-  /**/
-  int lock_thres;
-  int fast_switching;
-  int fsm_enhancement;
-  int port_select_ovr_en;
-  int phy_cmu_config_force_val;
-  int phy_system_config_force_val;
-};
-
-
-/**
- * @short HDMI RX controller video parameters
- *
- * For Auxiliary Video InfoFrame (AVI) details see HDMI 1.4a section 8.2.2
- */
-struct hdmi_rx_ctrl_video
-{
-	/** DVI detection status: DVI (true) or HDMI (false) */
-	bool dvi;
-	/** Deep color mode: 24, 30, 36 or 48 [bits per pixel] */
-	unsigned deep_color_mode;
-
-	/** Pixel clock frequency [kHz] */
-	unsigned long pixel_clk;
-	/** Refresh rate [0.01Hz] */
-	unsigned long refresh_rate;
-	/** Interlaced */
-	bool interlaced;
-	/** Vertical offset */
-	unsigned voffset;
-	/** Vertical active */
-	unsigned vactive;
-	/** Vertical total */
-	unsigned vtotal;
-	/** Horizontal offset */
-	unsigned hoffset;
-	/** Horizontal active */
-	unsigned hactive;
-	/** Horizontal total */
-	unsigned htotal;
-
-	/** AVI Y1-0, video format */
-	unsigned video_format;
-	/** AVI A0, active format information present */
-	unsigned active_valid;
-	/** AVI B1-0, bar valid information */
-	unsigned bar_valid;
-	/** AVI S1-0, scan information */
-	unsigned scan_info;
-	/** AVI C1-0, colorimetry information */
-	unsigned colorimetry;
-	/** AVI M1-0, picture aspect ratio */
-	unsigned picture_ratio;
-	/** AVI R3-0, active format aspect ratio */
-	unsigned active_ratio;
-	/** AVI ITC, IT content */
-	unsigned it_content;
-	/** AVI EC2-0, extended colorimetry */
-	unsigned ext_colorimetry;
-	/** AVI Q1-0, RGB quantization range */
-	unsigned rgb_quant_range;
-	/** AVI SC1-0, non-uniform scaling information */
-	unsigned n_uniform_scale;
-	/** AVI VIC6-0, video mode identification code */
-	unsigned video_mode;
-	/** AVI PR3-0, pixel repetition factor */
-	unsigned pixel_repetition;
-	/** AVI, line number of end of top bar */
-	unsigned bar_end_top;
-	/** AVI, line number of start of bottom bar */
-	unsigned bar_start_bottom;
-	/** AVI, pixel number of end of left bar */
-	unsigned bar_end_left;
-	/** AVI, pixel number of start of right bar */
-	unsigned bar_start_right;
-
-	/* for sw info */
-	unsigned int sw_vic;
-	unsigned int sw_dvi;
-	bool           sw_fp;
-	bool           sw_alternative;
-};
-
-/**
- * @short HDMI RX controller context information
- *
- * Initialize @b user fields (set status to zero).
- * After opening this data is for internal use only.
- */
-struct hdmi_rx_ctrl
-{
-	/** (@b user) Context status: closed (0), opened (<0) and configured (>0) */
-	int status;
-	/** (@b user) Configuration clock frequency [kHz], valid range 10MHz to 160MHz */
-	unsigned long cfg_clk;
-	/** (@b user) Mode detection clock frequency [kHz], valid range 10MHz to 50MHz */
-	unsigned long md_clk;
-	/** TDMS clock frequency [kHz] */
-	unsigned long tmds_clk;
-	unsigned long tmds_clk2; //[MHz], measured with clk_util_clk_msr2
-	/** Debug status, audio FIFO reset count */
-	int acr_mode;
-	/**/
-	unsigned debug_audio_fifo_rst;
-	/** Debug status, packet FIFO reset count */
-	unsigned debug_packet_fifo_rst;
-	/** Debug status, IRQ handling count */
-	unsigned debug_irq_handling;
-	/** Debug status, IRQ packet decoder count */
-	unsigned debug_irq_packet_decoder;
-	/** Debug status, IRQ audio clock count */
-	unsigned debug_irq_audio_clock;
-	/** Debug status, IRQ audio FIFO count */
-	unsigned debug_irq_audio_fifo;
-	/** Debug status, IRQ video mode count */
-	unsigned debug_irq_video_mode;
-	/** Debug status, IRQ HDMI count */
-	unsigned debug_irq_hdmi;
-};
-
-/** Receiver key selection size - 40 bits */
-#define HDCP_BKSV_SIZE	(2 *  1)
-/** Encrypted keys size - 40 bits x 40 keys */
-#define HDCP_KEYS_SIZE	(2 * 40)
-
-/**
- * @short HDMI RX controller HDCP configuration
- */
-struct hdmi_rx_ctrl_hdcp {
-	/** Repeater mode else receiver only */
-	bool repeat;
-	/** Key description seed */
-	uint32_t seed;
-	/**
-	 * Receiver key selection
-	 * @note 0: high order, 1: low order
-	 */
-	uint32_t bksv[HDCP_BKSV_SIZE];
-	/**
-	 * Encrypted keys
-	 * @note 0: high order, 1: low order
-	 */
-	uint32_t keys[HDCP_KEYS_SIZE];
-};
-
-#define CHANNEL_STATUS_SIZE   24
- 
-struct aud_info_s{
-    /* info frame*/
-    /*
-    unsigned char cc;
-    unsigned char ct;
-    unsigned char ss;
-    unsigned char sf;
-    */
-    int coding_type;
-    int channel_count;
-    int sample_frequency;
-    int sample_size;
-    int coding_extension;
-    int channel_allocation;
-    int down_mix_inhibit;
-    int level_shift_value;
-
-    /* channel status */
-    unsigned char channel_status[CHANNEL_STATUS_SIZE];
-    unsigned char channel_status_bak[CHANNEL_STATUS_SIZE];
-    /**/
-    unsigned int cts;
-    unsigned int n;
-    unsigned int audio_recovery_clock;
-    /**/
-    int real_channel_num;
-    int real_sample_size;
-    int real_sample_rate;
-};
-
-struct vendor_specific_info_s{
-    unsigned identifier;
-    unsigned char hdmi_video_format;
-    unsigned char _3d_structure;
-    unsigned char _3d_ext_data;
-};
- 
-struct rx {
-	/** HDMI RX received signal changed */
-	uint change;
-	/** HDMI RX input port 0 (A) or 1 (B) (or 2(C) or 3 (D)) */
-	unsigned port;
-	/** HDMI RX PHY context */
-	struct hdmi_rx_phy phy;
-	/** HDMI RX controller context */
-	struct hdmi_rx_ctrl ctrl;
-	/** HDMI RX controller HDCP configuration */
-	struct hdmi_rx_ctrl_hdcp hdcp;
-	
-	/* wrapper */
-	unsigned int state;
-	unsigned char pow5v_state[10];
-	bool tx_5v_status;
-	bool tx_5v_status_pre;
-	bool no_signal;
-	int hpd_wait_time;
-	int audio_wait_time;
-	int audio_sample_rate_stable_count;
-	unsigned int audio_reset_release_flag;
-	int video_wait_time;
-	/* info */
-	struct aud_info_s aud_info;
-	struct hdmi_rx_ctrl_video video_params;
-	struct hdmi_rx_ctrl_video pre_video_params;
-	struct hdmi_rx_ctrl_video cur_video_params;
-	struct hdmi_rx_ctrl_video reltime_video_params;
-	struct vendor_specific_info_s vendor_specific_info;
-
-};
-
-static unsigned first_bit_set(uint32_t data)
-{
-	unsigned n = 32;
-
-	if (data != 0) 
-	{
-		for (n = 0; (data & 1) == 0; n++) 
-		{
-			data >>= 1;
-		}
-	}
-	return n;
-}
-
-static uint32_t get(uint32_t data, uint32_t mask)
-{
-	return (data & mask) >> first_bit_set(mask);
-}
-
-static uint32_t set(uint32_t data, uint32_t mask, uint32_t value)
-{
-	return ((value << first_bit_set(mask)) & mask) | (data & ~mask);
-}
-
-extern struct rx rx;
-extern int hdmirx_log_flag;
-extern int hdcp_enable;
-extern int hdmirx_print_flag;
-extern bool irq_ctrl_reg_en; /* enable/disable reg rd/wr in irq  */
-
-void hdmirx_wr_top (unsigned long addr, unsigned long data);
-unsigned long hdmirx_rd_top (unsigned long addr);
-void hdmirx_wr_dwc(uint16_t addr, uint32_t data);
-uint32_t hdmirx_rd_dwc(uint16_t addr);
-int hdmirx_wr_phy(uint8_t reg_address, uint16_t data);
-uint16_t hdmirx_rd_phy(uint8_t reg_address);
-uint32_t hdmirx_rd_bits_dwc( uint16_t addr, uint32_t mask);
-void hdmirx_wr_bits_dwc( uint16_t addr, uint32_t mask, uint32_t value);
-
-int hdmirx_control_clk_range(unsigned long min, unsigned long max);
-int hdmirx_packet_fifo_rst(void);
-void hdmirx_audio_enable(bool en);
-int hdmirx_audio_fifo_rst(void);
-void hdmirx_phy_hw_reset(void);
-void phy_init(int rx_port_sel, int dcm);
-void hdmirx_hw_config(void);
-void hdmirx_hw_reset(void);
-void hdmirx_set_hpd(int port, unsigned char val);
-int hdmirx_interrupts_cfg( bool enable);
-int hdmirx_interrupts_hpd( bool enable);
-void hdmirx_phy_reset(bool enable);
-void hdmirx_phy_pddq(int enable);
-
-int hdmirx_get_video_info(struct hdmi_rx_ctrl *ctx, struct hdmi_rx_ctrl_video *params);
-int hdmirx_packet_get_avi(struct hdmi_rx_ctrl_video *params);
-int hdmirx_config_audio(void);
-void hdmirx_config_video(struct hdmi_rx_ctrl_video *video_params);
-int hdmirx_get_tmds_clock(void);
-int hdmirx_get_pixel_clock(void);
-void hdmirx_read_audio_info(struct aud_info_s* audio_info);
-void hdmirx_read_vendor_specific_info_frame(struct vendor_specific_info_s* vs);
-void hdmirx_set_pinmux(void);
-int hdmirx_get_clock(int index);
-
-/**
- * all functions declare
- */
-extern enum tvin_sig_fmt_e hdmirx_hw_get_fmt(void);
-extern void hdmirx_hw_monitor(void);
-extern bool hdmirx_hw_is_nosig(void);
-extern bool video_format_change(void);
-extern bool hdmirx_hw_pll_lock(void);
-extern void hdmirx_reset(void);
-extern void hdmirx_hw_init(tvin_port_t port);
-extern void to_init_state(void);
-extern void hdmirx_hw_uninit(void);
-extern unsigned int hdmirx_get_cur_vic(void);
-extern void hdmirx_hw_enable(void);
-extern void hdmirx_default_hpd(bool high);
-extern void hdmirx_hw_disable(unsigned char flag);
-extern void hdmirx_fill_edid_buf(const char* buf, int size);
-extern int hdmirx_read_edid_buf(char* buf, int max_size);
-extern void hdmirx_fill_key_buf(const char* buf, int size);
-extern int hdmirx_read_key_buf(char* buf, int max_size);
-extern int hdmirx_debug(const char* buf, int size);
-extern int hdmirx_hw_get_color_fmt(void);
-extern int hdmirx_hw_get_3d_structure(unsigned char*, unsigned char*);
-extern int hdmirx_hw_get_dvi_info(void);
-extern int hdmirx_hw_get_pixel_repeat(void);
-extern bool hdmirx_hw_check_frame_skip(void);
-extern int hdmirx_print(const char *fmt, ...);
-extern int hdmirx_log_flag;
-extern int hdmirx_hw_dump_reg(unsigned char* buf, int size);
-
-#endif  // _TVHDMI_H
diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_test.c b/drivers/amlogic/tvin/hdmirx/hdmirx_test.c
deleted file mode 100755
index ec8606696af3..000000000000
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_test.c
+++ /dev/null
@@ -1,852 +0,0 @@
-/*
- * Amlogic M6TV
- * HDMI RX
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-//#include <linux/amports/canvas.h>
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <mach/regs.h>
-#include <mach/clock.h>
-#include <mach/register.h>
-#include <mach/power_gate.h>
-
-#include <linux/amlogic/tvin/tvin.h>
-/* Local include */
-#include "hdmirx_drv.h"
-#include "hdmi_rx_reg.h"
-
-#define HDMIRX_DEV_ID_TOP   0
-#define HDMIRX_DEV_ID_DWC   1
-#define HDMIRX_DEV_ID_PHY   2
-
-
-
-#define EDID_AUTO_CHECKSUM_ENABLE   1               // Checksum byte selection: 0=Use data stored in MEM; 1=Use checksum calculated by HW.
-#define EDID_CLK_DIVIDE_M1          2               // EDID I2C clock = sysclk / (1+EDID_CLK_DIVIDE_M1).
-#define EDID_AUTO_CEC_ENABLE        0
-                                                    // 0=Analog PLL based ACR;
-                                                    // 1=Digital ACR.
-#define VSYNC_POLARITY      1                       // TX VSYNC polarity: 0=low active; 1=high active.
-#define RX_8_CHANNEL        1        // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
-
-#define RX_INPUT_COLOR_FORMAT 0
-#define PIXEL_REPEAT_HDMI 0
-#define RX_INPUT_COLOR_DEPTH 0
-#define RX_HSCALE_HALF 0
-
-#define MANUAL_ACR_N        6272
-#define MANUAL_ACR_CTS      ((RX_INPUT_COLOR_DEPTH==0)? 30000 : (RX_INPUT_COLOR_DEPTH==1)? 30000*5/4 : (RX_INPUT_COLOR_DEPTH==2)? 30000*3/2 : 30000*2)
-#define EXPECT_ACR_N        4096
-#define EXPECT_ACR_CTS      19582
-
-#define EXPECT_MEAS_RESULT  145057                  // = T(audio_master_clk) * meas_clk_cycles / T(hdmi_audmeas_ref_clk); where meas_clk_cycles=4096; T(hdmi_audmeas_ref_clk)=5 ns.
-
-#define HDMI_ARCTX_EN       0                       // Audio Return Channel (ARC) transmission block control:0=Disable; 1=Enable.
-#define HDMI_ARCTX_MODE     0                       // ARC transmission mode: 0=Single-ended mode; 1=Common mode.
-
-#define AUD_CLK_DELTA   2000
-
-#define INTERLACE_MODE 1    
-
-
-#define Wr_reg_bits(reg, val, start, len) \
-  WRITE_MPEG_REG(reg, (READ_MPEG_REG(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
-
-
-#define P_HDMIRX_CTRL_PORT    0xc800e008  // TOP CTRL_PORT: 0xc800e008; DWC CTRL_PORT: 0xc800e018
-#define HDMIRX_ADDR_PORT    (0xe000)  // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-#define HDMIRX_DATA_PORT    (0xe004)  // TOP DATA_PORT: 0xc800e004; DWC DATA_PORT: 0xc800e014
-#define HDMIRX_CTRL_PORT    (0xe008)  // TOP CTRL_PORT: 0xc800e008; DWC CTRL_PORT: 0xc800e018
-
-
-void hdmirx_wr_dwc_check(uint16_t addr, uint32_t data)
-{
-   uint32_t rd_back;
-   hdmirx_wr_dwc(addr, data);
-   rd_back = hdmirx_rd_dwc(addr);
-   if(rd_back!=data){
-        printk("%s error (%x,%x) read back is %x\n", __func__, addr, data, rd_back);
-        while(1); 
-   }
-}
-
-void hdmirx_wr_phy_check(uint16_t addr, uint32_t data)
-{
-   uint32_t rd_back;
-   hdmirx_wr_phy(addr, data);
-   rd_back = hdmirx_rd_phy(addr);
-   if(rd_back!=data){
-        printk("%s error (%x,%x) read back is %x\n", __func__, addr, data, rd_back);
-        while(1); 
-   }
-}
-
-
-
-void hdmirx_wr_top_check(uint16_t addr, uint32_t data)
-{
-   uint32_t rd_back;
-   hdmirx_wr_top(addr, data);
-   rd_back = hdmirx_rd_top(addr);
-   if(rd_back!=data){
-        printk("%s error (%x,%x) read back is %x\n", __func__, addr, data, rd_back);
-        while(1); 
-   }
-}
-
-#define HDCP_KEY_WR_TRIES		(5)
-static void hdmi_rx_ctrl_hdcp_config( const struct hdmi_rx_ctrl_hdcp *hdcp)
-{
-	int error = 0;
-	unsigned i = 0;
-	unsigned k = 0;
-
-	hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 0);
-	//hdmirx_wr_bits_dwc(ctx, RA_HDCP_CTRL, KEY_DECRYPT_ENABLE, 1);
-	hdmirx_wr_bits_dwc( RA_HDCP_CTRL, KEY_DECRYPT_ENABLE, 0);
-	hdmirx_wr_dwc(RA_HDCP_SEED, hdcp->seed);
-	for (i = 0; i < HDCP_KEYS_SIZE; i += 2) {
-		for (k = 0; k < HDCP_KEY_WR_TRIES; k++) {
-			if (hdmirx_rd_bits_dwc( RA_HDCP_STS, HDCP_KEY_WR_OK_STS) != 0) {
-				break;
-			}
-		}
-		if (k < HDCP_KEY_WR_TRIES) {
-			hdmirx_wr_dwc(RA_HDCP_KEY1, hdcp->keys[i + 0]);
-			hdmirx_wr_dwc(RA_HDCP_KEY0, hdcp->keys[i + 1]);
-		} else {
-			error = -EAGAIN;
-			break;
-		}
-	}
-	hdmirx_wr_dwc(RA_HDCP_BKSV1, hdcp->bksv[0]);
-	hdmirx_wr_dwc(RA_HDCP_BKSV0, hdcp->bksv[1]);
-	hdmirx_wr_bits_dwc( RA_HDCP_RPT_CTRL, REPEATER, hdcp->repeat? 1 : 0);
-	hdmirx_wr_dwc(RA_HDCP_RPT_BSTATUS, 0);	/* nothing attached downstream */
-
-  hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 1);
-	
-}
-
-void hdmirx_rd_check_reg (unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data = 0;
-    if (dev_id == HDMIRX_DEV_ID_TOP) {
-        rd_data = hdmirx_rd_top(addr);
-    } else if (dev_id == HDMIRX_DEV_ID_DWC) {
-        rd_data = hdmirx_rd_dwc(addr);
-    } else if (dev_id == HDMIRX_DEV_ID_PHY) {
-        rd_data = hdmirx_rd_phy(addr);
-    }
-    if ((rd_data | mask) != (exp_data | mask)) 
-    {
-        printk("Error: %s(%d) addr=0x%x, rd_data=0x%x, exp_data=0x%x, mask=0x%x\n", 
-            __func__, dev_id, addr, rd_data, exp_data, mask);
-    }
-    
-} /* hdmirx_rd_check_reg */
-
-void hdmirx_poll_dwc (unsigned long addr, unsigned long exp_data, unsigned long mask, unsigned long max_try)
-{
-    unsigned long rd_data;
-    unsigned long cnt   = 0;
-    unsigned char done  = 0;
-    
-    rd_data = hdmirx_rd_dwc(addr);
-    while (((cnt < max_try) || (max_try == 0)) && (done != 1)) {
-        if ((rd_data | mask) == (exp_data | mask)) {
-            done = 1;
-        } else {
-            cnt ++;
-            rd_data = hdmirx_rd_dwc(addr);
-        }
-    }
-    if (done == 0) {
-        printk("Error: hdmirx_poll_DWC access time-out!\n");
-    }
-} /* hdmirx_poll_DWC */
-
-int hdmi_rx_ctrl_edid_update(void);
-
-void hdmirx_hw_config_ori(int rx_port_sel)
-{
-    unsigned long   data32;
-
-    printk("[TEST.C] Configure HDMIRX\n");
-    Wr_reg_bits(HHI_GCLK_MPEG0, 1, 21, 1);  // Turn on clk_hdmirx_pclk, also = sysclk
-
-    // Enable APB3 fail on error
-    *((volatile unsigned long *) P_HDMIRX_CTRL_PORT)          |= (1 << 15);   // APB3 to HDMIRX-TOP err_en
-    *((volatile unsigned long *) (P_HDMIRX_CTRL_PORT+0x10))   |= (1 << 15);   // APB3 to HDMIRX-DWC err_en
-    //--------------------------------------------------------------------------
-    // Enable HDMIRX interrupts:
-    //--------------------------------------------------------------------------
-    // [12]     meter_stable_chg_hdmi
-    // [11]     vid_colour_depth_chg
-    // [10]     vid_fmt_chg
-    // [9:6]    hdmirx_5v_fall
-    // [5:2]    hdmirx_5v_rise
-    // [1]      edid_addr_intr
-    // [0]      core_intr_rise: sub-interrupts will be configured later
-    hdmirx_wr_top_check( HDMIRX_TOP_INTR_MASKN, 0x00001fff);
-    
-    //--------------------------------------------------------------------------
-    // Step 1-13: RX_INITIAL_CONFIG
-    //--------------------------------------------------------------------------
-
-    // 1. DWC reset default to be active, until reg HDMIRX_TOP_SW_RESET[0] is set to 0.
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_SW_RESET, 0x1, 0x0);
-    
-    // 2. turn on clocks: md, cfg...
-
-    data32  = 0;
-    data32 |= 0 << 25;  // [26:25] HDMIRX mode detection clock mux select: osc_clk
-    data32 |= 1 << 24;  // [24]    HDMIRX mode detection clock enable
-    data32 |= 0 << 16;  // [22:16] HDMIRX mode detection clock divider
-    data32 |= 3 << 9;   // [10: 9] HDMIRX config clock mux select: fclk_div5=400MHz
-    data32 |= 1 << 8;   // [    8] HDMIRX config clock enable
-    data32 |= 3 << 0;   // [ 6: 0] HDMIRX config clock divider: 400/4=100MHz
-    WRITE_MPEG_REG(HHI_HDMIRX_CLK_CNTL,     data32);
-
-    data32  = 0;
-    data32 |= 2             << 25;  // [26:25] HDMIRX ACR ref clock mux select: fclk_div5
-    data32 |= rx.ctrl.acr_mode      << 24;  // [24]    HDMIRX ACR ref clock enable
-    data32 |= 0             << 16;  // [22:16] HDMIRX ACR ref clock divider
-    data32 |= 2             << 9;   // [10: 9] HDMIRX audmeas clock mux select: fclk_div5
-    data32 |= 1             << 8;   // [    8] HDMIRX audmeas clock enable
-    data32 |= 1             << 0;   // [ 6: 0] HDMIRX audmeas clock divider: 400/2 = 200MHz
-    WRITE_MPEG_REG(HHI_HDMIRX_AUD_CLK_CNTL, data32);
-
-    data32  = 0;
-    data32 |= 1 << 17;  // [17]     audfifo_rd_en
-    data32 |= 1 << 16;  // [16]     pktfifo_rd_en
-    data32 |= 1 << 2;   // [2]      hdmirx_cecclk_en
-    data32 |= 0 << 1;   // [1]      bus_clk_inv
-    data32 |= 0 << 0;   // [0]      hdmi_clk_inv
-    hdmirx_wr_top_check( HDMIRX_TOP_CLK_CNTL, data32);    // DEFAULT: {32'h0}
-
-    // 3. wait for TX PHY clock up
-    
-    // 4. wait for rx sense
-    
-    // 5. Release IP reset
-    hdmirx_wr_top_check( HDMIRX_TOP_SW_RESET, 0x0);
-
-#if 1
-    mdelay(100);
-#endif
-
-    // 6. Enable functional modules
-    data32  = 0;
-    data32 |= 1 << 5;   // [5]      cec_enable
-    data32 |= 1 << 4;   // [4]      aud_enable
-    data32 |= 1 << 3;   // [3]      bus_enable
-    data32 |= 1 << 2;   // [2]      hdmi_enable
-    data32 |= 1 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_dwc_check( RA_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-    //WRITE_MPEG_REG(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 5 ) {}  // delay 5uS
-            mdelay(1);
-
-    // 7. Reset functional modules
-    hdmirx_wr_dwc( RA_DMI_SW_RST,     0x0000007F);
-    //WRITE_MPEG_REG(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 10 ) {} // delay 10uS
-            mdelay(1);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_DMI_SW_RST,   0, 0);
-    
-    // 8. If defined, force manual N & CTS to speed up simulation
-
-    data32  = 0;
-    data32 |= 0         << 9;   // [9]      force_afif_status:1=Use cntl_audfifo_status_cfg as fifo status; 0=Use detected afif_status.
-    data32 |= 1         << 8;   // [8]      afif_status_auto:1=Enable audio FIFO status auto-exit EMPTY/FULL, if FIFO level is back to LipSync; 0=Once enters EMPTY/FULL, never exits.
-    data32 |= 1         << 6;   // [ 7: 6]  Audio FIFO nominal level :0=s_total/4;1=s_total/8;2=s_total/16;3=s_total/32.
-    data32 |= 3         << 4;   // [ 5: 4]  Audio FIFO critical level:0=s_total/4;1=s_total/8;2=s_total/16;3=s_total/32.
-    data32 |= 0         << 3;   // [3]      afif_status_clr:1=Clear audio FIFO status to IDLE.
-    data32 |= rx.ctrl.acr_mode  << 2;   // [2]      dig_acr_en
-    data32 |= 0         << 1;   // [1]      audmeas_clk_sel: 0=select aud_pll_clk; 1=select aud_acr_clk.
-    data32 |= rx.ctrl.acr_mode  << 0;   // [0]      aud_clk_sel: 0=select aud_pll_clk; 1=select aud_acr_clk.
-    hdmirx_wr_top_check( HDMIRX_TOP_ACR_CNTL_STAT, data32);
-
-    hdmirx_wr_dwc_check( RA_AUDPLL_GEN_CTS, MANUAL_ACR_CTS);
-    hdmirx_wr_dwc_check( RA_AUDPLL_GEN_N,   MANUAL_ACR_N);
-
-    // Force N&CTS to start with, will switch to received values later on, for simulation speed up.
-    data32  = 0;
-    data32 |= 1 << 4;   // [4]      cts_n_ref: 0=used decoded; 1=use manual N&CTS.
-    hdmirx_wr_dwc_check( RA_AUD_CLK_CTRL,   data32);
-
-    data32  = 0;
-    data32 |= 0 << 28;  // [28]     pll_lock_filter_byp
-    data32 |= 0 << 24;  // [27:24]  pll_lock_toggle_div
-    hdmirx_wr_dwc_check( RA_AUD_PLL_CTRL,   data32);    // DEFAULT: {1'b0, 3'd0, 4'd6, 4'd3, 4'd8, 1'b0, 1'b0, 1'b1, 1'b0, 12'd0}
-    
-    // 9. Set EDID data at RX
-#if 1
-    hdmi_rx_ctrl_edid_update();
-
-    data32  = 0;
-    data32 |= 0                         << 13;  // [   13]  checksum_init_mode
-    data32 |= EDID_AUTO_CHECKSUM_ENABLE << 12;  // [   12]  auto_checksum_enable
-    data32 |= EDID_AUTO_CEC_ENABLE      << 11;  // [   11]  auto_cec_enable
-    data32 |= 0                         << 10;  // [   10]  scl_stretch_trigger_config
-    data32 |= 0                         << 9;   // [    9]  force_scl_stretch_trigger
-    data32 |= 1                         << 8;   // [    8]  scl_stretch_enable
-    data32 |= EDID_CLK_DIVIDE_M1 << 0;   // [ 7: 0]  clk_divide_m1
-    hdmirx_wr_top_check( HDMIRX_TOP_EDID_GEN_CNTL,  data32);
-
-	if(hdcp_enable){
-		hdmi_rx_ctrl_hdcp_config(&rx.hdcp);
-	} else {
-		hdmirx_wr_bits_dwc( RA_HDCP_CTRL, HDCP_ENABLE, 0);
-	}
-
-#else
-    hdmirx_edid_setting(edid_extension_flag);
-
-    data32  = 0;
-    data32 |= 0                         << 13;  // [   13]  checksum_init_mode
-    data32 |= edid_auto_checksum_enable << 12;  // [   12]  auto_checksum_enable
-    data32 |= edid_auto_cec_enable      << 11;  // [   11]  auto_cec_enable
-    data32 |= 0                         << 10;  // [   10]  scl_stretch_trigger_config
-    data32 |= 0                         << 9;   // [    9]  force_scl_stretch_trigger
-    data32 |= 1                         << 8;   // [    8]  scl_stretch_enable
-    data32 |= edid_clk_divide_m1 << 0;   // [ 7: 0]  clk_divide_m1
-    hdmirx_wr_top( HDMIRX_TOP_EDID_GEN_CNTL,  data32);
-    
-    if (edid_cec_id_addr != 0x00990098) {
-        hdmirx_wr_top( HDMIRX_TOP_EDID_ADDR_CEC,  edid_cec_id_addr);
-    }
-
-    if (rx_port_sel == 0) {
-        hdmirx_wr_top( HDMIRX_TOP_EDID_DATA_CEC_PORT01,  ((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8));
-    } else if (rx_port_sel == 1) {
-        hdmirx_wr_top( HDMIRX_TOP_EDID_DATA_CEC_PORT01,  (((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8))<<16);
-    } else if (rx_port_sel == 2) {
-        hdmirx_wr_top( HDMIRX_TOP_EDID_DATA_CEC_PORT23,  ((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8));
-    } else { // rx_port_sel == 3
-        hdmirx_wr_top( HDMIRX_TOP_EDID_DATA_CEC_PORT23,  (((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8))<<16);
-    }
-    
-    // 10. HDCP
-    if (hdcp_on) {
-        data32  = 0;
-        data32 |= 0                     << 14;  // [14]     hdcp_vid_de: Force DE=1.
-        data32 |= 0                     << 10;  // [11:10]  hdcp_sel_avmute: 0=normal mode.
-        data32 |= 0                     << 8;   // [9:8]    hdcp_ctl: 0=automatic.
-        data32 |= 0                     << 6;   // [7:6]    hdcp_ri_rate: 0=Ri exchange once every 128 frames.
-        data32 |= hdcp_key_decrypt_en   << 1;   // [1]      key_decrypt_enable
-        data32 |= hdcp_on               << 0;   // [0]      hdcp_enable
-        hdmirx_wr_dwc( RA_HDCP_CTRL,  data32);
-    
-        data32  = 0;
-        data32 |= 1                     << 16;  // [17:16]  i2c_spike_suppr
-        data32 |= 1                     << 13;  // [13]     hdmi_reserved. 0=No HDMI capabilities.
-        data32 |= 1                     << 12;  // [12]     fast_i2c
-        data32 |= 1                     << 9;   // [9]      one_dot_one
-        data32 |= 1                     << 8;   // [8]      fast_reauth
-        data32 |= 0x3a                  << 1;   // [7:1]    hdcp_ddc_addr
-        hdmirx_wr_dwc( RA_HDCP_SETTINGS,  data32);    // DEFAAULT: {13'd0, 2'd1, 1'b1, 3'd0, 1'b1, 2'd0, 1'b1, 1'b1, 7'd58, 1'b0}
-
-        hdmirx_key_setting(hdcp_key_decrypt_en);
-    } /* if (hdcp_on) */
-#endif
-    // 11. RX configuration
-
-    hdmirx_wr_dwc_check( RA_HDMI_CKM_EVLTM, 0x0016fff0);
-    hdmirx_wr_dwc_check( RA_HDMI_CKM_F,     0xf98a0190);
-
-    data32  = 0;
-    data32 |= 80    << 18;  // [26:18]  afif_th_start
-    data32 |= 8     << 9;   // [17:9]   afif_th_max
-    data32 |= 8     << 0;   // [8:0]    afif_th_min
-    hdmirx_wr_dwc_check( RA_AUD_FIFO_TH,    data32);
-
-    data32  = 0;
-    data32 |= 0     << 24;  // [25:24]  mr_vs_pol_adj_mode
-    data32 |= 0     << 18;  // [18]     spike_filter_en
-    data32 |= 0     << 13;  // [17:13]  dvi_mode_hyst
-    data32 |= 0     << 8;   // [12:8]   hdmi_mode_hyst
-    data32 |= 0     << 6;   // [7:6]    hdmi_mode: 0=automatic
-    data32 |= 2     << 4;   // [5:4]    gb_det
-    data32 |= 0     << 2;   // [3:2]    eess_oess
-    data32 |= 1     << 0;   // [1:0]    sel_ctl01
-    hdmirx_wr_dwc_check( RA_HDMI_MODE_RECOVER,  data32); // DEFAULT: {6'd0, 2'd0, 5'd0, 1'b0, 5'd8, 5'd8, 2'd0, 2'd0, 2'd0, 2'd0}
-
-    data32  = 0;
-    data32 |= 1     << 31;  // [31]     pfifo_store_filter_en
-    data32 |= 1     << 26;  // [26]     pfifo_store_mpegs_if
-    data32 |= 1     << 25;  // [25]     pfifo_store_aud_if
-    data32 |= 1     << 24;  // [24]     pfifo_store_spd_if
-    data32 |= 1     << 23;  // [23]     pfifo_store_avi_if
-    data32 |= 1     << 22;  // [22]     pfifo_store_vs_if
-    data32 |= 1     << 21;  // [21]     pfifo_store_gmtp
-    data32 |= 1     << 20;  // [20]     pfifo_store_isrc2
-    data32 |= 1     << 19;  // [19]     pfifo_store_isrc1
-    data32 |= 1     << 18;  // [18]     pfifo_store_acp
-    data32 |= 0     << 17;  // [17]     pfifo_store_gcp
-    data32 |= 0     << 16;  // [16]     pfifo_store_acr
-    data32 |= 0     << 14;  // [14]     gcpforce_clravmute
-    data32 |= 0     << 13;  // [13]     gcpforce_setavmute
-    data32 |= 0     << 12;  // [12]     gcp_avmute_allsps
-    data32 |= 0     << 8;   // [8]      pd_fifo_fill_info_clr
-    data32 |= 0     << 6;   // [6]      pd_fifo_skip
-    data32 |= 0     << 5;   // [5]      pd_fifo_clr
-    data32 |= 1     << 4;   // [4]      pd_fifo_we
-    data32 |= 1     << 0;   // [0]      pdec_bch_en
-    hdmirx_wr_dwc_check( RA_PDEC_CTRL,  data32); // DEFAULT: {23'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 3'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 1     << 6;   // [6]      auto_vmute
-    data32 |= 0xf   << 2;   // [5:2]    auto_spflat_mute
-    hdmirx_wr_dwc_check( RA_PDEC_ASP_CTRL,  data32); // DEFAULT: {25'd0, 1'b1, 4'd0, 2'd0}
-
-    data32  = 0;
-    data32 |= 1     << 16;  // [16]     afif_subpackets: 0=store all sp; 1=store only the ones' spX=1.
-    data32 |= 0     << 0;   // [0]      afif_init
-    hdmirx_wr_dwc_check( RA_AUD_FIFO_CTRL,  data32); // DEFAULT: {13'd0, 2'd0, 1'b1, 15'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 0     << 10;  // [10]     ws_disable
-    data32 |= 0     << 9;   // [9]      sck_disable
-    data32 |= 0     << 5;   // [8:5]    i2s_disable
-    data32 |= 0     << 1;   // [4:1]    spdif_disable
-    data32 |= 1     << 0;   // [0]      i2s_32_16 
-    hdmirx_wr_dwc_check( RA_AUD_SAO_CTRL,   data32); // DEFAULT: {21'd0, 1'b1, 1'b1, 4'd15, 4'd15, 1'b1}
-
-    // Manual de-repeat to speed up simulation
-    data32  = 0;
-    data32 |= PIXEL_REPEAT_HDMI << 1;   // [4:1]    man_vid_derepeat
-    data32 |= 0                 << 0;   // [0]      auto_derepeat
-    hdmirx_wr_dwc_check( RA_HDMI_RESMPL_CTRL,   data32); // DEFAULT: {27'd0, 4'd0, 1'b1}
-
-#if 0
-    // At the 1st frame, HDMIRX hasn't received AVI packet, to speed up receiving YUV422 video, force oavi_video_format=1, release forcing on receiving AVI packet.
-    if (RX_INPUT_COLOR_FORMAT == 1) {
-        /*stimulus_event(31, STIMULUS_HDMI_UTIL_VID_FORMAT    |
-                           (1                       << 4)   |   // 0=Release force; 1=Force vid_fmt
-                           (RX_INPUT_COLOR_FORMAT   << 0));     // Video format: 0=RGB444; 1=YCbCr422; 2=YCbCr444.
-                           */
-    }
-#endif
-
-    // At the 1st frame, HDMIRX hasn't received AVI packet, HDMIRX default video format to RGB, so manual/force something to speed up simulation:
-    data32  = 0;
-    data32 |= (((RX_INPUT_COLOR_DEPTH==3) ||
-                (RX_HSCALE_HALF==1))? 1:0)  << 29;  // [29]     cntl_vid_clk_half: To make timing easier, this bit can be set to 1: if input is dn-sample by 1, or input is 3*16-bit.
-    data32 |= 0                             << 28;  // [28]     cntl_vs_timing: 0=Detect VS rising; 1=Detect HS falling.
-    data32 |= 0                             << 27;  // [27]     cntl_hs_timing: 0=Detect HS rising; 1=Detect HS falling.
-    // For receiving YUV444 video, we manually map component data to speed up simulation, manual-mapping will be cancelled once AVI is received.
-    if (RX_INPUT_COLOR_FORMAT == 2) {
-        data32 |= 2                         << 24;  // [26:24]  vid_data_map. 2={vid1, vid0, vid2}->{vid2, vid1, vid0}
-    } else {
-        data32 |= 0                         << 24;  // [26:24]  vid_data_map. 0={vid2, vid1, vid0}->{vid2, vid1, vid0}
-    }
-    data32 |= RX_HSCALE_HALF                << 23;  // [23]     hscale_half: 1=Horizontally scale down by half
-    data32 |= 0                             << 22;  // [22]     force_vid_rate: 1=Force video output sample rate
-    data32 |= 0                             << 19;  // [21:19]  force_vid_rate_chroma_cfg : 0=Bypass, not rate change. Applicable only if force_vid_rate=1
-    data32 |= 0                             << 16;  // [18:16]  force_vid_rate_luma_cfg   : 0=Bypass, not rate change. Applicable only if force_vid_rate=1
-    data32 |= 0x7fff                        << 0;   // [14: 0]  hsizem1
-    hdmirx_wr_top_check( HDMIRX_TOP_VID_CNTL,   data32);
-
-    // To speed up simulation:
-    // Force VS polarity until for the first 2 frames, because it takes one whole frame for HDMIRX to detect the correct VS polarity;
-    // HS polarity can be detected just after one line, so it can be set to auto-detect from the start.
-    data32  = 0;
-    data32 |= VSYNC_POLARITY    << 3;   // [4:3]    vs_pol_adj_mode:0=invert input VS; 1=no invert; 2=auto convert to high active; 3=no invert.
-    data32 |= 2                 << 1;   // [2:1]    hs_pol_adj_mode:0=invert input VS; 1=no invert; 2=auto convert to high active; 3=no invert.
-    hdmirx_wr_dwc_check( RA_HDMI_SYNC_CTRL,     data32); // DEFAULT: {27'd0, 2'd0, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 3     << 21;  // [22:21]  aport_shdw_ctrl
-    data32 |= 2     << 19;  // [20:19]  auto_aclk_mute
-    data32 |= 1     << 10;  // [16:10]  aud_mute_speed
-    data32 |= 1     << 7;   // [7]      aud_avmute_en
-    data32 |= 1     << 5;   // [6:5]    aud_mute_sel
-    data32 |= 1     << 3;   // [4:3]    aud_mute_mode
-    data32 |= 0     << 1;   // [2:1]    aud_ttone_fs_sel
-    data32 |= 0     << 0;   // [0]      testtone_en 
-    hdmirx_wr_dwc_check( RA_AUD_MUTE_CTRL,  data32); // DEFAULT: {9'd0, 2'd0, 2'd0, 2'd0, 7'd48, 2'd0, 1'b1, 2'd3, 2'd3, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 0     << 4;   // [11:4]   audio_fmt_chg_thres
-    data32 |= 0     << 1;   // [2:1]    audio_fmt
-    data32 |= 0     << 0;   // [0]      audio_fmt_sel
-    hdmirx_wr_dwc_check( RA_AUD_PAO_CTRL,   data32); // DEFAULT: {20'd0, 8'd176, 1'b0, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= (RX_8_CHANNEL? 0x7 :0x0)  << 8;   // [10:8]   ch_map[7:5]
-    data32 |= 1                         << 7;   // [7]      ch_map_manual
-    data32 |= (RX_8_CHANNEL? 0x1f:0x3)  << 2;   // [6:2]    ch_map[4:0]
-    data32 |= 1                         << 0;   // [1:0]    aud_layout_ctrl:0/1=auto layout; 2=layout 0; 3=layout 1.
-    hdmirx_wr_dwc_check( RA_AUD_CHEXTRA_CTRL,    data32); // DEFAULT: {24'd0, 1'b0, 5'd0, 2'd0}
-
-    data32  = 0;
-    data32 |= 0     << 8;   // [8]      fc_lfe_exchg: 1=swap channel 3 and 4
-    hdmirx_wr_dwc_check( RA_PDEC_AIF_CTRL,  data32); // DEFAULT: {23'd0, 1'b0, 8'd0}
-
-    data32  = 0;
-    data32 |= 0     << 20;  // [20]     rg_block_off:1=Enable HS/VS/CTRL filtering during active video
-    data32 |= 1     << 19;  // [19]     block_off:1=Enable HS/VS/CTRL passing during active video
-    data32 |= 5     << 16;  // [18:16]  valid_mode
-    data32 |= 0     << 12;  // [13:12]  ctrl_filt_sens
-    data32 |= 3     << 10;  // [11:10]  vs_filt_sens
-    data32 |= 0     << 8;   // [9:8]    hs_filt_sens
-    data32 |= 2     << 6;   // [7:6]    de_measure_mode
-    data32 |= 0     << 5;   // [5]      de_regen
-    data32 |= 3     << 3;   // [4:3]    de_filter_sens 
-    hdmirx_wr_dwc_check( RA_HDMI_ERRORA_PROTECT, data32); // DEFAULT: {11'd0, 1'b0, 1'b0, 3'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 1'b0, 2'd0, 3'd0}
-
-    data32  = 0;
-    data32 |= 0     << 8;   // [10:8]   hact_pix_ith
-    data32 |= 0     << 5;   // [5]      hact_pix_src
-    data32 |= 1     << 4;   // [4]      htot_pix_src
-    hdmirx_wr_dwc_check( RA_MD_HCTRL1,  data32); // DEFAULT: {21'd0, 3'd1, 2'd0, 1'b0, 1'b1, 4'd0}
-
-    data32  = 0;
-    data32 |= 1     << 12;  // [14:12]  hs_clk_ith
-    data32 |= 7     << 8;   // [10:8]   htot32_clk_ith
-    data32 |= 1     << 5;   // [5]      vs_act_time
-    data32 |= 3     << 3;   // [4:3]    hs_act_time
-    data32 |= 0     << 0;   // [1:0]    h_start_pos
-    hdmirx_wr_dwc_check( RA_MD_HCTRL2,  data32); // DEFAULT: {17'd0, 3'd2, 1'b0, 3'd1, 2'd0, 1'b0, 2'd0, 1'b0, 2'd2}
-
-    data32  = 0;
-    data32 |= 1                 << 4;   // [4]      v_offs_lin_mode
-    data32 |= 1                 << 1;   // [1]      v_edge
-    data32 |= INTERLACE_MODE    << 0;   // [0]      v_mode
-    hdmirx_wr_dwc_check( RA_MD_VCTRL,   data32); // DEFAULT: {27'd0, 1'b0, 2'd0, 1'b1, 1'b0}
-
-    data32  = 0;
-    data32 |= 1 << 10;  // [11:10]  vofs_lin_ith
-    data32 |= 3 << 8;   // [9:8]    vact_lin_ith 
-    data32 |= 0 << 6;   // [7:6]    vtot_lin_ith
-    data32 |= 7 << 3;   // [5:3]    vs_clk_ith
-    data32 |= 2 << 0;   // [2:0]    vtot_clk_ith
-    hdmirx_wr_dwc_check( RA_MD_VTH,     data32); // DEFAULT: {20'd0, 2'd2, 2'd0, 2'd0, 3'd2, 3'd2}
-
-    data32  = 0;
-    data32 |= 1 << 2;   // [2]      fafielddet_en
-    data32 |= 0 << 0;   // [1:0]    field_pol_mode
-    hdmirx_wr_dwc_check( RA_MD_IL_POL,  data32); // DEFAULT: {29'd0, 1'b0, 2'd0}
-
-    data32  = 0;
-    data32 |= 0 << 2;   // [4:2]    deltacts_irqtrig
-    data32 |= 0 << 0;   // [1:0]    cts_n_meas_mode
-    hdmirx_wr_dwc_check( RA_PDEC_ACRM_CTRL, data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    // 12. RX PHY GEN3 configuration
-
-#if 0
-    // Turn on interrupts that to do with PHY communication
-    hdmirx_wr_dwc( RA_HDMI_ICLR,         0xffffffff);
-    *curr_hdmi_ien_maskn    = hdmi_ien_maskn;
-    hdmirx_wr_dwc( RA_HDMI_IEN_SET,      hdmi_ien_maskn);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_HDMI_ISTS,        0, 0);
-#endif
-    // PDDQ = 1'b1; PHY_RESET = 1'b1;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 1             << 1;   // [1]      phypddq
-    data32 |= 1             << 0;   // [0]      phyreset
-    hdmirx_wr_dwc_check( RA_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-    //WRITE_MPEG_REG(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 1 ) {} // delay 1uS
-        mdelay(1);
-
-    // PDDQ = 1'b1; PHY_RESET = 1'b0;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 1             << 1;   // [1]      phypddq
-    data32 |= 0             << 0;   // [0]      phyreset
-    hdmirx_wr_dwc_check( RA_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    // Configuring I2C to work in fastmode
-    hdmirx_wr_dwc_check( RA_I2CM_PHYG3_MODE,    0x1);
-
-    // Write PHY register 0x02 -> { 6'b001000, 1'b1, timebase_ovr[8:0]};
-    //                                              - timebase_ovr[8:0] = Fcfg_clk(MHz) x 4;
-    data32  = 0;
-    data32 |= 8         << 10;  // [15:10]  lock_thres
-    data32 |= 1         << 9;   // [9]      timebase_ovr_en
-    data32 |= (25 * 4)  << 0;   // [8:0]    timebase_ovr = F_cfgclk(MHz) * 4
-    hdmirx_wr_phy_check( 0x02, data32);
-
-    //------------------------------------------------------------------------------------------
-    // Write PHY register 0x03 -> {9'b000000100, color_depth[1:0], 5'b0000};
-    //                                              - color_depth = 00 ->  8bits;
-    //                                              - color_depth = 01 -> 10bits;
-    //                                              - color_depth = 10 -> 12bits;
-    //                                              - color_depth = 11 -> 16bits.
-    //------------------------------------------------------------------------------------------
-    data32  = 0;
-    data32 |= 0                     << 15;  // [15]     mpll_short_power_up
-    data32 |= 0                     << 13;  // [14:13]  mpll_mult
-    data32 |= 0                     << 12;  // [12]     dis_off_lp
-    data32 |= 0                     << 11;  // [11]     fast_switching
-    data32 |= 0                     << 10;  // [10]     bypass_afe
-    data32 |= 1                     << 9;   // [9]      fsm_enhancement
-    data32 |= 0                     << 8;   // [8]      low_freq_eq
-    data32 |= 0                     << 7;   // [7]      bypass_aligner
-    data32 |= RX_INPUT_COLOR_DEPTH  << 5;   // [6:5]    color_depth: 0=8-bit; 1=10-bit; 2=12-bit; 3=16-bit.
-    data32 |= 0                     << 3;   // [4:3]    sel_tmdsclk: 0=Use chan0 clk; 1=Use chan1 clk; 2=Use chan2 clk; 3=Rsvd.
-    data32 |= 0                     << 2;   // [2]      port_select_ovr_en
-    data32 |= 0                     << 0;   // [1:0]    port_select_ovr
-    hdmirx_wr_phy(0x03, data32);
-
-    // PDDQ = 1'b0; PHY_RESET = 1'b0;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 0             << 1;   // [1]      phypddq
-    data32 |= 0             << 0;   // [0]      phyreset
-    hdmirx_wr_dwc_check( RA_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    data32  = 0;
-    data32 |= 0                     << 15;  // [15]     mpll_short_power_up
-    data32 |= 0                     << 13;  // [14:13]  mpll_mult
-    data32 |= 0                     << 12;  // [12]     dis_off_lp
-    data32 |= 0                     << 11;  // [11]     fast_switching
-    data32 |= 0                     << 10;  // [10]     bypass_afe
-    data32 |= 1                     << 9;   // [9]      fsm_enhancement
-    data32 |= 0                     << 8;   // [8]      low_freq_eq
-    data32 |= 0                     << 7;   // [7]      bypass_aligner
-    data32 |= RX_INPUT_COLOR_DEPTH  << 5;   // [6:5]    color_depth: 0=8-bit; 1=10-bit; 2=12-bit; 3=16-bit.
-    data32 |= 0                     << 3;   // [4:3]    sel_tmdsclk: 0=Use chan0 clk; 1=Use chan1 clk; 2=Use chan2 clk; 3=Rsvd.
-    data32 |= 0                     << 2;   // [2]      port_select_ovr_en
-    data32 |= 0                     << 0;   // [1:0]    port_select_ovr
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_PHY, 0x03, data32, 0);
-
-    // 13.  HDMI RX Ready! - Assert HPD
-    printk("[TEST.C] HDMI RX Ready! - Assert HPD\n");
-
-    hdmirx_wr_top_check( HDMIRX_TOP_PORT_SEL,   (1<<rx_port_sel));
-
-    data32  = 0;
-    data32 |= 1                 << 5;   // [    5]  invert_hpd
-    data32 |= 1                 << 4;   // [    4]  force_hpd: default=1
-    data32 |= (1<<rx_port_sel)  << 0;   // [ 3: 0]  hpd_config
-    hdmirx_wr_top( HDMIRX_TOP_HPD_PWR5V,  data32);
-
-    // Configure external video data generator and analyzer
-    /*
-    start_video_gen_ana(vic,                // Video format identification code
-                        pixel_repeat_hdmi,
-                        interlace_mode,     // 0=Progressive; 1=Interlace.
-                        front_porch,        // Number of pixels from DE Low to HSYNC high
-                        back_porch,         // Number of pixels from HSYNC low to DE high
-                        hsync_pixels,       // Number of pixels of HSYNC pulse
-                        hsync_polarity,     // TX HSYNC polarity: 0=low active; 1=high active.
-                        sof_lines,          // HSYNC count between VSYNC de-assertion and first line of active video
-                        eof_lines,          // HSYNC count between last line of active video and start of VSYNC
-                        vsync_lines,        // HSYNC count of VSYNC assertion
-                        vsync_polarity,     // TX VSYNC polarity: 0=low active; 1=high active.
-                        total_pixels,       // Number of total pixels per line
-                        total_lines);       // Number of total lines per frame
-    */
-    // 14.  RX_FINAL_CONFIG
-    
-    // RX PHY PLL configuration
-    //get config for CMU
-    /*stimulus_event(31, STIMULUS_HDMI_UTIL_CALC_PLL_CONFIG   |
-                       (0   << 4)                           |   // mdclk freq: 0=24MHz; 1=25MHz; 2=27MHz.
-                       (1   << 0));                             // tmds_clk_freq: 0=25MHz; 1=27MHz; 2=54MHz; 3=74.25MHz; 4=148.5MHz; 5=27*5/4MHz.
-                       */
-//        //margin of +/-0.78% for clock drift
-//        clockrate_max[15:0] = (expected_clockrate[15:0]+expected_clockrate[15:7]);
-//        clockrate_min[15:0] = (expected_clockrate[15:0]-expected_clockrate[15:7]);
-
-    data32  = 0;
-    data32 |= 1     << 20;  // [21:20]  lock_hyst
-    data32 |= 0     << 16;  // [18:16]  clk_hyst
-    data32 |= 2490  << 4;   // [15:4]   eval_time
-    hdmirx_wr_dwc_check( RA_HDMI_CKM_EVLTM, data32);    // DEFAULT: {10'd0, 2'd1, 1'b0, 3'd0, 12'd4095, 3'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 3533  << 16;  // [31:16]  maxfreq
-    data32 |= 3479  << 0;   // [15:0]   minfreq
-    hdmirx_wr_dwc_check( RA_HDMI_CKM_F, data32);    // DEFAULT: {16'd63882, 16'd9009}
-
-    // RX PHY PLL lock wait
-    printk("[TEST.C] WAITING FOR TMDSVALID-------------------\n");
-    //while (! (*hdmi_pll_lock)) {
-    while(1){
-        if( hdmirx_rd_dwc( RA_HDMI_PLL_LCK_STS) & 0x1)
-            break;
-        mdelay(1);
-        //WRITE_MPEG_REG(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 10 ) {} // delay 10uS
-    }
-    hdmirx_poll_dwc( RA_HDMI_CKM_RESULT, 1<<16, ~(1<<16), 0);
-
-    // 15. Waiting for AUDIO PLL to lock before performing RX synchronous resets!
-    //hdmirx_poll_reg(HDMIRX_DEV_ID_DWC, RA_AUD_PLL_CTRL, 1<<31, ~(1<<31));
-
-    // 16. RX Reset
-
-    data32  = 0;
-    data32 |= 0 << 5;   // [5]      cec_enable
-    data32 |= 0 << 4;   // [4]      aud_enable
-    data32 |= 0 << 3;   // [3]      bus_enable
-    data32 |= 0 << 2;   // [2]      hdmi_enable
-    data32 |= 0 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_dwc_check( RA_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    //WRITE_MPEG_REG(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 1 ) {} // delay 1uS
-        mdelay(1);
-#if 0
-    //--------------------------------------------------------------------------
-    // Enable HDMIRX-DWC interrupts:
-    //--------------------------------------------------------------------------
-    
-    hdmirx_wr_dwc( RA_PDEC_ICLR,         0xffffffff);
-    hdmirx_wr_dwc( RA_AUD_CLK_ICLR,      0xffffffff);
-    hdmirx_wr_dwc( RA_AUD_FIFO_ICLR,     0xffffffff);
-    hdmirx_wr_dwc( RA_MD_ICLR,           0xffffffff);
-    //hdmirx_wr_dwc( RA_HDMI_ICLR,         0xffffffff);
-
-    *curr_pdec_ien_maskn     = pdec_ien_maskn;
-    *curr_aud_clk_ien_maskn  = aud_clk_ien_maskn;
-    *curr_aud_fifo_ien_maskn = aud_fifo_ien_maskn;
-    *curr_md_ien_maskn       = md_ien_maskn;
-
-    hdmirx_wr_dwc( RA_PDEC_IEN_SET,      pdec_ien_maskn);
-    hdmirx_wr_dwc( RA_AUD_CLK_IEN_SET,   aud_clk_ien_maskn);
-    hdmirx_wr_dwc( RA_AUD_FIFO_IEN_SET,  aud_fifo_ien_maskn);
-    hdmirx_wr_dwc( RA_MD_IEN_SET,        md_ien_maskn);
-    //hdmirx_wr_dwc( RA_HDMI_IEN_SET,      hdmi_ien_maskn);
-
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_PDEC_ISTS,        0, 0);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_AUD_CLK_ISTS,     0, 0);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_AUD_FIFO_ISTS,    0, 0);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_MD_ISTS,          0, 0);
-    //hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, RA_HDMI_ISTS,        0, 0);
-#endif    
-    //--------------------------------------------------------------------------
-    // Bring up RX
-    //--------------------------------------------------------------------------
-    data32  = 0;
-    data32 |= 1 << 5;   // [5]      cec_enable
-    data32 |= 1 << 4;   // [4]      aud_enable
-    data32 |= 1 << 3;   // [3]      bus_enable
-    data32 |= 1 << 2;   // [2]      hdmi_enable
-    data32 |= 1 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_dwc_check( RA_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    //WRITE_MPEG_REG(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 10 ) {} // delay 10uS
-        mdelay(1);
-
-    // To speed up simulation, reset the video generator after HDMIRX-PHY is locked,
-    // so that HDMIRX-DWC doesn't have wait for a whole frame before seeing the 1st Vsync.
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_VGEN_RESET        | 1);
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_VGEN_RESET        | 0);
-
-    // Enable HDMI_ARCTX if needed
-    if (HDMI_ARCTX_EN) {
-        data32  = 0;
-        data32 |= HDMI_ARCTX_MODE   << 1;   // [1]      arctx_mode
-        data32 |= 0                 << 0;   // [0]      arctx_en
-        hdmirx_wr_top_check( HDMIRX_TOP_ARCTX_CNTL, data32);
-        
-        data32  = 0;
-        data32 |= HDMI_ARCTX_MODE   << 1;   // [1]      arctx_mode
-        data32 |= HDMI_ARCTX_EN     << 0;   // [0]      arctx_en
-        hdmirx_wr_top_check( HDMIRX_TOP_ARCTX_CNTL, data32);
-    }
-//        register_read(`RX_HDMI_ERD_STS,supportreg,"VERBOSE_MODE");
-//        check_vector("Acc valid indication",supportreg,32'd0,32,error_tmp,"NOPRINT"); errorsum(error,error_tmp,error);
-//        wait_for(5000,"VERBOSE_MODE");
-//        register_read(`RX_HDMI_ERD_STS,supportreg,"VERBOSE_MODE");
-//        check_vector("Acc valid indication",supportreg,32'd7,32,error_tmp,"NOPRINT"); errorsum(error,error_tmp,error);
-//
-//        wait_for(5000,"VERBOSE_MODE");
-//
-//        display_msg( "END OF HDMI RX CONFIGURATION", "DEBUG_MODE");
-//
-//      register_read(  `RX_PDEC_STS  ,  supportreg, "VERBOSE_MODE");
-//      register_read(  `RX_MD_IL_SKEW  ,  supportreg, "NO_PRINT");
-//      {phase, skew} = supportreg[3:0];
-//      if (phase) begin
-//        display_msg("ERROR - PHASE should be 0! Phase 1 detected","VERBOSE_MODE");
-//        errorsum(error,1,error);
-//      end
-//
-//      display_msg("############################### VS vs HS Skew Results ##################################", "VERBOSE_MODE");
-//      if ((skew != 0) && (skew != 3) && (skew != 4) && (skew != 7)) begin
-//        $sformat(supportstring,"   ERROR - Current frame skew %d/8 of a line width (phase %d)                   ", (skew+1), phase);
-//        errorsum(error,1,error);
-//      end
-//      else $sformat(supportstring,"    Current frame skew %d/8 of a line width (phase %d)                           ", (skew+1), phase);
-//      display_msg(supportstring, "VERBOSE_MODE");
-//      display_msg("########################################################################################", "VERBOSE_MODE");
-//
-//          register_read(  `RX_MD_VSC      , { supportreg[15:0], vs_clk_temp  }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_HT0      , { htot32_clk      , hs_clk       }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_HT1      , { htot_pix        , hofs_pix     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_HACT_PX  , { supportreg[15:0], hact_pix     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VSC      , { supportreg[15:0], vs_clk_temp  }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VTC      , { vtot_clk                       }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VOL      , { supportreg[15:0], vofs_lin     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VAL      , { supportreg[15:0], vact_lin     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VTL      , { supportreg[15:0], vtot_lin     }  , "VERBOSE_MODE");
-//      register_read(  `RX_AUD_FIFO_STS    , supportreg  , "VERBOSE_MODE");
- if(rx.ctrl.acr_mode == 0){
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL,  0x60010000); 
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL2, 0x814d3928);
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL3, 0x6b425012);
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL4, 0x101);
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL5, 0x8550d20);
-	if(rx.aud_info.audio_recovery_clock > (96000 + AUD_CLK_DELTA)){
-		if(rx.ctrl.tmds_clk2 <= 36000000) {
-			printk("tmds_clk2 <= 36000000\n");
-			WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55013000);
-		} else if (rx.ctrl.tmds_clk2 <= 53000000) {
-			printk("tmds_clk2 <= 53000000\n");
-			WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55053000);
-		} else {
-			printk("tmds_clk2 > 53000000\n");
-			WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55153000);
-		}
-	} else {
-		printk("audio_recovery_clock < 98000\n");
-		WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL6, 0x55153000);
-	}
-	WRITE_MPEG_REG(HHI_AUDCLK_PLL_CNTL, 0x00010000);  //reset
-}
-
-}
-
diff --git a/drivers/amlogic/tvin/hdmirx/test/hdmi.c b/drivers/amlogic/tvin/hdmirx/test/hdmi.c
deleted file mode 100644
index b784d21de201..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/hdmi.c
+++ /dev/null
@@ -1,755 +0,0 @@
-#include "register.h"
-#include "hdmi.h"
-#include "hdmi_parameter.h"
-#include "c_stimulus.h"
-void hdmi_wr_only_reg(unsigned long addr, unsigned long data)
-{
-  *((volatile unsigned long *) HDMI_ADDR_PORT) = addr;
-  *((volatile unsigned long *) HDMI_DATA_PORT) = data; 
-}
-
-void hdmi_wr_reg(unsigned long addr, unsigned long data)
-{
-    unsigned long rd_data;
-    *((volatile unsigned long *) HDMI_ADDR_PORT) = addr;
-    *((volatile unsigned long *) HDMI_DATA_PORT) = data; 
-    if (addr < EXT_HDMI_TRX_ADDR_OFFSET) {  // only read back if it's chip internal device
-        rd_data = hdmi_rd_reg (addr);
-        if (rd_data != data) 
-        {
-            stimulus_print("Error: (addr) ");
-            stimulus_print_num_hex(addr);
-            stimulus_print_without_timestamp("(rdata) ");
-            stimulus_print_num_hex(rd_data);
-            stimulus_print_without_timestamp("(exp_data) ");
-            stimulus_print_num_hex(data);
-            stimulus_print_without_timestamp("\n");
-            stimulus_finish_fail(10);
-        }
-    }
-}
-
-unsigned long hdmi_rd_reg(unsigned long addr)
-{
-  unsigned long data;
-  *((volatile unsigned long *) HDMI_ADDR_PORT) = addr;
-  data = *((volatile unsigned long *) HDMI_DATA_PORT); 
-  return (data);
-}
-
-void hdmi_rd_check_reg(unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmi_rd_reg(addr);
-    if ((rd_data | mask) != (exp_data | mask)) 
-    {
-        stimulus_print("Error: (addr) ");
-        stimulus_print_num_hex(addr);
-        stimulus_print_without_timestamp("(rd_data) ");
-        stimulus_print_num_hex(rd_data);
-        stimulus_print_without_timestamp("(exp_data) ");
-        stimulus_print_num_hex(exp_data);
-        stimulus_print_without_timestamp("(mask) ");
-        stimulus_print_num_hex(mask);
-        stimulus_print_without_timestamp("\n");
-        stimulus_finish_fail(10);
-    }
-}
-
-void hdmi_poll_reg(unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmi_rd_reg(addr);
-    while ((rd_data | mask) != (exp_data | mask))
-    {
-        rd_data = hdmi_rd_reg(addr);
-    }
-}
-
-void ext_hdmi_wr_only_reg(unsigned long addr, unsigned long data)
-{
-    hdmi_wr_only_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr, data);
-}
-
-void ext_hdmi_wr_reg(unsigned long addr, unsigned long data)
-{
-    //hdmi_wr_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr, data);
-    hdmi_wr_only_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr, data);
-}
-
-unsigned long ext_hdmi_rd_reg(unsigned long addr)
-{
-    return ( hdmi_rd_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr) );
-}
-
-void ext_hdmi_rd_check_reg(unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    hdmi_rd_check_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr, exp_data, mask);
-}
-
-void ext_hdmi_poll_reg(unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmi_rd_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr);
-    while ((rd_data | mask) != (exp_data | mask))
-    {
-        rd_data = hdmi_rd_reg(EXT_HDMI_TRX_ADDR_OFFSET+addr);
-    }
-}
-
-//------------------------------------------------------------------------------
-// set_hdmi_audio_source(unsigned int src)
-//
-// Description:
-// Select HDMI audio clock source, and I2S input data source.
-//
-// Parameters:
-//  src -- 0=no audio clock to HDMI; 1=pcmout to HDMI; 2=Aiu I2S out to HDMI.
-//------------------------------------------------------------------------------
-void set_hdmi_audio_source (unsigned int src)
-{
-    unsigned long data32;
-    unsigned int i;
-    
-    // Disable HDMI audio clock input and its I2S input
-    data32  = 0;
-    data32 |= 0     << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= 0     << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    Wr(AIU_HDMI_CLK_DATA_CTRL, data32);
-
-    // Enable HDMI audio clock from the selected source
-    data32  = 0;
-    data32 |= 0      << 4;  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= src   << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    Wr(AIU_HDMI_CLK_DATA_CTRL, data32);
-    
-    // Wait until clock change is settled
-    i = 0;
-    while ( (((Rd(AIU_HDMI_CLK_DATA_CTRL))>>8)&0x3) != src ) {
-        if (i > 255) {
-            stimulus_print("[TEST.C] Error: set_hdmi_audio_source timeout!\n");
-            stimulus_finish_fail(10);
-        }
-        i ++;
-    }
-
-    // Enable HDMI I2S input from the selected source
-    data32  = 0;
-    data32 |= src   << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= src   << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    Wr(AIU_HDMI_CLK_DATA_CTRL, data32);
-
-    // Wait until data change is settled
-    while ( (((Rd(AIU_HDMI_CLK_DATA_CTRL))>>12)&0x3) != src ) {}
-} /* set_hdmi_audio_source */
-
-void hdmi_tx_key_setting (unsigned long   tx_dev_offset)  // 0x00000: Internal TX; 0x10000: External TX.
-{
-    const unsigned char a1_keys[] ={0x69,
-                                    0x1e,
-                                    0x13,
-                                    0x8f,
-                                    0x58,
-                                    0xa4,
-                                    0x4d,
-                                    0x09,
-                                    0x50,
-                                    0xe6,
-                                    0x58,
-                                    0x35,
-                                    0x82,
-                                    0x1f,
-                                    0x0d,
-                                    0x98,
-                                    0xb9,
-                                    0xab,
-                                    0x47,
-                                    0x6a,
-                                    0x8a,
-                                    0xca,
-                                    0xc5,
-                                    0xcb,
-                                    0x52,
-                                    0x1b,
-                                    0x18,
-                                    0xf3,
-                                    0xb4,
-                                    0xd8,
-                                    0x96,
-                                    0x68,
-                                    0x7f,
-                                    0x14,
-                                    0xfb,
-                                    0x81,
-                                    0x8f,
-                                    0x48,
-                                    0x78,
-                                    0xc9,
-                                    0x8b,
-                                    0xe0,
-                                    0x41,
-                                    0x2c,
-                                    0x11,
-                                    0xc8,
-                                    0x64,
-                                    0xd0,
-                                    0xa0,
-                                    0x44,
-                                    0x20,
-                                    0x24,
-                                    0x28,
-                                    0x5a,
-                                    0x9d,
-                                    0xb3,
-                                    0x6b,
-                                    0x56,
-                                    0xad,
-                                    0xbd,
-                                    0xb2,
-                                    0x28,
-                                    0xb9,
-                                    0xf6,
-                                    0xe4,
-                                    0x6c,
-                                    0x4a,
-                                    0x7b,
-                                    0xa4,
-                                    0x91,
-                                    0x58,
-                                    0x9d,
-                                    0x5e,
-                                    0x20,
-                                    0xf8,
-                                    0x00,
-                                    0x56,
-                                    0xa0,
-                                    0x3f,
-                                    0xee,
-                                    0x06,
-                                    0xb7,
-                                    0x7f,
-                                    0x8c,
-                                    0x28,
-                                    0xbc,
-                                    0x7c,
-                                    0x9d,
-                                    0x8c,
-                                    0x2d,
-                                    0xc0,
-                                    0x05,
-                                    0x9f,
-                                    0x4b,
-                                    0xe5,
-                                    0x61,
-                                    0x12,
-                                    0x56,
-                                    0xcb,
-                                    0xc1,
-                                    0xca,
-                                    0x8c,
-                                    0xde,
-                                    0xf0,
-                                    0x74,
-                                    0x6a,
-                                    0xdb,
-                                    0xfc,
-                                    0x0e,
-                                    0xf6,
-                                    0xb8,
-                                    0x3b,
-                                    0xd7,
-                                    0x2f,
-                                    0xb2,
-                                    0x16,
-                                    0xbb,
-                                    0x2b,
-                                    0xa0,
-                                    0x98,
-                                    0x54,
-                                    0x78,
-                                    0x46,
-                                    0x8e,
-                                    0x2f,
-                                    0x48,
-                                    0x38,
-                                    0x47,
-                                    0x27,
-                                    0x62,
-                                    0x25,
-                                    0xae,
-                                    0x66,
-                                    0xf2,
-                                    0xdd,
-                                    0x23,
-                                    0xa3,
-                                    0x52,
-                                    0x49,
-                                    0x3d,
-                                    0x54,
-                                    0x3a,
-                                    0x7b,
-                                    0x76,
-                                    0x31,
-                                    0xd2,
-                                    0xe2,
-                                    0x25,
-                                    0x61,
-                                    0xe6,
-                                    0xed,
-                                    0x1a,
-                                    0x58,
-                                    0x4d,
-                                    0xf7,
-                                    0x22,
-                                    0x7b,
-                                    0xbf,
-                                    0x82,
-                                    0x60,
-                                    0x32,
-                                    0x6b,
-                                    0xce,
-                                    0x30,
-                                    0x35,
-                                    0x46,
-                                    0x1b,
-                                    0xf6,
-                                    0x6b,
-                                    0x97,
-                                    0xd7,
-                                    0xf0,
-                                    0x09,
-                                    0x04,
-                                    0x36,
-                                    0xf9,
-                                    0x49,
-                                    0x8d,
-                                    0x61,
-                                    0x05,
-                                    0xe1,
-                                    0xa1,
-                                    0x06,
-                                    0x34,
-                                    0x05,
-                                    0xd1,
-                                    0x9d,
-                                    0x8e,
-                                    0xc9,
-                                    0x90,
-                                    0x61,
-                                    0x42,
-                                    0x94,
-                                    0x67,
-                                    0xc3,
-                                    0x20,
-                                    0xc3,
-                                    0x4f,
-                                    0xac,
-                                    0xce,
-                                    0x51,
-                                    0x44,
-                                    0x96,
-                                    0x8a,
-                                    0x8c,
-                                    0xe1,
-                                    0x04,
-                                    0x45,
-                                    0x90,
-                                    0x3e,
-                                    0xfc,
-                                    0x2d,
-                                    0x9c,
-                                    0x57,
-                                    0x10,
-                                    0x00,
-                                    0x29,
-                                    0x80,
-                                    0xb1,
-                                    0xe5,
-                                    0x69,
-                                    0x3b,
-                                    0x94,
-                                    0xd7,
-                                    0x43,
-                                    0x7b,
-                                    0xdd,
-                                    0x5b,
-                                    0xea,
-                                    0xc7,
-                                    0x54,
-                                    0xba,
-                                    0x90,
-                                    0xc7,
-                                    0x87,
-                                    0x58,
-                                    0xfb,
-                                    0x74,
-                                    0xe0,
-                                    0x1d,
-                                    0x4e,
-                                    0x36,
-                                    0xfa,
-                                    0x5c,
-                                    0x93,
-                                    0xae,
-                                    0x11,
-                                    0x9a,
-                                    0x15,
-                                    0x5e,
-                                    0x07,
-                                    0x03,
-                                    0x01,
-                                    0xfb,
-                                    0x78,
-                                    0x8a,
-                                    0x40,
-                                    0xd3,
-                                    0x05,
-                                    0xb3,
-                                    0x4d,
-                                    0xa0,
-                                    0xd7,
-                                    0xa5,
-                                    0x59,
-                                    0x00,
-                                    0x40,
-                                    0x9e,
-                                    0x2c,
-                                    0x4a,
-                                    0x63,
-                                    0x3b,
-                                    0x37,
-                                    0x41,
-                                    0x20,
-                                    0x56,
-                                    0xb4,
-                                    0xbb,
-                                    0x73,
-                                    0x25,
-                                    // ksv
-                                    0x14,  
-                                    0xf7,  
-                                    0x61,  
-                                    0x03,  
-                                    0xb7,  
-                                    // km   
-                                    0xcc,  
-                                    0xce,  
-                                    0x2f,  
-                                    0xd2,  
-                                    0xc7,  
-                                    0x09,  
-                                    0x53};  
-
-    int i, j, ram_addr, byte_num;
-    unsigned int value;
-    
-    byte_num = sizeof(a1_keys)/sizeof(unsigned char);
-    
-    j = 0;
-    for (i = 0; i < byte_num; i++)
-    {
-        value = a1_keys[i]; 
-        ram_addr = TX_HDCP_DKEY_OFFSET+j;
-        //printf("Tx Key value=%x was writen to address %x\n",value,ram_addr);
-        //stimulus_display2("Tx Key value=%h was writen to address %h\n",value,ram_addr);
-        hdmi_wr_reg(tx_dev_offset+ram_addr, value ^ 0xbe);
-        j = ((i % 7) == 6) ? j + 2: j + 1;
-    }
-} /* hdmi_tx_key_setting */
-
-void hdmitx_test_function ( unsigned long   tx_dev_offset,          // 0x00000: Internal TX; 0x10000: External TX.
-                            unsigned char   hdcp_on,
-                            unsigned char   vic,                    // Video format identification code
-                            unsigned char   mode_3d,                // 0=2D; 1=3D frame-packing; 2=3D side-by-side; 3=3D top-and-bottom.
-                            unsigned char   pixel_repeat_hdmi,
-                            unsigned char   tx_input_color_depth,   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                            unsigned char   tx_input_color_format,  // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-                            unsigned char   tx_input_color_range,   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-                            unsigned char   tx_output_color_depth,  // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                            unsigned char   tx_output_color_format, // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-                            unsigned char   tx_output_color_range,  // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-                            unsigned char   tx_i2s_spdif,           // 0=SPDIF; 1=I2S. Note: Must select I2S if CHIP_HAVE_HDMI_RX is defined.
-                            unsigned char   tx_i2s_8_channel,       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
-                            unsigned char   audio_packet_type)      // 0=audio sample packet; 1=one bit audio; 2=HBR audio packet; 3=DST audio packet.
-{
-    unsigned int tmp_add_data;
-    
-    stimulus_print("[TEST.C] Configure HDMITX\n");
-
-    // Enable APB3 fail on error
-    *((volatile unsigned long *) HDMI_CTRL_PORT) |= (1 << 15);        //APB3 err_en
-
-    // Keep TX (except register I/F) in reset, while programming the registers:
-    tmp_add_data  = 0;
-    tmp_add_data |= 1   << 7; // [7] tx_pixel_rstn
-    tmp_add_data |= 1   << 6; // [6] tx_tmds_rstn
-    tmp_add_data |= 1   << 5; // [5] tx_audio_master_rstn
-    tmp_add_data |= 1   << 4; // [4] tx_audio_sample_rstn
-    tmp_add_data |= 1   << 3; // [3] tx_i2s_reset_rstn
-    tmp_add_data |= 1   << 2; // [2] tx_dig_reset_n_ch2
-    tmp_add_data |= 1   << 1; // [1] tx_dig_reset_n_ch1
-    tmp_add_data |= 1   << 0; // [0] tx_dig_reset_n_ch0
-    hdmi_wr_reg(tx_dev_offset+TX_SYS5_TX_SOFT_RESET_1, tmp_add_data); // 0xff
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] HDMI_CH3_RST_IN
-    tmp_add_data |= 0   << 6; // [6] HDMI_CH2_RST_IN
-    tmp_add_data |= 0   << 5; // [5] HDMI_CH1_RST_IN
-    tmp_add_data |= 0   << 4; // [4] HDMI_CH0_RST_IN
-    tmp_add_data |= 0   << 3; // [3] HDMI_SR_RST
-    tmp_add_data |= 1   << 0; // [0] tx_dig_reset_n_ch3
-    hdmi_wr_reg(tx_dev_offset+TX_SYS5_TX_SOFT_RESET_2, tmp_add_data); // 0x01
-
-    // Enable software controlled DDC transaction
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] forced_sys_trigger
-    tmp_add_data |= 0   << 6; // [6] sys_trigger_config
-    tmp_add_data |= 0   << 5; // [5] mem_acc_seq_mode
-    tmp_add_data |= 0   << 4; // [4] mem_acc_seq_start
-    tmp_add_data |= 1   << 3; // [3] forced_mem_copy_done
-    tmp_add_data |= 1   << 2; // [2] mem_copy_done_config
-    tmp_add_data |= 0   << 1; // [1] edid_int_forced_clear
-    tmp_add_data |= 0   << 0; // [0] edid_int_auto_clear
-    hdmi_wr_reg(tx_dev_offset+TX_HDCP_EDID_CONFIG, tmp_add_data); // 0x0e
-    
-    // Setting HDCP keys
-    stimulus_print("[TEST.C] Setting HDMI TX HDCP keys with encryption\n");
-    hdmi_tx_key_setting(tx_dev_offset);
-    stimulus_print("[TEST.C] HDMI TX Key Setting is done\n");
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   Force DTV timing (Auto)
-    tmp_add_data |= 0   << 6; // [6]   Force Video Scan, only if [7]is set
-    tmp_add_data |= 0   << 5; // [5]   Force Video field, only if [7]is set
-    tmp_add_data |= 0   << 0; // [4:0] Rsrv
-    hdmi_wr_reg(tx_dev_offset+TX_VIDEO_DTV_TIMING, tmp_add_data); // 0x00
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0                       << 7; // [7]   forced_default_phase
-    tmp_add_data |= 0                       << 2; // [6:2] Rsrv
-    tmp_add_data |= tx_output_color_depth   << 0; // [1:0] Color_depth:0=24-bit pixel; 1=30-bit pixel; 2=36-bit pixel; 3=48-bit pixel
-    hdmi_wr_reg(tx_dev_offset+TX_VIDEO_DTV_MODE, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 1                       << 7; // [7]   gc_pack_mode: 0=clear color_depth and pixel_phase when GC packet is transmitting AV_mute/clear info;
-                                                  //                     1=do not clear.
-    tmp_add_data |= 0                       << 0; // [6:0] forced_islands_per_period_active
-    hdmi_wr_reg(tx_dev_offset+TX_PACKET_ALLOC_ACTIVE_1, tmp_add_data); // 0x80
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   Force packet timing
-    tmp_add_data |= 0   << 6; // [6]   PACKET ALLOC MODE
-    //tmp_add_data |= 47  << 0; // [5:0] PACKET_START_LATENCY
-    tmp_add_data |= 58  << 0; // [5:0] PACKET_START_LATENCY
-    hdmi_wr_reg(tx_dev_offset+TX_PACKET_CONTROL_1, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 6; // [7:6] audio_source_select[1:0]
-    tmp_add_data |= 0   << 5; // [5]   external_packet_enable
-    tmp_add_data |= 1   << 4; // [4]   internal_packet_enable
-    tmp_add_data |= 0   << 2; // [3:2] afe_fifo_source_select_lane_1[1:0]
-    tmp_add_data |= 0   << 0; // [1:0] afe_fifo_source_select_lane_0[1:0]
-    hdmi_wr_reg(tx_dev_offset+TX_CORE_DATA_CAPTURE_2, tmp_add_data); // 0x10
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   monitor_lane_1
-    tmp_add_data |= 0   << 4; // [6:4] monitor_select_lane_1[2:0]
-    tmp_add_data |= 1   << 3; // [3]   monitor_lane_0
-    tmp_add_data |= 7   << 0; // [2:0] monitor_select_lane_0[2:0]
-    hdmi_wr_reg(tx_dev_offset+TX_CORE_DATA_MONITOR_1, tmp_add_data); // 0x0f
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 3; // [7:3] Rsrv
-    tmp_add_data |= 2   << 0; // [2:0] monitor_select[2:0]
-    hdmi_wr_reg(tx_dev_offset+TX_CORE_DATA_MONITOR_2, tmp_add_data); // 0x02
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 1   << 7; // [7]   forced_hdmi
-    tmp_add_data |= 1   << 6; // [6]   hdmi_config
-    tmp_add_data |= 0   << 4; // [5:4] Rsrv
-    tmp_add_data |= 0   << 3; // [3]   bit_swap.
-    tmp_add_data |= 0   << 0; // [2:0] channel_swap[2:0]
-    hdmi_wr_reg(tx_dev_offset+TX_TMDS_MODE, tmp_add_data); // 0xc0
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   Rsrv
-    tmp_add_data |= 0   << 6; // [6]   TX_CONNECT_SEL: 0=use lower channel data[29:0]; 1=use upper channel data[59:30]
-    tmp_add_data |= 0   << 0; // [5:0] Rsrv
-    hdmi_wr_reg(tx_dev_offset+TX_SYS4_CONNECT_SEL_1, tmp_add_data); // 0x00
-    
-    // Normally it makes sense to synch 3 channel output with clock channel's rising edge,
-    // as HDMI's serializer is LSB out first, invert tmds_clk pattern from "1111100000" to
-    // "0000011111" actually enable data synch with clock rising edge.
-    tmp_add_data = 1 << 4; // Set tmds_clk pattern to be "0000011111" before being sent to AFE clock channel
-    hdmi_wr_reg(tx_dev_offset+TX_SYS4_CK_INV_VIDEO, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] Rsrv
-    tmp_add_data |= 0   << 6; // [6] TX_AFE_FIFO channel 2 bypass=0
-    tmp_add_data |= 0   << 5; // [5] TX_AFE_FIFO channel 1 bypass=0
-    tmp_add_data |= 0   << 4; // [4] TX_AFE_FIFO channel 0 bypass=0
-    tmp_add_data |= 1   << 3; // [3] output enable of clk channel (channel 3)
-    tmp_add_data |= 1   << 2; // [2] TX_AFE_FIFO channel 2 enable
-    tmp_add_data |= 1   << 1; // [1] TX_AFE_FIFO channel 1 enable
-    tmp_add_data |= 1   << 0; // [0] TX_AFE_FIFO channel 0 enable
-    hdmi_wr_reg(tx_dev_offset+TX_SYS5_FIFO_CONFIG, tmp_add_data); // 0x0f
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= tx_output_color_format  << 6; // [7:6] output_color_format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-    tmp_add_data |= tx_input_color_format   << 4; // [5:4] input_color_format:  0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-    tmp_add_data |= tx_output_color_depth   << 2; // [3:2] output_color_depth:  0=24-b; 1=30-b; 2=36-b; 3=48-b.
-    tmp_add_data |= tx_input_color_depth    << 0; // [1:0] input_color_depth:   0=24-b; 1=30-b; 2=36-b; 3=48-b.
-    hdmi_wr_reg(tx_dev_offset+TX_VIDEO_DTV_OPTION_L, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0                       << 4; // [7:4] Rsrv
-    tmp_add_data |= tx_output_color_range   << 2; // [3:2] output_color_range:  0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-    tmp_add_data |= tx_input_color_range    << 0; // [1:0] input_color_range:   0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-    hdmi_wr_reg(tx_dev_offset+TX_VIDEO_DTV_OPTION_H, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= pixel_repeat_hdmi       << 4; // [7:4] pixel_repetition
-    hdmi_wr_reg(tx_dev_offset+TX_VIDEO_PROC_CONFIG0, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= tx_i2s_spdif    << 7; // [7]    I2S or SPDIF
-    tmp_add_data |= tx_i2s_8_channel<< 6; // [6]    8 or 2ch
-    tmp_add_data |= 2               << 4; // [5:4]  Serial Format: I2S format
-    tmp_add_data |= 3               << 2; // [3:2]  Bit Width: 24-bit
-    tmp_add_data |= 0               << 1; // [1]    WS Polarity: 0=WS low is left; 1=WS high is left
-    tmp_add_data |= 1               << 0; // [0]    For I2S: 0=one-bit audio; 1=I2S;
-                                          //        For SPDIF: 0= channel status from input data; 1=from register
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_FORMAT, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0x3 << 4; // [7:4]  FIFO Depth=256
-    tmp_add_data |= 0x3 << 2; // [3:2]  Critical threshold=Depth/32
-    tmp_add_data |= 0x1 << 0; // [1:0]  Normal threshold=Depth/8
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_FIFO, tmp_add_data); // 0x3d
-
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_LIPSYNC, 0); // [7:0] Normalized lip-sync param: 0 means S(lipsync) = S(total)/2
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]    forced_audio_fifo_clear
-    tmp_add_data |= 1   << 6; // [6]    auto_audio_fifo_clear
-    tmp_add_data |= audio_packet_type << 4; // [5:4]  audio_packet_type: 0=audio sample packet; 1=one bit audio; 2=HBR audio packet; 3=DST audio packet.
-    tmp_add_data |= 0   << 3; // [3]    Rsrv
-    tmp_add_data |= 0   << 2; // [2]    Audio sample packet's valid bit: 0=valid bit is 0 for I2S, is input data for SPDIF; 1=valid bit from register
-    tmp_add_data |= 0   << 1; // [1]    Audio sample packet's user bit: 0=user bit is 0 for I2S, is input data for SPDIF; 1=user bit from register
-    tmp_add_data |= 1   << 0; // [0]    0=Audio sample packet's sample_flat bit is 1; 1=sample_flat is 0.
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_CONTROL, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= tx_i2s_8_channel<< 7; // [7]    Audio sample packet's header layout bit: 0=layout0; 1=layout1
-    tmp_add_data |= 0               << 6; // [6]    Set normal_double bit in DST packet header.
-    tmp_add_data |= 0               << 0; // [5:0]  Rsrv
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_HEADER, tmp_add_data);
-
-    tmp_add_data  = tx_i2s_8_channel ? 0xff : 0x03;
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_SAMPLE, tmp_add_data); // Channel valid for up to 8 channels, 1 bit per channel.
-
-    hdmi_wr_reg(tx_dev_offset+TX_AUDIO_PACK, 0x01); // Enable audio sample packets
-
-    hdmi_wr_reg(tx_dev_offset+TX_SYS0_ACR_CTS_0, 0x0a);
-    hdmi_wr_reg(tx_dev_offset+TX_SYS0_ACR_CTS_1, 0x22);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7;    // [7]   Force ACR
-    tmp_add_data |= 0   << 6;    // [6]   Force ACR Ready
-    tmp_add_data |= 0x1 << 0;    // [3:0] CTS
-    hdmi_wr_reg(tx_dev_offset+TX_SYS0_ACR_CTS_2, tmp_add_data); // 0x01
-    
-    // Set N = 4096 (N is not measured, N must be configured so as to be a reference to clock_meter)
-    hdmi_wr_reg(tx_dev_offset+TX_SYS1_ACR_N_0, 0x00); // N[7:0]
-    hdmi_wr_reg(tx_dev_offset+TX_SYS1_ACR_N_1, 0x10); // N[15:8]
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0xa << 4;    // [7:4] Meas Tolerance
-    tmp_add_data |= 0x0 << 0;    // [3:0] N[19:16]
-    hdmi_wr_reg(tx_dev_offset+TX_SYS1_ACR_N_2, tmp_add_data); // 0xa0
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] cp_desired
-    tmp_add_data |= 0   << 6; // [6] ess_config
-    tmp_add_data |= 0   << 5; // [5] set_avmute
-    tmp_add_data |= 1   << 4; // [4] clear_avmute
-    tmp_add_data |= 0   << 3; // [3] hdcp_1_1
-    tmp_add_data |= 0   << 2; // [2] Vsync/Hsync forced_polarity_select
-    tmp_add_data |= 0   << 1; // [1] forced_vsync_polarity
-    tmp_add_data |= 0   << 0; // [0] forced_hsync_polarity
-    hdmi_wr_reg(tx_dev_offset+TX_HDCP_MODE, tmp_add_data); // 0x10
-
-    // Audio Info frame
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AUDIO_INFO_BASE_ADDR+0x00, 0x01); // PB0: Checksum
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AUDIO_INFO_BASE_ADDR+0x04, tx_i2s_8_channel? 0xff : 0x03); // PB4: channel speaker allocation.
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AUDIO_INFO_BASE_ADDR+0x1B, 0x01); // PB27: Rsrv.
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AUDIO_INFO_BASE_ADDR+0x1C, 0x84); // HB0: Packet Type = 0x84
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AUDIO_INFO_BASE_ADDR+0x1E, 0x0a); // HB2: Payload length in bytes
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AUDIO_INFO_BASE_ADDR+0x1F, 0x80); // Enable audio info frame
-   
-    // TX Channel Status
-    //0xB0 - 00000000;     //0xC8 - 00000000;
-    //0xB1 - 00000000;     //0xC9 - 00000000;
-    //0xB2 - 00011000;     //0xCA - 00101000;
-    //0xB3 - 00000000;     //0xCB - 00000000;
-    //0xB4 - 11111011;     //0xCC - 11111011;
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB1_OFFSET+0x00, 0x00);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB1_OFFSET+0x01, 0x00);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB1_OFFSET+0x02, 0x18);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB1_OFFSET+0x03, 0x00);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB1_OFFSET+0x04, 0xfb);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB2_OFFSET+0x00, 0x00);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB2_OFFSET+0x01, 0x00);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB2_OFFSET+0x02, 0x28);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB2_OFFSET+0x03, 0x00);
-    hdmi_wr_reg(tx_dev_offset+TX_IEC60958_SUB2_OFFSET+0x04, 0xfb);
-
-    // AVI frame
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x00, 0xCC);              // PB0: Checksum
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x01, ((tx_output_color_format==1)? 2 : (tx_output_color_format==3)? 1 : 0)<<5);  // PB1 (Note: the value should be meaningful but is not!)
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x02, 0x34);              // PB2 (Note: the value should be meaningful but is not!)
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x03, 0x12);              // PB3 (Note: the value should be meaningful but is not!)
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x04, vic);               // PB4: [7]    Rsrv
-                                                                                      //      [6:0]  VIC
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x05, pixel_repeat_hdmi); // PB5: [7:4]  Rsrv
-                                                                                      //      [3:0]  PixelRepeat
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1C, 0x82);              // HB0: packet type=0x82
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1D, 0x02);              // HB1: packet version =0x02
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1E, 0x0D);              // HB2: payload bytes=13
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1F, 0x80);              // Enable AVI packet generation
-
-    // HDMI Vendor Specific Info (VSI) frame
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x00, 0xDD);                   // PB0: Checksum
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x01, 0x03);                   // PB1: 24-bit IEEE registration ID byte0
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x02, 0x0C);                   // PB2: 24-bit IEEE registration ID byte1
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x03, 0x00);                   // PB3: 24-bit IEEE registration ID byte2
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x04, ((mode_3d==0)?0:2)<<5);  // PB4: [7:5] HDMI_Video_Format
-                                                                                            //      [4:0] Rsrv
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x05, ((mode_3d==1)?0:
-                                                                    (mode_3d==2)?8:
-                                                                    (mode_3d==3)?6:1)<<4);  // PB5: [7:4]  3D_Structure
-                                                                                            //      [3:0]  Rsrv
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x1C, 0x81);                   // HB0: packet type=0x81
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x1D, 0x01);                   // HB1: packet version =0x01
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x1E, 0x06);                   // HB2: payload bytes=6
-    hdmi_wr_reg(tx_dev_offset+TX_PKT_REG_VEND_INFO_BASE_ADDR+0x1F, 0x80);                   // Enable VSI packet generation
-
-    tmp_add_data = 0xa; // time_divider[7:0] for DDC I2C bus clock
-    hdmi_wr_reg(tx_dev_offset+TX_HDCP_CONFIG3, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= hdcp_on << 7; // [7] cp_desired 
-    tmp_add_data |= 1       << 6; // [6] ess_config 
-    tmp_add_data |= 0       << 5; // [5] set_avmute 
-    tmp_add_data |= 0       << 4; // [4] clear_avmute 
-    tmp_add_data |= 1       << 3; // [3] hdcp_1_1 
-    tmp_add_data |= 0       << 2; // [2] forced_polarity 
-    tmp_add_data |= 0       << 1; // [1] forced_vsync_polarity 
-    tmp_add_data |= 0       << 0; // [0] forced_hsync_polarity
-    hdmi_wr_reg(tx_dev_offset+TX_HDCP_MODE, tmp_add_data); // 0xc8
-    
-    // Release TX out of reset
-    hdmi_wr_reg(tx_dev_offset+TX_SYS5_TX_SOFT_RESET_1, 0x0);
-    hdmi_wr_reg(tx_dev_offset+TX_SYS5_TX_SOFT_RESET_2, 0x0);
-} /* hdmitx_test_function */
-
diff --git a/drivers/amlogic/tvin/hdmirx/test/hdmi.h b/drivers/amlogic/tvin/hdmirx/test/hdmi.h
deleted file mode 100644
index d0c7295d74ea..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/hdmi.h
+++ /dev/null
@@ -1,98 +0,0 @@
-#ifndef HDMI_H
-#define HDMI_H
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-//#include <linux/amports/canvas.h>
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <mach/regs.h>
-#include <mach/clock.h>
-#include <mach/register.h>
-#include <mach/power_gate.h>
-
-#define stimulus_print printk
-#define stimulus_finish_fail(a)
-
-#define HDMI_ADDR_PORT   0xc8002000
-#define HDMI_DATA_PORT   0xc8002004
-#define HDMI_CTRL_PORT   0xc8002008
-
-// Use the following functions to access the on-chip HDMI modules by default
-extern void hdmi_wr_reg(unsigned long addr, unsigned long data);
-extern void hdmi_wr_only_reg(unsigned long addr, unsigned long data);
-extern unsigned long hdmi_rd_reg(unsigned long addr);
-extern void hdmi_rd_check_reg(unsigned long addr, unsigned long exp_data, unsigned long mask);
-extern void hdmi_poll_reg(unsigned long addr, unsigned long exp_data, unsigned long mask);
-
-// Use the following functions to access the off-chip HDMI modules by default, input address the same as on-chip HDMI's,
-// the regisers accessed by these functions only exist in a simulation environment.
-extern void ext_hdmi_wr_reg(unsigned long addr, unsigned long data);
-extern void ext_hdmi_wr_only_reg(unsigned long addr, unsigned long data);
-extern unsigned long ext_hdmi_rd_reg(unsigned long addr);
-extern void ext_hdmi_rd_check_reg(unsigned long addr, unsigned long exp_data, unsigned long mask);
-extern void ext_hdmi_poll_reg(unsigned long addr, unsigned long exp_data, unsigned long mask);
-
-extern void set_hdmi_audio_source (unsigned int src);
-
-extern void hdmitx_test_function (  unsigned long   tx_dev_offset,          // 0x00000: Internal TX; 0x10000: External TX.
-                                    unsigned char   hdcp_on,
-                                    unsigned char   vic,                    // Video format identification code
-                                    unsigned char   mode_3d,                // 0=2D; 1=3D frame-packing; 2=3D side-by-side; 3=3D top-and-bottom.
-                                    unsigned char   pixel_repeat_hdmi,
-                                    unsigned char   tx_input_color_depth,   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                                    unsigned char   tx_input_color_format,  // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-                                    unsigned char   tx_input_color_range,   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-                                    unsigned char   tx_output_color_depth,  // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                                    unsigned char   tx_output_color_format, // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-                                    unsigned char   tx_output_color_range,  // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-                                    unsigned char   tx_i2s_spdif,           // 0=SPDIF; 1=I2S. Note: Must select I2S if CHIP_HAVE_HDMI_RX is defined.
-                                    unsigned char   tx_i2s_8_channel,       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
-                                    unsigned char   audio_packet_type);     // 0=audio sample packet; 1=one bit audio; 2=HBR audio packet; 3=DST audio packet.
-
-// Internal functions:
-void hdmi_tx_key_setting (unsigned long tx_dev_offset);
-
-//------------------------------------------------------------------------------
-// Defines to communicate from C code to verilog world
-//------------------------------------------------------------------------------
-
-#define STIMULUS_HDMI_UTIL_SET_VIC                  0x01000000
-#define STIMULUS_HDMI_UTIL_SET_HSYNC_0              0x02000000
-#define STIMULUS_HDMI_UTIL_SET_HSYNC_1              0x03000000
-#define STIMULUS_HDMI_UTIL_SET_VSYNC_0              0x04000000
-#define STIMULUS_HDMI_UTIL_SET_VSYNC_1              0x05000000
-#define STIMULUS_HDMI_UTIL_SET_HV_TOTAL             0x06000000
-#define STIMULUS_HDMI_UTIL_VANLYZ_RESET             0x07000000
-#define STIMULUS_HDMI_UTIL_AANLYZ_EN                0x08000000
-#define STIMULUS_HDMI_UTIL_SEL_RX_PORT              0x09000000
-#define STIMULUS_HDMI_UTIL_SET_TOTAL_FRAMES         0x0a000000
-#define STIMULUS_HDMI_UTIL_VGEN_RESET               0x0b000000
-#define STIMULUS_HDMI_UTIL_AGEN_CTRL                0x0c000000
-#define STIMULUS_HDMI_UTIL_AGEN_ENABLE              0x0d000000
-#define STIMULUS_HDMI_UTIL_AIU_ANLYZ_EN             0x0e000000
-#define STIMULUS_HDMI_UTIL_CEC1_CHK_REG_RD          0x0f000000
-#define STIMULUS_HDMI_UTIL_AGEN_CTRL_2              0x10000000
-#define STIMULUS_HDMI_UTIL_INVERT_HPD               0x11000000
-#define STIMULUS_HDMI_UTIL_INIT_FIELD_NUM           0x12000000
-#define STIMULUS_HDMI_UTIL_CALC_PLL_CONFIG          0x13000000
-#define STIMULUS_HDMI_UTIL_VID_FORMAT               0x14000000
-#define STIMULUS_HDMI_UTIL_ARCTX_MODE               0x15000000
-#define STIMULUS_HDMI_UTIL_CHECK_HPD                0x16000000
-#define STIMULUS_HDMI_UTIL_AOCEC_CHK_PARAM          0x17000000
-
-#define STIMULUS_EVENT_EXT_HDMI_TX_PLL              30
-
-#endif
diff --git a/drivers/amlogic/tvin/hdmirx/test/hdmi_parameter.h b/drivers/amlogic/tvin/hdmirx/test/hdmi_parameter.h
deleted file mode 100644
index f40221827023..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/hdmi_parameter.h
+++ /dev/null
@@ -1,878 +0,0 @@
-#ifndef  HDMI_PARAMETER_DEFINE_H
-#define  HDMI_PARAMETER_DEFINE_H
-
-//inside chip
-// tx base addr  : 0x00000 ~ 0x03fff
-// rx base addr  : 0x04000 ~ 0x07fff
-// other base addr : 0x08000 ~ 0x0bfff
-// cec0 base addr : 0x0c000 ~ 0x0c0ff
-//external module
-// tx base addr  : 0x10000 ~ 0x13fff
-// rx base addr  : 0x14000 ~ 0x17fff
-// sim base addr : 0x18000 ~ 0x1bfff
-// cec0 base addr : 0x1c000 ~ 0x1c0ff
-// cec1 base addr : 0x1c100 ~ 0x1c1ff
-
-#define TX_BASE_ADDR                0x00000 // Base address for on-chip HDMI TX
-#define RX_BASE_ADDR                0x04000 // Base address for on-chip HDMI RX
-
-#define EXT_HDMI_TRX_ADDR_OFFSET    0x10000 // For simulation only: add the offset for accessing off-chip HDMI TX and/or RX
-
-//#ifdef STIMULUS_HAVE_HDMI_TX
-//#define TX_BASE_ADDR     0x10000        //outside chip
-//#else
-//#define TX_BASE_ADDR     0x00000        //inside chip
-//#endif
-//
-//#ifdef STIMULUS_HAVE_HDMI_RX
-//#define RX_BASE_ADDR     0x14000        //outside chip
-//#else
-//#define RX_BASE_ADDR     0x04000        //inside chip
-//#endif
-
-#define SIM_BASE_ADDR    0x18000        //outside chip 
-#define CEC0_BASE_ADDR    0x0c000       //inside chip 
-#define CEC1_BASE_ADDR    0x1c100       //outside chip 
-
-#define OTHER_BASE_ADDR  0x08000        //inside chip
-
-//********** OTHER BASE related **********//
-#define HDMI_OTHER_CTRL0                    0x0
-#define HDMI_OTHER_CTRL1                    0x1
-#define HDMI_OTHER_STATUS0                  0x2
-#define HDMI_OTHER_CTRL2                    0x3
-#define HDMI_OTHER_INTR_MASKN               0x4
-#define HDMI_OTHER_INTR_STAT                0x5
-#define HDMI_OTHER_INTR_STAT_CLR            0x6
-// Reserved                                 0x7
-#define HDMI_OTHER_AVI_INTR_MASKN0          0x8
-#define HDMI_OTHER_AVI_INTR_MASKN1          0x9
-#define HDMI_OTHER_RX_AINFO_INTR_MASKN0     0xa
-#define HDMI_OTHER_RX_AINFO_INTR_MASKN1     0xb
-#define HDMI_OTHER_RX_PACKET_INTR_CLR       0xc
-
-//********** TX related **********//
-#define TX_HDCP_DKEY_OFFSET             TX_BASE_ADDR+0x400 
-#define TX_RX_EDID_OFFSET               TX_BASE_ADDR+0x600 
-#define TX_HDCP_SHADOW_OFFSET           TX_BASE_ADDR+0x100 
-
-#define TX_IEC60958_SUB1_OFFSET         TX_BASE_ADDR+0x0B0 
-#define TX_IEC60958_SUB2_OFFSET         TX_BASE_ADDR+0x0C8 
-
-#define TX_IEC60958_ST_SUB1_OFFSET      TX_BASE_ADDR+0x1B0 
-#define TX_IEC60958_ST_SUB2_OFFSET      TX_BASE_ADDR+0x1C8 
-
-// System config 0
-#define TX_SYS0_AFE_SIGNAL        TX_BASE_ADDR+0x000 
-#define TX_SYS0_AFE_LOOP          TX_BASE_ADDR+0x001 
-#define TX_SYS0_ACR_CTS_0         TX_BASE_ADDR+0x002 
-#define TX_SYS0_ACR_CTS_1         TX_BASE_ADDR+0x003 
-#define TX_SYS0_ACR_CTS_2         TX_BASE_ADDR+0x004 
-#define TX_SYS0_BIST_CONTROL      TX_BASE_ADDR+0x005 
-#define TX_SYS0_BIST_DATA_0       TX_BASE_ADDR+0x006 
-#define TX_SYS0_BIST_DATA_1       TX_BASE_ADDR+0x007 
-#define TX_SYS0_BIST_DATA_2       TX_BASE_ADDR+0x008 
-#define TX_SYS0_BIST_DATA_3       TX_BASE_ADDR+0x009 
-#define TX_SYS0_BIST_DATA_4       TX_BASE_ADDR+0x00A 
-#define TX_SYS0_BIST_DATA_5       TX_BASE_ADDR+0x00B 
-#define TX_SYS0_BIST_DATA_6       TX_BASE_ADDR+0x00C 
-#define TX_SYS0_BIST_DATA_7       TX_BASE_ADDR+0x00D 
-#define TX_SYS0_BIST_DATA_8       TX_BASE_ADDR+0x00E 
-#define TX_SYS0_BIST_DATA_9       TX_BASE_ADDR+0x00F 
-// system config 1
-// Pre-M6: #define TX_SYS1_PRE_EMPHASIS      TX_BASE_ADDR+0x010 
-// Pre-M6: #define TX_SYS1_TERMINATION       TX_BASE_ADDR+0x011 
-// Pre-M6: #define TX_SYS1_AFE_SPARE0        TX_BASE_ADDR+0x012 
-// Pre-M6: #define TX_SYS1_AFE_SPARE1        TX_BASE_ADDR+0x013 
-// Pre-M6: #define TX_SYS1_BANDGAP           TX_BASE_ADDR+0x014 
-// Pre-M6: #define TX_SYS1_BIAS              TX_BASE_ADDR+0x015 
-// Pre-M6: #define TX_SYS1_AFE_RESET         TX_BASE_ADDR+0x016 
-// Pre-M6: #define TX_SYS1_AFE_TEST          TX_BASE_ADDR+0x017 
-// Pre-M6: #define TX_SYS1_PLL               TX_BASE_ADDR+0x018 
-// Pre-M6: #define TX_SYS1_TUNE              TX_BASE_ADDR+0x019 
-// Pre-M6: #define TX_SYS1_AFE_CONNECT       TX_BASE_ADDR+0x01A 
-// Pre-M6: #define TX_AFE_GENERAL            TX_BASE_ADDR+0x01B 
-#define TX_PHY_CONFIG0            TX_BASE_ADDR+0x010 
-#define TX_PHY_CONFIG1            TX_BASE_ADDR+0x011 
-#define TX_PHY_CONFIG2            TX_BASE_ADDR+0x012 
-#define TX_PHY_CONFIG3            TX_BASE_ADDR+0x013 
-#define TX_PHY_CONFIG4            TX_BASE_ADDR+0x014 
-#define TX_PHY_CONFIG5            TX_BASE_ADDR+0x015 
-#define TX_PHY_CONFIG6            TX_BASE_ADDR+0x016 
-#define TX_PHY_CONFIG7            TX_BASE_ADDR+0x017 
-
-#define TX_SYS1_ACR_N_0           TX_BASE_ADDR+0x01C 
-#define TX_SYS1_ACR_N_1           TX_BASE_ADDR+0x01D 
-#define TX_SYS1_ACR_N_2           TX_BASE_ADDR+0x01E 
-#define TX_SYS1_PRBS_DATA         TX_BASE_ADDR+0x01F 
-// system config 4
-#define TX_SYS4_TX_CKI_DDR        TX_BASE_ADDR+0x0A0 
-#define TX_SYS4_TX_CKO_DDR        TX_BASE_ADDR+0x0A1 
-#define TX_SYS4_RX_CKI_DDR        TX_BASE_ADDR+0x0A2 
-#define TX_SYS4_RX_CKO_DDR        TX_BASE_ADDR+0x0A3 
-#define TX_SYS4_CONNECT_SEL_0     TX_BASE_ADDR+0x0A4 
-#define TX_SYS4_CONNECT_SEL_1     TX_BASE_ADDR+0x0A5 
-#define TX_SYS4_CONNECT_SEL_2     TX_BASE_ADDR+0x0A6 
-#define TX_SYS4_CONNECT_SEL_3     TX_BASE_ADDR+0x0A7 
-#define TX_SYS4_CK_INV_VIDEO      TX_BASE_ADDR+0x0A8 
-#define TX_SYS4_CK_INV_AUDIO      TX_BASE_ADDR+0x0A9 
-#define TX_SYS4_CK_INV_AFE        TX_BASE_ADDR+0x0AA 
-#define TX_SYS4_CK_INV_CH01       TX_BASE_ADDR+0x0AB 
-#define TX_SYS4_CK_INV_CH2        TX_BASE_ADDR+0x0AC 
-#define TX_SYS4_CK_CEC            TX_BASE_ADDR+0x0AD 
-#define TX_SYS4_CK_SOURCE_1       TX_BASE_ADDR+0x0AE 
-#define TX_SYS4_CK_SOURCE_2       TX_BASE_ADDR+0x0AF 
-// system config 5
-#define TX_SYS5_TX_SOFT_RESET_1   TX_BASE_ADDR+0x0E0 
-#define TX_SYS5_TX_SOFT_RESET_2   TX_BASE_ADDR+0x0E1 
-#define TX_SYS5_RX_SOFT_RESET_1   TX_BASE_ADDR+0x0E2 
-#define TX_SYS5_RX_SOFT_RESET_2   TX_BASE_ADDR+0x0E3 
-#define TX_SYS5_RX_SOFT_RESET_3   TX_BASE_ADDR+0x0E4 
-#define TX_SYS5_SSTL_BIDIR_IN     TX_BASE_ADDR+0x0E5 
-#define TX_SYS5_SSTL_IN           TX_BASE_ADDR+0x0E6 
-#define TX_SYS5_SSTL_DIFF_IN      TX_BASE_ADDR+0x0E7 
-#define TX_SYS5_FIFO_CONFIG       TX_BASE_ADDR+0x0E8 
-#define TX_SYS5_FIFO_SAMP01_CFG   TX_BASE_ADDR+0x0E9 
-#define TX_SYS5_FIFO_SAMP23_CFG   TX_BASE_ADDR+0x0EA 
-#define TX_SYS5_CONNECT_FIFO_CFG  TX_BASE_ADDR+0x0EB 
-#define TX_SYS5_IO_CALIB_CONTROL  TX_BASE_ADDR+0x0EC 
-#define TX_SYS5_SSTL_BIDIR_OUT    TX_BASE_ADDR+0x0ED 
-#define TX_SYS5_SSTL_OUT          TX_BASE_ADDR+0x0EE 
-#define TX_SYS5_SSTL_DIFF_OUT     TX_BASE_ADDR+0x0EF 
-
-// HDCP CONFIG
-#define TX_HDCP_ECC_CONFIG        TX_BASE_ADDR+0x024 
-#define TX_HDCP_CRC_CONFIG        TX_BASE_ADDR+0x025 
-#define TX_HDCP_EDID_CONFIG       TX_BASE_ADDR+0x026 
-#define TX_HDCP_MEM_CONFIG        TX_BASE_ADDR+0x027 
-#define TX_HDCP_HPD_FILTER_L      TX_BASE_ADDR+0x028 
-#define TX_HDCP_HPD_FILTER_H      TX_BASE_ADDR+0x029 
-#define TX_HDCP_ENCRYPT_BYTE      TX_BASE_ADDR+0x02A 
-#define TX_HDCP_CONFIG0           TX_BASE_ADDR+0x02B 
-#define TX_HDCP_CONFIG1           TX_BASE_ADDR+0x02C 
-#define TX_HDCP_CONFIG2           TX_BASE_ADDR+0x02D 
-#define TX_HDCP_CONFIG3           TX_BASE_ADDR+0x02E 
-#define TX_HDCP_MODE              TX_BASE_ADDR+0x02F 
-
-// Video config, part 1
-#define TX_VIDEO_ACTIVE_PIXELS_0  TX_BASE_ADDR+0x030 
-#define TX_VIDEO_ACTIVE_PIXELS_1  TX_BASE_ADDR+0x031 
-#define TX_VIDEO_FRONT_PIXELS     TX_BASE_ADDR+0x032 
-#define TX_VIDEO_HSYNC_PIXELS     TX_BASE_ADDR+0x033 
-#define TX_VIDEO_BACK_PIXELS      TX_BASE_ADDR+0x034 
-#define TX_VIDEO_ACTIVE_LINES_0   TX_BASE_ADDR+0x035 
-#define TX_VIDEO_ACTIVE_LINES_1   TX_BASE_ADDR+0x036 
-#define TX_VIDEO_EOF_LINES        TX_BASE_ADDR+0x037 
-#define TX_VIDEO_VSYNC_LINES      TX_BASE_ADDR+0x038 
-#define TX_VIDEO_SOF_LINES        TX_BASE_ADDR+0x039 
-#define TX_VIDEO_DTV_TIMING       TX_BASE_ADDR+0x03A 
-#define TX_VIDEO_DTV_MODE         TX_BASE_ADDR+0x03B 
-#define TX_VIDEO_DTV_FORMAT0      TX_BASE_ADDR+0x03C 
-#define TX_VIDEO_DTV_FORMAT1      TX_BASE_ADDR+0x03D 
-#define TX_VIDEO_PIXEL_PACK       TX_BASE_ADDR+0x03F 
-// video config, part 2
-#define TX_VIDEO_CSC_COEFF_B0     TX_BASE_ADDR+0x040 
-#define TX_VIDEO_CSC_COEFF_B1     TX_BASE_ADDR+0x041 
-#define TX_VIDEO_CSC_COEFF_R0     TX_BASE_ADDR+0x042 
-#define TX_VIDEO_CSC_COEFF_R1     TX_BASE_ADDR+0x043 
-#define TX_VIDEO_CSC_COEFF_CB0    TX_BASE_ADDR+0x044 
-#define TX_VIDEO_CSC_COEFF_CB1    TX_BASE_ADDR+0x045 
-#define TX_VIDEO_CSC_COEFF_CR0    TX_BASE_ADDR+0x046 
-#define TX_VIDEO_CSC_COEFF_CR1    TX_BASE_ADDR+0x047 
-#define TX_VIDEO_DTV_OPTION_L     TX_BASE_ADDR+0x048 
-#define TX_VIDEO_DTV_OPTION_H     TX_BASE_ADDR+0x049 
-#define TX_VIDEO_DTV_FILTER       TX_BASE_ADDR+0x04A 
-#define TX_VIDEO_DTV_DITHER       TX_BASE_ADDR+0x04B 
-#define TX_VIDEO_DTV_DEDITHER     TX_BASE_ADDR+0x04C 
-#define TX_VIDEO_PROC_CONFIG0     TX_BASE_ADDR+0x04E 
-#define TX_VIDEO_PROC_CONFIG1     TX_BASE_ADDR+0x04F 
-
-// Audio config
-#define TX_AUDIO_FORMAT           TX_BASE_ADDR+0x058 
-#define TX_AUDIO_SPDIF            TX_BASE_ADDR+0x059 
-#define TX_AUDIO_I2S              TX_BASE_ADDR+0x05A 
-#define TX_AUDIO_FIFO             TX_BASE_ADDR+0x05B 
-#define TX_AUDIO_LIPSYNC          TX_BASE_ADDR+0x05C 
-#define TX_AUDIO_CONTROL          TX_BASE_ADDR+0x05D 
-#define TX_AUDIO_HEADER           TX_BASE_ADDR+0x05E 
-#define TX_AUDIO_SAMPLE           TX_BASE_ADDR+0x05F 
-#define TX_AUDIO_VALID            TX_BASE_ADDR+0x060 
-#define TX_AUDIO_USER             TX_BASE_ADDR+0x061 
-#define TX_AUDIO_PACK             TX_BASE_ADDR+0x062 
-#define TX_AUDIO_CLOCK_METER      TX_BASE_ADDR+0x063
-#define TX_AUDIO_CONTROL_MORE     TX_BASE_ADDR+0x064
-
-// tmds config
-#define TX_TMDS_MODE              TX_BASE_ADDR+0x068 
-#define TX_TMDS_CONFIG0           TX_BASE_ADDR+0x06C 
-#define TX_TMDS_CONFIG1           TX_BASE_ADDR+0x06D 
-
-// packet config
-#define TX_PACKET_ALLOC_ACTIVE_1  TX_BASE_ADDR+0x078 
-#define TX_PACKET_ALLOC_ACTIVE_2  TX_BASE_ADDR+0x079 
-#define TX_PACKET_ALLOC_EOF_1     TX_BASE_ADDR+0x07A 
-#define TX_PACKET_ALLOC_EOF_2     TX_BASE_ADDR+0x07B 
-#define TX_PACKET_ALLOC_SOF_1     TX_BASE_ADDR+0x07C 
-#define TX_PACKET_ALLOC_SOF_2     TX_BASE_ADDR+0x07D 
-#define TX_PACKET_CONTROL_1       TX_BASE_ADDR+0x07E 
-#define TX_PACKET_CONTROL_2       TX_BASE_ADDR+0x07F 
-
-#define TX_EDID_CONFIG_MORE       TX_BASE_ADDR+0x080
-
-// core config
-#define TX_CORE_DATA_CAPTURE_1    TX_BASE_ADDR+0x0F0 
-#define TX_CORE_DATA_CAPTURE_2    TX_BASE_ADDR+0x0F1 
-#define TX_CORE_DATA_MONITOR_1    TX_BASE_ADDR+0x0F2 
-#define TX_CORE_DATA_MONITOR_2    TX_BASE_ADDR+0x0F3 
-#define TX_CORE_CALIB_MODE        TX_BASE_ADDR+0x0F4 
-#define TX_CORE_CALIB_SAMPLE_DELAY  TX_BASE_ADDR+0x0F5 
-#define TX_CORE_CALIB_VALUE_AUTO  TX_BASE_ADDR+0x0F6 
-#define TX_CORE_CALIB_VALUE       TX_BASE_ADDR+0x0F7 
-
-// HDCP shadow register
-#define TX_HDCP_SHW_BKSV_0        TX_BASE_ADDR+0x100 
-#define TX_HDCP_SHW_BKSV_1        TX_BASE_ADDR+0x101 
-#define TX_HDCP_SHW_BKSV_2        TX_BASE_ADDR+0x102 
-#define TX_HDCP_SHW_BKSV_3        TX_BASE_ADDR+0x103 
-#define TX_HDCP_SHW_BKSV_4        TX_BASE_ADDR+0x104 
-#define TX_HDCP_SHW_RI1_0         TX_BASE_ADDR+0x108 
-#define TX_HDCP_SHW_RI1_1         TX_BASE_ADDR+0x109 
-#define TX_HDCP_SHW_PJ1           TX_BASE_ADDR+0x10A 
-#define TX_HDCP_SHW_AKSV_0        TX_BASE_ADDR+0x110 
-#define TX_HDCP_SHW_AKSV_1        TX_BASE_ADDR+0x111 
-#define TX_HDCP_SHW_AKSV_2        TX_BASE_ADDR+0x112 
-#define TX_HDCP_SHW_AKSV_3        TX_BASE_ADDR+0x113 
-#define TX_HDCP_SHW_AKSV_4        TX_BASE_ADDR+0x114 
-#define TX_HDCP_SHW_AINFO         TX_BASE_ADDR+0x115 
-#define TX_HDCP_SHW_AN_0          TX_BASE_ADDR+0x118 
-#define TX_HDCP_SHW_AN_1          TX_BASE_ADDR+0x119 
-#define TX_HDCP_SHW_AN_2          TX_BASE_ADDR+0x11A 
-#define TX_HDCP_SHW_AN_3          TX_BASE_ADDR+0x11B 
-#define TX_HDCP_SHW_AN_4          TX_BASE_ADDR+0x11C 
-#define TX_HDCP_SHW_AN_5          TX_BASE_ADDR+0x11D 
-#define TX_HDCP_SHW_AN_6          TX_BASE_ADDR+0x11E 
-#define TX_HDCP_SHW_AN_7          TX_BASE_ADDR+0x11F 
-#define TX_HDCP_SHW_V1_H0_0       TX_BASE_ADDR+0x120 
-#define TX_HDCP_SHW_V1_H0_1       TX_BASE_ADDR+0x121 
-#define TX_HDCP_SHW_V1_H0_2       TX_BASE_ADDR+0x122 
-#define TX_HDCP_SHW_V1_H0_3       TX_BASE_ADDR+0x123 
-#define TX_HDCP_SHW_V1_H1_0       TX_BASE_ADDR+0x124 
-#define TX_HDCP_SHW_V1_H1_1       TX_BASE_ADDR+0x125 
-#define TX_HDCP_SHW_V1_H1_2       TX_BASE_ADDR+0x126 
-#define TX_HDCP_SHW_V1_H1_3       TX_BASE_ADDR+0x127 
-#define TX_HDCP_SHW_V1_H2_0       TX_BASE_ADDR+0x128 
-#define TX_HDCP_SHW_V1_H2_1       TX_BASE_ADDR+0x129 
-#define TX_HDCP_SHW_V1_H2_2       TX_BASE_ADDR+0x12A 
-#define TX_HDCP_SHW_V1_H2_3       TX_BASE_ADDR+0x12B 
-#define TX_HDCP_SHW_V1_H3_0       TX_BASE_ADDR+0x12C 
-#define TX_HDCP_SHW_V1_H3_1       TX_BASE_ADDR+0x12D 
-#define TX_HDCP_SHW_V1_H3_2       TX_BASE_ADDR+0x12E 
-#define TX_HDCP_SHW_V1_H3_3       TX_BASE_ADDR+0x12F 
-#define TX_HDCP_SHW_V1_H4_0       TX_BASE_ADDR+0x130 
-#define TX_HDCP_SHW_V1_H4_1       TX_BASE_ADDR+0x131 
-#define TX_HDCP_SHW_V1_H4_2       TX_BASE_ADDR+0x132 
-#define TX_HDCP_SHW_V1_H4_3       TX_BASE_ADDR+0x133 
-#define TX_HDCP_SHW_BCAPS         TX_BASE_ADDR+0x140 
-#define TX_HDCP_SHW_BSTATUS_0     TX_BASE_ADDR+0x141 
-#define TX_HDCP_SHW_BSTATUS_1     TX_BASE_ADDR+0x142 
-#define TX_HDCP_SHW_KSV_FIFO      TX_BASE_ADDR+0x143 
-
-// system status 0
-#define TX_SYSST0_CONNECT_FIFO    TX_BASE_ADDR+0x180 
-#define TX_SYSST0_PLL_MONITOR     TX_BASE_ADDR+0x181 
-#define TX_SYSST0_AFE_FIFO        TX_BASE_ADDR+0x182 
-#define TX_SYSST0_ROM_STATUS      TX_BASE_ADDR+0x18F 
-
-// system status 1
-#define TX_SYSST1_CALIB_BIT_RESULT_0     TX_BASE_ADDR+0x1E0 
-#define TX_SYSST1_CALIB_BIT_RESULT_1     TX_BASE_ADDR+0x1E1 
-#define TX_SYSST1_CALIB_BIT_RESULT_2     TX_BASE_ADDR+0x1E2 
-#define TX_SYSST1_CALIB_BIT_RESULT_3     TX_BASE_ADDR+0x1E3 
-#define TX_SYSST1_CALIB_BIT_RESULT_4     TX_BASE_ADDR+0x1E4 
-#define TX_SYSST1_CALIB_BIT_RESULT_5     TX_BASE_ADDR+0x1E5 
-#define TX_SYSST1_CALIB_BIT_RESULT_6     TX_BASE_ADDR+0x1E6 
-#define TX_SYSST1_CALIB_BIT_RESULT_7     TX_BASE_ADDR+0x1E7 
-#define TX_SYSST1_CALIB_BUS_RESULT_0     TX_BASE_ADDR+0x1E8 
-#define TX_SYSST1_CALIB_BUS_RESULT_1     TX_BASE_ADDR+0x1E9 
-#define TX_SYSST1_CALIB_BUS_RESULT_2     TX_BASE_ADDR+0x1EA 
-#define TX_SYSST1_CALIB_BUS_RESULT_3     TX_BASE_ADDR+0x1EB 
-#define TX_SYSST1_CALIB_BUS_RESULT_4     TX_BASE_ADDR+0x1EC 
-#define TX_SYSST1_CALIB_BUS_RESULT_5     TX_BASE_ADDR+0x1ED 
-#define TX_SYSST1_CALIB_BUS_RESULT_6     TX_BASE_ADDR+0x1EE 
-#define TX_SYSST1_CALIB_BUS_RESULT_7     TX_BASE_ADDR+0x1EF 
-
-// hdcp status
-#define TX_HDCP_ST_AUTHENTICATION        TX_BASE_ADDR+0x190 
-#define TX_HDCP_ST_FRAME_COUNT           TX_BASE_ADDR+0x191 
-#define TX_HDCP_ST_STATUS_0              TX_BASE_ADDR+0x192 
-#define TX_HDCP_ST_STATUS_1              TX_BASE_ADDR+0x193 
-#define TX_HDCP_ST_STATUS_2              TX_BASE_ADDR+0x194 
-#define TX_HDCP_ST_STATUS_3              TX_BASE_ADDR+0x195 
-#define TX_HDCP_ST_EDID_STATUS           TX_BASE_ADDR+0x196 
-#define TX_HDCP_ST_MEM_STATUS            TX_BASE_ADDR+0x197 
-#define TX_HDCP_ST_ST_MODE               TX_BASE_ADDR+0x19F 
-
-// video status
-#define TX_VIDEO_ST_ACTIVE_PIXELS_1      TX_BASE_ADDR+0x1A0 
-#define TX_VIDEO_ST_ACTIVE_PIXELS_2      TX_BASE_ADDR+0x1A1 
-#define TX_VIDEO_ST_FRONT_PIXELS         TX_BASE_ADDR+0x1A2 
-#define TX_VIDEO_ST_HSYNC_PIXELS         TX_BASE_ADDR+0x1A3 
-#define TX_VIDEO_ST_BACK_PIXELS          TX_BASE_ADDR+0x1A4 
-#define TX_VIDEO_ST_ACTIVE_LINES_1       TX_BASE_ADDR+0x1A5 
-#define TX_VIDEO_ST_ACTIVE_LINES_2       TX_BASE_ADDR+0x1A6 
-#define TX_VIDEO_ST_EOF_LINES            TX_BASE_ADDR+0x1A7 
-#define TX_VIDEO_ST_VSYNC_LINES          TX_BASE_ADDR+0x1A8 
-#define TX_VIDEO_ST_SOF_LINES            TX_BASE_ADDR+0x1A9 
-#define TX_VIDEO_ST_DTV_TIMING           TX_BASE_ADDR+0x1AA 
-#define TX_VIDEO_ST_DTV_MODE             TX_BASE_ADDR+0x1AB 
-// audio status
-#define TX_VIDEO_ST_AUDIO_STATUS         TX_BASE_ADDR+0x1AC 
-#define TX_AFE_STATUS_0                  TX_BASE_ADDR+0x1AE 
-#define TX_AFE_STATUS_1                  TX_BASE_ADDR+0x1AF 
-
-// Packet status
-#define TX_PACKET_ST_REQUEST_STATUS_1    TX_BASE_ADDR+0x1F0 
-#define TX_PACKET_ST_REQUEST_STATUS_2    TX_BASE_ADDR+0x1F1 
-#define TX_PACKET_ST_REQUEST_MISSED_1    TX_BASE_ADDR+0x1F2 
-#define TX_PACKET_ST_REQUEST_MISSED_2    TX_BASE_ADDR+0x1F3 
-#define TX_PACKET_ST_ENCODE_STATUS_0     TX_BASE_ADDR+0x1F4 
-#define TX_PACKET_ST_ENCODE_STATUS_1     TX_BASE_ADDR+0x1F5 
-#define TX_PACKET_ST_ENCODE_STATUS_2     TX_BASE_ADDR+0x1F6 
-#define TX_PACKET_ST_TIMER_STATUS        TX_BASE_ADDR+0x1F7 
-
-// tmds status
-#define TX_TMDS_ST_CLOCK_METER_1         TX_BASE_ADDR+0x1F8 
-#define TX_TMDS_ST_CLOCK_METER_2         TX_BASE_ADDR+0x1F9 
-#define TX_TMDS_ST_CLOCK_METER_3         TX_BASE_ADDR+0x1FA 
-#define TX_TMDS_ST_TMDS_STATUS_1         TX_BASE_ADDR+0x1FC 
-#define TX_TMDS_ST_TMDS_STATUS_2         TX_BASE_ADDR+0x1FD 
-#define TX_TMDS_ST_TMDS_STATUS_3         TX_BASE_ADDR+0x1FE 
-#define TX_TMDS_ST_TMDS_STATUS_4         TX_BASE_ADDR+0x1FF 
-
-
-// Packet register
-#define TX_PKT_REG_SPD_INFO_BASE_ADDR     TX_BASE_ADDR+0x200 
-#define TX_PKT_REG_VEND_INFO_BASE_ADDR    TX_BASE_ADDR+0x220 
-#define TX_PKT_REG_MPEG_INFO_BASE_ADDR    TX_BASE_ADDR+0x240 
-#define TX_PKT_REG_AVI_INFO_BASE_ADDR     TX_BASE_ADDR+0x260 
-#define TX_PKT_REG_AUDIO_INFO_BASE_ADDR   TX_BASE_ADDR+0x280 
-#define TX_PKT_REG_ACP_INFO_BASE_ADDR     TX_BASE_ADDR+0x2A0 
-#define TX_PKT_REG_ISRC1_BASE_ADDR        TX_BASE_ADDR+0x2C0 
-#define TX_PKT_REG_ISRC2_BASE_ADDR        TX_BASE_ADDR+0x2E0 
-#define TX_PKT_REG_EXCEPT0_BASE_ADDR      TX_BASE_ADDR+0x300 
-#define TX_PKT_REG_EXCEPT1_BASE_ADDR      TX_BASE_ADDR+0x320 
-#define TX_PKT_REG_EXCEPT2_BASE_ADDR      TX_BASE_ADDR+0x340 
-#define TX_PKT_REG_EXCEPT3_BASE_ADDR      TX_BASE_ADDR+0x360 
-#define TX_PKT_REG_EXCEPT4_BASE_ADDR      TX_BASE_ADDR+0x380 
-#define TX_PKT_REG_GAMUT_P0_BASE_ADDR     TX_BASE_ADDR+0x3A0 
-#define TX_PKT_REG_GAMUT_P1_1_BASE_ADDR   TX_BASE_ADDR+0x3C0 
-#define TX_PKT_REG_GAMUT_P1_2_BASE_ADDR   TX_BASE_ADDR+0x3E0 
-
-
-
-
-
-//************ RX related ************//
-#define RX_HDCP_DKEY_OFFSET             RX_BASE_ADDR+0x400 
-#define RX_EDID_OFFSET                  RX_BASE_ADDR+0x600 
-
-#define RX_IEC60958_SUB1_OFFSET         RX_BASE_ADDR+0x0B0 
-#define RX_IEC60958_SUB2_OFFSET         RX_BASE_ADDR+0x0C8 
-
-#define RX_IEC60958_ST_SUB1_OFFSET      RX_BASE_ADDR+0x1B0 
-#define RX_IEC60958_ST_SUB2_OFFSET      RX_BASE_ADDR+0x1C8 
-
-
-// System config 0
-#define RX_SYS0_CDR_0_1_BYPASS          RX_BASE_ADDR+0x006 
-#define RX_SYS0_CDR_2_3_BYPASS          RX_BASE_ADDR+0x007 
-#define RX_SYS0_EQ_MASK_CH0_0           RX_BASE_ADDR+0x008 
-#define RX_SYS0_EQ_MASK_CH0_1           RX_BASE_ADDR+0x009 
-#define RX_SYS0_EQ_MASK_CH1_0           RX_BASE_ADDR+0x00A 
-#define RX_SYS0_EQ_MASK_CH1_1           RX_BASE_ADDR+0x00B 
-#define RX_SYS0_EQ_MASK_CH2_0           RX_BASE_ADDR+0x00C 
-#define RX_SYS0_EQ_MASK_CH2_1           RX_BASE_ADDR+0x00D 
-#define RX_SYS0_EQ_MASK_CH3_0           RX_BASE_ADDR+0x00E 
-#define RX_SYS0_EQ_MASK_CH3_1           RX_BASE_ADDR+0x00F 
-// System config 1
-#define RX_SYS1_CLOCK_CONTROL_M_EXP_0   RX_BASE_ADDR+0x010 
-#define RX_SYS1_CLOCK_CONTROL_M_EXP_1   RX_BASE_ADDR+0x011 
-#define RX_SYS1_CLOCK_CONTROL_M_EXP_2   RX_BASE_ADDR+0x012 
-#define RX_SYS1_CLOCK_CONTROL_N_EXP_0   RX_BASE_ADDR+0x013 
-#define RX_SYS1_CLOCK_CONTROL_N_EXP_1   RX_BASE_ADDR+0x014 
-#define RX_SYS1_CLOCK_CONTROL_N_EXP_2   RX_BASE_ADDR+0x015 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_0   RX_BASE_ADDR+0x016 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_1   RX_BASE_ADDR+0x017 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_2   RX_BASE_ADDR+0x018 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_3   RX_BASE_ADDR+0x019 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_4   RX_BASE_ADDR+0x01A 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_5   RX_BASE_ADDR+0x01B 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_6   RX_BASE_ADDR+0x01C 
-#define RX_SYS1_CLOCK_CONTROL_TIMER_0   RX_BASE_ADDR+0x01D 
-#define RX_SYS1_CLOCK_CONTROL_TIMER_1   RX_BASE_ADDR+0x01E 
-#define RX_SYS1_CLOCK_CONTROL_FSM       RX_BASE_ADDR+0x01F 
-// system config 2
-#define RX_SYS2_CDR0_BYPASS_CNTRL       RX_BASE_ADDR+0x080 
-#define RX_SYS2_CDR0_EN_CNTRL           RX_BASE_ADDR+0x081 
-#define RX_SYS2_CDR1_BYPASS_CNTRL       RX_BASE_ADDR+0x082 
-#define RX_SYS2_CDR1_EN_CNTRL           RX_BASE_ADDR+0x083 
-#define RX_SYS2_CDR2_BYPASS_CNTRL       RX_BASE_ADDR+0x084 
-#define RX_SYS2_CDR2_EN_CNTRL           RX_BASE_ADDR+0x085 
-#define RX_SYS2_CDR3_BYPASS_CNTRL       RX_BASE_ADDR+0x086 
-#define RX_SYS2_CDR3_EN_CNTRL           RX_BASE_ADDR+0x087 
-#define RX_SYS2_PRBS0_CNTRL             RX_BASE_ADDR+0x088 
-#define RX_SYS2_PRBS1_CNTRL             RX_BASE_ADDR+0x089 
-#define RX_SYS2_PRBS2_CNTRL             RX_BASE_ADDR+0x08A 
-#define RX_SYS2_PRBS3_CNTRL             RX_BASE_ADDR+0x08B 
-#define RX_SYS2_PRBS_ERR_THR            RX_BASE_ADDR+0x08C 
-#define RX_SYS2_PRBS_TIME_WINDOW0       RX_BASE_ADDR+0x08D 
-#define RX_SYS2_PRBS_TIME_WINDOW1       RX_BASE_ADDR+0x08E 
-// system config 3
-#define RX_SYS3_RX_ACR_0                RX_BASE_ADDR+0x09C 
-#define RX_SYS3_RX_ACR_1                RX_BASE_ADDR+0x09D
-// system config 4
-#define RX_SYS4_OSC_EXT_CLK_CNTL_0      RX_BASE_ADDR+0x0AD 
-#define RX_SYS4_OSC_EXT_CLK_CNTL_1      RX_BASE_ADDR+0x0AE 
-
-// HDCP CONFIG
-#define RX_HDCP_I2C_MASTER_CONFIG_0     RX_BASE_ADDR+0x020 
-#define RX_HDCP_I2C_MASTER_CONFIG_1     RX_BASE_ADDR+0x021 
-#define RX_HDCP_I2C_MASTER_CONFIG_2     RX_BASE_ADDR+0x022 
-#define RX_HDCP_ECC_CONFIG              RX_BASE_ADDR+0x024 
-#define RX_HDCP_CRC_CONFIG              RX_BASE_ADDR+0x025 
-#define RX_HDCP_EDID_CONFIG             RX_BASE_ADDR+0x026 
-#define RX_HDCP_MEM_CONFIG              RX_BASE_ADDR+0x027 
-#define RX_HDCP_HPD_FILTER_L            RX_BASE_ADDR+0x028 
-#define RX_HDCP_HPD_FILTER_H            RX_BASE_ADDR+0x029 
-#define RX_HDCP_BCAPS                   RX_BASE_ADDR+0x02A 
-#define RX_HDCP_CONFIG0                 RX_BASE_ADDR+0x02B 
-#define RX_HDCP_CONFIG1                 RX_BASE_ADDR+0x02C 
-#define RX_HDCP_CONFIG2                 RX_BASE_ADDR+0x02D 
-#define RX_HDCP_CONFIG3                 RX_BASE_ADDR+0x02E 
-#define RX_HDCP_MODE                    RX_BASE_ADDR+0x02F 
-
-// Video config, part 1
-#define RX_VIDEO_ACTIVE_PIXELS_0        RX_BASE_ADDR+0x030 
-#define RX_VIDEO_ACTIVE_PIXELS_1        RX_BASE_ADDR+0x031 
-#define RX_VIDEO_FRONT_PIXELS           RX_BASE_ADDR+0x032 
-#define RX_VIDEO_HSYNC_PIXELS           RX_BASE_ADDR+0x033 
-#define RX_VIDEO_BACK_PIXELS            RX_BASE_ADDR+0x034 
-#define RX_VIDEO_ACTIVE_LINES_0         RX_BASE_ADDR+0x035 
-#define RX_VIDEO_ACTIVE_LINES_1         RX_BASE_ADDR+0x036 
-#define RX_VIDEO_EOF_LINES              RX_BASE_ADDR+0x037 
-#define RX_VIDEO_VSYNC_LINES            RX_BASE_ADDR+0x038 
-#define RX_VIDEO_SOF_LINES              RX_BASE_ADDR+0x039 
-#define RX_VIDEO_DTV_TIMING             RX_BASE_ADDR+0x03A 
-#define RX_VIDEO_DTV_MODE               RX_BASE_ADDR+0x03B 
-#define RX_VIDEO_DTV_FORMAT0            RX_BASE_ADDR+0x03C 
-#define RX_VIDEO_DTV_FORMAT1            RX_BASE_ADDR+0x03D 
-#define RX_VIDEO_PIXEL_PACK             RX_BASE_ADDR+0x03F 
-// video config, part 2
-#define RX_VIDEO_CSC_COEFF_B0           RX_BASE_ADDR+0x040 
-#define RX_VIDEO_CSC_COEFF_B1           RX_BASE_ADDR+0x041 
-#define RX_VIDEO_CSC_COEFF_R0           RX_BASE_ADDR+0x042 
-#define RX_VIDEO_CSC_COEFF_R1           RX_BASE_ADDR+0x043 
-#define RX_VIDEO_CSC_COEFF_CB0          RX_BASE_ADDR+0x044 
-#define RX_VIDEO_CSC_COEFF_CB1          RX_BASE_ADDR+0x045 
-#define RX_VIDEO_CSC_COEFF_CR0          RX_BASE_ADDR+0x046 
-#define RX_VIDEO_CSC_COEFF_CR1          RX_BASE_ADDR+0x047 
-#define RX_VIDEO_DTV_OPTION_L           RX_BASE_ADDR+0x048 
-#define RX_VIDEO_DTV_OPTION_H           RX_BASE_ADDR+0x049 
-#define RX_VIDEO_DTV_FILTER             RX_BASE_ADDR+0x04A 
-#define RX_VIDEO_DTV_DITHER             RX_BASE_ADDR+0x04B 
-#define RX_VIDEO_PROC_CONFIG0           RX_BASE_ADDR+0x04E 
-#define RX_VIDEO_PROC_CONFIG1           RX_BASE_ADDR+0x04F 
-
-// Reserved config
-#define RX_AUDIO_EQ_INDEX_CH3           RX_BASE_ADDR+0x056 
-#define RX_AUDIO_EQ_CNTRL_CH3           RX_BASE_ADDR+0x057 
-// VIC and color depth control and interrupts
-#define RX_VIC_COLOR_DEPTH              RX_BASE_ADDR+0x063 
-// Audio config
-#define RX_AUDIO_FORMAT                 RX_BASE_ADDR+0x058 
-#define RX_AUDIO_SPDIF                  RX_BASE_ADDR+0x059 
-#define RX_AUDIO_I2S                    RX_BASE_ADDR+0x05A 
-#define RX_AUDIO_FIFO                   RX_BASE_ADDR+0x05B 
-#define RX_AUDIO_SOFT_MUTE              RX_BASE_ADDR+0x05C 
-#define RX_AUDIO_CONTROL                RX_BASE_ADDR+0x05D 
-#define RX_AUDIO_RSV1                   RX_BASE_ADDR+0x05E 
-#define RX_AUDIO_SAMPLE                 RX_BASE_ADDR+0x05F 
-#define RX_AUDIO_RSV2                   RX_BASE_ADDR+0x060 
-// tmds config
-#define RX_TMDS_MODE                    RX_BASE_ADDR+0x07E 
-#define RX_TMDS_PACKET_CONTROL          RX_BASE_ADDR+0x07F 
-
-// core config
-#define RX_CORE_DATA_CAPTURE_1          RX_BASE_ADDR+0x0F0 
-#define RX_CORE_DATA_CAPTURE_2          RX_BASE_ADDR+0x0F1 
-#define RX_CORE_DATA_MONITOR_1          RX_BASE_ADDR+0x0F2 
-#define RX_CORE_DATA_MONITOR_2          RX_BASE_ADDR+0x0F3 
-#define RX_CORE_CALIB_MODE              RX_BASE_ADDR+0x0F4 
-#define RX_CORE_WAIT_START              RX_BASE_ADDR+0x0F5 
-#define RX_CORE_WAIT_NEXT               RX_BASE_ADDR+0x0F6 
-#define RX_CORE_CALIB_VALUE             RX_BASE_ADDR+0x0F7 
-#define RX_CORE_INTERRUPT_CLEAR_0       RX_BASE_ADDR+0x0F8 
-#define RX_CORE_INTERRUPT_CLEAR_1       RX_BASE_ADDR+0x0F9 
-#define RX_CORE_INTERRUPT_CLEAR_2       RX_BASE_ADDR+0x0FA 
-#define RX_CORE_EQ_INDEX_CH0            RX_BASE_ADDR+0x0FB 
-#define RX_CORE_EQ_INDEX_CH1            RX_BASE_ADDR+0x0FC 
-#define RX_CORE_EQ_INDEX_CH2            RX_BASE_ADDR+0x0FD 
-#define RX_CORE_EQ_CNTRL_0              RX_BASE_ADDR+0x0FE 
-#define RX_CORE_EQ_CNTRL_1              RX_BASE_ADDR+0x0FF 
-// HDCP shadow register
-#define RX_HDCP_SHW_BKSV_0              RX_BASE_ADDR+0x100 
-#define RX_HDCP_SHW_BKSV_1              RX_BASE_ADDR+0x101 
-#define RX_HDCP_SHW_BKSV_2              RX_BASE_ADDR+0x102 
-#define RX_HDCP_SHW_BKSV_3              RX_BASE_ADDR+0x103 
-#define RX_HDCP_SHW_BKSV_4              RX_BASE_ADDR+0x104 
-#define RX_HDCP_SHW_RI1_0               RX_BASE_ADDR+0x108 
-#define RX_HDCP_SHW_RI1_1               RX_BASE_ADDR+0x109 
-#define RX_HDCP_SHW_PJ1                 RX_BASE_ADDR+0x10A 
-#define RX_HDCP_SHW_AKSV_0              RX_BASE_ADDR+0x110 
-#define RX_HDCP_SHW_AKSV_1              RX_BASE_ADDR+0x111 
-#define RX_HDCP_SHW_AKSV_2              RX_BASE_ADDR+0x112 
-#define RX_HDCP_SHW_AKSV_3              RX_BASE_ADDR+0x113 
-#define RX_HDCP_SHW_AKSV_4              RX_BASE_ADDR+0x114 
-#define RX_HDCP_SHW_AINFO               RX_BASE_ADDR+0x115 
-#define RX_HDCP_SHW_AN_0                RX_BASE_ADDR+0x118 
-#define RX_HDCP_SHW_AN_1                RX_BASE_ADDR+0x119 
-#define RX_HDCP_SHW_AN_2                RX_BASE_ADDR+0x11A 
-#define RX_HDCP_SHW_AN_3                RX_BASE_ADDR+0x11B 
-#define RX_HDCP_SHW_AN_4                RX_BASE_ADDR+0x11C 
-#define RX_HDCP_SHW_AN_5                RX_BASE_ADDR+0x11D 
-#define RX_HDCP_SHW_AN_6                RX_BASE_ADDR+0x11E 
-#define RX_HDCP_SHW_AN_7                RX_BASE_ADDR+0x11F 
-#define RX_HDCP_SHW_V1_H0_0             RX_BASE_ADDR+0x120 
-#define RX_HDCP_SHW_V1_H0_1             RX_BASE_ADDR+0x121 
-#define RX_HDCP_SHW_V1_H0_2             RX_BASE_ADDR+0x122 
-#define RX_HDCP_SHW_V1_H0_3             RX_BASE_ADDR+0x123 
-#define RX_HDCP_SHW_V1_H1_0             RX_BASE_ADDR+0x124 
-#define RX_HDCP_SHW_V1_H1_1             RX_BASE_ADDR+0x125 
-#define RX_HDCP_SHW_V1_H1_2             RX_BASE_ADDR+0x126 
-#define RX_HDCP_SHW_V1_H1_3             RX_BASE_ADDR+0x127 
-#define RX_HDCP_SHW_V1_H2_0             RX_BASE_ADDR+0x128 
-#define RX_HDCP_SHW_V1_H2_1             RX_BASE_ADDR+0x129 
-#define RX_HDCP_SHW_V1_H2_2             RX_BASE_ADDR+0x12A 
-#define RX_HDCP_SHW_V1_H2_3             RX_BASE_ADDR+0x12B 
-#define RX_HDCP_SHW_V1_H3_0             RX_BASE_ADDR+0x12C 
-#define RX_HDCP_SHW_V1_H3_1             RX_BASE_ADDR+0x12D 
-#define RX_HDCP_SHW_V1_H3_2             RX_BASE_ADDR+0x12E 
-#define RX_HDCP_SHW_V1_H3_3             RX_BASE_ADDR+0x12F 
-#define RX_HDCP_SHW_V1_H4_0             RX_BASE_ADDR+0x130 
-#define RX_HDCP_SHW_V1_H4_1             RX_BASE_ADDR+0x131 
-#define RX_HDCP_SHW_V1_H4_2             RX_BASE_ADDR+0x132 
-#define RX_HDCP_SHW_V1_H4_3             RX_BASE_ADDR+0x133 
-#define RX_HDCP_SHW_BCAPS               RX_BASE_ADDR+0x140 
-#define RX_HDCP_SHW_BSTATUS_0           RX_BASE_ADDR+0x141 
-#define RX_HDCP_SHW_BSTATUS_1           RX_BASE_ADDR+0x142 
-#define RX_HDCP_SHW_KSV_FIFO            RX_BASE_ADDR+0x143 
-#define RX_HDCP_SHW_KM_0                RX_BASE_ADDR+0x148 
-#define RX_HDCP_SHW_KM_1                RX_BASE_ADDR+0x149 
-#define RX_HDCP_SHW_KM_2                RX_BASE_ADDR+0x14A 
-#define RX_HDCP_SHW_KM_3                RX_BASE_ADDR+0x14B 
-#define RX_HDCP_SHW_KM_4                RX_BASE_ADDR+0x14C 
-#define RX_HDCP_SHW_KM_5                RX_BASE_ADDR+0x14D 
-#define RX_HDCP_SHW_KM_6                RX_BASE_ADDR+0x14E 
-// system status extension
-#define RX_SYSST_EXT_CDR0_MONITOR_0     RX_BASE_ADDR+0x160 
-#define RX_SYSST_EXT_CDR0_MONITOR_1     RX_BASE_ADDR+0x161 
-#define RX_SYSST_EXT_CDR1_MONITOR_0     RX_BASE_ADDR+0x162 
-#define RX_SYSST_EXT_CDR1_MONITOR_1     RX_BASE_ADDR+0x163 
-#define RX_SYSST_EXT_CDR2_MONITOR_0     RX_BASE_ADDR+0x164 
-#define RX_SYSST_EXT_CDR2_MONITOR_1     RX_BASE_ADDR+0x165 
-#define RX_SYSST_EXT_CDR3_MONITOR_0     RX_BASE_ADDR+0x166 
-#define RX_SYSST_EXT_CDR3_MONITOR_1     RX_BASE_ADDR+0x167 
-#define RX_SYSST_EXT_PRBS_BER_METER_0   RX_BASE_ADDR+0x168 
-#define RX_SYSST_EXT_PRBS_BER_METER_1   RX_BASE_ADDR+0x169 
-#define RX_SYSST_EXT_PRBS_BER_METER_2   RX_BASE_ADDR+0x16A 
-#define RX_SYSST_EXT_PRBS_STATUS        RX_BASE_ADDR+0x16B 
-#define RX_SYSST_EXT_RCALIB_STATUS_0    RX_BASE_ADDR+0x16D 
-#define RX_SYSST_EXT_RCALIB_STATUS_1    RX_BASE_ADDR+0x16E 
-#define RX_SYSST_EXT_RX_FIFO_STATUS     RX_BASE_ADDR+0x16F 
-// Error Correction status
-#define RX_ERRST_ECC_STATUS_0           RX_BASE_ADDR+0x170 
-#define RX_ERRST_ECC_STATUS_1           RX_BASE_ADDR+0x171 
-#define RX_ERRST_ECC_STATUS_2           RX_BASE_ADDR+0x172 
-#define RX_ERRST_ECC_STATUS_3           RX_BASE_ADDR+0x173 
-#define RX_ERRST_ECC_STATUS_4           RX_BASE_ADDR+0x174 
-#define RX_ERRST_PACKET_CONTENTS        RX_BASE_ADDR+0x175 
-#define RX_ERRST_ERROR_LOCATION_0       RX_BASE_ADDR+0x176 
-#define RX_ERRST_ERROR_LOCATION_1       RX_BASE_ADDR+0x177 
-#define RX_ERRST_ERROR_LOCATION_2       RX_BASE_ADDR+0x178 
-#define RX_ERRST_ERROR_LOCATION_3       RX_BASE_ADDR+0x179 
-#define RX_ERRST_ERROR_LOCATION_4       RX_BASE_ADDR+0x17A 
-#define RX_ERRST_ERROR_LOCATION_5       RX_BASE_ADDR+0x17B 
-#define RX_ERRST_ERROR_LOCATION_6       RX_BASE_ADDR+0x17C 
-#define RX_ERRST_ERROR_LOCATION_7       RX_BASE_ADDR+0x17D 
-#define RX_ERRST_ERROR_LOCATION_8       RX_BASE_ADDR+0x17E 
-#define RX_ERRST_ERROR_LOCATION_9       RX_BASE_ADDR+0x17F 
-
-// system status 0
-#define RX_SYSST0_AFE_REV_ID            RX_BASE_ADDR+0x180 
-#define RX_SYSST0_PWR_STATUS            RX_BASE_ADDR+0x189 
-#define RX_SYSST0_CTS_STATUS_L          RX_BASE_ADDR+0x18A 
-#define RX_SYSST0_CTS_STATUS_H          RX_BASE_ADDR+0x18B 
-#define RX_SYSST0_NCTS_STATUS           RX_BASE_ADDR+0x18C 
-#define RX_SYSST0_N_STATUS_L            RX_BASE_ADDR+0x18D 
-#define RX_SYSST0_N_STATUS_H            RX_BASE_ADDR+0x18E 
-#define RX_SYSST0_ROM_STATUS            RX_BASE_ADDR+0x18F 
-// system status 1
-#define RX_SYSST1_CLOCK_CONTROL_M_ACT_0         RX_BASE_ADDR+0x1E0 
-#define RX_SYSST1_CLOCK_CONTROL_M_ACT_1         RX_BASE_ADDR+0x1E1 
-#define RX_SYSST1_CLOCK_CONTROL_M_ACT_2         RX_BASE_ADDR+0x1E2 
-#define RX_SYSST1_CLOCK_CONTROL_N_ACT_0         RX_BASE_ADDR+0x1E3 
-#define RX_SYSST1_CLOCK_CONTROL_N_ACT_1         RX_BASE_ADDR+0x1E4 
-#define RX_SYSST1_CLOCK_CONTROL_N_ACT_2         RX_BASE_ADDR+0x1E5 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_0        RX_BASE_ADDR+0x1E6 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_1        RX_BASE_ADDR+0x1E7 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_2        RX_BASE_ADDR+0x1E8 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_3        RX_BASE_ADDR+0x1E9 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_4        RX_BASE_ADDR+0x1EA 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_5        RX_BASE_ADDR+0x1EB 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_PRE_0       RX_BASE_ADDR+0x1EC 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_PRE_1       RX_BASE_ADDR+0x1ED 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_MAIN_0      RX_BASE_ADDR+0x1EE 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_MAIN_1      RX_BASE_ADDR+0x1EF 
-
-// hdcp status
-#define RX_HDCP_ST_AUTHENTICATION               RX_BASE_ADDR+0x190 
-#define RX_HDCP_ST_FRAME_COUNT                  RX_BASE_ADDR+0x191 
-#define RX_HDCP_ST_STATUS_0                     RX_BASE_ADDR+0x192 
-#define RX_HDCP_ST_STATUS_1                     RX_BASE_ADDR+0x193 
-#define RX_HDCP_ST_STATUS_2                     RX_BASE_ADDR+0x194 
-#define RX_HDCP_ST_STATUS_3                     RX_BASE_ADDR+0x195 
-#define RX_HDCP_ST_EDID_STATUS                  RX_BASE_ADDR+0x196 
-#define RX_HDCP_ST_MEM_STATUS                   RX_BASE_ADDR+0x197 
-#define RX_HDCP_ST_EDID_EXTENSIONS              RX_BASE_ADDR+0x198 
-#define RX_HDCP_ST_EDDC_MASTER_SEGMENT          RX_BASE_ADDR+0x199 
-#define RX_HDCP_ST_EDDC_MASTER_STATE            RX_BASE_ADDR+0x19A 
-#define RX_HDCP_ST_EDDC_SLAVE_SEGMENT           RX_BASE_ADDR+0x19B 
-#define RX_HDCP_ST_EDDC_SLAVE_STATE             RX_BASE_ADDR+0x19C 
-#define RX_HDCP_ST_CRC_STATUS                   RX_BASE_ADDR+0x19D 
-#define RX_HDCP_ST_REPEATER                     RX_BASE_ADDR+0x19E 
-#define RX_HDCP_ST_ST_MODE                      RX_BASE_ADDR+0x19F 
-
-// video status
-#define RX_VIDEO_ST_ACTIVE_PIXELS_1     RX_BASE_ADDR+0x1A0 
-#define RX_VIDEO_ST_ACTIVE_PIXELS_2     RX_BASE_ADDR+0x1A1 
-#define RX_VIDEO_ST_FRONT_PIXELS        RX_BASE_ADDR+0x1A2 
-#define RX_VIDEO_ST_HSYNC_PIXELS        RX_BASE_ADDR+0x1A3 
-#define RX_VIDEO_ST_BACK_PIXELS         RX_BASE_ADDR+0x1A4 
-#define RX_VIDEO_ST_ACTIVE_LINES_1      RX_BASE_ADDR+0x1A5 
-#define RX_VIDEO_ST_ACTIVE_LINES_2      RX_BASE_ADDR+0x1A6 
-#define RX_VIDEO_ST_EOF_LINES           RX_BASE_ADDR+0x1A7 
-#define RX_VIDEO_ST_VSYNC_LINES         RX_BASE_ADDR+0x1A8 
-#define RX_VIDEO_ST_SOF_LINES           RX_BASE_ADDR+0x1A9 
-#define RX_VIDEO_ST_DTV_TIMING          RX_BASE_ADDR+0x1AA 
-#define RX_VIDEO_ST_DTV_MODE            RX_BASE_ADDR+0x1AB 
-// audio status 
-#define RX_AUDIOST_AUDIO_STATUS         RX_BASE_ADDR+0x1AC 
-#define RX_AUDIOST_AUDIO_HEADER         RX_BASE_ADDR+0x1AD 
-#define RX_AUDIOST_AUDIO_FIFO_LEVEL     RX_BASE_ADDR+0x1AE 
-#define RX_AUDIOST_CALIB_STATUS         RX_BASE_ADDR+0x1AF 
-// core status
-#define RX_COREST_INTERRUPT_STATUS_0    RX_BASE_ADDR+0x1F0 
-#define RX_COREST_INTERRUPT_STATUS_1    RX_BASE_ADDR+0x1F1 
-#define RX_COREST_INTERRUPT_STATUS_2    RX_BASE_ADDR+0x1F2 
-#define RX_COREST_EQ_MEAS_STATUS        RX_BASE_ADDR+0x1F3 
-#define RX_COREST_TMDS_MEAS_STATUS_0    RX_BASE_ADDR+0x1F4 
-#define RX_COREST_TMDS_MEAS_STATUS_1    RX_BASE_ADDR+0x1F5 
-#define RX_COREST_TMDS_MEAS_STATUS_2    RX_BASE_ADDR+0x1F6 
-#define RX_COREST_TMDS_MEAS_STATUS_3    RX_BASE_ADDR+0x1F7 
-// tmds status
-#define RX_TMDSST_ALIGN_STATUS_0        RX_BASE_ADDR+0x1F8 
-#define RX_TMDSST_ALIGN_STATUS_1        RX_BASE_ADDR+0x1F9 
-#define RX_TMDSST_ALIGN_STATUS_2        RX_BASE_ADDR+0x1FA 
-#define RX_TMDSST_ALIGN_STATUS_3        RX_BASE_ADDR+0x1FB 
-#define RX_TMDSST_HDMI_STATUS           RX_BASE_ADDR+0x1FC 
-#define RX_TMDSST_EQ_STATUS_CH0         RX_BASE_ADDR+0x1FD 
-#define RX_TMDSST_EQ_STATUS_CH1         RX_BASE_ADDR+0x1FE 
-#define RX_TMDSST_EQ_STATUS_CH2         RX_BASE_ADDR+0x1FF 
-
-// Packet register
-#define RX_PKT_REG_SPD_INFO_BASE_ADDR           RX_BASE_ADDR+0x200 
-#define RX_PKT_REG_VEND_INFO_BASE_ADDR          RX_BASE_ADDR+0x220 
-#define RX_PKT_REG_MPEG_INFO_BASE_ADDR          RX_BASE_ADDR+0x240 
-#define RX_PKT_REG_AVI_INFO_BASE_ADDR           RX_BASE_ADDR+0x260 
-#define RX_PKT_REG_AUDIO_INFO_BASE_ADDR         RX_BASE_ADDR+0x280 
-#define RX_PKT_REG_ACP_INFO_BASE_ADDR           RX_BASE_ADDR+0x2A0 
-#define RX_PKT_REG_ISRC1_BASE_ADDR              RX_BASE_ADDR+0x2C0 
-#define RX_PKT_REG_ISRC2_BASE_ADDR              RX_BASE_ADDR+0x2E0 
-#define RX_PKT_REG_EXCEPT0_BASE_ADDR            RX_BASE_ADDR+0x300 
-#define RX_PKT_REG_EXCEPT1_BASE_ADDR            RX_BASE_ADDR+0x320 
-#define RX_PKT_REG_EXCEPT2_BASE_ADDR            RX_BASE_ADDR+0x340 
-#define RX_PKT_REG_EXCEPT3_BASE_ADDR            RX_BASE_ADDR+0x360 
-#define RX_PKT_REG_GAMUT_P0_BASE_ADDR           RX_BASE_ADDR+0x380 
-#define RX_PKT_REG_GAMUT_P1_2_BASE_ADDR         RX_BASE_ADDR+0x3A0 
-#define RX_PKT_REG_GAMUT_P1_3_BASE_ADDR         RX_BASE_ADDR+0x3C0 
-#define RX_PKT_REG_GAMUT_P1_4_BASE_ADDR         RX_BASE_ADDR+0x3E0 
-
-
-//********** CEC related **********//
-//read/write
-#define CEC_TX_MSG_0_HEADER        0x00 
-#define CEC_TX_MSG_1_OPCODE        0x01 
-#define CEC_TX_MSG_2_OP1           0x02 
-#define CEC_TX_MSG_3_OP2           0x03 
-#define CEC_TX_MSG_4_OP3           0x04 
-#define CEC_TX_MSG_5_OP4           0x05 
-#define CEC_TX_MSG_6_OP5           0x06 
-#define CEC_TX_MSG_7_OP6           0x07 
-#define CEC_TX_MSG_8_OP7           0x08 
-#define CEC_TX_MSG_9_OP8           0x09 
-#define CEC_TX_MSG_A_OP9           0x0A 
-#define CEC_TX_MSG_B_OP10          0x0B 
-#define CEC_TX_MSG_C_OP11          0x0C 
-#define CEC_TX_MSG_D_OP12          0x0D 
-#define CEC_TX_MSG_E_OP13          0x0E 
-#define CEC_TX_MSG_F_OP14          0x0F 
-
-//read/write
-#define CEC_TX_MSG_LENGTH          0x10 
-#define CEC_TX_MSG_CMD             0x11 
-#define CEC_TX_WRITE_BUF           0x12 
-#define CEC_TX_CLEAR_BUF           0x13 
-#define CEC_RX_MSG_CMD             0x14 
-#define CEC_RX_CLEAR_BUF           0x15 
-#define CEC_LOGICAL_ADDR0          0x16 
-#define CEC_LOGICAL_ADDR1          0x17 
-#define CEC_LOGICAL_ADDR2          0x18 
-#define CEC_LOGICAL_ADDR3          0x19 
-#define CEC_LOGICAL_ADDR4          0x1A 
-#define CEC_CLOCK_DIV_H            0x1B 
-#define CEC_CLOCK_DIV_L            0x1C 
-
-// The following registers are for fine tuning CEC bit timing parameters.
-// They are only valid in AO CEC, NOT valid in HDMITX CEC.
-// The AO CEC's timing parameters are already set default to work with 32768Hz clock, so hopefully
-// SW never need to program these registers. The timing registers are made programmable just in case.
-#define AO_CEC_QUIESCENT_25MS_BIT7_0            0x20
-#define AO_CEC_QUIESCENT_25MS_BIT11_8           0x21
-#define AO_CEC_STARTBITMINL2H_3MS5_BIT7_0       0x22
-#define AO_CEC_STARTBITMINL2H_3MS5_BIT8         0x23
-#define AO_CEC_STARTBITMAXL2H_3MS9_BIT7_0       0x24
-#define AO_CEC_STARTBITMAXL2H_3MS9_BIT8         0x25
-#define AO_CEC_STARTBITMINH_0MS6_BIT7_0         0x26
-#define AO_CEC_STARTBITMINH_0MS6_BIT8           0x27
-#define AO_CEC_STARTBITMAXH_1MS0_BIT7_0         0x28
-#define AO_CEC_STARTBITMAXH_1MS0_BIT8           0x29
-#define AO_CEC_STARTBITMINTOTAL_4MS3_BIT7_0     0x2A
-#define AO_CEC_STARTBITMINTOTAL_4MS3_BIT9_8     0x2B
-#define AO_CEC_STARTBITMAXTOTAL_4MS7_BIT7_0     0x2C
-#define AO_CEC_STARTBITMAXTOTAL_4MS7_BIT9_8     0x2D
-#define AO_CEC_LOGIC1MINL2H_0MS4_BIT7_0         0x2E
-#define AO_CEC_LOGIC1MINL2H_0MS4_BIT8           0x2F
-#define AO_CEC_LOGIC1MAXL2H_0MS8_BIT7_0         0x30
-#define AO_CEC_LOGIC1MAXL2H_0MS8_BIT8           0x31
-#define AO_CEC_LOGIC0MINL2H_1MS3_BIT7_0         0x32
-#define AO_CEC_LOGIC0MINL2H_1MS3_BIT8           0x33
-#define AO_CEC_LOGIC0MAXL2H_1MS7_BIT7_0         0x34
-#define AO_CEC_LOGIC0MAXL2H_1MS7_BIT8           0x35
-#define AO_CEC_LOGICMINTOTAL_2MS05_BIT7_0       0x36
-#define AO_CEC_LOGICMINTOTAL_2MS05_BIT9_8       0x37
-#define AO_CEC_LOGICMAXHIGH_2MS8_BIT7_0         0x38
-#define AO_CEC_LOGICMAXHIGH_2MS8_BIT8           0x39
-#define AO_CEC_LOGICERRLOW_3MS4_BIT7_0          0x3A
-#define AO_CEC_LOGICERRLOW_3MS4_BIT8            0x3B
-#define AO_CEC_NOMSMPPOINT_1MS05                0x3C
-#define AO_CEC_DELCNTR_LOGICERR                 0x3E
-#define AO_CEC_TXTIME_17MS_BIT7_0               0x40
-#define AO_CEC_TXTIME_17MS_BIT10_8              0x41
-#define AO_CEC_TXTIME_2BIT_BIT7_0               0x42
-#define AO_CEC_TXTIME_2BIT_BIT10_8              0x43
-#define AO_CEC_TXTIME_4BIT_BIT7_0               0x44
-#define AO_CEC_TXTIME_4BIT_BIT10_8              0x45
-#define AO_CEC_STARTBITNOML2H_3MS7_BIT7_0       0x46
-#define AO_CEC_STARTBITNOML2H_3MS7_BIT8         0x47
-#define AO_CEC_STARTBITNOMH_0MS8_BIT7_0         0x48
-#define AO_CEC_STARTBITNOMH_0MS8_BIT8           0x49
-#define AO_CEC_LOGIC1NOML2H_0MS6_BIT7_0         0x4A
-#define AO_CEC_LOGIC1NOML2H_0MS6_BIT8           0x4B
-#define AO_CEC_LOGIC0NOML2H_1MS5_BIT7_0         0x4C
-#define AO_CEC_LOGIC0NOML2H_1MS5_BIT8           0x4D
-#define AO_CEC_LOGIC1NOMH_1MS8_BIT7_0           0x4E
-#define AO_CEC_LOGIC1NOMH_1MS8_BIT8             0x4F
-#define AO_CEC_LOGIC0NOMH_0MS9_BIT7_0           0x50
-#define AO_CEC_LOGIC0NOMH_0MS9_BIT8             0x51
-#define AO_CEC_LOGICERRLOW_3MS6_BIT7_0          0x52
-#define AO_CEC_LOGICERRLOW_3MS6_BIT8            0x53
-#define AO_CEC_CHKCONTENTION_0MS1               0x54
-#define AO_CEC_PREPARENXTBIT_0MS05_BIT7_0       0x56
-#define AO_CEC_PREPARENXTBIT_0MS05_BIT8         0x57
-#define AO_CEC_NOMSMPACKPOINT_0MS45             0x58
-#define AO_CEC_ACK0NOML2H_1MS5_BIT7_0           0x5A
-#define AO_CEC_ACK0NOML2H_1MS5_BIT8             0x5B
-
-
-//read only
-#define CEC_RX_MSG_0_HEADER        0x80 
-#define CEC_RX_MSG_1_OPCODE        0x81 
-#define CEC_RX_MSG_2_OP1           0x82 
-#define CEC_RX_MSG_3_OP2           0x83 
-#define CEC_RX_MSG_4_OP3           0x84 
-#define CEC_RX_MSG_5_OP4           0x85 
-#define CEC_RX_MSG_6_OP5           0x86 
-#define CEC_RX_MSG_7_OP6           0x87 
-#define CEC_RX_MSG_8_OP7           0x88 
-#define CEC_RX_MSG_9_OP8           0x89 
-#define CEC_RX_MSG_A_OP9           0x8A 
-#define CEC_RX_MSG_B_OP10          0x8B 
-#define CEC_RX_MSG_C_OP11          0x8C 
-#define CEC_RX_MSG_D_OP12          0x8D 
-#define CEC_RX_MSG_E_OP13          0x8E 
-#define CEC_RX_MSG_F_OP14          0x8F 
-
-//read only
-#define CEC_RX_MSG_LENGTH          0x90 
-#define CEC_RX_MSG_STATUS          0x91 
-#define CEC_RX_NUM_MSG             0x92 
-#define CEC_TX_MSG_STATUS          0x93 
-#define CEC_TX_NUM_MSG             0x94 
-
-// tx_msg_cmd definition
-#define TX_NO_OP                0  // No transaction
-#define TX_REQ_CURRENT          1  // Transmit earliest message in buffer
-#define TX_ABORT                2  // Abort transmitting earliest message
-#define TX_REQ_NEXT             3  // Overwrite earliest message in buffer and transmit next message
-
-// tx_msg_status definition
-#define TX_IDLE                 0  // No transaction
-#define TX_BUSY                 1  // Transmitter is busy
-#define TX_DONE                 2  // Message has been successfully transmitted
-#define TX_ERROR                3  // Message has been transmitted with error
-
-// rx_msg_cmd
-#define RX_NO_OP                0  // No transaction
-#define RX_ACK_CURRENT          1  // Read earliest message in buffer
-#define RX_DISABLE              2  // Disable receiving latest message
-#define RX_ACK_NEXT             3  // Clear earliest message from buffer and read next message
-
-// rx_msg_status
-#define RX_IDLE                 0  // No transaction
-#define RX_BUSY                 1  // Receiver is busy
-#define RX_DONE                 2  // Message has been received successfully
-#define RX_ERROR                3  // Message has been received with error
-
-
-
-//************ SIM related *************//
-#define SIM_MYREG_BASE_ADDR             SIM_BASE_ADDR+0x0000 
-#define SIM_CLKS_BASE_ADDR              SIM_BASE_ADDR+0x0800 
-#define SIM_SDI2HDMI_BASE_ADDR          SIM_BASE_ADDR+0x1000 
-#define SIM_VIDEOGEN_BASE_ADDR          SIM_BASE_ADDR+0x1800 
-#define SIM_VIDEO_ANALYZE_BASE_ADDR     SIM_BASE_ADDR+0x2000 
-#define SIM_AUDIOGEN_BASE_ADDR          SIM_BASE_ADDR+0x2800 
-
-#define SIM_MYREG_RESET                 SIM_MYREG_BASE_ADDR+0x0020
-
-#define SIM_MYREG_TX_I2S_SPDIF          SIM_MYREG_BASE_ADDR+0x00F0
-#define SIM_MYREG_RX_I2S_SPDIF          SIM_MYREG_BASE_ADDR+0x00F1
-
-#define SIM_MYREG_CPU_PRINT_CHAR        SIM_MYREG_BASE_ADDR+0x00FB
-#define SIM_MYREG_CMD_CNT               SIM_MYREG_BASE_ADDR+0x00FC
-#define SIM_MYREG_CPU_PRINT             SIM_MYREG_BASE_ADDR+0x00FD
-#define SIM_MYREG_END_SIM               SIM_MYREG_BASE_ADDR+0x00FE 
-#define SIM_MYREG_CONFIGEND             SIM_MYREG_BASE_ADDR+0x00FF 
-
-
-#endif
diff --git a/drivers/amlogic/tvin/hdmirx/test/hdmirx.c b/drivers/amlogic/tvin/hdmirx/test/hdmirx.c
deleted file mode 100644
index dea5fb5607c1..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/hdmirx.c
+++ /dev/null
@@ -1,1570 +0,0 @@
-//#include "register.h"
-//#include "c_always_on_pointer.h"
-#include "hdmi.h"
-#include "hdmirx.h"
-#include "hdmirx_parameter.h"
-//#include "c_stimulus.h"
-
-#define Wr(reg,val) WRITE_MPEG_REG(reg,val)
-#define Rd(reg)   READ_MPEG_REG(reg)
-#define Wr_reg_bits(reg, val, start, len) \
-  Wr(reg, (Rd(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
-
-void hdmirx_wr_top (unsigned long addr, unsigned long data);
-void hdmi_rx_ctrl_write (unsigned long addr, unsigned long data);
-void debug_phy_write (unsigned long addr, unsigned long data);
-unsigned hdmirx_rd_top (unsigned long addr);
-unsigned hdmi_rx_ctrl_read (unsigned long addr);
-unsigned debug_phy_read (unsigned long addr);
-
-void hdmirx_wr_only_TOP (unsigned long addr, unsigned long data)
-{
-    hdmirx_wr_top(addr, data);
-   /*
-    unsigned long dev_offset = 0;       // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-    *((volatile unsigned long *) (HDMIRX_ADDR_PORT+dev_offset)) = addr;
-    *((volatile unsigned long *) (HDMIRX_DATA_PORT+dev_offset)) = data;
-    */
-} /* hdmirx_wr_only_TOP */
-
-void hdmirx_wr_only_DWC (unsigned long addr, unsigned long data)
-{
-    hdmi_rx_ctrl_write(addr, data);
-    /*
-    unsigned long dev_offset = 0x10;    // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-    *((volatile unsigned long *) (HDMIRX_ADDR_PORT+dev_offset)) = addr;
-    *((volatile unsigned long *) (HDMIRX_DATA_PORT+dev_offset)) = data;
-    */
-} /* hdmirx_wr_only_DWC */
-
-void hdmirx_wr_only_PHY (unsigned long addr, unsigned long data)
-{
-    debug_phy_write(addr, data);
-    /*
-    hdmirx_wr_only_DWC( HDMIRX_DWC_I2CM_PHYG3_ADDRESS,  addr & 0xff);
-    hdmirx_wr_only_DWC( HDMIRX_DWC_I2CM_PHYG3_DATAO,    data & 0xffff);
-    hdmirx_wr_only_DWC( HDMIRX_DWC_I2CM_PHYG3_OPERATION,0x1);
-    Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 400 ) {}
-    hdmirx_poll_DWC(    HDMIRX_DWC_HDMI_ISTS,           1<<28, ~(1<<28), 0);
-    hdmirx_wr_only_DWC( HDMIRX_DWC_HDMI_ICLR,           1<<28);
-    hdmirx_poll_DWC(    HDMIRX_DWC_HDMI_ISTS,           0<<28, ~(1<<28), 0);
-    */
-} /* hdmirx_wr_only_PHY */
-
-void hdmirx_wr_only_reg (unsigned char dev_id, unsigned long addr, unsigned long data)
-{
-    if (dev_id == HDMIRX_DEV_ID_TOP) {
-        hdmirx_wr_only_TOP(addr, data);
-    } else if (dev_id == HDMIRX_DEV_ID_DWC) {
-        hdmirx_wr_only_DWC(addr, data);
-    } else if (dev_id == HDMIRX_DEV_ID_PHY) {
-        hdmirx_wr_only_PHY(addr, data);
-    } else {
-        stimulus_print("Error: hdmirx_wr_only_reg access unknown device ID!\n");
-        stimulus_finish_fail(10);
-    }
-} /* hdmirx_wr_only_reg */
-
-unsigned long hdmirx_rd_TOP (unsigned long addr)
-{
-    unsigned long dev_offset = 0;       // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-    unsigned long data;
-    /*
-    *((volatile unsigned long *) (HDMIRX_ADDR_PORT+dev_offset)) = addr;
-    data = *((volatile unsigned long *) (HDMIRX_DATA_PORT+dev_offset)); 
-    */
-    data = hdmirx_rd_top(addr);
-    return (data);
-} /* hdmirx_rd_TOP */
-
-unsigned long hdmirx_rd_DWC (unsigned long addr)
-{
-    unsigned long dev_offset = 0x10;    // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-    unsigned long data;
-    /*
-    *((volatile unsigned long *) (HDMIRX_ADDR_PORT+dev_offset)) = addr;
-    data = *((volatile unsigned long *) (HDMIRX_DATA_PORT+dev_offset)); 
-    */
-    data = hdmi_rx_ctrl_read(addr);
-    return (data);
-} /* hdmirx_rd_DWC */
-
-unsigned long hdmirx_rd_PHY (unsigned long addr)
-{
-    unsigned long data;
-    /*
-    hdmirx_wr_only_DWC( HDMIRX_DWC_I2CM_PHYG3_ADDRESS,  addr & 0xff);
-    hdmirx_wr_only_DWC( HDMIRX_DWC_I2CM_PHYG3_OPERATION,0x2);
-    Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 400 ) {}
-    hdmirx_poll_DWC(    HDMIRX_DWC_HDMI_ISTS,           1<<28, ~(1<<28), 0);
-    hdmirx_wr_only_DWC( HDMIRX_DWC_HDMI_ICLR,           1<<28);
-    hdmirx_poll_DWC(    HDMIRX_DWC_HDMI_ISTS,           0<<28, ~(1<<28), 0);
-    data = hdmirx_rd_DWC(HDMIRX_DWC_I2CM_PHYG3_DATAI);
-    */
-    data = debug_phy_read(addr);
-    return (data);
-} /* hdmirx_rd_PHY */
-
-unsigned long hdmirx_rd_reg (unsigned char dev_id, unsigned long addr)
-{
-    unsigned long data;
-
-    if (dev_id == HDMIRX_DEV_ID_TOP) {
-        data = hdmirx_rd_TOP(addr);
-    } else if (dev_id == HDMIRX_DEV_ID_DWC) {
-        data = hdmirx_rd_DWC(addr);
-    } else if (dev_id == HDMIRX_DEV_ID_PHY) {
-        data = hdmirx_rd_PHY(addr);
-    } else {
-        stimulus_print("Error: hdmirx_rd_reg access unknown device ID!\n");
-        stimulus_finish_fail(10);
-    }
-    return (data);
-} /* hdmirx_rd_reg */
-
-void hdmirx_rd_check_TOP (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmirx_rd_TOP(addr);
-    if ((rd_data | mask) != (exp_data | mask)) 
-    {
-        printk("Error: HDMIRX-TOP addr=0x%x, rd_data=0x%x, exp_data=0x%x, mask=0x%x\n", 
-            addr, rd_data, exp_data, mask);
-        /*
-        stimulus_print("Error: HDMIRX-TOP addr=0x");
-        stimulus_print_num_hex(addr);
-        stimulus_print_without_timestamp(" rd_data=0x");
-        stimulus_print_num_hex(rd_data);
-        stimulus_print_without_timestamp(" exp_data=0x");
-        stimulus_print_num_hex(exp_data);
-        stimulus_print_without_timestamp(" mask=0x");
-        stimulus_print_num_hex(mask);
-        stimulus_print_without_timestamp("\n");
-        */
-        //stimulus_finish_fail(10);
-    }
-} /* hdmirx_rd_check_TOP */
-
-void hdmirx_rd_check_DWC (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmirx_rd_DWC(addr);
-    if ((rd_data | mask) != (exp_data | mask)) 
-    {
-        printk("Error: HDMIRX-DWC addr=0x%x, rd_data=0x%x, exp_data=0x%x, mask=0x%x\n", 
-            addr, rd_data, exp_data, mask);
-
-        /*
-        stimulus_print("Error: HDMIRX-DWC addr=0x");
-        stimulus_print_num_hex(addr);
-        stimulus_print_without_timestamp(" rd_data=0x");
-        stimulus_print_num_hex(rd_data);
-        stimulus_print_without_timestamp(" exp_data=0x");
-        stimulus_print_num_hex(exp_data);
-        stimulus_print_without_timestamp(" mask=0x");
-        stimulus_print_num_hex(mask);
-        stimulus_print_without_timestamp("\n");
-        //stimulus_finish_fail(10); */
-    }
-} /* hdmirx_rd_check_DWC */
-
-void hdmirx_rd_check_PHY (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmirx_rd_PHY(addr);
-    if ((rd_data | mask) != (exp_data | mask)) 
-    {
-        printk("Error: HDMIRX-PHY addr=0x%x, rd_data=0x%x, exp_data=0x%x, mask=0x%x\n", 
-            addr, rd_data, exp_data, mask);
-        /*
-        stimulus_print("Error: HDMIRX-PHY addr=0x");
-        stimulus_print_num_hex(addr);
-        stimulus_print_without_timestamp(" rd_data=0x");
-        stimulus_print_num_hex(rd_data);
-        stimulus_print_without_timestamp(" exp_data=0x");
-        stimulus_print_num_hex(exp_data);
-        stimulus_print_without_timestamp(" mask=0x");
-        stimulus_print_num_hex(mask);
-        stimulus_print_without_timestamp("\n");
-        stimulus_finish_fail(10);*/
-    }
-} /* hdmirx_rd_check_PHY */
-
-void hdmirx_rd_check_reg (unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    if (dev_id == HDMIRX_DEV_ID_TOP) {
-        hdmirx_rd_check_TOP(addr, exp_data, mask);
-    } else if (dev_id == HDMIRX_DEV_ID_DWC) {
-        hdmirx_rd_check_DWC(addr, exp_data, mask);
-    } else if (dev_id == HDMIRX_DEV_ID_PHY) {
-        hdmirx_rd_check_PHY(addr, exp_data, mask);
-    } else {
-        stimulus_print("Error: hdmirx_rd_check_reg access unknown device ID!\n");
-        stimulus_finish_fail(10);
-    }
-} /* hdmirx_rd_check_reg */
-
-void hdmirx_wr_TOP (unsigned long addr, unsigned long data)
-{
-    hdmirx_wr_only_TOP(addr, data);
-    hdmirx_rd_check_TOP(addr, data, 0);
-} /* hdmirx_wr_TOP */
-
-void hdmirx_wr_DWC (unsigned long addr, unsigned long data)
-{
-    hdmirx_wr_only_DWC(addr, data);
-    hdmirx_rd_check_DWC(addr, data, 0);
-} /* hdmirx_wr_DWC */
-
-void hdmirx_wr_PHY (unsigned long addr, unsigned long data)
-{
-    hdmirx_wr_only_PHY(addr, data);
-    hdmirx_rd_check_PHY(addr, data, 0);
-} /* hdmirx_wr_PHY */
-
-void hdmirx_wr_reg (unsigned char dev_id, unsigned long addr, unsigned long data)
-{
-    if (dev_id == HDMIRX_DEV_ID_TOP) {
-        hdmirx_wr_TOP(addr, data);
-    } else if (dev_id == HDMIRX_DEV_ID_DWC) {
-        hdmirx_wr_DWC(addr, data);
-    } else if (dev_id == HDMIRX_DEV_ID_PHY) {
-        hdmirx_wr_PHY(addr, data);
-    } else {
-        stimulus_print("Error: hdmirx_wr_reg access unknown device ID!\n");
-        stimulus_finish_fail(10);
-    }
-} /* hdmirx_wr_reg */
-
-void hdmirx_poll_TOP (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmirx_rd_TOP(addr);
-    while ((rd_data | mask) != (exp_data | mask))
-    {
-        rd_data = hdmirx_rd_TOP(addr);
-    }
-} /* hdmirx_poll_TOP */
-
-void hdmirx_poll_DWC (unsigned long addr, unsigned long exp_data, unsigned long mask, unsigned long max_try)
-{
-    unsigned long rd_data;
-    unsigned long cnt   = 0;
-    unsigned char done  = 0;
-    
-    rd_data = hdmirx_rd_DWC(addr);
-    while (((cnt < max_try) || (max_try == 0)) && (done != 1)) {
-        if ((rd_data | mask) == (exp_data | mask)) {
-            done = 1;
-        } else {
-            cnt ++;
-            rd_data = hdmirx_rd_DWC(addr);
-        }
-    }
-    if (done == 0) {
-        stimulus_print("Error: hdmirx_poll_DWC access time-out!\n");
-        stimulus_finish_fail(10);
-    }
-} /* hdmirx_poll_DWC */
-
-void hdmirx_poll_PHY (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = hdmirx_rd_PHY(addr);
-    while ((rd_data | mask) != (exp_data | mask))
-    {
-        rd_data = hdmirx_rd_PHY(addr);
-    }
-} /* hdmirx_poll_PHY */
-
-void hdmirx_poll_reg (unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    if (dev_id == HDMIRX_DEV_ID_TOP) {
-        hdmirx_poll_TOP(addr, exp_data, mask);
-    } else if (dev_id == HDMIRX_DEV_ID_DWC) {
-        hdmirx_poll_DWC(addr, exp_data, mask, 0);
-    } else if (dev_id == HDMIRX_DEV_ID_PHY) {
-        hdmirx_poll_PHY(addr, exp_data, mask);
-    } else {
-        stimulus_print("Error: hdmirx_poll_reg access unknown device ID!\n");
-        stimulus_finish_fail(10);
-    }
-} /* hdmirx_poll_reg */
-
-void hdmirx_edid_setting (unsigned char edid_extension_flag)
-{
-    const unsigned char rx_edid[] = {
-        // Block 0:
-        0,                  // BLK_0_0   Reserved
-        255,                // BLK_0_1   
-        255,                // BLK_0_2   
-        255,                // BLK_0_3   
-        255,                // BLK_0_4   
-        255,                // BLK_0_5   
-        255,                // BLK_0_6   
-        0,                  // BLK_0_7   
-        83,                 // BLK_0_8   ID_MAN_NAME_7_0
-        3,                  // BLK_0_9   ID_MAN_NAME_15_8
-        65,                 // BLK_0_10  ID_PRO_CODE_7_0
-        1,                  // BLK_0_11  ID_PRO_CODE_15_8
-        0,                  // BLK_0_12  ID_SER_NUM_7_0
-        0,                  // BLK_0_13  ID_SER_NUM_15_8
-        0,                  // BLK_0_14  ID_SER_NUM_23_16
-        0,                  // BLK_0_15  ID_SER_NUM_31_24
-        0,                  // BLK_0_16  ID_MAN_WEEK_7_0
-        18,                 // BLK_0_17  ID_MAN_YEAR_7_0
-        1,                  // BLK_0_18  ID_VER_7_0
-        3,                  // BLK_0_19  ID_REV_7_0
-        128,                // BLK_0_20  ID_VID_IN_DEF_7_0
-        105,                // BLK_0_21  ID_MAX_HOR_SIZE_7_0
-        59,                 // BLK_0_22  ID_MAX_VER_SIZE_7_0
-        120,                // BLK_0_23  ID_GAM_7_0
-        10,                 // BLK_0_24  ID_FEAT_SUP_7_0
-        13,                 // BLK_0_25  ID_RG_LOW_BITS_7_0
-        201,                // BLK_0_26  ID_BW_LOW_BIT_7_0
-        160,                // BLK_0_27  ID_RX_7_0
-        87,                 // BLK_0_28  ID_RY_7_0
-        71,                 // BLK_0_29  ID_GX_7_0
-        152,                // BLK_0_30  ID_GY_7_0
-        39,                 // BLK_0_31  ID_BX_7_0
-        18,                 // BLK_0_32  ID_BY_7_0
-        72,                 // BLK_0_33  ID_WX_7_0
-        76,                 // BLK_0_34  ID_WY_7_0
-        32,                 // BLK_0_35  ID_TIM_1_7_0
-        0,                  // BLK_0_36  ID_TIM_2_7_0
-        0,                  // BLK_0_37  ID_TIM_RES_7_0
-        1,                  // BLK_0_38  ID_STD_TIM_7_0
-        1,                  // BLK_0_39  ID_STD_TIM_15_8
-        1,                  // BLK_0_40  ID_STD_TIM_ID_2_7_0
-        1,                  // BLK_0_41  ID_STD_TIM_ID_2_15_8
-        1,                  // BLK_0_42  ID_STD_TIM_ID_3_7_0
-        1,                  // BLK_0_43  ID_STD_TIM_ID_3_15_8
-        1,                  // BLK_0_44  ID_STD_TIM_ID_4_7_0
-        1,                  // BLK_0_45  ID_STD_TIM_ID_4_15_8
-        1,                  // BLK_0_46  ID_STD_TIM_ID_5_7_0
-        1,                  // BLK_0_47  ID_STD_TIM_ID_5_15_8
-        1,                  // BLK_0_48  ID_STD_TIM_ID_6_7_0
-        1,                  // BLK_0_49  ID_STD_TIM_ID_6_15_8
-        1,                  // BLK_0_50  ID_STD_TIM_ID_7_7_0
-        1,                  // BLK_0_51  ID_STD_TIM_ID_7_15_8
-        1,                  // BLK_0_52  ID_STD_TIM_ID_8_7_0
-        1,                  // BLK_0_53  ID_STD_TIM_ID_8_15_8
-        2,                  // BLK_0_54  ID_DET_TIM_DES_1_7_0
-        58,                 // BLK_0_55  ID_DET_TIM_DES_1_15_8
-        128,                // BLK_0_56  ID_DET_TIM_DES_1_23_16
-        208,                // BLK_0_57  ID_DET_TIM_DES_1_31_24
-        114,                // BLK_0_58  ID_DET_TIM_DES_1_39_32
-        56,                 // BLK_0_59  ID_DET_TIM_DES_1_47_40
-        45,                 // BLK_0_60  ID_DET_TIM_DES_1_55_48
-        64,                 // BLK_0_61  ID_DET_TIM_DES_1_63_5
-        16,                 // BLK_0_62  ID_DET_TIM_DES_1_71_64
-        44,                 // BLK_0_63  ID_DET_TIM_DES_1_79_72
-        69,                 // BLK_0_64  ID_DET_TIM_DES_1_87_80
-        128,                // BLK_0_65  ID_DET_TIM_DES_1_95_88
-        196,                // BLK_0_66  ID_DET_TIM_DES_1_103_96
-        142,                // BLK_0_67  ID_DET_TIM_DES_1_111_104
-        33,                 // BLK_0_68  ID_DET_TIM_DES_1_119_112
-        0,                  // BLK_0_69  ID_DET_TIM_DES_1_127_120
-        0,                  // BLK_0_70  ID_DET_TIM_DES_1_135_128
-        30,                 // BLK_0_71  ID_DET_TIM_DES_1_143_136
-        140,                // BLK_0_72  ID_DET_TIM_DES_2_7_0
-        10,                 // BLK_0_73  ID_DET_TIM_DES_2_15_8
-        208,                // BLK_0_74  ID_DET_TIM_DES_2_23_16
-        144,                // BLK_0_75  ID_DET_TIM_DES_2_31_24
-        32,                 // BLK_0_76  ID_DET_TIM_DES_2_39_32
-        64,                 // BLK_0_77  ID_DET_TIM_DES_2_47_40
-        49,                 // BLK_0_78  ID_DET_TIM_DES_2_55_48
-        32,                 // BLK_0_79  ID_DET_TIM_DES_2_63_56
-        12,                 // BLK_0_80  ID_DET_TIM_DES_2_71_64
-        64,                 // BLK_0_81  ID_DET_TIM_DES_2_79_72
-        85,                 // BLK_0_82  ID_DET_TIM_DES_2_87_80
-        0,                  // BLK_0_83  ID_DET_TIM_DES_2_95_88
-        196,                // BLK_0_84  ID_DET_TIM_DES_2_103_96
-        142,                // BLK_0_85  ID_DET_TIM_DES_2_111_104
-        33,                 // BLK_0_86  ID_DET_TIM_DES_2_119_112
-        0,                  // BLK_0_87  ID_DET_TIM_DES_2_127_120
-        0,                  // BLK_0_88  ID_DET_TIM_DES_2_135_128
-        24,                 // BLK_0_89  ID_DET_TIM_DES_2_143_136
-        0,                  // BLK_0_90  ID_DET_TIM_DES_3_7_0
-        0,                  // BLK_0_91  ID_DET_TIM_DES_3_15_8
-        0,                  // BLK_0_92  ID_DET_TIM_DES_3_23_16
-        252,                // BLK_0_93  ID_DET_TIM_DES_3_31_24
-        0,                  // BLK_0_94  ID_DET_TIM_DES_3_39_32
-        84,                 // BLK_0_95  ID_DET_TIM_DES_3_47_40
-        88,                 // BLK_0_96  ID_DET_TIM_DES_3_55_48
-        67,                 // BLK_0_97  ID_DET_TIM_DES_3_63_56
-        45,                 // BLK_0_98  ID_DET_TIM_DES_3_71_64
-        72,                 // BLK_0_99  ID_DET_TIM_DES_3_79_72
-        68,                 // BLK_0_100 ID_DET_TIM_DES_3_87_80
-        77,                 // BLK_0_101 ID_DET_TIM_DES_3_95_88
-        73,                 // BLK_0_102 ID_DET_TIM_DES_3_103_96
-        10,                 // BLK_0_103 ID_DET_TIM_DES_3_111_104
-        32,                 // BLK_0_104 ID_DET_TIM_DES_3_119_112
-        32,                 // BLK_0_105 ID_DET_TIM_DES_3_127_120
-        32,                 // BLK_0_106 ID_DET_TIM_DES_3_135_128
-        32,                 // BLK_0_107 ID_DET_TIM_DES_3_143_136
-        0,                  // BLK_0_108 ID_DET_TIM_DES_4_7_0
-        0,                  // BLK_0_109 ID_DET_TIM_DES_4_15_8
-        0,                  // BLK_0_110 ID_DET_TIM_DES_4_23_16
-        253,                // BLK_0_111 ID_DET_TIM_DES_4_31_24
-        0,                  // BLK_0_112 ID_DET_TIM_DES_4_39_32
-        23,                 // BLK_0_113 ID_DET_TIM_DES_4_47_40
-        61,                 // BLK_0_114 ID_DET_TIM_DES_4_55_48
-        15,                 // BLK_0_115 ID_DET_TIM_DES_4_63_56
-        68,                 // BLK_0_116 ID_DET_TIM_DES_4_71_64
-        15,                 // BLK_0_117 ID_DET_TIM_DES_4_79_72
-        0,                  // BLK_0_118 ID_DET_TIM_DES_4_87_80
-        10,                 // BLK_0_119 ID_DET_TIM_DES_4_95_88
-        32,                 // BLK_0_120 ID_DET_TIM_DES_4_103_96
-        32,                 // BLK_0_121 ID_DET_TIM_DES_4_111_104
-        32,                 // BLK_0_122 ID_DET_TIM_DES_4_119_112
-        32,                 // BLK_0_123 ID_DET_TIM_DES_4_127_120
-        32,                 // BLK_0_124 ID_DET_TIM_DES_4_135_128
-        32,                 // BLK_0_125 ID_DET_TIM_DES_4_143_136
-        edid_extension_flag,// BLK_0_126 EXT_FLAG_7_0//1,
-        191,                // BLK_0_127 CHECKSUM_7_0
-        // Block 1:
-        2,                  // BLK_1_0
-        3,                  // BLK_1_1
-        81,                 // BLK_1_2
-        113,                // BLK_1_3
-        95,                 // BLK_1_4
-        144,                // BLK_1_5
-        2,                  // BLK_1_6
-        3,                  // BLK_1_7
-        4,                  // BLK_1_8
-        1,                  // BLK_1_9
-        5,                  // BLK_1_10
-        6,                  // BLK_1_11
-        7,                  // BLK_1_12
-        8,                  // BLK_1_13
-        9,                  // BLK_1_14
-        10,                 // BLK_1_15
-        11,                 // BLK_1_16
-        12,                 // BLK_1_17
-        13,                 // BLK_1_18
-        14,                 // BLK_1_19
-        15,                 // BLK_1_20
-        17,                 // BLK_1_21
-        18,                 // BLK_1_22
-        19,                 // BLK_1_23
-        20,                 // BLK_1_24
-        21,                 // BLK_1_25
-        22,                 // BLK_1_26
-        23,                 // BLK_1_27
-        24,                 // BLK_1_28
-        25,                 // BLK_1_29
-        26,                 // BLK_1_30
-        27,                 // BLK_1_31
-        28,                 // BLK_1_32
-        29,                 // BLK_1_33
-        30,                 // BLK_1_34
-        31,                 // BLK_1_35
-        92,                 // BLK_1_36
-        32,                 // BLK_1_37
-        33,                 // BLK_1_38
-        34,                 // BLK_1_39
-        35,                 // BLK_1_40
-        36,                 // BLK_1_41
-        37,                 // BLK_1_42 
-        38,                 // BLK_1_43 
-        39,                 // BLK_1_44 
-        40,                 // BLK_1_45 
-        41,                 // BLK_1_46 
-        42,                 // BLK_1_47 
-        43,                 // BLK_1_48 
-        44,                 // BLK_1_49 
-        45,                 // BLK_1_50 
-        46,                 // BLK_1_51 
-        47,                 // BLK_1_52 
-        48,                 // BLK_1_53 
-        49,                 // BLK_1_54 
-        50,                 // BLK_1_55 
-        51,                 // BLK_1_56 
-        52,                 // BLK_1_57 
-        53,                 // BLK_1_58 
-        54,                 // BLK_1_59 
-        55,                 // BLK_1_60 
-        56,                 // BLK_1_61 
-        57,                 // BLK_1_62 
-        58,                 // BLK_1_63 
-        59,                 // BLK_1_64 
-        35,                 // BLK_1_65 
-        9,                  // BLK_1_66 
-        31,                 // BLK_1_67 
-        7,                  // BLK_1_68 
-        131,                // BLK_1_69 
-        1,                  // BLK_1_70 
-        0,                  // BLK_1_71 
-        0,                  // BLK_1_72 
-        103,                // BLK_1_73 
-        3,                  // BLK_1_74 
-        12,                 // BLK_1_75 
-        0,                  // BLK_1_76 
-        16,                 // BLK_1_77 
-        0,                  // BLK_1_78 
-        8,                  // BLK_1_79 
-        30,                 // BLK_1_80 
-        0,                  // BLK_1_81 
-        0,                  // BLK_1_82 
-        0,                  // BLK_1_83 
-        0,                  // BLK_1_84 
-        0,                  // BLK_1_85 
-        0,                  // BLK_1_86 
-        0,                  // BLK_1_87 
-        0,                  // BLK_1_88 
-        0,                  // BLK_1_89 
-        0,                  // BLK_1_90 
-        0,                  // BLK_1_91 
-        0,                  // BLK_1_92 
-        0,                  // BLK_1_93 
-        0,                  // BLK_1_94 
-        0,                  // BLK_1_95 
-        0,                  // BLK_1_96 
-        0,                  // BLK_1_97 
-        0,                  // BLK_1_98 
-        0,                  // BLK_1_99 
-        0,                  // BLK_1_100
-        0,                  // BLK_1_101
-        0,                  // BLK_1_102
-        0,                  // BLK_1_103
-        0,                  // BLK_1_104
-        0,                  // BLK_1_105
-        0,                  // BLK_1_106
-        0,                  // BLK_1_107
-        0,                  // BLK_1_108
-        0,                  // BLK_1_109
-        0,                  // BLK_1_110
-        0,                  // BLK_1_111
-        0,                  // BLK_1_112
-        0,                  // BLK_1_113
-        0,                  // BLK_1_114
-        0,                  // BLK_1_115
-        0,                  // BLK_1_116
-        0,                  // BLK_1_117
-        0,                  // BLK_1_118
-        0,                  // BLK_1_119
-        0,                  // BLK_1_120
-        0,                  // BLK_1_121
-        0,                  // BLK_1_122
-        0,                  // BLK_1_123
-        0,                  // BLK_1_124
-        0,                  // BLK_1_125
-        0,                  // BLK_1_126
-        146,                // BLK_1_127 CHECKSUM_7_0
-        // Block 2:
-        22,                 // BLK_2_0  
-        23,                 // BLK_2_1  
-        24,                 // BLK_2_2  
-        25,                 // BLK_2_3  
-        26,                 // BLK_2_4  
-        27,                 // BLK_2_5  
-        28,                 // BLK_2_6  
-        29,                 // BLK_2_7  
-        30,                 // BLK_2_8  
-        31,                 // BLK_2_9  
-        32,                 // BLK_2_10 
-        33,                 // BLK_2_11 
-        34,                 // BLK_2_12 
-        35,                 // BLK_2_13 
-        36,                 // BLK_2_14 
-        37,                 // BLK_2_15 
-        38,                 // BLK_2_16 
-        39,                 // BLK_2_17 
-        40,                 // BLK_2_18 
-        41,                 // BLK_2_19 
-        42,                 // BLK_2_20 
-        43,                 // BLK_2_21 
-        44,                 // BLK_2_22 
-        45,                 // BLK_2_23 
-        46,                 // BLK_2_24 
-        47,                 // BLK_2_25 
-        48,                 // BLK_2_26 
-        49,                 // BLK_2_27 
-        50,                 // BLK_2_28 
-        51,                 // BLK_2_29 
-        52,                 // BLK_2_30 
-        53,                 // BLK_2_31 
-        54,                 // BLK_2_32 
-        55,                 // BLK_2_33 
-        56,                 // BLK_2_34 
-        57,                 // BLK_2_35 
-        58,                 // BLK_2_36 
-        59,                 // BLK_2_37 
-        60,                 // BLK_2_38 
-        61,                 // BLK_2_39 
-        62,                 // BLK_2_40 
-        63,                 // BLK_2_41 
-        64,                 // BLK_2_42 
-        65,                 // BLK_2_43 
-        66,                 // BLK_2_44 
-        67,                 // BLK_2_45 
-        68,                 // BLK_2_46 
-        69,                 // BLK_2_47 
-        70,                 // BLK_2_48 
-        71,                 // BLK_2_49 
-        72,                 // BLK_2_50 
-        73,                 // BLK_2_51 
-        74,                 // BLK_2_52 
-        75,                 // BLK_2_53 
-        76,                 // BLK_2_54 
-        77,                 // BLK_2_55 
-        78,                 // BLK_2_56 
-        79,                 // BLK_2_57 
-        80,                 // BLK_2_58 
-        81,                 // BLK_2_59 
-        82,                 // BLK_2_60 
-        83,                 // BLK_2_61 
-        84,                 // BLK_2_62 
-        85,                 // BLK_2_63 
-        86,                 // BLK_2_64 
-        87,                 // BLK_2_65 
-        88,                 // BLK_2_66 
-        89,                 // BLK_2_67 
-        90,                 // BLK_2_68 
-        91,                 // BLK_2_69 
-        92,                 // BLK_2_70 
-        93,                 // BLK_2_71 
-        94,                 // BLK_2_72 
-        95,                 // BLK_2_73 
-        96,                 // BLK_2_74 
-        97,                 // BLK_2_75 
-        98,                 // BLK_2_76 
-        99,                 // BLK_2_77 
-        100,                // BLK_2_78 
-        101,                // BLK_2_79 
-        102,                // BLK_2_80 
-        103,                // BLK_2_81 
-        104,                // BLK_2_82 
-        105,                // BLK_2_83 
-        106,                // BLK_2_84 
-        107,                // BLK_2_85 
-        108,                // BLK_2_86 
-        109,                // BLK_2_87 
-        110,                // BLK_2_88 
-        111,                // BLK_2_89 
-        112,                // BLK_2_90 
-        113,                // BLK_2_91 
-        114,                // BLK_2_92 
-        115,                // BLK_2_93 
-        116,                // BLK_2_94 
-        117,                // BLK_2_95 
-        118,                // BLK_2_96 
-        119,                // BLK_2_97 
-        120,                // BLK_2_98 
-        121,                // BLK_2_99 
-        122,                // BLK_2_100
-        123,                // BLK_2_101
-        124,                // BLK_2_102
-        125,                // BLK_2_103
-        126,                // BLK_2_104
-        127,                // BLK_2_105
-        128,                // BLK_2_106
-        129,                // BLK_2_107
-        130,                // BLK_2_108
-        131,                // BLK_2_109
-        132,                // BLK_2_110
-        133,                // BLK_2_111
-        134,                // BLK_2_112
-        135,                // BLK_2_113
-        136,                // BLK_2_114
-        137,                // BLK_2_115
-        138,                // BLK_2_116
-        139,                // BLK_2_117
-        140,                // BLK_2_118
-        141,                // BLK_2_119
-        142,                // BLK_2_120
-        143,                // BLK_2_121
-        144,                // BLK_2_122
-        145,                // BLK_2_123
-        146,                // BLK_2_124
-        147,                // BLK_2_125
-        148,                // BLK_2_126
-        149};               // BLK_2_127 CHECKSUM_7_0
-
-    int i, ram_addr, byte_num;
-    unsigned int value;
-    
-    //byte_num = sizeof(rx_edid)/sizeof(unsigned char);
-    
-    byte_num = (edid_extension_flag<=2)? (1+edid_extension_flag)*128 : 3*128;
-    for (i = 0; i < byte_num; i++)
-    {
-        value = rx_edid[i]; 
-        ram_addr = HDMIRX_TOP_EDID_OFFSET+i;
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, ram_addr, value);
-    }
-} /* hdmirx_edid_setting */
-
-void hdmirx_key_setting (unsigned char encrypt_en)
-{
-    //first set of test Device Private Keys (HDCP Table A-1, Receiver B1)
-    const unsigned long hdmirx_hdcp_bksvs[2]    = {0x51, 0x1ef21acd}; // {high 8-bit, low32-bit}
-    const unsigned long hdmirx_hdcp_keys[40*2]  = {
-        0xbc13e0, 0xc75bf0fd,   // key set  0: {high 24-bit, low 32-bit}
-        0xae0d2c, 0x7f76443b,   // key set  1: {high 24-bit, low 32-bit}
-        0x24bf21, 0x85a36c60,   // key set  2: {high 24-bit, low 32-bit}
-        0xf4bc6c, 0xbcd7a32f,   // key set  3: {high 24-bit, low 32-bit}
-        0xa72e69, 0xc5eb6388,   // key set  4: {high 24-bit, low 32-bit}
-        0x7fa2d2, 0x7a37d9f8,   // key set  5: {high 24-bit, low 32-bit}
-        0x32fd35, 0x29dea3d1,   // key set  6: {high 24-bit, low 32-bit}
-        0x485fc2, 0x40cc9bae,   // key set  7: {high 24-bit, low 32-bit}
-        0x3b9857, 0x797d5103,   // key set  8: {high 24-bit, low 32-bit}
-        0x0dd170, 0xbe615250,   // key set  9: {high 24-bit, low 32-bit}
-        0x1a748b, 0xe4866bb1,   // key set 10: {high 24-bit, low 32-bit}
-        0xf9606a, 0x7c348cca,   // key set 11: {high 24-bit, low 32-bit}
-        0x4bbb03, 0x7899eea1,   // key set 12: {high 24-bit, low 32-bit}
-        0x190ecf, 0x9cc095a9,   // key set 13: {high 24-bit, low 32-bit}
-        0xa821c4, 0x6897447f,   // key set 14: {high 24-bit, low 32-bit}
-        0x1a8a0b, 0xc4298a41,   // key set 15: {high 24-bit, low 32-bit}
-        0xaefc08, 0x53e62082,   // key set 16: {high 24-bit, low 32-bit}
-        0xf75d4a, 0x0c497ba4,   // key set 17: {high 24-bit, low 32-bit}
-        0xad6495, 0xfc8a06d8,   // key set 18: {high 24-bit, low 32-bit}
-        0x67c202, 0x0c2b2e02,   // key set 19: {high 24-bit, low 32-bit}
-        0x8f116b, 0x18f4ae8d,   // key set 20: {high 24-bit, low 32-bit}
-        0xe3053f, 0xa3e9fa69,   // key set 21: {high 24-bit, low 32-bit}
-        0x37d800, 0x2881c7d1,   // key set 22: {high 24-bit, low 32-bit}
-        0xc3a5fd, 0x1c15669c,   // key set 23: {high 24-bit, low 32-bit}
-        0x9e93d4, 0x1e0811f7,   // key set 24: {high 24-bit, low 32-bit}
-        0x2c4074, 0x509eec6c,   // key set 25: {high 24-bit, low 32-bit}
-        0x8b7fd8, 0x19279b61,   // key set 26: {high 24-bit, low 32-bit}
-        0xd7caad, 0xa0a06ce9,   // key set 27: {high 24-bit, low 32-bit}
-        0x9297dc, 0xa1f8c1db,   // key set 28: {high 24-bit, low 32-bit}
-        0x5d1aaa, 0x99dea489,   // key set 29: {high 24-bit, low 32-bit}
-        0x60cb56, 0xddbaa1d9,   // key set 30: {high 24-bit, low 32-bit}
-        0x85d4ad, 0x5e5ff2e0,   // key set 31: {high 24-bit, low 32-bit}
-        0x128016, 0x1221df6d,   // key set 32: {high 24-bit, low 32-bit}
-        0xca31a5, 0xf2406589,   // key set 33: {high 24-bit, low 32-bit}
-        0x1d30e8, 0xcb198e6f,   // key set 34: {high 24-bit, low 32-bit}
-        0xd1c18b, 0xed07d3fa,   // key set 35: {high 24-bit, low 32-bit}
-        0xcec7ec, 0x09245b43,   // key set 36: {high 24-bit, low 32-bit}
-        0xb08129, 0xefedd583,   // key set 37: {high 24-bit, low 32-bit}
-        0x2134cf, 0x4ce286e5,   // key set 38: {high 24-bit, low 32-bit}
-        0xedeef9, 0xd099b78c    // key set 39: {high 24-bit, low 32-bit}
-    }; /* hdmirx_hdcp_keys */
-    const unsigned long hdmirx_hdcp_key_decrypt_seed    = 0xA55A;
-    const unsigned long hdmirx_hdcp_encrypt_keys[40*2]  = {
-        0xC0E0BD, 0x0AB26F9F,   // key set  0: {high 24-bit, low 32-bit}
-        0x0B90B3, 0xE9B2B75F,   // key set  1: {high 24-bit, low 32-bit}
-        0xBD00B5, 0xD15859EE,   // key set  2: {high 24-bit, low 32-bit}
-        0xD89597, 0x7578E44C,   // key set  3: {high 24-bit, low 32-bit}
-        0x4AFF12, 0xFCC45CA2,   // key set  4: {high 24-bit, low 32-bit}
-        0x36555B, 0xD5B12FAF,   // key set  5: {high 24-bit, low 32-bit}
-        0x8AE77F, 0x4EDFD419,   // key set  6: {high 24-bit, low 32-bit}
-        0x7AA3D0, 0x0FD2C60F,   // key set  7: {high 24-bit, low 32-bit}
-        0x79052E, 0xBD613745,   // key set  8: {high 24-bit, low 32-bit}
-        0xB67BB5, 0xE12AE0A6,   // key set  9: {high 24-bit, low 32-bit}
-        0x78B9DD, 0xF6629AC5,   // key set 10: {high 24-bit, low 32-bit}
-        0x61DEEE, 0x2BFE2F2F,   // key set 11: {high 24-bit, low 32-bit}
-        0x1A40B2, 0x1F63F998,   // key set 12: {high 24-bit, low 32-bit}
-        0x5A9AE6, 0xDE543C62,   // key set 13: {high 24-bit, low 32-bit}
-        0x65DF19, 0xA00E5744,   // key set 14: {high 24-bit, low 32-bit}
-        0x6C684F, 0x4B65A8BB,   // key set 15: {high 24-bit, low 32-bit}
-        0x7DA075, 0xB7F8D6CC,   // key set 16: {high 24-bit, low 32-bit}
-        0x1DE01C, 0xEEADFBC8,   // key set 17: {high 24-bit, low 32-bit}
-        0x06E607, 0xC4DC61C4,   // key set 18: {high 24-bit, low 32-bit}
-        0xA3BB1E, 0xD7510D5E,   // key set 19: {high 24-bit, low 32-bit}
-        0x02F495, 0xECEB5843,   // key set 20: {high 24-bit, low 32-bit}
-        0x80E13E, 0x57081DCB,   // key set 21: {high 24-bit, low 32-bit}
-        0x6FB563, 0x6F2E0EAB,   // key set 22: {high 24-bit, low 32-bit}
-        0x72439F, 0x4058074B,   // key set 23: {high 24-bit, low 32-bit}
-        0xB98261, 0xF21FBEEF,   // key set 24: {high 24-bit, low 32-bit}
-        0xC1EB77, 0x5AECDF3B,   // key set 25: {high 24-bit, low 32-bit}
-        0xF780A5, 0x5E975124,   // key set 26: {high 24-bit, low 32-bit}
-        0xE1DB09, 0x5E94F736,   // key set 27: {high 24-bit, low 32-bit}
-        0x8FFA7B, 0x82786B25,   // key set 28: {high 24-bit, low 32-bit}
-        0xE60823, 0x52B35574,   // key set 29: {high 24-bit, low 32-bit}
-        0x212A04, 0x82E7C09F,   // key set 30: {high 24-bit, low 32-bit}
-        0x38AF79, 0xC2A06F25,   // key set 31: {high 24-bit, low 32-bit}
-        0xFB17B5, 0x2A46ACA3,   // key set 32: {high 24-bit, low 32-bit}
-        0x2C2DE0, 0x1316DBC3,   // key set 33: {high 24-bit, low 32-bit}
-        0x5E5761, 0x758CCA16,   // key set 34: {high 24-bit, low 32-bit}
-        0x4D93A9, 0x09C6A332,   // key set 35: {high 24-bit, low 32-bit}
-        0xFA6BF7, 0x463357F5,   // key set 36: {high 24-bit, low 32-bit}
-        0x60B17C, 0xA1A5D7FA,   // key set 37: {high 24-bit, low 32-bit}
-        0x7BB35C, 0x605646D5,   // key set 38: {high 24-bit, low 32-bit}
-        0x28AAD1, 0x52893794    // key set 39: {high 24-bit, low 32-bit}
-    }; /* hdmirx_hdcp_encrypt_keys */
-
-    int i;
-    
-    if (encrypt_en) {
-        hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_SEED,  hdmirx_hdcp_key_decrypt_seed);
-    }
-
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_KIDX,      0);
-    for (i = 0; i < 40; i ++) {
-        hdmirx_poll_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_STS, 1, 0);
-        hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_KEY1,  encrypt_en? hdmirx_hdcp_encrypt_keys[i*2]   : hdmirx_hdcp_keys[i*2]);
-        hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_KEY0,  encrypt_en? hdmirx_hdcp_encrypt_keys[i*2+1] : hdmirx_hdcp_keys[i*2+1]);
-    }
-    
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_BKSV1, hdmirx_hdcp_bksvs[0]);
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_BKSV0, hdmirx_hdcp_bksvs[1]);
-} /* hdmirx_key_setting */
-
-void start_video_gen_ana (  unsigned char   vic,                // Video format identification code
-                            unsigned char   pixel_repeat_hdmi,
-                            unsigned char   interlace_mode,     // 0=Progressive; 1=Interlace.
-                            unsigned long   front_porch,        // Number of pixels from DE Low to HSYNC high
-                            unsigned long   back_porch,         // Number of pixels from HSYNC low to DE high
-                            unsigned long   hsync_pixels,       // Number of pixels of HSYNC pulse
-                            unsigned long   hsync_polarity,     // TX HSYNC polarity: 0=low active; 1=high active.
-                            unsigned long   sof_lines,          // HSYNC count between VSYNC de-assertion and first line of active video
-                            unsigned long   eof_lines,          // HSYNC count between last line of active video and start of VSYNC
-                            unsigned long   vsync_lines,        // HSYNC count of VSYNC assertion
-                            unsigned long   vsync_polarity,     // TX VSYNC polarity: 0=low active; 1=high active.
-                            unsigned long   total_pixels,       // Number of total pixels per line
-                            unsigned long   total_lines)        // Number of total lines per frame
-{
-    unsigned long data32;
-    
-    stimulus_print("[TEST.C] Configure external video data generator\n");
-    
-    data32  = vic               << 0;
-    data32 |= pixel_repeat_hdmi << 8;
-    data32 |= interlace_mode    << 12;
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_SET_VIC | data32);
-    
-    data32  = front_porch       << 0;
-    data32 |= back_porch        << 12;
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_SET_HSYNC_0 | data32);
-    
-    data32  = hsync_pixels      << 0;
-    data32 |= hsync_polarity    << 12;
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_SET_HSYNC_1 | data32);
-    
-    data32  = sof_lines << 0;
-    data32 |= eof_lines << 12;
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_SET_VSYNC_0 | data32);
-    
-    data32  = vsync_lines       << 0;
-    data32 |= vsync_polarity    << 12;
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_SET_VSYNC_1 | data32);
-
-    data32  = total_pixels      << 0;
-    data32 |= total_lines       << 12;
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_SET_HV_TOTAL | data32);
-
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_VGEN_RESET        | 0);
-}
-
-void hdmirx_test_function ( unsigned char   acr_mode,                   // Select which ACR scheme: 0=Analog PLL based ACR; 1=Digital ACR.
-                            unsigned long   manual_acr_cts,
-                            unsigned long   manual_acr_n,
-                            unsigned char   rx_8_channel,               // Audio channels: 0=2-channel; 1=4 x 2-channel.
-                            unsigned char   edid_extension_flag,        // Number of 128-bytes blocks that following the basic block
-                            unsigned char   edid_auto_cec_enable,       // 1=Automatic switch CEC ID depend on RX_PORT_SEL
-                            unsigned long   edid_cec_id_addr,           // EDID address offsets for storing 2-byte of Physical Address
-                            unsigned long   edid_cec_id_data,           // Physical Address: e.g. 0x1023 is 1.0.2.3
-                            unsigned char   edid_auto_checksum_enable,  // Checksum byte selection: 0=Use data stored in MEM; 1=Use checksum calculated by HW.
-                            unsigned char   edid_clk_divide_m1,         // EDID I2C clock = sysclk / (1+edid_clk_divide_m1).
-                            unsigned char   hdcp_on,
-                            unsigned char   hdcp_key_decrypt_en,
-                            unsigned char   vic,                        // Video format identification code
-                            unsigned char   pixel_repeat_hdmi,
-                            unsigned char   interlace_mode,             // 0=Progressive; 1=Interlace.
-                            unsigned long   front_porch,                // Number of pixels from DE Low to HSYNC high
-                            unsigned long   back_porch,                 // Number of pixels from HSYNC low to DE high
-                            unsigned long   hsync_pixels,               // Number of pixels of HSYNC pulse
-                            unsigned long   hsync_polarity,             // TX HSYNC polarity: 0=low active; 1=high active.
-                            unsigned long   sof_lines,                  // HSYNC count between VSYNC de-assertion and first line of active video
-                            unsigned long   eof_lines,                  // HSYNC count between last line of active video and start of VSYNC
-                            unsigned long   vsync_lines,                // HSYNC count of VSYNC assertion
-                            unsigned char   vsync_polarity,             // TX VSYNC polarity: 0=low active; 1=high active.
-                            unsigned long   total_pixels,               // Number of total pixels per line
-                            unsigned long   total_lines,                // Number of total lines per frame
-                            unsigned char   rx_input_color_format,      // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444.
-                            unsigned char   rx_input_color_depth,       // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                            unsigned char   rx_hscale_half,             // 1=RX output video horizontally scaled by half, to reduce clock speed.
-                            unsigned long   *curr_pdec_ien_maskn,
-                            unsigned long   *curr_aud_clk_ien_maskn,
-                            unsigned long   *curr_aud_fifo_ien_maskn,
-                            unsigned long   *curr_md_ien_maskn,
-                            unsigned long   *curr_hdmi_ien_maskn,
-                            unsigned long   pdec_ien_maskn,
-                            unsigned long   aud_clk_ien_maskn,
-                            unsigned long   aud_fifo_ien_maskn,
-                            unsigned long   md_ien_maskn,
-                            unsigned long   hdmi_ien_maskn,
-                            unsigned char   rx_port_sel,                // Select HDMI RX input port: 0=PortA; 1=PortB; 2=PortC, 3=PortD; others=invalid.
-                            unsigned char   hdmi_arctx_en,              // Audio Return Channel (ARC) transmission block control:0=Disable; 1=Enable.
-                            unsigned char   hdmi_arctx_mode,            // ARC transmission mode: 0=Single-ended mode; 1=Common mode.
-                            unsigned char   *hdmi_pll_lock)
-{
-    unsigned long   data32;
-
-    stimulus_print("[TEST.C] Configure HDMIRX\n");
-
-    Wr_reg_bits(HHI_GCLK_MPEG0, 1, 21, 1);  // Turn on clk_hdmirx_pclk, also = sysclk
-
-    // Enable APB3 fail on error
-    *((volatile unsigned long *) HDMIRX_CTRL_PORT)          |= (1 << 15);   // APB3 to HDMIRX-TOP err_en
-    *((volatile unsigned long *) (HDMIRX_CTRL_PORT+0x10))   |= (1 << 15);   // APB3 to HDMIRX-DWC err_en
-
-    //--------------------------------------------------------------------------
-    // Enable HDMIRX interrupts:
-    //--------------------------------------------------------------------------
-    // [12]     meter_stable_chg_hdmi
-    // [11]     vid_colour_depth_chg
-    // [10]     vid_fmt_chg
-    // [9:6]    hdmirx_5v_fall
-    // [5:2]    hdmirx_5v_rise
-    // [1]      edid_addr_intr
-    // [0]      core_intr_rise: sub-interrupts will be configured later
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_INTR_MASKN, 0x00001fff);
-    
-    //--------------------------------------------------------------------------
-    // Step 1-13: RX_INITIAL_CONFIG
-    //--------------------------------------------------------------------------
-
-    // 1. DWC reset default to be active, until reg HDMIRX_TOP_SW_RESET[0] is set to 0.
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_SW_RESET, 0x1, 0x0);
-    
-    // 2. turn on clocks: md, cfg...
-
-    data32  = 0;
-    data32 |= 0 << 25;  // [26:25] HDMIRX mode detection clock mux select: osc_clk
-    data32 |= 1 << 24;  // [24]    HDMIRX mode detection clock enable
-    data32 |= 0 << 16;  // [22:16] HDMIRX mode detection clock divider
-    data32 |= 3 << 9;   // [10: 9] HDMIRX config clock mux select: fclk_div5=400MHz
-    data32 |= 1 << 8;   // [    8] HDMIRX config clock enable
-    data32 |= 3 << 0;   // [ 6: 0] HDMIRX config clock divider: 400/4=100MHz
-    Wr(HHI_HDMIRX_CLK_CNTL,     data32);
-
-    data32  = 0;
-    data32 |= 2             << 25;  // [26:25] HDMIRX ACR ref clock mux select: fclk_div5
-    data32 |= acr_mode      << 24;  // [24]    HDMIRX ACR ref clock enable
-    data32 |= 0             << 16;  // [22:16] HDMIRX ACR ref clock divider
-    data32 |= 2             << 9;   // [10: 9] HDMIRX audmeas clock mux select: fclk_div5
-    data32 |= 1             << 8;   // [    8] HDMIRX audmeas clock enable
-    data32 |= 1             << 0;   // [ 6: 0] HDMIRX audmeas clock divider: 400/2 = 200MHz
-    Wr(HHI_HDMIRX_AUD_CLK_CNTL, data32);
-
-    data32  = 0;
-    data32 |= 1 << 17;  // [17]     audfifo_rd_en
-    data32 |= 1 << 16;  // [16]     pktfifo_rd_en
-    data32 |= 1 << 2;   // [2]      hdmirx_cecclk_en
-    data32 |= 0 << 1;   // [1]      bus_clk_inv
-    data32 |= 0 << 0;   // [0]      hdmi_clk_inv
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_CLK_CNTL, data32);    // DEFAULT: {32'h0}
-
-    // 3. wait for TX PHY clock up
-    
-    // 4. wait for rx sense
-    
-    // 5. Release IP reset
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_SW_RESET, 0x0);
-
-    // 6. Enable functional modules
-    data32  = 0;
-    data32 |= 1 << 5;   // [5]      cec_enable
-    data32 |= 1 << 4;   // [4]      aud_enable
-    data32 |= 1 << 3;   // [3]      bus_enable
-    data32 |= 1 << 2;   // [2]      hdmi_enable
-    data32 |= 1 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-    //Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 5 ) {}  // delay 5uS
-            mdelay(1);
-
-    // 7. Reset functional modules
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_DMI_SW_RST,     0x0000007F);
-    //Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 10 ) {} // delay 10uS
-            mdelay(1);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_DMI_SW_RST,   0, 0);
-    
-    // 8. If defined, force manual N & CTS to speed up simulation
-
-    data32  = 0;
-    data32 |= 0         << 9;   // [9]      force_afif_status:1=Use cntl_audfifo_status_cfg as fifo status; 0=Use detected afif_status.
-    data32 |= 1         << 8;   // [8]      afif_status_auto:1=Enable audio FIFO status auto-exit EMPTY/FULL, if FIFO level is back to LipSync; 0=Once enters EMPTY/FULL, never exits.
-    data32 |= 1         << 6;   // [ 7: 6]  Audio FIFO nominal level :0=s_total/4;1=s_total/8;2=s_total/16;3=s_total/32.
-    data32 |= 3         << 4;   // [ 5: 4]  Audio FIFO critical level:0=s_total/4;1=s_total/8;2=s_total/16;3=s_total/32.
-    data32 |= 0         << 3;   // [3]      afif_status_clr:1=Clear audio FIFO status to IDLE.
-    data32 |= acr_mode  << 2;   // [2]      dig_acr_en
-    data32 |= 0         << 1;   // [1]      audmeas_clk_sel: 0=select aud_pll_clk; 1=select aud_acr_clk.
-    data32 |= acr_mode  << 0;   // [0]      aud_clk_sel: 0=select aud_pll_clk; 1=select aud_acr_clk.
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_ACR_CNTL_STAT, data32);
-
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUDPLL_GEN_CTS, manual_acr_cts);
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUDPLL_GEN_N,   manual_acr_n);
-
-    // Force N&CTS to start with, will switch to received values later on, for simulation speed up.
-    data32  = 0;
-    data32 |= 1 << 4;   // [4]      cts_n_ref: 0=used decoded; 1=use manual N&CTS.
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_CLK_CTRL,   data32);
-
-    data32  = 0;
-    data32 |= 0 << 28;  // [28]     pll_lock_filter_byp
-    data32 |= 0 << 24;  // [27:24]  pll_lock_toggle_div
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_PLL_CTRL,   data32);    // DEFAULT: {1'b0, 3'd0, 4'd6, 4'd3, 4'd8, 1'b0, 1'b0, 1'b1, 1'b0, 12'd0}
-    
-    // 9. Set EDID data at RX
-
-    hdmirx_edid_setting(edid_extension_flag);
-
-    data32  = 0;
-    data32 |= 0                         << 13;  // [   13]  checksum_init_mode
-    data32 |= edid_auto_checksum_enable << 12;  // [   12]  auto_checksum_enable
-    data32 |= edid_auto_cec_enable      << 11;  // [   11]  auto_cec_enable
-    data32 |= 0                         << 10;  // [   10]  scl_stretch_trigger_config
-    data32 |= 0                         << 9;   // [    9]  force_scl_stretch_trigger
-    data32 |= 1                         << 8;   // [    8]  scl_stretch_enable
-    data32 |= edid_clk_divide_m1 << 0;   // [ 7: 0]  clk_divide_m1
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_EDID_GEN_CNTL,  data32);
-    
-    if (edid_cec_id_addr != 0x00990098) {
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_EDID_ADDR_CEC,  edid_cec_id_addr);
-    }
-
-    if (rx_port_sel == 0) {
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_EDID_DATA_CEC_PORT01,  ((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8));
-    } else if (rx_port_sel == 1) {
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_EDID_DATA_CEC_PORT01,  (((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8))<<16);
-    } else if (rx_port_sel == 2) {
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_EDID_DATA_CEC_PORT23,  ((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8));
-    } else { // rx_port_sel == 3
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_EDID_DATA_CEC_PORT23,  (((edid_cec_id_data&0xff)<<8) | (edid_cec_id_data>>8))<<16);
-    }
-    
-    // 10. HDCP
-    if (hdcp_on) {
-        data32  = 0;
-        data32 |= 0                     << 14;  // [14]     hdcp_vid_de: Force DE=1.
-        data32 |= 0                     << 10;  // [11:10]  hdcp_sel_avmute: 0=normal mode.
-        data32 |= 0                     << 8;   // [9:8]    hdcp_ctl: 0=automatic.
-        data32 |= 0                     << 6;   // [7:6]    hdcp_ri_rate: 0=Ri exchange once every 128 frames.
-        data32 |= hdcp_key_decrypt_en   << 1;   // [1]      key_decrypt_enable
-        data32 |= hdcp_on               << 0;   // [0]      hdcp_enable
-        hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_CTRL,  data32);
-    
-        data32  = 0;
-        data32 |= 1                     << 16;  // [17:16]  i2c_spike_suppr
-        data32 |= 1                     << 13;  // [13]     hdmi_reserved. 0=No HDMI capabilities.
-        data32 |= 1                     << 12;  // [12]     fast_i2c
-        data32 |= 1                     << 9;   // [9]      one_dot_one
-        data32 |= 1                     << 8;   // [8]      fast_reauth
-        data32 |= 0x3a                  << 1;   // [7:1]    hdcp_ddc_addr
-        hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDCP_SETTINGS,  data32);    // DEFAAULT: {13'd0, 2'd1, 1'b1, 3'd0, 1'b1, 2'd0, 1'b1, 1'b1, 7'd58, 1'b0}
-
-        hdmirx_key_setting(hdcp_key_decrypt_en);
-    } /* if (hdcp_on) */
-
-    // 11. RX configuration
-
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_CKM_EVLTM, 0x0016fff0);
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_CKM_F,     0xf98a0190);
-
-    data32  = 0;
-    data32 |= 80    << 18;  // [26:18]  afif_th_start
-    data32 |= 8     << 9;   // [17:9]   afif_th_max
-    data32 |= 8     << 0;   // [8:0]    afif_th_min
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_FIFO_TH,    data32);
-
-    data32  = 0;
-    data32 |= 0     << 24;  // [25:24]  mr_vs_pol_adj_mode
-    data32 |= 0     << 18;  // [18]     spike_filter_en
-    data32 |= 0     << 13;  // [17:13]  dvi_mode_hyst
-    data32 |= 0     << 8;   // [12:8]   hdmi_mode_hyst
-    data32 |= 0     << 6;   // [7:6]    hdmi_mode: 0=automatic
-    data32 |= 2     << 4;   // [5:4]    gb_det
-    data32 |= 0     << 2;   // [3:2]    eess_oess
-    data32 |= 1     << 0;   // [1:0]    sel_ctl01
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_MODE_RECOVER,  data32); // DEFAULT: {6'd0, 2'd0, 5'd0, 1'b0, 5'd8, 5'd8, 2'd0, 2'd0, 2'd0, 2'd0}
-
-    data32  = 0;
-    data32 |= 1     << 31;  // [31]     pfifo_store_filter_en
-    data32 |= 1     << 26;  // [26]     pfifo_store_mpegs_if
-    data32 |= 1     << 25;  // [25]     pfifo_store_aud_if
-    data32 |= 1     << 24;  // [24]     pfifo_store_spd_if
-    data32 |= 1     << 23;  // [23]     pfifo_store_avi_if
-    data32 |= 1     << 22;  // [22]     pfifo_store_vs_if
-    data32 |= 1     << 21;  // [21]     pfifo_store_gmtp
-    data32 |= 1     << 20;  // [20]     pfifo_store_isrc2
-    data32 |= 1     << 19;  // [19]     pfifo_store_isrc1
-    data32 |= 1     << 18;  // [18]     pfifo_store_acp
-    data32 |= 0     << 17;  // [17]     pfifo_store_gcp
-    data32 |= 0     << 16;  // [16]     pfifo_store_acr
-    data32 |= 0     << 14;  // [14]     gcpforce_clravmute
-    data32 |= 0     << 13;  // [13]     gcpforce_setavmute
-    data32 |= 0     << 12;  // [12]     gcp_avmute_allsps
-    data32 |= 0     << 8;   // [8]      pd_fifo_fill_info_clr
-    data32 |= 0     << 6;   // [6]      pd_fifo_skip
-    data32 |= 0     << 5;   // [5]      pd_fifo_clr
-    data32 |= 1     << 4;   // [4]      pd_fifo_we
-    data32 |= 1     << 0;   // [0]      pdec_bch_en
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_CTRL,  data32); // DEFAULT: {23'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 3'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 1     << 6;   // [6]      auto_vmute
-    data32 |= 0xf   << 2;   // [5:2]    auto_spflat_mute
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_ASP_CTRL,  data32); // DEFAULT: {25'd0, 1'b1, 4'd0, 2'd0}
-
-    data32  = 0;
-    data32 |= 1     << 16;  // [16]     afif_subpackets: 0=store all sp; 1=store only the ones' spX=1.
-    data32 |= 0     << 0;   // [0]      afif_init
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_FIFO_CTRL,  data32); // DEFAULT: {13'd0, 2'd0, 1'b1, 15'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 0     << 10;  // [10]     ws_disable
-    data32 |= 0     << 9;   // [9]      sck_disable
-    data32 |= 0     << 5;   // [8:5]    i2s_disable
-    data32 |= 0     << 1;   // [4:1]    spdif_disable
-    data32 |= 1     << 0;   // [0]      i2s_32_16 
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_SAO_CTRL,   data32); // DEFAULT: {21'd0, 1'b1, 1'b1, 4'd15, 4'd15, 1'b1}
-
-    // Manual de-repeat to speed up simulation
-    data32  = 0;
-    data32 |= pixel_repeat_hdmi << 1;   // [4:1]    man_vid_derepeat
-    data32 |= 0                 << 0;   // [0]      auto_derepeat
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_RESMPL_CTRL,   data32); // DEFAULT: {27'd0, 4'd0, 1'b1}
-
-    // At the 1st frame, HDMIRX hasn't received AVI packet, to speed up receiving YUV422 video, force oavi_video_format=1, release forcing on receiving AVI packet.
-    if (rx_input_color_format == 1) {
-        /*stimulus_event(31, STIMULUS_HDMI_UTIL_VID_FORMAT    |
-                           (1                       << 4)   |   // 0=Release force; 1=Force vid_fmt
-                           (rx_input_color_format   << 0));     // Video format: 0=RGB444; 1=YCbCr422; 2=YCbCr444.
-                           */
-    }
-
-    // At the 1st frame, HDMIRX hasn't received AVI packet, HDMIRX default video format to RGB, so manual/force something to speed up simulation:
-    data32  = 0;
-    data32 |= (((rx_input_color_depth==3) ||
-                (rx_hscale_half==1))? 1:0)  << 29;  // [29]     cntl_vid_clk_half: To make timing easier, this bit can be set to 1: if input is dn-sample by 1, or input is 3*16-bit.
-    data32 |= 0                             << 28;  // [28]     cntl_vs_timing: 0=Detect VS rising; 1=Detect HS falling.
-    data32 |= 0                             << 27;  // [27]     cntl_hs_timing: 0=Detect HS rising; 1=Detect HS falling.
-    // For receiving YUV444 video, we manually map component data to speed up simulation, manual-mapping will be cancelled once AVI is received.
-    if (rx_input_color_format == 2) {
-        data32 |= 2                         << 24;  // [26:24]  vid_data_map. 2={vid1, vid0, vid2}->{vid2, vid1, vid0}
-    } else {
-        data32 |= 0                         << 24;  // [26:24]  vid_data_map. 0={vid2, vid1, vid0}->{vid2, vid1, vid0}
-    }
-    data32 |= rx_hscale_half                << 23;  // [23]     hscale_half: 1=Horizontally scale down by half
-    data32 |= 0                             << 22;  // [22]     force_vid_rate: 1=Force video output sample rate
-    data32 |= 0                             << 19;  // [21:19]  force_vid_rate_chroma_cfg : 0=Bypass, not rate change. Applicable only if force_vid_rate=1
-    data32 |= 0                             << 16;  // [18:16]  force_vid_rate_luma_cfg   : 0=Bypass, not rate change. Applicable only if force_vid_rate=1
-    data32 |= 0x7fff                        << 0;   // [14: 0]  hsizem1
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_VID_CNTL,   data32);
-
-    // To speed up simulation:
-    // Force VS polarity until for the first 2 frames, because it takes one whole frame for HDMIRX to detect the correct VS polarity;
-    // HS polarity can be detected just after one line, so it can be set to auto-detect from the start.
-    data32  = 0;
-    data32 |= vsync_polarity    << 3;   // [4:3]    vs_pol_adj_mode:0=invert input VS; 1=no invert; 2=auto convert to high active; 3=no invert.
-    data32 |= 2                 << 1;   // [2:1]    hs_pol_adj_mode:0=invert input VS; 1=no invert; 2=auto convert to high active; 3=no invert.
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_SYNC_CTRL,     data32); // DEFAULT: {27'd0, 2'd0, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 3     << 21;  // [22:21]  aport_shdw_ctrl
-    data32 |= 2     << 19;  // [20:19]  auto_aclk_mute
-    data32 |= 1     << 10;  // [16:10]  aud_mute_speed
-    data32 |= 1     << 7;   // [7]      aud_avmute_en
-    data32 |= 1     << 5;   // [6:5]    aud_mute_sel
-    data32 |= 1     << 3;   // [4:3]    aud_mute_mode
-    data32 |= 0     << 1;   // [2:1]    aud_ttone_fs_sel
-    data32 |= 0     << 0;   // [0]      testtone_en 
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_MUTE_CTRL,  data32); // DEFAULT: {9'd0, 2'd0, 2'd0, 2'd0, 7'd48, 2'd0, 1'b1, 2'd3, 2'd3, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 0     << 4;   // [11:4]   audio_fmt_chg_thres
-    data32 |= 0     << 1;   // [2:1]    audio_fmt
-    data32 |= 0     << 0;   // [0]      audio_fmt_sel
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_PAO_CTRL,   data32); // DEFAULT: {20'd0, 8'd176, 1'b0, 2'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= (rx_8_channel? 0x7 :0x0)  << 8;   // [10:8]   ch_map[7:5]
-    data32 |= 1                         << 7;   // [7]      ch_map_manual
-    data32 |= (rx_8_channel? 0x1f:0x3)  << 2;   // [6:2]    ch_map[4:0]
-    data32 |= 1                         << 0;   // [1:0]    aud_layout_ctrl:0/1=auto layout; 2=layout 0; 3=layout 1.
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_CHEXTR_CTRL,    data32); // DEFAULT: {24'd0, 1'b0, 5'd0, 2'd0}
-
-    data32  = 0;
-    data32 |= 0     << 8;   // [8]      fc_lfe_exchg: 1=swap channel 3 and 4
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_AIF_CTRL,  data32); // DEFAULT: {23'd0, 1'b0, 8'd0}
-
-    data32  = 0;
-    data32 |= 0     << 20;  // [20]     rg_block_off:1=Enable HS/VS/CTRL filtering during active video
-    data32 |= 1     << 19;  // [19]     block_off:1=Enable HS/VS/CTRL passing during active video
-    data32 |= 5     << 16;  // [18:16]  valid_mode
-    data32 |= 0     << 12;  // [13:12]  ctrl_filt_sens
-    data32 |= 3     << 10;  // [11:10]  vs_filt_sens
-    data32 |= 0     << 8;   // [9:8]    hs_filt_sens
-    data32 |= 2     << 6;   // [7:6]    de_measure_mode
-    data32 |= 0     << 5;   // [5]      de_regen
-    data32 |= 3     << 3;   // [4:3]    de_filter_sens 
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_ERROR_PROTECT, data32); // DEFAULT: {11'd0, 1'b0, 1'b0, 3'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 1'b0, 2'd0, 3'd0}
-
-    data32  = 0;
-    data32 |= 0     << 8;   // [10:8]   hact_pix_ith
-    data32 |= 0     << 5;   // [5]      hact_pix_src
-    data32 |= 1     << 4;   // [4]      htot_pix_src
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_HCTRL1,  data32); // DEFAULT: {21'd0, 3'd1, 2'd0, 1'b0, 1'b1, 4'd0}
-
-    data32  = 0;
-    data32 |= 1     << 12;  // [14:12]  hs_clk_ith
-    data32 |= 7     << 8;   // [10:8]   htot32_clk_ith
-    data32 |= 1     << 5;   // [5]      vs_act_time
-    data32 |= 3     << 3;   // [4:3]    hs_act_time
-    data32 |= 0     << 0;   // [1:0]    h_start_pos
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_HCTRL2,  data32); // DEFAULT: {17'd0, 3'd2, 1'b0, 3'd1, 2'd0, 1'b0, 2'd0, 1'b0, 2'd2}
-
-    data32  = 0;
-    data32 |= 1                 << 4;   // [4]      v_offs_lin_mode
-    data32 |= 1                 << 1;   // [1]      v_edge
-    data32 |= interlace_mode    << 0;   // [0]      v_mode
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_VCTRL,   data32); // DEFAULT: {27'd0, 1'b0, 2'd0, 1'b1, 1'b0}
-
-    data32  = 0;
-    data32 |= 1 << 10;  // [11:10]  vofs_lin_ith
-    data32 |= 3 << 8;   // [9:8]    vact_lin_ith 
-    data32 |= 0 << 6;   // [7:6]    vtot_lin_ith
-    data32 |= 7 << 3;   // [5:3]    vs_clk_ith
-    data32 |= 2 << 0;   // [2:0]    vtot_clk_ith
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_VTH,     data32); // DEFAULT: {20'd0, 2'd2, 2'd0, 2'd0, 3'd2, 3'd2}
-
-    data32  = 0;
-    data32 |= 1 << 2;   // [2]      fafielddet_en
-    data32 |= 0 << 0;   // [1:0]    field_pol_mode
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_IL_POL,  data32); // DEFAULT: {29'd0, 1'b0, 2'd0}
-
-    data32  = 0;
-    data32 |= 0 << 2;   // [4:2]    deltacts_irqtrig
-    data32 |= 0 << 0;   // [1:0]    cts_n_meas_mode
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_ACRM_CTRL, data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    // 12. RX PHY GEN3 configuration
-
-    // Turn on interrupts that to do with PHY communication
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_ICLR,         0xffffffff);
-    *curr_hdmi_ien_maskn    = hdmi_ien_maskn;
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_IEN_SET,      hdmi_ien_maskn);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_ISTS,        0, 0);
-
-    // PDDQ = 1'b1; PHY_RESET = 1'b1;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 1             << 1;   // [1]      phypddq
-    data32 |= 1             << 0;   // [0]      phyreset
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-    //Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 1 ) {} // delay 1uS
-        mdelay(1);
-
-    // PDDQ = 1'b1; PHY_RESET = 1'b0;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 1             << 1;   // [1]      phypddq
-    data32 |= 0             << 0;   // [0]      phyreset
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    // Configuring I2C to work in fastmode
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_I2CM_PHYG3_MODE,    0x1);
-
-    // Write PHY register 0x02 -> { 6'b001000, 1'b1, timebase_ovr[8:0]};
-    //                                              - timebase_ovr[8:0] = Fcfg_clk(MHz) x 4;
-    data32  = 0;
-    data32 |= 8         << 10;  // [15:10]  lock_thres
-    data32 |= 1         << 9;   // [9]      timebase_ovr_en
-    data32 |= (25 * 4)  << 0;   // [8:0]    timebase_ovr = F_cfgclk(MHz) * 4
-    hdmirx_wr_reg(HDMIRX_DEV_ID_PHY, 0x02, data32);
-
-    //------------------------------------------------------------------------------------------
-    // Write PHY register 0x03 -> {9'b000000100, color_depth[1:0], 5'b0000};
-    //                                              - color_depth = 00 ->  8bits;
-    //                                              - color_depth = 01 -> 10bits;
-    //                                              - color_depth = 10 -> 12bits;
-    //                                              - color_depth = 11 -> 16bits.
-    //------------------------------------------------------------------------------------------
-    data32  = 0;
-    data32 |= 0                     << 15;  // [15]     mpll_short_power_up
-    data32 |= 0                     << 13;  // [14:13]  mpll_mult
-    data32 |= 0                     << 12;  // [12]     dis_off_lp
-    data32 |= 0                     << 11;  // [11]     fast_switching
-    data32 |= 0                     << 10;  // [10]     bypass_afe
-    data32 |= 1                     << 9;   // [9]      fsm_enhancement
-    data32 |= 0                     << 8;   // [8]      low_freq_eq
-    data32 |= 0                     << 7;   // [7]      bypass_aligner
-    data32 |= rx_input_color_depth  << 5;   // [6:5]    color_depth: 0=8-bit; 1=10-bit; 2=12-bit; 3=16-bit.
-    data32 |= 0                     << 3;   // [4:3]    sel_tmdsclk: 0=Use chan0 clk; 1=Use chan1 clk; 2=Use chan2 clk; 3=Rsvd.
-    data32 |= 0                     << 2;   // [2]      port_select_ovr_en
-    data32 |= 0                     << 0;   // [1:0]    port_select_ovr
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_PHY, 0x03, data32);
-
-    // PDDQ = 1'b0; PHY_RESET = 1'b0;
-    data32  = 0;
-    data32 |= 1             << 6;   // [6]      physvsretmodez
-    data32 |= 1             << 4;   // [5:4]    cfgclkfreq
-    data32 |= rx_port_sel   << 2;   // [3:2]    portselect
-    data32 |= 0             << 1;   // [1]      phypddq
-    data32 |= 0             << 0;   // [0]      phyreset
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_SNPS_PHYG3_CTRL,    data32); // DEFAULT: {27'd0, 3'd0, 2'd1}
-
-    data32  = 0;
-    data32 |= 0                     << 15;  // [15]     mpll_short_power_up
-    data32 |= 0                     << 13;  // [14:13]  mpll_mult
-    data32 |= 0                     << 12;  // [12]     dis_off_lp
-    data32 |= 0                     << 11;  // [11]     fast_switching
-    data32 |= 0                     << 10;  // [10]     bypass_afe
-    data32 |= 1                     << 9;   // [9]      fsm_enhancement
-    data32 |= 0                     << 8;   // [8]      low_freq_eq
-    data32 |= 0                     << 7;   // [7]      bypass_aligner
-    data32 |= rx_input_color_depth  << 5;   // [6:5]    color_depth: 0=8-bit; 1=10-bit; 2=12-bit; 3=16-bit.
-    data32 |= 0                     << 3;   // [4:3]    sel_tmdsclk: 0=Use chan0 clk; 1=Use chan1 clk; 2=Use chan2 clk; 3=Rsvd.
-    data32 |= 0                     << 2;   // [2]      port_select_ovr_en
-    data32 |= 0                     << 0;   // [1:0]    port_select_ovr
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_PHY, 0x03, data32, 0);
-
-    // 13.  HDMI RX Ready! - Assert HPD
-    stimulus_print("[TEST.C] HDMI RX Ready! - Assert HPD\n");
-
-    hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_PORT_SEL,   (1<<rx_port_sel));
-
-    data32  = 0;
-    data32 |= 1                 << 5;   // [    5]  invert_hpd
-    data32 |= 1                 << 4;   // [    4]  force_hpd: default=1
-    data32 |= (1<<rx_port_sel)  << 0;   // [ 3: 0]  hpd_config
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_HPD_PWR5V,  data32);
-
-    // Configure external video data generator and analyzer
-    /*
-    start_video_gen_ana(vic,                // Video format identification code
-                        pixel_repeat_hdmi,
-                        interlace_mode,     // 0=Progressive; 1=Interlace.
-                        front_porch,        // Number of pixels from DE Low to HSYNC high
-                        back_porch,         // Number of pixels from HSYNC low to DE high
-                        hsync_pixels,       // Number of pixels of HSYNC pulse
-                        hsync_polarity,     // TX HSYNC polarity: 0=low active; 1=high active.
-                        sof_lines,          // HSYNC count between VSYNC de-assertion and first line of active video
-                        eof_lines,          // HSYNC count between last line of active video and start of VSYNC
-                        vsync_lines,        // HSYNC count of VSYNC assertion
-                        vsync_polarity,     // TX VSYNC polarity: 0=low active; 1=high active.
-                        total_pixels,       // Number of total pixels per line
-                        total_lines);       // Number of total lines per frame
-    */
-    // 14.  RX_FINAL_CONFIG
-    
-    // RX PHY PLL configuration
-    //get config for CMU
-    /*stimulus_event(31, STIMULUS_HDMI_UTIL_CALC_PLL_CONFIG   |
-                       (0   << 4)                           |   // mdclk freq: 0=24MHz; 1=25MHz; 2=27MHz.
-                       (1   << 0));                             // tmds_clk_freq: 0=25MHz; 1=27MHz; 2=54MHz; 3=74.25MHz; 4=148.5MHz; 5=27*5/4MHz.
-                       */
-//        //margin of +/-0.78% for clock drift
-//        clockrate_max[15:0] = (expected_clockrate[15:0]+expected_clockrate[15:7]);
-//        clockrate_min[15:0] = (expected_clockrate[15:0]-expected_clockrate[15:7]);
-
-    data32  = 0;
-    data32 |= 1     << 20;  // [21:20]  lock_hyst
-    data32 |= 0     << 16;  // [18:16]  clk_hyst
-    data32 |= 2490  << 4;   // [15:4]   eval_time
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_CKM_EVLTM, data32);    // DEFAULT: {10'd0, 2'd1, 1'b0, 3'd0, 12'd4095, 3'd0, 1'b0}
-
-    data32  = 0;
-    data32 |= 3533  << 16;  // [31:16]  maxfreq
-    data32 |= 3479  << 0;   // [15:0]   minfreq
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_CKM_F, data32);    // DEFAULT: {16'd63882, 16'd9009}
-
-    // RX PHY PLL lock wait
-    stimulus_print("[TEST.C] WAITING FOR TMDSVALID-------------------\n");
-    //while (! (*hdmi_pll_lock)) {
-    while(1){
-        if( hdmirx_rd_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_PLL_LCK_STS) & 0x1)
-            break;
-        mdelay(1);
-        //Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 10 ) {} // delay 10uS
-    }
-    hdmirx_poll_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_CKM_RESULT, 1<<16, ~(1<<16));
-
-    // 15. Waiting for AUDIO PLL to lock before performing RX synchronous resets!
-    //hdmirx_poll_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_PLL_CTRL, 1<<31, ~(1<<31));
-
-    // 16. RX Reset
-
-    data32  = 0;
-    data32 |= 0 << 5;   // [5]      cec_enable
-    data32 |= 0 << 4;   // [4]      aud_enable
-    data32 |= 0 << 3;   // [3]      bus_enable
-    data32 |= 0 << 2;   // [2]      hdmi_enable
-    data32 |= 0 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    //Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 1 ) {} // delay 1uS
-        mdelay(1);
-
-    //--------------------------------------------------------------------------
-    // Enable HDMIRX-DWC interrupts:
-    //--------------------------------------------------------------------------
-    
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_ICLR,         0xffffffff);
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_CLK_ICLR,      0xffffffff);
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_FIFO_ICLR,     0xffffffff);
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_ICLR,           0xffffffff);
-    //hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_ICLR,         0xffffffff);
-
-    *curr_pdec_ien_maskn     = pdec_ien_maskn;
-    *curr_aud_clk_ien_maskn  = aud_clk_ien_maskn;
-    *curr_aud_fifo_ien_maskn = aud_fifo_ien_maskn;
-    *curr_md_ien_maskn       = md_ien_maskn;
-
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_IEN_SET,      pdec_ien_maskn);
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_CLK_IEN_SET,   aud_clk_ien_maskn);
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_FIFO_IEN_SET,  aud_fifo_ien_maskn);
-    hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_IEN_SET,        md_ien_maskn);
-    //hdmirx_wr_only_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_IEN_SET,      hdmi_ien_maskn);
-
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_PDEC_ISTS,        0, 0);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_CLK_ISTS,     0, 0);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_AUD_FIFO_ISTS,    0, 0);
-    hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_MD_ISTS,          0, 0);
-    //hdmirx_rd_check_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_HDMI_ISTS,        0, 0);
-    
-    //--------------------------------------------------------------------------
-    // Bring up RX
-    //--------------------------------------------------------------------------
-    data32  = 0;
-    data32 |= 1 << 5;   // [5]      cec_enable
-    data32 |= 1 << 4;   // [4]      aud_enable
-    data32 |= 1 << 3;   // [3]      bus_enable
-    data32 |= 1 << 2;   // [2]      hdmi_enable
-    data32 |= 1 << 1;   // [1]      modet_enable
-    data32 |= 1 << 0;   // [0]      cfg_enable
-    hdmirx_wr_reg(HDMIRX_DEV_ID_DWC, HDMIRX_DWC_DMI_DISABLE_IF, data32);    // DEFAULT: {31'd0, 1'b0}
-
-    //Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 10 ) {} // delay 10uS
-        mdelay(1);
-
-    // To speed up simulation, reset the video generator after HDMIRX-PHY is locked,
-    // so that HDMIRX-DWC doesn't have wait for a whole frame before seeing the 1st Vsync.
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_VGEN_RESET        | 1);
-    //stimulus_event(31, STIMULUS_HDMI_UTIL_VGEN_RESET        | 0);
-
-    // Enable HDMI_ARCTX if needed
-    if (hdmi_arctx_en) {
-        data32  = 0;
-        data32 |= hdmi_arctx_mode   << 1;   // [1]      arctx_mode
-        data32 |= 0                 << 0;   // [0]      arctx_en
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_ARCTX_CNTL, data32);
-        
-        data32  = 0;
-        data32 |= hdmi_arctx_mode   << 1;   // [1]      arctx_mode
-        data32 |= hdmi_arctx_en     << 0;   // [0]      arctx_en
-        hdmirx_wr_reg(HDMIRX_DEV_ID_TOP, HDMIRX_TOP_ARCTX_CNTL, data32);
-    }
-//        register_read(`RX_HDMI_ERD_STS,supportreg,"VERBOSE_MODE");
-//        check_vector("Acc valid indication",supportreg,32'd0,32,error_tmp,"NOPRINT"); errorsum(error,error_tmp,error);
-//        wait_for(5000,"VERBOSE_MODE");
-//        register_read(`RX_HDMI_ERD_STS,supportreg,"VERBOSE_MODE");
-//        check_vector("Acc valid indication",supportreg,32'd7,32,error_tmp,"NOPRINT"); errorsum(error,error_tmp,error);
-//
-//        wait_for(5000,"VERBOSE_MODE");
-//
-//        display_msg( "END OF HDMI RX CONFIGURATION", "DEBUG_MODE");
-//
-//      register_read(  `RX_PDEC_STS  ,  supportreg, "VERBOSE_MODE");
-//      register_read(  `RX_MD_IL_SKEW  ,  supportreg, "NO_PRINT");
-//      {phase, skew} = supportreg[3:0];
-//      if (phase) begin
-//        display_msg("ERROR - PHASE should be 0! Phase 1 detected","VERBOSE_MODE");
-//        errorsum(error,1,error);
-//      end
-//
-//      display_msg("############################### VS vs HS Skew Results ##################################", "VERBOSE_MODE");
-//      if ((skew != 0) && (skew != 3) && (skew != 4) && (skew != 7)) begin
-//        $sformat(supportstring,"   ERROR - Current frame skew %d/8 of a line width (phase %d)                   ", (skew+1), phase);
-//        errorsum(error,1,error);
-//      end
-//      else $sformat(supportstring,"    Current frame skew %d/8 of a line width (phase %d)                           ", (skew+1), phase);
-//      display_msg(supportstring, "VERBOSE_MODE");
-//      display_msg("########################################################################################", "VERBOSE_MODE");
-//
-//          register_read(  `RX_MD_VSC      , { supportreg[15:0], vs_clk_temp  }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_HT0      , { htot32_clk      , hs_clk       }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_HT1      , { htot_pix        , hofs_pix     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_HACT_PX  , { supportreg[15:0], hact_pix     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VSC      , { supportreg[15:0], vs_clk_temp  }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VTC      , { vtot_clk                       }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VOL      , { supportreg[15:0], vofs_lin     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VAL      , { supportreg[15:0], vact_lin     }  , "VERBOSE_MODE");
-//    register_read(  `RX_MD_VTL      , { supportreg[15:0], vtot_lin     }  , "VERBOSE_MODE");
-//      register_read(  `RX_AUD_FIFO_STS    , supportreg  , "VERBOSE_MODE");
-
-} /* hdmirx_test_function */
-
-#if 0
-void aocec_poll_reg_busy (unsigned char reg_busy)
-{
-    if (reg_busy) {
-        stimulus_print("[TEST.C] Polling AO_CEC reg_busy=1\n");
-    } else {
-        stimulus_print("[TEST.C] Polling AO_CEC reg_busy=0\n");
-    }
-    while (((*P_AO_CEC_RW_REG) & (1 << 23)) != (reg_busy << 23)) {
-        Wr(ISA_TIMERE, 0); while( Rd(ISA_TIMERE) < 31 ) {}
-    }
-} /* aocec_poll_reg_busy */
-
-void aocec_wr_only_reg (unsigned long addr, unsigned long data)
-{
-    unsigned long data32;
-    
-    aocec_poll_reg_busy(0);
-    
-    data32  = 0;
-    data32 |= 1     << 16;  // [16]     cec_reg_wr
-    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
-    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
-    (*P_AO_CEC_RW_REG) = data32;
-} /* aocec_wr_only_reg */
-
-unsigned long aocec_rd_reg (unsigned long addr)
-{
-    unsigned long data32;
-    
-    aocec_poll_reg_busy(0);
-    
-    data32  = 0;
-    data32 |= 0     << 16;  // [16]     cec_reg_wr
-    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
-    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
-    (*P_AO_CEC_RW_REG) = data32;
-
-    aocec_poll_reg_busy(1);
-    aocec_poll_reg_busy(0);
-    
-    data32 = ((*P_AO_CEC_RW_REG) >> 24) & 0xff;
-    
-    return (data32);
-} /* aocec_rd_reg */
-
-void aocec_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask)
-{
-    unsigned long rd_data;
-    rd_data = aocec_rd_reg(addr);
-    if ((rd_data | mask) != (exp_data | mask)) 
-    {
-        stimulus_print("Error: AO-CEC addr=0x");
-        stimulus_print_num_hex(addr);
-        stimulus_print_without_timestamp(" rd_data=0x");
-        stimulus_print_num_hex(rd_data);
-        stimulus_print_without_timestamp(" exp_data=0x");
-        stimulus_print_num_hex(exp_data);
-        stimulus_print_without_timestamp(" mask=0x");
-        stimulus_print_num_hex(mask);
-        stimulus_print_without_timestamp("\n");
-        //stimulus_finish_fail(10);
-    }
-} /* aocec_rd_check_reg */
-
-void aocec_wr_reg (unsigned long addr, unsigned long data)
-{
-    aocec_wr_only_reg(addr, data);
-    aocec_rd_check_reg(addr, data, 0);
-} /* aocec_wr_reg */
-
-#endif
-
diff --git a/drivers/amlogic/tvin/hdmirx/test/hdmirx.h b/drivers/amlogic/tvin/hdmirx/test/hdmirx.h
deleted file mode 100644
index fc2b91b43135..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/hdmirx.h
+++ /dev/null
@@ -1,194 +0,0 @@
-#ifndef HDMIRX_H
-#define HDMIRX_H
-
-// Device ID to differentiate HDMIRX register access to TOP, DWC or PHY
-#define HDMIRX_DEV_ID_TOP   0
-#define HDMIRX_DEV_ID_DWC   1
-#define HDMIRX_DEV_ID_PHY   2
-
-#define HDMIRX_ADDR_PORT    0xc800e000  // TOP ADDR_PORT: 0xc800e000; DWC ADDR_PORT: 0xc800e010
-#define HDMIRX_DATA_PORT    0xc800e004  // TOP DATA_PORT: 0xc800e004; DWC DATA_PORT: 0xc800e014
-#define HDMIRX_CTRL_PORT    0xc800e008  // TOP CTRL_PORT: 0xc800e008; DWC CTRL_PORT: 0xc800e018
-
-// Use the following functions to access the HDMIRX modules (TOP, DWC or PHY) by default
-extern void             hdmirx_wr_only_reg  (unsigned char dev_id, unsigned long addr, unsigned long data);
-extern unsigned long    hdmirx_rd_reg       (unsigned char dev_id, unsigned long addr);
-extern void             hdmirx_rd_check_reg (unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask);
-extern void             hdmirx_wr_reg       (unsigned char dev_id, unsigned long addr, unsigned long data);
-extern void             hdmirx_poll_reg     (unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask);
-
-// HDMIRX initialization
-extern void             hdmirx_test_function (unsigned char acr_mode,                   // Select which ACR scheme: 0=Analog PLL based ACR; 1=Digital ACR.
-                                              unsigned long manual_acr_cts,
-                                              unsigned long manual_acr_n,
-                                              unsigned char rx_8_channel,               // Audio channels: 0=2-channel; 1=4 x 2-channel.
-                                              unsigned char edid_extension_flag,        // Number of 128-bytes blocks that following the basic block
-                                              unsigned char edid_auto_cec_enable,       // 1=Automatic switch CEC ID depend on RX_PORT_SEL
-                                              unsigned long edid_cec_id_addr,           // EDID address offsets for storing 2-byte of Physical Address
-                                              unsigned long edid_cec_id_data,           // Physical Address: e.g. 0x1023 is 1.0.2.3
-                                              unsigned char edid_auto_checksum_enable,  // Checksum byte selection: 0=Use data stored in MEM; 1=Use checksum calculated by HW.
-                                              unsigned char edid_clk_divide_m1,         // EDID I2C clock = sysclk / (1+edid_clk_divide_m1).
-                                              unsigned char hdcp_on,
-                                              unsigned char hdcp_key_decrypt_en,
-                                              unsigned char vic,                        // Video format identification code
-                                              unsigned char pixel_repeat_hdmi,
-                                              unsigned char interlace_mode,             // 0=Progressive; 1=Interlace.
-                                              unsigned long front_porch,                // Number of pixels from DE Low to HSYNC high
-                                              unsigned long back_porch,                 // Number of pixels from HSYNC low to DE high
-                                              unsigned long hsync_pixels,               // Number of pixels of HSYNC pulse
-                                              unsigned long hsync_polarity,             // TX HSYNC polarity: 0=low active; 1=high active.
-                                              unsigned long sof_lines,                  // HSYNC count between VSYNC de-assertion and first line of active video
-                                              unsigned long eof_lines,                  // HSYNC count between last line of active video and start of VSYNC
-                                              unsigned long vsync_lines,                // HSYNC count of VSYNC assertion
-                                              unsigned char vsync_polarity,             // TX VSYNC polarity: 0=low active; 1=high active.
-                                              unsigned long total_pixels,               // Number of total pixels per line
-                                              unsigned long total_lines,                // Number of total lines per frame
-                                              unsigned char rx_input_color_format,      // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444.
-                                              unsigned char rx_input_color_depth,       // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                                              unsigned char rx_hscale_half,             // 1=RX output video horizontally scaled by half, to reduce clock speed.
-                                              unsigned long *curr_pdec_ien_maskn,
-                                              unsigned long *curr_aud_clk_ien_maskn,
-                                              unsigned long *curr_aud_fifo_ien_maskn,
-                                              unsigned long *curr_md_ien_maskn,
-                                              unsigned long *curr_hdmi_ien_maskn,
-                                              unsigned long pdec_ien_maskn,
-                                              unsigned long aud_clk_ien_maskn,
-                                              unsigned long aud_fifo_ien_maskn,
-                                              unsigned long md_ien_maskn,
-                                              unsigned long hdmi_ien_maskn,
-                                              unsigned char rx_port_sel,                // Select HDMI RX input port: 0=PortA; 1=PortB; 2=PortC, 3=PortD; others=invalid.
-                                              unsigned char hdmi_arctx_en,              // Audio Return Channel (ARC) transmission block control:0=Disable; 1=Enable.
-                                              unsigned char hdmi_arctx_mode,            // ARC transmission mode: 0=Single-ended mode; 1=Common mode.
-                                              unsigned char *hdmi_pll_lock);
-
-extern void             aocec_poll_reg_busy (unsigned char reg_busy);
-extern void             aocec_wr_only_reg (unsigned long addr, unsigned long data);
-extern unsigned long    aocec_rd_reg (unsigned long addr);
-extern void             aocec_rd_check_reg (unsigned long addr, unsigned long exp_data, unsigned long mask);
-extern void             aocec_wr_reg (unsigned long addr, unsigned long data);
-
-// Internal functions:
-void            hdmirx_wr_only_TOP  (unsigned long addr, unsigned long data);
-void            hdmirx_wr_only_DWC  (unsigned long addr, unsigned long data);
-void            hdmirx_wr_only_PHY  (unsigned long addr, unsigned long data);
-unsigned long   hdmirx_rd_TOP       (unsigned long addr);
-unsigned long   hdmirx_rd_DWC       (unsigned long addr);
-unsigned long   hdmirx_rd_PHY       (unsigned long addr);
-void            hdmirx_rd_check_TOP (unsigned long addr, unsigned long exp_data, unsigned long mask);
-void            hdmirx_rd_check_DWC (unsigned long addr, unsigned long exp_data, unsigned long mask);
-void            hdmirx_rd_check_PHY (unsigned long addr, unsigned long exp_data, unsigned long mask);
-void            hdmirx_wr_TOP       (unsigned long addr, unsigned long data);
-void            hdmirx_wr_DWC       (unsigned long addr, unsigned long data);
-void            hdmirx_wr_PHY       (unsigned long addr, unsigned long data);
-void            hdmirx_poll_TOP     (unsigned long addr, unsigned long exp_data, unsigned long mask);
-void            hdmirx_poll_DWC     (unsigned long addr, unsigned long exp_data, unsigned long mask, unsigned long max_try);
-void            hdmirx_poll_PHY     (unsigned long addr, unsigned long exp_data, unsigned long mask);
-void            hdmirx_edid_setting (unsigned char edid_extension_flag);
-void            hdmirx_key_setting  (unsigned char encrypt_en);
-void            start_video_gen_ana (unsigned char  vic,                // Video format identification code
-                                     unsigned char  pixel_repeat_hdmi,
-                                     unsigned char  interlace_mode,     // 0=Progressive; 1=Interlace.
-                                     unsigned long  front_porch,        // Number of pixels from DE Low to HSYNC high
-                                     unsigned long  back_porch,         // Number of pixels from HSYNC low to DE high
-                                     unsigned long  hsync_pixels,       // Number of pixels of HSYNC pulse
-                                     unsigned long  hsync_polarity,     // TX HSYNC polarity: 0=low active; 1=high active.
-                                     unsigned long  sof_lines,          // HSYNC count between VSYNC de-assertion and first line of active video
-                                     unsigned long  eof_lines,          // HSYNC count between last line of active video and start of VSYNC
-                                     unsigned long  vsync_lines,        // HSYNC count of VSYNC assertion
-                                     unsigned long  vsync_polarity,     // TX VSYNC polarity: 0=low active; 1=high active.
-                                     unsigned long  total_pixels,       // Number of total pixels per line
-                                     unsigned long  total_lines);       // Number of total lines per frame
-
-//------------------------------------------------------------------------------
-// Defines for simulation
-//------------------------------------------------------------------------------
-
-////first set of test Device Private Keys (HDCP Table A-1, Receiver B1)
-//const unsigned long hdmirx_hdcp_bksvs[2]    = {0x51, 0x1ef21acd}; // {high 8-bit, low32-bit}
-//const unsigned long hdmirx_hdcp_keys[40*2]  = {
-//    0xbc13e0, 0xc75bf0fd,   // key set  0: {high 24-bit, low 32-bit}
-//    0xae0d2c, 0x7f76443b,   // key set  1: {high 24-bit, low 32-bit}
-//    0x24bf21, 0x85a36c60,   // key set  2: {high 24-bit, low 32-bit}
-//    0xf4bc6c, 0xbcd7a32f,   // key set  3: {high 24-bit, low 32-bit}
-//    0xa72e69, 0xc5eb6388,   // key set  4: {high 24-bit, low 32-bit}
-//    0x7fa2d2, 0x7a37d9f8,   // key set  5: {high 24-bit, low 32-bit}
-//    0x32fd35, 0x29dea3d1,   // key set  6: {high 24-bit, low 32-bit}
-//    0x485fc2, 0x40cc9bae,   // key set  7: {high 24-bit, low 32-bit}
-//    0x3b9857, 0x797d5103,   // key set  8: {high 24-bit, low 32-bit}
-//    0x0dd170, 0xbe615250,   // key set  9: {high 24-bit, low 32-bit}
-//    0x1a748b, 0xe4866bb1,   // key set 10: {high 24-bit, low 32-bit}
-//    0xf9606a, 0x7c348cca,   // key set 11: {high 24-bit, low 32-bit}
-//    0x4bbb03, 0x7899eea1,   // key set 12: {high 24-bit, low 32-bit}
-//    0x190ecf, 0x9cc095a9,   // key set 13: {high 24-bit, low 32-bit}
-//    0xa821c4, 0x6897447f,   // key set 14: {high 24-bit, low 32-bit}
-//    0x1a8a0b, 0xc4298a41,   // key set 15: {high 24-bit, low 32-bit}
-//    0xaefc08, 0x53e62082,   // key set 16: {high 24-bit, low 32-bit}
-//    0xf75d4a, 0x0c497ba4,   // key set 17: {high 24-bit, low 32-bit}
-//    0xad6495, 0xfc8a06d8,   // key set 18: {high 24-bit, low 32-bit}
-//    0x67c202, 0x0c2b2e02,   // key set 19: {high 24-bit, low 32-bit}
-//    0x8f116b, 0x18f4ae8d,   // key set 20: {high 24-bit, low 32-bit}
-//    0xe3053f, 0xa3e9fa69,   // key set 21: {high 24-bit, low 32-bit}
-//    0x37d800, 0x2881c7d1,   // key set 22: {high 24-bit, low 32-bit}
-//    0xc3a5fd, 0x1c15669c,   // key set 23: {high 24-bit, low 32-bit}
-//    0x9e93d4, 0x1e0811f7,   // key set 24: {high 24-bit, low 32-bit}
-//    0x2c4074, 0x509eec6c,   // key set 25: {high 24-bit, low 32-bit}
-//    0x8b7fd8, 0x19279b61,   // key set 26: {high 24-bit, low 32-bit}
-//    0xd7caad, 0xa0a06ce9,   // key set 27: {high 24-bit, low 32-bit}
-//    0x9297dc, 0xa1f8c1db,   // key set 28: {high 24-bit, low 32-bit}
-//    0x5d1aaa, 0x99dea489,   // key set 29: {high 24-bit, low 32-bit}
-//    0x60cb56, 0xddbaa1d9,   // key set 30: {high 24-bit, low 32-bit}
-//    0x85d4ad, 0x5e5ff2e0,   // key set 31: {high 24-bit, low 32-bit}
-//    0x128016, 0x1221df6d,   // key set 32: {high 24-bit, low 32-bit}
-//    0xca31a5, 0xf2406589,   // key set 33: {high 24-bit, low 32-bit}
-//    0x1d30e8, 0xcb198e6f,   // key set 34: {high 24-bit, low 32-bit}
-//    0xd1c18b, 0xed07d3fa,   // key set 35: {high 24-bit, low 32-bit}
-//    0xcec7ec, 0x09245b43,   // key set 36: {high 24-bit, low 32-bit}
-//    0xb08129, 0xefedd583,   // key set 37: {high 24-bit, low 32-bit}
-//    0x2134cf, 0x4ce286e5,   // key set 38: {high 24-bit, low 32-bit}
-//    0xedeef9, 0xd099b78c    // key set 39: {high 24-bit, low 32-bit}
-//}; /* hdmirx_hdcp_keys */
-//const unsigned long hdmirx_hdcp_key_decrypt_seed    = 0xA55A;
-//const unsigned long hdmirx_hdcp_encrypt_keys[40*2]  = {
-//    0xC0E0BD, 0x0AB26F9F,   // key set  0: {high 24-bit, low 32-bit}
-//    0x0B90B3, 0xE9B2B75F,   // key set  1: {high 24-bit, low 32-bit}
-//    0xBD00B5, 0xD15859EE,   // key set  2: {high 24-bit, low 32-bit}
-//    0xD89597, 0x7578E44C,   // key set  3: {high 24-bit, low 32-bit}
-//    0x4AFF12, 0xFCC45CA2,   // key set  4: {high 24-bit, low 32-bit}
-//    0x36555B, 0xD5B12FAF,   // key set  5: {high 24-bit, low 32-bit}
-//    0x8AE77F, 0x4EDFD419,   // key set  6: {high 24-bit, low 32-bit}
-//    0x7AA3D0, 0x0FD2C60F,   // key set  7: {high 24-bit, low 32-bit}
-//    0x79052E, 0xBD613745,   // key set  8: {high 24-bit, low 32-bit}
-//    0xB67BB5, 0xE12AE0A6,   // key set  9: {high 24-bit, low 32-bit}
-//    0x78B9DD, 0xF6629AC5,   // key set 10: {high 24-bit, low 32-bit}
-//    0x61DEEE, 0x2BFE2F2F,   // key set 11: {high 24-bit, low 32-bit}
-//    0x1A40B2, 0x1F63F998,   // key set 12: {high 24-bit, low 32-bit}
-//    0x5A9AE6, 0xDE543C62,   // key set 13: {high 24-bit, low 32-bit}
-//    0x65DF19, 0xA00E5744,   // key set 14: {high 24-bit, low 32-bit}
-//    0x6C684F, 0x4B65A8BB,   // key set 15: {high 24-bit, low 32-bit}
-//    0x7DA075, 0xB7F8D6CC,   // key set 16: {high 24-bit, low 32-bit}
-//    0x1DE01C, 0xEEADFBC8,   // key set 17: {high 24-bit, low 32-bit}
-//    0x06E607, 0xC4DC61C4,   // key set 18: {high 24-bit, low 32-bit}
-//    0xA3BB1E, 0xD7510D5E,   // key set 19: {high 24-bit, low 32-bit}
-//    0x02F495, 0xECEB5843,   // key set 20: {high 24-bit, low 32-bit}
-//    0x80E13E, 0x57081DCB,   // key set 21: {high 24-bit, low 32-bit}
-//    0x6FB563, 0x6F2E0EAB,   // key set 22: {high 24-bit, low 32-bit}
-//    0x72439F, 0x4058074B,   // key set 23: {high 24-bit, low 32-bit}
-//    0xB98261, 0xF21FBEEF,   // key set 24: {high 24-bit, low 32-bit}
-//    0xC1EB77, 0x5AECDF3B,   // key set 25: {high 24-bit, low 32-bit}
-//    0xF780A5, 0x5E975124,   // key set 26: {high 24-bit, low 32-bit}
-//    0xE1DB09, 0x5E94F736,   // key set 27: {high 24-bit, low 32-bit}
-//    0x8FFA7B, 0x82786B25,   // key set 28: {high 24-bit, low 32-bit}
-//    0xE60823, 0x52B35574,   // key set 29: {high 24-bit, low 32-bit}
-//    0x212A04, 0x82E7C09F,   // key set 30: {high 24-bit, low 32-bit}
-//    0x38AF79, 0xC2A06F25,   // key set 31: {high 24-bit, low 32-bit}
-//    0xFB17B5, 0x2A46ACA3,   // key set 32: {high 24-bit, low 32-bit}
-//    0x2C2DE0, 0x1316DBC3,   // key set 33: {high 24-bit, low 32-bit}
-//    0x5E5761, 0x758CCA16,   // key set 34: {high 24-bit, low 32-bit}
-//    0x4D93A9, 0x09C6A332,   // key set 35: {high 24-bit, low 32-bit}
-//    0xFA6BF7, 0x463357F5,   // key set 36: {high 24-bit, low 32-bit}
-//    0x60B17C, 0xA1A5D7FA,   // key set 37: {high 24-bit, low 32-bit}
-//    0x7BB35C, 0x605646D5,   // key set 38: {high 24-bit, low 32-bit}
-//    0x28AAD1, 0x52893794    // key set 39: {high 24-bit, low 32-bit}
-//}; /* hdmirx_hdcp_encrypt_keys */
-
-#endif /* HDMIRX_H */
diff --git a/drivers/amlogic/tvin/hdmirx/test/hdmirx_parameter.h b/drivers/amlogic/tvin/hdmirx/test/hdmirx_parameter.h
deleted file mode 100644
index 8ae6f978d689..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/hdmirx_parameter.h
+++ /dev/null
@@ -1,480 +0,0 @@
-#ifndef HDMIRX_PARAMETER_DEFINE_H
-#define HDMIRX_PARAMETER_DEFINE_H
-
-//------------------------------------------------------------------------------
-// TOP-level wrapper registers addresses
-//------------------------------------------------------------------------------
-
-#define HDMIRX_TOP_SW_RESET                     0x000
-#define HDMIRX_TOP_CLK_CNTL                     0x001
-#define HDMIRX_TOP_HPD_PWR5V                    0x002
-#define HDMIRX_TOP_PORT_SEL                     0x003
-#define HDMIRX_TOP_EDID_GEN_CNTL                0x004
-#define HDMIRX_TOP_EDID_ADDR_CEC                0x005
-#define HDMIRX_TOP_EDID_DATA_CEC_PORT01         0x006
-#define HDMIRX_TOP_EDID_DATA_CEC_PORT23         0x007
-#define HDMIRX_TOP_EDID_GEN_STAT                0x008
-#define HDMIRX_TOP_INTR_MASKN                   0x009
-#define HDMIRX_TOP_INTR_STAT                    0x00A
-#define HDMIRX_TOP_INTR_STAT_CLR                0x00B
-#define HDMIRX_TOP_VID_CNTL                     0x00C
-#define HDMIRX_TOP_VID_STAT                     0x00D
-#define HDMIRX_TOP_ACR_CNTL_STAT                0x00E
-#define HDMIRX_TOP_ACR_AUDFIFO                  0x00F
-#define HDMIRX_TOP_ARCTX_CNTL                   0x010
-#define HDMIRX_TOP_METER_HDMI_CNTL              0x011
-#define HDMIRX_TOP_METER_HDMI_STAT              0x012
-
-#define HDMIRX_TOP_EDID_OFFSET                  0x200
-
-//------------------------------------------------------------------------------
-// DWC_HDMI1.3_RX_Controller registers addresses
-//------------------------------------------------------------------------------
-
-#define HDMIRX_DWC_HDMI_SETUP_CTRL              0x0000
-#define HDMIRX_DWC_HDMI_OVR_CTRL                0x0004
-#define HDMIRX_DWC_HDMI_TIMER_CTRL              0x0008
-#define HDMIRX_DWC_HDMI_RES_OVR                 0x0010
-#define HDMIRX_DWC_HDMI_RES_STS                 0x0014
-#define HDMIRX_DWC_HDMI_PLL_CTRL                0x0018
-#define HDMIRX_DWC_HDMI_PLL_FRQSET1             0x001C
-#define HDMIRX_DWC_HDMI_PLL_FRQSET2             0x0020
-#define HDMIRX_DWC_HDMI_PLL_PAR1                0x0024
-#define HDMIRX_DWC_HDMI_PLL_PAR2                0x0028
-#define HDMIRX_DWC_HDMI_PLL_PAR3                0x002C
-#define HDMIRX_DWC_HDMI_PLL_LCK_STS             0x0030
-#define HDMIRX_DWC_HDMI_CLK_CTRL                0x0034
-#define HDMIRX_DWC_HDMI_PCB_CTRL                0x0038
-#define HDMIRX_DWC_HDMI_PHS_CTRL                0x0040
-#define HDMIRX_DWC_HDMI_PHS_USD                 0x0044
-#define HDMIRX_DWC_HDMI_MISC_CTRL               0x0048
-#define HDMIRX_DWC_HDMI_EQOFF_CTRL              0x004C
-#define HDMIRX_DWC_HDMI_EQGAIN_CTRL             0x0050
-#define HDMIRX_DWC_HDMI_EQCAL_STS               0x0054
-#define HDMIRX_DWC_HDMI_EQRESULT                0x0058
-#define HDMIRX_DWC_HDMI_EQ_MEAS_CTRL            0x005C
-#define HDMIRX_DWC_HDMI_MODE_RECOVER            0x0080
-#define HDMIRX_DWC_HDMI_ERROR_PROTECT           0x0084
-#define HDMIRX_DWC_HDMI_ERD_STS                 0x0088
-#define HDMIRX_DWC_HDMI_SYNC_CTRL               0x0090
-#define HDMIRX_DWC_HDMI_CKM_EVLTM               0x0094
-#define HDMIRX_DWC_HDMI_CKM_F                   0x0098
-#define HDMIRX_DWC_HDMI_CKM_RESULT              0x009C
-#define HDMIRX_DWC_HDMI_RESMPL_CTRL             0x00A4
-#define HDMIRX_DWC_HDMI_DCM_CTRL                0x00A8
-#define HDMIRX_DWC_HDMI_VM_CFG_CH_0_1           0x00B0
-#define HDMIRX_DWC_HDMI_VM_CFG_CH2              0x00B4
-#define HDMIRX_DWC_HDMI_SPARE                   0x00B8
-#define HDMIRX_DWC_HDMI_STS                     0x00BC
-#define HDMIRX_DWC_HDCP_CTRL                    0x00C0
-#define HDMIRX_DWC_HDCP_SETTINGS                0x00C4
-#define HDMIRX_DWC_HDCP_SEED                    0x00C8
-#define HDMIRX_DWC_HDCP_BKSV1                   0x00CC
-#define HDMIRX_DWC_HDCP_BKSV0                   0x00D0
-#define HDMIRX_DWC_HDCP_KIDX                    0x00D4
-#define HDMIRX_DWC_HDCP_KEY1                    0x00D8
-#define HDMIRX_DWC_HDCP_KEY0                    0x00DC
-#define HDMIRX_DWC_HDCP_DBG                     0x00E0
-#define HDMIRX_DWC_HDCP_AKSV1                   0x00E4
-#define HDMIRX_DWC_HDCP_AKSV0                   0x00E8
-#define HDMIRX_DWC_HDCP_AN1                     0x00EC
-#define HDMIRX_DWC_HDCP_AN0                     0x00F0
-#define HDMIRX_DWC_HDCP_EESS_WOO                0x00F4
-#define HDMIRX_DWC_HDCP_I2C_TIMEOUT             0x00F8
-#define HDMIRX_DWC_HDCP_STS                     0x00FC
-#define HDMIRX_DWC_MD_HCTRL1                    0x0140
-#define HDMIRX_DWC_MD_HCTRL2                    0x0144
-#define HDMIRX_DWC_MD_HT0                       0x0148
-#define HDMIRX_DWC_MD_HT1                       0x014C
-#define HDMIRX_DWC_MD_HACT_PX                   0x0150
-#define HDMIRX_DWC_MD_HACT_PXA                  0x0154
-#define HDMIRX_DWC_MD_VCTRL                     0x0158
-#define HDMIRX_DWC_MD_VSC                       0x015C
-#define HDMIRX_DWC_MD_VTC                       0x0160
-#define HDMIRX_DWC_MD_VOL                       0x0164
-#define HDMIRX_DWC_MD_VAL                       0x0168
-#define HDMIRX_DWC_MD_VTH                       0x016C
-#define HDMIRX_DWC_MD_VTL                       0x0170
-#define HDMIRX_DWC_MD_IL_CTRL                   0x0174
-#define HDMIRX_DWC_MD_IL_SKEW                   0x0178
-#define HDMIRX_DWC_MD_IL_POL                    0x017C
-#define HDMIRX_DWC_MD_STS                       0x0180
-#define HDMIRX_DWC_AUD_CTRL                     0x0200
-#define HDMIRX_DWC_AUD_PLL_CTRL                 0x0208
-#define HDMIRX_DWC_AUD_PLL_LOCK                 0x020C
-#define HDMIRX_DWC_AUD_PLL_RESET                0x0210
-#define HDMIRX_DWC_AUD_CLK_CTRL                 0x0214
-#define HDMIRX_DWC_AUD_CLK_MASP                 0x0218
-#define HDMIRX_DWC_AUD_CLK_MAUD                 0x021C
-#define HDMIRX_DWC_AUD_FILT_CTRL1               0x0220
-#define HDMIRX_DWC_AUD_FILT_CTRL2               0x0224
-#define HDMIRX_DWC_AUD_CTS_MAN                  0x0228
-#define HDMIRX_DWC_AUD_N_MAN                    0x022C
-#define HDMIRX_DWC_AUD_CLK_STS                  0x023C
-#define HDMIRX_DWC_AUD_FIFO_CTRL                0x0240
-#define HDMIRX_DWC_AUD_FIFO_TH                  0x0244
-#define HDMIRX_DWC_AUD_FIFO_FILL_S              0x0248
-#define HDMIRX_DWC_AUD_FIFO_CLR_MM              0x024C
-#define HDMIRX_DWC_AUD_FIFO_FILLSTS             0x0250
-#define HDMIRX_DWC_AUD_CHEXTR_CTRL              0x0254
-#define HDMIRX_DWC_AUD_MUTE_CTRL                0x0258
-#define HDMIRX_DWC_AUD_SAO_CTRL                 0x0260
-#define HDMIRX_DWC_AUD_PAO_CTRL                 0x0264
-#define HDMIRX_DWC_AUD_SPARE                    0x0268
-#define HDMIRX_DWC_AUD_FIFO_STS                 0x027C
-#define HDMIRX_DWC_AUDPLL_GEN_CTS               0x0280
-#define HDMIRX_DWC_AUDPLL_GEN_N                 0x0284
-#define HDMIRX_DWC_AUDPLL_GEN_CTRL_RW1          0x0288
-#define HDMIRX_DWC_AUDPLL_GEN_CTRL_RW2          0x028C
-#define HDMIRX_DWC_AUDPLL_GEN_CTRL_W1           0x0298
-#define HDMIRX_DWC_AUDPLL_GEN_STS_RO1           0x02A0
-#define HDMIRX_DWC_AUDPLL_GEN_STS_RO2           0x02A4
-#define HDMIRX_DWC_AUDPLL_SC_CTS                0x02AC
-#define HDMIRX_DWC_AUDPLL_SC_N                  0x02B0
-#define HDMIRX_DWC_AUDPLL_SC_CTRL               0x02B4
-#define HDMIRX_DWC_AUDPLL_SC_STS1               0x02B8
-#define HDMIRX_DWC_AUDPLL_SC_STS2               0x02BC
-#define HDMIRX_DWC_SNPS_PHYG3_CTRL              0x02C0
-#define HDMIRX_DWC_I2CM_PHYG3_SLAVE             0x02C4
-#define HDMIRX_DWC_I2CM_PHYG3_ADDRESS           0x02C8
-#define HDMIRX_DWC_I2CM_PHYG3_DATAO             0x02CC
-#define HDMIRX_DWC_I2CM_PHYG3_DATAI             0x02D0
-#define HDMIRX_DWC_I2CM_PHYG3_OPERATION         0x02D4
-#define HDMIRX_DWC_I2CM_PHYG3_MODE              0x02D8
-#define HDMIRX_DWC_I2CM_PHYG3_SOFTRST           0x02DC
-#define HDMIRX_DWC_I2CM_PHYG3_SS_CNTS           0x02E0
-#define HDMIRX_DWC_I2CM_PHYG3_FS_HCNT           0x02E4
-#define HDMIRX_DWC_PDEC_CTRL                    0x0300
-#define HDMIRX_DWC_PDEC_FIFO_CFG                0x0304
-#define HDMIRX_DWC_PDEC_FIFO_STS                0x0308
-#define HDMIRX_DWC_PDEC_FIFO_DATA               0x030C
-#define HDMIRX_DWC_PDEC_DBG_CTRL                0x0310
-#define HDMIRX_DWC_PDEC_DBG_TMAX                0x0314
-#define HDMIRX_DWC_PDEC_DBG_CTS                 0x0318
-#define HDMIRX_DWC_PDEC_DBG_ACP                 0x031C
-#define HDMIRX_DWC_PDEC_DBG_ERR_CORR            0x0320
-#define HDMIRX_DWC_PDEC_FIFO_STS1               0x0324
-#define HDMIRX_DWC_PDEC_ACRM_CTRL               0x0330
-#define HDMIRX_DWC_PDEC_ACRM_MAX                0x0334
-#define HDMIRX_DWC_PDEC_ACRM_MIN                0x0338
-#define HDMIRX_DWC_PDEC_ASP_CTRL                0x0340
-#define HDMIRX_DWC_PDEC_ASP_ERR                 0x0344
-#define HDMIRX_DWC_PDEC_STS                     0x0360
-#define HDMIRX_DWC_PDEC_GCP_AVMUTE              0x0380
-#define HDMIRX_DWC_PDEC_ACR_CTS                 0x0390
-#define HDMIRX_DWC_PDEC_ACR_N                   0x0394
-#define HDMIRX_DWC_PDEC_AVI_HB                  0x03A0
-#define HDMIRX_DWC_PDEC_AVI_PB                  0x03A4
-#define HDMIRX_DWC_PDEC_AVI_TBB                 0x03A8
-#define HDMIRX_DWC_PDEC_AVI_LRB                 0x03AC
-#define HDMIRX_DWC_PDEC_AIF_CTRL                0x03C0
-#define HDMIRX_DWC_PDEC_AIF_HB                  0x03C4
-#define HDMIRX_DWC_PDEC_AIF_PB0                 0x03C8
-#define HDMIRX_DWC_PDEC_AIF_PB1                 0x03CC
-#define HDMIRX_DWC_PDEC_GMD_HB                  0x03D0
-#define HDMIRX_DWC_PDEC_GMD_PB                  0x03D4
-#define HDMIRX_DWC_DUMMY_IP_REG                 0x0F00
-#define HDMIRX_DWC_PDEC_IEN_CLR                 0x0F78
-#define HDMIRX_DWC_PDEC_IEN_SET                 0x0F7C
-#define HDMIRX_DWC_PDEC_ISTS                    0x0F80
-#define HDMIRX_DWC_PDEC_IEN                     0x0F84
-#define HDMIRX_DWC_PDEC_ICLR                    0x0F88
-#define HDMIRX_DWC_PDEC_ISET                    0x0F8C
-#define HDMIRX_DWC_AUD_CLK_IEN_CLR              0x0F90
-#define HDMIRX_DWC_AUD_CLK_IEN_SET              0x0F94
-#define HDMIRX_DWC_AUD_CLK_ISTS                 0x0F98
-#define HDMIRX_DWC_AUD_CLK_IEN                  0x0F9C
-#define HDMIRX_DWC_AUD_CLK_ICLR                 0x0FA0
-#define HDMIRX_DWC_AUD_CLK_ISET                 0x0FA4
-#define HDMIRX_DWC_AUD_FIFO_IEN_CLR             0x0FA8
-#define HDMIRX_DWC_AUD_FIFO_IEN_SET             0x0FAC
-#define HDMIRX_DWC_AUD_FIFO_ISTS                0x0FB0
-#define HDMIRX_DWC_AUD_FIFO_IEN                 0x0FB4
-#define HDMIRX_DWC_AUD_FIFO_ICLR                0x0FB8
-#define HDMIRX_DWC_AUD_FIFO_ISET                0x0FBC
-#define HDMIRX_DWC_MD_IEN_CLR                   0x0FC0
-#define HDMIRX_DWC_MD_IEN_SET                   0x0FC4
-#define HDMIRX_DWC_MD_ISTS                      0x0FC8
-#define HDMIRX_DWC_MD_IEN                       0x0FCC
-#define HDMIRX_DWC_MD_ICLR                      0x0FD0
-#define HDMIRX_DWC_MD_ISET                      0x0FD4
-#define HDMIRX_DWC_HDMI_IEN_CLR                 0x0FD8
-#define HDMIRX_DWC_HDMI_IEN_SET                 0x0FDC
-#define HDMIRX_DWC_HDMI_ISTS                    0x0FE0
-#define HDMIRX_DWC_HDMI_IEN                     0x0FE4
-#define HDMIRX_DWC_HDMI_ICLR                    0x0FE8
-#define HDMIRX_DWC_HDMI_ISET                    0x0FEC
-#define HDMIRX_DWC_DMI_SW_RST                   0x0FF0
-#define HDMIRX_DWC_DMI_DISABLE_IF               0x0FF4
-#define HDMIRX_DWC_DMI_MODULE_ID                0x0FFC
-#define HDMIRX_DWC_SPARE_REGISTER_5             0x0600
-#define HDMIRX_DWC_SPARE_REGISTER_4             0x0604
-#define HDMIRX_DWC_SPARE_REGISTER_3             0x0608
-#define HDMIRX_DWC_SPARE_REGISTER_2             0x060C
-#define HDMIRX_DWC_SPARE_REGISTER_1             0x0610
-
-// CEC Controller registers addresses
-#define HDMIRX_DWC_CEC_CTRL                     0x1F00
-#define HDMIRX_DWC_CEC_STAT                     0x1F04
-#define HDMIRX_DWC_CEC_MASK                     0x1F08
-#define HDMIRX_DWC_CEC_POLARITY                 0x1F0C
-#define HDMIRX_DWC_CEC_INT                      0x1F10
-#define HDMIRX_DWC_CEC_ADDR_L                   0x1F14
-#define HDMIRX_DWC_CEC_ADDR_H                   0x1F18
-#define HDMIRX_DWC_CEC_TX_CNT                   0x1F1C
-#define HDMIRX_DWC_CEC_RX_CNT                   0x1F20
-#define HDMIRX_DWC_CEC_TX_DATA0                 0x1F40
-#define HDMIRX_DWC_CEC_TX_DATA1                 0x1F44
-#define HDMIRX_DWC_CEC_TX_DATA2                 0x1F48
-#define HDMIRX_DWC_CEC_TX_DATA3                 0x1F4C
-#define HDMIRX_DWC_CEC_TX_DATA4                 0x1F50
-#define HDMIRX_DWC_CEC_TX_DATA5                 0x1F54
-#define HDMIRX_DWC_CEC_TX_DATA6                 0x1F58
-#define HDMIRX_DWC_CEC_TX_DATA7                 0x1F5C
-#define HDMIRX_DWC_CEC_TX_DATA8                 0x1F60
-#define HDMIRX_DWC_CEC_TX_DATA9                 0x1F64
-#define HDMIRX_DWC_CEC_TX_DATA10                0x1F68
-#define HDMIRX_DWC_CEC_TX_DATA11                0x1F6C
-#define HDMIRX_DWC_CEC_TX_DATA12                0x1F70
-#define HDMIRX_DWC_CEC_TX_DATA13                0x1F74
-#define HDMIRX_DWC_CEC_TX_DATA14                0x1F78
-#define HDMIRX_DWC_CEC_TX_DATA15                0x1F7C
-#define HDMIRX_DWC_CEC_RX_DATA0                 0x1F80
-#define HDMIRX_DWC_CEC_RX_DATA1                 0x1F84
-#define HDMIRX_DWC_CEC_RX_DATA2                 0x1F88
-#define HDMIRX_DWC_CEC_RX_DATA3                 0x1F8C
-#define HDMIRX_DWC_CEC_RX_DATA4                 0x1F90
-#define HDMIRX_DWC_CEC_RX_DATA5                 0x1F94
-#define HDMIRX_DWC_CEC_RX_DATA6                 0x1F98
-#define HDMIRX_DWC_CEC_RX_DATA7                 0x1F9C
-#define HDMIRX_DWC_CEC_RX_DATA8                 0x1FA0
-#define HDMIRX_DWC_CEC_RX_DATA9                 0x1FA4
-#define HDMIRX_DWC_CEC_RX_DATA10                0x1FA8
-#define HDMIRX_DWC_CEC_RX_DATA11                0x1FAC
-#define HDMIRX_DWC_CEC_RX_DATA12                0x1FB0
-#define HDMIRX_DWC_CEC_RX_DATA13                0x1FB4
-#define HDMIRX_DWC_CEC_RX_DATA14                0x1FB8
-#define HDMIRX_DWC_CEC_RX_DATA15                0x1FBC
-#define HDMIRX_DWC_CEC_LOCK                     0x1FC0
-#define HDMIRX_DWC_CEC_WKUPCTRL                 0x1FC4
-
-//// DWC_HDMI1.3_RX_Controller registers default valus
-//#define DEFAULT_RX_HDMI_SETUP_CTRL      {6'd0, 1'b1, 1'b1, 6'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 6'd24, 1'b0, 1'b0, 4'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_OVR_CTRL        {1'b0, 3'd0, 2'd0, 1'b0, 3'd0, 1'b0, 1'b0, 3'd0, 1'b0, 2'd0, 3'd0, 3'd0, 7'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_TIMER_CTRL      {21'd0, 1'b0, 10'd632}
-//#define DEFAULT_RX_HDMI_RES_OVR         {4'd0, 4'd5, 1'b0, 7'd0, 1'b0, 6'd0, 1'b0, 1'b0, 1'b0, 6'd0}
-//#define DEFAULT_RX_HDMI_RES_STS         {1'b0, 7'd0, 1'b0, 6'd0, 1'b0, 8'd0, 8'd0}
-//#define DEFAULT_RX_HDMI_PLL_CTRL        {8'd0, 8'd0, 4'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b1, 2'd2, 1'b1, 1'b0, 2'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_PLL_FRQSET1     {8'd114, 8'd82, 8'd49, 8'd33}
-//#define DEFAULT_RX_HDMI_PLL_FRQSET2     {1'b0, 3'd4, 4'd0, 8'd212, 8'd179, 8'd147}
-//#define DEFAULT_RX_HDMI_PLL_PAR1        {4'd12, 4'd6, 4'd15, 4'd5, 4'd15, 4'd8, 4'd9, 4'd4}
-//#define DEFAULT_RX_HDMI_PLL_PAR2        {4'd7, 4'd8, 4'd8, 4'd7, 4'd9, 4'd6, 4'd10, 4'd6}
-//#define DEFAULT_RX_HDMI_PLL_PAR3        {1'b0, 3'd7, 1'b1, 3'd6, 1'b1, 3'd4, 1'b1, 3'd3, 1'b1, 3'd2, 1'b1, 3'd1, 1'b1, 3'd1, 1'b1, 3'd0}
-//#define DEFAULT_RX_HDMI_PLL_LCK_STS     {18'd0, 4'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_CLK_CTRL        {11'd0, 5'd0, 2'd0, 5'd0, 3'd2, 3'd2, 2'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_PCB_CTRL        {6'd0, 1'b0, 1'b0, 4'd0, 2'd0, 1'b0, 1'b0, 3'd0, 1'b0, 1'b0, 3'd0, 3'd0, 1'b0, 1'b0, 3'd0}
-//#define DEFAULT_RX_HDMI_PHS_CTRL        {3'd0, 3'd0, 3'd0, 1'b0, 6'd42, 2'd0, 2'd1, 1'b0, 1'b0, 1'b1, 1'b1, 3'd0, 1'b1, 2'd0, 2'd2}
-//#define DEFAULT_RX_HDMI_PHS_USD         {5'd0, 1'b0, 1'b0, 1'b0, 2'd0, 6'd0, 2'd0, 6'd0, 2'd0, 6'd0}
-//#define DEFAULT_RX_HDMI_MISC_CTRL       {2'd0, 3'd0, 2'd0, 1'b0, 7'd0, 1'b0, 4'd0, 1'b0, 1'b0, 1'b0, 1'b1, 7'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_EQOFF_CTRL      {13'd0, 3'd0, 2'd0, 1'b0, 4'd0, 4'd0, 4'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_EQGAIN_CTRL     {8'd0, 1'b0, 3'd4, 3'd4, 3'd4, 1'b0, 1'b0, 1'b0, 2'd1, 2'd2, 1'b0, 1'b0, 1'b0, 3'd4, 1'b0}
-//#define DEFAULT_RX_HDMI_EQCAL_STS       {2'd0, 4'd0, 4'd0, 4'd0, 1'b0, 1'b0, 1'b0, 3'd0, 3'd0, 3'd0, 3'd0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_EQRESULT        {9'd0, 12'd0, 11'd0}
-//#define DEFAULT_RX_HDMI_EQ_MEAS_CTRL    {12'd0, 1'b0, 1'b0, 1'b0, 1'b0, 16'd0}
-//#define DEFAULT_RX_HDMI_MODE_RECOVER    {6'd0, 2'd0, 5'd0, 1'b0, 5'd8, 5'd8, 2'd0, 2'd0, 2'd0, 2'd0}
-//#define DEFAULT_RX_HDMI_ERROR_PROTECT   {11'd0, 1'b0, 1'b0, 3'd0, 2'd0, 2'd0, 2'd0, 2'd0, 2'd0, 1'b0, 2'd0, 3'd0}
-//#define DEFAULT_RX_HDMI_ERD_STS         {29'd0, 3'd0}
-//#define DEFAULT_RX_HDMI_SYNC_CTRL       {27'd0, 2'd0, 2'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_CKM_EVLTM       {10'd0, 2'd1, 1'b0, 3'd0, 12'd4095, 3'd0, 1'b0}
-//#define DEFAULT_RX_HDMI_CKM_F           {16'd63882, 16'd9009}
-//#define DEFAULT_RX_HDMI_CKM_RESULT      {14'd0, 1'b0, 1'b0, 16'd0}
-//#define DEFAULT_RX_HDMI_RESMPL_CTRL     {27'd0, 4'd0, 1'b1}
-//#define DEFAULT_RX_HDMI_DCM_CTRL        {3'd0, 1'b0, 8'd0, 2'd0, 1'b0, 4'd0, 1'b0, 4'd4, 2'd0, 4'd5, 2'd0}
-//#define DEFAULT_RX_HDMI_VM_CFG_CH_0_1   {16'd0, 16'd0}
-//#define DEFAULT_RX_HDMI_VM_CFG_CH2      {15'd0,  1'b0, 16'd0}
-//#define DEFAULT_RX_HDMI_SPARE           32'd0
-//#define DEFAULT_RX_HDMI_STS             {4'd0, 4'd0, 8'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0}
-//#define DEFAULT_RX_HDCP_CTRL            {17'd0, 1'b0, 1'b0, 1'b0, 2'd0, 2'd0, 2'd0, 3'd0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDCP_SETTINGS        {13'd0, 2'd1, 1'b1, 3'd0, 1'b1, 2'd0, 1'b1, 1'b1, 7'd58, 1'b0}
-//#define DEFAULT_RX_HDCP_SEED            {16'd0, 16'd0}
-//#define DEFAULT_RX_HDCP_BKSV1           {24'd0, 8'd0}
-//#define DEFAULT_RX_HDCP_BKSV0           32'd0
-//#define DEFAULT_RX_HDCP_KIDX            {26'd0, 6'd0}
-//#define DEFAULT_RX_HDCP_KEY1            {8'd0, 24'd0}
-//#define DEFAULT_RX_HDCP_KEY0            32'd0
-//#define DEFAULT_RX_HDCP_DBG             {8'd0, 1'b0, 1'b0, 6'd0, 16'd0}
-//#define DEFAULT_RX_HDCP_AKSV1           {24'd0, 8'd0}
-//#define DEFAULT_RX_HDCP_AKSV0           32'd0
-//#define DEFAULT_RX_HDCP_AN1             32'd0
-//#define DEFAULT_RX_HDCP_AN0             32'd0
-//#define DEFAULT_RX_HDCP_EESS_WOO        {6'd0, 10'd534, 6'd0, 10'd511}
-//#define DEFAULT_RX_HDCP_I2C_TIMEOUT     32'd0
-//#define DEFAULT_RX_HDCP_STS             {31'd0, 1'b1}
-//#define DEFAULT_RX_MD_HCTRL1            {21'd0, 3'd1, 2'd0, 1'b0, 1'b1, 4'd0}
-//#define DEFAULT_RX_MD_HCTRL2            {17'd0, 3'd2, 1'b0, 3'd1, 2'd0, 1'b0, 2'd0, 1'b0, 2'd2}
-//#define DEFAULT_RX_MD_HT0               {16'd0, 7'd0, 9'd0}
-//#define DEFAULT_RX_MD_HT1               {4'd0, 12'd0, 4'd0, 12'd0}
-//#define DEFAULT_RX_MD_HACT_PX           {20'd0, 12'd0}
-//#define DEFAULT_RX_MD_HACT_PXA          {20'd0, 12'd0}
-//#define DEFAULT_RX_MD_VCTRL             {27'd0, 1'b0, 2'd0, 1'b1, 1'b0}
-//#define DEFAULT_RX_MD_VSC               {16'd0, 16'd0}
-//#define DEFAULT_RX_MD_VTC               {10'd0, 22'd0}
-//#define DEFAULT_RX_MD_VOL               {21'd0, 11'd0}
-//#define DEFAULT_RX_MD_VAL               {21'd0, 11'd0}
-//#define DEFAULT_RX_MD_VTH               {20'd0, 2'd2, 2'd0, 2'd0, 3'd2, 3'd2}
-//#define DEFAULT_RX_MD_VTL               {21'd0, 11'd0}
-//#define DEFAULT_RX_MD_IL_CTRL           {31'd0, 1'b0}
-//#define DEFAULT_RX_MD_IL_SKEW           {25'd0, 3'd0, 1'b0, 3'd0}
-//#define DEFAULT_RX_MD_IL_POL            {29'd0, 1'b0, 2'd0}
-//#define DEFAULT_RX_MD_STS               {28'd0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CTRL             {29'd0, 2'd3, 1'b0}
-//#define DEFAULT_RX_AUD_PLL_CTRL         {1'b0, 3'd0, 4'd6, 4'd3, 4'd8, 1'b0, 1'b0, 1'b1, 1'b0, 12'd0}
-//#define DEFAULT_RX_AUD_PLL_LOCK         {16'd0, 16'd128}
-//#define DEFAULT_RX_AUD_PLL_RESET        {1'b1, 31'd14331160}
-//#define DEFAULT_RX_AUD_CLK_CTRL         {24'd0, 1'b0, 1'b0, 1'b0, 1'b0, 2'd0, 1'b1, 1'b1}
-//#define DEFAULT_RX_AUD_CLK_MASP         {12'd0, 20'd3855}
-//#define DEFAULT_RX_AUD_CLK_MAUD         {12'd0, 20'd61440}
-//#define DEFAULT_RX_AUD_FILT_CTRL1       {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FILT_CTRL2       {5'd0, 5'd0, 2'd3, 10'd0, 10'd0}
-//#define DEFAULT_RX_AUD_CTS_MAN          {12'd0, 20'd0}
-//#define DEFAULT_RX_AUD_N_MAN            {12'd0, 20'd0}
-//#define DEFAULT_RX_AUD_CLK_STS          {31'd0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_CTRL        {13'd0, 2'd0, 1'b1, 15'd0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_TH          {5'd0, 9'd144, 9'd32, 9'd32}
-//#define DEFAULT_RX_AUD_FIFO_FILL_S      32'd0
-//#define DEFAULT_RX_AUD_FIFO_CLR_MM      {31'd0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_FILLSTS     {5'd0, 9'd0, 9'd0, 9'd0}
-//#define DEFAULT_RX_AUD_CHEXTR_CTRL      {24'd0, 1'b0, 5'd0, 2'd0}
-//#define DEFAULT_RX_AUD_MUTE_CTRL        {9'd0, 2'd0, 2'd0, 2'd0, 7'd48, 2'd0, 1'b1, 2'd3, 2'd3, 2'd0, 1'b0}
-//#define DEFAULT_RX_AUD_SAO_CTRL         {21'd0, 1'b1, 1'b1, 4'd15, 4'd15, 1'b1}
-//#define DEFAULT_RX_AUD_PAO_CTRL         {20'd0, 8'd176, 1'b0, 2'd0, 1'b0}
-//#define DEFAULT_RX_AUD_SPARE            32'd0
-//#define DEFAULT_RX_AUD_FIFO_STS         {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_CTRL            {23'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 3'd0, 1'b0}
-//#define DEFAULT_RX_PDEC_FIFO_CFG        {2'd0, 10'd32, 10'd32, 10'd32}
-//#define DEFAULT_RX_PDEC_FIFO_STS        {16'd0, 16'd0}
-//#define DEFAULT_RX_PDEC_FIFO_DATA       32'd0
-//#define DEFAULT_RX_PDEC_DBG_CTRL        {15'd0, 1'b0, 7'd0, 1'b0, 8'd0}
-//#define DEFAULT_RX_PDEC_DBG_TMAX        {8'd0, 24'd0}
-//#define DEFAULT_RX_PDEC_DBG_CTS         {16'd0, 8'd0, 8'd0}
-//#define DEFAULT_RX_PDEC_DBG_ACP         {16'd0, 8'd0, 8'd0}
-//#define DEFAULT_RX_PDEC_DBG_ERR_CORR    {8'd0, 8'd2, 7'd0, 1'b0, 8'd1}
-//#define DEFAULT_RX_PDEC_FIFO_STS1       {16'd0, 16'd0}
-//#define DEFAULT_RX_PDEC_ACRM_CTRL       {27'd0, 3'd0, 2'd1}
-//#define DEFAULT_RX_PDEC_ACRM_MAX        {12'd0, 20'd0}
-//#define DEFAULT_RX_PDEC_ACRM_MIN        {8'd0, 4'd0, 20'd0}
-//#define DEFAULT_RX_PDEC_ASP_CTRL        {25'd0, 1'b1, 4'd0, 2'd0}
-//#define DEFAULT_RX_PDEC_ASP_ERR         {16'd0, 16'd0}
-//#define DEFAULT_RX_PDEC_STS             {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_GCP_AVMUTE      {19'd0, 1'b0, 4'd0, 4'd0, 2'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_ACR_CTS         {12'd0, 20'd0}
-//#define DEFAULT_RX_PDEC_ACR_N           {12'd0, 20'd0}
-//#define DEFAULT_RX_PDEC_AVI_HB          {4'd0, 4'd0, 8'd0, 3'd0, 5'd0, 8'd0}
-//#define DEFAULT_RX_PDEC_AVI_PB          {1'b0, 7'd0, 1'b0, 3'd0, 2'd0, 2'd0, 2'd0, 2'd0, 4'd0, 1'b0, 2'd0, 1'b0, 2'd0, 2'd0}
-//#define DEFAULT_RX_PDEC_AVI_TBB         {16'd0, 16'd0}
-//#define DEFAULT_RX_PDEC_AVI_LRB         {16'd0, 16'd0}
-//#define DEFAULT_RX_PDEC_AIF_CTRL        {23'd0, 1'b0, 8'd0}
-//#define DEFAULT_RX_PDEC_AIF_HB          {8'd0, 8'd0, 3'd0, 5'd0, 8'd0}
-//#define DEFAULT_RX_PDEC_AIF_PB0         {8'd0, 8'd0, 3'd0, 3'd0, 2'd0, 4'd0, 1'b0, 3'd0}
-//#define DEFAULT_RX_PDEC_AIF_PB1         {24'd0, 1'b0, 4'd0, 3'd0}
-//#define DEFAULT_RX_PDEC_GMD_HB          {16'd0, 1'b0, 1'b0, 2'd0, 4'd0, 1'b0, 3'd0, 4'd0}
-//#define DEFAULT_RX_PDEC_GMD_PB          {8'd0, 8'd0, 16'd0}
-//#define DEFAULT_RX_DUMMY_IP_REG         32'd0
-//#define DEFAULT_RX_PDEC_IEN_CLR         {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_IEN_SET         {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_ISTS            {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_IEN             {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_ICLR            {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_PDEC_ISET            {3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 7'd0, 1'b0, 3'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CLK_IEN_CLR      {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CLK_IEN_SET      {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CLK_ISTS         {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CLK_IEN          {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CLK_ICLR         {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_CLK_ISET         {30'd0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_IEN_CLR     {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_IEN_SET     {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_ISTS        {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_IEN         {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_ICLR        {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUD_FIFO_ISET        {27'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_MD_IEN_CLR           {20'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_MD_IEN_SET           {20'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_MD_ISTS              {20'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_MD_IEN               {20'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_MD_ICLR              {20'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_MD_ISET              {20'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_IEN_CLR         {1'b0, 6'd0, 1'b0, 7'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_IEN_SET         {1'b0, 6'd0, 1'b0, 7'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_ISTS            {1'b0, 6'd0, 1'b0, 7'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_IEN             {1'b0, 6'd0, 1'b0, 7'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_ICLR            {1'b0, 6'd0, 1'b0, 7'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_HDMI_ISET            {1'b0, 6'd0, 1'b0, 7'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_DMI_SW_RST           {31'd0, 1'b0}
-//#define DEFAULT_RX_DMI_DISABLE_IF       {31'd0, 1'b0}
-//#define DEFAULT_RX_DMI_MODULE_ID        {16'd41154, 4'd5, 4'd0, 8'd0}
-//
-//#define DEFAULT_RX_AUDPLL_GEN_CTS       32'd0
-//#define DEFAULT_RX_AUDPLL_GEN_N         32'd0
-//#define DEFAULT_RX_AUDPLL_GEN_CTRL_RW1  32'd0
-//#define DEFAULT_RX_AUDPLL_GEN_CTRL_RW2  32'd0
-//#define DEFAULT_RX_AUDPLL_GEN_CTRL_W1   32'd0
-//
-//#define DEFAULT_RX_AUDPLL_SC_CTS        {12'd0, 20'd0}
-//#define DEFAULT_RX_AUDPLL_SC_N          {12'd0, 20'd0}
-//#define DEFAULT_RX_AUDPLL_SC_CTRL       {25'd0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}
-//#define DEFAULT_RX_AUDPLL_SC_STS1       {32'd0}
-//#define DEFAULT_RX_AUDPLL_SC_STS2       {32'd0}
-//
-//#define DEFAULT_RX_SPARE_REGISTER_5   32'd0
-//#define DEFAULT_RX_SPARE_REGISTER_4   32'd0
-//#define DEFAULT_RX_SPARE_REGISTER_3   32'd0
-//#define DEFAULT_RX_SPARE_REGISTER_2   32'd0
-//#define DEFAULT_RX_SPARE_REGISTER_1   32'd0
-//
-//// CEC Controller registers default values
-//#define  DEFAULT_RX_CEC_CTRL            {24'd0, 8'h02}
-//#define  DEFAULT_RX_CEC_STAT            {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_MASK            {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_POLARITY        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_INT             {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_ADDR_L          {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_ADDR_H          {24'd0, 8'h80}
-//#define  DEFAULT_RX_CEC_TX_CNT          {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_CNT          {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA0        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA1        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA2        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA3        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA4        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA5        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA6        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA7        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA8        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA9        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA10       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA11       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA12       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA13       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA14       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_TX_DATA15       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA0        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA1        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA2        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA3        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA4        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA5        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA6        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA7        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA8        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA9        {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA10       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA11       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA12       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA13       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA14       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_RX_DATA15       {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_LOCK            {24'd0, 8'h00}
-//#define  DEFAULT_RX_CEC_WKUPCTRL        {24'd0, 8'hff}
-
-#endif /* HDMIRX_PARAMETER_DEFINE_H */
diff --git a/drivers/amlogic/tvin/hdmirx/test/test.c b/drivers/amlogic/tvin/hdmirx/test/test.c
deleted file mode 100644
index 48bddad66b09..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/test.c
+++ /dev/null
@@ -1,127 +0,0 @@
-#include "hdmi.h"
-#include "hdmirx.h"
-#include "hdmirx_parameter.h"
-#include "test_prm.h"
-void hdmi_tx_hpd_detect(void);
-
-// -----------------------------------------------
-// Global variables
-// -----------------------------------------------
-unsigned char   vdin0_field_n               = 0;
-unsigned char   vdin1_field_n               = 0;
-unsigned char   viu_field_n                 = 0;
-
-unsigned char   vid_colour_depth_chg_1st    = 1;
-unsigned char   hdmi_pll_lock               = 0;
-unsigned char   hdmi_mode                   = 0;
-unsigned long   recv_acr_packet_cnt         = 0;
-unsigned char   vsAct_1st                   = 1;
-unsigned char   vactLin_1st                 = 1;
-unsigned char   vtotLin_1st                 = 1;
-unsigned char   htot32_1st                  = 1;
-unsigned char   gcp_rcv                     = 0;
-unsigned long   hs_clk_cnt                  = 0;
-unsigned long   hactPix_cnt                 = 0;
-unsigned long   vofsLin_cnt                 = 0;
-unsigned char   recv_avi                    = 0;
-unsigned char   edid_addr_intr_num          = 0;
-
-unsigned long   curr_pdec_ien_maskn         = 0;
-unsigned long   curr_aud_clk_ien_maskn      = 0;
-unsigned long   curr_aud_fifo_ien_maskn     = 0;
-unsigned long   curr_md_ien_maskn           = 0;
-unsigned long   curr_hdmi_ien_maskn         = 0;
-
-unsigned char   aud_clk_stable              = 0;
-
-// --------------------------------------------------------
-//                     C_Entry
-// --------------------------------------------------------
-void test(void) 
-{
-    unsigned long   data32;
-    unsigned char   divisor_i2s = 0;    // aoclk    = amclk / 1
-    unsigned char   divisor_958 = 0;    // clk958   = amclk / 1
-
-    // --------------------------------------------------------
-    // Set Clocks
-    // --------------------------------------------------------
-    stimulus_print("[TEST.C] Set clock\n");
-
-    // --------------------------------------------------------
-    // Program core_pin_mux to enable HDMI pins
-    // --------------------------------------------------------
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0 , READ_CBUS_REG(PERIPHS_PIN_MUX_0 )|
-				( (1 << 27)   |   // pm_gpioW_0_hdmirx_5V_A  
-				(1 << 26)   |   // pm_gpioW_1_hdmirx_HPD_A 
-				(1 << 25)   |   // pm_gpioW_2_hdmirx_scl_A 
-				(1 << 24)   |   // pm_gpioW_3_hdmirx_sda_A 
-				(1 << 23)   |   // pm_gpioW_4_hdmirx_5V_B  
-				(1 << 22)   |   // pm_gpioW_5_hdmirx_HPD_B 
-				(1 << 21)   |   // pm_gpioW_6_hdmirx_scl_B 
-				(1 << 20)   |   // pm_gpioW_7_hdmirx_sda_B 
-				(1 << 19)   |   // pm_gpioW_8_hdmirx_5V_C  
-				(1 << 18)   |   // pm_gpioW_9_hdmirx_HPD_C 
-				(1 << 17)   |   // pm_gpioW_10_hdmirx_scl_C
-				(1 << 16)   |   // pm_gpioW_11_hdmirx_sda_C
-				(1 << 15)   |   // pm_gpioW_12_hdmirx_5V_D 
-				(1 << 14)   |   // pm_gpioW_13_hdmirx_HPD_D
-				(1 << 13)   |   // pm_gpioW_14_hdmirx_scl_D
-				(1 << 12)   |   // pm_gpioW_15_hdmirx_sda_D
-				(1 << 11)));     // pm_gpioW_16_hdmirx_cec  
-
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_1 , READ_CBUS_REG(PERIPHS_PIN_MUX_1 )|
-				( (1 << 2)    |   // pm_gpioW_17_hdmirx_tmds_clk
-				(1 << 1)    |   // pm_gpioW_18_hdmirx_pix_clk 
-				(1 << 0)));      // pm_gpioW_19_hdmirx_audmeas 
-    
-    // --------------------------------------------------------
-    // Set up HDMI
-    // --------------------------------------------------------
-    hdmirx_test_function (  ACR_MODE,                   // Select which ACR scheme: 0=Analog PLL based ACR; 1=Digital ACR.
-                            MANUAL_ACR_CTS,
-                            MANUAL_ACR_N,
-                            RX_8_CHANNEL,               // Audio channels: 0=2-channel; 1=4 x 2-channel.
-                            EDID_EXTENSION_FLAG,        // Number of 128-bytes blocks that following the basic block
-                            EDID_AUTO_CEC_ENABLE,       // 1=Automatic switch CEC ID depend on RX_PORT_SEL
-                            EDID_CEC_ID_ADDR,           // EDID address offsets for storing 2-byte of Physical Address
-                            EDID_CEC_ID_DATA,           // Physical Address: e.g. 0x1023 is 1.0.2.3
-                            EDID_AUTO_CHECKSUM_ENABLE,  // Checksum byte selection: 0=Use data stored in MEM; 1=Use checksum calculated by HW.
-                            EDID_CLK_DIVIDE_M1,         // EDID I2C clock = sysclk / (1+EDID_CLK_DIVIDE_M1).
-                            HDCP_ON,
-                            HDCP_KEY_DECRYPT_EN,
-                            VIC,                        // Video format identification code
-                            PIXEL_REPEAT_HDMI,
-                            INTERLACE_MODE,             // 0=Progressive; 1=Interlace.
-                            FRONT_PORCH,                // Number of pixels from DE Low to HSYNC high
-                            BACK_PORCH,                 // Number of pixels from HSYNC low to DE high
-                            HSYNC_PIXELS,               // Number of pixels of HSYNC pulse
-                            HSYNC_POLARITY,             // TX HSYNC polarity: 0=low active; 1=high active.
-                            SOF_LINES,                  // HSYNC count between VSYNC de-assertion and first line of active video
-                            EOF_LINES,                  // HSYNC count between last line of active video and start of VSYNC
-                            VSYNC_LINES,                // HSYNC count of VSYNC assertion
-                            VSYNC_POLARITY,             // TX VSYNC polarity: 0=low active; 1=high active.
-                            TOTAL_PIXELS,               // Number of total pixels per line
-                            TOTAL_LINES,                // Number of total lines per frame
-                            RX_INPUT_COLOR_FORMAT,      // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444.
-                            RX_INPUT_COLOR_DEPTH,       // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-                            RX_HSCALE_HALF,             // 1=RX output video horizontally scaled by half, to reduce clock speed.
-                            &curr_pdec_ien_maskn,
-                            &curr_aud_clk_ien_maskn,
-                            &curr_aud_fifo_ien_maskn,
-                            &curr_md_ien_maskn,
-                            &curr_hdmi_ien_maskn,
-                            pdec_ien_maskn,
-                            aud_clk_ien_maskn,
-                            aud_fifo_ien_maskn,
-                            md_ien_maskn,
-                            hdmi_ien_maskn,
-                            RX_PORT_SEL,                // Select HDMI RX input port: 0=PortA; 1=PortB; 2=PortC, 3=PortD; others=invalid.
-                            HDMI_ARCTX_EN,              // Audio Return Channel (ARC) transmission block control:0=Disable; 1=Enable.
-                            HDMI_ARCTX_MODE,            // ARC transmission mode: 0=Single-ended mode; 1=Common mode.
-                            &hdmi_pll_lock);
-
-
-    return;
-}
-
diff --git a/drivers/amlogic/tvin/hdmirx/test/test_prm.h b/drivers/amlogic/tvin/hdmirx/test/test_prm.h
deleted file mode 100644
index 3f56d8511beb..000000000000
--- a/drivers/amlogic/tvin/hdmirx/test/test_prm.h
+++ /dev/null
@@ -1,403 +0,0 @@
-//------------------------------------------------------------------------------
-// Video
-//------------------------------------------------------------------------------
-
-#define VIC                 6                       // Video format identification code: 720(1440)x480i@59.94/60Hz
-#define INTERLACE_MODE      1                       // 0=Progressive; 1=Interlace.
-#define PIXEL_REPEAT_HDMI   (2-1)                   // Pixel repeat factor seen by HDMI TX
-
-//#define MODE_3D             0                       // Define it to enable 3D mode: 1=3D frame-packing; 2=3D side-by-side; 3=3D top-and-bottom.
-#define ACTIVE_SPACE        0                       // For 3D: Number of lines inserted between two active video regions.
-
-#define ACTIVE_PIXELS       (720*(1+PIXEL_REPEAT_HDMI)) // Number of active pixels per line.
-#define ACTIVE_LINES        (480/(1+INTERLACE_MODE))    // Number of active lines per field.
-
-#define LINES_F0            262                     // Number of lines in the even field.
-#define LINES_F1            263                     // Number of lines in the odd field.
-
-#define FRONT_PORCH         38                      // Number of pixels from DE Low to HSYNC high. 
-#define HSYNC_PIXELS        124                     // Number of pixels of HSYNC pulse. 
-#define BACK_PORCH          114                     // Number of pixels from HSYNC low to DE high.
-
-#define EOF_LINES           4                       // HSYNC count between last line of active video and start of VSYNC 
-                                                    // a.k.a. End of Field (EOF). In interlaced mode,
-                                                    // HSYNC count will be eof_lines at the end of even field  
-                                                    // and eof_lines+1 at the end of odd field.
-#define VSYNC_LINES         3                       // HSYNC count of VSYNC assertion
-                                                    // In interlaced mode VSYNC will be in-phase with HSYNC in the even field and 
-                                                    // out-of-phase with HSYNC in the odd field.
-#define SOF_LINES           15                      // HSYNC count between VSYNC de-assertion and first line of active video
-
-#define HSYNC_POLARITY      1                       // TX HSYNC polarity: 0=low active; 1=high active.
-#define VSYNC_POLARITY      1                       // TX VSYNC polarity: 0=low active; 1=high active.
-
-#define TOTAL_FRAMES        1                       // Number of frames to run in simulation
-//#define VIU_DISPLAY_ON                              // Define it to enable viu display
-
-#define TX_INPUT_COLOR_DEPTH    0                       // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-#define TX_OUTPUT_COLOR_DEPTH   0                       // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-#define RX_INPUT_COLOR_DEPTH    TX_OUTPUT_COLOR_DEPTH   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-
-#define TX_INPUT_COLOR_FORMAT   1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-#define TX_OUTPUT_COLOR_FORMAT  1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-#define RX_INPUT_COLOR_FORMAT   ((TX_OUTPUT_COLOR_FORMAT==1)? 2 : (TX_OUTPUT_COLOR_FORMAT==3)? 1 : 0)   // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444.
-
-#define TX_INPUT_COLOR_RANGE    0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-#define TX_OUTPUT_COLOR_RANGE   0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-
-#define RX_HSCALE_HALF          0                   // 1=RX output video horizontally scaled by half, to reduce clock speed.
-
-//------------------------------------------------------------------------------
-// Audio
-//------------------------------------------------------------------------------
-
-#define TX_I2S_SPDIF        1                       // 0=SPDIF; 1=I2S. Note: Must select I2S if CHIP_HAVE_HDMI_RX is defined.
-#define TX_I2S_8_CHANNEL    1                       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
-
-#define RX_AO_SEL           2                       // Select HDMIRX audio output format: 0=SAO SPDIF; 1=SAO I2S; 2=PAO; 3=Audin decode SPDIF; 4=Audin decode I2S.
-#define RX_8_CHANNEL        TX_I2S_8_CHANNEL        // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
-
-#define AUDIO_SAMPLE_RATE   7                       // 0=8kHz; 1=11.025kHz; 2=12kHz; 3=16kHz; 4=22.05kHz; 5=24kHz; 6=32kHz; 7=44.1kHz; 8=48kHz; 9=88.2kHz; 10=96kHz; 11=192kHz; 12=768kHz; Other=48kHz.
-#define AUDIO_PACKET_TYPE   0                       // 0=audio sample packet; 1=one bit audio; 2=HBR audio packet; 3=DST audio packet.
-#define EXP_AUDIO_LENGTH    2304                    // exp/i2s_data.exp file length
-
-// For Audio Clock Recovery
-#define ACR_MODE            0                       // Select which ACR scheme:
-                                                    // 0=Analog PLL based ACR;
-                                                    // 1=Digital ACR.
-
-#define MANUAL_ACR_N        6272
-#define MANUAL_ACR_CTS      ((RX_INPUT_COLOR_DEPTH==0)? 30000 : (RX_INPUT_COLOR_DEPTH==1)? 30000*5/4 : (RX_INPUT_COLOR_DEPTH==2)? 30000*3/2 : 30000*2)
-#define EXPECT_ACR_N        4096
-#define EXPECT_ACR_CTS      19582
-
-#define EXPECT_MEAS_RESULT  145057                  // = T(audio_master_clk) * meas_clk_cycles / T(hdmi_audmeas_ref_clk); where meas_clk_cycles=4096; T(hdmi_audmeas_ref_clk)=5 ns.
-
-#define HDMI_ARCTX_EN       0                       // Audio Return Channel (ARC) transmission block control:0=Disable; 1=Enable.
-#define HDMI_ARCTX_MODE     0                       // ARC transmission mode: 0=Single-ended mode; 1=Common mode.
-
-//------------------------------------------------------------------------------
-// EDID
-//------------------------------------------------------------------------------
-
-#define EDID_EXTENSION_FLAG         4               // Number of 128-bytes blocks that following the basic block
-#define EDID_AUTO_CEC_ENABLE        1               // 1=Automatic switch CEC ID depend on RX_PORT_SEL
-#define EDID_CEC_ID_ADDR            0x00990098      // EDID address offsets for storing 2-byte of Physical Address
-#define EDID_CEC_ID_DATA            0x1023          // Physical Address: e.g. 0x1023 is 1.0.2.3
-#define EDID_AUTO_CHECKSUM_ENABLE   1               // Checksum byte selection: 0=Use data stored in MEM; 1=Use checksum calculated by HW.
-#define EDID_CLK_DIVIDE_M1          2               // EDID I2C clock = sysclk / (1+EDID_CLK_DIVIDE_M1).
-
-//------------------------------------------------------------------------------
-// HDCP
-//------------------------------------------------------------------------------
-
-#define HDCP_ON                 1
-#define HDCP_KEY_DECRYPT_EN     0
-
-//------------------------------------------------------------------------------
-// Interrupt Mask
-//------------------------------------------------------------------------------
-
-#define HDMIRX_DWC_PDEC_IEN_BIT28_dviDet            (1<<28) // 0xf7c bit[28]
-//#define HDMIRX_DWC_PDEC_IEN_BIT27_vsiCksChg         (1<<27) // 0xf7c bit[27]
-//#define HDMIRX_DWC_PDEC_IEN_BIT26_gmdCksChg         (1<<26) // 0xf7c bit[26]
-//#define HDMIRX_DWC_PDEC_IEN_BIT25_aifCksChg         (1<<25) // 0xf7c bit[25]
-//#define HDMIRX_DWC_PDEC_IEN_BIT24_aviCksChg         (1<<24) // 0xf7c bit[24]
-//#define HDMIRX_DWC_PDEC_IEN_BIT23_acrNChg           (1<<23) // 0xf7c bit[23]
-//#define HDMIRX_DWC_PDEC_IEN_BIT22_acrCtsChg         (1<<22) // 0xf7c bit[22]
-//#define HDMIRX_DWC_PDEC_IEN_BIT21_gcpAvmuteChg      (1<<21) // 0xf7c bit[21]
-#define HDMIRX_DWC_PDEC_IEN_BIT20_gmdRcv            (1<<20) // 0xf7c bit[20]
-#define HDMIRX_DWC_PDEC_IEN_BIT19_aifRcv            (1<<19) // 0xf7c bit[19]
-#define HDMIRX_DWC_PDEC_IEN_BIT18_aviRcv            (1<<18) // 0xf7c bit[18]
-//#define HDMIRX_DWC_PDEC_IEN_BIT17_acrRcv            (1<<17) // 0xf7c bit[17]
-#define HDMIRX_DWC_PDEC_IEN_BIT16_gcpRcv            (1<<16) // 0xf7c bit[16]
-#define HDMIRX_DWC_PDEC_IEN_BIT15_vsiRcv            (1<<15) // 0xf7c bit[15]
-#define HDMIRX_DWC_PDEC_IEN_BIT08_pdFifoNewEntry    (1<<8)  // 0xf7c bit[08]
-#define HDMIRX_DWC_PDEC_IEN_BIT04_pdFifoOverfl      (1<<4)  // 0xf7c bit[04]
-#define HDMIRX_DWC_PDEC_IEN_BIT03_pdFifoUnderfl     (1<<3)  // 0xf7c bit[03]
-//#define HDMIRX_DWC_PDEC_IEN_BIT02_pdFifoThStartPass (1<<2)  // 0xf7c bit[02]
-#define HDMIRX_DWC_PDEC_IEN_BIT01_pdFifoThMaxPass   (1<<1)  // 0xf7c bit[01]
-#define HDMIRX_DWC_PDEC_IEN_BIT00_pdFifoThMinPass   (1<<0)  // 0xf7c bit[00]
-
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT22_wakeupctrl     (1<<22) // 0xf94 bit[22]
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT21_errorFoll      (1<<21) // 0xf94 bit[21]
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT20_errorInit      (1<<20) // 0xf94 bit[20]
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT19_arblst         (1<<19) // 0xf94 bit[19]
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT18_nack           (1<<18) // 0xf94 bit[18]
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT17_eom            (1<<17) // 0xf94 bit[17]
-//#define HDMIRX_DWC_AUD_CLK_IEN_BIT16_done           (1<<16) // 0xf94 bit[16]
-#define HDMIRX_DWC_AUD_CLK_IEN_BIT01_sckStable      (1<<1)  // 0xf94 bit[01]
-#define HDMIRX_DWC_AUD_CLK_IEN_BIT00_ctsnCnt        (1<<0)  // 0xf94 bit[00]
-
-#define HDMIRX_DWC_AUD_FIFO_IEN_BIT04_afifOverfl    (1<<4) // 0xfac bit[04]
-#define HDMIRX_DWC_AUD_FIFO_IEN_BIT03_afifUnderfl   (1<<3) // 0xfac bit[03]
-//#define HDMIRX_DWC_AUD_FIFO_IEN_BIT02_afifThsPass   (1<<2) // 0xfac bit[02]
-#define HDMIRX_DWC_AUD_FIFO_IEN_BIT01_afifThMax     (1<<1) // 0xfac bit[01]
-#define HDMIRX_DWC_AUD_FIFO_IEN_BIT00_afifThMin     (1<<0) // 0xfac bit[00]
-
-//#define HDMIRX_DWC_MD_IEN_BIT11_vofsLin             (1<<11) // 0xfc4 bit[11]
-//#define HDMIRX_DWC_MD_IEN_BIT10_vtotLin             (1<<10) // 0xfc4 bit[10]
-//#define HDMIRX_DWC_MD_IEN_BIT09_vactLin             (1<<9)  // 0xfc4 bit[09]
-//#define HDMIRX_DWC_MD_IEN_BIT08_vsClk               (1<<8)  // 0xfc4 bit[08]
-//#define HDMIRX_DWC_MD_IEN_BIT07_vtotClk             (1<<7)  // 0xfc4 bit[07]
-//#define HDMIRX_DWC_MD_IEN_BIT06_hactPix             (1<<6)  // 0xfc4 bit[06]
-//#define HDMIRX_DWC_MD_IEN_BIT05_hsClk               (1<<5)  // 0xfc4 bit[05]
-//#define HDMIRX_DWC_MD_IEN_BIT04_htot32Clk           (1<<4)  // 0xfc4 bit[04]
-#define HDMIRX_DWC_MD_IEN_BIT03_ilace               (1<<3)  // 0xfc4 bit[03]
-//#define HDMIRX_DWC_MD_IEN_BIT02_deActivity          (1<<2)  // 0xfc4 bit[02]
-//#define HDMIRX_DWC_MD_IEN_BIT01_vsAct               (1<<1)  // 0xfc4 bit[01]
-//#define HDMIRX_DWC_MD_IEN_BIT00_hsAct               (1<<0)  // 0xfc4 bit[00]
-
-//#define HDMIRX_DWC_HDMI_IEN_BIT30_i2cmpArblost      (1<<30) // 0xfdc bit[30]
-//#define HDMIRX_DWC_HDMI_IEN_BIT29_i2cmpnack         (1<<29) // 0xfdc bit[29]
-//#define HDMIRX_DWC_HDMI_IEN_BIT28_i2cmpdone         (1<<28) // 0xfdc bit[28]
-//#define HDMIRX_DWC_HDMI_IEN_BIT25_aksvRcv           (1<<25) // 0xfdc bit[25]
-//#define HDMIRX_DWC_HDMI_IEN_BIT24_pllClockGated     (1<<24) // 0xfdc bit[24]
-//#define HDMIRX_DWC_HDMI_IEN_BIT16_dcmCurrentModeChg (1<<16) // 0xfdc bit[16]
-//#define HDMIRX_DWC_HDMI_IEN_BIT15_dcmPhDiffCntOverfl    (1<<15) // 0xfdc bit[15]
-//#define HDMIRX_DWC_HDMI_IEN_BIT14_dcmGcpZeroFieldsPass  (1<<14) // 0xfdc bit[14]
-//#define HDMIRX_DWC_HDMI_IEN_BIT13_ctl3Change            (1<<13) // 0xfdc bit[13]
-//#define HDMIRX_DWC_HDMI_IEN_BIT12_ctl2Change        (1<<12) // 0xfdc bit[12]
-//#define HDMIRX_DWC_HDMI_IEN_BIT11_ctl1Change        (1<<11) // 0xfdc bit[11]
-//#define HDMIRX_DWC_HDMI_IEN_BIT10_ctl0Change        (1<<10) // 0xfdc bit[10]
-//#define HDMIRX_DWC_HDMI_IEN_BIT09_vsPolAdj          (1<<9)  // 0xfdc bit[09]
-//#define HDMIRX_DWC_HDMI_IEN_BIT08_hsPolAdj          (1<<8)  // 0xfdc bit[08]
-//#define HDMIRX_DWC_HDMI_IEN_BIT07_resOverload       (1<<7)  // 0xfdc bit[07]
-//#define HDMIRX_DWC_HDMI_IEN_BIT06_clkChange         (1<<6)  // 0xfdc bit[06]
-#define HDMIRX_DWC_HDMI_IEN_BIT05_pllLckChg         (1<<5)  // 0xfdc bit[05]
-//#define HDMIRX_DWC_HDMI_IEN_BIT04_eqgainDone        (1<<4)  // 0xfdc bit[04]
-//#define HDMIRX_DWC_HDMI_IEN_BIT03_offscalDone       (1<<3)  // 0xfdc bit[03]
-//#define HDMIRX_DWC_HDMI_IEN_BIT02_rescalDone        (1<<2)  // 0xfdc bit[02]
-//#define HDMIRX_DWC_HDMI_IEN_BIT01_actChange         (1<<1)  // 0xfdc bit[01]
-//#define HDMIRX_DWC_HDMI_IEN_BIT00_stateReached      (1<<0)  // 0xfdc bit[00]
-
-unsigned long pdec_ien_maskn    = ( 0
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT28_dviDet
-                                    | HDMIRX_DWC_PDEC_IEN_BIT28_dviDet
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT27_vsiCksChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT27_vsiCksChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT26_gmdCksChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT26_gmdCksChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT25_aifCksChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT25_aifCksChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT24_aviCksChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT24_aviCksChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT23_acrNChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT23_acrNChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT22_acrCtsChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT22_acrCtsChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT21_gcpAvmuteChg
-                                    | HDMIRX_DWC_PDEC_IEN_BIT21_gcpAvmuteChg
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT20_gmdRcv
-                                    | HDMIRX_DWC_PDEC_IEN_BIT20_gmdRcv
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT19_aifRcv
-                                    | HDMIRX_DWC_PDEC_IEN_BIT19_aifRcv
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT18_aviRcv
-                                    | HDMIRX_DWC_PDEC_IEN_BIT18_aviRcv
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT17_acrRcv
-                                    | HDMIRX_DWC_PDEC_IEN_BIT17_acrRcv
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT16_gcpRcv
-                                    | HDMIRX_DWC_PDEC_IEN_BIT16_gcpRcv
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT15_vsiRcv
-                                    | HDMIRX_DWC_PDEC_IEN_BIT15_vsiRcv
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT08_pdFifoNewEntry
-                                    | HDMIRX_DWC_PDEC_IEN_BIT08_pdFifoNewEntry
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT04_pdFifoOverfl
-                                    | HDMIRX_DWC_PDEC_IEN_BIT04_pdFifoOverfl
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT03_pdFifoUnderfl
-                                    | HDMIRX_DWC_PDEC_IEN_BIT03_pdFifoUnderfl
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT02_pdFifoThStartPass
-                                    | HDMIRX_DWC_PDEC_IEN_BIT02_pdFifoThStartPass
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT01_pdFifoThMaxPass
-                                    | HDMIRX_DWC_PDEC_IEN_BIT01_pdFifoThMaxPass
-                                #endif
-                                #ifdef HDMIRX_DWC_PDEC_IEN_BIT00_pdFifoThMinPass
-                                    | HDMIRX_DWC_PDEC_IEN_BIT00_pdFifoThMinPass
-                                #endif
-                                    );
-
-unsigned long aud_clk_ien_maskn = ( 0
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT22_wakeupctrl
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT22_wakeupctrl
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT21_errorFoll
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT21_errorFoll 
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT20_errorInit
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT20_errorInit 
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT19_arblst
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT19_arblst    
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT18_nack
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT18_nack      
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT17_eom
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT17_eom       
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT16_done
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT16_done      
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT01_sckStable
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT01_sckStable 
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_CLK_IEN_BIT00_ctsnCnt
-                                    | HDMIRX_DWC_AUD_CLK_IEN_BIT00_ctsnCnt   
-                                #endif
-                                    );
-
-unsigned long aud_fifo_ien_maskn= ( 0
-                                #ifdef HDMIRX_DWC_AUD_FIFO_IEN_BIT04_afifOverfl
-                                    | HDMIRX_DWC_AUD_FIFO_IEN_BIT04_afifOverfl 
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_FIFO_IEN_BIT03_afifUnderfl
-                                    | HDMIRX_DWC_AUD_FIFO_IEN_BIT03_afifUnderfl
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_FIFO_IEN_BIT02_afifThsPass
-                                    | HDMIRX_DWC_AUD_FIFO_IEN_BIT02_afifThsPass
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_FIFO_IEN_BIT01_afifThMax
-                                    | HDMIRX_DWC_AUD_FIFO_IEN_BIT01_afifThMax  
-                                #endif
-                                #ifdef HDMIRX_DWC_AUD_FIFO_IEN_BIT00_afifThMin
-                                    | HDMIRX_DWC_AUD_FIFO_IEN_BIT00_afifThMin  
-                                #endif
-                                    );
-
-unsigned long md_ien_maskn      = ( 0
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT11_vofsLin
-                                    | HDMIRX_DWC_MD_IEN_BIT11_vofsLin   
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT10_vtotLin
-                                    | HDMIRX_DWC_MD_IEN_BIT10_vtotLin   
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT09_vactLin
-                                    | HDMIRX_DWC_MD_IEN_BIT09_vactLin   
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT08_vsClk
-                                    | HDMIRX_DWC_MD_IEN_BIT08_vsClk     
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT07_vtotClk
-                                    | HDMIRX_DWC_MD_IEN_BIT07_vtotClk   
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT06_hactPix
-                                    | HDMIRX_DWC_MD_IEN_BIT06_hactPix   
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT05_hsClk
-                                    | HDMIRX_DWC_MD_IEN_BIT05_hsClk     
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT04_htot32Clk
-                                    | HDMIRX_DWC_MD_IEN_BIT04_htot32Clk 
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT03_ilace
-                                    | HDMIRX_DWC_MD_IEN_BIT03_ilace     
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT02_deActivity
-                                    | HDMIRX_DWC_MD_IEN_BIT02_deActivity
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT01_vsAct
-                                    | HDMIRX_DWC_MD_IEN_BIT01_vsAct     
-                                #endif
-                                #ifdef HDMIRX_DWC_MD_IEN_BIT00_hsAct
-                                    | HDMIRX_DWC_MD_IEN_BIT00_hsAct     
-                                #endif
-                                    );
-
-unsigned long hdmi_ien_maskn    = ( 0
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT30_i2cmpArblost
-                                    | HDMIRX_DWC_HDMI_IEN_BIT30_i2cmpArblost     
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT29_i2cmpnack
-                                    | HDMIRX_DWC_HDMI_IEN_BIT29_i2cmpnack        
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT28_i2cmpdone
-                                    | HDMIRX_DWC_HDMI_IEN_BIT28_i2cmpdone        
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT25_aksvRcv
-                                    | HDMIRX_DWC_HDMI_IEN_BIT25_aksvRcv          
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT24_pllClockGated
-                                    | HDMIRX_DWC_HDMI_IEN_BIT24_pllClockGated    
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT16_dcmCurrentModeChg
-                                    | HDMIRX_DWC_HDMI_IEN_BIT16_dcmCurrentModeChg
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT15_dcmPhDiffCntOverfl
-                                    | HDMIRX_DWC_HDMI_IEN_BIT15_dcmPhDiffCntOverfl  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT14_dcmGcpZeroFieldsPass
-                                    | HDMIRX_DWC_HDMI_IEN_BIT14_dcmGcpZeroFieldsPass
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT13_ctl3Change
-                                    | HDMIRX_DWC_HDMI_IEN_BIT13_ctl3Change  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT12_ctl2Change
-                                    | HDMIRX_DWC_HDMI_IEN_BIT12_ctl2Change  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT11_ctl1Change
-                                    | HDMIRX_DWC_HDMI_IEN_BIT11_ctl1Change  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT10_ctl0Change
-                                    | HDMIRX_DWC_HDMI_IEN_BIT10_ctl0Change  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT09_vsPolAdj
-                                    | HDMIRX_DWC_HDMI_IEN_BIT09_vsPolAdj    
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT08_hsPolAdj
-                                    | HDMIRX_DWC_HDMI_IEN_BIT08_hsPolAdj    
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT07_resOverload
-                                    | HDMIRX_DWC_HDMI_IEN_BIT07_resOverload 
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT06_clkChange
-                                    | HDMIRX_DWC_HDMI_IEN_BIT06_clkChange   
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT05_pllLckChg
-                                    | HDMIRX_DWC_HDMI_IEN_BIT05_pllLckChg   
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT04_eqgainDone
-                                    | HDMIRX_DWC_HDMI_IEN_BIT04_eqgainDone  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT03_offscalDone
-                                    | HDMIRX_DWC_HDMI_IEN_BIT03_offscalDone 
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT02_rescalDone
-                                    | HDMIRX_DWC_HDMI_IEN_BIT02_rescalDone  
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT01_actChange
-                                    | HDMIRX_DWC_HDMI_IEN_BIT01_actChange   
-                                #endif
-                                #ifdef HDMIRX_DWC_HDMI_IEN_BIT00_stateReached
-                                    | HDMIRX_DWC_HDMI_IEN_BIT00_stateReached
-                                #endif
-                                    );
-
-//------------------------------------------------------------------------------
-// The following parameters are mandatory only if CHIP_HAVE_HDMI_RX
-//------------------------------------------------------------------------------
-#define RX_PORT_SEL             0                   // Select from which input port HDMI RX is to receive: 0=PortA; 1=PortB; 2=PortC, 3=PortD; others=invalid.
-
-//------------------------------------------------------------------------------
-// The following parameters are not to be modified
-//------------------------------------------------------------------------------
-
-#define TOTAL_PIXELS        (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS) // Number of total pixels per line.
-#define TOTAL_LINES         (LINES_F0+(LINES_F1*INTERLACE_MODE))                // Number of total lines per frame.
diff --git a/drivers/amlogic/tvin/isp/Kconfig b/drivers/amlogic/tvin/isp/Kconfig
deleted file mode 100644
index 9625ba07278c..000000000000
--- a/drivers/amlogic/tvin/isp/Kconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-config  TVIN_ISP 
-	tristate "Amlogic ISP device driver"
-	default n
-	help
-		ISP device driver.
diff --git a/drivers/amlogic/tvin/isp/Makefile b/drivers/amlogic/tvin/isp/Makefile
deleted file mode 100644
index e71086483b57..000000000000
--- a/drivers/amlogic/tvin/isp/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-$(CONFIG_TVIN_ISP) += tvin_isp.o
-tvin_isp-objs := isp_hw.o isp_sm.o isp_parm.o isp_drv.o
diff --git a/drivers/amlogic/tvin/isp/isp_drv.c b/drivers/amlogic/tvin/isp/isp_drv.c
deleted file mode 100755
index f309bfaa58c8..000000000000
--- a/drivers/amlogic/tvin/isp/isp_drv.c
+++ /dev/null
@@ -1,1474 +0,0 @@
-/*
- * ISP driver
- *
- * Author: Kele Bai <kele.bai@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/* Standard Linux Headers */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/string.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-/* Amlogic Headers */
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include <mach/am_regs.h>
-#include <mach/vpu.h>
-/* Local Headers */
-#include "../tvin_global.h"
-#include "../tvin_frontend.h"
-#include "../tvin_format_table.h"
-
-#include "isp_drv.h"
-#include "isp_tool.h"
-#include "isp_sm.h"
-#include "isp_regs.h"
-
-#define DEVICE_NAME "isp"
-#define MODULE_NAME "isp"
-
-static struct isp_dev_s *isp_devp[ISP_NUM];
-static unsigned int addr_offset[ISP_NUM];
-static dev_t isp_devno;
-static struct class *isp_clsp;
-static unsigned int isp_debug = 0;
-static unsigned int ae_enable = 1;
-static unsigned int ae_adjust_enable = 1;
-static unsigned int awb_enable = 1;
-static unsigned int af_enable = 1;
-static unsigned int af_pr = 0;
-static unsigned int ioctl_debug = 0;
-static unsigned int isr_debug = 0;
-static unsigned int ae_flag = 0;
-static bool rgb_mode = false;
-
-extern struct isp_ae_to_sensor_s ae_sens;
-static unsigned int def_config = 0;
-static void parse_param(char *buf_orig,char **parm)
-{
-	char *ps, *token;
-	unsigned int n=0;
-	ps = buf_orig;
-
-        if(isp_debug)
-		pr_info("%s parm:%s",__func__,buf_orig);
-
-        while(1) {
-                token = strsep(&ps, " \n");
-                if (token == NULL)
-                        break;
-                if (*token == '\0')
-                        continue;
-                parm[n++] = token;
-        }
-}
-
-static ssize_t debug_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-	isp_dev_t *devp;
-	unsigned int addr,data;
-	char *parm[3]={NULL},*buf_orig;
-	int n=0;
-	if(!buf)
-		return len;
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	devp = dev_get_drvdata(dev);
-	parse_param(buf_orig,&parm);
-	if(!strcmp(parm[0],"r")){
-		addr = simple_strtol(parm[1],NULL,16);
-		data = isp_rd(addr);
-		pr_info("r:0x%x = 0x%x.\n",addr,data);
-	}else if(!strcmp(parm[0],"w")){
-		addr = simple_strtol(parm[1],NULL,16);
-		data = simple_strtol(parm[2],NULL,16);
-		isp_wr(addr,data);
-		pr_info("w:0x%x = 0x%x.\n",addr,data);
-	}else if(!strcmp(parm[0],"reset")){
-		isp_hw_reset();
-	}else if(!strcmp(parm[0],"flag")){
-		data = simple_strtol(parm[1],NULL,16);
-		devp->flag = data;
-		af_sm_init(devp);
-	}else if(!strcmp(parm[0],"lenc-mode")){
-		devp->debug.comb4_mode = simple_strtol(parm[1],NULL,10);
-		devp->flag |= ISP_FLAG_SET_COMB4;
-	}else if(!strcmp(parm[0],"test_pattern")){
-		unsigned int width,height;
-		width = simple_strtol(parm[1],NULL,10);
-		height = simple_strtol(parm[2],NULL,10);
-		isp_test_pattern(width,height,width+26,height+16,0);
-	} else if(!strcmp(parm[0],"rgb")){
-        unsigned int b,r,g;
-        b = RD_BITS(ISP_GAIN_GRBG23, GAIN_GRBG2_BIT, GAIN_GRBG2_WID);
-        r = RD_BITS(ISP_GAIN_GRBG01, GAIN_GRBG1_BIT, GAIN_GRBG1_WID);
-        g = RD_BITS(ISP_GAIN_GRBG01, GAIN_GRBG0_BIT, GAIN_GRBG0_WID);
-        pr_info("%s: r:%d, g:%d b:%d.\n",__func__,r,g,b);
-	}else if(!strcmp(parm[0],"read_ae")){
-	    int i;
-		struct isp_ae_stat_s *ae = &devp->isp_ae;
-		for(i=0;i<16;i++)
-		pr_info("ae->luma_win[%d]=%d.\n",i,ae->luma_win[i]);
-		for(i=0;i<3;i++)
-		pr_info("ae->bayer_over_info[%d]=%d.\n",i,ae->bayer_over_info[i]);
-	}else if(!strcmp(parm[0],"read_awb")){
-	    int i;
-		struct isp_awb_stat_s *awb = &devp->isp_awb;
-		for(i=0;i<3;i++)
-		pr_info("awb->rgb.rgb_sum[%d]=%d.\n",i,awb->rgb.rgb_sum[i]);
-		pr_info("awb->rgb.rgb_count=%d.\n",awb->rgb.rgb_count);
-		for(i=0;i<4;i++)
-		pr_info("awb->yuv_low[%d].sum=%d,count=%d\n",i,awb->yuv_low[i].sum,awb->yuv_low[i].count);
-		for(i=0;i<4;i++)
-		pr_info("awb->yuv_mid[%d].sum=%d,count=%d\n",i,awb->yuv_mid[i].sum,awb->yuv_mid[i].count);
-		for(i=0;i<4;i++)
-		pr_info("awb->yuv_high[%d].sum=%d,count=%d\n",i,awb->yuv_high[i].sum,awb->yuv_high[i].count);
-		//echo wb_test 1 >/sys/class/isp/isp0/debug --disable 3a,disable gamma correction,lensd
-	}else if(!strcmp(parm[0],"wb_test")){
-		unsigned int flag = simple_strtol(parm[1],NULL,10);
-		if(flag)
-			devp->flag |= ISP_FLAG_TEST_WB;
-		else
-			devp->flag &= (~ISP_FLAG_TEST_WB);
-		pr_info("%s wb test.\n",flag?"start":"stop");
-	//echo reconfigure h w bayer_fmt >/sys/class/isp/isp0/debug
-	}else if(!strcmp(parm[0],"reconfigure")){
-		unsigned int width,height,bayer;
-		if(parm[1] && parm[2] && parm[3]){
-			width = simple_strtol(parm[1],NULL,10);//width
-			height = simple_strtol(parm[2],NULL,10);//height
-			bayer = simple_strtol(parm[3],NULL,10);//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-			devp->flag |= ISP_FLAG_RECONFIG;
-			isp_load_def_setting(width,height,bayer);
-			pr_info("default setting:%ux%u bayer=%u.\n",width,height,bayer);
-		}else{
-			devp->flag &= (~ISP_FLAG_RECONFIG);
-			pr_info("config according to configure file.\n");
-		}
-	}else if(!strcmp(parm[0],"bypass_all")){
-		isp_bypass_all();
-		pr_info("isp bypass all for raw data.\n");
-	}
-	return len;
-}
-
-static ssize_t debug_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-	isp_dev_t *devp;
-
-	devp = dev_get_drvdata(dev);
-	len += sprintf(buf+len,"flag=0x%x.\n",devp->flag);
-	return len;
-}
-static DEVICE_ATTR(debug, 0664, debug_show, debug_store);
-
-static ssize_t af_debug_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-	isp_dev_t *devp;
-	int data[10];
-	char *parm[11]={NULL};
-	char *buf_orig = kstrdup(buf, GFP_KERNEL);
-	af_debug_t *af = NULL;
-	if(IS_ERR_OR_NULL(buf)){
-		pr_info("%s: cmd null error.\n",__func__);
-		return len;
-	}
-	parse_param(buf_orig,(char **)&parm);
-	devp = dev_get_drvdata(dev);
-	if(!strcmp(parm[0],"jump")){
-		data[0] = simple_strtol(parm[1],NULL,16);
-		pr_info("%s to 0x%x.\n",parm[0],data[0]);
-		devp->cam_param->cam_function.set_af_new_step(devp->cam_param->cam_function.priv_data,data[0]);
-	//echo start control min max dir delay step >af_debug
-	}else if(!strcmp(parm[0],"start")){
-		af = kmalloc(sizeof(af_debug_t),GFP_KERNEL);
-		if(IS_ERR_OR_NULL(af)){
-			pr_info("%s kmalloc error.\n",__func__);
-			return len;
-		}
-		memset(af,0,sizeof(af_debug_t));
-		if(parm[1]&&parm[2]&&parm[3]&&parm[4]){
-			//data[0] = simple_strtol(parm[1],NULL,16);//control
-			data[1] = simple_strtol(parm[2],NULL,10);//min step
-			data[2] = simple_strtol(parm[3],NULL,10);//max step
-			data[3] = simple_strtol(parm[4],NULL,10);//dir
-			data[4] = simple_strtol(parm[5],NULL,10);//delay
-			data[5] = simple_strtol(parm[6],NULL,10);//pre step
-			data[6] = simple_strtol(parm[7],NULL,10);//mid step
-			data[7] = simple_strtol(parm[8],NULL,10);//post step
-			data[8] = simple_strtol(parm[9],NULL,10);//pre threshold
-			data[9] = simple_strtol(parm[10],NULL,10);//post threshold
-		}
-		//af->control = data[0];
-		af->min_step = data[1];
-		af->cur_step = af->min_step;
-		af->max_step = data[2];
-		af->dir = data[3]>0?true:false;
-		af->delay = data[4];
-		af->pre_step = data[5];
-		af->mid_step = data[6];
-		af->post_step = data[7];
-		af->pre_threshold = data[8];
-		af->post_threshold = data[9];
-
-		af->state = 0;
-		af->step = af->pre_step;
-		if(devp->af_dbg)
-			kfree(devp->af_dbg);
-		devp->af_dbg = af;
-		devp->flag |= ISP_FLAG_AF_DBG;
-		pr_info("%s:full scan from %u-%u-%u-%u.\n",__func__,af->min_step,
-				af->pre_threshold,af->post_threshold,af->max_step);
-	}else if(!strcmp(parm[0],"print")){
-		unsigned int i=0,cursor=0;
-		af = devp->af_dbg;
-		if(IS_ERR_OR_NULL(af))
-			return len;
-		devp->flag &=(~ISP_FLAG_AF_DBG);
-		pr_info("ac[0]   ac[1]    ac[2]   ac[3]   dc[0]   dc[1]   dc[2]   dc[3]   af0_ac   af1_ac\n");
-		if(af->dir){
-			for (i=af->min_step; i <= af->max_step;i+=af->mid_step){
-				cursor = i;
-				while((af->data[cursor].ac[0]==0)&&(cursor!=0)){
-					cursor--;
-				}
-				pr_info("step[%4u]:%u %u %u %u %u %u %u %u %u %u\n",
-					i,af->data[cursor].ac[0],af->data[cursor].ac[1],
-					af->data[cursor].ac[2],af->data[cursor].ac[3],
-					af->data[cursor].dc[0],af->data[cursor].dc[1],
-					af->data[cursor].dc[2],af->data[cursor].dc[3],
-					af->data[cursor].af_ac[0],af->data[cursor].af_ac[1]);
-				msleep(10);
-			}
-		}else{
-			for (i=af->max_step; i <= af->min_step;i+=af->mid_step){
-				cursor = i;
-				while((af->data[cursor].ac[0]==0)&&(cursor!=0)){
-					cursor--;
-				}
-				pr_info("step[%4u]:%u %u %u %u %u %u %u %u %u %u\n",
-					i,af->data[cursor].ac[0],af->data[cursor].ac[1],
-					af->data[cursor].ac[2],af->data[cursor].ac[3],
-					af->data[cursor].dc[0],af->data[cursor].dc[1],
-					af->data[cursor].dc[2],af->data[cursor].dc[3],
-					af->data[cursor].af_ac[0],af->data[cursor].af_ac[1]);
-				msleep(10);
-			}
-		}
-		pr_info("%s:full scan end.\n",__func__);
-		kfree(af);
-		devp->af_dbg = NULL;
-	}else if(!strcmp(parm[0],"blnr_en")){
-		if(parm[1])
-			devp->vs_cnt = simple_strtol(parm[1],NULL,10);
-		else
-			devp->vs_cnt = 4;
-		devp->flag |= ISP_FLAG_BLNR;
-	}else if(!strcmp(parm[0],"af_test")){
-		devp->af_test.max = simple_strtol(parm[1],NULL,10);
-		if(devp->af_test.af_win)
-			kfree(devp->af_test.af_win);
-		if(devp->af_test.af_bl)
-			kfree(devp->af_test.af_bl);
-		devp->af_test.af_win = kmalloc(sizeof(isp_af_stat_t)*devp->af_test.max,GFP_KERNEL);
-		devp->af_test.af_bl = kmalloc(sizeof(isp_blnr_stat_t)*devp->af_test.max,GFP_KERNEL);
-		devp->af_test.cnt = 0;
-		devp->flag |= ISP_TEST_FOR_AF_WIN;
-	}else if(!strcmp(parm[0],"af_print")){
-		int i = 0;
-		unsigned long long sum_ac,sum_dc;
-		pr_info("af:f0_win0 f1_win0 f0_win1 f1_win1 f0_win2 f1_win2 f0_win3 f1_win3 f0_win4 f1_win4 f0_win5 f1_win5 f0_win6 f1_win6 f0_win7 f1_win7\n");
-		for(i=0;i<devp->af_test.cnt;i++){
-			pr_info("%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u\n",
-				devp->af_test.af_win[i].luma_win[0],devp->af_test.af_win[i].luma_win[1],
-				devp->af_test.af_win[i].luma_win[2],devp->af_test.af_win[i].luma_win[3],
-				devp->af_test.af_win[i].luma_win[4],devp->af_test.af_win[i].luma_win[5],
-				devp->af_test.af_win[i].luma_win[6],devp->af_test.af_win[i].luma_win[7],
-				devp->af_test.af_win[i].luma_win[8],devp->af_test.af_win[i].luma_win[9],
-				devp->af_test.af_win[i].luma_win[10],devp->af_test.af_win[i].luma_win[11],
-				devp->af_test.af_win[i].luma_win[12],devp->af_test.af_win[i].luma_win[13],
-				devp->af_test.af_win[i].luma_win[14],devp->af_test.af_win[i].luma_win[15]);
-			msleep(1);
-		}
-		pr_info("blnr:ac0 ac1 ac2 ac3 dc0 dc1 dc2 dc3\n");
-		for(i=0;i<devp->af_test.cnt;i++){
-			pr_info("%u %u %u %u %u %u %u %u\n", devp->af_test.af_bl[i].ac[0],
-				devp->af_test.af_bl[i].ac[1],devp->af_test.af_bl[i].ac[2],
-				devp->af_test.af_bl[i].ac[3],devp->af_test.af_bl[i].dc[0],
-				devp->af_test.af_bl[i].dc[1],devp->af_test.af_bl[i].dc[2],
-				devp->af_test.af_bl[i].dc[3]);
-		}
-		kfree(devp->af_test.af_bl);
-		kfree(devp->af_test.af_win);
-		devp->af_test.af_bl = NULL;
-		devp->af_test.af_win = NULL;
-	}
-
-	kfree(buf_orig);
-
-	return len;
-}
-
-static ssize_t af_debug_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-
-	isp_dev_t *devp = dev_get_drvdata(dev);
-	unsigned int pix_sum = ((devp->info.h_active)*(devp->info.v_active))>>2;
-	len += sprintf(buf+len,"0x%x 0x%x 0x%x 0x%x\n",devp->blnr_stat.dc[0],devp->blnr_stat.dc[1],devp->blnr_stat.dc[2],devp->blnr_stat.dc[3]);
-
-        return len;
-}
-
-static void af_stat(struct af_debug_s *af,cam_function_t *ops)
-{
-	if (af->state == 0) {
-		if(ops&&ops->set_af_new_step)
-			ops->set_af_new_step(ops->priv_data,af->cur_step);
-		af->state = 1;
-		if(af_pr)
-			pr_info("set step %u.\n",af->cur_step);
-	}else if(af->state == af->delay) {
-		af->state = 0;
-		if(af->cur_step >= af->post_threshold)
-			af->step = af->post_step;
-		else if(af->cur_step >= af->pre_threshold)
-			af->step = af->mid_step;
-		else
-			af->step = af->post_step;
-
-		if(af->dir){
-			af->cur_step += af->step;
-			if (af->cur_step > af->max_step){
-				af->cur_step = 0;
-				/*stop*/
-				af->state = 0xffffffff;
-				ops->set_af_new_step(ops->priv_data,0);
-				pr_info("%s get statics ok.\n",__func__);
-			}
-		}else{
-			af->cur_step -= af->step;
-			if (af->cur_step <= af->max_step){
-				af->cur_step = 0;
-				/*stop*/
-				af->state = 0xffffffff;
-				ops->set_af_new_step(ops->priv_data,0);
-				pr_info("%s get statics ok.\n",__func__);
-			}
-		}
-	}
-        return;
-
-}
-static DEVICE_ATTR(af_debug, 0664, af_debug_show, af_debug_store);
-
-
-static ssize_t ae_param_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-
-        char *parm[18]={NULL};
-	isp_dev_t *devp;
-	char *buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	devp = dev_get_drvdata(dev);
-	if(!devp->isp_ae_parm||!buf){
-		pr_err("[%s..]%s %s error.isp device has't started.\n",DEVICE_NAME,__func__,buf);
-		return len;
-	}
-	set_ae_parm(devp->isp_ae_parm,(char **)&parm);
-	kfree(buf_orig);
-	return len;
-}
-
-static ssize_t ae_param_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-	isp_dev_t *devp;
-	char *buff="show";
-
-	devp = dev_get_drvdata(dev);
-	if(!devp->isp_ae_parm){
-		pr_err("[%s..]%s %s error,isp device has't started.\n",DEVICE_NAME,__func__,buf);
-		return len;
-	}
-	set_ae_parm(devp->isp_ae_parm,&buff);
-	return len;
-}
-static DEVICE_ATTR(ae_param, 0664, ae_param_show, ae_param_store);
-
-static ssize_t awb_param_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-        char *parm[21]={NULL};
-	isp_dev_t *devp;
-	char *buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	devp = dev_get_drvdata(dev);
-	if(!devp->isp_awb_parm||!buf){
-		pr_err("[%s..]%s %s error.isp device has't started.\n",DEVICE_NAME,__func__,buf);
-		return len;
-	}
-	set_awb_parm(devp->isp_awb_parm,(char **)&parm);
-	kfree(buf_orig);
-	return len;
-}
-
-static ssize_t awb_param_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-	char *buff ="show";
-	isp_dev_t *devp;
-
-	devp = dev_get_drvdata(dev);
-	if(!devp->isp_awb_parm){
-		len += sprintf(buf+len,"[%s..]%s isp device has't started.\n",DEVICE_NAME,__func__);
-		return len;
-	}
-	set_awb_parm(devp->isp_awb_parm,&buff);
-	return len;
-}
-
-static DEVICE_ATTR(awb_param, 0664, awb_param_show, awb_param_store);
-
-static ssize_t af_param_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-        char *parm[3]={NULL};
-	isp_dev_t *devp;
-	char *buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	devp = dev_get_drvdata(dev);
-	if(!devp->isp_af_parm||!buf){
-		pr_err("[%s..]%s %s error.isp device has't started.\n",DEVICE_NAME,__func__,buf);
-		return len;
-	}
-	set_af_parm(devp->isp_af_parm,(char **)&parm);
-	kfree(buf_orig);
-	return len;
-}
-
-static ssize_t af_param_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-	char *buff="show";
-	isp_dev_t *devp;
-
-	devp = dev_get_drvdata(dev);
-	if(!devp->isp_af_parm){
-		len += sprintf(buf+len,"[%s..]%s isp device has't started.\n",DEVICE_NAME,__func__);
-		return len;
-	}
-	set_af_parm(devp->isp_af_parm,&buff);
-	return len;
-}
-
-static DEVICE_ATTR(af_param, 0664, af_param_show, af_param_store);
-
-static ssize_t capture_param_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-        char *parm[3];
-	isp_dev_t *devp;
-	char *buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	devp = dev_get_drvdata(dev);
-	if(!devp->capture_parm||!buf){
-		pr_err("[%s..]%s %s error.isp device has't started.\n",DEVICE_NAME,__func__,buf);
-		return len;
-	}
-	set_cap_parm(devp->capture_parm,(char **)&parm);
-	kfree(buf_orig);
-	return len;
-}
-
-static ssize_t capture_param_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-	char *buff="show";
-		isp_dev_t *devp;
-
-	devp = dev_get_drvdata(dev);
-	if(!devp->capture_parm){
-		len += sprintf(buf+len,"[%s..]%s isp device has't started.\n",DEVICE_NAME,__func__);
-		return len;
-	}
-	set_cap_parm(devp->capture_parm,&buff);
-	return len;
-}
-
-static DEVICE_ATTR(cap_param, 0664, capture_param_show, capture_param_store);
-
-static ssize_t wave_param_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-        char *parm[3];
-	isp_dev_t *devp;
-	char *buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	devp = dev_get_drvdata(dev);
-	if(!devp->wave||!buf){
-		pr_err("[%s..]%s %s error.isp device has't started.\n",DEVICE_NAME,__func__,buf);
-		return len;
-	}
-	if(!strcmp(parm[0],"torch")){
-		unsigned int level = simple_strtol(parm[1],NULL,10);
-		pr_info("%s:set torch level to %u.\n",__func__,level);
-		torch_level(devp->flash.mode_pol_inv,devp->flash.led1_pol_inv,devp->flash.pin_mux_inv,devp->flash.torch_pol_inv,devp->wave,level);
-	}else{
-		set_wave_parm(devp->wave,(char **)&parm);
-	}
-	kfree(buf_orig);
-	return len;
-}
-
-static ssize_t wave_param_show(struct device *dev,struct device_attribute *attr, char* buf)
-{
-	size_t len = 0;
-	char *buff="show";
-		isp_dev_t *devp;
-
-	devp = dev_get_drvdata(dev);
-	if(!devp->wave){
-		len += sprintf(buf+len,"[%s..]%s isp device has't started.\n",DEVICE_NAME,__func__);
-		return len;
-	}
-	set_wave_parm(devp->wave,&buff);
-	return len;
-}
-static DEVICE_ATTR(wave_param, 0664, wave_param_show, wave_param_store);
-
-static ssize_t gamma_debug_store(struct device *dev,struct device_attribute *attr, const char* buf, size_t len)
-{
-	unsigned int curve_ratio,r,g,b;
-	if(buf){
-		curve_ratio = simple_strtol(buf,NULL,16);
-    	        r = (curve_ratio >> 8) & 15;
-		g = (curve_ratio >> 4) & 15;
-		b = (curve_ratio >> 0) & 15;
-		pr_info("curve ratio r:%u,g:%u,b:%u.\n",r,g,b);
-		if(!set_gamma_table_with_curve_ratio(r,g,b))
-			pr_info("%s:set gamma error.\n",__func__);
-	}else{
-		pr_info("%s:null pointer error.\n",__func__);
-	}
-	return len;
-}
-static ssize_t gamma_debug_show(struct class *cls,struct class_attribute *attr,char *buf)
-{
-	unsigned short *gammaR, *gammaG, *gammaB, i;
-	gammaR = kmalloc(257 * sizeof(unsigned short), GFP_KERNEL);
-	gammaG = kmalloc(257 * sizeof(unsigned short), GFP_KERNEL);
-	gammaB = kmalloc(257 * sizeof(unsigned short), GFP_KERNEL);
-	get_isp_gamma_table(gammaR,GAMMA_R);
-	get_isp_gamma_table(gammaG,GAMMA_G);
-	get_isp_gamma_table(gammaB,GAMMA_B);
-	pr_info("  r        g         b.\n");
-	for(i=0;i<257;i++){
-		pr_info("0x%3x    0x%3x    0x%3x\n",
-                        gammaR[i],gammaG[i],gammaB[i]);
-		msleep(1);
-	}
-	kfree(gammaR);
-	kfree(gammaG);
-	kfree(gammaB);
-	return 0;
-}
-
-static DEVICE_ATTR(gamma_debug, 0664, gamma_debug_show, gamma_debug_store);
-
-static ssize_t gamma_show(struct class *cls,struct class_attribute *attr,char *buf)
-{
-	pr_info("Usage:");
-	pr_info("	echo sgr|sgg|sgb xxx...xx > /sys/class/register/gamma\n");
-	pr_info("Notes:");
-	pr_info("	if the string xxx......xx is less than 257*3,");
-	pr_info("	then the remaining will be set value 0\n");
-	pr_info("	if the string xxx......xx is more than 257*3, ");
-	pr_info("	then the remaining will be ignored\n");
-	return 0;
-}
-
-static ssize_t gamma_store(struct class *cls,
-			 struct class_attribute *attr,
-			 const char *buffer, size_t count)
-{
-
-	char *buf_orig, *parm[4];
-	unsigned short *gammaR, *gammaG, *gammaB;
-	unsigned int gamma_count;
-	char gamma[4];
-	int i = 0;
-
-	/* to avoid the bellow warning message while compiling:
-	 * warning: the frame size of 1576 bytes is larger than 1024 bytes
-	 */
-	gammaR = kmalloc(257 * sizeof(unsigned short), GFP_KERNEL);
-	gammaG = kmalloc(257 * sizeof(unsigned short), GFP_KERNEL);
-	gammaB = kmalloc(257 * sizeof(unsigned short), GFP_KERNEL);
-
-	buf_orig = kstrdup(buffer, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-
-	if ((parm[0][0] == 's') && (parm[0][1] == 'g')) {
-		memset(gammaR, 0, 257 * sizeof(unsigned short));
-		gamma_count = (strlen(parm[1]) + 2) / 3;
-		if (gamma_count > 257)
-			gamma_count = 257;
-
-		for (i = 0; i < gamma_count; ++i) {
-			gamma[0] = parm[1][3 * i + 0];
-			gamma[1] = parm[1][3 * i + 1];
-			gamma[2] = parm[1][3 * i + 2];
-			gamma[3] = '\0';
-			gammaR[i] = simple_strtol(gamma, NULL, 16);
-		}
-
-		switch (parm[0][2]) {
-		case 'r':
-			set_isp_gamma_table(gammaR, GAMMA_R);
-			break;
-
-		case 'g':
-			set_isp_gamma_table(gammaR, GAMMA_G);
-			break;
-
-		case 'b':
-			set_isp_gamma_table(gammaR, GAMMA_B);
-			break;
-		default:
-			break;
-		}
-	} else {
-		pr_info("invalid command\n");
-		pr_info("please: cat /sys/class/isp/isp0/gamma");
-
-	}
-	kfree(buf_orig);
-	kfree(gammaR);
-	kfree(gammaG);
-	kfree(gammaB);
-	return count;
-}
-
-static DEVICE_ATTR(gamma, 0664, gamma_show, gamma_store);
-
-static ssize_t ls_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-        ssize_t len = 0;
-
-        len += sprintf(buf+len," command format:\n");
-        len += sprintf(buf+len," echo psize_v2h ocenter_c2l ocenter_c2t gain_0db curvature_gr curvature_r curvature_b curvature_gb force_enable > ... \n");
-
-        len += sprintf(buf+len," Example:\n");
-        len += sprintf(buf+len," echo enable 100 50 50 0 120 120 120 120 1 > /sys/class/isp/isp0/lens \n");
-
-        return len;
-}
-
-static ssize_t ls_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t len)
-{
-	char *buf_orig, *parm[10]={NULL};
-        isp_dev_t *devp;
-	devp = dev_get_drvdata(dev);
-	isp_info_t *info = &devp->info;
-        unsigned int psize_v2h,hactive,vactive,ocenter_c2l,ocenter_c2t,gain_0db, curvature_gr,curvature_r;
-        unsigned int curvature_b,curvature_gb;
-        bool force_enable;
-
-	/* to avoid the bellow warning message while compiling:
-	 * warning: the frame size of 1576 bytes is larger than 1024 bytes
-	 */
-        if(!buf)
-                return len;
-
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	if(!strcmp(parm[0],"enable")) {
-	        psize_v2h = simple_strtoul(     parm[1],NULL,10);
-	        ocenter_c2l = simple_strtoul(   parm[2],NULL,10);
-	        ocenter_c2t = simple_strtoul(   parm[3],NULL,10);
-	        gain_0db = simple_strtoul(      parm[4],NULL,10);
-	        curvature_gr = simple_strtoul(  parm[5],NULL,10);
-	        curvature_r = simple_strtoul(   parm[6],NULL,10);
-                curvature_b = simple_strtoul(   parm[7],NULL,10);
-                curvature_gb = simple_strtoul(  parm[8],NULL,10);
-                force_enable = simple_strtoul(  parm[9],NULL,10);
-
-                pr_info("psize_v2h:%u hactive:%u vactive:%u ocenter_c2l:%u ocenter_c2t:%u gain_0db:%u curvature_gr:%u curvature_r:%u curvature_b:%u curvature_gb:%u force_enable:%u \n", \
-                psize_v2h,info->h_active,info->v_active,ocenter_c2l,ocenter_c2t,gain_0db, \
-                curvature_gr,curvature_r, curvature_b,curvature_gb,force_enable);
-
-                isp_ls_curve(psize_v2h,info->h_active,info->v_active,ocenter_c2l,ocenter_c2t,gain_0db, \
-                curvature_gr,curvature_r, curvature_b,curvature_gb,force_enable);
-        }
-	kfree(buf_orig);
-
-	return len;
-}
-
-static DEVICE_ATTR(lens, 0664, ls_show, ls_store);
-
-/*
-*get aet current state
-*cat /sys/class/isp/isp0/aet
-*set aet new step
-*echo x >/sys/class/isp/isp0/aet
-*/
-static ssize_t aet_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-        ssize_t len = 0;
-	struct cam_function_s *cam_func;
-	isp_dev_t *devp = dev_get_drvdata(dev);
-    
-        if(!buf)
-                return len;
-	if(devp->cam_param)
-		cam_func = &(devp->cam_param->cam_function);
-	else
-		return len;
-        len += sprintf(buf+len,"aet_current_step: %u.\n",cam_func->get_aet_current_step(cam_func->priv_data));
-        len += sprintf(buf+len,"aet_current_gain:%u.\n",cam_func->get_aet_current_gain(cam_func->priv_data));
-        len += sprintf(buf+len,"aet_min_gain:%u.\n",cam_func->get_aet_min_gain(cam_func->priv_data));
-        len += sprintf(buf+len,"aet_max_gain:%u.\n",cam_func->get_aet_max_gain(cam_func->priv_data));
-        len += sprintf(buf+len,"aet_max_step:%u.\n",cam_func->get_aet_max_step(cam_func->priv_data));
-
-        return len;
-}
-
-static ssize_t aet_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t len)
-{
-	char *buf_orig,*parm[4]={NULL};
-	struct cam_function_s *cam_func;
-        isp_dev_t *devp=dev_get_drvdata(dev);
-    
-        if(!buf)
-                return len;	
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,(char **)&parm);
-	if(devp->cam_param)
-		cam_func = &(devp->cam_param->cam_function);
-	else
-		return len;
-	
-	if(parm[0]){
-		unsigned int step = simple_strtol(parm[0],NULL,10);
-		cam_func->set_aet_new_step(cam_func->priv_data,step,1,1);
-	}
-	
-	kfree(buf_orig);
-
-	return len;
-}
-
-static DEVICE_ATTR(aet, 0664, aet_show, aet_store);
-
-#ifndef USE_WORK_QUEUE
-static int isp_thread(isp_dev_t *devp) {
-	unsigned newstep = 0;
-	struct cam_function_s *func = &devp->cam_param->cam_function;
-	printk("isp_thread is run! \n");
-	while (1) {
-	        if(ae_flag&0x2) {
-		        ae_flag &= (~0x2);
-		        newstep = isp_tune_exposure(devp);
-		        printk("set new step2 %d \n",newstep);
-		        if(func&&func->set_aet_new_step)
-		                func->set_aet_new_step(func->priv_data,newstep,true,true);
-	        }
-	        if(atomic_read(&devp->ae_info.writeable)&&func&&func->set_aet_new_step){
-		        if(isp_debug)
-			        printk("[isp] set new step:%d \n",ae_sens.new_step);
-		        if(ae_adjust_enable)
-			        func->set_aet_new_step(func->priv_data,ae_sens.new_step,ae_sens.shutter,ae_sens.gain);
-		        atomic_set(&devp->ae_info.writeable,0);
-	        }
-	        if(devp->flag&ISP_FLAG_AF_DBG){
-		        af_stat(devp->af_dbg,func);
-	        }
-	        if(devp->flag & ISP_AF_SM_MASK) {
-		        if(atomic_read(&devp->af_info.writeable)&&func&&func->set_af_new_step){
-			        func->set_af_new_step(func->priv_data,devp->af_info.cur_step);
-			        atomic_set(&devp->af_info.writeable,0);
-		        }
-	        }
-                if(kthread_should_stop())
-                        break;
-	}
-}
-
-static int start_isp_thread(isp_dev_t *devp) {
-	if(!devp->kthread) {
-		devp->kthread = kthread_run(isp_thread, devp, "isp");
-		if(IS_ERR(devp->kthread)) {
-			pr_err("[%s..]%s thread creating error.\n",DEVICE_NAME,__func__);
-			return -1;
-		}
-		wake_up_process(devp->kthread);
-	}
-	return 0;
-}
-
-static void stop_isp_thread(isp_dev_t *devp) {
-    if(devp->kthread){
-        send_sig(SIGTERM, devp->kthread, 1);
-        kthread_stop(devp->kthread);
-        devp->kthread = NULL;
-    }
-}
-#endif
-
-static int isp_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        if(port == TVIN_PORT_ISP)
-                return 0;
-        else
-                return -1;
-}
-
-static int isp_fe_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-	vdin_parm_t *parm = (vdin_parm_t*)fe->private_data;
-	isp_info_t *info = &devp->info;
-
-	info->fe_port = parm->isp_fe_port;
-	info->bayer_fmt = parm->cfmt;
-	info->cfmt = TVIN_YUV422;
-	info->dfmt = parm->dfmt;
-	info->h_active = parm->h_active;
-	info->v_active = parm->v_active;
-	info->frame_rate = parm->frame_rate;
-	info->skip_cnt = 0;
-	devp->isp_fe = tvin_get_frontend(info->fe_port, 0);
-	if(devp->isp_fe && devp->isp_fe->dec_ops) {
-		devp->isp_fe->private_data = fe->private_data;
-		devp->isp_fe->dec_ops->open(devp->isp_fe, info->fe_port);
-		pr_info("[%s..]%s: open %s ok.\n",DEVICE_NAME,__func__,tvin_port_str(info->fe_port));
-	} else {
-		pr_info("[%s..]%s:get %s frontend error.\n",DEVICE_NAME,__func__,tvin_port_str(info->fe_port));
-	}
-	/*open the isp to vdin path,power on the isp hw module*/
-	switch_vpu_mem_pd_vmod(VPU_ISP,VPU_MEM_POWER_ON);
-        devp->cam_param = (cam_parameter_t*)parm->reserved;
-	if(IS_ERR_OR_NULL(devp->cam_param)){
-		pr_err("[%s..] camera parameter error use default config.\n",__func__);
-		isp_load_def_setting(info->h_active,info->v_active,0);
-	}  else {
-		devp->isp_ae_parm = &devp->cam_param->xml_scenes->ae;
-		devp->isp_awb_parm = &devp->cam_param->xml_scenes->awb;
-		unsigned int i;
-		devp->isp_af_parm = &devp->cam_param->xml_scenes->af;
-		devp->isp_af_parm->valid_step_cnt = 0;
-		for(i = 0;devp->isp_af_parm->step[i] != 0;i++){
-			devp->isp_af_parm->valid_step_cnt++;
-		}
-		devp->capture_parm = devp->cam_param->xml_capture;
-		devp->wave = devp->cam_param->xml_wave;
-		isp_hw_enable(false);
-		isp_set_def_config(devp->cam_param->xml_regs_map,info->fe_port,info->bayer_fmt,info->h_active,info->v_active);
-		isp_set_manual_wb(devp->cam_param->xml_wb_manual);
-		if (rgb_mode){
-			isp_bypass_for_rgb();
-			info->cfmt = TVIN_RGB444;
-		}
-		/*test for wb test disable gamma & lens*/
-		if(devp->flag & ISP_FLAG_TEST_WB)
-			disable_gc_lns_pk(false);
-		/*enable isp hw*/
-		isp_hw_enable(true);
-		devp->af_info.x0 = info->h_active/devp->isp_af_parm->win_ratio;
-		devp->af_info.y0 = info->v_active/devp->isp_af_parm->win_ratio;
-		devp->af_info.x1 = info->h_active - devp->af_info.x0;
-		devp->af_info.y1 = info->v_active - devp->af_info.y0;
-		devp->af_info.radius = info->h_active/devp->isp_af_parm->radius_ratio;
-		devp->af_info.af_detect = kmalloc(sizeof(isp_blnr_stat_t)*devp->isp_af_parm->detect_step_cnt,GFP_KERNEL);
-		devp->af_info.v_dc = kmalloc(sizeof(unsigned long long)*devp->isp_af_parm->detect_step_cnt,GFP_KERNEL);
-	}
-        return 0;
-}
-
-static void isp_fe_close(struct tvin_frontend_s *fe)
-{
-        isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-		if(devp->af_info.af_detect)
-			kfree(devp->af_info.af_detect);
-		if(devp->af_info.v_dc)
-			kfree(devp->af_info.v_dc);
-	if(devp->isp_fe)
-		devp->isp_fe->dec_ops->close(devp->isp_fe);
-        memset(&devp->info,0,sizeof(isp_info_t));
-	/*power down isp hw*/
-	isp_hw_enable(false);
-	switch_vpu_mem_pd_vmod(VPU_ISP,VPU_MEM_POWER_DOWN);
-
-}
-
-static void isp_fe_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-        isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-
-	pr_info("[%s..]%s:isp start.\n",DEVICE_NAME,__func__);
-
-	if(devp->isp_fe)
-	        devp->isp_fe->dec_ops->start(devp->isp_fe,fmt);
-
-	/*configuration the hw,load reg table*/
-
-	if(!IS_ERR_OR_NULL(devp->cam_param)) {
-	        if(devp->cam_param->cam_mode == CAMERA_CAPTURE){
-		        devp->flag = ISP_FLAG_CAPTURE;
-			capture_sm_init(devp);
-	        }else if(devp->cam_param->cam_mode == CAMERA_RECORD){
-		        devp->flag = ISP_FLAG_RECORD;
-#ifndef USE_WORK_QUEUE
-			start_isp_thread(devp);
-#endif
-	        }else{
-		        devp->flag &= (~ISP_WORK_MODE_MASK);
-#ifndef USE_WORK_QUEUE
-			start_isp_thread(devp);
-#endif
-	        }
-        }
-#ifndef USE_WORK_QUEUE
-    tasklet_enable(&devp->isp_task);
-#endif
-        devp->flag |= ISP_FLAG_START;
-	return;
-}
-static void isp_fe_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-
-        isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-	if(devp->isp_fe)
-	        devp->isp_fe->dec_ops->stop(devp->isp_fe,devp->info.fe_port);
-#ifndef USE_WORK_QUEUE
-	tasklet_disable_nosync(&devp->isp_task);
-#endif
-	if(devp->cam_param->cam_mode != CAMERA_CAPTURE)
-#ifndef USE_WORK_QUEUE
-		stop_isp_thread(devp);
-#endif
-	devp->flag &= (~ISP_FLAG_AF);
-	devp->flag &= (~ISP_FLAG_TOUCH_AF);
-	isp_sm_uninit(devp);
-	/*disable hw*/
-        devp->flag &= (~ISP_FLAG_START);
-}
-static int isp_fe_ioctl(struct tvin_frontend_s *fe, void *arg)
-{
-	unsigned int x0,y0,x1,y1;
-	isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-	cam_parameter_t *param = (cam_parameter_t *)arg;
-	enum cam_command_e cmd;
-	cam_cmd_state_t ret = CAM_STATE_SUCCESS;
-	if(IS_ERR_OR_NULL(param)||rgb_mode) {
-		if(ioctl_debug)
-                        pr_err("[%s..]camera parameter can't be null.\n",DEVICE_NAME);
-                return -1;
-        }
-	cmd = param->cam_command;
-	devp->cam_param = param;
-	if(ioctl_debug)
-	 	pr_info("[%s..]%s:cmd: %s run mode %u.\n",DEVICE_NAME,__func__,cam_cmd_to_str(cmd),devp->cam_param->cam_mode);
-	switch(cmd) {
-                case CAM_COMMAND_INIT:
-		        break;
-		case CAM_COMMAND_GET_STATE:
-			ret = devp->cmd_state;
-			break;
-                case CAM_COMMAND_SCENES:
-		        devp->isp_ae_parm = &param->xml_scenes->ae;
-		        devp->isp_awb_parm = &param->xml_scenes->awb;
-		        devp->isp_af_parm = &param->xml_scenes->af;
-		        devp->capture_parm = param->xml_capture;
-		        devp->flag |= ISP_FLAG_SET_SCENES;
-		        break;
-                case CAM_COMMAND_EFFECT:
-	                devp->flag |= ISP_FLAG_SET_EFFECT;
-		        break;
-                case CAM_COMMAND_AWB:
-			if(!(devp->flag & ISP_FLAG_CAPTURE)){
-	               	        devp->flag |= ISP_FLAG_AWB;
-			}
-		        break;
-		case CAM_COMMAND_MWB:
-			devp->flag &= (~ISP_FLAG_AWB);
-	                devp->flag |= ISP_FLAG_MWB;
-		        break;
-		case CAM_COMMAND_SET_WORK_MODE:
-			if(devp->cam_param->cam_mode == CAMERA_CAPTURE)
-		                devp->flag = ISP_FLAG_CAPTURE;
-	                else if(devp->cam_param->cam_mode == CAMERA_RECORD)
-		                devp->flag = ISP_FLAG_RECORD;
-	                else
-		                devp->flag &= (~ISP_WORK_MODE_MASK);
-			break;
-                // ae related
-                case CAM_COMMAND_AE_ON:
-			if(!(devp->flag & ISP_FLAG_CAPTURE)){
-		        	isp_sm_init(devp);
-		        	devp->flag |= ISP_FLAG_AE;
-			}
-		        break;
-                case CAM_COMMAND_AE_OFF:
-		        devp->flag &= (~ISP_FLAG_AE);
-		        break;
-		case CAM_COMMAND_SET_AE_LEVEL:
-			devp->ae_info.manul_level = devp->cam_param->exposure_level;
-			isp_set_manual_exposure(devp);
-			break;
-                // af related
-                case CAM_COMMAND_AF:
-			devp->flag |= ISP_FLAG_AF;
-			af_sm_init(devp);
-		        break;
-                case CAM_COMMAND_FULLSCAN:
-			isp_set_af_scan_stat(devp->af_info.x0,devp->af_info.y0,devp->af_info.x1,devp->af_info.y1);
-			devp->flag |= ISP_FLAG_TOUCH_AF;
-			devp->cmd_state = CAM_STATE_DOING;
-			af_sm_init(devp);
-		        break;
-                case CAM_COMMAND_TOUCH_FOCUS:
-			if(!(devp->flag & ISP_FLAG_CAPTURE)){
-				devp->flag |= ISP_FLAG_TOUCH_AF;
-			        //devp->isp_af_parm = &param->xml_scenes->af;
-			        devp->isp_af_parm->x = param->xml_scenes->af.x;
-			        devp->isp_af_parm->y = param->xml_scenes->af.y;
-			        x0 = devp->isp_af_parm->x>devp->af_info.radius?devp->isp_af_parm->x-devp->af_info.radius:0;
-			        y0 = devp->isp_af_parm->y>devp->af_info.radius?devp->isp_af_parm->y-devp->af_info.radius:0;
-			        x1 = devp->isp_af_parm->x + devp->af_info.radius;
-			        y1 = devp->isp_af_parm->y + devp->af_info.radius;
-			        if(x1 >= devp->info.h_active)
-				        x1 = devp->info.h_active - 1;
-			        if(y1 >= devp->info.v_active)
-				        y1 = devp->info.v_active - 1;
-			        if(ioctl_debug)
-				        pr_info("focus win: center(%u,%u) left(%u %u) right(%u,%u).\n",devp->isp_af_parm->x,
-					devp->isp_af_parm->y,x0,y0,x1,y1);
-			        isp_set_af_scan_stat(x0,y0,x1,y1);
-			        af_sm_init(devp);
-			}
-		        break;
-                case CAM_COMMAND_CONTINUOUS_FOCUS_ON:
-			if(!(devp->flag & ISP_FLAG_CAPTURE)){
-			        devp->flag |= ISP_FLAG_AF;
-				af_sm_init(devp);
-			}
-		        break;
-                case CAM_COMMAND_CONTINUOUS_FOCUS_OFF:
-			devp->flag &= (~ISP_FLAG_AF);
-		        break;
-                case CAM_COMMAND_BACKGROUND_FOCUS_ON:
-		        break;
-                case CAM_COMMAND_BACKGROUND_FOCUS_OFF:
-		        break;
-                // flash related
-                case CAM_COMMAND_SET_FLASH_MODE:
-			isp_set_flash_mode(devp);
-		        break;
-                // torch related
-                case CAM_COMMAND_TORCH:
-		        devp->wave = param->xml_wave;
-		        torch_level(devp->flash.mode_pol_inv,devp->flash.led1_pol_inv,devp->flash.pin_mux_inv,devp->flash.torch_pol_inv,devp->wave,param->level);
-		        break;
-		case CMD_ISP_BYPASS:
-			isp_bypass_all();
-			break;
-	        default:
-		        break;
-	}
-	return ret;
-}
-static int isp_fe_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
-{
-	xml_csc_t *csc;
-	xml_wb_manual_t *wb;
-	af_debug_t *af;
-        isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-	struct isp_af_info_s *af_info = &devp->af_info;
-	int ret = 0;
-	if(IS_ERR_OR_NULL(devp->cam_param)){
-		pr_info("%s:null pointer error.\n",__func__);
-	}
-	if(devp->flag & ISP_FLAG_RECONFIG)
-		return ret;
-
-	if(awb_enable){
-                isp_get_awb_stat(&devp->isp_awb);
-	}
-	if((devp->flag&ISP_FLAG_AE)&&(ae_enable)){
-	        isp_get_ae_stat(&devp->isp_ae);
-	}
-	if((devp->flag&ISP_AF_SM_MASK)&&(af_enable)){
-	        isp_get_blnr_stat(&af_info->isr_af_data);
-		isp_get_af_scan_stat(&af_info->isr_af_data);
-	}
-	if(devp->flag & ISP_FLAG_SET_EFFECT){
-		csc = &(devp->cam_param->xml_effect_manual->csc);
-		isp_set_matrix(csc,devp->info.v_active);
-		devp->flag &= (~ISP_FLAG_SET_EFFECT);
-	}
-	if(devp->flag&ISP_FLAG_CAPTURE){
-		isp_get_blnr_stat(&devp->blnr_stat);
-		isp_get_af_scan_stat(&devp->blnr_stat);
-	}
-	if(devp->flag&ISP_FLAG_BLNR){
-		isp_get_blnr_stat(&devp->blnr_stat);
-		isp_get_af_scan_stat(&devp->blnr_stat);
-		if(devp->vs_cnt-- == 0)
-			devp->flag &= (~ISP_FLAG_BLNR);
-	}
-	if(devp->flag & ISP_FLAG_AF_DBG){
-		af = devp->af_dbg;
-		if((af->state >= 1)&&(af->state <= af->delay)){
-			isp_get_blnr_stat(&af->data[af->cur_step]);
-			isp_get_af_scan_stat(&af->data[af->cur_step]);
-			af->state++;
-		}
-	}
-	if(devp->flag & ISP_TEST_FOR_AF_WIN){
-		isp_get_blnr_stat(&devp->af_test.af_bl[devp->af_test.cnt]);
-		//isp_get_af_scan_stat(&devp->af_test.af_bl[devp->af_test.cnt]);
-		isp_get_af_stat(&devp->af_test.af_win[devp->af_test.cnt]);
-		//isp_get_ae_stat(&devp->af_test.ae_win[devp->af_test.cnt]);
-		devp->af_test.cnt+=1;
-		if(devp->af_test.cnt >= devp->af_test.max){
-			devp->flag &=(~ISP_TEST_FOR_AF_WIN);
-			pr_info("get af win,ae win&blnr info end.\n");
-		}
-	}
-	if(devp->flag&ISP_FLAG_MWB){
-		wb = devp->cam_param->xml_wb_manual;
-		isp_set_manual_wb(wb);
-		devp->flag &=(~ISP_FLAG_MWB);
-	}
-	if(devp->flag&ISP_FLAG_SET_COMB4){
-		isp_set_lnsd_mode(devp->debug.comb4_mode);
-		devp->flag &= (~ISP_FLAG_SET_COMB4);
-	}
-	if(devp->isp_fe)
-		ret = devp->isp_fe->dec_ops->decode_isr(devp->isp_fe,0);
-
-	if(devp->flag & ISP_FLAG_CAPTURE)
-		ret = max(isp_capture_sm(devp),ret);
-	if(isr_debug&&ret)
-		pr_info("%s isp %d buf.\n",__func__,ret);
-	
-	
-#ifndef USE_WORK_QUEUE
-	if(!(devp->flag & ISP_FLAG_TEST_WB))
-	    tasklet_schedule(&devp->isp_task);
-#else
-        schedule_work(&devp->isp_wq);
-#endif
-        return ret;
-}
-
-#ifndef USE_WORK_QUEUE
-static void isp_tasklet(unsigned long arg)
-{
-	isp_dev_t *devp = (isp_dev_t *)arg;
-        if((devp->flag & ISP_FLAG_AE)&&(ae_enable)){
-	    	isp_ae_sm(devp);
-        }
-	if((devp->flag&ISP_FLAG_AWB)&&(awb_enable)){
-    		isp_awb_sm(devp);
-	}
-	if((devp->flag&ISP_AF_SM_MASK)&&(af_enable)){
-		isp_af_detect(devp);
-	}
-}
-
-#else
-
-static void  isp_do_work(struct work_struct *work)
-{
-
-	isp_dev_t *devp = container_of(work, isp_dev_t, isp_wq);
-
-	unsigned newstep = 0;
-	struct cam_function_s *func = &devp->cam_param->cam_function;
-
-	if(!(devp->flag & ISP_FLAG_TEST_WB)){
-		if((devp->flag & ISP_FLAG_AE)&&(ae_enable)){
-			isp_ae_sm(devp);
-		}
-		if((devp->flag&ISP_FLAG_AWB)&&(awb_enable)){
-			isp_awb_sm(devp);
-		}
-		if((devp->flag&ISP_AF_SM_MASK)&&(af_enable)){
-			isp_af_detect(devp);
-		}
-	}
-
-	if(ae_flag&0x2)	{
-		ae_flag &= (~0x2);
-		newstep = isp_tune_exposure(devp);
-		printk("wq:set new step2 %d \n",newstep);
-		if(func&&func->set_aet_new_step)
-			func->set_aet_new_step(func->priv_data,newstep,true,true);
-	}
-	if(atomic_read(&devp->ae_info.writeable)&&func&&func->set_aet_new_step)	{
-		if(isp_debug)
-		        printk("[isp] wq:set new step:%d \n",ae_sens.new_step);
-		if(ae_adjust_enable)
-			func->set_aet_new_step(func->priv_data,ae_sens.new_step,ae_sens.shutter,ae_sens.gain);
-		atomic_set(&devp->ae_info.writeable,0);
-	}
-	if(devp->flag&ISP_FLAG_AF_DBG){
-		af_stat(devp->af_dbg,func);
-	}
-	if(devp->flag & ISP_AF_SM_MASK) {
-		if(atomic_read(&devp->af_info.writeable)&&func&&func->set_af_new_step){
-			func->set_af_new_step(func->priv_data,devp->af_info.cur_step);
-			atomic_set(&devp->af_info.writeable,0);
-		}
-	}
-
-}
-#endif
-
-static struct tvin_decoder_ops_s isp_dec_ops ={
-        .support            = isp_support,
-	.open               = isp_fe_open,
-	.start              = isp_fe_start,
-	.stop               = isp_fe_stop,
-	.close              = isp_fe_close,
-	.ioctl              = isp_fe_ioctl,
-	.decode_isr         = isp_fe_isr,
-};
-static void isp_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-	isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-        prop->color_format = devp->info.cfmt;
-	prop->dest_cfmt = devp->info.dfmt;
-        prop->pixel_repeat = 0;
-}
-static bool isp_frame_skip(struct tvin_frontend_s *fe)
-{
-	isp_dev_t *devp = container_of(fe,isp_dev_t,frontend);
-	if(devp->isp_fe && devp->isp_fe->sm_ops){
-		if(devp->isp_fe->sm_ops->check_frame_skip)
-			return devp->isp_fe->sm_ops->check_frame_skip(devp->isp_fe);
-	}
-	return 0;
-}
-
-static struct tvin_state_machine_ops_s isp_sm_ops ={
-       .get_sig_propery  = isp_sig_propery,
-       .check_frame_skip = isp_frame_skip,
-};
-
-static int isp_open(struct inode *inode, struct file *file)
-{
-	isp_dev_t *devp;
-	/* Get the per-device structure that contains this cdev */
-	devp = container_of(inode->i_cdev, isp_dev_t, cdev);
-	file->private_data = devp;
-	return 0;
-}
-
-static int isp_release(struct inode *inode, struct file *file)
-{
-	file->private_data = NULL;
-	return 0;
-}
-static struct file_operations isp_fops = {
-	.owner	         = THIS_MODULE,
-	.open	         = isp_open,
-	.release         = isp_release,
-};
-static int isp_add_cdev(struct cdev *cdevp, struct file_operations *fops,
-		int minor)
-{
-	int ret;
-	dev_t devno = MKDEV(MAJOR(isp_devno), minor);
-	cdev_init(cdevp, fops);
-	cdevp->owner = THIS_MODULE;
-	ret = cdev_add(cdevp, devno, 1);
-	return ret;
-}
-
-static struct device * isp_create_device(struct device *parent, int minor)
-{
-	dev_t devno = MKDEV(MAJOR(isp_devno), minor);
-	return device_create(isp_clsp, parent, devno, NULL, "%s%d",
-			DEVICE_NAME, minor);
-}
-
-static void isp_delete_device(int minor)
-{
-	dev_t devno = MKDEV(MAJOR(isp_devno), minor);
-	device_destroy(isp_clsp, devno);
-}
-
-static int isp_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct isp_dev_s *devp = NULL;
-	devp = kmalloc(sizeof(isp_dev_t),GFP_KERNEL);
-	memset(devp,0,sizeof(isp_dev_t));
-	if(!devp){
-		pr_err("[%s..]%s kmalloc error.\n",DEVICE_NAME,__func__);
-		return -ENOMEM;
-	}
-	devp->index = pdev->id;
-	devp->offset = addr_offset[devp->index];
-	isp_devp[devp->index] = devp;
-	/* create cdev and reigser with sysfs */
-	ret = isp_add_cdev(&devp->cdev,&isp_fops,devp->index);
-
-	devp->dev = isp_create_device(&pdev->dev,devp->index);
-
-	ret = device_create_file(devp->dev,&dev_attr_debug);
-	ret = device_create_file(devp->dev,&dev_attr_ae_param);
-	ret = device_create_file(devp->dev,&dev_attr_awb_param);
-	ret = device_create_file(devp->dev,&dev_attr_af_param);
-	ret = device_create_file(devp->dev,&dev_attr_af_debug);
-	ret = device_create_file(devp->dev,&dev_attr_cap_param);
-	ret = device_create_file(devp->dev,&dev_attr_wave_param);
-	ret = device_create_file(devp->dev,&dev_attr_gamma_debug);
-	ret = device_create_file(devp->dev,&dev_attr_gamma);
-	ret = device_create_file(devp->dev,&dev_attr_lens);
-	ret = device_create_file(devp->dev,&dev_attr_aet);
-	if(ret < 0)
-		goto err;
-
-	sprintf(devp->frontend.name, "%s%d", DEVICE_NAME, devp->index);
-
-	if(!tvin_frontend_init(&devp->frontend,&isp_dec_ops,&isp_sm_ops,devp->index)) {
-		if(tvin_reg_frontend(&devp->frontend))
-			pr_err("[%s..]%s register isp frontend error.\n",DEVICE_NAME,__func__);
-	}
-#ifdef USE_WORK_QUEUE
-    INIT_WORK(&devp->isp_wq,(void (*)(void *))isp_do_work);
-#else
-    tasklet_init(&devp->isp_task,isp_tasklet,(unsigned long)devp);
-    tasklet_disable(&devp->isp_task);
-#endif
-	platform_set_drvdata(pdev,(void *)devp);
-	dev_set_drvdata(devp->dev,(void *)devp);
-	pr_info("[%s..]%s isp probe ok.\n",DEVICE_NAME,__func__);
-	return 0;
-err:
-	isp_delete_device(devp->index);
-	return 0;
-
-}
-static int isp_remove(struct platform_device *pdev)
-{
-	struct isp_dev_s *devp;
-	devp = platform_get_drvdata(pdev);
-	device_remove_file(devp->dev,&dev_attr_debug);
-	device_remove_file(devp->dev,&dev_attr_ae_param);
-	device_remove_file(devp->dev,&dev_attr_awb_param);
-	device_remove_file(devp->dev,&dev_attr_af_param);
-	device_remove_file(devp->dev,&dev_attr_cap_param);
-	device_remove_file(devp->dev,&dev_attr_wave_param);
-	device_remove_file(devp->dev,&dev_attr_lens);
-
-	isp_delete_device(devp->index);
-        tvin_unreg_frontend(&devp->frontend);
-#ifndef USE_WORK_QUEUE
-	tasklet_kill(&devp->isp_task);
-#endif
-	kfree(devp);
-	return 0;
-}
-
-static int isp_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	wave_power_manage(false);
-	return 0;
-}
-
-static int isp_resume(struct platform_device *pdev)
-{
-	wave_power_manage(true);
-	return 0;
-}
-static struct platform_driver isp_driver = {
-	.probe 	 = isp_probe,
-	.remove  = isp_remove,
-	.suspend = isp_suspend,
-	.resume  = isp_resume,
-	.driver = {
-		.name = DEVICE_NAME,
-	}
-};
-
-static struct platform_device *isp_dev[ISP_NUM];
-static int __init isp_init_module(void)
-{
-	int i = 0;
-	isp_clsp = class_create(THIS_MODULE, MODULE_NAME);
-	if(IS_ERR(isp_clsp)) {
-		pr_err();
-	}
-	for(i=0;i<ISP_NUM;i++) {
-		isp_dev[i] = platform_device_alloc(DEVICE_NAME,i);
-		platform_device_add(isp_dev[i]);
-	}
-	platform_driver_register(&isp_driver);
-
-	return 0;
-}
-
-
-static void __exit isp_exit_module(void)
-{
-	int i = 0;
-	for(i=0;i<ISP_NUM;i++){
-		platform_device_del(isp_dev[i]);
-	}
-	platform_driver_unregister(&isp_driver);
-	class_destroy(isp_clsp);
-	return;
-}
-module_param(isp_debug,uint,0664);
-MODULE_PARM_DESC(isp_debug,"\n debug flag for isp.\n");
-
-module_param(ae_enable,uint,0664);
-MODULE_PARM_DESC(ae_enable,"\n ae_enable.\n");
-
-module_param(ae_adjust_enable,uint,0664);
-MODULE_PARM_DESC(ae_adjust_enable,"\n ae_adjust_enable.\n");
-
-module_param(awb_enable,uint,0664);
-MODULE_PARM_DESC(awb_enable,"\n awb_enable.\n");
-
-module_param(af_enable,uint,0664);
-MODULE_PARM_DESC(af_enable,"\n af enable flag.\n");
-
-module_param(ae_flag,uint,0664);
-MODULE_PARM_DESC(ae_flag,"\n debug flag for ae_flag.\n");
-
-module_param(af_pr,uint,0664);
-MODULE_PARM_DESC(af_pr,"\n debug flag for af print.\n");
-
-module_param(ioctl_debug,uint,0664);
-MODULE_PARM_DESC(ioctl_debug,"\n debug ioctl function.\n");
-
-module_param(isr_debug,uint,0664);
-MODULE_PARM_DESC(isr_debug,"\n debug isr function.\n");
-
-module_param(rgb_mode,bool,0664);
-MODULE_PARM_DESC(rgb_mode,"\n debug for rgb output.\n");
-
-MODULE_VERSION(ISP_VER);
-module_init(isp_init_module);
-module_exit(isp_exit_module);
-MODULE_DESCRIPTION("AMLOGIC isp input driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/tvin/isp/isp_drv.h b/drivers/amlogic/tvin/isp/isp_drv.h
deleted file mode 100755
index 2c1ee9badf93..000000000000
--- a/drivers/amlogic/tvin/isp/isp_drv.h
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * ISP driver
- *
- * Author: Kele Bai <kele.bai@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_ISP_DRV_H
-#define __TVIN_ISP_DRV_H
-
-/* Standard Linux Headers */
-#include <linux/cdev.h>
-#include <linux/spinlock.h>
-#include <linux/irqreturn.h>
-#include <linux/timer.h>
-#include <linux/mutex.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/device.h>
-
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include "isp_hw.h"
-#include "../tvin_frontend.h"
-
-#define ISP_VER					"2014.01.03a"
-#define ISP_NUM					1
-#define DEVICE_NAME 			        "isp"
-
-#define USE_WORK_QUEUE
-
-#define ISP_FLAG_START				0x00000001
-#define ISP_FLAG_AE				0x00000002
-#define ISP_FLAG_AWB				0x00000004
-#define ISP_FLAG_AF				0x00000008
-#define ISP_FLAG_CAPTURE			0x00000010
-#define ISP_FLAG_RECORD				0x00000020
-#define ISP_WORK_MODE_MASK			0x00000030
-#define ISP_FLAG_SET_EFFECT			0x00000040
-#define ISP_FLAG_SET_SCENES			0x00000080
-#define ISP_FLAG_AF_DBG				0x00000100
-#define ISP_FLAG_MWB			        0x00000200
-#define ISP_FLAG_BLNR				0x00000400
-#define ISP_FLAG_SET_COMB4			0x00000800
-#define ISP_TEST_FOR_AF_WIN			0x00001000
-#define ISP_FLAG_TOUCH_AF			0x00002000
-#define ISP_FLAG_SKIP_BUF			0x00004000
-#define ISP_FLAG_TEST_WB			0x00008000
-#define ISP_FLAG_RECONFIG                       0x00010000
-
-#define ISP_AF_SM_MASK				ISP_FLAG_AF|ISP_FLAG_TOUCH_AF
-
-typedef enum bayer_fmt_e {
-	RAW_BGGR = 0,
-	RAW_RGGB,
-	RAW_GBRG,
-	RAW_GRBG,//3
-} bayer_fmt_t;
-typedef struct isp_info_s {
-	tvin_port_t fe_port;
-	tvin_color_fmt_t bayer_fmt;
-	tvin_color_fmt_t cfmt;
-	tvin_color_fmt_t dfmt;
-	unsigned int h_active;
-	unsigned int v_active;
-	unsigned int frame_rate;
-	unsigned int skip_cnt;
-} isp_info_t;
-/*config in bsp*/
-typedef struct flash_property_s {
-	bool 	 valid;		 //true:have flash,false:havn't flash
-	bool     torch_pol_inv;  // false: negative correlation
-                                 // true: positive correlation
-        bool 	 pin_mux_inv;	 // false: led1=>pin1 & led2=>pin2, true: led1=>pin2 & led2=>pin1
-
-        bool 	 led1_pol_inv;	 // false: active high, true: active low
-        bool     mode_pol_inv;   //        TORCH  FLASH
-                                 //false: low      high
-                                 //true:  high     low
-} flash_property_t;
-/*parameters used for ae in sm or driver*/
-typedef struct isp_ae_info_s {
-	int manul_level;//each step 2db
-	atomic_t writeable;
-} isp_ae_info_t;
-
-/*for af debug*/
-typedef struct af_debug_s {
-	bool            dir;
-	//unsigned int    control;
-	unsigned int    state;
-	unsigned int    step;
-	unsigned int 	min_step;
-		 int 	max_step;
-	unsigned int    delay;
-		 int 	cur_step;
-	unsigned int    pre_step;
-	unsigned int	mid_step;
-	unsigned int	post_step;
-	unsigned int	pre_threshold;
-	unsigned int	post_threshold;
-	isp_blnr_stat_t data[1024];
-} af_debug_t;
-/*for af test debug*/
-typedef struct af_debug_test_s {
-	unsigned int cnt;
-	unsigned int max;
-	struct isp_af_stat_s *af_win;
-	struct isp_blnr_stat_s *af_bl;
-	struct isp_ae_stat_s  *ae_win;
-	struct isp_awb_stat_s  *awb_stat;
-} af_debug_test_t;
-/*for af fine tune*/
-typedef struct isp_af_fine_tune_s {
-	unsigned int cur_step;
-	isp_blnr_stat_t af_data;
-} isp_af_fine_tune_t;
-
-typedef struct isp_af_info_s {
-	unsigned int cur_index;
-	/*for lose focus*/
-	unsigned int *v_dc;
-        bool	     last_move;
-	isp_blnr_stat_t last_blnr;
-	/*for climbing algorithm*/
-	unsigned int great_step;
-	unsigned int cur_step;
-	unsigned int capture_step;
-	isp_blnr_stat_t *af_detect;
-	isp_blnr_stat_t af_data[FOCUS_GRIDS];
-	//unsigned char af_delay;
-	atomic_t writeable;
-	/*window for full scan&detect*/
-	unsigned int x0;
-	unsigned int y0;
-	unsigned int x1;
-	unsigned int y1;
-	/*touch window radius*/
-	unsigned int radius;
-	/* blnr tmp for isr*/
-	isp_blnr_stat_t isr_af_data;
-	unsigned int valid_step_cnt;
-	isp_af_fine_tune_t af_fine_data[FOCUS_GRIDS];
-}isp_af_info_t;
-
-/*for debug cmd*/
-typedef struct debug_s {
-	unsigned int comb4_mode;
-} debug_t;
-
-typedef struct isp_dev_s{
-	int             index;
-	dev_t		devt;
-	unsigned int    offset;
-	struct cdev	cdev;
-	struct device	*dev;
-	unsigned int    flag;
-	unsigned int 	vs_cnt;
-        /*add for tvin frontend*/
-        tvin_frontend_t frontend;
-	tvin_frontend_t *isp_fe;
-
-	struct isp_info_s info;
-#ifndef USE_WORK_QUEUE
-    struct tasklet_struct isp_task;
-    struct task_struct     *kthread;
-#else
-    struct work_struct isp_wq;
-#endif
-	struct isp_ae_stat_s isp_ae;
-	struct isp_ae_info_s ae_info;
-	struct isp_awb_stat_s isp_awb;
-	struct isp_af_stat_s isp_af;
-	struct isp_af_info_s af_info;
-	struct isp_blnr_stat_s blnr_stat;
-	cam_parameter_t *cam_param;
-	xml_algorithm_ae_t *isp_ae_parm;
-	xml_algorithm_awb_t *isp_awb_parm;
-	xml_algorithm_af_t *isp_af_parm;
-	xml_capture_t *capture_parm;
-	wave_t        *wave;
-	flash_property_t flash;
-	af_debug_t      *af_dbg;
-	debug_t         debug;
-	/*test for af test win*/
-	af_debug_test_t af_test;
-	/*cmd state for camera*/
-	cam_cmd_state_t cmd_state;
-}isp_dev_t;
-
-typedef enum data_type_e{
-	ISP_U8=0,
-	ISP_U16,
-	ISP_U32,
-	ISP_FLOAT,
-}data_type_t;
-
-typedef struct isp_param_s{
-    const char *name;
-    unsigned int *param;
-    unsigned char length;
-    data_type_t type;
-}isp_param_t;
-
-extern void set_ae_parm(xml_algorithm_ae_t * ae_sw,char * * parm);
-extern void set_awb_parm(xml_algorithm_awb_t * awb_sw,char * * parm);
-extern void set_af_parm(xml_algorithm_af_t * af_sw,char * * parm);
-extern void set_cap_parm(struct xml_capture_s * cap_sw,char * * parm);
-extern void set_wave_parm(struct wave_s * wave,char * * parm);
-extern bool set_gamma_table_with_curve_ratio(unsigned int r,unsigned int g,unsigned int b);
-#endif
-
diff --git a/drivers/amlogic/tvin/isp/isp_hw.c b/drivers/amlogic/tvin/isp/isp_hw.c
deleted file mode 100755
index d462c4e0e1ab..000000000000
--- a/drivers/amlogic/tvin/isp/isp_hw.c
+++ /dev/null
@@ -1,1400 +0,0 @@
-/*
- * ISP driver
- *
- * Author: Kele Bai <kele.bai@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <mach/am_regs.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/err.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include "isp_regs.h"
-#include "isp_hw.h"
-
-#define DEVICE_NAME "isp"
-
-static unsigned int gamma_enable = 1;
-module_param(gamma_enable,uint,0664);
-MODULE_PARM_DESC(gamma_enable,"\n enable/disable for gamma.\n");
-
-static unsigned int af_filter0 = 7;
-module_param(af_filter0,uint,0664);
-MODULE_PARM_DESC(af_filter0,"\n filter for af hist.\n");
-
-static unsigned int af_filter1 = 2;
-module_param(af_filter1,uint,0664);
-MODULE_PARM_DESC(af_filter1,"\n filter for af hist.\n");
-
-static unsigned int af_limit = 0;
-module_param(af_limit,uint,0664);
-MODULE_PARM_DESC(af_filter0,"\n filter for af hist.\n");
-
-/*
-*reg 0x00~0x07
-*reg 0xaf
-*/
-
-static int isp_param_lns_lut_480p[1024] = {
-	0x8a809c8a,0x857c9785,0x80769080,0x7a71897a,0x756d8575,0x71688171,0x6c657b6c,0x69617769,0x665f7366,0x635c6f63,0x615a6c61,0x5f586a5f,0x5e57685e,0x5d56675d,0x5c55655c,0x5b55665b,0x5c56655c,0x5c55665c,0x5c56665c,0x5d57675d,0x5f58695f,0x60596c60,0x625b6f62,0x645d7264,0x68607668,0x6b637b6b,0x70678070,0x746b8474,0x796f8a79,0x7d74907d,0x83799783,0x887e9c88,
-	0x887e9a88,0x837a9483,0x7d748e7d,0x786f8778,0x736b8273,0x6e677d6e,0x6a62776a,0x675f7367,0x645d6f64,0x615a6c61,0x5f59695f,0x5d57675d,0x5b56655b,0x5a55645a,0x59546359,0x59536359,0x59546259,0x59546359,0x5a55635a,0x5b55645b,0x5c56665c,0x5e58695e,0x60596c60,0x635c6e63,0x655e7365,0x69617769,0x6d657c6d,0x71698171,0x766d8676,0x7b728c7b,0x81779381,0x867c9986,
-	0x847b9684,0x80789180,0x7a728a7a,0x756d8475,0x70677e70,0x6b63786b,0x67607367,0x635d6f63,0x615a6b61,0x5e58685e,0x5c56655c,0x5a55635a,0x58536158,0x58526058,0x57525e57,0x56525e56,0x56525e56,0x56525e56,0x57525f57,0x58536158,0x59546359,0x5b55655b,0x5d57685d,0x60596b60,0x625b6f62,0x655e7365,0x6a62786a,0x6e667e6e,0x736b8273,0x786f8978,0x7e758f7e,0x82789582,
-	0x82789282,0x7d748e7d,0x776f8677,0x726a8072,0x6d657b6d,0x68617568,0x645d6f64,0x615a6c61,0x5e58685e,0x5b56655b,0x59546259,0x58536058,0x56515e56,0x55515c55,0x54505b54,0x544f5b54,0x544f5a54,0x54505b54,0x54505c54,0x55515d55,0x57525f57,0x58536258,0x5a55655a,0x5d57685d,0x60596b60,0x635c6f63,0x665f7566,0x6b647a6b,0x70687f70,0x766d8676,0x7b728c7b,0x7f76927f,
-	0x7e768f7e,0x7a728a7a,0x746c8374,0x6f677d6f,0x6a62776a,0x655e7165,0x615b6c61,0x5e58685e,0x5b56655b,0x59546259,0x57525e57,0x55515c55,0x534f5a53,0x524e5852,0x514e5751,0x514d5751,0x514d5751,0x514d5751,0x524e5952,0x534f5953,0x54505c54,0x56515e56,0x58536158,0x5a55645a,0x5d57685d,0x60596c60,0x645d7064,0x68617668,0x6d657c6d,0x736a8273,0x786f8978,0x7c748e7c,
-	0x7c738c7c,0x786f8778,0x726a8072,0x6c657a6c,0x67607467,0x635c6e63,0x5f596a5f,0x5b56655b,0x59546259,0x56525f56,0x54505c54,0x524f5952,0x514d5751,0x504c5550,0x4f4c544f,0x4e4b534e,0x4e4b544e,0x4f4b544f,0x4f4c554f,0x504d5650,0x524e5952,0x54505b54,0x56515e56,0x58536158,0x5b55655b,0x5e58695e,0x625b6e62,0x665f7366,0x6b63796b,0x70687f70,0x766d8776,0x7a718b7a,
-	0x7a718a7a,0x756d8575,0x6f687e6f,0x6a62776a,0x655e7165,0x605a6c60,0x5d57675d,0x5a55635a,0x57535f57,0x54505b54,0x524f5852,0x504d5650,0x4f4b534f,0x4d4b524d,0x4c4a514c,0x4c49504c,0x4c49504c,0x4c49514c,0x4d4a514d,0x4e4b534e,0x4f4c554f,0x514e5851,0x54505b54,0x56515e56,0x59546259,0x5c56665c,0x5f596b5f,0x645d7064,0x68617668,0x6e667d6e,0x746b8374,0x786e8878,
-	0x786f8778,0x736b8273,0x6d657b6d,0x67617467,0x635c6e63,0x5f59695f,0x5b56645b,0x58536058,0x55515c55,0x524f5952,0x504d5650,0x4e4b534e,0x4d4a514d,0x4b494f4b,0x4a484d4a,0x4a474d4a,0x4a474d4a,0x4a484e4a,0x4a494f4a,0x4c49504c,0x4d4b534d,0x4f4c554f,0x524e5852,0x54505c54,0x57526057,0x5a54645a,0x5d58685d,0x625b6d62,0x675f7467,0x6b647a6b,0x71698171,0x756d8675,
-	0x766d8576,0x71698071,0x6b64796b,0x655f7265,0x615b6c61,0x5d57675d,0x59546259,0x56515e56,0x534f5a53,0x514d5651,0x4e4b534e,0x4c49504c,0x4a484e4a,0x49474c49,0x48464a48,0x47464a47,0x47464b47,0x48464b48,0x48474c48,0x4a484e4a,0x4b49504b,0x4d4a534d,0x504c5650,0x524e5952,0x55515e55,0x58536258,0x5c56665c,0x605a6c60,0x655d7265,0x6a62776a,0x6f677e6f,0x736b8473,
-	0x746c8374,0x6f687e6f,0x69627669,0x645d7064,0x5f596a5f,0x5b56645b,0x57536057,0x54505b54,0x524e5852,0x4f4c544f,0x4c4a504c,0x4a484e4a,0x48464b48,0x47454947,0x46444846,0x45444745,0x45444745,0x46444846,0x46454946,0x48464b48,0x49474d49,0x4c49504c,0x4e4b544e,0x514d5751,0x53505c53,0x57525f57,0x5a55645a,0x5e586a5e,0x635c6f63,0x68607468,0x6e657c6e,0x726a8172,
-	0x726a8172,0x6e667c6e,0x68617568,0x625c6e62,0x5e58685e,0x5a54635a,0x56525e56,0x534f5953,0x504d5650,0x4d4b524d,0x4b494f4b,0x48474b48,0x47454947,0x46444746,0x45434645,0x44434644,0x44434544,0x44434644,0x45444745,0x46454946,0x48464b48,0x4a484e4a,0x4c49524c,0x4f4c554f,0x524f5952,0x56515d56,0x59546359,0x5d57685d,0x615b6d61,0x675f7367,0x6c647b6c,0x70687f70,
-	0x71698171,0x6c657a6c,0x67607367,0x615b6c61,0x5d57675d,0x59546159,0x55515c55,0x524e5852,0x4f4c544f,0x4c4a504c,0x49484d49,0x47464a47,0x45444845,0x44434544,0x43424443,0x43424443,0x43424443,0x43424443,0x44434644,0x45444745,0x47454a47,0x49474c49,0x4b484f4b,0x4e4b534e,0x514d5851,0x54505c54,0x58536158,0x5c56665c,0x615a6c61,0x655e7265,0x6b63796b,0x6f667e6f,
-	0x70687f70,0x6b64796b,0x665f7266,0x605a6c60,0x5c56655c,0x57536057,0x54505b54,0x504d5650,0x4e4b524e,0x4b494f4b,0x48474b48,0x46454846,0x44444644,0x43434443,0x42414342,0x42414242,0x42414342,0x42424342,0x43424443,0x44434644,0x46454846,0x47464b47,0x4a484e4a,0x4d4b524d,0x504d5650,0x534f5b53,0x57526057,0x5b56655b,0x60596b60,0x655d7165,0x6a62786a,0x6e657e6e,
-	0x6f687e6f,0x6b63786b,0x655e7165,0x60596a60,0x5b56655b,0x57525f57,0x534f5a53,0x504d5550,0x4d4a514d,0x4a484e4a,0x47464a47,0x45444745,0x44434544,0x42424342,0x41414241,0x41414141,0x42414242,0x42414242,0x42424342,0x43434543,0x45444745,0x47454a47,0x49474d49,0x4c49514c,0x4f4c554f,0x534f5a53,0x56525f56,0x5b55645b,0x5f596a5f,0x645d7064,0x69627769,0x6e657c6e,
-	0x6f677d6f,0x6a63776a,0x645e7064,0x5f59695f,0x5a55645a,0x56525e56,0x524f5952,0x4f4c544f,0x4c4a504c,0x49484d49,0x47454947,0x45444645,0x43424443,0x42414242,0x41414141,0x40414140,0x41414141,0x41414141,0x42424242,0x43424443,0x44434644,0x46454946,0x49474c49,0x4b49504b,0x4f4c544f,0x524e5952,0x56515e56,0x5a55635a,0x5f58695f,0x635c6f63,0x68617668,0x6d647b6d,
-	0x6e677d6e,0x6a63776a,0x645d6f64,0x5f59695f,0x5a55645a,0x56515e56,0x524f5952,0x4f4c544f,0x4b4a4f4b,0x49474c49,0x46454946,0x44444644,0x43424343,0x41414241,0x41414141,0x40404040,0x40404140,0x41404141,0x42414242,0x43424343,0x44434644,0x46454846,0x48464c48,0x4b49504b,0x4e4b544e,0x524e5952,0x55515e55,0x5a54635a,0x5e58695e,0x635c6f63,0x68607568,0x6c647b6c,
-	0x6e677d6e,0x6a63776a,0x645d6f64,0x5f59695f,0x5a55635a,0x56525e56,0x524e5852,0x4e4c544e,0x4b4a4f4b,0x49474b49,0x46454846,0x44444644,0x43424343,0x41414241,0x41404141,0x40404040,0x40404040,0x41414141,0x41414141,0x42424342,0x44434544,0x46444846,0x48464c48,0x4b484f4b,0x4e4b544e,0x524e5952,0x55515e55,0x59546359,0x5e58685e,0x635c6e63,0x68607568,0x6c647b6c,
-	0x6e667c6e,0x6a62776a,0x645d7064,0x5e59695e,0x5a55635a,0x56525e56,0x524f5952,0x4e4c544e,0x4b4a504b,0x48474b48,0x46454846,0x44444644,0x43424343,0x41414241,0x41404141,0x40404040,0x40404140,0x40404140,0x41414241,0x42424442,0x44434644,0x46444846,0x48464b48,0x4b49504b,0x4e4b544e,0x524e5952,0x55515e55,0x59546359,0x5e58695e,0x635c6f63,0x68607668,0x6c647b6c,
-	0x6e677d6e,0x6a63786a,0x645e7064,0x5f59695f,0x5a55645a,0x56525e56,0x524f5952,0x4f4c544f,0x4b4a504b,0x49484c49,0x46454946,0x44444644,0x43424443,0x42414242,0x41404141,0x40404140,0x40404140,0x41414141,0x42414242,0x43424443,0x44434644,0x46444846,0x49474c49,0x4b49504b,0x4e4b544e,0x524e5952,0x55515e55,0x5a54645a,0x5e57695e,0x635c7063,0x68607668,0x6d647c6d,
-	0x6f677e6f,0x6b64786b,0x645f7164,0x5f5a6a5f,0x5b56655b,0x57525f57,0x534f5a53,0x4f4d554f,0x4c4a514c,0x4a484d4a,0x47464947,0x45444745,0x43434543,0x42424342,0x41414241,0x41414141,0x41404141,0x41414241,0x42424342,0x43424443,0x45434745,0x46454946,0x49474d49,0x4c49514c,0x4f4c564f,0x534e5a53,0x56525f56,0x5a55655a,0x5e58695e,0x635c7063,0x69617769,0x6d657c6d,
-	0x70697f70,0x6b64796b,0x665f7266,0x605a6c60,0x5b56655b,0x57536057,0x53505b53,0x504d5650,0x4d4b524d,0x4a494e4a,0x48464b48,0x46454846,0x44444644,0x43434443,0x42424342,0x41414241,0x42414242,0x42414342,0x43424443,0x44434644,0x45444845,0x47464a47,0x4a484e4a,0x4d4a524d,0x504c5650,0x534f5b53,0x57526057,0x5b55655b,0x5f596b5f,0x645d7164,0x6a61786a,0x6e657c6e,
-	0x71698071,0x6d657a6d,0x66607366,0x615c6c61,0x5c57665c,0x58546158,0x54515c54,0x514e5751,0x4e4b534e,0x4b49504b,0x49474c49,0x46454946,0x45444745,0x44434544,0x43424443,0x43424343,0x42424342,0x43424443,0x44434544,0x45444745,0x46454946,0x48474c48,0x4b494f4b,0x4e4b534e,0x514d5751,0x544f5c54,0x58526158,0x5b56665b,0x60596c60,0x655d7265,0x6a62796a,0x6f667f6f,
-	0x726b8272,0x6d667c6d,0x68617468,0x625c6d62,0x5e58685e,0x59556359,0x56525e56,0x524f5952,0x4f4c554f,0x4c4a514c,0x4a484e4a,0x48464b48,0x46454946,0x45444745,0x44434644,0x44434544,0x44434544,0x44434644,0x45444645,0x46454846,0x47464b47,0x49484e49,0x4c49514c,0x4f4b554f,0x524e5952,0x55505e55,0x58536258,0x5d56675d,0x615a6d61,0x665e7366,0x6b647a6b,0x70678070,
-	0x746c8374,0x6f687d6f,0x69627669,0x645e7064,0x5f5a6a5f,0x5a56645a,0x57536057,0x53505b53,0x504e5750,0x4e4c534e,0x4b494f4b,0x49484d49,0x47464b47,0x46454946,0x45444845,0x45444745,0x45444745,0x45444845,0x46454946,0x47464a47,0x49474d49,0x4b49504b,0x4d4b534d,0x504d5650,0x534f5b53,0x56516056,0x5a54645a,0x5e57695e,0x625b6f62,0x67607567,0x6d657c6d,0x72698172,
-	0x766e8576,0x716a8071,0x6b64796b,0x665f7266,0x615b6c61,0x5c57675c,0x58546258,0x55515d55,0x524e5952,0x4f4d554f,0x4d4b524d,0x4b494f4b,0x49484d49,0x48474b48,0x47454a47,0x47454a47,0x46454a46,0x47464a47,0x48464b48,0x49484d49,0x4b484f4b,0x4d4a524d,0x4f4c554f,0x514e5951,0x54505d54,0x57526157,0x5b55665b,0x5f596b5f,0x645c7164,0x69617869,0x6f667f6f,0x736a8373,
-	0x77708877,0x736c8273,0x6d667b6d,0x67617467,0x625c6e62,0x5e59695e,0x5a55645a,0x56525f56,0x54505b54,0x514e5851,0x4f4c554f,0x4c4b524c,0x4b494f4b,0x4a484e4a,0x49474d49,0x49474c49,0x48474c48,0x49474d49,0x4a484e4a,0x4b494f4b,0x4d4a524d,0x4f4c554f,0x514d5851,0x534f5b53,0x56515f56,0x59546359,0x5d57685d,0x615a6d61,0x665e7366,0x6b637a6b,0x71688171,0x756c8575,
-	0x79718979,0x766e8576,0x6f687e6f,0x69637669,0x655e7165,0x5f5a6b5f,0x5c57665c,0x59546259,0x56525e56,0x534f5a53,0x514e5751,0x4e4c544e,0x4d4b524d,0x4c4a514c,0x4b494f4b,0x4b494f4b,0x4b494f4b,0x4b49504b,0x4c49514c,0x4d4b534d,0x4f4c554f,0x504d5750,0x524e5a52,0x55505e55,0x58536258,0x5b55665b,0x5f586b5f,0x635c7063,0x68607668,0x6d657c6d,0x736a8373,0x776e8877,
-	0x7c738c7c,0x78708878,0x716b8071,0x6b65796b,0x67607467,0x625c6e62,0x5e59695e,0x5b56655b,0x58536158,0x55515d55,0x534f5a53,0x514e5851,0x4f4c564f,0x4e4b544e,0x4d4b524d,0x4d4a524d,0x4d4a524d,0x4d4b534d,0x4e4b544e,0x4f4c554f,0x514d5751,0x524f5a52,0x55505d55,0x57526157,0x5a54645a,0x5d57695d,0x615a6d61,0x655e7365,0x6a62796a,0x6f677f6f,0x756c8575,0x79708a79,
-	0x7f768f7f,0x7a738a7a,0x746d8374,0x6e687d6e,0x69637769,0x655e7165,0x615b6c61,0x5d58685d,0x5a55645a,0x57536057,0x55515d55,0x53505b53,0x524e5852,0x504d5750,0x504d5650,0x4f4c554f,0x4f4c554f,0x504d5650,0x504d5750,0x524e5852,0x534f5a53,0x55505d55,0x56526056,0x59546359,0x5c56675c,0x60596b60,0x635c7063,0x68607668,0x6c657b6c,0x726a8272,0x786f8878,0x7c738d7c,
-	0x81799381,0x7d768d7d,0x77708677,0x716a8071,0x6c667a6c,0x67617467,0x635d6f63,0x605a6b60,0x5d58675d,0x5a55645a,0x58536058,0x56515e56,0x54505c54,0x534f5a53,0x524f5952,0x524e5952,0x524e5952,0x524e5a52,0x534f5b53,0x54505c54,0x56515e56,0x57526157,0x59546359,0x5c56665c,0x5f586a5f,0x625b6e62,0x665f7366,0x6b627a6b,0x6f677f6f,0x756c8675,0x7a718c7a,0x7e75907e,
-	0x847c9784,0x80789080,0x7a738a7a,0x746d8374,0x6f687e6f,0x6b64786b,0x66607366,0x625d6f62,0x605a6b60,0x5d57665d,0x5a55645a,0x58546258,0x57526057,0x56515e56,0x55505d55,0x55505d55,0x55505d55,0x55515d55,0x56515e56,0x57526057,0x58536158,0x5a54635a,0x5c56675c,0x5e586a5e,0x625b6e62,0x655d7265,0x69617769,0x6e667d6e,0x726a8372,0x776f8877,0x7d738f7d,0x81779381,
-	0x877e9987,0x827a9382,0x7d758d7d,0x776f8777,0x726a8272,0x6d667b6d,0x69627769,0x655e7265,0x625c6e62,0x5f596a5f,0x5c57665c,0x5a55655a,0x59546259,0x58536158,0x57526057,0x57526057,0x57525f57,0x57526057,0x58536158,0x59536359,0x5a54655a,0x5c56665c,0x5e58695e,0x605a6c60,0x635d7163,0x675f7567,0x6c637b6c,0x70687f70,0x756c8575,0x7a718b7a,0x7f76917f,0x837a9683
-};
-
-static int isp_param_lns_lut_720p[1024] = {
-	0x7f748f7f,0x7b718b7b,0x756c8475,0x70667e70,0x6b62796b,0x665e7266,0x625a6d62,0x5f58695f,0x5c55655c,0x59536259,0x57525f57,0x55505c55,0x534f5a53,0x524e5852,0x514d5751,0x514d5751,0x514d5751,0x514d5851,0x524d5952,0x534e5a53,0x544f5c54,0x56515f56,0x58526258,0x5b55655b,0x5e57695e,0x615a6d61,0x655d7265,0x69617769,0x6f647d6f,0x746a8374,0x796f8979,0x7e728e7e,
-	0x7e738e7e,0x796f8979,0x746a8374,0x6e657c6e,0x69617669,0x645d7164,0x61596c61,0x5d56685d,0x5b55645b,0x58526058,0x56515d56,0x544f5b54,0x524e5852,0x514d5751,0x504c5550,0x504c5550,0x4f4b554f,0x504c5650,0x504c5750,0x514d5851,0x534e5a53,0x55505d55,0x57516057,0x5a53635a,0x5d55675d,0x60586b60,0x645b7064,0x685f7568,0x6d637b6d,0x72688172,0x786e8878,0x7c718c7c,
-	0x7c718c7c,0x786e8778,0x72688072,0x6c637a6c,0x675f7367,0x635b6e63,0x5f58695f,0x5c55665c,0x59536259,0x56515e56,0x544f5a54,0x524d5852,0x504c5650,0x4f4b544f,0x4e4b534e,0x4e4a524e,0x4e4a524e,0x4e4a534e,0x4f4b544f,0x504c5550,0x514d5851,0x534e5b53,0x55505d55,0x58526158,0x5b54655b,0x5e57695e,0x625a6e62,0x665e7366,0x6b62796b,0x70677f70,0x766b8676,0x7a6f8b7a,
-	0x7b708a7b,0x766c8576,0x70677e70,0x6a62786a,0x655d7265,0x61596c61,0x5d56675d,0x5a54635a,0x57525f57,0x55505c55,0x524e5852,0x504c5650,0x4e4b534e,0x4d4a514d,0x4c49514c,0x4c49504c,0x4c49504c,0x4c49504c,0x4d4a514d,0x4e4b534e,0x504b5550,0x524d5852,0x544f5b54,0x57515f57,0x59536359,0x5c56675c,0x60596c60,0x655c7165,0x69607769,0x6f657d6f,0x746a8474,0x796e8879,
-	0x796f8979,0x746a8374,0x6f657c6f,0x69607669,0x645c7064,0x60596a60,0x5c55665c,0x58536158,0x56515d56,0x534e5953,0x504d5650,0x4f4b534f,0x4d4a514d,0x4b494f4b,0x4a484e4a,0x4a484d4a,0x4a474d4a,0x4a484e4a,0x4b484f4b,0x4c49514c,0x4e4b534e,0x504c5650,0x524e5952,0x55505d55,0x58526158,0x5b54655b,0x5f576a5f,0x635b6f63,0x675f7567,0x6d647b6d,0x73688273,0x776c8677,
-	0x786d8678,0x736a8173,0x6d647a6d,0x675f7467,0x635b6e63,0x5e58685e,0x5a54645a,0x57525f57,0x54505b54,0x524d5852,0x4f4c544f,0x4d4a514d,0x4b484f4b,0x4a474d4a,0x49474c49,0x48464b48,0x48464b48,0x49464c49,0x49474d49,0x4b484e4b,0x4c49514c,0x4e4b544e,0x514d5751,0x534f5b53,0x56515f56,0x59546459,0x5d57685d,0x625a6e62,0x665e7366,0x6c62796c,0x71678071,0x766b8576,
-	0x766c8576,0x72687f72,0x6b63796b,0x665e7266,0x615a6c61,0x5d56675d,0x59536259,0x56505d56,0x534f5953,0x504c5550,0x4e4a524e,0x4b494f4b,0x49474d49,0x48464b48,0x47454a47,0x47454947,0x46454946,0x47454a47,0x48464b48,0x49474d49,0x4b484f4b,0x4d4a524d,0x504c5550,0x524e5952,0x55505d55,0x58526258,0x5c56675c,0x60596c60,0x655d7165,0x6a61776a,0x70667e70,0x746a8374,
-	0x756b8375,0x70677e70,0x6a62776a,0x655d7065,0x60596a60,0x5c56655c,0x58526058,0x55505b55,0x524e5852,0x4f4b544f,0x4c4a514c,0x4a484e4a,0x48464b48,0x47454947,0x46454846,0x45444745,0x45444745,0x46444846,0x46454946,0x48464b48,0x4a474d4a,0x4c49504c,0x4e4b534e,0x514d5751,0x544f5b54,0x58526058,0x5b55655b,0x5f586a5f,0x645c7064,0x69607669,0x6e657c6e,0x73698273,
-	0x746a8374,0x6f667d6f,0x69617569,0x645c6f64,0x5f58695f,0x5b55645b,0x57525f57,0x534f5a53,0x514d5651,0x4e4b524e,0x4b494f4b,0x49474c49,0x47454a47,0x45444745,0x45434645,0x44434544,0x44434644,0x45434645,0x46444846,0x47454947,0x49474c49,0x4b484f4b,0x4d4a524d,0x504c5650,0x534f5a53,0x57515f57,0x5a54645a,0x5e57695e,0x635b6f63,0x685f7468,0x6d647b6d,0x72688072,
-	0x73698173,0x6e657c6e,0x68607568,0x635b6e63,0x5e58685e,0x5a54635a,0x56515e56,0x534e5953,0x4f4c554f,0x4d4a514d,0x4a484e4a,0x48464a48,0x46454846,0x45434645,0x44434544,0x43424443,0x43424443,0x44434544,0x45434645,0x46444846,0x48464a48,0x49474d49,0x4c49514c,0x4f4b554f,0x524e5952,0x56505e56,0x59546359,0x5d57685d,0x625a6d62,0x675f7467,0x6d637a6d,0x71678071,
-	0x72688072,0x6d647b6d,0x675f7367,0x625b6d62,0x5d57685d,0x59536259,0x55505d55,0x514e5851,0x4e4b544e,0x4c49504c,0x49474c49,0x47454947,0x45444745,0x44434544,0x43424443,0x42424342,0x43424443,0x43424443,0x44434544,0x45444745,0x47454a47,0x49474c49,0x4b49504b,0x4e4b534e,0x514d5851,0x55505d55,0x59536159,0x5d56675d,0x61596d61,0x665d7366,0x6c62796c,0x70667f70,
-	0x71677f71,0x6c647a6c,0x675f7367,0x615a6c61,0x5d56665d,0x58536158,0x544f5c54,0x514d5751,0x4e4b524e,0x4b494f4b,0x48464b48,0x46454846,0x44434644,0x43424443,0x42414342,0x42414242,0x42414342,0x42424342,0x43424443,0x44434644,0x46444846,0x48464b48,0x4a484f4a,0x4d4a524d,0x514c5751,0x544f5c54,0x58526158,0x5c55665c,0x61596c61,0x655d7265,0x6b61796b,0x6f657e6f,
-	0x70677e70,0x6c63796c,0x665e7266,0x605a6c60,0x5c56665c,0x58526058,0x544f5b54,0x504d5650,0x4d4a524d,0x4a484e4a,0x48464a48,0x45444745,0x44434544,0x42424342,0x41414241,0x41414241,0x41414241,0x42414242,0x42424342,0x44434544,0x45444745,0x47454a47,0x4a474e4a,0x4d49514d,0x504c5650,0x544f5b54,0x57526057,0x5b55655b,0x60586b60,0x655c7165,0x6a61776a,0x6f657e6f,
-	0x70677f70,0x6b63796b,0x655e7265,0x60596b60,0x5b55655b,0x57526057,0x534f5a53,0x504c5550,0x4c4a514c,0x49484d49,0x47454a47,0x45444645,0x43424443,0x42414242,0x41414141,0x41414141,0x41414141,0x41414141,0x42424342,0x43424443,0x45444645,0x47454a47,0x49474d49,0x4c49514c,0x4f4c564f,0x534e5a53,0x57515f57,0x5b55655b,0x5f586a5f,0x645c7064,0x6a60786a,0x6e647d6e,
-	0x6f667e6f,0x6b62786b,0x655d7165,0x5f596b5f,0x5b55655b,0x57525f57,0x534f5a53,0x4f4c544f,0x4c4a504c,0x49474d49,0x46454946,0x45434645,0x43424443,0x42414242,0x41404141,0x41404141,0x40404140,0x41414141,0x41414241,0x43424443,0x44434644,0x46454946,0x49474c49,0x4c49514c,0x4f4c554f,0x534e5a53,0x57515f57,0x5b54645b,0x5f586a5f,0x645c7064,0x69607769,0x6e647c6e,
-	0x6f667e6f,0x6b62786b,0x655d7165,0x5f596a5f,0x5b55655b,0x56515f56,0x534e5953,0x4f4b544f,0x4c49504c,0x49474c49,0x46454946,0x44434644,0x43424443,0x41414241,0x40404140,0x40404040,0x40404040,0x41414141,0x41414241,0x42424342,0x44434644,0x46454946,0x49474c49,0x4b49504b,0x4f4b554f,0x534e5a53,0x56515f56,0x5a54645a,0x5f586a5f,0x645c7064,0x69607669,0x6d647c6d,
-	0x6f667d6f,0x6a62786a,0x655d7165,0x5f596a5f,0x5b55645b,0x56515f56,0x524e5952,0x4f4b544f,0x4c49504c,0x49474c49,0x46454846,0x44434644,0x42424442,0x41414241,0x40404140,0x40404040,0x40404040,0x40404140,0x41414241,0x42424342,0x44434644,0x46444846,0x48464c48,0x4b48504b,0x4f4b544f,0x524e5a52,0x57515f57,0x5a54645a,0x5f58695f,0x645b7064,0x69607669,0x6d637c6d,
-	0x6f667e6f,0x6a62786a,0x655d7165,0x5f596a5f,0x5b55655b,0x56515f56,0x534e5953,0x4f4c544f,0x4b49504b,0x49474c49,0x46454946,0x44434644,0x42424342,0x41414241,0x40404140,0x40404040,0x40404040,0x40404140,0x41414241,0x42424342,0x44434644,0x46444846,0x48464c48,0x4b48504b,0x4f4b544f,0x524e5a52,0x56515f56,0x5a54645a,0x5f57695f,0x635b7063,0x69607669,0x6d637c6d,
-	0x6f667e6f,0x6b62786b,0x655d7165,0x60596a60,0x5b55655b,0x56515f56,0x534e5953,0x4f4c554f,0x4c49504c,0x49474c49,0x46454946,0x44434644,0x43424443,0x41414241,0x40404140,0x40404040,0x40404040,0x41404141,0x41414241,0x42424442,0x44434644,0x46444946,0x48464c48,0x4b49504b,0x4f4b544f,0x524e5952,0x56515f56,0x5a54655a,0x5f576a5f,0x645b7064,0x69607769,0x6d637c6d,
-	0x70667e70,0x6b62786b,0x655d7165,0x60596b60,0x5b55655b,0x57525f57,0x534f5a53,0x4f4c554f,0x4c49504c,0x49484d49,0x47454947,0x45444645,0x43424443,0x42414242,0x41404141,0x40404140,0x40404140,0x41414141,0x42414242,0x43424443,0x44434644,0x46454946,0x49474c49,0x4c49504c,0x4f4b554f,0x534e5a53,0x57515f57,0x5b54655b,0x5f586a5f,0x645b7064,0x69607769,0x6e647d6e,
-	0x70677f70,0x6b63796b,0x665e7266,0x60596b60,0x5c55665c,0x57526057,0x534f5a53,0x4f4c564f,0x4d4a514d,0x4a484e4a,0x47464a47,0x45444745,0x43434543,0x42414342,0x41414241,0x41414141,0x40404140,0x41414241,0x42414342,0x43424543,0x45434745,0x47454947,0x49474d49,0x4c49514c,0x504c5650,0x534e5b53,0x57516057,0x5b54655b,0x5f586b5f,0x645c7164,0x6a61786a,0x6e647d6e,
-	0x71677f71,0x6c637a6c,0x665f7366,0x615a6c61,0x5c56665c,0x58536058,0x54505b54,0x504d5750,0x4d4a524d,0x4a484e4a,0x48464b48,0x45444845,0x44434544,0x42424442,0x42414342,0x41414241,0x41414241,0x41414241,0x42424342,0x43434543,0x45444745,0x47454a47,0x4a474e4a,0x4d4a524d,0x504c5750,0x544f5b54,0x57526057,0x5c55665c,0x60586b60,0x655c7265,0x6a61786a,0x6f657e6f,
-	0x72688072,0x6d647b6d,0x675f7367,0x625b6d62,0x5d57675d,0x58536158,0x55505c55,0x514d5751,0x4e4b534e,0x4b494f4b,0x48474c48,0x46454946,0x44444644,0x43434543,0x42424342,0x42424342,0x42424342,0x42424342,0x43424443,0x44434644,0x46444846,0x48464b48,0x4b484f4b,0x4e4a534e,0x514d5851,0x544f5c54,0x58526158,0x5c55675c,0x60596c60,0x665d7366,0x6b627a6b,0x70657f70,
-	0x73688173,0x6e657b6e,0x68607468,0x625b6d62,0x5e58685e,0x59546259,0x55515d55,0x524e5852,0x4e4b544e,0x4c49504c,0x49474d49,0x47464a47,0x45444845,0x44434644,0x43434543,0x43424443,0x43424443,0x43424443,0x44434644,0x45444745,0x47454a47,0x49474d49,0x4b49504b,0x4e4b544e,0x524d5852,0x55505d55,0x59536259,0x5d56685d,0x61596d61,0x665e7466,0x6c637b6c,0x70667f70,
-	0x736a8273,0x6f667d6f,0x69617569,0x635c6f63,0x5f58695f,0x5a55645a,0x56515e56,0x534f5a53,0x4f4d554f,0x4d4a514d,0x4a484e4a,0x48474b48,0x46454946,0x45444745,0x44434644,0x44434544,0x44434544,0x44434644,0x45444745,0x46444946,0x48464b48,0x4a474e4a,0x4c4a514c,0x4f4b554f,0x524e5a52,0x56505e56,0x59536359,0x5d56685d,0x625a6e62,0x675e7567,0x6d637c6d,0x71678071,
-	0x746b8374,0x70677e70,0x6a62776a,0x645d7064,0x60596a60,0x5b55655b,0x57525f57,0x534f5b53,0x504d5750,0x4e4b534e,0x4b49504b,0x49474d49,0x47464a47,0x46444846,0x45444745,0x45444745,0x44444644,0x45444745,0x46444846,0x47464a47,0x49474c49,0x4b484f4b,0x4d4a534d,0x504c5750,0x534f5b53,0x57516057,0x5a54645a,0x5e576a5e,0x635b6f63,0x685f7568,0x6e647d6e,0x73688273,
-	0x766c8476,0x71687f71,0x6b63786b,0x655e7265,0x615a6c61,0x5c56665c,0x58536158,0x55505c55,0x514e5851,0x4f4c544f,0x4c4a514c,0x4a484e4a,0x48474c48,0x47464a47,0x46454946,0x46444846,0x46444846,0x46454946,0x47454a47,0x48474c48,0x4a484e4a,0x4c49514c,0x4f4b544f,0x514d5851,0x554f5d55,0x58526158,0x5b55665b,0x5f586b5f,0x645c7164,0x69607769,0x6f657e6f,0x74698374,
-	0x776d8677,0x72698172,0x6d647a6d,0x675f7367,0x625b6d62,0x5d57685d,0x59546359,0x56515e56,0x534f5a53,0x504d5650,0x4e4b534e,0x4b49504b,0x4a484e4a,0x48474c48,0x48464b48,0x47464a47,0x47454a47,0x47464a47,0x48474c48,0x4a474d4a,0x4b49504b,0x4d4a534d,0x504c5650,0x524e5952,0x55505e55,0x58536258,0x5c55675c,0x60596d60,0x655d7365,0x6b61796b,0x71668071,0x756a8475,
-	0x786e8878,0x746b8374,0x6e657c6e,0x68617568,0x635c6f63,0x5f58695f,0x5a55645a,0x57526057,0x54505c54,0x524e5852,0x4f4c554f,0x4d4a524d,0x4b484f4b,0x4a484e4a,0x49474c49,0x48474c48,0x48474c48,0x49474d49,0x4a474d4a,0x4b48504b,0x4d4a524d,0x4f4b544f,0x514d5851,0x544f5b54,0x57516057,0x5a53645a,0x5e56695e,0x625a6e62,0x665e7466,0x6c627b6c,0x72688172,0x766b8676,
-	0x7a70897a,0x756c8475,0x6f677d6f,0x6a62776a,0x655d7165,0x60596b60,0x5c56665c,0x58536258,0x56515e56,0x534f5a53,0x514d5751,0x4e4b544e,0x4d4a524d,0x4b49504b,0x4b484f4b,0x4a484e4a,0x4a484e4a,0x4b484f4b,0x4b49504b,0x4d4a524d,0x4e4b544e,0x504c5750,0x524e5a52,0x554f5d55,0x58526258,0x5b55665b,0x5f586a5f,0x635b7063,0x685f7568,0x6d647c6d,0x73698373,0x786d8878,
-	0x7c718c7c,0x776e8677,0x71698071,0x6c63796c,0x665f7366,0x625b6d62,0x5e57685e,0x5a55645a,0x57526057,0x55505c55,0x524e5952,0x504c5650,0x4e4b544e,0x4d4a524d,0x4c4a514c,0x4c49504c,0x4c49504c,0x4c49514c,0x4d4a524d,0x4e4b544e,0x504c5650,0x524d5952,0x544f5c54,0x57515f57,0x59536359,0x5d56685d,0x61596c61,0x655c7265,0x6a61786a,0x6f657e6f,0x756b8575,0x796e8a79,
-	0x7d738d7d,0x796f8879,0x736a8173,0x6d647a6d,0x67607467,0x635c6f63,0x5f586a5f,0x5b55655b,0x58536158,0x56515e56,0x534f5b53,0x514d5851,0x504c5650,0x4f4b544f,0x4e4a534e,0x4d4a524d,0x4d4a534d,0x4e4a534e,0x4f4b544f,0x4f4c554f,0x514d5851,0x534e5a53,0x55505e55,0x58526158,0x5b54655b,0x5e56695e,0x625a6e62,0x665e7466,0x6b627a6b,0x71678071,0x766c8676,0x7b6f8c7b
-};
-
-static int isp_param_lns_lut_960p[1024] = {
-	0x8a7f9a8a,0x857b9585,0x7f758f7f,0x7a71897a,0x756c8375,0x71677f71,0x6c647a6c,0x69617669,0x665e7266,0x635b6e63,0x615a6c61,0x5e58695e,0x5d56675d,0x5c56665c,0x5c55655c,0x5b55645b,0x5b55645b,0x5b55655b,0x5c55665c,0x5d56675d,0x5f58695f,0x60596b60,0x625b6e62,0x655d7165,0x68607568,0x6c637a6c,0x6f677e6f,0x746b8374,0x796f8979,0x7e748f7e,0x83799683,0x897d9c89,
-	0x887d9788,0x83799283,0x7e748c7e,0x786f8678,0x736a8073,0x6e667b6e,0x6a62766a,0x675f7267,0x635c6e63,0x615a6c61,0x5e58685e,0x5c57665c,0x5b55645b,0x5a54635a,0x59546259,0x59536159,0x59536159,0x59536259,0x5a54625a,0x5b55645b,0x5c56665c,0x5e57685e,0x60596b60,0x625b6e62,0x655e7265,0x69617669,0x6d657b6d,0x71698071,0x766e8676,0x7b728c7b,0x82779282,0x877c9987,
-	0x847a9384,0x80768f80,0x7a70887a,0x756c8375,0x70677d70,0x6b63776b,0x675f7267,0x645c6f64,0x605a6a60,0x5e57675e,0x5c56645c,0x5a54625a,0x58536058,0x57525f57,0x56515e56,0x56515d56,0x56515e56,0x56515e56,0x57525f57,0x58536058,0x59536259,0x5b55645b,0x5d57675d,0x5f596a5f,0x625c6e62,0x665e7366,0x6a62776a,0x6e667c6e,0x746b8274,0x79708879,0x7f758f7f,0x83799483,
-	0x82779082,0x7d748c7d,0x776e8577,0x72697f72,0x6d657a6d,0x68607468,0x645c6f64,0x615a6b61,0x5e58675e,0x5b56645b,0x59546159,0x57525f57,0x56515d56,0x55505b55,0x544f5a54,0x534f5a53,0x534f5a53,0x534f5a53,0x54505b54,0x55505d55,0x57525f57,0x58536158,0x5a54645a,0x5d56675d,0x60596b60,0x635c6f63,0x67607467,0x6c647a6c,0x71688071,0x766d8576,0x7c728b7c,0x80769180,
-	0x7f748e7f,0x7a71897a,0x746c8374,0x6f677d6f,0x6a62776a,0x665e7166,0x615b6c61,0x5e58685e,0x5c56655c,0x59536159,0x57525e57,0x55505c55,0x534f5a53,0x524e5852,0x514d5751,0x504d5650,0x504d5650,0x514d5751,0x514d5851,0x534e5953,0x544f5b54,0x56515e56,0x58536158,0x5a55645a,0x5d57685d,0x60596c60,0x645d7164,0x69617769,0x6e657d6e,0x736a8373,0x79708979,0x7d738e7d,
-	0x7c728c7c,0x786f8778,0x72698072,0x6c64796c,0x67607467,0x625c6e62,0x5f58695f,0x5c56655c,0x59546259,0x57525f57,0x54505b54,0x524e5852,0x514d5651,0x4f4c554f,0x4f4b544f,0x4e4b534e,0x4e4b534e,0x4e4b544e,0x4f4b554f,0x504d5650,0x524e5852,0x534f5b53,0x56515e56,0x58536258,0x5b55655b,0x5e58695e,0x625b6e62,0x665f7466,0x6b637a6b,0x71688071,0x776e8677,0x7b718c7b,
-	0x7a70897a,0x756d8475,0x6f677d6f,0x6a62766a,0x655e7165,0x615a6b61,0x5d57675d,0x5a54625a,0x57525f57,0x54505b54,0x524e5852,0x504d5650,0x4e4b534e,0x4d4a524d,0x4c49504c,0x4c49504c,0x4c49504c,0x4c49504c,0x4d4a514d,0x4e4b534e,0x504c5550,0x514d5851,0x544f5b54,0x56515e56,0x59536259,0x5c56675c,0x60596c60,0x645d7064,0x69617669,0x6f667d6f,0x756b8375,0x796f8979,
-	0x786f8778,0x736b8173,0x6d657b6d,0x68617468,0x635c6e63,0x5e58695e,0x5b55645b,0x58536058,0x55515c55,0x524f5852,0x504d5550,0x4e4b524e,0x4c49504c,0x4b494f4b,0x4a484d4a,0x49474d49,0x49474d49,0x4a474d4a,0x4a484e4a,0x4c49504c,0x4d4a524d,0x4f4c554f,0x524e5852,0x54505b54,0x57526057,0x5b55645b,0x5e58685e,0x625b6e62,0x675f7467,0x6d647a6d,0x72698172,0x776d8677,
-	0x766d8576,0x72698072,0x6b64786b,0x665f7266,0x615b6c61,0x5d57675d,0x59546259,0x56525e56,0x53505a53,0x514e5651,0x4e4b534e,0x4c4a504c,0x4a484e4a,0x49474c49,0x48464b48,0x47464a47,0x47464a47,0x47464a47,0x49464c49,0x4a484e4a,0x4c49504c,0x4d4b524d,0x504c5650,0x534f5a53,0x56515e56,0x59536259,0x5d57675d,0x615a6c61,0x655e7265,0x6b62786b,0x71687f71,0x756c8475,
-	0x746c8374,0x70687e70,0x6a63766a,0x655e7065,0x60596a60,0x5b56655b,0x58536058,0x54505b54,0x524e5852,0x4f4c544f,0x4c4a514c,0x4a484e4a,0x48474b48,0x47454947,0x46454846,0x46444746,0x46444846,0x46454846,0x47454947,0x48464b48,0x4a484e4a,0x4c49504c,0x4e4b544e,0x514d5751,0x54505b54,0x57536057,0x5b55655b,0x5f596a5f,0x645c7064,0x69617569,0x6f667d6f,0x746a8274,
-	0x736a8173,0x6e677c6e,0x68617568,0x635c6e63,0x5e58685e,0x5a55635a,0x56525e56,0x534f5a53,0x504d5650,0x4d4b524d,0x4b484f4b,0x49474b49,0x47454947,0x45444745,0x45444645,0x44434544,0x44434544,0x45434645,0x45444745,0x46454946,0x48464b48,0x4a484e4a,0x4d4a524d,0x504d5550,0x534f5a53,0x56515e56,0x5a54635a,0x5e58695e,0x625b6e62,0x68607468,0x6d657b6d,0x72698172,
-	0x71698071,0x6d657a6d,0x67607367,0x625b6d62,0x5d57675d,0x59546259,0x55515c55,0x524e5852,0x4f4c544f,0x4c4a504c,0x4a484d4a,0x47464a47,0x46444746,0x44434644,0x44424444,0x43424443,0x43424443,0x44424544,0x44434644,0x45444745,0x47454a47,0x49474c49,0x4c49504c,0x4e4b544e,0x514e5851,0x55515d55,0x59536259,0x5d57675d,0x615a6d61,0x675f7367,0x6c637a6c,0x71677f71,
-	0x70687e70,0x6c64796c,0x665f7266,0x615a6b61,0x5c56665c,0x58536158,0x54505b54,0x514d5751,0x4e4b534e,0x4b494f4b,0x48474b48,0x46454846,0x44434644,0x43424443,0x42424342,0x42414242,0x42414342,0x43424343,0x43424443,0x44434644,0x46454846,0x48464b48,0x4a484e4a,0x4d4a524d,0x504d5650,0x54505c54,0x58536058,0x5c56665c,0x605a6b60,0x655e7265,0x6b62786b,0x6f667e6f,
-	0x70677d70,0x6b63786b,0x655e7165,0x605a6b60,0x5b56655b,0x57525f57,0x534f5a53,0x504d5550,0x4d4a514d,0x4a484e4a,0x47464a47,0x45444745,0x44434544,0x42424342,0x41414241,0x41414141,0x41414141,0x42414242,0x42424342,0x44434544,0x45444745,0x47454a47,0x4a474d4a,0x4c4a514c,0x504c5650,0x534f5b53,0x57525f57,0x5b55655b,0x5f596a5f,0x645d7064,0x6a62776a,0x6f657d6f,
-	0x6f677c6f,0x6b62776b,0x655e7065,0x5f596a5f,0x5b55645b,0x56525f56,0x534f5953,0x4f4c554f,0x4c4a504c,0x49484d49,0x47454947,0x45444645,0x43424443,0x42414242,0x41414141,0x41404141,0x41414141,0x41414141,0x42414242,0x43424443,0x44434644,0x46454946,0x49474c49,0x4c49504c,0x4f4c554f,0x534f5a53,0x56525f56,0x5b55645b,0x5f586a5f,0x645d7064,0x69617669,0x6d657c6d,
-	0x6f667c6f,0x6a62776a,0x645d6f64,0x5f59695f,0x5b55635b,0x56525e56,0x524f5952,0x4f4c544f,0x4c4a504c,0x49474c49,0x46454946,0x44434644,0x43424443,0x41414241,0x40414140,0x40404040,0x40404040,0x41404141,0x42414242,0x43424343,0x44434644,0x46454846,0x48464c48,0x4b48504b,0x4f4b544f,0x524e5952,0x56515e56,0x5a55645a,0x5f58695f,0x645d6f64,0x69617669,0x6d647c6d,
-	0x6e667d6e,0x6a62776a,0x645d6f64,0x5f59695f,0x5a55645a,0x56525e56,0x524f5952,0x4e4c544e,0x4c4a504c,0x49474c49,0x46454846,0x44434644,0x43424343,0x41414241,0x40404040,0x40404040,0x40404040,0x41404141,0x41414241,0x42424342,0x44434544,0x46444846,0x48464c48,0x4b48504b,0x4f4b544f,0x524e5952,0x56515e56,0x5a54645a,0x5f58695f,0x645c6f64,0x69617669,0x6d647b6d,
-	0x6f667c6f,0x6a62776a,0x645d6f64,0x5f59695f,0x5a55645a,0x56525e56,0x524f5952,0x4f4c544f,0x4c49504c,0x49474c49,0x46454846,0x44444644,0x43424343,0x41414241,0x41404141,0x40404040,0x40404040,0x41404141,0x41414241,0x43424443,0x44434644,0x46444846,0x48464c48,0x4b49504b,0x4f4c544f,0x524e5952,0x56515e56,0x5a54645a,0x5f58695f,0x645c6f64,0x69617669,0x6d657c6d,
-	0x6f677c6f,0x6b63776b,0x655e7065,0x5f596a5f,0x5b55645b,0x56525e56,0x534f5953,0x4f4c544f,0x4c4a504c,0x49474c49,0x47454947,0x45444645,0x43424443,0x42414242,0x41404141,0x40404140,0x40404140,0x41414141,0x41414241,0x43424443,0x44434644,0x46444946,0x49474c49,0x4c49504c,0x4f4c554f,0x534e5a53,0x56515f56,0x5a54645a,0x5f586a5f,0x645c7064,0x69617769,0x6e657c6e,
-	0x70677d70,0x6b63786b,0x655e7165,0x605a6b60,0x5b56655b,0x57525f57,0x534f5a53,0x4f4c554f,0x4c4a514c,0x4a484e4a,0x47464a47,0x45444745,0x43434543,0x42424342,0x41414241,0x41414141,0x41414141,0x41414241,0x42424342,0x43424443,0x45444745,0x47454947,0x49474d49,0x4c4a514c,0x504c5650,0x534f5a53,0x57526057,0x5b55655b,0x5f596b5f,0x645d7064,0x6a62776a,0x6e657d6e,
-	0x71687f71,0x6c64796c,0x665f7266,0x615b6c61,0x5c57665c,0x58536058,0x54505b54,0x514d5751,0x4d4b524d,0x4b494f4b,0x48474b48,0x46454846,0x44434644,0x43424443,0x42424342,0x42414242,0x42414242,0x42414342,0x43424443,0x44434544,0x45444845,0x48464b48,0x4a484e4a,0x4d4a524d,0x504d5750,0x54505c54,0x58536158,0x5c56665c,0x60596b60,0x655e7265,0x6b62786b,0x6f667e6f,
-	0x72698072,0x6d667b6d,0x67607367,0x625c6d62,0x5d57675d,0x59546259,0x55515d55,0x514e5851,0x4e4c544e,0x4c4a504c,0x49484d49,0x47454a47,0x45444745,0x44434644,0x43434443,0x43424443,0x43424443,0x43424443,0x44434544,0x45444745,0x47454a47,0x49474d49,0x4c49504c,0x4e4b544e,0x524e5852,0x55505d55,0x58536258,0x5d56675d,0x615a6d61,0x665e7366,0x6c637a6c,0x70677f70,
-	0x746b8274,0x6f677c6f,0x69627569,0x635d6f63,0x5e59695e,0x5a55635a,0x56525f56,0x534f5a53,0x4f4d564f,0x4d4b524d,0x4a494e4a,0x48474c48,0x47454947,0x45444745,0x44444644,0x44434644,0x44434644,0x44444644,0x45444745,0x46454946,0x48464b48,0x4a484e4a,0x4d4a524d,0x4f4c554f,0x534f5a53,0x56515f56,0x5a54635a,0x5e58695e,0x625b6e62,0x67607567,0x6d657c6d,0x72688172,
-	0x756c8475,0x70687e70,0x6a63776a,0x655e7065,0x605a6b60,0x5b56655b,0x57536057,0x54505c54,0x514e5751,0x4e4c544e,0x4c4a504c,0x4a484d4a,0x48474b48,0x47464947,0x46454846,0x45454845,0x45444845,0x46454846,0x47454a47,0x48464b48,0x4a484e4a,0x4c49504c,0x4e4b544e,0x514d5751,0x54505c54,0x57526157,0x5b55655b,0x5f586b5f,0x645c7064,0x69617669,0x6f667e6f,0x736a8373,
-	0x766d8676,0x726a8072,0x6c65796c,0x675f7367,0x615b6c61,0x5d57675d,0x59546259,0x56525e56,0x524f5952,0x504d5650,0x4d4b524d,0x4b49504b,0x4a484e4a,0x48474c48,0x48464b48,0x47464a47,0x47464a47,0x48464a48,0x48474c48,0x4a484d4a,0x4b49504b,0x4d4b534d,0x504c5650,0x524e5a52,0x55515e55,0x58536258,0x5c56675c,0x605a6c60,0x655e7265,0x6a62796a,0x71678071,0x756b8475,
-	0x786f8878,0x746c8274,0x6e667b6e,0x68617468,0x635d6e63,0x5e59695e,0x5b56645b,0x57536057,0x54505c54,0x524f5852,0x4f4c554f,0x4d4b524d,0x4c49504c,0x4a484e4a,0x49484d49,0x49474d49,0x49474d49,0x49484d49,0x4b484e4b,0x4c49504c,0x4d4a524d,0x4f4c554f,0x514e5851,0x54505c54,0x57526057,0x5a54645a,0x5e57695e,0x625b6f62,0x675f7467,0x6d647b6d,0x72698272,0x766d8776,
-	0x7a718a7a,0x776d8577,0x70687e70,0x6a63776a,0x655f7165,0x615a6c61,0x5d57675d,0x59546259,0x56525f56,0x54505b54,0x514e5851,0x4f4c554f,0x4e4b534e,0x4d4a514d,0x4c49504c,0x4b49504b,0x4b49504b,0x4c49504c,0x4c4a514c,0x4e4b534e,0x4f4c554f,0x514d5851,0x534f5b53,0x56515e56,0x59536359,0x5c56675c,0x60596c60,0x645d7164,0x69617769,0x6e667e6e,0x746b8474,0x796f8a79,
-	0x7d738d7d,0x79708879,0x726b8172,0x6d657a6d,0x67617467,0x635d6e63,0x5f59695f,0x5c56655c,0x58536158,0x56515e56,0x54505b54,0x514e5851,0x504d5650,0x4f4c544f,0x4e4b534e,0x4e4b534e,0x4d4b534d,0x4e4b534e,0x4f4c544f,0x504d5650,0x514e5851,0x534f5b53,0x55515e55,0x58526158,0x5b55655b,0x5e58695e,0x625b6f62,0x665e7466,0x6b637a6b,0x71688071,0x776d8777,0x7b718b7b,
-	0x7f768f7f,0x7b728b7b,0x756d8375,0x6f687d6f,0x6a63776a,0x655f7265,0x615b6c61,0x5e58685e,0x5b55645b,0x58536158,0x56515e56,0x54505b54,0x524e5952,0x514e5851,0x504d5750,0x504d5650,0x504d5650,0x514d5751,0x514d5851,0x524e5952,0x544f5c54,0x56515e56,0x57526157,0x5a54645a,0x5d57685d,0x615a6d61,0x645d7264,0x69617769,0x6e667d6e,0x746a8374,0x796f8979,0x7d728e7d,
-	0x82799282,0x7e748d7e,0x78708778,0x736a8173,0x6d667a6d,0x68617468,0x645e7064,0x605a6b60,0x5e58685e,0x5b55645b,0x58536158,0x56525f56,0x55505c55,0x54505b54,0x534f5a53,0x534f5a53,0x534f5a53,0x534f5a53,0x54505c54,0x55505d55,0x56515f56,0x58536158,0x5a54645a,0x5d56675d,0x60596c60,0x645c7064,0x67607567,0x6c647a6c,0x71688071,0x766d8676,0x7b718c7b,0x7f75907f,
-	0x857c9585,0x81789181,0x7b728a7b,0x766e8476,0x70697d70,0x6b64786b,0x67607467,0x635d6f63,0x605a6b60,0x5d57685d,0x5b55645b,0x59546259,0x57526057,0x56515f56,0x56515e56,0x55515d55,0x55515e55,0x55515e55,0x56515f56,0x57526057,0x59536259,0x5b55655b,0x5d57675d,0x5f596b5f,0x635b6e63,0x665f7366,0x6b63786b,0x6f677e6f,0x746b8374,0x796f8979,0x7e738e7e,0x80769280,
-	0x887e9888,0x837a9383,0x7d758d7d,0x786f8678,0x726a8172,0x6d667b6d,0x69627669,0x655f7265,0x635c6f63,0x5f596a5f,0x5d57675d,0x5b55655b,0x59546359,0x58536258,0x58536158,0x58526058,0x58526058,0x58536158,0x58536258,0x59546359,0x5b55655b,0x5d57675d,0x5f586a5f,0x615b6e61,0x655d7265,0x69617669,0x6d657b6d,0x71698071,0x766d8676,0x7b718b7b,0x7f75907f,0x81769381
-};
-
-static int isp_param_lns_lut_1080p[1024] = {
-	0x635c6d63,0x605b6b60,0x5d57675d,0x5b55645b,0x59546159,0x57525e57,0x55515c55,0x534f5953,0x514e5651,0x4f4c544f,0x4e4b524e,0x4d4a514d,0x4c494f4c,0x4b484e4b,0x4a484d4a,0x4a484d4a,0x4a484d4a,0x4a484d4a,0x4a484e4a,0x4b494f4b,0x4c4a504c,0x4d4a524d,0x4f4c534f,0x504d5550,0x524f5852,0x54505b54,0x56515d56,0x58536058,0x5a55645a,0x5d57675d,0x60596a60,0x625c6d62,
-	0x625c6d62,0x605a6960,0x5d57665d,0x5a55635a,0x58535f58,0x56525d56,0x54505a54,0x524f5852,0x504d5550,0x4f4c534f,0x4d4a514d,0x4c494f4c,0x4b494e4b,0x4a484d4a,0x49474c49,0x49474c49,0x49474c49,0x49474c49,0x4a484d4a,0x4a484e4a,0x4b494f4b,0x4c4a514c,0x4e4b534e,0x4f4c544f,0x514d5751,0x534f5953,0x55515c55,0x57525f57,0x5a54625a,0x5c57665c,0x5f59695f,0x615b6c61,
-	0x615b6b61,0x5e59685e,0x5c56655c,0x59546259,0x57525f57,0x55515c55,0x534f5953,0x514e5751,0x4f4c544f,0x4e4b524e,0x4c4a504c,0x4b484e4b,0x49474d49,0x49474c49,0x48464b48,0x48464a48,0x48464a48,0x48464b48,0x48474b48,0x49474c49,0x4a484d4a,0x4b494f4b,0x4d4a514d,0x4e4b534e,0x504d5650,0x524e5852,0x54505b54,0x56525e56,0x59546159,0x5b56655b,0x5e58685e,0x605a6b60,
-	0x605a6a60,0x5e58685e,0x5b55645b,0x58536058,0x56515d56,0x54505a54,0x524e5752,0x504d5550,0x4e4b534e,0x4c4a504c,0x4b494e4b,0x49474d49,0x48474b48,0x48464a48,0x47454947,0x47454947,0x47454947,0x47454947,0x47464a47,0x48464b48,0x49474c49,0x4a484e4a,0x4c49504c,0x4d4a524d,0x4f4c544f,0x514d5751,0x534f5a53,0x55515d55,0x58536058,0x5a55635a,0x5d57675d,0x60596a60,
-	0x5f59695f,0x5c57665c,0x5a55635a,0x57535e57,0x55515c55,0x534f5953,0x514e5751,0x4f4c534f,0x4d4a514d,0x4b494f4b,0x4a484d4a,0x48474b48,0x48464a48,0x47454947,0x46454846,0x46444746,0x45444845,0x45444845,0x46454846,0x47454947,0x48464b48,0x49474c49,0x4b484e4b,0x4c4a504c,0x4e4b534e,0x504d5550,0x524e5852,0x54505c54,0x57525f57,0x5a54625a,0x5d57665d,0x5f59685f,
-	0x5e58695e,0x5c56655c,0x59546159,0x57525e57,0x54505b54,0x524e5852,0x504d5550,0x4e4b524e,0x4c4a504c,0x4a484e4a,0x49474c49,0x48464a48,0x46454946,0x46444746,0x45444745,0x45434645,0x45434645,0x45434745,0x45444745,0x46454946,0x47464a47,0x48464b48,0x4a474d4a,0x4b494f4b,0x4d4a524d,0x4f4c554f,0x514e5851,0x54505a54,0x56515e56,0x59546159,0x5c56655c,0x5e58685e,
-	0x5e58675e,0x5c56655c,0x59546159,0x55525d55,0x53505a53,0x524e5752,0x504c5550,0x4d4b524d,0x4b494f4b,0x4a484d4a,0x48464b48,0x47454947,0x46444846,0x45444745,0x44434644,0x44434544,0x44434544,0x44434644,0x45434745,0x45444745,0x46454946,0x48464a48,0x49474c49,0x4b484f4b,0x4c49514c,0x4e4b544e,0x504d5750,0x534f5a53,0x56515d56,0x58536158,0x5b56645b,0x5d58675d,
-	0x5d57675d,0x5b55635b,0x58536058,0x55515c55,0x534f5953,0x514d5651,0x4f4c544f,0x4c4a514c,0x4a494e4a,0x49474b49,0x47464a47,0x46444846,0x45444645,0x44434544,0x44434544,0x43424443,0x43424443,0x44434544,0x44434644,0x45444745,0x46444846,0x47464947,0x48464b48,0x4a474e4a,0x4c49504c,0x4e4b534e,0x504d5550,0x524e5952,0x55515c55,0x58536058,0x5b55645b,0x5c57665c,
-	0x5d57665d,0x5a55635a,0x57535f57,0x54505b54,0x524e5852,0x504d5550,0x4e4b534e,0x4c49504c,0x4a484d4a,0x48464b48,0x46454946,0x45444745,0x44434544,0x43434443,0x43424443,0x42424342,0x43424343,0x43424443,0x43424543,0x44434544,0x45434745,0x46454846,0x47464a47,0x49474c49,0x4b494f4b,0x4d4a524d,0x4f4c554f,0x514e5851,0x54505b54,0x57525f57,0x5a54635a,0x5c56655c,
-	0x5c56655c,0x59546259,0x57525f57,0x54505b54,0x514e5751,0x4f4c554f,0x4d4b524d,0x4b494f4b,0x49474c49,0x48464a48,0x46444846,0x45444645,0x44434544,0x43424443,0x42414342,0x42414342,0x42424342,0x43424343,0x43424443,0x44434544,0x44434644,0x45444745,0x47464a47,0x48474c48,0x4a484e4a,0x4c4a514c,0x4e4b544e,0x514e5751,0x544f5b54,0x56525e56,0x59546259,0x5b56655b,
-	0x5b56655b,0x59546259,0x56525e56,0x53505b53,0x514e5751,0x4f4c544f,0x4d4b514d,0x4a494e4a,0x48474c48,0x47454947,0x45444745,0x44434544,0x43424443,0x42424342,0x42414242,0x42414242,0x42414242,0x42414342,0x42424342,0x43424443,0x44434544,0x45444745,0x46454946,0x48464b48,0x4a474d4a,0x4c49504c,0x4e4b534e,0x504d5650,0x534f5a53,0x56515d56,0x59546159,0x5b55645b,
-	0x5b56645b,0x59546159,0x56515d56,0x534f5a53,0x504e5650,0x4f4c544f,0x4d4a504d,0x4a484e4a,0x48474b48,0x46454846,0x45444745,0x44434544,0x43424443,0x42414342,0x41414241,0x41414241,0x41414241,0x42414242,0x42414342,0x43424343,0x43434543,0x45434645,0x46454846,0x48464a48,0x4a474d4a,0x4b49504b,0x4e4b524e,0x504d5650,0x534f5a53,0x56515d56,0x58536158,0x5b55645b,
-	0x5a55645a,0x58536158,0x55515d55,0x534f5953,0x504d5650,0x4e4b534e,0x4c4a504c,0x4a484d4a,0x48464a48,0x46454846,0x44434644,0x43424443,0x42424342,0x42414242,0x41414241,0x41414141,0x41414141,0x41414241,0x41414241,0x42424342,0x43424443,0x44434644,0x45444845,0x47464a47,0x49474c49,0x4b494f4b,0x4d4b524d,0x504c5550,0x524e5952,0x55515d55,0x58536058,0x5a55635a,
-	0x5a55645a,0x58536158,0x55515c55,0x534f5853,0x504d5650,0x4e4b524e,0x4b4a4f4b,0x49474d49,0x47464a47,0x46454746,0x44434544,0x43424443,0x42424342,0x41414241,0x41404141,0x41414141,0x41404141,0x41414141,0x41414241,0x42424342,0x43424443,0x44434644,0x45444745,0x47454a47,0x48474c48,0x4a484e4a,0x4d4a524d,0x504c5550,0x524e5952,0x55505c55,0x58536158,0x5a55635a,
-	0x5a55635a,0x58536058,0x55515c55,0x524f5852,0x504d5550,0x4d4b524d,0x4b494f4b,0x49474c49,0x47464947,0x46444746,0x44434544,0x43424343,0x42414242,0x41414141,0x41404141,0x40404140,0x41404141,0x41414141,0x41414241,0x42414242,0x43424343,0x44434544,0x45444745,0x47454947,0x48464c48,0x4a484f4a,0x4d4a514d,0x4f4c554f,0x524e5852,0x55505c55,0x58536058,0x5a54635a,
-	0x5a55635a,0x58536058,0x55515c55,0x524f5852,0x4f4d554f,0x4d4b514d,0x4b494f4b,0x49484c49,0x47464947,0x45444745,0x44434544,0x43424343,0x42414242,0x41414141,0x41404141,0x41404141,0x40404040,0x41404141,0x41414141,0x42414242,0x42424342,0x44424544,0x45444745,0x47454947,0x48464b48,0x4a484e4a,0x4c4a524c,0x4f4c554f,0x524e5852,0x55505c55,0x57526057,0x5a54625a,
-	0x5a55635a,0x58536058,0x55515c55,0x524f5852,0x4f4c554f,0x4d4b514d,0x4b494f4b,0x49474c49,0x47464947,0x45444745,0x44434544,0x42424342,0x41414241,0x41414141,0x40404040,0x40404040,0x40404040,0x41414141,0x41414141,0x41414241,0x42424342,0x43434543,0x45444745,0x46454946,0x48464b48,0x4a484e4a,0x4c4a514c,0x4f4c544f,0x524e5852,0x54505c54,0x57526057,0x5a55635a,
-	0x5a55635a,0x58536058,0x55515c55,0x524f5952,0x504c5550,0x4d4b524d,0x4b494f4b,0x49474c49,0x47464947,0x45444745,0x44434544,0x42424342,0x41414241,0x41414141,0x41414141,0x40404040,0x40404040,0x41404141,0x41414241,0x42414242,0x42424342,0x43424543,0x45434745,0x46454946,0x48464b48,0x4a484e4a,0x4c4a514c,0x4f4c554f,0x524e5852,0x54505c54,0x58526058,0x5a54635a,
-	0x5a55635a,0x58536058,0x55515c55,0x524f5852,0x4f4c554f,0x4d4b524d,0x4b494f4b,0x49474c49,0x47464947,0x45444745,0x44434544,0x42424342,0x42414242,0x41414141,0x40404040,0x40404140,0x40404040,0x40404140,0x41414141,0x41414241,0x42424342,0x43424543,0x45434745,0x46454846,0x48464b48,0x4a484e4a,0x4c4a514c,0x4f4c554f,0x524e5852,0x54505c54,0x57526057,0x5a54635a,
-	0x5a55635a,0x58536058,0x55515c55,0x524f5952,0x504d5550,0x4d4b524d,0x4b494f4b,0x49474c49,0x47464a47,0x45444745,0x44434544,0x43424343,0x42414242,0x41414141,0x41404141,0x40404140,0x40404140,0x41414141,0x41414241,0x41414241,0x42424342,0x43434543,0x45434745,0x46454946,0x48464b48,0x4a484e4a,0x4c4a524c,0x4f4c554f,0x524e5852,0x55505c55,0x57526057,0x5a54635a,
-	0x5b55635b,0x58536058,0x55515c55,0x524f5952,0x504d5550,0x4d4b524d,0x4b494f4b,0x49484d49,0x47464a47,0x45454845,0x44434544,0x43424443,0x42424242,0x41414241,0x41414141,0x40404140,0x40414140,0x41414141,0x41414241,0x42424342,0x43424443,0x44434544,0x45444745,0x46454946,0x48474c48,0x4b484e4b,0x4d4a524d,0x4f4c554f,0x524e5952,0x55505d55,0x58536058,0x5a55635a,
-	0x5b56645b,0x59546159,0x55515c55,0x534f5953,0x504d5650,0x4e4b534e,0x4c4a504c,0x4a484d4a,0x48464a48,0x46454846,0x44444644,0x43424443,0x42424342,0x41414241,0x41414141,0x40404140,0x41414141,0x41414141,0x41414241,0x42414342,0x43424443,0x44434544,0x45444745,0x47454947,0x49474c49,0x4b494f4b,0x4d4a524d,0x504c5650,0x524e5952,0x55515d55,0x58536158,0x5a55645a,
-	0x5b56645b,0x59546159,0x55525d55,0x534f5953,0x504d5650,0x4e4b534e,0x4c4a504c,0x4a484d4a,0x48464b48,0x46454846,0x45444645,0x43434543,0x42424342,0x42414242,0x41414241,0x41414141,0x41414241,0x41414241,0x42414242,0x42414342,0x43424543,0x44434644,0x45444845,0x47464b47,0x49474c49,0x4b494f4b,0x4e4b534e,0x504c5650,0x524f5952,0x55515d55,0x58536158,0x5b55645b,
-	0x5b56645b,0x59546259,0x56525e56,0x53505a53,0x514e5751,0x4f4c544f,0x4d4a514d,0x4a484e4a,0x48474b48,0x47464947,0x45444845,0x44434544,0x43424443,0x42424342,0x42414242,0x41414241,0x41414241,0x41414241,0x42414342,0x42424442,0x43424543,0x44434644,0x46454846,0x48464a48,0x4a474e4a,0x4c49504c,0x4e4b534e,0x504d5650,0x534f5a53,0x56515d56,0x58536158,0x5b55645b,
-	0x5c57655c,0x59556359,0x57525e57,0x54505b54,0x514e5751,0x4f4c544f,0x4d4a524d,0x4b494f4b,0x49474c49,0x47464a47,0x46454846,0x44444644,0x43434543,0x43424443,0x42424342,0x42414342,0x42414342,0x42424342,0x43424443,0x43424543,0x44434644,0x45444745,0x47454947,0x48464b48,0x4a484e4a,0x4c49514c,0x4e4b544e,0x514d5751,0x534f5b53,0x56515e56,0x59546259,0x5b56655b,
-	0x5d57675d,0x5a55635a,0x57535f57,0x54515b54,0x524e5852,0x504d5550,0x4d4b524d,0x4b494f4b,0x49484d49,0x48464b48,0x47454947,0x45444745,0x44434644,0x43434443,0x43424443,0x42424342,0x42424442,0x43424443,0x43424443,0x44434544,0x45434645,0x46444846,0x47464a47,0x49474c49,0x4b484f4b,0x4d4a524d,0x4f4c554f,0x514d5851,0x54505c54,0x57525f57,0x59546359,0x5c56665c,
-	0x5d58675d,0x5a56645a,0x58536058,0x55515c55,0x524f5952,0x504d5650,0x4e4b534e,0x4c4a504c,0x4a484e4a,0x48474c48,0x47464947,0x45454845,0x44444644,0x44434544,0x43434543,0x43434443,0x43424443,0x43424543,0x44434544,0x44434644,0x45444745,0x46454946,0x48464b48,0x49484d49,0x4b49504b,0x4d4a534d,0x4f4c564f,0x524e5952,0x54505c54,0x57526057,0x5a55645a,0x5c56665c,
-	0x5e58675e,0x5b56655b,0x58546158,0x56525d56,0x53505a53,0x514e5751,0x4e4c544e,0x4d4a514d,0x4b494f4b,0x49474d49,0x48464b48,0x46454946,0x45444845,0x45444745,0x44434644,0x44434544,0x44434544,0x44434644,0x44434644,0x45444745,0x46454846,0x47464a47,0x49474c49,0x4a484e4a,0x4c49514c,0x4e4b544e,0x504d5750,0x534e5a53,0x55515d55,0x58536158,0x5b55645b,0x5d57675d,
-	0x5f59685f,0x5c57665c,0x59546259,0x56525e56,0x54505b54,0x514e5851,0x4f4d554f,0x4d4b524d,0x4b49504b,0x4a484d4a,0x48474c48,0x47464a47,0x46454946,0x45444845,0x44444744,0x44444644,0x44444644,0x45444745,0x45444745,0x46454846,0x47464a47,0x48464b48,0x49474d49,0x4b484f4b,0x4d4a514d,0x4f4c544f,0x514d5751,0x534f5b53,0x55515e55,0x58536158,0x5b56655b,0x5d57685d,
-	0x5f5a695f,0x5d57675d,0x5a55625a,0x57535f57,0x55515c55,0x524f5952,0x504d5650,0x4e4c534e,0x4c4a514c,0x4b494f4b,0x49484d49,0x48474b48,0x47464a47,0x46454946,0x45454845,0x45444845,0x45454845,0x45454845,0x46454846,0x47464947,0x48464b48,0x49474c49,0x4a484f4a,0x4c49514c,0x4e4b534e,0x504c5650,0x524e5952,0x54505c54,0x56525f56,0x59546259,0x5c56665c,0x5f58695f,
-	0x605a6b60,0x5e58685e,0x5a56645a,0x58536058,0x55515d55,0x53505a53,0x514e5751,0x4f4c544f,0x4d4b524d,0x4b4a504b,0x4a494e4a,0x49474c49,0x48464b48,0x47464a47,0x47464947,0x46454946,0x46454946,0x47454947,0x47464a47,0x48464b48,0x49474c49,0x4a484e4a,0x4b49504b,0x4d4a524d,0x4e4c544e,0x514d5751,0x534f5a53,0x55515d55,0x57526057,0x5a54635a,0x5d57675d,0x5f596a5f,
-	0x615b6c61,0x5e59685e,0x5b56645b,0x59546159,0x56525e56,0x54505b54,0x524f5952,0x504d5650,0x4e4c534e,0x4c4a514c,0x4b494f4b,0x4a484d4a,0x49474c49,0x48474b48,0x47464b47,0x47464b47,0x47464a47,0x47464a47,0x48464b48,0x48474c48,0x4a484d4a,0x4b484f4b,0x4c49514c,0x4e4b534e,0x4f4c554f,0x514e5751,0x534f5a53,0x55515d55,0x58536058,0x5a55645a,0x5d57685d,0x60596b60
-};
-
-static int isp_param_lns_lut_5m[1024] = {
-	0x8d809d8d,0x867c9786,0x81769081,0x7b728a7b,0x776d8577,0x72698072,0x6e657b6e,0x6a62776a,0x675f7467,0x645c7064,0x625a6d62,0x60586a60,0x5e57695e,0x5d56675d,0x5d56665d,0x5c55665c,0x5c55665c,0x5c55665c,0x5d56675d,0x5e57685e,0x5f586a5f,0x615a6c61,0x635b6f63,0x665e7366,0x69617669,0x6d647a6d,0x70687f70,0x756c8475,0x79708979,0x7f758e7f,0x857a9685,0x8a7e9c8a,
-	0x897e9989,0x857a9385,0x7f758d7f,0x7a70877a,0x746b8274,0x70677c70,0x6b63786b,0x68607468,0x655e7065,0x625b6d62,0x60596a60,0x5e57685e,0x5c56655c,0x5b55645b,0x5a54635a,0x5a54625a,0x5a54635a,0x5a54635a,0x5b55645b,0x5c56655c,0x5d57675d,0x5f58695f,0x615a6b61,0x635c6f63,0x675f7267,0x6a62776a,0x6e667c6e,0x736a8173,0x786e8678,0x7d738b7d,0x82789282,0x887d9888,
-	0x867b9586,0x81789081,0x7c73897c,0x766d8376,0x72687e72,0x6c64796c,0x68607468,0x655e6f65,0x625b6c62,0x5f59685f,0x5d57665d,0x5b55635b,0x5a54625a,0x58536058,0x57525f57,0x57525e57,0x57525f57,0x57525f57,0x58536058,0x59536159,0x5a54635a,0x5c56655c,0x5e57685e,0x615a6b61,0x635c6f63,0x675f7367,0x6b63776b,0x70677d70,0x756c8275,0x79708879,0x7f758e7f,0x83799483,
-	0x83799283,0x7e758c7e,0x79708679,0x736b8073,0x6e667b6e,0x69617569,0x655e7065,0x625b6c62,0x5f59685f,0x5c56655c,0x5a55625a,0x58536058,0x57525e57,0x56515c56,0x55505b55,0x54505b54,0x54505b54,0x55505b55,0x55505c55,0x56515d56,0x57536057,0x59546259,0x5b55645b,0x5e57685e,0x615a6b61,0x645d6f64,0x68607468,0x6d64796d,0x72697f72,0x776e8577,0x7c738b7c,0x81779081,
-	0x80768e80,0x7c728a7c,0x766d8376,0x70677d70,0x6b63776b,0x665f7266,0x625b6c62,0x5f59685f,0x5c56655c,0x5a54625a,0x58535f58,0x56515c56,0x54505a54,0x534f5953,0x524e5752,0x514e5751,0x514e5751,0x524e5752,0x524e5852,0x534f5a53,0x55515c55,0x57525e57,0x59536159,0x5b55645b,0x5e58685e,0x615a6c61,0x665e7166,0x6a62766a,0x6f667b6f,0x746b8174,0x7a70887a,0x7d748c7d,
-	0x7d748c7d,0x79708779,0x736b8073,0x6e657a6e,0x68607468,0x645c6e64,0x60596960,0x5d57655d,0x5a55625a,0x57535f57,0x55515c55,0x534f5953,0x514e5751,0x504d5550,0x4f4c544f,0x4f4b544f,0x4f4b534f,0x4f4c544f,0x504c5550,0x514d5751,0x534e5953,0x54505b54,0x56515e56,0x59546159,0x5c56655c,0x5f58695f,0x635c6e63,0x67607367,0x6d64796d,0x72697e72,0x776e8577,0x7b728a7b,
-	0x7b718a7b,0x766e8476,0x71687e71,0x6b63776b,0x665e7166,0x615b6c61,0x5e57675e,0x5a55635a,0x58535f58,0x55515c55,0x534f5953,0x514d5651,0x4f4c544f,0x4e4b524e,0x4d4a514d,0x4c49504c,0x4c49504c,0x4c4a504c,0x4d4a524d,0x4e4b534e,0x504d5550,0x524e5852,0x54505b54,0x57525e57,0x5a54625a,0x5d57665d,0x605a6b60,0x655e7065,0x6a62766a,0x6f667c6f,0x756b8275,0x796f8779,
-	0x796f8779,0x746c8274,0x6e667b6e,0x68617468,0x645d6e64,0x60596960,0x5b56645b,0x58536158,0x56525d56,0x534f5953,0x514d5651,0x4e4b534e,0x4d4a514d,0x4c494f4c,0x4a484e4a,0x4a484d4a,0x4a474d4a,0x4a484d4a,0x4b484f4b,0x4c49504c,0x4e4b534e,0x504c5550,0x524e5952,0x55505b55,0x58526058,0x5b55645b,0x5e58695e,0x635c6e63,0x68607368,0x6d65796d,0x736a8073,0x776e8577,
-	0x766e8576,0x736a8073,0x6c65796c,0x675f7267,0x625b6c62,0x5d57675d,0x5a54625a,0x56525e56,0x54505a54,0x514e5751,0x4f4c534f,0x4c4a514c,0x4b484e4b,0x49474c49,0x48464b48,0x47464a47,0x47464a47,0x48464b48,0x49474c49,0x4a484e4a,0x4c49504c,0x4e4b534e,0x504d5650,0x534f5953,0x56515e56,0x59546259,0x5d57665d,0x615a6c61,0x665f7166,0x6b63776b,0x71687e71,0x756c8275,
-	0x756c8375,0x71687d71,0x6b63766b,0x655e7065,0x605a6a60,0x5c56655c,0x58536058,0x55515c55,0x524f5852,0x504c5550,0x4d4a514d,0x4b484e4b,0x49474c49,0x47464947,0x46454846,0x46444746,0x46444746,0x46444846,0x47454947,0x48464b48,0x4a484d4a,0x4c49504c,0x4f4b544f,0x514d5751,0x54505b54,0x58526058,0x5b56645b,0x5f59695f,0x645d6f64,0x69627569,0x6f677c6f,0x746a8174,
-	0x736b8273,0x6f677c6f,0x69617469,0x635d6e63,0x5f59695f,0x5a55635a,0x57525e57,0x53505a53,0x514e5651,0x4e4b534e,0x4b494f4b,0x49474c49,0x47454947,0x46444746,0x45434645,0x44434544,0x44434544,0x44434644,0x45444745,0x46454946,0x48464b48,0x4a484e4a,0x4d4a514d,0x504c5550,0x534f5953,0x56525e56,0x5a55635a,0x5e58685e,0x635c6d63,0x68607368,0x6e657a6e,0x72698072,
-	0x726a8072,0x6e667a6e,0x68607368,0x625c6d62,0x5e58675e,0x59546259,0x56515d56,0x524f5852,0x504c5550,0x4d4a514d,0x4a484d4a,0x47464a47,0x46444746,0x44434644,0x43424443,0x43424443,0x43424443,0x43424543,0x44434644,0x45444745,0x47454a47,0x49474c49,0x4b49504b,0x4e4b534e,0x524e5852,0x55505c55,0x59546159,0x5d57675d,0x625b6c62,0x675f7267,0x6c64796c,0x71687f71,
-	0x71697f71,0x6d65796d,0x675f7267,0x615b6c61,0x5c57665c,0x58536158,0x55505b55,0x514e5751,0x4e4c534e,0x4c4a4f4c,0x49474b49,0x46454846,0x45444645,0x43424443,0x42424342,0x42414242,0x42414242,0x42424342,0x43424443,0x44434644,0x46454846,0x48464b48,0x4a484e4a,0x4d4a524d,0x514d5651,0x54505b54,0x58536058,0x5c56655c,0x615a6b61,0x665e7166,0x6b63786b,0x70677d70,
-	0x70687e70,0x6b64796b,0x665f7166,0x615a6b61,0x5c56655c,0x58535f58,0x54505b54,0x504d5650,0x4d4b524d,0x4a494e4a,0x48464a48,0x45444745,0x44434544,0x42424342,0x41414241,0x41414141,0x41414141,0x42414242,0x42424342,0x43434543,0x45444745,0x47454a47,0x49484d49,0x4c4a514c,0x504d5550,0x534f5a53,0x57525f57,0x5b55655b,0x60596a60,0x655d7065,0x6b62776b,0x6f667c6f,
-	0x6f677e6f,0x6b64786b,0x655e7165,0x605a6a60,0x5b56645b,0x57525f57,0x534f5a53,0x504c5550,0x4d4a514d,0x4a484d4a,0x47464947,0x45444645,0x43424443,0x42414242,0x41414141,0x40404140,0x41414141,0x41414141,0x42414242,0x43424443,0x45444645,0x46454946,0x49474c49,0x4c49504c,0x4f4c554f,0x534f5953,0x56525f56,0x5b55645b,0x5f59695f,0x645d7064,0x6a61766a,0x6e657c6e,
-	0x6f677d6f,0x6b63776b,0x655e7165,0x60596a60,0x5b55645b,0x57525e57,0x534f5953,0x504c5450,0x4c4a504c,0x4a484d4a,0x47454947,0x45444645,0x43424343,0x41414241,0x41404141,0x40404040,0x40404040,0x41414141,0x41414241,0x42424342,0x44434644,0x46454846,0x48464c48,0x4b49504b,0x4f4b544f,0x534e5953,0x56515e56,0x5b55635b,0x5f59695f,0x645d6f64,0x69617669,0x6e657c6e,
-	0x6f667e6f,0x6b63776b,0x655e7065,0x60596a60,0x5b55645b,0x56525e56,0x534f5953,0x4f4c544f,0x4c4a504c,0x49484c49,0x46454946,0x44444644,0x43424343,0x41414241,0x40404040,0x40404040,0x40404040,0x40404140,0x41414241,0x42424342,0x44434544,0x46444846,0x48464b48,0x4b494f4b,0x4f4b544f,0x524e5952,0x56515e56,0x5a55635a,0x5f58695f,0x645c6f64,0x69617669,0x6d657b6d,
-	0x6f677d6f,0x6b63776b,0x655e7065,0x60596a60,0x5b55645b,0x57525e57,0x534f5953,0x4f4c554f,0x4c4a504c,0x49484d49,0x46454946,0x44444644,0x43424343,0x41414241,0x40414140,0x40404040,0x40404040,0x41414141,0x41414241,0x42424342,0x44434644,0x46454846,0x48464c48,0x4b49504b,0x4f4c544f,0x524e5952,0x56515e56,0x5a54645a,0x5f58695f,0x645d6f64,0x69617669,0x6e657b6e,
-	0x70677d70,0x6b64786b,0x655e7165,0x605a6a60,0x5b56645b,0x57525f57,0x534f5953,0x504d5550,0x4c4a514c,0x4a484d4a,0x47464947,0x45444645,0x43434443,0x42414242,0x41414141,0x40404040,0x40404140,0x41414141,0x41414241,0x43424443,0x44434644,0x46454846,0x49474c49,0x4c49504c,0x4f4c554f,0x534f5a53,0x56525f56,0x5b55645b,0x5f596a5f,0x645d6f64,0x6a62766a,0x6d657c6d,
-	0x70687e70,0x6c64796c,0x665f7266,0x605a6b60,0x5c56655c,0x57536057,0x54505a54,0x504d5650,0x4d4a514d,0x4a494e4a,0x47464a47,0x45444745,0x43434543,0x42424342,0x41414241,0x41414141,0x41404141,0x41414241,0x42414342,0x43424543,0x45444745,0x47454a47,0x49474d49,0x4c4a514c,0x504c5650,0x534f5a53,0x57525f57,0x5b56655b,0x60596a60,0x645d7064,0x6a62776a,0x6f667c6f,
-	0x71697f71,0x6d65796d,0x67607267,0x615b6c61,0x5d57665d,0x58536158,0x54505c54,0x514e5751,0x4e4b534e,0x4b494f4b,0x48474b48,0x46454846,0x44444644,0x43424443,0x42424342,0x42414242,0x42414242,0x42414342,0x43424443,0x44434544,0x46444846,0x48464b48,0x4a484e4a,0x4d4a524d,0x514d5651,0x54505b54,0x58526058,0x5c56655c,0x615a6b61,0x655e7165,0x6b63786b,0x6f677e6f,
-	0x736a8073,0x6e667b6e,0x68617368,0x625c6d62,0x5e58675e,0x59546259,0x55515d55,0x524f5852,0x4f4c544f,0x4c4a504c,0x4a484d4a,0x47464a47,0x45444845,0x44434644,0x43434443,0x43424443,0x43424443,0x43424443,0x44434544,0x45444745,0x47454947,0x49474c49,0x4b49504b,0x4e4b544e,0x514e5851,0x55505d55,0x59536259,0x5d57675d,0x615a6c61,0x665f7366,0x6c64796c,0x71687f71,
-	0x746b8274,0x6f677d6f,0x69627569,0x645d6f64,0x5f59695f,0x5a55635a,0x57525e57,0x534f5a53,0x504d5650,0x4d4b524d,0x4b494f4b,0x48474b48,0x46454946,0x45444745,0x44444644,0x44434644,0x44434544,0x44434644,0x45444745,0x46454946,0x48464b48,0x4a484e4a,0x4d4a514d,0x4f4c554f,0x534f5a53,0x56515e56,0x5a54635a,0x5e58685e,0x625b6e62,0x68607468,0x6d657b6d,0x72698072,
-	0x766c8476,0x71697e71,0x6b64776b,0x655e7165,0x605a6a60,0x5c56655c,0x58536058,0x55515c55,0x514e5751,0x4f4c544f,0x4c4a504c,0x4a484e4a,0x48474b48,0x47454a47,0x46454846,0x46444746,0x45444745,0x46444846,0x47454947,0x48464b48,0x4a484d4a,0x4c49504c,0x4e4b534e,0x514d5751,0x54505c54,0x57526057,0x5b55645b,0x5f586a5f,0x645c7064,0x69617569,0x6f667c6f,0x736a8273,
-	0x776e8577,0x736b8073,0x6d65796d,0x67607267,0x625c6c62,0x5d58675d,0x59556259,0x56525e56,0x534f5a53,0x514d5651,0x4e4b534e,0x4c49504c,0x4a484e4a,0x49474c49,0x48464b48,0x47464a47,0x47464a47,0x48464a48,0x49474c49,0x4a484d4a,0x4b49504b,0x4d4b534d,0x504c5650,0x534e5953,0x55515d55,0x59536259,0x5c56665c,0x615a6c61,0x655e7165,0x6b63786b,0x71687e71,0x756c8375,
-	0x79708879,0x756c8375,0x6e677c6e,0x69627569,0x645d6f64,0x5f59695f,0x5b56645b,0x58536058,0x55515c55,0x524f5952,0x504d5650,0x4e4b534e,0x4c4a504c,0x4b494f4b,0x4a484e4a,0x49474d49,0x49484d49,0x4a484d4a,0x4a484f4a,0x4c4a504c,0x4d4b524d,0x504c5550,0x524e5852,0x54505b54,0x57526057,0x5a55645a,0x5e58685e,0x635b6e63,0x68607468,0x6d657a6d,0x73698073,0x776d8577,
-	0x7b728a7b,0x776e8577,0x71697e71,0x6b64776b,0x665f7166,0x615b6c61,0x5d58675d,0x5a55635a,0x57525f57,0x54505c54,0x524e5852,0x504d5550,0x4e4b534e,0x4d4a514d,0x4c4a504c,0x4b49504b,0x4b49504b,0x4c4a504c,0x4d4a514d,0x4e4b534e,0x4f4c554f,0x514e5851,0x534f5b53,0x56515e56,0x59546259,0x5c56665c,0x61596b61,0x655d7065,0x6a62766a,0x6f677d6f,0x746c8274,0x786f8778,
-	0x7e748d7e,0x7a71887a,0x746c8174,0x6e667a6e,0x69617469,0x645d6f64,0x605a6a60,0x5c57665c,0x59546259,0x57525e57,0x54505b54,0x524e5852,0x514d5651,0x4f4c554f,0x4e4b544e,0x4e4b534e,0x4e4b534e,0x4e4b534e,0x4f4c544f,0x504d5650,0x524e5852,0x534f5b53,0x56515e56,0x58536158,0x5b55655b,0x5f58695f,0x635b6e63,0x675f7367,0x6c63796c,0x72687f72,0x776d8677,0x7b718a7b,
-	0x80778f80,0x7c748a7c,0x776e8477,0x71697e71,0x6b64786b,0x66607266,0x625c6d62,0x5f59695f,0x5b56655b,0x59546159,0x57525e57,0x55505c55,0x534f5a53,0x524e5852,0x514d5751,0x514d5751,0x504d5750,0x514d5751,0x524e5852,0x534f5953,0x54505c54,0x56515e56,0x58536158,0x5a55645a,0x5e58685e,0x615a6c61,0x655e7165,0x6a62776a,0x6f667c6f,0x746b8274,0x7a70887a,0x7d738c7d,
-	0x837a9383,0x7f768e7f,0x7a71877a,0x746c8174,0x6e667b6e,0x69627669,0x655f7165,0x615b6c61,0x5f58685f,0x5c56655c,0x59546259,0x57525f57,0x56515d56,0x55505c55,0x54505b54,0x534f5a53,0x534f5a53,0x54505b54,0x55505c55,0x55505d55,0x57525f57,0x58536158,0x5a55645a,0x5d57675d,0x615a6b61,0x645d7064,0x68607468,0x6d647a6d,0x72698072,0x776d8577,0x7c728b7c,0x7f758f7f,
-	0x877d9687,0x82799182,0x7d738a7d,0x776e8477,0x716a7f71,0x6c65796c,0x68617468,0x645d7064,0x625b6c62,0x5f58695f,0x5c56655c,0x5a55635a,0x59536159,0x57526057,0x56525f56,0x56515e56,0x56515e56,0x56515f56,0x57526057,0x58536158,0x5a54635a,0x5b56655b,0x5d57685d,0x60596b60,0x635c6f63,0x675f7367,0x6c63796c,0x70677e70,0x756c8375,0x7a70887a,0x7e748d7e,0x81779281,
-	0x89809a89,0x847b9484,0x7e768e7e,0x79718879,0x746c8274,0x6e687d6e,0x6a63786a,0x66607366,0x645d7064,0x605a6c60,0x5e58695e,0x5c56665c,0x5b55645b,0x5a54635a,0x59546259,0x59536159,0x58536158,0x59536259,0x59546259,0x5a54645a,0x5c56665c,0x5e57685e,0x60596b60,0x625b6e62,0x665e7266,0x6a62776a,0x6e657c6e,0x73698073,0x776e8577,0x7c728b7c,0x80768f80,0x82789382
-};
-
-void isp_top_init(xml_top_t *top,unsigned int w,unsigned int h)
-{
-	unsigned short offset[XML_TOP]={
-		0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0xaf
-	};
-	int i = 0;
-	if(top){
-		//for(i=0;i < XML_TOP;i++)
-                //	WR(ISP_VCBUS_BASE+offset[i],top->reg_map[i]);
-	}
-	/*config input size*/
-	WR(ISP_HV_SIZE,w<<REG_HSIZE_BIT|h);
-        WR(ISP_HBLANK,w<<REG_TOTAL_W_BIT|10);
-	/*config output timming*/
-	WR(ISP_OUTHS_PARA,0x100000a);
-	return;
-}
-/*
-*reg 0x08~0x1b
-*/
-void isp_set_test_pattern(xml_tp_t *tp)
-{
-	int i = 0;
-	if(tp){
-		for(i=0;i<XML_TP;i++)
-			WR(ISP_PAT_GEN_CTRL+i,tp->reg_map[i]);
-	} 
-	return;
-}
-/*
-*reg 0x20~0x25
-*/
-void isp_set_clamp_gain(xml_cg_t *cg)
-{
-	int i = 0;
-	if(cg){
-		for(i=0;i<XML_CG;i++)
-		        WR(ISP_CLAMPGAIN_CTRL+i, cg->reg_map[i]);
-	}
-	return;
-}
-/*
-*reg 0x28~0x2c
-*/
-void isp_set_lens_shading(xml_ls_t *lens)
-{
-	int i = 0;
-	if(lens){
-		for(i=0;i<XML_LS;i++)
-		        WR(ISP_LNS_CTRL+i, lens->reg_map[i]);
-	}
-}
-/*
-*reg 0x30
-*/
-void isp_set_gamma_correction(xml_gc_t *gc)
-{
-	int i = 0;
-	if(gc){
-		for(i=0;i<XML_GC;i++)
-		        WR(ISP_GMR0_CTRL+i, gc->reg_map[i]);
-	}
-}
-/*
-*reg 0x31
-*reg 0x33~0x3c
-*/
-void isp_set_defect_pixel_correction(xml_dp_t *dpc)
-{
-	int i = 0;
-	unsigned short offset[XML_DP]={
-		0x31,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c
-	};
-	if(dpc){
-		for(i=0;i<XML_DP;i++)
-		        WR(ISP_VCBUS_BASE+offset[i], dpc->reg_map[i]);
-	}
-}
-/*
-*reg 0x40~0x41
-*/
-void isp_set_demosaicing(xml_dm_t *dms)
-{
-	int i = 0;
-	if(dms){
-		for(i=0;i<XML_DM;i++)
-		        WR(ISP_DMS_CTRL0+i, dms->reg_map[i]);
-	}
-}
-/*
-*reg 0x42~0x4a
-*/
-void isp_set_matrix(xml_csc_t *csc, unsigned int height)
-{
-	unsigned int isp_matrix_lup[3][9]=
-	{
-		{0x0,0x10000,0x840102,0x3203b4,0x36b00e1,0xe10344,0x3dc,0x400200,0x200},
-		//rgb->601
-		{0x0,0x10000,0x5e013a,0x2003cc,0x35300e1,0xe10334,0x3ec,0x400200,0x200},
-		//rgb->709
-		{0x0,0x0000,0x01000000,0x00000,0x01000000,0x00000,0x100,0x000000,0x000},
-	};
-	unsigned int i=0, *start;
-	if(csc){
-		start = &(csc->reg_map[0]);
-		if(height > 720)
-			start = &(csc->reg_map[XML_CSC]);
-		for(i=0;i<XML_CSC;i++)
-		        WR(ISP_MATRIX_PRE_OFST0_1+i, *(start+i));
-	} else {
-	        if(height==0) {
-	    	        start = isp_matrix_lup[2];
-			for(i=0;i<XML_CSC;i++)
-			        WR(ISP_MATRIX_PRE_OFST0_1+i, *(start+i));			
-	        }else{
-		        start = (height>720)?isp_matrix_lup[1]:isp_matrix_lup[0];
-		        for(i=0;i<XML_CSC;i++)
-		                WR(ISP_MATRIX_PRE_OFST0_1+i, *(start+i));
-		}
-	}
-}
-/*
-*reg 0x50
-*reg 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x5b
-*reg 0x60 0x61 0x62 0x63 0x64 0x65 0x66
-*reg 0x72 0x73 0x74 0x75 0x76 0x78 0x79 0x7a 0x7b
-*reg 0x80 0x81 0x82 0x83 0x84 0x85(special effect )
-*/
-void isp_set_sharpness(xml_sharp_t *sharp)
-{
-	int i=0;
-	unsigned short offset[XML_SH]={
-		0x50,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,
-		0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x72,0x73,0x74,0x75,
-		0x76,0x78,0x79,0x7a,0x7b,0x80,0x81,0x82,0x83,0x84,0x85
-	};
-	if(sharp){
-		for(i=0;i<XML_SH;i++)
-			WR(ISP_VCBUS_BASE+offset[i], sharp->reg_map[i]);
-	}
-}
-/*
-*reg 0x50~0x51
-*reg 0x68~0x71
-*reg 0x85
-*/
-void isp_set_nr(xml_nr_t *nr)
-{
-	int i = 0;
-	unsigned short offset[XML_NR]={
-		0x50,0x51,0x68,0x69,0x6a,0x6b,0x6c,
-		0x6d,0x6e,0x6f,0x70,0x71,0x85
-	};
-	if(nr){
-		for(i=0;i<XML_NR;i++)
-			WR(ISP_VCBUS_BASE+offset[i], nr->reg_map[i]);
-	}
-}
-/*
-*reg 0x88~0x8c
-*/
-void isp_set_awb_stat(xml_awb_t *awbs,unsigned int w,unsigned int h)
-{
-	int i = 0;
-	if(awbs){
-		for(i=0;i<XML_AWB;i++)
-			WR(ISP_AWB_WIND_LR+i, awbs->reg_map[i]);
-	}
-	/*config awb statistics window*/
-	WR(ISP_AWB_WIND_LR,w);
-	WR(ISP_AWB_WIND_TB,h);
-}
-/*
-*reg 0x8c
-*reg 0x90~0x94
-*/
-void isp_set_ae_stat(xml_ae_t *aes,unsigned int w,unsigned int h)
-{
-	unsigned int i=0,xstep=0,ystep=0;
-	unsigned short offset[XML_AE]={
-		0x8c,0x90,0x91,0x92,0x93,0x94
-	};
-	if(aes){
-		for(i=0;i<XML_AE;i++)
-			WR(ISP_VCBUS_BASE+offset[i],aes->reg_map[i]);
-	}
-	/*config ae statistics window*/
-	xstep = w>>2;
-	ystep = h>>2;
-
-	WR(ISP_AEC_WIND_XYSTART,0);
-	WR(ISP_AEC_WIND_XYSTEP,xstep<<13|ystep);
-	WR(ISP_AECRAW_WIND_LR,w);
-	WR(ISP_AECRAW_WIND_TB,h);
-}
-/*
-*reg 0x98~0xa8
-*/
-void isp_set_af_stat(xml_af_t *afs,unsigned int w,unsigned int h)
-{
-	unsigned int i=0,tmp_w=0,tmp_h=0;
-	if(afs){
-		for(i=0;i<XML_AF;i++)
-			WR(ISP_AFC_FILTER_SEL+i, afs->reg_map[i]);
-	}
-	WR(ISP_AFC_FILTER_SEL,0x17722);
-    /*config win0~win8 according to hv size*/
-	tmp_w = w/12;
-	tmp_h = h/12;
-	/* wind0 h:2-5  v:2-5*/
-	WR(ISP_AFC_WIND0_LR,(tmp_w<<1)<<16|tmp_w*5);
-	WR(ISP_AFC_WIND0_TB,(tmp_h<<1)<<16|tmp_h*5);
-	/* wind1 h:5-8  v:5-8*/
-	WR(ISP_AFC_WIND1_LR,(tmp_w*5)<<16|tmp_w<<3);
-	WR(ISP_AFC_WIND1_TB,(tmp_h*5)<<16|tmp_h<<3);
-	/* wind2 h:8-11 v:2-5*/
-	WR(ISP_AFC_WIND2_LR,(tmp_w<<3)<<16|tmp_w*11);
-	WR(ISP_AFC_WIND2_TB,(tmp_h<<1)<<16|tmp_h*5);
-	/* wind3 h:2-5  v:8-11*/
-	WR(ISP_AFC_WIND3_LR,(tmp_w<<1)<<16|tmp_w*5);
-	WR(ISP_AFC_WIND3_TB,(tmp_h<<3)<<16|tmp_h*11);
-	/*wind4 h:8-11 v:8-11*/
-	WR(ISP_AFC_WIND4_LR,(tmp_w<<3)<<16|tmp_w*11);
-	WR(ISP_AFC_WIND4_TB,(tmp_h<<3)<<16|tmp_h*11);
-}
-void isp_set_af_scan_stat(unsigned int x0,unsigned int y0,unsigned int x1,unsigned int y1)
-{
-	WR(ISP_AFC_WIND0_LR,x1|x0<<16);
-	WR(ISP_AFC_WIND0_TB,y1|y0<<16);
-	//WR(ISP_AFC_FILTER_SEL,0x000170f0);
-	WR_BITS(ISP_AFC_FILTER_SEL,af_limit,AFC_F1_CORING_BIT,AFC_F1_CORING_WID);
-	WR_BITS(ISP_AFC_FILTER_SEL,af_limit,AFC_F0_CORING_BIT,AFC_F0_CORING_WID);
-	WR_BITS(ISP_AFC_FILTER_SEL,af_filter1,AFC_F1_SELECT_BIT,AFC_F1_SELECT_WID);
-	WR_BITS(ISP_AFC_FILTER_SEL,af_filter0,AFC_F0_SELECT_BIT,AFC_F0_SELECT_WID);
-	WR_BITS(ISP_AFC_FILTER_SEL,1,AFC_RO_UPDATE_BIT,AFC_RO_UPDATE_WID);
-}
-/*
-*reg 0xac~0xae
-*/
-void isp_set_blenr_stat(unsigned int x0,unsigned int y0,unsigned int x1,unsigned int y1)
-{
-	#if 0
-	int i = 0;
-	pr_info("[%s..]%s: init ok.\n",DEVICE_NAME,__func__);
-	if(blenrs){
-		for(i=0;i<XML_BN;i++)
-			WR(ISP_BLNR_CTRL+i, blenrs->reg_map[i]);
-	}
-	#endif
-	/*set lpf according to sd or hd*/
-	WR_BITS(ISP_BLNR_CTRL,0,BLNR_STATISTICS_EN_BIT,BLNR_STATISTICS_EN_WID);
-	if(abs(y1-y0) > 720)
-		WR_BITS(ISP_BLNR_CTRL,3,BLNR_LPF_MODE_BIT,BLNR_LPF_MODE_WID);
-	else
-		WR_BITS(ISP_BLNR_CTRL,1,BLNR_LPF_MODE_BIT,BLNR_LPF_MODE_WID);
-	/*set ac adaptive*/
-	WR_BITS(ISP_BLNR_CTRL,1,BLNR_AC_ADAPTIVE_BIT,BLNR_AC_ADAPTIVE_WID);
-	WR(ISP_BLNR_WIND_LR, x1|x0<<16);
-	WR(ISP_BLNR_WIND_TB, y1|y0<<16);
-	WR_BITS(ISP_BLNR_CTRL,1,BLNR_STATISTICS_EN_BIT,BLNR_STATISTICS_EN_WID);
-}
-/*
-*reg 0xb0~0xb1
-*/
-void isp_set_dbg(xml_dbg_t *dbg)
-{
-	int i = 0;
-	pr_info("[%s..]%s: init ok.\n",DEVICE_NAME,__func__);
-	if(dbg){
-		for(i=0;i<XML_DBG;i++)
-			WR(ISP_DBG_PIXEL_CTRL+i, dbg->reg_map[i]);
-	}
-}
-static void isp_set_lnsd(xml_lut_ls_t *lnsd)
-{
-	int i = 0;
-	if(lnsd){
-		pr_info("%s\n",__func__);
-		WRITE_VCBUS_REG(0x2d28, (READ_VCBUS_REG(0x2d28)&0xefffffff)); // disable lens shielding
-		WRITE_VCBUS_REG(0x2daf, 0x0000000c);         // lens shielding lut ram: v-bus write mode		
-		WRITE_VCBUS_REG(ISP_LNS_XYSCAL, lnsd->reg_map[i]);
-		for(i=1;i<XML_LUT_LS;i++){
-			WR(ISP_LNSD_LUT_ADDR,i-1);
-			WR(ISP_LNSD_LUT_DATA,lnsd->reg_map[i]);
-		}
-	    WRITE_VCBUS_REG(0x2daf, 0x00000000); // lens shielding lut ram: hardware read mode	
-	    WRITE_VCBUS_REG(0x2d28, (READ_VCBUS_REG(0x2d28)|0x10000000));		
-	}
-}
-
-static void isp_set_lnsd_test(unsigned int w,unsigned int h)
-{
-	int i;
-	pr_info("%s:w=%d,h=%d\n",__func__,w,h);
-    WRITE_VCBUS_REG(0x2d28, (READ_VCBUS_REG(0x2d28)&0xefffffff)); // disable lens shielding
-    WRITE_VCBUS_REG(0x2daf, 0x0000000c);         // lens shielding lut ram: v-bus write mode
-    if((w==640)&&(h==480))
-    {
-		pr_info("480p\n");
-	    WRITE_VCBUS_REG(0x2d29, 0x018D0212);      // lens shielding xscale & yscale
-	    WRITE_VCBUS_REG(0x2dc6, 0x00000000);         // point to head of ram
-	    for (i = 0; i < 1024; i++)
-	    {
-			WRITE_VCBUS_REG(0x2dc7, isp_param_lns_lut_480p[i]);
-	    }
-    }
-	else if((w==1280)&&(h==720))
-    {
-		pr_info("720p\n");
-	    WRITE_VCBUS_REG(0x2d29, 0x00C60161);      // lens shielding xscale & yscale
-	    WRITE_VCBUS_REG(0x2dc6, 0x00000000);         // point to head of ram
-	    for (i = 0; i < 1024; i++)
-	    {
-			WRITE_VCBUS_REG(0x2dc7, isp_param_lns_lut_720p[i]);
-	    }
-    }
-	else if((w==1280)&&(h==960))
-    {
-		pr_info("960p\n");
-	    WRITE_VCBUS_REG(0x2d29, 0x00C60108);      // lens shielding xscale & yscale
-	    WRITE_VCBUS_REG(0x2dc6, 0x00000000);         // point to head of ram
-	    for (i = 0; i < 1024; i++)
-	    {
-			WRITE_VCBUS_REG(0x2dc7, isp_param_lns_lut_960p[i]);
-	    }
-    }
-	else if((w==1920)&&(h==1080))
-    {
-		pr_info("1080p\n");
-	    WRITE_VCBUS_REG(0x2d29, 0x008400EB);      // lens shielding xscale & yscale
-	    WRITE_VCBUS_REG(0x2dc6, 0x00000000);         // point to head of ram
-	    for (i = 0; i < 1024; i++)
-	    {
-			WRITE_VCBUS_REG(0x2dc7, isp_param_lns_lut_1080p[i]);
-	    }
-    }
-	else if((w==2592)&&(h==1944))
-    {
-		pr_info("5m\n");
-	    WRITE_VCBUS_REG(0x2d29, 0x00620082);      // lens shielding xscale & yscale
-	    WRITE_VCBUS_REG(0x2dc6, 0x00000000);         // point to head of ram
-	    for (i = 0; i < 1024; i++)
-	    {
-			WRITE_VCBUS_REG(0x2dc7, isp_param_lns_lut_5m[i]);
-	    }
-    }
-    WRITE_VCBUS_REG(0x2daf, 0x00000000); // lens shielding lut ram: hardware read mode	
-    WRITE_VCBUS_REG(0x2d28, (READ_VCBUS_REG(0x2d28)|0x10000000));
-}
-
-void isp_set_lnsd_mode(unsigned int mode)
-{
-	WR_BITS(ISP_LNS_CTRL,mode,LNS_MESH_MODE_BIT,LNS_MESH_MODE_WID);
-}
-static void isp_set_gamma_table(struct xml_lut_gc_s *gt)
-{
-	if(gt){
-		set_isp_gamma_table(gt->gamma_r,GAMMA_R);
-		set_isp_gamma_table(gt->gamma_g,GAMMA_G);
-		set_isp_gamma_table(gt->gamma_b,GAMMA_B);
-	}else{
-		pr_info("%s:null pointer error.\n",__func__);
-	}
-}
-/*
-*disable gamma correction & lnsd
-*/
-void disable_gc_lns_pk(bool flag)
-{
-	if(flag){
-		WR_BITS(ISP_LNS_CTRL,1,LNS_CMOP_ENABLE_BIT,LNS_CMOP_ENABLE_WID);
-		WR_BITS(ISP_GMR0_CTRL,1,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-		WR_BITS(ISP_PKNR_ENABLE,1,ISP_PK_EN_BIT,ISP_PK_EN_WID);
-	}else{
-		WR_BITS(ISP_LNS_CTRL,0,LNS_CMOP_ENABLE_BIT,LNS_CMOP_ENABLE_WID);
-		WR_BITS(ISP_GMR0_CTRL,0,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-		WR_BITS(ISP_PKNR_ENABLE,0,ISP_PK_EN_BIT,ISP_PK_EN_WID);
-	}
-}
-
-void isp_bypass_all()
-{
-	isp_bypass_for_rgb();
-	WR_BITS(ISP_DMS_CTRL0,7,ISP_DMS_BYPASS_BIT,ISP_DMS_BYPASS_WID);
-}
-
-void isp_bypass_for_rgb()
-{
-	WR_BITS(ISP_PAT_GEN_CTRL,0,ISP_PAT_ENABLE_BIT,ISP_PAT_ENABLE_WID);
-	WR_BITS(ISP_CLAMP_GRBG01,0,CLAMP_GRBG0_BIT,CLAMP_GRBG0_WID);
-	WR_BITS(ISP_CLAMP_GRBG01,0,CLAMP_GRBG1_BIT,CLAMP_GRBG1_WID);
-	WR_BITS(ISP_CLAMP_GRBG23,0,CLAMP_GRBG2_BIT,CLAMP_GRBG2_WID);
-	WR_BITS(ISP_CLAMP_GRBG23,0,CLAMP_GRBG3_BIT,CLAMP_GRBG3_WID);
-	WR_BITS(ISP_GAIN_GRBG01,0x100,GAIN_GRBG0_BIT,GAIN_GRBG0_WID);
-	WR_BITS(ISP_GAIN_GRBG01,0x100,GAIN_GRBG1_BIT,GAIN_GRBG1_WID);
-	WR_BITS(ISP_GAIN_GRBG23,0x100,GAIN_GRBG2_BIT,GAIN_GRBG2_WID);
-	WR_BITS(ISP_GAIN_GRBG23,0x100,GAIN_GRBG3_BIT,GAIN_GRBG3_WID);	
-	WR_BITS(ISP_LNS_CTRL,0,LNS_CMOP_ENABLE_BIT,LNS_CMOP_ENABLE_WID);
-	WR_BITS(ISP_GMR0_CTRL,0,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-	WR_BITS(ISP_DFT_CTRL,0,ISP_DFT_ENABLE_BIT,ISP_DFT_ENABLE_WID);
-	isp_set_matrix(NULL,0);
-	WR_BITS(ISP_PKNR_ENABLE,0,ISP_NR_EN_BIT,ISP_NR_EN_WID);
-	WR_BITS(ISP_PKNR_ENABLE,0,ISP_PK_EN_BIT,ISP_PK_EN_WID);	
-	
-}
-static void isp_set_bayer_fmt(tvin_color_fmt_t bfmt)
-{
-	unsigned int tmp = bfmt - TVIN_BGGR;
-	WR_BITS(ISP_PAT_GEN_CTRL,tmp,PAT_BAYER_FMT_BIT,PAT_BAYER_FMT_WID);
-	WR_BITS(ISP_CLAMPGAIN_CTRL,tmp,CLP_BAYER_FMT_BIT,CLP_BAYER_FMT_WID);
-	WR_BITS(ISP_LNS_CTRL,tmp,LNS_BAYER_FMT_BIT,LNS_BAYER_FMT_WID);
-	WR_BITS(ISP_GMR0_CTRL,tmp,GMR_BAYER_FMT_BIT,GMR_BAYER_FMT_WID);
-	WR_BITS(ISP_DFT_CTRL,tmp,DFT_BAYER_FMT_BIT,DFT_BAYER_FMT_WID);
-	WR_BITS(ISP_DMS_CTRL0,tmp,DMS_BAYER_FMT_BIT,DMS_BAYER_FMT_BIT);
-}
-/*
-*load isp config according to config file
-*/
-void isp_set_def_config(xml_default_regs_t *regs,tvin_port_t fe_port,tvin_color_fmt_t bfmt,unsigned int w,unsigned int h)
-{
-	unsigned int mux = 0;
-	
-	switch(fe_port){
-		case TVIN_PORT_CAMERA:
-			mux = 1;
-			break;
-		case TVIN_PORT_MIPI:
-			mux = 2;
-			break;
-		default:
-			mux = 0;
-			break;
-	}
-	WR_BITS(VPU_MISC_CTRL,mux,ISP_IN_SEL_BIT,ISP_IN_SEL_WID);
-	
-	isp_top_init(&regs->top,w,h);
-	isp_set_test_pattern(&regs->tp);
-	isp_set_clamp_gain(&regs->cg);
-	isp_set_lens_shading(&regs->ls);
-	isp_set_gamma_correction(&regs->gc);
-	isp_set_defect_pixel_correction(&regs->dp);
-	isp_set_demosaicing(&regs->dm);
-	isp_set_matrix(NULL,h);
-	isp_set_sharpness(&regs->sharp);
-	isp_set_nr(&regs->nr);
-	isp_set_blenr_stat((w>>2),(h>>2),(w-(w>>2)),(h-(h>>2)));
-	isp_set_awb_stat(&regs->awb_reg,w,h);
-	isp_set_ae_stat(&regs->ae_reg,w,h);
-	isp_set_af_stat(&regs->af_reg,w,h);
-	//isp_set_dbg(&regs->dbg);
-	isp_set_lnsd(&regs->lnsd);
-	//isp_set_lnsd_test(w,h);
-	isp_set_gamma_table(&regs->lut_gc);
-	/*config bayer fmt*/
-	if(TVIN_BGGR<=bfmt && bfmt<=TVIN_GRBG)
-		isp_set_bayer_fmt(bfmt);
-	//enable isp
-	WR_BITS(ISP_FRM_SOFT_RST,0,0,1);
-	WR_BITS(ISP_TIMING_MODE,0,5,1);
-	pr_info("[%s..]%s: init ok(w:%d,h:%d) bayer fmt %s.\n",DEVICE_NAME,__func__,w,h,tvin_color_fmt_str(bfmt));
-}
-
-void isp_hw_enable(bool flag)
-{
-	if(flag){
-		WR_BITS(ISP_FRM_SOFT_RST,0,0,1);
-		WR_BITS(ISP_TIMING_MODE,0,5,1);
-	}else{
-		WR_BITS(ISP_TIMING_MODE,1,5,1);
-		WR_BITS(ISP_FRM_SOFT_RST,1,0,1);
-	}
-		
-}
-/*
-*just enable test pattern
-*/
-void isp_test_pattern(unsigned int hsize,unsigned int vsize,unsigned int htotal,unsigned int vtotal,unsigned char bayer_fmt)
-{
-        // pat gen
-        WRITE_VCBUS_REG(ISP_PAT_GEN_CTRL, 0x0);
-        WRITE_VCBUS_REG(ISP_PAT_XRAMP_SCAL,0x00ffffff);
-        WRITE_VCBUS_REG(ISP_PAT_YRAMP_SCAL,0x00ffffff);
-        WRITE_VCBUS_REG(ISP_PAT_XYIDX_OFST,0x0 );
-        WRITE_VCBUS_REG(ISP_PAT_XYIDX_SCAL,0x0022003d); //default=0
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_RED0,0x0000ffff);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_RED1,0x0000ffff);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_RED2,0x80604020);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_RED3,0xffe0c0a0);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_GRN0,0x0000ffff); //defaulr is all 'hff
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_GRN1,0x00000000);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_GRN2,0x80604020);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_GRN3,0xffe0c0a0);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_BLU0,0x00ff00ff);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_BLU1,0x00ff00ff);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_BLU2,0x80604020);
-        WRITE_VCBUS_REG(ISP_PAT_BAR16_BLU3,0xffe0c0a0);
-
-        WRITE_VCBUS_REG_BITS(ISP_PAT_GEN_CTRL,  0 ,20,3); // xmode: raster/bar16/burst enable
-        WRITE_VCBUS_REG_BITS(ISP_PAT_GEN_CTRL,  2 ,16,3); // ymode: 1023
-	WRITE_VCBUS_REG_BITS(ISP_PAT_GEN_CTRL,bayer_fmt,PAT_BAYER_FMT_BIT,PAT_BAYER_FMT_WID);
-        // pat dft
-        WRITE_VCBUS_REG(ISP_PAT_DFT_XYIDX,0x006400c8 ); //reg_isp_pat_dft_xidx='h64,reg_isp_pat_dft_yidx='hc8
-        WRITE_VCBUS_REG(ISP_PAT_DFT_XYWID,0x00010004 ); //default reg_isp_pat_dft_ywid=64,default is wrong?
-        WRITE_VCBUS_REG(ISP_PAT_DFT_GAIN, 0x0);
-        WRITE_VCBUS_REG(ISP_PAT_HVTOTAL,(vtotal<<16)|(htotal));
-        WRITE_VCBUS_REG(ISP_PAT_VDE_SLINE,0x00000007 );
-        // demosaicing
-        WRITE_VCBUS_REG(ISP_DMS_CTRL0, 0x00030000);
-        WRITE_VCBUS_REG(ISP_DMS_CTRL1, 0x00120510);
-	WRITE_VCBUS_REG_BITS(ISP_DMS_CTRL0,bayer_fmt,DMS_BAYER_FMT_BIT,DMS_BAYER_FMT_WID);
-        // color matrix
-        isp_set_matrix(NULL,0);
-
-        WRITE_VCBUS_REG(ISP_RST_DLY_NUM,htotal*6);
-        WRITE_VCBUS_REG_BITS(ISP_PAT_GEN_CTRL,1,28,1);
-}
-/*
-*just enable demosaicing,matrix
-*/
-void isp_load_def_setting(unsigned int w,unsigned int h,unsigned char bayer_fmt)
-{
-	//reset isp
-	WR_BITS(ISP_TIMING_MODE,1,5,1);
-	WR_BITS(ISP_FRM_SOFT_RST,1,0,1);
-	//disable pattern generator
-	WR_BITS(ISP_PAT_GEN_CTRL,0,ISP_PAT_ENABLE_BIT,ISP_PAT_ENABLE_WID);
-	//disable gamma & lnsd
-	disable_gc_lns_pk(false);
-	//disable nr,pk
-	WR_BITS(ISP_PKNR_ENABLE,0,ISP_NR_EN_BIT,ISP_NR_EN_WID);
-	//disable defect pixel
-	WR_BITS(ISP_DFT_CTRL,0,ISP_DFT_ENABLE_BIT,ISP_DFT_ENABLE_WID);
-	WR_BITS(ISP_DFT_CTRL,0,DFTMAP_CORRECT_MODE_BIT,DFTMAP_CORRECT_MODE_WID);
-	//disable clamp gain
-	WR(ISP_CLAMPGAIN_CTRL,bayer_fmt<<24);
-	WR(ISP_GAIN_BSCORE_GRBG,0x3000000);
-	WR(ISP_CLAMP_GRBG01,0x0);
-	WR(ISP_CLAMP_GRBG23,0x0);
-	WR(ISP_GAIN_GRBG01, 0x1000100);
-	WR(ISP_GAIN_GRBG23, 0x1000100);
-	
-	WR(ISP_HV_SIZE,w<<REG_HSIZE_BIT|h);
-        WR(ISP_HBLANK, w<<REG_TOTAL_W_BIT|10);
-	// demosaicing
-        WR(ISP_DMS_CTRL0, bayer_fmt<<24);
-        WR(ISP_DMS_CTRL1, 0x00120510);
-	//matrix
-	isp_set_matrix(NULL,h);
-	//enable
-	WR_BITS(ISP_FRM_SOFT_RST,0,0,1);
-	WR_BITS(ISP_TIMING_MODE,0,5,1);
-	
-}
-
-/*
-*wave init
-*/
-void wave_init(wave_t *wave_param)
-{
-	static bool init_flag = false;
-        if (!init_flag) {
-    	        init_flag = true;
-                // clock_div & clock disable
-                WRITE_CBUS_REG(HHI_ISP_LED_CLK_CNTL, wave_param->wave_clock_div);
-	        // disable isp_led2_en
-	        WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_9,0,17,1); // clear pinmux_9[17] for isp_led2_en
-	        // enable isp_led1_en
-	        WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_5,0,31,1); // clear pinmux_5[31] for I2C_SDA_A
-	        WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_7,0,25,1); // clear pinmux_7[25] for PWM_VS
-	        WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_9,0,16,1); // clear pinmux_9[16] for PWM_A
-	        WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_9,1,18,1); // set pinmux_9[18] for isp_led1_en
-        }
-}
-
-void flash_init(bool mode_pol_inv,bool led1_pol_inv,bool pin_mux_inv,wave_t *wave_param)
-{
-        wave_init(wave_param);
-        // MODE pin
-        //if (mode_pol_inv)
-		//set_mode_low();
-	//else
-		//set_mode_high();
-	// EN/SET pin
-	WRITE_CBUS_REG(ISP_LED_CTRL, (led1_pol_inv<<29)|(pin_mux_inv<<27)|(1<<26)|(1<<24));
-        WRITE_CBUS_REG(ISP_LED_TIMING1, 0);
-        WRITE_CBUS_REG(ISP_LED_TIMING2, 0);
-        WRITE_CBUS_REG(ISP_LED_TIMING3, wave_param->latch_time_timeout);
-        WRITE_CBUS_REG(ISP_LED_TIMING4, wave_param->latch_time);
-        WRITE_CBUS_REG(ISP_LED_TIMING5, 0);
-        WRITE_CBUS_REG(ISP_LED_TIMING6, wave_param->time_to_latch);
-}
-
-void torch_init(bool mode_pol_inv,bool led1_pol_inv,bool pin_mux_inv,bool torch_pol_inv,wave_t *wave_param,unsigned int level)
-{
-        unsigned int pulse_qty = 0;
-
-	wave_init(wave_param);
-	// MODE pin
-	//if (mode_pol_inv)
-		//set_mode_high();
-	//else
-		//set_mode_low();
-	// EN/SET pin
-	pulse_qty = level*wave_param->pulse_qty_max/100;
-	if (pulse_qty > wave_param->pulse_qty_max - 1)
-		pulse_qty = wave_param->pulse_qty_max - 1;
-	if (!torch_pol_inv)
-		pulse_qty = wave_param->pulse_qty_max - 1 - pulse_qty;
-	WRITE_CBUS_REG(ISP_LED_CTRL, (led1_pol_inv<<29)|(pin_mux_inv<<27)|(1<<26)|(pulse_qty<<12)|(wave_param->pulse_init_time<<0));
-	WRITE_CBUS_REG(ISP_LED_TIMING1, 0);
-	WRITE_CBUS_REG(ISP_LED_TIMING2, (wave_param->pulse_high_time<<21)|(wave_param->pulse_low_time<<10));
-	WRITE_CBUS_REG(ISP_LED_TIMING3, 0);
-	WRITE_CBUS_REG(ISP_LED_TIMING4, 0x03ffffff);
-	WRITE_CBUS_REG(ISP_LED_TIMING5, (wave_param->time_to_off&0x0000003f)<<26);
-	WRITE_CBUS_REG(ISP_LED_TIMING6, ((wave_param->time_to_off>>6)<<26)|wave_param->time_to_latch);
-}
-
-static void wave_on(bool enable)
-{
-	if(enable) {
-        WRITE_CBUS_REG_BITS(ISP_LED_CTRL,1,31,1);
-        WRITE_CBUS_REG_BITS(HHI_ISP_LED_CLK_CNTL,1,16,1);
-    } else
-		WRITE_CBUS_REG_BITS(ISP_LED_CTRL,0,31,1);
-}
-
-void flash_on(bool mode_pol_inv,bool led1_pol_inv,bool pin_mux_inv,wave_t *wave_param)
-{
-        wave_on(false);
-	flash_init(mode_pol_inv,led1_pol_inv,pin_mux_inv,wave_param);
-	wave_on(true);
-}
-
-void torch_level(bool mode_pol_inv,bool led1_pol_inv,bool pin_mux_inv,bool torch_pol_inv,wave_t *wave_param,unsigned int level)
-{
-        wave_on(false);
-	// torch on
-        if (level) {
-	        torch_init(mode_pol_inv,led1_pol_inv,pin_mux_inv,torch_pol_inv,wave_param,level);
-		wave_on(true);
-	}
-}
-
-
-void wave_power_manage(bool enable)
-{
-	if(enable)
-    	// clock enable
-    	        WRITE_CBUS_REG_BITS(HHI_ISP_LED_CLK_CNTL,1,16,1);
-	else
-	// clock disable
-    	        WRITE_CBUS_REG_BITS(HHI_ISP_LED_CLK_CNTL,0,16,1);
-}
-
-/*only adjust g0 r1 b2 g3*/
-void isp_set_manual_wb(xml_wb_manual_t *wb)
-{
-	WR(ISP_GAIN_GRBG01,wb->reg_map[0]);
-	WR(ISP_GAIN_GRBG23,wb->reg_map[1]);
-}
-
-void isp_wr(unsigned int addr,unsigned int data)
-{
-	WR(ISP_RO_ADDR_PORT,addr);
-	WR(ISP_RO_DATA_PORT,data);
-}
-
-unsigned int isp_rd(unsigned int addr)
-{
-	WR(ISP_RO_ADDR_PORT,addr);
-        return(RD(ISP_RO_DATA_PORT));
-}
-/*
-*reg 0x00~0x1b
-*/
-void isp_get_awb_stat(isp_awb_stat_t *awb_stat)
-{
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_RED_SUM);
-	awb_stat->rgb.rgb_sum[0] = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_GRN_SUM);
-	awb_stat->rgb.rgb_sum[1] = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_BLU_SUM);
-	awb_stat->rgb.rgb_sum[2] = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_RGB_NUM);
-	awb_stat->rgb.rgb_count = RD_BITS(ISP_RO_DATA_PORT,AWB_RGB_NUM_BIT,AWB_RGB_NUM_WID);
-
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_UNEG_SUM);
-	awb_stat->yuv_low[0].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_VNEG_SUM);
-	awb_stat->yuv_low[1].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_UPOS_SUM);
-	awb_stat->yuv_low[2].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_VPOS_SUM);
-	awb_stat->yuv_low[3].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_UNEG_NUM);
-	awb_stat->yuv_low[0].count = RD_BITS(ISP_RO_DATA_PORT,AWB_LOW_UNEG_NUM_BIT,AWB_LOW_UNEG_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_VNEG_NUM);
-	awb_stat->yuv_low[1].count = RD_BITS(ISP_RO_DATA_PORT,AWB_LOW_VNEG_NUM_BIT,AWB_LOW_VNEG_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_UPOS_NUM);
-	awb_stat->yuv_low[2].count = RD_BITS(ISP_RO_DATA_PORT,AWB_LOW_UPOS_NUM_BIT,AWB_LOW_UPOS_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_LOW_VPOS_NUM);
-	awb_stat->yuv_low[3].count = RD_BITS(ISP_RO_DATA_PORT,AWB_LOW_VPOS_NUM_BIT,AWB_LOW_VPOS_NUM_WID);
-
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_UNEG_SUM);
-	awb_stat->yuv_mid[0].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_VNEG_SUM);
-	awb_stat->yuv_mid[1].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_UPOS_SUM);
-	awb_stat->yuv_mid[2].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_VPOS_SUM);
-	awb_stat->yuv_mid[3].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_UNEG_NUM);
-	awb_stat->yuv_mid[0].count = RD_BITS(ISP_RO_DATA_PORT,AWB_MID_UNEG_NUM_BIT,AWB_MID_UNEG_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_VNEG_NUM);
-	awb_stat->yuv_mid[1].count = RD_BITS(ISP_RO_DATA_PORT,AWB_MID_VNEG_NUM_BIT,AWB_MID_VNEG_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_UPOS_NUM);
-	awb_stat->yuv_mid[2].count = RD_BITS(ISP_RO_DATA_PORT,AWB_MID_UPOS_NUM_BIT,AWB_MID_UPOS_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_MID_VPOS_NUM);
-	awb_stat->yuv_mid[3].count = RD_BITS(ISP_RO_DATA_PORT,AWB_MID_VPOS_NUM_BIT,AWB_MID_VPOS_NUM_WID);
-
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_UNEG_SUM);
-	awb_stat->yuv_high[0].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_VNEG_SUM);
-	awb_stat->yuv_high[1].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_UPOS_SUM);
-	awb_stat->yuv_high[2].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_VPOS_SUM);
-	awb_stat->yuv_high[3].sum = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_UNEG_NUM);
-	awb_stat->yuv_high[0].count = RD_BITS(ISP_RO_DATA_PORT,AWB_HIG_UNEG_NUM_BIT,AWB_HIG_UNEG_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_VNEG_NUM);
-	awb_stat->yuv_high[1].count = RD_BITS(ISP_RO_DATA_PORT,AWB_HIG_VNEG_NUM_BIT,AWB_HIG_VNEG_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_UPOS_NUM);
-	awb_stat->yuv_high[2].count = RD_BITS(ISP_RO_DATA_PORT,AWB_HIG_UPOS_NUM_BIT,AWB_HIG_UPOS_NUM_WID);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AWB_HIG_VPOS_NUM);
-	awb_stat->yuv_high[3].count = RD_BITS(ISP_RO_DATA_PORT,AWB_HIG_VPOS_NUM_BIT,AWB_HIG_VPOS_NUM_WID);
-
-	return;
-}
-/*
-*reg 0x1c~0x2e
-*/
-void isp_get_ae_stat(isp_ae_stat_t *ae_stat)
-{
-	int i = 0;
-	/*0x1c~0x2b*/
-	for(i=0;i<16;i++){
-		WR(ISP_RO_ADDR_PORT, ISP_RO_AEC_LUMA_WIND0_0+i);
-		ae_stat->luma_win[i] = RD(ISP_RO_DATA_PORT);
-	}
-
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AECRAW_NUM_RED);
-	ae_stat->bayer_over_info[0] = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AECRAW_NUM_GREEN);
-	ae_stat->bayer_over_info[1] = RD(ISP_RO_DATA_PORT);
-	WR(ISP_RO_ADDR_PORT, ISP_RO_AECRAW_NUM_BLUE);
-	ae_stat->bayer_over_info[2] = RD(ISP_RO_DATA_PORT);
-
-	return;
-}
-
-void isp_set_ae_win(unsigned int left, unsigned int right, unsigned int top, unsigned int bottom)
-{
-	WR_BITS(ISP_AECRAW_WIND_LR, left, AECRAW_WIND_LEFT_BIT, AECRAW_WIND_LEFT_WID);
-	WR_BITS(ISP_AECRAW_WIND_LR, right, AECRAW_WIND_RIGHT_BIT, AECRAW_WIND_RIGHT_WID);
-	WR_BITS(ISP_AECRAW_WIND_TB, top, AECRAW_WIND_TOP_BIT, AECRAW_WIND_TOP_WID);
-	WR_BITS(ISP_AECRAW_WIND_TB, bottom, AECRAW_WIND_BOT_BIT, AECRAW_WIND_BOT_WID);
-
-	WR_BITS(ISP_AEC_WIND_XYSTART, left, AEC_WIND_XSTART_BIT, AEC_WIND_XSTART_WID);
-	WR_BITS(ISP_AEC_WIND_XYSTART, top, AEC_WIND_YSTART_BIT, AEC_WIND_YSTART_WID);
-	WR_BITS(ISP_AEC_WIND_XYSTEP, (right-left+1)>>2, AEC_WIND_XSTEP_BIT, AEC_WIND_XSTEP_WID);
-	WR_BITS(ISP_AEC_WIND_XYSTEP, (bottom-top+1)>>2, AEC_WIND_YSTEP_BIT, AEC_WIND_YSTEP_WID);
-}
-
-void isp_set_awb_win(unsigned int left, unsigned int right, unsigned int top, unsigned int bottom)
-{
-	WR_BITS(ISP_AWB_WIND_LR, left, AWB_WIND_LEFT_BIT, AWB_WIND_LEFT_BIT);
-	WR_BITS(ISP_AWB_WIND_LR, right, AWB_WIND_RIGHT_BIT, AWB_WIND_RIGHT_WID);
-	WR_BITS(ISP_AWB_WIND_TB, top, AWB_WIND_TOP_BIT, AWB_WIND_TOP_WID);
-	WR_BITS(ISP_AWB_WIND_TB, bottom, AWB_WIND_BOT_BIT, AWB_WIND_BOT_WID);
-}
-
-void isp_set_ae_thrlpf(unsigned char thr_r, unsigned char thr_g, unsigned char thr_b, unsigned char lpf)
-{
-	WR_BITS(ISP_AEC_THRESHOLDS, thr_r, AEC_RAWBRIGHT_R_BIT, AEC_RAWBRIGHT_R_WID);
-	WR_BITS(ISP_AEC_THRESHOLDS, thr_g, AEC_RAWBRIGHT_G_BIT, AEC_RAWBRIGHT_G_WID);
-	WR_BITS(ISP_AEC_THRESHOLDS, thr_b, AEC_RAWBRIGHT_B_BIT, AEC_RAWBRIGHT_B_WID);
-	WR_BITS(ISP_CLAMPGAIN_CTRL, lpf, AECRAW_LPF_SEL_BIT, AECRAW_LPF_SEL_WID);
-}
-
-void isp_set_awb_yuv_thr(unsigned char yh, unsigned char yl, unsigned char u, unsigned char v)
-{
-	WR_BITS(ISP_AWB_UVTH_YPIECE, yh, AWB_YPIECE_HIG_BIT, AWB_YPIECE_HIG_WID);
-	WR_BITS(ISP_AWB_UVTH_YPIECE, yl, AWB_YPIECE_LOW_BIT, AWB_YPIECE_LOW_WID);
-	WR_BITS(ISP_AWB_UVTH_YPIECE, u, AWB_U_THRD_BIT, AWB_U_THRD_WID);
-	WR_BITS(ISP_AWB_UVTH_YPIECE, v, AWB_V_THRD_BIT, AWB_V_THRD_WID);
-}
-
-void isp_set_awb_rgb_thr(unsigned char gb, unsigned char gr, unsigned br)
-{
-	WR_BITS(ISP_AWB_GBGRBR_THRD, gb, AWB_GB_THRD_BIT, AWB_GB_THRD_WID);
-	WR_BITS(ISP_AWB_GBGRBR_THRD, gr, AWB_GR_THRD_BIT, AWB_GR_THRD_WID);
-	WR_BITS(ISP_AWB_GBGRBR_THRD, br, AWB_BR_THRD_BIT, AWB_BR_THRD_WID);
-}
-
-void isp_get_af_stat(isp_af_stat_t * af_stat)
-{
-	int i = 0;
-	/*0xbc~0xc6*/
-	if(IS_ERR_OR_NULL(af_stat)){
-		pr_info("%s null pointer error.\n",__func__);
-	} else {
-	for(i=0;i<16;i++)
-		af_stat->luma_win[i]=isp_rd(ISP_RO_AFC_WIND0_F0 + i);
-	}
-	return;
-}
-void isp_get_af_scan_stat(isp_blnr_stat_t *blnr_stat)
-{
-	int i = 0;
-	for(i=0;i<16;i++){
-		blnr_stat->af_ac[i] = isp_rd(ISP_RO_AFC_WIND0_F0 + i);
-	}
-}
-void isp_get_blnr_stat(isp_blnr_stat_t *blnr_stat)
-{
-	int i = 0;
-
-	for(i=0;i<4;i++){
-		blnr_stat->dc[i] = isp_rd(ISP_RO_BLNR_GRBG_DCSUM0+i);
-		blnr_stat->ac[i] = isp_rd(ISP_RO_BLNR_GRBG_ACSUM0+i);
-	}
-
-	return;
-}
-
-void isp_hw_reset()
-{
-	WR_BITS(ISP_TIMING_MODE,1,5,1);
-	WR_BITS(ISP_FRM_SOFT_RST,1,0,1);
-	WR_BITS(ISP_FRM_SOFT_RST,0,0,1);
-	WR_BITS(ISP_FRM_SOFT_RST,1,0,1);
-	WR_BITS(ISP_FRM_SOFT_RST,0,0,1);
-	WR_BITS(ISP_TIMING_MODE,0,5,1);
-}
-
-void isp_awb_set_gain(unsigned int r,unsigned int g,unsigned int b)
-{
-	WR_BITS(ISP_GAIN_GRBG01, g, GAIN_GRBG0_BIT, GAIN_GRBG0_WID);
-	WR_BITS(ISP_GAIN_GRBG01, r, GAIN_GRBG1_BIT, GAIN_GRBG1_WID);
-	WR_BITS(ISP_GAIN_GRBG23, b, GAIN_GRBG2_BIT, GAIN_GRBG2_WID);
-	WR_BITS(ISP_GAIN_GRBG23, g, GAIN_GRBG3_BIT, GAIN_GRBG3_WID);
-}
-
-void isp_awb_get_gain(isp_awb_gain_t *awb_gain)
-{
-	awb_gain->b_val = RD_BITS(ISP_GAIN_GRBG23, GAIN_GRBG2_BIT, GAIN_GRBG2_WID);
-	awb_gain->r_val = RD_BITS(ISP_GAIN_GRBG01, GAIN_GRBG1_BIT, GAIN_GRBG1_WID);
-	awb_gain->g_val = RD_BITS(ISP_GAIN_GRBG01, GAIN_GRBG0_BIT, GAIN_GRBG0_WID);
-}
-
-void set_isp_gamma_table(unsigned short *gamma,unsigned int type)
-{
-	unsigned int flag = 0,i = 0;
-
-        // store gamma table enable/disable status
-        flag = (RD_BITS(ISP_GMR0_CTRL,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID))|gamma_enable;
-
-        // gamma table disable, gamma table vbus mode
-        WR_BITS(ISP_GMR0_CTRL,0,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-	WR_BITS(ISP_GMR0_CTRL,1,GCLUT_ACCMODE_BIT,GCLUT_ACCMODE_WID);
-        // point to gamma
-        WR(ISP_GAMMA_LUT_ADDR, type);
-        // write gamma
-        for (i = 0; i < 257; i++) {
-                WR(ISP_GAMMA_LUT_DATA, gamma[i]);
-        }
-
-        // retrieve gamma table enable/disable status, gamma table hardware mode
-        WR_BITS(ISP_GMR0_CTRL, flag,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-	WR_BITS(ISP_GMR0_CTRL,0,GCLUT_ACCMODE_BIT,GCLUT_ACCMODE_WID);
-
-}
-void get_isp_gamma_table(unsigned short *gamma,unsigned int type)
-{
-	unsigned int flag = 0,i = 0;
-
-        // store gamma table enable/disable status
-        flag = RD_BITS(ISP_GMR0_CTRL,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-
-        // gamma table disable, gamma table vbus mode
-        WR_BITS(ISP_GMR0_CTRL,0,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-	WR_BITS(ISP_GMR0_CTRL,1,GCLUT_ACCMODE_BIT,GCLUT_ACCMODE_WID);
-        // point to gamma
-        WR(ISP_GAMMA_LUT_ADDR, type);
-        // get gamma
-        for (i = 0; i < 257; i++) {
-                gamma[i] = RD(ISP_GAMMA_LUT_DATA);
-        }
-
-        // retrieve gamma table enable/disable status, gamma table hardware mode
-        WR_BITS(ISP_GMR0_CTRL, flag,GMR_CORRECT_ENABLE_BIT,GMR_CORRECT_ENABLE_WID);
-	WR_BITS(ISP_GMR0_CTRL,0,GCLUT_ACCMODE_BIT,GCLUT_ACCMODE_WID);
-}
-
-/*
-* lens-shading debug start
-*/
-static unsigned long long div64(unsigned long long n, unsigned long long d) // n for numerator, d for denominator
-{
-    unsigned int n_bits = 0, d_bits = 0, i = 0;
-    unsigned long long q = 0, t = 0; // q for quotient, t for temporary
-    // invalid
-    if (!d) {
-        q = 0xffffffffffffffff;
-    }
-    // (0.5, 0]
-    else if (n + n < d) {
-        q = 0;
-    }
-    // [1.0, 0.5]
-    else if (n <= d) {
-        q = 1;
-    }
-    // [max, 1.0)
-    else
-    {
-        // get n_bits
-        for (n_bits = 1; n_bits <= 64; n_bits++)
-            if (!(n >> n_bits))
-                break;
-        if (n_bits > 64)
-		n_bits = 64;
-		// get d_bits
-        for (d_bits = 1; d_bits <= 64; d_bits++)
-            if (!(d >> d_bits))
-                break;
-        if (d_bits > 64)
-            d_bits = 64;
-        // check integer part
-        for (i = n_bits; i >= d_bits; i--) {
-            q <<= 1;
-            t = d << (i - d_bits);
-            if (n >= t)
-            {
-                n -= t;
-                q += 1;
-            }
-        }
-        // check fraction part
-        if (n + n >= d)
-            q += 1;
-    }
-    return q;
-}
-
-static unsigned int phase_curve_grid(unsigned int curvature, unsigned int gain_0db, unsigned int dx, unsigned int dy, unsigned int rradium)
-{
-    unsigned int data = 0;
-
-    if (curvature > 100)
-    {
-        data = (unsigned int)div64((unsigned long long)gain_0db*(unsigned long long)(curvature - 100)*(unsigned long long)(dx*dx + dy*dy), (unsigned long long)rradium*(unsigned long long)100);
-        data = gain_0db + data;
-        if (data > 255)
-        {
-            data = 255;
-        }
-    }
-    else if (curvature < 100)
-    {
-        data = (unsigned int)div64((unsigned long long)gain_0db*(unsigned long long)(100 - curvature)*(unsigned long long)(dx*dx + dy*dy), (unsigned long long)rradium*(unsigned long long)100);
-        if (data > gain_0db)
-        {
-            data = 0;
-        }
-        else
-        {
-            data = gain_0db - data;
-        }
-    }
-    else
-    {
-        data = gain_0db;
-    }
-
-    return(data);
-}
-
-void isp_ls_curve(unsigned int psize_v2h,    // pixel_size_percentage_vertical_to_horizontal (default is 100), given 1.4um*1.4um, it is:
-                                             // 100(%) for p2p format
-                                             // 100(%) for skipping format
-                                             // 100(%) for 2*2 binning format
-                                             // 100(%) for 4*4 binning format
-                                             //  50(%) for 2*1 binning format
-                                             //  50(%) for 4*2 binning format
-                  unsigned int hactive,      // given 1080p, this value is 1920, default is 1920
-                  unsigned int vactive,      // given 1080p, this value is 1080, default is 1080
-                  unsigned int ocenter_c2l,  // optical_center_percentage_center_to_left (default is 50), given centralized, this value is 50(%)
-                  unsigned int ocenter_c2t,  // optical_center_percentage_center_to_top  (default is 50), given centralized, this value is 50(%)
-                  unsigned int gain_0db,     // gain_0db (default is 0)
-                                             // 0 for 128
-                                             // 1 for 64
-                                             // 2 for 32
-                                             // 3 for 16
-                  unsigned int curvature_gr, //   0: corner_gain = 0.0*gain_0db, minimum
-                                             // 100: corner_gain = 1.0*gain_0db, default
-                                             // 200: corner_gain = 2.0*gain_0db, maximum
-                  unsigned int curvature_r,  //   0: corner_gain = 0.0*gain_0db, minimum
-                                             // 100: corner_gain = 1.0*gain_0db, default
-                                             // 200: corner_gain = 2.0*gain_0db, maximum
-                  unsigned int curvature_b,  //   0: corner_gain = 0.0*gain_0db, minimum
-                                             // 100: corner_gain = 1.0*gain_0db, default
-                                             // 200: corner_gain = 2.0*gain_0db, maximum
-                  unsigned int curvature_gb, //   0: corner_gain = 0.0*gain_0db, minimum
-                                             // 100: corner_gain = 1.0*gain_0db, default
-                                             // 200: corner_gain = 2.0*gain_0db, maximum
-                  bool         force_enable  //   0: keep original disable/enable status
-                                             //   1: force to enable lens shielding
-                  )
-{
-    unsigned int haxis[32], vaxis[32], curve[32][32];
-    unsigned int hmax = 0, vmax = 0, vcenter = 0, hcenter = 0, rradium = 0, xscale = 0, yscale = 0;
-    unsigned int i = 0, j = 0, dx = 0, dy = 0, data = 0, control = READ_VCBUS_REG(0x2d28);
-
-    // validation
-    if ((psize_v2h < 50) || (psize_v2h > 200))
-    {
-        psize_v2h = 100;
-        pr_info(" pixel size too narrow!!!!! \n");
-    }
-#if 0
-    if ((!hactive) || (!vactive))
-    {
-        hactive = 1920;
-        vactive = 1080;
-    }
-#endif
-    if ((!ocenter_c2l) || (ocenter_c2l > 100))
-    {
-        ocenter_c2l = 50;
-    }
-    if ((!ocenter_c2t) || (ocenter_c2t > 100))
-    {
-        ocenter_c2t = 50;
-    }
-    control &= 0xffff8fff; // lens shielding mux : normal
-    control &= 0xffff7fff; // lens shielding mode: z
-    control &= 0xff00ffff; // clear lens shielding pre_gain_shift
-    switch (gain_0db)
-    {
-        case 0:
-            control |= 0x00000000; // set lens shielding pre_gain_shift
-            gain_0db = 128;
-            break;
-        case 1:
-            control |= 0x00550000; // set lens shielding pre_gain_shift
-            gain_0db = 64;
-            break;
-        case 2:
-            control |= 0x00aa0000; // set lens shielding pre_gain_shift
-            gain_0db = 32;
-            break;
-        case 3:
-            control |= 0x00ff0000; // set lens shielding pre_gain_shift
-            gain_0db = 16;
-            break;
-        default:
-            control |= 0x00000000; // set lens shielding pre_gain_shift
-            gain_0db = 128;
-            break;
-    }
-
-    // variables
-    hmax    = hactive - 1;
-    vmax    = vactive - 1;
-    hcenter = (hmax*ocenter_c2l + 50)/100;
-    vcenter = (vmax*ocenter_c2t + 50)/100;
-    rradium = (unsigned int)div64((unsigned long long)hmax*(unsigned long long)hmax*(unsigned long long)10000 + (unsigned long long)vmax*(unsigned long long)vmax*(unsigned long long)psize_v2h*(unsigned long long)psize_v2h + (unsigned long long)20000, (unsigned long long)40000);
-    xscale  = (7935*32*2 + hmax)/(hmax + hmax);
-    if (xscale > 0x00000fff)
-    {
-        xscale = 0x00000fff;
-    }
-    yscale  = (7935*32*2 + vmax)/(vmax + vmax);
-    if (yscale > 0x00000fff)
-    {
-        yscale = 0x00000fff;
-    }
-#if 0
-    pr_info("hmax:%u vmax:%u hcenter:%u vcenter:%u rradium:%u xscale:%u yscale:%u \n",
-             hmax,vmax,hcenter,vcenter,rradium,xscale,yscale);
-#endif
-    for (i = 0; i < 32; i++)
-    {
-        haxis[i] = (i*256*32*2 + xscale)/(xscale + xscale);
-        vaxis[i] = (i*256*32*2 + yscale)/(yscale + yscale);
-    }
-#if 0
-    pr_info(" haxis----\n");
-    pr_info("%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u \n", \
-         haxis[0], haxis[1], haxis[2], haxis[3], haxis[4], haxis[5], haxis[6], haxis[7], haxis[8], haxis[9], \
-        haxis[10],haxis[11],haxis[12],haxis[13],haxis[14],haxis[15],haxis[16],haxis[17],haxis[18],haxis[19],\
-        haxis[20],haxis[21],haxis[22],haxis[23],haxis[24],haxis[25],haxis[26],haxis[27],haxis[28],haxis[29],\
-        haxis[30],haxis[31]);
-    pr_info(" vaxis----\n");
-    pr_info("%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u \n", \
-         vaxis[0], vaxis[1], vaxis[2], vaxis[3], vaxis[4], vaxis[5], vaxis[6], vaxis[7], vaxis[8], vaxis[9], \
-        vaxis[10],vaxis[11],vaxis[12],vaxis[13],vaxis[14],vaxis[15],vaxis[16],vaxis[17],vaxis[18],vaxis[19],\
-        vaxis[20],vaxis[21],vaxis[22],vaxis[23],vaxis[24],vaxis[25],vaxis[26],vaxis[27],vaxis[28],vaxis[29],\
-        vaxis[30],vaxis[31]);
-#endif
-    // write lut
-    WRITE_VCBUS_REG(0x2d28, control&0xefffffff); // disable lens shielding
-    WRITE_VCBUS_REG(0x2d29, (xscale << 16)|
-                           (yscale << 0));      // lens shielding xscale & yscale
-    WRITE_VCBUS_REG(0x2d2a, 0x00000000);         // lens shielding xoffset = yoffset = 0
-    WRITE_VCBUS_REG(0x2d2b, 0x80808080);         // lens shielding pre_gain = 0.5
-    WRITE_VCBUS_REG(0x2d2c, 0x00000000);         // lens shielding post_offset = 0
-    WRITE_VCBUS_REG(0x2daf, 0x0000000c);         // lens shielding lut ram: v-bus write mode
-    WRITE_VCBUS_REG(0x2dc6, 0x00000000);         // point to head of ram
-    for (i = 0; i < 32; i++)
-    {
-        for (j = 0; j < 32; j++)
-        {
-            dx = (haxis[j] > hcenter) ? (haxis[j] - hcenter) : (hcenter - haxis[j]);
-            dy = (vaxis[i] > vcenter) ? (vaxis[i] - vcenter) : (vcenter - vaxis[i]);
-            dy = (dy*psize_v2h + 50)/100;
-            curve[i][j] = (phase_curve_grid(curvature_gr, gain_0db, dx, dy, rradium) << 24)|
-                          (phase_curve_grid(curvature_r,  gain_0db, dx, dy, rradium) << 16)|
-                          (phase_curve_grid(curvature_b,  gain_0db, dx, dy, rradium) <<  8)|
-                          (phase_curve_grid(curvature_gb, gain_0db, dx, dy, rradium) <<  0);
-            WRITE_VCBUS_REG(0x2dc7, curve[i][j]);
-        }
-    }
-    WRITE_VCBUS_REG(0x2daf, 0x00000000); // lens shielding lut ram: hardware read mode
-
-    // disable/enable
-    if (force_enable)
-    {
-        //WRITE_VCBUS_REG(0x2d28, backup|0x10000000); // force to enable lens shielding
-        WRITE_VCBUS_REG_BITS(0x2d28, 1, LNS_CMOP_ENABLE_BIT, LNS_CMOP_ENABLE_WID);
-    }
-    else
-    {
-        //WRITE_VCBUS_REG(0x2d28, backup); // retrieve original disable/enable status
-        WRITE_VCBUS_REG_BITS(0x2d28, 0, LNS_CMOP_ENABLE_BIT, LNS_CMOP_ENABLE_WID);
-    }
-    pr_info(" Gb----\n");
-    for (i = 0; i < 32; i++) {
-        pr_info("%3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %u %3u %3u \n", \
-         curve[i][0]&0xff, curve[i][1]&0xff, curve[i][2]&0xff, curve[i][3]&0xff, curve[i][4]&0xff, curve[i][5]&0xff, curve[i][6]&0xff, curve[i][7]&0xff, curve[i][8]&0xff, curve[i][9]&0xff, \
-        curve[i][10]&0xff,curve[i][11]&0xff,curve[i][12]&0xff,curve[i][13]&0xff,curve[i][14]&0xff,curve[i][15]&0xff,curve[i][16]&0xff,curve[i][17]&0xff,curve[i][18]&0xff,curve[i][19]&0xff,\
-        curve[i][20]&0xff,curve[i][21]&0xff,curve[i][22]&0xff,curve[i][23]&0xff,curve[i][24]&0xff,curve[i][25]&0xff,curve[i][26]&0xff,curve[i][27]&0xff,curve[i][28]&0xff,curve[i][29]&0xff,\
-        curve[i][30]&0xff,curve[i][31]&0xff);
-    }
-    pr_info(" B----\n");
-    for (i = 0; i < 32; i++) {
-        pr_info("%3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %u %3u %3u \n", \
-        ( curve[i][0]>>8)&0xff,( curve[i][1]>>8)&0xff,( curve[i][2]>>8)&0xff,( curve[i][3]>>8)&0xff,( curve[i][4]>>8)&0xff,( curve[i][5]>>8)&0xff,( curve[i][6]>>8)&0xff,( curve[i][7]>>8)&0xff,( curve[i][8]>>8)&0xff,( curve[i][9]>>8)&0xff, \
-        (curve[i][10]>>8)&0xff,(curve[i][11]>>8)&0xff,(curve[i][12]>>8)&0xff,(curve[i][13]>>8)&0xff,(curve[i][14]>>8)&0xff,(curve[i][15]>>8)&0xff,(curve[i][16]>>8)&0xff,(curve[i][17]>>8)&0xff,(curve[i][18]>>8)&0xff,(curve[i][19]>>8)&0xff,\
-        (curve[i][20]>>8)&0xff,(curve[i][21]>>8)&0xff,(curve[i][22]>>8)&0xff,(curve[i][23]>>8)&0xff,(curve[i][24]>>8)&0xff,(curve[i][25]>>8)&0xff,(curve[i][26]>>8)&0xff,(curve[i][27]>>8)&0xff,(curve[i][28]>>8)&0xff,(curve[i][29]>>8)&0xff,\
-        (curve[i][30]>>8)&0xff,(curve[i][31]>>8)&0xff);
-    }
-    pr_info(" R----\n");
-    for (i = 0; i < 32; i++) {
-        pr_info("%3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %u %3u %3u \n", \
-        ( curve[i][0]>>16)&0xff,( curve[i][1]>>16)&0xff,( curve[i][2]>>16)&0xff,( curve[i][3]>>16)&0xff,( curve[i][4]>>16)&0xff,( curve[i][5]>>16)&0xff,( curve[i][6]>>16)&0xff,( curve[i][7]>>16)&0xff,( curve[i][8]>>16)&0xff,( curve[i][9]>>16)&0xff, \
-        (curve[i][10]>>16)&0xff,(curve[i][11]>>16)&0xff,(curve[i][12]>>16)&0xff,(curve[i][13]>>16)&0xff,(curve[i][14]>>16)&0xff,(curve[i][15]>>16)&0xff,(curve[i][16]>>16)&0xff,(curve[i][17]>>16)&0xff,(curve[i][18]>>16)&0xff,(curve[i][19]>>16)&0xff,\
-        (curve[i][20]>>16)&0xff,(curve[i][21]>>16)&0xff,(curve[i][22]>>16)&0xff,(curve[i][23]>>16)&0xff,(curve[i][24]>>16)&0xff,(curve[i][25]>>16)&0xff,(curve[i][26]>>16)&0xff,(curve[i][27]>>16)&0xff,(curve[i][28]>>16)&0xff,(curve[i][29]>>16)&0xff,\
-        (curve[i][30]>>16)&0xff,(curve[i][31]>>16)&0xff);
-    }
-    pr_info(" Gr----\n");
-    for (i = 0; i < 32; i++) {
-        pr_info("%3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %3u %u %3u %3u \n", \
-        ( curve[i][0]>>24)&0xff,( curve[i][1]>>24)&0xff,( curve[i][2]>>24)&0xff,( curve[i][3]>>24)&0xff,( curve[i][4]>>24)&0xff,( curve[i][5]>>24)&0xff,( curve[i][6]>>24)&0xff,( curve[i][7]>>24)&0xff,( curve[i][8]>>24)&0xff,( curve[i][9]>>24)&0xff, \
-        (curve[i][10]>>24)&0xff,(curve[i][11]>>24)&0xff,(curve[i][12]>>24)&0xff,(curve[i][13]>>24)&0xff,(curve[i][14]>>24)&0xff,(curve[i][15]>>24)&0xff,(curve[i][16]>>24)&0xff,(curve[i][17]>>24)&0xff,(curve[i][18]>>24)&0xff,(curve[i][19]>>24)&0xff,\
-        (curve[i][20]>>24)&0xff,(curve[i][21]>>24)&0xff,(curve[i][22]>>24)&0xff,(curve[i][23]>>24)&0xff,(curve[i][24]>>24)&0xff,(curve[i][25]>>24)&0xff,(curve[i][26]>>24)&0xff,(curve[i][27]>>24)&0xff,(curve[i][28]>>24)&0xff,(curve[i][29]>>24)&0xff,\
-        (curve[i][30]>>24)&0xff,(curve[i][31]>>24)&0xff);
-    }
-    pr_info(" -------end------\n");
-
-}
diff --git a/drivers/amlogic/tvin/isp/isp_hw.h b/drivers/amlogic/tvin/isp/isp_hw.h
deleted file mode 100755
index f8c471960a7d..000000000000
--- a/drivers/amlogic/tvin/isp/isp_hw.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * ISP driver
- *
- * Author: Kele Bai <kele.bai@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- 
- */
-#ifndef __TVIN_ISP_HW_H
-#define __TVIN_ISP_HW_H
-
-#if 0
-#define WR(x,val)                           printk("0x%x <- 0x%x.\n",x,val)
-#define WR_BITS(x,val,start,length)    	    printk("0x%x[%u:%u] <- 0x%x.\n",x,start,start+length-1,val)
-#define RD(x)                               printk("read 0x%x.\n",x)
-#define RD_BITS(x,start,length)             printk("read 0x%x[%u:%u].\n",x,start,start+length-1)
-#else
-#define WR(x,val)                         WRITE_VCBUS_REG(x,val)
-#define WR_BITS(x,val,start,length)       WRITE_VCBUS_REG_BITS(x,val,start,length)
-#define RD(x)                             READ_VCBUS_REG(x)
-#define RD_BITS(x,start,length)           READ_VCBUS_REG_BITS(x,start,length)
-
-#endif
-
-#define GAMMA_R				0x00000000
-#define GAMMA_G				0x00000200
-#define GAMMA_B				0x00000400
-
-typedef struct awb_rgb_stat_s {
-	unsigned int rgb_count;
-	unsigned int rgb_sum[3];// r g b
-} awb_rgb_stat_t;
-
-typedef struct awb_yuv_stat_s {
-	unsigned int count;
-	unsigned int sum;
-} awb_yuv_stat_t;
-
-typedef struct isp_awb_stat_s {
-	awb_rgb_stat_t rgb;//R G B
-	awb_yuv_stat_t yuv_low[4];//y < low    0, -u; 1, +u; 2, -v; 3, +v
-	awb_yuv_stat_t yuv_mid[4];
-	awb_yuv_stat_t yuv_high[4];//y > high
-} isp_awb_stat_t;
-
-typedef struct isp_ae_stat_s {
-	unsigned int bayer_over_info[3];//R G B
-	unsigned int luma_win[16];
-	unsigned char curstep;
-	float curgain;
-	float maxgain;
-	float mingain;
-	unsigned char maxstep;
-} isp_ae_stat_t;
-
-typedef struct isp_af_stat_s {
-	unsigned int bayer_over_info[3];//R G B
-	unsigned int luma_win[16];
-} isp_af_stat_t;
-
-typedef struct isp_awb_gain_s {
-	unsigned int r_val;
-	unsigned int g_val;
-	unsigned int b_val;
-} isp_awb_gain_t;
-
-typedef struct isp_blnr_stat_s {
-	unsigned int ac[4];//G0 R1 B2 G3
-	unsigned int dc[4];//G0 R1 B2 G3
-	unsigned int af_ac[16];
-} isp_blnr_stat_t;
-
-extern void isp_wr(unsigned int addr,unsigned int value);
-extern unsigned int isp_rd(unsigned int addr);
-extern void isp_top_init(xml_top_t *top,unsigned int w,unsigned int h);
-extern void isp_set_test_pattern(xml_tp_t *tp);
-extern void isp_set_clamp_gain(xml_cg_t *cg);
-extern void isp_set_lens_shading(xml_ls_t *ls);
-void isp_set_gamma_correction(xml_gc_t *gc);
-extern void isp_set_defect_pixel_correction(xml_dp_t *dp);
-extern void isp_set_demosaicing(xml_dm_t *dm);
-extern void isp_set_matrix(xml_csc_t *csc,unsigned int height);
-extern void isp_set_sharpness(xml_sharp_t *sharp);
-extern void isp_set_nr(xml_nr_t *nr);
-extern void isp_set_awb_stat(xml_awb_t *awb,unsigned int w,unsigned int h);
-extern void isp_set_ae_stat(xml_ae_t *ae,unsigned int w,unsigned int h);
-extern void isp_set_af_stat(xml_af_t *af,unsigned int w,unsigned int h);
-extern void isp_set_af_scan_stat(unsigned int x0,unsigned int y0,unsigned int x1,unsigned int y1);
-extern void isp_set_blenr_stat(unsigned int x0,unsigned int y0,unsigned int x1,unsigned int y1);
-extern void isp_set_dbg(xml_dbg_t *dbg);
-extern void isp_set_lnsd_mode(unsigned int mode);
-extern void isp_set_def_config(xml_default_regs_t *regs,tvin_port_t fe_port,tvin_color_fmt_t bfmt,unsigned int w,unsigned int h);
-extern void isp_load_def_setting(unsigned int hsize,unsigned int vsize,unsigned char bayer_fmt);
-extern void isp_test_pattern(unsigned int hsize,unsigned int vsize,unsigned int htotal,unsigned int vtotal,unsigned char bayer_fmt);
-extern void isp_set_manual_wb(xml_wb_manual_t *wb);
-extern void isp_get_awb_stat(isp_awb_stat_t *awb_stat);
-extern void isp_get_ae_stat(isp_ae_stat_t *ae_stat);
-extern void isp_get_af_stat(isp_af_stat_t *af_stat);
-extern void isp_get_af_scan_stat(isp_blnr_stat_t *blnr_stat);
-extern void isp_get_blnr_stat(isp_blnr_stat_t *blnr_stat);
-extern void isp_set_ae_win(unsigned int left, unsigned int right, unsigned int top, unsigned int bottom);
-extern void isp_set_awb_win(unsigned int left, unsigned int right, unsigned int top, unsigned int bottom);
-extern void isp_set_ae_thrlpf(unsigned char thr_r, unsigned char thr_g, unsigned char thr_b, unsigned char lpf);
-extern void isp_set_awb_yuv_thr(unsigned char yh, unsigned char yl, unsigned char u, unsigned char v);
-extern void isp_set_awb_rgb_thr(unsigned char gb, unsigned char gr, unsigned br);
-extern void flash_on(bool mode_pol_inv,bool led1_pol_inv,bool pin_mux_inv,wave_t *wave_param);
-extern void torch_level(bool mode_pol_inv,bool led1_pol_inv,bool pin_mux_inv,bool torch_pol_inv,wave_t *wave_param,unsigned int level);
-extern void wave_power_manage(bool enable);
-extern void isp_hw_reset(void);
-extern void isp_bypass_all(void);
-extern void isp_bypass_for_rgb(void);
-extern void isp_hw_enable(bool enable);
-extern void isp_awb_set_gain(unsigned int r, unsigned int g, unsigned int b);
-extern void isp_awb_get_gain(isp_awb_gain_t *awb_gain);
-extern void set_isp_gamma_table(unsigned short *gamma,unsigned int type);
-extern void get_isp_gamma_table(unsigned short *gamma,unsigned int type);
-extern void disable_gc_lns_pk(bool flag);
-extern void isp_ls_curve(unsigned int psize_v2h, unsigned int hactive, 
-        unsigned int vactive, unsigned int ocenter_c2l, 
-        unsigned int ocenter_c2t, unsigned int gain_0db, 
-        unsigned int curvature_gr, unsigned int curvature_r, 
-        unsigned int curvature_b, unsigned int curvature_gb, bool force_enable);
-                  
-#endif
-
diff --git a/drivers/amlogic/tvin/isp/isp_parm.c b/drivers/amlogic/tvin/isp/isp_parm.c
deleted file mode 100755
index 0902c30a7d7e..000000000000
--- a/drivers/amlogic/tvin/isp/isp_parm.c
+++ /dev/null
@@ -1,2995 +0,0 @@
-/*
- * ISP driver
- *
- * Author: Kele Bai <kele.bai@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/* Standard Linux Headers */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/string.h>
-#include <linux/fs.h>
-#include <mach/am_regs.h>
-
-/* Amlogic Headers */
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-
-#include "isp_drv.h"
-
-#define DEVICE_NAME "isp"
-
-static void isp_param_show(isp_param_t *parm, int len)
-{
-	int i=0,j=0;
-
-	for(i=0;i<len;i++){
-		if(ISP_U32==parm[i].type || ISP_U16== parm[i].type || ISP_U8== parm[i].type) {
-			for(j=0;j<parm[i].length;j++)
-				pr_info("%s %s[%d]=0x%x.\n",__func__,parm[i].name,j,*(parm[i].param+j));
-		} else if(ISP_FLOAT == parm[i].type) {
-			for(j=0;j<parm[i].length;j++)
-				pr_info("%s %s[%d]=%f.\n",__func__,parm[i].name,j,*(parm[i].param+j));
-		}
-	}
-}
-
-static int isp_set_param(isp_param_t *parm,int len,char **buf)
-{
-	int i=0,j=0;
-	for(i=0;i<len;i++) {
-		if(!strcmp(parm[i].name,*buf)) {
-			if(ISP_U32==parm[i].type || ISP_U8== parm[i].type || ISP_U16== parm[i].type) {
-				for(j=0;j<parm[i].length&&*(buf+j+1)!=NULL;j++) {
-					*(parm[i].param+j) = simple_strtol(*(buf+j+1),NULL,16);
-					pr_info("%s %s[%d]=0x%x.\n",__func__,parm[i].name,j,*(parm[i].param+j));
-				}
-			} else if(ISP_FLOAT == parm[i].type) {
-				for(j=0;j<parm[i].length&&*(buf+j+1)!=NULL;j++) {
-					sscanf(*(buf+j+1),"%f",(float*)(parm[i].param+j));
-					pr_info("%s %s[%d]=%f.\n",__func__,parm[i].name,j,*(parm[i].param+j));
-				}
-			}
-			break;
-		}
-	}
-	if(i == len) {
-		pr_err("[%s..]%s:the parameter name %s is error.\n",DEVICE_NAME,__func__,buf[0]);
-		return 1;
-	}
-	return 0;
-}
-
-void set_ae_parm(xml_algorithm_ae_t *ae_sw,char **parm)
-{
-	int len = AE_PARM_NUM;
-	isp_param_t ae[AE_PARM_NUM]={
-		{"ae_algorithm",      &ae_sw->ae_algorithm,      1,  ISP_U32},
-		{"ae_statistics",     &ae_sw->ae_statistics[0],  3,  ISP_U32},
-		{"ae_exp",            &ae_sw->ae_exp[0],         3,  ISP_U32},
-		{"ae_ag",             &ae_sw->ae_ag[0],          3,  ISP_U32},
-		{"ae_skip",           &ae_sw->ae_skip[0],        3,  ISP_U32},
-		{"ratio_winl",        &ae_sw->ratio_winl,        1,  ISP_U32},
-		{"ratio_winr",        &ae_sw->ratio_winr,        1,  ISP_U32},
-		{"ratio_wint",        &ae_sw->ratio_wint,        1,  ISP_U32},
-		{"ratio_winb",        &ae_sw->ratio_winb,        1,  ISP_U32},
-		{"alert_mode",        &ae_sw->alert_mode,        1,  ISP_U32},
-		{"tune_mode",         &ae_sw->tune_mode,         1,  ISP_U32},
-		{"ratio_r",           &ae_sw->ratio_r,           1,  ISP_U32},
-		{"ratio_g",           &ae_sw->ratio_g,           1,  ISP_U32},
-		{"ratio_b",           &ae_sw->ratio_b,           1,  ISP_U32},
-		{"stepdnr",           &ae_sw->stepdnr,           1,  ISP_U32},
-		{"stepdng",           &ae_sw->stepdng,           1,  ISP_U32},
-		{"stepdnb",           &ae_sw->stepdnb,           1,  ISP_U32},
-		{"stepup",            &ae_sw->stepup,            1,  ISP_U32},
-		{"slow_lpfcoef",      &ae_sw->slow_lpfcoef,      1,  ISP_U32},
-		{"fast_lpfcoef",      &ae_sw->fast_lpfcoef,      1,  ISP_U32},
-		{"coef_cur",          &ae_sw->coef_cur[0],       16, ISP_U32},
-		{"coef_env",          &ae_sw->coef_env[0],       16, ISP_U32},
-		{"env_hign",          &ae_sw->env_hign,          1,  ISP_U32},
-		{"env_hign2mid",      &ae_sw->env_hign2mid,      1,  ISP_U32},
-		{"env_low2mid",       &ae_sw->env_low2mid,       1,  ISP_U32},
-		{"env_low",           &ae_sw->env_low,           1,  ISP_U32},
-		{"thr_r_high",        &ae_sw->thr_r_high,        1,  ISP_U32},
-		{"thr_r_mid",         &ae_sw->thr_r_mid,         1,  ISP_U32},
-		{"thr_r_low",         &ae_sw->thr_r_low,         1,  ISP_U32},
-		{"thr_g_high",        &ae_sw->thr_g_high,        1,  ISP_U32},
-		{"thr_g_mid",         &ae_sw->thr_g_mid,         1,  ISP_U32},
-		{"thr_g_low",         &ae_sw->thr_g_low,         1,  ISP_U32},
-		{"thr_b_high",        &ae_sw->thr_b_high,        1,  ISP_U32},
-		{"thr_b_mid",         &ae_sw->thr_b_mid,         1,  ISP_U32},
-		{"thr_b_low",         &ae_sw->thr_b_low,         1,  ISP_U32},
-		{"lpftype_high",      &ae_sw->lpftype_high,      1,  ISP_U32},
-		{"lpftype_mid",       &ae_sw->lpftype_mid,       1,  ISP_U32},
-		{"lpftype_low",       &ae_sw->lpftype_low,       1,  ISP_U32},
-		{"targethigh",        &ae_sw->targethigh,        1,  ISP_U32},
-		{"targetmid",         &ae_sw->targetmid,         1,  ISP_U32},
-		{"targetlow",         &ae_sw->targetlow,         1,  ISP_U32},
-		{"radium_inner_h",    &ae_sw->radium_inner_h,    1,  ISP_U32},
-		{"radium_outer_h",    &ae_sw->radium_outer_h,    1,  ISP_U32},
-		{"radium_inner_m",    &ae_sw->radium_inner_m,    1,  ISP_U32},
-		{"radium_outer_m",    &ae_sw->radium_outer_m,    1,  ISP_U32},
-		{"radium_inner_l",    &ae_sw->radium_inner_l,    1,  ISP_U32},
-		{"radium_outer_l",    &ae_sw->radium_outer_l,    1,  ISP_U32},
-		{"flash_thr",	      &ae_sw->flash_thr,         1,  ISP_U32},
-		{"ratio_histr",	      &ae_sw->ratio_histr,       1,  ISP_U32},
-		{"ratio_histg",	      &ae_sw->ratio_histg,       1,  ISP_U32},
-		{"ratio_histb",	      &ae_sw->ratio_histb,       1,  ISP_U32},
-		{"target_r",	      &ae_sw->target_r,          1,  ISP_U32},
-		{"target_g",	      &ae_sw->target_g,          1,  ISP_U32},
-		{"target_b",	      &ae_sw->target_b,          1,  ISP_U32},
-		{"maxrate_inner",     &ae_sw->maxrate_inner,     1,  ISP_U32},
-		{"maxrate_outer",     &ae_sw->maxrate_outer,     1,  ISP_U32},
-		{"slow_lpfcoef_enh",  &ae_sw->slow_lpfcoef_enh,  1,  ISP_U32},
-		{"fast_lpfcoef_enh",  &ae_sw->fast_lpfcoef_enh,  1,  ISP_U32},
-		{"flash_thr_enh",     &ae_sw->flash_thr_enh,     1,  ISP_U32},
-		{"ae_ratio_low",	  &ae_sw->ae_ratio_low, 	 1,  ISP_U32},
-		{"ae_ratio_low2mid",  &ae_sw->ae_ratio_low2mid,  1,  ISP_U32},
-		{"ae_ratio_mid2high", &ae_sw->ae_ratio_mid2high, 1,  ISP_U32},
-		{"ae_ratio_high",	  &ae_sw->ae_ratio_high, 	 1,  ISP_U32},
-		{"ae_min_diff",	      &ae_sw->ae_min_diff, 	     1,  ISP_U32},
-		{"ae_max_diff",	      &ae_sw->ae_max_diff, 	     1,  ISP_U32},
-		{"reserve",	          &ae_sw->reserve[0], 	     16, ISP_U32},
-		{"aet_fmt_gain",	  &ae_sw->aet_fmt_gain, 	 1,  ISP_U32},
-	};
-
-	if(!strcmp(parm[0],"show")){
-		isp_param_show((isp_param_t*)&ae,len);
-	} else {
-		isp_set_param((isp_param_t*)&ae,len,parm);
-	}
-
-}
-
-void set_awb_parm(xml_algorithm_awb_t *awb_sw,char **parm)
-{
-	int len = AWB_PARM_NUM;
-	isp_param_t awb[AWB_PARM_NUM]={
-		{"awb_algorithm",  &awb_sw->awb_algorithm,   1,  ISP_U32},
-		{"ratio_winl",	   &awb_sw->ratio_winl,		 1,  ISP_U32},
-		{"ratio_winr",	   &awb_sw->ratio_winr,		 1,  ISP_U32},
-		{"ratio_wint",	   &awb_sw->ratio_wint,		 1,  ISP_U32},
-		{"ratio_winb",	   &awb_sw->ratio_winb,		 1,  ISP_U32},
-		{"ratio_rgb",      &awb_sw->ratio_rgb,       1,  ISP_U32},
-		{"ratio_yh",       &awb_sw->ratio_yh,        1,  ISP_U32},
-		{"ratio_ym",       &awb_sw->ratio_ym,        1,  ISP_U32},
-		{"ratio_yl",       &awb_sw->ratio_yl,        1,  ISP_U32},
-		{"yyh",            &awb_sw->yyh,             1,  ISP_U32},
-		{"yym",            &awb_sw->yym,             1,  ISP_U32},
-		{"yyl",            &awb_sw->yyl,             1,  ISP_U32},
-		{"coef_r",         &awb_sw->coef_r[0],       4,  ISP_U32},
-		{"coef_g",         &awb_sw->coef_g[0],       4,  ISP_U32},
-		{"coef_b",         &awb_sw->coef_b[0],       4,  ISP_U32},
-		{"inner_rg",       &awb_sw->inner_rg,        1,  ISP_U32},
-		{"outer_rg",       &awb_sw->outer_rg,        1,  ISP_U32},
-		{"inner_bg",       &awb_sw->inner_bg,        1,  ISP_U32},
-		{"outer_bg",       &awb_sw->outer_bg,        1,  ISP_U32},
-		{"r_max",          &awb_sw->r_max,           1,  ISP_U32},
-		{"r_min",          &awb_sw->r_min,           1,  ISP_U32},
-		{"b_max",          &awb_sw->b_max,           1,  ISP_U32},
-		{"b_min",          &awb_sw->b_min,           1,  ISP_U32},
-		{"thr_gb_h",	   &awb_sw->thr_gb_h,	     1,  ISP_U32},
-		{"thr_gb_m",	   &awb_sw->thr_gb_m,	     1,  ISP_U32},
-		{"thr_gb_l",	   &awb_sw->thr_gb_l,	     1,  ISP_U32},
-		{"thr_gr_h",	   &awb_sw->thr_gr_h,	     1,  ISP_U32},
-		{"thr_gr_m",	   &awb_sw->thr_gr_m,	     1,  ISP_U32},
-		{"thr_gr_l",	   &awb_sw->thr_gr_l,	     1,  ISP_U32},
-		{"thr_br_h",	   &awb_sw->thr_br_h,	     1,  ISP_U32},
-		{"thr_br_m",	   &awb_sw->thr_br_m,	     1,  ISP_U32},
-		{"thr_br_l",	   &awb_sw->thr_br_l,	     1,  ISP_U32},
-		{"thr_du_h",	   &awb_sw->thr_du_h,	     1,  ISP_U32},
-		{"thr_du_m",	   &awb_sw->thr_du_m,	     1,  ISP_U32},
-		{"thr_du_l",	   &awb_sw->thr_du_l,	     1,  ISP_U32},
-		{"thr_dv_h",	   &awb_sw->thr_dv_h,	     1,  ISP_U32},
-		{"thr_dv_m",	   &awb_sw->thr_dv_m,	     1,  ISP_U32},
-		{"thr_dv_l",	   &awb_sw->thr_dv_l,	     1,  ISP_U32},
-		{"thr_yh_h",	   &awb_sw->thr_yh_h,	     1,  ISP_U32},
-		{"thr_yh_m",	   &awb_sw->thr_yh_m,	     1,  ISP_U32},
-		{"thr_yh_l",	   &awb_sw->thr_yh_l,	     1,  ISP_U32},
-		{"thr_yl_h",	   &awb_sw->thr_yl_h,	     1,  ISP_U32},
-		{"thr_yl_m",	   &awb_sw->thr_yl_m,	     1,  ISP_U32},
-		{"thr_yl_l",	   &awb_sw->thr_yl_l,	     1,  ISP_U32},
-	        {"ratio_yuv",      &awb_sw->ratio_yuv,       1,  ISP_U32},
-		{"slow_lpfcoef",   &awb_sw->slow_lpfcoef,    1,  ISP_U32},
-		{"fast_lpfcoef",   &awb_sw->fast_lpfcoef,    1,  ISP_U32},
-		{"outer",          &awb_sw->outer,           1,  ISP_U32},
-		{"inner",          &awb_sw->inner,           1,  ISP_U32},
-		{"rw_limith",      &awb_sw->rw_limith,       1,  ISP_U32},
-		{"rw_limitl",      &awb_sw->rw_limitl,       1,  ISP_U32},
-		{"gw_limith",      &awb_sw->gw_limith,       1,  ISP_U32},
-		{"gw_limitl",      &awb_sw->gw_limitl,       1,  ISP_U32},
-		{"bw_limith",      &awb_sw->bw_limith,       1,  ISP_U32},
-		{"bw_limitl",      &awb_sw->bw_limitl,       1,  ISP_U32},
-		{"thr_u",          &awb_sw->thr_u[0],        20, ISP_U32},
-		{"thr_v",          &awb_sw->thr_v[0],        20, ISP_U32},
-		{"reserve",        &awb_sw->reserve[0],      16, ISP_U32},
-	};
-
-	if(!strcmp(parm[0],"show")){
-		isp_param_show((isp_param_t*)&awb,len);
-	} else {
-		isp_set_param((isp_param_t*)&awb,len,parm);
-	}
-}
-
-void set_af_parm(xml_algorithm_af_t *af_sw,char **parm)
-{
-	int len = AF_PARM_NUM;
-	isp_param_t af[AF_PARM_NUM]={
-		{"enter_static_ratio",    &af_sw->enter_static_ratio,      1, ISP_U32},
-		{"detect_step_cnt",       &af_sw->detect_step_cnt,         1, ISP_U32},
-		{"ave_vdc_thr",		  &af_sw->ave_vdc_thr,		   		   1, ISP_U32},
-		{"win_ratio", 	  	  &af_sw->win_ratio,		   1, ISP_U32},
-		{"step",      		  &af_sw->step,           FOCUS_GRIDS, ISP_U32},
-		{"valid_step_cnt",        &af_sw->valid_step_cnt,          1, ISP_U32},
-		{"jump_offset",           &af_sw->jump_offset,             1, ISP_U32},
-		{"field_delay",           &af_sw->field_delay,             1, ISP_U32},
-		{"x",                     &af_sw->x,      			       1, ISP_U32},
-		{"y",                     &af_sw->y,      			       1, ISP_U32},
-		{"radius_ratio",          &af_sw->radius_ratio,     		       1, ISP_U32},
-		{"radius_ratio",          &af_sw->hillside_fall,     		       1, ISP_U32},
-	};
-
-	if(!strcmp(parm[0],"show")){
-		isp_param_show((isp_param_t*)&af,len);
-	} else {
-		isp_set_param((isp_param_t*)&af,len,parm);
-	}
-}
-
-void set_cap_parm(struct xml_capture_s *cap_sw,char **parm)
-{
-	int len = CAP_PARM_NUM;
-	isp_param_t cap[CAP_PARM_NUM]={
-		{"ae_try_max_cnt",   &cap_sw->ae_try_max_cnt,      1, ISP_U32},
-		{"af_mode",          &cap_sw->af_mode,      	   1, ISP_U32},
-		{"sigle_count",      &cap_sw->sigle_count,         1, ISP_U32},
-		{"skip_step",        &cap_sw->skip_step,      	   1, ISP_U32},
-		{"multi_capture_num",&cap_sw->multi_capture_num,   1, ISP_U32},
-		{"eyetime",          &cap_sw->eyetime,      	   1, ISP_U32},
-		{"pretime",          &cap_sw->pretime,      	   1, ISP_U32},
-		{"postime",          &cap_sw->postime,      	   1, ISP_U32},
-	};
-
-	if(!strcmp(parm[0],"show")){
-		isp_param_show((isp_param_t*)&cap,len);
-	} else {
-		isp_set_param((isp_param_t*)&cap,len,parm);
-	}
-
-}
-
-void set_wave_parm(struct wave_s *wave,char **parm)
-{
-	int len = WAVE_PARM_NUM;
-	isp_param_t wav[WAVE_PARM_NUM]={
-		{"torch_rising_time",      	&wave->torch_rising_time,      	1, ISP_U32},
-		{"flash_rising_time",           &wave->flash_rising_time,      	1, ISP_U32},
-		{"torch_flash_ratio",           &wave->torch_flash_ratio,      	1, ISP_U32},
-		{"wave_clock_div",              &wave->wave_clock_div,          1, ISP_U32},
-		{"pulse_init_time",             &wave->pulse_init_time,         1, ISP_U32},
-		{"pulse_high_time",             &wave->pulse_high_time,      	1, ISP_U32},
-		{"pulse_low_time",              &wave->pulse_low_time,          1, ISP_U32},
-		{"time_to_latch",               &wave->time_to_latch,      	1, ISP_U32},
-		{"latch_time",                  &wave->latch_time,      	1, ISP_U32},
-		{"latch_time_timeout",          &wave->latch_time_timeout,      1, ISP_U32},
-		{"time_to_off",                 &wave->time_to_off,      	1, ISP_U32},
-		{"pulse_qty_max",               &wave->pulse_qty_max,      	1, ISP_U32},
-	};
-
-	if(!strcmp(parm[0],"show")){
-		isp_param_show((isp_param_t*)&wav,len);
-	} else {
-		isp_set_param((isp_param_t*)&wav,len,parm);
-	}
-
-}
-static unsigned int gamma[10][257] =
-	{
-		// curve_ratio = 1.0
-		{
-			0x00000000,
-			0x00000004,
-			0x00000008,
-			0x0000000C,
-			0x00000010,
-			0x00000014,
-			0x00000018,
-			0x0000001C,
-			0x00000020,
-			0x00000024,
-			0x00000028,
-			0x0000002C,
-			0x00000030,
-			0x00000034,
-			0x00000038,
-			0x0000003C,
-			0x00000040,
-			0x00000044,
-			0x00000048,
-			0x0000004C,
-			0x00000050,
-			0x00000054,
-			0x00000058,
-			0x0000005C,
-			0x00000060,
-			0x00000064,
-			0x00000068,
-			0x0000006C,
-			0x00000070,
-			0x00000074,
-			0x00000078,
-			0x0000007C,
-			0x00000080,
-			0x00000084,
-			0x00000088,
-			0x0000008C,
-			0x00000090,
-			0x00000094,
-			0x00000098,
-			0x0000009C,
-			0x000000A0,
-			0x000000A4,
-			0x000000A8,
-			0x000000AC,
-			0x000000B0,
-			0x000000B4,
-			0x000000B8,
-			0x000000BC,
-			0x000000C0,
-			0x000000C4,
-			0x000000C8,
-			0x000000CC,
-			0x000000D0,
-			0x000000D4,
-			0x000000D8,
-			0x000000DC,
-			0x000000E0,
-			0x000000E4,
-			0x000000E8,
-			0x000000EC,
-			0x000000F0,
-			0x000000F4,
-			0x000000F8,
-			0x000000FC,
-			0x00000100,
-			0x00000104,
-			0x00000108,
-			0x0000010C,
-			0x00000110,
-			0x00000114,
-			0x00000118,
-			0x0000011C,
-			0x00000120,
-			0x00000124,
-			0x00000128,
-			0x0000012C,
-			0x00000130,
-			0x00000134,
-			0x00000138,
-			0x0000013C,
-			0x00000140,
-			0x00000144,
-			0x00000148,
-			0x0000014C,
-			0x00000150,
-			0x00000154,
-			0x00000158,
-			0x0000015C,
-			0x00000160,
-			0x00000164,
-			0x00000168,
-			0x0000016C,
-			0x00000170,
-			0x00000174,
-			0x00000178,
-			0x0000017C,
-			0x00000180,
-			0x00000184,
-			0x00000188,
-			0x0000018C,
-			0x00000190,
-			0x00000194,
-			0x00000198,
-			0x0000019C,
-			0x000001A0,
-			0x000001A4,
-			0x000001A8,
-			0x000001AC,
-			0x000001B0,
-			0x000001B4,
-			0x000001B8,
-			0x000001BC,
-			0x000001C0,
-			0x000001C4,
-			0x000001C8,
-			0x000001CC,
-			0x000001D0,
-			0x000001D4,
-			0x000001D8,
-			0x000001DC,
-			0x000001E0,
-			0x000001E4,
-			0x000001E8,
-			0x000001EC,
-			0x000001F0,
-			0x000001F4,
-			0x000001F8,
-			0x000001FC,
-			0x00000200,
-			0x00000204,
-			0x00000208,
-			0x0000020C,
-			0x00000210,
-			0x00000214,
-			0x00000218,
-			0x0000021C,
-			0x00000220,
-			0x00000224,
-			0x00000228,
-			0x0000022C,
-			0x00000230,
-			0x00000234,
-			0x00000238,
-			0x0000023C,
-			0x00000240,
-			0x00000244,
-			0x00000248,
-			0x0000024C,
-			0x00000250,
-			0x00000254,
-			0x00000258,
-			0x0000025C,
-			0x00000260,
-			0x00000264,
-			0x00000268,
-			0x0000026C,
-			0x00000270,
-			0x00000274,
-			0x00000278,
-			0x0000027C,
-			0x00000280,
-			0x00000284,
-			0x00000288,
-			0x0000028C,
-			0x00000290,
-			0x00000294,
-			0x00000298,
-			0x0000029C,
-			0x000002A0,
-			0x000002A4,
-			0x000002A8,
-			0x000002AC,
-			0x000002B0,
-			0x000002B4,
-			0x000002B8,
-			0x000002BC,
-			0x000002C0,
-			0x000002C4,
-			0x000002C8,
-			0x000002CC,
-			0x000002D0,
-			0x000002D4,
-			0x000002D8,
-			0x000002DC,
-			0x000002E0,
-			0x000002E4,
-			0x000002E8,
-			0x000002EC,
-			0x000002F0,
-			0x000002F4,
-			0x000002F8,
-			0x000002FC,
-			0x00000300,
-			0x00000304,
-			0x00000308,
-			0x0000030C,
-			0x00000310,
-			0x00000314,
-			0x00000318,
-			0x0000031C,
-			0x00000320,
-			0x00000324,
-			0x00000328,
-			0x0000032C,
-			0x00000330,
-			0x00000334,
-			0x00000338,
-			0x0000033C,
-			0x00000340,
-			0x00000344,
-			0x00000348,
-			0x0000034C,
-			0x00000350,
-			0x00000354,
-			0x00000358,
-			0x0000035C,
-			0x00000360,
-			0x00000364,
-			0x00000368,
-			0x0000036C,
-			0x00000370,
-			0x00000374,
-			0x00000378,
-			0x0000037C,
-			0x00000380,
-			0x00000384,
-			0x00000388,
-			0x0000038C,
-			0x00000390,
-			0x00000394,
-			0x00000398,
-			0x0000039C,
-			0x000003A0,
-			0x000003A4,
-			0x000003A8,
-			0x000003AC,
-			0x000003B0,
-			0x000003B4,
-			0x000003B8,
-			0x000003BC,
-			0x000003C0,
-			0x000003C4,
-			0x000003C8,
-			0x000003CC,
-			0x000003D0,
-			0x000003D4,
-			0x000003D8,
-			0x000003DC,
-			0x000003E0,
-			0x000003E4,
-			0x000003E8,
-			0x000003EC,
-			0x000003F0,
-			0x000003F4,
-			0x000003F8,
-			0x000003FC,
-			0x000003FF,
-		},
-		// curve_ratio = 0.1
-		{
-			0x00000000,
-			0x0000024C,
-			0x00000276,
-			0x00000290,
-			0x000002A4,
-			0x000002B3,
-			0x000002C0,
-			0x000002CA,
-			0x000002D4,
-			0x000002DD,
-			0x000002E4,
-			0x000002EC,
-			0x000002F2,
-			0x000002F8,
-			0x000002FE,
-			0x00000303,
-			0x00000308,
-			0x0000030D,
-			0x00000311,
-			0x00000315,
-			0x0000031A,
-			0x0000031D,
-			0x00000321,
-			0x00000325,
-			0x00000328,
-			0x0000032B,
-			0x0000032F,
-			0x00000332,
-			0x00000335,
-			0x00000338,
-			0x0000033A,
-			0x0000033D,
-			0x00000340,
-			0x00000342,
-			0x00000345,
-			0x00000347,
-			0x0000034A,
-			0x0000034C,
-			0x0000034E,
-			0x00000350,
-			0x00000353,
-			0x00000355,
-			0x00000357,
-			0x00000359,
-			0x0000035B,
-			0x0000035D,
-			0x0000035E,
-			0x00000360,
-			0x00000362,
-			0x00000364,
-			0x00000366,
-			0x00000367,
-			0x00000369,
-			0x0000036B,
-			0x0000036C,
-			0x0000036E,
-			0x00000370,
-			0x00000371,
-			0x00000373,
-			0x00000374,
-			0x00000376,
-			0x00000377,
-			0x00000379,
-			0x0000037A,
-			0x0000037B,
-			0x0000037D,
-			0x0000037E,
-			0x00000380,
-			0x00000381,
-			0x00000382,
-			0x00000383,
-			0x00000385,
-			0x00000386,
-			0x00000387,
-			0x00000388,
-			0x0000038A,
-			0x0000038B,
-			0x0000038C,
-			0x0000038D,
-			0x0000038E,
-			0x00000390,
-			0x00000391,
-			0x00000392,
-			0x00000393,
-			0x00000394,
-			0x00000395,
-			0x00000396,
-			0x00000397,
-			0x00000398,
-			0x00000399,
-			0x0000039A,
-			0x0000039B,
-			0x0000039C,
-			0x0000039D,
-			0x0000039E,
-			0x0000039F,
-			0x000003A0,
-			0x000003A1,
-			0x000003A2,
-			0x000003A3,
-			0x000003A4,
-			0x000003A5,
-			0x000003A6,
-			0x000003A7,
-			0x000003A8,
-			0x000003A9,
-			0x000003AA,
-			0x000003AA,
-			0x000003AB,
-			0x000003AC,
-			0x000003AD,
-			0x000003AE,
-			0x000003AF,
-			0x000003B0,
-			0x000003B0,
-			0x000003B1,
-			0x000003B2,
-			0x000003B3,
-			0x000003B4,
-			0x000003B4,
-			0x000003B5,
-			0x000003B6,
-			0x000003B7,
-			0x000003B8,
-			0x000003B8,
-			0x000003B9,
-			0x000003BA,
-			0x000003BB,
-			0x000003BB,
-			0x000003BC,
-			0x000003BD,
-			0x000003BE,
-			0x000003BE,
-			0x000003BF,
-			0x000003C0,
-			0x000003C1,
-			0x000003C1,
-			0x000003C2,
-			0x000003C3,
-			0x000003C3,
-			0x000003C4,
-			0x000003C5,
-			0x000003C5,
-			0x000003C6,
-			0x000003C7,
-			0x000003C7,
-			0x000003C8,
-			0x000003C9,
-			0x000003C9,
-			0x000003CA,
-			0x000003CB,
-			0x000003CB,
-			0x000003CC,
-			0x000003CD,
-			0x000003CD,
-			0x000003CE,
-			0x000003CF,
-			0x000003CF,
-			0x000003D0,
-			0x000003D0,
-			0x000003D1,
-			0x000003D2,
-			0x000003D2,
-			0x000003D3,
-			0x000003D3,
-			0x000003D4,
-			0x000003D5,
-			0x000003D5,
-			0x000003D6,
-			0x000003D6,
-			0x000003D7,
-			0x000003D8,
-			0x000003D8,
-			0x000003D9,
-			0x000003D9,
-			0x000003DA,
-			0x000003DA,
-			0x000003DB,
-			0x000003DB,
-			0x000003DC,
-			0x000003DD,
-			0x000003DD,
-			0x000003DE,
-			0x000003DE,
-			0x000003DF,
-			0x000003DF,
-			0x000003E0,
-			0x000003E0,
-			0x000003E1,
-			0x000003E1,
-			0x000003E2,
-			0x000003E2,
-			0x000003E3,
-			0x000003E3,
-			0x000003E4,
-			0x000003E5,
-			0x000003E5,
-			0x000003E6,
-			0x000003E6,
-			0x000003E7,
-			0x000003E7,
-			0x000003E8,
-			0x000003E8,
-			0x000003E9,
-			0x000003E9,
-			0x000003EA,
-			0x000003EA,
-			0x000003EA,
-			0x000003EB,
-			0x000003EB,
-			0x000003EC,
-			0x000003EC,
-			0x000003ED,
-			0x000003ED,
-			0x000003EE,
-			0x000003EE,
-			0x000003EF,
-			0x000003EF,
-			0x000003F0,
-			0x000003F0,
-			0x000003F1,
-			0x000003F1,
-			0x000003F2,
-			0x000003F2,
-			0x000003F2,
-			0x000003F3,
-			0x000003F3,
-			0x000003F4,
-			0x000003F4,
-			0x000003F5,
-			0x000003F5,
-			0x000003F6,
-			0x000003F6,
-			0x000003F6,
-			0x000003F7,
-			0x000003F7,
-			0x000003F8,
-			0x000003F8,
-			0x000003F9,
-			0x000003F9,
-			0x000003F9,
-			0x000003FA,
-			0x000003FA,
-			0x000003FB,
-			0x000003FB,
-			0x000003FC,
-			0x000003FC,
-			0x000003FC,
-			0x000003FD,
-			0x000003FD,
-			0x000003FE,
-			0x000003FE,
-			0x000003FE,
-			0x000003FF,
-			0x000003FF,
-			0x000003FF,
-			0x000003FF,
-		},
-		// curve_ratio = 0.2
-		{
-			0x00000000,
-			0x00000152,
-			0x00000184,
-			0x000001A5,
-			0x000001BE,
-			0x000001D2,
-			0x000001E3,
-			0x000001F3,
-			0x00000200,
-			0x0000020C,
-			0x00000217,
-			0x00000222,
-			0x0000022B,
-			0x00000234,
-			0x0000023D,
-			0x00000245,
-			0x0000024C,
-			0x00000253,
-			0x0000025A,
-			0x00000261,
-			0x00000267,
-			0x0000026D,
-			0x00000273,
-			0x00000278,
-			0x0000027E,
-			0x00000283,
-			0x00000288,
-			0x0000028D,
-			0x00000292,
-			0x00000296,
-			0x0000029B,
-			0x0000029F,
-			0x000002A4,
-			0x000002A8,
-			0x000002AC,
-			0x000002B0,
-			0x000002B4,
-			0x000002B7,
-			0x000002BB,
-			0x000002BF,
-			0x000002C2,
-			0x000002C6,
-			0x000002C9,
-			0x000002CD,
-			0x000002D0,
-			0x000002D3,
-			0x000002D6,
-			0x000002DA,
-			0x000002DD,
-			0x000002E0,
-			0x000002E3,
-			0x000002E6,
-			0x000002E8,
-			0x000002EB,
-			0x000002EE,
-			0x000002F1,
-			0x000002F4,
-			0x000002F6,
-			0x000002F9,
-			0x000002FC,
-			0x000002FE,
-			0x00000301,
-			0x00000303,
-			0x00000306,
-			0x00000308,
-			0x0000030A,
-			0x0000030D,
-			0x0000030F,
-			0x00000312,
-			0x00000314,
-			0x00000316,
-			0x00000318,
-			0x0000031B,
-			0x0000031D,
-			0x0000031F,
-			0x00000321,
-			0x00000323,
-			0x00000325,
-			0x00000327,
-			0x00000329,
-			0x0000032B,
-			0x0000032D,
-			0x0000032F,
-			0x00000331,
-			0x00000333,
-			0x00000335,
-			0x00000337,
-			0x00000339,
-			0x0000033B,
-			0x0000033D,
-			0x0000033F,
-			0x00000341,
-			0x00000342,
-			0x00000344,
-			0x00000346,
-			0x00000348,
-			0x0000034A,
-			0x0000034B,
-			0x0000034D,
-			0x0000034F,
-			0x00000351,
-			0x00000352,
-			0x00000354,
-			0x00000356,
-			0x00000357,
-			0x00000359,
-			0x0000035A,
-			0x0000035C,
-			0x0000035E,
-			0x0000035F,
-			0x00000361,
-			0x00000362,
-			0x00000364,
-			0x00000365,
-			0x00000367,
-			0x00000369,
-			0x0000036A,
-			0x0000036C,
-			0x0000036D,
-			0x0000036F,
-			0x00000370,
-			0x00000371,
-			0x00000373,
-			0x00000374,
-			0x00000376,
-			0x00000377,
-			0x00000379,
-			0x0000037A,
-			0x0000037B,
-			0x0000037D,
-			0x0000037E,
-			0x00000380,
-			0x00000381,
-			0x00000382,
-			0x00000384,
-			0x00000385,
-			0x00000386,
-			0x00000388,
-			0x00000389,
-			0x0000038A,
-			0x0000038C,
-			0x0000038D,
-			0x0000038E,
-			0x0000038F,
-			0x00000391,
-			0x00000392,
-			0x00000393,
-			0x00000394,
-			0x00000396,
-			0x00000397,
-			0x00000398,
-			0x00000399,
-			0x0000039B,
-			0x0000039C,
-			0x0000039D,
-			0x0000039E,
-			0x0000039F,
-			0x000003A1,
-			0x000003A2,
-			0x000003A3,
-			0x000003A4,
-			0x000003A5,
-			0x000003A6,
-			0x000003A8,
-			0x000003A9,
-			0x000003AA,
-			0x000003AB,
-			0x000003AC,
-			0x000003AD,
-			0x000003AE,
-			0x000003AF,
-			0x000003B1,
-			0x000003B2,
-			0x000003B3,
-			0x000003B4,
-			0x000003B5,
-			0x000003B6,
-			0x000003B7,
-			0x000003B8,
-			0x000003B9,
-			0x000003BA,
-			0x000003BB,
-			0x000003BC,
-			0x000003BE,
-			0x000003BF,
-			0x000003C0,
-			0x000003C1,
-			0x000003C2,
-			0x000003C3,
-			0x000003C4,
-			0x000003C5,
-			0x000003C6,
-			0x000003C7,
-			0x000003C8,
-			0x000003C9,
-			0x000003CA,
-			0x000003CB,
-			0x000003CC,
-			0x000003CD,
-			0x000003CE,
-			0x000003CF,
-			0x000003D0,
-			0x000003D1,
-			0x000003D2,
-			0x000003D3,
-			0x000003D3,
-			0x000003D4,
-			0x000003D5,
-			0x000003D6,
-			0x000003D7,
-			0x000003D8,
-			0x000003D9,
-			0x000003DA,
-			0x000003DB,
-			0x000003DC,
-			0x000003DD,
-			0x000003DE,
-			0x000003DF,
-			0x000003E0,
-			0x000003E1,
-			0x000003E1,
-			0x000003E2,
-			0x000003E3,
-			0x000003E4,
-			0x000003E5,
-			0x000003E6,
-			0x000003E7,
-			0x000003E8,
-			0x000003E9,
-			0x000003E9,
-			0x000003EA,
-			0x000003EB,
-			0x000003EC,
-			0x000003ED,
-			0x000003EE,
-			0x000003EF,
-			0x000003EF,
-			0x000003F0,
-			0x000003F1,
-			0x000003F2,
-			0x000003F3,
-			0x000003F4,
-			0x000003F5,
-			0x000003F5,
-			0x000003F6,
-			0x000003F7,
-			0x000003F8,
-			0x000003F9,
-			0x000003FA,
-			0x000003FA,
-			0x000003FB,
-			0x000003FC,
-			0x000003FD,
-			0x000003FE,
-			0x000003FE,
-			0x000003FF,
-			0x000003FF,
-		},
-		// curve_ratio = 0.3
-		{
-			0x00000000,
-			0x000000C2,
-			0x000000EF,
-			0x0000010E,
-			0x00000126,
-			0x0000013A,
-			0x0000014C,
-			0x0000015C,
-			0x0000016A,
-			0x00000177,
-			0x00000183,
-			0x0000018E,
-			0x00000199,
-			0x000001A3,
-			0x000001AC,
-			0x000001B5,
-			0x000001BE,
-			0x000001C6,
-			0x000001CE,
-			0x000001D5,
-			0x000001DD,
-			0x000001E4,
-			0x000001EA,
-			0x000001F1,
-			0x000001F7,
-			0x000001FE,
-			0x00000204,
-			0x00000209,
-			0x0000020F,
-			0x00000215,
-			0x0000021A,
-			0x00000220,
-			0x00000225,
-			0x0000022A,
-			0x0000022F,
-			0x00000234,
-			0x00000238,
-			0x0000023D,
-			0x00000242,
-			0x00000246,
-			0x0000024B,
-			0x0000024F,
-			0x00000253,
-			0x00000258,
-			0x0000025C,
-			0x00000260,
-			0x00000264,
-			0x00000268,
-			0x0000026C,
-			0x00000270,
-			0x00000273,
-			0x00000277,
-			0x0000027B,
-			0x0000027E,
-			0x00000282,
-			0x00000286,
-			0x00000289,
-			0x0000028D,
-			0x00000290,
-			0x00000293,
-			0x00000297,
-			0x0000029A,
-			0x0000029D,
-			0x000002A0,
-			0x000002A4,
-			0x000002A7,
-			0x000002AA,
-			0x000002AD,
-			0x000002B0,
-			0x000002B3,
-			0x000002B6,
-			0x000002B9,
-			0x000002BC,
-			0x000002BF,
-			0x000002C2,
-			0x000002C5,
-			0x000002C7,
-			0x000002CA,
-			0x000002CD,
-			0x000002D0,
-			0x000002D2,
-			0x000002D5,
-			0x000002D8,
-			0x000002DA,
-			0x000002DD,
-			0x000002E0,
-			0x000002E2,
-			0x000002E5,
-			0x000002E7,
-			0x000002EA,
-			0x000002EC,
-			0x000002EF,
-			0x000002F1,
-			0x000002F4,
-			0x000002F6,
-			0x000002F9,
-			0x000002FB,
-			0x000002FD,
-			0x00000300,
-			0x00000302,
-			0x00000304,
-			0x00000307,
-			0x00000309,
-			0x0000030B,
-			0x0000030E,
-			0x00000310,
-			0x00000312,
-			0x00000314,
-			0x00000316,
-			0x00000319,
-			0x0000031B,
-			0x0000031D,
-			0x0000031F,
-			0x00000321,
-			0x00000323,
-			0x00000325,
-			0x00000328,
-			0x0000032A,
-			0x0000032C,
-			0x0000032E,
-			0x00000330,
-			0x00000332,
-			0x00000334,
-			0x00000336,
-			0x00000338,
-			0x0000033A,
-			0x0000033C,
-			0x0000033E,
-			0x00000340,
-			0x00000342,
-			0x00000344,
-			0x00000346,
-			0x00000347,
-			0x00000349,
-			0x0000034B,
-			0x0000034D,
-			0x0000034F,
-			0x00000351,
-			0x00000353,
-			0x00000355,
-			0x00000356,
-			0x00000358,
-			0x0000035A,
-			0x0000035C,
-			0x0000035E,
-			0x0000035F,
-			0x00000361,
-			0x00000363,
-			0x00000365,
-			0x00000367,
-			0x00000368,
-			0x0000036A,
-			0x0000036C,
-			0x0000036D,
-			0x0000036F,
-			0x00000371,
-			0x00000373,
-			0x00000374,
-			0x00000376,
-			0x00000378,
-			0x00000379,
-			0x0000037B,
-			0x0000037D,
-			0x0000037E,
-			0x00000380,
-			0x00000382,
-			0x00000383,
-			0x00000385,
-			0x00000386,
-			0x00000388,
-			0x0000038A,
-			0x0000038B,
-			0x0000038D,
-			0x0000038E,
-			0x00000390,
-			0x00000392,
-			0x00000393,
-			0x00000395,
-			0x00000396,
-			0x00000398,
-			0x00000399,
-			0x0000039B,
-			0x0000039C,
-			0x0000039E,
-			0x0000039F,
-			0x000003A1,
-			0x000003A2,
-			0x000003A4,
-			0x000003A5,
-			0x000003A7,
-			0x000003A8,
-			0x000003AA,
-			0x000003AB,
-			0x000003AD,
-			0x000003AE,
-			0x000003B0,
-			0x000003B1,
-			0x000003B3,
-			0x000003B4,
-			0x000003B5,
-			0x000003B7,
-			0x000003B8,
-			0x000003BA,
-			0x000003BB,
-			0x000003BD,
-			0x000003BE,
-			0x000003BF,
-			0x000003C1,
-			0x000003C2,
-			0x000003C4,
-			0x000003C5,
-			0x000003C6,
-			0x000003C8,
-			0x000003C9,
-			0x000003CA,
-			0x000003CC,
-			0x000003CD,
-			0x000003CE,
-			0x000003D0,
-			0x000003D1,
-			0x000003D2,
-			0x000003D4,
-			0x000003D5,
-			0x000003D6,
-			0x000003D8,
-			0x000003D9,
-			0x000003DA,
-			0x000003DC,
-			0x000003DD,
-			0x000003DE,
-			0x000003E0,
-			0x000003E1,
-			0x000003E2,
-			0x000003E3,
-			0x000003E5,
-			0x000003E6,
-			0x000003E7,
-			0x000003E9,
-			0x000003EA,
-			0x000003EB,
-			0x000003EC,
-			0x000003EE,
-			0x000003EF,
-			0x000003F0,
-			0x000003F1,
-			0x000003F3,
-			0x000003F4,
-			0x000003F5,
-			0x000003F6,
-			0x000003F8,
-			0x000003F9,
-			0x000003FA,
-			0x000003FB,
-			0x000003FC,
-			0x000003FE,
-			0x000003FF,
-			0x000003FF,
-		},
-		// curve_ratio = 0.4
-		{
-			0x00000000,
-			0x0000006F,
-			0x00000093,
-			0x000000AD,
-			0x000000C2,
-			0x000000D4,
-			0x000000E4,
-			0x000000F3,
-			0x00000100,
-			0x0000010C,
-			0x00000118,
-			0x00000123,
-			0x0000012D,
-			0x00000137,
-			0x00000140,
-			0x00000149,
-			0x00000152,
-			0x0000015A,
-			0x00000162,
-			0x0000016A,
-			0x00000171,
-			0x00000179,
-			0x00000180,
-			0x00000187,
-			0x0000018D,
-			0x00000194,
-			0x0000019A,
-			0x000001A0,
-			0x000001A7,
-			0x000001AD,
-			0x000001B2,
-			0x000001B8,
-			0x000001BE,
-			0x000001C3,
-			0x000001C9,
-			0x000001CE,
-			0x000001D3,
-			0x000001D8,
-			0x000001DD,
-			0x000001E2,
-			0x000001E7,
-			0x000001EC,
-			0x000001F1,
-			0x000001F6,
-			0x000001FA,
-			0x000001FF,
-			0x00000203,
-			0x00000208,
-			0x0000020C,
-			0x00000211,
-			0x00000215,
-			0x00000219,
-			0x0000021D,
-			0x00000221,
-			0x00000225,
-			0x0000022A,
-			0x0000022E,
-			0x00000232,
-			0x00000235,
-			0x00000239,
-			0x0000023D,
-			0x00000241,
-			0x00000245,
-			0x00000248,
-			0x0000024C,
-			0x00000250,
-			0x00000253,
-			0x00000257,
-			0x0000025B,
-			0x0000025E,
-			0x00000262,
-			0x00000265,
-			0x00000269,
-			0x0000026C,
-			0x0000026F,
-			0x00000273,
-			0x00000276,
-			0x00000279,
-			0x0000027D,
-			0x00000280,
-			0x00000283,
-			0x00000286,
-			0x00000289,
-			0x0000028D,
-			0x00000290,
-			0x00000293,
-			0x00000296,
-			0x00000299,
-			0x0000029C,
-			0x0000029F,
-			0x000002A2,
-			0x000002A5,
-			0x000002A8,
-			0x000002AB,
-			0x000002AE,
-			0x000002B1,
-			0x000002B4,
-			0x000002B7,
-			0x000002B9,
-			0x000002BC,
-			0x000002BF,
-			0x000002C2,
-			0x000002C5,
-			0x000002C7,
-			0x000002CA,
-			0x000002CD,
-			0x000002D0,
-			0x000002D2,
-			0x000002D5,
-			0x000002D8,
-			0x000002DA,
-			0x000002DD,
-			0x000002E0,
-			0x000002E2,
-			0x000002E5,
-			0x000002E8,
-			0x000002EA,
-			0x000002ED,
-			0x000002EF,
-			0x000002F2,
-			0x000002F4,
-			0x000002F7,
-			0x000002F9,
-			0x000002FC,
-			0x000002FE,
-			0x00000301,
-			0x00000303,
-			0x00000306,
-			0x00000308,
-			0x0000030A,
-			0x0000030D,
-			0x0000030F,
-			0x00000312,
-			0x00000314,
-			0x00000316,
-			0x00000319,
-			0x0000031B,
-			0x0000031D,
-			0x00000320,
-			0x00000322,
-			0x00000324,
-			0x00000327,
-			0x00000329,
-			0x0000032B,
-			0x0000032D,
-			0x00000330,
-			0x00000332,
-			0x00000334,
-			0x00000336,
-			0x00000339,
-			0x0000033B,
-			0x0000033D,
-			0x0000033F,
-			0x00000341,
-			0x00000344,
-			0x00000346,
-			0x00000348,
-			0x0000034A,
-			0x0000034C,
-			0x0000034E,
-			0x00000351,
-			0x00000353,
-			0x00000355,
-			0x00000357,
-			0x00000359,
-			0x0000035B,
-			0x0000035D,
-			0x0000035F,
-			0x00000361,
-			0x00000363,
-			0x00000365,
-			0x00000367,
-			0x00000369,
-			0x0000036B,
-			0x0000036D,
-			0x0000036F,
-			0x00000371,
-			0x00000373,
-			0x00000375,
-			0x00000377,
-			0x00000379,
-			0x0000037B,
-			0x0000037D,
-			0x0000037F,
-			0x00000381,
-			0x00000383,
-			0x00000385,
-			0x00000387,
-			0x00000389,
-			0x0000038B,
-			0x0000038D,
-			0x0000038F,
-			0x00000391,
-			0x00000393,
-			0x00000394,
-			0x00000396,
-			0x00000398,
-			0x0000039A,
-			0x0000039C,
-			0x0000039E,
-			0x000003A0,
-			0x000003A2,
-			0x000003A3,
-			0x000003A5,
-			0x000003A7,
-			0x000003A9,
-			0x000003AB,
-			0x000003AD,
-			0x000003AE,
-			0x000003B0,
-			0x000003B2,
-			0x000003B4,
-			0x000003B6,
-			0x000003B7,
-			0x000003B9,
-			0x000003BB,
-			0x000003BD,
-			0x000003BE,
-			0x000003C0,
-			0x000003C2,
-			0x000003C4,
-			0x000003C6,
-			0x000003C7,
-			0x000003C9,
-			0x000003CB,
-			0x000003CC,
-			0x000003CE,
-			0x000003D0,
-			0x000003D2,
-			0x000003D3,
-			0x000003D5,
-			0x000003D7,
-			0x000003D8,
-			0x000003DA,
-			0x000003DC,
-			0x000003DE,
-			0x000003DF,
-			0x000003E1,
-			0x000003E3,
-			0x000003E4,
-			0x000003E6,
-			0x000003E8,
-			0x000003E9,
-			0x000003EB,
-			0x000003ED,
-			0x000003EE,
-			0x000003F0,
-			0x000003F1,
-			0x000003F3,
-			0x000003F5,
-			0x000003F6,
-			0x000003F8,
-			0x000003FA,
-			0x000003FB,
-			0x000003FD,
-			0x000003FE,
-			0x000003FF,
-		},
-		// curve_ratio = 0.5
-		{
-			0x00000000,
-			0x00000040,
-			0x0000005B,
-			0x0000006F,
-			0x00000080,
-			0x0000008F,
-			0x0000009D,
-			0x000000A9,
-			0x000000B5,
-			0x000000C0,
-			0x000000CA,
-			0x000000D4,
-			0x000000DE,
-			0x000000E7,
-			0x000000EF,
-			0x000000F8,
-			0x00000100,
-			0x00000108,
-			0x00000110,
-			0x00000117,
-			0x0000011E,
-			0x00000125,
-			0x0000012C,
-			0x00000133,
-			0x0000013A,
-			0x00000140,
-			0x00000146,
-			0x0000014D,
-			0x00000153,
-			0x00000159,
-			0x0000015F,
-			0x00000164,
-			0x0000016A,
-			0x00000170,
-			0x00000175,
-			0x0000017B,
-			0x00000180,
-			0x00000185,
-			0x0000018B,
-			0x00000190,
-			0x00000195,
-			0x0000019A,
-			0x0000019F,
-			0x000001A4,
-			0x000001A9,
-			0x000001AD,
-			0x000001B2,
-			0x000001B7,
-			0x000001BB,
-			0x000001C0,
-			0x000001C5,
-			0x000001C9,
-			0x000001CE,
-			0x000001D2,
-			0x000001D6,
-			0x000001DB,
-			0x000001DF,
-			0x000001E3,
-			0x000001E7,
-			0x000001EC,
-			0x000001F0,
-			0x000001F4,
-			0x000001F8,
-			0x000001FC,
-			0x00000200,
-			0x00000204,
-			0x00000208,
-			0x0000020C,
-			0x00000210,
-			0x00000214,
-			0x00000217,
-			0x0000021B,
-			0x0000021F,
-			0x00000223,
-			0x00000227,
-			0x0000022A,
-			0x0000022E,
-			0x00000232,
-			0x00000235,
-			0x00000239,
-			0x0000023C,
-			0x00000240,
-			0x00000244,
-			0x00000247,
-			0x0000024B,
-			0x0000024E,
-			0x00000252,
-			0x00000255,
-			0x00000258,
-			0x0000025C,
-			0x0000025F,
-			0x00000263,
-			0x00000266,
-			0x00000269,
-			0x0000026D,
-			0x00000270,
-			0x00000273,
-			0x00000276,
-			0x0000027A,
-			0x0000027D,
-			0x00000280,
-			0x00000283,
-			0x00000286,
-			0x0000028A,
-			0x0000028D,
-			0x00000290,
-			0x00000293,
-			0x00000296,
-			0x00000299,
-			0x0000029C,
-			0x0000029F,
-			0x000002A2,
-			0x000002A5,
-			0x000002A8,
-			0x000002AB,
-			0x000002AE,
-			0x000002B1,
-			0x000002B4,
-			0x000002B7,
-			0x000002BA,
-			0x000002BD,
-			0x000002C0,
-			0x000002C3,
-			0x000002C6,
-			0x000002C9,
-			0x000002CC,
-			0x000002CE,
-			0x000002D1,
-			0x000002D4,
-			0x000002D7,
-			0x000002DA,
-			0x000002DD,
-			0x000002DF,
-			0x000002E2,
-			0x000002E5,
-			0x000002E8,
-			0x000002EA,
-			0x000002ED,
-			0x000002F0,
-			0x000002F3,
-			0x000002F5,
-			0x000002F8,
-			0x000002FB,
-			0x000002FD,
-			0x00000300,
-			0x00000303,
-			0x00000305,
-			0x00000308,
-			0x0000030B,
-			0x0000030D,
-			0x00000310,
-			0x00000312,
-			0x00000315,
-			0x00000318,
-			0x0000031A,
-			0x0000031D,
-			0x0000031F,
-			0x00000322,
-			0x00000324,
-			0x00000327,
-			0x0000032A,
-			0x0000032C,
-			0x0000032F,
-			0x00000331,
-			0x00000334,
-			0x00000336,
-			0x00000339,
-			0x0000033B,
-			0x0000033E,
-			0x00000340,
-			0x00000342,
-			0x00000345,
-			0x00000347,
-			0x0000034A,
-			0x0000034C,
-			0x0000034F,
-			0x00000351,
-			0x00000353,
-			0x00000356,
-			0x00000358,
-			0x0000035B,
-			0x0000035D,
-			0x0000035F,
-			0x00000362,
-			0x00000364,
-			0x00000366,
-			0x00000369,
-			0x0000036B,
-			0x0000036E,
-			0x00000370,
-			0x00000372,
-			0x00000374,
-			0x00000377,
-			0x00000379,
-			0x0000037B,
-			0x0000037E,
-			0x00000380,
-			0x00000382,
-			0x00000385,
-			0x00000387,
-			0x00000389,
-			0x0000038B,
-			0x0000038E,
-			0x00000390,
-			0x00000392,
-			0x00000394,
-			0x00000397,
-			0x00000399,
-			0x0000039B,
-			0x0000039D,
-			0x0000039F,
-			0x000003A2,
-			0x000003A4,
-			0x000003A6,
-			0x000003A8,
-			0x000003AA,
-			0x000003AD,
-			0x000003AF,
-			0x000003B1,
-			0x000003B3,
-			0x000003B5,
-			0x000003B7,
-			0x000003BA,
-			0x000003BC,
-			0x000003BE,
-			0x000003C0,
-			0x000003C2,
-			0x000003C4,
-			0x000003C6,
-			0x000003C8,
-			0x000003CB,
-			0x000003CD,
-			0x000003CF,
-			0x000003D1,
-			0x000003D3,
-			0x000003D5,
-			0x000003D7,
-			0x000003D9,
-			0x000003DB,
-			0x000003DD,
-			0x000003DF,
-			0x000003E2,
-			0x000003E4,
-			0x000003E6,
-			0x000003E8,
-			0x000003EA,
-			0x000003EC,
-			0x000003EE,
-			0x000003F0,
-			0x000003F2,
-			0x000003F4,
-			0x000003F6,
-			0x000003F8,
-			0x000003FA,
-			0x000003FC,
-			0x000003FE,
-			0x000003FF,
-		},
-		// curve_ratio = 0.6
-		{
-			0x00000000,
-			0x00000025,
-			0x00000038,
-			0x00000047,
-			0x00000054,
-			0x00000061,
-			0x0000006C,
-			0x00000076,
-			0x00000080,
-			0x00000089,
-			0x00000092,
-			0x0000009B,
-			0x000000A3,
-			0x000000AB,
-			0x000000B3,
-			0x000000BB,
-			0x000000C2,
-			0x000000C9,
-			0x000000D0,
-			0x000000D7,
-			0x000000DE,
-			0x000000E4,
-			0x000000EB,
-			0x000000F1,
-			0x000000F7,
-			0x000000FE,
-			0x00000104,
-			0x0000010A,
-			0x0000010F,
-			0x00000115,
-			0x0000011B,
-			0x00000121,
-			0x00000126,
-			0x0000012C,
-			0x00000131,
-			0x00000136,
-			0x0000013C,
-			0x00000141,
-			0x00000146,
-			0x0000014B,
-			0x00000150,
-			0x00000155,
-			0x0000015A,
-			0x0000015F,
-			0x00000164,
-			0x00000169,
-			0x0000016E,
-			0x00000172,
-			0x00000177,
-			0x0000017C,
-			0x00000180,
-			0x00000185,
-			0x0000018A,
-			0x0000018E,
-			0x00000193,
-			0x00000197,
-			0x0000019B,
-			0x000001A0,
-			0x000001A4,
-			0x000001A8,
-			0x000001AD,
-			0x000001B1,
-			0x000001B5,
-			0x000001BA,
-			0x000001BE,
-			0x000001C2,
-			0x000001C6,
-			0x000001CA,
-			0x000001CE,
-			0x000001D2,
-			0x000001D6,
-			0x000001DA,
-			0x000001DE,
-			0x000001E2,
-			0x000001E6,
-			0x000001EA,
-			0x000001EE,
-			0x000001F2,
-			0x000001F6,
-			0x000001FA,
-			0x000001FE,
-			0x00000201,
-			0x00000205,
-			0x00000209,
-			0x0000020D,
-			0x00000210,
-			0x00000214,
-			0x00000218,
-			0x0000021C,
-			0x0000021F,
-			0x00000223,
-			0x00000227,
-			0x0000022A,
-			0x0000022E,
-			0x00000231,
-			0x00000235,
-			0x00000238,
-			0x0000023C,
-			0x00000240,
-			0x00000243,
-			0x00000247,
-			0x0000024A,
-			0x0000024E,
-			0x00000251,
-			0x00000254,
-			0x00000258,
-			0x0000025B,
-			0x0000025F,
-			0x00000262,
-			0x00000265,
-			0x00000269,
-			0x0000026C,
-			0x00000270,
-			0x00000273,
-			0x00000276,
-			0x0000027A,
-			0x0000027D,
-			0x00000280,
-			0x00000283,
-			0x00000287,
-			0x0000028A,
-			0x0000028D,
-			0x00000290,
-			0x00000294,
-			0x00000297,
-			0x0000029A,
-			0x0000029D,
-			0x000002A0,
-			0x000002A4,
-			0x000002A7,
-			0x000002AA,
-			0x000002AD,
-			0x000002B0,
-			0x000002B3,
-			0x000002B6,
-			0x000002BA,
-			0x000002BD,
-			0x000002C0,
-			0x000002C3,
-			0x000002C6,
-			0x000002C9,
-			0x000002CC,
-			0x000002CF,
-			0x000002D2,
-			0x000002D5,
-			0x000002D8,
-			0x000002DB,
-			0x000002DE,
-			0x000002E1,
-			0x000002E4,
-			0x000002E7,
-			0x000002EA,
-			0x000002ED,
-			0x000002F0,
-			0x000002F3,
-			0x000002F6,
-			0x000002F9,
-			0x000002FC,
-			0x000002FF,
-			0x00000301,
-			0x00000304,
-			0x00000307,
-			0x0000030A,
-			0x0000030D,
-			0x00000310,
-			0x00000313,
-			0x00000316,
-			0x00000318,
-			0x0000031B,
-			0x0000031E,
-			0x00000321,
-			0x00000324,
-			0x00000327,
-			0x00000329,
-			0x0000032C,
-			0x0000032F,
-			0x00000332,
-			0x00000335,
-			0x00000337,
-			0x0000033A,
-			0x0000033D,
-			0x00000340,
-			0x00000342,
-			0x00000345,
-			0x00000348,
-			0x0000034B,
-			0x0000034D,
-			0x00000350,
-			0x00000353,
-			0x00000356,
-			0x00000358,
-			0x0000035B,
-			0x0000035E,
-			0x00000360,
-			0x00000363,
-			0x00000366,
-			0x00000368,
-			0x0000036B,
-			0x0000036E,
-			0x00000370,
-			0x00000373,
-			0x00000376,
-			0x00000378,
-			0x0000037B,
-			0x0000037E,
-			0x00000380,
-			0x00000383,
-			0x00000385,
-			0x00000388,
-			0x0000038B,
-			0x0000038D,
-			0x00000390,
-			0x00000392,
-			0x00000395,
-			0x00000398,
-			0x0000039A,
-			0x0000039D,
-			0x0000039F,
-			0x000003A2,
-			0x000003A4,
-			0x000003A7,
-			0x000003AA,
-			0x000003AC,
-			0x000003AF,
-			0x000003B1,
-			0x000003B4,
-			0x000003B6,
-			0x000003B9,
-			0x000003BB,
-			0x000003BE,
-			0x000003C0,
-			0x000003C3,
-			0x000003C5,
-			0x000003C8,
-			0x000003CA,
-			0x000003CD,
-			0x000003CF,
-			0x000003D2,
-			0x000003D4,
-			0x000003D7,
-			0x000003D9,
-			0x000003DC,
-			0x000003DE,
-			0x000003E0,
-			0x000003E3,
-			0x000003E5,
-			0x000003E8,
-			0x000003EA,
-			0x000003ED,
-			0x000003EF,
-			0x000003F2,
-			0x000003F4,
-			0x000003F6,
-			0x000003F9,
-			0x000003FB,
-			0x000003FE,
-			0x000003FF,
-		},
-		// curve_ratio = 0.7
-		{
-			0x00000000,
-			0x00000015,
-			0x00000022,
-			0x0000002E,
-			0x00000038,
-			0x00000041,
-			0x0000004A,
-			0x00000052,
-			0x0000005B,
-			0x00000062,
-			0x0000006A,
-			0x00000071,
-			0x00000078,
-			0x0000007F,
-			0x00000086,
-			0x0000008D,
-			0x00000093,
-			0x00000099,
-			0x000000A0,
-			0x000000A6,
-			0x000000AC,
-			0x000000B2,
-			0x000000B8,
-			0x000000BE,
-			0x000000C3,
-			0x000000C9,
-			0x000000CF,
-			0x000000D4,
-			0x000000DA,
-			0x000000DF,
-			0x000000E4,
-			0x000000EA,
-			0x000000EF,
-			0x000000F4,
-			0x000000F9,
-			0x000000FE,
-			0x00000103,
-			0x00000108,
-			0x0000010D,
-			0x00000112,
-			0x00000117,
-			0x0000011C,
-			0x00000121,
-			0x00000126,
-			0x0000012B,
-			0x0000012F,
-			0x00000134,
-			0x00000139,
-			0x0000013D,
-			0x00000142,
-			0x00000146,
-			0x0000014B,
-			0x00000150,
-			0x00000154,
-			0x00000159,
-			0x0000015D,
-			0x00000161,
-			0x00000166,
-			0x0000016A,
-			0x0000016F,
-			0x00000173,
-			0x00000177,
-			0x0000017B,
-			0x00000180,
-			0x00000184,
-			0x00000188,
-			0x0000018C,
-			0x00000191,
-			0x00000195,
-			0x00000199,
-			0x0000019D,
-			0x000001A1,
-			0x000001A5,
-			0x000001A9,
-			0x000001AE,
-			0x000001B2,
-			0x000001B6,
-			0x000001BA,
-			0x000001BE,
-			0x000001C2,
-			0x000001C6,
-			0x000001CA,
-			0x000001CE,
-			0x000001D1,
-			0x000001D5,
-			0x000001D9,
-			0x000001DD,
-			0x000001E1,
-			0x000001E5,
-			0x000001E9,
-			0x000001ED,
-			0x000001F0,
-			0x000001F4,
-			0x000001F8,
-			0x000001FC,
-			0x00000200,
-			0x00000203,
-			0x00000207,
-			0x0000020B,
-			0x0000020F,
-			0x00000212,
-			0x00000216,
-			0x0000021A,
-			0x0000021D,
-			0x00000221,
-			0x00000225,
-			0x00000228,
-			0x0000022C,
-			0x00000230,
-			0x00000233,
-			0x00000237,
-			0x0000023B,
-			0x0000023E,
-			0x00000242,
-			0x00000245,
-			0x00000249,
-			0x0000024C,
-			0x00000250,
-			0x00000253,
-			0x00000257,
-			0x0000025B,
-			0x0000025E,
-			0x00000262,
-			0x00000265,
-			0x00000268,
-			0x0000026C,
-			0x0000026F,
-			0x00000273,
-			0x00000276,
-			0x0000027A,
-			0x0000027D,
-			0x00000281,
-			0x00000284,
-			0x00000287,
-			0x0000028B,
-			0x0000028E,
-			0x00000292,
-			0x00000295,
-			0x00000298,
-			0x0000029C,
-			0x0000029F,
-			0x000002A3,
-			0x000002A6,
-			0x000002A9,
-			0x000002AD,
-			0x000002B0,
-			0x000002B3,
-			0x000002B6,
-			0x000002BA,
-			0x000002BD,
-			0x000002C0,
-			0x000002C4,
-			0x000002C7,
-			0x000002CA,
-			0x000002CD,
-			0x000002D1,
-			0x000002D4,
-			0x000002D7,
-			0x000002DA,
-			0x000002DE,
-			0x000002E1,
-			0x000002E4,
-			0x000002E7,
-			0x000002EB,
-			0x000002EE,
-			0x000002F1,
-			0x000002F4,
-			0x000002F7,
-			0x000002FB,
-			0x000002FE,
-			0x00000301,
-			0x00000304,
-			0x00000307,
-			0x0000030A,
-			0x0000030D,
-			0x00000311,
-			0x00000314,
-			0x00000317,
-			0x0000031A,
-			0x0000031D,
-			0x00000320,
-			0x00000323,
-			0x00000326,
-			0x0000032A,
-			0x0000032D,
-			0x00000330,
-			0x00000333,
-			0x00000336,
-			0x00000339,
-			0x0000033C,
-			0x0000033F,
-			0x00000342,
-			0x00000345,
-			0x00000348,
-			0x0000034B,
-			0x0000034E,
-			0x00000351,
-			0x00000354,
-			0x00000357,
-			0x0000035A,
-			0x0000035D,
-			0x00000361,
-			0x00000364,
-			0x00000367,
-			0x0000036A,
-			0x0000036D,
-			0x00000370,
-			0x00000372,
-			0x00000375,
-			0x00000378,
-			0x0000037B,
-			0x0000037E,
-			0x00000381,
-			0x00000384,
-			0x00000387,
-			0x0000038A,
-			0x0000038D,
-			0x00000390,
-			0x00000393,
-			0x00000396,
-			0x00000399,
-			0x0000039C,
-			0x0000039F,
-			0x000003A2,
-			0x000003A5,
-			0x000003A8,
-			0x000003AA,
-			0x000003AD,
-			0x000003B0,
-			0x000003B3,
-			0x000003B6,
-			0x000003B9,
-			0x000003BC,
-			0x000003BF,
-			0x000003C2,
-			0x000003C4,
-			0x000003C7,
-			0x000003CA,
-			0x000003CD,
-			0x000003D0,
-			0x000003D3,
-			0x000003D6,
-			0x000003D8,
-			0x000003DB,
-			0x000003DE,
-			0x000003E1,
-			0x000003E4,
-			0x000003E7,
-			0x000003E9,
-			0x000003EC,
-			0x000003EF,
-			0x000003F2,
-			0x000003F5,
-			0x000003F8,
-			0x000003FA,
-			0x000003FD,
-			0x000003FF,
-		},
-		// curve_ratio = 0.8
-		{
-			0x00000000,
-			0x0000000C,
-			0x00000015,
-			0x0000001D,
-			0x00000025,
-			0x0000002C,
-			0x00000033,
-			0x0000003A,
-			0x00000040,
-			0x00000046,
-			0x0000004D,
-			0x00000053,
-			0x00000059,
-			0x0000005E,
-			0x00000064,
-			0x0000006A,
-			0x0000006F,
-			0x00000075,
-			0x0000007A,
-			0x00000080,
-			0x00000085,
-			0x0000008B,
-			0x00000090,
-			0x00000095,
-			0x0000009A,
-			0x0000009F,
-			0x000000A4,
-			0x000000A9,
-			0x000000AE,
-			0x000000B3,
-			0x000000B8,
-			0x000000BD,
-			0x000000C2,
-			0x000000C7,
-			0x000000CC,
-			0x000000D0,
-			0x000000D5,
-			0x000000DA,
-			0x000000DF,
-			0x000000E3,
-			0x000000E8,
-			0x000000ED,
-			0x000000F1,
-			0x000000F6,
-			0x000000FA,
-			0x000000FF,
-			0x00000103,
-			0x00000108,
-			0x0000010C,
-			0x00000111,
-			0x00000115,
-			0x0000011A,
-			0x0000011E,
-			0x00000122,
-			0x00000127,
-			0x0000012B,
-			0x00000130,
-			0x00000134,
-			0x00000138,
-			0x0000013D,
-			0x00000141,
-			0x00000145,
-			0x00000149,
-			0x0000014E,
-			0x00000152,
-			0x00000156,
-			0x0000015A,
-			0x0000015E,
-			0x00000163,
-			0x00000167,
-			0x0000016B,
-			0x0000016F,
-			0x00000173,
-			0x00000177,
-			0x0000017B,
-			0x0000017F,
-			0x00000184,
-			0x00000188,
-			0x0000018C,
-			0x00000190,
-			0x00000194,
-			0x00000198,
-			0x0000019C,
-			0x000001A0,
-			0x000001A4,
-			0x000001A8,
-			0x000001AC,
-			0x000001B0,
-			0x000001B4,
-			0x000001B8,
-			0x000001BC,
-			0x000001C0,
-			0x000001C4,
-			0x000001C8,
-			0x000001CB,
-			0x000001CF,
-			0x000001D3,
-			0x000001D7,
-			0x000001DB,
-			0x000001DF,
-			0x000001E3,
-			0x000001E7,
-			0x000001EA,
-			0x000001EE,
-			0x000001F2,
-			0x000001F6,
-			0x000001FA,
-			0x000001FE,
-			0x00000201,
-			0x00000205,
-			0x00000209,
-			0x0000020D,
-			0x00000211,
-			0x00000214,
-			0x00000218,
-			0x0000021C,
-			0x00000220,
-			0x00000223,
-			0x00000227,
-			0x0000022B,
-			0x0000022F,
-			0x00000232,
-			0x00000236,
-			0x0000023A,
-			0x0000023D,
-			0x00000241,
-			0x00000245,
-			0x00000248,
-			0x0000024C,
-			0x00000250,
-			0x00000253,
-			0x00000257,
-			0x0000025B,
-			0x0000025E,
-			0x00000262,
-			0x00000266,
-			0x00000269,
-			0x0000026D,
-			0x00000271,
-			0x00000274,
-			0x00000278,
-			0x0000027B,
-			0x0000027F,
-			0x00000283,
-			0x00000286,
-			0x0000028A,
-			0x0000028D,
-			0x00000291,
-			0x00000295,
-			0x00000298,
-			0x0000029C,
-			0x0000029F,
-			0x000002A3,
-			0x000002A6,
-			0x000002AA,
-			0x000002AD,
-			0x000002B1,
-			0x000002B5,
-			0x000002B8,
-			0x000002BC,
-			0x000002BF,
-			0x000002C3,
-			0x000002C6,
-			0x000002CA,
-			0x000002CD,
-			0x000002D1,
-			0x000002D4,
-			0x000002D8,
-			0x000002DB,
-			0x000002DF,
-			0x000002E2,
-			0x000002E5,
-			0x000002E9,
-			0x000002EC,
-			0x000002F0,
-			0x000002F3,
-			0x000002F7,
-			0x000002FA,
-			0x000002FE,
-			0x00000301,
-			0x00000305,
-			0x00000308,
-			0x0000030B,
-			0x0000030F,
-			0x00000312,
-			0x00000316,
-			0x00000319,
-			0x0000031C,
-			0x00000320,
-			0x00000323,
-			0x00000327,
-			0x0000032A,
-			0x0000032D,
-			0x00000331,
-			0x00000334,
-			0x00000338,
-			0x0000033B,
-			0x0000033E,
-			0x00000342,
-			0x00000345,
-			0x00000348,
-			0x0000034C,
-			0x0000034F,
-			0x00000353,
-			0x00000356,
-			0x00000359,
-			0x0000035D,
-			0x00000360,
-			0x00000363,
-			0x00000367,
-			0x0000036A,
-			0x0000036D,
-			0x00000371,
-			0x00000374,
-			0x00000377,
-			0x0000037B,
-			0x0000037E,
-			0x00000381,
-			0x00000384,
-			0x00000388,
-			0x0000038B,
-			0x0000038E,
-			0x00000392,
-			0x00000395,
-			0x00000398,
-			0x0000039C,
-			0x0000039F,
-			0x000003A2,
-			0x000003A5,
-			0x000003A9,
-			0x000003AC,
-			0x000003AF,
-			0x000003B2,
-			0x000003B6,
-			0x000003B9,
-			0x000003BC,
-			0x000003BF,
-			0x000003C3,
-			0x000003C6,
-			0x000003C9,
-			0x000003CC,
-			0x000003D0,
-			0x000003D3,
-			0x000003D6,
-			0x000003D9,
-			0x000003DD,
-			0x000003E0,
-			0x000003E3,
-			0x000003E6,
-			0x000003EA,
-			0x000003ED,
-			0x000003F0,
-			0x000003F3,
-			0x000003F6,
-			0x000003FA,
-			0x000003FD,
-			0x000003FF,
-		},
-		// curve_ratio = 0.9
-		{
-			0x00000000,
-			0x00000007,
-			0x0000000D,
-			0x00000013,
-			0x00000018,
-			0x0000001E,
-			0x00000023,
-			0x00000028,
-			0x0000002D,
-			0x00000032,
-			0x00000037,
-			0x0000003C,
-			0x00000041,
-			0x00000046,
-			0x0000004B,
-			0x00000050,
-			0x00000054,
-			0x00000059,
-			0x0000005E,
-			0x00000063,
-			0x00000067,
-			0x0000006C,
-			0x00000070,
-			0x00000075,
-			0x0000007A,
-			0x0000007E,
-			0x00000083,
-			0x00000087,
-			0x0000008C,
-			0x00000090,
-			0x00000095,
-			0x00000099,
-			0x0000009E,
-			0x000000A2,
-			0x000000A6,
-			0x000000AB,
-			0x000000AF,
-			0x000000B4,
-			0x000000B8,
-			0x000000BC,
-			0x000000C1,
-			0x000000C5,
-			0x000000C9,
-			0x000000CE,
-			0x000000D2,
-			0x000000D6,
-			0x000000DA,
-			0x000000DF,
-			0x000000E3,
-			0x000000E7,
-			0x000000EB,
-			0x000000F0,
-			0x000000F4,
-			0x000000F8,
-			0x000000FC,
-			0x00000101,
-			0x00000105,
-			0x00000109,
-			0x0000010D,
-			0x00000111,
-			0x00000115,
-			0x0000011A,
-			0x0000011E,
-			0x00000122,
-			0x00000126,
-			0x0000012A,
-			0x0000012E,
-			0x00000132,
-			0x00000137,
-			0x0000013B,
-			0x0000013F,
-			0x00000143,
-			0x00000147,
-			0x0000014B,
-			0x0000014F,
-			0x00000153,
-			0x00000157,
-			0x0000015B,
-			0x0000015F,
-			0x00000163,
-			0x00000167,
-			0x0000016C,
-			0x00000170,
-			0x00000174,
-			0x00000178,
-			0x0000017C,
-			0x00000180,
-			0x00000184,
-			0x00000188,
-			0x0000018C,
-			0x00000190,
-			0x00000194,
-			0x00000198,
-			0x0000019C,
-			0x000001A0,
-			0x000001A4,
-			0x000001A8,
-			0x000001AC,
-			0x000001B0,
-			0x000001B3,
-			0x000001B7,
-			0x000001BB,
-			0x000001BF,
-			0x000001C3,
-			0x000001C7,
-			0x000001CB,
-			0x000001CF,
-			0x000001D3,
-			0x000001D7,
-			0x000001DB,
-			0x000001DF,
-			0x000001E3,
-			0x000001E7,
-			0x000001EB,
-			0x000001EE,
-			0x000001F2,
-			0x000001F6,
-			0x000001FA,
-			0x000001FE,
-			0x00000202,
-			0x00000206,
-			0x0000020A,
-			0x0000020E,
-			0x00000211,
-			0x00000215,
-			0x00000219,
-			0x0000021D,
-			0x00000221,
-			0x00000225,
-			0x00000229,
-			0x0000022C,
-			0x00000230,
-			0x00000234,
-			0x00000238,
-			0x0000023C,
-			0x00000240,
-			0x00000244,
-			0x00000247,
-			0x0000024B,
-			0x0000024F,
-			0x00000253,
-			0x00000257,
-			0x0000025A,
-			0x0000025E,
-			0x00000262,
-			0x00000266,
-			0x0000026A,
-			0x0000026E,
-			0x00000271,
-			0x00000275,
-			0x00000279,
-			0x0000027D,
-			0x00000281,
-			0x00000284,
-			0x00000288,
-			0x0000028C,
-			0x00000290,
-			0x00000293,
-			0x00000297,
-			0x0000029B,
-			0x0000029F,
-			0x000002A3,
-			0x000002A6,
-			0x000002AA,
-			0x000002AE,
-			0x000002B2,
-			0x000002B5,
-			0x000002B9,
-			0x000002BD,
-			0x000002C1,
-			0x000002C4,
-			0x000002C8,
-			0x000002CC,
-			0x000002D0,
-			0x000002D3,
-			0x000002D7,
-			0x000002DB,
-			0x000002DF,
-			0x000002E2,
-			0x000002E6,
-			0x000002EA,
-			0x000002EE,
-			0x000002F1,
-			0x000002F5,
-			0x000002F9,
-			0x000002FC,
-			0x00000300,
-			0x00000304,
-			0x00000308,
-			0x0000030B,
-			0x0000030F,
-			0x00000313,
-			0x00000316,
-			0x0000031A,
-			0x0000031E,
-			0x00000322,
-			0x00000325,
-			0x00000329,
-			0x0000032D,
-			0x00000330,
-			0x00000334,
-			0x00000338,
-			0x0000033B,
-			0x0000033F,
-			0x00000343,
-			0x00000346,
-			0x0000034A,
-			0x0000034E,
-			0x00000351,
-			0x00000355,
-			0x00000359,
-			0x0000035C,
-			0x00000360,
-			0x00000364,
-			0x00000367,
-			0x0000036B,
-			0x0000036F,
-			0x00000372,
-			0x00000376,
-			0x0000037A,
-			0x0000037D,
-			0x00000381,
-			0x00000385,
-			0x00000388,
-			0x0000038C,
-			0x00000390,
-			0x00000393,
-			0x00000397,
-			0x0000039B,
-			0x0000039E,
-			0x000003A2,
-			0x000003A6,
-			0x000003A9,
-			0x000003AD,
-			0x000003B0,
-			0x000003B4,
-			0x000003B8,
-			0x000003BB,
-			0x000003BF,
-			0x000003C3,
-			0x000003C6,
-			0x000003CA,
-			0x000003CD,
-			0x000003D1,
-			0x000003D5,
-			0x000003D8,
-			0x000003DC,
-			0x000003E0,
-			0x000003E3,
-			0x000003E7,
-			0x000003EA,
-			0x000003EE,
-			0x000003F2,
-			0x000003F5,
-			0x000003F9,
-			0x000003FC,
-			0x000003FF,
-		},
-	};
-
-// echo 0x00000rgb > .../gamma_table_curve_ratio
-// curve_ratio_r/g/b: '0' for straight, '1' for ^0.1, ..., '9' for ^0.9
-
-bool set_gamma_table_with_curve_ratio(unsigned int r,unsigned int g,unsigned int b)
-{
-
-
-    bool flag = false;
-	unsigned int i = 0;
-
-    // parameter validation check
-    if ((r>9) || (g>9) || (b>9))
-    {
-        return false;
-    }
-
-    // store gamma table enable/disable status
-    flag = (RD(0x2d30)&0x10000000)?true:false;
-
-    // gamma table disable, gamma table vbus mode
-    WR(0x2d30, 0x00000001);
-
-    // point to gamma_r
-    WR(0x2dc2, 0x00000000);
-    // write gamma_r
-    for (i = 0; i < 257; i++)
-    {
-        WR(0x2dc3, gamma[r][i]);
-    }
-
-    // point to gamma_r
-    WR(0x2dc2, 0x00000000);
-    // varify gamma_r
-    for (i = 0; i < 257; i++)
-    {
-        if (gamma[r][i] != RD(0x2dc3))
-        {
-            // retrieve gamma table enable/disable status, gamma table hardware mode
-            WR(0x2d30, (flag?0x10000000:0x00000000));
-            // return with failure
-            return false;
-        }
-    }
-
-    // point to gamma_g
-    WR(0x2dc2, 0x00000200);
-    // write gamma_g
-    for (i = 0; i < 257; i++)
-    {
-        WR(0x2dc3, gamma[g][i]);
-    }
-
-    // point to gamma_g
-    WR(0x2dc2, 0x00000200);
-    // varify gamma_g
-    for (i = 0; i < 257; i++)
-    {
-        if (gamma[g][i] != RD(0x2dc3))
-        {
-            // retrieve gamma table enable/disable status, gamma table hardware mode
-            WR(0x2d30, (flag?0x10000000:0x00000000));
-            // return with failure
-            return false;
-        }
-    }
-
-    // point to gamma_b
-    WR(0x2dc2, 0x00000400);
-    // write gamma_b
-    for (i = 0; i < 257; i++)
-    {
-        WR(0x2dc3, gamma[b][i]);
-    }
-
-    // point to gamma_b
-    WR(0x2dc2, 0x00000400);
-    // varify gamma_b
-    for (i = 0; i < 257; i++)
-    {
-        if (gamma[b][i] != RD(0x2dc3))
-        {
-            // retrieve gamma table enable/disable status, gamma table hardware mode
-            WR(0x2d30, (flag?0x10000000:0x00000000));
-            // return with failure
-            return false;
-        }
-    }
-
-    // retrieve gamma table enable/disable status, gamma table hardware mode
-    WR(0x2d30, (flag?0x10000000:0x00000000));
-
-    // return with success
-    return true;
-}
-
-
diff --git a/drivers/amlogic/tvin/isp/isp_regs.h b/drivers/amlogic/tvin/isp/isp_regs.h
deleted file mode 100755
index b76291bbcd61..000000000000
--- a/drivers/amlogic/tvin/isp/isp_regs.h
+++ /dev/null
@@ -1,2213 +0,0 @@
-/*
- * ISP register bit-field definition
- * Sorted by the appearing order of registers in register.h.
- *
- * Author: bai kele <kele.bai@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __ISP_REGS_H
-#define __ISP_REGS_H
-// ----------------------------
-// ISP_FLASH_LED_CTRL
-// ----------------------------
-#define HHI_ISP_LED_CLK_CNTL                       0x1098
-//bit 31, reg_led_en //rising pulse start, falling pulse stop for torch mode
-//bit 30, reg_inc_i_st_lat //for as3685, dynamic increase current during st_latch
-//bit 29:28, reg_inv_en_pol //bit[29], invert en1, bit [28], invert en2
-//bit 27, reg_switch_en1en2  //switch output en1 and en2. For IS3231: en1 is EN, en2 is mode. 
-//bit 26, reg_force_off_mode //1: reset state machine at the falling edge no matter which state it is in
-//bit 25, reg_hold_nonstd_off_mode //hold the non-std led_off signal input before state "OFF"
-//bit 24, reg_flash_mode_timeout_en  //force to exit the Tlat state when time out, for flash mode protection
-//bit 23, reg_en1_st_ini_level //en1 level during state ST_INI
-//bit 22, reg_en2_st_set_mp_level //en2 level during state ST_SET_MP_HI, ST_SET_MP_LO
-//bit 21, reg_en1_st_off_level //en1 level during state ST_OFF
-//bit 20, reg_en2_st_off_level //en2 level during state ST_OFF
-//bit 19:12, reg_en1_mp_num  //en1 multi pulse number, up to 256 step current control
-//bit 10:0, reg_t_st_ini //Max: 85.2 us under 24M clock input
-#define ISP_LED_CTRL                        0x2198
-//bit 31:21, reg_t_en1_inc_i_st_lat_cnt //Max: 85.2us under 24M. for as3685, dynamic increase current during st_latch
-//bit 20:10, reg_t_en2_lo_st_ini //Max: 85.2 us under 24M clock input
-//bit 9:0, reg_t_en2_hi1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
-#define ISP_LED_TIMING1                     0x2199 
-//bit 31:21, reg_t_en1_mp_hi_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
-//bit 20:10, reg_t_en1_mp_lo_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
-//bit 9:0, reg_t_en2_lo1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
-#define ISP_LED_TIMING2                     0x219a 
-//bit 30:28, RO state
-//bit 25:0, reg_flash_mode_timeout_cnt //up to 2.79s at 24Mhz clk input
-#define ISP_LED_TIMING3                     0x219b  
-//bit 25:0, reg_t_st_lat_cnt //up to 2.79s, keep the led on if it's 26'h3ffffff under torch mode
-#define ISP_LED_TIMING4                     0x219c  
-//bit 31:26, reg_t_st_off_cnt[5:0] //up to 85.2us OFF state.
-//bit 25:0, reg_t_en2_hi2_st_lat_cnt //EN2 can output hi-lo-hi during ST_LATCH, this is the second hi -duration
-#define ISP_LED_TIMING5                     0x219d 
-//bit 30:26, reg_t_st_off_cnt[10:6] //up to 85.2us OFF state.
-//bit 25:0, reg_t_en1_st_lat_hold_cnt //to make sure Tlat to meat it's minimum request 500us (since non-std led_off signal may comes in anytime)
-#define ISP_LED_TIMING6                     0x219e  
-
-#define VPU_MISC_CTRL			    0x2740
-//1:bt656 2:mipi
-#define ISP_IN_SEL_BIT			    1
-#define ISP_IN_SEL_WID			    2
-#define ISP_VCBUS_BASE                      0x2d00
-
-#define ISP_HV_SIZE                         0x2d00  
-//Bit 31:29, reserved  
-#define REG_HSIZE_BIT			    16
-#define REG_HSIZE_WID			    13
-//Bit 28:16, reg_hsize                      image horizontal size (number of cols)   
-//Bit 15:13, reserved                       
-#define REG_VSIZE_BIT			    0
-#define REG_VSIZE_WID			    13
-//Bit 12: 0, reg_vsize                      image vertical size   (number of rows)  
-
-#define ISP_HBLANK                          0x2d01  
-//Bit 31:29, reserved
-#define REG_TOTAL_W_BIT				16
-#define REG_TOTAL_W_WID				13
-//Bit 15: 8, reserved
-#define REG_HBLANK_BIT			    0
-#define REG_HBLANK_WID			    8
-//Bit  7: 0, reg_hblank                     image horizontal blank length   
-#define ISP_TIMING_MODE                    0x2d02  
-//Bit 31:17, reserved                      
-//Bit    16, reg_din_timing_sw_ph           for safeing, enable this bit to disable de/vsyn/hsyn pulse sample when the input de/vsyn/hsyn polarity switch default=0   
-//Bit 15: 8, reg_out_hs_ofst                the offset of output hsync (between two de) generate after last de of each line,  default=0
-//Bit     7, reserved                       
-//Bit  6: 5, reg_frm_syn_mode               bit[0]: isp global reset generate mode   1--reg soft reset input; 0--vsyn generate reset    //     bit[1]: input data process mode based on input hsyn  1--there is hsyn input; 0--no hsyn input   default=0
-//Bit     4, reg_vs_samp_mode               vsyn posedge or negedge is sampled as trigger edge  //                                          0--posedge sample;   1--negedge sample     default=0
-//Bit     3, reserved                       
-//Bit  2: 0, reg_syn_level_invs             high-level or low-level of vsyn/hsyn/de is valid   default=0//                                          bit[2] for vsyn, 0--high-level valid    1--low is valid//                                          bit[1] for hsyn, 0--high-level valid    1--low is valid//                                          bit[0] for de  , 0--high-level valid    1--low is valid
-#define ISP_RST_DLY_NUM                    0x2d03 
-//Bit 31: 0, reg_frm_rst_dlynum             represent how many clock number delay after generated-global reset(from input vsyn or soft-reset).  default=0
-#define ISP_OUTVS_DLY_NUM                  0x2d04 
-//Bit 31: 0, reg_out_vs_dlynum              represent how many clock number delay generate the output vsync after generated-global reset(from input vsyn or soft-reset).default=0
-#define ISP_DIN_WIND_OFST                  0x2d05
-//Bit 31:29, reserved                       
-//Bit 28:16, reg_din_wind_vofst             data input window vertical top offset default=0
-//Bit 15:13, reserved                       
-//Bit 12: 0, reg_din_wind_hofst             data input window horizontal left offset default=0
-#define ISP_FRM_SOFT_RST                   0x2d06
-//Bit 31: 1, reserved                       
-//Bit     0, reg_frm_soft_rst               frm soft reset default=0
-#define ISP_RST_SYN_SEL                   0x2d07 
-//Bit 31: 0, reg_rst_syn_sel                some important reg-setting signal, such as sub-function enable, need to switch sync to 
-// the isp reset time, this signal is cfg those signal whether sync-reset enable or real-time
-// enable, when 1 is sync to reset default=32'hffffffff,
-
-
-/******** pattern generator registers***********/
-
-#define ISP_PAT_GEN_CTRL                    0x2d08  
-//Bit 31:29, reserved  
-#define ISP_PAT_ENABLE_BIT		    28
-#define ISP_PAT_ENABLE_WID		    1
-//Bit    28, reg_isp_pat_enable             enable of pattern generator data path, 0- disable; 1- enable; default=0    
-#define ISP_PAT_XINVT_BIT		    27
-#define ISP_PAT_XINVT_WID		    1
-//Bit    27, reg_isp_pat_xinvt             invert the pattern in horizontal direction, 0- no invert; 1- invert; default=0 
-#define ISP_PAT_YINVT_BIT		    26
-#define ISP_PAT_YINVT_WID		    1
-//Bit    26, reg_isp_pat_yinvt              invert the pattern in vertical direction,   0- no invert; 1- invert; default=0 
-#define PAT_BAYER_FMT_BIT		    24//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-#define PAT_BAYER_FMT_WID		    2
-//Bit    24, reg_isp_pat_yphase_ofst        bayer pattern yphase offset in pattern generator, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0
-//Bit    23, reserved
-#define ISP_PAT_XMODE_BIT	            20
-#define ISP_PAT_XMODE_WID		    3
-//Bit 22:20, reg_isp_pat_xmode              pattern horizontal mode, 0: raster/bar16/burst; 1; ramp-up; 2/up: normalized gain of horizontal dirrection (no change); default = 0
-//Bit    19, reserved                       
-#define ISP_PAT_YMODE_BIT		    16
-#define ISP_PAT_YMODE_WID		    3
-//Bit 18:16, reg_isp_pat_ymode              pattern vertical mode, 0: raster/bar16/burst; 1; ramp-up; 2/up: normalized gain of vertical dirrection (no change); default = 0
-//Bit 15: 2, reserved 
-#define ISP_PAT_DFT_MODE_BIT		    0
-#define ISP_PAT_DFT_MODE_WID	            2
-//Bit  1: 0, reg_isp_pat_dft_mode           defect pixel emulatiion mode in pattern generator; 0: no dft; 1: dead pixel (black); 2: hot pixel; 3:not dft default =0;
-
-#define ISP_PAT_XRAMP_SCAL                  0x2d09  
-//Bit 31:16, reserved
-#define PAT_XRMP_SCALE_R_BIT		    16
-#define PAT_XRMP_SCALE_R_WID		    8
-//Bit 23:16, reg_isp_pat_xrmp_scale_r       ramp pattern horizontal scale for red channel,  default= 255
-#define PAT_XRMP_SCALE_G_BIT		    8
-#define PAT_XRMP_SCALE_G_WID		    8
-//Bit 15: 8, reg_isp_pat_xrmp_scale_g       ramp pattern horizontal scale for green channel,default= 255
-#define PAT_XRMP_SCALE_B_BIT		    0
-#define PAT_XRMP_SCALE_B_WID		    8
-//Bit  7: 0, reg_isp_pat_xrmp_scale_b       ramp pattern horizontal scale for blue channel, default= 255
-
-#define ISP_PAT_YRAMP_SCAL                  0x2d0a  
-//Bit 31:16, reserved
-#define PAT_YRMP_SCALE_R_BIT		    16
-#define PAT_YRMP_SCALE_R_WID		    8
-//Bit 23:16, reg_isp_pat_yrmp_scale_r       ramp pattern horizontal scale for red channel,   default= 255
-#define PAT_YRMP_SCALE_G_BIT		    8
-#define PAT_YRMP_SCALE_G_WID	            8
-//Bit 15: 8, reg_isp_pat_yrmp_scale_g       ramp pattern horizontal scale for green channel, default= 255
-#define PAT_YRMP_SCALE_B_BIT		    0
-#define PAT_YRMP_SCALE_B_WID		    8
-//Bit  7: 0, reg_isp_pat_yrmp_scale_b       ramp pattern horizontal scale for blue channel,  default= 255
-
-#define ISP_PAT_XYIDX_OFST                  0x2d0b  
-//Bit 31:29, reserved  
-#define PAT_XIEX_OFSET_BIT		    16
-#define PAT_XIEX_OFSET_WID		    13
-//Bit 28:16, reg_isp_pat_xidx_ofset         horizontal index ofset for pattern generation. default=0    
-//Bit 15:13, reserved  
-#define PAT_YIEX_OFSET_BIT		    0
-#define PAT_YIEX_OFSET_WID		    13
-//Bit 12: 0, reg_isp_pat_yidx_ofset         vertical index ofset for pattern generation. default=0 
-
-#define ISP_PAT_XYIDX_SCAL                  0x2d0c  
-//Bit 31:30, reserved  
-#define PAT_XIEX_RSHFT_BIT		    28
-#define PAT_XIEX_RSHFT_WID		    2
-//Bit 29:28, reg_isp_pat_xidx_rshft         pattern generator horizontal index scale right shift, 0~3: scale normalized to divx=2^(6-rshft); default = 0 
-#define PAT_XIDX_SCALE_BIT		    16
-#define PAT_XIDX_SCALE_WID		    12
-//Bit 27:16, reg_isp_pat_xidx_scale         pattern generator horizontal index scale. default=ceil((1024/reg_hsize)*divx) will cover one pattern cycle horizontally
-//Bit 15:14, reserved                       
-#define PAT_YIEX_RSHFT_BIT		    12
-#define PAT_YIEX_RSHFT_WID		    2
-//Bit 13:12, reg_isp_pat_yidx_rshft         pattern generator horizontal index scale right shift, 0~3: scale normalized to divy=2^(6-rshft); default = 0 
-#define PAT_YIDX_SCALE_BIT		    0
-#define PAT_YIDX_SCALE_WID		    12
-//Bit 11: 0, reg_isp_pat_yidx_scale         pattern generator horizontal index scale. ceil((1024/reg_vsize)*divy) will cover one pattern cycle vertically
-
-#define ISP_PAT_BAR16_RED0                  0x2d0d  
-#define PAT_BAR16RGB_R3_BIT		    24
-#define PAT_BAR16RGB_R3_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_r3     pattern generator 4th bar red value. 0~255.   default= 0
-#define PAT_BAR16RGB_R2_BIT		    16
-#define PAT_BAR16RGB_R2_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_r2     pattern generator 3rd bar red value. 0~255.   default= 0
-#define PAT_BAR16RGB_R1_BIT		    8
-#define PAT_BAR16RGB_R1_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_r1     pattern generator 2nd bar red value. 0~255.   default= 255
-#define PAT_BAR16RGB_R0_BIT		    0
-#define PAT_BAR16RGB_R0_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_r0     pattern generator 1st bar red value. 0~255.   default= 255
-
-#define ISP_PAT_BAR16_RED1                  0x2d0e  
-#define PAT_BAR16RGB_R7_BIT		    24
-#define PAT_BAR16RGB_R7_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_r7     pattern generator 7th bar red value. 0~255.   default= 0
-#define PAT_BAR16RGB_R6_BIT		    16
-#define PAT_BAR16RGB_R6_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_r6     pattern generator 6th bar red value. 0~255.   default= 0
-#define PAT_BAR16RGB_R5_BIT		    8
-#define PAT_BAR16RGB_R5_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_r5     pattern generator 5th bar red value. 0~255.   default= 255
-#define PAT_BAR16RGB_R4_BIT		    0
-#define PAT_BAR16RGB_R4_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_r4     pattern generator 4th bar red value. 0~255.   default= 255
-
-#define ISP_PAT_BAR16_RED2                  0x2d0f  
-#define PAT_BAR16RGB_R11_BIT		    24
-#define PAT_BAR16RGB_R11_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_r11    pattern generator 11th bar red value. 0~255.   default= 128
-#define PAT_BAR16RGB_R10_BIT	            16
-#define PAT_BAR16RGB_R10_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_r10    pattern generator 10th bar red value. 0~255.   default= 96
-#define PAT_BAR16RGB_R9_BIT		    8
-#define PAT_BAR16RGB_R9_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_r9     pattern generator  9th bar red value. 0~255.   default= 64
-#define PAT_BAR16RGB_R8_BIT		    0
-#define PAT_BAR16RGB_R8_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_r8     pattern generator  8th bar red value. 0~255.   default= 32
-
-#define ISP_PAT_BAR16_RED3                  0x2d10  
-#define PAT_BAR16RGB_R15_BIT		    24
-#define PAT_BAR16RGB_R15_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_r15    pattern generator 15th bar red value. 0~255.   default= 255
-#define PAT_BAR16RGB_R14_BIT		    16
-#define PAT_BAR16RGB_R14_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_r14    pattern generator 14th bar red value. 0~255.   default= 224
-#define PAT_BAR16RGB_R13_BIT		    8
-#define PAT_BAR16RGB_R13_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_r13    pattern generator 13th bar red value. 0~255.   default= 192
-#define PAT_BAR16RGB_R12_BIT		    0
-#define PAT_BAR16RGB_R12_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_r12    pattern generator 12th bar red value. 0~255.   default= 160
-
-#define ISP_PAT_BAR16_GRN0                  0x2d11  
-#define PAT_BAR16RGB_G3_BIT		    24
-#define PAT_BAR16RGB_G3_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_g3     pattern generator 4th bar green value. 0~255.   default= 255
-#define PAT_BAR16RGB_G2_BIT		    16
-#define PAT_BAR16RGB_G2_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_g2     pattern generator 3rd bar green value. 0~255.   default= 255
-#define PAT_BAR16RGB_G1_BIT		    8
-#define PAT_BAR16RGB_G1_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_g1     pattern generator 2nd bar green value. 0~255.   default= 255
-#define PAT_BAR16RGB_G0_BIT		    0
-#define PAT_BAR16RGB_G0_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_g0     pattern generator 1st bar green value. 0~255.   default= 255
-
-#define ISP_PAT_BAR16_GRN1                  0x2d12 
-#define PAT_BAR16RGB_G7_BIT		    24
-#define PAT_BAR16RGB_G7_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_g7     pattern generator 7th bar green value. 0~255.   default= 0
-#define PAT_BAR16RGB_G6_BIT		    16
-#define PAT_BAR16RGB_G6_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_g6     pattern generator 6th bar green value. 0~255.   default= 0
-#define PAT_BAR16RGB_G5_BIT		    8
-#define PAT_BAR16RGB_G5_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_g5     pattern generator 5th bar green value. 0~255.   default= 0
-#define PAT_BAR16RGB_G4_BIT		    0
-#define PAT_BAR16RGB_G4_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_g4     pattern generator 4th bar green value. 0~255.   default= 0
-
-#define ISP_PAT_BAR16_GRN2                  0x2d13  
-#define PAT_BAR16RGB_G11_BIT		    24
-#define PAT_BAR16RGB_G11_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_g11    pattern generator 11th bar green value. 0~255.   default= 128
-#define PAT_BAR16RGB_G10_BIT		    16
-#define PAT_BAR16RGB_G10_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_g10    pattern generator 10th bar green value. 0~255.   default= 96
-#define PAT_BAR16RGB_G9_BIT		    8
-#define PAT_BAR16RGB_G9_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_g9    pattern generator  9th bar green value. 0~255.   default= 64
-#define PAT_BAR16RGB_G8_BIT		    0
-#define PAT_BAR16RGB_G8_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_g8    pattern generator  8th bar green value. 0~255.   default= 32
-
-#define ISP_PAT_BAR16_GRN3                  0x2d14
-#define PAT_BAR16RGB_G15_BIT		    24
-#define PAT_BAR16RGB_G15_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_g15    pattern generator 15th bar green value. 0~255.   default= 255
-#define PAT_BAR16RGB_G14_BIT		    16
-#define PAT_BAR16RGB_G14_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_g14    pattern generator 14th bar green value. 0~255.   default= 224
-#define PAT_BAR16RGB_G13_BIT		    8
-#define PAT_BAR16RGB_G13_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_g13    pattern generator 13th bar green value. 0~255.   default= 192
-#define PAT_BAR16RGB_G12_BIT		    0
-#define PAT_BAR16RGB_G12_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_g12    pattern generator 12th bar green value. 0~255.   default= 160 
-
-#define ISP_PAT_BAR16_BLU0                  0x2d15       
-#define PAT_BAR16RGB_B3_BIT		    24
-#define PAT_BAR16RGB_B3_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_b3     pattern generator 4th bar green value. 0~255.   default= 0  
-#define PAT_BAR16RGB_B2_BIT		    16
-#define PAT_BAR16RGB_B2_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_b2     pattern generator 3rd bar green value. 0~255.   default= 255  
-#define PAT_BAR16RGB_B1_BIT		    8
-#define PAT_BAR16RGB_B1_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_b1     pattern generator 2nd bar green value. 0~255.   default= 0  
-#define PAT_BAR16RGB_B0_BIT		    0
-#define PAT_BAR16RGB_B0_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_b0     pattern generator 1st bar green value. 0~255.   default= 255   
-
-#define ISP_PAT_BAR16_BLU1                  0x2d16
-#define PAT_BAR16RGB_B7_BIT		    24
-#define PAT_BAR16RGB_B7_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_b7     pattern generator 7th bar green value. 0~255.   default= 0    
-#define PAT_BAR16RGB_B6_BIT		    16
-#define PAT_BAR16RGB_B6_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_b6     pattern generator 6th bar green value. 0~255.   default= 255    
-#define PAT_BAR16RGB_B5_BIT		    8
-#define PAT_BAR16RGB_B5_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_b5     pattern generator 5th bar green value. 0~255.   default= 0    
-#define PAT_BAR16RGB_B4_BIT		    0
-#define PAT_BAR16RGB_B4_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_b4     pattern generator 4th bar green value. 0~255.   default= 255     
-
-#define ISP_PAT_BAR16_BLU2                  0x2d17    
-#define PAT_BAR16RGB_B11_BIT		    24
-#define PAT_BAR16RGB_B11_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_b11    pattern generator 11th bar green value. 0~255.   default= 128
-#define PAT_BAR16RGB_B10_BIT		    16
-#define PAT_BAR16RGB_B10_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_b10    pattern generator 10th bar green value. 0~255.   default= 96 
-#define PAT_BAR16RGB_B9_BIT		    8
-#define PAT_BAR16RGB_B9_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_b9     pattern generator  9th bar green value. 0~255.   default= 64 
-#define PAT_BAR16RGB_B8_BIT		    0
-#define PAT_BAR16RGB_B8_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_b8     pattern generator  8th bar green value. 0~255.   default= 32                                                                                                       
-
-#define ISP_PAT_BAR16_BLU3                  0x2d18
-#define PAT_BAR16RGB_B15_BIT		    24
-#define PAT_BAR16RGB_B15_WID		    8
-//Bit 31:24, reg_isp_pat_bar16rgb_b15    pattern generator 15th bar green value. 0~255.   default= 255
-#define PAT_BAR16RGB_B14_BIT		    16
-#define PAT_BAR16RGB_B14_WID		    8
-//Bit 23:16, reg_isp_pat_bar16rgb_b14    pattern generator 14th bar green value. 0~255.   default= 224
-#define PAT_BAR16RGB_B13_BIT		    8
-#define PAT_BAR16RGB_B13_WID		    8
-//Bit 15: 8, reg_isp_pat_bar16rgb_b13    pattern generator 13th bar green value. 0~255.   default= 192
-#define PAT_BAR16RGB_B12_BIT		    0
-#define PAT_BAR16RGB_B12_WID		    8
-//Bit  7: 0, reg_isp_pat_bar16rgb_b12    pattern generator 12th bar green value. 0~255.   default= 160                                                                                                      
-
-#define ISP_PAT_DFT_XYIDX                   0x2d19  
-//Bit 31:29, reserved  
-#define PAT_DFT_XIDEX_BIT		    16
-#define PAT_DFT_XIDEX_WID		    13
-//Bit 28:16, reg_isp_pat_dft_xidx           horizontal index of defect region center for pattern generation. default=100    
-//Bit 15:13, reserved   
-#define PAT_DFT_YIDEX_BIT		    0
-#define PAT_DFT_YIDEX_WID		    13
-//Bit 12: 0, reg_isp_pat_dft_yidx           ver index of defect region center for pattern generation. default=200 
-
-#define ISP_PAT_DFT_XYWID                   0x2d1a  
-//Bit 31:29, reserved  
-#define PAT_DFT_XWID_BIT		    16
-#define PAT_DFT_XWID_WID		    13
-//Bit 28:16, reg_isp_pat_dft_xwid           horizontal half width of defect region for pattern generation. width = 2x+1, default=1    
-//Bit 15:13, reserved                    
-#define PAT_DFT_YWID_BIT		    0
-#define PAT_DFT_YWID_WID		    13
-//Bit 12: 0, reg_isp_pat_dft_ywid           vertical half width of defect region for pattern generation. width = 2y+1, default=64
-
-#define ISP_PAT_DFT_GAIN                    0x2d1b  
-//Bit 31:30, reserved  
-#define PAT_DFT_GAINGRBG0_BIT		    24
-#define PAT_DFT_GAINGRBG0_WID		    6
-//Bit 29:24, reg_isp_pat_dft_gaingrbg0   lazy or active pixel gain of green channel (phase0). <32 means lazy pixel, >32 means active, 32: means normal; default=0    
-//Bit 23:22, reserved    
-#define PAT_DFT_GAINGRBG1_BIT		    21
-#define PAT_DFT_GAINGRBG1_WID		    6
-//Bit 21:16, reg_isp_pat_dft_gaingrbg1   lazy or active pixel gain of red channel (phase1). <32 means lazy pixel, >32 means active, 32: means normal; default=0   
-//Bit 15:14, reserved   
-#define PAT_DFT_GAINGRBG2_BIT		    8
-#define PAT_DFT_GAINGRBG2_WID		    6
-//Bit 13: 8, reg_isp_pat_dft_gaingrbg2   lazy or active pixel gain of blue channel (phase2). <32 means lazy pixel, >32 means active, 32: means normal; default=0   
-//Bit  7: 6, reserved
-#define PAT_DFT_GAINGRBG3_BIT		    0
-#define PAT_DFT_GAINGRBG3_WID		    6
-//Bit  5: 0, reg_isp_pat_dft_gaingrbg3   lazy or active pixel gain of green channel (phase3). <32 means lazy pixel, >32 means active, 32: means normal; default=0  
-
-#define ISP_PAT_HVTOTAL                     0x2d1c 
-//Bit 31:16, reg_isp_pat_vtotal             default=490    
-//Bit 15: 0, reg_isp_pat_htotal             default=760
-#define ISP_PAT_VDE_SLINE                   0x2d1d
-//Bit 31:29, reserved  
-//Bit 15: 0, reg_isp_pat_vde_sline          default=64
-#define ISP_OUTHS_PARA                      0x2d1e 
-//Bit 31:16, reg_ouths_pre_dist             represent the output hsyn inter-distance when need some output hsyn in the head of each frame  default=0        
-//Bit 15: 8, reserved                     
-//Bit  7: 0, reg_ouths_pre_num              how many output hsyn is needed in the head of each frame   default=0        
-#define ISP_FRM_DONE_PARA                   0x2d1f 
-//Bit 31:17, reserved                      
-//Bit    16, reg_isp_intr_sel               isp interrupt source select  0--generated global reset 1--isp real frame process done  default=0       
-//Bit 15: 0, reg_frm_done_dlynum            how many time frame done delay as the finally done  default=128        
-
-
-
-/*********** Clamp and Gain module registers************/
-
-#define ISP_CLAMPGAIN_CTRL                  0x2d20  
-//Bit 31:26, reserved
-#define CLP_BAYER_FMT_BIT		    24//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-#define CLP_BAYER_FMT_WID		    2
-//Bit    24, reg_isp_clp_yphase_ofst        bayer pattern yphase offset in clamp gain, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
-//Bit 23:22, reserved
-#define AECRAW_LPF_SEL_BIT		    20
-#define AECRAW_LPF_SEL_WID		    2
-//Bit 21:20, reg_isp_aecraw_lpf_sel         low-pass filter mode for raw data components too bright statistics for auto exposure. 0: no lpf; 1:[1 2 1]/4; 2: [1 2 2 2 1]/8; 3:[1 2 3 4 3 2 1]/16; default = 0
-//Bit 19:18, reserved            
-#define BANDSPLIT_MODE_BIT		    16
-#define BANDSPLIT_MODE_WID		    2
-//Bit 17:16, reg_isp_bandsplit_mode         bandsplit filter mode for clamp and gain,  0- no lpf; 1: [1 2 1]/4; 2:[1 2 2 2 1]/8; 3: [1 2 3 4 3 2 1]/4;   default= 0
-//Bit 15: 8, reserved
-#define BANDSPLIT_USK_BIT		    0
-#define BANDSPLIT_USK_WID		    8
-//Bit  7: 0, reg_isp_bandsplit_usk          digital gain to unsharped highpass portion of each channel before adding back, 0~255, 32 normalized to '1'.  default= 32
-
-#define ISP_GAIN_BSCORE_GRBG                0x2d21
-#define BANDSPLIT_CORE0_BIT		    24
-#define BANDSPLIT_CORE0_WID		    8
-//Bit 31:24, reg_isp_bandsplit_core0     coring to unsharp part of green (phase0) channel.   default= 0
-#define BANDSPLIT_CORE1_BIT		    16
-#define BANDSPLIT_CORE1_WID		    8
-//Bit 23:16, reg_isp_bandsplit_core1     coring to unsharp part of red   (phase1) channel.   default= 0
-#define BANDSPLIT_CORE2_BIT		    8
-#define BANDSPLIT_CORE2_WID		    8
-//Bit 15: 8, reg_isp_bandsplit_core2     coring to unsharp part of blue  (phase2) channel.   default= 0
-#define BANDSPLIT_CORE3_BIT		    0
-#define BANDSPLIT_CORE3_WID		    8
-//Bit  7: 0, reg_isp_bandsplit_core3     coring to unsharp part of green (phase3) channel.   default= 0
-
-#define ISP_CLAMP_GRBG01                    0x2d22  
-//Bit 31:26, reserved
-#define CLAMP_GRBG0_BIT			    16
-#define CLAMP_GRBG0_WID			    10
-//Bit 25:16, reg_isp_clamp_grbg0         clamping offset to raw data green (phase0) channel, -512~511.   default= 0
-//Bit 15:10, reserved
-#define CLAMP_GRBG1_BIT			    0
-#define CLAMP_GRBG1_WID			    10
-//Bit  9: 0, reg_isp_clamp_grbg1         clamping offset to raw data red (phase1) channel, -512~511.   default= 0
-
-#define ISP_CLAMP_GRBG23                    0x2d23  
-//Bit 31:26, reserved
-#define CLAMP_GRBG2_BIT			    16
-#define CLAMP_GRBG2_WID			    10
-//Bit 25:16, reg_isp_clamp_grbg2         clamping offset to raw data blue (phase2) channel, -512~511.   default= 0
-//Bit 15:10, reserved
-#define CLAMP_GRBG3_BIT			    0
-#define CLAMP_GRBG3_WID			    10
-//Bit  9: 0, reg_isp_clamp_grbg3         clamping offset to raw data green (phase3) channel, -512~511.   default= 0
-
-#define ISP_GAIN_GRBG01                     0x2d24  
-//Bit 31:28, reserved
-#define GAIN_GRBG0_BIT			    16
-#define GAIN_GRBG0_WID			    12
-//Bit 27:16, reg_isp_gain_grbg0          digital gain to raw data green (phase0) channel, 0~4095, 256 as normalized '1'.   default= 256
-//Bit 15:12, reserved 
-#define GAIN_GRBG1_BIT			    0
-#define GAIN_GRBG1_WID			    12
-//Bit 11: 0, reg_isp_gain_grbg1          digital gain to raw data red   (phase1) channel, 0~4095, 256 as normalized '1'.   default= 256
-
-#define ISP_GAIN_GRBG23                     0x2d25  
-//Bit 31:28, reserved
-#define GAIN_GRBG2_BIT			    16
-#define GAIN_GRBG2_WID			    12
-//Bit 27:16, reg_isp_gain_grbg2          digital gain to raw data blue  (phase2) channel, 0~4095, 256 as normalized '1'.   default= 256
-//Bit 15:12, reserved
-#define GAIN_GRBG3_BIT			    0
-#define GAIN_GRBG3_WID			    12
-//Bit 11: 0, reg_isp_gain_grbg3          digital gain to raw data green (phase3) channel, 0~4095, 256 as normalized '1'.   default= 256
-
-// address 0x2d26~ 0x2d27 null
-/*********************** lens shading correction registers*****************/
-#define ISP_LNS_CTRL                        0x2d28    
-//Bit 31:29, reserved
-#define LNS_CMOP_ENABLE_BIT		    28
-#define LNS_CMOP_ENABLE_WID		    1
-//Bit    28, reg_isp_lns_cmop_enable    lens shading compensation enable. 0: no compensation; 1: compensation enable;  default= 0
-//Bit 27:26, reserved
-#define LNS_BAYER_FMT_BIT		    24//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-#define LNS_BAYER_FMT_WID		    2
-//Bit    24, reg_isp_lns_yphase_ofst    bayer pattern yphase offset in lens shading correction, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
-#define LNS_GAINNORM_GRBG0_BIT		    22
-#define LNS_GAINNORM_GRBG0_WID		    2
-//Bit 23:22, reg_isp_lns_gainnorm_grbg0 normalization mode for green channel (phase0) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
-#define LNS_GAINNORM_GRBG1_BIT		    20
-#define LNS_GAINNORM_GRBG1_WID		    2
-//Bit 21:20, reg_isp_lns_gainnorm_grbg1 normalization mode for red   channel (phase1) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
-#define LNS_GAINNORM_GRBG2_BIT		    18
-#define LNS_GAINNORM_GRBG2_WID		    2
-//Bit 19:18, reg_isp_lns_gainnorm_grbg2 normalization mode for blue  channel (phase2) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
-#define LNS_GAINNORM_GRBG3_BIT		    16
-#define LNS_GAINNORM_GRBG3_WID		    2
-//Bit 17:16, reg_isp_lns_gainnorm_grbg3 normalization mode for green channel (phase3) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
-#define LNS_GAIN_MODE_BIT		    15
-#define LNS_GAIN_MODE_WID		    1
-//Bit    15, reg_isp_lns_gain_mode      mode for gains from lut32x32x4. 0: final gain= x; 1: final gain = 1+x; default = 1
-#define LNS_MESH_MODE_BIT		    12
-#define LNS_MESH_MODE_WID		    3
-//Bit 14:12, reg_isp_lns_mesh_mode      mode for getting gain value from or write pixel raw components to lut32x32x4. if write pixel to lut (x>0), it was used for lut gain calculation during calibration. 0: read gain from lut 32x32x4; 1: gain='1', write pixel data without lpf to lut32x32x4 of the mesh position; 2; gain='1', write [1 2 1]/4 lpf filtered pixel data to lut32x32x4 of mesh position; 3: gain='1', write [1 2 2 2 1]/8 lpf filtered pixel data to lut32x32x4 of mesh position; default = 0;
-#define LNS_HOLD_BIT			    0
-#define LNS_HOLD_WID			    12
-//Bit 11: 0, reg_isp_lns_hold           TBD
-
-#define ISP_LNS_XYSCAL                      0x2d29    
-//Bit 31:28, reserved
-#define LNS_XSCALE_BIT			    16
-#define LNS_XSCALE_WID			    12
-//Bit 27:16, reg_isp_lns_xscale             lens shading compensation horizontal index scale. extend the sensor region to 32x32 grid, xscale=floor(7936*32/reg_hsize)
-//Bit 15:12, reserved
-#define LNS_YSCALE_BIT			    0
-#define LNS_YSCALE_WID			    12
-//Bit 11: 0, reg_isp_lns_yscale             lens shading compensation vertical index scale. extend the sensor region to 32x32 grid, yscale=floor(7936*32/reg_vsize)
-
-#define ISP_LNS_XYIDX_SHFT                  0x2d2a    
-//Bit 31:30, reserved
-#define LNS_XIDX_SHIFT_BIT		    16
-#define LNS_XIDX_SHIFT_WID		    14
-//Bit 29:16, reg_isp_lns_xidx_shift         lens shading compensation horizontal index offset. -8192~8191; default= 0;
-//Bit 15:14, reserved
-#define LNS_YIDX_SHIFT_BIT		    0
-#define LNS_YIDX_SHIFT_WID		    14
-//Bit 13: 0, reg_isp_lns_yidx_shift         lens shading compensation vertical index offset.   -8192~8191; default= 0;
-
-
-#define ISP_LNS_SENSOR_GAINGRBG             0x2d2b
-#define LNS_SENSOR_GAINGRBG0_BIT	    24
-#define LNS_SENSOR_GAINGRBG0_WID	    8
-//Bit 31:24, reg_isp_lns_sensor_gaingrbg0    gain to the lut 32x32 phase 0 green gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128                        
-#define LNS_SENSOR_GAINGRBG1_BIT	    16
-#define LNS_SENSOR_GAINGRBG1_WID	    8
-//Bit 23:16, reg_isp_lns_sensor_gaingrbg1    gain to the lut 32x32 phase 1   red gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128
-#define LNS_SENSOR_GAINGRBG2_BIT	    8
-#define LNS_SENSOR_GAINGRBG2_WID	    8
-//Bit 15: 8, reg_isp_lns_sensor_gaingrbg2    gain to the lut 32x32 phase 2  blue gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128                      
-#define LNS_SENSOR_GAINGRBG3_BIT	    0
-#define LNS_SENSOR_GAINGRBG3_WID	    8
-//Bit  7: 0, reg_isp_lns_sensor_gaingrbg3    gain to the lut 32x32 phase 3 green gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128
-
-#define ISP_LNS_POST_OFSTGRBG               0x2d2c
-#define LNS_POST_OFSET_GRBG0_BIT	    24
-#define LNS_POST_OFSET_GRBG0_WID	    8
-//Bit 31:24, reg_isp_lns_post_ofset_grbg0    ofset to phase 0 green pixel after lens compensation (gain). -128~127. default= 0                        
-#define LNS_POST_OFSET_GRBG1_BIT	    16
-#define LNS_POST_OFSET_GRBG1_WID	    8
-//Bit 23:16, reg_isp_lns_post_ofset_grbg1    ofset to phase 1 red   pixel after lens compensation (gain). -128~127. default= 0
-#define LNS_POST_OFSET_GRBG2_BIT	    8
-#define LNS_POST_OFSET_GRBG2_WID	    8
-//Bit 15: 8, reg_isp_lns_post_ofset_grbg2    ofset to phase 2 blue  pixel after lens compensation (gain). -128~127. default= 0                      
-#define LNS_POST_OFSET_GRBG3_BIT	    0
-#define LNS_POST_OFSET_GRBG3_WID	    8
-//Bit  7: 0, reg_isp_lns_post_ofset_grbg3    ofset to phase 3 green pixel after lens compensation (gain). -128~127. default= 0
-
-// address 0x2d2d~ 0x2d2f null
-
-/*****************gamma correction registers*******************/
-
-#define ISP_GMR0_CTRL                       0x2d30  
-//Bit 31:29, reserved
-#define GMR_CORRECT_ENABLE_BIT		    28
-#define GMR_CORRECT_ENABLE_WID		    1
-//Bit    28, reg_isp_gmr_correct_enable     raw data gammar correction enable;    default= 0;
-//Bit 27:26, reserved
-#define GMR_BAYER_FMT_BIT		    24//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-#define GMR_BAYER_FMT_WID		    2
-//Bit    24, reg_isp_gmr_yphase_ofst        bayer pattern yphase offset in gammar correction, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
-//Bit 23: 1, reserved 
-#define GCLUT_ACCMODE_BIT		    0
-#define GCLUT_ACCMODE_WID		    1
-//Bit     0, reg_isp_gclut_accmode          TBD
-
-// TBD: gammar LUT memory operation
-
-/*********************defect pixel correction registers**********************/
-
-#define ISP_DFT_CTRL                        0x2d31   
-//Bit 31:29, reserved
-#define ISP_DFT_ENABLE_BIT		    28
-#define ISP_DFT_ENABLE_WID		    1
-//Bit    28, reg_isp_dft_enable             defect pixel detection block operation enable, reg_isp_dft_detect_mode decides the detection mode; 0: no defect_detection; 1: detection logic on;    default= 1;
-//Bit 27:26, reserved
-#define DFT_BAYER_FMT_BIT		    24//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-#define DFT_BAYER_FMT_WID		    2
-//Bit    24, reg_isp_dft_yphase_ofst        bayer pattern yphase offset in defect pixel correction, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
-//Bit 23:20, reserved
-#define DFTMAP_WRITETO_LUT_STLINE_BIT	    16
-#define DFTMAP_WRITETO_LUT_STLINE_WID	    4
-//Bit 19:16, reg_isp_dftmap_writeto_lut_stline starting line number to write dftmap to LUT1024. 0~15; default= 14;
-//Bit 15:13, reserved
-#define DFTMAP_WRITETO_LUT_ENABLE_BIT	    12
-#define DFTMAP_WRITETO_LUT_ENABLE_WID	    1
-//Bit    12, reg_isp_dftmap_writeto_lut     enable to HW write dftmap info to LUT1024 in raster-scan mode. 0: no write to LUT1024; 1: write to LUT1024 (HW)
-//Bit 11:10, reserved
-#define DFTMAP_CORRECT_DRTATE_BIT	    8
-#define DFTMAP_CORRECT_DRTATE_WID	    2
-//Bit  9: 8, reg_isp_dftmap_correct_drtrate  defect pixel correction directional rate for error. 0; x2; 1:1  2: 1/2; 3:1/4; default=1
-//Bit  7: 6, reserved
-#define DFT_DETECT_MODE_BIT		    4
-#define DFT_DETECT_MODE_WID		    2
-//Bit  5: 4, reg_isp_dft_detect_mode        defect pixel detection mode. 0: manual mode; 1/2/3: adaptive mode, default = 2;
-//Bit  3: 2, reserved
-#define DFTMAP_CORRECT_MODE_BIT	            0
-#define DFTMAP_CORRECT_MODE_WID		    2
-//Bit  1: 0, reg_isp_dftmap_correct_mode    defect map generation mode. 0: all dftmap=0; 1: dftmap based on LUT1024 only; 2: based on on dft_map9 (only sky mode only; 3 based on both LUT1024 and dft_map9) defaul=3
-
-
-#define ISP_DFT_VAR_MINMAX                  0x2d33
-#define ISP_DFT_VARMIN_BIT		    24
-#define ISP_DFT_VARMIN_WID		    8
-//Bit 31:24, reg_isp_dft_varmin             min limit for 4x8 block variance.  default = 10;
-#define ISP_DFT_VARMAX_BIT		    16
-#define ISP_DFT_VARMAX_WID		    8
-//Bit 23:16, reg_isp_dft_varmax             max limit for 4x8 block variance.  default = 32;
-#define ISP_DFT_THDLOW_BIT		    8
-#define ISP_DFT_THDLOW_WID		    8
-//Bit 15: 8, reg_isp_dft_thdlow_minfloor    min limit for 4x8 block mininum value for thd_low calculation. default= 75;
-#define ISP_DFT_THDHIG_BIT		    0
-#define ISP_DFT_THDHIG_WID		    8
-//Bit  7: 0, reg_isp_dft_thdhig_maxfloor    max limit for 4x8 block maximum value for thd_low calculation. default= 175;
-
-#define ISP_DFT_THDLOW                      0x2d34
-#define DFT_THDLOW_VARRATE_BIT		    24
-#define DFT_THDLOW_VARRATE_WID		    8
-//Bit 31:24, reg_isp_dft_thdlow_varrate     rate to variance in thdlow calculation. normalized to 16 as '1', default = 16; 
-#define DFT_THDLOW_MINRATE_BIT		    16
-#define DFT_THDLOW_MINRATE_WID		    8
-//Bit 23:16, reg_isp_dft_thdlow_minrate     rate to distance between min_BLK and avg_BLK in thdlow calculation. normalized to 16 as '1', default = 8; 
-#define DFT_THDLOW_MINRANGE_BIT		    8
-#define DFT_THDLOW_MINRANGE_WID		    8
-//Bit 15: 8, reg_isp_dft_thdlow_minrange    min limit of adaptive range for thd_low calculation. default= 2 (calibrat mode =0/1);  25 (calibrat mode =2/3);
-#define DFT_THDLOW_MAXRANGE_BIT		    0
-#define DFT_THDLOW_MAXRANGE_WID		    8
-//Bit  7: 0, reg_isp_dft_thdlow_maxrange    max limit of adaptive range for thd_low calculation. default= 2 (calibrat mode =0/1); 210 (calibrat mode =2/3);
-
-
-#define ISP_DFT_THDHIG                      0x2d35
-#define DFT_THDHIG_VARRATE_BIT		    24
-#define DFT_THDHIG_VARRATE_WID		    8
-//Bit 31:24, reg_isp_dft_thdhig_varrate     rate to variance in thdhig calculation. normalized to 16 as '1', default = 16; 
-#define DFT_THDHIG_MINRATE_BIT		    16
-#define DFT_THDHIG_MINRATE_WID		    8
-//Bit 23:16, reg_isp_dft_thdhig_minrate     rate to distance between min_BLK and avg_BLK in thdhig calculation. normalized to 16 as '1', default = 8; 
-#define DFT_THDHIG_MINRANGE_BIT		    8
-#define DFT_THDHIG_MINRANGE_WID		    8
-//Bit 15: 8, reg_isp_dft_thdhig_minrange    min limit of adaptive range for thdhig calculation. default= 2 (calibrat mode =0/1);  25 (calibrat mode =2/3);
-#define DFT_THDHIG_MAXRANGE_BIT		    0
-#define DFT_THDHIG_MAXRANGE_WID		    8
-//Bit  7: 0, reg_isp_dft_thdhig_maxrange    max limit of adaptive range for thdhig calculation. default= 2 (calibrat mode =0/1); 210 (calibrat mode =2/3);
-
-#define ISP_DFT_CALIBRAT_REF                0x2d36  
-//Bit 31:24, reserved
-#define DFT_CALIBRAT_REF_R_BIT		    16
-#define DFT_CALIBRAT_REF_R_WID		    8
-//Bit 23:16  reg_isp_dft_calibrat_ref_r     calibration reference   red color value under reg_ISP_dft_calibrat_mode=0; normally get from average of red component of the image (only work for raster pattern); default= 100;
-#define DFT_CALIBRAT_REF_G_BIT		    8
-#define DFT_CALIBRAT_REF_G_WID		    8
-//Bit 15: 8, reg_isp_dft_calibrat_ref_g     calibration reference green color value under reg_ISP_dft_calibrat_mode=0; normally get from average of green component of the image (only work for raster pattern); default= 100;
-#define DFT_CALIBRAT_REF_B_BIT		    0
-#define DFT_CALIBRAT_REF_B_WID		    8
-//Bit  7: 0, reg_isp_dft_calibrat_ref_b     calibration reference  blue color value under reg_ISP_dft_calibrat_mode=0; normally get from average of blue component of the image (only work for raster pattern); default= 100;
-
-#define ISP_DFT_CALIBRAT_CTRL               0x2d37   
-//Bit 31:30, reserved
-#define DFT_CALIBRAT_MIDNUM_BIT		    24
-#define DFT_CALIBRAT_MIDNUM_WID		    6
-//Bit 29:24, reg_isp_dft_calibrat_midnum    threshold of number of pixels (5x9 block) located in the [thdlow, thdhig] range, if num of pixels is larger than this midnum, the calibration reference will be updated. 0~45. default=44
-//Bit 23:22, reserved      
-#define DFT_CALIBRAT_TMIDNUM_BIT	    21
-#define DFT_CALIBRAT_TMIDNUM_WID	    6
-//Bit 21:16, reg_isp_dft_calibrat_tmidnum   threshold of number of pixels (4x9 block) located in the [thdlow, thdhig] range, if num of pixels is larger than this midnum, the calibration reference will be updated. 0~36. default=35 
-//Bit 15:10, reserved
-#define DFT_LASTVALID_MODE_BIT		    8
-#define DFT_LASTVALID_MODE_WID		    2
-//Bit  9: 8, reg_isp_dft_lastvalid_mode     current phase color valid (not defect) status mode. it will be used in calibration update decision. 0: only current line; 1: n-2/n/n+2 lines; 2/3:n-4/n-2/n/n+2/n+4 lines; default = 1
-//Bit  7: 6, reserved
-#define DFT_LASTVALID_TMODE_BIT		    4
-#define DFT_LASTVALID_TMODE_WID		    2
-//Bit  5: 4, reg_isp_dft_lastvalid_tmode    top phase color valid (not defect) status mode. it will be used in calibration update decision.0: not update; 1: n-1/n+1 lines; 2/3:n-3/n-1/n+1/n+3 lines; default = 1
-//Bit  3: 2, reserved
-#define DFT_CALIBRAT_MODE_BIT		    0
-#define DFT_CALIBRAT_MODE_WID		    2
-//Bit  1: 0, reg_isp_dft_calibrat_mode      calibration reference selection mode. 0: from reg_isp_dft_calibrat_ref_r/g/b; 1: from local average of current phase if it is not dft; 
-// 2: from local average of both current and other phases if it was not dft; 3:from local average of both current and other phases whether it was not dft; default=2
-
-#define ISP_DFT_DET0_MANUALTH              0x2d38   
-//Bit 31:24, reserved
-#define DFT_MANUAL_THRD_R_BIT		   16
-#define DFT_MANUAL_THRD_R_WID		   8
-//Bit 23:16  reg_isp_dft_manual_thrd_r      threshold of difference between pixel to calibration reference in red channel under reg_isp_dft_detect_mode=0 (manual mode). default= 80;
-#define DFT_MANUAL_THRD_G_BIT		   8
-#define DFT_MANUAL_THRD_G_WID		   8
-//Bit 15: 8, reg_isp_dft_manual_thrd_g      threshold of difference between pixel to calibration reference in green channel under reg_isp_dft_detect_mode=0 (manual mode). default= 80;
-#define DFT_MANUAL_THRD_B_BIT		   0
-#define DFT_MANUAL_THRD_B_WID		   8
-//Bit  7: 0, reg_isp_dft_manual_thrd_b      threshold of difference between pixel to calibration reference in blue channel under reg_isp_dft_detect_mode=0 (manual mode). default= 80;
-
-#define ISP_DFT_DET1_ADPTLOWTH             0x2d39  
-//Bit 31:24, reserved
-#define DFT_LOW_THRD_R_BIT		   16
-#define DFT_LOW_THRD_R_WID		   8
-//Bit 23:16  reg_isp_dft_low_thrd_r         low threshold to   red channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 50;
-#define DFT_LOW_THRD_G_BIT		   8
-#define DFT_LOW_THRD_G_WID		   8
-//Bit 15: 8, reg_isp_dft_low_thrd_g         low threshold to green channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 50;
-#define DFT_LOW_THRD_B_BIT		   0
-#define DFT_LOW_THRD_B_WID		   8
-//Bit  7: 0, reg_isp_dft_low_thrd_b         low threshold to  blue channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 50;
-
-#define ISP_DFT_DET1_ADPTHIGTH             0x2d3a   
-//Bit 31:24, reserve
-#define DFT_HIG_THRD_R_BIT		   16
-#define DFT_HIG_THRD_R_WID		   8
-//Bit 23:16  reg_isp_dft_hig_thrd_r         high threshold to   red channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 200;
-#define DFT_HIG_THRD_G_BIT		   8
-#define DFT_HIG_THRD_G_WID		   8
-//Bit 15: 8, reg_isp_dft_hig_thrd_g         high threshold to green channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 200;
-#define DFT_HIG_THRD_B_BIT		   0
-#define DFT_HIG_THRD_B_WID		   8
-//Bit  7: 0, reg_isp_dft_hig_thrd_b         high threshold to  blue channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 200;
-
-#define ISP_DFT_DET1_ADPTNUM0              0x2d3b  
-//Bit 31:22, reserved
-#define DFT_ADAPT_NUM_LOW_BIT		   16
-#define DFT_ADAPT_NUM_LOW_WID		   6
-//Bit 21:16  reg_isp_dft_adapt_num_low      threshold of number of pixels smaller than thdlow in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~46; default= 4;
-//Bit 15:14, reserved
-#define DFT_ADAPT_NUM_MID_BIT		   8
-#define DFT_ADAPT_NUM_MID_WID		   6
-//Bit 13: 8, reg_isp_dft_adapt_num_mid      threshold of number of pixels within [thdlow, thdhig] in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~46; default= 4;
-//Bit  7: 6, reserved
-#define DFT_ADAPT_NUM_HIG_BIT		   0
-#define DFT_ADAPT_NUM_HIG_WID		   6
-//Bit  5: 0, reg_isp_dft_adapt_num_hig      threshold of number of pixels larger than thdhig in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~46; default= 4;
-
-#define ISP_DFT_DET1_ADPTNUM1              0x2d3c   
-//Bit 31:22, reserved
-#define DFT_ADAPT_NUM_TLOW_BIT		   16
-#define DFT_ADAPT_NUM_TLOW_WID		   6
-//Bit 21:16  reg_isp_dft_adapt_num_tlow     threshold of number of pixels smaller than tthdlow in 4x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~37; default= 3;
-//Bit 15:14, reserved
-#define DFT_ADAPT_NUM_TMID_BIT		   8
-#define DFT_ADAPT_NUM_TMID_WID		   6
-//Bit 13: 8, reg_isp_dft_adapt_num_tmid     threshold of number of pixels within [tthdlow, tthdhig] in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~37; default= 3;
-//Bit  7: 6, reserved
-#define DFT_ADAPT_NUM_THIG_BIT		   0
-#define DFT_ADAPT_NUM_THIG_WID		   6
-//Bit  5: 0, reg_isp_dft_adapt_num_thig     threshold of number of pixels larger than tthdhig in 4x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~37; default= 3;
-
-// address 0x2d3d~ 0x2d3e null
-/************************ demosaicing registers*************************/
-#define ISP_DMS_CTRL0                      0x2d40  
-//Bit    31, reserved
-#define ISP_DMS_BYPASS_BIT		   28
-#define ISP_DMS_BYPASS_WID		   3
-//Bit 30:28, reg_isp_dms_bypass             bypass of demosaicing module. 0: no bypass; 1: replace (n-2) line dms result to current line; 2: (n-1) line to current; 3: (n+1) line to current; 4: (n+2) lines to current; 5~6: (n)line tocurrent; 7: bypass dms and put bayer data to RGB channels as repeat; default =0;
-//Bit 27:26, reserved
-#define DMS_BAYER_FMT_BIT		   24//bayer fmt 0:BGGR 1:RGGB 2:GBRG 3:GRBG
-#define DMS_BAYER_FMT_WID		   2
-//Bit    24, reg_isp_dms_yphase_ofst        bayer pattern yphase offset in demosaicing, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0
-//Bit 23:22, reserved                       
-#define DMS_L28_SIMPLE_BIT		   20
-#define DMS_L28_SIMPLE_WID		   2
-//Bit 21:20, reg_isp_dms_l28_simple         line 2 and line 8 green interpolation mode. 0/2: full dlmmse; 1:  using 4/6 line's alpha to replace; 2:simple alpha calculation. default= 0
-//Bit 19:18, reserved                       
-#define DMS_L19_SIMPLE_BIT		   16
-#define DMS_L19_SIMPLE_WID		   2
-//Bit 17:16, reg_isp_dms_l19_simple         line 1 and line 9 green interpolation mode. 0: using 2/8 line's green to replace; 1: using left/right green pixel to replace; 2: average of left/right and 2/8 line's green; 3:smaller transition directional nearby green average; default=3 
-//Bit 15: 1, reserved
-#define DMS_DVDH_FILTER_MODE_BIT           0
-#define DMS_DVDH_FILTER_MODE_WID	   1
-//Bit     0, reg_isp_dms_dvdh_filter_mode   filter mode for dh/dv calculation. 0: [1 0 1]/2; 1: [-1 2 2 2 -1]/4; default = 0.
-
-#define ISP_DMS_CTRL1                      0x2d41  
-//Bit 31:30, reserved
-#define DMS_GRN_USE_CDM_BIT		   28
-#define DMS_GRN_USE_CDM_WID		   2
-//Bit 29:28, reg_isp_dms_grn_use_cdm        dms 1st step green recovery fallback mode. 0: ussing dlmmse; 1: simple cdm; 2; simple min gradient; 3: simple average; default = 0;
-//Bit 27:26, reserved
-#define DMS_DNR_MODE_BIT		   24
-#define DMS_DNR_MODE_WID		   2
-//Bit 25:24, reg_isp_dms_dnr_mode           denoise mode in greem recovery est_h/est_v calculation for high frequency component; 0: no denoise; 1: high-freq degrade by half; 2: high-freq degrade to 1/4; 3: remove high-freq; default=0
-//Bit 23:21, reserved                       
-#define DMS_RB_MIN_ENABLE_BIT		   20
-#define DMS_RB_MIN_ENABLE_WID		   1
-//Bit    20, reg_isp_dms_rb_min_enable      enable signal to use min transition directional dms. 0: always average; 1: adaptive directional; default=1;
-//Bit 19:18, reserved                       
-#define DMS_RB_MIN_RATE_BIT		   16
-#define DMS_RB_MIN_RATE_WID		   2
-//Bit 17:16, reg_isp_dms_rb_min_rate        minimum transition (after offset) to maximum transition ratio (./4) threshold to decide using min direction dms. 0~3. default = 2
-#define DMS_RB_MIN_OFST_BIT		   8
-#define DMS_RB_MIN_OFST_WID		   8
-//Bit 15: 8, reg_isp_dms_rb_min_ofst        minimum transition offset (s8) to decide whether using min direction dms or average. if reg_ISP_dms_RB_min_rate=127, will use average. -128~127; default= 5
-#define DMS_G_ALP_OFSET_BIT		   0
-#define DMS_G_ALP_OFSET_WID		   8
-//Bit  7: 0, reg_isp_dms_g_alp_ofset        offset to alpha in lmmse algorithm green component recovery. the larger of this value, the more blender; default = 16
-
-/********************* isp color matrix 0 registers*********************/
-#define ISP_MATRIX_PRE_OFST0_1             0x2d42   
-//Bit 31:27, reserved
-#define MATRIX_PRE_OFST0_BIT	           16
-#define MATRIX_PRE_OFST0_WID		   11
-//Bit 26:16, reg_isp_matrix_pre_ofst0       input offset of component 0 (most likely red) before going to 3x3 matrix; -1024:1023. default=0
-//Bit 15:11, reserved
-#define MATRIX_PRE_OFST1_BIT		   0
-#define MATRIX_PRE_OFST1_WID		   11
-//Bit 10: 0, reg_isp_matrix_pre_ofst1       input offset of component 1 (most likely green) before going to 3x3 matrix; -1024:1023. default=0
-
-#define ISP_MATRIX_PRE_OFST2               0x2d43  
-//Bit 31:18, reserved
-#define MATRIX_RS_BIT			   16
-#define MATRIX_RS_WID			   2
-//Bit 17:16, reg_isp_matrix_rs              default=0                        
-//Bit 15:11, reserved
-#define MATRIX_PRE_OFST2_BIT		   0
-#define MATRIX_PRE_OFST2_WID		   11
-//Bit 10: 0, reg_isp_matrix_pre_ofst2       input offset of component 2 (most likely blue) before going to 3x3 matrix; -1024:1023. default=0
-
-#define ISP_MATRIX_COEF00_01               0x2d44  
-//Bit 31:30, reserved
-#define MATRIX_COEF00_BIT		   16
-#define MATRIX_COEF00_WID		   10
-//Bit 25:16, reg_isp_matrix_coef00          3x3 matrix (0,0) coef; -512:511. default= 77.
-//Bit 15:10, reserved
-#define MATRIX_COEF01_BIT		   0
-#define MATRIX_COEF01_WID		   10
-//Bit  9: 0, reg_isp_matrix_coef01          3x3 matrix (0,1) coef; -512:511. default=150.
-
-#define ISP_MATRIX_COEF02_10               0x2d45  
-//Bit 31:30, reserved
-#define MATRIX_COEF02_BIT		   16
-#define MATRIX_COEF02_WID		   10
-//Bit 25:16, reg_isp_matrix_coef02          3x3 matrix (0,2) coef; -512:511. default= 29.
-//Bit 15:10, reserved 
-#define MATRIX_COEF10_BIT		   0
-#define MATRIX_COEF10_WID		   10
-//Bit  9: 0, reg_isp_matrix_coef10          3x3 matrix (1,0) coef; -512:511. default=-43.
-
-#define ISP_MATRIX_COEF11_12               0x2d46  
-//Bit 31:30, reserved
-#define MATRIX_COEF11_BIT		   25
-#define MATRIX_COEF11_WID		   10
-//Bit 25:16, reg_isp_matrix_coef11          3x3 matrix (1,1) coef; -512:511. default=-85.
-//Bit 15:10, reserved
-#define MATRIX_COEF12_BIT		   0
-#define MATRIX_COEF12_WID		   10
-//Bit  9: 0, reg_isp_matrix_coef12          3x3 matrix (1,2) coef; -512:511. default=128.
-
-#define ISP_MATRIX_COEF20_21               0x2d47  
-//Bit 31:30, reserved
-#define MATRIX_COEF20_BIT		   25
-#define MATRIX_COEF20_WID		   10
-//Bit 25:16, reg_isp_matrix_coef20          3x3 matrix (2,0) coef; -512:511. default=128.
-//Bit 15:10, reserved
-#define MATRIX_COEF21_BIT		   0
-#define MATRIX_COEF21_WID		   10
-//Bit  9: 0, reg_isp_matrix_coef21          3x3 matrix (2,1) coef; -512:511. default=-107.
-
-#define ISP_MATRIX_COEF22                  0x2d48  
-//Bit 31:10, reserved
-#define MATRIX_COEF22_BIT		   0
-#define MATRIX_COEF22_WID		   10
-//Bit  9: 0, reg_isp_matrix_coef22          3x3 matrix (2,2) coef; -512:511. default=-21.
-
-#define ISP_MATRIX_POS_OFST0_1             0x2d49   
-//Bit 31:27, reserved
-#define MATRIX_POS_OFST0_BIT		   16
-#define MATRIX_POS_OFST0_WID		   11
-//Bit 26:16, reg_isp_matrix_pos_ofst0       output offset of component 0 (most likely Y) before going to 3x3 matrix; -1024:1023. default=0
-//Bit 15:11, reserved
-#define MATRIX_POS_OFST1_BIT		   0
-#define MATRIX_POS_OFST1_WID		   11
-//Bit 10: 0, reg_isp_matrix_pos_ofst1       output offset of component 1 (most likely U) before going to 3x3 matrix; -1024:1023. default=512
-
-#define ISP_MATRIX_POS_OFST2               0x2d4a  
-//Bit 31:11, reserved
-#define MATRIX_POS_OFST2_BIT		   0
-#define MATRIX_POS_OFST2_WID		   11
-//Bit 10: 0, reg_isp_matrix_pos_ofst2       output offset of component 2 (most likely V) before going to 3x3 matrix; -1024:1023. default=512
-
-// address 0x2d4b~ 0x2d4f null
-
-/******************** noise reduction and peaking registers***********************/
-#define ISP_PKNR_HVBLANK_NUM                0x2d50
-#define DMS_HBLANK_NUM_BIT		    24
-#define DMS_HBLANK_NUM_WID		    8
-//Bit 31:24, reg_isp_dms_hblank_num         dms horizontal blank pixel number.  default = 8
-#define DMS_VBLANK_NUM_BIT		    16
-#define DMS_VBLANK_NUM_WID		    8
-//Bit 23:16, reg_isp_dms_vblank_num         dms vertical blank pixel number.   default = 30
-#define PKNR_HBLANK_NUM_BIT		    8
-#define PKNR_HBLANK_NUM_WID		    8
-//Bit 15: 8, reg_pknr_hblank_num            peaking and noise reduction horizontal blank pixel number.  default = 8
-#define PKNR_VBLANK_NUM_BIT		    8
-#define PKNR_VBLANK_NUM_WID		    8
-//Bit  7: 0, reg_pknr_vblank_num            peaking and noise reduction vertical blank pixel number.   default = 30
-
-#define ISP_NR_GAUSSIAN_MODE                0x2d51  
-//Bit 31: 5, reserved
-#define NR_GAU_YMODE_BIT		    4
-#define NR_GAU_YMODE_WID		    1
-//Bit     4, reg_nr_gau_ymode               noise reduction luma gaussian filter mode. 0: 3x3 gaussian filter; 1:5x5 gaussian filter. default=1;
-//Bit  3: 1, reserved
-#define NR_GAU_CMODE_BIT		    0
-#define NR_GAU_CMODE_WID		    1
-//Bit     0, reg_nr_gau_cmode               noise reduction chroma gaussian filter mode. 0: 3x3 gaussian filter; 1:5x5 gaussian filter. default=1;
-
-#define ISP_PK_HVCON_LPF_MODE               0x2d52  
-//Bit 31:30, reserved
-#define HCON_HPF_MODE_BIT		    28
-#define HCON_HPF_MODE_WID		    2
-//Bit 29:28, reg_hcon_hpf_mode              horizontal highpass transition ([-1 2 -1]) detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
-//Bit 27:26, reserved
-#define HCON_BPF_MODE_BIT		    24
-#define HCON_BPF_MODE_WID		    2
-//Bit 25:24, reg_hcon_bpf_mode              horizontal bandpass transition ([-1 1 0]+[0 1 -1])detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
-//Bit 23:22, reserved
-#define HCON_LBPF_MODE_BIT		    21
-#define HCON_LBPF_MODE_WID		    2
-//Bit 21:20, reg_hcon_lbpf_mode             horizontal low-bandpass transition ([-2 0 2])detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
-//Bit 19:18, reserved
-#define HCON_LLBPF_MODE_BIT		    16
-#define HCON_LLBPF_MODE_WID		    2
-//Bit 17:16, reg_hcon_llbpf_mode            horizontal very low-bandpass transition ([1 1 0  1 1])detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
-//Bit 15:14, reserved
-#define VCON_HPF_MODE_BIT		    12
-#define VCON_HPF_MODE_WID		    2
-//Bit 13:12, reg_vcon_hpf_mode              vertical highpass transition ([-1 2 -1]) detection horizontal lowpass filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
-//Bit 11:10, reserved                       
-#define VCON_BPF_MODE_BIT		    8
-#define VCON_BPF_MODE_WID		    2
-//Bit  9: 8, reg_vcon_bpf_mode              vertical bandpass transition ([-1 1 0]+[0 1 -1])detection horizontal lowpass filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
-//Bit  7: 6, reserved                       
-#define VCON_LBPF_MODE_BIT		    4
-#define VCON_LBPF_MODE_WID		    2
-//Bit  5: 4, reg_vcon_lbpf_mode             vertical low-bandpass transition ([-2 0 2])detection vertical horizontal filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
-//Bit  3: 2, reserved                       
-#define VCON_LLBPF_MODE_BIT		    0
-#define VCON_LLBPF_MODE_WID		    2
-//Bit  1: 0, reg_vcon_llbpf_mode            vertical very low-bandpass transition ([1 1 0  1 1])detection horizontal lowpass filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
-
-#define ISP_PK_CON_BLEND_GAIN               0x2d53 
-#define PK_HPCON_HPGAIN_BIT		    28
-#define PK_HPCON_HPGAIN_WID		    4
-//Bit 31:28, reg_pk_hpcon_hpgain            gain to con_hp (blended from hcon_hp, vcon_hp) to get hpcon. normalized 8 to '1'; default =4
-#define PK_HPCON_BPGAIN_BIT		    24
-#define PK_HPCON_BPGAIN_WID		    4
-//Bit 27:24, reg_pk_hpcon_bpgain            gain to con_bp (blended from hcon_bp, vcon_bp) to get hpcon. normalized 8 to '1'; default =4
-#define PK_HPCON_LBPGAIN_BIT		    20
-#define PK_HPCON_LBPGAIN_WID		    4
-//Bit 23:20, reg_pk_hpcon_lbpgain           gain to con_lbp (blended from hcon_lbp, vcon_lbp) to get hpcon. normalized 8 to '1'; default =0
-#define PK_HPCON_LLBPGAIN_BIT	            16
-#define PK_HPCON_LLBPGAIN_WID		    4
-//Bit 19:16, reg_pk_hpcon_llbpgain          gain to con_llbp (blended from hcon_llbp, vcon_llbp) to get hpcon. normalized 8 to '1'; default =0
-#define PK_BPCON_HPGAIN_BIT		    12
-#define PK_BPCON_HPGAIN_WID		    4
-//Bit 15:12, reg_pk_bpcon_hpgain            gain to con_hp (blended from hcon_hp, vcon_hp) to get bpcon. normalized 8 to '1'; default =0
-#define PK_BPCON_BPGAIN_BIT		    8
-#define PK_BPCON_BPGAIN_WID		    4
-//Bit 11: 8, reg_pk_bpcon_bpgain            gain to con_bp (blended from hcon_bp, vcon_bp) to get bpcon. normalized 8 to '1'; default =2
-#define PK_BPCON_LBPGAIN_BIT	            4
-#define PK_BPCON_LBPGAIN_WID		    4
-//Bit  7: 4, reg_pk_bpcon_lbpgain           gain to con_lbp (blended from hcon_lbp, vcon_lbp) to get bpcon. normalized 8 to '1'; default =6
-#define PK_BPCON_LLBPGAIN_BIT	       	    0
-#define PK_BPCON_LLBPGAIN_WID		    4
-//Bit  3: 0, reg_pk_bpcon_llbpgain          gain to con_llbp (blended from hcon_llbp, vcon_llbp) to get bpcon. normalized 8 to '1'; default =0
-
-
-#define ISP_PK_CON_2CIRHPGAIN_TH_RATE       0x2d54  
-//reg_pk_cirhp_con2gain (0 1 5 6)
-#define PK_CIRHP_CON2GAIN_TH0_BIT	    24
-#define PK_CIRHP_CON2GAIN_TH0_WID	    8
-//Bit 31:24, reg_pk_cirhp_con2gain_th0      threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 25;
-#define PK_CIRHP_CON2GAIN_TH1_BIT	    16
-#define PK_CIRHP_CON2GAIN_TH1_WID           8
-//Bit 23:16, reg_pk_cirhp_con2gain_th1      threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 60;
-#define PK_CIRHP_CON2GAIN_RATE0_BIT	    8
-#define PK_CIRHP_CON2GAIN_RATE0_WID	    8
-//Bit 15: 8, reg_pk_cirhp_con2gain_rate0    rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 80;
-#define PK_CIRHP_CON2GAIN_RATE1_BIT	    0
-#define PK_CIRHP_CON2GAIN_RATE1_WID	    8
-//Bit  7: 0, reg_pk_cirhp_con2gain_rate1    rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 20;
-
-#define ISP_PK_CON_2CIRHPGAIN_LIMIT         0x2d55   
-//reg_pk_cirhp_con2gain (2 3 4)
-#define PK_CIRHP_CON2GAIN_LV0_BIT	    24
-#define PK_CIRHP_CON2GAIN_LV0_WID	    8
-//Bit 31:24, reg_pk_cirhp_con2gain_lv0      level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 0;
-#define PK_CIRHP_CON2GAIN_LV1_BIT	    16
-#define PK_CIRHP_CON2GAIN_LV1_WID	    8
-//Bit 23:16, reg_pk_cirhp_con2gain_lv1      level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 96;
-#define PK_CIRHP_CON2GAIN_LV2_BIT	    8
-#define PK_CIRHP_CON2GAIN_LV2_WID	    8
-//Bit 15: 8, reg_pk_cirhp_con2gain_lv2      level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 5;
-//Bit  7: 0, reserved                       
-
-#define ISP_PK_CON_2CIRBPGAIN_TH_RATE       0x2d56   
-//reg_pk_cirbp_con2gain (0 1 5 6)
-#define PK_CIRBP_CON2GAIN_TH0_BIT	    24
-#define PK_CIRBP_CON2GAIN_TH0_WID	    8
-//Bit 31:24, reg_pk_cirbp_con2gain_th0      threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 20;
-#define PK_CIRBP_CON2GAIN_TH1_BIT	    16
-#define PK_CIRBP_CON2GAIN_TH1_WID	    8
-//Bit 23:16, reg_pk_cirbp_con2gain_th1      threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 50;
-#define PK_CIRBP_CON2GAIN_RATE0_BIT	    8
-#define PK_CIRBP_CON2GAIN_RATE0_WID	    8
-//Bit 15: 8, reg_pk_cirbp_con2gain_rate0    rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 50;
-#define PK_CIRBP_CON2GAIN_RATE1_BIT	    0
-#define PK_CIRBP_CON2GAIN_RATE1_WID	    8
-//Bit  7: 0, reg_pk_cirbp_con2gain_rate1    rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 25;
-
-#define ISP_PK_CON_2CIRBPGAIN_LIMIT         0x2d57  
-//reg_pk_cirbp_con2gain (2 3 4) 
-#define PK_CIRBP_CON2GAIN_LV0_BIT	    24
-#define PK_CIRBP_CON2GAIN_LV0_WID	    8
-//Bit 31:24, reg_pk_cirbp_con2gain_lv0      level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 0;
-#define PK_CIRBP_CON2GAIN_LV1_BIT	    16
-#define PK_CIRBP_CON2GAIN_LV1_WID	    8
-//Bit 23:16, reg_pk_cirbp_con2gain_lv1      level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 40;
-#define PK_CIRBP_CON2GAIN_LV2_BIT	    8
-#define PK_CIRBP_CON2GAIN_LV2_WID      	    8
-//Bit 15: 8, reg_pk_cirbp_con2gain_lv2      level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 5;
-//Bit  7: 0, reserved                       
-
-#define ISP_PK_CON_2DRTHPGAIN_TH_RATE       0x2d58  
-//reg_pk_drthp_con2gain (0 1 5 6)
-#define PK_DRTHP_CON2GAIN_TH0_BIT	    24
-#define PK_DRTHP_CON2GAIN_TH0_WID	    8
-//Bit 31:24, reg_pk_drthp_con2gain_th0      threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 25;
-#define PK_DRTHP_CON2GAIN_TH1_BIT	    16
-#define PK_DRTHP_CON2GAIN_TH1_WID	    8
-//Bit 23:16, reg_pk_drthp_con2gain_th1      threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 60;
-#define PK_DRTHP_CON2GAIN_RATE0_BIT	    8
-#define PK_DRTHP_CON2GAIN_RATE0_WID	    8
-//Bit 15: 8, reg_pk_drthp_con2gain_rate0    rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 80;
-#define PK_DRTHP_CON2GAIN_RATE1_BIT	    0
-#define PK_DRTHP_CON2GAIN_RATE1_WID	    8
-//Bit  7: 0, reg_pk_drthp_con2gain_rate1    rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 20;
-
-#define ISP_PK_CON_2DRTHPGAIN_LIMIT         0x2d59   
-//reg_pk_drthp_con2gain (2 3 4) 
-#define PK_DRTHP_CON2GAIN_LV0_BIT	    24
-#define PK_DRTHP_CON2GAIN_LV0_WID	    8
-//Bit 31:24, reg_pk_drthp_con2gain_lv0      level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 0;
-#define PK_DRTHP_CON2GAIN_LV1_BIT	    16
-#define PK_DRTHP_CON2GAIN_LV1_WID	    8
-//Bit 23:16, reg_pk_drthp_con2gain_lv1      level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 96;
-#define PK_DRTHP_CON2GAIN_LV2_BIT	    8
-#define PK_DRTHP_CON2GAIN_LV2_WID	    8
-//Bit 15: 8, reg_pk_drthp_con2gain_lv2      level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 5;
-//Bit  7: 0, reserved                       
-
-#define ISP_PK_CON_2DRTBPGAIN_TH_RATE       0x2d5a   
-//reg_pk_drtbp_con2gain (0 1 5 6) 
-#define PK_DRTBP_CON2GAIN_TH0_BIT	    24
-#define PK_DRTBP_CON2GAIN_TH0_WID	    8
-//Bit 31:24, reg_pk_drtbp_con2gain_th0      threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 20;
-#define PK_DRTBP_CON2GAIN_TH1_BIT	    16
-#define PK_DRTBP_CON2GAIN_TH1_WID	    8
-//Bit 23:16, reg_pk_drtbp_con2gain_th1      threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 50;
-#define PK_DRTBP_CON2GAIN_RATE0_BIT	    8
-#define PK_DRTBP_CON2GAIN_RATE0_WID	    8
-//Bit 15: 8, reg_pk_drtbp_con2gain_rate0    rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 50;
-#define PK_DRTBP_CON2GAIN_RATE1_BIT	    0
-#define PK_DRTBP_CON2GAIN_RATE1_WID	    8
-//Bit  7: 0, reg_pk_drtbp_con2gain_rate1    rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 25;
-
-#define ISP_PK_CON_2DRTBPGAIN_LIMIT         0x2d5b   
-//reg_pk_drtbp_con2gain (2 3 4) 
-#define PK_DRTBP_CON2GAIN_LV0_BIT	    24
-#define PK_DRTBP_CON2GAIN_LV0_WID	    8
-//Bit 31:24, reg_pk_drtbp_con2gain_lv0      level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 0;
-#define PK_DRTBP_CON2GAIN_LV1_BIT 	    16
-#define PK_DRTBP_CON2GAIN_LV1_WID	    8
-//Bit 23:16, reg_pk_drtbp_con2gain_lv1      level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 40;
-#define PK_DRTBP_CON2GAIN_LV2_BIT	    8
-#define PK_DRTBP_CON2GAIN_LV2_WID	    8
-//Bit 15: 8, reg_pk_drtbp_con2gain_lv2      level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 5;
-//Bit  7: 0, reserved                       
-
-// address 0x2d5c~ 0x2d5f null
-
-#define ISP_PK_CIRFB_LPF_MODE               0x2d60  
-//Bit 31:30, reserved
-#define CIRHP_HORZ_FLT_MODE_BIE		    28
-#define CIRHP_HORZ_FLT_MODE_WID		    2
-//Bit 29:28, reg_cirhp_horz_flt_mode        vertical highpass filter ([-1 2 -1]') horizontal lpf mode for circle hpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 1;
-//Bit 27:26, reserved
-#define CIRHP_VERT_FLT_MODE_BIE		    24
-#define CIRHP_VERT_FLT_MODE_WID		    2
-//Bit 25:24, reg_cirhp_vert_flt_mode        horizontal highpass filter ([-1 2 -1]) vertical lpf mode  for circle hpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 1;
-//Bit 23:21, reserved                       
-#define CIRHP_DIAG_FLT_MODE_BIE		    20
-#define CIRHP_DIAG_FLT_MODE_WID		    1
-//Bit    20, reg_cirhp_diag_flt_mode        diagonal highpass filter crossing lpf mode for circle hpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
-//Bit 19:14, reserved
-#define CIRBP_HORZ_FLT_MODE_BIT		    12
-#define CIRBP_HORZ_FLT_MODE_WID		    2
-//Bit 13:12, reg_cirbp_horz_flt_mode        vertical bandpass filte ([-3 1 4 1 -3]') horizontal lpf mode for circle bpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 1;
-//Bit 11:10, reserved                       
-#define CIRBP_VERT_FLT_MODE_BIT		    8
-#define CIRBP_VERT_FLT_MODE_WID		    2
-//Bit  9: 8, reg_cirbp_vert_flt_mode        horizontal bandpass filte ([-3 1 4 1 -3]) vertical lpf mode  for circle bpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 1;
-//Bit  7: 5, reserved                     
-#define CIRBP_DIAG_FLT_MODE_BIT		    4
-#define CIRBP_DIAG_FLT_MODE_WID		    1
-//Bit     4, reg_cirbp_diag_flt_mode        diagonal bandpass filter crossing lpf mode for circle bpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
-//Bit  3: 0, reserved                       
-
-#define ISP_PK_DRTFB_LPF_MODE               0x2d61  
-//Bit 31:30, reserved
-#define DRTHP_HORZ_FLT_MODE_BIT		    28
-#define DRTHP_HORZ_FLT_MODE_WID		    2
-//Bit 29:28, reg_drthp_horz_flt_mode        vertical highpass filter ([-1 2 -1]') horizontal lpf mode for directional hpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 2;
-//Bit 27:26, reserved
-#define DRTHP_VERT_FLT_MODE_BIT		    24
-#define DRTHP_VERT_FLT_MODE_WID		    2
-//Bit 25:24, reg_drthp_vert_flt_mode        horizontal highpass filter ([-1 2 -1]) vertical lpf mode  for directional hpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
-//Bit 23:21, reserved                       
-#define DRTHP_DIAG_FLT_MODE_BIT		    20
-#define DRTHP_DIAG_FLT_MODE_WID		    1
-//Bit    20, reg_drthp_diag_flt_mode        diagonal highpass filter crossing lpf mode for directional hpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
-//Bit 19:14, reserved
-#define DRTBP_HORZ_FLT_MODE_BIT		    12
-#define DRTBP_HORZ_FLT_MODE_MODE	    2
-//Bit 13:12, reg_drtbp_horz_flt_mode        vertical bandpass filte ([-3 1 4 1 -3]') horizontal lpf mode for directional bpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 2;
-//Bit 11:10, reserved
-#define DRTBP_VERT_FLT_MODE_BIT		    8
-#define DRTBP_VERT_FLT_MODE_MODE	    2
-//Bit  9: 8, reg_drtbp_vert_flt_mode        horizontal bandpass filte ([-3 1 4 1 -3]) vertical lpf mode  for directional bpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
-//Bit  7: 5, reserved
-#define DRTBP_DIAG_FLT_MODE_BIE		    4
-#define DRTBP_DIAG_FLT_MODE_WID		    1
-//Bit     4, reg_drtbp_diag_flt_mode        diagonal bandpass filter crossing lpf mode for directional bpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
-//Bit  3: 0, reserved                       
-
-#define ISP_PK_CIRFB_HP_CORING              0x2d62  
-//Bit 31:22, reserved
-#define CIRHP_HORZ_CORE_BIT		    16
-#define CIRHP_HORZ_CORE_MODE		    6
-//Bit 21:16, reg_cirhp_horz_core            coring to vertical highpass filter ([-1 2 -1]') in circle hpf calculation. 0~63. default= 20;
-//Bit 15:14, reserved
-#define CIRHP_VERT_CORE_BIT		    13
-#define CIRHP_VERT_CORE_MODE		    6
-//Bit 13: 8, reg_cirhp_vert_core            coring to horizontal highpass filter ([-1 2 -1])  in circle hpf calculation. 0~63. default= 20;
-//Bit  7: 6, reserved
-#define CIRHP_DIAG_CORE_BIT		    0
-#define CIRHP_DIAG_CORE_WID		    6
-//Bit  5: 0, reg_cirhp_diag_core            coring to diagonal highpass filter ([-1 2 -1])  in circle hpf calculation. 0~63. default= 20;
-
-#define ISP_PK_CIRFB_BP_CORING              0x2d63  
-//Bit 31:22, reserved
-#define CIRBP_HORZ_CORE_BIT		    16
-#define CIRBP_HORZ_CORE_WID		    6
-//Bit 21:16, reg_cirbp_horz_core            coring to vertical bandpass filter ([-1 2 -1]') in circle bpf calculation. 0~63. default= 15;
-//Bit 15:14, reserved                       
-#define CIRBP_VERT_CORE_BIT		    8
-#define CIRBP_VERT_CORE_WID		    6
-//Bit 13: 8, reg_cirbp_vert_core            coring to horizontal bandpass filter ([-1 2 -1])  in circle bpf calculation. 0~63. default= 15;
-//Bit  7: 6, reserved                       
-#define CIRBP_DIAG_CORE_BIT		    0
-#define CIRBP_DIAG_CORE_WID		    6
-//Bit  5: 0, reg_cirbp_diag_core            coring to diagonal bandpass filter ([-1 2 -1])  in circle bpf calculation. 0~63. default= 15;
-
-#define ISP_PK_DRTFB_HP_CORING              0x2d64  
-//Bit 31:22, reserved
-#define DRTHP_HORZ_CORE_BIT		    16
-#define DRTHP_HORZ_CORE_WID		    6
-//Bit 21:16, reg_drthp_horz_core            coring to vertical highpass filter ([-1 2 -1]') in directional hpf calculation. 0~63. default= 20;
-//Bit 15:14, reserved
-#define DRTHP_VERT_CORE_BIT		    13
-#define DRTHP_VERT_CORE_WID		    6
-//Bit 13: 8, reg_drthp_vert_core            coring to horizontal highpass filter ([-1 2 -1])  in directional hpf calculation. 0~63. default= 20;
-//Bit  7: 6, reserved
-#define DRTHP_DIAG_CORE_BIT		    0
-#define DRTHP_DIAG_CORE_WID		    6
-//Bit  5: 0, reg_drthp_diag_core            coring to diagonal highpass filter ([-1 2 -1])  in directional hpf calculation. 0~63. default= 20;
-
-#define ISP_PK_DRTFB_BP_CORING              0x2d65  
-//Bit 31:22, reserved
-#define DRTBP_HORZ_CORE_BIT		    16
-#define DRTBP_HORZ_CORE_WID		    6
-//Bit 21:16, reg_drtbp_horz_core            coring to vertical bandpass filter ([-1 2 -1]') in directional bpf calculation. 0~63. default= 15;
-//Bit 15:14, reserved
-#define DRTBP_VERT_CORE_BIT                 8
-#define DRTBP_VERT_CORE_WID		    6
-//Bit 13: 8, reg_drtbp_vert_core            coring to horizontal bandpass filter ([-1 2 -1])  in directional bpf calculation. 0~63. default= 15;
-//Bit  7: 6, reserved
-#define DRTBP_DIAG_CORE_BIT		    0
-#define DRTBP_DIAG_CORE_WID		    6
-//Bit  5: 0, reg_drtbp_diag_core            coring to diagonal bandpass filter ([-1 2 -1])  in directional bpf calculation. 0~63. default= 15;
-
-#define ISP_PK_CIRFB_BLEND_GAIN             0x2d66  
-#define HP_CIR_HGAIN_BIT		    28
-#define HP_CIR_HGAIN_WID		    4
-//Bit 31:28, reg_hp_cir_hgain               vertical hpf gain for hp_cir calculation. 0~15. normalize 8 as '1';  default = 8;
-#define HP_CIR_VGAIN_BIT		    24
-#define HP_CIR_VGAIN_WID		    4
-//Bit 27:24, reg_hp_cir_vgain               horizontal hpf gain for hp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
-#define HP_CIR_DGAIN_BIT		    20
-#define HP_CIR_DGAIN_WID	            4
-//Bit 23:20, reg_hp_cir_dgain               diagonal hpf gain for hp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
-//Bit 19:16, reserved                       
-#define BP_CIR_HGAIN_BIT		    12
-#define BP_CIR_HGAIN_WID		    4
-//Bit 15:12, reg_bp_cir_hgain               vertical bpf gain for bp_cir calculation. 0~15. normalize 8 as '1';  default = 8;
-#define BP_CIR_VGAIN_BIT	            11
-#define BP_CIR_VGAIN_WID		    4
-//Bit 11: 8, reg_bp_cir_vgain               horizontal bpf gain for bp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
-#define BP_CIR_DGAIN_BIT		    4
-#define BP_CIR_DGAIN_WID		    4
-//Bit  7: 4, reg_bp_cir_dgain               diagonal bpf gain for bp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
-//Bit  3: 0, reserved                       
-
-// address 0x2d67~ 0x2d67 null
-
-//nr_alp0 is for blending of gaussian and original results
-#define ISP_NR_ALPY_SSD_GAIN_OFST           0x2d68  
-//Bit 31:15, reserved
-#define NR_ALP0_SSD_GAIN_BIT	            8
-#define NR_ALP0_SSD_GAIN_WID	            8
-//Bit 15: 8, reg_nr_alp0_ssd_gain           gain to signed sum difference (SSD for transition detection) for alpha0 calculation. the smaller of this value, the more blur of image (more Gaussian results). 0~255, normalized 16 as '1'; default= 16     
-//Bit  7: 6, reserved
-#define NR_ALP0_SSD_OFST_BIT	            0
-#define NR_ALP0_SSD_OFST_WID		    6
-//Bit  5: 0, reg_nr_alp0_ssd_ofst           ofsset to SSD before dividing to min_err. the smaller of this value, the more blur of image (more Gaussian results); -32:31. default= -2;
-
-#define ISP_NR_ALP0Y_ERR2CURV_TH_RATE       0x2d69  
-//reg_nr_alp0_minerr_ypar (0 1 5 6)
-#define NR_ALP0_MINERR_YPAR_TH0_BIT         24
-#define NR_ALP0_MINERR_YPAR_TH0_WID	    8
-//Bit 31:24, reg_nr_alp0_minerr_ypar_th0    threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255. default = 10;
-#define NR_ALP0_MINERR_YPAR_TH1_BIT         16
-#define NR_ALP0_MINERR_YPAR_TH1_WID	    8
-//Bit 23:16, reg_nr_alp0_minerr_ypar_th1    threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur. 0~255. default = 25;
-#define NR_ALP0_MINERR_YPAR_RATE0_BIT	    8
-#define NR_ALP0_MINERR_YPAR_RATE0_WID	    8
-//Bit 15: 8, reg_nr_alp0_minerr_ypar_rate0  rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255. default = 80;
-#define NR_ALP0_MINERR_YPAR_RATE1_BIT	    0
-#define NR_ALP0_MINERR_YPAR_RATE1_WID	    8
-//Bit  7: 0, reg_nr_alp0_minerr_ypar_rate1  rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255. default = 64;
-
-//reg_nr_alp0_minerr_ypar (2 3 4)
-#define ISP_NR_ALP0Y_ERR2CURV_LIMIT         0x2d6a
-#define ALP0_MINERR_YPAR_LV0_BIT	    24
-#define ALP0_MINERR_YPAR_LV0_WID	    8
-//Bit 31:24, reg_nr_alp0_minerr_ypar_lv0    level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255. default = 63;
-#define ALP0_MINERR_YPAR_LV1_BIT	    16
-#define ALP0_MINERR_YPAR_LV1_WID	    8
-//Bit 23:16, reg_nr_alp0_minerr_ypar_lv1    level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255. default = 0;
-#define ALP0_MINERR_YPAR_LV2_BIT	    8
-#define ALP0_MINERR_YPAR_LV2_WID	    8
-//Bit 15: 8, reg_nr_alp0_minerr_ypar_lv2    level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255. default = 63;
-//Bit  7: 0, reserved                                                                   
-//reg_nr_alp0_minerr_cpar (0 1 5 6)         
-#define ISP_NR_ALP0C_ERR2CURV_TH_RATE       0x2d6b  
-#define ALP0_MINERR_CPAR_TH0_BIT	    24
-#define ALP0_MINERR_CPAR_TH0_WID	    8
-//Bit 31:24, reg_nr_alp0_minerr_cpar_th0    threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur. 0~255. default = 10;
-#define ALP0_MINERR_CPAR_TH1_BIT	    16
-#define ALP0_MINERR_CPAR_TH1_WID	    8
-//Bit 23:16, reg_nr_alp0_minerr_cpar_th1    threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur. 0~255. default = 25;
-#define ALP0_MINERR_CPAR_RATE0_BIT	    8
-#define ALP0_MINERR_CPAR_RATE0_WID	    8
-//Bit 15: 8, reg_nr_alp0_minerr_cpar_rate0  rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255. default = 80;
-#define ALP0_MINERR_CPAR_RATE1_BIT	    0
-#define ALP0_MINERR_CPAR_RATE1_WID	    8
-//Bit  7: 0, reg_nr_alp0_minerr_cpar_rate1  rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255. default = 64;
-
-//reg_nr_alp0_minerr_cpar (2 3 4)
-#define ISP_NR_ALP0C_ERR2CURV_LIMIT         0x2d6c  
-#define ALP0_MINERR_CPAR_LV0_BIT	    24
-#define ALP0_MINERR_CPAR_LV0_WID	    8
-//Bit 31:24, reg_nr_alp0_minerr_cpar_lv0    level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255. default = 63;
-#define ALP0_MINERR_CPAR_LV1_BIT	    16
-#define ALP0_MINERR_CPAR_LV1_WID	    8
-//Bit 23:16, reg_nr_alp0_minerr_cpar_lv1    level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255. default = 0;
-#define ALP0_MINERR_CPAR_LV2_BIT	    8
-#define ALP0_MINERR_CPAR_LV2_WID	    8
-//Bit 15: 8, reg_nr_alp0_minerr_cpar_lv2    level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255. default = 63;
-//Bit  7: 0, reserved                       
-
-#define ISP_NR_ALP0_MIN_MAX                 0x2d6d  
-//Bit 31:30, reserved
-#define NR_ALP0_YMIN_BIT		    24
-#define NR_ALP0_YMIN_WID		    6
-//Bit 29:24, reg_nr_alp0_ymin               minumum limit of alp0 for luma channel, if it is 63, means all gaussian lpf result, 0~63, . default = 2;
-//Bit 23:22, reserved                       
-#define NR_ALP0_YMAX_BIT		    24
-#define NR_ALP0_YMAX_WID		    6
-//Bit 21:16, reg_nr_alp0_ymax               maximum limit of alp0 for luma channel, if it is  0, means all orginal result, 0~63, . default = 63;
-//Bit 15:14, reserved
-#define NR_ALP0_CMIN_BIT		    8
-#define NR_ALP0_CMIN_WID		    6
-//Bit 13: 8, reg_nr_alp0_cmin               minumum limit of alp0 for chroma channel, if it is 63, means all gaussian lpf result, 0~63, . default = 2;
-//Bit  7: 6, reserved
-#define NR_ALP0_CMAX_BIT		    0
-#define NR_ALP0_CMAX_WID		    6
-//Bit  5: 0, reg_nr_alp0_cmax               maximum limit of alp0 for chroma channel, if it is  0, means all orginal result, 0~63, . default = 63;
-
-
-#define ISP_NR_ALP1_MIERR_CORING            0x2d6e      
-//Bit 31:17, reserved
-#define NR_ALP1_MAXERR_MODE_BIT	            16	
-#define NR_ALP1_MAXERR_MODE_WID		    1
-//Bit    16, reg_nr_alp1_maxerr_mode        mxerr select mode. 0: max_err of eight directions; 1: crossing direction of min_err direction. default=0;
-//Bit 15:14, reserved
-#define NR_ALP1_CORE_RATE_BIT	            8
-#define NR_ALP1_CORE_RATE_WID		    6
-//Bit 13: 8, reg_nr_alp1_core_rate          rate to (mxerr-min_err) to get coring to min_err. normalized to 64 as '1'. 0~63. default =0;   
-//Bit  7: 6, reserved
-#define NR_ALP1_CORE_OFST_BIT		    0
-#define NR_ALP1_CORE_OFST_WID		    6
-//Bit  5: 0, reg_nr_alp1_core_ofst          offset of coring to min_err. normalized to 64 as '1'. 0~63. default =3;
-
-#define ISP_NR_ALP1_ERR2CURV_TH_RATE        0x2d6f  
-//reg_nr_alp1_minerr_par (0 1 5 6) 
-#define ALP1_MINERR_PAR_TH0_BIT		    24
-#define ALP1_MINERR_PAR_TH0_WID		    8
-//Bit 31:24, reg_nr_alp1_minerr_par_th0     threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255. default = 0;
-#define ALP1_MINERR_PAR_TH1_BIT		    16
-#define ALP1_MINERR_PAR_TH1_WID		    8
-//Bit 23:16, reg_nr_alp1_minerr_par_th1     threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255. default = 24;
-#define ALP1_MINERR_PAR_RATE0_BIT	    8
-#define ALP1_MINERR_PAR_RATE0_WID	    8
-//Bit 15: 8, reg_nr_alp1_minerr_par_rate0   rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. default = 0;
-#define ALP1_MINERR_PAR_RATE1_BIT	    0
-#define ALP1_MINERR_PAR_RATE1_WID	    8
-//Bit  7: 0, reg_nr_alp1_minerr_par_rate1   rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. default = 20;
-
-#define ISP_NR_ALP1_ERR2CURV_LIMIT          0x2d70    
-//reg_nr_alp1_minerr_par (2 3 4)
-#define ALP1_MINERR_PAR_LV0_BIT		    24
-#define ALP1_MINERR_PAR_LV0_WID		    8
-//Bit 31:24, reg_nr_alp1_minerr_par_lv0     level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255. default = 0;
-#define ALP1_MINERR_PAR_LV1_BIT		    16
-#define ALP1_MINERR_PAR_LV1_WID		    8
-//Bit 23:16, reg_nr_alp1_minerr_par_lv1     level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255. default = 16;
-#define ALP1_MINERR_PAR_LV2_BIT		    8
-#define ALP1_MINERR_PAR_LV2_WID		    8
-//Bit 15: 8, reg_nr_alp1_minerr_par_lv2     level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255. default = 63;
-//Bit  7: 0, reserved                       
-
-#define ISP_NR_ALP1_MIN_MAX                 0x2d71  
-//Bit 31:30, reserved
-#define NR_ALP1_YMIN_BIT		    24
-#define NR_ALP1_YMIN_WID		    6
-//Bit 29:24, reg_nr_alp1_ymin               minumum limit of alp1 for luma channel, if it is 63, means all directional lpf result, 0~63, . default = 0;
-//Bit 23:22, reserved
-#define NR_ALP1_YMAX_BIT		    16
-#define NR_ALP1_YMAX_WID		    6
-//Bit 21:16, reg_nr_alp1_ymax               maximum limit of alp1 for luma channel, if it is  0, means all gaussian blend  result, 0~63, . default = 63;
-//Bit 15:14, reserved
-#define NR_ALP1_CMIN_BIT		    8
-#define NR_ALP1_CMIN_WID		    6
-//Bit 13: 8, reg_nr_alp1_cmin               minumum limit of alp1 for chroma channel, if it is 63, means all directonal lpf result, 0~63, . default = 0;
-//Bit  7: 6, reserved
-#define NR_ALP1_CMAX_BIT		    0
-#define NR_ALP1_CMAX_WID		    6
-//Bit  5: 0, reg_nr_alp1_cmax               maximum limit of alp1 for chroma channel, if it is  0, means all gaussian blend result, 0~63, . default = 63;
-
-#define ISP_PK_ALP2_MIERR_CORING            0x2d72       
-//Bit 31:17, reserved
-#define ALP2_MAXERR_MODE_BIT	            16
-#define ALP2_MAXERR_MODE_WID		    1
-//Bit    16, reg_nr_alp2_maxerr_mode        mxerr select mode for alp2 calculation. 0: max_err of eight directions; 1: crossing direction of min_err direction. default=1;
-//Bit 15:14, reserved
-#define ALP2_CORE_RATE_BIT		    8
-#define ALP2_CORE_RATE_WID		    6
-//Bit 13: 8, reg_nr_alp2_core_rate          rate to (mxerr-min_err) to get coring to min_err for alp2 calculation. normalized to 64 as '1'. 0~63. default =13;   
-//Bit  7: 6, reserved          
-#define ALP2_CORE_OFST_BIT		    0
-#define ALP2_CORE_OFST_WID		    6
-//Bit  5: 0, reg_nr_alp2_core_ofst          offset of coring to min_err for alp2 calculation. normalized to 64 as '1'. 0~63. default =1;
-
-#define ISP_PK_ALP2_ERR2CURV_TH_RATE        0x2d73  
-//reg_nr_alp2_minerr_par (0 1 5 6)
-#define ALP2_MINERR_PAR_TH0_BIT		    24
-#define ALP2_MINERR_PAR_TH0_WID		    8
-//Bit 31:24, reg_nr_alp2_minerr_par_th0     threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking. 0~255. default = 0;
-#define ALP2_MINERR_PAR_TH1_BIT		    16
-#define ALP2_MINERR_PAR_TH1_WID	            8
-//Bit 23:16, reg_nr_alp2_minerr_par_th1     threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255. default = 24;
-#define ALP2_MINERR_PAR_RATE0_BIT	    8
-#define ALP2_MINERR_PAR_RATE0_WID	    8
-//Bit 15: 8, reg_nr_alp2_minerr_par_rate0   rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255. default = 0;
-#define ALP2_MINERR_PAR_RATE1_BIT	    0
-#define ALP2_MINERR_PAR_RATE1_WID	    8
-//Bit  7: 0, reg_nr_alp2_minerr_par_rate1   rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255. default = 20;
-
-#define ISP_PK_ALP2_ERR2CURV_LIMIT          0x2d74   
-//reg_nr_alp1_minerr_par (2 3 4)
-#define ALP2_MINERR_PAR_LV0_BIT		    24
-#define ALP2_MINERR_PAR_LV0_WID		    8
-//Bit 31:24, reg_nr_alp2_minerr_par_lv0     level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255. default = 0;
-#define ALP2_MINERR_PAR_LV1_BIT		    16
-#define ALP2_MINERR_PAR_LV1_WID		    8
-//Bit 23:16, reg_nr_alp2_minerr_par_lv1     level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255. default = 16;
-#define ALP2_MINERR_PAR_LV2_BIT		    8
-#define ALP2_MINERR_PAR_LV2_WID		    8
-//Bit 15: 8, reg_nr_alp2_minerr_par_lv2     level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 63;
-//Bit  7: 0, reserved                       
-
-#define ISP_PK_ALP2_MIN_MAX                 0x2d75  
-//Bit 31:14, reserved
-#define NR_ALP2_MIN_BIT			    8
-#define NR_ALP2_MIN_WID			    6
-//Bit 13: 8, reg_nr_alp2_min                minumum limit of alp2 for luma channel, if it is 63, means directional peaking result, 0~63, . default = 0;
-//Bit  7: 6, reserved
-#define NR_ALP2_MIN_BIT			    8
-#define NR_ALP2_MIN_WID			    6
-
-//Bit  5: 0, reg_nr_alp2_max                maximum limit of alp2 for luma channel, if it is  0, means all circle peaking result, 0~63, . default = 63;
-
-#define ISP_PK_FINALGAIN_HP_BP              0x2d76  
-//Bit 31:16, reserved
-#define HP_FINAL_GAIN_BIT	            8
-#define HP_FINAL_GAIN_WID		    8
-//Bit 15: 8, reg_hp_final_gain              gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. default = 40;
-#define BP_FINAL_GAIN_BIT		    0
-#define BP_FINAL_GAIN_WID		    8
-//Bit  7: 0, reg_bp_final_gain              gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. default = 40;
-
-// address 0x2d77~ 0x2d77 null 
-
-#define ISP_PK_OS_HORZ_CORE_GAIN            0x2d78
-#define OS_HSIDE_CORE_BIT		    24
-#define OS_HSIDE_CORE_WID		    8
-//Bit 31:24, reg_os_hside_core              side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255; default= 8;             
-#define OS_HSIDE_GAIN_BIT		    16
-#define OS_HSIDE_GAIN_WID		    8
-//Bit 23:16, reg_os_hside_gain              side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255; default= 20;     
-#define OS_HMIDD_CORE_BIT		    8
-#define OS_HMIDD_CORE_WID		    8
-//Bit 15: 8, reg_os_hmidd_core              midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255; default= 2;             
-#define OS_HMIDD_GAIN_BIT		    0
-#define OS_HMIDD_GAIN_WID		    8
-//Bit  7: 0, reg_os_hmidd_gain              midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255; default= 20;   
-
-#define ISP_PK_OS_VERT_CORE_GAIN            0x2d79  
-#define OS_VSIDE_CORE_BIT		    24
-#define OS_VSIDE_CORE_WID		    8
-//Bit 31:24, reg_os_vside_core              side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255; default= 2;             
-#define OS_VSIDE_GAIN_BIT		    16
-#define OS_VSIDE_GAIN_WID		    8
-//Bit 23:16, reg_os_vside_gain              side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255; default= 20;     
-#define OS_VMIDD_CORE_BIT		    8
-#define OS_VMIDD_CORE_WID		    8
-//Bit 15: 8, reg_os_vmidd_core              midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255; default= 8;             
-#define OS_VMIDD_GAIN_BIT	            0
-#define OS_VMIDD_GAIN_WID		    8
-//Bit  7: 0, reg_os_vmidd_gain              midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255; default= 20;   
-
-
-#define ISP_PK_OS_ADPT_MISC                 0x2d7a
-#define PK_OS_MINERR_CORE_BIT	            24
-#define PK_OS_MINERR_CORE_WID	            8
-//Bit 31:24, reg_pk_os_minerr_core          coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255; default= 40;             
-#define PK_OS_MINERR_GAIN_BIT	            16
-#define PK_OS_MINERR_GAIN_WID		    8
-//Bit 23:16, reg_pk_os_minerr_gain          gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255; default= 6;     
-#define PK_OS_ADPT_MAX_BIT		    8
-#define PK_OS_ADPT_MAX_WID		    8
-//Bit 15: 8, reg_pk_os_adpt_max             maximum limit adaptive overshoot margin (4x). 0~255; default= 200;             
-#define PK_OS_ADPT_MIN_BIT		    0
-#define PK_OS_ADPT_MIN_WID		    8
-//Bit  7: 0, reg_pk_os_adpt_min             minimun limit adaptive overshoot margin (1x). 0~255; default= 20; 
-
-#define ISP_PK_OS_STATIC                    0x2d7b  
-//Bit 31:30, reserved
-#define PK_OSH_MODE_BIT			    28
-#define PK_OSH_MODE_WID			    2
-//Bit 29:28, reg_pk_osh_mode                horizontal min_max window size for overshoot. window size =(2x+1); 0~3. default=2;   
-//Bit 27:26, reserved                       
-#define PK_OSV_MODE_BIT			    24
-#define PK_OSV_MODE_WID			    2
-//Bit 25:24, reg_pk_osv_mode                vertical min_max window size for overshoot. window size =(2x+1); 0~2. default=2;
-//Bit 23:22, reserved                       
-#define PK_OS_DOWN_BIT			    12
-#define PK_OS_DOWN_WID			    10
-//Bit 21:12, reg_pk_os_down                 static negative overshoot margin. 0~1023; default= 0;     
-//Bit 11:10, reserved                     
-#define PK_OS_UP_BIT			    0
-#define PK_OS_UP_WID			    10
-//Bit  9: 0, reg_pk_os_up                   static positive overshoot margin. 0~1023; default= 0; 
-
-// address 0x2d7c~ 0x2d7f null 
-/************************special digital effect register************************/
-#define ISP_PKSDE_MODE_PKGAIN               0x2d80  
-//Bit    31, reserved
-#define PKSDE_YMODE_BIT			    28
-#define PKSDE_YMODE_WID			    3
-//Bit 30:28, reg_pksde_ymode                luma channel sde mode. 0~7. 0, no SDE; 1: rplc+ peaking; 2: rplc - peaking; 3: rplc+ peaking>0; 4: rplc + peaking<0; 5: rplc+ abs(peaking) 6: rplc-abs(peaking); 7: binary; default = 0;
-//Bit    27, reserved                       
-#define PKSDE_UMODE_BIT			    24
-#define PKSDE_UMODE_WID			    3
-//Bit 26:24, reg_pksde_umode                U channel sde mode. 0~7. 0, no SDE; 1: rplc+ peaking; 2: rplc - peaking; 3: rplc+ peaking>0; 4: rplc + peaking<0; 5: rplc+ abs(peaking) 6: rplc-abs(peaking); 7: binary ; default = 0;
-//Bit    23, reserved                       
-#define PKSDE_VMODE_BIT			    20
-#define PKSDE_VMODE_WID			    3
-//Bit 22:20, reg_pksde_vmode                V channel sde mode. 0~7. 0, no SDE; 1: rplc+ peaking; 2: rplc - peaking; 3: rplc+ peaking>0; 4: rplc + peaking<0; 5: rplc+ abs(peaking) 6: rplc-abs(peaking); 7: binary ; default = 0;
-//Bit 19:12, reserved
-#define PKSDE_PK4Y_GAIN_BIT		    8
-#define PKSDE_PK4Y_GAIN_WID		    4
-//Bit 11: 8, reg_pksde_pk4y_gain            gain to peaking boost component and add delta to luma channel. normalized 8 as '1'. 0~15; default=8 
-#define PKSDE_PK4U_GAIN_BIT		    4
-#define PKSDE_PK4U_GAIN_WID		    4
-//Bit  7: 4, reg_pksde_pk4u_gain            gain to peaking boost component and add delta to u channel. normalized 8 as '1'. 0~15; default=8 
-#define PKSDE_PK4V_GAIN_BIT		    0
-#define PKSDE_PK4V_GAIN_WID		    4
-//Bit  3: 0, reg_pksde_pk4v_gain            gain to peaking boost component and add delta to v channel. normalized 8 as '1'. 0~15; default=8 
-
-#define ISP_PKSDE_REPLACE_Y_U               0x2d81  
-//Bit 31:29, reserved
-#define PKSDE_RPLC_YEN_BIT		    28
-#define PKSDE_RPLC_YEN_WID		    1
-//Bit    28, reg_pksde_rplc_yen             enable to replace Y channel with reg_pksde_rplc_y. default = 0
-//Bit 27:26, reserved
-#define PKSDE_RPLC_Y_BIT		    16
-#define PKSDE_RPLC_Y_WID		    10
-//Bit 25:16, reg_pksde_rplc_y               luma value to be replaced to Y channel when reg_pksde_rplc_yen=1. 0~1023. default = 512
-//Bit 15:13, reserved
-#define PKSDE_RPLC_RPLC_UEN_BIT		    12
-#define PKSDE_RPLC_RPLC_UEN_WID		    1
-//Bit    12, reg_pksde_rplc_uen             enable to replace U channel with reg_pksde_rplc_u. default = 0
-//Bit 11:10, reserved                       
-#define PKSDE_RPLC_RPLC_U_BIT		    0
-#define PKSDE_RPLC_RPLC_U_WID		    10
-//Bit  9: 0, reg_pksde_rplc_u               U value to be replaced to U channel when reg_pksde_rplc_uen=1. 0~1023. default = 512
-
-#define ISP_PKSDE_REPLACE_V                 0x2d82  
-//Bit 31:29, reserved
-#define PKSDE_RPLC_RPLC_VEN_BIT		    28
-#define PKSDE_RPLC_RPLC_VEN_WID		    1
-//Bit    28, reg_pksde_rplc_ven             enable to replace V channel with reg_pksde_rplc_v. default = 0
-//Bit 27:26, reserved
-#define PKSDE_RPLC_RPLC_V_BIT		    16
-#define PKSDE_RPLC_RPLC_V_WID		    10
-//Bit 25:16, reg_pksde_rplc_v               V value to be replaced to V channel when reg_pksde_rplc_ven=1. 0~1023. default = 512
-//Bit 15: 0, reserved                       
-
-#define ISP_PKSDE_BINARY_HIG                0x2d83  
-//Bit 31:24, reserved
-#define PKSDE_YPOSI_BIT			    16
-#define PKSDE_YPOSI_WID			    8
-//Bit 23:16, reg_pksde_yposi                binary effect high luma level for Y. 0~255. default = 192
-#define PKSDE_UPOSI_BIT			    8
-#define PKSDE_UPOSI_WID			    8
-//Bit 15: 8, reg_pksde_uposi                binary effect high U level for U. 0~255. default = 192
-#define PKSDE_VPOSI_BIT			    0
-#define PKSDE_VPOSI_WID			    8
-//Bit  7: 0, reg_pksde_vposi                binary effect high V level for V. 0~255. default = 192
-
-#define ISP_PKSDE_BINARY_LOW                0x2d84  
-//Bit 31:24, reserved
-#define PKSDE_YNEGI_BIT			    16
-#define PKSDE_YNEGI_WID			    8
-//Bit 23:16, reg_pksde_ynegi                binary effect low luma level for Y. 0~255. default = 64
-#define PKSDE_UNEGI_BIT			    8
-#define PKSDE_UNEGI_WID			    8
-//Bit 15: 8, reg_pksde_unegi                binary effect low U level for U. 0~255. default = 128
-#define PKSDE_VNEGI_BIT			    0
-#define PKSDE_VNEGI_WID			    8
-//Bit  7: 0, reg_pksde_vnegi                binary effect low V level for V. 0~255. default = 128
-
-#define ISP_PKNR_ENABLE                     0x2d85  
-//Bit 31: 2, reserved
-#define ISP_PK_EN_BIT			    1
-#define ISP_PK_EN_WID			    1
-//Bit     1, reg_isp_pk_en                  isp peaking enable default = 1
-#define ISP_NR_EN_BIT			    0
-#define ISP_NR_EN_WID			    1
-//Bit     0, reg_isp_nr_en                  isp noise reduction enable default = 1
-
-
-// address 8'h86~ 8'h87 null 
-/***************auto white balance statistics registers*****************/
-#define ISP_AWB_WIND_LR                     0x2d88  
-//Bit 31:29, reserved
-#define AWB_WIND_LEFT_BIT		    16
-#define AWB_WIND_LEFT_WID		    13
-//Bit 28:16, reg_isp_awb_wind_left          window left x index for rgb raw statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AWB_WIND_RIGHT_BIT		    0
-#define AWB_WIND_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_awb_wind_right         window right x index for rgb raw statistics. 0~8191. default = 100.
-
-#define ISP_AWB_WIND_TB                     0x2d89  
-//Bit 31:29, reserved
-#define AWB_WIND_TOP_BIT		    16
-#define AWB_WIND_TOP_WID		    13
-//Bit 28:16, reg_isp_awb_wind_top           window top y index for awb rgb statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AWB_WIND_BOT_BIT		    0
-#define AWB_WIND_BOT_WID		    13
-//Bit 12: 0, reg_isp_awb_wind_bot           window bot y index for awb rgb statistics. 0~8191. default = 100.
-
-#define ISP_AWB_GBGRBR_THRD                 0x2d8a  
-//Bit 31:24, reserved
-#define AWB_GB_THRD_BIT			    16
-#define AWB_GB_THRD_WID			    8
-//Bit 23:16, reg_isp_awb_gb_thrd            threshold to abs(g-b) to decide adding to awb statistics. 0~255. default = 200.
-#define AWB_GR_THRD_BIT			    8
-#define AWB_GR_THRD_WID			    8
-//Bit 15: 8, reg_isp_awb_gr_thrd            threshold to abs(g-r) to decide adding to awb statistics. 0~255. default = 200.
-#define AWB_BR_THRD_BIT			    0
-#define AWB_BR_THRD_WID			    8
-//Bit  7: 0, reg_isp_awb_br_thrd            threshold to abs(b-r) to decide adding to awb statistics. 0~255. default = 200.
-
-#define ISP_AWB_UVTH_YPIECE                 0x2d8b
-#define AWB_U_THRD_BIT			    24
-#define AWB_U_THRD_WID			    8
-//Bit 31:24, reg_isp_awb_u_thrd             threshold to abs(u-128) to decide adding to awb statistics. 0~255. default = 200.
-#define AWB_V_THRD_BIT			    16
-#define AWB_V_THRD_WID			    8
-//Bit 23:16, reg_isp_awb_v_thrd             threshold to abs(v-128) to decide adding to awb statistics. 0~255. default = 200.
-#define AWB_YPIECE_LOW_BIT		    8
-#define AWB_YPIECE_LOW_WID		    8
-//Bit 15: 8, reg_isp_awb_ypiece_low         low threshold of Y to decide adding to awb statistics to yluv_sum/num and ymuv_sum/num. 0~255. default = 50. 
-#define AWB_YPIECE_HIG_BIT		    0
-#define AWB_YPIECE_HIG_WID		    8
-//Bit  7: 0, reg_isp_awb_ypiece_hig         hig threshold of Y to decide adding to awb statistics to yhuv_sum/num and ymuv_sum/num. 0~255. default = 200. 
-
-#define ISP_AWB_AEC_ENABLE                  0x2d8c
-//Bit 31: 3, reserved
-//Bit     2, reg_isp_aec_raw_en             default = 1.
-#define AEC_RAW_EN_BIT			    2
-#define AEC_RAW_EN_WID			    1
-//Bit     1, reg_isp_aec_stat_en            default = 1.
-#define AEC_STAT_EN_BIT			    1
-#define AEC_STAT_EN_WID			    1
-//Bit     0, reg_isp_awb_stat_en            default = 1. 
-#define AWB_STAT_EN_BIT			    0
-#define AWB_STAT_EN_WID			    1
-
-// address 0x2d8c~ 0x2d8f null 
-/*************** auto exposure statistics registers******************/
-
-#define ISP_AEC_THRESHOLDS                  0x2d90 
-#define AEC_LUMA_LOWLMT_BIT		    24
-#define AEC_LUMA_LOWLMT_WID		    8
-//Bit 31:24, reg_isp_aec_luma_lowlmt        luma low limit when added to aec statistics in 4x4 regions. 0~255, default = 128
-#define AEC_RAWBRIGHT_R_BIT		    16
-#define AEC_RAWBRIGHT_R_WID		    8
-//Bit 23:16, reg_isp_aec_rawbright_r        red pixels considered as too bright threshold. 0~255, default = 200
-#define AEC_RAWBRIGHT_G_BIT		    8
-#define AEC_RAWBRIGHT_G_WID		    8
-//Bit 15: 8, reg_isp_aec_rawbright_g        green pixels considered as too bright threshold. 0~255, default = 200
-#define AEC_RAWBRIGHT_B_BIT		    0
-#define AEC_RAWBRIGHT_B_WID		    8
-//Bit  7: 0, reg_isp_aec_rawbright_b        blue pixels considered as too bright threshold. 0~255, default = 200
-
-#define ISP_AEC_WIND_XYSTART                0x2d91  
-//Bit 31:29, reserved
-#define AEC_WIND_XSTART_BIT		    16
-#define AEC_WIND_XSTART_WID		    13
-//Bit 28:16, reg_isp_aec_wind_xstart        window 0 left x index for AEC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved 
-#define AEC_WIND_YSTART_BIT		    0
-#define AEC_WIND_YSTART_WID		    13
-//Bit 12: 0, reg_isp_aec_wind_ystart        window 0 top y index for AEC statistics. 0~8191. default = 0.
-
-#define ISP_AEC_WIND_XYSTEP                 0x2d92  
-//Bit 31:29, reserved
-#define AEC_WIND_XSTEP_BIT		    16
-#define AEC_WIND_XSTEP_WID		    13
-//Bit 28:16, reg_isp_aec_wind_xstep         window 0 sub-window x lenght for AEC statistics. 0~8191. default = 64.
-//Bit 15:13, reserved
-#define AEC_WIND_YSTEP_BIT		    0
-#define AEC_WIND_YSTEP_WID		    13
-//Bit 12: 0, reg_isp_aec_wind_ystep         window 0 sub-window y lenght for AEC statistics. 0~8191. default = 64.
-
-#define ISP_AECRAW_WIND_LR                  0x2d93  
-//Bit 31:29, reserved
-#define AECRAW_WIND_LEFT_BIT		    16
-#define AECRAW_WIND_LEFT_WID		    13
-//Bit 28:16, reg_isp_aecraw_wind_left       window left x index for AEC raw statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AECRAW_WIND_RIGHT_BIT	            0
-#define AECRAW_WIND_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_aecraw_wind_right      window right x index for AEC raw statistics. 0~8191. default = 100.
-
-#define ISP_AECRAW_WIND_TB                  0x2d94                                     
-//Bit 31:29, reserved
-#define AECRAW_WIND_TOP_BIT		    16
-#define AECRAW_WIND_TOP_WID		    13
-//Bit 28:16, reg_isp_aecraw_wind_top        window top y index for AEC raw statistics. 0~8191. default = 0.
-//Bit 15:13, reserved                       
-#define AECRAW_WIND_BOT_BIT		    0
-#define AECRAW_WIND_BOT_WID		    13
-//Bit 12: 0, reg_isp_aecraw_wind_bot        window bot y index for AEC raw statistics. 0~8191. default = 100.
-
-// address 0x2d95~ 0x2d97 null 
-
-/*******************  auto focus statistics registers *********************/
-#define ISP_AFC_FILTER_SEL                  0x2d98  
-//Bit 31:17, reserved
-#define AFC_RO_UPDATE_BIT		    16
-#define AFC_RO_UPDATE_WID		    1
-//Bit    16, reg_isp_afc_ro_update          auto focus statistics read-only register update enable. 0: no update; 1: update in v blank time
-//Bit    15, reserved
-#define AFC_F0_SELECT_BIT		    12
-#define AFC_F0_SELECT_WID		    3
-//Bit 14:12, reg_isp_afc_f0_select          filter 0 selection mode. 0: [-2 2]; 1: [-1 0  1;-1 0 1; -1 0 1]; 2: [-1 0  1;-2 0 2; -1 0 1]; 3: [-1 0 0 0  1;-2 0 0 0 2; -1 0 0 0 1]; 4:[-1 2 -1;-1 2 -1;-1 2 -1]; 5/up:[-1 0 2 0 -1;-1 0 2 0 -1;-1 0 2 0 -1]; default= 2
-//Bit    11, reserved
-#define AFC_F1_SELECT_BIT		    8
-#define AFC_F1_SELECT_WID		    3
-//Bit 10: 8, reg_isp_afc_f1_select          filter 1 selection mode. 0: [-2 2]; 1: [-1 0  1;-1 0 1; -1 0 1]; 2: [-1 0  1;-2 0 2; -1 0 1]; 3: [-1 0 0 0  1;-2 0 0 0 2; -1 0 0 0 1]; 4:[-1 2 -1;-1 2 -1;-1 2 -1]; 5/up:[-1 0 2 0 -1;-1 0 2 0 -1;-1 0 2 0 -1]; default= 4
-#define AFC_F0_CORING_BIT		    4
-#define AFC_F0_CORING_WID		    4
-//Bit  7: 4, reg_isp_afc_f0_coring          coring to filter 0 filtering result before doing accum, to reduce noise interference. 0~15. default=2
-#define AFC_F1_CORING_BIT		    0
-#define AFC_F1_CORING_WID		    4
-//Bit  3: 0, reg_isp_afc_f1_coring          coring to filter 1 filtering result before doing accum, to reduce noise interference. 0~15. default=2
-
-#define ISP_AFC_WIND0_LR                    0x2d99  
-//Bit 31:29, reserved
-#define AFC_WIND0_LEFT_BIT		    16
-#define AFC_WIND0_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind0_left         window 0 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND0_RIGHT_BIT		    0
-#define AFC_WIND0_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind0_right        window 0 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND0_TB                    0x2d9a  
-//Bit 31:29, reserved
-#define AFC_WIND0_TOP_BIT		    16
-#define AFC_WIND0_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind0_top          window 0 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved    
-#define AFC_WIND0_BOT_BIT		    0
-#define AFC_WIND0_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind0_bot          window 0 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND1_LR                    0x2d9b  
-//Bit 31:29, reserved 
-#define AFC_WIND1_LEFT_BIT		    16
-#define AFC_WIND1_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind1_left         window 1 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND1_RIGHT_BIT		    0
-#define AFC_WIND1_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind1_righ         window 1 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND1_TB                    0x2d9c  
-//Bit 31:29, reserved
-#define AFC_WIND1_TOP_BIT		    16
-#define AFC_WIND1_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind1_top          window 1 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND1_BOT_BIT		    0
-#define AFC_WIND1_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind1_bot          window 1 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND2_LR                    0x2d9d  
-//Bit 31:29, reserved
-#define AFC_WIND2_LEFT_BIT		    16
-#define AFC_WIND2_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind2_left         window 2 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND2_RIGHT_BIT		    0
-#define AFC_WIND2_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind2_right        window 2 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND2_TB                    0x2d9e  
-//Bit 31:29, reserved
-#define AFC_WIND2_TOP_BIT		    16
-#define AFC_WIND2_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind2_top          window 2 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND2_BOT_BIT		    0
-#define AFC_WIND2_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind2_bot          window 2 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND3_LR                    0x2d9f  
-//Bit 31:29, reserved
-#define AFC_WIND3_LEFT_BIT		    16
-#define AFC_WIND3_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind3_left         window 3 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND3_RIGHT_BIT		    0
-#define AFC_WIND3_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind3_right        window 3 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND3_TB                    0x2da0  
-//Bit 31:29, reserved
-#define AFC_WIND3_TOP_BIT		    16
-#define AFC_WIND3_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind3_top          window 3 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND3_BOT_BIT		    0
-#define AFC_WIND3_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind3_bot          window 3 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND4_LR                    0x2da1  
-//Bit 31:29, reserved
-#define AFC_WIND4_LEFT_BIT		    16
-#define AFC_WIND4_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind4_left         window 4 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved                       
-#define AFC_WIND4_RIGHT_BIT		    0
-#define AFC_WIND4_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind4_righ         window 4 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND4_TB                    0x2da2  
-//Bit 31:29, reserved
-#define AFC_WIND4_TOP_BIT		    16
-#define AFC_WIND4_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind4_top          window 4 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND4_BOT_BIT		    0
-#define AFC_WIND4_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind4_bot          window 4 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND5_LR                    0x2da3  
-//Bit 31:29, reserved                       
-#define AFC_WIND5_LEFT_BIT		    16
-#define AFC_WIND5_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind5_left         window 5 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved                       
-#define AFC_WIND5_RIGHT_BIT		    0
-#define AFC_WIND5_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind5_righ         window 5 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND5_TB                    0x2da4  
-//Bit 31:29, reserved                       
-#define AFC_WIND5_TOP_BIT		    16
-#define AFC_WIND5_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind5_top          window 5 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND5_BOT_BIT		    0
-#define AFC_WIND5_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind5_bot          window 5 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND6_LR                    0x2da5  
-//Bit 31:29, reserved
-#define AFC_WIND6_LEFT_BIT		    16
-#define AFC_WIND6_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind6_left         window 6 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved                       
-#define AFC_WIND6_RIGHT_BIT		    0
-#define AFC_WIND6_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind6_righ         window 6 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND6_TB                    0x2da6  
-//Bit 31:29, reserved
-#define AFC_WIND6_TOP_BIT		    16
-#define AFC_WIND6_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind6_top          window 6 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND6_BOT_BIT		    0
-#define AFC_WIND6_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind6_bot          window 6 bot y index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND7_LR                    0x2da7  
-//Bit 31:29, reserved
-#define AFC_WIND7_LEFT_BIT		    16
-#define AFC_WIND7_LEFT_WID		    13
-//Bit 28:16, reg_isp_afc_wind7_left         window 7 left x index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved                       
-#define AFC_WIND7_RIGHT_BIT		    0
-#define AFC_WIND7_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind7_righ         window 7 right x index for AFC statistics. 0~8191. default = 100.
-
-#define ISP_AFC_WIND7_TB                    0x2da8  
-//Bit 31:29, reserved
-#define AFC_WIND7_TOP_BIT		    16
-#define AFC_WIND7_TOP_WID		    13
-//Bit 28:16, reg_isp_afc_wind7_top          window 7 top y index for AFC statistics. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define AFC_WIND7_BOT_BIT		    0
-#define AFC_WIND7_BOT_WID		    13
-//Bit 12: 0, reg_isp_afc_wind7_bot          window 7 bot y index for AFC statistics. 0~8191. default = 100.
-
-// address 0x2da9~ 0x2dab null 
-//  black level and noise level statistics registers
-#define ISP_BLNR_CTRL                       0x2dac  
-//Bit 31: 9, reserved
-#define BLNR_STATISTICS_EN_BIT		    8
-#define BLNR_STATISTICS_EN_WID		    1
-//Bit     8, reg_isp_blnr_statistics_en     enable for black level and noise level statistics on raw data. 0: no statistics; 1: enable. default =1
-//Bit  7: 6, reserved
-#define BLNR_LPF_MODE_BIT		    4
-#define BLNR_LPF_MODE_WID		    2
-//Bit  5: 4, reg_isp_blnr_lpf_mode          mode for lpf in black level and noise level statistics on raw data.0~3. 0: no lpf; 1: [1 2 1]/4 2/3: [1 2 2 2 1]/8; . default =3
-//Bit  3: 2, reserved 
-#define BLNR_AC_ADAPTIVE_BIT		    0
-#define BLNR_AC_ADAPTIVE_WID		    2
-//Bit  1: 0, reg_isp_blnr_ac_adaptive       mode for noise statistics in horizontal and vertical ac blending. 0~3. u2: 0: (H+V)/2; 1: sqrt(H^2 + V^2); 2: min(H,V); 3: max(H,V). default = 2
-
-#define ISP_BLNR_WIND_LR                    0x2dad  
-//Bit 31:29, reserved
-#define BLNR_WIND_LEFT_BIT		    16
-#define BLNR_WIND_LEFT_WID		    13
-//Bit 28:16, reg_isp_blnr_wind_left         window left x index for black level and noise level statistics on raw data. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define BLNR_WIND_RIGHT_BIT		    0
-#define BLNR_WIND_RIGHT_WID		    13
-//Bit 12: 0, reg_isp_blnr_wind_right         window right x index for black level and noise level statistics on raw data. 0~8191. default = 100.
-
-#define ISP_BLNR_WIND_TB                    0x2dae  
-//Bit 31:29, reserved
-#define BLNR_WIND_TOP_BIT		    16
-#define BLNR_WIND_TOP_WID		    13
-//Bit 28:16, reg_isp_blnr_wind_top          window top y index for black level and noise level statistics on raw data. 0~8191. default = 0.
-//Bit 15:13, reserved
-#define BLNR_WIND_BOT_BIT		    0
-#define BLNR_WIND_BOT_WID		    13
-//Bit 12: 0, reg_isp_blnr_wind_bot          window bot y index for black level and noise level statistics on raw data. 0~8191. default = 100.
-
-// address 0x2daf~ 0x2daf null                                    
-/*************** raw component statistics registers****************/
-#define ISP_DBG_PIXEL_CTRL                  0x2db0 
-//Bit 31: 2, reserved
-#define DBG_PIXEL_LPF_BIT		    0
-#define DBG_PIXEL_LPF_WID		    2
-//Bit  1: 0, reg_isp_dbg_pixel_lpf          low-pass filter mode for debug pixel position. 0~3. 0: no lpf; 1: [1 2 1]/4; 2: [1 2 1]'/4; 3: [0 1 0; 1 1 1;0 1 0]; default = 0
-
-#define ISP_DBG_PIXEL_POSITION              0x2db1  
-//Bit 31:29, reserved
-#define DBG_PIXEL_XPOS_BIT		    16
-#define DBG_PIXEL_XPOS_WID		    13
-//Bit 28:16, reg_isp_dbg_pixel_xpos         x index of pixel for debug on raw data. 0~8191. default = 100.
-//Bit 15:13, reserved
-#define DBG_PIXEL_YPOS_BIT		    0
-#define DBG_PIXEL_YPOS_WID		    13
-//Bit 12: 0, reg_isp_dbg_pixel_ypos         y index of pixel for debug on raw data. 0~8191. default = 1000.
-
-
-#define ISP_RO_DBG_PIXEL_GRBG0_1            0x2db2  
-//Bit 31:26, reserved
-#define DBG_PIXEL_GRBG_0_BIT		    16
-#define DBG_PIXEL_GRBG_0_WID		    10
-//Bit 25:16, ro_isp_dbg_pixel_grbg_0        phasDATA_PORTe 0 green component value of the debuged postion (x,y).
-//Bit 15:10, reserved
-#define DBG_PIXEL_GRBG_1_BIT		    0
-#define DBG_PIXEL_GRBG_1_WID		    10
-//Bit  9: 0, ro_isp_dbg_pixel_grbg_1        phase 1 red component value of the debuged postion (x,y).
-
-#define ISP_RO_DBG_PIXEL_GRBG2_3            0x2db3   
-//Bit 31:26, reserved
-#define DBG_PIXEL_GRBG_2_BIT		    16
-#define DBG_PIXEL_GRBG_2_WID		    10
-//Bit 25:16, ro_isp_dbg_pixel_grbg_2        phase 2 blue component value of the debuged postion (x,y).
-//Bit 15:10, reserved
-#define DBG_PIXEL_GRBG_3_BIT		    0
-#define DBG_PIXEL_GRBG_3_WID		    10
-//Bit  9: 0, ro_isp_dbg_pixel_grbg_3        phase 3 green component value of the debuged postion (x,y).
-
-// LUT1024/dft_LUT9x32
-
-#define ISP_RO_DFT_LUTMEM_CTRL              0x2d32  
-//Bit 31:11, reserved
-//Bit 10: 0, ro_isp_dft_lutpointer          pointer of the latest defect pixel position in LUT1024. will be accumulated in HW, but will be readout
-
-#define ISP_RO_DFT_DET_NUM                  0x2d3f  
-//Bit 31:28, reserved
-//Bit 27: 0, ro_isp_dftpixel_num            read-only register for detected defect pixels numbers of each frame. shadow locked version during v-blank.
-
-
-
-/******************* index + data **********************/
-
-// note there are some space in the header
-#define ISP_RO_ADDR_PORT                    0x2dc0
-#define ISP_RO_DATA_PORT                    0x2dc1
-
-//=================================awb readonly=======================================================
-
-#define ISP_RO_AWB_RED_SUM                  0x9b  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_red_sum             red accum statistics for awb.
-#define ISP_RO_AWB_GRN_SUM                  0x9c  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_grn_sum             green accum statistics for awb.
-#define ISP_RO_AWB_BLU_SUM                  0x9d  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_blu_sum             blue accum statistics for awb.
-#define ISP_RO_AWB_RGB_NUM                  0x9e  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-#define AWB_RGB_NUM_BIT                     0  //number of rgb pixels added to statistics for awb.
-#define AWB_RGB_NUM_WID                     24
-
-#define ISP_RO_AWB_LOW_UNEG_SUM             0x9f  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_low_uneg_sum        u (u<0) accum statistics for y<reg_isp_awb_ypiece_low awb.
-#define ISP_RO_AWB_LOW_VNEG_SUM             0xa0  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_low_vneg_sum        v (v<0) accum statistics for y<reg_isp_awb_ypiece_low awb.
-#define ISP_RO_AWB_LOW_UPOS_SUM             0xa1  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_low_upos_sum        u (u>=0) accum statistics for y>=reg_isp_awb_ypiece_high awb.
-#define ISP_RO_AWB_LOW_VPOS_SUM             0xa2  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_low_vpos_sum        v (v>=0) accum statistics for y>=reg_isp_awb_ypiece_high awb.
-
-#define ISP_RO_AWB_LOW_UNEG_NUM             0xa3  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_low_uneg_num        number of u (u<0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
-#define AWB_LOW_UNEG_NUM_BIT		    0
-#define AWB_LOW_UNEG_NUM_WID		    24
-
-#define ISP_RO_AWB_LOW_VNEG_NUM             0xa4  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_low_vneg_num        number of v (v<0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
-#define AWB_LOW_VNEG_NUM_BIT		    0
-#define AWB_LOW_VNEG_NUM_WID		    24
-
-#define ISP_RO_AWB_LOW_UPOS_NUM             0xa5  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_low_upos_num        number of u (u>=0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
-#define AWB_LOW_UPOS_NUM_BIT		    0
-#define AWB_LOW_UPOS_NUM_WID		    24
-
-#define ISP_RO_AWB_LOW_VPOS_NUM             0xa6  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_low_vpos_num        number of v (v>=0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
-#define AWB_LOW_VPOS_NUM_BIT		    0
-#define AWB_LOW_VPOS_NUM_WID		    24
-
-#define ISP_RO_AWB_MID_UNEG_SUM             0xa7  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_mid_uneg_sum        u (u<0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define ISP_RO_AWB_MID_VNEG_SUM             0xa8  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_mid_vneg_sum        v (v<0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define ISP_RO_AWB_MID_UPOS_SUM             0xa9  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_mid_upos_sum        u (u>=0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define ISP_RO_AWB_MID_VPOS_SUM             0xaa  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_mid_vpos_sum        v (v>=0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-
-#define ISP_RO_AWB_MID_UNEG_NUM             0xab  //read-only register, update each v-blank
-//Bit 31:24, reserved
-//Bit 23: 0, ro_isp_awb_mid_uneg_num        number of u (u<0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define AWB_MID_UNEG_NUM_BIT		    0
-#define AWB_MID_UNEG_NUM_WID		    24
-
-#define ISP_RO_AWB_MID_VNEG_NUM             0xac  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_mid_vneg_num        number of v (v<0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define AWB_MID_VNEG_NUM_BIT		    0
-#define AWB_MID_VNEG_NUM_WID		    24
-
-#define ISP_RO_AWB_MID_UPOS_NUM             0xad  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_mid_upos_num        number of u (u>=0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define AWB_MID_UPOS_NUM_BIT		    0
-#define AWB_MID_UPOS_NUM_WID		    24
-
-#define ISP_RO_AWB_MID_VPOS_NUM             0xae  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_mid_vpos_num        number of v (v>=0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
-#define AWB_MID_VPOS_NUM_BIT		    0
-#define AWB_MID_VPOS_NUM_WID		    24
-
-#define ISP_RO_AWB_HIG_UNEG_SUM             0xaf  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_hig_uneg_sum        u (u<0) accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define ISP_RO_AWB_HIG_VNEG_SUM             0xb0  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_hig_vneg_sum        v (v<0) accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define ISP_RO_AWB_HIG_UPOS_SUM             0xb1  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_hig_upos_sum        u (u>=0) accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define ISP_RO_AWB_HIG_VPOS_SUM             0xb2  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_awb_hig_vpos_sum        v (v>=0) accum statistics for y>reg_isp_awb_ypiece_hig awb.
-
-#define ISP_RO_AWB_HIG_UNEG_NUM             0xb3  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_hig_uneg_num        number of u (u<0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define AWB_HIG_UNEG_NUM_BIT		    0
-#define AWB_HIG_UNEG_NUM_WID		    24
-
-#define ISP_RO_AWB_HIG_VNEG_NUM             0xb4  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_hig_vneg_num        number of v (v<0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define AWB_HIG_VNEG_NUM_BIT		    0
-#define AWB_HIG_VNEG_NUM_WID		    24
-
-#define ISP_RO_AWB_HIG_UPOS_NUM             0xb5  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_hig_upos_num        number of u (u>=0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define AWB_HIG_UPOS_NUM_BIT		    0
-#define AWB_HIG_UPOS_NUM_WID		    24
-
-#define ISP_RO_AWB_HIG_VPOS_NUM             0xb6  //read-only register, update each v-blank
-//Bit 31:24, reserved                       
-//Bit 23: 0, ro_isp_awb_hig_vpos_num        number of v (v>=0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
-#define AWB_HIG_VPOS_NUM_BIT		    0
-#define AWB_HIG_VPOS_NUM_WID		    24
-
-//======================================aec readonly ==========================================================
-#define ISP_RO_AEC_LUMA_WIND0_0             0x8b  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma0_0             window 00 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND0_1             0x8c  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma0_1             window 01 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND0_2             0x8d  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma0_2             window 02 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND0_3             0x8e  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma0_3             window 03 luma accum statistics
-
-#define ISP_RO_AEC_LUMA_WIND1_0             0x8f  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma1_0             window 10 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND1_1             0x90  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma1_1             window 11 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND1_2             0x91  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma1_2             window 12 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND1_3             0x92  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma1_3             window 13 luma accum statistics 
-
-#define ISP_RO_AEC_LUMA_WIND2_0             0x93  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma2_0             window 20 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND2_1             0x94  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma2_1             window 21 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND2_2             0x95  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma2_2             window 22 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND2_3             0x96  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma2_3             window 23 luma accum statistics 
-
-#define ISP_RO_AEC_LUMA_WIND3_0             0x97  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma3_0             window 30 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND3_1             0x98  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma3_1             window 31 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND3_2             0x99  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma3_2             window 32 luma accum statistics 
-#define ISP_RO_AEC_LUMA_WIND3_3             0x9a  //read-only register, update each v-blank
-//Bit 31: 0, ro_isp_aec_luma3_3             window 33 luma accum statistics 
-
-#define ISP_RO_AECRAW_NUM_RED               0x80  //read-only register, update each v-blank
-//Bit 31:26, reserved                       
-//Bit 25: 0, ro_isp_aecraw_num_r            red bright pixels numbers in raw window    
-#define AECRAW_NUM_RED_BIT                  0
-#define AECRAW_NUM_RED_WID                  26
-
-#define ISP_RO_AECRAW_NUM_GREEN             0x81  //read-only register, update each v-blank
-//Bit 31:26, reserved                       
-//Bit 25: 0, ro_isp_aecraw_num_g            green bright pixels numbers in raw window
-#define AECRAW_NUM_GREEN_BIT                0
-#define AECRAW_NUM_GREEN_WID                26
-
-#define ISP_RO_AECRAW_NUM_BLUE              0x82  //read-only register, update each v-blank
-//Bit 31:26, reserved                       
-//Bit 25: 0, ro_isp_aecraw_num_b            blue bright pixels numbers in raw window   
-#define AECRAW_NUM_BLUE_BIT                 0
-#define AECRAW_NUM_BLUE_WID                 26
-//===================================afc readonly====================================================
-
-#define ISP_RO_AFC_WIND0_F0                 0xb7  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind0_f0            f0 accum within window 0. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND0_F1                 0xb8  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind0_f1            f1 accum within window 0. the larger the better focus lock. 
-
-#define ISP_RO_AFC_WIND1_F0                 0xb9  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind1_f0            f0 accum within window 1. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND1_F1                 0xba  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind1_f1            f1 accum within window 1. the larger the better focus lock.
-
-#define ISP_RO_AFC_WIND2_F0                 0xbb  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind2_f0            f0 accum within window 2. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND2_F1                 0xbc  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind2_f1            f1 accum within window 2. the larger the better focus lock. 
-
-#define ISP_RO_AFC_WIND3_F0                 0xbd  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind3_f0            f0 accum within window 3. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND3_F1                 0xbe  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind3_f1            f1 accum within window 3. the larger the better focus lock. 
-
-#define ISP_RO_AFC_WIND4_F0                 0xbf  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind4_f0            f0 accum within window 4. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND4_F1                 0xc0  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind4_f1            f1 accum within window 4. the larger the better focus lock. 
-
-#define ISP_RO_AFC_WIND5_F0                 0xc1  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind5_f0            f0 accum within window 5. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND5_F1                 0xc2  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind5_f1            f1 accum within window 5. the larger the better focus lock. 
-
-#define ISP_RO_AFC_WIND6_F0                 0xc3  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind6_f0            f0 accum within window 6. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND6_F1                 0xc4  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind6_f1            f1 accum within window 6. the larger the better focus lock. 
-
-#define ISP_RO_AFC_WIND7_F0                 0xc5  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_afc_wind7_f0            f0 accum within window 7. the larger the better focus lock. 
-#define ISP_RO_AFC_WIND7_F1                 0xc6  // read-only register, update each v-blank
-//Bit 31: 0, ro_isp_afc_wind7_f1            f1 accum within window 7. the larger the better focus lock. 
-
-//=================================blnr readonly=====================================================
-
-#define ISP_RO_BLNR_GRBG_DCSUM0             0x83  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_dcsum0        phase 0 green chanel DC sum within stattistic window for black level statistics. 
-#define ISP_RO_BLNR_GRBG_DCSUM1             0x84  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_dcsum1        phase 1 red chanel DC sum within stattistic window for black level statistics. 
-#define ISP_RO_BLNR_GRBG_DCSUM2             0x85  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_dcsum2        phase 2 blue chanel DC sum within stattistic window for black level statistics. 
-#define ISP_RO_BLNR_GRBG_DCSUM3             0x86  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_dcsum3        phase 2 green chanel DC sum within stattistic window for black level statistics.
-
-#define ISP_RO_BLNR_GRBG_ACSUM0             0x87  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_acsum0        phase 0 green chanel AC sum within stattistic window for noise level statistics. 
-#define ISP_RO_BLNR_GRBG_ACSUM1             0x88  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_acsum1        phase 1 red chanel AC sum within stattistic window for noise level statistics. 
-#define ISP_RO_BLNR_GRBG_ACSUM2             0x89  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_acsum2        phase 2 blue chanel AC sum within stattistic window for noise level statistics. 
-#define ISP_RO_BLNR_GRBG_ACSUM3             0x8a  // read-only register, update each v-blank 
-//Bit 31: 0, ro_isp_blnr_grbg_acsum3        phase 2 green chanel AC sum within stattistic window for noise level statistics. 
-
-#define ISP_GAMMA_LUT_ADDR                  0x2dc2
-#define ISP_GAMMA_LUT_DATA                  0x2dc3  
-#define ISP_DF1024_LUT_ADDR                 0x2dc4 
-#define ISP_DF1024_LUT_DATA                 0x2dc5  
-#define ISP_LNSD_LUT_ADDR                   0x2dc6
-#define ISP_LNSD_LUT_DATA                   0x2dc7 
-
-#endif  // __ISP_REGS_H
-
diff --git a/drivers/amlogic/tvin/isp/isp_sm.c b/drivers/amlogic/tvin/isp/isp_sm.c
deleted file mode 100755
index 55a9e4ed940e..000000000000
--- a/drivers/amlogic/tvin/isp/isp_sm.c
+++ /dev/null
@@ -1,1557 +0,0 @@
-/*
-* ISP 3A State Machine
-*
-* Author: Kele Bai <kele.bai@amlogic.com>
-*
-* Copyright (C) 2010 Amlogic Inc.
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*/
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-
-#include "isp_drv.h"
-#include "isp_hw.h"
-#include "isp_sm.h"
-
-#define DEVICE_NAME "isp"
-
-static struct isp_sm_s sm_state;
-static unsigned int capture_debug = 0;
-
-#define AE_ORI_SET_DG			0x00000001
-#define AE_SHUTTER_ADJUST_DG		0x00000002
-#define AE_GAIN_ADJUST_SEL		0x00000004
-#define AE_CALCULATE_LUMA_AVG_DG	0x00000008
-#define AE_CALCULATE_LUMA_TARG_DG	0x00000010
-#define AE_LUMA_AVG_CHECK_DG		0x00000020
-#define AE_EXPOSURE_ADJUST_DG		0x00000040
-#define AE_STATUS_DG			0x00000080
-#define AE_DYNAMIC_ADJUST_DG    0x00000100
-
-static unsigned int ae_sm_dg = 0;
-module_param(ae_sm_dg,uint,0664);
-MODULE_PARM_DESC(ae_sm_dg,"\n debug flag for ae.\n");
-
-static unsigned int ae_step = 1;
-
-module_param(ae_step,uint,0664);
-MODULE_PARM_DESC(ae_step,"\n debug flag for ae.\n");
-
-#define AWB_RGB_BLEND_DG		0x00000001
-#define AWB_TEMP_CHECK_DG		0x00000002
-#define AWB_TEMP_ADJUST_DG		0x00000004
-#define AWB_GAIN_SET_DG			0x00000008
-#define AWB_RGB_COUNT_CHECK_DG		0x00000010
-
-static unsigned int awb_sm_dg = AWB_GAIN_SET_DG;
-module_param(awb_sm_dg,uint,0664);
-MODULE_PARM_DESC(awb_sm_dg,"\n debug flag for awb.\n");
-
-static unsigned int exposure_extra = 1024;
-module_param(exposure_extra,uint,0664);
-MODULE_PARM_DESC(exposure_extra,"\n debug exposure for ae.\n");
-
-
-#define P1DB 1149
-#define N1DB  913
-#define P2DB 1289
-#define N2DB  813
-
-#define AF_DETECT			0x00000001
-#define AF_FINE_TUNE			0x00000002
-#define AF_BEST_STEP			0x00000004
-static unsigned int af_sm_dg = 0;
-
-volatile struct isp_ae_to_sensor_s ae_sens;
-
-
-static inline int find_step(cam_function_t *func, unsigned int low, unsigned int hign, unsigned int gain)
-{
-	unsigned int mid = 0;
-	unsigned int rate = 0;
-	unsigned int ret = 0;
-	while(hign >= low)
-	{
-		mid = (hign + low)/2;
-		if(func&&func->get_aet_gain_by_step)
-			rate = func->get_aet_gain_by_step(func->priv_data,mid);
-		if(0)
-			printk("mid = %d,rate = %d, gain = %d,%d,%d,%d,%d\n",mid,rate,gain,hign,low,func,func->get_aet_gain_by_step);
-		if(gain < rate)
-			hign = mid - 1;
-		else if(gain > rate)
-			low = mid + 1;
-		else {
-		    //pr_info("[isp] %s step:%d found ...................\n", __func__, mid);
-			return mid;
-		}
-	}
-	//pr_info("[isp] %s step:%d set default .\n", __func__, (mid + 1));
-	if((mid + 1) > hign){
-		//pr_info("[isp]find_step,warning mid:%d,hign:%d\n",mid,hign);
-		return hign;
-	}
-	return (mid + 1);
-}
-
-static unsigned int aet_gain_pre = 0, format_gain_pre = 0;
-
-static unsigned int isp_ae_cal_new_para(isp_dev_t *devp)
-{
-    struct isp_ae_sm_s *aepa = &sm_state.isp_ae_parm;
-    struct cam_function_s *func = &devp->cam_param->cam_function;
-    unsigned int aet_gain_new = 0, format_gain_new = 0;
-
-    aepa->max_step = func->get_aet_max_step(func->priv_data);
-    format_gain_new = devp->isp_ae_parm->aet_fmt_gain;
-    aet_gain_new = ((aet_gain_pre * format_gain_pre) / format_gain_new);
-    if (aet_gain_new == 0) {
-        pr_info("[isp] %s: cal ae error, aet_gain_pre:%d, format_gain_pre:%d ... ...\n", __func__, \
-                aet_gain_pre, format_gain_pre);
-        return 0;
-    }
-    ae_sens.new_step = find_step(func, 0, aepa->max_step, aet_gain_new);
-    ae_sens.shutter = 1;
-    ae_sens.gain = 1;
-    pr_info("[isp] %s: format_gain_new:%d, aet_gain_new:%d new_step:%d... ...\n", __func__, \
-            format_gain_new, aet_gain_new, ae_sens.new_step);
-
-    if (func && func->set_aet_new_step) {
-        func->set_aet_new_step(func->priv_data,ae_sens.new_step, ae_sens.shutter, ae_sens.gain);
-        pr_info("[isp] %s: write new step to sensor... ...\n", __func__);
-    }
-
-    return 0;
-}
-
-static struct isp_awb_gain_s awb_gain, awb_gain_pre;
-
-unsigned int isp_awb_load_pre_para(isp_dev_t *devp)
-{
-    if ((awb_gain_pre.r_val == 0) &&
-        (awb_gain_pre.r_val == 0) &&
-        (awb_gain_pre.r_val == 0)) {
-        pr_info("[isp] %s cal awb error, r:%d g:%d b:%d ... ...\n",
-                    __func__, awb_gain.r_val, awb_gain.g_val,awb_gain.b_val);
-        return 0;
-    }
-    memcpy(&awb_gain, &awb_gain_pre, sizeof(struct isp_awb_gain_s));
-    isp_awb_set_gain(awb_gain.r_val, awb_gain.g_val,awb_gain.b_val);
-    pr_info("[isp] %s r:%d g:%d b:%d ... ...\n",
-                __func__, awb_gain.r_val, awb_gain.g_val,awb_gain.b_val);
-
-    return 0;
-}
-void isp_sm_init(isp_dev_t *devp)
-{
-	sm_state.isp_ae_parm.tf_ratio = devp->wave->torch_flash_ratio;
-	sm_state.status = ISP_AE_STATUS_NULL;
-	sm_state.flash = ISP_FLASH_STATUS_NULL;
-	sm_state.isp_ae_parm.isp_ae_state = AE_INIT;
-	sm_state.isp_awb_parm.isp_awb_state = AWB_INIT;
-	sm_state.env = ENV_NULL;
-	sm_state.ae_down = true;
-	/*init for af*/
-	sm_state.cap_sm.fr_time = devp->wave->flash_rising_time;
-	sm_state.cap_sm.tr_time = devp->wave->torch_rising_time;
-	/*init for wave*/
-	sm_state.flash = ISP_FLASH_STATUS_NULL;
-    isp_ae_cal_new_para(devp);     // cal and set new ae value
-    isp_awb_load_pre_para(devp);  // cal and set new awb value
-}
-
-void isp_set_manual_exposure(isp_dev_t *devp)
-{
-	struct xml_algorithm_ae_s *aep = devp->isp_ae_parm;
-	struct isp_ae_sm_s *aepa = &sm_state.isp_ae_parm;
-	int i;
-	int manual_target;
-	if((aepa->targ > aep->targethigh)||(aepa->targ < aep->targetlow))
-	{
-		return;
-	}
-	printk("devp->ae_info.manul_level=%d\n",devp->ae_info.manul_level);
-	i = devp->ae_info.manul_level;
-	manual_target = aep->targetmid;
-	if(i > 0)
-	{
-		for(;i>0;i--)
-		{
-			manual_target = (manual_target*P1DB+512) >> 10;
-		}
-	}
-	else if(i < 0)
-	{
-		for(;i<0;i++)
-		{
-			manual_target = (manual_target*N1DB+512) >> 10;
-		}
-	}
-	aepa->targ = manual_target;
-    if(aepa->targ > aep->targethigh)
-		aepa->targ = aep->targethigh;
-    if(aepa->targ < aep->targetlow)
-		aepa->targ = aep->targetlow;
-}
-
-void af_sm_init(isp_dev_t *devp)
-{
-	struct isp_af_info_s *af_info = &devp->af_info;
-	struct cam_function_s *func = &devp->cam_param->cam_function;
-	/*init for af*/
-	if(devp->flag & ISP_AF_SM_MASK){
-    	        sm_state.af_state = AF_SCAN_INIT;
-	}
-	if(devp->flag & ISP_FLAG_CAPTURE){
-		af_info->cur_step = af_info->capture_step;
-		func->set_af_new_step(func->priv_data,devp->af_info.cur_step);
-	}
-}
-void isp_ae_low_gain()
-{
-	sm_state.isp_ae_parm.isp_ae_state = AE_LOW_GAIN;
-}
-
-int isp_ae_save_current_para(isp_dev_t *devp)
-{
-    struct cam_function_s *func = &devp->cam_param->cam_function;
-    struct isp_ae_sm_s *aepa = &sm_state.isp_ae_parm;
-    aepa->max_step = func->get_aet_max_step(func->priv_data);
-
-    if (func && func->get_aet_gain_by_step)
-        aet_gain_pre = func->get_aet_gain_by_step(func->priv_data,ae_sens.new_step);
-    format_gain_pre = devp->isp_ae_parm->aet_fmt_gain;
-    pr_info("[isp] %s format_gain_pre:%d aet_gain_pre:%d ... ...\n",
-                __func__, format_gain_pre, aet_gain_pre);
-
-    return 0;
-}
-
-unsigned int isp_tune_exposure(isp_dev_t *devp)
-{
-    struct isp_ae_sm_s *aepa = &sm_state.isp_ae_parm;
-    struct cam_function_s *func = &devp->cam_param->cam_function;
-    unsigned int new_step = 0;
-	unsigned int gain_cur = 0;
-	unsigned int gain_target = 0;
-	if(func&&func->get_aet_current_gain)
-	gain_cur = func->get_aet_current_gain(func->priv_data);
-	gain_target = (gain_cur*exposure_extra + 512) >> 10;
-	new_step = find_step(func, 0, aepa->max_step, gain_target);
-	return new_step;
-}
-void isp_ae_sm(isp_dev_t *devp)
-{
-	struct isp_ae_stat_s *ae = &devp->isp_ae;
-	struct xml_algorithm_ae_s *aep = devp->isp_ae_parm;
-	struct isp_info_s *parm = &devp->info;
-	struct isp_ae_sm_s *aepa = &sm_state.isp_ae_parm;
-	struct cam_function_s *func = &devp->cam_param->cam_function;
-	struct vframe_prop_s *ph = devp->frontend.private_data;
-	struct isp_ae_info_s *ae_info = &devp->ae_info;
-	u8  sub_avg[16] = {0};
-	unsigned int avg_sum = 0;
-	unsigned int avg_env_sum = 0;
-	unsigned int avg_env;
-	unsigned int avg_envo;
-	int avg, avgo;
-	static short temp;
-	int i;
-	static int k = 0;
-	static int h = 0;
-	static int sum = 0;
-	int step = 0;
-	unsigned int targrate;
-	unsigned int targstep;
-	static unsigned int newstep;
-	u8 lpfcoef;
-	u8 radium_outer;
-	u8 radium_inner;
-
-    	switch(sm_state.isp_ae_parm.isp_ae_state){
-		case AE_IDLE:
-			break;
-		case AE_INIT:
-			k = 0;
-			h = 0;
-			aepa->win_l = (parm->h_active * aep->ratio_winl) >> 10;
-			aepa->win_r = ((parm->h_active * aep->ratio_winr) >> 10) - 1;
-			aepa->win_t = (parm->v_active * aep->ratio_wint) >> 10;
-			aepa->win_b = ((parm->v_active * aep->ratio_winb) >> 10) - 1;
-			isp_set_ae_win(aepa->win_l, aepa->win_r, aepa->win_t, aepa->win_b);
-			isp_set_ae_thrlpf(aep->thr_r_mid, aep->thr_g_mid, aep->thr_b_mid, aep->lpftype_mid);
-			aepa->pixel_sum = parm->h_active * parm->v_active;
-			aepa->sub_pixel_sum = aepa->pixel_sum >> 4;
-			aepa->max_lumasum1 = ((aepa->pixel_sum >> 4) * aep->ae_ratio_low) >> 7;
-			aepa->max_lumasum2 = ((aepa->pixel_sum >> 4) * aep->ae_ratio_low2mid) >> 7;
-			aepa->max_lumasum3 = ((aepa->pixel_sum >> 4) * aep->ae_ratio_mid2high) >> 7;
-			aepa->max_lumasum4 = ((aepa->pixel_sum >> 4) * aep->ae_ratio_high) >> 7;
-			aepa->pre_gain = 400;
-			if(devp->ae_info.manul_level==0)
-			aepa->targ = aep->targetmid;
-			temp = 1;
-			aepa->alert_r = ((aepa->pixel_sum >> 4) * aep->ratio_r) >> 8;
-			aepa->alert_g = ((aepa->pixel_sum >> 4) * aep->ratio_g) >> 7;	 //grgb
-			aepa->alert_b = ((aepa->pixel_sum >> 4) * aep->ratio_b) >> 8;
-			aepa->change_step = 0;
-			if(func&&func->get_aet_max_gain)
-				aepa->max_gain = func->get_aet_max_gain(func->priv_data);
-			if(func&&func->get_aet_min_gain)
-				aepa->min_gain = func->get_aet_min_gain(func->priv_data);
-			if(func&&func->get_aet_max_step)
-				aepa->max_step = func->get_aet_max_step(func->priv_data);
-			pr_info("ae,win_l=%d,win_r=%d,win_t=%d,win_b=%d\n",aepa->win_l,aepa->win_r,aepa->win_t,aepa->win_b);
-			pr_info("aepa->max_lumasum1=%d,max_lumasum2=%d,=%d,=%d",aepa->max_lumasum1,aepa->max_lumasum2,aepa->max_lumasum3,aepa->max_lumasum4);
-			pr_info("aepa->alert_r=%d,g=%d,b=%d\n",aepa->alert_r,aepa->alert_g,aepa->alert_b);
-			pr_info("aepa->sub_pixel_sum=%d\n",aepa->sub_pixel_sum);
-			pr_info("aepa->max_gain=%d\n",aepa->max_gain);
-			pr_info("aepa->min_gain=%d\n",aepa->min_gain);
-			pr_info("aepa->max_step=%d\n",aepa->max_step);
-			sm_state.isp_ae_parm.isp_ae_state = AE_SHUTTER_ADJUST;
-			break;
-		case AE_ORI_SET:
-			newstep = find_step(func,0,aepa->max_step,aepa->pre_gain);
-			if(aep->ae_skip[0] == 0x1){
-				if(atomic_read(&ae_info->writeable) <= 0){
-					ae_sens.new_step = newstep;
-					ae_sens.shutter = 0;
-					ae_sens.gain = 1;
-					atomic_set(&ae_info->writeable,1);
-					sm_state.status = ISP_AE_STATUS_UNSTABLE;
-					if(ae_sm_dg&AE_ORI_SET_DG)
-						pr_info("ISP_AE_STATUS_UNSTABLE1\n");
-					sm_state.ae_down = false;
-				}
-				sm_state.isp_ae_parm.isp_ae_state = AE_SHUTTER_ADJUST;
-			}
-			else if(aep->ae_skip[1] == 0x1){
-				ae_sens.new_step = newstep;
-				ae_sens.shutter = 1;
-				ae_sens.gain = 1;
-				atomic_set(&ae_info->writeable,1);
-				sm_state.status = ISP_AE_STATUS_UNSTABLE;
-				if(ae_sm_dg&AE_ORI_SET_DG)
-					pr_info("ISP_AE_STATUS_UNSTABLE\n");
-				sm_state.ae_down = false;
-				sm_state.isp_ae_parm.isp_ae_state = AE_REST;
-			}
-			else{
-				ae_sens.new_step = newstep;
-				ae_sens.shutter = 1;
-				ae_sens.gain = 0;
-				atomic_set(&ae_info->writeable,1);
-				sm_state.status = ISP_AE_STATUS_UNSTABLE;
-				if(ae_sm_dg&AE_ORI_SET_DG)
-					pr_info("ISP_AE_STATUS_UNSTABLE\n");
-				sm_state.ae_down = false;
-				sm_state.isp_ae_parm.isp_ae_state = AE_GAIN_ADJUST;//AE_REST;
-			}
-			break;
-		case AE_LOW_GAIN:
-			aepa->cur_gain = func->get_aet_current_gain(func->priv_data);
-			targrate = (aepa->cur_gain << 10)/aepa->tf_ratio;
-			newstep = find_step(func,0,aepa->max_step,targrate);
-			if(aep->ae_skip[1] == 0x1){
-				ae_sens.new_step = newstep;
-				ae_sens.shutter = 1;
-				ae_sens.gain = 1;
-				atomic_set(&ae_info->writeable,1);
-				sm_state.ae_down = false;
-				sm_state.isp_ae_parm.isp_ae_state = AE_REST;
-			}
-			else{
-				ae_sens.new_step = newstep;
-				ae_sens.shutter = 1;
-				ae_sens.gain = 0;
-				atomic_set(&ae_info->writeable,1);
-				sm_state.ae_down = false;
-				sm_state.isp_ae_parm.isp_ae_state = AE_GAIN_ADJUST;
-			}
-			break;
-		case AE_SHUTTER_ADJUST:
-			if(func&&func->get_aet_current_gain)
-				aepa->cur_gain = func->get_aet_current_gain(func->priv_data);
-			aepa->pre_gain = aepa->cur_gain;
-			if(func&&func->get_aet_current_gain)
-				aepa->cur_step = func->get_aet_current_step(func->priv_data);
-			if(ae_sm_dg&AE_SHUTTER_ADJUST_DG)
-				pr_info("cur_gain = %d,cur_step = %d\n",aepa->cur_gain,aepa->cur_step);
-			if(aepa->cur_gain == 0)
-				break;
-			while(step != AE_SUCCESS){
-				switch(step){
-					case AE_START:
-						step = AE_CALCULATE_LUMA_AVG;
-						break;
-					case AE_CALCULATE_LUMA_AVG:
-						for(i=0;i<16;i++){
-							sub_avg[i] = ae->luma_win[i]/aepa->sub_pixel_sum;
-						    	avg_sum += sub_avg[i] * aep->coef_cur[i];
-							avg_env_sum += sub_avg[i] * aep->coef_env[i];
-							if((i == ae_step)&&(ae_sm_dg&AE_CALCULATE_LUMA_AVG_DG))
-								pr_info("sub_avg[%d]=%d,ae->luma_win=%d,aep->coef_cur=%d,aep->coef_env=%d,avg_env_sum=%d,avg_sum=%d \n",i,sub_avg[i],ae->luma_win[i],aep->coef_cur[i],aep->coef_env[i],avg_env_sum,avg_sum);
-						}
-						avg = avg_sum >> 10;
-						if(devp->flag & ISP_FLAG_CAPTURE){
-							avgo = avg/aepa->cur_gain;
-							if(avgo < aep->flash_thr)
-								sm_state.flash = ISP_FLASH_STATUS_ON;
-							else
-								sm_state.flash = ISP_FLASH_STATUS_OFF;
-						}
-						avg_env = avg_env_sum >> 10;
-						step = AE_CALCULATE_LUMA_TARG;
-						break;
-					case AE_CALCULATE_LUMA_TARG:
-						if(aepa->cur_gain == 0)
-							printk("[AE_CALCULATE_LUMA_TARG]:error,aepa->cur_gain = 0\n");
-						avg_envo = (avg_env << 10)/aepa->cur_gain;
-						sum = (ph->hist.gamma[58]+ph->hist.gamma[57]) << ph->hist.hist_pow;
-						if(ae_sm_dg&AE_CALCULATE_LUMA_TARG_DG){
-							pr_info("avg=%d,avg_envo=%d,aepa->cur_gain=%d,avg_env=%d,avg_env_sum=%d,avg_sum=%d,luma_win[9]=%d,sub[9]=%d\n",avg,avg_envo,aepa->cur_gain,avg_env,avg_env_sum,avg_sum,ae->luma_win[9],sub_avg[9]);
-							pr_info("ph->hist.gamma[58]=%d,%d,%d\n",ph->hist.gamma[58],sum,ph->hist.hist_pow);
-						}
-						if((devp->ae_info.manul_level==0)&&((ae_sm_dg&AE_DYNAMIC_ADJUST_DG)==0)){//(avg_envo <= aep->env_low)||((avg_envo <= aep->env_low2mid)&&targ == (aep->targetlow)))
-							//targ = aep->targetlow;
-							if((sum > aepa->max_lumasum4)||((sum > aepa->max_lumasum3)&&(temp==2))){
-								temp = 2;
-								aepa->targ-=2;
-								if(aepa->targ<(aep->targetmid-aep->ae_min_diff))
-									aepa->targ = aep->targetmid-aep->ae_min_diff;
-							}
-							else if((sum < aepa->max_lumasum1)||((sum < aepa->max_lumasum2)&&(temp==0))){
-								temp = 0;
-								aepa->targ++;
-								if(aepa->targ>(aep->targetmid+aep->ae_max_diff))
-									aepa->targ = aep->targetmid+aep->ae_max_diff;
-							}
-							else{
-								temp = 1;
-							}
-						}
-						radium_inner = aep->radium_inner_l;
-						radium_outer = aep->radium_outer_l;
-						sm_state.env = ENV_LOW;
-						isp_set_ae_thrlpf(aep->thr_r_low, aep->thr_g_low, aep->thr_b_low, aep->lpftype_low);
-						/*
-						else if((avg_envo >= aep->env_hign)||((avg_envo >= aep->env_hign2mid)&&targ == (aep->targethigh)))
-						{
-							targ = aep->targethigh;
-							radium_inner = aep->radium_inner_h;
-							radium_outer = aep->radium_outer_h;
-							sm_state.env = ENV_HIGH;
-							isp_set_ae_thrlpf(aep->thr_r_high, aep->thr_g_high, aep->thr_b_high, aep->lpftype_high);
-						}
-						else
-						{
-							targ = aep->targetmid;
-							radium_inner = aep->radium_inner_m;
-							radium_outer = aep->radium_outer_m;
-							sm_state.env = ENV_MID;
-							isp_set_ae_thrlpf(aep->thr_r_mid, aep->thr_g_mid, aep->thr_b_mid, aep->lpftype_mid);
-						}*/
-						if(ae_sm_dg&AE_CALCULATE_LUMA_TARG_DG)
-							pr_info("targ=%d,temp=%d\n",aepa->targ,temp);
-						step = AE_LUMA_AVG_CHECK;
-						break;
-					case AE_LUMA_AVG_CHECK:
-						if(ae_sm_dg&AE_LUMA_AVG_CHECK_DG)
-							pr_info("avg=%d,targ=%d,radium_inner=%d,radium_outer=%d\n",avg,aepa->targ,radium_inner,radium_outer);
-						if(((sm_state.status == ISP_AE_STATUS_UNSTABLE)&&(((avg - aepa->targ) > radium_inner)||((aepa->targ - avg) > radium_inner)))
-							||(((avg - aepa->targ) > radium_outer)||((aepa->targ - avg) > radium_outer))
-							){
-							step = AE_EXPOSURE_ADJUST;
-						}
-						else{
-							if(ae_sm_dg&AE_STATUS_DG)
-								pr_info("ISP_AE_STATUS_STABLE\n");
-							sm_state.status = ISP_AE_STATUS_STABLE;
-							step = AE_SUCCESS;
-							//if(func->check_mains_freq)
-								//sm_state.isp_ae_parm.isp_ae_state = AE_ORI_SET;
-							//else
-								sm_state.isp_ae_parm.isp_ae_state = AE_SHUTTER_ADJUST;
-						}
-						break;
-					case AE_EXPOSURE_ADJUST:
-						if(avg == 0){
-							step = AE_SUCCESS;
-							break;
-						}
-						targrate = (aepa->targ * aepa->cur_gain)/avg;
-						if(ae_sm_dg&AE_EXPOSURE_ADJUST_DG)
-							pr_info("targrate = %d\n",targrate);
-						if(targrate > aepa->max_gain)
-							targrate = aepa->max_gain;
-						if(targrate < aepa->min_gain)
-							targrate = aepa->min_gain;
-						targstep = find_step(func,0,aepa->max_step,targrate);
-						if(targstep > aepa->max_step)
-							targstep = aepa->max_step;
-						if(ae_sm_dg&AE_EXPOSURE_ADJUST_DG)
-							pr_info("targstep = %d,%d\n",targstep,targrate);
-						lpfcoef = (devp->flag & ISP_FLAG_CAPTURE)?aep->fast_lpfcoef:aep->slow_lpfcoef;
-						newstep = (aepa->cur_step*lpfcoef + targstep*(256-lpfcoef))>>8;
-						if(ae_sm_dg&AE_EXPOSURE_ADJUST_DG)
-							pr_info("newstep =%d,lpf =%d,%d\n",newstep,lpfcoef,aepa->cur_step);
-						if((newstep >= aepa->max_step - 1)||(newstep == aepa->cur_step)||(newstep == 0)){
-							sm_state.status = ISP_AE_STATUS_STABLE;
-							if(ae_sm_dg&AE_STATUS_DG)
-								pr_info("ISP_AE_STATUS_STABLE2\n");
-							step = AE_SUCCESS;
-						}
-						else
-							step = AE_SET_NEWSTEP;
-						break;
-					case AE_SET_NEWSTEP:
-						if(aep->ae_skip[0] == 0x1){
-							if(atomic_read(&ae_info->writeable) <= 0){
-								ae_sens.new_step = newstep;
-								ae_sens.shutter = 0;
-								ae_sens.gain = 1;
-								atomic_set(&ae_info->writeable,1);
-								sm_state.status = ISP_AE_STATUS_UNSTABLE;
-								if(ae_sm_dg&AE_STATUS_DG)
-									pr_info("ISP_AE_STATUS_UNSTABLE1\n");
-								sm_state.ae_down = false;
-							}
-							if(ae_sm_dg&AE_GAIN_ADJUST_SEL)
-								sm_state.isp_ae_parm.isp_ae_state = AE_GAIN_ADJUST;
-							else
-								sm_state.isp_ae_parm.isp_ae_state = AE_SHUTTER_ADJUST;
-							step = AE_SUCCESS;
-						}
-						else if(aep->ae_skip[1] == 0x1){
-							ae_sens.new_step = newstep;
-							ae_sens.shutter = 1;
-							ae_sens.gain = 1;
-							atomic_set(&ae_info->writeable,1);
-							sm_state.status = ISP_AE_STATUS_UNSTABLE;
-							if(ae_sm_dg&AE_STATUS_DG)
-								pr_info("ISP_AE_STATUS_UNSTABLE\n");
-							sm_state.ae_down = false;
-							sm_state.isp_ae_parm.isp_ae_state = AE_REST;
-							step = AE_SUCCESS;
-						}
-						else{
-							ae_sens.new_step = newstep;
-							ae_sens.shutter = 1;
-							ae_sens.gain = 0;
-							atomic_set(&ae_info->writeable,1);
-							sm_state.status = ISP_AE_STATUS_UNSTABLE;
-							if(ae_sm_dg&AE_STATUS_DG)
-								pr_info("ISP_AE_STATUS_UNSTABLE\n");
-							sm_state.ae_down = false;
-							sm_state.isp_ae_parm.isp_ae_state = AE_GAIN_ADJUST;//AE_REST;
-							step = AE_SUCCESS;
-						}
-						break;
-					case AE_SUCCESS:
-					default:
-						step = 0;
-						break;
-				};
-			}
-			break;
-		case AE_GAIN_ADJUST:
-			if(atomic_read(&ae_info->writeable) <= 0){
-				ae_sens.new_step = newstep;
-				ae_sens.shutter = 0;
-				ae_sens.gain = 1;
-				atomic_set(&ae_info->writeable,1);
-				sm_state.isp_ae_parm.isp_ae_state = AE_REST;
-			}
-			break;
-		case AE_REST:
-			sm_state.ae_down = true;
-			if(atomic_read(&ae_info->writeable) <= 0)
-				k++;
-			//printk("func->check_mains_freq =%x\n",func->check_mains_freq);
-			//if(func->check_mains_freq)
-			//	sm_state.isp_ae_parm.isp_ae_state = AE_ORI_SET;
-			//else
-			if(k > ae_step){
-				k = 0;
-				sm_state.isp_ae_parm.isp_ae_state = AE_SHUTTER_ADJUST;
-			}
-			break;
-    		}
-}
-
-// VDIN_MATRIX_YUV601_RGB
-//	-16 	1.164  0	  1.596 	 0
-// -128 	1.164 -0.391 -0.813 	 0
-// -128 	1.164  2.018  0 		 0
-static inline int matrix_yuv601_rgb_r(unsigned int y, unsigned int u, unsigned int v)
-{
-	return (((y-16)*1192+(u-128)*0+(v-128)*1634+0) >> 10);
-}
-
-static inline int matrix_yuv601_rgb_g(unsigned int y, unsigned int u, unsigned int v)
-{
-	return (((y-16)*1192+(u-128)*(-400)+(v-128)*(-833)+0) >> 10);
-}
-
-static inline int matrix_yuv601_rgb_b(unsigned int y, unsigned int u, unsigned int v)
-{
-	return (((y-16)*1192+(u-128)*2066+(v-128)*0+0) >> 10);
-}
-
-// VDIN_MATRIX_YUV709_RGB
-//	-16 	1.164  0	  1.793 	 0
-// -128 	1.164 -0.213 -0.534 	 0
-// -128 	1.164  2.115  0 		 0
-static inline int matrix_yuv709_rgb_r(unsigned int y, unsigned int u, unsigned int v)
-{
-	return (((y-16)*1192+(u-128)*0+(v-128)*1836+0) >> 10);
-}
-
-static inline int matrix_yuv709_rgb_g(unsigned int y, unsigned int u, unsigned int v)
-{
-	return (((y-16)*1192+(u-128)*(-218)+(v-128)*(-547)+0) >> 10);
-}
-
-static inline int matrix_yuv709_rgb_b(unsigned int y, unsigned int u, unsigned int v)
-{
-	return (((y-16)*1192+(u-128)*2166+(v-128)*0+0) >> 10);
-}
-
-//static unsigned int r_val = 256;
-//static unsigned int g_val = 390;//256;
-//static unsigned int b_val = 256;
-
-int isp_awb_save_current_para(isp_dev_t *devp)
-{
-    isp_awb_get_gain(&awb_gain_pre);
-
-    pr_info("[isp] %s save awb, r:%d g:%d b:%d ... ...\n",
-                __func__, awb_gain_pre.r_val, awb_gain_pre.g_val,awb_gain_pre.b_val);
-
-    return 0;
-}
-void isp_awb_sm(isp_dev_t *devp)
-{
-	struct isp_awb_stat_s *awb = &devp->isp_awb;
-	struct xml_algorithm_awb_s *awbp = devp->isp_awb_parm;
-	struct isp_info_s *parm = &devp->info;
-	struct isp_awb_sm_s *awba = &sm_state.isp_awb_parm;
-	int step = 0;
-
-	u16 r[5] = {0};      //0,rgb;1,ym;2,yh;3,yl;4,final.
-	u16 g[5] = {0};
-	u16 b[5] = {0};
-	u32 count[3] = {0};   //0,mid;1,hign;2,low.
-	int u[3] = {0};
-	int v[3] = {0};
-	u16 rg = 0;
-	u16 bg = 0;
-	u16 target_r;
-	u16 target_b;
-	//printk("sm_state.isp_awb_parm.isp_awb_state=%d\n",sm_state.isp_awb_parm.isp_awb_state);
-
-	switch(sm_state.isp_awb_parm.isp_awb_state){
-		case AWB_IDLE:
-			break;
-		case AWB_INIT:
-			awba->win_l = (parm->h_active * awbp->ratio_winl) >> 10;
-			awba->win_r = ((parm->h_active * awbp->ratio_winr) >> 10) - 1;
-			awba->win_t = (parm->v_active * awbp->ratio_wint) >> 10;
-			awba->win_b = ((parm->v_active * awbp->ratio_winb) >> 10) - 1;
-			printk("awb,win_l=%d,win_r=%d,win_t=%d,win_b=%d\n",awba->win_l,awba->win_r,awba->win_t,awba->win_b);
-			isp_set_awb_win(awba->win_l, awba->win_r, awba->win_t, awba->win_b);
-			awba->pixel_sum = parm->h_active * parm->v_active;
-			awba->countlimitrgb = ((awba->pixel_sum >> 2) * awbp->ratio_rgb) >> 6;
-			awba->countlimityh	= ((awba->pixel_sum >> 2) * awbp->ratio_yh) >> 6;
-			awba->countlimitym	= ((awba->pixel_sum >> 2) * awbp->ratio_ym) >> 6;
-			awba->countlimityl	= ((awba->pixel_sum >> 2) * awbp->ratio_yl) >> 6;
-			awba->status = ISP_AWB_STATUS_STABLE;
-			    sm_state.isp_awb_parm.isp_awb_state = AWB_CHECK;
-			break;
-		case AWB_CHECK:
-			while(step != AWB_SUCCESS)
-			{
-				//printk("step = %d\n",step);
-				switch(step){
-					case AWB_START:
-						step = AWB_RGB_COUNT_CHECK;
-						//printk("step1 = %d\n",step);
-						break;
-					case AWB_RGB_COUNT_CHECK:
-						if(awb_sm_dg&AWB_RGB_COUNT_CHECK_DG)
-							pr_info("awb->rgb.rgb_count=%d\n",awb->rgb.rgb_count);
-						if(awb->rgb.rgb_count >= awba->countlimitrgb)
-							step = AWB_CALCULATE_RGB;
-						else
-						{
-							r[0] = 0;
-							g[0] = 0;
-							b[0] = 0;
-							step = AWB_YUVM_COUNT_CHECK;
-						}
-						//printk("step55 = %d\n",step);
-					    break;
-					case AWB_CALCULATE_RGB:
-						if(awb->rgb.rgb_count <= 0)
-						{
-							step = AWB_SUCCESS;
-							break;
-						}
-						r[0] = awb->rgb.rgb_sum[0]/awb->rgb.rgb_count;
-						g[0] = awb->rgb.rgb_sum[1]/awb->rgb.rgb_count;
-						b[0] = awb->rgb.rgb_sum[2]/awb->rgb.rgb_count;
-						step = AWB_YUVM_COUNT_CHECK;
-						break;
-					case AWB_YUVM_COUNT_CHECK:
-						count[0] = awb->yuv_mid[0].count + awb->yuv_mid[1].count;
-						if(count[0] >= awba->countlimitym)
-							step = AWB_CALCULATE_YUVM;
-						else
-						{
-							r[1] = 0;
-							g[1] = 0;
-							b[1] = 0;
-							step = AWB_YUVH_COUNT_CHECK;
-						}
-						break;
-					case AWB_CALCULATE_YUVM:
-						if(count[0] <= 0)
-						{
-							step = AWB_SUCCESS;
-							break;
-						}
-						u[0] = (awb->yuv_mid[1].sum - awb->yuv_mid[0].sum)/count[0];
-						v[0] = (awb->yuv_mid[3].sum - awb->yuv_mid[2].sum)/count[0];
-
-						if(parm->v_active >= 720)
-						{
-							r[1] = matrix_yuv709_rgb_r(awbp->yym,u[0]+128,v[0]+128);
-							g[1] = matrix_yuv709_rgb_g(awbp->yym,u[0]+128,v[0]+128);
-							b[1] = matrix_yuv709_rgb_b(awbp->yym,u[0]+128,v[0]+128);
-						}
-						else
-						{
-							r[1] = matrix_yuv601_rgb_r(awbp->yym,u[0]+128,v[0]+128);
-							g[1] = matrix_yuv601_rgb_g(awbp->yym,u[0]+128,v[0]+128);
-							b[1] = matrix_yuv601_rgb_b(awbp->yym,u[0]+128,v[0]+128);
-						}
-						step = AWB_YUVH_COUNT_CHECK;
-						break;
-					case AWB_YUVH_COUNT_CHECK:
-						count[1] = awb->yuv_high[0].count + awb->yuv_high[1].count;
-						if(count[1] >= awba->countlimityh)
-							step = AWB_CALCULATE_YUVH;
-						else
-						{
-							r[2] = 0;
-							g[2] = 0;
-							b[2] = 0;
-							step = AWB_YUVL_COUNT_CHECK;
-						}
-						break;
-					case AWB_CALCULATE_YUVH:
-						if(count[1] <= 0)
-						{
-							step = AWB_SUCCESS;
-							break;
-						}
-						u[1] = (awb->yuv_high[1].sum - awb->yuv_high[0].sum)/count[1];
-						v[1] = (awb->yuv_high[3].sum - awb->yuv_high[2].sum)/count[1];
-
-						if(parm->v_active >= 720)
-						{
-							r[2] = matrix_yuv709_rgb_r(awbp->yyh,u[1]+128,v[1]+128);
-							g[2] = matrix_yuv709_rgb_g(awbp->yyh,u[1]+128,v[1]+128);
-							b[2] = matrix_yuv709_rgb_b(awbp->yyh,u[1]+128,v[1]+128);
-						}
-						else
-						{
-							r[2] = matrix_yuv601_rgb_r(awbp->yyh,u[1]+128,v[1]+128);
-							g[2] = matrix_yuv601_rgb_g(awbp->yyh,u[1]+128,v[1]+128);
-							b[2] = matrix_yuv601_rgb_b(awbp->yyh,u[1]+128,v[1]+128);
-						}
-						step = AWB_YUVL_COUNT_CHECK;
-						break;
-					case AWB_YUVL_COUNT_CHECK:
-						count[2] = awb->yuv_low[0].count + awb->yuv_low[1].count;
-						if(count[2] >= awba->countlimityl)
-							step = AWB_CALCULATE_YUVL;
-						else
-						{
-							r[3] = 0;
-							g[3] = 0;
-							b[3] = 0;
-							step = AWB_RGB_BLEND;
-						}
-						break;
-					case AWB_CALCULATE_YUVL:
-						if(count[2] <= 0)
-						{
-							step = AWB_SUCCESS;
-							break;
-						}
-						u[2] = (awb->yuv_low[1].sum - awb->yuv_low[0].sum)/count[2];
-						v[2] = (awb->yuv_low[3].sum - awb->yuv_low[2].sum)/count[2];
-
-						if(parm->v_active >= 720)
-						{
-							r[3] = matrix_yuv709_rgb_r(awbp->yyl,u[2]+128,v[2]+128);
-							g[3] = matrix_yuv709_rgb_g(awbp->yyl,u[2]+128,v[2]+128);
-							b[3] = matrix_yuv709_rgb_b(awbp->yyl,u[2]+128,v[2]+128);
-						}
-						else
-						{
-							r[3] = matrix_yuv601_rgb_r(awbp->yyl,u[2]+128,v[2]+128);
-							g[3] = matrix_yuv601_rgb_g(awbp->yyl,u[2]+128,v[2]+128);
-							b[3] = matrix_yuv601_rgb_b(awbp->yyl,u[2]+128,v[2]+128);
-						}
-						step = AWB_RGB_BLEND;
-						break;
-			        case AWB_RGB_BLEND:
-						r[4] = (r[0]*awbp->coef_r[0]+r[1]*awbp->coef_r[1]+r[2]*awbp->coef_r[2]+r[3]*awbp->coef_r[3])>>8;
-						g[4] = (g[0]*awbp->coef_g[0]+g[1]*awbp->coef_g[1]+g[2]*awbp->coef_g[2]+g[3]*awbp->coef_g[3])>>8;
-						b[4] = (b[0]*awbp->coef_b[0]+b[1]*awbp->coef_b[1]+b[2]*awbp->coef_b[2]+b[3]*awbp->coef_b[3])>>8;
-						if(awb_sm_dg&AWB_RGB_BLEND_DG)
-							pr_info("r=%d,%d,%d,%d,%d,g=%d,%d,%d,%d,%d,b=%d,%d,%d,%d,%d\n",r[0],r[1],r[2],r[3],r[4],g[0],g[1],g[2],g[3],g[4],b[0],b[1],b[2],b[3],b[4]);
-						if(sm_state.env == ENV_HIGH)
-						{
-							isp_set_awb_yuv_thr(awbp->thr_yh_h, awbp->thr_yl_h, awbp->thr_du_h, awbp->thr_dv_h);
-							isp_set_awb_rgb_thr(awbp->thr_gb_h, awbp->thr_gr_h, awbp->thr_br_h);
-						}
-						else if(sm_state.env == ENV_MID)
-						{
-							isp_set_awb_yuv_thr(awbp->thr_yh_m, awbp->thr_yl_m, awbp->thr_du_m, awbp->thr_dv_m);
-							isp_set_awb_rgb_thr(awbp->thr_gb_m, awbp->thr_gr_m, awbp->thr_br_m);
-						}
-						else if(sm_state.env == ENV_LOW)
-						{
-							isp_set_awb_yuv_thr(awbp->thr_yh_l, awbp->thr_yl_l, awbp->thr_du_l, awbp->thr_dv_l);
-							isp_set_awb_rgb_thr(awbp->thr_gb_l, awbp->thr_gr_l, awbp->thr_br_l);
-						}
-						step = AWB_TEMP_CHECK;
-						break;
-					case AWB_TEMP_CHECK:
-						if((g[4] == 0)||(r[4] == 0)||(b[4] == 0))
-						{
-							step = AWB_SUCCESS;
-							break;
-						}
-						rg = (r[4] << 10)/g[4];
-						bg = (b[4] << 10)/g[4];
-						if(awb_sm_dg&AWB_TEMP_CHECK_DG)
-							pr_info("rg=%d,bg=%d\n",rg,bg);
-						if(((awba->status == ISP_AWB_STATUS_UNSTABLE) && ((rg > 1024 + awbp->inner_rg)||(rg < 1024 - awbp->inner_rg)))
-							||((rg > 1024 + awbp->outer_rg)||(rg < 1024 - awbp->outer_rg))
-							||((awba->status == ISP_AWB_STATUS_UNSTABLE) && ((bg > 1024 + awbp->inner_bg)||(bg < 1024 - awbp->inner_bg)))
-							||((bg > 1024 + awbp->outer_bg)||(bg < 1024 - awbp->outer_bg))
-							)
-							step = AWB_TEMP_ADJUST;
-						else
-						{
-							awba->status = ISP_AWB_STATUS_STABLE;
-							step = AWB_SUCCESS;
-						}
-						break;
-					case AWB_TEMP_ADJUST:
-						awba->status = ISP_AWB_STATUS_UNSTABLE;
-						isp_awb_get_gain(&awb_gain);
-						if(awb_sm_dg&AWB_TEMP_ADJUST_DG)
-							pr_info("r_val=%d,b_val=%d\n",awb_gain.r_val,awb_gain.b_val);
-						target_r = (awb_gain.r_val<<10)/rg;
-						target_b = (awb_gain.b_val<<10)/bg;
-						//awbp->r_max = 282;
-						//awbp->g_max = 512;
-						//awbp->b_max = 282;
-						//awbp->r_min = 200;
-						//awbp->g_min = 128;
-						//awbp->b_min = 200;
-
-						if(awb_sm_dg&AWB_TEMP_ADJUST_DG)
-							pr_info("target_r=%d,target_b=%d\n",target_r,target_b);
-						if(target_r > awbp->r_max)
-							target_r = awbp->r_max;
-						if(target_r < awbp->r_min)
-							target_r = awbp->r_min;
-						if(target_b > awbp->b_max)
-							target_b = awbp->b_max;
-						if(target_b < awbp->b_min)
-							target_b = awbp->b_min;
-						if(awb_sm_dg&AWB_GAIN_SET_DG)
-							isp_awb_set_gain(target_r,awb_gain.g_val,target_b);
-						//r_val = target_r;
-						//b_val = target_b;
-						step = AWB_SUCCESS;
-						break;
-					case AWB_SUCCESS:
-					default:
-						step = 0;
-						break;
-				}
-			}
-			break;
-	}
-}
-unsigned long long div64(unsigned long long n, unsigned long long d) // n for numerator, d for denominator
-{
-    unsigned int n_bits = 0, d_bits = 0, i = 0;
-    unsigned long long q = 0, t = 0; // q for quotient, t for temporary
-    // invalid
-    if (!d) {
-        q = 0xffffffffffffffff;
-    }
-    // (0.5, 0]
-    else if (n + n < d) {
-        q = 0;
-    }
-    // [1.0, 0.5]
-    else if (n <= d) {
-        q = 1;
-    }
-    // [max, 1.0)
-    else
-    {
-        // get n_bits
-        for (n_bits = 1; n_bits <= 64; n_bits++)
-            if (!(n >> n_bits))
-                break;
-        if (n_bits > 64)
-		n_bits = 64;
-		// get d_bits
-        for (d_bits = 1; d_bits <= 64; d_bits++)
-            if (!(d >> d_bits))
-                break;
-        if (d_bits > 64)
-            d_bits = 64;
-        // check integer part
-        for (i = n_bits; i >= d_bits; i--) {
-            q <<= 1;
-            t = d << (i - d_bits);
-            if (n >= t)
-            {
-                n -= t;
-                q += 1;
-            }
-        }
-        // check fraction part
-        if (n + n >= d)
-            q += 1;
-    }
-    return q;
-}
-static unsigned long long isp_abs64(unsigned long long a,unsigned long long b)
-{
-	return (a>b?(a-b):(b-a));
-}
-static unsigned long long get_fv_base_blnr(isp_blnr_stat_t *blnr)
-{
-	unsigned long long sum_ac = 0, sum_dc = 0, mul_ac = 0;
-	sum_ac  = (unsigned long long)blnr->ac[0];
-	sum_ac += (unsigned long long)blnr->ac[1];
-	sum_ac += (unsigned long long)blnr->ac[2];
-	sum_ac += (unsigned long long)blnr->ac[3];
-
-	sum_dc  = (unsigned long long)blnr->dc[0];
-	sum_dc += (unsigned long long)blnr->dc[1];
-	sum_dc += (unsigned long long)blnr->dc[2];
-	sum_dc += (unsigned long long)blnr->dc[3];
-
-	mul_ac = (sum_ac > 0x00000000ffffffff) ? 0xffffffffffffffff : sum_ac*sum_ac;
-	sum_ac = (unsigned long long)blnr->af_ac[0];
-	return sum_ac;
-	//return div64(mul_ac,sum_dc);
-
-}
-static unsigned int jitter = 5;
-module_param(jitter,uint,0664);
-MODULE_PARM_DESC(jitter,"\n debug flag for ae.\n");
-
-static unsigned int delta = 9;
-module_param(delta,uint,0664);
-MODULE_PARM_DESC(delta,"\n debug flag for ae.\n");
-
-static bool is_lost_focus(isp_af_info_t *af_info,xml_algorithm_af_t *af_alg)
-{
-	unsigned long long *v_dc,sum_vdc=0,ave_vdc=0,delta_dc=0,tmp_vdc=0;
-	unsigned int i=0,dc0,dc1,dc2,dc3,static_cnt;
-	bool ret=false,is_move=false,is_static=false;
-	v_dc = af_info->v_dc;
-	/*calc v dc*/
-	dc0 = af_info->last_blnr.dc[0];
-	dc1 = af_info->last_blnr.dc[1];
-	dc2 = af_info->last_blnr.dc[2];
-	dc3 = af_info->last_blnr.dc[3];
-	for(i=0;i<af_alg->detect_step_cnt;i++){
-		delta_dc = isp_abs64(dc0,af_info->af_detect[i].dc[0]);
-		v_dc[i]  = div64((delta_dc*1024),(unsigned long long)dc0);
-		delta_dc = isp_abs64(dc1,af_info->af_detect[i].dc[1]);
-		v_dc[i] += div64((delta_dc*1024),(unsigned long long)dc1);
-		delta_dc = isp_abs64(dc2,af_info->af_detect[i].dc[2]);
-		v_dc[i] += div64((delta_dc*1024),(unsigned long long)dc2);
-		delta_dc = isp_abs64(dc3,af_info->af_detect[i].dc[3]);
-		v_dc[i] += div64((delta_dc*1024),(unsigned long long)dc3);
-		sum_vdc += v_dc[i];
-	}
-	ave_vdc = div64(sum_vdc,af_alg->detect_step_cnt);
-
-	static_cnt = 0;
-	for(i=0;i<af_alg->detect_step_cnt;i++){
-		delta_dc = isp_abs64(v_dc[i],ave_vdc);
-		tmp_vdc = div64(delta_dc*1024,af_alg->enter_static_ratio);
-		if(!af_info->last_move){
-			if((ave_vdc > af_alg->ave_vdc_thr)||(v_dc[i] > af_alg->ave_vdc_thr)){
-			        is_move = true;
-				break;
-			}
-		}else if(tmp_vdc < ave_vdc){
-			if(++static_cnt >= af_alg->detect_step_cnt)
-				is_static = true;
-		}
-	}
-	/* enter move from static */
-	if(is_move){
-		if(af_sm_dg&AF_DETECT)
-			pr_info("0->1\n");
-		af_info->last_move = true;
-		return false;
-	/* during hysteresis ,still last state*/
-	}else if((!is_static&&!is_move)||!af_info->last_move){
-		if(af_sm_dg&AF_DETECT){
-			pr_info("ave_vdc:%llu,af_info->last_move:%d keep last state.\n",ave_vdc,af_info->last_move);
-		}
-		return false;
-	}
-	if(af_sm_dg&AF_DETECT)
-		pr_info("1->0\n");
-	/*enter static from move,trigger full scan*/
-	return true;
-}
-void isp_af_detect(isp_dev_t *devp)
-{
-	struct xml_algorithm_af_s *af_alg = devp->isp_af_parm;
-	struct isp_af_info_s *af_info = &devp->af_info;
-
-	switch(sm_state.af_state){
-		case AF_DETECT_INIT:
-			isp_set_blenr_stat(af_info->x0,af_info->y0,af_info->x1,af_info->y1);
-			af_info->cur_index = 0;
-			sm_state.af_state = AF_GET_STEPS_INFO;
-			break;
-		case AF_GET_STEPS_INFO:
-			memcpy(&af_info->af_detect[af_info->cur_index],&af_info->isr_af_data,sizeof(isp_blnr_stat_t));
-			if(++af_info->cur_index >= af_alg->detect_step_cnt){
-				if(af_sm_dg&AF_DETECT)
-					pr_info("%s get info end index=%u .\n",__func__,af_info->cur_index);
-				af_info->cur_index = 0;
-				sm_state.af_state = AF_GET_STATUS;
-			}
-			break;
-		case AF_GET_STATUS:
-			if(is_lost_focus(af_info,af_alg)){
-				sm_state.af_state = AF_SCAN_INIT;
-				if(af_sm_dg&AF_DETECT)
-					pr_info("[af_sm]:lost focus.\n");
-			}else if(af_info->cur_index < af_alg->detect_step_cnt){
-				memcpy(&af_info->af_detect[af_info->cur_index],&af_info->isr_af_data,sizeof(isp_blnr_stat_t));
-				af_info->cur_index++;
-			}else{
-				af_info->cur_index = 0;
-			}
-			break;
-		default:
-			isp_af_fine_tune(devp);
-			break;
-	}
-}
-static unsigned int check_hillside(isp_af_info_t *af_info,xml_algorithm_af_t *af_alg)
-{
-	unsigned int cur_ac,last_ac,delta_ac,delta_ac_ratio,ret;
-	if(af_info->valid_step_cnt < 2)
-		return 0;//avoid first step
-	cur_ac = af_info->af_fine_data[af_info->valid_step_cnt - 1].af_data.af_ac[0];
-	last_ac = af_info->af_fine_data[af_info->valid_step_cnt - 2].af_data.af_ac[0];
-	delta_ac = isp_abs64(cur_ac,last_ac);
-	if((cur_ac == 0)||(last_ac == 0)){/*avoid wrong*/
-		if(af_sm_dg&AF_FINE_TUNE)
-			pr_info("[check_hillside]error:ac is 0\n");
-		return 3;
-	}
-	delta_ac_ratio = delta_ac*100/((last_ac < cur_ac)?cur_ac:last_ac);
-	if(af_sm_dg&AF_FINE_TUNE)
-		pr_info("[check hillside]delta_ac_ratio:%d,cur_ac:%d,last_ac:%d .\n",delta_ac_ratio,cur_ac,last_ac);
-	if((last_ac > cur_ac)&&(delta_ac_ratio > af_alg->hillside_fall)){
-		ret = 1;//fall fillside
-	}
-	else if((last_ac < cur_ac)&&(delta_ac_ratio > af_alg->hillside_fall)){
-		return 2;//up fillside
-	}
-	else
-		ret = 0;//platform
-	return ret;
-
-}
-static unsigned int get_fine_step(isp_af_info_t *af_info,xml_algorithm_af_t *af_alg)
-{
-        unsigned int i = 0, j = 0,cur_grid = 0, max_grid = 0, best_step = 0;
-        unsigned long long delta_fv,sum_ac = 0, mul_ac = 0, fv[FOCUS_GRIDS], max_fv = 0, min_fv = 0xffffffffffffffff, sum_fv = 0,moment = 0;
-	unsigned long long fv_ave=0,fv_sum=0,diff_fv_parm;
-	isp_af_fine_tune_t af_fine_data_ex;
-	for(i = 0; i < af_info->valid_step_cnt; i++){
-		for(j = i+1; j < af_info->valid_step_cnt; j++ ){
-			if(af_info->af_fine_data[j].cur_step < af_info->af_fine_data[i].cur_step){
-				memcpy(&af_fine_data_ex,&af_info->af_fine_data[i],sizeof(isp_af_fine_tune_t));
-				memcpy(&af_info->af_fine_data[i],&af_info->af_fine_data[j],sizeof(isp_af_fine_tune_t));
-				memcpy(&af_info->af_fine_data[j],&af_fine_data_ex,sizeof(isp_af_fine_tune_t));
-			}
-		}
-	}
-	if(af_sm_dg&AF_BEST_STEP)
-		pr_info("%s ac[0] ac[1] ac[2] ac[3] dc[0] dc[1] dc[2] dc[3] af0_ac af1_ac\n", __func__);
-        for (i = 0; i < af_info->valid_step_cnt; i++){
-                if (i && (af_info->af_fine_data[i].cur_step==0))
-                        break;
-                max_grid = i;
-                fv[i] = get_fv_base_blnr(&af_info->af_fine_data[i].af_data);
-	        if(af_sm_dg&AF_BEST_STEP)
-                        pr_info("%s %u %u %u %u %u %u %u %u %u %u\n", __func__, af_info->af_fine_data[i].af_data.ac[0], af_info->af_fine_data[i].af_data.ac[1], af_info->af_fine_data[i].af_data.ac[2],
-                        af_info->af_fine_data[i].af_data.ac[3], af_info->af_fine_data[i].af_data.dc[0], af_info->af_fine_data[i].af_data.dc[1], af_info->af_fine_data[i].af_data.dc[2], af_info->af_fine_data[i].af_data.dc[3],
-                        af_info->af_fine_data[i].af_data.af_ac[0],af_info->af_fine_data[i].af_data.af_ac[1]);
-                if (max_fv < fv[i]){
-		        max_fv = fv[i];
-		        cur_grid = i;
-	        }
-		if(min_fv > fv[i])
-			min_fv = fv[i];
-        }
-	// too less stroke, for power saving
-        if (!cur_grid) {
-	        best_step = af_info->af_fine_data[0].cur_step;
-        }
-        // too much stroke
-        else if (cur_grid == max_grid){
-	        best_step = af_info->af_fine_data[max_grid].cur_step;
-	}
-	// work out best step with 3 grids
-	else if ((cur_grid == 1) || (cur_grid == max_grid - 1)){
-                moment += fv[cur_grid - 1]*(unsigned long long)af_info->af_fine_data[cur_grid - 1].cur_step;
-                moment += fv[cur_grid    ]*(unsigned long long)af_info->af_fine_data[cur_grid    ].cur_step;
-                moment += fv[cur_grid + 1]*(unsigned long long)af_info->af_fine_data[cur_grid + 1].cur_step;
-                sum_fv += fv[cur_grid - 1];
-                sum_fv += fv[cur_grid    ];
-                sum_fv += fv[cur_grid + 1];
-                best_step = (unsigned int)div64(moment,sum_fv);
-	}
-	// work out best step with 5 grids
-        else {
-                moment += (unsigned long long)fv[cur_grid - 2]*(unsigned long long)af_info->af_fine_data[cur_grid - 2].cur_step;
-                moment += (unsigned long long)fv[cur_grid - 1]*(unsigned long long)af_info->af_fine_data[cur_grid - 1].cur_step;
-                moment += (unsigned long long)fv[cur_grid    ]*(unsigned long long)af_info->af_fine_data[cur_grid    ].cur_step;
-                moment += (unsigned long long)fv[cur_grid + 1]*(unsigned long long)af_info->af_fine_data[cur_grid + 1].cur_step;
-                moment += (unsigned long long)fv[cur_grid + 2]*(unsigned long long)af_info->af_fine_data[cur_grid + 2].cur_step;
-                sum_fv += fv[cur_grid - 2];
-                sum_fv += fv[cur_grid - 1];
-                sum_fv += fv[cur_grid    ];
-                sum_fv += fv[cur_grid + 1];
-                sum_fv += fv[cur_grid + 2];
-                best_step = (unsigned int)div64(moment,sum_fv);
-	}
-	delta_fv = div64(100*(max_fv-min_fv),max_fv);
-	if(af_sm_dg&AF_BEST_STEP)
-		pr_info("%s:get best step %u,delta_fv:%lld.\n",__func__,best_step,delta_fv);
-	return best_step;
-}
-void isp_af_fine_tune(isp_dev_t *devp)
-{
-	static unsigned int af_delay=0;
-	struct xml_algorithm_af_s *af_alg = devp->isp_af_parm;
-	struct isp_af_info_s *af_info = &devp->af_info;
-	struct isp_af_sm_s *sm = &sm_state.af_sm;
-	af_delay++;
-
-	switch(sm_state.af_state){
-		case AF_SCAN_INIT:
-			devp->cmd_state = CAM_STATE_DOING;
-			isp_set_blenr_stat(af_info->x0,af_info->y0,af_info->x1,af_info->y1);
-			af_delay = 0;
-			af_info->valid_step_cnt = 0;
-			memset(af_info->af_fine_data,0,FOCUS_GRIDS*sizeof(isp_af_fine_tune_t));
-			if(af_info->cur_step < (af_alg->step[af_alg->valid_step_cnt - 1] + af_alg->step[0])/2){
-				af_info->cur_index = 0;
-				sm_state.af_state = AF_GET_COARSE_INFO_L;
-			}
-			else{
-				af_info->cur_index = af_alg->valid_step_cnt - 1;
-				sm_state.af_state = AF_GET_COARSE_INFO_H;
-			}
-			break;
-		case AF_GET_COARSE_INFO_H://from H step --> L step
-			/*return to max step*/
-			if((atomic_read(&af_info->writeable) <= 0)&&(af_info->cur_index == (af_alg->valid_step_cnt - 1))&&(af_info->cur_step != af_alg->step[af_alg->valid_step_cnt - 1])){
-				if(af_info->cur_step < af_alg->step[af_alg->valid_step_cnt - 1]){
-					if((af_alg->step[af_alg->valid_step_cnt - 1] - af_info->cur_step) > af_alg->jump_offset)
-						af_info->cur_step = af_info->cur_step + af_alg->jump_offset;
-					else
-						af_info->cur_step = af_alg->step[af_info->cur_index];
-				}
-				else
-					af_info->cur_step = af_alg->step[af_info->cur_index];
-				atomic_set(&af_info->writeable,1);
-				af_delay = 0;
-				break;
-			}
-			/*get isp af info*/
-			if((atomic_read(&af_info->writeable) <= 0)&&(af_delay >= af_alg->field_delay)){
-				af_info->valid_step_cnt++;
-				af_info->af_fine_data[af_info->valid_step_cnt - 1].cur_step = af_info->cur_step;
-				memcpy(&af_info->af_fine_data[af_info->valid_step_cnt - 1].af_data,&af_info->isr_af_data,sizeof(isp_blnr_stat_t));
-				if((af_info->cur_index == 0)||(check_hillside(af_info,af_alg) == 1)){
-				        sm_state.af_state = AF_GET_FINE_INFO;
-					af_info->great_step = get_fine_step(af_info,af_alg);
-				}else{
-					af_info->cur_index--;
-					af_info->cur_step = af_alg->step[af_info->cur_index];
-				        atomic_set(&af_info->writeable,1);
-				        af_delay = 0;
-				}
-			}
-			break;
-		case AF_GET_COARSE_INFO_L://from L step --> H step
-			/*return to min step*/
-			if((atomic_read(&af_info->writeable) <= 0)&&(af_info->cur_index == 0)&&(af_info->cur_step != af_alg->step[0])){
-				if(af_info->cur_step > af_alg->step[0]){
-					if((af_info->cur_step - af_alg->step[0]) > af_alg->jump_offset)
-						af_info->cur_step = af_info->cur_step - af_alg->jump_offset;
-					else
-						af_info->cur_step = af_alg->step[af_info->cur_index];
-				}
-				else
-					af_info->cur_step = af_alg->step[af_info->cur_index];
-				atomic_set(&af_info->writeable,1);
-				af_delay = 0;
-				break;
-			}
-			/*get isp af info*/
-			if((atomic_read(&af_info->writeable) <= 0)&&(af_delay >= af_alg->field_delay)){
-				af_info->valid_step_cnt++;
-				af_info->af_fine_data[af_info->valid_step_cnt - 1].cur_step = af_info->cur_step;
-				memcpy(&af_info->af_fine_data[af_info->valid_step_cnt - 1].af_data,&af_info->isr_af_data,sizeof(isp_blnr_stat_t));
-				if((++af_info->cur_index >= af_alg->valid_step_cnt)||(check_hillside(af_info,af_alg) == 1)){
-				        sm_state.af_state = AF_GET_FINE_INFO;
-					af_info->great_step = get_fine_step(af_info,af_alg);
-				}else{
-					af_info->cur_step = af_alg->step[af_info->cur_index];
-				        atomic_set(&af_info->writeable,1);
-				        af_delay = 0;
-				}
-			}
-			break;
-		case AF_CALC_GREAT:
-			if(atomic_read(&af_info->writeable) <= 0){
-				af_info->great_step = get_fine_step(af_info,af_alg);
-				if((af_info->cur_step - af_alg->jump_offset) > af_info->great_step){
-					af_info->cur_step = af_info->cur_step - af_alg->jump_offset;
-					sm_state.af_state = AF_GET_FINE_INFO;
-				}
-				else{
-					af_info->cur_step = af_info->great_step;
-					sm_state.af_state = AF_SUCCESS;
-				}
-				atomic_set(&af_info->writeable,1);
-				af_delay = 0;
-			}
-			break;
-		case AF_GET_FINE_INFO:
-			if(atomic_read(&af_info->writeable) <= 0){
-				if(af_sm_dg&AF_FINE_TUNE)
-					pr_info("[af_sm..]:af_info->cur_step:%d,af_alg->jump_offset:%d,af_info->great_step:%d.\n",
-					af_info->cur_step,af_alg->jump_offset,af_info->great_step);
-				if((af_info->cur_step - af_alg->jump_offset) > af_info->great_step){
-					af_info->cur_step = af_info->cur_step - af_alg->jump_offset;
-				}
-				else{
-					af_info->cur_step = af_info->great_step;
-					sm_state.af_state = AF_SUCCESS;
-				}
-				atomic_set(&af_info->writeable,1);
-				af_delay = 0;
-			}
-			break;
-		case AF_SUCCESS:
-			if((atomic_read(&af_info->writeable) <= 0)&&(af_delay >= af_alg->field_delay*2)){
-				/*get last blnr*/
-				memcpy(&af_info->last_blnr,&af_info->isr_af_data,sizeof(isp_blnr_stat_t));
-			        if(af_sm_dg&AF_FINE_TUNE){
-				        pr_info("[af] last blnr:ac0=%u ac1=%u ac2=%u ac3=%u dc0=%u dc1=%u dc2=%u dc3=%u af0_ac=%u af1_ac=%u.\n",
-				                af_info->last_blnr.ac[0],af_info->last_blnr.ac[1],
-				                af_info->last_blnr.ac[2],af_info->last_blnr.ac[3],
-					        af_info->last_blnr.dc[0],af_info->last_blnr.dc[1],
-					        af_info->last_blnr.dc[2],af_info->last_blnr.dc[3],
-					        af_info->last_blnr.af_ac[0],af_info->last_blnr.af_ac[1]);
-				}
-				af_info->last_move = false;
-				af_delay = 0;
-				if(devp->flag & ISP_FLAG_TOUCH_AF)
-					devp->flag &= (~ISP_FLAG_TOUCH_AF);
-				if(devp->flag & ISP_FLAG_AF)
-					sm_state.af_state = AF_DETECT_INIT;
-				else
-					sm_state.af_state = AF_NULL;
-				devp->cmd_state = CAM_STATE_SUCCESS;
-				isp_set_blenr_stat(af_info->x0,af_info->y0,af_info->x1,af_info->y1);
-				isp_set_af_scan_stat(af_info->x0,af_info->y0,af_info->x1,af_info->y1);
-			}
-			break;
-		default:
-			break;
-	}
-}
-void isp_af_save_current_para(isp_dev_t *devp)
-{
-	struct isp_af_info_s *af_info = &devp->af_info;
-	struct xml_algorithm_af_s *af_alg = devp->isp_af_parm;
-	af_info->last_move = false;
-	sm_state.af_state = AF_NULL;
-	if(sm_state.af_state == AF_SUCCESS)
-		af_info->capture_step = af_info->cur_step;
-	else
-		af_info->capture_step = af_alg->step[0];
-	pr_info("[isp]%s:save step:%d\n",__func__,af_info->capture_step);
-}
-#define FLASH_OFF         0
-#define FLASH_ON	  1
-#define FLASH_TORCH       2
-static void isp_set_flash(isp_dev_t *devp,unsigned flash_mode,unsigned level)
-{
-	if(!flash_mode)
-	torch_level(devp->flash.mode_pol_inv,devp->flash.led1_pol_inv,devp->flash.pin_mux_inv,devp->flash.torch_pol_inv,devp->wave,0);
-	else if(flash_mode == FLASH_ON)
-		flash_on(devp->flash.mode_pol_inv,devp->flash.led1_pol_inv,devp->flash.pin_mux_inv,devp->wave);
-	else if(flash_mode == FLASH_TORCH)
-		torch_level(devp->flash.mode_pol_inv,devp->flash.led1_pol_inv,devp->flash.pin_mux_inv,devp->flash.torch_pol_inv,devp->wave,level);
-}
-
-void isp_set_flash_mode(isp_dev_t *devp)
-{
-	if(!devp->flash.valid)
-		/*no flash*/
-		sm_state.cap_sm.flash_mode = FLASH_MODE_NULL;
-	else
-		sm_state.cap_sm.flash_mode = devp->cam_param->flash_mode;
-}
-void capture_sm_init(isp_dev_t *devp)
-{
-	struct isp_capture_sm_s *cap_sm = &sm_state.cap_sm;
-	xml_capture_t *parm = devp->capture_parm;
-
-	devp->capture_parm->ae_try_max_cnt = 3;
-	devp->capture_parm->sigle_count = 0;
-	devp->capture_parm->skip_step = 0;
-	devp->capture_parm->multi_capture_num = 0;
-	devp->capture_parm->af_mode = CAM_SCANMODE_FULL;
-	devp->capture_parm->eyetime = 0;
-	devp->capture_parm->pretime = 0;
-	devp->capture_parm->postime = 0;
-	cap_sm->adj_cnt = 0;
-	cap_sm->flash_mode = FLASH_MODE_NULL;
-	cap_sm->fr_time = 0;
-	cap_sm->tr_time = 0;
-
-	if(cap_sm->flash_mode) {
-		cap_sm->capture_state = CAPTURE_INIT;
-	} else {
-		cap_sm->capture_state = CAPTURE_TUNE_3A;
-		if(parm->af_mode){
-			devp->flag |= ISP_FLAG_AF;
-		}else{
-			devp->flag &= (~ISP_FLAG_AF);
-		}
-		devp->flag &= (~ISP_FLAG_AWB);
-		devp->flag &= (~ISP_FLAG_AE);
-	}
-	isp_ae_cal_new_para(devp);     // cal and set new ae value
-	isp_awb_load_pre_para(devp);  // cal and set new awb value
-
-	af_sm_init(devp);
-}
-int isp_capture_sm(isp_dev_t *devp)
-{
-	static unsigned int start_jf,multi_count=0;
-	unsigned int cur_ac=0,j=0;
-	xml_capture_t *parm = devp->capture_parm;
-	struct isp_capture_sm_s *cap_sm = &sm_state.cap_sm;
-	enum tvin_buffer_ctl_e ret = TVIN_BUF_SKIP;
-
-	cap_sm->adj_cnt++;
-
-	switch(cap_sm->capture_state){
-		case CAPTURE_INIT:
-			isp_set_blenr_stat(0,0,devp->info.h_active-1,devp->info.v_active-1);
-			if(parm->pretime){
-				cap_sm->capture_state = CAPTURE_PRE_WAIT;
-				start_jf = jiffies;
-				if(capture_debug)
-					pr_info("[cap_sm]%u:init->pre_wait.\n",__LINE__);
-			} else {
-			        cap_sm->capture_state = CAPTURE_FLASH_ON;
-				if(capture_debug)
-					pr_info("[cap_sm]%u:init->flash_on.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_PRE_WAIT:
-			if(time_after(jiffies,start_jf+parm->pretime)){
-				cap_sm->capture_state = CAPTURE_FLASH_ON;
-				start_jf = 0;
-				if(capture_debug)
-					pr_info("[cap_sm]%u:pre_wait->flash_on.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_FLASH_ON:
-			if((sm_state.flash==ISP_FLASH_STATUS_NULL)&&(cap_sm->flash_mode==FLASH_MODE_AUTO)){
-				return ret;
-			}
-			if(((cap_sm->flash_mode == FLASH_MODE_AUTO)&&(sm_state.flash == ISP_FLASH_STATUS_ON))||
-				(cap_sm->flash_mode == FLASH_MODE_ON))
-			{
-				start_jf = jiffies;
-				isp_set_flash(devp,FLASH_TORCH,100);
-				cap_sm->adj_cnt = 0;
-				cap_sm->flash_on = 1;
-				cap_sm->capture_state = CAPTURE_TR_WAIT;
-				if(capture_debug)
-					pr_info("[cap_sm]%u:flash on->torch rising wait.\n",__LINE__);
-			} else {
-				/*without flash*/
-				cap_sm->flash_on = 0;
-				cap_sm->capture_state = CAPTURE_TUNE_3A;
-			        if(capture_debug)
-				        pr_info("[cap_sm]%u:flash on->tune 3a wait.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_TR_WAIT:
-			if(time_after(jiffies,cap_sm->tr_time)){
-				cap_sm->capture_state = CAPTURE_TUNE_3A;
-				if(capture_debug)
-				        pr_info("[cap_sm]%u:torch rising wait->tune 3a wait.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_TUNE_3A:
-			if(cap_sm->adj_cnt >= parm->ae_try_max_cnt)
-			{
-				cap_sm->adj_cnt = 0;
-				if(cap_sm->flash_on) {
-					devp->flag |= ISP_FLAG_AE;
-					cap_sm->capture_state = CAPTURE_LOW_GAIN;
-					if(capture_debug)
-						pr_info("[cap_sm]%u:3a->low gain.\n",__LINE__);
-				} else {
-					cap_sm->capture_state = CAPTURE_SINGLE;
-					if(capture_debug)
-						pr_info("[cap_sm]%u:3a(%s)->sigle.\n",__LINE__,
-							cap_sm->adj_cnt>=parm->ae_try_max_cnt?"timeout":"stable");
-				}
-			}
-			break;
-		case CAPTURE_LOW_GAIN:
-			if(sm_state.ae_down==true){
-				devp->flag &=(~ISP_FLAG_AE);
-				cap_sm->capture_state = CAPTURE_EYE_WAIT;
-				if(capture_debug)
-					pr_info("[cap_sm]%u:low gain->eye wait.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_EYE_WAIT:
-			if(time_after(jiffies,start_jf+parm->eyetime)){
-				isp_set_flash(devp,FLASH_TORCH,0);
-				start_jf = 0;
-				cap_sm->capture_state = CAPTURE_POS_WAIT;
-				if(capture_debug)
-				        pr_info("[cap_sm]%u:eye wait->post wait:%u.\n",__LINE__,start_jf);
-			}
-			break;
-		case CAPTURE_POS_WAIT:
-			if(time_after(jiffies,start_jf+parm->postime)){
-				cap_sm->capture_state = CAPTURE_FLASHW;
-				isp_set_flash(devp,FLASH_ON,0);
-				start_jf = 0;
-				if(capture_debug)
-				        pr_info("[cap_sm]%u:changed post waite->flash wait.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_FLASHW:
-			if(time_after(jiffies,start_jf+cap_sm->fr_time)){
-				isp_set_flash(devp,FLASH_TORCH,0);
-				ret = TVIN_BUF_NULL;
-				if(capture_debug)
-					pr_info("[cap_sm]%u:flash wait end,report buffer.\n",__LINE__);
-			}
-			break;
-		case CAPTURE_SINGLE:
-			if(parm->sigle_count <= 1){
-				ret = TVIN_BUF_NULL;
-				cap_sm->capture_state = CAPTURE_NULL;
-				return ret;
-			}
-			if(cap_sm->adj_cnt <= parm->sigle_count){
-				for(j=0;j<4;j++)
-					cur_ac += devp->blnr_stat.ac[j];
-				if(capture_debug)
-					pr_info("[cap_sm]%u:field[%u] ac_sum %u.\n",__LINE__,cap_sm->adj_cnt,cur_ac);
-				if(cur_ac > cap_sm->max_ac_sum){
-					cap_sm->max_ac_sum = cur_ac;
-					ret = TVIN_BUF_TMP;
-				}
-			}else{
-				ret = TVIN_BUF_RECYCLE_TMP;
-				if(parm->multi_capture_num > 0){
-					cap_sm->capture_state = CAPTURE_MULTI;
-					cap_sm->adj_cnt = 1;
-					if(capture_debug)
-						pr_info("[cap_sm]%u:single->multi.\n",__LINE__);
-				}else{
-					cap_sm->capture_state = CAPTURE_END;
-					if(capture_debug)
-						pr_info("[cap_sm]%u:single->capture end.\n",__LINE__);
-				}
-			}
-
-			break;
-		case CAPTURE_MULTI:
-			if(cap_sm->adj_cnt % parm->skip_step == 0) {
-				ret = TVIN_BUF_NULL;
-				if(multi_count++ > parm->multi_capture_num){
-					cap_sm->capture_state = CAPTURE_END;
-                                        if(capture_debug)
-                                                pr_info("[cap_sm]%u:muti capture end.\n",__LINE__);
-				}
-			} else {
-				ret = TVIN_BUF_SKIP;
-			}
-			break;
-		case CAPTURE_END:
-			ret = TVIN_BUF_RECYCLE_TMP;
-			devp->flag &= (~ISP_FLAG_CAPTURE);
-			break;
-		default:
-			break;
-		}
-
-	return ret;
-}
-
-#define MAX_ABC(a,b,c)  (max(max(a,b),c))
-
-void isp_sm_uninit(isp_dev_t *devp)
-{
-    isp_ae_save_current_para(devp);
-    isp_awb_save_current_para(devp);
-    isp_af_save_current_para(devp);
-}
-
-module_param(af_sm_dg,uint,0664);
-MODULE_PARM_DESC(af_sm_dg,"\n debug flag for auto focus.\n");
-
-module_param(capture_debug,uint,0664);
-MODULE_PARM_DESC(capture_debug,"\n debug flag for isp capture function.\n");
-
diff --git a/drivers/amlogic/tvin/isp/isp_sm.h b/drivers/amlogic/tvin/isp/isp_sm.h
deleted file mode 100755
index 9d04d6464668..000000000000
--- a/drivers/amlogic/tvin/isp/isp_sm.h
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
-  * ISP 3A State Machine
-  *
-  * Author: Kele Bai <kele.bai@amlogic.com>
-  *
-  * Copyright (C) 2010 Amlogic Inc.
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  */
-
-#ifndef __ISP_STATE_MACHINE_H
-#define __ISP_STATE_MACHINE_H
-#include "isp_drv.h"
-
-typedef enum isp_auto_exposure_step_e {
-	AE_START = 0,
-	AE_CALCULATE_LUMA_AVG,
-	AE_CALCULATE_LUMA_TARG,
-	AE_LUMA_AVG_CHECK,
-	AE_EXPOSURE_ADJUST,
-	AE_SET_NEWSTEP,
-	AE_SUCCESS,
-} isp_auto_exposure_step_t;
-
-typedef enum isp_auto_whiteblance_step_e {
-	AWB_START = 0,
-	AWB_RGB_COUNT_CHECK,
-	AWB_CALCULATE_RGB,
-	AWB_YUVH_COUNT_CHECK,
-	AWB_CALCULATE_YUVH,
-	AWB_YUVM_COUNT_CHECK,
-	AWB_CALCULATE_YUVM,
-	AWB_YUVL_COUNT_CHECK,
-	AWB_CALCULATE_YUVL,
-	AWB_RGB_BLEND,
-	AWB_TEMP_CHECK,
-	AWB_TEMP_ADJUST,
-	AWB_SUCCESS,
-} isp_auto_whiteblance_step_t;
-
-
-typedef enum isp_auto_exposure_state_e {
-	AE_IDLE,
-	AE_INIT,
-	AE_SHUTTER_ADJUST,
-	AE_GAIN_ADJUST,
-	AE_REST,
-	AE_ORI_SET,
-	AE_LOW_GAIN,
-} isp_auto_exposure_state_t;
-
-typedef enum isp_auto_white_balance_state_e {
-	AWB_IDLE,
-	AWB_INIT,
-	AWB_CHECK,
-} isp_auto_white_balance_state_t;
-
-typedef enum af_state_e {
-	AF_NULL,
-	AF_DETECT_INIT,
-	AF_GET_STEPS_INFO,
-	AF_GET_STATUS,
-	AF_SCAN_INIT,
-	AF_GET_COARSE_INFO_H,
-	AF_GET_COARSE_INFO_L,
-	AF_CALC_GREAT,
-	AF_GET_FINE_INFO,
-	AF_CLIMBING,
-	AF_FINE,
-	AF_SUCCESS,
-} af_state_t;
-typedef enum isp_capture_state_e {
-	CAPTURE_NULL,
-	CAPTURE_INIT,
-	CAPTURE_PRE_WAIT,//for time lapse
-	CAPTURE_FLASH_ON,//turn on flash for red eye
-	CAPTURE_TR_WAIT,
-	CAPTURE_TUNE_3A,
-	CAPTURE_LOW_GAIN,
-	CAPTURE_EYE_WAIT,
-	CAPTURE_POS_WAIT,
-	CAPTURE_SINGLE,
-	CAPTURE_FLASHW,
-	CAPTURE_MULTI,
-	CAPTURE_END,
-}isp_capture_state_t;
-
-typedef enum isp_ae_status_s {
-	ISP_AE_STATUS_NULL = 0,
-	ISP_AE_STATUS_UNSTABLE,	
-	ISP_AE_STATUS_STABLE,
-	ISP_AE_STATUS_UNTUNEABLE,
-}isp_ae_status_t;
-
-typedef struct isp_ae_sm_s {
-	unsigned int pixel_sum;
-	unsigned int sub_pixel_sum;
-	unsigned int win_l;
-	unsigned int win_r;
-	unsigned int win_t;
-	unsigned int win_b;
-	unsigned int alert_r;
-	unsigned int alert_g;
-	unsigned int alert_b;
-	unsigned int cur_gain;
-	unsigned int pre_gain;
-	unsigned int max_gain;
-	unsigned int min_gain;
-	unsigned int max_step;
-	unsigned int cur_step;
-	unsigned int countlimit_r;	
-	unsigned int countlimit_g;
-	unsigned int countlimit_b;
-	unsigned int tf_ratio;
-    unsigned int change_step;
-	unsigned int max_lumasum1;  //low
-	unsigned int max_lumasum2;
-	unsigned int max_lumasum3;
-	unsigned int max_lumasum4;	//high
-	int targ;
-
-	isp_auto_exposure_state_t isp_ae_state;
-}isp_ae_sm_t;
-
-typedef enum isp_awb_status_s {
-	ISP_AWB_STATUS_NULL = 0,
-	ISP_AWB_STATUS_UNSTABLE,	
-	ISP_AWB_STATUS_STABLE,
-}isp_awb_status_t;
-
-typedef struct isp_awb_sm_s {
-	enum isp_awb_status_s status;
-	unsigned int pixel_sum;
-	unsigned int win_l;
-	unsigned int win_r;
-	unsigned int win_t;
-	unsigned int win_b;
-	unsigned int countlimitrgb;
-	unsigned int countlimityh;
-	unsigned int countlimitym;
-	unsigned int countlimityl;	
-
-	unsigned int countlimityuv;
-	unsigned char y;
-	unsigned char w;
-	unsigned char coun;
-	
-	isp_auto_white_balance_state_t isp_awb_state;
-
-}isp_awb_sm_t;
-
-typedef enum isp_flash_status_s {
-	ISP_FLASH_STATUS_NULL = 0,
-	ISP_FLASH_STATUS_ON,
-	ISP_FLASH_STATUS_OFF,
-}isp_flash_status_t;
-
-typedef enum isp_env_status_s {
-	ENV_NULL = 0,
-	ENV_HIGH,
-	ENV_MID,
-	ENV_LOW,
-}isp_env_status_t;
-typedef struct isp_af_sm_s {
-	af_state_t state;
-} isp_af_sm_t;
-
-typedef struct isp_capture_sm_s {
-	unsigned int adj_cnt;
-	unsigned int max_ac_sum;
-	unsigned int tr_time; 
-	unsigned int fr_time;
-	unsigned char flash_on;
-	flash_mode_t  flash_mode;
-	isp_capture_state_t capture_state;	
-} isp_capture_sm_t;
-
-typedef struct isp_sm_s {
-	enum isp_ae_status_s status;
-	enum isp_flash_status_s flash;
-	enum isp_env_status_s env;
-	bool ae_down;
-	af_state_t af_state;
-	isp_ae_sm_t isp_ae_parm;
-	isp_awb_sm_t isp_awb_parm;
-	isp_af_sm_t af_sm;
-	isp_capture_sm_t cap_sm;
-} isp_sm_t;
-
-typedef struct isp_ae_to_sensor_s {
-	volatile unsigned int send;
-	volatile unsigned int new_step;
-	volatile unsigned int shutter;
-	volatile unsigned int gain;
-} isp_ae_to_sensor_t;
-
-extern void isp_sm_init(isp_dev_t *devp);
-extern void isp_sm_uninit(isp_dev_t *devp);
-extern void af_sm_init(isp_dev_t *devp);
-extern void capture_sm_init(isp_dev_t *devp);
-extern void isp_set_flash_mode(isp_dev_t *devp);
-extern void isp_ae_sm(isp_dev_t *devp);
-extern void isp_awb_sm(isp_dev_t *devp);
-extern void isp_af_fine_tune(isp_dev_t *devp);
-extern void isp_af_detect(isp_dev_t *devp);
-extern int isp_capture_sm(isp_dev_t *devp);
-extern unsigned long long div64(unsigned long long n, unsigned long long d);
-extern void isp_af_save_current_para(isp_dev_t *devp);
-extern void isp_set_manual_exposure(isp_dev_t *devp);
-extern unsigned int isp_tune_exposure(isp_dev_t *devp);
-#endif
-
-
diff --git a/drivers/amlogic/tvin/isp/isp_tool.h b/drivers/amlogic/tvin/isp/isp_tool.h
deleted file mode 100644
index e69de29bb2d1..000000000000
diff --git a/drivers/amlogic/tvin/it660x/Kconfig b/drivers/amlogic/tvin/it660x/Kconfig
deleted file mode 100755
index 69d1ac05482f..000000000000
--- a/drivers/amlogic/tvin/it660x/Kconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-#Hdmirx It660xin Device Driver Configuration
-#
-config  AM_HDMI_REPEATER
-	bool 
-	default n
-
-config TVIN_IT660X
-    tristate "Amlogic IT660XIN device driver" 
-    default  n
-    select AM_HDMI_REPEATER
-    help
-         Amlogic IT660XIN device driver.
-
diff --git a/drivers/amlogic/tvin/it660x/Makefile b/drivers/amlogic/tvin/it660x/Makefile
deleted file mode 100755
index 9fbf216e1d7d..000000000000
--- a/drivers/amlogic/tvin/it660x/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-#
-#Makefile for it660xin
-#
-obj-$(CONFIG_TVIN_IT660X) += tvin_it660x.o
-tvin_it660x-objs := it660x_fe.o it660x_drv.o it660x_i2c.o hdmirx.o csc.o edid.o hdmirx_repeater.o sha1.o
diff --git a/drivers/amlogic/tvin/it660x/config.h b/drivers/amlogic/tvin/it660x/config.h
deleted file mode 100755
index 8b55f3829b3f..000000000000
--- a/drivers/amlogic/tvin/it660x/config.h
+++ /dev/null
@@ -1,38 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <config.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-#ifndef _CONFIG_H_
-#define _CONFIG_H_
-
-#define SUPPORT_INPUTRGB
-#define SUPPORT_INPUTYUV444
-#define SUPPORT_INPUTYUV422
-
-#if defined(SUPPORT_INPUTYUV444)|| defined(SUPPORT_INPUTYUV422)
-#define SUPPORT_INPUTYUV
-#endif
-
-
-#define SUPPORT_OUTPUTYUV
-#define SUPPORT_OUTPUTYUV444
-#define SUPPORT_OUTPUTYUV422
-#if (defined(SUPPORT_OUTPUTYUV444))||(defined(SUPPORT_OUTPUTYUV422))
-#define SUPPORT_OUTPUTYUV
-#endif
-
-#define SUPPORT_OUTPUTRGB
-
-#define LOOP_MSEC 20
-// 2010/01/26 added a option to disable HDCP.
-// #define _COPY_EDID_
-// #define DISABLE_COLOR_DEPTH_RESET
-
-#endif // _CONFIG_H_
diff --git a/drivers/amlogic/tvin/it660x/csc.c b/drivers/amlogic/tvin/it660x/csc.c
deleted file mode 100755
index b79bc8bd14f4..000000000000
--- a/drivers/amlogic/tvin/it660x/csc.c
+++ /dev/null
@@ -1,86 +0,0 @@
-///*****************************************
-//  Copyright (C)2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <csc.c>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2010/09/01
-//   @fileversion: COMMON_FILE_1.00
-//******************************************/
-
-
-#include "mcu.h"
-#include "config.h"
-#include "typedef.h"
-
-BYTE _CODE bCSCOffset_16_235[] =
-{
-    0x00,0x80,0x00
-};
-
-BYTE _CODE bCSCOffset_0_255[] =
-{
-    0x10,0x80,0x10
-};
-
-
-#if (defined (SUPPORT_OUTPUTYUV))&& (defined (SUPPORT_INPUTRGB))
-    BYTE _CODE bCSCMtx_RGB2YUV_ITU601_16_235[] =
-    {
-        0xB2,0x04,0x64,0x02,0xE9,0x00,
-        0x93,0x3C,0x18,0x04,0x56,0x3F,
-        0x49,0x3D,0x9F,0x3E,0x18,0x04
-    } ;
-
-    BYTE _CODE bCSCMtx_RGB2YUV_ITU601_0_255[] =
-    {
-        0x09,0x04,0x0E,0x02,0xC8,0x00,
-        0x0E,0x3D,0x84,0x03,0x6E,0x3F,
-        0xAC,0x3D,0xD0,0x3E,0x84,0x03
-    } ;
-
-    BYTE _CODE bCSCMtx_RGB2YUV_ITU709_16_235[] =
-    {
-        0xB8,0x05,0xB4,0x01,0x93,0x00,
-        0x49,0x3C,0x18,0x04,0x9F,0x3F,
-        0xD9,0x3C,0x10,0x3F,0x18,0x04
-    } ;
-
-    BYTE _CODE bCSCMtx_RGB2YUV_ITU709_0_255[] =
-    {
-        0xE5,0x04,0x78,0x01,0x81,0x00,
-        0xCE,0x3C,0x84,0x03,0xAE,0x3F,
-        0x49,0x3D,0x33,0x3F,0x84,0x03
-    } ;
-#endif
-
-#if (defined (SUPPORT_OUTPUTRGB))&& (defined (SUPPORT_INPUTYUV))
-    BYTE _CODE bCSCMtx_YUV2RGB_ITU601_16_235[] =
-    {
-        0x00,0x08,0x6A,0x3A,0x4F,0x3D,
-        0x00,0x08,0xF7,0x0A,0x00,0x00,
-        0x00,0x08,0x00,0x00,0xDB,0x0D
-    } ;
-
-    BYTE _CODE bCSCMtx_YUV2RGB_ITU601_0_255[] =
-    {
-        0x4F,0x09,0x81,0x39,0xDF,0x3C,
-        0x4F,0x09,0xC2,0x0C,0x00,0x00,
-        0x4F,0x09,0x00,0x00,0x1E,0x10
-    } ;
-
-    BYTE _CODE bCSCMtx_YUV2RGB_ITU709_16_235[] =
-    {
-        0x00,0x08,0x53,0x3C,0x89,0x3E,
-        0x00,0x08,0x51,0x0C,0x00,0x00,
-        0x00,0x08,0x00,0x00,0x87,0x0E
-    } ;
-
-    BYTE _CODE bCSCMtx_YUV2RGB_ITU709_0_255[] =
-    {
-        0x4F,0x09,0xBA,0x3B,0x4B,0x3E,
-        0x4F,0x09,0x56,0x0E,0x00,0x00,
-        0x4F,0x09,0x00,0x00,0xE7,0x10
-    } ;
-#endif
diff --git a/drivers/amlogic/tvin/it660x/debug.h b/drivers/amlogic/tvin/it660x/debug.h
deleted file mode 100755
index d5a3064138c2..000000000000
--- a/drivers/amlogic/tvin/it660x/debug.h
+++ /dev/null
@@ -1,62 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <debug.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-#ifndef _DEBUG_H_
-#define _DEBUG_H_
-
-#define Debug_message
-#ifndef Debug_message
-	#pragma message("not DEFINED DEBUG in debug.h")
-	#define HDMITX_DEBUG_PRINTF(x)
-	#define HDMITX_DEBUG_PRINTF1(x)
-	#define HDMITX_DEBUG_PRINTF2(x)
-	#define HDMITX_DEBUG_PRINTF3(x)
-	#define HDMIRX_DEBUG_PRINTF(x)
-	#define HDMIRX_DEBUG_PRINTF1(x)
-	#define HDMIRX_DEBUG_PRINTF2(x)
-	#define HDMIRX_DEBUG_PRINTF3(x)
-	#define EDID_DEBUG_PRINTF(x)
-	#define EDID_DEBUG_PRINTF1(x)
-	#define EDID_DEBUG_PRINTF2(x)
-	#define EDID_DEBUG_PRINTF3(x)
-    #define VGA_DEBUG_PRINTF(x)
-
-    #define HDCP_DEBUG_PRINTF(x)
-    #define HDCP_DEBUG_PRINTF1(x)
-    #define HDCP_DEBUG_PRINTF2(x)
-#else // DEBUG
-#pragma message("DEFINED DEBUG in debug.h")
-
-	#define HDMITX_DEBUG_PRINTF(x) // printf x
-	#define HDMIRX_DEBUG_PRINTF(x) printk x
-	// #define HDMITX_DEBUG_PRINTF(x)
-	// #define HDMIRX_DEBUG_PRINTF(x)
-
-	#define HDMITX_DEBUG_PRINTF1(x) // printf x
-	#define HDMITX_DEBUG_PRINTF2(x) // printf x
-	#define HDMITX_DEBUG_PRINTF3(x) // printf x
-	#define HDMIRX_DEBUG_PRINTF1(x) printk x
-	#define HDMIRX_DEBUG_PRINTF2(x) // printf x
-	#define HDMIRX_DEBUG_PRINTF3(x) // printf x
-
-	#define EDID_DEBUG_PRINTF(x)  printk x
-	#define EDID_DEBUG_PRINTF1(x)  // printf x
-	#define EDID_DEBUG_PRINTF2(x)  // printf x
-	#define EDID_DEBUG_PRINTF3(x)  // printf x
-
-    #define VGA_DEBUG_PRINTF(x)   // printf x
-
-    #define HDCP_DEBUG_PRINTF(x) printk x
-    #define HDCP_DEBUG_PRINTF1(x) printk x
-    #define HDCP_DEBUG_PRINTF2(x) printk x
-
-#endif
-#endif // _DEBUG_H_
diff --git a/drivers/amlogic/tvin/it660x/dvin.h b/drivers/amlogic/tvin/it660x/dvin.h
deleted file mode 100755
index fdd8c03f4d5e..000000000000
--- a/drivers/amlogic/tvin/it660x/dvin.h
+++ /dev/null
@@ -1,71 +0,0 @@
-#ifndef DVIN_H
-#define DVIN_H
-
-#define DEBUG_DVIN
-
-#ifdef DEBUG_DVIN  
-extern int hs_pol_inv;           
-extern int vs_pol_inv;           
-extern int de_pol_inv;           
-extern int field_pol_inv;        
-extern int ext_field_sel;        
-extern int de_mode;              
-extern int data_comp_map;        
-extern int mode_422to444;        
-extern int dvin_clk_inv;         
-extern int vs_hs_tim_ctrl;       
-extern int hs_lead_vs_odd_min;   
-extern int hs_lead_vs_odd_max;   
-extern int active_start_pix_fe;  
-extern int active_start_pix_fo;  
-extern int active_start_line_fe; 
-extern int active_start_line_fo; 
-extern int line_width;           
-extern int field_height; 
-#endif       
-
-extern void config_dvin (unsigned long hs_pol_inv,             // Invert HS polarity, for HW regards HS active high.
-                         unsigned long vs_pol_inv,             // Invert VS polarity, for HW regards VS active high.
-                         unsigned long de_pol_inv,             // Invert DE polarity, for HW regards DE active high.
-                         unsigned long field_pol_inv,          // Invert FIELD polarity, for HW regards odd field when high.
-                         unsigned long ext_field_sel,          // FIELD source select:
-                                                               // 1=Use external FIELD signal, ignore internal FIELD detection result;
-                                                               // 0=Use internal FIELD detection result, ignore external input FIELD signal.
-                         unsigned long de_mode,                // DE mode control:
-                                                               // 0=Ignore input DE signal, use internal detection to to determine active pixel;
-                                                               // 1=Rsrv;
-                                                               // 2=During internal detected active region, if input DE goes low, replace input data with the last good data;
-                                                               // 3=Active region is determined by input DE, no internal detection.
-                         unsigned long data_comp_map,          // Map input data to form YCbCr.
-                                                               // Use 0 if input is YCbCr;
-                                                               // Use 1 if input is YCrCb;
-                                                               // Use 2 if input is CbCrY;
-                                                               // Use 3 if input is CbYCr;
-                                                               // Use 4 if input is CrYCb;
-                                                               // Use 5 if input is CrCbY;
-                                                               // 6,7=Rsrv.
-                         unsigned long mode_422to444,          // 422 to 444 conversion control:
-                                                               // 0=No convertion; 1=Rsrv;
-                                                               // 2=Convert 422 to 444, use previous C value;
-                                                               // 3=Convert 422 to 444, use average C value.
-                         unsigned long dvin_clk_inv,           // Invert dvin_clk_in for ease of data capture.
-                         unsigned long vs_hs_tim_ctrl,         // Controls which edge of HS/VS (post polarity control) the active pixel/line is related:
-                                                               // Bit 0: HS and active pixel relation.
-                                                               //  0=Start of active pixel is counted from the rising edge of HS;
-                                                               //  1=Start of active pixel is counted from the falling edge of HS;
-                                                               // Bit 1: VS and active line relation.
-                                                               //  0=Start of active line is counted from the rising edge of VS;
-                                                               //  1=Start of active line is counted from the falling edge of VS.
-                         unsigned long hs_lead_vs_odd_min,     // For internal FIELD detection:
-                                                               // Minimum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
-                         unsigned long hs_lead_vs_odd_max,     // For internal FIELD detection:
-                                                               // Maximum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
-                         unsigned long active_start_pix_fe,    // Number of clock cycles between HS active edge to first active pixel, in even field.
-                         unsigned long active_start_pix_fo,    // Number of clock cycles between HS active edge to first active pixel, in odd field.
-                         unsigned long active_start_line_fe,   // Number of clock cycles between VS active edge to first active line, in even field.
-                         unsigned long active_start_line_fo,   // Number of clock cycles between VS active edge to first active line, in odd field.
-                         unsigned long line_width,             // Number_of_pixels_per_line
-                         unsigned long field_height);          // Number_of_lines_per_field
-
-                                              
-#endif /*DVIN_H*/
diff --git a/drivers/amlogic/tvin/it660x/edid.c b/drivers/amlogic/tvin/it660x/edid.c
deleted file mode 100755
index f05a74a0d1b8..000000000000
--- a/drivers/amlogic/tvin/it660x/edid.c
+++ /dev/null
@@ -1,532 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <edid.c>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2011/01/13
-//   @fileversion: HDMIRX_SAMPLE_2.09
-//******************************************/
-
-
-#include "mcu.h"
-#include "io.h"
-#include "edid.h"
-//#include "VGA.h"
-#ifdef Debug_message
-#define EDID_Dump
-#endif
-
-#ifdef _COPY_EDID_
-
-BYTE MeshCheckSum = 0 ;
-BYTE PrevMeshCheckSum = 0xA5 ;
-
-
-BOOL bSupport1080p = FALSE ;
-// #define SUPPORT_NOEDID_MONITOR
-
-// BYTE DTD_640x480_60P[] = { 0xD5,0x09,0x80,0xA0,0x20,0xE0,0x2D,0x10,0x10,0x60,0xA2,0x00,0xA0,0x78,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_720x480_60P[] = { 0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xB4,0x78,0x00,0x00,0x00,0x18} ;
-BYTE DTD_1280x720_60P[] = { 0x1A,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,0x55,0x00,0x40,0xB4,0x10,0x00,0x00,0x1E} ;
-BYTE DTD_1920x1080_60I[] = { 0x1A,0x1D,0x80,0x18,0x71,0x1C,0x16,0x20,0x58,0x2C,0x25,0x00,0xE0,0x87,0x10,0x00,0x00,0x9E} ;
-// BYTE DTD_720x480_60I[] = { 0x46,0x05,0xD0,0x8A,0x20,0xF0,0x16,0x00,0x13,0x3E,0x43,0x00,0xB4,0x3C,0x00,0x00,0x00,0x98} ;
-// BYTE DTD_720x240_60P[] = { 0x46,0x05,0xD0,0x8A,0x20,0xF0,0x16,0x00,0x13,0x3E,0x43,0x00,0xB4,0x3C,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_1440x480_60I[] = { 0x8C,0x0A,0xA0,0x14,0x51,0xF0,0x16,0x00,0x26,0x7C,0x53,0x00,0x68,0x3C,0x10,0x00,0x00,0x98} ;
-// BYTE DTD_1440x240_60P[] = { 0x8C,0x0A,0xA0,0x14,0x51,0xF0,0x17,0x00,0x26,0x7C,0x53,0x00,0x68,0x3C,0x10,0x00,0x00,0x18} ;
-// BYTE DTD_2880x480_60I[] = { 0x18,0x15,0x40,0x28,0xB2,0xF0,0x16,0x00,0x4C,0xF8,0x43,0x00,0xD0,0x3C,0x20,0x00,0x00,0x98} ;
-// BYTE DTD_2880x240_60P[] = { 0x18,0x15,0x40,0x28,0xB2,0xF0,0x16,0x00,0x4C,0xF8,0x43,0x00,0xD0,0x3C,0x20,0x00,0x00,0x18} ;
-// BYTE DTD_1440x480_60P[] = { 0x18,0x15,0xA0,0x14,0x51,0xE0,0x2D,0x10,0x20,0x7C,0x96,0x00,0x68,0x78,0x10,0x00,0x00,0x18} ;
-BYTE DTD_1920x1080_60P[] = { 0xF3,0x39,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xE0,0x0E,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_720x576_50P[] = { 0x8C,0x0A,0xD0,0x90,0x20,0x40,0x31,0x20,0x0C,0x40,0x55,0x00,0xB4,0x90,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_1280x720_50P[] = { 0x1A,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,0x40,0x40,0xB4,0x10,0x00,0x00,0x1E} ;
-BYTE DTD_1920x1080_50I[] = { 0x1A,0x1D,0x80,0xD0,0x72,0x1C,0x16,0x20,0x10,0x2C,0x25,0x80,0xE0,0x87,0x10,0x00,0x00,0x9E} ;
-// BYTE DTD_720x576_50I[] = { 0x46,0x05,0xD0,0x90,0x20,0x20,0x18,0x10,0x0C,0x3F,0x23,0x00,0xB4,0x48,0x00,0x00,0x00,0x98} ;
-// BYTE DTD_1440x576_50I[] = { 0x8C,0x0A,0xA0,0x20,0x51,0x20,0x18,0x10,0x18,0x7E,0x23,0x00,0x68,0x48,0x10,0x00,0x00,0x98} ;
-// BYTE DTD_720x288_50P[] = { 0x46,0x05,0xD0,0x90,0x20,0x20,0x18,0x10,0x0C,0x3F,0x23,0x00,0xB4,0x48,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_1440x288_50P[] = { 0x8C,0x0A,0xA0,0x20,0x51,0x20,0x19,0x10,0x18,0x7E,0x33,0x00,0x68,0x48,0x10,0x00,0x00,0x18} ;
-// BYTE DTD_2880x576_50I[] = { 0x18,0x15,0x40,0x40,0xB2,0x20,0x18,0x10,0x30,0xFC,0x23,0x00,0xD0,0x48,0x20,0x00,0x00,0x98} ;
-// BYTE DTD_2880x288_50P[] = { 0x18,0x15,0x40,0x40,0xB2,0x20,0x18,0x10,0x30,0xFC,0x23,0x00,0xD0,0x48,0x20,0x00,0x00,0x18} ;
-// BYTE DTD_1440x576_50P[] = { 0x18,0x15,0xA0,0x20,0x51,0x40,0x31,0x20,0x18,0x80,0x55,0x00,0x68,0x90,0x10,0x00,0x00,0x1C} ;
-BYTE DTD_1920x1080_50P[] = { 0xD0,0x39,0x80,0xD0,0x72,0x38,0x2D,0x40,0x10,0x2C,0x45,0x80,0xE0,0x0E,0x11,0x00,0x00,0x1E} ;
-BYTE DTD_1920x1080_24P[] = { 0x1A,0x1D,0x80,0x3E,0x73,0x38,0x2D,0x40,0x7E,0x2C,0x45,0x80,0xE0,0x0E,0x11,0x00,0x00,0x1E} ;
-BYTE DTD_1920x1080_25P[] = { 0x1A,0x1D,0x80,0xD0,0x72,0x38,0x2D,0x40,0x10,0x2C,0x45,0x80,0xE0,0x0E,0x11,0x00,0x00,0x1E} ;
-BYTE DTD_1920x1080_30P[] = { 0x1A,0x1D,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xE0,0x0E,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_640x350_85P[] = { 0x4E,0x0C,0x80,0xC0,0x20,0x5E,0x5F,0x10,0x20,0x40,0x03,0x08,0xA0,0x57,0x00,0x00,0x00,0x1A} ;
-// BYTE DTD_640x400_85P[] = { 0x4E,0x0C,0x80,0xC0,0x20,0x90,0x2D,0x10,0x20,0x40,0x13,0x00,0xA0,0x64,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_832x624_75P[] = { 0x60,0x16,0x40,0x40,0x31,0x70,0x2B,0x20,0x20,0x40,0x13,0x00,0xD0,0x9C,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_720x350_70P[] = { 0x10,0x0B,0xD0,0xB4,0x20,0x5E,0x63,0x10,0x12,0x6C,0xB2,0x0C,0xB4,0x57,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_720x400_70P[] = { 0x10,0x0B,0xD0,0xB4,0x20,0x90,0x31,0x10,0x12,0x6C,0xD2,0x00,0xB4,0x64,0x00,0x00,0x00,0x1C} ;
-// BYTE DTD_720x400_85P[] = { 0xDE,0x0D,0xD0,0xD8,0x20,0x90,0x2E,0x10,0x24,0x48,0x13,0x00,0xB4,0x64,0x00,0x00,0x00,0x1C} ;
-// BYTE DTD_640x480_75P[] = { 0x4E,0x0C,0x80,0xC8,0x20,0xE0,0x14,0x10,0x10,0x40,0x13,0x00,0xA0,0x78,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_640x480_85P[] = { 0x10,0x0E,0x80,0xC0,0x20,0xE0,0x1D,0x10,0x38,0x38,0x13,0x00,0xA0,0x78,0x00,0x00,0x00,0x18} ;
-// BYTE DTD_800x600_56P[] = { 0x10,0x0E,0x20,0xE0,0x30,0x58,0x19,0x20,0x18,0x48,0x12,0x00,0xC8,0x96,0x00,0x00,0x00,0x1E} ;
-// BYTE DTD_800x600_60P[] = { 0xA0,0x0F,0x20,0x00,0x31,0x58,0x1C,0x20,0x28,0x80,0x14,0x00,0xC8,0x96,0x00,0x00,0x00,0x1E} ;
-// BYTE DTD_800x600_72P[] = { 0x88,0x13,0x20,0xF0,0x30,0x58,0x42,0x20,0x38,0x78,0x56,0x08,0xC8,0x96,0x00,0x00,0x00,0x1E} ;
-// BYTE DTD_800x600_75P[] = { 0x56,0x13,0x20,0x00,0x31,0x58,0x19,0x20,0x10,0x50,0x13,0x00,0xC8,0x96,0x00,0x00,0x00,0x1E} ;
-// BYTE DTD_800x600_85P[] = { 0xF9,0x15,0x20,0xF8,0x30,0x58,0x1F,0x20,0x20,0x40,0x13,0x00,0xC8,0x96,0x00,0x00,0x00,0x1E} ;
-// BYTE DTD_848x480_60P[] = { 0x2F,0x0D,0x50,0xF0,0x30,0xE0,0x25,0x10,0x10,0x70,0x68,0x00,0xD4,0x78,0x00,0x00,0x00,0x1E} ;
-// BYTE DTD_1024x768_87I[] = { 0x8A,0x11,0x00,0xF0,0x40,0x80,0x18,0x10,0x08,0xB0,0x04,0x00,0x00,0x60,0x10,0x00,0x00,0x9E} ;
-// BYTE DTD_1024x768_60P[] = { 0x64,0x19,0x00,0x40,0x41,0x00,0x26,0x30,0x18,0x88,0x36,0x00,0x00,0xC0,0x10,0x00,0x00,0x18} ;
-// BYTE DTD_1024x768_70P[] = { 0x4C,0x1D,0x00,0x30,0x41,0x00,0x26,0x30,0x18,0x88,0x36,0x00,0x00,0xC0,0x10,0x00,0x00,0x18} ;
-// BYTE DTD_1024x768_75P[] = { 0xC3,0x1E,0x00,0x20,0x41,0x00,0x20,0x30,0x10,0x60,0x13,0x00,0x00,0xC0,0x10,0x00,0x00,0x1E} ;
-// BYTE DTD_1024x768_85P[] = { 0xEA,0x24,0x00,0x60,0x41,0x00,0x28,0x30,0x30,0x60,0x13,0x00,0x00,0xC0,0x10,0x00,0x00,0x1E} ;
-// BYTE DTD_1152x864_75P[] = { 0x30,0x2A,0x80,0xC0,0x41,0x60,0x24,0x30,0x40,0x80,0x13,0x00,0x20,0xD8,0x10,0x00,0x00,0x1E} ;
-// BYTE DTD_1280x768_60PR[] = { 0xA9,0x1A,0x00,0xA0,0x50,0x00,0x16,0x30,0x30,0x20,0x37,0x00,0x40,0xC0,0x10,0x00,0x00,0x1A} ;
-// BYTE DTD_1280x768_60PW[] = { 0x0E,0x1F,0x00,0x80,0x51,0x00,0x1E,0x30,0x40,0x80,0x37,0x00,0x40,0xC0,0x10,0x00,0x00,0x1C} ;
-// BYTE DTD_1280x768_75P[] = { 0xF1,0x27,0x00,0xA0,0x51,0x00,0x25,0x30,0x50,0x80,0x37,0x00,0x40,0xC0,0x10,0x00,0x00,0x1C} ;
-// BYTE DTD_1280x768_85P[] = { 0xE6,0x2D,0x00,0xB0,0x51,0x00,0x29,0x30,0x50,0x88,0x37,0x00,0x40,0xC0,0x10,0x00,0x00,0x1C} ;
-// BYTE DTD_1280x960_60P[] = { 0x30,0x2A,0x00,0x08,0x52,0xC0,0x28,0x30,0x60,0x70,0x13,0x00,0x40,0xF0,0x10,0x00,0x00,0x1E} ;
-// BYTE DTD_1280x960_85P[] = { 0x02,0x3A,0x00,0xC0,0x51,0xC0,0x33,0x30,0x40,0xA0,0x13,0x00,0x40,0xF0,0x10,0x00,0x00,0x1E} ;
-// BYTE DTD_1280x1024_60P[] = { 0x30,0x2A,0x00,0x98,0x51,0x00,0x2A,0x40,0x30,0x70,0x13,0x00,0x40,0x00,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1280x1024_75P[] = { 0xBC,0x34,0x00,0x98,0x51,0x00,0x2A,0x40,0x10,0x90,0x13,0x00,0x40,0x00,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1280x1024_85P[] = { 0x86,0x3D,0x00,0xC0,0x51,0x00,0x30,0x40,0x40,0xA0,0x13,0x00,0x40,0x00,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1360x768_60P[] = { 0x66,0x21,0x50,0xB0,0x51,0x00,0x1B,0x30,0x40,0x70,0x36,0x00,0x54,0xC0,0x10,0x00,0x00,0x1E} ;
-// BYTE DTD_1400x1050_60PR[] = { 0x74,0x27,0x78,0xA0,0x50,0x1A,0x1E,0x40,0x30,0x20,0x34,0x00,0x5E,0x06,0x11,0x00,0x00,0x1A} ;
-// BYTE DTD_1400x1050_60PW[] = { 0x8F,0x2F,0x78,0xD0,0x51,0x1A,0x27,0x40,0x58,0x90,0x34,0x00,0x5E,0x06,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1400x1050_75P[] = { 0xF0,0x3C,0x78,0xF0,0x51,0x1A,0x31,0x40,0x68,0x90,0x34,0x00,0x5E,0x06,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1400x1050_85P[] = { 0x1E,0x46,0x78,0x00,0x52,0x1A,0x37,0x40,0x68,0x98,0x34,0x00,0x5E,0x06,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1440x900_60PR[] = { 0xAB,0x22,0xA0,0xA0,0x50,0x84,0x1A,0x30,0x30,0x20,0x36,0x00,0x68,0xE1,0x10,0x00,0x00,0x1A} ;
-// BYTE DTD_1440x900_60PW[] = { 0x9A,0x29,0xA0,0xD0,0x51,0x84,0x22,0x30,0x50,0x98,0x36,0x00,0x68,0xE1,0x10,0x00,0x00,0x1C} ;
-// BYTE DTD_1440x900_75P[] = { 0x6B,0x35,0xA0,0xF0,0x51,0x84,0x2A,0x30,0x60,0x98,0x36,0x00,0x68,0xE1,0x10,0x00,0x00,0x1C} ;
-// BYTE DTD_1440x900_85P[] = { 0x54,0x3D,0xA0,0x00,0x52,0x84,0x30,0x30,0x68,0x98,0x36,0x00,0x68,0xE1,0x10,0x00,0x00,0x1C} ;
-BYTE DTD_1600x1200_60P[] = { 0x48,0x3F,0x40,0x30,0x62,0xB0,0x32,0x40,0x40,0xC0,0x13,0x00,0x90,0x2C,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1600x1200_65P[] = { 0x8E,0x44,0x40,0x30,0x62,0xB0,0x32,0x40,0x40,0xC0,0x13,0x00,0x90,0x2C,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1600x1200_70P[] = { 0xD4,0x49,0x40,0x30,0x62,0xB0,0x32,0x40,0x40,0xC0,0x13,0x00,0x90,0x2C,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1600x1200_75P[] = { 0x1A,0x4F,0x40,0x30,0x62,0xB0,0x32,0x40,0x40,0xC0,0x13,0x00,0x90,0x2C,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1600x1200_85P[] = { 0xA6,0x59,0x40,0x30,0x62,0xB0,0x32,0x40,0x40,0xC0,0x13,0x00,0x90,0x2C,0x11,0x00,0x00,0x1E} ;
-// BYTE DTD_1680x1050_60PR[] = { 0x7C,0x2E,0x90,0xA0,0x60,0x1A,0x1E,0x40,0x30,0x20,0x36,0x00,0xA4,0x06,0x11,0x00,0x00,0x1A} ;
-// BYTE DTD_1680x1050_60PW[] = { 0x21,0x39,0x90,0x30,0x62,0x1A,0x27,0x40,0x68,0xB0,0x36,0x00,0xA4,0x06,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1680x1050_75P[] = { 0x0C,0x49,0x90,0x50,0x62,0x1A,0x31,0x40,0x78,0xB0,0x36,0x00,0xA4,0x06,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1680x1050_85P[] = { 0xE3,0x53,0x90,0x60,0x62,0x1A,0x37,0x40,0x80,0xB0,0x36,0x00,0xA4,0x06,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1792x1344_60P[] = { 0xFB,0x4F,0x00,0x90,0x72,0x40,0x32,0x50,0x80,0xC8,0x13,0x00,0xC0,0x50,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1792x1344_75P[] = { 0xF4,0x65,0x00,0x98,0x72,0x40,0x49,0x50,0x60,0xD8,0x13,0x00,0xC0,0x50,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1856x1392_60P[] = { 0x41,0x55,0x40,0xA0,0x72,0x70,0x2F,0x50,0x60,0xE0,0x13,0x00,0xD0,0x5C,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1856x1392_75P[] = { 0x80,0x70,0x40,0xC0,0x72,0x70,0x6C,0x50,0x80,0xE0,0x13,0x00,0xD0,0x5C,0x11,0x00,0x00,0x1C} ;
-BYTE DTD_1920x1200_60PR[] = { 0x28,0x3C,0x80,0xA0,0x70,0xB0,0x23,0x40,0x30,0x20,0x36,0x00,0xE0,0x2C,0x11,0x00,0x00,0x1A} ;
-// BYTE DTD_1920x1200_60PW[] = { 0x7D,0x4B,0x80,0xA0,0x72,0xB0,0x2D,0x40,0x88,0xC8,0x36,0x00,0xE0,0x2C,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1920x1200_75P[] = { 0xCD,0x5F,0x80,0xB0,0x72,0xB0,0x37,0x40,0x88,0xD0,0x36,0x00,0xE0,0x2C,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1920x1200_85P[] = { 0xDD,0x6D,0x80,0xC0,0x72,0xB0,0x3E,0x40,0x90,0xD0,0x36,0x00,0xE0,0x2C,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1920x1440_60P[] = { 0x68,0x5B,0x80,0xA8,0x72,0xA0,0x3C,0x50,0x80,0xD0,0x13,0x00,0xE0,0x68,0x11,0x00,0x00,0x1C} ;
-// BYTE DTD_1920x1440_75P[] = { 0x04,0x74,0x80,0xD0,0x72,0xA0,0x3C,0x50,0x90,0xE0,0x13,0x00,0xE0,0x68,0x11,0x00,0x00,0x1C} ;
-
-#define EDID_Page_Size 16
-#if 0
-BYTE Default_EDID0[] =
-{
-    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
-    0x26,0x85,0x06,0x65,0x00,0x00,0x00,0x00,
-    0x1E,0x12,
-              0x01,0x03,0x80,
-                             0x3C,0x22,0x78,
-    0x28,0x03,0x20,0xA7,0x55,0x45,0x96,0x24,
-    0x11,0x49,0x4B,
-                   0x21,0x08,0x00,
-                                  0x01,0x01,
-    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-    0x01,0x01,0x01,0x01,0x01,0x01,
-#if 1
-                                  0x64,0x19, // just enable 1024x768@60 as DTD.
-    0x00,0x40,0x41,0x00,0x26,0x30,0x18,0x88,
-    0x36,0x00,0x00,0xC0,0x10,0x00,0x00,0x18,
-#else
-    0x48,0x3F,0x40,0x30,0x62,0xB0,0x32,0x40,0x40,0xC0,0x13,0x00,0x90,0x2C,0x11,0x00,0x00,0x1E,//1600x1200
-#endif
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,
-              0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,
-                        0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,
-    #ifndef DISABLE_HDMI_EDID
-                                  0x01,0x2F
-    #else
-                                  0x00,0x30
-    #endif
-};
-
-
-/////////////////////////////////////////////////
-//BLOCK 1 --HDMI--
-/////////////////////////////////////////////////
-#ifndef DISABLE_AUDIO_SUPPORT
-#pragma message("Audio support EDID1.")
-BYTE Default_EDID1[] = {
-#define USE_640x480
-#ifdef USE_640x480
-0x02,0x03,0x14,0x41,
-0x41,0x81,
-#else
-0x02,0x03,0x15,0x41,
-0x42,0x84,0x02,
-#endif
-0x23,0x09,0x07,0x07,
-0x65,0x03,0x0c,0x00,0x10,0x00,
-0x83,0x01,0x00,0x00,
-
-#ifdef USE_640x480
-0xD5,0x09,0x80,0xA0,0x20,0xE0,0x2D,0x10,0x10,0x60,0xA2,0x00,0xA0,0x78,0x00,0x00,0x00,0x18,
-#else
-0x1A, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x40, 0xB4, 0x10, 0x00, 0x00, 0x1E,//1280x720p
-#endif
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x25
-};
-//BYTE Default_EDID1[] = {
-//0x02,0x03,0x1a,0x41,
-//0x47,0x90,0x04,0x03,0x02,0x07,0x16,0x01,
-//0x23,0x09,0x07,0x07,
-//0x65,0x03,0x0c,0x00,0x10,0x00,
-//0x83,0x01,0x00,0x00,
-//
-//0x02,0x3a,0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c,0x45,0x00,0x07,0x44,0x21,0x00,0x00,0x1e,
-//0x01,0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20,0x6e,0x28,0x55,0x00,0x07,0x44,0x21,0x00,0x00,0x1e,
-//0x8c,0x0a,0xd0,0x8a,0x20,0xe0,0x2d,0x10,0x10,0x3e,0x96,0x00,0x07,0x44,0x21,0x00,0x00,0x18,
-//0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-//0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-//0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23
-//};
-// BYTE weakDefault_EDID1[] = {
-// 0x02,0x03,0x19,0x41,
-// 0x46,0x84,0x03,0x02,0x07,0x16,0x01,
-// 0x23,0x09,0x07,0x07,
-// 0x65,0x03,0x0c,0x00,0x10,0x00,
-// 0x83,0x01,0x00,0x00,
-//
-// 0x01,0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20,0x6e,0x28,0x55,0x00,0x07,0x44,0x21,0x00,0x00,0x1e,
-// 0x8c,0x0a,0xd0,0x8a,0x20,0xe0,0x2d,0x10,0x10,0x3e,0x96,0x00,0x07,0x44,0x21,0x00,0x00,0x18,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23
-// };
-#else // DISABLE_AUDIO_SUPPORT
-#pragma message("Audio not support EDID1.")
-BYTE Default_EDID1[] = {
-0x02,0x03,0x10,0x01,
-0x41,0x81,
-0x65,0x03,0x0c,0x00,0x10,0x00,
-0x83,0x01,0x00,0x00,
-
-0xD5,0x09,0x80,0xA0,0x20,0xE0,0x2D,0x10,0x10,0x60,0xA2,0x00,0xA0,0x78,0x00,0x00,0x00,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0,0,0,0,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x25
-};
-// BYTE Default_EDID1[] = {
-// 0x02,0x03,0x16,0x01,
-// 0x47,0x90,0x04,0x03,0x02,0x07,0x16,0x01,
-// 0x65,0x03,0x0c,0x00,0x10,0x00,
-// 0x83,0x01,0x00,0x00,
-//
-// 0x02,0x3a,0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c,0x45,0x00,0x07,0x44,0x21,0x00,0x00,0x1e,
-// 0x01,0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20,0x6e,0x28,0x55,0x00,0x07,0x44,0x21,0x00,0x00,0x1e,
-// 0x8c,0x0a,0xd0,0x8a,0x20,0xe0,0x2d,0x10,0x10,0x3e,0x96,0x00,0x07,0x44,0x21,0x00,0x00,0x18,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x23
-// };
-//
-// BYTE weakDefault_EDID1[] = {
-// 0x02,0x03,0x16,0x01,
-// 0x47,0x05,0x84,0x03,0x02,0x07,0x16,0x01,
-// 0x65,0x03,0x0c,0x00,0x10,0x00,
-// 0x83,0x01,0x00,0x00,
-//
-// 0x01,0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20,0x6e,0x28,0x55,0x00,0x07,0x44,0x21,0x00,0x00,0x1e,
-// 0x8c,0x0a,0xd0,0x8a,0x20,0xe0,0x2d,0x10,0x10,0x3e,0x96,0x00,0x07,0x44,0x21,0x00,0x00,0x18,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-// 0x23
-// };
-#endif // DISABLE_AUDIO_SUPPORT
-#else
-BYTE Default_EDID0[] =
-{
-0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x4C,0x2D,0xAC,0x06,0x01,0x00,0x00,0x00,
-0x34,0x13,0x01,0x03,0x80,0x66,0x39,0x78,0x0A,0xEE,0x91,0xA3,0x54,0x4C,0x99,0x26,
-0x0F,0x50,0x54,0xBD,0xEF,0x80,0x71,0x4F,0x81,0x00,0x81,0x40,0x81,0x80,0x95,0x00,
-0x95,0x0F,0xB3,0x00,0xA9,0x40,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,
-0x45,0x00,0xA0,0x5A,0x00,0x00,0x00,0x1E,0x66,0x21,0x50,0xB0,0x51,0x00,0x1B,0x30,
-0x40,0x70,0x36,0x00,0xA0,0x5A,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0xFD,0x00,0x18,
-0x4B,0x1A,0x51,0x17,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
-0x00,0x53,0x41,0x4D,0x53,0x55,0x4E,0x47,0x0A,0x20,0x20,0x20,0x20,0x20,0x01,0x59,
-};
-
-BYTE Default_EDID1[] =
-{
-0x02,0x03,0x33,0xF1,0x46,0x90,0x04,0x05,0x03,0x20,0x22,0x23,0x09,0x07,0x07,0x83,
-0x01,0x00,0x00,0xE2,0x00,0x0F,0xE3,0x05,0x03,0x01,0x78,0x03,0x0C,0x00,0x10,0x00,
-0xB8,0x2D,0x20,0xC0,0x0E,0x01,0x00,0x00,0x12,0x18,0x20,0x28,0x20,0x38,0x20,0x58,
-0x20,0x68,0x20,0x01,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,0x55,0x00,0xA0,
-0x5A,0x00,0x00,0x00,0x1E,0x01,0x1D,0x80,0x18,0x71,0x1C,0x16,0x20,0x58,0x2C,0x25,
-0x00,0xA0,0x5A,0x00,0x00,0x00,0x9E,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,
-0x3E,0x96,0x00,0xA0,0x5A,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF4,
-};
-#endif
-
-#ifdef EDID_Dump
-void DumpEDID(BYTE *dEDID)
-{
-    BYTE i;
-    for(i=0;i<0x80;i++)
-    {
-        if((i%16)==0)
-            EDID_DEBUG_PRINTF(("\n"));
-        if(dEDID[i]<0x10)
-            EDID_DEBUG_PRINTF(("0"));
-        EDID_DEBUG_PRINTF(("%x  ",(WORD)dEDID[i]));
-    }
-    EDID_DEBUG_PRINTF(("\n"));
-}
-#endif
-
-
-BYTE Read_OneBlock_EDID(BYTE *rEDID, BYTE uBlock, BYTE EDIDdev)
-{
-
-    BYTE i;
-    BOOL EDID_Reading;
-
-    BYTE CheckSum =0;
-
-    for(i=0;i<0x80;i+=0x10)
-    {             // Read EDID
-        #ifdef On_Chip_EDID
-        if(EDIDdev == ExtEDID)
-        EDID_Reading=EDID_READ_BYTE(EXT_EDIDADR, i+(uBlock*0x80), 0x10,  &rEDID[i], EDIDdev);
-        else
-        #endif
-        EDID_Reading=EDID_READ_BYTE(EDIDADR, i+(uBlock*0x80), 0x10,  &rEDID[i], EDIDdev);
-        if(EDID_Reading== TRUE)
-            continue;
-        else
-        {
-            #ifdef EDID_Dump
-            EDID_DEBUG_PRINTF(("Read EIDI[%x] = %x\n",(WORD)i,(WORD)rEDID[i]));
-            #endif
-            return Ext_EDID_Read_Fail;
-        }
-    }
-
-    for(i=0;i<0x80;i++)
-    {
-        CheckSum+=rEDID[i];
-    }
-#ifdef EDID_Dump
-        EDID_DEBUG_PRINTF(("========Read EDID Block %x ========\n",(WORD)uBlock));
-        EDID_DEBUG_PRINTF(("CheckSum=%X\n",(WORD)CheckSum));
-        DumpEDID(rEDID);
-#endif
-    if(CheckSum!=0)
-    {
-#ifdef EDID_Dump
-        EDID_DEBUG_PRINTF(("================================\n"));
-        EDID_DEBUG_PRINTF(("||                            ||\n"));
-        EDID_DEBUG_PRINTF(("||                            ||\n"));
-        EDID_DEBUG_PRINTF(("||   Check Sum Error          ||\n"));
-        EDID_DEBUG_PRINTF(("||                            ||\n"));
-        EDID_DEBUG_PRINTF(("||                            ||\n"));
-        EDID_DEBUG_PRINTF(("================================\n"));
-#endif
-        return Int_EDID_CheckSum_Fail;
-    }
-    return EDID_Read_Success;				 // EDID OK return
-}
-void EDIDWP(BOOL wp)
-{
-    if(wp)
-        EDID_WP=1;
-    else
-        EDID_WP=0;
-}
-
-BYTE Write_OneBlock_EDID(BYTE *wEDID, BYTE uBlock)
-{
-	BYTE i;
-    EDIDWP(FALSE);
-    //==================================================================
-    wEDID[0x7F] = 0;
-    for(i=0;i<0x7F;i++)
-    {
-        wEDID[0x7F] -= wEDID[i];
-    }
-#ifdef EDID_Dump
-    EDID_DEBUG_PRINTF(("========EDID buf Data %x ========\n",(WORD)uBlock));
-    DumpEDID(wEDID);
-    //==================================================================
-#endif
-	for(i=0;i<0x80;i+=EDID_Page_Size)
-    {
-        BYTE cCheckLimCnt,cNumCnt,ByteAddress,ReadErrorCnt;
-        BYTE cCheckData[EDID_Page_Size];
-        BOOL bWriteSuccess;
-        #ifdef EDID_Dump
-        EDID_DEBUG_PRINTF1(("========EDID block-%x-%x========",(WORD)uBlock,(WORD)i));
-        #endif
-        cCheckLimCnt = 3;
-        while(cCheckLimCnt--)
-        {
-            ByteAddress = i+(uBlock*0x80);
-            ReadErrorCnt = 100;
-        #ifdef On_Chip_EDID
-            EDID_WRITE_BYTE( EDIDADR,ByteAddress ,EDID_Page_Size, &wEDID[i],  RXDEV);
-            while(!EDID_READ_BYTE(EDIDADR,ByteAddress, EDID_Page_Size, cCheckData, RXDEV)&&(ReadErrorCnt))
-                ReadErrorCnt--;
-        #else
-            EDID_WRITE_BYTE( EDIDADR,ByteAddress ,EDID_Page_Size, &wEDID[i],  IntEDID);
-            delay1ms(8);//8
-            while(!EDID_READ_BYTE(EDIDADR,ByteAddress, EDID_Page_Size, cCheckData, IntEDID)&&(ReadErrorCnt))
-                ReadErrorCnt--;
-        #endif
-            for(cNumCnt=0;cNumCnt<EDID_Page_Size;cNumCnt++)
-            {
-                ByteAddress = i+cNumCnt;
-                bWriteSuccess = TRUE;
-                //EDID_DEBUG_PRINTF(("ByteAddress=%x\n",(WORD)ByteAddress));
-                if(cCheckData[cNumCnt] == wEDID[ByteAddress]) continue;
-                else
-                {
-                    #ifdef EDID_Dump
-                    EDID_DEBUG_PRINTF(("cCheckData=%x vs EDID[%x]=%x\n",(WORD)cCheckData[cNumCnt],(WORD)ByteAddress,(WORD)wEDID[ByteAddress]));
-                    #endif
-                    bWriteSuccess = FALSE;
-                    //break;
-                }
-            }
-            if(bWriteSuccess) break;
-        }
-        #ifdef EDID_Dump
-        if(bWriteSuccess==FALSE)
-            EDID_DEBUG_PRINTF(("========can't write ========\n",(WORD)uBlock));
-        else
-            EDID_DEBUG_PRINTF(("\n"));
-        #endif
-	}
-   // HoldSystem();
-#ifdef EDID_Dump
-    #ifdef On_Chip_EDID
-    //==================================================================
-    Read_OneBlock_EDID(wEDID, uBlock, RXDEV);
-    //==================================================================
-    #else
-    //==================================================================
-    Read_OneBlock_EDID(wEDID, uBlock, IntEDID);
-    //==================================================================
-    #endif
-#endif
-    EDIDWP(TRUE);
-    return EDID_Write_Finish;
-}
-
-BYTE GetMeshCheckSum(BYTE *pEDIDBuff, int N)
-{
-    int i ;
-    BYTE c, checksum ;
-
-    for( i = 0, checksum = 0 ; i < N ; i++)
-    {
-        c = pEDIDBuff[i] ;
-        EDID_DEBUG_PRINTF2(("c = %02X",(int)c)) ;
-        c = rol8(c,i) ;
-        EDID_DEBUG_PRINTF2(("-> %02X",(int)c)) ;
-        EDID_DEBUG_PRINTF2(("MeshChecksum[%02X]: %02X",(int)i,(int)checksum)) ;
-        checksum ^= c ;
-        EDID_DEBUG_PRINTF2(("^%02X = %02X\n",(int)c,(int)checksum)) ;
-    }
-
-    return checksum ;
-}
-
-
-void EDID_1st_Block_Parsing(BYTE *v0EDID)
-{
-
-    BYTE i,k,flag;
-    int Detailed_PCLK=0,j=0;
-
-    v0EDID[0x12]= 0x01;
-    v0EDID[0x13]= 0x03;
-    v0EDID[0x14]= 0x80 ;
-
-    EDID_DEBUG_PRINTF(("EDID_1st_Block_Parsing\n")) ;
-
-    for(i=0x26;i<0x36;i+=2)
-    {
-        #ifdef DISABLE_STANDARD_TIMING
-            v0EDID[i] = 1 ; v0EDID[i+1] = 1 ;
-        #else
-            if( v0EDID[i] < (80-31))
-            {
-                v0EDID[i] = 0x01 ;
-                v0EDID[i+1] = 0x01 ;
-            }
-            else
-            {
-                if( (v0EDID[i+1] & 0x3F)>(85-60))
-                {
-                    v0EDID[i] = 0x01 ;
-                    v0EDID[i+1] = 0x01 ;
-                }
-            }
-        #endif
-    }
-}
-
-void CopyDefaultEDID_0()
-{
-    BYTE bEDID[0x80];
-    BYTE i,checksum;
-    checksum = 0 ;
-    for(i=0;i<0x7F;i++)
-    {
-        bEDID[i] = Default_EDID0[i];
-        checksum -= bEDID[i] ; checksum &= 0xFF ;
-    }
-    bEDID[0x7F] = checksum ;
-    #ifdef EDID_Dump
-    EDID_DEBUG_PRINTF(("CopyDefaultEDID_0\n"));
-    #endif
-    Write_OneBlock_EDID(bEDID, 0);                   // 032509 Clive
-}
-
-void CopyDefaultEDID_1()
-{
-    BYTE aEDID[0x80];
-    BYTE i,checksum;
-
-    checksum = 0 ;
-    for(i=0;i<0x7F;i++)
-    {
-        aEDID[i] = Default_EDID1[i];
-        checksum -= aEDID[i] ; checksum &= 0xFF ;
-    }
-    aEDID[0x7F] = checksum ;
-    #ifdef EDID_Dump
-    EDID_DEBUG_PRINTF(("CopyDefaultEDID_1()\n"));
-    #endif
-    Write_OneBlock_EDID(aEDID, 1);                   // 061709 Clive
-}
-
-void CopyDefaultEDID()
-{
-    CopyDefaultEDID_0();
-    CopyDefaultEDID_1();
-}
-
-#endif // _COPY_EDID_
-
diff --git a/drivers/amlogic/tvin/it660x/edid.h b/drivers/amlogic/tvin/it660x/edid.h
deleted file mode 100755
index 4899abcfb33a..000000000000
--- a/drivers/amlogic/tvin/it660x/edid.h
+++ /dev/null
@@ -1,45 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <edid.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2011/01/13
-//   @fileversion: HDMIRX_SAMPLE_2.09
-//******************************************/
-
-#ifndef _EDID_h_
-#define _EDID_h_
-#include "mcu.h"
-#include "debug.h"
-
-//#define _COPY_EDID_ 
-
-#ifdef _COPY_EDID_
-
-#define Ext_EDID_Read_Fail	    1
-#define Ext_EDID_CheckSum_Fail	2
-#define Int_EDID_Write_Fail	    3
-#define Int_EDID_Read_Fail	    4
-#define Int_EDID_CheckSum_Fail	5
-#define EDID_Read_Success   	6
-#define EDID_Copy_Success   	7
-#define EDID_Write_Finish   	8
-// #define _Block_0_Only_
-
-
-//    #message --Ext_Chip_EDID
-//======================================================
-#define rol16(x,y) (((x)<<(y%16))|((x)>>(16-(y%16))))
-#define ror16(x,y) (((x)>>(y%16))|((x)<<(16-(y%16))))
-#define rol8(x,y) (((x)<<(y%8))|((x)>>(8-(y%8))))
-#define ror8(x,y) (((x)>>(y%8))|((x)<<(8-(y%8))))
-
-#define EDIDADR			0xA0
-#define EXT_EDIDADR     0xA0
-
-void CopyDefaultEDID() ;
-#endif
-
-#endif
diff --git a/drivers/amlogic/tvin/it660x/hdmirx.c b/drivers/amlogic/tvin/it660x/hdmirx.c
deleted file mode 100755
index 383a79203680..000000000000
--- a/drivers/amlogic/tvin/it660x/hdmirx.c
+++ /dev/null
@@ -1,4645 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <hdmirx.c>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-
-
-// #define OUTPUT_CCIR656
-// #define OUTPUT_SYNC_EMBEDDED
-// #define OUTPUT_16BIT_YUV422
-// #define OUTPUT_24BIT_YUV422
-// #define OUTPUT_24BIT_YUV444
-#define OUTPUT_24BIT_RGB444
-// #define HDMI_REPEATER    // always output signal withtout tristate
-
-
-///////////////////////////////////////////////////
-// Rev 1.01
-///////////////////////////////////////////////////
-// reg6C = 0x03
-// reg6B = 0x11
-// reg3B = 0x40
-// reg6E = 0x0C
-///////////////////////////////////////////////////
-// Rev 1.09
-///////////////////////////////////////////////////
-//Reg6C=0x00
-//Reg93=0x43
-//Reg94=0x4F
-//Reg95=0x87
-//Reg96=0x33
-///////////////////////////////////////////////////
-
-
-/*********************************************************************************
- * HDMIRX HDMI RX sample code                                                   *
- *********************************************************************************/
-#include "hdmirx.h"
-
-#ifndef DEBUG_PORT_ENABLE
-#define DEBUG_PORT_ENABLE 0
-#else
-#pragma message("DEBUG_PORT_ENABLE defined\n")
-#endif
-
-
-///////////////////////////////////////////////////////////
-// Definition.
-///////////////////////////////////////////////////////////
-
-#define SetSPDIFMUTE(x) SetMUTE(~(1<<O_TRI_SPDIF),(x)?(1<<O_TRI_SPDIF):0)
-#define SetI2S3MUTE(x) SetMUTE(~(1<<O_TRI_I2S3),(x)?(1<<O_TRI_I2S3):0)
-#define SetI2S2MUTE(x) SetMUTE(~(1<<O_TRI_I2S2),(x)?(1<<O_TRI_I2S2):0)
-#define SetI2S1MUTE(x) SetMUTE(~(1<<O_TRI_I2S1),(x)?(1<<O_TRI_I2S1):0)
-#define SetI2S0MUTE(x) SetMUTE(~(1<<O_TRI_I2S0),(x)?(1<<O_TRI_I2S0):0)
-//#define SetALLMute() SetMUTE(B_VDO_MUTE_DISABLE,(B_VDO_MUTE_DISABLE|B_TRI_ALL))
-
-#define SwitchHDMIRXBank(x) HDMIRX_WriteI2C_Byte(REG_RX_BANK,(x)&1)
-
-
-char _CODE * VStateStr[] = {
-    "VSTATE_Off",
-    "VSTATE_PwrOff",
-    "VSTATE_SyncWait ",
-    "VSTATE_SWReset",
-    "VSTATE_SyncChecking",
-    "VSTATE_HDCPSet",
-    "VSTATE_HDCP_Reset",
-    "VSTATE_ModeDetecting",
-    "VSTATE_VideoOn",
-    "VSTATE_ColorDetectReset",
-    "VSTATE_Reserved"
-} ;
-
-char _CODE *AStateStr[] = {
-    "ASTATE_AudioOff",
-    "ASTATE_RequestAudio",
-    "ASTATE_ResetAudio",
-    "ASTATE_WaitForReady",
-    "ASTATE_AudioOn",
-    "ASTATE_Reserved"
-};
-
-
-#if defined(OUTPUT_CCIR656)
-    #pragma message("OUTPUT_CCIR656 defined")
-    #define HDMIRX_OUTPUT_MAPPING (B_OUTPUT_16BIT)
-    #define HDMIRX_OUTPUT_TYPE (B_SYNC_EMBEDDED|B_CCIR656)
-    #define HDMIRX_OUTPUT_COLORMODE (B_OUTPUT_YUV422<<O_OUTPUT_COLOR_MODE)
-#elif defined(OUTPUT_SYNC_EMBEDDED)
-    #pragma message("OUTPUT_SYNC_EMBEDDED defined")
-    #define HDMIRX_OUTPUT_MAPPING (B_OUTPUT_16BIT)
-    #define HDMIRX_OUTPUT_TYPE (B_SYNC_EMBEDDED)
-    #define HDMIRX_OUTPUT_COLORMODE (B_OUTPUT_YUV422<<O_OUTPUT_COLOR_MODE)
-#elif defined(OUTPUT_16BIT_YUV422)
-    #pragma message("OUTPUT_16BIT_YUV422 defined")
-    #define HDMIRX_OUTPUT_MAPPING (B_OUTPUT_16BIT)
-    #define HDMIRX_OUTPUT_TYPE 0
-    #define HDMIRX_OUTPUT_COLORMODE (B_OUTPUT_YUV422<<O_OUTPUT_COLOR_MODE)
-#elif defined(OUTPUT_24BIT_YUV422)
-    #pragma message("OUTPUT_24BIT_YUV422 defined")
-    #define HDMIRX_OUTPUT_MAPPING   0
-    #define HDMIRX_OUTPUT_TYPE  0
-    #define HDMIRX_OUTPUT_COLORMODE (B_OUTPUT_YUV422<<O_OUTPUT_COLOR_MODE)
-#elif defined(OUTPUT_24BIT_YUV444)
-    #pragma message("OUTPUT_24BIT_YUV444 defined")
-    #define HDMIRX_OUTPUT_MAPPING   0
-    #define HDMIRX_OUTPUT_TYPE  0
-    #define HDMIRX_OUTPUT_COLORMODE (B_OUTPUT_YUV444<<O_OUTPUT_COLOR_MODE)
-#else // if defined(OUTPUT_24BIT_RGB444)
-    #pragma message("OUTPUT_24BIT_RGB444 defined")
-    #define HDMIRX_OUTPUT_MAPPING   0
-    #define HDMIRX_OUTPUT_TYPE  0
-    #define HDMIRX_OUTPUT_COLORMODE (B_OUTPUT_RGB24<<O_OUTPUT_COLOR_MODE)
-#endif
-// 2009/02/10 added by Jau-Chih.Tseng@ite.com.tw
-#define DEFAULT_START_FIXED_AUD_SAMPLEFREQ AUDFS_192KHz
-//~Jau-Chih.Tseng@ite.com.tw 2009/02/10
-
-#ifndef I2S_DSP_SETTING
-#pragma message ("I2S_DSP_SETTING as 0x60 for 0T delay, 32bit I2S left justify audio.")
-#define I2S_DSP_SETTING 0x60
-#else
-#pragma message ("predefined I2S_DSP_SETTING ....")
-#endif
-
-// 2009/11/04  modified by jau-chih.tseng@ite.com.tw
-// marked for moving into typedef.h
-// typedef struct {
-//     WORD HActive ;
-//     WORD VActive ;
-//     WORD HTotal ;
-//     WORD VTotal ;
-//     LONG PCLK ;
-//     BYTE xCnt ;
-//     WORD HFrontPorch ;
-//     WORD HSyncWidth ;
-//     WORD HBackPorch ;
-//     BYTE VFrontPorch ;
-//     BYTE VSyncWidth ;
-//     BYTE VBackPorch ;
-//     BYTE ScanMode:1 ;
-//     BYTE VPolarity:1 ;
-//     BYTE HPolarity:1 ;
-// } HDMI_VTiming ;
-//
-// #define PROG 1
-// #define INTERLACE 0
-// #define Vneg 0
-// #define Hneg 0
-// #define Vpos 1
-// #define Hpos 1
-//~jau-chih.tseng@ite.com.tw 2009/11/04
-///////////////////////////////////////////////////////////
-// Public Data
-///////////////////////////////////////////////////////////
-BYTE	ucDVISCDToffCNT=0;		// 20091021 for VG-859 HDMI / DVI change issue
-_IDATA Video_State_Type VState = VSTATE_PwrOff ;
-_IDATA Audio_State_Type AState = ASTATE_AudioOff ;
-
-///////////////////////////////////////////////////////////
-// Global Data
-///////////////////////////////////////////////////////////
-static _IDATA USHORT VideoCountingTimer = 0 ;
-static _IDATA USHORT AudioCountingTimer = 0 ;
-static _IDATA USHORT MuteResumingTimer = 0 ;
-static BOOL MuteAutoOff = FALSE ;
-static _IDATA BYTE bGetSyncFailCount = 0 ;
-static BYTE _IDATA bOutputVideoMode = F_MODE_EN_UDFILT | F_MODE_RGB24 ;
-static BOOL EnaSWCDRRest = FALSE ;
-BYTE _XDATA bDisableAutoAVMute = 0 ;
-static BYTE ucRevision = 0xFF ;
-BYTE _XDATA bHDCPMode = 0 ;
-
-
-//2008/06/17 modified by jj_tseng@chipadvanced.com
-#ifndef LOOP_MSEC
-#define LOOP_MSEC 32
-#else
-	#pragma message ("LOOP_MSEC defined.")
-#endif
-
-#define MS_TimeOut(x)      (((x)+LOOP_MSEC-1)/LOOP_MSEC)
-// #define VSTATE_MISS_SYNC_COUNT MS_TimeOut(2000)// 2000ms, 2sec
-#define VSTATE_MISS_SYNC_COUNT MS_TimeOut(15000)// 8000ms, 8sec
-#define VSATE_CONFIRM_SCDT_COUNT MS_TimeOut(150)// 150ms // direct change into 8 times of loop.
-#define AUDIO_READY_TIMEOUT MS_TimeOut(200)
-#define AUDIO_CLEARERROR_TIMEOUT MS_TimeOut(1000)
-#define MUTE_RESUMING_TIMEOUT MS_TimeOut(2500)// 2.5 sec
-#define HDCP_WAITING_TIMEOUT MS_TimeOut(3000)// 3 sec
-#define CDRRESET_TIMEOUT MS_TimeOut(3000)// 3 sec
-#define VSTATE_SWRESET_COUNT MS_TimeOut(500)// 500ms
-#define FORCE_SWRESET_TIMEOUT  MS_TimeOut(16000)// 15000ms, 15sec
-#define VIDEO_TIMER_CHECK_COUNT MS_TimeOut(1000)
-
-#define SCDT_LOST_TIMEOUT  15
-static _XDATA USHORT SWResetTimeOut = FORCE_SWRESET_TIMEOUT;
-
-static _XDATA BYTE ucHDMIAudioErrorCount = 0 ;
-// 2009/02/10 modified by Jau-Chih.Tseng@ite.com.tw
-// static _XDATA BYTE ucAudioSampleClock = AUDFS_192KHz ; // 192KHz, to changed 48KHz
-static _XDATA BYTE ucAudioSampleClock = DEFAULT_START_FIXED_AUD_SAMPLEFREQ ; // 192KHz, to changed 48KHz
-//~Jau-Chih.Tseng@ite.com.tw 2009/02/10
-
-BOOL bIntPOL = FALSE ;
-static BOOL NewAVIInfoFrameF = FALSE ;
-static BOOL MuteByPKG = OFF ;
-static _XDATA BYTE bInputVideoMode ;
-
-// 2006/12/04 added by jj_tseng@chipadvanced.com
-static _XDATA BYTE prevAVIDB1 = 0 ;
-static _XDATA BYTE prevAVIDB2 = 0 ;
-//~jjtseng 2006/12/04
-
-static BOOL bVSIpresent=FALSE ;
-static _XDATA USHORT currHTotal ;
-static _XDATA BYTE currXcnt ;
-static BOOL currScanMode ;
-static BOOL bGetSyncInfo();
-// BYTE iVTimingIndex = 0xFF ;
-
-// 2011/10/17 added by jau-chih.tseng@ite.com.tw
-#ifndef DISABLE_COLOR_DEPTH_RESET
-static BOOL bDisableColorDepthResetState = FALSE ;
-#endif
-//~jau-chih.tseng@ite.com.tw 2011/10/17
-
-// 2011/06/15 added by jau-chih.tseng@ite.com.tw
-static BOOL bIgnoreVideoChgEvent=FALSE ;
-//~jau-chih.tseng@ite.com.tw
-
-static _XDATA AUDIO_CAPS AudioCaps ;
-
-// 2009/11/04 removed by jau-chih.tseng@ite.com.tw
-// to avoid the wrong space using on 8051 code.
-// _XDATA HDMI_VTiming code *pVTiming ;
-_XDATA HDMI_VTiming s_CurrentVM ;
-//~jau-chih.tseng@ite.com.tw 2009/11/04
-
-BYTE bVideoOutputOption = VIDEO_AUTO ;
-
-BYTE SCDTErrorCnt = 0;
-
-///////////////////////////////////////////////////////////////////////
-// Global Table
-///////////////////////////////////////////////////////////////////////
-#ifdef USE_MODE_TABLE
-static HDMI_VTiming _CODE s_VMTable[] = {
-    {640,480,800,525,25175L,0x89,16,96,48,10,2,33,PROG,Vneg,Hneg},    //640x480@60Hz
-    {720,480,858,525,27000L,0x80,16,62,60,9,6,30,PROG,Vneg,Hneg},    //720x480@60Hz
-    {1280,720,1650,750,74000L,0x2E,110,40,220,5,5,20,PROG,Vpos,Hpos},    //1280x720@60Hz
-    {1920,540,2200,562,74000L,0x2E,88,44,148,2,5,15,INTERLACE,Vpos,Hpos},    //1920x1080(I)@60Hz
-    {720,240,858,262,13500L,0xFF,19,62,57,4,3,15,INTERLACE,Vneg,Hneg},    //720x480(I)@60Hz
-    {720,240,858,262,13500L,0xFF,19,62,57,4,3,15,PROG,Vneg,Hneg},    //720x480(I)@60Hz
-    {1440,240,1716,262,27000L,0x80,38,124,114,5,3,15,INTERLACE,Vneg,Hneg},    //1440x480(I)@60Hz
-    {1440,240,1716,263,27000L,0x80,38,124,114,5,3,15,PROG,Vneg,Hneg},    //1440x240@60Hz
-    {2880,240,3432,262,54000L,0x40,76,248,288,4,3,15,INTERLACE,Vneg,Hneg},    //2880x480(I)@60Hz
-    {2880,240,3432,262,54000L,0x40,76,248,288,4,3,15,PROG,Vneg,Hneg},    //2880x240@60Hz
-    {2880,240,3432,263,54000L,0x40,76,248,288,5,3,15,PROG,Vneg,Hneg},    //2880x240@60Hz
-    {1440,480,1716,525,54000L,0x40,32,124,120,9,6,30,PROG,Vneg,Hneg},    //1440x480@60Hz
-    {1920,1080,2200,1125,148352L,0x17,88,44,148,4,5,36,PROG,Vpos,Hpos},    //1920x1080@60Hz
-    {720,576,864,625,27000L,0x80,12,64,68,5,5,36,PROG,Vneg,Hneg},    //720x576@50Hz
-    {1280,720,1980,750,74000L,0x2E,440,40,220,5,5,20,PROG,Vpos,Hpos},    //1280x720@50Hz
-    {1920,540,2640,562,74000L,0x2E,528,44,148,2,5,15,INTERLACE,Vpos,Hpos},    //1920x1080(I)@50Hz
-    {1440/2,288,1728/2,312,13500L,0xFF,24/2,126/2,138/2,2,3,19,INTERLACE,Vneg,Hneg},    //1440x576(I)@50Hz
-    {1440,288,1728,312,27000L,0x80,24,126,138,2,3,19,INTERLACE,Vneg,Hneg},    //1440x576(I)@50Hz
-    {1440/2,288,1728/2,312,13500L,0xFF,24/2,126/2,138/2,2,3,19,PROG,Vneg,Hneg},    //1440x288@50Hz
-    {1440,288,1728,313,27000L,0x80,24,126,138,3,3,19,PROG,Vneg,Hneg},    //1440x288@50Hz
-    {1440,288,1728,314,27000L,0x80,24,126,138,4,3,19,PROG,Vneg,Hneg},    //1440x288@50Hz
-    {2880,288,3456,312,54000L,0x40,48,252,276,2,3,19,INTERLACE,Vneg,Hneg},    //2880x576(I)@50Hz
-    {2880,288,3456,312,54000L,0x40,48,252,276,2,3,19,PROG,Vneg,Hneg},    //2880x288@50Hz
-    {2880,288,3456,313,54000L,0x40,48,252,276,3,3,19,PROG,Vneg,Hneg},    //2880x288@50Hz
-    {2880,288,3456,314,54000L,0x40,48,252,276,4,3,19,PROG,Vneg,Hneg},    //2880x288@50Hz
-    {1440,576,1728,625,54000L,0x40,24,128,136,5,5,39,PROG,Vpos,Hneg},    //1440x576@50Hz
-    {1920,1080,2640,1125,148000L,0x17,528,44,148,4,5,36,PROG,Vpos,Hpos},    //1920x1080@50Hz
-    {1920,1080,2750,1125,74000L,0x2E,638,44,148,4,5,36,PROG,Vpos,Hpos},    //1920x1080@24Hz
-    {1920,1080,2640,1125,74000L,0x2E,528,44,148,4,5,36,PROG,Vpos,Hpos},    //1920x1080@25Hz
-    {1920,1080,2200,1125,74000L,0x2E,88,44,148,4,5,36,PROG,Vpos,Hpos},    //1920x1080@30Hz
-    // VESA mode
-    {640,350,832,445,31500L,0x6D,32,64,96,32,3,60,PROG,Vneg,Hpos},         // 640x350@85
-    {640,400,832,445,31500L,0x6D,32,64,96,1,3,41,PROG,Vneg,Hneg},          // 640x400@85
-    {832,624,1152,667,57283L,0x3C,32,64,224,1,3,39,PROG,Vneg,Hneg},        // 832x624@75Hz
-    {720,350,900,449,28322L,0x7A,18,108,54,59,2,38,PROG,Vneg,Hneg},        // 720x350@70Hz
-    {720,400,900,449,28322L,0x7A,18,108,54,13,2,34,PROG,Vpos,Hneg},        // 720x400@70Hz
-    {720,400,936,446,35500L,0x61,36,72,108,1,3,42,PROG,Vpos,Hneg},         // 720x400@85
-    {640,480,800,525,25175L,0x89,16,96,48,10,2,33,PROG,Vneg,Hneg},         // 640x480@60
-    {640,480,832,520,31500L,0x6D,24,40,128,9,3,28,PROG,Vneg,Hneg},         // 640x480@72
-    {640,480,840,500,31500L,0x6D,16,64,120,1,3,16,PROG,Vneg,Hneg},         // 640x480@75
-    {640,480,832,509,36000L,0x60,56,56,80,1,3,25,PROG,Vneg,Hneg},          // 640x480@85
-    {800,600,1024,625,36000L,0x60,24,72,128,1,2,22,PROG,Vpos,Hpos},        // 800x600@56
-    {800,600,1056,628,40000L,0x56,40,128,88,1,4,23,PROG,Vpos,Hpos},        // 800x600@60
-    {800,600,1040,666,50000L,0x45,56,120,64,37,6,23,PROG,Vpos,Hpos},       // 800x600@72
-    {800,600,1056,625,49500L,0x45,16,80,160,1,3,21,PROG,Vpos,Hpos},        // 800x600@75
-    {800,600,1048,631,56250L,0x3D,32,64,152,1,3,27,PROG,Vpos,Hpos},        // 800X600@85
-    {848,480,1088,517,33750L,0x66,16,112,112,6,8,23,PROG,Vpos,Hpos},       // 840X480@60
-    {1024,384,1264,408,44900L,0x4d,8,176,56,0,4,20,INTERLACE,Vpos,Hpos},    //1024x768(I)@87Hz
-    {1024,768,1344,806,65000L,0x35,24,136,160,3,6,29,PROG,Vneg,Hneg},      // 1024x768@60
-    {1024,768,1328,806,75000L,0x2E,24,136,144,3,6,29,PROG,Vneg,Hneg},      // 1024x768@70
-    {1024,768,1312,800,78750L,0x2B,16,96,176,1,3,28,PROG,Vpos,Hpos},       // 1024x768@75
-    {1024,768,1376,808,94500L,0x24,48,96,208,1,3,36,PROG,Vpos,Hpos},       // 1024x768@85
-    {1152,864,1600,900,108000L,0x20,64,128,256,1,3,32,PROG,Vpos,Hpos},     // 1152x864@75
-
-
-    {1280,768,1440,790,68250L,0x32,48,32,80,3,7,12,PROG,Vneg,Hpos},        // 1280x768@60-R
-    {1280,768,1664,798,79500L,0x2B,64,128,192,3,7,20,PROG,Vpos,Hneg},      // 1280x768@60
-    {1280,768,1696,805,102250L,0x21,80,128,208,3,7,27,PROG,Vpos,Hneg},     // 1280x768@75
-    {1280,768,1712,809,117500L,0x1D,80,136,216,3,7,31,PROG,Vpos,Hneg},     // 1280x768@85
-
-    {1280,800,1440,823,71000L,0x31,48,32,80,3,6,14,PROG,Vneg,Hpos}, // 1280x800@60-R HReq = 49.306KHz
-    {1280,800,1680,831,83500L,0x2A,72,128,200,3,6,22,PROG,Vpos,Hneg},//1280x800@60, HReq = 49.702KHz
-
-
-    {1280,960,1800,1000,108000L,0x20,96,112,312,1,3,36,PROG,Vpos,Hpos},    // 1280x960@60
-    {1280,960,1728,1011,148500L,0x17,64,160,224,1,3,47,PROG,Vpos,Hpos},    // 1280x960@85
-    {1280,1024,1688,1066,108000L,0x20,48,112,248,1,3,38,PROG,Vpos,Hpos},   // 1280x1024@60
-    {1280,1024,1688,1066,135000L,0x19,16,144,248,1,3,38,PROG,Vpos,Hpos},   // 1280x1024@75
-    {1280,1024,1728,1072,157500L,0x15,64,160,224,1,3,44,PROG,Vpos,Hpos},   // 1280X1024@85
-    {1360,768,1792,795,85500L,0x28,64,112,256,3,6,18,PROG,Vpos,Hpos},      // 1360X768@60
-    {1366,768,1500,800, 72000L, 0x30, 14,56,64,1,3,28,PROG,Vpos,Hpos} , // 1366x768@60-R, HReq = 48KHz
-    {1366,768,1792,798, 85500L, 0x29, 70, 143, 213,3,3,24,PROG,Vpos,Hpos} , // 1366x768@60, HReq = 47.712KHz
-
-    {1400,1050,1560,1080,101000L,0x22,48,32,80,3,4,23,PROG,Vneg,Hpos},     // 1400x768@60-R
-    {1400,1050,1864,1089,121750L,0x1C,88,144,232,3,4,32,PROG,Vpos,Hneg},   // 1400x768@60
-    {1400,1050,1896,1099,156000L,0x16,104,144,248,3,4,42,PROG,Vpos,Hneg},  // 1400x1050@75
-    {1400,1050,1912,1105,179500L,0x13,104,152,256,3,4,48,PROG,Vpos,Hneg},  // 1400x1050@85
-    {1440,900,1600,926,88750L,0x26,48,32,80,3,6,17,PROG,Vneg,Hpos},        // 1440x900@60-R
-    {1440,900,1904,934,106500L,0x20,80,152,232,3,6,25,PROG,Vpos,Hneg},     // 1440x900@60
-    {1440,900,1936,942,136750L,0x19,96,152,248,3,6,33,PROG,Vpos,Hneg},     // 1440x900@75
-    {1440,900,1952,948,157000L,0x16,104,152,256,3,6,39,PROG,Vpos,Hneg},    // 1440x900@85
-    {1600,1200,2160,1250,162000L,0x15,64,192,304,1,3,46,PROG,Vpos,Hpos},   // 1600x1200@60
-    {1600,1200,2160,1250,175500L,0x13,64,192,304,1,3,46,PROG,Vpos,Hpos},   // 1600x1200@65
-    {1600,1200,2160,1250,189000L,0x12,64,192,304,1,3,46,PROG,Vpos,Hpos},   // 1600x1200@70
-    {1600,1200,2160,1250,202500L,0x11,64,192,304,1,3,46,PROG,Vpos,Hpos},   // 1600x1200@75
-    {1600,1200,2160,1250,229500L,0x0F,64,192,304,1,3,46,PROG,Vpos,Hpos},   // 1600x1200@85
-    {1680,1050,1840,1080,119000L,0x1D,48,32,80,3,6,21,PROG,Vneg,Hpos},     // 1680x1050@60-R
-    {1680,1050,2240,1089,146250L,0x17,104,176,280,3,6,30,PROG,Vpos,Hneg},  // 1680x1050@60
-    {1680,1050,2272,1099,187000L,0x12,120,176,296,3,6,40,PROG,Vpos,Hneg},  // 1680x1050@75
-    {1680,1050,2288,1105,214750L,0x10,128,176,304,3,6,46,PROG,Vpos,Hneg},  // 1680x1050@85
-    {1792,1344,2448,1394,204750L,0x10,128,200,328,1,3,46,PROG,Vpos,Hneg},  // 1792x1344@60
-    {1792,1344,2456,1417,261000L,0x0D,96,216,352,1,3,69,PROG,Vpos,Hneg},   // 1792x1344@75
-    {1856,1392,2528,1439,218250L,0x0F,96,224,352,1,3,43,PROG,Vpos,Hneg},   // 1856x1392@60
-    {1856,1392,2560,1500,288000L,0x0C,128,224,352,1,3,104,PROG,Vpos,Hneg}, // 1856x1392@75
-    {1920,1200,2080,1235,154000L,0x16,48,32,80,3,6,26,PROG,Vneg,Hpos},     // 1920x1200@60-R
-    {1920,1200,2592,1245,193250L,0x11,136,200,336,3,6,36,PROG,Vpos,Hneg},  // 1920x1200@60
-    {1920,1200,2608,1255,245250L,0x0E,136,208,344,3,6,46,PROG,Vpos,Hneg},  // 1920x1200@75
-    {1920,1200,2624,1262,281250L,0x0C,144,208,352,3,6,53,PROG,Vpos,Hneg},  // 1920x1200@85
-    {1920,1440,2600,1500,234000L,0x0E,128,208,344,1,3,56,PROG,Vpos,Hneg},  // 1920x1440@60
-    {1920,1440,2640,1500,297000L,0x0B,144,224,352,1,3,56,PROG,Vpos,Hneg},  // 1920x1440@75
-};
-
-#define     SizeofVMTable(sizeof(s_VMTable)/sizeof(HDMI_VTiming))
-#else
-#define     SizeofVMTable    0
-#endif
-
-extern _CODE BYTE bCSCOffset_16_235[] ;
-extern _CODE BYTE bCSCOffset_0_255[] ;
-#if (defined(SUPPORT_OUTPUTYUV))&&(defined(SUPPORT_INPUTRGB))
-    extern _CODE BYTE bCSCMtx_RGB2YUV_ITU601_16_235[] ;
-    extern _CODE BYTE bCSCMtx_RGB2YUV_ITU601_0_255[] ;
-    extern _CODE BYTE bCSCMtx_RGB2YUV_ITU709_16_235[] ;
-    extern _CODE BYTE bCSCMtx_RGB2YUV_ITU709_0_255[] ;
-#endif
-
-#if (defined(SUPPORT_OUTPUTRGB))&&(defined(SUPPORT_INPUTYUV))
-    extern _CODE BYTE bCSCMtx_YUV2RGB_ITU601_16_235[] ;
-    extern _CODE BYTE bCSCMtx_YUV2RGB_ITU601_0_255[] ;
-    extern _CODE BYTE bCSCMtx_YUV2RGB_ITU709_16_235[] ;
-    extern _CODE BYTE bCSCMtx_YUV2RGB_ITU709_0_255[] ;
-
-#endif
-
-
-static BYTE ucCurrentHDMIPort = 0 ;
-static BOOL AcceptCDRReset = TRUE ;
-
-#ifdef AUTO_SEARCH_EQ_SETTING
-static _CODE BYTE EQValue[] = {0x87, 0x81, 0x80} ;
-#define MAX_EQ_IDX (sizeof(EQValue)-1)
-BYTE minInitEQIdx = 0 ; // 1 ; // 2 ; // for the minimal starting search.
-BYTE initEQTestIdx = 0 ;
-BYTE EccErrorCounter = 0 ;
-BYTE SyncDetectFailCounter = 0 ;
-BYTE SyncWaitCounter = 0;
-BYTE SyncCheckCounter = 0;
-USHORT VideoOnTick = 0;
-static USHORT EQSum[]={0,0,0};
-static USHORT gTestRep = 1;
-static USHORT gEqInc = 0;
-BYTE gAutoEQTestReset = 0;
-BYTE eqTest = 0;
-BOOL EnableAutoEQ = TRUE ;
-static void AutoAdjustEQ();
-static BOOL IncreaseEQ();
-#endif
-
-///////////////////////////////////////////////////////////
-// Function Prototype
-///////////////////////////////////////////////////////////
-BOOL CheckHDMIRX(void);
-
-void DumpHDMIRX(void);
-// void DumpSync(PSYNC_INFO pSyncInfo);
-// void GetSyncInfo(PSYNC_INFO pSyncInfo);
-// static BOOL CheckOutOfRange(PSYNC_INFO pSyncInfo);
-// BOOL ValidateMode(PSYNC_INFO pSyncInfo);
-void Interrupt_Handler(void);
-void Timer_Handler(void);
-void Video_Handler(void);
-
-static void HWReset_HDMIRX(void);
-static void SWReset_HDMIRX(void);
-// void Terminator_Reset();
-void setHDMIRX_TerminatorOff(void);
-void setHDMIRX_TerminatorOn(void);
-void Terminator_Off(void);
-void Terminator_On(void);
-
-void Check_RDROM(void);
-void RDROM_Reset(void);
-void SetDefaultRegisterValue(void);
-// static void LoadDefaultSyncPolarity();
-// static void LoadDefaultHWMuteControl();
-// static void LoadDefaultHWAmpControl();
-// static void LoadDefaultAudioOutputMap();
-// static void LoadDefaultVideoOutput();
-// static void LoadDefaultInterruptType();
-// static void LoadDefaultAudioSampleClock();
-// static void LoadDefaultROMSetting();
-static void LoadCustomizeDefaultSetting(void);
-static void SetupAudio(void);
-
-BOOL ReadRXIntPin(void);
-// USHORT GetVFreq();
-static void ClearIntFlags(BYTE flag);
-static void ClearHDCPIntFlags(void);
-BOOL IsSCDT(void);
-BOOL CheckPlg5VPwr(void);
-// BOOL CheckPlg5VPwrOn();
-// BOOL CheckPlg5VPwrOff();
-BOOL CheckHDCPFail(void);
-void SetMUTE(BYTE AndMask, BYTE OrMask);
-void SetMCLKInOUt(BYTE MCLKSelect);
-void SetIntMask1(BYTE AndMask,BYTE OrMask);
-void SetIntMask2(BYTE AndMask,BYTE OrMask);
-void SetIntMask3(BYTE AndMask,BYTE OrMask);
-void SetIntMask4(BYTE AndMask,BYTE OrMask);
-void SetGeneralPktType(BYTE type);
-BOOL IsHDMIRXHDMIMode(void);
-static void EnableAudio(void);
-
-///////////////////////////////////////////////////////////
-// Audio Macro
-///////////////////////////////////////////////////////////
-
-#define SetForceHWMute(){ SetHWMuteCTRL((~B_HW_FORCE_MUTE),(B_HW_FORCE_MUTE)); }
-#define SetHWMuteClrMode(){ SetHWMuteCTRL((~B_HW_AUDMUTE_CLR_MODE),(B_HW_AUDMUTE_CLR_MODE));}
-#define SetHWMuteClr(){ SetHWMuteCTRL((~B_HW_MUTE_CLR),(B_HW_MUTE_CLR)); }
-#define SetHWMuteEnable(){ SetHWMuteCTRL((~B_HW_MUTE_EN),(B_HW_MUTE_EN)); }
-#define ClearForceHWMute(){ SetHWMuteCTRL((~B_HW_FORCE_MUTE),0); }
-#define ClearHWMuteClrMode(){ SetHWMuteCTRL((~B_HW_AUDMUTE_CLR_MODE),0); }
-#define ClearHWMuteClr(){ SetHWMuteCTRL((~B_HW_MUTE_CLR),0); }
-#define ClearHWMuteEnable(){ SetHWMuteCTRL((~B_HW_MUTE_EN),0);}
-///////////////////////////////////////////////////////////
-// Function Prototype
-///////////////////////////////////////////////////////////
-void RXINT_5V_PwrOn(void);
-void RXINT_5V_PwrOff(void);
-void RXINT_SCDT_On(void);
-void RXINT_SCDT_Off(void);
-void RXINT_RXCKON(void);
-void RXINT_VideoMode_Chg(void);
-void RXINT_HDMIMode_Chg(void);
-void RXINT_AVMute_Set(void);
-void RXINT_AVMute_Clear(void);
-void RXINT_SetNewAVIInfo(void);
-void RXINT_ResetAudio(void);
-void RXINT_ResetHDCP(void);
-void TimerServiceISR(void);
-static void VideoTimerHandler(void);
-static void AudioTimerHandler(void);
-static void MuteProcessTimerHandler(void);
-
-void AssignVideoTimerTimeout(USHORT TimeOut);
-void ResetVideoTimerTimeout(void);
-void SwitchVideoState(Video_State_Type state);
-
-void AssignAudioTimerTimeout(USHORT TimeOut);
-void ResetAudioTimerTimeout(void);
-void SwitchAudioState(Audio_State_Type state);
-#define EnableMuteProcessTimer(){ MuteResumingTimer = MuteByPKG?MUTE_RESUMING_TIMEOUT:0 ; }
-#define DisableMuteProcessTimer(){ MuteResumingTimer = 0 ; }
-
-static void DumpSyncInfo(HDMI_VTiming *pVTiming);
-#define StartAutoMuteOffTimer(){ MuteAutoOff = ON ; }
-#define EndAutoMuteOffTimer(){ MuteAutoOff = OFF ; }
-static void CDR_Reset(void);
-//static void Reset_SCDTOFF(void);
-
-
-static void SetVideoInputFormatWithoutInfoFrame(BYTE bInMode);
-static void SetColorimetryByMode(void/* PSYNC_INFO pSyncInfo */);
-void SetVideoInputFormatWithInfoFrame(void);
-BOOL SetColorimetryByInfoFrame(void);
-void SetColorSpaceConvert(void);
-// BOOL CompareSyncInfo(PSYNC_INFO pSyncInfo1,PSYNC_INFO pSyncInfo2);
-// void HDCP_Reset();
-void SetDVIVideoOutput(void);
-void SetNewInfoVideoOutput(void);
-void ResetAudio(void);
-void SetHWMuteCTRL(BYTE AndMask, BYTE OrMask);
-void SetAudioMute(BOOL bMute);
-static void SetVideoMute(BOOL bMute);
-static void SetALLMute(void) ;
-// void DelayUS(ULONG us);
-//#ifndef _MCU_8051_
-//void delay1ms(USHORT ms);
-//void ErrorF(char *fmt,...);
-//#endif
-
-///////////////////////////////////////////////////////////
-// Connection Interface
-///////////////////////////////////////////////////////////
-void
-Check_HDMInterrupt()
-{
-	Interrupt_Handler();
-}
-
-
-
-BOOL
-CheckHDMIRX()
-{
-    Timer_Handler();
-    Video_Handler();
-
-    if(VState == VSTATE_VideoOn &&(!MuteByPKG))
-    {
-        return TRUE ;
-    }
-
-    return FALSE ;
-}
-
-void
-SelectHDMIPort(BYTE ucPort)
-{
-
-    if(ucPort != CAT_HDMI_PORTA)
-    {
-        ucPort = CAT_HDMI_PORTB ;
-    }
-
-    if(ucPort != ucCurrentHDMIPort)
-    {
-        ucCurrentHDMIPort = ucPort ;
-    }
-
-    HDMIRX_DEBUG_PRINTF(("SelectHDMIPort ucPort = %d, ucCurrentHDMIPort = %d\n",(int)ucPort, (int)ucCurrentHDMIPort));
-	// switch HDMI port should
-	// 1. power down HDMI
-	// 2. Select HDMI Port
-	// 3. call InitCAT6011();
-}
-
-BYTE
-GetCurrentHDMIPort()
-{
-	return ucCurrentHDMIPort ;
-}
-
-
-void
-InitHDMIRX(BOOL bFullInit)
-{
-    BYTE uc ;
-
-    #ifndef DISABLE_HWRESET
-    if(bFullInit)
-    {
-        HWReset_HDMIRX();
-    }
-    #endif
-    Terminator_Off();
-    //////////////////////////////////////////////
-    // Initialize HDMIRX chip uc.
-    //////////////////////////////////////////////
-
-    HDMIRX_WriteI2C_Byte(REG_RX_PWD_CTRL0, 0);
-
-    #ifndef DISABLE_RESET_REFCLK
-    if(bFullInit)
-    {
-        // this reset will activate the I2C no ACK in this call.
-        HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_REGRST); // register reset
-    }
-    #endif
-    // delay1ms(1); // wait for B_REGRST down to zero
-
-    // uc = HDMIRX_ReadI2C_Byte(REG_RX_HDCP_CTRL);
-
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_SWRST|B_CDRRST|B_EN_AUTOVDORST); // sw reset
-    // delay1ms(1);
-    ucRevision = HDMIRX_ReadI2C_Byte(0x04);
-
-    //// uc = 0x89 ; // for external ROM
-    //uc = B_EXTROM | B_HDCP_ROMDISWR | B_HDCP_EN ;
-    //HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL, uc);
-
-	if(ucCurrentHDMIPort==CAT_HDMI_PORTA)
-	{
-		uc = B_PORT_SEL_A|B_PWD_AFEALL|B_PWDC_ETC ;
-	}
-	else
-	{
-		uc = B_PORT_SEL_B|B_PWD_AFEALL|B_PWDC_ETC ;
-	}
-	HDMIRX_WriteI2C_Byte(REG_RX_PWD_CTRL1, uc);
-    HDMIRX_DEBUG_PRINTF(("InitHDMIRX(FALSE): reg07 = %02X, ucCurrentHDMIPort = %d\n",(int)HDMIRX_ReadI2C_Byte(07),(int)ucCurrentHDMIPort));
-
-    SetIntMask1(0,B_PWR5VON|B_SCDTON|B_PWR5VOFF|B_SCDTOFF);
-    SetIntMask2(0,B_NEW_AVI_PKG|B_PKT_SET_MUTE|B_PKT_CLR_MUTE);
-    SetIntMask3(0,B_ECCERR|B_R_AUTH_DONE|B_R_AUTH_START);
-    SetIntMask4(0,0) ; // B_M_RXCKON_DET);
-
-
-    SetDefaultRegisterValue();
-    LoadCustomizeDefaultSetting();
-
-    SetALLMute(); // MUTE ALL with tristate video, SPDIF and all I2S channel
-
-    // 2006/10/31 marked by jjtseng
-    // HDMIRX_WriteI2C_Byte(REG_RX_REGPKTFLAG_CTRL,B_INT_EVERYAVI);
-    //~jjtseng 2006/10/31
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST); // normal operation
-    bDisableAutoAVMute = FALSE ;
-    if(ucRevision == 0xA2)
-    {
-        HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL, 0x09);
-        HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL, 0x19);
-    }
-
-    #ifdef DISABLE_HDCP
-        HDMIRX_WriteI2C_Byte(0x0A, 0);
-        HDMIRX_WriteI2C_Byte(0x0B, 0);
-        HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL, 0x89);
-        HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL, 0x99);
-        HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_SWRST|B_HDCPRST|B_EN_AUTOVDORST); // sw reset
-        HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST); // sw reset
-        HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL, 0x00);
-    #endif
-
-
-    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    // DO NOT MOVE THE ACTION LOCATION!!
-    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-    if( bFullInit )
-    {
-        // this delay is the experience by previous project support compatibility issue.
-        delay1ms(200); // delay 0.2 sec by TPV project experience.
-    }
-
-    RDROM_Reset(); // it should be do SWRESET again AFTER RDROM_Reset().
-
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_SWRST|B_EN_AUTOVDORST); // sw reset
-    delay1ms(1);
-    SetALLMute();
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST); // normal operation
-
-    // Terminator_Reset();
-    //
-    // // 2006/10/26 modified by jjtseng
-    // // SwitchVideoState(VSTATE_SyncWait);
-    // SwitchVideoState(VSTATE_PwrOff);
-    // //~jjtseng 2006/10/26
-    #ifndef MANUAL_TURNON_HDMIRX
-    if(bFullInit)
-    {
-        Terminator_Off();
-        SwitchVideoState(VSTATE_SWReset);
-    }
-    #endif
-
-#ifdef SUPPORT_REPEATER
-	RxHDCPRepeaterCapabilityClear(B_ENABLE_FEATURE_1P1|B_ENABLE_FAST);
-    if(bHDCPMode & HDCP_REPEATER)
-    {
-	    RxHDCPRepeaterCapabilitySet(B_ENABLE_REPEATER);
-	    RxHDCPRepeaterCapabilityClear(B_KSV_READY);
-	}
-	else
-	{
-	    RxHDCPRepeaterCapabilityClear(B_KSV_READY|B_ENABLE_REPEATER);
-        SetIntMask3(~(B_R_AUTH_DONE|B_R_AUTH_START),B_ECCERR);
-	}
-#else
-	HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL)&0xF);
-#endif // SUPPORT_REPEATER
-    AcceptCDRReset = TRUE;
-
-    #ifndef MANUAL_TURNON_HDMIRX
-    if(!bFullInit)
-    {
-        // if switch from power saving, the terminator should be off at first.
-        Terminator_On();
-        SwitchVideoState(VSTATE_PwrOff);
-    }
-    #endif
-
-    #ifdef MANUAL_TURNON_HDMIRX
-        Terminator_Off();   // turn on the HDMIRX state machine need to call Turn_HDMIRX(ON);
-        SwitchVideoState(VSTATE_Off);
-    #endif
-
-}
-
-void Turn_HDMIRX(BOOL bEnable)
-{
-    HDMIRX_DEBUG_PRINTF3(("Turn_HDMIRX(%s)\n",bEnable?"ON":"OFF")) ;
-    if( bEnable )
-    {
-        SWReset_HDMIRX() ;
-    }
-    else
-    {
-        Terminator_Off();
-        SwitchVideoState(VSTATE_Off);
-    }
-}
-
-void PowerDownHDMI()
-{
-	HDMIRX_WriteI2C_Byte(REG_RX_PWD_CTRL1, B_PWD_AFEALL|B_PWDC_ETC|B_PWDC_SRV|B_EN_AUTOPWD);
-	HDMIRX_WriteI2C_Byte(REG_RX_PWD_CTRL0, B_PWD_ALL);
-}
-
-BOOL IsHDMIRXInterlace()
-{
-    if(HDMIRX_ReadI2C_Byte(REG_RX_VID_MODE)&B_INTERLACE)
-    {
-        return TRUE ;
-    }
-    return FALSE ;
-}
-
-BYTE
-getHDMIRX_InputColor()
-{
-    BYTE uc ;
-    if(IsHDMIRXHDMIMode())
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB1) ;
-        switch(uc&0x60)
-        {
-        case 0x40: return 2 ;
-        case 0x20: return 1 ;
-        default: return 0 ;
-        }
-    }
-    return 0 ;
-
-}
-
-WORD getHDMIRXHorzTotal()
-{
-    BYTE uc[2] ;
-	WORD hTotal ;
-
-	uc[0] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_L);
-	uc[1] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_H);
-	hTotal =(WORD)(uc [1] & M_HTOTAL_H);
-	hTotal <<= 8 ;
-	hTotal |=(WORD)uc[0] ;
-
-	return hTotal ;
-}
-
-WORD getHDMIRXHorzActive()
-{
-    BYTE uc[3] ;
-
-	WORD hTotal, hActive ;
-
-	uc[0] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_L);
-	uc[1] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_H);
-	uc[2] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HACT_L);
-
-	hTotal =(WORD)(uc [1] & M_HTOTAL_H);
-	hTotal <<= 8 ;
-	hTotal |=(WORD)uc[0] ;
-
-	hActive =(WORD)(uc[1] >> O_HACT_H)& M_HACT_H ;
-	hActive <<= 8 ;
-	hActive |=(WORD)uc[2] ;
-
-	if((hActive |(1<<11))< hTotal)
-	{
-		hActive |= 1<<11 ;
-	}
-
-	return hActive ;
-
-}
-
-WORD getHDMIRXHorzFrontPorch()
-{
-    BYTE uc[2] ;
-	WORD hFrontPorch ;
-
-	uc[0] = HDMIRX_ReadI2C_Byte(REG_RX_VID_H_FT_PORCH_L);
-	uc[1] =(HDMIRX_ReadI2C_Byte(REG_RX_VID_HSYNC_WID_H)>> O_H_FT_PORCH)& M_H_FT_PORCH ;
-	hFrontPorch =(WORD)uc[1] ;
-	hFrontPorch <<= 8 ;
-	hFrontPorch |=(WORD)uc[0] ;
-
-	return hFrontPorch ;
-}
-
-WORD getHDMIRXHorzSyncWidth()
-{
-    BYTE uc[2] ;
-	WORD hSyncWidth ;
-
-	uc[0] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HSYNC_WID_L);
-	uc[1] = HDMIRX_ReadI2C_Byte(REG_RX_VID_HSYNC_WID_H)& M_HSYNC_WID_H ;
-
-	hSyncWidth =(WORD)uc[1] ;
-	hSyncWidth <<= 8 ;
-	hSyncWidth |=(WORD)uc[0] ;
-
-	return hSyncWidth ;
-}
-
-WORD getHDMIRXHorzBackPorch()
-{
-	WORD hBackPorch ;
-
-	hBackPorch = getHDMIRXHorzTotal()- getHDMIRXHorzActive()- getHDMIRXHorzFrontPorch()- getHDMIRXHorzSyncWidth();
-
-	return hBackPorch ;
-}
-
-WORD getHDMIRXVertTotal()
-{
-    BYTE uc[3] ;
-	WORD vTotal, vActive ;
-	uc[0] = HDMIRX_ReadI2C_Byte(REG_RX_VID_VTOTAL_L);
-	uc[1] = HDMIRX_ReadI2C_Byte(REG_RX_VID_VTOTAL_H);
-	uc[2] = HDMIRX_ReadI2C_Byte(REG_RX_VID_VACT_L);
-
-	vTotal =(WORD)uc[1] & M_VTOTAL_H ;
-	vTotal <<= 8 ;
-	vTotal |=(WORD)uc[0] ;
-
-	vActive =(WORD)(uc[1] >> O_VACT_H)& M_VACT_H ;
-	vActive |=(WORD)uc[2] ;
-
-	if(vTotal >(vActive |(1<<10)))
-	{
-		vActive |= 1<<10 ;
-	}
-
-	// for vertical front porch bit lost, ...
-	#if 0
-	if(vActive == 600 && vTotal == 634)
-	{
-		vTotal = 666 ; // fix the 800x600@72 issue
-	}
-	#endif
-
-	return vTotal ;
-}
-
-WORD getHDMIRXVertActive()
-{
-    BYTE uc[3] ;
-	WORD vTotal, vActive ;
-	uc[0] = HDMIRX_ReadI2C_Byte(REG_RX_VID_VTOTAL_L);
-	uc[1] = HDMIRX_ReadI2C_Byte(REG_RX_VID_VTOTAL_H);
-	uc[2] = HDMIRX_ReadI2C_Byte(REG_RX_VID_VACT_L);
-
-	vTotal =(WORD)uc[1] & M_VTOTAL_H ;
-	vTotal <<= 8 ;
-	vTotal |=(WORD)uc[0] ;
-
-	vActive =(WORD)(uc[1] >> O_VACT_H)& M_VACT_H ;
-	vActive <<= 8 ;
-	vActive |=(WORD)uc[2] ;
-
-	if(vTotal >(vActive |(1<<10)))
-	{
-		vActive |= 1<<10 ;
-	}
-
-	return vActive ;
-}
-
-WORD getHDMIRXVertFrontPorch()
-{
-    WORD vFrontPorch ;
-
-	vFrontPorch =(WORD)HDMIRX_ReadI2C_Byte(REG_RX_VID_V_FT_PORCH)& 0xF ;
-
-	if(getHDMIRXVertActive()== 600 && getHDMIRXVertTotal()== 666)
-	{
-		vFrontPorch |= 0x20 ;
-	}
-
-	return vFrontPorch ;
-
-}
-
-WORD getHDMIRXVertSyncToDE()
-{
-    WORD vSync2DE ;
-
-    vSync2DE =(WORD)HDMIRX_ReadI2C_Byte(REG_RX_VID_VSYNC2DE);
-    return vSync2DE ;
-}
-
-WORD getHDMIRXVertSyncWidth()
-{
-    WORD vSync2DE ;
-    WORD vTotal, vActive, hActive  ;
-
-    vSync2DE = getHDMIRXVertSyncToDE();
-    vTotal = getHDMIRXVertTotal();
-    vActive = getHDMIRXVertActive();
-    hActive = getHDMIRXHorzActive();
-#ifndef HDMIRX_A1
-    // estamite value.
-    if(vActive < 300)
-    {
-    	return 3 ;
-    }
-
-    if(hActive == 640 && hActive == 480)
-    {
-    	if(HDMIRX_ReadI2C_Byte(REG_RX_VID_XTALCNT_128PEL)< 0x80)
-    	{
-    		return 3 ;
-    	}
-
-    	return 2;
-    }
-
-    return 5 ;
-#endif
-}
-
-WORD getHDMIRXVertSyncBackPorch()
-{
-    WORD vBackPorch ;
-
-    vBackPorch = getHDMIRXVertSyncToDE()- getHDMIRXVertSyncWidth();
-    return vBackPorch ;
-}
-
-BYTE getHDMIRXxCnt()
-{
-    return HDMIRX_ReadI2C_Byte(REG_RX_VID_XTALCNT_128PEL);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// BOOL getHDMIRXAudioInfo(BYTE *pbSampleFreq, BYTE *pbValidCh);
-// Parameter:	pointer of BYTE pbSampleFreq - return sample freq
-// pointer of BYTE pbValidCh - return valid audio channel.
-// Return:	FALSE - no valid audio information during DVI mode.
-//         TRUE - valid audio information returned.
-// Remark:	if pbSampleFreq is not NULL, *pbSampleFreq will be filled in with one of the following values:
-//         0 - 44.1KHz
-//         2 - 48KHz
-//         3 - 32KHz
-//         8 - 88.2 KHz
-//         10 - 96 KHz
-//         12 - 176.4 KHz
-//         14 - 192KHz
-//         Otherwise - invalid audio frequence.
-//         if pbValidCh is not NULL, *pbValidCh will be identified with the bit valie:
-//         bit[0] - '0' means audio channel 0 is not valid, '1' means it is valid.
-//         bit[1] - '0' means audio channel 1 is not valid, '1' means it is valid.
-//         bit[2] - '0' means audio channel 2 is not valid, '1' means it is valid.
-//         bit[3] - '0' means audio channel 3 is not valid, '1' means it is valid.
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////
-
-BOOL getHDMIRXAudioInfo(BYTE *pbAudioSampleFreq, BYTE *pbValidCh)
-{
-#ifndef DISABLE_AUDIO_SUPPORT
-    if(IsHDMIRXHDMIMode())
-    {
-        if(pbAudioSampleFreq)
-        {
-            *pbAudioSampleFreq = HDMIRX_ReadI2C_Byte(REG_RX_FS)& M_Fs ;
-        }
-
-        if(pbValidCh)
-        {
-            *pbValidCh = HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT);
-            if(*pbValidCh & B_AUDIO_LAYOUT)
-            {
-                *pbValidCh &= M_AUDIO_CH ;
-            }
-            else
-            {
-                *pbValidCh = B_AUDIO_SRC_VALID_0 ;
-            }
-        }
-        return TRUE ;
-    }
-    else
-#endif
-    {
-        return FALSE ;
-    }
-}
-
-///////////////////////////////////////////////////////////
-// Get Info Frame and HDMI Package
-// Need upper program pass information and read them.
-///////////////////////////////////////////////////////////
-#ifdef GET_PACKAGE
-// 2006/07/03 added by jjtseng
-BOOL
-GetAVIInfoFrame(BYTE *pData)
-{
-    // BYTE checksum ;
-    // int i ;
-
-    if(pData == NULL)
-    {
-        return ER_FAIL ;
-    }
-
-    pData[0] = AVI_INFOFRAME_TYPE|0x80 ; // AVI InfoFrame
-    pData[1] = HDMIRX_ReadI2C_Byte(REG_RX_AVI_VER);
-    pData[2] = AVI_INFOFRAME_LEN ;
-
-    HDMIRX_ReadI2C_ByteN(REG_RX_AVI_DB0, pData+3,AVI_INFOFRAME_LEN+1);
-
-    return TRUE ;
-}
-//~jjtseng 2006/07/03
-
-// 2006/07/03 added by jjtseng
-BOOL
-GetAudioInfoFrame(BYTE *pData)
-{
-    // BYTE checksum ;
-    BYTE i ;
-
-    if(pData == NULL)
-    {
-        return FALSE ;
-    }
-
-    pData[0] = AUDIO_INFOFRAME_TYPE|0x80 ; // AUDIO InfoFrame
-    pData[1] = HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_VER);
-    pData[2] = HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_LEN); ;
-
-    HDMIRX_ReadI2C_ByteN(REG_RX_AUDIO_DB0, pData+3,6);
-    for( i = 5 ; i <= pData[2] ; i++ )
-    {
-        pData[4+i] = 0 ;
-    }
-
-    return TRUE ;
-}
-//~jjtseng 2006/07/03
-//
-//
-// // 2006/07/03 added by jjtseng
-// BOOL
-// GetMPEGInfoFrame(BYTE *pData)
-// {
-//     // BYTE checksum ;
-//     // int i ;
-//
-//     if(pData == NULL)
-//     {
-//         return FALSE ;
-//     }
-//
-//     pData[0] = MPEG_INFOFRAME_TYPE|0x80 ; // MPEG InfoFrame
-//     pData[1] = HDMIRX_ReadI2C_Byte(REG_RX_MPEG_VER);
-//     pData[2] = MPEG_INFOFRAME_LEN ;
-//
-//     HDMIRX_ReadI2C_ByteN(REG_RX_MPEG_DB0, pData+3,MPEG_INFOFRAME_LEN+1);
-//
-//     return TRUE ;
-// }
-// //~jjtseng 2006/07/03
-
-// 2006/07/03 added by jjtseng
-BOOL
-GetVENDORSPECInfoFrame(BYTE *pData)
-{
-    // BYTE checksum ;
-    int i ;
-    BYTE uc ;
-
-    if(pData == NULL)
-    {
-        return FALSE ;
-    }
-
-	if(bVSIpresent == FALSE)
-	{
-		return FALSE ;
-	}
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_GENPKT_HB0);
-    if(uc !=(VENDORSPEC_INFOFRAME_TYPE|0x80))
-    {
-        return FALSE ;
-    }
-    pData[0] = uc ;
-    for(i = 1 ; i < 3+28 ; i++)
-    {
-        pData[i] = HDMIRX_ReadI2C_Byte(REG_RX_GENPKT_HB0+i);
-    }
-
-    return TRUE ;
-}
-//~jjtseng 2006/07/03
-
-
-
-#endif
-//~jjtseng 2006/07/03
-
-///////////////////////////////////////////////////////////
-//  Testing Function
-///////////////////////////////////////////////////////////
-
-void
-getHDMIRXRegs(BYTE *pData)
-{
-    int i, j ;
-
-    SwitchHDMIRXBank(0);
-    for(i = j = 0 ; i < 256 ; i++,j++)
-    {
-        pData[j] = HDMIRX_ReadI2C_Byte((BYTE)(i&0xFF));
-    }
-    SwitchHDMIRXBank(1);
-    for(i = 0xA0 ; i <= 0xF2 ; i++, j++)
-    {
-        pData[j] = HDMIRX_ReadI2C_Byte((BYTE)(i&0xFF));
-    }
-    SwitchHDMIRXBank(0);
-}
-
-BYTE
-getHDMIRXOutputColorMode()
-{
-    return bOutputVideoMode & F_MODE_CLRMOD_MASK ;
-}
-
-BYTE
-getHDMIRXOutputColorDepth()
-{
-    BYTE uc ;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_FS)& M_GCP_CD ;
-    return uc >> O_GCP_CD ;
-}
-
-// Initialization
-///////////////////////////////////////////////////////////
-
-static void
-HWReset_HDMIRX()
-{
-    // reset HW Reset Pin.
-#ifdef _MCU_8051_
-    // Write HDMIRX pin = 1 ;
-#endif
-}
-
-#if 0
-// void
-// setHDMIRX_TerminatorOff()
-// {
-// 	SwitchVideoState(VSTATE_Off);
-// 	Terminator_Off() ;
-// }
-//
-// void
-// setHDMIRX_TerminatorOn()
-// {
-// 	// SwitchVideoState(VSTATE_SWReset);
-// 	SWReset_HDMIRX() ;
-// }
-#endif 
-
-void
-Terminator_Off()
-{
-    BYTE uc ;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_PWD_CTRL1)|(B_PWD_AFEALL|B_PWDC_ETC);
-    HDMIRX_WriteI2C_Byte(REG_RX_PWD_CTRL1, uc);
-    HDMIRX_DEBUG_PRINTF(("Terminator_Off, reg07 = %02x\n",(int)uc));
-}
-
-void
-Terminator_On()
-{
-    BYTE uc ;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_PWD_CTRL1)& ~(B_PWD_AFEALL|B_PWDC_ETC);
-    HDMIRX_WriteI2C_Byte(REG_RX_PWD_CTRL1, uc);
-    HDMIRX_DEBUG_PRINTF(("Terminator_On, reg07 = %02x\n",(int)uc));
-}
-
-/*
-static void
-Terminator_Reset()
-{
-    Terminator_Off();
-    delay1ms(500); // delay 500 ms
-    Terminator_On();
-}
-*/
-
-void
-RDROM_Reset()
-{
-    BYTE i ;
-    BYTE uc ;
-
-    HDMIRX_DEBUG_PRINTF(("RDROM_Reset()\n"));
-    // uc =((bDisableAutoAVMute)?B_VDO_MUTE_DISABLE:0)|1;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_RDROM_CLKCTRL)& ~(B_ROM_CLK_SEL_REG|B_ROM_CLK_VALUE);
-    for(i=0 ;i < 16 ; i++)
-    {
-        HDMIRX_WriteI2C_Byte(REG_RX_RDROM_CLKCTRL, B_ROM_CLK_SEL_REG|uc);
-        HDMIRX_WriteI2C_Byte(REG_RX_RDROM_CLKCTRL, B_ROM_CLK_SEL_REG|B_ROM_CLK_VALUE|uc);
-    }
-    // 2006/10/31 modified by jjtseng
-    // added oring bDisableAutoAVMute
-    HDMIRX_WriteI2C_Byte(REG_RX_RDROM_CLKCTRL,uc);
-    //~jjtseng 2006/10/31
-}
-
-void
-Check_RDROM()
-{
-    BYTE uc ;
-    HDMIRX_DEBUG_PRINTF(("Check_HDCP_RDROM()\n"));
-
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST);
-
-    if(IsSCDT())
-    {
-        // int count ;
-        // for(count = 0 ;; count++)
-		{
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_RDROM_STATUS);
-            if((uc & 0xF)!= 0x9)
-            {
-                RDROM_Reset();
-            }
-            HDMIRX_DEBUG_PRINTF(("Check_HDCP_RDROM()done.\n"));
-            return ;
-        }
-    }
-}
-
-static void
-SWReset_HDMIRX()
-{
-    Check_RDROM();
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_SWRST|B_EN_AUTOVDORST); // sw reset
-    delay1ms(1);
-    SetALLMute();
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST); // normal operation
-
-    // Terminator_Reset();
-
-    // 2006/10/26 modified by jjtseng
-    // SwitchVideoState(VSTATE_SyncWait);
-    // SwitchVideoState(VSTATE_PwrOff);
-    //~jjtseng 2006/10/26
-
-    Terminator_Off();
-    SwitchVideoState(VSTATE_SWReset);
-
-
-    //2008/10/02 modified by hermes
-    SCDTErrorCnt = 0;
-
-}
-
-// 2006/10/31 added by jjtseng
-// for customized uc
-typedef struct _REGPAIR {
-    BYTE ucAddr ;
-    BYTE ucValue ;
-} REGPAIR ;
-//~jjtseng 2006/10/31
-
-/////////////////////////////////////////////////////////////////
-// Customer Defined uc area.
-/////////////////////////////////////////////////////////////////
-// 2006/10/31 added by jjtseng
-// for customized uc
-static REGPAIR _CODE acCustomizeValue[] =
-{
-    //2009/12/08 added by jau-chih.tseng@ite.com.tw
-    // {REG_RX_VCLK_CTRL, 0x20}, // request by Clive for adjusting A2 version.
-    {REG_RX_VCLK_CTRL, 0x30}, // request by Clive for IT6603 board .... !@#$!@$#! .
-    //~jau-chih.tseng 2009/12/08
-    // {REG_RX_I2S_CTRL,0x61},
-    {REG_RX_I2S_CTRL,I2S_DSP_SETTING},
-    // CCIR656
-    {REG_RX_PG_CTRL2,HDMIRX_OUTPUT_COLORMODE},
-    {REG_RX_VIDEO_MAP,HDMIRX_OUTPUT_MAPPING},
-    {REG_RX_VIDEO_CTRL1,HDMIRX_OUTPUT_TYPE},
-    {REG_RX_MCLK_CTRL, 0xC1},
-    {0xFF,0xFF}
-} ;
-// jjtseng 2006/10/31
-
-static void
-LoadCustomizeDefaultSetting()
-{
-    BYTE i, uc ;
-    for(i = 0 ; acCustomizeValue[i].ucAddr != 0xFF ; i++)
-    {
-        HDMIRX_WriteI2C_Byte(acCustomizeValue[i].ucAddr,acCustomizeValue[i].ucValue);
-    }
-
-    /*
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_PG_CTRL2)& ~(M_OUTPUT_COLOR_MASK<<O_OUTPUT_COLOR_MODE);
-    switch(bOutputVideoMode&F_MODE_CLRMOD_MASK)
-    {
-    case F_MODE_YUV444:
-        uc |= B_OUTPUT_YUV444 << O_OUTPUT_COLOR_MODE ;
-        break ;
-    case F_MODE_YUV422:
-        uc |= B_OUTPUT_YUV422 << O_OUTPUT_COLOR_MODE ;
-        break ;
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_PG_CTRL2, uc);
-    */
-    bOutputVideoMode&=~F_MODE_CLRMOD_MASK;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_PG_CTRL2)&(M_OUTPUT_COLOR_MASK<<O_OUTPUT_COLOR_MODE);
-
-    switch(uc)
-    {
-    case(B_OUTPUT_YUV444 << O_OUTPUT_COLOR_MODE): bOutputVideoMode|=F_MODE_YUV444; break ;
-    case(B_OUTPUT_YUV422 << O_OUTPUT_COLOR_MODE): bOutputVideoMode|=F_MODE_YUV422; break ;
-    case 0: bOutputVideoMode|=F_MODE_RGB444; break ;
-    default: bOutputVideoMode|=F_MODE_RGB444; break ;
-    }
-    bIntPOL =(HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_CTRL)& B_INTPOL)?LO_ACTIVE:HI_ACTIVE ;
-}
-
-//////////////////////////////////////////////////
-// SetDefaultRegisterValue
-// some register value have to be hard coded and
-// need to adjust by case. Set here.
-//////////////////////////////////////////////////
-//  There are some register default setting has changed, please make sure
-// when release to customer.
-///////////////////////////////////////////////////
-// Rev 1.09
-///////////////////////////////////////////////////
-//reg3B=0x40
-//reg68=0x03
-//reg69=0x00//HW DEF
-//reg6A=0xA8//HW DEF
-//reg6B=0x11
-//Reg6C=0x00
-//reg6D=0x64//HW DEF
-//reg6E=0x0C//HW DEF
-//Reg93=0x43
-//Reg94=0x4F
-//Reg95=0x87
-//Reg96=0x33
-///////////////////////////////////////////////////
-
-// 2006/10/31 added by jjtseng
-static REGPAIR _CODE acDefaultValue[] =
-{
-    {0x0F,0x00},// Reg08
-	// 2010/10/13 modified by jau-chih.tseng@ite.com.tw
-	// recommand by Clive to modify the driving from 0xAE to 0xCE
-    // {REG_RX_VIO_CTRL,0xAE},// Reg08
-    {REG_RX_VIO_CTRL,0xCE},// Reg08
-	//~jau-chih.tseng@ite.com.tw
-    //~jj_tseng@chipadvanced.com
-    // 2008/09/25 added by jj_tseng@chiopadvanced.com
-    // by IT's command, reg3B should set default value with 0x40
-    {REG_RX_DESKEW_CTRL, 0x40},
-    //~jj_tseng@chipadvanced.com 2008/09/25
-    {REG_RX_PLL_CTRL,0x03},// Reg68=0x03
-    // {REG_RX_TERM_CTRL1,0x00},// Reg69=0x00 // HW Default
-
-
-	{REG_RX_EQUAL_CTRL1,0x11}, 	// reg6B = 0x11
-    {REG_RX_EQUAL_CTRL2, 0x00}, // reg6C = 0x00
-    // reg6D = HW Default
-    // {REG_RX_DES_CTRL1, 0x64},
-    // reg6E = HW Default
-    // {REG_RX_DES_CTRL2, 0x0C}, // CDR Auto Reset, only CDR
-
-    {0x93,0x43},
-    {0x94,0x4F},
-    {0x95,0x87},
-    {0x96,0x33},
-
-    // {0x9B, 0x01},
-//20100928 added by jau-chih.tseng@ite.com.tw
-    {0x56, 0x01},
-    {0x97, 0x0E},
-//~20100928 jau-chih.tseng@ite.com.tw
-// 2011/08/10 modified by jau-chih.tseng@ite.com.tw
-    {REG_RX_CSC_CTRL,B_VIO_SEL},
-    {REG_RX_TRISTATE_CTRL,0x5F}, // set Tri-state
-//~jau-chih.tseng@ite.com.tw 2011/08/10
-    {0xFF,0xFF}
-
-
-} ;
-//~jjtseng 2006/10/31
-
-void
-SetDefaultRegisterValue()
-{
-    BYTE i ;
-
-    for(i = 0 ; acDefaultValue[i].ucAddr != 0xFF ; i++)
-    {
-        HDMIRX_WriteI2C_Byte(acDefaultValue[i].ucAddr, acDefaultValue[i].ucValue);
-    }
-
-    if(ucRevision >= 0xA3)
-    {
-        HDMIRX_WriteI2C_Byte(0x9B, 0x01);
-    }
-}
-
-///////////////////////////////////////////////////////////
-// Basic IO
-///////////////////////////////////////////////////////////
-
-
-
-
-static void
-ClearIntFlags(BYTE flag)
-{
-    BYTE uc ;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_CTRL);
-    uc &= FLAG_CLEAR_INT_MASK ;
-    uc |= flag ;
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_CTRL,uc);
-    delay1ms(1);
-    uc &= FLAG_CLEAR_INT_MASK ;
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_CTRL,uc);  // write 1, then write 0, the corresponded clear action is activated.
-    delay1ms(1);
-    // HDMIRX_DEBUG_PRINTF(("ClearIntFlags with %02X\n",(int)uc));
-}
-
-static void
-ClearHDCPIntFlags()
-{
-    BYTE uc ;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_CTRL1);
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_CTRL1,(BYTE)B_CLR_HDCP_INT|uc);
-    delay1ms(1);
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_CTRL1, uc&((BYTE)~B_CLR_HDCP_INT));
-}
-
-///////////////////////////////////////////////////
-// IsSCDT()
-// return TRUE if SCDT ON
-// return FALSE if SCDT OFF
-///////////////////////////////////////////////////
-
-BOOL
-IsSCDT()
-{
-    BYTE uc ;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE)&(B_SCDT|B_VCLK_DET/*|B_PWR5V_DET*/);
-    return(uc==(B_SCDT|B_VCLK_DET/*|B_PWR5V_DET*/))?TRUE:FALSE ;
-}
-
-#if 0
-//BOOL
-//IsSCDTOn()
-//{
-//    BYTE bData ;
-//
-//    bData = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-//    // HDMIRX_DEBUG_PRINTF(("IsSCDTOn(): Int1 = %02X\n",(int)bData));
-//
-//    return(bData&B_SCDTON)?TRUE:FALSE ;
-//}
-//
-//BOOL
-//IsSCDTOff()
-//{
-//    BYTE bData ;
-//
-//    bData = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-//    // HDMIRX_DEBUG_PRINTF(("IsSCDTOff(): Int1 = %02X\n",(int)bData));
-//    return(bData&B_SCDTOFF)?TRUE:FALSE ;
-//}
-//
-//BOOL
-//IsSCDTOnOff()
-//{
-//    BYTE bData ;
-//
-//    bData = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-//    return(bData&(B_SCDTOFF|B_SCDTON))?TRUE:FALSE ;
-//}
-#endif
-
-
-BOOL
-CheckPlg5VPwr()
-{
-    BYTE uc ;
-
-    // HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1,&uc);
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-    // HDMIRX_DEBUG_PRINTF(("CheckPlg5VPwr(): REG_RX_SYS_STATE = %02X %s\n",(int)uc,(uc&B_PWR5V_DET)?"TRUE":"FALSE"));
-
-    if(ucCurrentHDMIPort == CAT_HDMI_PORTB)
-    {
-        return(uc&B_PWR5V_DET_PORTB)?TRUE:FALSE ;
-
-    }
-
-    return(uc&B_PWR5V_DET_PORTA)?TRUE:FALSE ;
-}
-
-//BOOL
-//CheckPlg5VPwrOn()
-//{
-//    BYTE uc ;
-//
-//    uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-//    // HDMIRX_DEBUG_PRINTF(("CheckPlg5VPwrOn(): REG_RX_INTERRUPT1 = %02X %s\n",(int)uc,(uc&B_PWR5VON)?"TRUE":"FALSE"));
-//    return(uc&B_PWR5VON)?TRUE:FALSE ;
-//}
-//
-//BOOL
-//CheckPlg5VPwrOff()
-//{
-//    BYTE uc ;
-//
-//    uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-//    // HDMIRX_DEBUG_PRINTF(("CheckPlg5VPwrOff(): REG_RX_INTERRUPT1 = %02X %s\n",(int)uc,(uc&B_PWR5VOFF)?"TRUE":"FALSE"));
-//    return(uc&B_PWR5VOFF)?TRUE:FALSE ;
-//}
-
-#if 0
-// BOOL
-// CheckHDCPFail()
-// {
-//     BYTE uc ;
-//     uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-//     //HDMIRX_DEBUG_PRINTF(("CheckHDCPFail, uc = %02X, %s\n",(int)uc,(uc&B_ECCERR)?"TRUE":"FALSE"));
-//     return(uc&B_ECCERR)?TRUE:FALSE ;
-// }
-#endif
-
-
-void
-SetMUTE(BYTE AndMask, BYTE OrMask)
-{
-    BYTE uc = 0;
-
-    //HDMIRX_DEBUG_PRINTF(("SetMUTE(%02X,%02X)",(int)AndMask,(int)OrMask));
-
-    if(AndMask)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-        //HDMIRX_DEBUG_PRINTF(("%02X ",(int)uc));
-    }
-    uc &= AndMask ;
-    uc |= OrMask ;
-    #ifdef HDMI_REPEATER
-    #pragma message("HDMI Repeating TTL to next stage, do not gatting the video sync.")
-    uc &= 0x1F ;
-    uc |= 0x80 ;
-    #endif
-    HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL,uc);
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-    //HDMIRX_DEBUG_PRINTF(("-> %02x\n",(int)uc));
-}
-
-#if 0
-//void
-//SetMCLKInOUt(BYTE MCLKSelect)
-//{
-//    BYTE uc ;
-//    uc = HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL);
-//    uc &= ~M_MCLKSEL ;
-//    uc |= MCLKSelect ;
-//    HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL, uc);
-//}
-#endif
-
-void
-SetIntMask1(BYTE AndMask,BYTE OrMask)
-{
-    BYTE uc = 0;
-    if(AndMask != 0)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_MASK1);
-    }
-    uc &= AndMask ;
-    uc |= OrMask ;
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_MASK1, uc);
-}
-
-void
-SetIntMask2(BYTE AndMask,BYTE OrMask)
-{
-    BYTE uc = 0;
-    if(AndMask != 0)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_MASK2);
-    }
-    uc &= AndMask ;
-    uc |= OrMask ;
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_MASK2, uc);
-}
-
-void
-SetIntMask3(BYTE AndMask,BYTE OrMask)
-{
-    BYTE uc = 0;
-    if(AndMask != 0)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_MASK3);
-    }
-    uc &= AndMask ;
-    uc |= OrMask ;
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_MASK3, uc);
-}
-
-void
-SetIntMask4(BYTE AndMask,BYTE OrMask)
-{
-    BYTE uc = 0;
-    if(AndMask != 0)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_MASK4);
-    }
-    uc &= AndMask ;
-    uc |= OrMask ;
-    HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_MASK4, uc);
-}
-
-#if 0
-void
-SetGeneralPktType(BYTE type)
-{
-    HDMIRX_WriteI2C_Byte(REG_RX_GEN_PKT_TYPE,type);
-}
-#endif
-
-BOOL
-IsHDMIRXHDMIMode()
-{
-    BYTE uc ;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-    // HDMIRX_DEBUG_PRINTF(("IsHDMIRXHDMIMode(): read %02x from reg%02x, result is %s\n",
-    //(int)uc,(int)REG_RX_SYS_STATE,(uc&B_HDMIRX_MODE)?"TRUE":"FALSE"));
-    return (uc&B_HDMIRX_MODE)?TRUE:FALSE ;
-}
-
-BOOL
-IsHDCPOn()
-{
-    BYTE uc,stat ;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_HDCP_STATUS);
-    stat = HDMIRX_ReadI2C_Byte(REG_RX_VID_INPUT_ST) ;
-    HDMIRX_DEBUG_PRINTF(("reg12 = %02X reg65 = %02X\n",(int)uc,(int)stat)) ;
-    if((uc & 1 )&&(!(stat&8)))
-    {
-        return TRUE ;
-    }
-
-    return FALSE ;
-}
-
-BOOL
-IsHDMIRX_VideoReady()
-{
-    if(VState == VSTATE_VideoOn &&(!MuteByPKG))
-    {
-        return TRUE ;
-    }
-
-    return FALSE ;
-}
-
-BOOL
-IsHDMIRX_AudioReady()
-{
-    if(AState == ASTATE_AudioOn &&(!MuteByPKG))
-    {
-        return TRUE ;
-    }
-
-    return FALSE ;
-}
-
-BOOL
-IsHDMIRX_VideoOn(void)
-{
-    return (VState == VSTATE_VideoOn)?TRUE:FALSE ;
-}
-
-
-BOOL
-EnableHDMIRXVideoOutput(BYTE Option)
-{
-    BYTE uc ;
-    switch(Option)
-    {
-    case VIDEO_ON: bVideoOutputOption = VIDEO_ON ; break ;
-    case VIDEO_OFF: bVideoOutputOption = VIDEO_OFF ; break ;
-    case VIDEO_AUTO: bVideoOutputOption = VIDEO_AUTO ; break ;
-    default:
-        bVideoOutputOption = VIDEO_AUTO ; break ;
-    }
-
-    switch(bVideoOutputOption)
-    {
-    case VIDEO_ON:
-        SetMUTE(~B_TRI_VIDEO,0) ;
-        break ;
-    case VIDEO_OFF:
-        SetMUTE(~B_TRI_VIDEO,B_TRI_VIDEO) ;
-        break ;
-    case VIDEO_AUTO:
-        uc = (VState == VSTATE_VideoOn)?0:B_TRI_VIDEO ;
-        SetMUTE(~B_TRI_VIDEO,uc) ;
-        break ;
-    }
-    return FALSE ;
-}
-///////////////////////////////////////////////////////////
-// Interrupt Service
-///////////////////////////////////////////////////////////
-
-void
-Interrupt_Handler()
-{
-	BYTE int1data = 0 ;
-	BYTE int2data = 0 ;
-	BYTE int3data = 0 ;
-	BYTE int4data = 0 ;
-	BYTE sys_state ;
-	BYTE flag = FLAG_CLEAR_INT_ALL;
-
-    // ClearIntFlags(0);
-    if(VState == VSTATE_SWReset || VState == VSTATE_Off )
-    {
-    	return ; // if SWReset, ignore all interrupt.
-    }
-
-    sys_state = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-
-
-    // int4data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT4);
-    int1data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-
-    if(int1data /*||(int4data&B_RXCKON_DET) */)
-    {
-        HDMIRX_DEBUG_PRINTF3(("system state = %02X\n",(int)sys_state));
-        HDMIRX_DEBUG_PRINTF3(("Interrupt 1 = %02X\n",(int)int1data));
-        // HDMIRX_DEBUG_PRINTF3(("Interrupt 4 = %02X\n",(int)int4data));
-        ClearIntFlags(B_CLR_MODE_INT);
-
-		if(!CheckPlg5VPwr())
-		{
-			if(VState != VSTATE_SWReset && VState != VSTATE_PwrOff)
-			{
-				SWReset_HDMIRX();
-				return ;
-			}
-		}
-
-        if(int1data & B_PWR5VOFF)
-        {
-            HDMIRX_DEBUG_PRINTF(("5V Power Off interrupt\n"));
-            RXINT_5V_PwrOff();
-        }
-
-        if(VState == VSTATE_SWReset)
-        {
-        	return ;
-        }
-
-        if(int1data & B_SCDTOFF)
-        {
-            HDMIRX_DEBUG_PRINTF(("SCDT Off interrupt\n"));
-            RXINT_SCDT_Off();
-        }
-
-        if(int1data & B_PWR5VON)
-        {
-            HDMIRX_DEBUG_PRINTF(("5V Power On interrupt\n"));
-            RXINT_5V_PwrOn();
-        }
-
-
-        if(VState == VSTATE_SyncWait)
-        {
-
-            if(int1data & B_SCDTON)
-            {
-                HDMIRX_DEBUG_PRINTF(("SCDT On interrupt\n"));
-                RXINT_SCDT_On();
-            }
-
-            // if(int4data & B_RXCKON_DET)
-            // {
-            //     HDMIRX_DEBUG_PRINTF(("RXCKON DET interrupt\n"));
-            //     RXINT_RXCKON();
-            // }
-        }
-
-        if( VState == VSTATE_VideoOn || VState == VSTATE_HDCP_Reset)
-        {
-            if(int1data & B_HDMIMODE_CHG)
-            {
-                HDMIRX_DEBUG_PRINTF(("HDMI Mode change interrupt.\n"));
-                RXINT_HDMIMode_Chg();
-            }
-
-            if(int1data & B_VIDMODE_CHG)
-            {
-                HDMIRX_DEBUG_PRINTF(("Video mode change interrupt.\n:"));
-                RXINT_VideoMode_Chg();
-            }
-        }
-
-    }
-
-    int2data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT2);
-	if(VState == VSTATE_VideoOn || VState == VSTATE_HDCP_Reset)
-	{
-        int4data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT4);
-	}
-	else
-	{
-	    int4data = 0 ;
-	}
-    if(int2data||(int4data & B_GENPKT_DET))
-    {
-        BYTE vid_stat = HDMIRX_ReadI2C_Byte(REG_RX_VID_INPUT_ST);
-        HDMIRX_DEBUG_PRINTF2(("Interrupt 2 = %02X\n",(int)int2data));
-        ClearIntFlags(B_CLR_PKT_INT|B_CLR_MUTECLR_INT|B_CLR_MUTESET_INT);
-
-        if(int2data & B_PKT_SET_MUTE)
-        {
-            HDMIRX_DEBUG_PRINTF(("AVMute set interrupt.\n"));
-            RXINT_AVMute_Set();
-        }
-
-        if(int2data & B_NEW_AVI_PKG)
-        {
-            HDMIRX_DEBUG_PRINTF(("New AVI Info Frame Change interrupt\n"));
-            RXINT_SetNewAVIInfo();
-        }
-
-        if((int2data & B_PKT_CLR_MUTE))
-        {
-            HDMIRX_DEBUG_PRINTF(("AVMute clear interrupt.\n"));
-            RXINT_AVMute_Clear();
-        }
-
-    	if(VState == VSTATE_VideoOn || VState == VSTATE_HDCP_Reset)
-    	{
-
-            if(int4data & B_GENPKT_DET)
-            {
-                RXINT_CheckVendorSpecInfo() ;
-            }
-    	}
-    }
-
-    int3data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-
-    if(int3data &(B_R_AUTH_DONE|B_R_AUTH_START))
-    {
-        ClearHDCPIntFlags();
-    #ifdef SUPPORT_REPEATER
-        if(bHDCPMode & HDCP_REPEATER)
-        {
-	        if(int3data & B_R_AUTH_START)
-	        {
-	            HDMIRX_DEBUG_PRINTF((" B_R_AUTH_START\n"));
-	            SwitchRxHDCPState(RXHDCP_AuthStart);
-	        }
-	        if(int3data & B_R_AUTH_DONE)
-	        {
-	            HDMIRX_DEBUG_PRINTF(("B_R_AUTH_DONE \n"));
-	            SwitchRxHDCPState(RXHDCP_AuthDone);
-	        }
-        }
-    #endif // SUPPORT_REPEATER
-    }
-
-	if(VState == VSTATE_VideoOn || VState == VSTATE_HDCP_Reset)
-	{
-	    // int3data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-
-	    if(int3data &(B_ECCERR|B_AUDFIFOERR|B_AUTOAUDMUTE))
-	    {
-	        ClearIntFlags(B_CLR_AUDIO_INT|B_CLR_ECC_INT);
-	        if(AState != ASTATE_AudioOff)
-	        {
-		        if(int3data &(B_AUTOAUDMUTE|B_AUDFIFOERR))
-		        {
-		            HDMIRX_DEBUG_PRINTF3(("Audio Error interupt, int3 = %02X\n",(int)int3data));
-		            RXINT_ResetAudio();
-		            SetIntMask3(~(B_AUTOAUDMUTE|B_AUDFIFOERR),0);
-		        }
-	        }
-
-	        if(int3data & B_ECCERR)
-	        {
-            #ifdef AUTO_SEARCH_EQ_SETTING
-                EccErrorCounter++;
-            #endif
-	            HDMIRX_DEBUG_PRINTF(("int3 = %02X,ECC error interrupt\n",(int)int3data));
-	            RXINT_ResetHDCP();
-	        }
-	    }
-	}
-
-    #ifdef DEBUG
-    if(int1data | int2data)
-    {
-        int1data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1);
-        int2data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT2);
-        int3data = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-        sys_state = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-        HDMIRX_DEBUG_PRINTF2(("%02X %02X %02X %02X\n",
-                                (int)int1data,
-                                (int)int2data,
-                                (int)int3data,
-                                (int)HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT4),
-                                (int)sys_state));
-    }
-    #endif
-
-}
-
-void
-RXINT_CheckVendorSpecInfo(void)
-{
-	BYTE uc ;
-
-    if(ucRevision >= 0xA3)
-    {
-
-        if(HDMIRX_ReadI2C_Byte(REG_RX_GENPKT_HB0)==(VENDORSPEC_INFOFRAME_TYPE|0x80))
-        {
-            HDMIRX_DEBUG_PRINTF2(("Detecting a VENDORSPECIFIC_INFOFRAME\n")) ;
-			bVSIpresent = TRUE ;
-            if((HDMIRX_ReadI2C_Byte(REG_RX_GENPKT_DB4)&0xE0)== 0x40)
-            {
-                HDMIRX_DEBUG_PRINTF2(("Detecting a FramePacking\n")) ;
-                uc = HDMIRX_ReadI2C_Byte(0x3C);
-                uc |=(1<<2);
-                HDMIRX_WriteI2C_Byte(0x3C,uc);
-            }
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_REGPKTFLAG_CTRL) ;
-            uc &= ~B_INT_GENERAL_EVERY ;
-            HDMIRX_WriteI2C_Byte(REG_RX_REGPKTFLAG_CTRL, uc) ;
-        }
-        AssignVideoTimerTimeout(VIDEO_TIMER_CHECK_COUNT);
-    }
-}
-
-void
-RXINT_5V_PwrOn(void)
-{
-    // BYTE sys_state ;
-
-    if(VState == VSTATE_PwrOff)
-    {
-        // sys_state = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-
-        // if(sys_state & B_PWR5VON)
-        if(CheckPlg5VPwr())
-        {
-            SwitchVideoState(VSTATE_SyncWait);
-        }
-    }
-}
-
-void
-RXINT_5V_PwrOff()
-{
-    BYTE sys_state ;
-
-    sys_state = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-
-    SWReset_HDMIRX();
-}
-
-void
-RXINT_SCDT_On()
-{
-    if(VState == VSTATE_SyncWait)
-    {
-        if(IsSCDT())
-        {
-        #ifdef DISABLE_COLOR_DEPTH_RESET
-            SwitchVideoState(VSTATE_SyncChecking);
-        #else
-		// 2011/10/17 added by jau-chih.tseng@ite.com.tw
-			if( bDisableColorDepthResetState == FALSE )
-			{
-            SwitchVideoState(VSTATE_ColorDetectReset);
-        }
-			else
-			{
-            	SwitchVideoState(VSTATE_SyncChecking);
-			}
-		//~jau-chih.tseng@ite.com.tw 2011/10/17
-        #endif
-        }
-    }
-}
-
-//=============================================================================
-// 1. Reg97[5] = '1'
-// 2. Reg05[7][1] = '1' '1'
-// 3. Reg73[3]  = '1'
-//
-// 4. Reg97[5] = '0'
-// 5. REg05[7][1] = '0''0'
-// 6. Reg73[3] = '0'
-//=============================================================================
-
-static
-void CDR_Reset()
-{
-//
-// //	BYTE uc ;
-// // 2009/10/22 modified by Jau-chih.tseng@ite.com.tw
-// // //max7088 20081112 for A2 Jitter Tolerance Issue
-// // 	uc = HDMIRX_ReadI2C_Byte(0x97);
-// // 	HDMIRX_WriteI2C_Byte(0x97,uc|0x20);
-// // 	delay1ms(1);
-// // 	HDMIRX_WriteI2C_Byte(0x97,uc&(~0x20));
-// // //end
-// //
-// //     if(EnaSWCDRRest)
-// //     {
-// //         uc =  B_SWRST | B_CDRRST ;
-// //     }
-// //     else
-// //     {
-// //         uc =  B_CDRRST ;
-// //     }
-// //     EnaSWCDRRest = FALSE ;
-// //     HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, uc|B_EN_AUTOVDORST);
-// //     delay1ms(1);
-// //     HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL,B_EN_AUTOVDORST);
-// //
-// //     uc = HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL);
-// //     HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,uc|B_RSTCD);
-// //     delay1ms(1);
-// //     HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,uc&(~B_RSTCD));
-// //
-//
-// //20091028 follow Ann Suggestion to modify CDRReset()
-//     BYTE uc;
-// 	HDMIRX_DEBUG_PRINTF(("CDR_Reset()\n"));
-//
-//     SetIntMask4(0,0);
-//     SetIntMask1(0,0);
-//
-// // 1. Reg97[5] = '1'
-//     uc = HDMIRX_ReadI2C_Byte(0x97);
-//     HDMIRX_WriteI2C_Byte(0x97,uc|0x20);
-//
-// // 2. Reg05[7][1] = '1' '1'
-//     if(EnaSWCDRRest)
-//     {
-//         HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_SWRST | B_CDRRST|B_EN_AUTOVDORST);
-//     }
-//     else
-//     {
-//         HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_VDORST | B_CDRRST|B_EN_AUTOVDORST);
-//     }
-// // 3. Reg73[3]  = '1'
-//
-//     uc = HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL);
-//     HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,uc |B_RSTCD);
-//
-// // 4. Reg97[5] = '0'
-//     uc = HDMIRX_ReadI2C_Byte(0x97);
-//     HDMIRX_WriteI2C_Byte(0x97,uc&(~0x20));
-//
-// // 5. REg05[7][1] = '0''0'
-//     HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST);
-// // 6. Reg73[3] = '0'
-//     uc = HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL);
-//     HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,uc &(~B_RSTCD));
-// //~Jau-chih.tseng@ite.com.tw 2009/10/22
-//
-// #ifdef SUPPORT_REPEATER
-//     RxHDCPRepeaterCapabilityClear(B_KSV_READY);
-// #endif //SUPPORT_REPEATER
-//     // 2010/08/10 added by jau-chih.tseng@ite.com.tw
-//     // avoid the INT of mode by CDR Reset, clear the mode interrupt by CDR Reset
-//     SetIntMask4(0,B_M_RXCKON_DET);
-//     SetIntMask1(0,B_PWR5VON|B_SCDTON|B_PWR5VOFF);
-//     ClearIntFlags(B_CLR_MODE_INT);
-//     //~jau-chih.tseng@ite.com.tw 2010/08/10
-//
-//     AcceptCDRReset = FALSE ;
-// 	ucDVISCDToffCNT=0;		// 20091021 for VG-859 HDMI / DVI change issue
-//
-}
-
-
-
-void
-RXINT_SCDT_Off()
-{
-
-    if(VState != VSTATE_PwrOff)
-    {
-        HDMIRX_DEBUG_PRINTF(("GetSCDT OFF\n"));
-        SwitchVideoState(VSTATE_SyncWait);
-
-        //2008/10/02 modified by hermes
-        SCDTErrorCnt++;
-    }
-}
-
-void
-RXINT_VideoMode_Chg()
-{
-    BYTE sys_state ;
-
-    // CAT6023/IT6605 only detect video mode change while AVMute clear, thus
-    // the first Video mode change after AVMUTE clear and video on should be
-    // ignore.
-    HDMIRX_DEBUG_PRINTF(("RXINT_VideoMode_Chg\n"));
-
-    sys_state = HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-    // SetALLMute();
-
-    if(CheckPlg5VPwr())
-    {
-        if( bIgnoreVideoChgEvent == FALSE )
-        {
-        SwitchVideoState(VSTATE_SyncWait);
-    }
-    }
-    else
-    {
-        SWReset_HDMIRX();
-    }
-    bIgnoreVideoChgEvent = FALSE ;
-}
-
-void
-RXINT_HDMIMode_Chg()
-{
-    if(VState == VSTATE_VideoOn)
-    {
-        if(IsHDMIRXHDMIMode())
-        {
-            HDMIRX_DEBUG_PRINTF(("HDMI Mode.\n"));
-            SwitchAudioState(ASTATE_RequestAudio);
-            // wait for new AVIInfoFrame to switch color space.
-        }
-        else
-        {
-            HDMIRX_DEBUG_PRINTF(("DVI Mode.\n"));
-            SwitchAudioState(ASTATE_AudioOff);
-            NewAVIInfoFrameF = FALSE ;
-
-            // should switch input color mode to RGB24 mode.
-            SetDVIVideoOutput();
-            // No info frame active.
-        }
-    }
-}
-
-void RXINT_RXCKON()
-{
-    // if(AcceptCDRReset == TRUE)
-    // {
-    //     if((HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE)&(B_VCLK_DET|B_RXCK_VALID))==(B_VCLK_DET|B_RXCK_VALID))
-    //     {
-    //         CDR_Reset();
-    //     }
-    // }
-}
-
-void
-RXINT_AVMute_Set()
-{
-    BYTE uc ;
-    MuteByPKG = ON ;
-    // SetALLMute();
-    SetAudioMute(ON);
-    SetVideoMute(ON);
-    StartAutoMuteOffTimer(); // start AutoMute Timer.
-    SetIntMask2(~(B_PKT_CLR_MUTE),(B_PKT_CLR_MUTE)); // enable the CLR MUTE interrupt.
-
-    bDisableAutoAVMute = 0 ;
-//     uc = HDMIRX_ReadI2C_Byte(REG_RX_RDROM_CLKCTRL);
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-    uc &= ~B_VDO_MUTE_DISABLE ;
-//     HDMIRX_WriteI2C_Byte(REG_RX_RDROM_CLKCTRL, uc);
-    HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-}
-
-void
-RXINT_AVMute_Clear()
-{
-    BYTE uc ;
-    MuteByPKG = OFF ;
-
-    bDisableAutoAVMute = 0 ;
-    // HDMIRX_WriteI2C_Byte(REG_RX_RDROM_CLKCTRL, HDMIRX_ReadI2C_Byte(REG_RX_RDROM_CLKCTRL)&(~B_VDO_MUTE_DISABLE));
-    uc =  HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-    uc &= ~B_VDO_MUTE_DISABLE ;
-    HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-
-    EndAutoMuteOffTimer();
-
-    if(VState == VSTATE_VideoOn)
-    {
-        SetVideoMute(OFF);
-
-    }
-
-    if(AState == ASTATE_AudioOn)
-    {
-        SetHWMuteClr();
-        ClearHWMuteClr();
-
-        SetAudioMute(OFF);
-    }
-    SetIntMask2(~(B_PKT_CLR_MUTE),0); // clear the CLR MUTE interrupt.
-}
-
-void
-RXINT_SetNewAVIInfo()
-{
-    NewAVIInfoFrameF = TRUE ;
-
-    if(VState == VSTATE_VideoOn)
-    {
-        SetNewInfoVideoOutput();
-    }
-
-    prevAVIDB1 = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB1);
-    prevAVIDB2 = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB2);
-
-}
-
-void
-RXINT_ResetAudio()
-{
-    // audio error.
-    if(AState != ASTATE_AudioOff)
-    {
-        SetAudioMute(ON);
-        SwitchAudioState(ASTATE_RequestAudio);
-    }
-}
-
-
-void
-RXINT_ResetHDCP()
-{
-    BYTE uc ;
-
-    if(VState == VSTATE_VideoOn)
-    {
-        ClearIntFlags(B_CLR_ECC_INT);
-        delay1ms(1);
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-
-        if(uc & B_ECCERR)
-        {
-    		SwitchVideoState(VSTATE_HDCP_Reset);
-        }
-
-        // HDCP_Reset();
-        // SetVideoMute(MuteByPKG);
-        // RXINT_ResetAudio(); // reset Audio
-    }
-}
-
-#ifdef AUTO_SEARCH_EQ_SETTING
-BOOL
-IncreaseEQ()
-{
-    if ( initEQTestIdx < MAX_EQ_IDX )
-    {
-        initEQTestIdx++;
-        HDMIRX_WriteI2C_Byte(0x95, EQValue[initEQTestIdx]) ;
-
-        return TRUE;
-    }
-    return FALSE;
-}
-#endif
-///////////////////////////////////////////////////////////
-// Timer Service
-///////////////////////////////////////////////////////////
-
-void
-Timer_Handler()
-{
-
-	Interrupt_Handler();
-    VideoTimerHandler();
-    MuteProcessTimerHandler();
-    AudioTimerHandler();
-#ifdef SUPPORT_REPEATER
-    RxHDCP_Handler();
-#endif // SUPPORT_REPEATER
-}
-
-static void
-VideoTimerHandler()
-{
-	UCHAR uc ;
-
-    if( VState == VSTATE_Off )
-    {
-        return ;
-    }
-
-	if( VideoCountingTimer > 0 )
-	{
-	    VideoCountingTimer -- ;
-	}
-
-#ifndef AUTO_SEARCH_EQ_SETTING
-	//2008/10/02 modified by hermes
-	if(SCDTErrorCnt>= SCDT_LOST_TIMEOUT)
-    {
-		SWReset_HDMIRX();
-	}
-#else
-	//2008/10/02 modified by hermes
-	if(SCDTErrorCnt>= SCDT_LOST_TIMEOUT)
-    {
-        HDMIRX_DEBUG_PRINTF(("SCDTErrorCnt==%d, EQ++\n", (int)SCDTErrorCnt));
-        IncreaseEQ();
-		SWReset_HDMIRX();
-        return;
-	}
-
-    if( SyncDetectFailCounter > 8 && SyncCheckCounter > 8 )
-    {
-        if( IncreaseEQ() )
-        {
-            HDMIRX_DEBUG_PRINTF(("SyncWait/SyncCheck loop, EQ++ ( %d/%d/%d)\n", (int)SyncWaitCounter, (int)SyncCheckCounter, (int)SyncDetectFailCounter ));
-            SyncWaitCounter = 0;
-            SyncCheckCounter = 0;
-            SyncDetectFailCounter = 0;
-    		SWReset_HDMIRX();
-            return;
-        }
-    }
-
-    if ( (VState == VSTATE_VideoOn) )
-    {
-        if( VideoOnTick >= 3000/20 )
-        {
-            static BYTE eq;
-
-            if ( VideoOnTick == 6000/20 )
-            {
-                eq = HDMIRX_ReadI2C_Byte(0x95);
-                switch( eq )
-                {
-                case 0x87 : EQSum[0]++; break;
-                case 0x81 : EQSum[1]++; break;
-                case 0x80 : EQSum[2]++; break;
-                }
-            }
-
-            if( VideoOnTick % 150 == 0 )
-            {
-                HDMIRX_DEBUG_PRINTF(("VideoOnTick = %u, ",VideoOnTick));
-                HDMIRX_DEBUG_PRINTF(("9a=%bX, ", HDMIRX_ReadI2C_Byte(0x9a)));
-                HDMIRX_DEBUG_PRINTF(("85=%bX, ", HDMIRX_ReadI2C_Byte(0x85)));
-                HDMIRX_DEBUG_PRINTF(("95=%bX, ", eq));
-                HDMIRX_DEBUG_PRINTF(("eq+: 87(%u),81(%u),80(%u), rep=%u ", EQSum[0], EQSum[1], EQSum[2], gTestRep ));
-                HDMIRX_DEBUG_PRINTF(("ecc=%d\n", (int)EccErrorCounter));
-            }
-        }
-
-        if( VideoOnTick >= 5000/20 )
-        {
-            if ( EccErrorCounter )
-            {
-                if( IncreaseEQ() )
-                {
-                    HDMIRX_DEBUG_PRINTF(("ECC Error Count after video on, reset !!\n"));
-                    EccErrorCounter = 0;
-                    SWReset_HDMIRX();
-                    return;
-                }
-            }
-        }
-
-    }
-
-    // increase EQ when ECC error
-    if( EccErrorCounter > 100 )
-    {
-        if( IncreaseEQ() )
-        {
-            HDMIRX_DEBUG_PRINTF(("ECC Error Count reach, reset !!\n"));
-            EccErrorCounter = 0;
-            SWReset_HDMIRX();
-            return;
-        }
-    }
-
-#endif
-	// monitor if no state
-	if(VState == VSTATE_SWReset)
-	{
-		if(VideoCountingTimer==0)
-		{
-			Terminator_On();
-			SwitchVideoState(VSTATE_PwrOff);
-			return ;
-		}
-
-		return ;
-	}
-
-#ifdef AUTO_SEARCH_EQ_SETTING
-    if(!CheckPlg5VPwr())
-    {
-        initEQTestIdx = minInitEQIdx ;
-        HDMIRX_WriteI2C_Byte(0x95, EQValue[initEQTestIdx]) ;
-    }
-#endif
-	if(VState == VSTATE_PwrOff)
-	{
-	    if(CheckPlg5VPwr())
-	    {
-            SwitchVideoState(VSTATE_SyncWait);
-            return ;
-	    }
-	}
-
-    // if(VState == VSTATE_SyncWait)//20091021 modify
-    // {
-    //     if(AcceptCDRReset == TRUE)
-    //     {
-    //         if((HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE)&(B_VCLK_DET|B_RXCK_VALID))==(B_VCLK_DET|B_RXCK_VALID))
-    //         {
-    //         	AcceptCDRReset = FALSE;
-    //         	EnaSWCDRRest = FALSE;           //add by hermes 20090323
-    //         	CDR_Reset();
-    //         }
-    //     }
-    // }
-
-	if((VState != VSTATE_PwrOff)&&(VState != VSTATE_SyncWait)&&(VState != VSTATE_SWReset)&&(VState != VSTATE_ColorDetectReset))
-	{
-	    if(!IsSCDT())
-	    {
-            SwitchVideoState(VSTATE_SyncWait);
-            return ;
-	    }
-	}
-	else if((VState != VSTATE_PwrOff)&&(VState != VSTATE_SWReset))
-	{
-	    if(!CheckPlg5VPwr())
-	    {
-            // SwitchVideoState(VSTATE_PwrOff);
-            SWReset_HDMIRX();
-            return ;
-	    }
-	}
-
-    // 2007/01/12 added by jjtseng
-    // add the software reset timeout setting.
-    if(VState == VSTATE_SyncWait || VState == VSTATE_SyncChecking)
-    {
-        SWResetTimeOut-- ;
-        if(SWResetTimeOut == 0)
-        {
-        #ifdef AUTO_SEARCH_EQ_SETTING
-            HDMIRX_DEBUG_PRINTF(("SWResetTimeOut\n"));
-            IncreaseEQ();
-        #endif
-            SWReset_HDMIRX();
-            return ;
-        }
-    }
-    //~jjtseng
-
-    if(VState == VSTATE_SyncWait)
-    {
-
-        if(VideoCountingTimer == 0)
-        {
-            HDMIRX_DEBUG_PRINTF(("VsyncWaitResetTimer up, call SWReset_HDMIRX()\n",VideoCountingTimer));
-            SWReset_HDMIRX();
-            return ;
-            // AssignVideoTimerTimeout(VSTATE_MISS_SYNC_COUNT);
-        }
-        else
-        {
-
-    		uc=HDMIRX_ReadI2C_Byte(REG_RX_SYS_STATE);
-            HDMIRX_DEBUG_PRINTF(("REG_RX_SYS_STATE = %X\r",(int)uc));
-    		uc &=(B_RXPLL_LOCK|B_RXCK_VALID|B_SCDT|B_VCLK_DET);
-
-        #ifdef AUTO_SEARCH_EQ_SETTING
-            if((uc &(B_RXPLL_LOCK|B_RXCK_VALID))==(B_RXPLL_LOCK|B_RXCK_VALID)) // locked
-            {
-                SyncDetectFailCounter++ ;
-                HDMIRX_DEBUG_PRINTF(("SyncDetectFailCounter = %d\n",(int)SyncDetectFailCounter)) ;
-                if( SyncDetectFailCounter > 50 )
-                {
-                    SyncDetectFailCounter = 0;
-                    IncreaseEQ();
-                    SWReset_HDMIRX();
-                    return;
-                }
-            }
-        #endif
-
-    		if(uc ==(B_RXPLL_LOCK|B_RXCK_VALID|B_SCDT|B_VCLK_DET))// for check SCDT !!
-            {
-                #ifdef DISABLE_COLOR_DEPTH_RESET
-                    SwitchVideoState(VSTATE_SyncChecking);
-                #else
-        		// 2011/10/17 added by jau-chih.tseng@ite.com.tw
-        			if( bDisableColorDepthResetState == FALSE )
-        			{
-                SwitchVideoState(VSTATE_ColorDetectReset);
-        			}
-        			else
-        			{
-                    	SwitchVideoState(VSTATE_SyncChecking);
-        			}
-        		//~jau-chih.tseng@ite.com.tw 2011/10/17
-                #endif
-                return ;
-            }
-
-        }
-    }
-
-    if(VState==VSTATE_ColorDetectReset)
-    {
-        if(VideoCountingTimer==0 /*|| (IsSCDT() == TRUE) */)
-        {
-            // SwitchVideoState(VSTATE_ModeDetecting);
-            SwitchVideoState(VSTATE_SyncChecking);
-            return;
-        }
-    }
-
-    if(VState == VSTATE_SyncChecking)
-    {
-        // HDMIRX_DEBUG_PRINTF(("SyncChecking %d\n",VideoCountingTimer));
-        if(VideoCountingTimer == 0)
-        {
-            SwitchVideoState(VSTATE_ModeDetecting);
-            return ;
-        }
-    }
-
-    if(VState == VSTATE_HDCP_Reset)
-    {
-        // HDMIRX_DEBUG_PRINTF(("SyncChecking %d\n",VideoCountingTimer));
-        if(VideoCountingTimer == 0)
-        {
-        	HDMIRX_DEBUG_PRINTF(("HDCP timer reach, reset !!\n"));
-            // SwitchVideoState(VSTATE_PwrOff);
-            SWReset_HDMIRX();
-            return ;
-        }
-        else
-        {
-            HDMIRX_DEBUG_PRINTF(("VideoTimerHandler[VSTATE_HDCP_Reset](%d)\n",VideoCountingTimer));
-            do {
-	        	ClearIntFlags(B_CLR_ECC_INT);
-	        	delay1ms(1);
-	        	uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-	        	if(uc & B_ECCERR)
-	        	{
-	                break ;
-	        	}
-	        	delay1ms(1);
-	        	ClearIntFlags(B_CLR_ECC_INT);
-	        	delay1ms(1);
-	        	uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3);
-	        	if(!(uc & B_ECCERR))
-	        	{
-	                SwitchVideoState(VSTATE_VideoOn);
-	                return ;
-	        	}
-	        }while(0);
-        }
-    }
-
-    if(VState == VSTATE_VideoOn)
-    {
-		char diff ;
-		unsigned short HTotal ;
-		unsigned char xCnt ;
-		BOOL bVidModeChange = FALSE ;
-		BOOL ScanMode ;
-		// bGetSyncInfo();
-
-        #ifdef AUTO_SEARCH_EQ_SETTING
-        VideoOnTick ++;
-        #endif
-
-        if( MuteByPKG == ON )
-        {
-            // if AVMute, ignore the video parameter compare.
-            // if AVMute clear, the video parameter compare should be ignored.
-            AssignVideoTimerTimeout(5) ;
-        }
-        else
-        {
-            if(VideoCountingTimer == 1)
-            {
-                bGetSyncInfo();
-        		currHTotal = s_CurrentVM.HTotal ;
-        		currXcnt = s_CurrentVM.xCnt ;
-        		currScanMode = s_CurrentVM.ScanMode ;
-            }
-        }
-
-        if(VideoCountingTimer == 0)
-        {
-            SCDTErrorCnt = 0 ;
-
-            if( MuteByPKG == OFF )
-            {
-                // modified by jau-chih.tseng@ite.com.tw
-                // Only AVMUTE OFF the video mode can be detected.
-		HTotal =(unsigned short)HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_L);
-		HTotal |=(unsigned short)(HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_H)&M_HTOTAL_H)<< 8 ;
-        		// if(ABS((int)HTotal -(int)currHTotal)>4)
-        		if(HTotal > currHTotal)
-        		{
-        			HTotal -= currHTotal ;
-        		}
-        		else
-        		{
-        			HTotal = currHTotal - HTotal ;
-        		}
-
-        		if(HTotal>4)
-		{
-			bVidModeChange = TRUE ;
-			HDMIRX_DEBUG_PRINTF(("HTotal changed.\n"));
-		}
-
-		if(!bVidModeChange)
-		{
-			xCnt =(unsigned char)HDMIRX_ReadI2C_Byte(REG_RX_VID_XTALCNT_128PEL);
-
-        			// 2011/02/18 modified by jau-chih.tseng@ite.com.tw
-        			// to avoid the compiler calculation error. Change calculating
-        			// method.
-			//diff =(char)currXcnt -(char)xCnt ;
-        			if(currXcnt > xCnt )
-        			{
-        				diff = currXcnt - xCnt ;
-      }
-        			else
-        			{
-        				diff = xCnt - currXcnt ;
-        			}
-        			//~jau-chih.tseng@ite.com.tw 2011/02/18
-
-
-			if(xCnt > 0x80)
-			{
-        				if(diff> 6)
-				{
-					HDMIRX_DEBUG_PRINTF(("Xcnt changed. %02x -> %02x ",(int)xCnt,(int)currXcnt));
-					HDMIRX_DEBUG_PRINTF(("diff = %d\r\n",(int)diff));
-					bVidModeChange = TRUE ;
-				}
-			}
-			else if(xCnt > 0x40)
-			{
-        				if(diff> 4)
-				{
-					HDMIRX_DEBUG_PRINTF(("Xcnt changed. %02x -> %02x ",(int)xCnt,(int)currXcnt));
-					HDMIRX_DEBUG_PRINTF(("diff = %d\r\n",(int)diff));
-					bVidModeChange = TRUE ;
-				}
-			}
-			else if(xCnt > 0x20)
-			{
-        				if(diff> 2)
-				{
-					HDMIRX_DEBUG_PRINTF(("Xcnt changed. %02x -> %02x ",(int)xCnt,(int)currXcnt));
-					HDMIRX_DEBUG_PRINTF(("diff = %d\n\r",(int)diff));
-					bVidModeChange = TRUE ;
-				}
-			}
-			else
-			{
-        				if(diff> 1)
-				{
-					HDMIRX_DEBUG_PRINTF(("Xcnt changed. %02x -> %02x ",(int)xCnt,(int)currXcnt));
-					HDMIRX_DEBUG_PRINTF(("diff = %d\r\n",(int)diff));
-					bVidModeChange = TRUE ;
-				}
-			}
-		}
-
-        if(s_CurrentVM.VActive < 300)
-        {
-    		if(!bVidModeChange)
-    		{
-    			ScanMode =(HDMIRX_ReadI2C_Byte(REG_RX_VID_MODE)&B_INTERLACE)?INTERLACE:PROG ;
-    			if(ScanMode != currScanMode)
-    			{
-    				HDMIRX_DEBUG_PRINTF(("ScanMode change.\r\n"));
-    				bVidModeChange = TRUE ;
-    			}
-    		}
-        }
-            }
-        }
-
-
-
-		if(bVidModeChange)
-		{
-
-			SwitchVideoState(VSTATE_SyncWait);
-			return ;
-		}
-        else
-        {
-            unsigned char currAVI_DB1, currAVI_DB2 ;
-
-            currAVI_DB1 = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB1);
-            currAVI_DB2 = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB2);
-
-            if(IsHDMIRXHDMIMode()){
-                if((currAVI_DB1 != prevAVIDB1)||(currAVI_DB2 != prevAVIDB2)){
-                    RXINT_SetNewAVIInfo();
-                }
-            }
-            prevAVIDB1 = currAVI_DB1 ;
-            prevAVIDB2 = currAVI_DB2 ;
-        }
-
-    }
-}
-
-static void
-SetupAudio()
-{
-    BYTE uc ;
-    BYTE RxAudioCtrl ;
-    getHDMIRXInputAudio(&AudioCaps);
-
-    if(AudioCaps.AudioFlag & B_CAP_AUDIO_ON)
-    {
-        // bCurRxLPCM=(HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT0)&0x02)?FALSE:TRUE;
-        uc=HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL)& 0xF8; // default set 256Fs
-        uc |=0x1; // 256xFs
-        HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL,uc);
-
-        uc=(HDMIRX_ReadI2C_Byte(REG_RX_FS_SET)&0xCF); // avoid audio jitter
-        // uc|=0x10;
-        // 2009/08/24 modified by jjtseng
-        // jitter control set to maximum valud.
-        uc |= 0x70 ;
-        //~jjtseng
-        HDMIRX_WriteI2C_Byte(REG_RX_FS_SET,uc);
-
-        if(AudioCaps.AudioFlag& B_CAP_HBR_AUDIO)
-        {
-
-            Switch_HDMIRX_Bank(0);
-
-            #ifdef _HBR_I2S_
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_HWAMP_CTRL);
-            uc &= ~(1<<4);
-            HDMIRX_WriteI2C_Byte(REG_RX_HWAMP_CTRL, uc);
-            #else
-            HDMIRX_WriteI2C_Byte(REG_RX_HWAMP_CTRL,(HDMIRX_ReadI2C_Byte(REG_RX_HWAMP_CTRL)|0x10));
-            #endif
-
-        #if 1 // for TI DSP HBR only accept 128Fs MCLK
-            uc=HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL)& 0xF8;
-            uc |=0x0; // 128xFs
-            HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL,uc);
-        #endif
-
-            SetHWMuteClrMode();
-            ResetAudio();//mingchih add
-        }
-        else if(AudioCaps.AudioFlag& B_CAP_DSD_AUDIO)
-        {
-            // TBD.
-            SetHWMuteClrMode();
-            ResetAudio();//mingchih add
-        }
-        else // if(AudioCaps.AudioFlag& B_CAP_LPCM)// not only LPCM but all use audio sample packet need this fixing.
-        {
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_HWAMP_CTRL);
-            HDMIRX_WriteI2C_Byte(REG_RX_HWAMP_CTRL,uc &(~0x10));
-
-            ucHDMIAudioErrorCount++;
-            RxAudioCtrl=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CTRL);
-
-            if(ucHDMIAudioErrorCount > 10)
-            {
-                ucHDMIAudioErrorCount=0;
-                // 2009/02/10 added by Jau-Chih.Tseng@ite.com.tw
-                // change the force FS to be toggled to avoid something unknow wrong.
-                if(RxAudioCtrl & B_FORCE_FS)// 20090211
-                {
-                    RxAudioCtrl &= ~B_FORCE_FS;
-                }
-                //~Jau-Chih.Tseng@ite.com.tw 2009/02/10
-                else
-                {
-                    // Force Sample FS setting progress:
-                    // a. if find Audio Error in a period timers,
-                    // assum the FS message is wrong,then try to force FS setting.
-                    // force sequence : 48KHz -> 44.1KHz -> 32KHz -> 96KHz ->  192KHz ->
-                    //(88.2KHz -> 176.4KHz)
-                    // -> 48KHz
-                    switch(ucAudioSampleClock)
-                    {
-                    case AUDFS_192KHz: ucAudioSampleClock=AUDFS_48KHz;break ;// default: -> 48KHz
-
-                    case AUDFS_48KHz: ucAudioSampleClock=AUDFS_44p1KHz;break ;//
-                    case AUDFS_44p1KHz: ucAudioSampleClock=AUDFS_32KHz;break ;//
-                    case AUDFS_32KHz: ucAudioSampleClock=AUDFS_96KHz;break ;//
-
-                #ifndef SUPPORT_FORCE_88p2_176p4
-
-                    case AUDFS_96KHz: ucAudioSampleClock=AUDFS_192KHz;break ;//
-
-                #else // SUPPORT_FORCE_88p2_176p4
-
-                    case AUDFS_88p2KHz: ucAudioSampleClock=AUDFS_176p4KHz;break ;//
-                    case AUDFS_96KHz: ucAudioSampleClock=AUDFS_88p2KHz;break ;//
-                    case AUDFS_176p4KHz: ucAudioSampleClock=AUDFS_192KHz;break ;//
-
-                #endif
-
-                    default: ucAudioSampleClock=AUDFS_48KHz;break;// ? -> 48KHz
-                    }
-                    HDMIRX_DEBUG_PRINTF(("===[Audio FS Error ]===\n"));
-                    RxAudioCtrl |=B_FORCE_FS;
-                }
-                // if B_FORCE_FS changed, update REG_RX_audio change.
-            }
-            RxAudioCtrl |= B_EN_I2S_NLPCM ;
-            HDMIRX_WriteI2C_Byte(REG_RX_AUDIO_CTRL,RxAudioCtrl);// reg77[6]=?
-
-
-            // 2010/12/03 modified by Max.Kao@ite.com.tw
-            // This bit will affect the force Fs fail.
-            // Do not set this.
-            // uc=HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL);
-            // if(RxAudioCtrl & B_FORCE_FS)
-            // {
-            //     // b. set Reg0x77[6]=1=> select Force FS mode.
-            //     // c. set Reg0x78[5]=1=> CTSINI_EN=1
-            //     uc|=B_CTSINI_EN;
-            // }
-            // else
-            // {
-            //     uc &= ~B_CTSINI_EN;
-            // }
-            // HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL, uc);
-            //~Max.Kao@ite.com.tw 2010/12/03
-
-            SetHWMuteClrMode();
-            // d. set Reg0x05=04=> reset Audio
-            // e. set Reg0x05=0
-            ResetAudio();
-
-            if(RxAudioCtrl & B_FORCE_FS)
-            {
-                // f. set Reg0x7e[3:0]=0(at leasst three times)=> force FS value
-                // g. if Audio still Error,then repeat b~f setps.(on f setp,set another FS value
-                // 0:44,1K,2: 48K,3:32K,8:88.2K,A:96K,C:176.4K,E:192K)
-                uc=HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL);
-                uc &= 0xF0 ;
-                uc |= ucAudioSampleClock & 0xF ;
-                HDMIRX_WriteI2C_Byte(REG_RX_FS_SET,uc);
-                HDMIRX_WriteI2C_Byte(REG_RX_FS_SET,uc);
-                HDMIRX_WriteI2C_Byte(REG_RX_FS_SET,uc);
-                HDMIRX_WriteI2C_Byte(REG_RX_FS_SET,uc);
-            }
-            SetIntMask3(~(B_AUTOAUDMUTE|B_AUDFIFOERR),(B_AUTOAUDMUTE|B_AUDFIFOERR)); // enable Audio Error Interrupt
-        }
-        /*
-        else // NLPCM
-        {
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_HWAMP_CTRL);
-            HDMIRX_WriteI2C_Byte(REG_RX_HWAMP_CTRL,uc &(~0x10));
-            SetHWMuteClrMode();
-            ResetAudio();//mingchih add
-
-        }
-        */
-        ClearIntFlags(B_CLR_AUDIO_INT);
-        SetIntMask3(~(B_AUTOAUDMUTE|B_AUDFIFOERR),(B_AUTOAUDMUTE|B_AUDFIFOERR));
-        SwitchAudioState(ASTATE_WaitForReady);
-
-    }
-    else
-    {
-        ucHDMIAudioErrorCount = 0 ;
-    // 2009/02/10 added by Jau-Chih.Tseng@ite.com.tw
-        ucAudioSampleClock=DEFAULT_START_FIXED_AUD_SAMPLEFREQ ;
-        // ucAudioSampleClock=AUDFS_192KHz ;
-    //~Jau-Chih.Tseng@ite.com.tw 2009/02/10
-
-        uc=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CTRL);
-        uc &= ~B_FORCE_FS ;
-        HDMIRX_WriteI2C_Byte(REG_RX_AUDIO_CTRL, uc);
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL);
-        uc &= ~B_CTSINI_EN;
-        HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL, uc);
-        HDMIRX_DEBUG_PRINTF2(("Audio Off, clear Audio Error Count.\n"));
-    }
-}
-
-static void
-EnableAudio()
-{
-#ifndef DISABLE_AUDIO_SUPPORT
-    // Enable Audio
-    SetupAudio();
-
-    delay1ms(5);
-
-    if(AudioCaps.AudioFlag & B_CAP_AUDIO_ON)
-    {
-        if(HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT3)&(B_AUTOAUDMUTE|B_AUDFIFOERR))
-        {
-            SwitchAudioState(ASTATE_RequestAudio);
-        }
-        else
-        {
-            SwitchAudioState(ASTATE_AudioOn);
-        }
-    }
-    else
-    {
-        SwitchAudioState(ASTATE_RequestAudio);
-    }
-#else
-        SwitchAudioState(ASTATE_AudioOff);
-#endif
-
-}
-
-void AudioTimerHandler()
-{
-#ifndef DISABLE_AUDIO_SUPPORT
-    BYTE uc;
-    AUDIO_CAPS CurAudioCaps ;
-
-    switch(AState)
-    {
-    case ASTATE_RequestAudio:
-        SetupAudio();
-        break;
-
-    case ASTATE_WaitForReady:
-        if(AudioCountingTimer==0)
-        {
-            SwitchAudioState(ASTATE_AudioOn);
-        }
-        else
-        {
-            AudioCountingTimer --;
-        }
-
-        break;
-
-    case ASTATE_AudioOn:
-        getHDMIRXInputAudio(&CurAudioCaps);
-
-        if(AudioCaps.AudioFlag != CurAudioCaps.AudioFlag
-           /* || AudioCaps.AudSrcEnable != CurAudioCaps.AudSrcEnable
-           || AudioCaps.SampleFreq != CurAudioCaps.SampleFreq */)
-        {
-
-            ucHDMIAudioErrorCount=0;
-            // 2009/02/10 added by Jau-Chih.Tseng@ite.com.tw
-            // ucAudioSampleClock=AUDFS_48KHz ;
-            ucAudioSampleClock = DEFAULT_START_FIXED_AUD_SAMPLEFREQ;
-            //~Jau-Chih.Tseng@ite.com.tw 2009/02/10
-            uc=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CTRL);
-            uc &= ~B_FORCE_FS ;
-            HDMIRX_WriteI2C_Byte(REG_RX_AUDIO_CTRL, uc);
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL);
-            uc &= ~B_CTSINI_EN;
-            HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL, uc);
-
-            HDMIRX_DEBUG_PRINTF(("Audio change, clear Audio Error Count.\n"));
-
-            SetAudioMute(ON);
-            SwitchAudioState(ASTATE_RequestAudio);
-
-        }
-
-		if(AudioCountingTimer != 0)
-        {
-            AudioCountingTimer -- ;
-            if(AudioCountingTimer == 0)
-            {
-                ucHDMIAudioErrorCount=0 ;
-    			HDMIRX_DEBUG_PRINTF(("Audio On, clear Audio Error Count.\n"));
-            }
-        }
-
-
-        break;
-    }
-#endif
-}
-
-
-BYTE    HDMIRXFsGet()
-{
-    BYTE RxFS ;
-    RxFS=HDMIRX_ReadI2C_Byte(REG_RX_FS)& 0x0F;
-    return    RxFS;
-}
-
-//=============================================================================
-BOOL    HDMIRXHDAudioGet()
-{
-    BOOL bRxHBR ;
-    bRxHBR=(HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT)&(1<<6))?TRUE:FALSE;
-    return    bRxHBR;
-}
-
-//=============================================================================
-BOOL    HDMIRXMultiPCM()
-{
-    BOOL bRxMultiCh ;
-    bRxMultiCh=(HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT)&(1<<4))?TRUE:FALSE;
-    return    bRxMultiCh;
-}
-
-//=============================================================================
-BYTE    HDMIRXAudioChannelNum()
-{
-    BYTE RxChEn ;
-    RxChEn=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT)& M_AUDIO_CH;
-
-    return     RxChEn;
-}
-//=============================================================================
-void    HDMIRXHBRMclkSet(BYTE cFs)
-{
-    BYTE    uc;
-    uc=HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL)& 0xF8;
-
-    switch(cFs)
-    {
-    case    9:
-        uc |=0x0;    // 128xFs
-        break;
-    default:
-        uc |=0x1;    // 256xFs
-        break;
-
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL,uc);
-
-}
-
-void getHDMIRXInputAudio(AUDIO_CAPS *pAudioCaps)
-{
-    BYTE uc ;
-
-    if(!pAudioCaps)
-    {
-        return ;
-    }
-    Switch_HDMIRX_Bank(0);
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_FS);
-    pAudioCaps->SampleFreq=uc&M_Fs ;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT);
-    pAudioCaps->AudioFlag = uc & 0xF0 ;
-    pAudioCaps->AudSrcEnable=uc&M_AUDIO_CH ;
-    delay1ms(1);
-    pAudioCaps->AudSrcEnable|=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT)&M_AUDIO_CH ;
-    delay1ms(1);
-    pAudioCaps->AudSrcEnable|=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT)&M_AUDIO_CH ;
-    delay1ms(1);
-    pAudioCaps->AudSrcEnable|=HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT)&M_AUDIO_CH ;
-
-    if((uc &(B_HBRAUDIO|B_DSDAUDIO))== 0)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT0);
-
-        if((uc & B_AUD_NLPCM)== 0)
-        {
-            pAudioCaps->AudioFlag |= B_CAP_LPCM;
-        }
-    }
-
-}
-
-void getHDMIRXInputChStat(AUDIO_CAPS *pAudioCaps)
-{
-    BYTE uc ;
-
-    if(!pAudioCaps)
-    {
-        return ;
-    }
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT0);
-    pAudioCaps->ChStat[0] = uc;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT1);
-    pAudioCaps->ChStat[1] = uc;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT2);
-    pAudioCaps->ChStat[2] = uc;
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT3);
-
-    pAudioCaps->ChStat[3] = uc & M_CLK_ACCURANCE;
-    pAudioCaps->ChStat[3] <<= 4 ;
-    pAudioCaps->ChStat[3] |=((BYTE)pAudioCaps->SampleFreq)&0xF ;
-
-    pAudioCaps->ChStat[4] =(~((BYTE)pAudioCaps->SampleFreq))&0xF ;
-    pAudioCaps->ChStat[4] <<= 4 ;
-    pAudioCaps->ChStat[4] |=(uc & M_SW_LEN)>>O_SW_LEN;
-
-
-}
-
-static void
-MuteProcessTimerHandler()
-{
-    BYTE uc ;
-    BOOL TurnOffMute = FALSE ;
-
-    if(MuteByPKG == ON)
-    {
-        // HDMIRX_DEBUG_PRINTF(("MuteProcessTimerHandler()\n"));
-        if((MuteResumingTimer > 0)&&(VState == VSTATE_VideoOn))
-        {
-            MuteResumingTimer -- ;
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_VID_INPUT_ST);
-            HDMIRX_DEBUG_PRINTF(("MuteResumingTimer = %d uc = %02X\n",MuteResumingTimer ,(int)uc));
-
-            if(!(uc&B_AVMUTE))
-            {
-                TurnOffMute = TRUE ;
-                MuteByPKG = OFF ;
-            }
-            else if((MuteResumingTimer == 0))
-            {
-                bDisableAutoAVMute = B_VDO_MUTE_DISABLE ;
-
-                uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-                uc |= B_VDO_MUTE_DISABLE ;
-                HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-
-                TurnOffMute = TRUE ;
-                MuteByPKG = OFF ;
-            }
-        }
-
-        if(MuteAutoOff)
-        {
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_VID_INPUT_ST);
-            if(!(uc & B_AVMUTE))
-            {
-                EndAutoMuteOffTimer();
-                TurnOffMute = TRUE ;
-            }
-        }
-    }
-
-    if(TurnOffMute)
-    {
-        if(VState == VSTATE_VideoOn)
-        {
-            SetVideoMute(OFF);
-            if(AState == ASTATE_AudioOn)
-            {
-                SetAudioMute(OFF);
-            }
-            TurnOffMute = FALSE ;
-        }
-    }
-}
-
-
-void
-AssignVideoTimerTimeout(USHORT TimeOut)
-{
-    VideoCountingTimer = TimeOut ;
-}
-
-void
-AssignAudioTimerTimeout(USHORT TimeOut)
-{
-    AudioCountingTimer = TimeOut ;
-
-}
-
-#if 0
-void
-ResetVideoTimerTimeout()
-{
-    VideoCountingTimer = 0 ;
-}
-
-void
-ResetAudioTimerTimeout()
-{
-    AudioCountingTimer = 0 ;
-}
-#endif
-
-void
-SwitchVideoState(Video_State_Type state)
-{
-    BYTE uc ;
-	if(VState == state)
-	{
-		return ;
-	}
-
-    if(VState == VSTATE_VideoOn && state != VSTATE_VideoOn)
-    {
-    	// SetALLMute();
-
-        SwitchAudioState(ASTATE_AudioOff);
-    }
-
-    HDMIRX_DEBUG_PRINTF(("RX VState %s -> %s\n",VStateStr[VState],VStateStr[state]));
-    VState = state ;
-
-    if(VState != VSTATE_SyncWait && VState != VSTATE_SyncChecking)
-    {
-        SWResetTimeOut = FORCE_SWRESET_TIMEOUT;
-        // init the SWResetTimeOut, decreasing when timer.
-        // if down to zero when SyncWait or SyncChecking,
-        // SWReset.
-    }
-
-    switch(bVideoOutputOption)
-    {
-    case VIDEO_OFF:
-        SetMUTE(~B_TRI_VIDEO,B_TRI_VIDEO) ;
-        break ;
-    case VIDEO_ON:
-        SetMUTE(~B_TRI_VIDEO,0) ;
-        break ;
-    case VIDEO_AUTO:
-    default:
-        if( VState == VSTATE_VideoOn
-            || VState == VSTATE_HDCP_Reset
-            || VState == VSTATE_SyncChecking
-            || VState == VSTATE_ModeDetecting )
-        {
-            SetMUTE(~B_TRI_VIDEO,0) ;
-        }
-        else
-        {
-            SetMUTE(~B_TRI_VIDEO,B_TRI_VIDEO) ;
-        }
-    }
-
-
-    switch(VState)
-    {
-    case VSTATE_PwrOff:
-        AcceptCDRReset = TRUE ;
-        #ifdef AUTO_SEARCH_EQ_SETTING
-        SyncDetectFailCounter = 0;
-        SyncWaitCounter = 0;
-        SyncCheckCounter = 0;
-        #endif
-
-        break ;
-    case VSTATE_SWReset:
-        // HDMIRX_WriteI2C_Byte(REG_RX_GEN_PKT_TYPE, 0x03); // set default general control packet received in 0xA8
-        AssignVideoTimerTimeout(VSTATE_SWRESET_COUNT);
-    	break ;
-    case VSTATE_SyncWait:
-        #ifdef AUTO_SEARCH_EQ_SETTING
-        SyncWaitCounter++;
-        #endif
-        HDMIRX_WriteI2C_Byte(REG_RX_REGPKTFLAG_CTRL,0);
-        SetIntMask1(~(B_SCDTOFF|B_VIDMODE_CHG),0);
-        if(ucRevision >= 0xA3)
-        {
-            uc = HDMIRX_ReadI2C_Byte(0x3C);
-            uc &= ~(1<<2);
-            HDMIRX_WriteI2C_Byte(0x3C, uc);
-        }
-		bVSIpresent=FALSE ;
-        SetVideoMute(ON);
-        AssignVideoTimerTimeout(VSTATE_MISS_SYNC_COUNT);
-        break ;
-    #ifndef DISABLE_COLOR_DEPTH_RESET
-    case VSTATE_ColorDetectReset:
-
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT_MASK1) &(~B_SCDTOFF) ;
-        HDMIRX_WriteI2C_Byte(REG_RX_INTERRUPT_MASK1, uc) ;
-        ClearIntFlags(B_CLR_MODE_INT);
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL) & (~B_RSTCD);
-        HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,B_RSTCD|uc) ;
-        HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,uc) ;
-        AssignVideoTimerTimeout(MS_TimeOut(400));
-        break ;
-    #endif
-
-    case VSTATE_SyncChecking:
-        #ifdef AUTO_SEARCH_EQ_SETTING
-        SyncCheckCounter++;
-        #endif
-        HDMIRX_WriteI2C_Byte(REG_RX_GEN_PKT_TYPE, 0x81); // set default general control packet received in 0xA8
-        HDMIRX_WriteI2C_Byte(REG_RX_REGPKTFLAG_CTRL, B_INT_GENERAL_EVERY) ;
-        AssignVideoTimerTimeout(VSATE_CONFIRM_SCDT_COUNT);
-        HDMIRX_ReadI2C_Byte(REG_RX_CHANNEL_ERR) ; // read 0x85 for clear CDR counter in reg9A.
-        HDMIRX_DEBUG_PRINTF(("switch VSTATE_SyncChecking, reg9A = %02X\n",(int)HDMIRX_ReadI2C_Byte(0x9A))) ;
-        break ;
-	case VSTATE_HDCP_Reset:
-        SetVideoMute(ON);
-		AssignVideoTimerTimeout(HDCP_WAITING_TIMEOUT);
-		break ;
-    case VSTATE_VideoOn:
-
-        #ifdef AUTO_SEARCH_EQ_SETTING
-        VideoOnTick = 0;
-        EccErrorCounter = 0;
-        #endif
-
-        SetIntMask1(~(B_SCDTOFF|B_VIDMODE_CHG),(B_SCDTOFF|B_VIDMODE_CHG));
-        AssignVideoTimerTimeout(5);
-        // AcceptCDRReset = TRUE ;
-
-        AssignVideoTimerTimeout(CDRRESET_TIMEOUT);
-        if(!NewAVIInfoFrameF)
-        {
-            SetVideoInputFormatWithoutInfoFrame(F_MODE_RGB24);
-            SetColorimetryByMode(/*&SyncInfo*/);
-            SetColorSpaceConvert();
-        }
-
-        if(!IsHDMIRXHDMIMode())
-        {
-            SetIntMask1(~(B_SCDTOFF|B_PWR5VOFF),(B_SCDTOFF|B_PWR5VOFF));
-            SetVideoMute(OFF); // turned on Video.
-            SwitchAudioState(ASTATE_AudioOff);
-            NewAVIInfoFrameF = FALSE ;
-        }
-        else
-        {
-
-            if(NewAVIInfoFrameF)
-            {
-                SetNewInfoVideoOutput();
-            }
-
-        #ifdef SUPPORT_REPEATER
-            if(bHDCPMode & HDCP_REPEATER)
-            {
-                SetIntMask3(0,B_ECCERR|B_R_AUTH_DONE|B_R_AUTH_START);
-        	}
-        	else
-        #endif // SUPPORT_REPEATER
-        	{
-                SetIntMask3(~(B_R_AUTH_DONE|B_R_AUTH_START),B_ECCERR);
-        	}
-            SetIntMask2(~(B_NEW_AVI_PKG|B_PKT_SET_MUTE|B_PKT_CLR_MUTE),(B_NEW_AVI_PKG|B_PKT_SET_MUTE|B_PKT_CLR_MUTE));
-            SetIntMask1(~(B_SCDTOFF|B_PWR5VOFF),(B_SCDTOFF|B_PWR5VOFF));
-            SetIntMask4(0,B_M_RXCKON_DET);
-
-            MuteByPKG =(HDMIRX_ReadI2C_Byte(REG_RX_VID_INPUT_ST)& B_AVMUTE)?TRUE:FALSE ;
-            bIgnoreVideoChgEvent = MuteByPKG ;
-
-            SetVideoMute(MuteByPKG); // turned on Video.
-            ucHDMIAudioErrorCount = 0 ;
-            // 2009/02/10 added by Jau-Chih.Tseng@ite.com.tw
-            ucAudioSampleClock=DEFAULT_START_FIXED_AUD_SAMPLEFREQ ;
-            // ucAudioSampleClock=3 ;
-            //~Jau-Chih.Tseng@ite.com.tw 2009/02/10
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CTRL);
-            uc &= ~B_FORCE_FS ;
-            HDMIRX_WriteI2C_Byte(REG_RX_AUDIO_CTRL, uc);
-
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_MCLK_CTRL)&(~B_CTSINI_EN);
-            HDMIRX_WriteI2C_Byte(REG_RX_MCLK_CTRL, uc);
-
-            HDMIRX_DEBUG_PRINTF2(("[%s:%d] reg%02X = %02X\n",__FILE__,__LINE__,(int)REG_RX_AUDIO_CTRL,(int)uc));
-
-			#ifndef DISABLE_AUDIO_SUPPORT
-				EnableAudio();
-			#else
-            	SwitchAudioState(ASTATE_AudioOff);
-			#endif
-        }
-
-		currHTotal = s_CurrentVM.HTotal ;
-		currXcnt = s_CurrentVM.xCnt ;
-		currScanMode = s_CurrentVM.ScanMode ;
-
-        break ;
-    }
-}
-
-void
-SwitchAudioState(Audio_State_Type state)
-{
-#ifdef DISABLE_AUDIO_SUPPORT
-    AState = ASTATE_AudioOff ;
-    SetAudioMute(TRUE);
-	return ;
-#else
-    AState = state ;
-    HDMIRX_DEBUG_PRINTF(("AState -> %s\n",AStateStr[AState]));
-
-    switch(AState)
-    {
-    case ASTATE_AudioOff:
-        SetAudioMute(TRUE);
-        break ;
-
-    case ASTATE_WaitForReady:
-        AssignAudioTimerTimeout(AUDIO_READY_TIMEOUT);
-        break ;
-    case ASTATE_AudioOn:
-        SetAudioMute(MuteByPKG);
-        AssignAudioTimerTimeout(AUDIO_CLEARERROR_TIMEOUT); // set one second adjusting to reset ucAudioErrorCount.
-        if(MuteByPKG)
-        {
-            HDMIRX_DEBUG_PRINTF(("AudioOn, but still in mute.\n"));
-            EnableMuteProcessTimer();
-        }
-        break ;
-    }
-#endif
-}
-
-
-
-static void
-DumpSyncInfo(HDMI_VTiming *pVTiming)
-{
-    double VFreq ;
-    HDMIRX_DEBUG_PRINTF2(("{%4d,",pVTiming->HActive));
-    HDMIRX_DEBUG_PRINTF2(("%4d,",pVTiming->VActive));
-    HDMIRX_DEBUG_PRINTF2(("%4d,",pVTiming->HTotal));
-    HDMIRX_DEBUG_PRINTF2(("%4d,",pVTiming->VTotal));
-    HDMIRX_DEBUG_PRINTF2(("%8ld,",pVTiming->PCLK));
-    HDMIRX_DEBUG_PRINTF2(("0x%02x,",pVTiming->xCnt));
-    HDMIRX_DEBUG_PRINTF2(("%3d,",pVTiming->HFrontPorch));
-    HDMIRX_DEBUG_PRINTF2(("%3d,",pVTiming->HSyncWidth));
-    HDMIRX_DEBUG_PRINTF2(("%3d,",pVTiming->HBackPorch));
-    HDMIRX_DEBUG_PRINTF2(("%2d,",pVTiming->VFrontPorch));
-    HDMIRX_DEBUG_PRINTF2(("%2d,",pVTiming->VSyncWidth));
-    HDMIRX_DEBUG_PRINTF2(("%2d,",pVTiming->VBackPorch));
-    HDMIRX_DEBUG_PRINTF2(("%s,",pVTiming->ScanMode?"PROG":"INTERLACE"));
-    HDMIRX_DEBUG_PRINTF2(("%s,",pVTiming->VPolarity?"Vpos":"Vneg"));
-    HDMIRX_DEBUG_PRINTF2(("%s},",pVTiming->HPolarity?"Hpos":"Hneg"));
-    VFreq =(double)pVTiming->PCLK ;
-    VFreq *= 1000.0 ;
-    VFreq /= pVTiming->HTotal ;
-    VFreq /= pVTiming->VTotal ;
-    HDMIRX_DEBUG_PRINTF2(("/* %dx%d@%5.2lfHz */\n",pVTiming->HActive,pVTiming->VActive,VFreq));
-}
-
-static BOOL
-bGetSyncInfo()
-{
-
-    BYTE uc1, uc2, uc3 ;
-#ifdef USE_MODE_TABLE
-    long diff ;
-    int i ;
-#endif
-//    pVTiming = NULL ;
-
-//    pVTiming = &s_CurrentVM ;
-    uc1 = HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_L);
-    uc2 = HDMIRX_ReadI2C_Byte(REG_RX_VID_HTOTAL_H);
-    uc3 = HDMIRX_ReadI2C_Byte(REG_RX_VID_HACT_L);
-
-    s_CurrentVM.HTotal =((WORD)(uc2&0xF)<<8)|(WORD)uc1;
-    s_CurrentVM.HActive =((WORD)(uc2 & 0x70)<<4)|(WORD)uc3 ;
-    if((s_CurrentVM.HActive |(1<<11))<s_CurrentVM.HTotal)
-    {
-        s_CurrentVM.HActive |=(1<<11);
-    }
-    uc1 = HDMIRX_ReadI2C_Byte(REG_RX_VID_HSYNC_WID_L);
-    uc2 = HDMIRX_ReadI2C_Byte(REG_RX_VID_HSYNC_WID_H);
-    uc3 = HDMIRX_ReadI2C_Byte(REG_RX_VID_H_FT_PORCH_L);
-
-    s_CurrentVM.HSyncWidth =((WORD)(uc2&0x1)<<8)|(WORD)uc1;
-    s_CurrentVM.HFrontPorch =((WORD)(uc2 & 0xf0)<<4)|(WORD)uc3 ;
-    s_CurrentVM.HBackPorch = s_CurrentVM.HTotal - s_CurrentVM.HActive - s_CurrentVM.HSyncWidth - s_CurrentVM.HFrontPorch ;
-
-    uc1 = HDMIRX_ReadI2C_Byte(REG_RX_VID_VTOTAL_L);
-    uc2 = HDMIRX_ReadI2C_Byte(REG_RX_VID_VTOTAL_H);
-    uc3 = HDMIRX_ReadI2C_Byte(REG_RX_VID_VACT_L);
-
-    s_CurrentVM.VTotal =((WORD)(uc2&0x7)<<8)|(WORD)uc1;
-    s_CurrentVM.VActive =((WORD)(uc2 & 0x30)<<4)|(WORD)uc3 ;
-    if((s_CurrentVM.VActive |(1<<10))<s_CurrentVM.VTotal)
-    {
-        s_CurrentVM.VActive |=(1<<10);
-    }
-
-    s_CurrentVM.VBackPorch = HDMIRX_ReadI2C_Byte(REG_RX_VID_VSYNC2DE);
-    s_CurrentVM.VFrontPorch = HDMIRX_ReadI2C_Byte(REG_RX_VID_V_FT_PORCH);
-    s_CurrentVM.VSyncWidth = 0 ;
-
-    s_CurrentVM.ScanMode =(HDMIRX_ReadI2C_Byte(REG_RX_VID_MODE)&B_INTERLACE)?INTERLACE:PROG ;
-
-    s_CurrentVM.xCnt = HDMIRX_ReadI2C_Byte(REG_RX_VID_XTALCNT_128PEL);
-
-    if(s_CurrentVM.xCnt)
-    {
-        s_CurrentVM.PCLK = 128L * 27000L / s_CurrentVM.xCnt ;
-    }
-    else
-    {
-        HDMIRX_DEBUG_PRINTF(("s_CurrentVM.xCnt == %02x\n",s_CurrentVM.xCnt));
-        s_CurrentVM.PCLK = 1234 ;
-        /*
-        for(i = 0x58 ; i < 0x66 ; i++)
-        {
-            HDMIRX_DEBUG_PRINTF(("HDMIRX_ReadI2C_Byte(%02x)= %02X\n",i,(int)HDMIRX_ReadI2C_Byte(i)));
-        }
-        */
-        return FALSE ;
-    }
-
-    // HDMIRX_DEBUG_PRINTF(("Current Get: ")); DumpSyncInfo(&s_CurrentVM);
-    // HDMIRX_DEBUG_PRINTF(("Matched %d Result in loop 1: ", i)); DumpSyncInfo(pVTiming);
-
-#ifndef USE_MODE_TABLE
-	if((s_CurrentVM.VActive > 200)
-		&&(s_CurrentVM.VTotal>s_CurrentVM.VActive)
-		&&(s_CurrentVM.HActive > 300)
-		&&(s_CurrentVM.HTotal>s_CurrentVM.HActive))
-	{
-		return TRUE ;
-	}
-#else
-    #pragma message("USE_MODE_TABLE definition enabled.")
-	// return TRUE ;
-    for(i = 0 ; i < SizeofVMTable ; i++)
-    {
-        // 2006/10/17 modified by jjtseng
-        // Compare PCLK in 3% difference instead of comparing xCnt
-
-        // diff =(long)s_VMTable[i].xCnt -(long)s_CurrentVM.xCnt ;
-        // if(ABS(diff)> 1)
-        // {
-        //     continue ;
-        // }
-        //~jjtseng 2006/10/17
-
-		// 2011/02/18 modified by jau-chih.tseng@ite.com.tw
-		// to avoid the compiler calculation error. Change calculating
-		// method.
-        // diff = ABS(s_VMTable[i].PCLK - s_CurrentVM.PCLK);
-        if(s_VMTable[i].PCLK - s_CurrentVM.PCLK)
-		{
-			diff = s_VMTable[i].PCLK - s_CurrentVM.PCLK;
-		}
-		else
-		{
-
-	        diff = s_CurrentVM.PCLK - s_VMTable[i].PCLK;
-		}
-		//~jau-chih.tseng@ite.com.tw 2011/02/18
-
-        diff *= 100 ;
-        diff /= s_VMTable[i].PCLK ;
-
-        if(diff > 3)
-        {
-            // over 3%
-            continue ;
-        }
-
-        if(s_VMTable[i].HActive != s_CurrentVM.HActive)
-        {
-            continue ;
-        }
-
-        //if(s_VMTable[i].VActive != s_CurrentVM.VActive)
-        //{
-        //    continue ;
-        //}
-
-        if((long)s_VMTable[i].HTotal >=(long)s_CurrentVM.HTotal )
-        {
-        diff =(long)s_VMTable[i].HTotal -(long)s_CurrentVM.HTotal ;
-        }
-        else
-        {
-            diff = (long)s_CurrentVM.HTotal  - (long)s_VMTable[i].HTotal  ;
-        }
-        if(diff>4)
-        {
-            continue ;
-        }
-
-        if((long)s_VMTable[i].VActive >= (long)s_CurrentVM.VActive )
-        {
-        diff =(long)s_VMTable[i].VActive -(long)s_CurrentVM.VActive ;
-        }
-        else
-        {
-            diff = (long)s_CurrentVM.VActive  - (long)s_VMTable[i].VActive  ;
-        }
-        if(diff>10)
-        {
-            continue ;
-        }
-
-        if((long)s_VMTable[i].VTotal >= (long)s_CurrentVM.VTotal )
-        {
-        diff =(long)s_VMTable[i].VTotal -(long)s_CurrentVM.VTotal ;
-        }
-        else
-        {
-            diff = (long)s_CurrentVM.VTotal  - (long)s_VMTable[i].VTotal  ;
-        }
-        if(diff>40)
-        {
-            continue ;
-        }
-
-        if(s_VMTable[i].ScanMode != s_CurrentVM.ScanMode)
-        {
-            continue ;
-        }
-
-        s_CurrentVM = s_VMTable[i] ;
-        // HDMIRX_DEBUG_PRINTF(("Matched %d Result in loop 1: ", i)); DumpSyncInfo(pVTiming);
-        return TRUE ;
-    }
-
-
-    for(i = 0 ; i < SizeofVMTable ; i++)
-    {
-        if( s_VMTable[i].PCLK >= s_CurrentVM.PCLK)
-        {
-            diff = s_VMTable[i].PCLK  -  s_CurrentVM.PCLK ;
-        }
-        else
-        {
-            diff = s_CurrentVM.PCLK - s_VMTable[i].PCLK   ;
-        }
-        diff *= 100 ;
-        diff /= s_VMTable[i].PCLK ;
-
-        if(diff > 3)
-        {
-            // over 3%
-            continue ;
-        }
-
-        if(s_VMTable[i].HActive != s_CurrentVM.HActive)
-        {
-            continue ;
-        }
-
-        //if(s_VMTable[i].VActive != s_CurrentVM.VActive)
-        //{
-        //    continue ;
-        //}
-
-        if((long)s_VMTable[i].HTotal >=(long)s_CurrentVM.HTotal )
-        {
-        diff =(long)s_VMTable[i].HTotal -(long)s_CurrentVM.HTotal ;
-        }
-        else
-        {
-            diff = (long)s_CurrentVM.HTotal  - (long)s_VMTable[i].HTotal  ;
-        }
-        if(diff>4)
-        {
-            continue ;
-        }
-
-        if((long)s_VMTable[i].VActive >= (long)s_CurrentVM.VActive )
-        {
-        diff =(long)s_VMTable[i].VActive -(long)s_CurrentVM.VActive ;
-        }
-        else
-        {
-            diff = (long)s_CurrentVM.VActive  - (long)s_VMTable[i].VActive  ;
-        }
-        if(diff>10)
-        {
-            continue ;
-        }
-
-        if((long)s_VMTable[i].VTotal >=(long)s_CurrentVM.VTotal )
-        {
-        diff =(long)s_VMTable[i].VTotal -(long)s_CurrentVM.VTotal ;
-        }
-        else
-        {
-            diff = (long)s_CurrentVM.VTotal  - (long)s_VMTable[i].VTotal  ;
-        }
-        if(diff>40)
-        {
-            continue ;
-        }
-        s_CurrentVM = s_VMTable[i] ;
-        // HDMIRX_DEBUG_PRINTF(("Matched %d Result in loop 2: ", i)); DumpSyncInfo(pVTiming);
-        return TRUE ;
-    }
-#endif
-    return FALSE ;
-}
-
-
-
-
-#define SIZE_OF_CSCOFFSET (REG_RX_CSC_RGBOFF - REG_RX_CSC_YOFF + 1)
-#define SIZE_OF_CSCMTX (REG_RX_CSC_MTX33_H - REG_RX_CSC_MTX11_L + 1)
-#define SIZE_OF_CSCGAIN (REG_RX_CSC_GAIN3V_H - REG_RX_CSC_GAIN1V_L + 1)
-
-///////////////////////////////////////////////////////////
-// video.h
-///////////////////////////////////////////////////////////
-void
-Video_Handler()
-{
-    // SYNC_INFO SyncInfo, NewSyncInfo ;
-    BOOL bHDMIMode;
-    BYTE uc ;
-
-    if(VState == VSTATE_ModeDetecting)
-    {
-        HDMIRX_DEBUG_PRINTF(("Video_Handler, VState = VSTATE_ModeDetecting.\n"));
-        // HDMIRX_DEBUG_PRINTF(("Video Mode Detecting ... , REG_RX_RST_CTRL = %02X -> ",(int)HDMIRX_ReadI2C_Byte(REG_RX_RST_CTRL)));
-        // HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL,HDMIRX_ReadI2C_Byte(REG_RX_RST_CTRL)& ~B_HDCPRST|B_EN_AUTOVDORST);
-        // HDMIRX_DEBUG_PRINTF(("%02X\n",(int)HDMIRX_ReadI2C_Byte(REG_RX_RST_CTRL)));
-        uc = HDMIRX_ReadI2C_Byte(0x9A) ;
-        HDMIRX_DEBUG_PRINTF(("Video_Handler(): reg9A = %02X\n", (int)uc)) ;
-
-        if( uc == 0xFF )
-        {
-            HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_CDRRST|B_EN_AUTOVDORST) ;
-            HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST) ;
-            SwitchVideoState(VSTATE_SyncWait);
-            return ;
-        }
-        ClearIntFlags(B_CLR_MODE_INT);
-
-        bGetSyncInfo();
-
-        bHDMIMode = IsHDMIRXHDMIMode();
-
-        if(!bHDMIMode)
-        {
-            HDMIRX_DEBUG_PRINTF(("This is DVI Mode.\n"));
-            NewAVIInfoFrameF = FALSE ;
-        }
-
-        // GetSyncInfo(&NewSyncInfo);
-
-        // if(CompareSyncInfo(&NewSyncInfo,&SyncInfo))
-        if(HDMIRX_ReadI2C_Byte(REG_RX_INTERRUPT1)&(B_SCDTOFF|B_PWR5VOFF))
-        {
-            SwitchVideoState(VSTATE_SyncWait);
-            // SwitchAudioState(ASTATE_AudioOff); // SwitchVideoState will switch audio state to AudioOff if any non VideoOn mode.
-        }
-        else
-        {
-            // HDCP_Reset(); // even though in DVI mode, Tx also can set HDCP.
-
-            SwitchVideoState(VSTATE_VideoOn);
-        }
-
-        return ;
-    }
-}
-
-static void
-SetVideoInputFormatWithoutInfoFrame(BYTE bInMode)
-{
-    BYTE uc ;
-
-    // HDMIRX_DEBUG_PRINTF(("SetVideoInputFormat: NewAVIInfoFrameF = %s, bInMode = %d",(NewAVIInfoFrameF==TRUE)?"TRUE":"FALSE",bInMode));
-    // only set force input color mode selection under no AVI Info Frame case
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL);
-    uc |= B_FORCE_COLOR_MODE ;
-    bInputVideoMode &= ~F_MODE_CLRMOD_MASK ;
-    // bInputVideoMode |=(bInMode)&F_MODE_CLRMOD_MASK ;
-
-    switch(bInMode)
-    {
-    case F_MODE_YUV444:
-        uc &= ~(M_INPUT_COLOR_MASK<<O_INPUT_COLOR_MODE);
-        uc |= B_INPUT_YUV444 << O_INPUT_COLOR_MODE ;
-        bInputVideoMode |= F_MODE_YUV444 ;
-        break ;
-    case F_MODE_YUV422:
-        uc &= ~(M_INPUT_COLOR_MASK<<O_INPUT_COLOR_MODE);
-        uc |= B_INPUT_YUV422 << O_INPUT_COLOR_MODE ;
-        bInputVideoMode |= F_MODE_YUV422 ;
-        break ;
-    case F_MODE_RGB24:
-        uc &= ~(M_INPUT_COLOR_MASK<<O_INPUT_COLOR_MODE);
-        uc |= B_INPUT_RGB24 << O_INPUT_COLOR_MODE ;
-        bInputVideoMode |= F_MODE_RGB24 ;
-        break ;
-    default:
-        HDMIRX_DEBUG_PRINTF(("Invalid Color mode %d, ignore.\n", bInMode));
-        return ;
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_CSC_CTRL, uc);
-
-}
-
-static void
-SetColorimetryByMode(/*PSYNC_INFO pSyncInfo*/)
-{
-    // USHORT HRes, VRes ;
-    bInputVideoMode &= ~F_MODE_ITU709 ;
-    // HRes = pVTiming->HActive ;
-    // VRes = pVTiming->VActive ;
-    // VRes *=(pSyncInfo->Mode & F_MODE_INTERLACE)?2:1 ;
-    if((s_CurrentVM.HActive == 1920)||(s_CurrentVM.HActive == 1280 && s_CurrentVM.VActive == 720))
-    {
-        // only 1080p, 1080i, and 720p use ITU 709
-        bInputVideoMode |= F_MODE_ITU709 ;
-    }
-    else
-    {
-        // 480i,480p,576i,576p,and PC mode use 601
-        bInputVideoMode &= ~F_MODE_ITU709 ; // set mode as ITU601
-    }
-}
-
-void
-SetVideoInputFormatWithInfoFrame()
-{
-    BYTE uc ;
-    BOOL bAVIColorModeIndicated = FALSE ;
-    BOOL bOldInputVideoMode = bInputVideoMode ;
-
-    HDMIRX_DEBUG_PRINTF(("SetVideoInputFormatWithInfoFrame(): "));
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB1);
-    HDMIRX_DEBUG_PRINTF(("REG_RX_AVI_DB1 %02X get uc %02X ",(int)REG_RX_AVI_DB1,(int)uc));
-
-    prevAVIDB1 = uc ;
-    bInputVideoMode &= ~F_MODE_CLRMOD_MASK ;
-
-    switch((uc>>O_AVI_COLOR_MODE)&M_AVI_COLOR_MASK)
-    {
-    case B_AVI_COLOR_YUV444:
-        HDMIRX_DEBUG_PRINTF(("input YUV444 mode "));
-        bInputVideoMode |= F_MODE_YUV444 ;
-        break ;
-    case B_AVI_COLOR_YUV422:
-        HDMIRX_DEBUG_PRINTF(("input YUV422 mode "));
-        bInputVideoMode |= F_MODE_YUV422 ;
-        break ;
-    case B_AVI_COLOR_RGB24:
-        HDMIRX_DEBUG_PRINTF(("input RGB24 mode "));
-        bInputVideoMode |= F_MODE_RGB24 ;
-        break ;
-    default:
-        HDMIRX_DEBUG_PRINTF(("Invalid input color mode, ignore.\n"));
-        return ; // do nothing.
-    }
-
-    if((bInputVideoMode & F_MODE_CLRMOD_MASK)!=(bOldInputVideoMode & F_MODE_CLRMOD_MASK))
-    {
-        HDMIRX_DEBUG_PRINTF(("Input Video mode changed."));
-    }
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL);
-    uc &= ~B_FORCE_COLOR_MODE ; // color mode indicated by Info Frame.
-    HDMIRX_WriteI2C_Byte(REG_RX_CSC_CTRL, uc);
-
-    HDMIRX_DEBUG_PRINTF(("\n"));
-}
-
-BOOL
-SetColorimetryByInfoFrame()
-{
-    BYTE uc ;
-    BOOL bOldInputVideoMode = bInputVideoMode ;
-
-    HDMIRX_DEBUG_PRINTF(("SetColorimetryByInfoFrame: NewAVIInfoFrameF = %s ",NewAVIInfoFrameF?"TRUE":"FALSE"));
-
-    if(NewAVIInfoFrameF)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_AVI_DB2);
-        uc &= M_AVI_CLRMET_MASK<<O_AVI_CLRMET ;
-        if(uc ==(B_AVI_CLRMET_ITU601<<O_AVI_CLRMET))
-        {
-            HDMIRX_DEBUG_PRINTF(("F_MODE_ITU601\n"));
-            bInputVideoMode &= ~F_MODE_ITU709 ;
-            return TRUE ;
-        }
-        else if(uc ==(B_AVI_CLRMET_ITU709<<O_AVI_CLRMET))
-        {
-            HDMIRX_DEBUG_PRINTF(("F_MODE_ITU709\n"));
-            bInputVideoMode |= F_MODE_ITU709 ;
-            return TRUE ;
-        }
-        // if no uc, ignore
-        if((bInputVideoMode & F_MODE_ITU709)!=(bOldInputVideoMode & F_MODE_ITU709))
-        {
-            HDMIRX_DEBUG_PRINTF(("Input Video mode changed."));
-            // SetVideoMute(ON); // turned off Video for input color format change .
-        }
-    }
-    HDMIRX_DEBUG_PRINTF(("\n"));
-    return FALSE ;
-}
-
-void
-SetColorSpaceConvert()
-{
-    BYTE uc, csc = 0;
-    BYTE filter = 0 ; // filter is for Video CTRL DN_FREE_GO, EN_DITHER, and ENUDFILT
-
-    // HDMIRX_DEBUG_PRINTF(("Input mode is YUV444 "));
-    switch(bOutputVideoMode&F_MODE_CLRMOD_MASK)
-    {
-    #if defined(SUPPORT_OUTPUTYUV444)
-    case F_MODE_YUV444:
-        // HDMIRX_DEBUG_PRINTF(("Output mode is YUV444\n"));
-	    switch(bInputVideoMode&F_MODE_CLRMOD_MASK)
-	    {
-	    case F_MODE_YUV444:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is YUV444\n"));
-	        csc = B_CSC_BYPASS ;
-	        break ;
-	    case F_MODE_YUV422:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is YUV422\n"));
-            csc = B_CSC_BYPASS ;
-            if(bOutputVideoMode & F_MODE_EN_UDFILT)// RGB24 to YUV422 need up/dn filter.
-            {
-                filter |= B_RX_EN_UDFILTER ;
-            }
-
-            if(bOutputVideoMode & F_MODE_EN_DITHER)// RGB24 to YUV422 need up/dn filter.
-            {
-                filter |= B_RX_EN_UDFILTER | B_RX_DNFREE_GO ;
-            }
-
-            break ;
-	    case F_MODE_RGB24:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is RGB444\n"));
-            csc = B_CSC_RGB2YUV ;
-            break ;
-	    }
-        break ;
-    #endif
-
-    #if defined(SUPPORT_OUTPUTYUV422)
-
-    case F_MODE_YUV422:
-	    switch(bInputVideoMode&F_MODE_CLRMOD_MASK)
-	    {
-	    case F_MODE_YUV444:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is YUV444\n"));
-	        if(bOutputVideoMode & F_MODE_EN_UDFILT)
-	        {
-	            filter |= B_RX_EN_UDFILTER ;
-	        }
-	        csc = B_CSC_BYPASS ;
-	        break ;
-	    case F_MODE_YUV422:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is YUV422\n"));
-            csc = B_CSC_BYPASS ;
-
-            // if output is YUV422 and 16 bit or 656, then the dither is possible when
-            // the input is YUV422 with 24bit input, however, the dither should be selected
-            // by customer, thus the requirement should set in ROM, no need to check
-            // the register value .
-            if(bOutputVideoMode & F_MODE_EN_DITHER)// RGB24 to YUV422 need up/dn filter.
-            {
-                filter |= B_RX_EN_UDFILTER | B_RX_DNFREE_GO ;
-            }
-	    	break ;
-	    case F_MODE_RGB24:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is RGB444\n"));
-            if(bOutputVideoMode & F_MODE_EN_UDFILT)// RGB24 to YUV422 need up/dn filter.
-            {
-                filter |= B_RX_EN_UDFILTER ;
-            }
-            csc = B_CSC_RGB2YUV ;
-	    	break ;
-	    }
-	    break ;
-    #endif
-
-    #if defined(SUPPORT_OUTPUTRGB)
-    case F_MODE_RGB24:
-        // HDMIRX_DEBUG_PRINTF(("Output mode is RGB24\n"));
-	    switch(bInputVideoMode&F_MODE_CLRMOD_MASK)
-	    {
-	    case F_MODE_YUV444:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is YUV444\n"));
-	        csc = B_CSC_YUV2RGB ;
-	        break ;
-	    case F_MODE_YUV422:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is YUV422\n"));
-            csc = B_CSC_YUV2RGB ;
-            if(bOutputVideoMode & F_MODE_EN_UDFILT)// RGB24 to YUV422 need up/dn filter.
-            {
-                filter |= B_RX_EN_UDFILTER ;
-            }
-            if(bOutputVideoMode & F_MODE_EN_DITHER)// RGB24 to YUV422 need up/dn filter.
-            {
-                filter |= B_RX_EN_UDFILTER | B_RX_DNFREE_GO ;
-            }
-	    	break ;
-	    case F_MODE_RGB24:
-            // HDMIRX_DEBUG_PRINTF(("Input mode is RGB444\n"));
-            csc = B_CSC_BYPASS ;
-	    	break ;
-	    }
-	    break ;
-    #endif
-    }
-
-
-    #if defined(SUPPORT_OUTPUTYUV)
-    // set the CSC associated registers
-    if(csc == B_CSC_RGB2YUV)
-    {
-        // HDMIRX_DEBUG_PRINTF(("CSC = RGB2YUV "));
-        if(bInputVideoMode & F_MODE_ITU709)
-        {
-            HDMIRX_DEBUG_PRINTF(("ITU709 "));
-
-            if(bInputVideoMode & F_MODE_16_235)
-            {
-                HDMIRX_DEBUG_PRINTF((" 16-235\n"));
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_16_235,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_RGB2YUV_ITU709_16_235,18);
-            }
-            else
-            {
-                HDMIRX_DEBUG_PRINTF((" 0-255\n"));
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_0_255,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_RGB2YUV_ITU709_0_255,18);
-            }
-        }
-        else
-        {
-            HDMIRX_DEBUG_PRINTF(("ITU601 "));
-            if(bInputVideoMode & F_MODE_16_235)
-            {
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_16_235,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_RGB2YUV_ITU601_16_235,18);
-                HDMIRX_DEBUG_PRINTF((" 16-235\n"));
-            }
-            else
-            {
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_0_255,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_RGB2YUV_ITU601_0_255,18);
-                HDMIRX_DEBUG_PRINTF((" 0-255\n"));
-            }
-        }
-    }
-    #endif
-    #if defined(SUPPORT_OUTPUTRGB)
-	if(csc == B_CSC_YUV2RGB)
-    {
-        HDMIRX_DEBUG_PRINTF(("CSC = YUV2RGB "));
-        if(bInputVideoMode & F_MODE_ITU709)
-        {
-            HDMIRX_DEBUG_PRINTF(("ITU709 "));
-            if(bOutputVideoMode & F_MODE_16_235)
-            {
-                HDMIRX_DEBUG_PRINTF(("16-235\n"));
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_16_235,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_YUV2RGB_ITU709_16_235,18);
-            }
-            else
-            {
-                HDMIRX_DEBUG_PRINTF(("0-255\n"));
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_0_255,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_YUV2RGB_ITU709_0_255,18);
-            }
-        }
-        else
-        {
-            HDMIRX_DEBUG_PRINTF(("ITU601 "));
-            if(bOutputVideoMode & F_MODE_16_235)
-            {
-                HDMIRX_DEBUG_PRINTF(("16-235\n"));
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_16_235,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_YUV2RGB_ITU601_16_235,18);
-            }
-            else
-            {
-                HDMIRX_DEBUG_PRINTF(("0-255\n"));
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_YOFF,bCSCOffset_0_255,3);
-                HDMIRX_WriteI2C_ByteN(REG_RX_CSC_MTX11_L,bCSCMtx_YUV2RGB_ITU601_0_255,18);
-            }
-        }
-
-    }
-	#endif // SUPPORT_OUTPUTRGB
-
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL);
-    uc =(uc & ~M_CSC_SEL_MASK)|csc ;
-    HDMIRX_WriteI2C_Byte(REG_RX_CSC_CTRL,uc);
-
-    // set output Up/Down Filter, Dither control
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_VIDEO_CTRL1);
-    uc &= ~(B_RX_DNFREE_GO|B_RX_EN_DITHER|B_RX_EN_UDFILTER);
-    uc |= filter ;
-    HDMIRX_WriteI2C_Byte(REG_RX_VIDEO_CTRL1, uc);
-}
-
-
-void
-SetDVIVideoOutput()
-{
-    // SYNC_INFO SyncInfo ;
-    // GetSyncInfo(&SyncInfo);
-    SetVideoInputFormatWithoutInfoFrame(F_MODE_RGB24);
-    SetColorimetryByMode(/*&SyncInfo*/);
-    SetColorSpaceConvert();
-}
-
-void
-SetNewInfoVideoOutput()
-{
-    SetVideoInputFormatWithInfoFrame();
-    SetColorimetryByInfoFrame();
-    SetColorSpaceConvert();
-    // DumpHDMIRXReg();
-}
-
-void
-SetHDMIRXVideoOutputFormat(BYTE bOutputMapping, BYTE bOutputType, BYTE bOutputColorMode)
-{
-    BYTE uc ;
-    SetVideoMute(ON);
-
-    HDMIRX_DEBUG_PRINTF3(("SetHDMIRXVideoOutputFormat(%02X,%02X,%02X)\n",(int)bOutputMapping,(int)bOutputType,(int)bOutputColorMode));
-    HDMIRX_WriteI2C_Byte(REG_RX_VIDEO_CTRL1,bOutputType);
-    HDMIRX_WriteI2C_Byte(REG_RX_VIDEO_MAP,bOutputMapping);
-    bOutputVideoMode&=~F_MODE_CLRMOD_MASK;
-
-    bOutputVideoMode |= bOutputColorMode&F_MODE_CLRMOD_MASK ;
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_PG_CTRL2)& ~(M_OUTPUT_COLOR_MASK<<O_OUTPUT_COLOR_MODE);
-
-    switch(bOutputVideoMode&F_MODE_CLRMOD_MASK)
-    {
-    case F_MODE_YUV444:
-        uc |= B_OUTPUT_YUV444 << O_OUTPUT_COLOR_MODE ;
-        break ;
-    case F_MODE_YUV422:
-        uc |= B_OUTPUT_YUV422 << O_OUTPUT_COLOR_MODE ;
-        break ;
-    }
-    HDMIRX_DEBUG_PRINTF3(("write %02X %02X\n",(int)REG_RX_PG_CTRL2,(int)uc));
-    HDMIRX_WriteI2C_Byte(REG_RX_PG_CTRL2, uc);
-
-    if(VState == VSTATE_VideoOn)
-    {
-        if(IsHDMIRXHDMIMode())
-        {
-            SetNewInfoVideoOutput();
-        }
-        else
-        {
-            SetDVIVideoOutput();
-        }
-        SetVideoMute(MuteByPKG);
-    }
-
-}
-
-
-///////////////////////////////////////////////////////////
-// Audio Function
-///////////////////////////////////////////////////////////
-
-
-void
-ResetAudio()
-{
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_AUDRST|B_EN_AUTOVDORST);
-    delay1ms(1);
-    HDMIRX_WriteI2C_Byte(REG_RX_RST_CTRL, B_EN_AUTOVDORST);
-}
-
-static void
-SetALLMute()
-{
-    BYTE uc ;
-    uc = (bVideoOutputOption==VIDEO_ON)?B_TRI_ALL:(B_TRI_ALL|B_TRI_VIDEO);
-    SetMUTE(B_VDO_MUTE_DISABLE,uc);
-}
-
-void
-SetHWMuteCTRL(BYTE AndMask, BYTE OrMask)
-{
-    BYTE uc = 0;
-
-    if(AndMask)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_HWMUTE_CTRL);
-    }
-    uc &= AndMask ;
-    uc |= OrMask ;
-    HDMIRX_WriteI2C_Byte(REG_RX_HWMUTE_CTRL,uc);
-
-}
-
-void
-SetVideoMute(BOOL bMute)
-{
-    BYTE uc ;
-#ifdef SUPPORT_REPEATER
-    if(bHDCPMode & HDCP_REPEATER)
-    {
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-        uc &= ~(B_TRI_VIDEO | B_TRI_VDIO);
-        uc |= B_VDO_MUTE_DISABLE ;
-        HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-        return ;
-    }
-
-#endif //SUPPORT_REPEATER
-    if(bMute)
-    {
-        // 2009/11/04 added by jau-chih.tseng@ite.com.tw
-        // implement the video gatting for video output.
-		uc = HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL);
-		uc |= B_VDIO_GATTING | B_VIO_SEL ; // video data set to low.
-		HDMIRX_WriteI2C_Byte(REG_RX_CSC_CTRL, uc);
-
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-        uc &= ~(B_TRI_VDIO) ;
-        if( VState != VSTATE_VideoOn )
-        {
-            uc |= B_TRI_VIDEO|B_TRI_VDIO ;
-        }
-
-        HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-        //~jau-chih.tseng@ite.com.tw 2009/11/04
-
-    }
-    else
-    {
-        if(VState == VSTATE_VideoOn)
-        {
-            // modified by jjtseng 2012/07/24
-            // the reset will gatting the video sync out and may make some scalar crazy.
-            uc = HDMIRX_ReadI2C_Byte(REG_RX_VIDEO_CTRL1);
-            if( uc & B_CCIR656 ) // just reset under CCIR656 mode.
-            {
-                HDMIRX_WriteI2C_Byte(REG_RX_VIDEO_CTRL1,uc|B_656FFRST);
-                HDMIRX_WriteI2C_Byte(REG_RX_VIDEO_CTRL1,uc&(~B_656FFRST));
-            }
-            //~jjtseng
-
-            if(HDMIRX_ReadI2C_Byte(REG_RX_VID_INPUT_ST)&B_AVMUTE)
-            {
-                uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-                uc &= ~(B_TRI_VDIO );
-                uc |= B_VDO_MUTE_DISABLE ;
-                HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-            }
-            else
-            {
-                uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-                uc &= ~B_VDO_MUTE_DISABLE ;
-                // HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-
-        		// enable video io gatting
-        		// uc = HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL);
-        		uc |= B_TRI_VDIO ;
-        		HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-        		HDMIRX_DEBUG_PRINTF(("reg %02X <- %02X = %02X\n",(int)REG_RX_TRISTATE_CTRL,(int)uc, (int)HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL)));
-        		uc &= ~(B_TRI_VDIO|B_TRI_VIDEO) ;
-        		HDMIRX_WriteI2C_Byte(REG_RX_TRISTATE_CTRL, uc);
-        		HDMIRX_DEBUG_PRINTF(("reg %02X <- %02X = %02X\n",(int)REG_RX_TRISTATE_CTRL,(int)uc, (int)HDMIRX_ReadI2C_Byte(REG_RX_TRISTATE_CTRL)));
-
-        		uc = HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL);
-        		uc |= B_VDIO_GATTING|B_VIO_SEL ;
-        		HDMIRX_WriteI2C_Byte(REG_RX_CSC_CTRL, uc);
-        		HDMIRX_DEBUG_PRINTF(("reg %02X <- %02X = %02X\n",(int)REG_RX_CSC_CTRL,(int)uc,(int)HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL)));
-        		uc &= ~B_VDIO_GATTING ;
-        		HDMIRX_WriteI2C_Byte(REG_RX_CSC_CTRL, uc);
-        		HDMIRX_DEBUG_PRINTF(("reg %02X <- %02X = %02X\n",(int)REG_RX_CSC_CTRL,(int)uc,(int)HDMIRX_ReadI2C_Byte(REG_RX_CSC_CTRL)));
-        	}
-
-        }
-    }
-}
-
-void
-SetAudioMute(BOOL bMute)
-{
-    if(bMute)
-    {
-        SetMUTE(~B_TRI_AUDIO, B_TRI_AUDIO);
-    }
-    else
-    {
-        // uc = ReadEEPROMByte(EEPROM_AUD_TRISTATE);
-        // uc &= B_TRI_AUDIO ;
-        SetMUTE(~B_TRI_AUDIO, 0);
-    }
-}
-
-// 2008/08/15 added by jj_tseng@chipadvanced.com
-// added Audio parameter
-/////////////////////////////////////////////////////////////////////////////
-// Name - getHDMIRXAudioStatus()
-// Parameter - N/A
-// return -
-//         D[7:4] - audio type
-//                  1100 - high bit rate
-//                  1010 - one bit audio(DSD)
-//                  1001 - NLPCM audio(compress)
-//                  1000 - LPCM audio
-//         D[3]   - layout
-//         D[2:0] - enabled source.
-/////////////////////////////////////////////////////////////////////////////
-BYTE
-getHDMIRXAudioStatus()
-{
-    BYTE uc,audio_status ;
-
-    SwitchHDMIRXBank(0);
-
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_AUDIO_CH_STAT);
-    audio_status = 0 ;
-
-    if((uc &(B_AUDIO_ON|B_HBRAUDIO|B_DSDAUDIO))==(BYTE)(B_AUDIO_ON|B_HBRAUDIO))
-    {
-        audio_status = T_AUDIO_HBR ;
-    }
-    else if((uc &(B_AUDIO_ON|B_HBRAUDIO|B_DSDAUDIO))==(BYTE)(B_AUDIO_ON|B_DSDAUDIO))
-    {
-        audio_status = T_AUDIO_DSD ;
-    }
-    else if(uc & B_AUDIO_ON)
-    {
-        if(HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT0)&(1<<1))
-        {
-            // NLPCM/compressed audio
-            audio_status = T_AUDIO_NLPCM ;
-        }
-        else
-        {
-            audio_status = T_AUDIO_LPCM ;
-        }
-
-        if(uc & B_AUDIO_LAYOUT)
-        {
-            audio_status |= F_AUDIO_LAYOUT_1 ;
-        }
-
-        if(uc &(1<<3))
-        {
-            audio_status |= 4 ;
-        }
-        else if(uc &(1<<2))
-        {
-            audio_status |= 3 ;
-        }
-        else if(uc &(1<<1))
-        {
-            audio_status |= 2 ;
-        }
-        else if(uc &(1<<0))
-        {
-            audio_status |= 1 ;
-        }
-    }
-
-    return audio_status ;
-}
-
-///////////////////////////////////////////////////////////////////////
-// Parameter out - ucIEC60958ChStat[5]
-// return - TRUE if ucIEC60958ChStat is returned
-///////////////////////////////////////////////////////////////////////
-//                 ucIEC60958ChStat[0]
-//                 - D[0] Comsumer used for channel status block
-//                 - D[1] 0 - LPCM 1 - for IEC61937 spec.
-//                 - D[2] 0 - Software for which copyright assert.
-//                        1 - Software for which no copyright assert.
-//                 - D[5:3] addition information.
-//                 - D[7:6] channel status mode
-///////////////////////////////////////////////////////////////////////
-//                 ucIEC60958ChStat[1]
-//                 - D[7:0] categery of audio.
-///////////////////////////////////////////////////////////////////////
-//                 ucIEC60958ChStat[2]
-//                 - D[7:4] - Channel number(0/1/2)
-//                 - D[3:0] - Source number(0..15)
-///////////////////////////////////////////////////////////////////////
-//                 ucIEC60958ChStat[3]
-//                 - D[5:4] = Clock accurency    - ret9F[1:0]
-//                 - D[3:0] = Sample Word Length - reg84[3:0]
-///////////////////////////////////////////////////////////////////////
-//                 ucIEC60958ChStat[4]
-//                 - D[7:4] = Original sampling frequency
-//                 - D[3:0] = Sample Word Length - reg9F[7:4]
-///////////////////////////////////////////////////////////////////////
-BOOL
-getHDMIRXAudioChannelStatus(BYTE ucIEC60958ChStat[])
-{
-    BYTE fs,audio_status ;
-
-
-    audio_status = getHDMIRXAudioStatus();
-
-    if(((audio_status & T_AUDIO_MASK)== T_AUDIO_OFF)||
-((audio_status & T_AUDIO_MASK)== T_AUDIO_DSD))
-    {
-        // return false if no audio or one-bit audio.
-        return FALSE ;
-    }
-
-    SwitchHDMIRXBank(0);
-    ucIEC60958ChStat[0] = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT0);
-    ucIEC60958ChStat[1] = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT1);
-    ucIEC60958ChStat[2] = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT2);
-    fs = HDMIRX_ReadI2C_Byte(REG_RX_FS)& M_Fs ;
-
-    if((audio_status & T_AUDIO_MASK)== T_AUDIO_HBR)
-    {
-        fs = B_Fs_HBR ;
-        ucIEC60958ChStat[0] |= B_AUD_NLPCM ;
-    }
-
-    ucIEC60958ChStat[3] = HDMIRX_ReadI2C_Byte(REG_RX_AUD_CHSTAT3);
-    //
-    ucIEC60958ChStat[4] =(ucIEC60958ChStat[3] >> 4)& 0xF ;
-    ucIEC60958ChStat[4] |=((~fs)& 0xF)<<4 ;
-
-    ucIEC60958ChStat[3] &= 3 ;
-    ucIEC60958ChStat[3] <<= 4 ;
-    ucIEC60958ChStat[3] |= fs & 0xF ;
-
-    return TRUE ;
-}
-
-//////////////////////////////////////////////////////////////////////////
-// Name - setHDMIRX_HBROutput
-// Parameter - HBR_SPDIF
-//             0 - output HBR through I2S channel
-//             1 - output HBR through SPDIF
-// return N/A
-//////////////////////////////////////////////////////////////////////////
-
-void
-setHDMIRX_HBROutput(BOOL HBR_SPDIF)
-{
-    BYTE uc ;
-    SwitchHDMIRXBank(0);
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_HWAMP_CTRL);
-
-    if(HBR_SPDIF)
-    {
-        HDMIRX_WriteI2C_Byte(REG_RX_HWAMP_CTRL, uc | B_HBR_SPDIF);
-
-        uc = HDMIRX_ReadI2C_Byte(REG_RX_FS_SET);
-        uc &= ~0x30 ;
-        uc |= 0x20 ; // reg7E[5:4] = '10'
-        uc = HDMIRX_WriteI2C_Byte(REG_RX_FS_SET, uc);
-        SetMUTE(~B_TRI_AUDIO, B_TRI_I2S3|B_TRI_I2S2|B_TRI_I2S1|B_TRI_I2S0);
-        // enabled SPDIF output and disable all I2S channel
-    }
-    else
-    {
-        HDMIRX_WriteI2C_Byte(REG_RX_HWAMP_CTRL, uc | B_HBR_SPDIF);
-        SetMUTE(~B_TRI_AUDIO, B_TRI_SPDIF);
-        // disable SPDIF output and enable all I2S channel
-    }
-}
-
-//////////////////////////////////////////////////////////////////////////
-// Name - setHDMIRX_SPDIFOutput
-// Parameter - N/A
-// return N/A
-// comment :
-//          set output to SPDIF audio.
-//////////////////////////////////////////////////////////////////////////
-void
-setHDMIRX_SPDIFOutput()
-{
-    BYTE uc ;
-    SwitchHDMIRXBank(0);
-    uc = HDMIRX_ReadI2C_Byte(REG_RX_FS_SET);
-    uc &= ~0x30 ;
-    uc |= 0x20 ; // reg7E[5:4] = '10'
-    uc = HDMIRX_WriteI2C_Byte(REG_RX_FS_SET, uc);
-    SetMUTE(~B_TRI_AUDIO, B_TRI_I2S3|B_TRI_I2S2|B_TRI_I2S1|B_TRI_I2S0);
-}
-
-
-//////////////////////////////////////////////////////////////////////////
-// Name - setHDMIRX_SPDIFOutput
-// Parameter - src_enable
-//             D[0] - enable I2S0
-//             D[1] - enable I2S1
-//             D[2] - enable I2S2
-//             D[3] - enable I2S3
-// return N/A
-// comment :
-//          set output to SPDIF audio.
-//////////////////////////////////////////////////////////////////////////
-void
-setHDMIRX_I2SOutput(BYTE src_enable)
-{
-    SwitchHDMIRXBank(0);
-
-    src_enable &= 0xF ;
-    src_enable ^= 0xF ; // invert lower four enable bit to tristate bit.
-    SetMUTE(~B_TRI_AUDIO, B_TRI_SPDIF|src_enable);
-}
-//~jj_tseng@chipadvanced.com
-
-
-#ifdef DEBUG
-void
-DumpHDMIRXReg()
-{
-    int i,j ;
-    BYTE ucData ;
-
-    HDMIRX_DEBUG_PRINTF1(("       "));
-    for(j = 0 ; j < 16 ; j++)
-    {
-        HDMIRX_DEBUG_PRINTF1((" %02X",(int)j));
-        if((j == 3)||(j==7)||(j==11))
-        {
-            HDMIRX_DEBUG_PRINTF1(("  "));
-        }
-    }
-    HDMIRX_DEBUG_PRINTF1(("\n        -----------------------------------------------------\n"));
-
-    Switch_HDMIRX_Bank(0);
-
-    for(i = 0 ; i < 0x100 ; i+=16)
-    {
-        HDMIRX_DEBUG_PRINTF1(("[%3X]  ",(int)i));
-        for(j = 0 ; j < 16 ; j++)
-        {
-            ucData = HDMIRX_ReadI2C_Byte((BYTE)((i+j)&0xFF));
-            HDMIRX_DEBUG_PRINTF1((" %02X",(int)ucData));
-            if((j == 3)||(j==7)||(j==11))
-            {
-                HDMIRX_DEBUG_PRINTF1((" -"));
-            }
-        }
-        HDMIRX_DEBUG_PRINTF1(("\n"));
-        if((i % 0x40)== 0x30)
-        {
-            HDMIRX_DEBUG_PRINTF1(("        -----------------------------------------------------\n"));
-        }
-    }
-
-    Switch_HDMIRX_Bank(1);
-    for(i = 0x180; i < 0x200 ; i+=16)
-    {
-        HDMIRX_DEBUG_PRINTF1(("[%3X]  ",(int)i));
-        for(j = 0 ; j < 16 ; j++)
-        {
-            ucData = HDMIRX_ReadI2C_Byte((BYTE)((i+j)&0xFF));
-            HDMIRX_DEBUG_PRINTF1((" %02X",(int)ucData));
-            if((j == 3)||(j==7)||(j==11))
-            {
-                HDMIRX_DEBUG_PRINTF1((" -"));
-            }
-        }
-        HDMIRX_DEBUG_PRINTF1(("\n"));
-        if((i % 0x40)== 0x30)
-        {
-            HDMIRX_DEBUG_PRINTF1(("        -----------------------------------------------------\n"));
-        }
-
-    }
-
-    Switch_HDMIRX_Bank(0);
-}
-#endif
-
diff --git a/drivers/amlogic/tvin/it660x/hdmirx.h b/drivers/amlogic/tvin/it660x/hdmirx.h
deleted file mode 100755
index 17f727a163d0..000000000000
--- a/drivers/amlogic/tvin/it660x/hdmirx.h
+++ /dev/null
@@ -1,1226 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <hdmirx.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-
-#ifndef _HDMIRX_H_
-#define _HDMIRX_H_
-
-#define SUPPORT_REPEATER
-
-#include "mcu.h"
-
-#include "typedef.h"
-
-#ifdef SUPPORT_REPEATER
-#include "sha1.h"
-#endif
-
-#ifdef GET_PACKAGE
-#undef GET_PACKAGE
-#endif // GET_PACKAGE
-
-#ifdef OUTPUT_YUV444
-#undef OUTPUT_YUV444
-#endif // OUTPUT_YUV444
-
-#ifdef OUTPUT_YUV422
-#undef OUTPUT_YUV422
-#endif // OUTPUT_YUV422
-
-#ifdef OUTPUT_RGB444
-#undef OUTPUT_RGB444
-#endif // OUTPUT_RGB444
-
-#ifdef OUTPUT_RGB
-#undef OUTPUT_RGB
-#endif // OUTPUT_RGB
-
-#ifdef OUTPUT_YUV
-#undef OUTPUT_YUV
-#endif // OUTPUT_YUV
-
-
-#define GET_PACKAGE
-#define OUTPUT_YUV444
-#define OUTPUT_YUV422
-#define OUTPUT_RGB444
-#define _HBR_I2S_
-
-#if (defined OUTPUT_YUV444)||(defined OUTPUT_YUV422)
-#define OUTPUT_YUV
-
-#pragma message("Ouptut supports YUV Format.")
-#endif
-
-#if defined OUTPUT_RGB444
-#define OUTPUT_RGB
-#pragma message("Output supports RGB Format.")
-#endif
-
-////////////////////////////////////////////////////////////
-// HDMIRX register definition.
-////////////////////////////////////////////////////////////
-
-#define HDMI_RX_I2C_SLAVE_ADDR 0x90
-
-#define REG_RX_VID_L	0x00
-#define REG_RX_VID_H	0x01
-#define REG_RX_DEVID_L	0x02
-#define REG_RX_DEVID_H	0x03
-#define REG_RX_DEVREV	0x04
-#define REG_RX_RST_CTRL	0x05
-
-#define B_CDRRST        (1<<7)
-#define B_EN_CDRAUTORST (1<<6)
-#define B_EN_AUTOVDORST (1<<5)
-#define B_REGRST        (1<<4)
-#define B_HDCPRST       (1<<3)
-#define B_AUDRST        (1<<2)
-#define B_VDORST        (1<<1)
-#define B_SWRST         (1<<0)
-
-#define REG_RX_PWD_CTRL0	0x06
-#define B_PWD_ALL       (1<<0)
-
-#define REG_RX_PWD_CTRL1	0x07
-#define B_PORT_SEL_B      (1<<4)
-#define B_PORT_SEL_A      (0<<4)
-#define B_PORT_MASK     (1<<7)
-#define B_PWD_AFEALL	(1<<3)
-#define B_PWDC_ETC	(1<<2)
-#define B_PWDC_SRV	(1<<1)
-#define B_EN_AUTOPWD	(1<<0)
-
-
-
-
-#define REG_RX_VIO_CTRL	0x08
-#define REG_RX_AIO_CTRL	0x09
-#define REG_RX_OTP_CTRL	0x0A
-#define REG_RX_OTP_XOR	0x0B
-#define REG_RX_BIST_CTRL	0x0C
-#define REG_RX_BIST_RESULT1	0x0D
-#define REG_RX_BIST_RESULT2	0x0E
-#define REG_RX_BLOCK_SEL	0x0F
-
-#define REG_RX_BANK 0x0F
-//#define  REG_RX_RSVD	0x0F
-#define REG_RX_SYS_STATE	0x10
-
-#define B_RXPLL_LOCK (1<<7)
-#define B_RXCK_SPEED (1<<6)
-#define B_RXCK_VALID (1<<5)
-#define B_HDMIRX_MODE (1<<4)
-// #define B_VSYNC (1<<3)
-#define B_SCDT (1<<2)
-#define B_VCLK_DET (1<<1)
-#define B_PWR5V_DET (1<<0)
-#define B_PWR5V_DET_PORTA (1<<0)
-#define B_PWR5V_DET_PORTB (1<<3)
-
-#define REG_RX_HDCP_CTRL	0x11
-    #define B_EXTROM     (1<<7)
-    #define B_HDCP_STABLECNT     (1<<5)
-    #define M_HDCP_STABLECNT     (1<<5)
-    #define B_HDCP_RDKSV     (1<<4)
-    #define B_HDCP_ROMDISWR     (1<<3)
-    #define B_HDCP_A0     (1<<2)
-    #define B_FASTHDCPMODE     (1<<1)
-    #define B_HDCP_EN     (1<<0)
-
-#define REG_RX_HDCP_STATUS	0x12
-#define B_R0_READY	(1<<6)
-#define REG_RX_INTERRUPT1	0x13
-#define REG_RX_INTERRUPT_MASK1	0x16
-
-#define B_VIDMODE_CHG   (1<<5)
-#define B_HDMIMODE_CHG  (1<<4)
-#define B_SCDTOFF       (1<<3)
-#define B_SCDTON        (1<<2)
-#define B_PWR5VOFF      (1<<1)
-#define B_PWR5VON       (1<<0)
-
-#define REG_RX_INTERRUPT2	0x14
-#define REG_RX_INTERRUPT_MASK2	0x17
-#define B_PKT_CLR_MUTE (1<<7)
-#define B_NEW_AUD_PKT (1<<6)
-#define B_NEW_ACP_PKT (1<<5)
-#define B_NEW_SPD_PKT (1<<4)
-#define B_NEW_MPG_PKG (1<<3)
-#define B_NEW_AVI_PKG (1<<2)
-#define B_NO_AVI_RCV (1<<1)
-#define B_PKT_SET_MUTE (1<<0)
-
-#define REG_RX_INTERRUPT3	0x15
-#define REG_RX_INTERRUPT_MASK3	0x18
-#define B_AUTOAUDMUTE (1<<4)
-#define B_AUDFIFOERR (1<<3)
-#define B_ECCERR (1<<2)
-#define B_R_AUTH_DONE (1<<1)
-#define B_R_AUTH_START (1<<0)
-
-#define REG_RX_INTERRUPT4 0x8B
-#define B_RXCK_CHG      (1<<7)
-#define B_RXCKON_DET      (1<<6)
-#define B_HDCP_OFF      (1<<5)
-#define B_SYMERR_DET    (1<<4)
-#define B_CD_DET    (1<<3)
-#define B_GENPKT_DET    (1<<2)
-#define B_ISRC2_DET    (1<<1)
-#define B_ISRC1_DET    (1<<0)
-
-#define REG_RX_INTERRUPT_MASK4 0x8C
-#define B_M_RXCKON_DET      (1<<5)
-#define B_M_HDCP_OFF      (1<<6)
-
-
-
-#define REG_RX_INTERRUPT_CTRL1	0x18
-#define B_CLR_HDCP_INT  (1<<7)
-
-#define REG_RX_INTERRUPT_CTRL	0x19
-
-#define	B_CLR_MODE_INT	(1<<0)
-#define	B_CLR_PKT_INT	(1<<1)
-#define	B_CLR_ECC_INT	(1<<2)
-#define	B_CLR_AUDIO_INT	(1<<3)
-#define	B_INTPOL	    (1<<4)
-#define	B_INTROUTTYPE	(1<<5)
-#define B_CLR_MUTECLR_INT (1<<6)
-#define B_CLR_MUTESET_INT (1<<7)
-
-#define LO_ACTIVE TRUE
-#define HI_ACTIVE FALSE
-
-#define REG_RX_MISC_CTRL	0x1A
-
-#define B_RXCK_FILT (1<<5)
-#define B_TIMEOUT_EN (1<<4)
-#define B_EN_DEBUG (1<<3)
-#define B_DE_POL (1<<2)
-#define B_VSYNC_OUT_POL (1<<1)
-#define B_HSYNC_OUT_POL (1<<0)
-
-
-#define REG_RX_VIDEO_MAP	0x1B
-#define B_OUTPUT_16BIT (1<<5)
-#define B_SWAP_CH422 (1<<4)
-#define B_SWAP_OUTRB (1<<3)
-#define B_SWAP_ML (1<<2)
-#define B_SWAP_POL (1<<1)
-#define B_SWAP_RB (1<<0)
-
-#define REG_RX_VIDEO_CTRL1	0x1C
-#define B_RX_DNFREE_GO (1<<7)
-#define B_SYNC_EMBEDDED (1<<6)
-#define B_RX_EN_DITHER (1<<5)
-#define B_RX_EN_UDFILTER (1<<4)
-#define B_DDR_OUTPUT (1<<3)// used for 12bit output of RGB24 or YUV444
-#define B_CCIR656    (1<<2)
-#define B_656FFRST   (1<<1)
-#define B_EN_AVMUTE_RST (1<<0)
-
-#define REG_RX_VCLK_CTRL	0x1D
-#define REG_RX_I2CIO_CTRL	0x1E
-#define REG_RX_REGPKTFLAG_CTRL	0x1F
-#define B_INT_GENERAL_EVERY (1<<4)
-#define B_INT_EVERYAVI	1
-
-#define REG_RX_CSC_CTRL	0x20
-#define B_VDIO_GATTING   (1<<7)
-#define B_VDIO_DISABLE   (1<<6)
-#define B_VIO_SEL       (1<<5)
-// 0 - reg89[6] = 1 -> turing off VIO and VDIO
-// 1 - reg89[5] = 1 -> turing off VIO, reg89[6] = 1 -> truning off VDIO
-
-#define B_FORCE_COLOR_MODE (1<<4)
-#define O_INPUT_COLOR_MODE 2
-#define M_INPUT_COLOR_MASK 3
-#define B_INPUT_RGB24      0
-#define B_INPUT_YUV422     1
-#define B_INPUT_YUV444     2
-
-#define O_CSC_SEL          0
-#define M_CSC_SEL_MASK     3
-#define B_CSC_BYPASS       0
-#define B_CSC_RGB2YUV      2
-#define B_CSC_YUV2RGB      3
-
-#define REG_RX_CSC_YOFF	0x21
-#define REG_RX_CSC_COFF	0x22
-#define REG_RX_CSC_RGBOFF	0x23
-#define REG_RX_CSC_MTX11_L	0x24
-#define REG_RX_CSC_MTX11_H	0x25
-#define REG_RX_CSC_MTX12_L	0x26
-#define REG_RX_CSC_MTX12_H	0x27
-#define REG_RX_CSC_MTX13_L	0x28
-#define REG_RX_CSC_MTX13_H	0x29
-#define REG_RX_CSC_MTX21_L	0x2A
-#define REG_RX_CSC_MTX21_H	0x2B
-#define REG_RX_CSC_MTX22_L	0x2C
-#define REG_RX_CSC_MTX22_H	0x2D
-#define REG_RX_CSC_MTX23_L	0x2E
-#define REG_RX_CSC_MTX23_H	0x2F
-#define REG_RX_CSC_MTX31_L	0x30
-#define REG_RX_CSC_MTX31_H	0x31
-#define REG_RX_CSC_MTX32_L	0x32
-#define REG_RX_CSC_MTX32_H	0x33
-#define REG_RX_CSC_MTX33_L	0x34
-#define REG_RX_CSC_MTX33_H	0x35
-// 2008/09/25 modified by jj_tseng@chipadvanced.com
-//#define REG_RX_CSC_GAIN1V_L	0x36
-//#define REG_RX_CSC_GAIN1V_H	0x37
-//#define REG_RX_CSC_GAIN2V_L	0x38
-//#define REG_RX_CSC_GAIN2V_H	0x39
-//#define REG_RX_CSC_GAIN3V_L	0x3A
-//#define REG_RX_CSC_GAIN3V_H	0x3B
-#define REG_RX_FRAMEPKT_ERR 0x36
-#define REG_RX_SKNDLY       0x37
-#define REG_RX_RXPLL2_LOCK  0x38
-#define REG_RX_OUTBIT       0x39
-#define REG_RX_AUTO_EQ_CTRL 0x3A
-#define REG_RX_DESKEW_CTRL  0x3B
-//~jj_tseng@chipadvanced.com
-
-#define REG_RX_PG_CTRL1	0x3C
-#define REG_RX_PG_CTRL2	0x3D
-// output color mode is located this register D[7:6]
-#define O_OUTPUT_COLOR_MODE 6
-#define M_OUTPUT_COLOR_MASK 3
-#define B_OUTPUT_RGB24      0
-#define B_OUTPUT_YUV422     1
-#define B_OUTPUT_YUV444     2
-
-#define REG_RX_PG_COLR	0x3E
-#define REG_RX_PG_COLG	0x3F
-#define REG_RX_PG_COLB	0x40
-#define REG_RX_PG_COLBLANK	0x41
-#define REG_RX_PG_COLBLANKY	0x42
-#define REG_RX_PG_HACTST_L	0x43
-#define REG_RX_PG_HACTST_H	0x44
-#define REG_RX_PG_HACTED_H	0x45
-#define REG_RX_PG_VACTST_L	0x46
-#define REG_RX_PG_VACTST_H	0x47
-#define REG_RX_PG_VACTED_H	0x48
-#define REG_RX_PG_VACTST2ND_L	0x49
-#define REG_RX_PG_VACTST2ND_H	0x4A
-#define REG_RX_PG_VACTED2ND_H	0x4B
-#define REG_RX_PG_HTOTAL_L	0x4C
-#define REG_RX_PG_HTOTAL_H	0x4D
-#define REG_RX_PG_HSYNCST_H	0x4E
-#define REG_RX_PG_HSYNCED_L	0x4F
-#define REG_RX_PG_VTOTAL_L	0x50
-#define REG_RX_PG_VTOTAL_H	0x51
-#define REG_RX_PG_VSYNCST_H	0x52
-#define REG_RX_PG_VSYNCED	0x53
-#define REG_RX_PG_CHINC	0x54
-#define REG_RX_PG_CVINC	0x55
-//#define  REG_RX_RSV	0x56
-
-#define REG_RX_I2C_CTRL    0x57
-#define B_FILT_TAP      (1<<5)
-#define B_FILT_TYPE     (1<<4)
-#define B_DEGLITCH      (1<<3)
-#define B_CMD_FILTTAP   (1<<2)
-#define B_CMD_FILTTYPE  (1<<1)
-#define B_CMD_DEGLITCH  (1<<0)
-
-#define REG_RX_VID_MODE    0x58
-#define B_PX_VIDEOSTABLE (1<<3)
-#define B_VIDFIELD       (1<<2)
-#define B_INTERLACE      (1<<1)
-// #define B_VIDMODE_CHG    (1<<0)
-
-#define REG_RX_VID_HTOTAL_L     0x59
-#define REG_RX_VID_HTOTAL_H     0x5A
-// D[6:4] - HActive [10:8]
-// D[3:0] - HTotal  [11:8]
-#define O_HTOTAL_H 0
-#define M_HTOTAL_H 0xF
-#define O_HACT_H   4
-#define M_HACT_H   0x7
-
-#define REG_RX_VID_HACT_L       0x5B
-
-#define REG_RX_VID_HSYNC_WID_L  0x5C
-#define REG_RX_VID_HSYNC_WID_H  0x5D
-// D[0] - HSYNC_Width[8]
-// D[7:4] HFrontPorch[11:8]
-#define O_HSYNC_WID_H 0
-#define M_HSYNC_WID_H 1
-#define O_H_FT_PORCH 4
-#define M_H_FT_PORCH		3
-
-#define REG_RX_VID_H_FT_PORCH_L 0x5E
-#define REG_RX_VID_VTOTAL_L     0x5F
-#define REG_RX_VID_VTOTAL_H     0x60
-#define O_VTOTAL_H 0
-#define M_VTOTAL_H 0xF
-#define O_VACT_H   4
-#define M_VACT_H   0x7
-
-#define REG_RX_VID_VACT_L       0x61
-#define REG_RX_VID_VSYNC2DE     0x62
-#define REG_RX_VID_V_FT_PORCH   0x63
-#define REG_RX_VID_XTALCNT_128PEL 0x64
-#define REG_RX_VID_INPUT_ST     0x65
-
-#define O_PIXEL_REPEAT 4
-#define M_PIXEL_REPEAT 0xF
-#define B_DISABLEHDCP (1<<3)
-#define B_AVMUTE (1<<2)
-#define B_VSYNC_IN_POL (1<<1)
-#define B_HSYNC_IN_POL (1<<0)
-
-//#define  REG_RX_RSV	0x66
-#define REG_RX_DEBUG_CTRL	0x67
-#define REG_RX_PLL_CTRL	0x68
-#define REG_RX_TERM_CTRL1	0x69
-#define REG_RX_TERM_CTRL2	0x6A
-//#define  REG_RX_RSV	0x6B
-#define REG_RX_EQUAL_CTRL1	0x6B
-#define REG_RX_EQUAL_CTRL2	0x6C
-#define REG_RX_DES_CTRL1	0x6D
-#define REG_RX_DES_CTRL2	0x6E
-#define REG_RX_DES_PHASE_B	0x6F
-#define REG_RX_DES_PHASE_G	0x70
-#define REG_RX_DES_PHASE_R	0x71
-#define REG_RX_BCH_MODE	0x72
-#define O_BCH_THRSH 3
-#define M_BCH_THRSH ((1<<(6-3))-1)
-
-#define B_TERC_INV (1<<2)
-#define B_TERC_CHECK (1<<1)
-#define B_DIS_BCH (1<<0)
-
-#define REG_RX_CDEPTH_CTRL	0x73
-#define B_EN_DefPhase 			(1<<0)
-#define B_DIS_DEEP_MODE 		(1<<1)
-#define B_SEL_CD_DEBUG 			(1<<2)
-#define B_RSTCD 				(1<<3)
-#define B_ENABLE_FAST 			(1<<4)
-#define B_ENABLE_FEATURE_1P1 	(1<<5)
-#define B_KSV_READY 			(1<<6)
-#define B_ENABLE_REPEATER 		(1<<7)
-//#define  REG_RX_RSV	0x73
-#define REG_RX_APLL_CTRL	0x74
-#define B_APLL_ENI2A (1<<7)
-#define B_APLL_EC1 (1<<6)
-#define B_APLL_ENIA (1<<5)
-#define B_RSVED (1<<4)
-#define B_DIEN (1<<3)
-#define B_DIS_SDM (1<<2)
-#define B_APLL_REFSW (1<<1)
-#define B_APLL_AUTOSW (1<<0)
-
-#define REG_RX_I2S_CTRL	0x75
-
-#define REG_RX_I2S_MAP	0x76
-#define O_I2S_CH3SEL 6
-#define O_I2S_CH2SEL 4
-#define O_I2S_CH1SEL 2
-#define O_I2S_CH0SEL 0
-
-#define M_I2S_CHSEL 3
-#define B_I2S_CHSEL0 0 // map channel n to output select 0
-#define B_I2S_CHSEL1 1 // map channel n to output select 1
-#define B_I2S_CHSEL2 2 // map channel n to output select 2
-#define B_I2S_CHSEL3 3 // map channel n to output select 3
-
-#define REG_RX_AUDIO_CTRL	0x77
-// 2010/03/04 added by jjtseng
-#define B_EN_I2S_NLPCM (1<<7)
-// 2007/08/10 added by jjtseng
-#define B_AUDCK_BBEN (1<<7)
-#define B_FORCE_FS (1<<6)
-//~jjtseng 2007/08/10
-#define B_DIS_FALSE_DE (1<<5)
-#define B_AUD_INFO_FORCE (1<<4)
-#define B_AVMUTE_VALUE (1<<3)
-#define B_FORCE_AVMUTE (1<<2)
-#define B_DIS_VDO_MUTE (1<<1)
-#define B_DIS_AUD_MUTE (1<<0)
-
-#define REG_RX_MCLK_CTRL	0x78
-#define B_OSC_EN (1<<7)
-#define B_OSCSEL (1<<6)
-// 2007/08/10 marked by jj_tseng@chipadvanced.com
-#define B_CTSINI_EN (1<<5)
-//~jj_tseng@chipadvanced.com 2007/08/10
-#define B_FORCE_CTS (1<<4)
-#define B_FORCE_CTSMODE (1<<3)
-#define O_MCLKSEL 0
-#define M_MCLKSEL 0x07
-#define B_128FS 0
-#define B_256FS 1
-#define B_512FS 3
-#define B_1024FS 7
-
-#define REG_RX_N_SET1	0x79
-#define REG_RX_N_SET2	0x7A
-#define REG_RX_N_SET3	0x7B
-#define REG_RX_CTS_SET2	0x7C
-#define REG_RX_CTS_SET3	0x7D
-#define REG_RX_FS_SET	0x7E
-#define REG_RX_N_RCV1	0x7F
-#define REG_RX_N_RCV2	0x80
-#define REG_RX_N_RCV3	0x81
-#define REG_RX_CTS_RCV2	0x82
-#define REG_RX_CTS_RCV3	0x83
-#define REG_RX_FS	0x84
-    #define M_GCP_CD 0xF0
-    #define O_GCP_CD 4
-
-    #define M_Fs 0xF
-    #define B_Fs_44p1KHz    0
-    #define B_Fs_48KHz  2
-    #define B_Fs_32KHz  3
-    #define B_Fs_88p2KHz    8
-    #define B_Fs_96KHz  0xA
-    #define B_Fs_176p4KHz   0xC
-    #define B_Fs_192KHz 0xE
-    #define B_Fs_768KHz 0x9 // 1001
-    #define B_Fs_HBR 0x9 // 1001
-
-#define REG_RX_CHANNEL_ERR	0x85
-    #define B_PKT_2BERR (1<<7)
-    #define B_PKT_1BERR (1<<6)
-    #define O_CH2_ERR 4
-    #define O_CH1_ERR 2
-    #define O_CH0_ERR 0
-#define REG_RX_HWMUTE_RATE	0x86
-
-#define REG_RX_HWMUTE_CTRL	0x87
-#define B_HW_FORCE_MUTE (1<<6)
-#define B_HW_AUDMUTE_CLR_MODE (1<<5)
-#define B_HW_MUTE_CLR (1<<4)
-#define B_HW_MUTE_EN (1<<3)
-
-#define M_HWMUTE_RATE_MASK 7
-
-#define REG_RX_HWAMP_CTRL	0x88
-#define B_HBR_SPDIF (1<<4)
-#define M_HWAMP_CTRL_MASK 3
-
-
-#define REG_RX_TRISTATE_CTRL	0x89
-#define B_VDO_MUTE_DISABLE  (1<<7)
-#define O_TRI_VIDEOIO 6
-#define O_TRI_VIDEO 5
-#define O_TRI_SPDIF 4
-#define O_TRI_I2S3 3
-#define O_TRI_I2S2 2
-#define O_TRI_I2S1 1
-#define O_TRI_I2S0 0
-
-
-
-
-#define B_TRI_VDIO (1<<6)
-#define B_TRI_VIDEO (1<<5)
-#define B_TRI_SPDIF (1<<4)
-#define B_TRI_I2S3 (1<<3)
-#define B_TRI_I2S2 (1<<2)
-#define B_TRI_I2S1 (1<<1)
-#define B_TRI_I2S0 (1<<0)
-
-#define B_TRI_ALL  (B_TRI_VDIO|B_TRI_SPDIF|B_TRI_I2S3|B_TRI_I2S2|B_TRI_I2S1|B_TRI_I2S0)
-#define B_TRI_AUDIO  (B_TRI_SPDIF|B_TRI_I2S3|B_TRI_I2S2|B_TRI_I2S1|B_TRI_I2S0)
-#define B_TRI_MASK  0x80
-
-#define REG_RX_AUDIO_CH_STAT 0x8A
-    #define B_AUDIO_ON    (1<<7)
-    #define B_HBRAUDIO    (1<<6)
-    #define B_DSDAUDIO    (1<<5)
-    #define B_AUDIO_LAYOUT     (1<<4)
-    #define M_AUDIO_CH         0xF
-    #define B_AUDIO_SRC_VALID_3 (1<<3)
-    #define B_AUDIO_SRC_VALID_2 (1<<2)
-    #define B_AUDIO_SRC_VALID_1 (1<<1)
-    #define B_AUDIO_SRC_VALID_0 (1<<0)
-
-// 2008/08/15 added by jj_tseng@chipadvanced
-#define F_AUDIO_ON  (1<<7)
-#define F_AUDIO_HBR (1<<6)
-#define F_AUDIO_DSD (1<<5)
-#define F_AUDIO_NLPCM (1<<4)
-#define F_AUDIO_LAYOUT_1 (1<<3)
-#define F_AUDIO_LAYOUT_0 (0<<3)
-
-
-// HBR - 1100
-// DSD - 1010
-// NLPCM - 1001
-// LPCM - 1000
-
-#define T_AUDIO_MASK 0xF0
-#define T_AUDIO_OFF 0
-#define T_AUDIO_HBR (F_AUDIO_ON|F_AUDIO_HBR)
-#define T_AUDIO_DSD (F_AUDIO_ON|F_AUDIO_DSD)
-#define T_AUDIO_NLPCM (F_AUDIO_ON|F_AUDIO_NLPCM)
-#define T_AUDIO_LPCM (F_AUDIO_ON)
-
-//~jj_tseng@chipadvanced.com
-
-#define REG_RX_RDROM_OFFSET	0x8F
-#define REG_RX_RDROM_REQBYTE	0x90
-#define REG_RX_RDROM_CTRL	0x91
-
-#define REG_RX_RDROM_STATUS	0x92
-#define B_ROMIDLE   1
-#define REG_RX_RDROM_CLKCTRL	0x9B
-#define B_ROM_CLK_SEL_REG   (1<<7)
-#define B_ROM_CLK_VALUE     (1<<6)
-// #define B_VDO_MUTE_DISABLE  (1<<4)
-#define B_CLKRST_SEL (1<<5)
-#define B_HDCP_NOAVMUTE (1<<4)
-#define O_ANALOG_BACKUP  2
-#define O_DIGITAL_BACKUP 0
-
-#define REG_RX_AUD_CHSTAT0 0x9C
-#define B_AUD_NLPCM (1<<1)
-#define B_SW_COPYRIGHT_ASSERT (1<<2)
-
-
-#define REG_RX_AUD_CHSTAT1 0x9D
-
-#define REG_RX_AUD_CHSTAT2 0x9E
-#define M_CH_NUM    0xF0
-#define O_CH_NUM    4
-#define M_SRC_NUM   0x0F
-#define O_SRC_NUM   0
-
-#define REG_RX_GEN_PKT_TYPE 0xA8
-
-#define REG_RX_AUD_CHSTAT3 0x9F
-#define M_CLK_ACCURANCE 0x03
-#define M_SW_LEN    0xF0
-#define O_SW_LEN    4
-
-
-#define SPD_INFOFRAME           0
-#define ISRC1_PKT               1
-#define ISRC2_PKT               2
-#define DSD_PKT                 3
-#define AVI_INFOFRAME           4
-#define AUDIO_INFOFRAME         5
-#define MPEG_INFOFRAME          6
-#define VENDORSPEC_INFOFRAME    7
-#define ACP_PKT                 8
-#define UNRECOGNIZED_PKT        9
-#define AUDIO_SAMPLE_PKT        10
-#define GENERAL_CONTROL_PKT     11
-
-// #define REG_RX_PKT_TYPE	0xAB
-
-#define REG_RX_AVI_VER	0xAC
-#define REG_RX_AVI_DB0	0xAD
-// for AVI Info Frame
-// D[6:5] AVI Info frame color mode Y1Y0
-// RGB    - 00
-// YUV422 - 01
-// YUV444 - 02
-#define O_AVI_COLOR_MODE 5
-#define M_AVI_COLOR_MASK   3
-#define B_AVI_COLOR_RGB24  0
-#define B_AVI_COLOR_YUV422 1
-#define B_AVI_COLOR_YUV444 2
-// D[4] A0 - Active format information present
-// 0 - No Data
-// 1 - Active Format Inforation valid
-#define B_AVI_PRESENT (1<<4)
-// D[3:2] B1B0 - Bar Info
-// 00 - bar uc not valid
-// 01 - vert. bar info valid
-// 10 - horz. bar info valid
-// 11 - vert and horz bar info valid
-#define O_AVI_BAR_INFO 2
-#define M_AVI_BAR_INFO_MASK 3
-#define B_AVI_BAR_NOT_VALID 0
-#define B_AVI_BAR_VINFO_VALID 1
-#define B_AVI_BAR_HINFO_VALID 2
-#define B_AVI_BAR_VHINFO_VALID 3
-// D[1:0] Scan Information
-// 00 - no uc
-// 01 - Overscanned (Television)
-// 10 - Underscanned (Computer)
-// 11 - Future (reserved)
-#define O_AVI_SCAN_INFO 0
-#define M_AVI_SCAN_INFO_MASK 3
-#define M_AVI_SCAN_NODATA    0
-#define M_AVI_SCAN_OVER_SCAN 1
-#define M_AVI_SCAN_UNDER_SCAN 2
-#define REG_RX_AVI_DB1	0xAE
-// D[7:6] C1C0 Colorimetry
-#define O_AVI_CLRMET 6
-#define M_AVI_CLRMET_MASK 3
-#define B_AVI_CLRMET_NODATA 0
-#define B_AVI_CLRMET_ITU601  1
-#define B_AVI_CLRMET_ITU709  2
-// D[5:4] M1M0 Picture Aspect Ratio
-#define O_AVI_PIC_ASRATIO 4
-#define M_AVI_PIC_ASRATIO_MASK 3
-#define B_AVI_PIC_ASRATIO_NODATA 0
-#define B_AVI_PIC_ASRATIO_4_3    1
-#define B_AVI_PIC_ASRATIO_16_9   2
-// D[3:0] R3R2R1R0 Active Format Aspect Ratio
-#define O_AVI_FMT_ASRATIO 0
-#define M_AVI_FMT_ASRATIO_MASK  0xF
-#define M_AVI_FMT_ASRATIO_EQPIC 0x8
-#define M_AVI_FMT_ASRATIO_4_3 0x9
-#define M_AVI_FMT_ASRATIO_16_9 0xA
-#define M_AVI_FMT_ASRATIO_14_9 0xB
-#define REG_RX_AVI_DB2	0xAF
-// D[1:0] SC1SC0 Non-uniform picture scaling
-#define O_AVI_NUNI_SCALE 0
-#define M_AVI_NUNI_SCALE_MASK 3
-#define B_AVI_NUNI_SCALE_NODATA 0
-#define B_AVI_NUNI_SCALE_HORZ 1
-#define B_AVI_NUNI_SCALE_VERT 2
-#define B_AVI_NUNI_SCALE_HORZVERT 3
-// the following code is valid when AVI Infoframe ver 2.0
-#define REG_RX_AVI_DB3	0xB0
-// D[6:0] - Video Codes
-#define O_AVI_VIDCODE 0
-#define O_AVI_VIDCODE_MASK 0x7f
-#define REG_RX_AVI_DB4	0xB1
-// D[3:0] - Pixel Repeating Info
-#define O_AVI_PIXREPT 0
-#define M_AVI_PIXREPT_MASK 0xF
-// pixel repeating value is the D[3:0]
-#define REG_RX_AVI_DB5	0xB2
-#define REG_RX_AVI_DB6	0xB3
-#define REG_RX_AVI_DB7	0xB4
-#define REG_RX_AVI_DB8	0xB5
-#define REG_RX_AVI_DB9	0xB6
-#define REG_RX_AVI_DB10	0xB7
-#define REG_RX_AVI_DB11	0xB8
-#define REG_RX_AVI_DB12	0xB9
-#define REG_RX_AVI_DB13	0xBA
-#define REG_RX_AVI_DB14	0xBB
-#define REG_RX_AVI_DB15	0xBC
-#define REG_RX_GENPKT_HB0	0xBD
-#define REG_RX_GENPKT_HB1	0xBE
-#define REG_RX_GENPKT_HB2	0xBF
-#define REG_RX_GENPKT_DB0	0xC0
-#define REG_RX_GENPKT_DB1	0xC1
-#define REG_RX_GENPKT_DB2	0xC2
-#define REG_RX_GENPKT_DB3	0xC3
-#define REG_RX_GENPKT_DB4	0xC4
-#define REG_RX_GENPKT_DB5	0xC5
-#define REG_RX_GENPKT_DB6	0xC6
-#define REG_RX_GENPKT_DB7	0xC7
-#define REG_RX_GENPKT_DB8	0xC8
-#define REG_RX_GENPKT_DB9	0xC9
-#define REG_RX_GENPKT_DB10	0xCA
-#define REG_RX_GENPKT_DB11	0xCB
-#define REG_RX_GENPKT_DB12	0xCC
-#define REG_RX_GENPKT_DB13	0xCD
-#define REG_RX_GENPKT_DB14	0xCE
-#define REG_RX_GENPKT_DB15	0xCF
-#define REG_RX_GENPKT_DB16	0xD0
-#define REG_RX_GENPKT_DB17	0xD1
-#define REG_RX_GENPKT_DB18	0xD2
-#define REG_RX_GENPKT_DB19	0xD3
-#define REG_RX_GENPKT_DB20	0xD4
-#define REG_RX_GENPKT_DB21	0xD5
-#define REG_RX_GENPKT_DB22	0xD6
-#define REG_RX_GENPKT_DB23	0xD7
-#define REG_RX_GENPKT_DB24	0xD8
-#define REG_RX_GENPKT_DB25	0xD9
-#define REG_RX_GENPKT_DB26	0xDA
-#define REG_RX_GENPKT_DB27	0xDB
-#define REG_RX_AUDIO_VER	0xDC
-#define REG_RX_AUDIO_DB0	0xDD
-// D[7:4] CT3~CT0 Audio Coding Type
-// 0000 - Refer to Stream Header
-// 0001 - IEC60958 PCM
-// 0010 - AC-3
-// 0011 - MPEG1 (Layers 1 & 2)
-// 0100 - MP3 (MPEG1 Layer 3)
-// 0101 - MPEG2 (Multichannel)
-// 0110 - AAC
-// 0111 - DTS
-// 1000 - ATRAC
-#define O_AUD_CODTYPE 4
-#define M_AUD_CODTYPE_MASK 0xF
-#define B_AUD_CODTYPE_STREAMDEF 0
-#define B_AUD_CODTYPE_IEC60958  1
-#define B_AUD_CODTYPE_AC3       2
-#define B_AUD_CODTYPE_MPEG1     3
-#define B_AUD_CODTYPE_MP3       4
-#define B_AUD_CODTYPE_MPEG2     5
-#define B_AUD_CODTYPE_AAC       6
-#define B_AUD_CODTYPE_DTS       7
-#define B_AUD_CODTYPE_ATRAC     8
-// D[2:0] Audio Channel Count
-// 000 - Refer to stream header
-// 001 ~ 111 channel # -1
-#define O_AUD_CHCNT 0
-#define M_AUD_CHCNT_MASK 0x7
-#define B_AUD_CHCNT_STREAMDEF 0
-#define B_AUD_CHCNT_CH2       1
-#define B_AUD_CHCNT_CH3       2
-#define B_AUD_CHCNT_CH4       3
-#define B_AUD_CHCNT_CH5       4
-#define B_AUD_CHCNT_CH6       5
-#define B_AUD_CHCNT_CH7       6
-#define B_AUD_CHCNT_CH8       7
-#define REG_RX_AUDIO_DB1	0xDE
-// D[4:2] Sampling Freq
-// 000 - Refer to stream definition
-// 001 - 32KHz
-// 010 - 44.1 KHz
-// 011 - 48 KHz
-// 100 - 88.2 KHz
-// 101 - 96 KHz
-// 110 - 176.4 KHz
-// 111 - 192 KHz
-#define O_AUD_SMP_FREQ  2
-#define M_AUD_SMP_FREQ_MASK 7
-#define B_AUD_SMP_FREQ_STREAMDEF 0
-#define B_AUD_SMP_32K            1
-#define B_AUD_SMP_44K            2
-#define B_AUD_SMP_48K            3
-#define B_AUD_SMP_88K            4
-#define B_AUD_SMP_96K            5
-#define B_AUD_SMP_176K           6
-#define B_AUD_SMP_192K           7
-// D[1:0] Sample Size
-#define O_AUD_SMP_SIZE 0
-#define O_AUD_SMP_SIZE_MASK 0x3
-#define O_AUD_SMP_SIZE_STREAMDEF 0
-#define O_AUD_SMP_16BIT 1
-#define O_AUD_SMP_20BIT 2
-#define O_AUD_SMP_24BIT 3
-#define REG_RX_AUDIO_DB2	0xDF
-// depend the audio color code
-// most case define the maximum bit rate / 8KHz
-#define REG_RX_AUDIO_DB3	0xE0
-// CA - define the speak layout
-#define REG_RX_AUDIO_DB4	0xE1
-// D[7] - Describes whether the down mixed stereo output is permitted or not
-#define B_PROHIBITED (1<<7)
-// D[6:3] Audio Level shift
-#define O_AUD_LEVEL_SHIFT_VALUE 3
-#define O_AUD_LEVEL_SHIFT_MASK 0xF
-#define REG_RX_AUDIO_DB5	0xE2
-#define REG_RX_AUDIO_LEN    0xE3
-#define REG_RX_MPEG_VER	0xE4
-#define REG_RX_MPEG_LEN 0xE5
-#define REG_RX_MPEG_DB0	0xE6
-#define REG_RX_MPEG_DB1	0xE7
-#define REG_RX_MPEG_DB2	0xE8
-#define REG_RX_MPEG_DB3	0xE9
-#define REG_RX_MPEG_DB4	0xEA
-#define REG_RX_MPEG_DB5	0xEB
-
-#define REG_RX_ACP_HB0 0xEC
-#define REG_RX_ACP_HB1 0xED
-#define REG_RX_ACP_HB2 0xEE
-#define REG_RX_ACP_DB0 0xEF
-#define REG_RX_ACP_DB1 0xF0
-#define REG_RX_ACP_DB2 0xF1
-#define REG_RX_ACP_DB3 0xF2
-#define REG_RX_ACP_DB4 0xF3
-#define REG_RX_ACP_DB5 0xF4
-#define REG_RX_ACP_DB6 0xF5
-#define REG_RX_ACP_DB7 0xF6
-#define REG_RX_ACP_DB8 0xF7
-#define REG_RX_ACP_DB9 0xF8
-#define REG_RX_ACP_DB10 0xF9
-#define REG_RX_ACP_DB11 0xFA
-#define REG_RX_ACP_DB12 0xFB
-#define REG_RX_ACP_DB13 0xFC
-#define REG_RX_ACP_DB14 0xFD
-#define REG_RX_ACP_DB15 0xFE
-#define REG_RX_ACP_REC_TYPE 0xFF
-///////////////////////////////////////////////////////////
-// Bank 1
-///////////////////////////////////////////////////////////
-
-#define REG_RX_ISRC1_HB0 0xA0
-#define REG_RX_ISRC1_HB1 0xA1
-#define REG_RX_ISRC1_HB2 0xA2
-#define REG_RX_ISRC1_DB0 0xA3
-#define REG_RX_ISRC1_DB1 0xA4
-#define REG_RX_ISRC1_DB2 0xA5
-#define REG_RX_ISRC1_DB3 0xA6
-#define REG_RX_ISRC1_DB4 0xA7
-#define REG_RX_ISRC1_DB5 0xA8
-#define REG_RX_ISRC1_DB6 0xA9
-#define REG_RX_ISRC1_DB7 0xAA
-#define REG_RX_ISRC1_DB8 0xAB
-#define REG_RX_ISRC1_DB9 0xAC
-#define REG_RX_ISRC1_DB10 0xAD
-#define REG_RX_ISRC1_DB11 0xAE
-#define REG_RX_ISRC1_DB12 0xAF
-#define REG_RX_ISRC1_DB13 0xB0
-#define REG_RX_ISRC1_DB14 0xB1
-#define REG_RX_ISRC1_DB15 0xB2
-#define REG_RX_ISRC1_REC_TYPE 0xB3
-#define REG_RX_ISRC2_HB0 0xB4
-#define REG_RX_ISRC2_HB1 0xB5
-#define REG_RX_ISRC2_HB2 0xB6
-#define REG_RX_ISRC2_DB0 0xB7
-#define REG_RX_ISRC2_DB1 0xB8
-#define REG_RX_ISRC2_DB2 0xB9
-#define REG_RX_ISRC2_DB3 0xBA
-#define REG_RX_ISRC2_DB4 0xBB
-#define REG_RX_ISRC2_DB5 0xBC
-#define REG_RX_ISRC2_DB6 0xBD
-#define REG_RX_ISRC2_DB7 0xBE
-#define REG_RX_ISRC2_DB8 0xBF
-#define REG_RX_ISRC2_REC_TYPE 0xC0
-#define REG_RX_KSV_FIFO00 0xC1
-#define REG_RX_KSV_FIFO01 0xC2
-#define REG_RX_KSV_FIFO02 0xC3
-#define REG_RX_KSV_FIFO03 0xC4
-#define REG_RX_KSV_FIFO04 0xC5
-#define REG_RX_KSV_FIFO10 0xC6
-#define REG_RX_KSV_FIFO11 0xC7
-#define REG_RX_KSV_FIFO12 0xC8
-#define REG_RX_KSV_FIFO13 0xC9
-#define REG_RX_KSV_FIFO14 0xCA
-#define REG_RX_KSV_FIFO20 0xCB
-#define REG_RX_KSV_FIFO21 0xCC
-#define REG_RX_KSV_FIFO22 0xCD
-#define REG_RX_KSV_FIFO23 0xCE
-#define REG_RX_KSV_FIFO24 0xCF
-#define REG_RX_KSV_FIFO30 0xD0
-#define REG_RX_KSV_FIFO31 0xD1
-#define REG_RX_KSV_FIFO32 0xD2
-#define REG_RX_KSV_FIFO33 0xD3
-#define REG_RX_KSV_FIFO34 0xD4
-#define REG_RX_KSV_FIFO40 0x80
-#define REG_RX_KSV_FIFO41 0x81
-#define REG_RX_KSV_FIFO42 0x82
-#define REG_RX_KSV_FIFO43 0x83
-#define REG_RX_KSV_FIFO44 0x84
-#define REG_RX_KSV_FIFO50 0x85
-#define REG_RX_KSV_FIFO51 0x86
-#define REG_RX_KSV_FIFO52 0x87
-#define REG_RX_KSV_FIFO53 0x88
-#define REG_RX_KSV_FIFO54 0x89
-#define REG_RX_KSV_FIFO60 0x8A
-#define REG_RX_KSV_FIFO61 0x8B
-#define REG_RX_KSV_FIFO62 0x8C
-#define REG_RX_KSV_FIFO63 0x8D
-#define REG_RX_KSV_FIFO64 0x8E
-#define REG_RX_KSV_FIFO70 0x8F
-#define REG_RX_KSV_FIFO71 0x90
-#define REG_RX_KSV_FIFO72 0x91
-#define REG_RX_KSV_FIFO73 0x92
-#define REG_RX_KSV_FIFO74 0x93
-
-#define REG_RX_BSTATUSL 0xD5
-#define REG_RX_BSTATUSH 0xD6
-    #define B_CAP_HDMI_MODE (1<<12)
-    #define B_CAP_DVI_MODE (0<<12)
-    #define B_MAX_CASCADE_EXCEEDED  (1<<11)
-    #define M_REPEATER_DEPTH    (0x7<<8)
-    #define O_REPEATER_DEPTH    8
-    #define B_DOWNSTREAM_OVER   (1<<7)
-    #define M_DOWNSTREAM_COUNT  0x7F
-#define REG_RX_SHA1_H00 0xD7
-#define REG_RX_SHA1_H01 0xD8
-#define REG_RX_SHA1_H02 0xD9
-#define REG_RX_SHA1_H03 0xDA
-#define REG_RX_SHA1_H10 0xDB
-#define REG_RX_SHA1_H11 0xDC
-#define REG_RX_SHA1_H12 0xDD
-#define REG_RX_SHA1_H13 0xDE
-#define REG_RX_SHA1_H20 0xDF
-#define REG_RX_SHA1_H21 0xE0
-#define REG_RX_SHA1_H22 0xE1
-#define REG_RX_SHA1_H23 0xE2
-#define REG_RX_SHA1_H30 0xE3
-#define REG_RX_SHA1_H31 0xE4
-#define REG_RX_SHA1_H32 0xE5
-#define REG_RX_SHA1_H33 0xE6
-#define REG_RX_SHA1_H40 0xE7
-#define REG_RX_SHA1_H41 0xE8
-#define REG_RX_SHA1_H42 0xE9
-#define REG_RX_SHA1_H43 0xEA
-#define REG_RX_M0_B0 0xEB
-#define REG_RX_M0_B1 0xEC
-#define REG_RX_M0_B2 0xED
-#define REG_RX_M0_B3 0xEE
-#define REG_RX_M0_B4 0xEF
-#define REG_RX_M0_B5 0xF0
-#define REG_RX_M0_B6 0xF1
-#define REG_RX_M0_B7 0xF2
-
-///////////////////////////////////////////////////////////
-// mode uc type and structure
-///////////////////////////////////////////////////////////
-
-#define CAPS_MIN_PROGRESS_VFREQ 2300  // 23Hz
-#define CAPS_MAX_PROGRESS_VFREQ 10000 // 100Hz
-#define CAPS_MIN_PROGRESS_HFREQ 300   // 30.0 KHz
-#define CAPS_MAX_PROGRESS_HFREQ 1000  // 100.0 KHz
-#define CAPS_MIN_INTERLACE_VFREQ 2500 // 25Hz
-#define CAPS_MAX_INTERLACE_VFREQ 6000 // 55Hz
-#define CAPS_MIN_INTERLACE_HFREQ 150  // 15.0 KHz
-#define CAPS_MAX_INTERLACE_HFREQ 550  // 60.0 KHz
-
-//typedef struct _Sync_Info {
-//    USHORT HRes, VRes ;
-//    SHORT VFreq ; // in 0.01Hz unit
-//    USHORT HTotal, VTotal ;
-//    USHORT PCLK ; // in 100KHz unit
-//    BYTE PixelRep ;
-//    BYTE Mode ; // D[0] - interlace
-//} SYNC_INFO, *PSYNC_INFO ;
-//
-
-//#define F_MODE_INTERLACE  (1<<0)
-//#define F_MODE_RGB24  (0<<1)
-//#define F_MODE_YUV422 (1<<1)
-//#define F_MODE_YUV444 (2<<1)
-//#define F_MODE_CLRMOD_MASK (3<<1)
-//#define F_MODE_ITU709  (1<<3)
-//#define F_MODE_16_235  (1<<4)
-//#define F_MODE_EN_UDFILT (1<<5)// output mode only, and loaded from EEPROM
-//#define F_MODE_EN_DITHER  (1<<6)// output mode only, and loaded from EEPROM
-#define HDMI_RX_I2C_SLAVE_ADDR 0x90
-
-/////////////////////////////////////////
-// PC Implementation
-/////////////////////////////////////////
-// 1. SCL => output => Pin-2,  D0
-// 2. SDA-write => output => Pin1, ~C0
-// 3. SDA-read => input => Pin15, S3
-// 4. ResetN=> output => Pin14, ~C1
-// 5. SCDT => input => Pin13, S4
-// 6. Vsync => input => Pin12, S5
-// 7. INT => input => Pin11, ~S7
-/////////////////////////////////////////
-
-#define PORT_PRN_DATA 0x378
-#define PORT_PRN_STAT 0x379
-#define PORT_PRN_CTRL 0x37A
-
-#define FLAG_CLEAR_INT_MODE 1
-#define FLAG_CLEAR_INT_PKG 2
-#define FLAG_CLEAR_INT_ECC 4
-#define FLAG_CLEAR_INT_AUDIO 8
-#define FLAG_CLEAR_INT_MUTECLR (1<<6)
-#define FLAG_CLEAR_INT_MUTESET (1<<7)
-#define FLAG_CLEAR_INT_ALL  (FLAG_CLEAR_INT_MUTESET|FLAG_CLEAR_INT_MUTECLR|FLAG_CLEAR_INT_MODE|FLAG_CLEAR_INT_PKG|FLAG_CLEAR_INT_ECC|FLAG_CLEAR_INT_AUDIO)
-#define FLAG_CLEAR_INT_MASK (~FLAG_CLEAR_INT_ALL)
-
-#define FLAG_CLEAR_INT_HDCP (1<<7)
-
-#ifndef _MCU_8051_
-UCHAR Read_Port_UCHAR(USHORT Port);
-USHORT Read_Port_USHORT(USHORT Port);
-ULONG Read_Port_ULONG(USHORT Port);
-UCHAR Write_Port_UCHAR(USHORT Port,UCHAR uc);
-USHORT Write_Port_USHORT(USHORT Port,USHORT uc);
-ULONG Write_Port_ULONG(USHORT Port,ULONG uc);
-#endif
-
-BYTE HDMIRX_ReadI2C_Byte(BYTE RegAddr);
-SYS_STATUS HDMIRX_WriteI2C_Byte(BYTE RegAddr, BYTE Data);
-SYS_STATUS HDMIRX_ReadI2C_ByteN(BYTE RegAddr, BYTE *pData, int N);
-SYS_STATUS HDMIRX_WriteI2C_ByteN(BYTE RegAddr, BYTE *pData, int N);
-
-#ifndef _MCU_8051_
-/////////////////////////////////////////
-// PC Implementation
-/////////////////////////////////////////
-// 1. SCL => output => Pin-2,  D0
-// 2. SDA-write => output => Pin1, ~C0
-// 3. SDA-read => input => Pin15, S3
-// 4. ResetN=> output => Pin14, ~C1
-// 5. SCDT => input => Pin13, S4
-// 6. Vsync => input => Pin12, S5
-// 7. INT => input => Pin11, ~S7
-/////////////////////////////////////////
-
-#define PORT_PRN_DATA 0x378
-#define PORT_PRN_STAT 0x379
-#define PORT_PRN_CTRL 0x37A
-#endif
-
-
-//void ClearIntFlags(BYTE flag);
-void RXINT_CheckVendorSpecInfo(void);
-
-//#ifndef _MCU_8051_
-//BOOL ReadRXIntPin();
-
-//#endif
-
-#define B_CAP_AUDIO_ON  (1<<7)
-#define B_CAP_HBR_AUDIO (1<<6)
-#define B_CAP_DSD_AUDIO (1<<5)
-#define B_LAYOUT        (1<<4)
-#define B_MULTICH       (1<<4)
-#define B_HBR_BY_SPDIF  (1<<3)
-#define B_SPDIF         (1<<2)
-#define B_CAP_LPCM      (1<<0)
-
-typedef struct {
-    BYTE AudioFlag ;
-    BYTE AudSrcEnable ;
-    BYTE SampleFreq ;
-    BYTE ChStat[5] ;
-} AUDIO_CAPS ;
-
-#define Switch_HDMIRX_Bank(x)HDMIRX_WriteI2C_Byte(0x0f,(x)&1)
-
-//////////////////////////////////////////////////////////////////////////
-// EEPROM setting
-//////////////////////////////////////////////////////////////////////////
-//#define EEPROM_SYNC_POL    0x00
-//#define EEPROM_HWMUTE_RATE 0x01 // 2byte
-//#define EEPROM_HWAMP_CTRL  0x03
-//#define EEPROM_I2S_MODE    0x04 // for reg 0x75
-//#define EEPROM_AUDMAP_INFO 0x05 // for reg 0x76
-//#define EEPROM_MCLK_SEL    0x06 // for reg 0x78[2:0]
-//#define EEPROM_AUD_TRISTATE 0x07 // for reg 0x89 [4:0], SPDIF or I2S
-//#define EEPROM_INT_CTRL    0x08 // for reg 0x19
-//#define EEPROM_DEFAULT_VIDEO_OUTPUT 0x10
-//                                // indicated to the bOutputVideoMode
-//#define EEPROM_OUTPUT_MAP  0x11 // corresponded into reg1B
-//#define EEPROM_VID_CTRL    0x12 // corresponded into reg1C
-
-//#define EEPROM_BINFILE "hdmirom.bin"
-
-
-//BYTE ReadEEPROMByte(SHORT RegAddr);
-//SYS_STATUS ReadEEPROMByteN(SHORT RegAddr, BYTE *pData, int N);
-
-#define CAT_HDMI_PORTA 0
-#define CAT_HDMI_PORTB 1
-#define HDMIRX_MAX_KSV 6
-///////////////////////////////////////////////////////////
-// Interface
-///////////////////////////////////////////////////////////
-void InitHDMIRX(BOOL bFullInit);
-void Check_HDMInterrupt(void);
-BOOL CheckHDMIRX(void);
-void SelectHDMIPort(BYTE ucPort);
-BYTE GetCurrentHDMIPort(void);
-void PowerDownHDMI(void);
-void Turn_HDMIRX(BOOL bEnable);
-BOOL IsHDMIRXInterlace(void);
-WORD getHDMIRXHorzTotal(void);
-WORD getHDMIRXHorzActive(void);
-WORD getHDMIRXHorzFrontPorch(void);
-WORD getHDMIRXHorzSyncWidth(void);
-WORD getHDMIRXHorzBackPorch(void);
-WORD getHDMIRXVertTotal(void);
-WORD getHDMIRXVertActive(void);
-WORD getHDMIRXVertFrontPorch(void);
-WORD getHDMIRXVertSyncToDE(void);
-WORD getHDMIRXVertSyncBackPorch(void);
-WORD getHDMIRXVertSyncWidth(void);
-BYTE getHDMIRXxCnt(void);
-void getHDMIRXRegs(BYTE *pData);
-BYTE getHDMIRXOutputColorMode(void);
-BOOL getHDMIRXAudioInfo(BYTE *pbAudioSampleFreq, BYTE *pbValidCh);
-BYTE getHDMIRXOutputColorDepth(void);
-
-BYTE HDMIRXFsGet(void);
-BOOL HDMIRXHDAudioGet(void);
-BOOL HDMIRXMultiPCM(void);
-BYTE HDMIRXAudioChannelNum(void);
-void HDMIRXHBRMclkSet(BYTE cFs);
-void getHDMIRXInputAudio(AUDIO_CAPS *pAudioCaps);
-
-BOOL IsHDCPOn(void);
-BOOL IsHDMIRXHDMIMode(void);
-void SetHDMIRXVideoOutputFormat(BYTE bOutputMapping, BYTE bOutputType, BYTE bOutputColorMode);
-
-BOOL  GetAVIInfoFrame(BYTE *pData);
-BOOL  GetAudioInfoFrame(BYTE *pData);
-BOOL  GetVENDORSPECInfoFrame(BYTE *pData);
-
-BYTE getHDMIRXAudioStatus(void);
-BOOL getHDMIRXAudioChannelStatus(BYTE ucIEC60958ChStat[]);
-void setHDMIRX_HBROutput(BOOL HBR_SPDIF);
-void setHDMIRX_SPDIFOutput(void);
-void setHDMIRX_I2SOutput(BYTE src_enable);
-
-// void setHDMIRX_TerminatorOff();
-// void setHDMIRX_TerminatorOn();
-
-#define HDCP_RECEIVER   0
-#define HDCP_REPEATER   1
-#define HDCP_RDY_TIMEOUT    (1<<1)
-#define HDCP_INVALID_V      (1<<2)
-#define HDCP_OVER_DOWNSTREAM    (1<<3)
-#define HDCP_OVER_CASCADE   (1<<4)
-
-#define EVENT_RXHDCP_AUTH_START   (1<<0)
-#define EVENT_RXHDCP_AUTH_DONE   (1<<1)
-
-BOOL IsHDMIRX_VideoReady(void) ;
-BOOL IsHDMIRX_AudioReady(void) ;
-BOOL IsHDMIRX_VideoOn(void) ;
-#define VIDEO_OFF   0
-#define VIDEO_ON    1
-#define VIDEO_AUTO  2
-BOOL EnableHDMIRXVideoOutput(BYTE Option) ;
-
-
-#ifdef DEBUG
-void DumpHDMIRXReg(void);
-#else
-#define DumpHDMIRXReg(void)
-#endif
-//////////////////////////////////////////////////////////////////////////////////
-// HDCP Repeater Function
-//////////////////////////////////////////////////////////////////////////////////
-
-#ifdef SUPPORT_REPEATER
-void RxHDCPSetReceiver(void);
-void RxHDCPSetRepeater(void);
-void RxHDCPSetRdyTimeOut(void);
-void RxHDCPSetInvalidV(void);
-void RxHDCPSetOverDownStream(void);
-void RxHDCPSetOverCascade(void);
-void RxHDCPSetReceiver(void);
-void RxHDCPSetRepeater(void);
-void RxHDCPSetRdyTimeOut(void);
-void RxHDCPSetInvalidV(void);
-void RxHDCPSetOverDownStream(void);
-void RxHDCPSetOverCascade(void);
-void RxHDCPRepeaterCapabilitySet(BYTE uc);
-void RxHDCPRepeaterCapabilityClear(BYTE uc);
-
-BOOL EnableRepeater(BOOL bEnable);
-SYS_STATUS RxGetKSVFifoList(BYTE *pKSVList);
-SYS_STATUS RxHDCPGetBstatus(USHORT *pBstatus);
-
-void SwitchRxHDCPState(RXHDCP_State_Type state);
-void RxHDCP_Handler(void);
-
-void setRxHDCPBStatus(WORD bstatus);
-void setRxHDCPFailReady(void);
-void setRxHDCPCalcSHA(void);
-SYS_STATUS setRxHDCPKSVList(BYTE offset, BYTE *pKSVList, BYTE count);
-
-BOOL getRxHDCPEvent(BYTE event);
-void setRxHDCPEvent(BYTE event);
-
-#define IsRxAuthStart()getRxHDCPEvent(EVENT_RXHDCP_AUTH_START)
-#define IsRxAuthDone()getRxHDCPEvent(EVENT_RXHDCP_AUTH_DONE)
-
-
-#endif // SUPPORT_REPEATER
-
-
-#endif // _HDMIRX_H_
-
diff --git a/drivers/amlogic/tvin/it660x/hdmirx_repeater.c b/drivers/amlogic/tvin/it660x/hdmirx_repeater.c
deleted file mode 100755
index 0bc4592ecc52..000000000000
--- a/drivers/amlogic/tvin/it660x/hdmirx_repeater.c
+++ /dev/null
@@ -1,356 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <hdmirx_repeater.c>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-
-
-#include "hdmirx.h"
-
-#ifdef SUPPORT_REPEATER
-
-RXHDCP_State_Type RHDCPState = RXHDCP_Reset ;
-// BOOL repeater = FALSE ;
-
-
-static BYTE RxHDCPStatusFlag = 0 ;
-static BYTE cDownStream = 0 ;
-static BYTE KSVOffset=0 ;
-
-static _XDATA BYTE Vr[20] ;
-static _XDATA BYTE M0[8] ;
-static _XDATA BYTE SHABuff[64] ;
-
-extern BYTE bHDCPMode ;
-
-///////////////////////////////////////////////////////////////////////////////
-// Function Prototype
-///////////////////////////////////////////////////////////////////////////////
-SYS_STATUS RxHDCP_WriteVR(BYTE *pVr);
-
-
-///////////////////////////////////////////////////////////////////////////////
-// Function Body
-///////////////////////////////////////////////////////////////////////////////
-void RxHDCPSetReceiver()
-{
-	PowerDownHDMI();
-    bHDCPMode = HDCP_RECEIVER ;
-	InitHDMIRX(TRUE);
-
-}
-
-void RxHDCPSetRepeater()
-{
-    PowerDownHDMI();
-    bHDCPMode = HDCP_REPEATER ;
-    InitHDMIRX(TRUE);
-}
-
-#ifdef REPEATER_DEBUG
-void RxHDCPSetRdyTimeOut()
-{
-    PowerDownHDMI();
-    bHDCPMode = HDCP_REPEATER | HDCP_RDY_TIMEOUT ;
-    InitHDMIRX(TRUE);
-}
-
-void RxHDCPSetInvalidV()
-{
-    PowerDownHDMI();
-    bHDCPMode = HDCP_REPEATER | HDCP_INVALID_V ;
-    InitHDMIRX(FALSE);
-}
-
-void RxHDCPSetOverDownStream()
-{
-    PowerDownHDMI();
-    bHDCPMode = HDCP_REPEATER | HDCP_OVER_DOWNSTREAM ;
-    InitHDMIRX(TRUE);
-}
-
-void RxHDCPSetOverCascade()
-{
-    PowerDownHDMI();
-    bHDCPMode = HDCP_REPEATER | HDCP_OVER_CASCADE ;
-    InitHDMIRX(TRUE);
-}
-#endif // REPEATER_DEBUG
-
-void RxHDCPRepeaterCapabilitySet(BYTE uc)
-{
-	HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL)|uc);
-    HDMIRX_DEBUG_PRINTF(("RxHDCPRepeaterCapabilitySet=%2X\n",(int)uc));
-}
-
-void RxHDCPRepeaterCapabilityClear(BYTE uc)
-{
-	HDMIRX_WriteI2C_Byte(REG_RX_CDEPTH_CTRL,HDMIRX_ReadI2C_Byte(REG_RX_CDEPTH_CTRL)&(~uc));
-    HDMIRX_DEBUG_PRINTF(("RxHDCPRepeaterCapabilityClear=%2X\n",(int)uc));
-}
-
-SYS_STATUS
-RxHDCP_GenVR(BYTE Vr[])
-{
-	// extern void SHA_Simple(void *p, LONG len, BYTE *output);
-
-    int i, n ;
-
-    n = cDownStream*5+10 ;
-    for(i = n ; i < 64 ; i++)
-    {
-        SHABuff[i] = 0 ;
-    }
-	for(i = 0 ; i < 64 ; i++)
-	{
-		HDMIRX_DEBUG_PRINTF2(("%02X ",(int)SHABuff[i]));
-		if(0==((i+1)%8))HDMIRX_DEBUG_PRINTF2(("\n"));
-	}
-	HDMIRX_DEBUG_PRINTF(("n=%2X\n",(int)n));
-    SHA_Simple(SHABuff, (LONG)n, Vr);
-	HDMIRX_DEBUG_PRINTF2(("SHA[]: "));
-	for(i = 0 ; i < 20 ; i++)
-	{
-		HDMIRX_DEBUG_PRINTF2(("%02X ",(int)Vr[i]));
-	}
-	HDMIRX_DEBUG_PRINTF2(("\n"));
-    return ER_SUCCESS ;
-}
-
-
-SYS_STATUS setRxHDCPKSVList(BYTE offset, BYTE *pKSVList, BYTE count)
-{
-	BYTE i=0;
-    if(!pKSVList)
-    {
-        return ER_FAIL ;
-    }
-
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,1);
-    if((offset+count)> HDMIRX_MAX_KSV)
-    {
-        return ER_FAIL ;
-    }
-
-    for(KSVOffset = offset ; (KSVOffset < HDMIRX_MAX_KSV)&& (KSVOffset < count); KSVOffset ++)
-    {
-        if (KSVOffset < 4)
-        {
-        	for(i = 0 ;i<5;i++)
-        	{
-        		HDMIRX_WriteI2C_Byte(REG_RX_KSV_FIFO00+i+KSVOffset*5,pKSVList[(KSVOffset-offset)*5+i]);
-        		SHABuff[KSVOffset*5+i] = pKSVList[(KSVOffset-offset)*5+i] ;
-        	}
-        }
-        else
-        {
-        	for(i = 0 ;i<5;i++)
-        	{
-        		HDMIRX_WriteI2C_Byte(REG_RX_KSV_FIFO40+i+KSVOffset*5-20,pKSVList[(KSVOffset-offset)*5+i]);
-        		SHABuff[KSVOffset*5+i] = pKSVList[(KSVOffset-offset)*5+i] ;
-        	}
-        }
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,0);
-
-	return ER_SUCCESS;
-}
-
-SYS_STATUS RxHDCPGetM0()
-{
-	BYTE i=0;
-    if(cDownStream > HDMIRX_MAX_KSV)
-    {
-        return ER_FAIL ;
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,1);
-	for(;i<8;i++)
-	{
-		SHABuff[cDownStream*5+2+i]=HDMIRX_ReadI2C_Byte(REG_RX_M0_B0+i);
-		HDMIRX_DEBUG_PRINTF3(("M[%d] = %02X\n",i,(int)SHABuff[cDownStream*5+2+i]));
-	}
-
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,0);
-    HDMIRX_DEBUG_PRINTF(("RxHDCPGetM0\n"));
-	return ER_SUCCESS;
-}
-
-SYS_STATUS RxHDCPGetBstatus(USHORT *pBstatus)
-{
-    if(!pBstatus)
-    {
-        return ER_FAIL ;
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,1);
-    *pBstatus=HDMIRX_ReadI2C_Byte(REG_RX_BSTATUSH);
-    *pBstatus <<= 8 ;
-    *pBstatus |= HDMIRX_ReadI2C_Byte(REG_RX_BSTATUSL);
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,0);
-    HDMIRX_DEBUG_PRINTF(("RxHDCPGetBstatus\n"));
-	return ER_SUCCESS;
-}
-
-void setRxHDCPBStatus(WORD bstatus)
-{
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,1);
-    HDMIRX_WriteI2C_Byte(REG_RX_BSTATUSH,(BYTE)((bstatus>>8)& 0x0F));
-    HDMIRX_WriteI2C_Byte(REG_RX_BSTATUSL,(BYTE)(bstatus & 0xFF));
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,0);
-
-    cDownStream = (BYTE)(bstatus &0x7F);
-    if((0==(bstatus & 0x880))&& cDownStream <= HDMIRX_MAX_KSV)
-    {
-        SHABuff[cDownStream*5] = (BYTE)(bstatus &0xFF);
-        SHABuff[cDownStream*5+1] = (BYTE)((bstatus>>8)&0x0F)| (IsHDMIRXHDMIMode()?0x10:0);
-    }
-
-}
-
-SYS_STATUS RxHDCP_WriteVR(BYTE *pVr)
-{
-	BYTE i;
-    if(!pVr)
-    {
-        return ER_FAIL ;
-    }
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,1);
-
-	for(i = 0 ; i < 20 ; i++ )
-	{
-		HDMIRX_WriteI2C_Byte(REG_RX_SHA1_H00+i,*(pVr+i));
-		if(!(i%5))HDMIRX_DEBUG_PRINTF2(("\n"));
-		HDMIRX_DEBUG_PRINTF2(("SHA1[%2X]=%2X ,",(int)i,(int)*(pVr+i))) ;
-	}
-    HDMIRX_WriteI2C_Byte(REG_RX_BLOCK_SEL,0);
-	DumpHDMIRXReg();
-	return ER_SUCCESS;
-}
-
-void setRxHDCPEvent(BYTE event)
-{
-    RxHDCPStatusFlag |= event ;
-}
-
-
-BOOL getRxHDCPEvent(BYTE event)
-{
-    BOOL retv ;
-    retv = (RxHDCPStatusFlag & event)?TRUE:FALSE ;
-    RxHDCPStatusFlag &= ~event ;
-    return retv ;
-}
-
-
-void setRxHDCPCalcSHA()
-{
-#if 1
-    SwitchRxHDCPState(RXHDCP_UpdateKSVList);
-#else
-    RxHDCPGetM0();
-    RxHDCP_GenVR(Vr);
-    RxHDCP_WriteVR(Vr);
-    SwitchRxHDCPState(RXHDCP_Ready);
-#endif
-}
-
-char _CODE *RXHDCPStr[] =
-{
-    "RXHDCP_Reset = 0",
-    "RXHDCP_AuthStart",
-    "RXHDCP_AuthDone",
-    "RXHDCP_UpdateKSVList",
-    "RXHDCP_Ready",
-    "RXHDCP_FailReady",
-    "RXHDCP_Reserved"
-
-};
-
-void SwitchRxHDCPState(RXHDCP_State_Type state)
-{
-    if(RHDCPState == state)
-    {
-        return ;
-    }
-
-    HDMIRX_DEBUG_PRINTF(("SwitchRxHDCPState():%s->%s\n",RXHDCPStr[RHDCPState],RXHDCPStr[state])) ;
-
-    switch(state)
-    {
-    case RXHDCP_Reset:
-    	RxHDCPRepeaterCapabilityClear(B_KSV_READY);
-        break ;
-
-    case RXHDCP_AuthStart:
-    	RxHDCPRepeaterCapabilityClear(B_KSV_READY);
-	    setRxHDCPEvent(EVENT_RXHDCP_AUTH_START);
-        break ;
-
-    case RXHDCP_AuthDone:
-	    setRxHDCPEvent(EVENT_RXHDCP_AUTH_DONE);
-	    KSVOffset=0 ;
-	    cDownStream = 0 ;
-        break ;
-
-    case RXHDCP_UpdateKSVList:
-        break ;
-
-    case RXHDCP_Ready:
-        RxHDCPRepeaterCapabilitySet(B_KSV_READY);
-        break ;
-
-    case RXHDCP_FailReady:
-        RxHDCPRepeaterCapabilitySet(B_KSV_READY);
-        break ;
-    }
-
-    RHDCPState = state ;
-}
-
-void setRxHDCPFailReady()
-{
-    SwitchRxHDCPState(RXHDCP_FailReady);
-}
-
-void RxHDCP_Handler()
-{
-    if(0==(bHDCPMode & HDCP_REPEATER))
-    {
-        return ;
-    }
-    switch(RHDCPState)
-    {
-    case RXHDCP_Reset:
-        if(HDMIRX_ReadI2C_Byte(REG_RX_HDCP_STATUS)& B_R0_READY)
-        {
-            SwitchRxHDCPState(RXHDCP_AuthDone);
-        }
-        break ;
-
-    case RXHDCP_AuthStart:
-        if(HDMIRX_ReadI2C_Byte(REG_RX_HDCP_STATUS)& B_R0_READY)
-        {
-            SwitchRxHDCPState(RXHDCP_AuthDone);
-        }
-        break ;
-
-    case RXHDCP_AuthDone:
-        break ;
-
-    case RXHDCP_UpdateKSVList:
-        RxHDCPGetM0();
-        RxHDCP_GenVR(Vr);
-        RxHDCP_WriteVR(Vr);
-        SwitchRxHDCPState(RXHDCP_Ready);
-        break ;
-
-    }
-}
-
-
-#endif // SUPPORT_REPEATER
diff --git a/drivers/amlogic/tvin/it660x/io.h b/drivers/amlogic/tvin/it660x/io.h
deleted file mode 100755
index 31a1d135bba5..000000000000
--- a/drivers/amlogic/tvin/it660x/io.h
+++ /dev/null
@@ -1,64 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <io.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-#ifndef _IO_h_
-#define _IO_h_
-#include "config.h"
-#include "typedef.h"
-#include "debug.h"
-
-///////////////////////////////////////////////////////////////////////////////
-// Start: I2C for 8051
-///////////////////////////////////////////////////////////////////////////////
-///////////////////////////////////////////////////////////////////////////////
-// I2C for original function call
-///////////////////////////////////////////////////////////////////////////////
-
-BOOL i2c_write( BYTE address, BYTE offset, BYTE byteno, BYTE dataIn );
-BYTE i2c_read( BYTE address, BYTE offset, BYTE byteno, BYTE* rddata );
-
-
-BYTE ReadI2C_Byte(BYTE RegAddr);
-SYS_STATUS WriteI2C_Byte(BYTE RegAddr, BYTE d);
-
-SYS_STATUS ReadI2C_ByteN(BYTE RegAddr, BYTE *pData, int N);
-SYS_STATUS WriteI2C_ByteN(SHORT RegAddr, BYTE *pData, int N);
-
-BOOL i2c_read_byte( BYTE , BYTE , BYTE , BYTE *p_data, BYTE  );
-BOOL i2c_write_byte( BYTE , BYTE , BYTE , BYTE *DataIn, BYTE  );
-
-void hdmirx_clear_hpd(void) ;
-void hdmirx_set_hpd(void) ;
-
-///////////////// Delay Utility ////////////////////
-void DelayUS(USHORT);
-void delay1ms(USHORT);
-void HoldSystem(void);
-BOOL DisableVGAChecking(void);
-
-#define I2C_OrReg_Byte(reg,ormask) WriteI2C_Byte(reg,(ReadI2C_Byte(reg) | (ormask)))
-#define I2C_AndReg_Byte(reg,andmask) WriteI2C_Byte(reg,(ReadI2C_Byte(reg) & (andmask)))
-#define I2C_SetReg_Byte(reg,andmask,ormask) WriteI2C_Byte(reg,((ReadI2C_Byte(reg) & (andmask))|(ormask)))
-BOOL EDID_READ_BYTE( BYTE address, BYTE offset, BYTE byteno, BYTE *p_data, BYTE device);
-BOOL EDID_WRITE_BYTE( BYTE address, BYTE offset, BYTE byteno, BYTE *p_data, BYTE device );
-//#ifdef 	_Myson_CS8953_
-//#include "CS8953sfr.h"
-//void Initial_SFR();
-//void Initial_OSC();
-//#endif
-
-#ifndef Debug_message
-
-#endif
-extern    BYTE   I2CADR;
-extern    BYTE   I2CDEV;
-
-#endif
diff --git a/drivers/amlogic/tvin/it660x/it660x_drv.c b/drivers/amlogic/tvin/it660x/it660x_drv.c
deleted file mode 100755
index 49af048768e9..000000000000
--- a/drivers/amlogic/tvin/it660x/it660x_drv.c
+++ /dev/null
@@ -1,1584 +0,0 @@
-/*
- * Amlogic M6 
- * frame buffer driver-----------HDMI_RX
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-#define HDMI_DEBUG()  printk("HDMI DEBUG: %s [%d]", __FUNCTION__, __LINE__)
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-#include <linux/proc_fs.h> 
-#include <asm/uaccess.h>
-#include <mach/am_regs.h>
-#ifdef USE_TVIN_CAMERA
-#include <media/amlogic/656in.h>
-#else
-#include "../tvin_global.h"
-#include "../vdin/vdin_regs.h"
-#include "../vdin/vdin_drv.h"
-#include "../vdin/vdin_ctl.h"
-#include "../tvin_format_table.h"
-#include "../tvin_frontend.h"
-#endif
-//#include "mcu.h"
-#include "hdmirx.h"
-#include "version.h"
-#include "edid.h"
-#include "dvin.h"
-
-#define DEVICE_NAME "it660x"
-#define HDMI_RX_COUNT 4
-
-#define pr_dbg(fmt, args...) printk(KERN_DEBUG "it660x_hdmirx: " fmt, ## args)
-#define pr_error(fmt, args...) printk(KERN_ERR "it660x_hdmirx: " fmt, ## args)
-
-//GPIOD_4
-#define ENABLE_HPD_MUX   WRITE_MPEG_REG_BITS(PREG_PAD_GPIO2_EN_N, 0, 20, 1)
-#define SET_HPD          WRITE_MPEG_REG_BITS(PREG_PAD_GPIO2_O, 1, 20, 1)
-#define CLEAR_HPD          WRITE_MPEG_REG_BITS(PREG_PAD_GPIO2_O, 0, 20, 1)
-//GPIOD_6
-#define ENABLE_SYSRSTN_MUX   WRITE_MPEG_REG_BITS(PREG_PAD_GPIO2_EN_N, 0, 22, 1)
-#define RESET_SYSRSTN        WRITE_MPEG_REG_BITS(PREG_PAD_GPIO2_O, 1, 22, 1)
-#define RELEASE_SYSRSTN      WRITE_MPEG_REG_BITS(PREG_PAD_GPIO2_O, 0, 22, 1)
-
-#ifdef CONFIG_AML_AUDIO_DSP
-#define M2B_IRQ0_DSP_AUDIO_EFFECT (7)
-#define DSP_CMD_SET_HDMI_SR   (6)
-extern int  mailbox_send_audiodsp(int overwrite,int num,int cmd,const char *data,int len);
-#endif
-
-void set_invert_top_bot(bool invert_flag);
-
-static dev_t hdmirx_id;
-static struct class *hdmirx_class;
-static struct device *hdmirx_dev;
-
-static int repeater_enable = 0;
-static int test_flag = 0;
-int it660x_debug_flag = 0;
-static int stable_threshold = 10;
-static int is_hdmi_mode = 0;
-static int horz_active = 0;
-static int vert_active = 0;
-static int is_interlace = 0;
-static int vfreq = 0;
-
-static int audio_status = 0;
-static int audio_sample_freq = 0;
-static int audio_channel_alloc = 0;
-
-struct aud_info_s{
-    int real_sample_rate;
-};
-
-#define HDMIRX_STATE_POWEROFF           0
-#define HDMIRX_STATE_POWERON            1
-#define HDMIRX_STATE_HPD_HIGH           2
-#define HDMIRX_STATE_STABLE             3
-#define HDMIRX_STATE_READY              4
-
-char* state_name[] = {"poweroff", "poweron", "hpd high", "stable", "ready"};
-
-typedef struct hdmirx_dev_{
-    struct cdev cdev;             /* The cdev structure */
-    struct proc_dir_entry *proc_file;
-    struct task_struct *task;
-    struct aud_info_s aud_info;
-    /**/
-    unsigned int cur_width;
-    unsigned int cur_height;
-    unsigned int cur_frame_rate;
-    unsigned char it660x_enable;
-    unsigned char vdin_enable;
-    unsigned char vdin_started;
-    unsigned char task_pause;
-    unsigned char global_event;
-    /**/
-    unsigned int repeater_tx_event;
-    unsigned int state;
-}hdmirx_dev_t;
-
-
-static hdmirx_dev_t hdmirx_device;
-
-#if 1 //def SUPPORT_REPEATER
-
-static _CODE BYTE SampleKSVList[]=
-{
-	0x35,0x79,0x6A,0x17,0x2E,//Bksv0
-	0x47,0x8E,0x71,0xE2,0x0F,//Bksv1
-	0x74,0xE8,0x53,0x97,0xA6,//Bksv2
-	0x51,0x1E,0xF2,0x1A,0xCD,//BKSV3
-	0xE7,0x26,0x97,0xf4,0x01,//BKSV4
-};
-
-int DelayCounter = 0 ;
-USHORT bStatus = 0x0100 ;
-int DownStreamCount = 0 ;
-BYTE KSVList[15] ;
-#endif // SUPPORT_REPEATER
-
-
-static void start_vdin(int width, int height, int frame_rate, int field_flag);
-static void stop_vdin(void);
-/*****************************
-*    hdmirx attr management :
-******************************/
-
-static ssize_t show_enable(struct device * dev, struct device_attribute *attr, char * buf)
-{   
-    return sprintf(buf, "%d\n", hdmirx_device.vdin_enable);
-}
-    
-static ssize_t store_enable(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
-{
-    size_t r;
-    int val;
-    unsigned char vdin_enable;
-    r = sscanf(buf, "%d", &val);
-    if (r != 1) {
-        return -EINVAL;
-    }
-    vdin_enable = val&0xff;
-    hdmirx_device.global_event = (val>>8)&0xff;
-    if(vdin_enable != hdmirx_device.vdin_enable){
-        hdmirx_device.vdin_enable = vdin_enable; 
-        if(hdmirx_device.vdin_enable == 1){
-            //start_vdin(getHDMIRXHorzActive(), getHDMIRXVertActive(), 10000, IsHDMIRXInterlace());
-        }
-        else if(hdmirx_device.vdin_enable == 0){
-            //stop_vdin();
-        }  
-    }
-
-    return count;
-}
-
-
-static ssize_t show_poweron(struct device * dev, struct device_attribute *attr, char * buf)
-{   
-    return sprintf(buf, "%d\n", hdmirx_device.it660x_enable);
-}
-    
-static ssize_t store_poweron(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
-{
-    size_t r;
-    int val;
-    r = sscanf(buf, "%d", &val);
-    if (r != 1) {
-        return -EINVAL;
-    }
-    if(val != hdmirx_device.it660x_enable){
-        hdmirx_device.it660x_enable = val; 
-        if(hdmirx_device.vdin_enable == 1){
-        }
-        else if(hdmirx_device.it660x_enable == 0){
-        }  
-    }
-
-    return count;
-}
-
-#ifdef DEBUG_DVIN  
-int hs_pol_inv;           
-int vs_pol_inv;           
-int de_pol_inv;           
-int field_pol_inv;        
-int ext_field_sel;        
-int de_mode;              
-int data_comp_map;        
-int mode_422to444;        
-int dvin_clk_inv;         
-int vs_hs_tim_ctrl;       
-int hs_lead_vs_odd_min;   
-int hs_lead_vs_odd_max;   
-int active_start_pix_fe;  
-int active_start_pix_fo;  
-int active_start_line_fe; 
-int active_start_line_fo; 
-int line_width;           
-int field_height; 
-#endif       
-static ssize_t store_dbg(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
-{
-    char tmpbuf[128];
-    int i=0;
-    unsigned int adr;
-    unsigned int value=0;
-    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
-        tmpbuf[i]=buf[i];
-        i++;
-    }
-    tmpbuf[i]=0;
-    if(strncmp(tmpbuf, "config_dvin", 11)==0){
-#ifdef DEBUG_DVIN  
-        config_dvin (hs_pol_inv,          
-                  vs_pol_inv,          
-                  de_pol_inv,          
-                  field_pol_inv,       
-                  ext_field_sel,       
-                  de_mode,             
-                  data_comp_map,       
-                  mode_422to444,       
-                  dvin_clk_inv,        
-                  vs_hs_tim_ctrl,      
-                  hs_lead_vs_odd_min,  
-                  hs_lead_vs_odd_max,  
-                  active_start_pix_fe, 
-                  active_start_pix_fo, 
-                  active_start_line_fe,
-                  active_start_line_fo,
-                  line_width,          
-                  field_height);
-#endif       
-    }
-    else if(strncmp(tmpbuf, "pause", 5)==0){
-        hdmirx_device.task_pause = 1;
-        printk("Pause %s\n", __func__);
-    }
-    else if(strncmp(tmpbuf, "start", 5)==0){
-        hdmirx_device.task_pause = 0;
-        printk("Start %s\n", __func__);
-    }
-    else if(strncmp(tmpbuf, "spdif", 5)==0){
-        setHDMIRX_SPDIFOutput();
-    }
-    else if(strncmp(tmpbuf, "i2s", 3)==0){
-        setHDMIRX_I2SOutput(0x1);
-    }
-    else if(strncmp(tmpbuf, "hpd", 3)==0){
-        if(tmpbuf[3]=='0'){
-            CLEAR_HPD;
-        }
-        else if(tmpbuf[3]=='1'){
-            SET_HPD;
-        }
-    }
-    else if(tmpbuf[0]=='w'){
-        adr=simple_strtoul(tmpbuf+2, NULL, 16);
-        value=simple_strtoul(buf+i+1, NULL, 16);
-        if(buf[1]=='h'){
-            HDMIRX_WriteI2C_Byte(adr, value);
-        }
-        else if(buf[1]=='c'){
-            WRITE_MPEG_REG(adr, value);
-            pr_info("write %x to CBUS reg[%x]\n",value,adr);
-        }
-        else if(buf[1]=='p'){
-            WRITE_APB_REG(adr, value);
-            pr_info("write %x to APB reg[%x]\n",value,adr);
-        }
-    }
-    else if(tmpbuf[0]=='r'){
-        adr=simple_strtoul(tmpbuf+2, NULL, 16);
-        if(buf[1]=='h'){
-            value = HDMIRX_ReadI2C_Byte(adr);
-            pr_info("HDMI reg[%x]=%x\n", adr, value);
-        }
-        else if(buf[1]=='c'){
-            value = READ_MPEG_REG(adr);
-            pr_info("CBUS reg[%x]=%x\n", adr, value);
-        }
-        else if(buf[1]=='p'){
-            value = READ_APB_REG(adr);
-            pr_info("APB reg[%x]=%x\n", adr, value);
-        }
-    }
-
-    return 16;    
-}
-
-static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO, show_enable, store_enable);
-static DEVICE_ATTR(poweron, S_IWUSR | S_IRUGO, show_poweron, store_poweron);
-static DEVICE_ATTR(debug, S_IRWXUGO, NULL, store_dbg);
-
-/******************************
-*  hdmirx kernel task
-*******************************/
-#define DUMP_TIME 20
-
-#define PAD_GPIOD_4  99
-#define PAD_GPIOD_6  101
-
-BOOL ReadRXIntPin(void);
-
-void InitHDMIRX(BOOL bFullInit);
-BOOL CheckHDMIRX(void);
-void Initial8051Timer1(void);
-void InitUrt(void);
-int dump_vidmode(void);
-int dump_audSts(void);
-void dump_InfoFrame(void);
-/////////////////////////////////////////////////////
-// Global Data
-/////////////////////////////////////////////////////
-int xCntSum, xCntCnt ;
-
-BOOL ReadRXIntPin(void)
-{
-#if 0	
-	bit i;
-
-	i=P3_2;
-	if(i==0)return TRUE;
-	else return FALSE;
-#endif
-   return TRUE;
-}
-
-void MCU_init(void)
-{
-    ENABLE_HPD_MUX; // HPD
-    CLEAR_HPD; 
-    //ENABLE_SYSRSTN_MUX; // SYSRSTN, low to reset
-    //RESET_SYSRSTN; //low to reset
-}
-
-void HoldSystem(void)
-{
-  while(!hdmirx_device.it660x_enable){
-    msleep(10);
-	}
-}
-
-BOOL RXHPD_ENABLE=TRUE ;
-ULONG HPDOff_TickCount ;
-#define HPDOFF_MIN_PERIOD 2000
-
-// PIN89 (SYSRSTN): GPIOD_6
-
-USHORT CalTimer(ULONG SetupCnt)
-{
-    ULONG ucTickCount = jiffies * 1000 / HZ;
-    if(SetupCnt>ucTickCount)
-    {
-        return (0xffff-(SetupCnt-ucTickCount));
-    }
-    else
-    {
-        return (ucTickCount-SetupCnt);
-    }
-}
-
-void hdmirx_set_hpd()
-{
-    if( RXHPD_ENABLE == FALSE )
-    {
-        while(CalTimer(HPDOff_TickCount)<HPDOFF_MIN_PERIOD)
-        {
-            msleep(100);
-            //HDMIRX_DEBUG_PRINTF(("HPDOff_TickCount = %d, ucTickCount = %d\r",HPDOff_TickCount,ucTickCount)) ;
-        }
-        //HDMIRX_DEBUG_PRINTF(("\n")) ;
-
-    	Turn_HDMIRX(ON) ;
-        SET_HPD; //RX_HPD = HIGH ; // GPIOD_4    
-        RXHPD_ENABLE = TRUE ;
-    }
-}
-
-void hdmirx_clear_hpd()
-{
-    if( RXHPD_ENABLE == TRUE )
-    {
-      HPDOff_TickCount = jiffies * 1000 / HZ  ;
-    	Turn_HDMIRX(OFF) ;
-        CLEAR_HPD; //RX_HPD = LOW ;// GPIOD_4    
-        RXHPD_ENABLE = FALSE ;
-    }
-}
-
-static void update_status(unsigned char clear)
-{
-    static int xcntcnt, xcntsum;
-    if(clear){
-        is_hdmi_mode = 0;
-        horz_active = 0;
-        vert_active = 0;
-        is_interlace = 0;
-        vfreq = 0;
-        
-        audio_status = 0;
-        audio_sample_freq = 0;
-        audio_channel_alloc = 0;
-        xcntcnt = 0;
-        xcntsum = 0;
-    }
-    else{
-        ULONG PCLK, HFreq;
-        unsigned char sample_freq_idx, valid_ch;
-        is_hdmi_mode = IsHDMIRXHDMIMode();
-        horz_active = getHDMIRXHorzActive();
-        vert_active = getHDMIRXVertActive();
-        is_interlace = IsHDMIRXInterlace();
-
-        xcntcnt ++ ;
-        xcntsum += getHDMIRXxCnt() ;
-        if( xcntcnt > 40 )
-        {
-            xcntcnt /= 2 ;
-            xcntsum /= 2 ;
-        }
-        PCLK = 27000L * 128;
-        PCLK *= (ULONG) xcntcnt ;
-        PCLK /= (ULONG) xcntsum ;
-        PCLK *= 1000L ; // 100*PCLK ;
-
-        HFreq = PCLK / (ULONG)getHDMIRXHorzTotal() ; // HFreq
-        vfreq = (HFreq*100) / (ULONG)getHDMIRXVertTotal() ; // VFreq * 100
-
-        if(is_hdmi_mode!=0){
-            audio_status = getHDMIRXAudioStatus();
-            getHDMIRXAudioInfo(&sample_freq_idx, &valid_ch);
-            audio_channel_alloc = valid_ch;
-            switch(sample_freq_idx){
-                case 0x0:
-                    audio_sample_freq = 44100;
-                    break;
-                case 0x2:
-                    audio_sample_freq = 48000;
-                    break;
-                case 0x3:
-                    audio_sample_freq = 32000;
-                    break;
-                case 0x8:
-                    audio_sample_freq = 88200;
-                    break;
-                case 0xa:
-                    audio_sample_freq = 96000;
-                    break;
-                case 0xc:
-                    audio_sample_freq = 176400;
-                    break;
-                case 0xe:
-                    audio_sample_freq = 192000;
-                    break;
-                case 0x9:    
-                    printk("smaple freq for HBR\n");
-                    audio_sample_freq = 768000;
-                    break;                        
-            }
-            if((audio_sample_freq != hdmirx_device.aud_info.real_sample_rate)||
-                (hdmirx_device.global_event&0x1)){
-                hdmirx_device.aud_info.real_sample_rate = audio_sample_freq;                    
-#ifdef CONFIG_AML_AUDIO_DSP
-                if(hdmirx_device.vdin_started){
-                    mailbox_send_audiodsp(1, M2B_IRQ0_DSP_AUDIO_EFFECT, DSP_CMD_SET_HDMI_SR, (char *)&hdmirx_device.aud_info.real_sample_rate,sizeof(hdmirx_device.aud_info.real_sample_rate));
-                    hdmirx_device.global_event&=(~0x1);
-                    printk("[IT660x]%s: mailbox_send_audiodsp %d\n",__func__, hdmirx_device.aud_info.real_sample_rate);
-                }
-#endif
-            }
-        }
-        else{
-            audio_status = 0;
-            audio_sample_freq = 0;
-            audio_channel_alloc = 0;
-        }
-    }    
-}    
-
-
-#if 1
-#define HDMI_TX_STATE_HPD                       0
-#define HDMI_TX_STATE_HDCP_AUTH                 1
-#define HDMI_TX_STATE_HDCP_CMD_DONE             2
-unsigned char get_hdmi_tx_state(unsigned char type);
-
-#define HDMI_TX_HDCP_MODE_NONE_REPEATER     0
-#define HDMI_TX_HDCP_MODE_REPEATER          1
-void hdmi_repeater_set_hdcp_mode(unsigned char mode);
-
-void hdmi_repeater_enable_hdcp(unsigned char enable);
-
-void hdmi_hdcp_get_bksv(char* buf, int endian);
-
-
-void tx_event(unsigned int event, void* arg)
-{
-    if(event != 0){
-        hdmirx_device.repeater_tx_event = event;
-    }
-}    
-
-static int 
-hdmi_task_handle(void *data) 
-{
-
-    int repeater = 0;
-    int stable_count = 0;
-    static BOOL bSignal ;
-    BOOL bOldSignal, bChangeMode ;
-    int i;
-    int pre_state;
-
-
-    MCU_init() ;
-    
-    HoldSystem();
-    
-  	hdmirx_clear_hpd();
-
-    update_status(1);
-    printk("\n%s\n" , VERSION_STRING);
-    while(1){
-        if(hdmirx_device.task_pause){
-            continue;
-        }
-
-        if((hdmirx_device.state == HDMIRX_STATE_HPD_HIGH)||
-            (hdmirx_device.state == HDMIRX_STATE_STABLE) ||
-            (hdmirx_device.state == HDMIRX_STATE_READY)){
-            if(ReadRXIntPin())
-            {
-                Check_HDMInterrupt();
-            }
-            bOldSignal = bSignal ;
-            bSignal = CheckHDMIRX();
-            bChangeMode = (bSignal != bOldSignal);
-        }
-        
-        pre_state = hdmirx_device.state;
-        switch(hdmirx_device.state){
-            case HDMIRX_STATE_POWEROFF:
-                if(hdmirx_device.it660x_enable){
-                    repeater=repeater_enable ;
-    	              if( repeater ){
-                        hdmi_repeater_set_hdcp_mode(HDMI_TX_HDCP_MODE_REPEATER);
-                        RxHDCPSetRepeater();
-                    }
-                    else{
-                        hdmi_repeater_set_hdcp_mode(HDMI_TX_HDCP_MODE_NONE_REPEATER);
-                        RxHDCPSetReceiver();
-                    }
-                    hdmirx_device.state = HDMIRX_STATE_POWERON;    
-                }
-                
-                break;
-            case HDMIRX_STATE_POWERON:
-                if(hdmirx_device.it660x_enable == 0){
-                  	hdmirx_clear_hpd();
-                    PowerDownHDMI();
-                    hdmirx_device.state = HDMIRX_STATE_POWEROFF;    
-                }
-               	else{
-               	    if((!repeater)||(get_hdmi_tx_state(HDMI_TX_STATE_HPD)==1)){
-               	        hdmirx_set_hpd();
-                        hdmirx_device.state = HDMIRX_STATE_HPD_HIGH;    
-                    }
-                }
-                break;
-            case HDMIRX_STATE_HPD_HIGH:
-                if(hdmirx_device.it660x_enable == 0){
-                  	hdmirx_clear_hpd();
-                    PowerDownHDMI();
-                    hdmirx_device.state = HDMIRX_STATE_POWEROFF;    
-                }
-                else if(bSignal){
-                    stable_count = 0;
-                    hdmirx_device.state = HDMIRX_STATE_STABLE;    
-                }
-                break;
-            case HDMIRX_STATE_STABLE:
-                if(hdmirx_device.it660x_enable == 0){
-                  	hdmirx_clear_hpd();
-                    PowerDownHDMI();
-                    update_status(1);
-                    hdmirx_device.state = HDMIRX_STATE_POWEROFF;    
-                }
-                else if(!bSignal){
-                    update_status(1);
-                    hdmirx_device.state = HDMIRX_STATE_HPD_HIGH;    
-                }
-                else{
-                    update_status(0);
-                    if(bChangeMode){
-                        stable_count = 0;
-                    }
-                    if(stable_count<stable_threshold){
-                        stable_count++;
-                    }
-                    if((stable_count == stable_threshold)&&(hdmirx_device.vdin_enable)){
-                        start_vdin(getHDMIRXHorzActive(), getHDMIRXVertActive(), 10000, IsHDMIRXInterlace());
-                        hdmirx_device.state = HDMIRX_STATE_READY;    
-                    }
-                }
-
-                break;
-            case HDMIRX_STATE_READY:
-                if(hdmirx_device.it660x_enable == 0){
-                    stop_vdin();
-                  	hdmirx_clear_hpd();
-                    PowerDownHDMI();
-                    update_status(1);
-                    hdmirx_device.state = HDMIRX_STATE_POWEROFF;    
-                }
-                else if(repeater&&get_hdmi_tx_state(HDMI_TX_STATE_HPD)==0){
-               	    hdmirx_clear_hpd();
-                    hdmirx_device.state = HDMIRX_STATE_POWERON;    
-                }
-                else if((!bSignal)||bChangeMode){
-                    stop_vdin();
-                    update_status(1);
-                    hdmirx_device.state = HDMIRX_STATE_HPD_HIGH;    
-                }
-                else if(hdmirx_device.vdin_enable == 0){
-                    stop_vdin();
-                    hdmirx_device.state = HDMIRX_STATE_STABLE;    
-                }
-                else{
-                    update_status(0);
-                }
-                break;
-        }
-        
-        if(pre_state != hdmirx_device.state){
-            printk("[HDMIRX State] %s -> %s\n", state_name[pre_state], state_name[hdmirx_device.state]);
-        }
-        bChangeMode = FALSE ; // clear bChange Mode action
-
-        /* HDCP */
-        if(repeater&&
-            ((hdmirx_device.state == HDMIRX_STATE_HPD_HIGH)||
-            (hdmirx_device.state == HDMIRX_STATE_STABLE) ||
-            (hdmirx_device.state == HDMIRX_STATE_READY))){
-            static int pre_tx_auth = 0;
-            if(IsRxAuthStart())
-            {
-                printk("[HDMIRX HDCP] RX auth start\n");
-                hdmi_repeater_enable_hdcp(0);
-                while(!get_hdmi_tx_state(HDMI_TX_STATE_HDCP_CMD_DONE)){
-                    msleep(10);
-                }
-                hdmi_repeater_enable_hdcp(1);
-            }
-            
-            if(get_hdmi_tx_state(HDMI_TX_STATE_HDCP_AUTH) == 1){
-                if(pre_tx_auth == 0)
-                    printk("[HDMIRX HDCP] TX authenticated\n");
-                pre_tx_auth = 1;
-                if(IsRxAuthDone())
-                {
-                    printk("[HDMIRX HDCP] RX auth done\n");
-                    char bksv_buf[5];
-                    /* to do, read b-ksv list */    
-
-                    hdmi_hdcp_get_bksv(bksv_buf, 0);
-                    printk("BKSV: ");
-                    for(i = 0;i < 5; i++) {
-                        printk("%02x", bksv_buf[i]);
-                        KSVList[i] = bksv_buf[i];
-                    }
-                    printk("  \r\n");
-                    DownStreamCount = 1;
-
-                    if(test_flag&1){
-                        DownStreamCount = 3;
-                        for(i = 0 ; i < 5*DownStreamCount ; i++)
-                        {
-                            KSVList[i] = SampleKSVList[i] ;
-                            printk("%0x\n", SampleKSVList[i]);
-                        }
-                    }
-                    setRxHDCPKSVList(0,KSVList,DownStreamCount);
-                    if( DownStreamCount > 0 ){
-                        bStatus=DownStreamCount|0x0100 ;
-                    }
-                    else{
-                        bStatus=0;
-                    }
-                    setRxHDCPBStatus(bStatus);
-                    setRxHDCPCalcSHA();
-                }
-            }
-            else{
-                if(pre_tx_auth == 1)
-                    printk("[HDMIRX HDCP] TX none auth\n");
-                pre_tx_auth = 0;
-            }
-        }
-        /*HDCP end*/
-        msleep(10);
-
-    } 
-}    
-
-
-#else
-static int 
-hdmi_task_handle(void *data) 
-{
-
-    int repeater = 0;
-    int stable_count = 0;
-    static BOOL bSignal ;
-    BOOL bOldSignal, bChangeMode ;
-    int i;
-
-    int dump_count = 0 ;
-
-    MCU_init() ;
-
-	printk("\n%s\n" , VERSION_STRING);
-  while(1){
-    	HoldSystem();
-    	hdmirx_clear_hpd();
-    	#ifdef _COPY_EDID_
-    	CopyDefaultEDID() ;
-    	#endif
-    
-      repeater=repeater_enable ;
-    #if 0
-        GetCurrentHDMIPort();
-        SelectHDMIPort(CAT_HDMI_PORTA);
-    #endif    
-    	// InitHDMIRX(FALSE);
-    	if( repeater )
-    	{
-    	    DownStreamCount = 3 ;
-        	RxHDCPSetRepeater();
-        }
-        else
-        {
-        	RxHDCPSetReceiver();
-        }
-    	hdmirx_set_hpd();
-    
-      while(hdmirx_device.it660x_enable){
-            while(hdmirx_device.task_pause){
-                msleep(10);
-            }
-    
-            //HoldSystem();
-    
-    		if(ReadRXIntPin())
-    		{
-    	        Check_HDMInterrupt();
-    	    }
-    
-    	    //if(IsTimeOut(20))
-    	    //{
-    
-                dump_count ++ ;
-    		    bOldSignal = bSignal ;
-    		    bSignal = CheckHDMIRX();
-    		    bChangeMode = (bSignal != bOldSignal);
-    
-                if(bChangeMode)
-                {
-                    // if Changed Mode ...
-    
-        	        if(bSignal)
-        	        {
-                        stable_count = 0;
-                        update_status(0);
-        	            // if signal is TRUE , then ...
-                        dump_vidmode();
-                        if( IsHDMIRXHDMIMode() ) dump_InfoFrame() ;
-                        dump_audSts();
-    
-        	        }
-        	        else
-        	        {
-                        stable_count = 0;
-                        stop_vdin();
-                        update_status(1);
-        	            // if signal is FALSE , then ...
-                        xCntCnt = 0 ;
-                        xCntSum = 0 ;
-    
-        	        }
-    
-        			bChangeMode = FALSE ; // clear bChange Mode action
-                }
-                else
-                {
-                    // if not change mode, ...
-        	        if(bSignal)
-        	        {
-                      if(stable_count<stable_threshold){
-                        stable_count++;
-                        if(stable_count == stable_threshold){
-                            start_vdin(getHDMIRXHorzActive(), getHDMIRXVertActive(), 10000, IsHDMIRXInterlace());
-                        }
-                      }
-
-                      update_status(0);
-
-        	            // if signal is TRUE , then ...
-        	            if( (dump_count % 20) == 1 )
-        	            {
-                            xCntCnt ++ ;
-                            xCntSum += getHDMIRXxCnt() ;
-                            if( xCntCnt > 40 )
-                            {
-                                xCntCnt /= 2 ;
-                                xCntSum /= 2 ;
-                            }
-    
-        	            }
-        	        }
-        	        else
-        	        {
-                       stable_count = 0;
-                       stop_vdin();
-                       update_status(1);
-        	            
-        	            // if signal is FALSE , then ...
-                        xCntCnt = 0 ;
-                        xCntSum = 0 ;
-        	        }
-        	    }
-    
-    
-                if( dump_count > (DUMP_TIME*1000/20) )
-                {
-                    dump_count = 0 ;
-                    if( bSignal )
-                    {
-                        dump_vidmode();
-                        if( IsHDMIRXHDMIMode() ) dump_InfoFrame() ;
-                        dump_audSts();
-    
-                    }
-                    else
-                    {
-                        printk("Reg10 = %02X\nReg12 = %02X\nReg64 = %02X\nReg65 = %02X\n"
-                            ,(int)HDMIRX_ReadI2C_Byte(0x10)
-                            ,(int)HDMIRX_ReadI2C_Byte(0x12)
-                            ,(int)HDMIRX_ReadI2C_Byte(0x64)
-                            ,(int)HDMIRX_ReadI2C_Byte(0x65) ) ;
-                    }
-                    printk("\n\n");
-                    DumpHDMIRXReg();
-                }
-    
-                if( (dump_count % (1000/20)) == 0)
-                {
-                    if( repeater!=repeater_enable )
-                    {
-                        repeater=repeater_enable ;
-                    	hdmirx_clear_hpd();
-    
-    
-                    	if( repeater )
-                    	{
-                    	    if( DownStreamCount == 0 )
-                    	    {
-                    	        DownStreamCount = 5 ;
-                    	    }
-                    	    else
-                    	    {
-                    	        DownStreamCount -- ;
-                    	    }
-                    	    printk("Set Repeater Mode, DownStream  = %d\n",DownStreamCount) ;
-                        	RxHDCPSetRepeater();
-                        }
-                        else
-                        {
-                        	RxHDCPSetReceiver();
-                        }
-                    	hdmirx_set_hpd();
-                    }
-    
-                }
-    
-                if( repeater )
-                {
-            	    if(IsRxAuthStart())
-            	    {
-            	        DelayCounter = 0 ;
-            	    }
-    
-            	    if(IsRxAuthDone())
-            	    {
-            	        DelayCounter = DownStreamCount*2+1 ;
-            	    }
-    
-            	    if(DelayCounter > 0)
-            	    {
-            	        DelayCounter -- ;
-            	        if(DelayCounter == 0)
-            	        {
-            	            for(i = 0 ; i < 5*DownStreamCount ; i++)
-            	            {
-            	                KSVList[i] = SampleKSVList[i] ;
-            	            }
-            	            setRxHDCPKSVList(0,KSVList,DownStreamCount);
-            	            if( DownStreamCount > 0 )
-            	            {
-            	                bStatus=DownStreamCount|0x0100 ;
-            	            }
-            	            else
-            	            {
-            	                bStatus=0;
-            	            }
-            	            setRxHDCPBStatus(bStatus);
-            	            setRxHDCPCalcSHA();
-    
-            	        }
-            	    }
-                }
-            //}//	if(IsTimeOut(20))
-            msleep(10);
-    
-        }
-        PowerDownHDMI();
-  }
-	return 0;
-}
-#endif
-
-int dump_vidmode(void)
-{
-    USHORT HActive, VActive ;
-    USHORT HTotal, VTotal ;
-    ULONG HFreq, VFreq ;
-    ULONG PCLK ;
-    if((it660x_debug_flag&0x1)==0){
-        return 0;
-    }
-    xCntCnt ++ ;
-    xCntSum += getHDMIRXxCnt() ;
-
-    HActive = getHDMIRXHorzActive() ;
-    VActive = getHDMIRXVertActive() ;
-    HTotal = getHDMIRXHorzTotal() ;
-    VTotal = getHDMIRXVertTotal() ;
-
-    PCLK = 27000L * 128;
-    PCLK *= (ULONG) xCntCnt ;
-    PCLK /= (ULONG) xCntSum ;
-    PCLK *= 1000L ; // 100*PCLK ;
-
-    HFreq = PCLK / (ULONG)HTotal ; // HFreq
-    VFreq = (HFreq*100) / (ULONG)VTotal ; // VFreq * 100
-
-
-	printk("\n========================================================================\n") ;
-	printk("%s mode\n",IsHDMIRXHDMIMode()?"HDMI":"DVI") ;
-    printk("Mode - %dx%d@",HActive,VActive);
-    printk("%ld.%02ldHz",VFreq/100,VFreq%100) ;
-    switch(getHDMIRXOutputColorDepth())
-    {
-    case 0x7: printk("@48bits") ; break ;
-    case 0x6: printk("@36bits") ; break ;
-    case 0x5: printk("@30bits") ; break ;
-    case 0x4: printk("@24bits") ; break ;
-    default: printk("@No def(24bits)") ; break ;
-    }
-    printk(", PCLK = %ld.%02ldMHz", PCLK/1000000, (PCLK/10000)%100) ;
-    PCLK = xCntSum ;
-    PCLK *= 100 ;
-    PCLK /= xCntCnt ;
-    PCLK -= (ULONG)(xCntSum / xCntCnt)*100 ;
-    printk(",xCnt= %d.%02ld\n", xCntSum/xCntCnt,PCLK) ;
-
-    printk("<%4dx%4d>,",HTotal,VTotal);
-
-    printk("H:(%d,%d,%d),"
-		,getHDMIRXHorzFrontPorch()
-	    ,getHDMIRXHorzSyncWidth()
-	    ,getHDMIRXHorzBackPorch());
-
-    printk("V:(%d,%d,%d), "
-		,getHDMIRXVertFrontPorch()
-	    ,getHDMIRXVertSyncWidth()
-	    ,getHDMIRXVertSyncBackPorch());
-
-    printk("VSyncToDE = %d\n",getHDMIRXVertSyncToDE());
-	printk("========================================================================\n") ;
-    printk("HDCP %s\n",IsHDCPOn()?"ON":"OFF") ;
-	printk("========================================================================\n") ;
-	return 0;
-}
-
-int dump_audSts(void)
-{
-    BYTE audio_status ;
-    if((it660x_debug_flag&0x1)==0){
-        return 0;
-    }
-
-	printk("\n========================================================================\n") ;
-    audio_status = getHDMIRXAudioStatus() ;
-    if( (audio_status & T_AUDIO_MASK)!=T_AUDIO_OFF )
-    {
-        BYTE ch[5] ;
-        if( audio_status == T_AUDIO_HBR )
-        {
-            printk("Audio input is HBR (High Bit Rate) audio.\n") ;
-        }
-        else if( audio_status == T_AUDIO_DSD )
-        {
-            printk("Audio input is DSD (One Bit Audio) audio.\n") ;
-        }
-        else
-        {
-            if( audio_status & T_AUDIO_NLPCM )
-            {
-                printk("Audio input is IEC 61937 compressed audio.\n") ;
-            }
-            else
-            {
-                printk("Audio input is IEC 60958 linear PCM audio.\n") ;
-            }
-
-
-            printk("layout %d, ",(audio_status & F_AUDIO_LAYOUT_1)?1:0) ;
-            printk("%d source\n", (USHORT)audio_status & 7) ;
-
-            getHDMIRXAudioChannelStatus(ch) ;
-            printk("Channel Status: %02X %02X %02X %02X %02X\n",(int)ch[0],(int)ch[1],(int)ch[2],(int)ch[3],(int)ch[4]) ;
-
-
-        }
-    }
-    else
-    {
-        printk("No Audio.\n") ;
-    }
-	printk("========================================================================\n") ;
-	return 0;
-}
-
-void
-dump_InfoFrame(void)
-{
-    BYTE INFOFRAME[31] ;
-    int i ;
-    if((it660x_debug_flag&0x1)==0){
-        return 0;
-    }
-
-
-    if( GetAVIInfoFrame(INFOFRAME) )
-    {
-        printk("GetAVIInfoFrame():") ;
-        for( i = 0 ; i <= (3+(INFOFRAME[2] & 0x1F)) ; i++ )
-        {
-            printk(" %02X",(int)INFOFRAME[i]) ;
-        }
-        printk("\n") ;
-    }
-    else
-    {
-        printk("Cannot get AVI Infoframe()\n") ;
-    }
-
-    if( GetAudioInfoFrame(INFOFRAME) )
-    {
-        printk("GetAudioInfoFrame():") ;
-        for( i = 0 ; i <= (3+(INFOFRAME[2] & 0x1F)) ; i++ )
-        {
-            printk(" %02X",(int)INFOFRAME[i]) ;
-        }
-        printk("\n") ;
-    }
-    else
-    {
-        printk("Cannot get audio infoframe.\n") ;
-    }
-
-
-    if( GetVENDORSPECInfoFrame(INFOFRAME) )
-    {
-        printk("GetVENDORSPECInfoFrame():") ;
-        for( i = 0 ; i <= (3+(INFOFRAME[2] & 0x1F)) ; i++ )
-        {
-            printk(" %02X",(int)INFOFRAME[i]) ;
-        }
-        printk("\n") ;
-    }
-    else
-    {
-        printk("Cannot GetVENDORSPECInfoFrame()\n") ;
-    }
-}
-
-static void stop_vdin(void)
-{
-    if(hdmirx_device.vdin_started){
-        stop_tvin_service(0);
-        set_invert_top_bot(false);
-        hdmirx_device.vdin_started=0;
-        printk("%s: stop vdin\n", __func__);
-    }
-}
-
-static void start_vdin(int width, int height, int frame_rate, int field_flag)
-{
-#ifdef USE_TVIN_CAMERA
-    tvin_parm_t para;
-#else
-    vdin_parm_t para;
-#endif    
-    if(hdmirx_device.vdin_enable == 0){
-        return;
-    }    
-    if(hdmirx_device.vdin_started){
-        if(hdmirx_device.cur_width != width ||
-                hdmirx_device.cur_height != height ||
-                hdmirx_device.cur_frame_rate != frame_rate){
-            stop_tvin_service(0);
-            hdmirx_device.vdin_started=0;
-            printk("%s: stop vdin\n", __func__);
-        }
-    }
-    
-    if(hdmirx_device.vdin_started==0 && width>0 && height>0 && frame_rate >0){
-        hdmirx_device.cur_width = width;
-        hdmirx_device.cur_height = height;
-        hdmirx_device.cur_frame_rate = frame_rate;
-        
-        if(field_flag && height <= 480 ){
-            config_dvin(0, //hs_pol_inv,          
-                      1, //vs_pol_inv,          
-                      0, //de_pol_inv,          
-                      0, //field_pol_inv,       
-                      0, //ext_field_sel,       
-                      3, //de_mode,             
-                      0, //data_comp_map,       
-                      0, //mode_422to444,       
-                      0, //dvin_clk_inv,        
-                      0, //vs_hs_tim_ctrl,      
-                      400, //hs_lead_vs_odd_min,  
-                      1200, //hs_lead_vs_odd_max,  
-                      getHDMIRXHorzBackPorch(),//0xdc, //active_start_pix_fe, 
-                      getHDMIRXHorzBackPorch(),//0xdc, //active_start_pix_fo, 
-                      getHDMIRXVertSyncBackPorch(), //0x19, //active_start_line_fe,
-                      getHDMIRXVertSyncBackPorch(),//0x19, //active_start_line_fo,
-                      getHDMIRXHorzTotal(), //0x672, //line_width,          
-                      getHDMIRXVertTotal() //0x2ee //field_height
-                      );       
-        }
-        else{
-            config_dvin(0, //hs_pol_inv,          
-                      height>480?0:1, //vs_pol_inv,          
-                      0, //de_pol_inv,          
-                      (field_flag && height>=540)?1:0, //field_pol_inv, set to 1 for 1080i
-                      0, //ext_field_sel,       
-                      3, //de_mode,             
-                      0, //data_comp_map,       
-                      0, //mode_422to444,       
-                      0, //dvin_clk_inv,        
-                      0, //vs_hs_tim_ctrl,      
-                      0, //hs_lead_vs_odd_min,  
-                      0, //hs_lead_vs_odd_max,  
-                      getHDMIRXHorzBackPorch(),//0xdc, //active_start_pix_fe, 
-                      getHDMIRXHorzBackPorch(),//0xdc, //active_start_pix_fo, 
-                      getHDMIRXVertSyncBackPorch(), //0x19, //active_start_line_fe,
-                      getHDMIRXVertSyncBackPorch(),//0x19, //active_start_line_fo,
-                      getHDMIRXHorzTotal(), //0x672, //line_width,          
-                      getHDMIRXVertTotal() //0x2ee //field_height
-                      );       
-        }        
-#ifdef USE_TVIN_CAMERA
-        para.fmt_info.h_active = hdmirx_device.cur_width;
-        para.fmt_info.v_active = hdmirx_device.cur_height;
-        para.port  = TVIN_PORT_DVIN0;
-        if(field_flag){
-            para.fmt_info.v_active <<= 1;
-            //if(height == 1080){
-                para.fmt_info.fmt = TVIN_SIG_FMT_HDMI_1920x1080I_60Hz;
-            //}
-            //else{
-            //    para.fmt_info.fmt = TVIN_SIG_FMT_HDMI_1440x480I_60Hz;
-            //}
-        }
-        else{
-            para.fmt_info.fmt = TVIN_SIG_FMT_MAX+1;//TVIN_SIG_FMT_MAX+1;TVIN_SIG_FMT_CAMERA_1280X720P_30Hz
-        }
-        para.fmt_info.frame_rate = frame_rate;
-        para.fmt_info.hsync_phase = 1;
-      	para.fmt_info.vsync_phase  = 0;	
-#else
-        memset( &para, 0, sizeof(para));
-        para.port  = TVIN_PORT_DVIN0;
-        para.frame_rate = frame_rate;
-        para.h_active = hdmirx_device.cur_width;
-        para.v_active = hdmirx_device.cur_height;
-        if(field_flag){
-            if(hdmirx_device.cur_width == 1920 &&  (hdmirx_device.cur_height == 1080 || hdmirx_device.cur_height == 540)){
-                para.fmt = TVIN_SIG_FMT_HDMI_1920X1080I_60HZ;
-                para.v_active = 1080;
-            }
-            /*
-            else if( hdmirx_device.cur_width == 720 &&  (hdmirx_device.cur_height == 576 || hdmirx_device.cur_height == 288)){
-                para.fmt = TVIN_SIG_FMT_HDMI_720X576I_50HZ;
-                para.v_active = 576;
-                set_invert_top_bot(true);
-            }
-            else if(hdmirx_device.cur_width == 1440 &&  (hdmirx_device.cur_height == 576 || hdmirx_device.cur_height == 288)){
-                para.fmt = TVIN_SIG_FMT_HDMI_1440X576I_50HZ;
-                para.v_active = 576;
-                set_invert_top_bot(true);
-            }
-            else if( hdmirx_device.cur_width == 720 &&  (hdmirx_device.cur_height == 480 || hdmirx_device.cur_height == 240)){
-                para.fmt = TVIN_SIG_FMT_HDMI_720X480I_60HZ;
-                para.v_active = 480;
-                set_invert_top_bot(true);
-            }
-            else if(hdmirx_device.cur_width == 1440  &&  (hdmirx_device.cur_height == 480 || hdmirx_device.cur_height == 240)){
-                para.fmt = TVIN_SIG_FMT_HDMI_1440X480I_60HZ;
-                para.v_active = 480;
-                set_invert_top_bot(true);
-            }*/
-            else{
-                para.fmt = TVIN_SIG_FMT_MAX+1;
-                set_invert_top_bot(true);
-            }
-            para.scan_mode = TVIN_SCAN_MODE_INTERLACED;	
-        }
-        else{
-            if(hdmirx_device.cur_width == 1920 &&  hdmirx_device.cur_height == 1080){
-                para.fmt = TVIN_SIG_FMT_HDMI_1920X1080P_60HZ;
-            }
-            else if(hdmirx_device.cur_width == 1280 &&  hdmirx_device.cur_height == 720){
-                para.fmt = TVIN_SIG_FMT_HDMI_1280X720P_60HZ;
-            }
-            else if((hdmirx_device.cur_width == 1440 || hdmirx_device.cur_width == 720) &&  hdmirx_device.cur_height == 576){
-                para.fmt = TVIN_SIG_FMT_HDMI_720X576P_50HZ;
-            }
-            else if((hdmirx_device.cur_width == 1440 || hdmirx_device.cur_width == 720) &&  hdmirx_device.cur_height == 480){
-                para.fmt = TVIN_SIG_FMT_HDMI_720X480P_60HZ;
-            }
-            else{
-                para.fmt = TVIN_SIG_FMT_MAX+1;
-            }
-            para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-        }
-        para.hsync_phase = 1;
-        para.vsync_phase = 0;
-        //para.hs_bp = 0;
-        //para.vs_bp = 2;
-        para.cfmt = TVIN_RGB444;
-        para.reserved = 0; //skip_num
-
-#endif      	
-        start_tvin_service(0,&para);
-        hdmirx_device.vdin_started = 1;
-        
-        printk("%s: %dx%d %d/s\n", __func__, width, height, frame_rate);
-        
-        hdmirx_device.aud_info.real_sample_rate = audio_sample_freq;                    
-#ifdef CONFIG_AML_AUDIO_DSP
-        mailbox_send_audiodsp(1, M2B_IRQ0_DSP_AUDIO_EFFECT, DSP_CMD_SET_HDMI_SR, (char *)&hdmirx_device.aud_info.real_sample_rate,sizeof(hdmirx_device.aud_info.real_sample_rate));
-        printk("[IT660x]%s: mailbox_send_audiodsp %d\n",__func__, hdmirx_device.aud_info.real_sample_rate);
-#endif
-        
-    }
-}
-
-
-/*****************************
-*    hdmirx driver file_operations 
-*    
-******************************/
-static int it660x_hdmirx_open(struct inode *node, struct file *file)
-{
-    hdmirx_dev_t *hdmirx_in_devp;
-
-    /* Get the per-device structure that contains this cdev */
-    hdmirx_in_devp = container_of(node->i_cdev, hdmirx_dev_t, cdev);
-    file->private_data = hdmirx_in_devp;
-
-    return 0;
-
-}
-
-
-static int it660x_hdmirx_release(struct inode *node, struct file *file)
-{
-    //hdmirx_dev_t *hdmirx_in_devp = file->private_data;
-
-    /* Reset file pointer */
-
-    /* Release some other fields */
-    /* ... */
-    return 0;
-}
-
-
-
-static int it660x_hdmirx_ioctl(struct inode *node, struct file *file, unsigned int cmd,   unsigned long args)
-{
-    int   r = 0;
-    switch (cmd) {
-        default:
-            break;
-    }
-    return r;
-}
-
-const static struct file_operations it660x_hdmirx_fops = {
-    .owner    = THIS_MODULE,
-    .open     = it660x_hdmirx_open,
-    .release  = it660x_hdmirx_release,
-//    .ioctl    = it660x_hdmirx_ioctl,
-};
-
-int it660xin_init(void);
-int it660xin_remove(void);
-
-static int it660x_hdmirx_probe(struct platform_device *pdev)
-{
-    int r;
-    HDMI_DEBUG();
-    pr_dbg("it660x_hdmirx_probe\n");
-
-    //it660xin_init();
-
-
-
-    r = alloc_chrdev_region(&hdmirx_id, 0, HDMI_RX_COUNT, DEVICE_NAME);
-    if (r < 0) {
-        pr_error("Can't register major for it660x_hdmirx device\n");
-        return r;
-    }
-    hdmirx_class = class_create(THIS_MODULE, DEVICE_NAME);
-    if (IS_ERR(hdmirx_class))
-    {
-        unregister_chrdev_region(hdmirx_id, HDMI_RX_COUNT);
-        return -1;
-        //return PTR_ERR(aoe_class);
-    }
-
-    cdev_init(&(hdmirx_device.cdev), &it660x_hdmirx_fops);
-    hdmirx_device.cdev.owner = THIS_MODULE;
-    cdev_add(&(hdmirx_device.cdev), hdmirx_id, HDMI_RX_COUNT);
-
-    //hdmirx_dev = device_create(hdmirx_class, NULL, hdmirx_id, "it660x_hdmirx%d", 0);
-    hdmirx_dev = device_create(hdmirx_class, NULL, hdmirx_id, NULL, "it660x_hdmirx%d", 0); //kernel>=2.6.27 
-    device_create_file(hdmirx_dev, &dev_attr_enable);
-    device_create_file(hdmirx_dev, &dev_attr_poweron);
-    device_create_file(hdmirx_dev, &dev_attr_debug);
-    
-    if (hdmirx_dev == NULL) {
-        pr_error("device_create create error\n");
-        class_destroy(hdmirx_class);
-        r = -EEXIST;
-        return r;
-    }
-    hdmirx_device.task = kthread_run(hdmi_task_handle, &hdmirx_device, "kthread_hdmi");
-    
-	if (r < 0){
-		printk(KERN_ERR "hdmirx: register switch dev failed\n");
-		return r;
-	}    
-
-    return r;
-}
-
-static int it660x_hdmirx_remove(struct platform_device *pdev)
-{
-    kthread_stop(hdmirx_device.task);
-    
-    //it660xin_remove();
-    /* Remove the cdev */
-    device_remove_file(hdmirx_dev, &dev_attr_enable);
-    device_remove_file(hdmirx_dev, &dev_attr_poweron);
-    device_remove_file(hdmirx_dev, &dev_attr_debug);
-
-    cdev_del(&hdmirx_device.cdev);
-
-    device_destroy(hdmirx_class, hdmirx_id);
-
-    class_destroy(hdmirx_class);
-
-    unregister_chrdev_region(hdmirx_id, HDMI_RX_COUNT);
-    return 0;
-}
-
-#ifdef CONFIG_PM
-static int it660x_hdmirx_suspend(struct platform_device *pdev,pm_message_t state)
-{
-    pr_info("it660x_hdmirx: hdmirx_suspend\n");
-    return 0;
-}
-
-static int it660x_hdmirx_resume(struct platform_device *pdev)
-{
-    pr_info("it660x_hdmirx: resume module\n");
-    return 0;
-}
-
-static struct platform_driver it660x_hdmirx_driver = {
-    .probe      = it660x_hdmirx_probe,
-    .remove     = it660x_hdmirx_remove,
-#ifdef CONFIG_PM
-    .suspend    = it660x_hdmirx_suspend,
-    .resume     = it660x_hdmirx_resume,
-#endif
-    .driver     = {
-        .name   = DEVICE_NAME,
-		    .owner	= THIS_MODULE,
-    }
-};
-
-static struct platform_device* it660x_hdmirx_device = NULL;
-
-
-static int  __init it660x_hdmirx_init(void)
-{
-    pr_dbg("it660x_hdmirx_init\n");
-    memset(&hdmirx_device, 0, sizeof(hdmirx_device));
-	  it660x_hdmirx_device = platform_device_alloc(DEVICE_NAME,0);
-    if (!it660x_hdmirx_device) {
-        pr_error("failed to alloc it660x_hdmirx_device\n");
-        return -ENOMEM;
-    }
-    
-    if(platform_device_add(it660x_hdmirx_device)){
-        platform_device_put(it660x_hdmirx_device);
-        pr_error("failed to add it660x_hdmirx_device\n");
-        return -ENODEV;
-    }
-    if (platform_driver_register(&it660x_hdmirx_driver)) {
-        pr_error("failed to register it660x_hdmirx module\n");
-        
-        platform_device_del(it660x_hdmirx_device);
-        platform_device_put(it660x_hdmirx_device);
-        return -ENODEV;
-    }
-    return 0;
-}
-
-
-
-
-static void __exit it660x_hdmirx_exit(void)
-{
-    pr_dbg("it660x_hdmirx_exit\n");
-    platform_driver_unregister(&it660x_hdmirx_driver);
-    platform_device_unregister(it660x_hdmirx_device); 
-    it660x_hdmirx_device = NULL;
-    return ;
-}
-
-module_init(it660x_hdmirx_init);
-module_exit(it660x_hdmirx_exit);
-
-MODULE_PARM_DESC(it660x_debug_flag, "\n it660x_debug_flag \n");
-module_param(it660x_debug_flag, int, 0664);
-
-MODULE_PARM_DESC(stable_threshold, "\n stable_threshold \n");
-module_param(stable_threshold, int, 0664);
-
-MODULE_PARM_DESC(is_hdmi_mode, "\n is_hdmi_mode \n");
-module_param(is_hdmi_mode, int, 0664);
-
-MODULE_PARM_DESC(horz_active, "\n horz_active \n");
-module_param(horz_active, int, 0664);
-
-MODULE_PARM_DESC(vert_active, "\n vert_active \n");
-module_param(vert_active, int, 0664);
-
-MODULE_PARM_DESC(is_interlace, "\n is_interlace \n");
-module_param(is_interlace, int, 0664);
-
-MODULE_PARM_DESC(vfreq, "\n vfreq \n");
-module_param(vfreq, int, 0664);
-
-MODULE_PARM_DESC(audio_status, "\n audio_status \n");
-module_param(audio_status, int, 0664);
-
-MODULE_PARM_DESC(audio_sample_freq, "\n audio_sample_freq \n");
-module_param(audio_sample_freq, int, 0664);
-
-MODULE_PARM_DESC(audio_channel_alloc, "\n audio_channel_alloc \n");
-module_param(audio_channel_alloc, int, 0664);
-
-
-#ifdef DEBUG_DVIN  
-MODULE_PARM_DESC(hs_pol_inv, "\n hs_pol_inv \n");
-module_param(hs_pol_inv, int, 0664);
-
-MODULE_PARM_DESC(vs_pol_inv, "\n vs_pol_inv \n");
-module_param(vs_pol_inv, int, 0664);
-          
-MODULE_PARM_DESC(de_pol_inv, "\n de_pol_inv \n");
-module_param(de_pol_inv, int, 0664);
-
-MODULE_PARM_DESC(field_pol_inv, "\n field_pol_inv \n");
-module_param(field_pol_inv, int, 0664);
-
-MODULE_PARM_DESC(ext_field_sel, "\n ext_field_sel \n");
-module_param(ext_field_sel, int, 0664);
-           
-MODULE_PARM_DESC(de_mode, "\n de_mode \n");
-module_param(de_mode, int, 0664);
-      
-MODULE_PARM_DESC(data_comp_map, "\n data_comp_map \n");
-module_param(data_comp_map, int, 0664);
-       
-MODULE_PARM_DESC(mode_422to444, "\n mode_422to444 \n");
-module_param(mode_422to444, int, 0664);
-         
-MODULE_PARM_DESC(dvin_clk_inv, "\n dvin_clk_inv \n");
-module_param(dvin_clk_inv, int, 0664);
-      
-MODULE_PARM_DESC(vs_hs_tim_ctrl, "\n vs_hs_tim_ctrl \n");
-module_param(vs_hs_tim_ctrl, int, 0664);
-
-MODULE_PARM_DESC(hs_lead_vs_odd_min, "\n hs_lead_vs_odd_min \n");
-module_param(hs_lead_vs_odd_min, int, 0664);
-
-MODULE_PARM_DESC(hs_lead_vs_odd_max, "\n hs_lead_vs_odd_max \n");
-module_param(hs_lead_vs_odd_max, int, 0664);
-  
-MODULE_PARM_DESC(active_start_pix_fe, "\n active_start_pix_fe \n");
-module_param(active_start_pix_fe, int, 0664);
- 
-MODULE_PARM_DESC(active_start_pix_fo, "\n active_start_pix_fo \n");
-module_param(active_start_pix_fo, int, 0664);
-
-MODULE_PARM_DESC(active_start_line_fe, "\n active_start_line_fe \n");
-module_param(active_start_line_fe, int, 0664);
-
-MODULE_PARM_DESC(active_start_line_fo, "\n active_start_line_fo \n");
-module_param(active_start_line_fo, int, 0664);
-           
-MODULE_PARM_DESC(line_width, "\n line_width \n");
-module_param(line_width, int, 0664);
-      
-MODULE_PARM_DESC(field_height, "\n field_height \n");
-module_param(field_height, int, 0664);
-#endif
-
-MODULE_PARM_DESC(repeater_enable, "\n repeater_enable \n");
-module_param(repeater_enable, int, 0664);
-
-MODULE_PARM_DESC(test_flag, "\n test_flag \n");
-module_param(test_flag, int, 0664);
-
-MODULE_DESCRIPTION("IT660X HDMI RX driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0.0");
-
-
-#endif
diff --git a/drivers/amlogic/tvin/it660x/it660x_fe.c b/drivers/amlogic/tvin/it660x/it660x_fe.c
deleted file mode 100755
index 01f34f2dd66c..000000000000
--- a/drivers/amlogic/tvin/it660x/it660x_fe.c
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Amlogic M6
- * frame buffer driver  -------it660x input
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/dma-mapping.h>
-#include <linux/slab.h>
-#include <asm/delay.h>
-#include <asm/atomic.h>
-
-#include <linux/amports/amstream.h>
-#include <linux/amports/ptsserv.h>
-#include <linux/tvin/tvin_v4l2.h>
-#include <mach/am_regs.h>
-
-#include "../tvin_frontend.h"
-#include "dvin.h"
-
-#define DEVICE_NAME "t660xin"
-#define MODULE_NAME "it660xin"
-
-
-typedef struct it660xin_s{
-    unsigned char       fmt_check_cnt;
-    unsigned char       watch_dog;
-
-    unsigned        dec_status : 1;
-    unsigned        wrap_flag : 1;
-    /*add for tv frontend architecture*/
-    struct tvin_frontend_s frontend;
-    struct vdin_parm_s parm;
-
-}it660xin_t;
-
-static int it660xin_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        if(port == TVIN_PORT_DVIN0)
-                return 0;
-        else
-                return -1;
-}
-static void it660xin_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        it660xin_t *devp = container_of(fe,it660xin_t,frontend);
-        /*copy the vdin_parm_s to local device parameter*/
-        if(!memcpy(&devp->parm,fe->private_data,sizeof(vdin_parm_t))){
-                printk("[it660..]%s copy vdin parm error.\n",__func__);
-        }
-        /*do something init the it660 device*/
-        WRITE_MPEG_REG(PERIPHS_PIN_MUX_0, READ_MPEG_REG(PERIPHS_PIN_MUX_0)|
-                                        ((1 << 10)    | // pm_gpioA_lcd_in_de
-                                        (1 << 9)     | // pm_gpioA_lcd_in_vs
-                                        (1 << 8)     | // pm_gpioA_lcd_in_hs
-                                        (1 << 7)     | // pm_gpioA_lcd_in_clk
-                                        (1 << 6)));     // pm_gpioA_lcd_in
-
-        WRITE_MPEG_REG_BITS(VDIN_ASFIFO_CTRL2, 0x39, 2, 6); 
-
-}
-static void it660xin_close(struct tvin_frontend_s *fe)
-{
-        it660xin_t *devp = container_of(fe,it660xin_t,frontend);
-                
-}
-static void it660xin_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-        it660xin_t *devp = container_of(fe,it660xin_t,frontend);
-                
-}
-static void it660xin_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        it660xin_t *devp = container_of(fe,it660xin_t,frontend);
-                
-}
-static int it660xin_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
-{
-        it660xin_t *devp = container_of(fe,it660xin_t,frontend);
-                return 0;
-}
-
-static struct tvin_decoder_ops_s it660xin_dec_ops = {
-        .support = it660xin_support,
-        .open = it660xin_open,
-        .close = it660xin_close,
-        .start  = it660xin_start,
-        .stop  = it660xin_stop,
-        .decode_isr =it660xin_isr, 
-};
-
-static void it660xin_get_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-        it660xin_t *devp = container_of(fe,it660xin_t,frontend);
-        prop->color_format = TVIN_RGB444;
-        if(devp->parm.h_active >= 1440)
-        prop->pixel_repeat = 2;
-        else 
-               prop->pixel_repeat = 0;
-}
-static struct tvin_state_machine_ops_s it660xin_sm_ops = {
-        .get_sig_propery = it660xin_get_sig_propery,
-};
-static int it660xin_probe(struct platform_device *pdev)
-{
-    int ret = 0;
-    it660xin_t *it660_devp = kmalloc(sizeof(it660xin_t),GFP_KERNEL);
-    printk("[it660..] it660xin probe start.\n");
-    if(!it660_devp){
-        printk("[it660..] %s kmalloc error.\n",__func__);
-        return -ENOMEM;
-    }
-    memset(it660_devp,0,sizeof(it660xin_t));
-    /*init the it660xin frontend and register*/
-    if(tvin_frontend_init(&it660_devp->frontend,&it660xin_dec_ops,&it660xin_sm_ops,0))
-    {
-        printk("[it660..] %s init it660 frontend error.\n",__func__);
-        ret = -1;
-    }
-    if(tvin_reg_frontend(&it660_devp->frontend)){
-         printk("[it660..] %s register it660 frontend error.\n",__func__);
-        ret = -1;
-    }
-    platform_set_drvdata(pdev,it660_devp);
-    
-    printk("[it660..] it660xin probe end.\n");
-    return ret;
-}
-
-static int it660xin_remove(struct platform_device *pdev)
-{
-    it660xin_t *it660_devp = platform_get_drvdata(pdev);
-    /*unregister it660 frontend*/
-        tvin_unreg_frontend(&it660_devp->frontend);
-    return 0;
-}
-
-
-
-static struct platform_driver it660xin_driver = {
-    .probe      = it660xin_probe,
-    .remove     = it660xin_remove,
-    .driver     = {
-        .name   = DEVICE_NAME,
-    }
-};
-
-static struct platform_device* it660xin_device = NULL;
-
-static int __init it660xin_init_module(void)
-{
-    printk("it660xin module init\n");
-        it660xin_device = platform_device_alloc(DEVICE_NAME,0);
-    if (!it660xin_device) {
-        printk("failed to alloc it660xin_device\n");
-        return -ENOMEM;
-    }
-
-    if(platform_device_add(it660xin_device)){
-        platform_device_put(it660xin_device);
-        printk("failed to add it660xin_device\n");
-        return -ENODEV;
-    }
-    if (platform_driver_register(&it660xin_driver)) {
-        printk("failed to register it660xin driver\n");
-
-        platform_device_del(it660xin_device);
-        platform_device_put(it660xin_device);
-        return -ENODEV;
-    }
-    return 0;
-}
-
-static void __exit it660xin_exit_module(void)
-{
-    printk("it660xin module remove.\n");
-    platform_driver_unregister(&it660xin_driver);
-    return ;
-}
-
-module_init(it660xin_init_module);
-module_exit(it660xin_exit_module);
-
-
-void config_dvin (unsigned long hs_pol_inv,             // Invert HS polarity, for HW regards HS active high.
-                  unsigned long vs_pol_inv,             // Invert VS polarity, for HW regards VS active high.
-                  unsigned long de_pol_inv,             // Invert DE polarity, for HW regards DE active high.
-                  unsigned long field_pol_inv,          // Invert FIELD polarity, for HW regards odd field when high.
-                  unsigned long ext_field_sel,          // FIELD source select:
-                                                        // 1=Use external FIELD signal, ignore internal FIELD detection result;
-                                                        // 0=Use internal FIELD detection result, ignore external input FIELD signal.
-                  unsigned long de_mode,                // DE mode control:
-                                                        // 0=Ignore input DE signal, use internal detection to to determine active pixel;
-                                                        // 1=Rsrv;
-                                                        // 2=During internal detected active region, if input DE goes low, replace input data with the last good data;
-                                                        // 3=Active region is determined by input DE, no internal detection.
-                  unsigned long data_comp_map,          // Map input data to form YCbCr.
-                                                        // Use 0 if input is YCbCr;
-                                                        // Use 1 if input is YCrCb;
-                                                        // Use 2 if input is CbCrY;
-                                                        // Use 3 if input is CbYCr;
-                                                        // Use 4 if input is CrYCb;
-                                                        // Use 5 if input is CrCbY;
-                                                        // 6,7=Rsrv.
-                  unsigned long mode_422to444,          // 422 to 444 conversion control:
-                                                        // 0=No convertion; 1=Rsrv;
-                                                        // 2=Convert 422 to 444, use previous C value;
-                                                        // 3=Convert 422 to 444, use average C value.
-                  unsigned long dvin_clk_inv,           // Invert dvin_clk_in for ease of data capture.
-                  unsigned long vs_hs_tim_ctrl,         // Controls which edge of HS/VS (post polarity control) the active pixel/line is related:
-                                                        // Bit 0: HS and active pixel relation.
-                                                        //  0=Start of active pixel is counted from the rising edge of HS;
-                                                        //  1=Start of active pixel is counted from the falling edge of HS;
-                                                        // Bit 1: VS and active line relation.
-                                                        //  0=Start of active line is counted from the rising edge of VS;
-                                                        //  1=Start of active line is counted from the falling edge of VS.
-                  unsigned long hs_lead_vs_odd_min,     // For internal FIELD detection:
-                                                        // Minimum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
-                  unsigned long hs_lead_vs_odd_max,     // For internal FIELD detection:
-                                                        // Maximum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
-                  unsigned long active_start_pix_fe,    // Number of clock cycles between HS active edge to first active pixel, in even field.
-                  unsigned long active_start_pix_fo,    // Number of clock cycles between HS active edge to first active pixel, in odd field.
-                  unsigned long active_start_line_fe,   // Number of clock cycles between VS active edge to first active line, in even field.
-                  unsigned long active_start_line_fo,   // Number of clock cycles between VS active edge to first active line, in odd field.
-                  unsigned long line_width,             // Number_of_pixels_per_line
-                  unsigned long field_height)           // Number_of_lines_per_field
-{
-    unsigned long data32;
-
-    printk("[it660..]%s: %lu %lu %lu %lu.\n",  __func__, active_start_pix_fe, active_start_line_fe,  line_width, field_height);  
-    // Program reg DVIN_CTRL_STAT: disable DVIN
-    WRITE_MPEG_REG(DVIN_CTRL_STAT, 0);
-
-    // Program reg DVIN_FRONT_END_CTRL
-    data32 = 0;
-    data32 |= (hs_pol_inv       & 0x1)  << 0;
-    data32 |= (vs_pol_inv       & 0x1)  << 1;
-    data32 |= (de_pol_inv       & 0x1)  << 2;
-    data32 |= (field_pol_inv    & 0x1)  << 3;
-    data32 |= (ext_field_sel    & 0x1)  << 4;
-    data32 |= (de_mode          & 0x3)  << 5;
-    data32 |= (mode_422to444    & 0x3)  << 7;
-    data32 |= (dvin_clk_inv     & 0x1)  << 9;
-    data32 |= (vs_hs_tim_ctrl   & 0x3)  << 10;
-    WRITE_MPEG_REG(DVIN_FRONT_END_CTRL, data32);
-    
-    // Program reg DVIN_HS_LEAD_VS_ODD
-    data32 = 0;
-    data32 |= (hs_lead_vs_odd_min & 0xfff) << 0;
-    data32 |= (hs_lead_vs_odd_max & 0xfff) << 16;
-    WRITE_MPEG_REG(DVIN_HS_LEAD_VS_ODD, data32);
-
-    // Program reg DVIN_ACTIVE_START_PIX
-    data32 = 0;
-    data32 |= (active_start_pix_fe & 0xfff) << 0;
-    data32 |= (active_start_pix_fo & 0xfff) << 16;
-    WRITE_MPEG_REG(DVIN_ACTIVE_START_PIX, data32);
-    
-    // Program reg DVIN_ACTIVE_START_LINE
-    data32 = 0;
-    data32 |= (active_start_line_fe & 0xfff) << 0;
-    data32 |= (active_start_line_fo & 0xfff) << 16;
-    WRITE_MPEG_REG(DVIN_ACTIVE_START_LINE, data32);
-    
-    // Program reg DVIN_DISPLAY_SIZE
-    data32 = 0;
-    data32 |= ((line_width-1)   & 0xfff) << 0;
-    data32 |= ((field_height-1) & 0xfff) << 16;
-    WRITE_MPEG_REG(DVIN_DISPLAY_SIZE, data32);
-    
-    // Program reg DVIN_CTRL_STAT, and enable DVIN
-    data32 = 0;
-    data32 |= 1                     << 0;
-    data32 |= (data_comp_map & 0x7) << 1;
-    WRITE_MPEG_REG(DVIN_CTRL_STAT, data32);
-} /* config_dvin */
-
-
-
diff --git a/drivers/amlogic/tvin/it660x/it660x_i2c.c b/drivers/amlogic/tvin/it660x/it660x_i2c.c
deleted file mode 100755
index 83ff3cf9420e..000000000000
--- a/drivers/amlogic/tvin/it660x/it660x_i2c.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * IT660X I2C device driver
- *
- * Author: Y.S. Zhang <rain.zhang@amlogic.com>
- *
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-/* Standard Liniux Headers */
-#include <linux/module.h>
-#include <linux/i2c.h>
-
-/* Amlogic Headers */
-#include <linux/tvin/tvin.h>
-
-/* Local Headers */
-#include "typedef.h"
-
-#define IT660X_I2C_NAME         "it660x_i2c"
-
-#define HDMIRXADR       (0x90>>1)
-#define I2C_TRY_MAX_CNT 3
-
-extern int it660x_debug_flag;
-static struct i2c_client *it660x_i2c_client = NULL;
-
-BYTE HDMIRX_ReadI2C_Byte(BYTE RegAddr)
-{
-    BYTE uc ;
-    int  i2c_flag = -1;
-    int i = 0;
-    unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
-    unsigned char offset = RegAddr;
-    struct i2c_msg msg[] = {
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= 0,    
-			.len	= 1,
-			.buf	= &offset,
-		},
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= I2C_M_RD,    
-			.len	= 1,
-			.buf	= &uc,
-		}
-
-	};
-
-repeat:
-	i2c_flag = i2c_transfer(it660x_i2c_client->adapter, msg, 2);
-    if (i2c_flag < 0) {
-        pr_err("error in read it660x_i2c, %d byte(s) should be read,. \n", 1);
-        if (i++ < i2c_try_cnt)
-            goto repeat;
-        return 0xff;
-    }
-
-    if(it660x_debug_flag&0x2){
-        printk("[%s] %x: %x\n", __func__, RegAddr, uc);
-    }
-    return uc ;
-}
-
-SYS_STATUS HDMIRX_WriteI2C_Byte(BYTE RegAddr,BYTE val)
-{
-    
-    int  i2c_flag = -1;
-    int i = 0;
-    unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
-    unsigned char offset = RegAddr;
-    struct i2c_msg msg[] = {
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= 0,    
-			.len	= 1,
-			.buf	= &offset,
-		},
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= I2C_M_NOSTART,    
-			.len	= 1,
-			.buf	= &val,
-		}
-
-	};
-
-repeat:
-	i2c_flag = i2c_transfer(it660x_i2c_client->adapter, msg, 2);
-    if (i2c_flag < 0) {
-        pr_err("error in writing it660x i2c, %d byte(s) should be writen,. \n", 1);
-        if (i++ < i2c_try_cnt)
-            goto repeat;
-        return ER_FAIL;
-    }
-    else
-    {
-        if(it660x_debug_flag&0x2){
-            printk("[%s] %x: %x\n", __func__, RegAddr, val);
-        }
-        return ER_SUCCESS;
-    }
-    
-}
-
-
-SYS_STATUS HDMIRX_ReadI2C_ByteN(BYTE RegAddr,BYTE *pData,int N)
-{
-    int  i2c_flag = -1;
-    int i = 0;
-    unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
-    unsigned char offset = RegAddr;
-    struct i2c_msg msg[] = {
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= 0,    
-			.len	= 1,
-			.buf	= &offset,
-		},
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= I2C_M_RD,    
-			.len	= N,
-			.buf	= pData,
-		}
-
-	};
-
-repeat:
-	i2c_flag = i2c_transfer(it660x_i2c_client->adapter, msg, 2);
-    if (i2c_flag < 0) {
-        pr_err("error in read it660x_i2c, %d byte(s) should be read,. \n", N);
-        if (i++ < i2c_try_cnt)
-            goto repeat;
-        return ER_FAIL;
-    }
-    else
-    {
-        if(it660x_debug_flag&0x2){
-            printk("[%s] %x:", __func__, RegAddr);
-            for(i=0; i<N; i++){
-                if((i%16)==0){
-                    printk("\n");
-                }
-                printk("%x ", pData[i]);
-            }
-            printk("\n");
-        }
-        return ER_SUCCESS;
-    }
-}
-
-SYS_STATUS HDMIRX_WriteI2C_ByteN(BYTE RegAddr,BYTE *pData,int N)
-{
-    int  i2c_flag = -1;
-    int i = 0;
-    unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
-    unsigned char offset = RegAddr;
-    struct i2c_msg msg[] = {
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= 0,    
-			.len	= 1,
-			.buf	= &offset,
-		},
-	    {
-			.addr	= HDMIRXADR,
-			.flags	= I2C_M_NOSTART,    
-			.len	= N,
-			.buf	= pData,
-		}
-
-	};
-
-repeat:
-	i2c_flag = i2c_transfer(it660x_i2c_client->adapter, msg, 2);
-    if (i2c_flag < 0) {
-        pr_err("error in writing it660x i2c, %d byte(s) should be writen,. \n", N);
-        if (i++ < i2c_try_cnt)
-            goto repeat;
-        return ER_FAIL;
-    }
-    else
-    {
-        if(it660x_debug_flag&0x2){
-            printk("[%s] %x:", __func__, RegAddr);
-            for(i=0; i<N; i++){
-                if((i%16)==0){
-                    printk("\n");
-                }
-                printk("%x ", pData[i]);
-            }
-            printk("\n");
-        }
-        return ER_SUCCESS;
-    }
-}
-
-#ifdef _EDID_Parsing_
-BOOL EDID_READ_BYTE( BYTE address, BYTE offset, BYTE byteno, BYTE *p_data, BYTE device)
-{
-    return i2c_read_byte(address, offset, byteno, p_data, device);
-
-}
-BOOL EDID_WRITE_BYTE( BYTE address, BYTE offset, BYTE byteno, BYTE *p_data, BYTE device )
-{
-    return i2c_write_byte(address, offset, byteno, p_data, device);
-}
-#endif
-
-static int it660x_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-
- if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-     pr_info("%s: functionality check failed\n", __FUNCTION__);
-     return -ENODEV;
- }
- it660x_i2c_client = client;
-
-
- printk( " %s: it660x_i2c_client->addr = %x\n", __FUNCTION__, it660x_i2c_client->addr);
-
-	return 0;
-}
-
-static int it660x_i2c_remove(struct i2c_client *client)
-{
-    pr_info("%s driver removed ok.\n", client->name);
-	return 0;
-}
-
-static const struct i2c_device_id it660x_i2c_id[] = {
-	{ IT660X_I2C_NAME, 0 },
-	{ }
-};
-
-
-static struct i2c_driver it660x_i2c_driver = {
-	.driver = {
-        .owner  = THIS_MODULE,
-		.name = IT660X_I2C_NAME,
-	},
-	.probe		= it660x_i2c_probe,
-	.remove		= it660x_i2c_remove,
-	.id_table	= it660x_i2c_id,
-};
-
-
-static int __init it660x_i2c_init(void)
-{
-    int ret = 0;
-    pr_info( "%s . \n", __FUNCTION__ );
-
-    ret = i2c_add_driver(&it660x_i2c_driver);
-
-    if (ret < 0 /*|| it660x_i2c_client == NULL*/) {
-        pr_err("it660x: failed to add i2c driver. \n");
-        ret = -ENOTSUPP;
-    }
-
-	return ret;
-
-}
-
-static void __exit it660x_i2c_exit(void)
-{
-    pr_info( "%s . \n", __FUNCTION__ );
-
-	i2c_del_driver(&it660x_i2c_driver);
-}
-
-MODULE_AUTHOR("Y.S Zhang <rain.zhang@amlogic.com>");
-MODULE_DESCRIPTION("IT660X i2c device driver");
-MODULE_LICENSE("GPL");
-
-module_init(it660x_i2c_init);
-module_exit(it660x_i2c_exit);
-
diff --git a/drivers/amlogic/tvin/it660x/mcu.h b/drivers/amlogic/tvin/it660x/mcu.h
deleted file mode 100755
index 19c1c0220a8b..000000000000
--- a/drivers/amlogic/tvin/it660x/mcu.h
+++ /dev/null
@@ -1,95 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <mcu.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-///////////////////////////////////////////////////////////////////////////////
-// Include file
-///////////////////////////////////////////////////////////////////////////////
-#ifndef _MCU_H_
-#define _MCU_H_
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-
-#include "config.h"
-//#include "Reg_c51.h"
-
-///////////////////////////////////////////////////////////////////////////////
-// Global Definition
-///////////////////////////////////////////////////////////////////////////////
-//#define DIVA
-///////////////////////////////////////////////////////////////////////////////
-// Type Definition
-///////////////////////////////////////////////////////////////////////////////
-#include "typedef.h"
-#include "debug.h"
-#include "io.h"
-//#include "TimerProcess.h"
-///////////////////////////////////////////////////////////////////////////////
-// Constant Definition
-///////////////////////////////////////////////////////////////////////////////
-#define HDMIRXADR       0x90
-#define RXDEV           0
-#define ExtEDID         1
-#define IntEDID         2
-
-
-#define RXADR           0xB0
-
-#define DELAY_TIME      1           // unit = 1 us;
-#define IDLE_TIME       100         // unit = 1 ms;
-
-#define HIGH            1
-#define LOW             0
-
-#define ACTIVE          1
-#define DISABLE         0
-
-#define DevNum          1
-#define LOOPMS          20          // 20-> 5 ,  030408, Clive
-
-#define delay1ms(ms) mdelay(ms)
-
-///////////////////////////////////////////////////////////////////////////////
-// 8051 Definition
-///////////////////////////////////////////////////////////////////////////////
-
-    #ifndef DISABLE_EDID_PARSING
-#pragma message ("Defined EDID Parsing")
-    #define _EDID_Parsing_
-    #endif
-
-#if 0
-    sbit HW_RSTN=P3^5;
-    sbit SCL_PORT           = P1^0;
-    sbit SDA_PORT           = P1^1;
-    sbit EDID_SCL=P1^3;
-    sbit EDID_SDA=P1^2;
-    sbit EDID_WP           = P4^0;     // inverse by MOS
-#ifndef OLD_VGA_DDC
-    sbit VGA_SCL            = P1^4;     // VGA DDC control
-    sbit VGA_SDA            = P1^7;
-#else
-    sbit VGA_SCL            = P0^0;     // VGA DDC control
-    sbit VGA_SDA            = P0^1;
-#endif
-	sbit Hold_Pin           = P1^5 ;
-
-    sbit RX_HPD=P4^2;
-    sbit RXINT=P3^2;
-    sbit REPEATER_SET=P1^6 ;
-#endif
-/////////////////////////////////////////////////////////////////
-// CHIP DEFINE
-/////////////////////////////////////////////////////////////////
-
-#endif      // _MCU_H_
diff --git a/drivers/amlogic/tvin/it660x/sha1.c b/drivers/amlogic/tvin/it660x/sha1.c
deleted file mode 100755
index 6d21d87725e3..000000000000
--- a/drivers/amlogic/tvin/it660x/sha1.c
+++ /dev/null
@@ -1,152 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <sha1.c>
-//   @author Hermes.Wu@ite.com.tw
-//   @date   2011/08/26
-//   @fileversion: COMMON_FILE_1.01
-//******************************************/
-
-//#include <stdio.h>
-//#include <stdlib.h>
-#include "sha1.h"
-
-
-#ifndef DISABLE_HDCP
-
-#define WCOUNT 17
-ULONG    VH[5];
-ULONG    w[WCOUNT];
-
-#define rol(x,y)(((x)<< (y))| (((ULONG)x)>> (32-y)))
-
-
-void SHATransform(ULONG * h)
-{
-    int t;
-    ULONG tmp;
-
-
-    h[0]=0x67452301;
-    h[1]=0xefcdab89;
-    h[2]=0x98badcfe;
-    h[3]=0x10325476;
-    h[4]=0xc3d2e1f0;
-
-    for (t=0; t < 20; t++){
-		if(t>=16)
-		{
-        	tmp=w[(t - 3)% WCOUNT] ^ w[(t - 8)% WCOUNT] ^ w[(t - 14)% WCOUNT] ^ w[(t - 16)% WCOUNT];
-	        w[(t)% WCOUNT]=rol(tmp,1);
-		}
-		HDCP_DEBUG_PRINTF2(("w[%d]=%08lX\n",t,w[(t)% WCOUNT]));
-
-        tmp=rol(h[0],5)+ ((h[1] & h[2])| (h[3] & ~h[1]))+ h[4] + w[(t)% WCOUNT] + 0x5a827999;
-        HDCP_DEBUG_PRINTF2(("%08lX %08lX %08lX %08lX %08lX\n",h[0],h[1],h[2],h[3],h[4]));
-
-        h[4]=h[3];
-        h[3]=h[2];
-        h[2]=rol(h[1],30);
-        h[1]=h[0];
-        h[0]=tmp;
-
-    }
-    for (t=20; t < 40; t++){
-        tmp=w[(t - 3)% WCOUNT] ^ w[(t - 8)% WCOUNT] ^ w[(t - 14)% WCOUNT] ^ w[(t - 16)% WCOUNT];
-        w[(t)% WCOUNT]=rol(tmp,1);
-        HDCP_DEBUG_PRINTF2(("w[%d]=%08lX\n",t,w[(t)% WCOUNT]));
-        tmp=rol(h[0],5)+ (h[1] ^ h[2] ^ h[3])+ h[4] + w[(t)% WCOUNT] + 0x6ed9eba1;
-        HDCP_DEBUG_PRINTF2(("%08lX %08lX %08lX %08lX %08lX\n",h[0],h[1],h[2],h[3],h[4]));
-        h[4]=h[3];
-        h[3]=h[2];
-        h[2]=rol(h[1],30);
-        h[1]=h[0];
-        h[0]=tmp;
-    }
-    for (t=40; t < 60; t++){
-        tmp=w[(t - 3)% WCOUNT] ^ w[(t - 8)% WCOUNT] ^ w[(t - 14)% WCOUNT] ^ w[(t - 16)% WCOUNT];
-        w[(t)% WCOUNT]=rol(tmp,1);
-        HDCP_DEBUG_PRINTF2(("w[%d]=%08lX\n",t,w[(t)% WCOUNT]));
-        tmp=rol(h[0],5)+ ((h[1] & h[2])| (h[1] & h[3])| (h[2] & h[3]))+ h[4] + w[(t)% WCOUNT] + 0x8f1bbcdc;
-        HDCP_DEBUG_PRINTF2(("%08lX %08lX %08lX %08lX %08lX\n",h[0],h[1],h[2],h[3],h[4]));
-        h[4]=h[3];
-        h[3]=h[2];
-        h[2]=rol(h[1],30);
-        h[1]=h[0];
-        h[0]=tmp;
-    }
-    for (t=60; t < 80; t++)
-    {
-        tmp=w[(t - 3)% WCOUNT] ^ w[(t - 8)% WCOUNT] ^ w[(t - 14)% WCOUNT] ^ w[(t - 16)% WCOUNT];
-        w[(t)% WCOUNT]=rol(tmp,1);
-        HDCP_DEBUG_PRINTF2(("w[%d]=%08lX\n",t,w[(t)% WCOUNT]));
-        tmp=rol(h[0],5)+ (h[1] ^ h[2] ^ h[3])+ h[4] + w[(t)% WCOUNT] + 0xca62c1d6;
-        HDCP_DEBUG_PRINTF2(("%08lX %08lX %08lX %08lX %08lX\n",h[0],h[1],h[2],h[3],h[4]));
-        h[4]=h[3];
-        h[3]=h[2];
-        h[2]=rol(h[1],30);
-        h[1]=h[0];
-        h[0]=tmp;
-    }
-    HDCP_DEBUG_PRINTF2(("%08lX %08lX %08lX %08lX %08lX\n",h[0],h[1],h[2],h[3],h[4]));
-    h[0] +=0x67452301;
-    h[1] +=0xefcdab89;
-    h[2] +=0x98badcfe;
-    h[3] +=0x10325476;
-    h[4] +=0xc3d2e1f0;
-
-    HDCP_DEBUG_PRINTF2(("%08lX %08lX %08lX %08lX %08lX\n",h[0],h[1],h[2],h[3],h[4]));
-}
-
-void SHA_Simple(void *p,WORD len,BYTE *output)
-{
-    // SHA_State s;
-    WORD i,t;
-    ULONG c;
-    BYTE *pBuff=p;
-
-    for(i=0;i < len;i++)
-    {
-        t=i/4;
-        if(i%4==0)
-        {
-            w[t]=0;
-        }
-        c=pBuff[i];
-        c <<=(3-(i%4))*8;
-        w[t] |=c;
-        HDCP_DEBUG_PRINTF2(("pBuff[%d]=%02X,c=%08lX,w[%d]=%08lX\n",(int)i,(int)pBuff[i],c,(int)t,w[t]));
-    }
-    t=i/4;
-    if(i%4==0)
-    {
-        w[t]=0;
-    }
-    //c=0x80 << ((3-i%4)*24);
-    c=0x80;
-    c <<=((3-i%4)*8);
-    w[t]|=c;t++;
-    for(; t < 15;t++)
-    {
-        w[t]=0;
-    }
-    w[15]=len*8;
-
-	for(i = 0 ; i < 16 ; i++)
-	{
-		HDCP_DEBUG_PRINTF2(("w[%d] = %08lX\n",i,w[i]));
-	}
-
-    SHATransform(VH);
-
-    for(i=0;i < 5;i++)
-    {
-        output[i*4+3]=(BYTE)((VH[i]>>24)&0xFF);
-        output[i*4+2]=(BYTE)((VH[i]>>16)&0xFF);
-        output[i*4+1]=(BYTE)((VH[i]>>8)&0xFF);
-        output[i*4+0]=(BYTE)(VH[i]&0xFF);
-    }
-}
-#endif
diff --git a/drivers/amlogic/tvin/it660x/sha1.h b/drivers/amlogic/tvin/it660x/sha1.h
deleted file mode 100755
index b40f6ce0d08e..000000000000
--- a/drivers/amlogic/tvin/it660x/sha1.h
+++ /dev/null
@@ -1,45 +0,0 @@
-///*****************************************
-//  Copyright (C)2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <sha1.h>
-//   @author Jau-chih.Tseng@ite.com.tw
-//   @date   2010/06/04
-//   @fileversion: COMMON_FILE_1.01
-//******************************************/
-
-#ifndef _SHA_1_H_
-#define _SHA_1_H_
-
-#ifdef _MCU_8051_
-    #include "Mcu.h"
-#endif
-
-//#include <string.h>
-
-#ifdef Debug_message
-//#include <stdio.h>
-#endif
-#include "config.h"
-#include "typedef.h"
-
-#ifndef HDCP_DEBUG_PRINTF
-    #define HDCP_DEBUG_PRINTF(x)
-#endif //HDCP_DEBUG_PRINTF
-
-#ifndef HDCP_DEBUG_PRINTF1
-    #define HDCP_DEBUG_PRINTF1(x)
-#endif //HDCP_DEBUG_PRINTF1
-
-#ifndef HDCP_DEBUG_PRINTF2
-    #define HDCP_DEBUG_PRINTF2(x)
-#endif //HDCP_DEBUG_PRINTF2
-
-
-#ifndef DISABLE_HDCP
-void SHA_Simple(void *p,WORD len,BYTE *output);
-void SHATransform(ULONG * h);
-#endif
-
-#endif // _SHA_1_H_
diff --git a/drivers/amlogic/tvin/it660x/typedef.h b/drivers/amlogic/tvin/it660x/typedef.h
deleted file mode 100755
index e57e1868a2bf..000000000000
--- a/drivers/amlogic/tvin/it660x/typedef.h
+++ /dev/null
@@ -1,738 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <typedef.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-#ifndef _TYPEDEF_H_
-#define _TYPEDEF_H_
-
-//////////////////////////////////////////////////
-// data type
-//////////////////////////////////////////////////
-#ifdef _MCU_8051_
-typedef bit BOOL ;
-#define _CODE code
-#define _IDATA idata
-#define _XDATA xdata
-typedef	code	unsigned char	cBYTE;
-#else
-typedef int BOOL ;
-#define _CODE
-#define _IDATA
-#define _XDATA
-typedef	unsigned char	cBYTE;
-#endif // _MCU_8051_
-
-
-typedef char CHAR, *PCHAR ;
-typedef unsigned char uchar, *puchar ;
-typedef unsigned char UCHAR, *PUCHAR ;
-typedef unsigned char byte, *pbyte ;
-typedef unsigned char BYTE, *PBYTE ;
-
-typedef short SHORT, *PSHORT ;
-//typedef unsigned short ushort, *pushort ;
-typedef unsigned short USHORT, *PUSHORT ;
-typedef unsigned short word, *pword ;
-typedef unsigned short WORD, *PWORD ;
-
-typedef long LONG, *PLONG ;
-//typedef unsigned long ulong, *pulong ;
-typedef unsigned long ULONG, *PULONG ;
-typedef unsigned long dword, *pdword ;
-typedef unsigned long DWORD, *PDWORD ;
-
-#define FALSE 0
-#define TRUE 1
-
-#define SUCCESS 0
-#define FAIL -1
-
-#define ON 1
-#define OFF 0
-
-typedef enum _SYS_STATUS {
-    ER_SUCCESS = 0,
-    ER_FAIL,
-    ER_RESERVED
-} SYS_STATUS ;
-
-#define ABS(x)(((x)>=0)?(x):(-(x)))
-
-typedef struct {
-    WORD HActive ;
-    WORD VActive ;
-    WORD HTotal ;
-    WORD VTotal ;
-    LONG PCLK ;
-    BYTE xCnt ;
-    WORD HFrontPorch ;
-    WORD HSyncWidth ;
-    WORD HBackPorch ;
-    BYTE VFrontPorch ;
-    BYTE VSyncWidth ;
-    BYTE VBackPorch ;
-    BYTE ScanMode:1 ;
-    BYTE VPolarity:1 ;
-    BYTE HPolarity:1 ;
-} HDMI_VTiming ;
-
-#define PROG 1
-#define INTERLACE 0
-#define Vneg 0
-#define Hneg 0
-#define Vpos 1
-#define Hpos 1
-
-
-typedef enum _Video_State_Type {
-	VSTATE_Off=0,
-    VSTATE_PwrOff,
-    VSTATE_SyncWait ,
-    VSTATE_SWReset,
-    VSTATE_SyncChecking,
-    VSTATE_HDCPSet,
-    VSTATE_HDCP_Reset,
-    VSTATE_ModeDetecting,
-    VSTATE_VideoOn,
-    VSTATE_ColorDetectReset,
-    VSTATE_Reserved
-} Video_State_Type ;
-
-
-typedef enum _Audio_State_Type {
-    ASTATE_AudioOff = 0,
-    ASTATE_RequestAudio ,
-    ASTATE_ResetAudio,
-    ASTATE_WaitForReady,
-    ASTATE_AudioOn ,
-    ASTATE_Reserved
-} Audio_State_Type ;
-
-typedef enum _TXVideo_State_Type {
-    TXVSTATE_Unplug = 0,
-    TXVSTATE_HPD,
-    TXVSTATE_WaitForMode,
-    TXVSTATE_WaitForVStable,
-    TXVSTATE_VideoInit,
-    TXVSTATE_VideoSetup,
-    TXVSTATE_VideoOn,
-    TXVSTATE_Reserved
-} TXVideo_State_Type ;
-
-
-typedef enum _TXAudio_State_Type {
-    TXASTATE_AudioOff = 0,
-    TXASTATE_AudioPrepare,
-    TXASTATE_AudioOn,
-    TXASTATE_AudioFIFOFail,
-    TXASTATE_Reserved
-} TXAudio_State_Type ;
-
-typedef enum _RXHDCP_State_Type {
-    RXHDCP_Reset = 0,
-    RXHDCP_AuthStart,
-    RXHDCP_AuthDone,
-    RXHDCP_UpdateKSVList,
-    RXHDCP_Ready,
-    RXHDCP_FailReady,
-    RXHDCP_Reserved
-} RXHDCP_State_Type ;
-
-
-typedef enum {
-    PCLK_LOW = 0 ,
-    PCLK_MEDIUM,
-    PCLK_HIGH
-} VIDEOPCLKLEVEL ;
-
-///////////////////////////////////////////////////////////////////////
-// Video Data Type
-///////////////////////////////////////////////////////////////////////
-#define F_MODE_RGB24  0
-#define F_MODE_RGB444  0
-#define F_MODE_YUV422 1
-#define F_MODE_YUV444 2
-#define F_MODE_CLRMOD_MASK 3
-
-
-#define F_MODE_INTERLACE  1
-
-#define F_MODE_ITU709  (1<<4)
-#define F_MODE_ITU601  0
-
-#define F_MODE_0_255   0
-#define F_MODE_16_235  (1<<5)
-
-#define F_MODE_EN_UDFILT (1<<6)// output mode only, and loaded from EEPROM
-#define F_MODE_EN_DITHER (1<<7)// output mode only, and loaded from EEPROM
-
-#define _VideoFormatCode
-typedef union _VideoFormatCode
-{
-    struct _VFC
-    {
-        BYTE colorfmt:2 ;
-        BYTE interlace:1 ;
-        BYTE Colorimetry:1 ;
-        BYTE Quantization:1 ;
-        BYTE UpDownFilter:1 ;
-        BYTE Dither:1 ;
-    } VFCCode ;
-    unsigned char VFCByte ;
-} VideoFormatCode ;
-
-#define T_MODE_CCIR656 (1<<0)
-#define T_MODE_SYNCEMB (1<<1)
-#define T_MODE_INDDR   (1<<2)
-#define T_MODE_PCLKDIV2 (1<<3)
-
-//////////////////////////////////////////////////////////////////
-// Audio relate definition and macro.
-//////////////////////////////////////////////////////////////////
-
-// for sample clock
-#define AUDFS_22p05KHz  4
-#define AUDFS_44p1KHz 0
-#define AUDFS_88p2KHz 8
-#define AUDFS_176p4KHz    12
-
-#define AUDFS_24KHz  6
-#define AUDFS_48KHz  2
-#define AUDFS_96KHz  10
-#define AUDFS_192KHz 14
-
-#define AUDFS_32KHz  3
-#define AUDFS_OTHER    1
-
-// Audio Enable
-#define ENABLE_SPDIF    (1<<4)
-#define ENABLE_I2S_SRC3  (1<<3)
-#define ENABLE_I2S_SRC2  (1<<2)
-#define ENABLE_I2S_SRC1  (1<<1)
-#define ENABLE_I2S_SRC0  (1<<0)
-
-#define AUD_SWL_NOINDICATE  0x0
-#define AUD_SWL_16          0x2
-#define AUD_SWL_17          0xC
-#define AUD_SWL_18          0x4
-#define AUD_SWL_20          0xA // for maximum 20 bit
-#define AUD_SWL_21          0xD
-#define AUD_SWL_22          0x5
-#define AUD_SWL_23          0x9
-#define AUD_SWL_24          0xB
-
-
-/////////////////////////////////////////////////////////////////////
-// Packet and Info Frame definition and datastructure.
-/////////////////////////////////////////////////////////////////////
-
-#define VENDORSPEC_INFOFRAME_TYPE 0x01
-#define AVI_INFOFRAME_TYPE  0x02
-#define SPD_INFOFRAME_TYPE 0x03
-#define AUDIO_INFOFRAME_TYPE 0x04
-#define MPEG_INFOFRAME_TYPE 0x05
-
-#define VENDORSPEC_INFOFRAME_VER 0x01
-#define AVI_INFOFRAME_VER  0x02
-#define SPD_INFOFRAME_VER 0x01
-#define AUDIO_INFOFRAME_VER 0x01
-#define MPEG_INFOFRAME_VER 0x01
-
-#define VENDORSPEC_INFOFRAME_LEN 8
-#define AVI_INFOFRAME_LEN 13
-#define SPD_INFOFRAME_LEN 25
-#define AUDIO_INFOFRAME_LEN 10
-#define MPEG_INFOFRAME_LEN 10
-
-#define ACP_PKT_LEN 9
-#define ISRC1_PKT_LEN 16
-#define ISRC2_PKT_LEN 16
-
-typedef union _AVI_InfoFrame
-{
-    struct {
-        BYTE Type ;
-        BYTE Ver ;
-        BYTE Len ;
-
-        BYTE Scan:2 ;
-        BYTE BarInfo:2 ;
-        BYTE ActiveFmtInfoPresent:1 ;
-        BYTE ColorMode:2 ;
-        BYTE FU1:1 ;
-
-        BYTE ActiveFormatAspectRatio:4 ;
-        BYTE PictureAspectRatio:2 ;
-        BYTE Colorimetry:2 ;
-
-        BYTE Scaling:2 ;
-        BYTE FU2:6 ;
-
-        BYTE VIC:7 ;
-        BYTE FU3:1 ;
-
-        BYTE PixelRepetition:4 ;
-        BYTE FU4:4 ;
-
-        SHORT Ln_End_Top ;
-        SHORT Ln_Start_Bottom ;
-        SHORT Pix_End_Left ;
-        SHORT Pix_Start_Right ;
-    } info ;
-    struct {
-        BYTE AVI_HB[3] ;
-        BYTE AVI_DB[AVI_INFOFRAME_LEN] ;
-    } pktbyte ;
-} AVI_InfoFrame ;
-
-typedef union _Audio_InfoFrame {
-
-    struct {
-        BYTE Type ;
-        BYTE Ver ;
-        BYTE Len ;
-
-        BYTE AudioChannelCount:3 ;
-        BYTE RSVD1:1 ;
-        BYTE AudioCodingType:4 ;
-
-        BYTE SampleSize:2 ;
-        BYTE SampleFreq:3 ;
-        BYTE Rsvd2:3 ;
-
-        BYTE FmtCoding ;
-
-        BYTE SpeakerPlacement ;
-
-        BYTE Rsvd3:3 ;
-        BYTE LevelShiftValue:4 ;
-        BYTE DM_INH:1 ;
-    } info ;
-
-    struct {
-        BYTE AUD_HB[3] ;
-        BYTE AUD_DB[AUDIO_INFOFRAME_LEN] ;
-    } pktbyte ;
-
-} Audio_InfoFrame ;
-
-typedef union _MPEG_InfoFrame {
-    struct {
-        BYTE Type ;
-        BYTE Ver ;
-        BYTE Len ;
-
-        ULONG MpegBitRate ;
-
-        BYTE MpegFrame:2 ;
-        BYTE Rvsd1:2 ;
-        BYTE FieldRepeat:1 ;
-        BYTE Rvsd2:3 ;
-    } info ;
-    struct {
-        BYTE MPG_HB[3] ;
-        BYTE MPG_DB[MPEG_INFOFRAME_LEN] ;
-    } pktbyte ;
-} MPEG_InfoFrame ;
-
-// Source Product Description
-typedef union _SPD_InfoFrame {
-    struct {
-        BYTE Type ;
-        BYTE Ver ;
-        BYTE Len ;
-
-        char VN[8] ; // vendor name character in 7bit ascii characters
-        char PD[16] ; // product description character in 7bit ascii characters
-        BYTE SourceDeviceInfomation ;
-    } info ;
-    struct {
-        BYTE SPD_HB[3] ;
-        BYTE SPD_DB[SPD_INFOFRAME_LEN] ;
-    } pktbyte ;
-} SPD_InfoFrame ;
-
-///////////////////////////////////////////////////////////////////////////
-// Using for interface.
-///////////////////////////////////////////////////////////////////////////
-struct VideoTiming {
-    ULONG VideoPixelClock ;
-    BYTE VIC ;
-    BYTE pixelrep ;
-	BYTE outputVideoMode ;
-} ;
-
-#define F_VIDMODE_ITU709  (1<<4)
-#define F_VIDMODE_ITU601  0
-
-#define F_VIDMODE_0_255   0
-#define F_VIDMODE_16_235  (1<<5)
-
-#define F_VIDMODE_EN_UDFILT (1<<6)// output mode only, and loaded from EEPROM
-#define F_VIDMODE_EN_DITHER (1<<7)// output mode only, and loaded from EEPROM
-
-/*
-#define T_MODE_CCIR656 (1<<0)
-#define T_MODE_SYNCEMB (1<<1)
-#define T_MODE_INDDR (1<<2)
-#define T_MODE_DEGEN (1<<3)
-#define T_MODE_SYNCGEN (1<<4)
-*/
-//////////////////////////////////////////////////////////////////
-// Audio relate definition and macro.
-//////////////////////////////////////////////////////////////////
-
-// for sample clock
-#define FS_22K05  4
-#define FS_44K1 0
-#define FS_88K2 8
-#define FS_176K4    12
-
-#define FS_24K  6
-#define FS_48K  2
-#define FS_96K  10
-#define FS_192K 14
-
-#define FS_32K  3
-#define FS_OTHER    1
-
-/////////////////////////////////////////////////////////////////////
-// Packet and Info Frame definition and datastructure.
-/////////////////////////////////////////////////////////////////////
-
-#define VENDORSPEC_INFOFRAME_TYPE 0x01
-#define AVI_INFOFRAME_TYPE  0x02
-#define SPD_INFOFRAME_TYPE 0x03
-#define AUDIO_INFOFRAME_TYPE 0x04
-#define MPEG_INFOFRAME_TYPE 0x05
-
-#define VENDORSPEC_INFOFRAME_VER 0x01
-#define AVI_INFOFRAME_VER  0x02
-#define SPD_INFOFRAME_VER 0x01
-#define AUDIO_INFOFRAME_VER 0x01
-#define MPEG_INFOFRAME_VER 0x01
-
-#define VENDORSPEC_INFOFRAME_LEN 8
-#define AVI_INFOFRAME_LEN 13
-#define SPD_INFOFRAME_LEN 25
-#define AUDIO_INFOFRAME_LEN 10
-#define MPEG_INFOFRAME_LEN 10
-
-#define ACP_PKT_LEN 9
-#define ISRC1_PKT_LEN 16
-#define ISRC2_PKT_LEN 16
-
-
-typedef enum tagHDMI_Video_Type {
-    HDMI_Unkown = 0 ,
-    HDMI_640x480p60 = 1 ,
-    HDMI_480p60,
-    HDMI_480p60_16x9,
-    HDMI_720p60,
-    HDMI_1080i60,
-    HDMI_480i60,
-    HDMI_480i60_16x9,
-    HDMI_240p60,
-    HDMI_1440x480p60,
-    HDMI_1080p60 = 16,
-    HDMI_576p50,
-    HDMI_576p50_16x9,
-    HDMI_720p50,
-    HDMI_1080i50,
-    HDMI_576i50,
-    HDMI_576i50_16x9,
-    HDMI_288p50,
-    HDMI_1440x576p50,
-    HDMI_1080p50 = 31,
-    HDMI_1080p24,
-    HDMI_1080p25,
-    HDMI_1080p30,
-    HDMI_2880x480p60,
-    HDMI_2880x480p60_16x9,
-    HDMI_2880x576p50,
-    HDMI_2880x576p50_16x9,
-    HDMI_1920x1080i50_1250total,
-    HDMI_1080i100,
-    HDMI_720p100,
-    HDMI_576p100,
-    HDMI_576p100_16x9,
-    HDMI_576i100,
-    HDMI_576i100_16x9,
-    HDMI_1080i120,
-    HDMI_720p120,
-    HDMI_480p120,
-    HDMI_480p120_16x9,
-    HDMI_480i120,
-    HDMI_480i120_16x9,
-    HDMI_576p200,
-    HDMI_576p200_16x9,
-    HDMI_576i200,
-    HDMI_576i200_16x9,
-    HDMI_480p240,
-    HDMI_480p240_200,
-    HDMI_480i240,
-    HDMI_480i240_200,
-    HDMI_720p24 = 60,
-    HDMI_720p30 = 61,
-    HDMI_720p25 = 62,
-    HDMI_1080p120,
-    HDMI_1080p100,
-} HDMI_Video_Type ;
-
-typedef enum tagHDMI_Aspec {
-    HDMI_4x3 ,
-    HDMI_16x9
-} HDMI_Aspec;
-
-typedef enum tagHDMI_OutputColorMode {
-    HDMI_RGB444,
-    HDMI_YUV444,
-    HDMI_YUV422
-} HDMI_OutputColorMode ;
-
-typedef enum tagHDMI_Colorimetry {
-    HDMI_ITU601,
-    HDMI_ITU709
-} HDMI_Colorimetry ;
-
-#define MODEID
-typedef enum tagMODE_ID{
-	CEA_640x480p60,
-	CEA_720x480p60,
-	CEA_1280x720p60,
-	CEA_1920x1080i60,
-	CEA_720x480i60,
-	CEA_720x240p60,
-	CEA_1440x480i60,
-	CEA_1440x240p60,
-	CEA_2880x480i60,
-	CEA_2880x240p60,
-	CEA_1440x480p60,
-	CEA_1920x1080p60,
-	CEA_720x576p50,
-	CEA_1280x720p50,
-	CEA_1920x1080i50,
-	CEA_720x576i50,
-	CEA_1440x576i50,
-	CEA_720x288p50,
-	CEA_1440x288p50,
-	CEA_2880x576i50,
-	CEA_2880x288p50,
-	CEA_1440x576p50,
-	CEA_1920x1080p50,
-	CEA_1920x1080p24,
-	CEA_1920x1080p25,
-	CEA_1920x1080p30,
-
-	VESA_640x350p85,
-	VESA_640x400p85,
-	VESA_720x400p85,
-	VESA_640x480p60,
-	VESA_640x480p72,
-	VESA_640x480p75,
-	VESA_640x480p85,
-	VESA_800x600p56,
-	VESA_800x600p60,
-	VESA_800x600p72,
-	VESA_800x600p75,
-	VESA_800X600p85,
-	VESA_840X480p60,
-	VESA_1024x768p60,
-	VESA_1024x768p70,
-	VESA_1024x768p75,
-	VESA_1024x768p85,
-	VESA_1152x864p75,
-	VESA_1280x768p60R,
-	VESA_1280x768p60,
-	VESA_1280x768p75,
-	VESA_1280x768p85,
-	VESA_1280x960p60,
-	VESA_1280x960p85,
-	VESA_1280x1024p60,
-	VESA_1280x1024p75,
-	VESA_1280X1024p85,
-	VESA_1360X768p60,
-	VESA_1400x768p60R,
-	VESA_1400x768p60,
-	VESA_1400x1050p75,
-	VESA_1400x1050p85,
-	VESA_1440x900p60R,
-	VESA_1440x900p60,
-	VESA_1440x900p75,
-	VESA_1440x900p85,
-	VESA_1600x1200p60,
-	VESA_1600x1200p65,
-	VESA_1600x1200p70,
-	VESA_1600x1200p75,
-	VESA_1600x1200p85,
-	VESA_1680x1050p60R,
-	VESA_1680x1050p60,
-	VESA_1680x1050p75,
-	VESA_1680x1050p85,
-	VESA_1792x1344p60,
-	VESA_1792x1344p75,
-	VESA_1856x1392p60,
-	VESA_1856x1392p75,
-	VESA_1920x1200p60R,
-	VESA_1920x1200p60,
-	VESA_1920x1200p75,
-	VESA_1920x1200p85,
-	VESA_1920x1440p60,
-	VESA_1920x1440p75,
-	UNKNOWN_MODE
-} MODE_ID;
-/////////////////////////////////////////
-// RX Capability.
-/////////////////////////////////////////
-typedef struct {
-    BYTE b16bit:1 ;
-    BYTE b20bit:1 ;
-    BYTE b24bit:1 ;
-    BYTE Rsrv:5 ;
-} LPCM_BitWidth ;
-
-typedef enum {
-    AUD_RESERVED_0 = 0 ,
-    AUD_LPCM,
-    AUD_AC3,
-    AUD_MPEG1,
-    AUD_MP3,
-    AUD_MPEG2,
-    AUD_AAC,
-    AUD_DTS,
-    AUD_ATRAC,
-    AUD_ONE_BIT_AUDIO,
-    AUD_DOLBY_DIGITAL_PLUS,
-    AUD_DTS_HD,
-    AUD_MAT_MLP,
-    AUD_DST,
-    AUD_WMA_PRO,
-    AUD_RESERVED_15
-} AUDIO_FORMAT_CODE ;
-
-typedef union {
-    struct {
-        BYTE channel:3 ;
-        BYTE AudioFormatCode:4 ;
-        BYTE Rsrv1:1 ;
-
-        BYTE b32KHz:1 ;
-        BYTE b44_1KHz:1 ;
-        BYTE b48KHz:1 ;
-        BYTE b88_2KHz:1 ;
-        BYTE b96KHz:1 ;
-        BYTE b176_4KHz:1 ;
-        BYTE b192KHz:1 ;
-        BYTE Rsrv2:1 ;
-        BYTE ucCode ;
-    } s ;
-    BYTE uc[3] ;
-
-} AUDDESCRIPTOR ;
-
-typedef union {
-    struct {
-        BYTE FL_FR:1 ;
-        BYTE LFE:1 ;
-        BYTE FC:1 ;
-        BYTE RL_RR:1 ;
-        BYTE RC:1 ;
-        BYTE FLC_FRC:1 ;
-        BYTE RLC_RRC:1 ;
-        BYTE Reserve:1 ;
-        BYTE Unuse[2] ;
-    } s ;
-    BYTE uc[3] ;
-} SPK_ALLOC ;
-
-#define CEA_SUPPORT_UNDERSCAN (1<<7)
-#define CEA_SUPPORT_AUDIO (1<<6)
-#define CEA_SUPPORT_YUV444 (1<<5)
-#define CEA_SUPPORT_YUV422 (1<<4)
-#define CEA_NATIVE_MASK 0xF
-
-
-#define HDMI_DC_SUPPORT_AI (1<<7)
-#define HDMI_DC_SUPPORT_48 (1<<6)
-#define HDMI_DC_SUPPORT_36 (1<<5)
-#define HDMI_DC_SUPPORT_30 (1<<4)
-#define HDMI_DC_SUPPORT_Y444 (1<<3)
-#define HDMI_DC_SUPPORT_DVI_DUAL 1
-
-typedef union _tag_DCSUPPORT {
-    struct {
-        BYTE DVI_Dual:1 ;
-        BYTE Rsvd:2 ;
-        BYTE DC_Y444:1 ;
-        BYTE DC_30Bit:1 ;
-        BYTE DC_36Bit:1 ;
-        BYTE DC_48Bit:1 ;
-        BYTE SUPPORT_AI:1 ;
-    } info ;
-    BYTE uc ;
-} DCSUPPORT ;
-
-typedef union _LATENCY_SUPPORT{
-    struct {
-        BYTE Rsvd:6 ;
-        BYTE I_Latency_Present:1 ;
-        BYTE Latency_Present:1 ;
-    } info ;
-    BYTE uc ;
-} LATENCY_SUPPORT ;
-
-#define HDMI_IEEEOUI 0x0c03
-typedef struct _RX_CAP{
-    BYTE VideoMode ;
-    BYTE VDOModeCount ;
-    BYTE idxNativeVDOMode ;
-    BYTE VDOMode[32] ;
-    BYTE AUDDesCount ;
-    AUDDESCRIPTOR AUDDes[8] ;
-    ULONG IEEEOUI ;
-    DCSUPPORT dc ;
-    BYTE MaxTMDSClock ;
-    LATENCY_SUPPORT lsupport ;
-    BYTE V_Latency ;
-    BYTE A_Latency ;
-    BYTE V_I_Latency ;
-    BYTE A_I_Latency ;
-    SPK_ALLOC   SpeakerAllocBlk ;
-    BYTE ValidCEA:1 ;
-    BYTE ValidHDMI:1 ;
-} RX_CAP ;
-
-
-#define PROG 1
-#define INTERLACE 0
-#define Vneg 0
-#define Hneg 0
-#define Vpos 1
-#define Hpos 1
-
-typedef struct {
-    USHORT HActive ;
-    USHORT VActive ;
-    USHORT HTotal ;
-    USHORT VTotal ;
-    ULONG  PCLK ;
-    USHORT xCnt ;
-    USHORT HFrontPorch ;
-    USHORT HSyncWidth ;
-    USHORT HBackPorch ;
-    USHORT VFrontPorch ;
-    USHORT VSyncWidth ;
-    USHORT VBackPorch ;
-    USHORT ScanMode:1 ;
-    USHORT VPolarity:1 ;
-    USHORT HPolarity:1 ;
-} VIDEO_Timing ;
-
-#endif // _TYPEDEF_H_
diff --git a/drivers/amlogic/tvin/it660x/version.h b/drivers/amlogic/tvin/it660x/version.h
deleted file mode 100755
index 4852df1fc875..000000000000
--- a/drivers/amlogic/tvin/it660x/version.h
+++ /dev/null
@@ -1,17 +0,0 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <version.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/07/24
-//   @fileversion: HDMIRX_SAMPLE_2.18
-//******************************************/
-
-#ifndef _VERSION_H_
-#define _VERSION_H_
-#define	VERSION_STRING	"HDMIRX_SAMPLE_2.18"
-#endif
-
-#define	SHORT_VERSION_STRING	"V218\n    "
diff --git a/drivers/amlogic/tvin/tvafe/Kconfig b/drivers/amlogic/tvin/tvafe/Kconfig
deleted file mode 100755
index b6fe0b13a9aa..000000000000
--- a/drivers/amlogic/tvin/tvafe/Kconfig
+++ /dev/null
@@ -1,23 +0,0 @@
-#
-# TVAFE Device Driver Configuration
-#
-
-
-config TVIN_AFE
-	tristate "Amlogic AFE device driver"
-	default n
-	help
-	  AFE device driver.
-if TVIN_AFE
-   config ADC_DOUBLE_SAMPLING_FOR_SD
-        bool "Enable double sampling function"
-        default n
-        help
-                Adc double sampling for SD.        
-   config TVIN_VBI
-    	tristate "Amlogic TVIN VBI device"
-    	default n
-    	help
-        	VBI devices driver.
-     
-endif 
diff --git a/drivers/amlogic/tvin/tvafe/Makefile b/drivers/amlogic/tvin/tvafe/Makefile
deleted file mode 100755
index ad0354f47579..000000000000
--- a/drivers/amlogic/tvin/tvafe/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# Makefile for HDMI RX.
-#
-obj-$(CONFIG_TVIN_AFE) += tvin_afe.o  
-tvin_afe-objs := tvafe_adc.o tvafe_cvd.o tvafe_general.o tvafe.o
-
-obj-$(CONFIG_TVIN_VBI) += tvin_vbi.o
diff --git a/drivers/amlogic/tvin/tvafe/tvafe.c b/drivers/amlogic/tvin/tvafe/tvafe.c
deleted file mode 100755
index 61f565ac87f7..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe.c
+++ /dev/null
@@ -1,1500 +0,0 @@
-/*
- * TVAFE char device driver.
- *
- * Copyright (c) 2010 Bo Yang <bo.yang@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-/* Standard Linux headers */
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/cdev.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/errno.h>
-#include <asm/uaccess.h>
-#include <linux/mutex.h>
-#include <linux/mm.h>
-
-/* Amlogic headers */
-#include <linux/amlogic/amports/canvas.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/amports/vframe.h>
-
-/* Local include */
-#include <linux/amlogic/tvin/tvin.h>
-#include "../tvin_frontend.h"
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "tvafe_regs.h"
-#include "tvafe_adc.h"
-#include "tvafe_cvd.h"
-#include "tvafe_general.h"
-#include "tvafe.h"
-
-#define TVAFE_NAME               "tvafe"
-#define TVAFE_DRIVER_NAME        "tvafe"
-#define TVAFE_MODULE_NAME        "tvafe"
-#define TVAFE_DEVICE_NAME        "tvafe"
-#define TVAFE_CLASS_NAME         "tvafe"
-
-static dev_t                     tvafe_devno;
-static struct class              *tvafe_clsp;
-static bool                      disableapi = 0;
-static bool                      force_stable = false;
-#define TVAFE_TIMER_INTERVAL    (HZ/100)   //10ms, #define HZ 100
-
-
-/*default only one tvafe ,echo cvdfmt pali/palm/ntsc/secam >dir*/
-static ssize_t tvafe_store(struct device *dev, struct device_attribute *attr,const char *buff,size_t count)
-{
-	unsigned char fmt_index = 0;
-
-	struct tvafe_dev_s *devp;
-	devp = dev_get_drvdata(dev);
-
-	if(!strncmp(buff,"cvdfmt",strlen("cvdfmt")))
-	{
-		fmt_index = strlen("cvdfmt") + 1;
-		if(!strncmp(buff+fmt_index,"ntscm",strlen("ntscm")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_NTSC_M;
-		else if(!strncmp(buff+fmt_index,"ntsc443",strlen("ntsc443")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_NTSC_443;
-		else if(!strncmp(buff+fmt_index,"pali",strlen("pali")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_PAL_I;
-		else if(!strncmp(buff+fmt_index,"palm",strlen("plam")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_PAL_M;
-		else if(!strncmp(buff+fmt_index,"pal60",strlen("pal60")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_PAL_60;
-		else if(!strncmp(buff+fmt_index,"palcn",strlen("palcn")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_PAL_CN;
-		else if(!strncmp(buff+fmt_index,"secam",strlen("secam")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_CVBS_SECAM;
-		else if(!strncmp(buff+fmt_index,"null",strlen("null")))
-			devp->tvafe.cvd2.manual_fmt = TVIN_SIG_FMT_NULL;
-		else
-			pr_info("%s:invaild command.",buff);
-	}
-	else if(!strncmp(buff,"disableapi",strlen("disableapi")))
-		disableapi = simple_strtoul(buff+strlen("disableapi")+1,NULL,10);
-    else if(!strncmp(buff,"force_stable",strlen("force_stable")))
-        force_stable = simple_strtoul(buff+strlen("force_stable")+1,NULL,10);
-	else if(!strncmp(buff,"cphasepr",strlen("cphasepr")))
-	        tvafe_adc_comphase_pr();
-        else if(!strncmp(buff,"vdin_bbld",strlen("vdin_bbld"))){
-                tvin_vdin_bbar_init(devp->tvafe.parm.info.fmt);
-                devp->tvafe.adc.vga_auto.phase_state == VGA_VDIN_BORDER_DET;
-        }
-        else if(!strncmp(buff,"pdown",strlen("pdown"))){
-                tvafe_enable_module(false);
-        }
-	else if(!strncmp(buff, "vga_edid",strlen("vga_edid"))){
-		struct tvafe_vga_edid_s edid;
-		int i = 0;
-		tvafe_vga_get_edid(&edid);
-		for(i=0; i<32; i++)
-		{
-        		pr_info("0x%2x 0x%2x 0x%2x 0x%2x 0x%2x 0x%2x 0x%2x 0x%2x.\n", edid.value[(i<<3)+0],
-				edid.value[(i<<3)+1], edid.value[(i<<3)+2], edid.value[(i<<3)+3], edid.value[(i<<3)+4],
-				edid.value[(i<<3)+5], edid.value[(i<<3)+6], edid.value[(i<<3)+7] );
-		}
-	}
-	else if(!strncmp(buff, "tvafe_enable",strlen("tvafe_enable")))
-		{
-			tvafe_enable_module(true);
-			pr_info("[tvafe..]%s:tvafe enable\n",__func__);
-		}
-	else if(!strncmp(buff, "tvafe_down",strlen("tvafe_down")))
-	{
-			tvafe_enable_module(false);
-			pr_info("[tvafe..]%s:tvafe down\n",__func__);
-	}
-	else
-		pr_info("[%s]:invaild command.\n",__func__);
-	return count;
-}
-static ssize_t tvafe_show(struct device *dev,struct device_attribute *attr,char *buff)
-{
-	ssize_t len = 0;
-
-	struct tvafe_dev_s *devp;
-	devp = dev_get_drvdata(dev);
-	switch(devp->tvafe.cvd2.manual_fmt)
-	{
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-			len = sprintf(buff,"cvdfmt:%s.\n","ntscm");
-			break;
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-			len = sprintf(buff,"cvdfmt:%s.\n","ntsc443");
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-			len = sprintf(buff,"cvdfmt:%s.\n","pali");
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-			len = sprintf(buff,"cvdfmt:%s.\n","palm");
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-			len = sprintf(buff,"cvdfmt:%s.\n","pal60");
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-			len = sprintf(buff,"cvdfmt:%s.\n","palcn");
-			break;
-		case TVIN_SIG_FMT_CVBS_SECAM:
-			len = sprintf(buff,"cvdfmt:%s.\n","secam");
-			break;
-		case TVIN_SIG_FMT_NULL:
-			len = sprintf(buff,"cvdfmt:%s.\n","auto");
-		default:
-			len = sprintf(buff,"cvdfmt:%s.\n","invaild command");
-			break;
-
-	}
-	if(disableapi)
-		pr_info("[%s]:diableapi!!!.\n",__func__);
-	return len;
-}
-static DEVICE_ATTR(debug,0644,tvafe_show,tvafe_store);
-/*
-* echo n >/sys/class/tvafe/tvafe0/cvd_reg8a set register of cvd2
-*/
-static ssize_t cvd_reg8a_store(struct device *dev, struct device_attribute *attr,const char *buff,size_t count)
-{
-	unsigned int n;
-	sscanf(buff, "%u", &n);
-	tvafe_cvd2_set_reg8a(n);
-	pr_info("[tvafe..] set register of cvd 0x8a to %u.\n",n);
-	return count;
-}
-static DEVICE_ATTR(cvd_reg8a,0644,NULL,cvd_reg8a_store);
-/*
- * tvafe 10ms timer handler
- */
-void tvafe_timer_handler(unsigned long arg)
-{
-	struct tvafe_dev_s *devp = (struct tvafe_dev_s *)arg;
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-	tvafe_vga_auto_adjust_handler(&tvafe->parm, &tvafe->adc);
-
-	devp->timer.expires = jiffies + TVAFE_TIMER_INTERVAL;
-	add_timer(&devp->timer);
-}
-
-/*
-func:come true the callmaster
-return:false-------no_sig
-	   true-------sig coming
-param:void
-*/
-
- static int tvafe_callmaster_det(enum tvin_port_e port,struct tvin_frontend_s *fe)
-{
-	int ret = 0;
-	struct tvafe_dev_s *devp = container_of(fe,struct tvafe_dev_s,frontend);
-	if(!devp || !(devp->pinmux)){
-		pr_err("[tvafe]%s:devp/pinmux is NULL\n",__func__);
-		return -1;
-	}
-	struct tvafe_pin_mux_s *pinmux = devp->pinmux;
-	switch(port)
-	{
-		case TVIN_PORT_VGA0:
-			if (pinmux->pin[VGA0_SOG] >= TVAFE_ADC_PIN_SOG_0){
-			    if(ret=(int)READ_APB_REG_BITS(ADC_REG_34,4,1))
-				     ret=(int)READ_APB_REG_BITS(ADC_REG_34,7,1);
-			    else
-				ret=0;
-			}
-				//ret=(int)READ_APB_REG_BITS(ADC_REG_2B,(pinmux->pin[VGA0_SOG] - TVAFE_ADC_PIN_SOG_0),1);
-			break;
-		case TVIN_PORT_COMP0:
-			if (pinmux->pin[COMP0_SOG] >= TVAFE_ADC_PIN_SOG_0)
-				ret=(int)READ_APB_REG_BITS(ADC_REG_2B,(pinmux->pin[COMP0_SOG] - TVAFE_ADC_PIN_SOG_0),1);
-			break;
-		case TVIN_PORT_CVBS0:
-			if (pinmux->pin[CVBS0_SOG] >= TVAFE_ADC_PIN_SOG_0)
-				ret=(int)READ_APB_REG_BITS(ADC_REG_2B,(pinmux->pin[CVBS0_SOG] - TVAFE_ADC_PIN_SOG_0),1);
-			break;
-		case TVIN_PORT_CVBS1:
-			if (pinmux->pin[CVBS1_SOG] >= TVAFE_ADC_PIN_SOG_0)
-				ret=(int)READ_APB_REG_BITS(ADC_REG_2B,(pinmux->pin[CVBS1_SOG] - TVAFE_ADC_PIN_SOG_0),1);
-			break;
-		case TVIN_PORT_CVBS2:
-			if (pinmux->pin[CVBS2_SOG] >= TVAFE_ADC_PIN_SOG_0)
-				ret=(int)READ_APB_REG_BITS(ADC_REG_2B,(pinmux->pin[CVBS2_SOG] - TVAFE_ADC_PIN_SOG_0),1);
-			break;
-		case TVIN_PORT_HDMI0:
-			break;
-		case TVIN_PORT_HDMI1:
-			break;
-		case TVIN_PORT_HDMI2:
-			break;
-		case TVIN_PORT_MAX:
-			break;
-		default:
-			break;
-	}
-	//ret=(bool)READ_APB_REG_BITS(ADC_REG_34,1,1);
-	//printk("[%s]:port==%s,ret=%d\n",__func__,tvin_port_str(port),ret);
-	return ret;
-}
-
-
-/*
- * tvafe check support port
- */
-int tvafe_dec_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-
-	/* check afe port and index */
-	if (((port < TVIN_PORT_VGA0) || (port > TVIN_PORT_SVIDEO7)) ||
-			(fe->index != devp->index))
-		return -1;
-
-	return 0;
-}
-
-/*
- * tvafe open port and init register
- */
-int tvafe_dec_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-	mutex_lock(&devp->afe_mutex);
-	if (devp->flags& TVAFE_FLAG_DEV_OPENED)
-	{
-		pr_err("[tvafe..] %s(%d), %s opened already\n", __func__,
-				devp->index, tvin_port_str(port));
-		mutex_unlock(&devp->afe_mutex);
-		return 1;
-	}
-	/* init variable */
-	memset(tvafe, 0, sizeof(struct tvafe_info_s));
-	/**enable and reset tvafe clock**/
-	tvafe_enable_module(true);
-
-    /**set cvd2 reset to high**/
-    tvafe_cvd2_hold_rst(&tvafe->cvd2);
-
-	/* init tvafe registers */
-	tvafe_init_reg(&tvafe->cvd2, &devp->mem, port, devp->pinmux);
-
-	tvafe->parm.port = port;
-
-	/* timer */
-	init_timer(&devp->timer);
-	devp->timer.data = (ulong)devp;
-	devp->timer.function = tvafe_timer_handler;
-	devp->timer.expires = jiffies + (TVAFE_TIMER_INTERVAL);
-	add_timer(&devp->timer);
-
-	/* set the flag to enabble ioctl access */
-	devp->flags|= TVAFE_FLAG_DEV_OPENED;
-	pr_info("[tvafe..] %s open port:0x%x ok.\n", __func__, port);
-
-	mutex_unlock(&devp->afe_mutex);
-	return 0;
-}
-
-/*
- * tvafe start after signal stable
- */
-void tvafe_dec_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = devp->tvafe.parm.port;
-
-	mutex_lock(&devp->afe_mutex);
-	if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-	{
-		pr_err("[tvafe..] tvafe_dec_start(%d) decode havn't opened\n", devp->index);
-		mutex_unlock(&devp->afe_mutex);
-		return;
-	}
-
-	if (devp->flags & TVAFE_FLAG_DEV_STARTED)
-	{
-		pr_err("[tvafe..] %s(%d), %s started already\n", __func__,
-				devp->index, tvin_port_str(port));
-		mutex_unlock(&devp->afe_mutex);
-		return;
-	}
-
-	tvafe->parm.info.fmt = fmt;
-	tvafe->parm.info.status = TVIN_SIG_STATUS_STABLE;
-
-	devp->flags |= TVAFE_FLAG_DEV_STARTED;
-
-	pr_info("[tvafe..] %s start fmt:%s ok.\n", __func__, tvin_sig_fmt_str(fmt));
-
-	mutex_unlock(&devp->afe_mutex);
-}
-
-/*
- * tvafe stop port
- */
-void tvafe_dec_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-	mutex_lock(&devp->afe_mutex);
-	if(!(devp->flags & TVAFE_FLAG_DEV_STARTED))
-	{
-		pr_err("[tvafe..] tvafe_dec_stop(%d) decode havn't started\n", devp->index);
-		mutex_unlock(&devp->afe_mutex);
-		return;
-	}
-
-	/* init variable */
-	memset(&tvafe->adc, 0, sizeof(struct tvafe_adc_s));
-	memset(&tvafe->cal, 0, sizeof(struct tvafe_cal_s));
-	memset(&tvafe->comp_wss, 0, sizeof(struct tvafe_comp_wss_s));
-	memset(&tvafe->cvd2.info, 0, sizeof(struct tvafe_cvd2_info_s));
-	memset(&tvafe->parm.info, 0, sizeof(struct tvin_info_s));
-
-	tvafe->parm.port = port;
-
-	tvafe_adc_digital_reset();
-
-	// need to do ...
-	/** write 7740 register for cvbs clamp **/
-	if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7))
-	{
-		tvafe->cvd2.fmt_loop_cnt = 0;  //reset loop cnt after channel switch
-#ifdef TVAFE_SET_CVBS_PGA_EN
-		tvafe_cvd2_reset_pga();
-#endif
-
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-		tvafe_cvd2_set_default_cdto(&tvafe->cvd2);
-#endif
-		tvafe_cvd2_set_default_de(&tvafe->cvd2);
-	}
-	devp->flags &= (~TVAFE_FLAG_DEV_STARTED);
-
-	pr_info("[tvafe..] %s stop port:0x%x ok.\n", __func__, port);
-
-	mutex_unlock(&devp->afe_mutex);
-}
-
-/*
- * tvafe close port
- */
-void tvafe_dec_close(struct tvin_frontend_s *fe)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-	mutex_lock(&devp->afe_mutex);
-	if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-	{
-		pr_err("[tvafe..] tvafe_dec_close(%d) decode havn't opened\n", devp->index);
-		mutex_unlock(&devp->afe_mutex);
-		return;
-	}
-
-	del_timer_sync(&devp->timer);
-
-	/**set cvd2 reset to high**/
-	tvafe_cvd2_hold_rst(&tvafe->cvd2);
-	/**disable av out**/
-	tvafe_enable_avout(false);
-#ifdef TVAFE_POWERDOWN_IN_IDLE
-	/**disable tvafe clock**/
-	tvafe_enable_module(false);
-#endif
-
-	/* init variable */
-	memset(tvafe, 0, sizeof(struct tvafe_info_s));
-
-	devp->flags &= (~TVAFE_FLAG_DEV_OPENED);
-
-	pr_info("[tvafe..] %s close afe ok.\n", __func__);
-
-	mutex_unlock(&devp->afe_mutex);
-}
-
-/*
- * tvafe vsync interrupt function
- */
-int tvafe_dec_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-        if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-        {
-                pr_err("[tvafe..] tvafe havn't opened, isr error!!!\n");
-                return true;
-        }
-
-        if (force_stable)
-            return 0;
-	/* if there is any error or overflow, do some reset, then rerurn -1;*/
-	if ((tvafe->parm.info.status != TVIN_SIG_STATUS_STABLE) ||
-			(tvafe->parm.info.fmt == TVIN_SIG_FMT_NULL)) {
-		return -1;
-	}
-
-	/* TVAFE CVD2 3D works abnormally => reset cvd2 */
-	if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_CVBS7))
-	{
-		tvafe_cvd2_check_3d_comb(&tvafe->cvd2);
-	}
-
-#ifdef TVAFE_SET_CVBS_PGA_EN
-	if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7))
-	{
-		tvafe_cvd2_adj_pga(&tvafe->cvd2);
-	}
-#endif
-
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-	if (tvafe->parm.info.fmt == TVIN_SIG_FMT_CVBS_PAL_I)
-	{
-		tvafe_cvd2_adj_cdto(&tvafe->cvd2, hcnt64);
-	}
-#endif
-
-	//tvafe_adc_clamp_adjust(devp);
-
-	/* TVAFE vs counter for VGA */
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7))
-	{
-		tvafe_vga_vs_cnt(&tvafe->adc);
-        if(tvafe->adc.vga_auto.phase_state == VGA_VDIN_BORDER_DET){
-                		tvin_vdin_bar_detect(tvafe->parm.info.fmt,&tvafe->adc);
-		}
-
-	}
-
-	/* fetch WSS data must get them during VBI */
-	if ((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7))
-	{
-		tvafe_get_wss_data(&tvafe->comp_wss);
-	}
-
-	return 0;
-}
-
-static struct tvin_decoder_ops_s tvafe_dec_ops = {
-	.support    = tvafe_dec_support,
-	.open       = tvafe_dec_open,
-	.start      = tvafe_dec_start,
-	.stop       = tvafe_dec_stop,
-	.close      = tvafe_dec_close,
-	.decode_isr = tvafe_dec_isr,
-	.callmaster_det = tvafe_callmaster_det,
-};
-
-/*
- * tvafe signal signal status: signal on/off
- */
-bool tvafe_is_nosig(struct tvin_frontend_s *fe)
-{
-	bool ret = false;
-	/* Get the per-device structure that contains this frontend */
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, check no sig error!!!\n");
-        return true;
-    }
-    if (force_stable)
-        return ret;
-
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_COMP7))
-		ret = tvafe_adc_no_sig();
-	else if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7))
-	{
-		ret = tvafe_cvd2_no_sig(&tvafe->cvd2, &devp->mem);
-
-		/* normal sigal & adc reg error, reload source mux */
-		if (tvafe->cvd2.info.adc_reload_en && !ret)
-		{
-			tvafe_set_source_muxing(port, devp->pinmux);
-		}
-	}
-
-	return ret;
-}
-
-/*
- * tvafe signal mode status: change/unchange
- */
-bool tvafe_fmt_chg(struct tvin_frontend_s *fe)
-{
-	bool ret = false;
-	/* Get the per-device structure that contains this frontend */
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, get fmt chg error!!!\n");
-        return true;
-    }
-    if (force_stable)
-        return ret;
-
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_COMP7))
-		ret = tvafe_adc_fmt_chg(&tvafe->parm, &tvafe->adc);
-	else  if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7))
-		ret = tvafe_cvd2_fmt_chg(&tvafe->cvd2);
-
-	return ret;
-}
-
-/*
- * tvafe adc lock status: lock/unlock
- */
-bool tvafe_pll_lock(struct tvin_frontend_s *fe)
-{
-	bool ret = true;
-
-#if 0  //can not trust pll lock status
-	/* Get the per-device structure that contains this frontend */
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_COMP7))
-		ret = tvafe_adc_get_pll_status();
-#endif
-	return (ret);
-}
-
-/*
- * tvafe search format number
- */
-enum tvin_sig_fmt_e tvafe_get_fmt(struct tvin_frontend_s *fe)
-{
-	enum tvin_sig_fmt_e fmt = TVIN_SIG_FMT_NULL;
-	/* Get the per-device structure that contains this frontend */
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, get sig fmt error!!!\n");
-        return fmt;
-    }
-
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_COMP7))
-		fmt = tvafe_adc_search_mode(&tvafe->parm, &tvafe->adc);
-	else  if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7))
-		fmt = tvafe_cvd2_get_format(&tvafe->cvd2);
-
-	tvafe->parm.info.fmt = fmt;
-
-	pr_info("[tvafe..] %s fmt:%s. \n", __func__, tvin_sig_fmt_str(fmt));
-
-	return fmt;
-}
-
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-/*
- * tvafe cvbs video position setting by mode detection
- */
-enum tvin_cvbs_pos_ctl_e tvafe_set_cvbs_fmt_pos(struct tvin_frontend_s *fe)
-{
-	/* Get the per-device structure that contains this frontend */
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_cvbs_pos_ctl_e cvbs_pos_ctl = TVIN_CVBS_POS_NULL;
-
-	cvbs_pos_ctl = tvafe_cvd2_set_pos(&tvafe->cvd2);
-
-	return (cvbs_pos_ctl);
-}
-#endif
-
-/*
- * tvafe signal property: 2D/3D, color format, aspect ratio, pixel repeat
- */
-void tvafe_get_sig_property(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-	prop->trans_fmt = TVIN_TFMT_2D;
-	if ((port >= TVIN_PORT_VGA0) &&
-			(port <= TVIN_PORT_VGA7))
-		prop->color_format = TVIN_RGB444;
-	else
-		prop->color_format = TVIN_YUV444;
-	prop->aspect_ratio = TVIN_ASPECT_NULL;
-	prop->pixel_repeat = 0;
-	prop->dvi_info = 0;
-}
-/*
- *get cvbs secam source's phase
- */
-static bool tvafe_cvbs_get_secam_phase(struct tvin_frontend_s *fe)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-	if(tvafe->cvd2.config_fmt == TVIN_SIG_FMT_CVBS_SECAM)
-		return tvafe->cvd2.hw.secam_phase;
-	else
-		return 0;
-
-}
-
-/*
- * tvafe set vga parameters: h/v position, phase, clock
- */
-void tvafe_vga_set_parm(struct tvafe_vga_parm_s *vga_parm, struct tvin_frontend_s *fe)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, vga parm error!!!\n");
-        return;
-    }
-
-	if(vga_parm == 0)
-		tvafe_adc_set_param(&tvafe->parm, &tvafe->adc);
-	else
-		tvafe_adc_set_deparam(&tvafe->parm, &tvafe->adc);
-}
-
-/*
- * tvafe get vga parameters: h/v position, phase, clock
- */
-void tvafe_vga_get_parm(struct tvafe_vga_parm_s *vga_parm, struct tvin_frontend_s *fe)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	struct tvafe_vga_parm_s *parm = &tvafe->adc.vga_parm;
-
-	vga_parm->clk_step     = parm->clk_step;
-	vga_parm->phase        = parm->phase;
-	vga_parm->hpos_step    = parm->hpos_step;
-	vga_parm->vpos_step    = parm->vpos_step;
-	vga_parm->vga_in_clean = parm->vga_in_clean;
-}
-
-/*
- * tvafe configure format Reg table
- */
-void tvafe_fmt_config(struct tvin_frontend_s *fe)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, config fmt error!!!\n");
-        return;
-    }
-
-	/*store the current fmt avoid configuration again*/
-	if(tvafe->adc.current_fmt != tvafe->parm.info.fmt)
-		tvafe->adc.current_fmt = tvafe->parm.info.fmt;
-	else
-	{
-		pr_info("[tvafe..] %s,no use to config fmt:%s.\n",__func__, tvin_sig_fmt_str(tvafe->parm.info.fmt));
-		return;
-	}
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7))
-	{
-		tvafe_set_vga_fmt(&tvafe->parm, &tvafe->cal, devp->pinmux);
-		pr_info("[tvafe..] %s, config fmt:%s. \n", __func__, tvin_sig_fmt_str(tvafe->parm.info.fmt));
-	}
-	else if ((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7))
-	{
-		tvafe_set_comp_fmt(&tvafe->parm, &tvafe->cal, devp->pinmux);
-		pr_info("[tvafe..] %s, config fmt:%s. \n", __func__, tvin_sig_fmt_str(tvafe->parm.info.fmt));
-	}
-}
-
-/*
- * tvafe calibration function called by vdin state machine
- */
-bool tvafe_cal(struct tvin_frontend_s *fe)
-{
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, calibration error!!!\n");
-        return false;
-    }
-
-	return tvafe_adc_cal(&tvafe->parm, &tvafe->cal);
-}
-
-/*
- * tvafe skip some frame after adjusting vga parameter to avoid picture flicker
- */
-bool tvafe_check_frame_skip(struct tvin_frontend_s *fe)
-{
-	bool ret = false;
-	struct tvafe_dev_s *devp = container_of(fe, struct tvafe_dev_s, frontend);
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-
-
-    if(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-    {
-        pr_err("[tvafe..] tvafe havn't opened, check frame error!!!\n");
-        return ret;
-    }
-
-	if (((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7)) ||
-			((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7))) {
-		ret = tvafe_adc_check_frame_skip(&tvafe->adc);
-	}
-
-	return ret;
-}
-
-static struct tvin_state_machine_ops_s tvafe_sm_ops = {
-	.nosig            = tvafe_is_nosig,
-	.fmt_changed      = tvafe_fmt_chg,
-	.get_fmt          = tvafe_get_fmt,
-	.fmt_config       = tvafe_fmt_config,
-	.adc_cal          = tvafe_cal,
-	.pll_lock         = tvafe_pll_lock,
-	.get_sig_propery  = tvafe_get_sig_property,
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-	.set_cvbs_fmt_pos = tvafe_set_cvbs_fmt_pos,
-#endif
-	.vga_set_param    = tvafe_vga_set_parm,
-	.vga_get_param    = tvafe_vga_get_parm,
-	.check_frame_skip = tvafe_check_frame_skip,
-	.get_secam_phase = tvafe_cvbs_get_secam_phase,
-};
-
-static int tvafe_open(struct inode *inode, struct file *file)
-{
-	tvafe_dev_t *devp;
-
-	/* Get the per-device structure that contains this cdev */
-	devp = container_of(inode->i_cdev, tvafe_dev_t, cdev);
-	file->private_data = devp;
-
-	/* ... */
-
-	pr_info("[tvafe..] %s: open device \n", __FUNCTION__);
-
-	return 0;
-}
-
-static int tvafe_release(struct inode *inode, struct file *file)
-{
-	tvafe_dev_t *devp = file->private_data;
-
-	file->private_data = NULL;
-
-	/* Release some other fields */
-	/* ... */
-
-	pr_info("[tvafe..] tvafe: device %d release ok.\n", devp->index);
-
-	return 0;
-}
-
-
-static long tvafe_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	long ret = 0;
-	unsigned char i,j;
-	void __user *argp = (void __user *)arg;
-	struct tvafe_dev_s *devp = file->private_data;
-	struct tvafe_info_s *tvafe = &devp->tvafe;
-	enum tvin_port_e port = tvafe->parm.port;
-	enum tvin_sig_fmt_e fmt = tvafe->parm.info.fmt;
-	struct tvafe_vga_edid_s edid;
-	enum tvafe_cvbs_video_e cvbs_lock_status = TVAFE_CVBS_VIDEO_HV_UNLOCKED;
-
-	if (_IOC_TYPE(cmd) != TVIN_IOC_MAGIC) {
-		pr_err("%s invalid command: %u\n", __func__, cmd);
-		return -ENOSYS;
-	}
-
-	//pr_info("[tvafe..] %s command: %u\n", __func__, cmd);
-	if(disableapi)
-		return -ENOSYS;
-	mutex_lock(&devp->afe_mutex);
-
-	/* EDID command !!! */
-	if (((cmd != TVIN_IOC_S_AFE_VGA_EDID) && (cmd != TVIN_IOC_G_AFE_VGA_EDID)) &&
-			(!(devp->flags & TVAFE_FLAG_DEV_OPENED))
-	   )
-	{
-		pr_info("[tvafe..] %s, tvafe device is disable, ignore the command %d\n", __func__, cmd);
-		mutex_unlock(&devp->afe_mutex);
-		return -EPERM;
-	}
-
-	switch (cmd)
-	{
-		case TVIN_IOC_S_AFE_ADC_CAL:
-			if (copy_from_user(&tvafe->cal.cal_val, argp, sizeof(struct tvafe_adc_cal_s)))
-			{
-				ret = -EFAULT;
-				break;
-			}
-
-			tvafe->cal.cal_val.reserved |= TVAFE_ADC_CAL_VALID;
-			tvafe_vga_auto_adjust_disable(&tvafe->adc);
-			if ((port >= TVIN_PORT_COMP0) &&(port <= TVIN_PORT_COMP7))
-			{
-#if defined(CONFIG_MACH_MESON6TV_H40)
-			if((fmt>=TVIN_SIG_FMT_COMP_1080P_23HZ_D976)&&(fmt<=TVIN_SIG_FMT_COMP_1080P_60HZ_D000))
-				{
-				tvafe->cal.cal_val.c_analog_clamp -= 1;
-				}
-			else if((fmt>=TVIN_SIG_FMT_COMP_1080I_47HZ_D952)&&(fmt<=TVIN_SIG_FMT_COMP_1080I_60HZ_D000))
-				{
-				;
-				}
-			else if(fmt==TVIN_SIG_FMT_COMP_720P_59HZ_D940)
-				{
-				tvafe->cal.cal_val.b_analog_clamp += 1;
-				}
-			else if(fmt==TVIN_SIG_FMT_COMP_720P_50HZ_D000)
-				{
-				tvafe->cal.cal_val.b_analog_clamp += 1;
-				tvafe->cal.cal_val.c_analog_clamp += 1;
-				}
-			else
-				{
-			//	tvafe->cal.cal_val.a_analog_clamp += 2;
-				tvafe->cal.cal_val.b_analog_clamp += 1;
-				tvafe->cal.cal_val.c_analog_clamp += 2;
-				}
-#else
-				//if((fmt>=TVIN_SIG_FMT_COMP_1080P_23HZ_D976)&&(fmt<=TVIN_SIG_FMT_COMP_1080P_60HZ_D000))
-				//	tvafe->cal.cal_val.a_analog_clamp += 4;
-				//else if((fmt>=TVIN_SIG_FMT_COMP_1080I_47HZ_D952)&&(fmt<=TVIN_SIG_FMT_COMP_1080I_60HZ_D000))
-				//	tvafe->cal.cal_val.a_analog_clamp += 3;
-				//else
-				//	tvafe->cal.cal_val.a_analog_clamp += 2;
-				tvafe->cal.cal_val.b_analog_clamp += 1;
-				tvafe->cal.cal_val.c_analog_clamp += 1;
-#endif
-			}
-
-			else if((port >= TVIN_PORT_VGA0) &&(port <= TVIN_PORT_VGA7))
-			{
-
-				//tvafe->cal.cal_val.a_analog_clamp += 2;
-				tvafe->cal.cal_val.b_analog_clamp += 1;
-				tvafe->cal.cal_val.c_analog_clamp += 1;
-			}
-			//pr_info("\nNot allow to use TVIN_IOC_S_AFE_ADC_CAL command!!!\n\n");
-			tvafe_set_cal_value(&tvafe->cal);
-#ifdef LOG_ADC_CAL
-			pr_info("\nset_adc_cal\n");
-			pr_info("A_cl = %4d %4d %4d\n",  (int)(tvafe->cal.cal_val.a_analog_clamp),
-					(int)(tvafe->cal.cal_val.b_analog_clamp),
-					(int)(tvafe->cal.cal_val.c_analog_clamp));
-			pr_info("A_gn = %4d %4d %4d\n",  (int)(tvafe->cal.cal_val.a_analog_gain),
-					(int)(tvafe->cal.cal_val.b_analog_gain),
-					(int)(tvafe->cal.cal_val.c_analog_gain));
-			pr_info("D_gn = %4d %4d %4d\n",  (int)(tvafe->cal.cal_val.a_digital_gain),
-					(int)(tvafe->cal.cal_val.b_digital_gain),
-					(int)(tvafe->cal.cal_val.c_digital_gain));
-			pr_info("D_o1 = %4d %4d %4d\n", ((int)(tvafe->cal.cal_val.a_digital_offset1) << 21) >> 21,
-					((int)(tvafe->cal.cal_val.b_digital_offset1) << 21) >> 21,
-					((int)(tvafe->cal.cal_val.c_digital_offset1) << 21) >> 21);
-			pr_info("D_o2 = %4d %4d %4d\n", ((int)(tvafe->cal.cal_val.a_digital_offset2) << 21) >> 21,
-					((int)(tvafe->cal.cal_val.b_digital_offset2) << 21) >> 21,
-					((int)(tvafe->cal.cal_val.c_digital_offset2) << 21) >> 21);
-			pr_info("\n");
-#endif
-
-			break;
-
-		case TVIN_IOC_G_AFE_ADC_CAL:
-			{
-				ret = tvafe_get_cal_value(&tvafe->cal);
-#ifdef LOG_ADC_CAL
-				pr_info("\nget_adc_cal\n");
-				pr_info("A_cl = %4d %4d %4d\n",  (int)(tvafe->cal.cal_val.a_analog_clamp),
-						(int)(tvafe->cal.cal_val.b_analog_clamp),
-						(int)(tvafe->cal.cal_val.c_analog_clamp));
-				pr_info("A_gn = %4d %4d %4d\n",  (int)(tvafe->cal.cal_val.a_analog_gain),
-						(int)(tvafe->cal.cal_val.b_analog_gain),
-						(int)(tvafe->cal.cal_val.c_analog_gain));
-				pr_info("D_gn = %4d %4d %4d\n",  (int)(tvafe->cal.cal_val.a_digital_gain),
-						(int)(tvafe->cal.cal_val.b_digital_gain),
-						(int)(tvafe->cal.cal_val.c_digital_gain));
-				pr_info("D_o1 = %4d %4d %4d\n", ((int)(tvafe->cal.cal_val.a_digital_offset1) << 21) >> 21,
-						((int)(tvafe->cal.cal_val.b_digital_offset1) << 21) >> 21,
-						((int)(tvafe->cal.cal_val.c_digital_offset1) << 21) >> 21);
-				pr_info("D_o2 = %4d %4d %4d\n", ((int)(tvafe->cal.cal_val.a_digital_offset2) << 21) >> 21,
-						((int)(tvafe->cal.cal_val.b_digital_offset2) << 21) >> 21,
-						((int)(tvafe->cal.cal_val.c_digital_offset2) << 21) >> 21);
-				pr_info("\n");
-#endif
-				if(ret)
-				{
-					ret = -EFAULT;
-					pr_info("[tvafe..] %s, the command %d error,adc calibriation error.\n", __func__, cmd);
-					break;
-				}
-				if (copy_to_user(argp, &tvafe->cal.cal_val, sizeof(struct tvafe_adc_cal_s)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-
-				break;
-			}
-		case TVIN_IOC_G_AFE_COMP_WSS:
-			{
-				if (copy_to_user(argp, &tvafe->comp_wss, sizeof(struct tvafe_comp_wss_s)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-				break;
-			}
-		case TVIN_IOC_S_AFE_VGA_EDID:
-			{
-				if (copy_from_user(&edid, argp, sizeof(struct tvafe_vga_edid_s)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-#ifdef LOG_VGA_EDID
-				for(i=0; i<32; i++)
-				{
-					pr_info("0x%2x 0x%2x 0x%2x 0x%2x 0x%2x 0x%2x 0x%2x 0x%2x.\n", edid.value[(i<<3)+0],
-							edid.value[(i<<3)+1], edid.value[(i<<3)+2], edid.value[(i<<3)+3], edid.value[(i<<3)+4],
-							edid.value[(i<<3)+5], edid.value[(i<<3)+6], edid.value[(i<<3)+7] );
-				}
-#endif
-				tvafe_vga_set_edid(&edid);
-
-				break;
-			}
-		case TVIN_IOC_G_AFE_VGA_EDID:
-			{
-				tvafe_vga_get_edid(&edid);
-				if (copy_to_user(argp, &edid, sizeof(struct tvafe_vga_edid_s)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-				break;
-			}
-		case TVIN_IOC_S_AFE_VGA_PARM:
-			{
-				if (copy_from_user(&tvafe->adc.vga_parm, argp, sizeof(struct tvafe_vga_parm_s)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-				tvafe_vga_auto_adjust_disable(&tvafe->adc);
-
-				break;
-			}
-		case TVIN_IOC_G_AFE_VGA_PARM:
-			{
-				if (copy_to_user(argp, &tvafe->adc.vga_parm, sizeof(struct tvafe_vga_parm_s)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-				break;
-			}
-		case TVIN_IOC_S_AFE_VGA_AUTO:
-			{
-				ret = tvafe_vga_auto_adjust_enable(&tvafe->adc);
-				break;
-			}
-		case TVIN_IOC_G_AFE_CMD_STATUS:
-			{
-				if (copy_to_user(argp, &tvafe->adc.cmd_status, sizeof(enum tvafe_cmd_status_e)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-				if ((tvafe->adc.cmd_status == TVAFE_CMD_STATUS_SUCCESSFUL) ||
-						(tvafe->adc.cmd_status == TVAFE_CMD_STATUS_FAILED)     ||
-						(tvafe->adc.cmd_status == TVAFE_CMD_STATUS_TERMINATED))
-				{
-					tvafe->adc.cmd_status = TVAFE_CMD_STATUS_IDLE;
-				}
-
-				break;
-			}
-		case TVIN_IOC_G_AFE_CVBS_LOCK:
-			{
-				cvbs_lock_status = tvafe_cvd2_get_lock_status(&tvafe->cvd2);
-				if (copy_to_user(argp, &cvbs_lock_status, sizeof(int)))
-				{
-					ret = -EFAULT;
-					break;
-				}
-				pr_info("[tvafe..] %s: get cvd2 lock status :%d. \n", __func__, cvbs_lock_status);
-				break;
-			}
-		case TVIN_IOC_S_AFE_CVBS_STD:
-			{
-				enum tvin_sig_fmt_e fmt = TVIN_SIG_FMT_NULL;
-
-				if (copy_from_user(&fmt, argp, sizeof(enum tvin_sig_fmt_e))) {
-					ret = -EFAULT;
-					break;
-				}
-				tvafe->cvd2.manual_fmt = fmt;
-				pr_info("[tvafe..] %s: ioctl set cvd2 manual fmt:%s. \n", __func__, tvin_sig_fmt_str(fmt));
-				break;
-			}
-	case TVIN_IOC_S_AFE_ADC_COMP_CAL:
-			memset(&tvafe->cal.fmt_cal_val, 0, sizeof(struct tvafe_adc_comp_cal_s));
-            if (copy_from_user(&tvafe->cal.fmt_cal_val, argp, sizeof(struct tvafe_adc_comp_cal_s)))
-            {
-                ret = -EFAULT;
-                break;
-            }
-
-            tvafe->cal.fmt_cal_val.comp_cal_val[0].reserved |= TVAFE_ADC_CAL_VALID;
-            tvafe->cal.fmt_cal_val.comp_cal_val[1].reserved |= TVAFE_ADC_CAL_VALID;
-            tvafe->cal.fmt_cal_val.comp_cal_val[2].reserved |= TVAFE_ADC_CAL_VALID;
-
-            tvafe_vga_auto_adjust_disable(&tvafe->adc);
-            //pr_info("\nNot allow to use TVIN_IOC_S_AFE_ADC_CAL command!!!\n\n");
-            if(fmt >= TVIN_SIG_FMT_COMP_1080P_23HZ_D976 && fmt <= TVIN_SIG_FMT_COMP_1080P_60HZ_D000){
-				//1080p
-				tvafe->cal.fmt_cal_val.comp_cal_val[0].a_analog_clamp -= 2;
-	   			tvafe_set_cal_value2(&(tvafe->cal.fmt_cal_val.comp_cal_val[0]));
-				i = 0;
-			}else if((fmt >= TVIN_SIG_FMT_COMP_720P_59HZ_D940 && fmt <= TVIN_SIG_FMT_COMP_720P_50HZ_D000)
-					|| (fmt >= TVIN_SIG_FMT_COMP_1080I_47HZ_D952 && fmt <= TVIN_SIG_FMT_COMP_1080I_60HZ_D000)){
-				//720p,1080i
-				tvafe->cal.fmt_cal_val.comp_cal_val[1].b_analog_clamp += 1;
-				tvafe_set_cal_value2(&(tvafe->cal.fmt_cal_val.comp_cal_val[1]));
-				i = 1;
-			}else{
-				//480p,576p,480i,576i
-				tvafe->cal.fmt_cal_val.comp_cal_val[2].c_analog_clamp += 1;
-				tvafe_set_cal_value2(&(tvafe->cal.fmt_cal_val.comp_cal_val[2]));
-				i = 2;
-			}
-            #ifdef LOG_ADC_CAL
-			pr_info("\nset_adc_cal:comp[%d]\n",i);
-					pr_info("A_cl = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].a_analog_clamp),
-													 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].b_analog_clamp),
-													 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].c_analog_clamp));
-					pr_info("A_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].a_analog_gain),
-													 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].b_analog_gain),
-													 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].c_analog_gain));
-					pr_info("D_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].a_digital_gain),
-													 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].b_digital_gain),
-													 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].c_digital_gain));
-					pr_info("D_o1 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].a_digital_offset1) << 21) >> 21,
-													((int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].b_digital_offset1) << 21) >> 21,
-													((int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].c_digital_offset1) << 21) >> 21);
-					pr_info("D_o2 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].a_digital_offset2) << 21) >> 21,
-													((int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].b_digital_offset2) << 21) >> 21,
-													((int)(tvafe->cal.fmt_cal_val.comp_cal_val[i].c_digital_offset2) << 21) >> 21);
-					pr_info("\n");
-
-            #endif
-
-            break;
-
-        case TVIN_IOC_G_AFE_ADC_COMP_CAL:
-        {
-            #ifdef LOG_ADC_CAL
-
-				pr_info("\nget_adc_cal:comp[0]\n");
-                pr_info("A_cl = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].a_analog_clamp),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].b_analog_clamp),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].c_analog_clamp));
-                pr_info("A_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].a_analog_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].b_analog_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].c_analog_gain));
-                pr_info("D_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].a_digital_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].b_digital_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].c_digital_gain));
-                pr_info("D_o1 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].a_digital_offset1) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].b_digital_offset1) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].c_digital_offset1) << 21) >> 21);
-                pr_info("D_o2 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].a_digital_offset2) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].b_digital_offset2) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[0].c_digital_offset2) << 21) >> 21);
-                pr_info("\n");
-
-				pr_info("\nget_adc_cal:comp[1]\n");
-                pr_info("A_cl = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].a_analog_clamp),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].b_analog_clamp),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].c_analog_clamp));
-                pr_info("A_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].a_analog_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].b_analog_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].c_analog_gain));
-                pr_info("D_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].a_digital_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].b_digital_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].c_digital_gain));
-                pr_info("D_o1 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].a_digital_offset1) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].b_digital_offset1) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].c_digital_offset1) << 21) >> 21);
-                pr_info("D_o2 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].a_digital_offset2) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].b_digital_offset2) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[1].c_digital_offset2) << 21) >> 21);
-                pr_info("\n");
-
-				pr_info("\nget_adc_cal:comp[2]\n");
-                pr_info("A_cl = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].a_analog_clamp),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].b_analog_clamp),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].c_analog_clamp));
-                pr_info("A_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].a_analog_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].b_analog_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].c_analog_gain));
-                pr_info("D_gn = %4d %4d %4d\n",  (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].a_digital_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].b_digital_gain),
-                                                 (int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].c_digital_gain));
-                pr_info("D_o1 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].a_digital_offset1) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].b_digital_offset1) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].c_digital_offset1) << 21) >> 21);
-                pr_info("D_o2 = %4d %4d %4d\n", ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].a_digital_offset2) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].b_digital_offset2) << 21) >> 21,
-                                                ((int)(tvafe->cal.fmt_cal_val.comp_cal_val[2].c_digital_offset2) << 21) >> 21);
-                pr_info("\n");
-            #endif
-
-            if(ret)
-            {
-                ret = -EFAULT;
-                pr_info("[tvafe..] %s, the command %d error,adc calibriation error.\n", __func__, cmd);
-                break;
-            }
-            if (copy_to_user(argp, &tvafe->cal.fmt_cal_val, sizeof(struct tvafe_adc_comp_cal_s)))
-            {
-                ret = -EFAULT;
-                break;
-            }
-            break;
-        }
-		default:
-			ret = -ENOIOCTLCMD;
-			break;
-	}
-
-	mutex_unlock(&devp->afe_mutex);
-	return ret;
-}
-
-static int tvafe_mmap(struct file *file, struct vm_area_struct * vma)
-{
-	unsigned long start, len, off;
-	unsigned long pfn, size;
-	tvafe_dev_t *devp = file->private_data;
-
-	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
-		return -EINVAL;
-	}
-
-	/* capture the vbi data  */
-	start = (devp->mem.start + (DECODER_VBI_ADDR_OFFSET << 3)) & PAGE_MASK;
-	len = PAGE_ALIGN((start & ~PAGE_MASK) + (DECODER_VBI_VBI_SIZE << 3));
-
-	off = vma->vm_pgoff << PAGE_SHIFT;
-
-	if ((vma->vm_end - vma->vm_start + off) > len) {
-		return -EINVAL;
-	}
-
-	off += start;
-	vma->vm_pgoff = off >> PAGE_SHIFT;
-
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-	vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
-
-	size = vma->vm_end - vma->vm_start;
-	pfn  = off >> PAGE_SHIFT;
-
-	if (io_remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot))
-		return -EAGAIN;
-
-	return 0;
-}
-
-/* File operations structure. Defined in linux/fs.h */
-static struct file_operations tvafe_fops = {
-	.owner   = THIS_MODULE,         /* Owner */
-	.open    = tvafe_open,          /* Open method */
-	.release = tvafe_release,       /* Release method */
-	.unlocked_ioctl   = tvafe_ioctl,         /* Ioctl method */
-	.mmap    = tvafe_mmap,
-	/* ... */
-};
-
-static int tvafe_add_cdev(struct cdev *cdevp, struct file_operations *fops,
-		int minor)
-{
-	int ret;
-	dev_t devno = MKDEV(MAJOR(tvafe_devno), minor);
-	cdev_init(cdevp, fops);
-	cdevp->owner = THIS_MODULE;
-	ret = cdev_add(cdevp, devno, 1);
-	return ret;
-}
-
-static struct device * tvafe_create_device(struct device *parent, int id)
-{
-	dev_t devno = MKDEV(MAJOR(tvafe_devno),  id);
-	return device_create(tvafe_clsp, parent, devno, NULL, "%s0",
-			TVAFE_DEVICE_NAME);
-	/* @to do this after Middleware API modified */
-	/*return device_create(tvafe_clsp, parent, devno, NULL, "%s",
-	  TVAFE_DEVICE_NAME); */
-}
-
-static void tvafe_delete_device(int minor)
-{
-	dev_t devno = MKDEV(MAJOR(tvafe_devno), minor);
-	device_destroy(tvafe_clsp, devno);
-}
-
-static int tvafe_drv_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct tvafe_dev_s *tdevp;
-	struct resource *res;
-	//struct tvin_frontend_s * frontend;
-
-	/* allocate memory for the per-device structure */
-	tdevp = kmalloc(sizeof(struct tvafe_dev_s), GFP_KERNEL);
-	if (!tdevp){
-		pr_err("tvafe: failed to allocate memory for tvafe device\n");
-		goto fail_kmalloc_tdev;
-	}
-	memset(tdevp, 0, sizeof(struct tvafe_dev_s));
-
-	/*@to get from bsp*/
-	if(pdev->id == -1){
-		tdevp->index = 0;
-	}
-	else{
-		pr_err("%s: failed to get device id\n", __func__);
-		goto fail_get_id;
-	}
-	tdevp->flags = 0;
-
-	/* create cdev and reigser with sysfs */
-	ret = tvafe_add_cdev(&tdevp->cdev, &tvafe_fops, tdevp->index);
-	if (ret) {
-		pr_err("%s: failed to add cdev\n", __func__);
-		goto fail_add_cdev;
-	}
-	/* create /dev nodes */
-	tdevp->dev = tvafe_create_device(&pdev->dev, tdevp->index);
-	if (IS_ERR(tdevp->dev)) {
-		pr_err("tvafe: failed to create device node\n");
-		/* @todo do with error */
-		ret = PTR_ERR(tdevp->dev);
-		goto fail_create_device;
-	}
-
-	/*create sysfs attribute files*/
-	ret = device_create_file(tdevp->dev,&dev_attr_debug);
-	ret = device_create_file(tdevp->dev,&dev_attr_cvd_reg8a);
-	if(ret < 0) {
-		pr_err("tvafe: fail to create dbg attribute file\n");
-		goto fail_create_dbg_file;
-	}
-
-	/* get device memory */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		pr_err("tvafe: can't get memory resource\n");
-		ret = -EFAULT;
-		goto fail_get_resource_mem;
-	}
-
-	tdevp->mem.start = res->start;
-	tdevp->mem.size = res->end - res->start + 1;
-	pr_info(" tvafe cvd memory addr is:0x%x, cvd mem_size is:0x%x . \n",
-			tdevp->mem.start,
-			tdevp->mem.size);
-	tdevp->pinmux = pdev->dev.platform_data;
-	if (!tdevp->pinmux) {
-		pr_err("tvafe: no platform data!\n");
-		ret = -ENODEV;
-	}
-
-	/* frontend */
-	tvin_frontend_init(&tdevp->frontend, &tvafe_dec_ops, &tvafe_sm_ops, tdevp ->index);
-	sprintf(tdevp->frontend.name, "%s", TVAFE_NAME);
-	tvin_reg_frontend(&tdevp->frontend);
-
-	mutex_init(&tdevp->afe_mutex);
-
-	/* set APB bus register accessing error exception */
-	tvafe_set_apb_bus_err_ctrl();
-	dev_set_drvdata(tdevp->dev, tdevp);
-        platform_set_drvdata(pdev,tdevp);
-
-    /**disable tvafe clock**/
-    tvafe_enable_module(false);
-
-	pr_info("tvafe: driver probe ok\n");
-	return 0;
-
-fail_create_dbg_file:
-fail_get_resource_mem:
-	tvafe_delete_device(tdevp->index);
-fail_create_device:
-	cdev_del(&tdevp->cdev);
-fail_add_cdev:
-fail_get_id:
-	kfree(tdevp);
-fail_kmalloc_tdev:
-	return ret;
-
-}
-
-static int tvafe_drv_remove(struct platform_device *pdev)
-{
-	struct tvafe_dev_s *tdevp;
-	tdevp = platform_get_drvdata(pdev);
-
-	mutex_destroy(&tdevp->afe_mutex);
-	tvin_unreg_frontend(&tdevp->frontend);
-	device_remove_file(tdevp->dev, &dev_attr_debug);
-	tvafe_delete_device(tdevp->index);
-	cdev_del(&tdevp->cdev);
-	kfree(tdevp);
-	pr_info("tvafe: driver removed ok.\n");
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int tvafe_drv_suspend(struct platform_device *pdev,pm_message_t state)
-{
-	struct tvafe_dev_s *tdevp;
-	tdevp = platform_get_drvdata(pdev);
-
-	/* close afe port first */
-    if (tdevp->flags & TVAFE_FLAG_DEV_OPENED)
-    {
-        pr_info("tvafe: suspend module, close afe port first\n");
-        //tdevp->flags &= (~TVAFE_FLAG_DEV_OPENED);
-        del_timer_sync(&tdevp->timer);
-
-        /**set cvd2 reset to high**/
-        tvafe_cvd2_hold_rst(&tdevp->tvafe.cvd2);
-        /**disable av out**/
-        tvafe_enable_avout(false);
-    }
-
-    /*disable and reset tvafe clock*/
-    tvafe_enable_module(false);
-
-    pr_info("tvafe: suspend module\n");
-
-	return 0;
-}
-
-static int tvafe_drv_resume(struct platform_device *pdev)
-{
-	struct tvafe_dev_s *tdevp;
-	tdevp = platform_get_drvdata(pdev);
-
-        /*disable and reset tvafe clock*/
-        tvafe_enable_module(true);
-	pr_info("tvafe: resume module\n");
-	return 0;
-}
-#endif
-
-static struct platform_driver tvafe_driver = {
-	.probe      = tvafe_drv_probe,
-	.remove     = tvafe_drv_remove,
-#ifdef CONFIG_PM
-	.suspend    = tvafe_drv_suspend,
-	.resume     = tvafe_drv_resume,
-#endif
-	.driver     = {
-		.name   = TVAFE_DRIVER_NAME,
-	}
-};
-
-static int __init tvafe_drv_init(void)
-{
-	int ret = 0;
-
-	ret = alloc_chrdev_region(&tvafe_devno, 0, 1, TVAFE_NAME);
-	if (ret < 0) {
-		pr_err("%s: failed to allocate major number\n", __func__);
-		goto fail_alloc_cdev_region;
-	}
-	pr_info("%s: major %d\n", __func__, MAJOR(tvafe_devno));
-
-	tvafe_clsp = class_create(THIS_MODULE, TVAFE_NAME);
-	if (IS_ERR(tvafe_clsp))
-	{
-		ret = PTR_ERR(tvafe_clsp);
-		pr_err("%s: failed to create class\n", __func__);
-		goto fail_class_create;
-	}
-
-	ret = platform_driver_register(&tvafe_driver);
-	if (ret != 0) {
-		pr_err("%s: failed to register driver\n", __func__);
-		goto fail_pdrv_register;
-	}
-	pr_info("tvafe: tvafe_init.\n");
-	return 0;
-
-fail_pdrv_register:
-	class_destroy(tvafe_clsp);
-fail_class_create:
-	unregister_chrdev_region(tvafe_devno, 1);
-fail_alloc_cdev_region:
-	return ret;
-
-
-}
-
-static void __exit tvafe_drv_exit(void)
-{
-	class_destroy(tvafe_clsp);
-	unregister_chrdev_region(tvafe_devno, 1);
-	platform_driver_unregister(&tvafe_driver);
-	pr_info("tvafe: tvafe_exit.\n");
-}
-
-module_init(tvafe_drv_init);
-module_exit(tvafe_drv_exit);
-
-MODULE_DESCRIPTION("AMLOGIC TVAFE driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Xu Lin <lin.xu@amlogic.com>");
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe.h b/drivers/amlogic/tvin/tvafe/tvafe.h
deleted file mode 100755
index a304cc8d72d7..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*******************************************************************
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *  File name: tvafe.h
- *  Description: IO function, structure, enum, used in TVIN AFE sub-module processing
- *******************************************************************/
-
-#ifndef _TVAFE_H
-#define _TVAFE_H
-
-/* Standard Linux Headers */
-#include <linux/cdev.h>
-#include <linux/timer.h>
-#include <linux/mutex.h>
-
-#include <linux/amlogic/tvin/tvin.h>
-#include "../tvin_global.h"
-#include "../tvin_frontend.h"
-#include "tvafe_general.h"   /* For Kernel used only */
-#include "tvafe_adc.h"       /* For Kernel used only */
-#include "tvafe_cvd.h"       /* For Kernel used only */
-
-// ***************************************************************************
-// *** macro definitions *********************************************
-// ***************************************************************************
-
-/* used to set the flag of tvafe_dev_s */
-#define TVAFE_FLAG_DEV_OPENED       0x00000010
-#define TVAFE_FLAG_DEV_STARTED      0x00000020
-#define TVAFE_POWERDOWN_IN_IDLE
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-
-// ***************************************************************************
-// *** structure definitions *********************************************
-// ***************************************************************************
-
-/* tvafe module structure */
-typedef struct tvafe_info_s {
-	struct tvin_parm_s          parm;
-
-	//adc calibration data
-	struct tvafe_cal_s          cal;
-
-	/* WSS data */
-	struct tvafe_comp_wss_s     comp_wss;    //WSS data;
-
-	struct tvafe_adc_s          adc;
-	struct tvafe_cvd2_s         cvd2;
-} tvafe_info_t;
-
-/* tvafe device structure */
-typedef struct tvafe_dev_s {
-	int                         index;
-
-	dev_t                       devt;
-	struct cdev                 cdev;
-	struct device               *dev;
-
-
-	struct mutex                afe_mutex;
-	struct timer_list           timer;
-
-	struct tvin_frontend_s      frontend;
-	unsigned int                flags;        // bit4: TVAFE_FLAG_DEV_OPENED
-	// bit5: TVAFE_FLAG_DEV_STARTED
-	struct tvafe_pin_mux_s      *pinmux;      //pin mux setting from board config
-	/* cvd2 memory */
-	struct tvafe_cvd2_mem_s     mem;
-
-	struct tvafe_info_s         tvafe;
-
-} tvafe_dev_t;
-
-
-#endif  // _TVAFE_H
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_adc.c b/drivers/amlogic/tvin/tvafe/tvafe_adc.c
deleted file mode 100755
index 18ee02fbe0a7..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_adc.c
+++ /dev/null
@@ -1,1589 +0,0 @@
-/*
- * TVAFE adc device driver.
- *
- * Copyright (c) 2010 Frank zhao <frank.zhao@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-/******************************Includes************************************/
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/moduleparam.h>
-
-#include <mach/am_regs.h>
-
-#include <linux/amlogic/tvin/tvin.h>
-#include "../vdin/vdin_regs.h"
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "tvafe_regs.h"
-#include "tvafe_adc.h"
-
-/***************************Local defines**********************************/
-/* adc auto adjust defines */
-#define AUTO_CLK_VS_CNT                 30 //10 // get stable BD readings after n+1 frames
-#define AUTO_PHASE_VS_CNT               2 // get stable AP readings after n+1 frames
-#define ADC_WINDOW_H_OFFSET             39 // auto phase window h offset
-#define ADC_WINDOW_V_OFFSET             2 // auto phase window v offset
-#define MAX_AUTO_CLOCK_ORDER            4 // 1/16 headroom
-#define VGA_AUTO_TRY_COUNTER            300 // vga max adjust counter, 3 seconds
-// divide window into 7*7 sub-windows & make phase detection on 9 sub-windows
-// -------
-// -*-*-*-
-// -------
-// -*-*-*-
-// -------
-// -*-*-*-
-// -------
-#define VGA_AUTO_PHASE_H_WIN            7
-#define VGA_AUTO_PHASE_V_WIN            7
-
-#define VGA_PHASE_WIN_INDEX_0           0
-#define VGA_PHASE_WIN_INDEX_1           1
-#define VGA_PHASE_WIN_INDEX_2           2
-#define VGA_PHASE_WIN_INDEX_3           3
-#define VGA_PHASE_WIN_INDEX_4           4
-#define VGA_PHASE_WIN_INDEX_5           5
-#define VGA_PHASE_WIN_INDEX_6           6
-#define VGA_PHASE_WIN_INDEX_7           7
-#define VGA_PHASE_WIN_INDEX_8           8
-#define VGA_PHASE_WIN_INDEX_MAX         VGA_PHASE_WIN_INDEX_8
-
-#define VGA_ADC_PHASE_0                  0
-#define VGA_ADC_PHASE_1                  1
-#define VGA_ADC_PHASE_2                  2
-#define VGA_ADC_PHASE_3                  3
-#define VGA_ADC_PHASE_4                  4
-#define VGA_ADC_PHASE_5                  5
-#define VGA_ADC_PHASE_6                  6
-#define VGA_ADC_PHASE_7                  7
-#define VGA_ADC_PHASE_8                  8
-#define VGA_ADC_PHASE_9                  9
-#define VGA_ADC_PHASE_10                10
-#define VGA_ADC_PHASE_11                11
-#define VGA_ADC_PHASE_12                12
-#define VGA_ADC_PHASE_13                13
-#define VGA_ADC_PHASE_14                14
-#define VGA_ADC_PHASE_15                15
-#define VGA_ADC_PHASE_16                16
-#define VGA_ADC_PHASE_17                17
-#define VGA_ADC_PHASE_18                18
-#define VGA_ADC_PHASE_19                19
-#define VGA_ADC_PHASE_20                20
-#define VGA_ADC_PHASE_21                21
-#define VGA_ADC_PHASE_22                22
-#define VGA_ADC_PHASE_23                23
-#define VGA_ADC_PHASE_24                24
-#define VGA_ADC_PHASE_25                25
-#define VGA_ADC_PHASE_26                26
-#define VGA_ADC_PHASE_27                27
-#define VGA_ADC_PHASE_28                28
-#define VGA_ADC_PHASE_29                29
-#define VGA_ADC_PHASE_30                30
-#define VGA_ADC_PHASE_31                31
-#define VGA_ADC_PHASE_MID               VGA_ADC_PHASE_15
-#define VGA_ADC_PHASE_MAX               VGA_ADC_PHASE_31
-
-#define TVAFE_H_MAX                     0xFFF
-#define TVAFE_H_MIN                     0x000
-#define TVAFE_V_MAX                     0xFFF
-#define TVAFE_V_MIN                     0x000
-
-#define TVAFE_VGA_VS_CNT_MAX            200
-
-#define TVAFE_VGA_BD_EN_DELAY           4  //4//4 field delay
-
-#define TVAFE_VGA_CLK_TUNE_RANGE_ORDER  5 // 1/64 h_total
-#define TVAFE_VGA_HPOS_TUNE_RANGE_ORDER 6 // 1/64 h_active
-#define TVAFE_VGA_VPOS_TUNE_RANGE_ORDER 6 // 1/64 v_active
-
-/* adc mode detection defines */
-#define TVIN_FMT_CHG_VGA_VS_CNT_WOBBLE  2
-#define TVIN_FMT_CHG_COMP_HS_CNT_WOBBLE 0xffffffff // not to trust
-#define TVIN_FMT_CHG_COMP_VS_CNT_WOBBLE 0xffffffff // not to trust
-#define TVIN_FMT_CHK_VGA_VS_CNT_WOBBLE  1   ///1
-#define TVIN_FMT_CHK_HS_SOG_SW_CNT      5
-#define TVIN_FMT_CHK_HS_SOG_DLY_CNT     3
-#define TVIN_FMT_CHK_COMP_RST_MAX_CNT   100 /// the difference of two hcnt
-#define TVAFE_ADC_RESET_MAX_CNT         3 // ADC reset max counter, avoid mode
-// detection error sometimes for component
-
-/***************************Local variables **********************************/
-static DEFINE_SPINLOCK(skip_cnt_lock);
-/*
-*protection for vga vertical de adjustment,if vertical blanking too short
-*mybe too short to process one field data 
-*/
-static int vbp_offset = 17;
-module_param(vbp_offset, short, 0664);
-MODULE_PARM_DESC(vbp_offset, "the mix lines after vsync");
-
-static bool adc_dbg_en = 0;
-module_param(adc_dbg_en, bool, 0664);
-MODULE_PARM_DESC(adc_dbg_en, "enable/disable adc auto adj debug message");
-
-static bool adc_parm_en = 0;
-module_param(adc_parm_en, bool, 0664);
-MODULE_PARM_DESC(adc_parm_en, "enable/disable set adc parm message");
-static bool adc_fmt_chg_dbg = 0;
-module_param(adc_fmt_chg_dbg, bool, 0664);
-MODULE_PARM_DESC(adc_fmt_chg_dbg, "enable/disable adc fmt change debug message");
-
-static unsigned rgb_thr = 0x240;
-module_param(rgb_thr, uint, 0664);
-MODULE_PARM_DESC(rgb_thr, "border detect r&g&b threshold");
-
-static bool enable_dphase = false;
-module_param(enable_dphase, bool, 0644);
-MODULE_PARM_DESC(enable_dphase,"turn on/off the different phase config");
-
-static unsigned short comp_phase[TVIN_SIG_FMT_COMP_MAX - TVIN_SIG_FMT_VGA_THRESHOLD];
-module_param_array(comp_phase, ushort, NULL, 0644);
-MODULE_PARM_DESC(comp_phase,"the phase array for different comp fmt");
-
-static unsigned short black_bar_v1 = 1;
-module_param(black_bar_v1, ushort, 0644);
-MODULE_PARM_DESC(black_bar_v1,"the if the row is bar");
-
-static unsigned short black_bar_v2 = 2;
-module_param(black_bar_v2, ushort, 0644);
-MODULE_PARM_DESC(black_bar_v2,"tell if the row is black");
-
-static unsigned int bar_width = 4;
-module_param(bar_width,int,0644);
-MODULE_PARM_DESC(bar_width,"bar det");
-/*
- * tvafe get adc pll lock status
- */
-inline bool tvafe_adc_get_pll_status(void)
-{
-	return (bool)READ_APB_REG_BITS(ADC_REG_35, PLLLOCKED_BIT, PLLLOCKED_WID);
-}
-
-/*
- * tvafe skip frame counter
- */
-static void tvafe_adc_set_frame_skip_number(struct tvafe_adc_s *adc, unsigned int frame_number)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&skip_cnt_lock, flags);
-	if (adc->skip_frame_cnt < frame_number) {
-		adc->skip_frame_cnt = frame_number;
-	}
-	spin_unlock_irqrestore(&skip_cnt_lock, flags);
-}
-
-/*
- * tvafe sikp frame function
- */
-bool tvafe_adc_check_frame_skip(struct tvafe_adc_s *adc)
-{
-	bool ret = false;
-	unsigned long flags;
-	//spin_lock_irqsave(&skip_cnt_lock, flags);
-	if (adc->skip_frame_cnt > 0) {
-		adc->skip_frame_cnt--;
-		ret = true;
-	}
-	else {
-		ret = false;
-	}
-	//spin_unlock_irqrestore(&skip_cnt_lock, flags);
-
-	return ret;
-}
-
-
-/*
- * tvafe set adc clamp parameters
- */
-static void tvafe_adc_set_clamp_para(enum tvin_sig_fmt_e fmt)
-{
-	int clamp_calculate = 0, clamp_range = 0;
-	const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-
-    if(!fmt_info) {
-        pr_err("[tvafe..] %s: error,fmt is null!!! \n",__func__);
-        return;
-    }
-
-	clamp_range = fmt_info->hs_bp - READ_APB_REG(ADC_REG_03) - 18;
-	clamp_calculate = fmt_info->pixel_clk / 200;
-	if (clamp_calculate >= 0xff)
-		clamp_calculate = 0xff;
-	else if (clamp_calculate > clamp_range)
-		clamp_calculate = clamp_range;
-	WRITE_APB_REG(ADC_REG_04, clamp_calculate);
-}
-
-/*
- * tvafe check adc signal status
- */
-inline bool tvafe_adc_no_sig(void)
-{
-	return (READ_APB_REG_BITS(TVFE_DVSS_INDICATOR1, NOSIG_BIT, NOSIG_WID) ? true : false);
-}
-
-/*
- * tvafe set hsync path: adc to top
- */
-static void tvafe_comp_set_sync_path(int sog_flag)
-{
-	WRITE_APB_REG_BITS(TVFE_SYNCTOP_SFG_MUXCTRL2, (sog_flag? 2:4),
-			SMUX_SM_HS_SRC_SEL_BIT, SMUX_SM_HS_SRC_SEL_WID);
-}
-
-/*
- * tvafe get hsync path setting: adc to top
- */
-static int tvafe_comp_get_sync_path(void)
-{
-	return ((READ_APB_REG_BITS(TVFE_SYNCTOP_SFG_MUXCTRL2,
-					SMUX_SM_HS_SRC_SEL_BIT, SMUX_SM_HS_SRC_SEL_WID)==2)? 1:0);
-}
-
-/*
- * tvafe check mode change status
- */
-inline bool tvafe_adc_fmt_chg(struct tvin_parm_s *parm, struct tvafe_adc_s *adc)
-{
-        const struct tvin_format_s *fmt_info_p;
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-	enum tvin_port_e port = parm->port;
-	enum tvin_sig_status_e status = parm->info.status;
-	struct tvin_format_s *hw_info = &adc->hw_info;                
-	unsigned short tmp0 = 0, tmp1 = 0;
-	unsigned int   h_cnt_offset = 0, h_cnt_offset1 =0, v_cnt_offset = 0, v_cnt_offset1 = 0;
-	unsigned int   hs_cnt_offset = 0, vs_cnt_offset = 0;
-	unsigned int   h_cnt_wobble = 0, v_cnt_wobble = 0;
-	unsigned int   hs_cnt_wobble = 0, vs_cnt_wobble = 0, flag;
-	bool           h_pol_chg = false, v_pol_chg = false;
-	bool           h_flag = false, v_flag = false;
-
-	flag = READ_APB_REG_BITS(TVFE_DVSS_INDICATOR1, NOSIG_BIT, NOSIG_WID);
-	if (flag)
-	{
-		if (adc_dbg_en)
-			pr_info("[tvafe..] %s: tvafe adc no signal!!! \n",__func__);
-		return true;
-	}
-
-        fmt_info_p = tvin_get_fmt_info(fmt);
-        if(fmt_info_p){
-                h_cnt_wobble  = fmt_info_p->h_cnt_offset;
-	        v_cnt_wobble  = fmt_info_p->v_cnt_offset;
-	        hs_cnt_wobble = fmt_info_p->hs_cnt_offset;                       
-        }else{
-                h_cnt_wobble  = 10;
-	        v_cnt_wobble  = 10;
-                hs_cnt_wobble = 2;
-        }
-                        
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7))
-	{		
-		vs_cnt_wobble = TVIN_FMT_CHG_VGA_VS_CNT_WOBBLE;
-		flag = READ_APB_REG(TVFE_SYNCTOP_INDICATOR3);
-
-		//h_pol
-		h_flag = (flag & (1 << SPOL_H_POL_BIT))? true : false;
-
-		//v_pol
-		v_flag = (flag & (1 << SPOL_V_POL_BIT))? true : false;
-
-		if (h_flag)
-		{
-			if (hw_info->hs_pol == TVIN_SYNC_POL_POSITIVE)
-				h_pol_chg = true;
-			hw_info->hs_pol = TVIN_SYNC_POL_NEGATIVE;
-		}
-		else
-		{
-			if (hw_info->hs_pol == TVIN_SYNC_POL_NEGATIVE)
-				h_pol_chg = true;
-			hw_info->hs_pol = TVIN_SYNC_POL_POSITIVE;
-		}
-
-		if (v_flag)
-		{
-			if (hw_info->vs_pol == TVIN_SYNC_POL_POSITIVE)
-				v_pol_chg = true;
-			hw_info->vs_pol = TVIN_SYNC_POL_NEGATIVE;
-		}
-		else
-		{
-			if (hw_info->vs_pol == TVIN_SYNC_POL_NEGATIVE)
-				v_pol_chg = true;
-			hw_info->vs_pol = TVIN_SYNC_POL_POSITIVE;
-		}
-
-		// hs_cnt
-		tmp0 = (unsigned short)READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR1_HCNT,
-				SPOL_HCNT_NEG_BIT, SPOL_HCNT_NEG_WID);
-		tmp1 = (unsigned short)READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR1_HCNT,
-				SPOL_HCNT_POS_BIT, SPOL_HCNT_POS_WID);
-		tmp0 = min(tmp0, tmp1);
-		hs_cnt_offset = abs((signed int)hw_info->hs_cnt - (signed int)tmp0);
-		hw_info->hs_cnt = tmp0;
-
-		// vs_cnt
-		tmp0 = (unsigned short)READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR2_VCNT,
-				SPOL_VCNT_NEG_BIT, SPOL_VCNT_NEG_WID);
-		tmp1 = (unsigned short)READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR2_VCNT,
-				SPOL_VCNT_POS_BIT, SPOL_VCNT_POS_WID);
-		tmp0 = min(tmp0, tmp1);
-		vs_cnt_offset = abs((signed int)hw_info->vs_width - (signed int)tmp0);
-		hw_info->vs_width = tmp0;
-		// h_cnt
-		tmp0 = READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR4,
-				SAM_HCNT_BIT, SAM_HCNT_WID);
-		h_cnt_offset = abs((signed int)hw_info->h_cnt - (signed int)tmp0);
-		//h_cnt_offset = abs((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_cnt - (signed int)tmp0);
-		hw_info->h_cnt = tmp0;
-		// v_cnt
-		tmp0 = READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR4,
-				SAM_VCNT_BIT, SAM_VCNT_WID);
-		v_cnt_offset = abs((signed int)hw_info->v_total - (signed int)tmp0);
-		//v_cnt_offset = abs((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_total- (signed int)tmp0);
-		hw_info->v_total = tmp0;
-
-	}
-	else if ((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7))
-	{		
-		hs_cnt_wobble = TVIN_FMT_CHG_COMP_HS_CNT_WOBBLE;
-		vs_cnt_wobble = TVIN_FMT_CHG_COMP_VS_CNT_WOBBLE;
-		adc->hs_sog_sw_cnt++;
-
-		if(adc->hs_sog_sw_cnt > TVIN_FMT_CHK_HS_SOG_DLY_CNT)
-		{
-			// h_cnt
-			tmp0 = READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR4,
-					SAM_HCNT_BIT, SAM_HCNT_WID);
-
-			if ((status == TVIN_SIG_STATUS_STABLE)&&(fmt_info_p))
-				hw_info->h_cnt = fmt_info_p->h_cnt;
-			h_cnt_offset = abs((signed int)hw_info->h_cnt - (signed int)tmp0);
-
-			adc->hs_sog_sw_cnt = 0;
-			tmp1 = READ_APB_REG_BITS(TVFE_SOG_MON_INDICATOR1,
-					SOG_CNT_POS_BIT, SOG_CNT_POS_WID);
-			tmp1 += READ_APB_REG_BITS(TVFE_SOG_MON_INDICATOR1,
-					SOG_CNT_NEG_BIT, SOG_CNT_NEG_WID);
-			//the difference between h_cnt  from sog and h_cnt from hs_out2
-			h_cnt_offset1 = abs((signed int)hw_info->h_cnt - (signed int)tmp1);
-                        hw_info->h_cnt = tmp0;
-                        if(h_cnt_offset < h_cnt_offset1){
-                                h_cnt_offset = h_cnt_offset1;
-                                hw_info->h_cnt = tmp1;
-                                if(adc_fmt_chg_dbg)
-                                        pr_info("[tvafe..] %s:sogout hcnt %u, hsyncout hcnt %u.\n",__func__,tmp1,tmp0);
-                        }
-
-			//pr_info("[tvafe..] %s: hw:%d, hw.hcnt:%d fmt is:%s\n",__func__, tmp0,
-			//    hw_info->h_cnt, tvin_sig_fmt_str(fmt));
-			/* if the diff exceed max cnt, reset adc for abnormal format */
-			if (h_cnt_offset > TVIN_FMT_CHK_COMP_RST_MAX_CNT)
-			{
-#if 0
-				/* avoid mode detection error for component */
-				if (devp->adc.adc_reset_cnt++ < TVAFE_ADC_RESET_MAX_CNT)
-				{
-					tvafe_adc_digital_reset();
-					if (adc_dbg_en)
-						pr_info("[tvafe..] %s: fmt change!! adc reset clock!!! \n",__func__);
-				}
-				else
-					devp->adc.adc_reset_cnt = TVAFE_ADC_RESET_MAX_CNT;
-#else
-				tvafe_adc_digital_reset();
-				if (adc_dbg_en)
-					pr_info("[tvafe..] %s: fmt change!! adc reset clock!!! \n",__func__);
-#endif
-			}
-
-			// v_cnt
-			tmp0 = READ_APB_REG_BITS(TVFE_SYNCTOP_INDICATOR4,SAM_VCNT_BIT, SAM_VCNT_WID);
-			v_cnt_offset = abs((signed int)hw_info->v_total - (signed int)tmp0);
-                        hw_info->v_total = tmp0;
-                        
-			if ((status == TVIN_SIG_STATUS_STABLE)&&(fmt_info_p)){
-				hw_info->v_total = fmt_info_p->v_total;
-				tmp1 = READ_APB_REG_BITS(TVFE_SOG_MON_INDICATOR2,SOG_VTOTAL_BIT, SOG_VTOTAL_WID);
-                                /*during vsync sog cnt is double of vsync width*/
-                                tmp1 -= hw_info->vs_width;
-				v_cnt_offset1= abs((signed int)hw_info->v_total - (signed int)tmp1);
-				//chose the correct v_total from sog and v_hs
-				if(v_cnt_offset < v_cnt_offset1){
-					hw_info->v_total = tmp1;
-					v_cnt_offset = v_cnt_offset1;
-                                        if(adc_fmt_chg_dbg)
-                                        pr_info("[tvafe..] %s:sogout vcnt %u, vsyncout vcnt %u.\n",__func__,tmp1,tmp0);
-                                                                                
-				}                    
-			
-		        }
-	        }
-	}
-	else
-	{
-		if (adc_dbg_en)
-			pr_err("[tvafe..] wrong input port. \n");
-		return false;
-	}
-
-	if ((h_cnt_offset > h_cnt_wobble)   ||
-			(v_cnt_offset > v_cnt_wobble)   ||
-			(hs_cnt_offset > hs_cnt_wobble) ||
-			(vs_cnt_offset > vs_cnt_wobble) ||
-			h_pol_chg                       ||
-			v_pol_chg
-	   )
-	{
-		flag = true;
-		if(adc_fmt_chg_dbg)
-		{
-			if(h_cnt_offset > h_cnt_wobble)
-				pr_info("[tvafe..] h_cnt_offset %u > %u h_cnt_wobble fmt change.\n",h_cnt_offset,h_cnt_wobble);
-			if(v_cnt_offset > v_cnt_wobble)
-				pr_info("[tvafe..] v_cnt_offset %u > %u v_cnt_wobble fmt change.\n",v_cnt_offset,v_cnt_wobble);
-			if(hs_cnt_offset > hs_cnt_wobble)
-				pr_info("[tvafe..] hs_cnt_offset %u.hs_cnt_offset > hs_cnt_wobble fmt change.\n",hs_cnt_offset);
-			if(vs_cnt_offset > vs_cnt_wobble)
-				pr_info("[tvafe..] vs_cnt_offset %u > %u vs_cnt_wobble fmt change.\n",vs_cnt_offset,vs_cnt_wobble);
-			if(h_pol_chg)
-				pr_info("[tvafe..] h_pol_chg fmt change.\n");
-			if(v_pol_chg)
-				pr_info("[tvafe..] v_pol_chg fmt change.\n");
-		}
-	}
-	else
-		flag = false;
-
-
-	return flag;
-}
-
-/*
- * tvafe reset digital module of adc
- */
-void tvafe_adc_digital_reset()
-{
-	WRITE_APB_REG(ADC_REG_21, 1);
-	WRITE_APB_REG(ADC_REG_21, 5);
-	WRITE_APB_REG(ADC_REG_21, 7);
-
-	//tvafe_adc_set_frame_skip_number(3);
-}
-
-/*
- * tvafe search format number
- */
-inline enum tvin_sig_fmt_e tvafe_adc_search_mode(struct tvin_parm_s *parm, struct tvafe_adc_s *adc)
-{
-	enum tvin_port_e port = parm->port;
-	struct tvin_format_s *hw_info = &adc->hw_info;
-	enum tvin_sig_fmt_e index     = TVIN_SIG_FMT_NULL;
-	enum tvin_sig_fmt_e index_min = TVIN_SIG_FMT_NULL;
-	enum tvin_sig_fmt_e index_max = TVIN_SIG_FMT_NULL;
-	//unsigned int hcnt = 0;
-
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7))
-	{
-		index_min = TVIN_SIG_FMT_VGA_512X384P_60HZ_D147;
-		index_max = TVIN_SIG_FMT_VGA_MAX;
-		for (index=index_min; index < index_max; index++)
-		{
-			if (tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_cnt == 0)
-				continue;
-			if (abs((signed int)hw_info->h_cnt- (signed int)tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_cnt) <= tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_cnt_offset)
-			{
-				if(abs((signed int)hw_info->v_total- (signed int)tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_total) <= tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_cnt_offset)
-				{
-					if(abs((signed int)hw_info->hs_cnt - (signed int)tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_cnt) <= tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_cnt_offset)
-					{
-						if(abs((signed int)hw_info->vs_width - (signed int)tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width) <= TVIN_FMT_CHK_VGA_VS_CNT_WOBBLE)
-						{
-							if((hw_info->hs_pol == tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_pol) &&
-									(hw_info->vs_pol == tvin_vga_fmt_tbl[index-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_pol))
-								break;
-						}
-					}
-				}
-			}
-		}
-
-	}
-	else if((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7))
-	{
-		index_min = TVIN_SIG_FMT_COMP_480P_60HZ_D000;
-		index_max = TVIN_SIG_FMT_COMP_MAX;
-		for (index=index_min; index < index_max; index++)
-		{
-			if (tvin_comp_fmt_tbl[index-TVIN_SIG_FMT_COMP_480P_60HZ_D000].h_cnt == 0)
-				continue;
-			if (abs((signed int)hw_info->h_cnt- (signed int)tvin_comp_fmt_tbl[index-TVIN_SIG_FMT_COMP_480P_60HZ_D000].h_cnt) <= tvin_comp_fmt_tbl[index-TVIN_SIG_FMT_COMP_480P_60HZ_D000].h_cnt_offset)
-			{
-				if(abs((signed int)hw_info->v_total- (signed int)tvin_comp_fmt_tbl[index-TVIN_SIG_FMT_COMP_480P_60HZ_D000].v_total) <= tvin_comp_fmt_tbl[index-TVIN_SIG_FMT_COMP_480P_60HZ_D000].v_cnt_offset)
-				{
-					break;
-				}
-			}
-		}
-
-	}
-
-	if (adc_dbg_en)
-		pr_info("[tvafe..] %s h_cnt= %d, v_total= %d, hs_cnt=%d, vs_width= %d, hs_pol= %d, vs_pol= %d \n", \
-				__func__, hw_info->h_cnt, hw_info->v_total, hw_info->hs_cnt, \
-				hw_info->vs_width, hw_info->hs_pol, hw_info->vs_pol);
-	if (index >= index_max)
-	{
-		index = TVIN_SIG_FMT_NULL;
-	}
-
-	adc->adc_reset_cnt = 0;
-
-	return index;
-}
-
-/*
- * tvafe set border detection window size
- */
-static void tvafe_adc_set_bd_window(enum tvin_sig_fmt_e fmt)
-{
-	unsigned int tmp = 0;
-
-	tmp = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp - ADC_WINDOW_H_OFFSET;
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL1, tmp, BD_HSTART_BIT, BD_HSTART_WID);
-	//tmp += tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active + ADC_WINDOW_H_OFFSET + ADC_WINDOW_H_OFFSET;
-	tmp = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1;
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL1, tmp, BD_HEND_BIT, BD_HEND_WID);
-	tmp = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp - ADC_WINDOW_V_OFFSET;
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL2, tmp, BD_VSTART_BIT, BD_VSTART_WID);
-	//tmp += tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active + ADC_WINDOW_V_OFFSET + ADC_WINDOW_V_OFFSET;
-	tmp = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_total - 1;
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL2, tmp, BD_VEND_BIT, BD_VEND_WID);
-}
-
-/*
- * tvafe set auto phase detection window size
- */
-static void tvafe_adc_set_ap_window(enum tvin_sig_fmt_e fmt, unsigned char idx)
-{
-	unsigned int hh = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active / VGA_AUTO_PHASE_H_WIN;
-	unsigned int vv = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active / VGA_AUTO_PHASE_V_WIN;
-	unsigned int hs = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width +
-		tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp    +
-		(((idx%3) << 1) + 1)*hh;
-	unsigned int he = hs + hh - 1;
-	unsigned int vs = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width +
-		tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp    +
-		(((idx/3) << 1) + 1)*vv;
-	unsigned int ve = vs + vv - 1;
-
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, hs, AP_HSTART_BIT, AP_HSTART_WID);
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, he, AP_HEND_BIT,   AP_HEND_WID  );
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL2, vs, AP_VSTART_BIT, AP_VSTART_WID);
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL2, ve, AP_VEND_BIT,   AP_VEND_WID  );
-}
-
-/*
- * tvafe set adc clock parameter
- */
-static void tvafe_vga_set_clock(unsigned int clock)
-{
-	unsigned int tmp;
-
-	tmp = (clock >> 4) & 0x000000FF;
-	WRITE_APB_REG_BITS(ADC_REG_01, tmp, PLLDIVRATIO_MSB_BIT, PLLDIVRATIO_MSB_WID);
-	tmp = clock & 0x0000000F;
-	WRITE_APB_REG_BITS(ADC_REG_02, tmp, PLLDIVRATIO_LSB_BIT, PLLDIVRATIO_LSB_WID);
-
-	//tvafe_adc_set_frame_skip_number(2);
-
-	//reset adc digital pll
-	//tvafe_adc_digital_reset();
-
-	return;
-}
-
-/*
- * tvafe get adc clock parameter
- */
-static unsigned int tvafe_vga_get_clock(void)
-{
-	unsigned int data;
-
-	data = READ_APB_REG_BITS(ADC_REG_01,
-			PLLDIVRATIO_MSB_BIT, PLLDIVRATIO_MSB_WID) << 4;
-	data |= READ_APB_REG_BITS(ADC_REG_02,
-			PLLDIVRATIO_LSB_BIT, PLLDIVRATIO_LSB_WID);
-
-	return data;
-}
-
-/*
- * tvafe set adc phase parameter
- */
-static void tvafe_vga_set_phase(unsigned int phase)
-{
-	WRITE_APB_REG_BITS(ADC_REG_56, phase, CLKPHASEADJ_BIT, CLKPHASEADJ_WID);
-
-	//tvafe_adc_set_frame_skip_number(1);
-
-	//reset adc digital pll
-	//tvafe_adc_digital_reset();  //removed for auto phase bug
-	return;
-}
-
-/*
- * tvafe get adc phase parameter
- */
-static unsigned int tvafe_vga_get_phase(void)
-{
-	return READ_APB_REG_BITS(ADC_REG_56, CLKPHASEADJ_BIT, CLKPHASEADJ_WID);
-}
-
-/*
- * tvafe set adc h-position parameter
- */
-void tvafe_vga_set_h_pos(unsigned int hs, unsigned int he)
-{
-	WRITE_APB_REG_BITS(TVFE_DEG_H,   hs, DEG_HSTART_BIT, DEG_HSTART_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_H,   he, DEG_HEND_BIT,   DEG_HEND_WID  );
-
-	return;
-}
-
-/*
- * tvafe get adc h-position parameter
- */
-static unsigned int tvafe_vga_get_h_pos(void)
-{
-	return READ_APB_REG_BITS(TVFE_DEG_H, DEG_HSTART_BIT, DEG_HSTART_WID);
-}
-
-/*
- * tvafe set adc v-position parameter
- */
-void tvafe_vga_set_v_pos(unsigned int vs, unsigned int ve, enum tvin_scan_mode_e scan_mode)
-{
-	unsigned int offset = (scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) ? 0 : 1;
-	WRITE_APB_REG_BITS(TVFE_DEG_VODD,  vs,          DEG_VSTART_ODD_BIT,  DEG_VSTART_ODD_WID );
-	WRITE_APB_REG_BITS(TVFE_DEG_VODD ,  ve,          DEG_VEND_ODD_BIT,    DEG_VEND_ODD_WID   );
-	WRITE_APB_REG_BITS(TVFE_DEG_VEVEN, vs + offset, DEG_VSTART_EVEN_BIT, DEG_VSTART_EVEN_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_VEVEN, ve + offset, DEG_VEND_EVEN_BIT,   DEG_VEND_EVEN_WID  );
-}
-
-/*
- * tvafe get adc v-position parameter
- */
-static unsigned int tvafe_vga_get_v_pos(void)
-{
-	return READ_APB_REG_BITS(TVFE_DEG_VODD, DEG_VSTART_ODD_BIT, DEG_VSTART_ODD_WID);
-}
-
-/*
- * tvafe enable border detection function
- */
-static void tvafe_vga_border_detect_enable(void)
-{
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 1, BD_DET_EN_BIT, BD_DET_EN_WID);
-}
-
-/*
- * tvafe disenable border detection function
- */
-static void tvafe_vga_border_detect_disable(void)
-{
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 0, BD_DET_EN_BIT, BD_DET_EN_WID);
-}
-
-/*
- * tvafe enable auto phase function
- */
-static void tvafe_vga_auto_phase_enable(void)
-{
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 1, AUTOPHASE_EN_BIT, AUTOPHASE_EN_WID);
-}
-
-/*
- * tvafe disenable auto phase function
- */
-static void tvafe_vga_auto_phase_disable(void)
-{
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 0, AUTOPHASE_EN_BIT, AUTOPHASE_EN_WID);
-}
-
-/*
- * tvafe init border detection function
- */
-static void tvafe_vga_border_detect_init(enum tvin_sig_fmt_e fmt)
-{
-	//diable border detect
-	tvafe_vga_border_detect_disable();
-	// pix_thr = 4 (pix-val > pix_thr => valid pixel)
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL3, rgb_thr/*0x10*/,
-			BD_R_TH_BIT, BD_R_TH_WID);
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL5, rgb_thr/*0x10*/,
-			BD_G_TH_BIT, BD_G_TH_WID);
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL5, rgb_thr/*0x10*/,
-			BD_B_TH_BIT, BD_B_TH_WID);
-	// pix_val > pix_thr => valid pixel
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 1,
-			BD_DET_METHOD_BIT, BD_DET_METHOD_WID);
-	// line_thr = 1/16 of h_active (valid pixels > line_thr => valid line)
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL3, (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active)>>5/*(tvin_fmt_tbl[fmt].h_active)>>4*/,
-			BD_VLD_LN_TH_BIT, BD_VLD_LN_TH_WID);
-	// line_thr enable
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL3, 1,
-			BD_VALID_LN_EN_BIT, BD_VALID_LN_EN_WID);
-	// continuous border detection mode
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL4, 1,
-			BD_LIMITED_FLD_RECORD_BIT, BD_LIMITED_FLD_RECORD_WID);
-	WRITE_APB_REG_BITS(TVFE_BD_MUXCTRL4, 6,
-			BD_FLD_CD_NUM_BIT, BD_FLD_CD_NUM_WID);
-	// set a large window
-	tvafe_adc_set_bd_window( fmt);
-	//enable border detect
-	tvafe_vga_border_detect_enable();
-}
-
-/*
- * tvafe init auto phase function
- */
-static void tvafe_vga_auto_phase_init( enum tvin_sig_fmt_e fmt, unsigned char idx)
-{
-	//disable auto phase
-	tvafe_vga_auto_phase_disable();
-	// use diff value
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 1,
-			AP_DIFF_SEL_BIT, AP_DIFF_SEL_WID);
-	// use window
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL1, 0,
-			AP_SPECIFIC_POINT_OUT_BIT, AP_SPECIFIC_POINT_OUT_WID);
-	// coring_thr = 4 (diff > coring_thr => valid diff)
-	WRITE_APB_REG_BITS(TVFE_AP_MUXCTRL3, 0x10,
-			AP_CORING_TH_BIT, AP_CORING_TH_WID);
-	// set auto phase window
-	tvafe_adc_set_ap_window(fmt, idx);
-	//enable auto phase
-	tvafe_vga_auto_phase_enable();
-}
-
-/*
- * tvafe get the diff value of auto phase
- */
-static unsigned int tvafe_vga_get_ap_diff(void)
-{
-
-	unsigned int sum_r = READ_APB_REG(TVFE_AP_INDICATOR1);
-	unsigned int sum_g = READ_APB_REG(TVFE_AP_INDICATOR2);
-	unsigned int sum_b = READ_APB_REG(TVFE_AP_INDICATOR3);
-
-	if (sum_r < sum_g)
-		return max(sum_g,sum_b);
-	else        
-		return max(sum_r,sum_b);
-}
-
-/*
- * tvafe get h border value after border detection
- */
-static void tvafe_vga_get_h_border(struct tvafe_vga_auto_s *vga_auto)
-{
-	unsigned int r_left_hcnt = 0, r_right_hcnt = 0;
-	unsigned int g_left_hcnt = 0, g_right_hcnt = 0;
-	unsigned int b_left_hcnt = 0, b_right_hcnt = 0;
-
-	struct tvafe_vga_border_s *bd = &vga_auto->border;
-
-	r_right_hcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR14 ,
-			BD_R_RIGHT_HCNT_BIT, BD_R_RIGHT_HCNT_WID);
-	r_left_hcnt  = READ_APB_REG_BITS(TVFE_AP_INDICATOR14,
-			BD_R_LEFT_HCNT_BIT,  BD_R_LEFT_HCNT_WID );
-	g_right_hcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR16,
-			BD_G_RIGHT_HCNT_BIT, BD_G_RIGHT_HCNT_WID);
-	g_left_hcnt  = READ_APB_REG_BITS(TVFE_AP_INDICATOR16,
-			BD_G_LEFT_HCNT_BIT,  BD_G_LEFT_HCNT_WID );
-	b_right_hcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR18,
-			BD_B_RIGHT_HCNT_BIT, BD_B_RIGHT_HCNT_WID);
-	b_left_hcnt  = READ_APB_REG_BITS(TVFE_AP_INDICATOR18,
-			BD_B_LEFT_HCNT_BIT,  BD_B_LEFT_HCNT_WID );
-	if(adc_dbg_en)
-		pr_info("[tvafe..]%s r_left %u.g_left %u.b_left %u.r_right %u.g_right %u.b_right %u.\n",__func__,r_left_hcnt,
-				g_left_hcnt, b_left_hcnt,r_right_hcnt,g_right_hcnt,b_right_hcnt);
-
-	bd->hstart = min(r_left_hcnt, g_left_hcnt);
-	bd->hstart = min(bd->hstart, b_left_hcnt);
-
-	bd->hend = max(r_right_hcnt, g_right_hcnt);
-	bd->hend = max(bd->hend, b_right_hcnt);
-
-}
-
-/*
- * tvafe get v border value after border detection
- */
-static void tvafe_vga_get_v_border(struct tvafe_vga_auto_s *vga_auto)
-{
-	unsigned int r_top_vcnt = 0, r_bot_vcnt = 0;
-	unsigned int g_top_vcnt = 0, g_bot_vcnt = 0;
-	unsigned int b_top_vcnt = 0, b_bot_vcnt = 0;
-	struct tvafe_vga_border_s *bd = &vga_auto->border;
-
-	r_top_vcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR13, BD_R_TOP_VCNT_BIT, BD_R_TOP_VCNT_WID);
-	r_bot_vcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR13, BD_R_BOT_VCNT_BIT, BD_R_BOT_VCNT_WID);
-	g_top_vcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR15, BD_G_TOP_VCNT_BIT, BD_G_TOP_VCNT_WID);
-	g_bot_vcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR15, BD_G_BOT_VCNT_BIT, BD_G_BOT_VCNT_WID);
-	b_top_vcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR17, BD_B_TOP_VCNT_BIT, BD_B_TOP_VCNT_WID);
-	b_bot_vcnt = READ_APB_REG_BITS(TVFE_AP_INDICATOR17, BD_B_BOT_VCNT_BIT, BD_B_BOT_VCNT_WID);
-	if(adc_dbg_en)
-		pr_info("[tvafe..]%s r_start %u.g_start %u.b_start%u.r_end %u.g_end %u.b_end%u.\n",__func__,r_top_vcnt,
-				g_top_vcnt, b_top_vcnt,r_bot_vcnt,g_bot_vcnt,b_bot_vcnt);
-
-	bd->vstart = min(r_top_vcnt, g_top_vcnt);
-	bd->vstart = min(bd->vstart, b_top_vcnt);
-
-	bd->vend  = max(r_bot_vcnt, g_bot_vcnt);
-	bd->vend  = max(bd->vend, b_bot_vcnt);
-
-}
-
-/*
- * tvafe vsync counter
- */
-inline void tvafe_vga_vs_cnt(struct tvafe_adc_s *adc)
-{
-	if (++adc->vga_auto.vs_cnt > TVAFE_VGA_VS_CNT_MAX)
-		adc->vga_auto.vs_cnt = TVAFE_VGA_VS_CNT_MAX;
-}
-
-/*
- * tvafe adc clock adjustment for vga auto adjust function
- */
-static void tvafe_vga_auto_clock_adj(unsigned int clk, signed int diff)
-{
-	if (diff > 0)
-		clk -= (abs(diff) + 1) >> 1;
-	if (diff < 0)
-		clk += (abs(diff) + 1) >> 1;
-	tvafe_vga_set_clock(clk);
-	// disable border detect
-	tvafe_vga_border_detect_disable();
-	// enable border detect
-	//tvafe_vga_border_detect_enable();
-}
-
-/*
- * tvafe vga auto clcok funtion
- */
-static void tvafe_vga_auto_clock_handler(enum tvin_sig_fmt_e fmt, struct tvafe_adc_s *adc)
-{
-	unsigned int clk = 0;
-	signed int diff = 0;
-
-	struct tvafe_vga_auto_s *vga_auto = &adc->vga_auto;
-	struct tvafe_vga_parm_s *vga_parm = &adc->vga_parm;
-
-	//signal stable
-
-	switch (vga_auto->clk_state)
-	{
-		case VGA_CLK_IDLE:
-			break;
-		case VGA_CLK_INIT:
-			//tvafe_vga_set_phase(VGA_ADC_PHASE_MID);
-			//tvafe_vga_set_clock(tvin_vga_fmt_tbl[tvinfo->fmt - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total-1);  //set spec clock value
-			vga_parm->phase = VGA_ADC_PHASE_MID;
-			vga_parm->clk_step = 0;
-			tvafe_vga_border_detect_init( fmt);
-			vga_auto->adj_cnt = 0;
-			vga_auto->adj_dir = 0;
-			vga_auto->clk_state = VGA_CLK_END;//VGA_CLK_ROUGH_ADJ;
-			vga_auto->vs_cnt  = 0;
-			break;
-		case VGA_CLK_ROUGH_ADJ:
-			diff = 0;
-			if (vga_auto->vs_cnt > AUTO_CLK_VS_CNT)
-			{
-				// get H border
-				tvafe_vga_get_h_border(vga_auto);
-				// get current clk
-				clk = tvafe_vga_get_clock();
-				if (adc_dbg_en)
-					pr_info("[tvafe..] %s: auto clock start, org_clk=%d \n",__func__, clk);
-				// calculate new clk
-				clk = (((clk * (unsigned int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active) << 8) / (vga_auto->border.hend - vga_auto->border.hstart + 1) + 128) >> 8;
-				if (adc_dbg_en)
-					pr_info("[tvafe..] %s: auto clock start, init_clk=%d \n",__func__, clk);
-				// if clk is too far from spec, then return error
-				if ((clk > ((tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1) + (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total >> MAX_AUTO_CLOCK_ORDER))) ||
-						(clk < ((tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1) - (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total >> MAX_AUTO_CLOCK_ORDER)))
-				   )
-				{
-					vga_auto->clk_state = VGA_CLK_EXCEPTION;
-				}
-				else
-				{
-					tvafe_vga_auto_clock_adj(clk, diff);
-					//tvafe_vga_border_detect_disable();
-					vga_auto->clk_state = VGA_CLK_FINE_ADJ;
-				}
-				vga_auto->vs_cnt = 0;
-			}
-			break;
-		case VGA_CLK_FINE_ADJ:
-			if (++vga_auto->adj_cnt > VGA_AUTO_TRY_COUNTER)
-			{
-				vga_auto->clk_state = VGA_CLK_EXCEPTION;
-			}
-			else
-			{
-				//delay about 4 field for border detection
-				if (vga_auto->vs_cnt == TVAFE_VGA_BD_EN_DELAY)
-				{
-					// disable border detect
-					tvafe_vga_border_detect_enable();
-				}
-				if (vga_auto->vs_cnt > AUTO_CLK_VS_CNT)
-				{
-					//vga_auto->vs_cnt = 0;
-					// get H border
-					tvafe_vga_get_h_border(vga_auto);
-					// get diff
-					diff = (signed int)vga_auto->border.hend - (signed int)vga_auto->border.hstart + (signed int)1 - (signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active;
-					// get clk
-					clk = tvafe_vga_get_clock();
-					if (!diff)
-					{
-						vga_auto->clk_state = VGA_CLK_END;
-					}
-					if (diff > 0)
-					{
-						if (vga_auto->adj_dir == 1)
-						{
-							if (clk > (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1))
-							{
-								tvafe_vga_auto_clock_adj( clk, diff);
-							}
-							vga_auto->clk_state = VGA_CLK_END;
-						}
-						else
-						{
-							tvafe_vga_auto_clock_adj(clk, diff);
-							vga_auto->adj_dir = -1;
-						}
-					}
-					if (diff < 0)
-					{
-						if (vga_auto->adj_dir == -1)
-						{
-							if (clk < (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1))
-							{
-								tvafe_vga_auto_clock_adj(clk, diff);
-							}
-							vga_auto->clk_state = VGA_CLK_END;
-						}
-						else
-						{
-							tvafe_vga_auto_clock_adj(clk, diff);
-							vga_auto->adj_dir = 1;
-						}
-					}
-					tvafe_adc_set_frame_skip_number(adc, 2);
-					vga_auto->vs_cnt = 0;
-				}
-			}
-			break;
-		case VGA_CLK_EXCEPTION: //stop auto
-			// disable border detect
-			if (adc_dbg_en)
-				pr_info("[tvafe..] %s: auto clock error!!! \n",__func__);
-			tvafe_vga_set_clock(tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1);  //set spec clock value
-			tvafe_adc_set_frame_skip_number(adc, 2);
-			tvafe_vga_border_detect_disable();
-			adc->cmd_status = TVAFE_CMD_STATUS_FAILED;
-			vga_auto->clk_state = VGA_CLK_IDLE;
-			break;
-		case VGA_CLK_END: //start auto phase
-			// disable border detect
-			if (adc_dbg_en)
-				pr_info("[tvafe..] %s: auto clock successful, last_clk=%d \n",__func__,
-						tvafe_vga_get_clock());
-			tvafe_vga_border_detect_disable();
-			vga_auto->phase_state = VGA_PHASE_INIT;
-			vga_auto->clk_state = VGA_CLK_IDLE;
-			break;
-		default:
-			break;
-	}
-
-	return;
-}
-void tvin_vdin_bar_detect(enum tvin_sig_fmt_e fmt, struct tvafe_adc_s *adc)
-{
-        unsigned int barhstart, barhend,hleft1,hleft2,hright1,hright2;
-        const struct tvin_format_s *fmt_info_p;
-        fmt_info_p = tvin_get_fmt_info(fmt);
-        if(!fmt_info_p){
-                pr_info("[tvafe]%s: null pointer error.\n",__func__);
-                return;
-        }
-		static unsigned int cnt=4;
-		tvafe_adc_set_frame_skip_number(adc, 4);
-        barhstart = READ_CBUS_REG_BITS(VDIN_BLKBAR_H_START_END,BLKBAR_HSTART_BIT,BLKBAR_HSTART_WID);
-        barhend   = READ_CBUS_REG_BITS(VDIN_BLKBAR_H_START_END,BLKBAR_HEND_BIT,BLKBAR_HEND_WID);
-
-        if(barhstart > 8){
-                adc->cmd_status = TVAFE_CMD_STATUS_SUCCESSFUL;
-                pr_err("[vdin..]%s: vdin border detection failed.\n",__func__);
-				adc->vga_parm.hpos_step+=bar_width;
-        }
-	                
-       // barhend--;
-       if(!(cnt--)){
-        	barhstart++;
-			cnt=4;
-       	}
-                   
-        hleft1 = READ_CBUS_REG_BITS(VDIN_BLKBAR_IND_LEFT1_CNT,BLKBAR_LEFT1_CNT_BIT,BLKBAR_LEFT1_CNT_WID); 
-        hleft2 = READ_CBUS_REG_BITS(VDIN_BLKBAR_IND_LEFT2_CNT,BLKBAR_LEFT2_CNT_BIT,BLKBAR_LEFT2_CNT_WID);
-        	
-		if(hleft1 >= (fmt_info_p->v_active>>black_bar_v1) && (hleft2 <= fmt_info_p->v_active>>black_bar_v2)){   
-                adc->cmd_status = TVAFE_CMD_STATUS_SUCCESSFUL;
-				if(cnt==4)
-                	adc->vga_parm.hpos_step += (barhstart);
-				else
-					adc->vga_parm.hpos_step += (barhstart+1);
-                if(adc_dbg_en)
-                        pr_info("[vdin..]%s: detect end left border barstart=%u.\n",__func__,barhstart);
-                                        
-        }
-
-        if(adc->cmd_status == TVAFE_CMD_STATUS_SUCCESSFUL){
-                //reset adc digital pll after vga auto done 
-				//tvafe_vga_border_detect_disable();
-				adc->vga_auto.phase_state = VGA_PHASE_IDLE;
-	        //tvafe_adc_set_frame_skip_number(adc, 4);
-        } else {        
-                WRITE_CBUS_REG(VDIN_BLKBAR_H_START_END,barhend|barhstart<<16);                      
-        }
-        if(adc_dbg_en)
-                pr_info("[vdin..]%s:cnt %d hleft1 cnt %u, hleft2 cnt %u, hright1 cnt %u,hright2 cnt %u,barhend %u,barhstart %u.\n",
-                        __func__,cnt,hleft1,hleft2,hright1,hright2,barhend,barhstart);
-}
-/*
-*use vdin black bar detection to detect border
-*/
-void tvin_vdin_bbar_init(enum tvin_sig_fmt_e fmt)
-{
-        const struct tvin_format_s *fmt_info_p;
-        fmt_info_p = tvin_get_fmt_info(fmt);
-        if(!fmt_info_p){
-                pr_info("[tvafe]%s: null pointer error.\n",__func__);
-                return;
-        }
-        //disable reset
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,0, BLKBAR_DET_SOFT_RST_N_BIT, BLKBAR_DET_SOFT_RST_N_WID);
-
-		WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,0x1f, BLKBAR_BLK_LVL_BIT, BLKBAR_BLK_LVL_WID);
-		WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,0, BLKBAR_DIN_SEL_BIT, BLKBAR_DIN_SEL_WID);
-	
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,1, BLKBAR_SW_STAT_EN_BIT, BLKBAR_SW_STAT_EN_WID);
-		WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,1, BLKBAR_H_WIDTH_BIT, BLKBAR_H_WIDTH_WID);
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_H_START_END,(fmt_info_p->h_active - 1), BLKBAR_HEND_BIT, BLKBAR_HEND_WID);        
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_H_START_END,0, BLKBAR_HSTART_BIT, BLKBAR_HSTART_WID);
-        // win_ve
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_V_START_END,(fmt_info_p->v_active - 1), BLKBAR_VEND_BIT, BLKBAR_VEND_WID);
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_V_START_END,0, BLKBAR_VSTART_BIT, BLKBAR_VSTART_WID);
-        WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,1, BLKBAR_DET_TOP_EN_BIT, BLKBAR_DET_TOP_EN_WID);
-
-		WRITE_CBUS_REG_BITS(VDIN_BLKBAR_CTRL0,1, BLKBAR_DET_SOFT_RST_N_BIT, BLKBAR_DET_SOFT_RST_N_WID);
-        // manual reset, rst = 0 & 1, raising edge mode        
-}
-/*
- * tvafe vga auto phase funtion
- */
-static void tvafe_vga_auto_phase_handler(enum tvin_sig_fmt_e fmt, struct tvafe_adc_s *adc)
-{
-	unsigned int sum = 0, hs = 0, he = 0, vs = 0, ve = 0;
-	struct tvafe_vga_auto_s *vga_auto = &adc->vga_auto;
-	struct tvafe_vga_parm_s *vga_parm = &adc->vga_parm;
-
-	switch (vga_auto->phase_state) {
-		case VGA_PHASE_IDLE:
-			break;
-		case VGA_PHASE_INIT:
-			vga_auto->adj_cnt         = 0;
-			vga_auto->ap_max_diff     = 0;
-			vga_auto->ap_pha_index    = VGA_ADC_PHASE_0;
-			vga_auto->ap_phamax_index = VGA_ADC_PHASE_0;
-			vga_auto->ap_win_index    = VGA_PHASE_WIN_INDEX_0;
-			vga_auto->ap_winmax_index = VGA_PHASE_WIN_INDEX_0;
-			//tvafe_vga_set_phase(vga_auto->ap_pha_index);
-			vga_parm->phase = (unsigned short)vga_auto->ap_pha_index;
-			tvafe_vga_auto_phase_init( fmt, vga_auto->ap_win_index);
-			vga_auto->phase_state = VGA_PHASE_SEARCH_WIN;
-			vga_auto->vs_cnt = 0;
-			break;
-		case VGA_PHASE_SEARCH_WIN:
-			if (++vga_auto->adj_cnt > VGA_AUTO_TRY_COUNTER)
-			{
-				vga_auto->phase_state = VGA_PHASE_EXCEPTION;
-			}
-			else
-			{
-				if (vga_auto->vs_cnt > AUTO_PHASE_VS_CNT)
-				{
-
-					vga_auto->vs_cnt = 0;
-					sum = tvafe_vga_get_ap_diff();
-					if (vga_auto->ap_max_diff < sum)
-					{
-						vga_auto->ap_max_diff = sum;
-						vga_auto->ap_winmax_index = vga_auto->ap_win_index;
-					}
-					if (unlikely(++vga_auto->ap_win_index > VGA_PHASE_WIN_INDEX_MAX))
-					{
-						tvafe_adc_set_ap_window(fmt, vga_auto->ap_winmax_index);
-						vga_auto->ap_max_diff = 0;
-						vga_auto->phase_state = VGA_PHASE_ADJ;
-					}
-					else
-						tvafe_adc_set_ap_window(fmt, vga_auto->ap_win_index);
-				}
-			}
-			break;
-		case VGA_PHASE_ADJ:
-			if (++vga_auto->adj_cnt > VGA_AUTO_TRY_COUNTER)
-			{
-				vga_auto->phase_state = VGA_PHASE_EXCEPTION;
-			}
-			else
-			{
-				if (vga_auto->vs_cnt > AUTO_PHASE_VS_CNT)
-				{
-					vga_auto->vs_cnt = 0;
-					sum = tvafe_vga_get_ap_diff();
-					if (adc_dbg_en)
-						printk("sum=%d,vga_auto->ap_pha_index=%d\n",sum,vga_auto->ap_pha_index);
-					if (vga_auto->ap_max_diff <= sum)
-					{
-						vga_auto->ap_max_diff = sum;
-						vga_auto->ap_phamax_index = vga_auto->ap_pha_index;
-					}
-					if (++vga_auto->ap_pha_index > VGA_ADC_PHASE_MAX)
-					{
-						tvafe_vga_set_phase(vga_auto->ap_phamax_index);                        
-						//tvafe_adc_digital_reset();  //added for phase abnormal bug.
-						//vga_parm->phase = (unsigned short)vga_auto->ap_phamax_index;
-						//enable border detect                        
-						tvafe_vga_auto_phase_disable();
-						tvafe_vga_border_detect_enable();
-						tvafe_vga_border_detect_init(fmt);
-						vga_auto->phase_state = VGA_PHASE_END;
-					if (adc_dbg_en)
-						printk("End:sum=%d,vga_auto->ap_pha_index=%d\n",sum,vga_auto->ap_pha_index);
-					}
-					else
-						//tvafe_vga_set_phase(vga_auto->ap_pha_index);
-						vga_parm->phase = (unsigned short)vga_auto->ap_pha_index;
-				}
-			}
-			break;
-		case VGA_PHASE_EXCEPTION: //stop auto
-			// disable auto phase
-			if (adc_dbg_en)
-				pr_info("[tvafe..] %s: auto phase error!!! \n",__func__);
-			tvafe_vga_auto_phase_disable();
-			adc->cmd_status = TVAFE_CMD_STATUS_FAILED;
-			vga_auto->phase_state = VGA_PHASE_IDLE;
-		case VGA_PHASE_END: //auto position
-			/*if(vga_auto->vs_cnt == 10)
-			  {
-			  tvafe_vga_border_detect_enable();
-			  tvafe_vga_border_detect_init(fmt);
-			  }*/
-			if (vga_auto->vs_cnt > AUTO_CLK_VS_CNT)
-			{
-				//vga_auto->vs_cnt = 0;
-				tvafe_vga_get_h_border(vga_auto);
-				tvafe_vga_get_v_border(vga_auto);
-				if (adc_dbg_en)
-					pr_info("[tvafe..] %s:border detect end ! ve: %d,vs: %d,he: %d,hs: %d\n",
-							__func__,vga_auto->border.vend,vga_auto->border.vstart,
-							vga_auto->border.hend,vga_auto->border.hstart);
-				if (vga_auto->border.hstart < (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp))
-				{
-					hs = vga_auto->border.hstart;
-					he = hs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active - 1;
-				}
-				else if (((vga_auto->border.hend - vga_auto->border.hstart + 1) >= tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active) ||
-						(vga_auto->border.hend > (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active - 1))
-					)
-				{
-					he = vga_auto->border.hend;
-					hs = he - tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active + 1;
-				}
-				else
-				{
-					hs = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp;
-					he = hs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active - 1;
-				}
-				if (((vga_auto->border.vend - vga_auto->border.vstart + 1) >= tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active) ||
-						(vga_auto->border.vend > (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1))
-				   )
-				{
-					ve = vga_auto->border.vend;
-					vs = ve - tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active + 1;
-				}
-				else if (vga_auto->border.vstart < (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp))
-				{
-					vs = vga_auto->border.vstart;
-					ve = vs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1;
-				}
-				else
-				{
-					vs = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp;
-					ve = vs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1;
-				}
-				if (adc_dbg_en)
-					pr_info("[tvafe..] %s: auto phase finish,phase:%d,hs:%d,he:%d,vs:%d,ve:%d\n",__func__,
-							tvafe_vga_get_phase(), hs, he, vs, ve);
-				//update phase information in frame struct                 
-				vga_parm->phase = (unsigned short)vga_auto->ap_phamax_index;
-				//tvafe_vga_set_h_pos(hs, he);
-				vga_parm->hpos_step =   (signed short)he
-					+ (signed short)1
-					- (signed short)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width
-					- (signed short)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp
-					- (signed short)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active;
-				//tvafe_vga_set_v_pos(vs, ve, tvin_vga_fmt_tbl[tvinfo->fmt - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].scan_mode);//tvafe_top_get_scan_mode());
-				//due to bar det ,it must adj the hs  
-				vga_parm->vpos_step =   (signed short)ve
-					+ (signed short)1
-					- (signed short)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width
-					- (signed short)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp
-					- (signed short)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active;
-				// disable border detect
-				
-				//tvafe_vga_border_detect_disable();
-				// disable auto phase
-				tvafe_vga_auto_phase_disable();
-				//adc->cmd_status = TVAFE_CMD_STATUS_SUCCESSFUL;
-				vga_parm->hpos_step -= bar_width;
-				tvafe_adc_set_frame_skip_number(adc, 10);
-				
-				vga_auto->phase_state = VGA_BORDER_DET_INIT;
-				vga_auto->vs_cnt = 0;
-			}
-			break;
-				case VGA_BORDER_DET_INIT:
-					if(vga_auto->vs_cnt > 10){
-						tvafe_adc_set_frame_skip_number(adc, 10);
-						tvafe_adc_digital_reset();
-						tvin_vdin_bbar_init(fmt);
-						vga_auto->phase_state = VGA_BORDER_DET;
-						vga_auto->vs_cnt = 0;
-					}
-					break;
-                case VGA_BORDER_DET:
-                        if(vga_auto->vs_cnt > 10){
-                                vga_auto->vs_cnt  = 0;
-                                vga_auto->phase_state = VGA_VDIN_BORDER_DET;
-                        }
-                        break;
-		default:
-			break;
-	}
-
-	return;
-}
-
-/*
- * tvafe enable vga suto adjust function
- */
-int tvafe_vga_auto_adjust_enable(struct tvafe_adc_s *adc)
-{
-	int ret = 0;
-
-	if (adc->cmd_status  == TVAFE_CMD_STATUS_IDLE)
-	{
-		adc->cmd_status           = TVAFE_CMD_STATUS_PROCESSING;
-		adc->vga_auto.clk_state   = VGA_CLK_INIT;
-		adc->vga_auto.phase_state = VGA_PHASE_IDLE;
-		adc->auto_enable          = true;
-	}
-	else
-	{
-		adc->cmd_status           = TVAFE_CMD_STATUS_FAILED;
-		adc->vga_auto.clk_state   = VGA_CLK_IDLE;
-		adc->vga_auto.phase_state = VGA_PHASE_IDLE;
-		adc->auto_enable          = false;
-		ret = -EAGAIN;
-	}
-
-	return ret;
-}
-
-/*
- * tvafe disenable vga suto adjust function
- */
-void tvafe_vga_auto_adjust_disable(struct tvafe_adc_s *adc)
-{
-	struct tvafe_vga_auto_s *vga_auto = &adc->vga_auto;
-
-	if (adc->cmd_status == TVAFE_CMD_STATUS_PROCESSING)
-	{
-		adc->cmd_status       = TVAFE_CMD_STATUS_TERMINATED;
-		vga_auto->clk_state   = VGA_CLK_IDLE;
-		vga_auto->phase_state = VGA_PHASE_IDLE;
-		adc->auto_enable      = false;
-	}
-}
-
-/*
- * tvafe vga suto adjust function
- */
-void tvafe_vga_auto_adjust_handler(struct tvin_parm_s *parm, struct tvafe_adc_s *adc)
-{
-	enum tvin_port_e port = parm->port;
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-
-	if (((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7)) &&
-			(adc->auto_enable == 1))
-	{
-		//auto clock handler
-		tvafe_vga_auto_clock_handler(fmt, adc);
-
-		// auto phase handler after auto clock
-		tvafe_vga_auto_phase_handler(fmt, adc);
-
-		if ((adc->cmd_status == TVAFE_CMD_STATUS_FAILED) ||
-				(adc->cmd_status == TVAFE_CMD_STATUS_SUCCESSFUL)
-		   )
-			adc->auto_enable = 0;
-	}
-
-}
-
-
-static void tvafe_adc_clear(unsigned int val, unsigned int clear)
-{
-	unsigned int i=0;
-
-	for (i=0; i<ADC_REG_NUM; i++)
-	{
-		if (clear)
-		{
-			WRITE_APB_REG((ADC_BASE_ADD+i)<<2, ((i == 0x21) ? val : 0));
-		}
-		else
-		{
-			WRITE_APB_REG(ADC_REG_21, val);
-		}
-	}
-}
-
-/*
- * tvafe adc Reg table configure for vga/comp/cvbs
- */
-void tvafe_adc_configure(enum tvin_sig_fmt_e fmt)
-{
-	int i = 0;
-	const unsigned char *buff_t = NULL;
-
-	/*adc reset*/
-	tvafe_adc_clear(TVAFE_ADC_CONFIGURE_INIT, 1);
-	tvafe_adc_clear(TVAFE_ADC_CONFIGURE_NORMAL, 1);
-	tvafe_adc_clear(TVAFE_ADC_CONFIGURE_RESET_ON, 1);
-
-	if (fmt < TVIN_SIG_FMT_VGA_MAX && fmt > TVIN_SIG_FMT_NULL) // VGA formats
-	{
-		buff_t = adc_vga_table[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147];
-	}
-	else if (fmt < TVIN_SIG_FMT_COMP_MAX && fmt > TVIN_SIG_FMT_VGA_THRESHOLD) // Component formats
-	{
-		buff_t = adc_component_table[fmt-TVIN_SIG_FMT_COMP_480P_60HZ_D000];
-	}
-	// CVBS formats
-        else if(fmt < TVIN_SIG_FMT_CVBS_MAX && fmt > TVIN_SIG_FMT_HDMI_THRESHOLD)
-	{
-		buff_t = adc_cvbs_table;
-	}
-        else
-        {
-                pr_err("[tvafe..]%s: invaild fmt %s.\n",__func__,tvin_sig_fmt_str(fmt));
-                return;
-        }
-
-	for (i=0; i<ADC_REG_NUM; i++)
-	{
-		WRITE_APB_REG(((ADC_BASE_ADD+i)<<2), (unsigned int)(buff_t[i]));
-	}
-	//set componet different phase base on board design
-	if(fmt > TVIN_SIG_FMT_VGA_MAX && fmt < TVIN_SIG_FMT_COMP_MAX && enable_dphase)
-	{
-		WRITE_APB_REG_BITS(ADC_REG_56, comp_phase[fmt-TVIN_SIG_FMT_VGA_THRESHOLD -1],CLKPHASEADJ_BIT,CLKPHASEADJ_WID);
-	}
-	//for adc calibration clamping duration setting
-	if (fmt < TVIN_SIG_FMT_COMP_MAX)
-	{
-		tvafe_adc_set_clamp_para(fmt);
-	}
-
-	/* adc config normal */
-	tvafe_adc_clear(TVAFE_ADC_CONFIGURE_NORMAL, 0);
-#ifdef TVAFE_DEBUG_PIN_ENABLE
-	//debug setting
-	// diable other mux on test pins 0~27 & 30
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0 , READ_CBUS_REG(PERIPHS_PIN_MUX_0 )&0xcff0ffdf);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_1 , READ_CBUS_REG(PERIPHS_PIN_MUX_1 )&0xfc017fff);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_2 , READ_CBUS_REG(PERIPHS_PIN_MUX_2 )&0xe001ffff);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_3 , READ_CBUS_REG(PERIPHS_PIN_MUX_3 )&0xfc000000);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_4 , READ_CBUS_REG(PERIPHS_PIN_MUX_4 )&0xff8007ff);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_6 , READ_CBUS_REG(PERIPHS_PIN_MUX_6 )&0xffffffbf);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_7 , READ_CBUS_REG(PERIPHS_PIN_MUX_7 )&0xff00003f);
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_10, READ_CBUS_REG(PERIPHS_PIN_MUX_10)&0xffffffb3);
-	// enable TVFE_TEST mux on test pins 0~27 & 30
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_9 , 0x4fffffff);//
-#endif
-
-}
-void tvafe_adc_comphase_pr()
-{
-	int i = 0;
-	for(i=0; i<TVIN_SIG_FMT_COMP_MAX-TVIN_SIG_FMT_VGA_THRESHOLD-1; i++)
-		printk("[tvafe..] %s phase 0x%x.\n",tvin_sig_fmt_str(i+TVIN_SIG_FMT_VGA_MAX+1), comp_phase[i]);
-}
-
-void tvafe_adc_set_deparam( struct tvin_parm_s *parm, struct tvafe_adc_s *adc)
-{
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-	//tvafe_vga_set_clock(tvin_vga_fmt_tbl[fmt - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1);
-	tvafe_vga_set_h_pos( tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp, tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active - 1);
-	tvafe_vga_set_v_pos( tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width, tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1,tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].scan_mode);
-	if (adc_parm_en)
-		pr_info("[tvafe..] %s: set default parameters \n",__func__);
-}
-/*
- * tvafe vga paramters adjustment: h-position, v-position, phase, clock
- */
-void tvafe_adc_set_param(struct tvin_parm_s *parm, struct tvafe_adc_s *adc)
-{
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-	struct tvafe_vga_parm_s *vga_parm = &adc->vga_parm;
-	signed int data = 0;
-	signed int step = 0;
-	unsigned int tmp = 0;
-	unsigned int hs = 0;
-	unsigned int he = 0;
-	unsigned int vs = 0;
-	unsigned int ve = 0;
-#if 1  //disable manual clock
-	data = (signed int)(vga_parm->clk_step);// * (tvin_fmt_tbl[fmt].h_total - 1)>>12);  //htotal/2^12
-	tmp = (unsigned int)((signed int)(tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1) + data);
-	if (tmp != tvafe_vga_get_clock())
-	{
-		tvafe_vga_set_clock(tmp);
-		if(!adc->auto_enable)
-			tvafe_adc_set_frame_skip_number(adc, 2);
-		if (adc_parm_en)
-			pr_info("[tvafe..] %s: set clk=%d \n",__func__, tmp);
-	}
-#endif
-	// phase
-	if (vga_parm->phase > VGA_ADC_PHASE_MAX)
-		vga_parm->phase = VGA_ADC_PHASE_MAX;
-	tmp = vga_parm->phase;
-	if (tmp != tvafe_vga_get_phase())
-	{
-		tvafe_vga_set_phase(tmp);
-		/*removed and keep adc_15 7'b 0 in m2c*/
-		  tvafe_adc_digital_reset();
-		  tvafe_adc_set_frame_skip_number(adc, 4);
-		if (adc_parm_en)
-			pr_info("[tvafe..] %s: set phase=%d \n",__func__, tmp);
-	}
-	// hpos
-	step = (signed int)vga_parm->hpos_step;
-	data = (signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp;
-	if (step + data < 0)
-	{
-		hs = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + (unsigned int)((data + step)%8 + 8);
-		he = (unsigned int)((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + (signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active
-				+ data + step) - 1;
-	}
-	else
-	{
-		hs = (unsigned int)((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width + data + step);
-		he = hs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_active - 1;
-		//avoid he is bigger than h total
-		he = he > (tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1)?(tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1):he;
-	}
-	if (adc_parm_en)
-		pr_info("[tvafe..] %s: step %d,set hs=%d \n",__func__,step, hs);
-	tvafe_vga_set_h_pos(hs, he);
-	// vpos
-	step = (signed int)vga_parm->vpos_step;
-	data = (signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp;
-	if (step + data - vbp_offset < 0)
-	{
-		vs = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + vbp_offset;
-		ve = (unsigned int)((signed int)vs + (signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active + data + step - vbp_offset) - 1;
-	}//avoid ve is bigger than v total
-	else if((1 == tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_front)&&(0<step))
-	{
-		vs = (unsigned int)((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + data +1);
-		ve = vs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1;
-	}
-	else if(step +1 > tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_front)
-	{
-		vs = (unsigned int)((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + data + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_front -1);
-		ve = vs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1;
-		if (adc_parm_en)
-			pr_info("[tvafe..] %s: vstep %u>vs_front enable %u cut window.\n",__func__,step,tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_front);
-	}
-	else
-	{
-		vs = (unsigned int)((signed int)tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width + data + step);
-		ve = vs + tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].v_active - 1;
-	}
-	if (adc_parm_en)
-		pr_info("[tvafe..] %s: step %d,set vs=%d ve=%d\n",__func__,step,vs,ve);
-	tvafe_vga_set_v_pos(vs, ve, tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].scan_mode);
-
-	//tvafe_adc_set_frame_skip_number(adc, 2);
-
-}
-
-/*
- * tvafe get vga paramters: h-position, v-position, phase, clock
- */
-void tvafe_adc_get_param(struct tvin_parm_s *parm, struct tvafe_adc_s *adc)
-{
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-	struct tvafe_vga_parm_s *vga_parm = &adc->vga_parm;
-
-	vga_parm->clk_step  = (signed short)(tvafe_vga_get_clock() -
-			(tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total - 1));
-	vga_parm->phase     = tvafe_vga_get_phase();
-	vga_parm->hpos_step = (signed short)(tvafe_vga_get_h_pos() -
-			tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_width   -
-			tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].hs_bp);
-	vga_parm->vpos_step = (signed short)(tvafe_vga_get_v_pos() -
-			tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_width   -
-			tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].vs_bp);
-
-	if (adc_parm_en)
-		pr_info("[tvafe..] %s: get clk=%d  phase=%d  h_step=%d  v_step=%d\n",__func__,
-				vga_parm->clk_step, vga_parm->phase, vga_parm->hpos_step, vga_parm->vpos_step);
-
-}
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_adc.h b/drivers/amlogic/tvin/tvafe/tvafe_adc.h
deleted file mode 100755
index b956a52313ba..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_adc.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*******************************************************************
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *  File name: TVAFE_ADC.h
- *  Description: IO function, structure, enum, used in TVIN AFE sub-module processing
- *******************************************************************/
-#ifndef _TVAFE_ADC_H
-#define _TVAFE_ADC_H
-
-#include <linux/amlogic/tvin/tvin.h>
-
-//#define TVAFE_DEBUG_PIN_ENABLE
-#define TVAFE_ADC_CONFIGURE_INIT     1
-#define TVAFE_ADC_CONFIGURE_NORMAL   1|(1<<POWERDOWNZ_BIT)|(1<<RSTDIGZ_BIT) // 7
-#define TVAFE_ADC_CONFIGURE_RESET_ON 1|(1<<POWERDOWNZ_BIT)
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-//auto clock detection state machine
-typedef enum tvafe_vga_auto_clk_state_e {
-	VGA_CLK_IDLE,
-	VGA_CLK_INIT,
-	VGA_CLK_ROUGH_ADJ,
-	VGA_CLK_FINE_ADJ,
-	VGA_CLK_EXCEPTION,
-	VGA_CLK_END,
-} tvafe_vga_auto_clk_state_t;
-
-//auto phase state machine
-typedef enum tvafe_vga_auto_phase_state_e {
-	VGA_PHASE_IDLE,
-	VGA_PHASE_INIT,                     //auto phase init
-	VGA_PHASE_SEARCH_WIN,
-	VGA_PHASE_ADJ,                      //write all the phase value, get the best value by the sum value
-	VGA_PHASE_EXCEPTION,
-	VGA_PHASE_END,
-	VGA_BORDER_DET_INIT,
-	VGA_BORDER_DET,
-	VGA_VDIN_BORDER_DET,
-} tvafe_vga_auto_phase_state_t;
-
-typedef struct tvafe_vga_border_s {
-	unsigned int hstart;
-	unsigned int hend;
-	unsigned int vstart;
-	unsigned int vend;
-} tvafe_vga_border_t;
-
-typedef struct tvafe_vga_auto_s {
-	enum tvafe_vga_auto_clk_state_e   clk_state;
-	enum tvafe_vga_auto_phase_state_e phase_state;
-	struct tvafe_vga_border_s         border;
-	unsigned char                     ap_win_index;
-	unsigned char                     ap_winmax_index;
-	unsigned char                     ap_pha_index;
-	unsigned char                     ap_phamax_index;
-	unsigned char                     vs_cnt;
-	unsigned char                     adj_cnt;
-	signed char                     adj_dir;
-	unsigned int                      ap_max_diff;
-} tvafe_vga_auto_t;
-
-typedef struct tvafe_adc_s {
-	/* status of command */
-	enum tvafe_cmd_status_e    cmd_status;
-	unsigned char                       auto_enable;  //adc auto adjust enable
-	struct tvafe_vga_auto_s        vga_auto;
-
-	struct tvafe_vga_parm_s       vga_parm;
-
-	struct tvin_format_s               hw_info;
-	unsigned char                       hs_sog_sw_cnt;
-	unsigned char                       adc_reset_cnt;
-	unsigned int                          skip_frame_cnt;
-	enum tvin_sig_fmt_e             current_fmt;
-} tvafe_adc_t;
-
-// *****************************************************************************
-// ******** GLOBAL FUNCTION CLAIM ********
-// *****************************************************************************
-extern void tvafe_adc_set_deparam(struct tvin_parm_s *parm, struct tvafe_adc_s *adc);
-extern void tvafe_adc_set_param(struct tvin_parm_s *parm, struct tvafe_adc_s *adc);
-extern void tvafe_adc_get_param( struct tvin_parm_s *parm, struct tvafe_adc_s *adc);
-extern void tvafe_vga_vs_cnt(struct tvafe_adc_s *adc);
-extern void tvafe_vga_auto_adjust_handler( struct tvin_parm_s *parm, struct tvafe_adc_s *adc);
-extern int  tvafe_vga_auto_adjust_enable(struct tvafe_adc_s *adc);
-extern void tvafe_vga_auto_adjust_disable(struct tvafe_adc_s *adc);
-extern bool tvafe_adc_no_sig(void);
-extern bool tvafe_adc_fmt_chg(struct tvin_parm_s *parm, struct tvafe_adc_s *adc);
-extern enum tvin_sig_fmt_e tvafe_adc_search_mode(struct tvin_parm_s *parm, struct tvafe_adc_s *adc);
-extern bool tvafe_adc_get_pll_status(void);
-extern bool tvafe_adc_check_frame_skip(struct tvafe_adc_s *adc);
-
-extern void tvafe_adc_configure( enum tvin_sig_fmt_e fmt);
-extern void tvafe_adc_digital_reset(void);
-extern void tvafe_adc_comphase_pr(void);
-extern void tvin_vdin_bar_detect(enum tvin_sig_fmt_e fmt, struct tvafe_adc_s *adc);
-extern void tvin_vdin_bbar_init(enum tvin_sig_fmt_e fmt);
-
-#endif // _TVAFE_ADC_H
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_cvd.c b/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
deleted file mode 100755
index 5ae54704deb5..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_cvd.c
+++ /dev/null
@@ -1,2132 +0,0 @@
-/*
- * TVAFE cvd2 device driver.
- *
- * Copyright (c) 2010 Frank zhao <frank.zhao@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-/******************************Includes************************************/
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <asm/uaccess.h>
-#include <asm/uaccess.h>
-#include <asm/div64.h>
-#include <linux/module.h>
-
-#include <mach/am_regs.h>
-
-#include <linux/amlogic/tvin/tvin.h>
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "tvafe_regs.h"
-#include "tvafe_adc.h"
-#include "tvafe_cvd.h"
-#include "../vdin/vdin_regs.h"
-/***************************Local defines**********************************/
-/* cvd2 memory size defines */
-#define DECODER_MOTION_BUFFER_ADDR_OFFSET   0x70000
-#define DECODER_MOTION_BUFFER_4F_LENGTH     0x15a60
-#define DECODER_VBI_ADDR_OFFSET             0x86000
-#define DECODER_VBI_VBI_SIZE                0x1000
-#define DECODER_VBI_START_ADDR              0x0
-
-/* cvd2 mode detection defines */
-#define TVAFE_CVD2_CORDIC_IN_MAX            224  //CVD cordic range of right fmt
-#define TVAFE_CVD2_CORDIC_IN_MIN            85  //0x20
-
-#define TVAFE_CVD2_CORDIC_OUT_MAX           192  //CVD cordic range of error fmt
-#define TVAFE_CVD2_CORDIC_OUT_MIN           96  //0x40
-
-#define TVAFE_CVD2_STATE_CNT                15  //cnt*10ms,delay between fmt check funtion
-#define TVAFE_CVD2_SHIFT_CNT                5   //cnt*10ms,delay for fmt shift counter
-
-#define TVAFE_CVD2_NONSTD_DGAIN_MAX         0x500  //CVD max digital gain for non-std signal
-#define TVAFE_CVD2_NONSTD_CNT_MAX           0x0A  //CVD max cnt non-std signal
-
-#define TVAFE_CVD2_FMT_LOOP_CNT             1   //n*loop, max fmt check loop counter
-
-/* cvd2 function in vsync */
-#define CVD_3D_COMB_CHECK_MAX_CNT           100  //cnt*vs_interval,3D comb error check delay
-
-#define TVAFE_CVD2_CDTO_ADJ_TH              0x4CEDB3  //CVD cdto adjust threshold
-#define TVAFE_CVD2_CDTO_ADJ_STEP            3     //CVD cdto adjust step cdto/2^n
-
-#define TVAFE_CVD2_PGA_MIN                  0    //CVD max cnt non-std signal
-#define TVAFE_CVD2_PGA_MAX                  255   //CVD max cnt non-std signal
-
-#define PAL_BURST_MAG_UPPER_LIMIT           0x1C80
-#define PAL_BURST_MAG_LOWER_LIMIT           0x1980
-
-#define NTSC_BURST_MAG_UPPER_LIMIT          0x1580
-#define NTSC_BURST_MAG_LOWER_LIMIT          0x1280
-
-#define SYNC_HEIGHT_LOWER_LIMIT             0x60
-#define SYNC_HEIGHT_UPPER_LIMIT             0xFF
-
-#define SYNC_HEIGHT_ADJ_CNT                 0x2
-
-/* cvd2 function in 10ms timer */
-#define TVAFE_CVD2_NOSIG_REG_CHECK_CNT      50   //n*10ms
-#define TVAFE_CVD2_NORMAL_REG_CHECK_CNT     100  //n*10ms
-
-//zhuangwei, nonstd flag 
-#define CVD2_NONSTD_CNT_INC_STEP 1
-#define CVD2_NONSTD_CNT_DEC_STEP 1
-#define CVD2_NONSTD_CNT_INC_LIMIT 50 
-#define CVD2_NONSTD_CNT_DEC_LIMIT 1 //should be large than CVD2_NONSTD_CNT_DEC_STEP
-#define CVD2_NONSTD_FLAG_ON_TH 10
-#define CVD2_NONSTD_FLAG_OFF_TH 2
-
-#define SCENE_COLORFUL_TH 0x80000
-/********************************Local variables*********************************/
-/* debug value */
-#ifdef CONFIG_AM_SI2176
-static int cordic_tv_in_min = 133;
-static int cordic_tv_in_max = 224;
-static int cordic_tv_out_min = 134;
-static int cordic_tv_out_max = 192;
-#else
-static int cordic_tv_in_min = TVAFE_CVD2_CORDIC_IN_MIN;
-static int cordic_tv_in_max = TVAFE_CVD2_CORDIC_IN_MAX;
-static int cordic_tv_out_min = TVAFE_CVD2_CORDIC_OUT_MIN;
-static int cordic_tv_out_max = TVAFE_CVD2_CORDIC_OUT_MAX;
-#endif
-
-static int cordic_av_in_min = TVAFE_CVD2_CORDIC_IN_MIN;
-static int cordic_av_in_max = TVAFE_CVD2_CORDIC_IN_MAX;
-static int cordic_av_out_min = TVAFE_CVD2_CORDIC_OUT_MIN;
-static int cordic_av_out_max = TVAFE_CVD2_CORDIC_OUT_MAX;
-static int cnt_dbg_en=0;
-static int force_fmt_flag=0;
-static unsigned int scene_colorful=1;
-static int scene_colorful_old=0;
-static int auto_de_en=1;
-
-static unsigned int cvd_reg8a = 0xa;
-
-module_param(auto_de_en,int,0664);
-MODULE_PARM_DESC(auto_de_en,"auto_de_en\n");
-
-module_param(cnt_dbg_en,int,0664);
-MODULE_PARM_DESC(cnt_dbg_en,"cnt_dbg_en\n");
-
-module_param(cordic_av_in_min,int,0664);
-MODULE_PARM_DESC(cordic_av_in_min,"cordic_av_in_min");
-
-module_param(cordic_av_in_max,int,0644);//CVD cordic range of right fmt
-MODULE_PARM_DESC(cordic_av_in_max,"cordic_av_in_max");
-
-module_param(cordic_av_out_min,int,0664);
-MODULE_PARM_DESC(cordic_av_out_min,"cordic_av_out_min");
-
-module_param(cordic_av_out_max,int,0644);//CVD cordic range of error fmt
-MODULE_PARM_DESC(cordic_av_out_max,"cordic_av_out_max");
-
-module_param(cordic_tv_in_min,int,0664);
-MODULE_PARM_DESC(cordic_tv_in_min,"cordic_tv_in_min");
-
-module_param(cordic_tv_in_max,int,0644);//CVD cordic range of right fmt
-MODULE_PARM_DESC(cordic_tv_in_max,"cordic_tv_in_max");
-
-module_param(cordic_tv_out_min,int,0664);
-MODULE_PARM_DESC(cordic_tv_out_min,"cordic_tv_out_min");
-
-module_param(cordic_tv_out_max,int,0644);//CVD cordic range of error fmt
-MODULE_PARM_DESC(cordic_tv_out_max,"cordic_tv_out_max");
-
-static int cdto_adj_th = TVAFE_CVD2_CDTO_ADJ_TH;
-module_param(cdto_adj_th, int, 0664);
-MODULE_PARM_DESC(cdto_adj_th, "cvd2_adj_diff_threshold");
-
-static int cdto_adj_step = TVAFE_CVD2_CDTO_ADJ_STEP;
-module_param(cdto_adj_step, int, 0664);
-MODULE_PARM_DESC(cdto_adj_step, "cvd2_adj_step");
-
-static int cvd_dbg_en = 0;
-module_param(cvd_dbg_en, bool, 0664);
-MODULE_PARM_DESC(cvd_dbg_en, "cvd2 debug enable");
-
-static int cvd_nonstd_dbg_en = 0;
-module_param(cvd_nonstd_dbg_en, bool, 0664);
-MODULE_PARM_DESC(cvd_nonstd_dbg_en, "cvd2 nonstd debug enable");
-
-
-static int ntsc_sw_maxcnt = 20;
-module_param(ntsc_sw_maxcnt, int, 0664);
-MODULE_PARM_DESC(ntsc_sw_maxcnt, "ntsc_sw_maxcnt");
-
-static int ntsc_sw_midcnt = 40;
-module_param(ntsc_sw_midcnt, int, 0664);
-MODULE_PARM_DESC(ntsc_sw_midcnt, "ntsc_sw_midcnt");
-
-static int fmt_try_maxcnt = 5;
-module_param(fmt_try_maxcnt, int, 0664);
-MODULE_PARM_DESC(fmt_try_maxcnt, "fmt_try_maxcnt");
-
-static int fmt_wait_cnt = 25;
-module_param(fmt_wait_cnt, int, 0664);
-MODULE_PARM_DESC(fmt_wait_cnt, "fmt_wait_cnt");
-/*force the fmt for chrome off,for example ntsc pal_i 12*/
-static unsigned int config_force_fmt = 0;
-module_param(config_force_fmt,uint,0664);
-MODULE_PARM_DESC(config_force_fmt,"after try try_format_cnt times ,we will force one fmt");
-
-static int cvd_reg07_pal = 0x03;
-module_param(cvd_reg07_pal, int, 0664);
-MODULE_PARM_DESC(cvd_reg07_pal, "cvd_reg07_pal");
-
-static unsigned short cnt_vld_th = 0x30;
-module_param(cnt_vld_th, ushort, 0664);
-MODULE_PARM_DESC(cnt_vld_th, "threshold for 4xx or 3xx vaild.");
-/*0:normal 1:force nonstandard configure 2:force don't nonstandard configure*/
-static unsigned int  force_nostd = 2;
-module_param(force_nostd,uint,0644);
-MODULE_PARM_DESC(force_nostd,"fixed nosig problem by removing the nostd config.\n");
-
-/*0x001:enable cdto adj 0x010:enable 3d adj 0x100:enable pga*/
-static unsigned int  cvd_isr_en = 0x111;
-module_param(cvd_isr_en, uint, 0644);
-MODULE_PARM_DESC(cvd_isr_en, "cvd_isr_en\n");
-
-static bool sync_sensitivity = true;
-module_param(sync_sensitivity, bool, 0644);
-MODULE_PARM_DESC(sync_sensitivity, "sync_sensitivity\n");
-
-static uint cdto_clamp = HS_CNT_STANDARD;
-module_param(cdto_clamp, uint, 0644);
-MODULE_PARM_DESC(cdto_clamp, "cdto_clamp\n");
-
-static int  cdto_filter_factor = 1;
-module_param(cdto_filter_factor, int, 0644);
-MODULE_PARM_DESC(cdto_filter_factor, "cdto_filter_factor\n");
-
-static int noise_judge=0;
-module_param(noise_judge, int, 0644);
-MODULE_PARM_DESC(noise_judge, "cdto_filter_factor\n");
-
-
-
-
-/*for force fmt*/
-//static enum tvin_sig_fmt_e line525fmt = TVIN_SIG_FMT_NULL;
-//static enum tvin_sig_fmt_e line625fmt = TVIN_SIG_FMT_NULL;
-static unsigned int try_format_max = 7;
-static unsigned int try_format_cnt = 0;
-
-static bool cvd_pr_flag = false;
-static bool cvd_pr1_chroma_flag = false;
-static bool cvd_pr2_chroma_flag = false;
-
-//zhuangwei, nonstd experiment
-static short nonstd_cnt = 0;
-static short nonstd_flag = 0;
-static unsigned int chroma_sum_pre1 = 0;
-static unsigned int chroma_sum_pre2 = 0;
-static unsigned int chroma_sum_pre3 = 0;
-//fanghui,noise det to juge some reg setting
-static unsigned int noise1 =0 ;
-static unsigned int noise2=0;
-static unsigned int noise3=0;
-//test
-static short print_cnt=0;
-
-const static unsigned int cvd_mem_4f_length[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1] =
-{
-	0x0000e946, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	0x0000e946, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	0x00015a60, // TVIN_SIG_FMT_CVBS_PAL_I,
-	0x0000e905, // TVIN_SIG_FMT_CVBS_PAL_M,
-	0x00015a60, // TVIN_SIG_FMT_CVBS_PAL_60,
-	0x000117d9, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	0x00015a60, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-/*
- * tvafe cvd2 memory setting for 3D comb/motion detection/vbi function
- */
-static void tvafe_cvd2_memory_init(struct tvafe_cvd2_mem_s *mem, enum tvin_sig_fmt_e fmt)
-{
-	unsigned int cvd2_addr = mem->start / 8;
-
-	if ((mem->start == 0) || (mem->size == 0))
-	{
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: cvd2 memory size error!!!\n", __func__);
-		return;
-	}
-
-	/* CVD2 mem addr is based on 64bit, system mem is based on 8bit*/
-	WRITE_APB_REG(CVD2_REG_96, cvd2_addr);
-	WRITE_APB_REG(ACD_REG_30, (cvd2_addr + DECODER_MOTION_BUFFER_ADDR_OFFSET));
-	/* 4frame mode memory setting */
-	WRITE_APB_REG_BITS(ACD_REG_2A , cvd_mem_4f_length[fmt - TVIN_SIG_FMT_CVBS_NTSC_M],
-			REG_4F_MOTION_LENGTH_BIT, REG_4F_MOTION_LENGTH_WID);
-
-	/* vbi memory setting */
-	WRITE_APB_REG(ACD_REG_2F, (cvd2_addr + DECODER_VBI_ADDR_OFFSET));
-	WRITE_APB_REG_BITS(ACD_REG_21, DECODER_VBI_VBI_SIZE,
-			AML_VBI_SIZE_BIT, AML_VBI_SIZE_WID);
-	WRITE_APB_REG_BITS(ACD_REG_21, DECODER_VBI_START_ADDR,
-			AML_VBI_START_ADDR_BIT, AML_VBI_START_ADDR_WID);
-
-	return;
-}
-
-/*
- * tvafe cvd2 load Reg talbe
- */
-static void tvafe_cvd2_write_mode_reg(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem)
-{
-	unsigned int i = 0;
-
-	//reset CVD2
-	WRITE_APB_REG_BITS(CVD2_RESET_REGISTER, 1, SOFT_RST_BIT, SOFT_RST_WID);
-
-	/* for rf&cvbs source acd table */
-	if (cvd2->vd_port == TVIN_PORT_CVBS0)
-	{
-		for (i=0; i<(ACD_REG_NUM+1); i++)
-		{
-			WRITE_APB_REG(((ACD_BASE_ADD+i)<<2),
-					(rf_acd_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][i]));
-		}
-
-	}
-	else
-	{
-		for (i=0; i<(ACD_REG_NUM+1); i++)
-		{
-
-			WRITE_APB_REG(((ACD_BASE_ADD+i)<<2),
-					(cvbs_acd_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][i]));
-		}
-
-	}
-
-	// load CVD2 reg 0x00~3f (char)
-	for (i=0; i<CVD_PART1_REG_NUM; i++)
-	{
-		WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART1_REG_MIN+i)<<2),
-				(cvd_part1_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][i]));
-	}
-
-	// load CVD2 reg 0x70~ff (char)
-	for (i=0; i<CVD_PART2_REG_NUM; i++)
-	{
-		WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART2_REG_MIN+i)<<2),
-				(cvd_part2_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][i]));
-	}
-
-	// reload CVD2 reg 0x87, 0x93, 0x94, 0x95, 0x96, 0xe6, 0xfa (int)
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_0)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][0]);
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_1)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][1]);
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_2)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][2]);
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_3)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][3]);
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_4)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][4]);
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_5)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][5]);
-	WRITE_APB_REG(((CVD_BASE_ADD+CVD_PART3_REG_6)<<2),
-			cvd_part3_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][6]);
-
-	//s-video setting => reload reg 0x00~03 & 0x18~1f
-	if ((cvd2->vd_port >= TVIN_PORT_SVIDEO0) && (cvd2->vd_port <= TVIN_PORT_SVIDEO7))
-	{
-		for (i=0; i<4; i++)
-		{
-			WRITE_APB_REG(((CVD_BASE_ADD+i)<<2),
-					(cvd_yc_reg_0x00_0x03[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][i]));
-		}
-		for (i=0; i<8; i++)
-		{
-			WRITE_APB_REG(((CVD_BASE_ADD+i+0x18)<<2),
-					(cvd_yc_reg_0x18_0x1f[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][i]));
-		}
-	}
-
-	/* for tuner picture quality */
-	if (cvd2->vd_port == TVIN_PORT_CVBS0)
-	{
-		WRITE_APB_REG(CVD2_REG_B0, 0xf0);
-		WRITE_APB_REG_BITS(CVD2_REG_B2 , 0, ADAPTIVE_CHROMA_MODE_BIT, ADAPTIVE_CHROMA_MODE_WID);
-		WRITE_APB_REG_BITS(CVD2_CONTROL1, 0, CHROMA_BW_LO_BIT, CHROMA_BW_LO_WID);
-	}
-	else{
-		WRITE_APB_REG(CVD2_VSYNC_NO_SIGNAL_THRESHOLD, 0x00);
-		if(cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I)
-		         /*add for chroma state adjust dynamicly*/
-			 WRITE_APB_REG(CVD2_CHROMA_LOOPFILTER_STATE, cvd_reg8a);
-	}
-#ifdef TVAFE_CVD2_CC_ENABLE
-	WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE21, 0x00000011);
-	WRITE_APB_REG(CVD2_VSYNC_VBI_LOCKOUT_START, 0x00000000);
-	WRITE_APB_REG(CVD2_VSYNC_VBI_LOCKOUT_END, 0x00000025);
-	WRITE_APB_REG(CVD2_VSYNC_TIME_CONSTANT, 0x0000004a);
-	WRITE_APB_REG(CVD2_VBI_CC_START, 0x00000054);
-	WRITE_APB_REG(CVD2_VBI_FRAME_CODE_CTL, 0x00000015);
-	WRITE_APB_REG(ACD_REG_22, 0x82080000); // manuel reset vbi
-	WRITE_APB_REG(ACD_REG_22, 0x04080000); // vbi reset release, vbi agent enable
-#endif
-#if defined(CONFIG_TVIN_TUNER_SI2176)
-	if (cvd2->vd_port == TVIN_PORT_CVBS0)
-	{
-		WRITE_APB_REG_BITS(CVD2_NON_STANDARD_SIGNAL_THRESHOLD, 3, HNON_STD_TH_BIT, HNON_STD_TH_WID);
-	}
-#elif defined(CONFIG_TVIN_TUNER_HTM9AW125)
-	if (cvd2->vd_port == TVIN_PORT_CVBS0 && cvd2->config_fmt == TVIN_SIG_FMT_CVBS_NTSC_M)
-	{
-		WRITE_APB_REG_BITS(ACD_REG_1B ,0xc,YCSEP_TEST6F_BIT,YCSEP_TEST6F_WID);
-	}
-#endif
-
-	/* add for board e04&e08  */
-	if ((cvd_reg07_pal != 0x03)            &&
-			(cvd2->vd_port == TVIN_PORT_CVBS0) &&
-			(cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I)
-	   )
-		WRITE_APB_REG(CVD2_OUTPUT_CONTROL, cvd_reg07_pal);
-
-	// 3D comb filter buffer assignment
-	tvafe_cvd2_memory_init(mem, cvd2->config_fmt);
-
-	// enable CVD2
-	WRITE_APB_REG_BITS(CVD2_RESET_REGISTER, 0, SOFT_RST_BIT, SOFT_RST_WID);
-
-	return;
-}
-
-/*
- * tvafe cvd2 configure Reg for non-standard signal
- */
-static void tvafe_cvd2_non_std_config(struct tvafe_cvd2_s *cvd2)
-{
-	static unsigned int time_non_count=50;
-	unsigned int noise_read=0;
-	unsigned int noise_strenth=0;
-	
-	noise_read=READ_APB_REG(CVD2_SYNC_NOISE_STATUS);
-	noise3=noise2;
-	noise2=noise1;
-	noise1=noise_read;
-	noise_strenth=(noise1+(noise2<<1)+noise3)>>2;
-	
-	if(time_non_count){
-		time_non_count--;
-		return;
-	}
-	time_non_count=200;	
-	if ((cvd2->info.non_std_config == cvd2->info.non_std_enable)&&(force_nostd&0x2))
-		return;
-	cvd2->info.non_std_config = cvd2->info.non_std_enable;
-	if (cvd2->info.non_std_config && (!(force_nostd&0x1)))
-	{
-        if (cvd_nonstd_dbg_en){
-		    pr_info("[tvafe..] %s: config non-std signal reg. \n",__func__);
-		    pr_info("[tvafe..] %s: noise_strenth=%d. \n",__func__,noise_strenth);     
-		}
-                
-#ifdef CONFIG_AM_SI2176
-		if (cvd2->vd_port == TVIN_PORT_CVBS0)
-		{
-			WRITE_APB_REG_BITS(CVD2_NON_STANDARD_SIGNAL_THRESHOLD, 3, HNON_STD_TH_BIT,HNON_STD_TH_WID);
-		        WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 1, VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			WRITE_APB_REG(CVD2_NOISE_THRESHOLD, 0x04);
-			if(scene_colorful)
-				WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x02);
-			if(noise_strenth>48 && noise_judge)
-				WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 4, HSTATE_MAX_BIT, HSTATE_MAX_WID);
-			else
-				WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 5, HSTATE_MAX_BIT, HSTATE_MAX_WID);
-			WRITE_APB_REG_BITS(CVD2_ACTIVE_VIDEO_VSTART, 0x14, VACTIVE_START_BIT, VACTIVE_START_WID);
-			WRITE_APB_REG_BITS(CVD2_ACTIVE_VIDEO_VHEIGHT, 0xe0, VACTIVE_HEIGHT_BIT, VACTIVE_HEIGHT_WID); 
-		}
-		else
-		{
-			//WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 1, VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			WRITE_APB_REG(CVD2_HSYNC_RISING_EDGE_START, 0x25);
-			WRITE_APB_REG(TVFE_CLAMP_INTF, 0x8661);
-			if(noise_strenth>48 && noise_judge)
-				WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 4, HSTATE_MAX_BIT, HSTATE_MAX_WID);
-			else
-				WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 5, HSTATE_MAX_BIT, HSTATE_MAX_WID);
-			if(scene_colorful)
-				WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x02);
-			WRITE_APB_REG(CVD2_VSYNC_SIGNAL_THRESHOLD, 0x10);
-			WRITE_APB_REG(CVD2_NOISE_THRESHOLD, 0x08);
-		}
-#else
-		WRITE_APB_REG(CVD2_HSYNC_RISING_EDGE_START, 0x25);
-		WRITE_APB_REG(TVFE_CLAMP_INTF, 0x8000);
-		WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 4, HSTATE_MAX_BIT, HSTATE_MAX_WID);
-		if (cvd2->vd_port == TVIN_PORT_CVBS0)
-		{
-			WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 1,
-					VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			WRITE_APB_REG(CVD2_NOISE_THRESHOLD, 0x00);
-		}
-		else
-		{
-			if(scene_colorful)
-				WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x02);
-			WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 1, VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 1, DISABLE_HFINE_BIT, DISABLE_HFINE_WID);
-			WRITE_APB_REG(CVD2_NOISE_THRESHOLD, 0x08);
-		}
-#endif
-	}
-	else
-	{	
-        if (cvd_nonstd_dbg_en)
-        	pr_info("[tvafe..] %s: out of non-std signal.\n",__func__);
-		WRITE_APB_REG(CVD2_HSYNC_RISING_EDGE_START, 0x6d);
-		WRITE_APB_REG(TVFE_CLAMP_INTF, 0x8666);
-		WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 5, HSTATE_MAX_BIT, HSTATE_MAX_WID);
-		if (cvd2->vd_port == TVIN_PORT_CVBS0)
-		{
-
-#ifdef  CVD_SI2176_RSSI
-			if(cvd_get_rf_strength()<187 && cvd_get_rf_strength()>100 && sync_sensitivity)
-			{
-					WRITE_APB_REG(CVD2_VSYNC_SIGNAL_THRESHOLD, 0xf0);
-					WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x2);
-					if (cvd_nonstd_dbg_en)
-						pr_info("[tvafe..] %s: out of non-std signal.rssi=%d \n",__func__,cvd_get_rf_strength());
-			}
-#else 
-			
-			if(READ_APB_REG(CVD2_SYNC_NOISE_STATUS)>48 && sync_sensitivity){
-					WRITE_APB_REG(CVD2_VSYNC_SIGNAL_THRESHOLD, 0xf0);
-					WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x2);
-				if (cvd_nonstd_dbg_en)
-					pr_info("[tvafe..] %s: use the cvd register to judge the rssi.rssi=%u \n",__func__,READ_APB_REG(CVD2_SYNC_NOISE_STATUS));		
-			}
-#endif
-			else{
-				WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x01);
-				WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 0,
-					VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			}
-			WRITE_APB_REG(CVD2_NOISE_THRESHOLD, 0x32);
-			WRITE_APB_REG_BITS(CVD2_ACTIVE_VIDEO_VSTART, 0x2a, VACTIVE_START_BIT, VACTIVE_START_WID);
-			WRITE_APB_REG_BITS(CVD2_ACTIVE_VIDEO_VHEIGHT, 0xc0, VACTIVE_HEIGHT_BIT, VACTIVE_HEIGHT_WID); 
-		}
-		else
-		{
-			WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 0,
--                                       VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			WRITE_APB_REG(CVD2_VSYNC_CNTL, 0x01);
-			WRITE_APB_REG_BITS(CVD2_VSYNC_SIGNAL_THRESHOLD, 0, VS_SIGNAL_AUTO_TH_BIT, VS_SIGNAL_AUTO_TH_WID);
-			WRITE_APB_REG_BITS(CVD2_H_LOOP_MAXSTATE, 0, DISABLE_HFINE_BIT, DISABLE_HFINE_WID);
-			WRITE_APB_REG(CVD2_NOISE_THRESHOLD, 0x32);
-		}
-	}
-
-}
-
-/*
- * tvafe cvd2 reset pga setting
- */
-inline void tvafe_cvd2_reset_pga(void)
-{
-	/* reset pga value */
-	if ((READ_APB_REG_BITS(ADC_REG_05, PGAGAIN_BIT, PGAGAIN_WID) != 0x30) ||
-			(READ_APB_REG_BITS(ADC_REG_06 , PGAMODE_BIT, PGAMODE_WID) != 0))
-	{
-		WRITE_APB_REG_BITS(ADC_REG_05 , 0x30, PGAGAIN_BIT, PGAGAIN_WID);
-		WRITE_APB_REG_BITS(ADC_REG_06, 0, PGAMODE_BIT, PGAMODE_WID);
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: reset pga value \n",__func__);
-	}
-
-}
-
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-/*
- * tvafe cvd2 read cdto setting from Reg
- */
-static unsigned int tvafe_cvd2_get_cdto()
-{
-	unsigned int cdto = 0;
-
-	cdto = (READ_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_29_24,
-				CDTO_INC_29_24_BIT, CDTO_INC_29_24_WID) & 0x0000003f)<<24;
-	cdto += (READ_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_23_16,
-				CDTO_INC_23_16_BIT, CDTO_INC_23_16_WID) & 0x000000ff)<<16;
-	cdto += (READ_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_15_8,
-				CDTO_INC_15_8_BIT, CDTO_INC_15_8_WID) & 0x000000ff)<<8;
-	cdto += (READ_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_7_0,
-				CDTO_INC_7_0_BIT, CDTO_INC_7_0_WID) & 0x000000ff);
-	return cdto;
-}
-
-/*
- * tvafe cvd2 write cdto value to Reg
- */
-static void tvafe_cvd2_set_cdto(unsigned int cdto)
-{
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_29_24, (cdto >> 24) & 0x0000003f);
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_23_16, (cdto >> 16) & 0x000000ff);
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_15_8,  (cdto >>  8) & 0x000000ff);
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_7_0,   (cdto >>  0) & 0x000000ff);
-}
-
-/*
-   set default cdto
- */
-void tvafe_cvd2_set_default_cdto(struct tvafe_cvd2_s *cvd2)
-{
-	if(!cvd2)
-	{
-		pr_info("[tvafe..]%s cvd2 null error.\n",__func__);
-		return;
-	}
-	switch(cvd2->config_fmt)
-	{
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_NTSC_M)
-				tvafe_cvd2_set_cdto( CVD2_CHROMA_DTO_NTSC_M);
-			break;
-		case TVIN_SIG_FMT_CVBS_NTSC_443:            
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_NTSC_443)
-				tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_NTSC_443);
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_I:            
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_PAL_I)
-				tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_PAL_I);
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_PAL_M)
-				tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_PAL_M);
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_60:            
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_PAL_60)
-				tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_PAL_60);
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_PAL_CN)
-				tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_PAL_CN);
-			break;
-		case TVIN_SIG_FMT_CVBS_SECAM:
-			if(tvafe_cvd2_get_cdto() != CVD2_CHROMA_DTO_SECAM)
-				tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_SECAM);
-			break;
-		default:
-			break;
-	}
-	if(cvd_dbg_en)
-		pr_info("[tvafe..]%s set cdto to default fmt %s.\n",__func__,tvin_sig_fmt_str(cvd2->config_fmt));
-}
-#endif
-
-/*
- * tvafe cvd2 write Reg table by different format
- */
-inline void tvafe_cvd2_try_format(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem, enum tvin_sig_fmt_e fmt)
-{
-	//check format validation
-	if ((fmt < TVIN_SIG_FMT_CVBS_NTSC_M) || (fmt > TVIN_SIG_FMT_CVBS_SECAM))
-	{
-		if (cvd_dbg_en)
-			pr_err("[tvafe..] %s: cvd2 try format error!!!\n", __func__);
-		return;
-	}
-
-	if (fmt != cvd2->config_fmt)
-	{
-		pr_info("[tvafe..] %s: try new fmt:%s\n", __func__, tvin_sig_fmt_str(fmt));
-		cvd2->config_fmt = fmt;
-		tvafe_cvd2_write_mode_reg(cvd2, mem);
-		/* init variable */
-		memset(&cvd2->info, 0, sizeof(struct tvafe_cvd2_info_s));
-	}
-}
-
-/*
- * tvafe cvd2 get signal status from Reg
- */
-static void tvafe_cvd2_get_signal_status(struct tvafe_cvd2_s *cvd2)
-{
-	int data = 0;
-
-	data = READ_APB_REG(CVD2_STATUS_REGISTER1);
-	cvd2->hw_data[cvd2->hw_data_cur].no_sig =      (bool)((data & 0x01) >> NO_SIGNAL_BIT );
-	cvd2->hw_data[cvd2->hw_data_cur].h_lock =      (bool)((data & 0x02) >> HLOCK_BIT     );
-	cvd2->hw_data[cvd2->hw_data_cur].v_lock =      (bool)((data & 0x04) >> VLOCK_BIT     );
-	cvd2->hw_data[cvd2->hw_data_cur].chroma_lock = (bool)((data & 0x08) >> CHROMALOCK_BIT);
-
-	data = READ_APB_REG(CVD2_STATUS_REGISTER2);
-	cvd2->hw_data[cvd2->hw_data_cur].h_nonstd =       (bool)((data & 0x02) >> HNON_STD_BIT         );
-	cvd2->hw_data[cvd2->hw_data_cur].v_nonstd =       (bool)((data & 0x04) >> VNON_STD_BIT         );
-	cvd2->hw_data[cvd2->hw_data_cur].no_color_burst = (bool)((data & 0x08) >> BKNWT_DETECTED_BIT   );
-	cvd2->hw_data[cvd2->hw_data_cur].comb3d_off =     (bool)((data & 0x10) >> STATUS_COMB3D_OFF_BIT);
-
-	data = READ_APB_REG(CVD2_STATUS_REGISTER3);
-	cvd2->hw_data[cvd2->hw_data_cur].pal =      (bool)((data & 0x01) >> PAL_DETECTED_BIT     );
-	cvd2->hw_data[cvd2->hw_data_cur].secam =    (bool)((data & 0x02) >> SECAM_DETECTED_BIT   );
-	cvd2->hw_data[cvd2->hw_data_cur].line625 =  (bool)((data & 0x04) >> LINES625_DETECTED_BIT);
-	cvd2->hw_data[cvd2->hw_data_cur].noisy =    (bool)((data & 0x08) >> NOISY_BIT            );
-	cvd2->hw_data[cvd2->hw_data_cur].vcr =      (bool)((data & 0x10) >> VCR_BIT              );
-	cvd2->hw_data[cvd2->hw_data_cur].vcrtrick = (bool)((data & 0x20) >> VCR_TRICK_BIT        );
-	cvd2->hw_data[cvd2->hw_data_cur].vcrff =    (bool)((data & 0x40) >> VCR_FF_BIT           );
-	cvd2->hw_data[cvd2->hw_data_cur].vcrrew =   (bool)((data & 0x80) >> VCR_REW_BIT          );
-
-	cvd2->hw_data[cvd2->hw_data_cur].cordic = READ_APB_REG_BITS(CVD2_CORDIC_FREQUENCY_STATUS,
-			STATUS_CORDIQ_FRERQ_BIT, STATUS_CORDIQ_FRERQ_WID);
-
-	//need the average of 3 fields ?
-	data = READ_APB_REG(ACD_REG_83);
-	cvd2->hw_data[cvd2->hw_data_cur].acc4xx_cnt = (unsigned char)(data >> RO_BD_ACC4XX_CNT_BIT);
-	cvd2->hw_data[cvd2->hw_data_cur].acc425_cnt = (unsigned char)(data >> RO_BD_ACC425_CNT_BIT);
-	cvd2->hw_data[cvd2->hw_data_cur].acc3xx_cnt = (unsigned char)(data >> RO_BD_ACC3XX_CNT_BIT);
-	cvd2->hw_data[cvd2->hw_data_cur].acc358_cnt = (unsigned char)(data >> RO_BD_ACC358_CNT_BIT);
-	data = cvd2->hw_data[0].acc4xx_cnt + cvd2->hw_data[1].acc4xx_cnt + cvd2->hw_data[2].acc4xx_cnt ;
-	cvd2->hw.acc4xx_cnt = data /3;
-	data = cvd2->hw_data[0].acc425_cnt + cvd2->hw_data[1].acc425_cnt + cvd2->hw_data[2].acc425_cnt ;
-	cvd2->hw.acc425_cnt = data /3;
-	data = cvd2->hw_data[0].acc3xx_cnt + cvd2->hw_data[1].acc3xx_cnt + cvd2->hw_data[2].acc3xx_cnt ;
-	cvd2->hw.acc3xx_cnt = data /3;
-	data = cvd2->hw_data[0].acc358_cnt + cvd2->hw_data[1].acc358_cnt + cvd2->hw_data[2].acc358_cnt ;
-	cvd2->hw.acc358_cnt = data /3;
-	data = READ_APB_REG(ACD_REG_84);
-	cvd2->hw_data[cvd2->hw_data_cur].secam_detected = (bool)((data & 0x1) >> RO_BD_SECAM_DETECTED_BIT);
-	cvd2->hw.secam_phase = (bool)((data & 0x2) >> RO_DBDR_PHASE_BIT);
-	if(cvd2->hw_data[0].secam_detected && cvd2->hw_data[1].secam_detected && cvd2->hw_data[2].secam_detected)
-		cvd2->hw.secam_detected = true;
-	if(!cvd2->hw_data[0].secam_detected && !cvd2->hw_data[1].secam_detected && !cvd2->hw_data[2].secam_detected)
-		cvd2->hw.secam_detected = false;
-	
-	if(cnt_dbg_en)
-		{
-		printk("[%d]:cvd2->hw.acc3xx_cnt =%d,cvd2->hw.acc4xx_cnt=%d,acc425_cnt=%d\n",__LINE__ ,
-			cvd2->hw.acc3xx_cnt,cvd2->hw.acc4xx_cnt,cvd2->hw.acc425_cnt);
-		printk("[%d]:cvd2->hw.fsc_358=%d,cvd2->hw.fsc_425=%d,cvd2->hw.fsc_443 =%d\n",__LINE__,
-			cvd2->hw.fsc_358,cvd2->hw.fsc_425,cvd2->hw.fsc_443);
-		}
-	if(cvd2->hw.acc3xx_cnt > cnt_vld_th)
-	{
-		if(cvd2->hw.acc358_cnt > (cvd2->hw.acc3xx_cnt -(cvd2->hw.acc3xx_cnt>>2)))
-		{
-			cvd2->hw.fsc_358 = true;
-			cvd2->hw.fsc_425 = false;
-			cvd2->hw.fsc_443 = false;
-		}
-		else if(cvd2->hw.acc358_cnt < (cvd2->hw.acc3xx_cnt<<1)/5)
-		{
-			cvd2->hw.fsc_358 = false;
-			if(cvd2->hw.acc4xx_cnt > cnt_vld_th)
-			{
-				/*
-				if(cvd2->hw.acc425_cnt > (cvd2->hw.acc4xx_cnt - (cvd2->hw.acc4xx_cnt>>2)))
-				{
-				if(cvd_dbg_en)
-					printk("[%d]:cvd2->hw.fsc_358=%d,cvd2->hw.fsc_425=%d,cvd2->hw.fsc_443 =%d\n",
-					__LINE__,cvd2->hw.fsc_358,cvd2->hw.fsc_425 ,cvd2->hw.fsc_443);
-
-	
-					cvd2->hw.fsc_425 = true;
-					cvd2->hw.fsc_443 = false;
-				}
-				else if (cvd2->hw.acc425_cnt < ((cvd2->hw.acc4xx_cnt)*3)/5)
-				{*/
- 					cvd2->hw.fsc_425 = false;
-					cvd2->hw.fsc_443 = true;
-			}
-			else if(cvd2->hw.acc4xx_cnt  < 40)
-			{
-				cvd2->hw.fsc_425 = false;
-				cvd2->hw.fsc_443 = false;
-			}
-		}        
-	}
-	else if(cvd2->hw.acc3xx_cnt < 40)
-	{
-		cvd2->hw.fsc_358 = false;
-		cvd2->hw.fsc_425 = false;
-		cvd2->hw.fsc_443 = false;
-		cvd2->hw.no_color_burst = true;
-	}    
-	if (++ cvd2->hw_data_cur >= 3)
-		cvd2->hw_data_cur = 0;
-	if(cnt_dbg_en)
-		printk("[%d]:cvd2->hw.fsc_358=%d,cvd2->hw.fsc_425=%d,cvd2->hw.fsc_443 =%d\n",__LINE__,
-																		cvd2->hw.fsc_358,
-																		cvd2->hw.fsc_425 ,
-																		cvd2->hw.fsc_443);
-
-#ifdef TVAFE_CVD2_NOT_TRUST_NOSIG
-#else
-	if (cvd2->hw_data[0].no_sig && cvd2->hw_data[1].no_sig && cvd2->hw_data[2].no_sig)
-		cvd2->hw.no_sig = true;
-	if (!cvd2->hw_data[0].no_sig && !cvd2->hw_data[1].no_sig && !cvd2->hw_data[2].no_sig)
-		cvd2->hw.no_sig = false;
-#endif
-	if ((cvd2->hw_data[0].h_lock || cvd2->hw_data[1].h_lock) && cvd2->hw_data[2].h_lock)
-		cvd2->hw.h_lock = true;
-	else if (cvd2->hw_data[0].h_lock && (cvd2->hw_data[1].h_lock || cvd2->hw_data[2].h_lock))
-		cvd2->hw.h_lock = true;
-	if (!cvd2->hw_data[0].h_lock && !cvd2->hw_data[1].h_lock && !cvd2->hw_data[2].h_lock)
-		cvd2->hw.h_lock = false;
-
-	if (cvd2->hw_data[0].v_lock && cvd2->hw_data[1].v_lock && cvd2->hw_data[2].v_lock)
-		cvd2->hw.v_lock = true;
-	if (!cvd2->hw_data[0].v_lock && !cvd2->hw_data[1].v_lock && !cvd2->hw_data[2].v_lock)
-		cvd2->hw.v_lock = false;
-
-	if (cvd2->hw_data[0].h_nonstd && cvd2->hw_data[1].h_nonstd && cvd2->hw_data[2].h_nonstd)
-		cvd2->hw.h_nonstd = true;
-	if (!cvd2->hw_data[0].h_nonstd && !cvd2->hw_data[1].h_nonstd && !cvd2->hw_data[2].h_nonstd)
-		cvd2->hw.h_nonstd = false;
-
-	if (cvd2->hw_data[0].v_nonstd && cvd2->hw_data[1].v_nonstd && cvd2->hw_data[2].v_nonstd)
-		cvd2->hw.v_nonstd = true;
-	else if(cvd2->hw_data[0].v_nonstd ||( cvd2->hw_data[1].v_nonstd && cvd2->hw_data[2].v_nonstd))
-		cvd2->hw.v_nonstd = true;
-	if (!cvd2->hw_data[0].v_nonstd && !cvd2->hw_data[1].v_nonstd && !cvd2->hw_data[2].v_nonstd)
-		cvd2->hw.v_nonstd = false;
-
-	if (cvd2->hw_data[0].no_color_burst && cvd2->hw_data[1].no_color_burst && cvd2->hw_data[2].no_color_burst)
-		cvd2->hw.no_color_burst = true;
-	if (!cvd2->hw_data[0].no_color_burst && !cvd2->hw_data[1].no_color_burst && !cvd2->hw_data[2].no_color_burst)
-		cvd2->hw.no_color_burst = false;
-
-	if (cvd2->hw_data[0].comb3d_off && cvd2->hw_data[1].comb3d_off && cvd2->hw_data[2].comb3d_off)
-		cvd2->hw.comb3d_off = true;
-	if (!cvd2->hw_data[0].comb3d_off && !cvd2->hw_data[1].comb3d_off && !cvd2->hw_data[2].comb3d_off)
-		cvd2->hw.comb3d_off = false;
-
-	if (cvd2->hw_data[0].chroma_lock && (cvd2->hw_data[1].chroma_lock || cvd2->hw_data[2].chroma_lock))
-		cvd2->hw.chroma_lock = true;
-	else if ((cvd2->hw_data[0].chroma_lock || cvd2->hw_data[1].chroma_lock) && cvd2->hw_data[2].chroma_lock)
-		cvd2->hw.chroma_lock = true;
-	if (!cvd2->hw_data[0].chroma_lock && !cvd2->hw_data[1].chroma_lock && !cvd2->hw_data[2].chroma_lock)
-		cvd2->hw.chroma_lock = false;
-
-	if ((cvd2->hw_data[0].pal || cvd2->hw_data[1].pal) && cvd2->hw_data[2].pal)
-		cvd2->hw.pal = true;
-	else if (cvd2->hw_data[0].pal && (cvd2->hw_data[1].pal || cvd2->hw_data[2].pal))
-		cvd2->hw.pal = true;
-	else if ((cvd2->hw_data[0].pal || cvd2->hw_data[2].pal) && cvd2->hw_data[1].pal)
-		cvd2->hw.pal = true;
-	if (!cvd2->hw_data[0].pal && !cvd2->hw_data[1].pal && !cvd2->hw_data[2].pal)
-		cvd2->hw.pal = false;
-
-	if (cvd2->hw_data[0].secam && cvd2->hw_data[1].secam && cvd2->hw_data[2].secam)
-		cvd2->hw.secam = true;
-	if (!cvd2->hw_data[0].secam && !cvd2->hw_data[1].secam && !cvd2->hw_data[2].secam)
-		cvd2->hw.secam = false;
-
-	if (cvd2->hw_data[0].line625 && cvd2->hw_data[1].line625 && cvd2->hw_data[2].line625)
-		cvd2->hw.line625 = true;
-	if (!cvd2->hw_data[0].line625 && !cvd2->hw_data[1].line625 && !cvd2->hw_data[2].line625)
-		cvd2->hw.line625 = false;
-
-	if (cvd2->hw_data[0].noisy && cvd2->hw_data[1].noisy && cvd2->hw_data[2].noisy)
-		cvd2->hw.noisy = true;
-	if (!cvd2->hw_data[0].noisy && !cvd2->hw_data[1].noisy && !cvd2->hw_data[2].noisy)
-		cvd2->hw.noisy = false;
-
-	if (cvd2->hw_data[0].vcr && cvd2->hw_data[1].vcr && cvd2->hw_data[2].vcr)
-		cvd2->hw.vcr = true;
-	if (!cvd2->hw_data[0].vcr && !cvd2->hw_data[1].vcr && !cvd2->hw_data[2].vcr)
-		cvd2->hw.vcr = false;
-
-	if (cvd2->hw_data[0].vcrtrick && cvd2->hw_data[1].vcrtrick && cvd2->hw_data[2].vcrtrick)
-		cvd2->hw.vcrtrick = true;
-	if (!cvd2->hw_data[0].vcrtrick && !cvd2->hw_data[1].vcrtrick && !cvd2->hw_data[2].vcrtrick)
-		cvd2->hw.vcrtrick = false;
-
-	if (cvd2->hw_data[0].vcrff && cvd2->hw_data[1].vcrff && cvd2->hw_data[2].vcrff)
-		cvd2->hw.vcrff = true;
-	if (!cvd2->hw_data[0].vcrff && !cvd2->hw_data[1].vcrff && !cvd2->hw_data[2].vcrff)
-		cvd2->hw.vcrff = false;
-
-	if (cvd2->hw_data[0].vcrrew && cvd2->hw_data[1].vcrrew && cvd2->hw_data[2].vcrrew)
-		cvd2->hw.vcrrew = true;
-	if (!cvd2->hw_data[0].vcrrew && !cvd2->hw_data[1].vcrrew && !cvd2->hw_data[2].vcrrew)
-		cvd2->hw.vcrrew = false;
-#ifdef TVAFE_CVD2_NOT_TRUST_NOSIG //while tv channel switch, avoid black screen
-	if (!cvd2->hw.h_lock)
-		cvd2->hw.no_sig = true;
-	if (cvd2->hw.h_lock)
-		cvd2->hw.no_sig = false;
-#endif
-
-	data  = 0;
-	data += (int)cvd2->hw_data[0].cordic;
-	data += (int)cvd2->hw_data[1].cordic;
-	data += (int)cvd2->hw_data[2].cordic;
-	if (cvd2->hw_data[0].cordic & 0x80)
-	{
-		data -= 256;
-	}
-	if (cvd2->hw_data[1].cordic & 0x80)
-	{
-		data -= 256;
-	}
-	if (cvd2->hw_data[2].cordic & 0x80)
-	{
-		data -= 256;
-	}
-	data /= 3;
-	cvd2->hw.cordic  = (unsigned char)(data & 0xff);
-
-	return;
-}
-
-/*
- * tvafe cvd2 get cvd2 signal lock status
- */
-enum tvafe_cvbs_video_e tvafe_cvd2_get_lock_status(struct tvafe_cvd2_s *cvd2)
-{
-	enum tvafe_cvbs_video_e cvbs_lock_status = TVAFE_CVBS_VIDEO_HV_UNLOCKED;
-
-	if (!cvd2->hw.h_lock && !cvd2->hw.v_lock)
-		cvbs_lock_status = TVAFE_CVBS_VIDEO_HV_UNLOCKED;
-	else if (cvd2->hw.h_lock && cvd2->hw.v_lock)
-		cvbs_lock_status = TVAFE_CVBS_VIDEO_HV_LOCKED;
-	else if (cvd2->hw.h_lock)
-		cvbs_lock_status = TVAFE_CVBS_VIDEO_H_LOCKED;
-	else if (cvd2->hw.v_lock)
-		cvbs_lock_status = TVAFE_CVBS_VIDEO_V_LOCKED;
-
-	return cvbs_lock_status;
-}
-
-/*
- * tvafe cvd2 check current cordic match status
- */
-static bool tvafe_cvd2_cordic_match(struct tvafe_cvd2_s *cvd2)
-{
-	int in_min = 0;
-	int in_max = 0;
-
-	if (cvd2->vd_port == TVIN_PORT_CVBS0)
-	{
-		in_min = cordic_tv_in_min;
-		in_max = cordic_tv_in_max;
-	}
-	else
-	{
-		in_min = cordic_av_in_min;
-		in_max = cordic_av_in_max;
-	}
-
-	if ((cvd2->hw.cordic <= in_min) ||
-			(cvd2->hw.cordic >= in_max))
-	{
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: codic:%d match:<%d or >%d \n",__func__,
-					cvd2->hw.cordic, in_min, in_max);
-		return true;
-
-	}
-	else
-	{
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: codic:%d dismatch:%d~%d \n",__func__,
-					cvd2->hw.cordic, in_min, in_max);
-		return false;
-	}
-
-}
-
-/*
- * tvafe cvd2 non-standard signal detection
- */
-static void tvafe_cvd2_non_std_signal_det(struct tvafe_cvd2_s *cvd2)
-{
-	unsigned short dgain = 0;
-	unsigned long chroma_sum_filt_tmp = 0;
-	unsigned long chroma_sum_filt=0;
-	unsigned long chroma_sum_in=0;
-	
-	
-	chroma_sum_in = READ_CBUS_REG_BITS(VDIN_HIST_CHROMA_SUM,  HIST_CHROMA_SUM_BIT,  HIST_CHROMA_SUM_WID );
-	chroma_sum_pre3 = chroma_sum_pre2;
-	chroma_sum_pre2 = chroma_sum_pre1;
-	chroma_sum_pre1 = chroma_sum_in;
-	
-	chroma_sum_filt_tmp = (chroma_sum_pre3 + (chroma_sum_pre2 << 1) + chroma_sum_pre1) >> 2;
-	chroma_sum_filt = chroma_sum_filt_tmp;
-	
-	if (chroma_sum_filt >= SCENE_COLORFUL_TH)
-		scene_colorful = 1;
-	else 
-		scene_colorful = 0;
-	
-	if (print_cnt == 0x50)
-		print_cnt = 0;
-	else 
-		print_cnt = print_cnt + 1;
-	
-	if (print_cnt == 0x28) {
-		if (cvd_nonstd_dbg_en)
-			pr_info("[tvafe..] %s: scene_colorful = %d, chroma_sum_filt = %ld \n",__func__,
-					scene_colorful, chroma_sum_filt);
-	}
-		
-	if ((cvd2->hw.h_nonstd | (cvd2->hw.v_nonstd && scene_colorful)) && (nonstd_cnt < CVD2_NONSTD_CNT_INC_LIMIT ))
-	{
-		nonstd_cnt = nonstd_cnt + CVD2_NONSTD_CNT_INC_STEP;
-	}
-	else if ((cvd2->hw.h_nonstd | (cvd2->hw.v_nonstd && scene_colorful)) && (nonstd_cnt >= CVD2_NONSTD_CNT_INC_LIMIT))
-	{
-		nonstd_cnt = nonstd_cnt;
-	}
-	else if ((!cvd2->hw.h_nonstd) && (!cvd2->hw.v_nonstd) && (nonstd_cnt >= CVD2_NONSTD_CNT_DEC_LIMIT))
-	{
-		nonstd_cnt = nonstd_cnt - CVD2_NONSTD_CNT_DEC_STEP;
-	}
-	else if ((!cvd2->hw.h_nonstd) && (!cvd2->hw.v_nonstd) && (nonstd_cnt < CVD2_NONSTD_CNT_DEC_LIMIT))
-	{
-		nonstd_cnt = nonstd_cnt;
-	}
-	
-	if (nonstd_cnt <= CVD2_NONSTD_FLAG_OFF_TH)
-		nonstd_flag = 0;
-	else if (nonstd_cnt >= CVD2_NONSTD_FLAG_ON_TH)
-		nonstd_flag = 1;	
-					
-	if ((cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I ) && cvd2->hw.line625)
-	{
-		dgain = READ_APB_REG_BITS(CVD2_AGC_GAIN_STATUS_7_0,
-				AGC_GAIN_7_0_BIT, AGC_GAIN_7_0_WID);
-		dgain |= READ_APB_REG_BITS(CVD2_AGC_GAIN_STATUS_11_8,
-				AGC_GAIN_11_8_BIT, AGC_GAIN_11_8_WID)<<8;
-		if ((dgain >= TVAFE_CVD2_NONSTD_DGAIN_MAX) ||
-				cvd2->hw.h_nonstd ||
-				nonstd_flag ||
-				//cvd2->hw.v_nonstd ||
-				(READ_APB_REG_BITS(ADC_REG_06, PGAMODE_BIT, PGAMODE_WID)))
-		{
-			cvd2->info.non_std_enable = 1;
-		}
-		else
-		{
-			cvd2->info.non_std_enable = 0;
-		}
-	}
-}
-
-/*
- * tvafe cvd2 signal unstable
- */
-static bool tvafe_cvd2_sig_unstable(struct tvafe_cvd2_s *cvd2)
-{
-	int ret = false;
-#if 1
-	if (cvd2->hw.no_sig)
-		ret = true;
-#else
-	if (cvd2->vd_port == TVIN_PORT_CVBS0)
-	{
-		if (cvd2->hw.no_sig)// || !cvd2->hw.h_lock)
-			ret = true;
-	}
-	else
-	{
-		if (cvd2->hw.no_sig || !cvd2->hw.h_lock || !cvd2->hw.v_lock)
-			ret = true;
-	}
-#endif
-	return ret;
-}
-
-/*
- * tvafe cvd2 checkt current format match condition
- */
-
-static bool tvafe_cvd2_condition_shift(struct tvafe_cvd2_s *cvd2)
-{
-	bool ret = false;
-	int out_min, out_max;
-
-	if (tvafe_cvd2_sig_unstable(cvd2))
-	{
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: sig unstable, nosig:%d,h-lock:%d,v-lock:%d\n",__func__,
-					cvd2->hw.no_sig,cvd2->hw.h_lock,cvd2->hw.v_lock);
-
-		return true;
-	}
-
-	/* check non standard signal, ignore SECAM/525 mode */
-	tvafe_cvd2_non_std_signal_det(cvd2);
-
-	if (cvd2->manual_fmt)
-		return false;
-	
-	/* check line flag */
-	switch (cvd2->config_fmt)
-	{
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-		case TVIN_SIG_FMT_CVBS_SECAM:
-			if (!cvd2->hw.line625)
-			{
-				ret = true;
-				cvd2->fmt_loop_cnt = 0;
-				if (cvd_dbg_en)
-					pr_info("[tvafe..] %s: reset fmt try cnt 525 line \n", __func__);
-			}
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-			if (cvd2->hw.line625)
-			{
-				ret = true;
-				cvd2->fmt_loop_cnt = 0;
-				if (cvd_dbg_en)
-					pr_info("[tvafe..] %s: reset fmt try cnt 625 line\n", __func__);
-			}
-			break;
-		default:
-			break;
-	}
-	if (ret)
-	{
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: line625 error!!!! \n",__func__);
-		return true;
-	}
-	if (cvd2->hw.no_color_burst)
-	{
-		/* for SECAM format, set PAL_I */
-		if (cvd2->config_fmt != TVIN_SIG_FMT_CVBS_SECAM)  //set default fmt
-		{
-			if (!cvd_pr_flag && cvd_dbg_en)
-			{
-				cvd_pr_flag = true;
-				pr_info("[tvafe..] %s: no-color-burst, do not change mode. \n",__func__);
-			}
-			return false;
-		}
-	}
-	/* ignore pal flag because of cdto adjustment */
-	if ((cvd2->info.non_std_worst || cvd2->hw.h_nonstd ) &&
-			(cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I))
-	{
-		if (!cvd_pr_flag && cvd_dbg_en)
-		{
-			cvd_pr_flag = true;
-			pr_info("[tvafe..] %s: if adj cdto or h-nonstd, ignore mode change. \n",__func__);
-		}
-		return false;
-	}
-
-	/* for ntsc-m pal-m switch bug */
-	if ((!cvd2->hw.chroma_lock) && (cvd2->config_fmt == TVIN_SIG_FMT_CVBS_NTSC_M))
-	{
-		if (cvd2->info.ntsc_switch_cnt++ >= ntsc_sw_maxcnt)
-		{
-			cvd2->info.ntsc_switch_cnt = 0;
-		}
-
-		if (cvd2->info.ntsc_switch_cnt <= ntsc_sw_midcnt)
-		{
-			if (READ_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_23_16, CDTO_INC_23_16_BIT, CDTO_INC_23_16_WID) != 0x2e)
-			{
-				WRITE_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_23_16, 0x2e, CDTO_INC_23_16_BIT, CDTO_INC_23_16_WID);
-				WRITE_APB_REG_BITS(CVD2_PAL_DETECTION_THRESHOLD, 0x40, PAL_DET_TH_BIT, PAL_DET_TH_WID);
-				WRITE_APB_REG_BITS(CVD2_CONTROL0, 0x00, COLOUR_MODE_BIT, COLOUR_MODE_WID);
-				WRITE_APB_REG_BITS(CVD2_COMB_FILTER_CONFIG, 0x2, PALSW_LVL_BIT, PALSW_LVL_WID);
-				WRITE_APB_REG_BITS(CVD2_COMB_LOCK_CONFIG, 0x7, LOSE_CHROMALOCK_LVL_BIT, LOSE_CHROMALOCK_LVL_WID);
-				WRITE_APB_REG_BITS(CVD2_PHASE_OFFSE_RANGE, 0x20, PHASE_OFFSET_RANGE_BIT, PHASE_OFFSET_RANGE_WID);
-			}
-			if (!cvd_pr1_chroma_flag && cvd_dbg_en)
-			{
-				cvd_pr1_chroma_flag = true;
-				cvd_pr2_chroma_flag = false;
-				pr_info("[tvafe..] %s: change cdto to ntsc-m \n",__func__);
-			}
-		}
-		else
-		{
-			if (READ_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_23_16, CDTO_INC_23_16_BIT, CDTO_INC_23_16_WID) != 0x23)
-			{
-				WRITE_APB_REG_BITS(CVD2_CHROMA_DTO_INCREMENT_23_16, 0x23, CDTO_INC_23_16_BIT, CDTO_INC_23_16_WID);
-				WRITE_APB_REG_BITS(CVD2_PAL_DETECTION_THRESHOLD, 0x1f, PAL_DET_TH_BIT, PAL_DET_TH_WID);
-				WRITE_APB_REG_BITS(CVD2_CONTROL0, 0x02, COLOUR_MODE_BIT, COLOUR_MODE_WID);
-				WRITE_APB_REG_BITS(CVD2_COMB_FILTER_CONFIG, 3, PALSW_LVL_BIT, PALSW_LVL_WID);
-				WRITE_APB_REG_BITS(CVD2_COMB_LOCK_CONFIG, 2, LOSE_CHROMALOCK_LVL_BIT, LOSE_CHROMALOCK_LVL_WID);
-				WRITE_APB_REG_BITS(CVD2_PHASE_OFFSE_RANGE, 0x15, PHASE_OFFSET_RANGE_BIT, PHASE_OFFSET_RANGE_WID);
-			}
-			if (!cvd_pr2_chroma_flag && cvd_dbg_en)
-			{
-				cvd_pr2_chroma_flag = true;
-				cvd_pr1_chroma_flag = false;
-				pr_info("[tvafe..] %s: change cdto to pal-m \n",__func__);
-			}
-		}
-	}
-	if(force_fmt_flag && cvd2->vd_port==TVIN_PORT_CVBS0){
-		if(cvd_dbg_en)
-			printk("[%s]:ignore the pal/358/443 flag and return\n",__func__);
-		return false;
-	}
-
-	/* check pal/secam flag */
-	switch (cvd2->config_fmt)
-	{
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-			if (!cvd2->hw.pal)
-				ret = true;
-			break;
-		case TVIN_SIG_FMT_CVBS_SECAM:
-			if (!cvd2->hw.secam||!cvd2->hw.secam_detected)
-				ret = true;
-			break;
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-			if (cvd2->hw.pal)
-				ret = true;
-			break;
-		default:
-			break;
-	}
-	/*check 358/443*/
-	switch(cvd2->config_fmt)
-	{
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-			if(!cvd2->hw.fsc_358||cvd2->hw.fsc_443)
-				ret = true;
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-			if(cvd2->hw.fsc_358||!cvd2->hw.fsc_443)
-				ret = true;
-			break;
-		default:
-			break;
-	}
-	if (ret)
-	{
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: pal is %d,secam flag is %d, changed.\n",__func__,cvd2->hw.pal,cvd2->hw.secam);
-		return true;
-	}
-	else
-		return false;
-}
-/*
-due to some cvd falg is invalid,we must force fmt after reach to max-cnt
-*/
-static void cvd_force_config_fmt(struct tvafe_cvd2_s * cvd2,struct tvafe_cvd2_mem_s * mem,int config_force_fmt)
-{
-	
-	//force to secam
-	if((cvd2->hw.line625 && (cvd2->hw.secam_detected||cvd2->hw.secam)) || config_force_fmt==1){
-		tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_SECAM);
-		printk("[%s]:force the fmt to TVIN_SIG_FMT_CVBS_SECAM\n",__func__);
-	}
-	//force to ntscm
-	else if ((!cvd2->hw.line625 && !cvd2->hw.pal) || config_force_fmt==2){
-		tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_NTSC_M);
-		printk("[%s]:force the fmt to TVIN_SIG_FMT_CVBS_NTSC_M\n",__func__);
-	}
-	//force to palm
-	else if((!cvd2->hw.line625 && cvd2->hw.pal) || config_force_fmt==3){ 
-		tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_M);
-		printk("[%s]:force the fmt to TVIN_SIG_FMT_CVBS_PAL_M\n",__func__);
-	}
-	//force to pali
-	else if((cvd2->hw.line625) || config_force_fmt==4){
-		tvafe_cvd2_try_format(cvd2, mem,TVIN_SIG_FMT_CVBS_PAL_I);
-		printk("[%s]:force the fmt to TVIN_SIG_FMT_CVBS_PAL_I\n",__func__);
-	}
-	return;
-		
-}
-
-
-
-/*
- * tvafe cvd2 search video format function
- */
-
-static void tvafe_cvd2_search_video_mode(struct tvafe_cvd2_s * cvd2,struct tvafe_cvd2_mem_s * mem)
-{
-	unsigned int shift_cnt = 0;
-
-	// execute manual mode
-	if ((cvd2->manual_fmt) &&
-			(cvd2->config_fmt != cvd2->manual_fmt) &&
-			(cvd2->config_fmt != TVIN_SIG_FMT_NULL))
-	{
-		tvafe_cvd2_try_format(cvd2, mem, cvd2->manual_fmt);
-	}
-	// state-machine
-	switch (cvd2->info.state)
-	{
-		case TVAFE_CVD2_STATE_INIT:
-			// wait for signal setup
-			if (tvafe_cvd2_sig_unstable(cvd2))
-			{
-				cvd2->info.state_cnt = 0;
-				if (!cvd_pr_flag && cvd_dbg_en)
-				{
-					cvd_pr_flag = true;
-					pr_info("[tvafe..] %s: sig unstable, nosig:%d,h-lock:%d,v-lock:%d.\n",__func__,
-							cvd2->hw.no_sig,cvd2->hw.h_lock,cvd2->hw.v_lock);
-				}
-			}
-			// wait for signal stable
-			else if (++cvd2->info.state_cnt > fmt_wait_cnt)
-			{
-				force_fmt_flag=0;
-				cvd_pr_flag = false;
-				cvd2->info.state_cnt = 0;
-				// manual mode => go directly to the manual format
-				if (cvd2->manual_fmt)
-				{
-					try_format_cnt = 0;
-					cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-					if (cvd_dbg_en)
-						pr_info("[tvafe..] %s: manual fmt is:%s, do not need try other format!!!\n",__func__,
-								tvin_sig_fmt_str(cvd2->manual_fmt));
-				}
-				
-				// auto mode
-				else
-				{
-					if (cvd_dbg_en)
-						pr_info("[tvafe..] %s: switch to fmt:%s,hnon:%d,vnon:%d,c-lk:%d,pal:%d,secam:%d,h-lk:%d,"
-								"v-lk:%d,fsc358:%d,fsc425:%d,fsc443:%d,secam detected %d,line625:%d\n",__func__,
-								tvin_sig_fmt_str(cvd2->config_fmt), cvd2->hw.h_nonstd, cvd2->hw.v_nonstd,\
-								cvd2->hw.chroma_lock,cvd2->hw.pal,cvd2->hw.secam,cvd2->hw.h_lock,\
-								cvd2->hw.v_lock,cvd2->hw.fsc_358,cvd2->hw.fsc_425,cvd2->hw.fsc_443,\
-								cvd2->hw.secam_detected,cvd2->hw.line625);
-					if (cvd_dbg_en)
-						printk("acc4xx_cnt = %d,acc425_cnt = %d,acc3xx_cnt = %d,acc358_cnt = %d secam_detected:%d\n",cvd2->hw_data[cvd2->hw_data_cur].acc4xx_cnt ,cvd2->hw_data[cvd2->hw_data_cur].acc425_cnt,
-					cvd2->hw_data[cvd2->hw_data_cur].acc3xx_cnt,cvd2->hw_data[cvd2->hw_data_cur].acc358_cnt,cvd2->hw_data[cvd2->hw_data_cur].secam_detected);
-
-					//force mode:due to some signal is hard to check out 
-					if(++try_format_cnt==try_format_max)
-						{
-				    		cvd_force_config_fmt(cvd2,mem,config_force_fmt);
-							return;
-						}
-					else if(try_format_cnt>try_format_max)
-						{
-							cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							force_fmt_flag=1; //this falg is aviod the func of "tvafe_cvd2_condition_shift(cvd2)"
-							return;
-						}
-					
-					switch (cvd2->config_fmt)
-					{
-						case TVIN_SIG_FMT_CVBS_PAL_I:
-							if (cvd2->hw.line625)
-							{
-								if(cvd2->hw.secam_detected||cvd2->hw.secam)
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_SECAM);
-								else if (cvd2->hw.fsc_443 && cvd2->hw.pal)
-								{
-									// 625 + cordic_match => confirm PAL_I
-									cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-								}
-								else if(cvd2->hw.fsc_358)
-								{
-									// 625 + 358 => try PAL_CN
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_CN);
-								}  
-							}
-							else//525 lines
-							{
-								if(cvd_dbg_en)
-									pr_info("[tvafe..]%s dismatch pal_i line625 %d!!!and the  fsc358 %d,pal %d,fsc_443:%d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_358, cvd2->hw.pal,cvd2->hw.fsc_443);
-								tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_M);
-								
-								if(cvd_dbg_en)
-								pr_info("[tvafe..]%sdismatch pal_i and  after try other format: line625 %d!!!and the  fsc358 %d,pal %d,fsc_443:%d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_358, cvd2->hw.pal,cvd2->hw.fsc_443);
-								
-							}
-							break;
-						case TVIN_SIG_FMT_CVBS_PAL_CN:
-							if (cvd2->hw.line625 && cvd2->hw.fsc_358 && cvd2->hw.pal)
-							{
-								//line625+brust358+pal -> pal_cn
-								cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							}
-							else
-							{
-								if(cvd_dbg_en)
-								pr_info("[tvafe..]%s dismatch pal_cn line625 %d, fsc358 %d,pal %d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_358, cvd2->hw.pal);
-								if(cvd2->hw.line625 )
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-								else if(!cvd2->hw.line625 && cvd2->hw.fsc_358&& cvd2->hw.pal) 
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_M);
-								else if(!cvd2->hw.line625 && cvd2->hw.fsc_443&& !cvd2->hw.pal)
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_NTSC_443);
-							}
-							break;
-						case TVIN_SIG_FMT_CVBS_SECAM:
-							if (cvd2->hw.line625 && cvd2->hw.secam_detected && cvd2->hw.secam)
-							{
-								// 625 + secam => confirm SECAM
-								cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							}
-							else
-							{
-								if(cvd_dbg_en)
-									pr_info("[tvafe..]%s dismatch secam line625 %d, secam_detected %d",__func__,
-											cvd2->hw.line625, cvd2->hw.secam_detected);
-								if(cvd2->hw.line625 )
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-								else if(!cvd2->hw.line625 && cvd2->hw.fsc_358&& cvd2->hw.pal)
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_M);
-								else if(!cvd2->hw.line625 && cvd2->hw.fsc_443&& !cvd2->hw.pal)
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_NTSC_443);
-							}
-							break;
-						case TVIN_SIG_FMT_CVBS_PAL_M:
-							if (!cvd2->hw.line625 && cvd2->hw.fsc_358 && cvd2->hw.pal&&cvd2->hw.chroma_lock)
-							{
-								// line525 + 358 + pal => confirm PAL_M
-								cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							}
-							else
-							{
-								if(cvd_dbg_en)
-									pr_info("[tvafe..]%s dismatch pal m line625 %d, fsc358 %d,pal %d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_358, cvd2->hw.pal);
-								if(cvd2->hw.line625 )
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-								else if(!cvd2->hw.line625 &&cvd2->hw.fsc_443 && cvd2->hw.pal)                                        
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_60);
-								else if(!cvd2->hw.line625 && cvd2->hw.fsc_358&& !cvd2->hw.pal)
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_NTSC_M);
-								else if(!cvd2->hw.line625 && cvd2->hw.fsc_443&& !cvd2->hw.pal)
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_NTSC_443);
-							}
-							break;
-						case TVIN_SIG_FMT_CVBS_NTSC_M:
-							if (!cvd2->hw.line625 && cvd2->hw.fsc_358 && !cvd2->hw.pal&&cvd2->hw.chroma_lock)
-							{
-								// line525 + 358 => confirm NTSC_M
-								cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							}
-							else
-							{
-								if(cvd_dbg_en)
-									pr_info("[tvafe..]%s dismatch ntsc m line625 %d, fsc358 %d,pal %d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_358, cvd2->hw.pal);
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-							}
-							break;
-						case TVIN_SIG_FMT_CVBS_PAL_60:
-							if (!cvd2->hw.line625 && cvd2->hw.fsc_443 && cvd2->hw.pal)
-								// 525 + 443 + pal => confirm PAL_60
-								cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							else
-							{
-								//set default to pal i
-								if(cvd_dbg_en)
-									pr_info("[tvafe..]%s dismatch pal 60 line625 %d, fsc443 %d,pal %d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_443, cvd2->hw.pal);
-								tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-							}
-							break;
-						case TVIN_SIG_FMT_CVBS_NTSC_443:
-							if(!cvd2->hw.line625 && cvd2->hw.fsc_443 && !cvd2->hw.pal)
-								//525 + 443 => confirm NTSC_443
-								cvd2->info.state = TVAFE_CVD2_STATE_FIND;
-							else
-							{
-								//set default to pal i
-								if(cvd_dbg_en)
-									pr_info("[tvafe..]%s dismatch NTSC_443 line625 %d, fsc443 %d,pal %d",__func__,
-											cvd2->hw.line625, cvd2->hw.fsc_443, cvd2->hw.pal);
-								if(!cvd2->hw.line625 &&cvd2->hw.fsc_443 && cvd2->hw.pal)                                        
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_60);
-								else 
-									tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-							}
-							break;
-						default:
-							break;
-					}
-				}
-				if (cvd_dbg_en)
-					pr_info("[tvafe..] %s: current fmt is:%s\n",__func__, tvin_sig_fmt_str(cvd2->config_fmt));
-			}
-			break;
-		case TVAFE_CVD2_STATE_FIND:
-			// manual mode => go directly to the manual format
-			try_format_cnt=0;
-			if (tvafe_cvd2_condition_shift(cvd2))
-			{
-				shift_cnt = TVAFE_CVD2_SHIFT_CNT;
-				if (cvd2->info.non_std_enable)
-					shift_cnt = TVAFE_CVD2_SHIFT_CNT*10;
-
-				/* if no color burst, pal flag can not be trusted */
-				if (cvd2->info.fmt_shift_cnt++ > shift_cnt)
-				{
-					tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-					cvd2->info.state = TVAFE_CVD2_STATE_INIT;
-					cvd2->info.ntsc_switch_cnt = 0;
-					try_format_cnt = 0;
-					cvd_pr_flag = false;
-				}
-			}
-			/* non-standard signal config */
-			tvafe_cvd2_non_std_config(cvd2);
-			break;
-		default:
-			break;
-	}
-}
-
-
-#ifdef TVAFE_CVD2_AUTO_DE_ENABLE
-static void tvafe_cvd2_auto_de(struct tvafe_cvd2_s *cvd2)
-{
-	struct tvafe_cvd2_lines_s *lines = &cvd2->info.vlines;
-	unsigned int i = 0, l_ave = 0, l_max = 0, l_min = 0xff, tmp = 0;
-	if (!cvd2->hw.line625 || (cvd2->config_fmt != TVIN_SIG_FMT_CVBS_PAL_I))
-		return;
-	lines->val[0] = lines->val[1];
-	lines->val[1] = lines->val[2];
-	lines->val[2] = lines->val[3];
-	lines->val[3] = READ_APB_REG(CVD2_REG_E6);
-	for (i = 0; i < 4; i++)
-	{
-		if (l_max < lines->val[i])
-			l_max = lines->val[i];
-		if (l_min > lines->val[i])
-			l_min = lines->val[i];
-		l_ave += lines->val[i];
-	}
-
-	if (lines->check_cnt++ == TVAFE_CVD2_AUTO_DE_CHECK_CNT)
-	{
-		lines->check_cnt = 0;
-		//if (cvd_dbg_en)
-		//    pr_info("%s: check lines every 100*10ms  \n", __func__);
-		l_ave = (l_ave - l_max - l_min + 1) >> 1;  // get the average value
-		if (l_ave > TVAFE_CVD2_AUTO_DE_TH)
-		{
-			tmp = (0xff - l_ave + 1) >> 2;
-
-			/* avoid overflow */
-			if (tmp > TVAFE_CVD2_PAL_DE_START)
-				tmp = TVAFE_CVD2_PAL_DE_START;
-			if (lines->de_offset != tmp || scene_colorful_old )
-			{
-				lines->de_offset = tmp;
-				tmp = ((TVAFE_CVD2_PAL_DE_START      - lines->de_offset) << 16) |
-					(288 + TVAFE_CVD2_PAL_DE_START - lines->de_offset);
-				WRITE_APB_REG(ACD_REG_2E, tmp);
-				scene_colorful_old=0;
-				if (cvd_dbg_en)
-					pr_info("%s: vlines:%d, de_offset:%d tmp:%x \n",
-							__func__, l_ave, lines->de_offset, tmp);
-			}
-		}
-		else
-		{
-			if (lines->de_offset > 0)
-			{
-				tmp = ((TVAFE_CVD2_PAL_DE_START      - lines->de_offset) << 16) |
-					(288 + TVAFE_CVD2_PAL_DE_START - lines->de_offset);
-				WRITE_APB_REG(ACD_REG_2E, tmp);
-				scene_colorful_old=0;
-				if (cvd_dbg_en)
-					pr_info("%s: vlines:%d, de_offset:%d tmp:%x \n",
-							__func__, l_ave, lines->de_offset, tmp);
-				lines->de_offset--;
-			}
-		}
-	}
-}
-#endif
-/*set default de according to config fmt*/
-void tvafe_cvd2_set_default_de(struct tvafe_cvd2_s * cvd2)
-{
-	if(scene_colorful_old==1)
-		return;
-#ifdef TVAFE_CVD2_AUTO_DE_ENABLE
-	if(!cvd2)
-	{
-		pr_info("[tvafe..]%s error.\n",__func__);
-		return;
-	}
-	/*write default de to register*/
-	WRITE_APB_REG(ACD_REG_2E,  (rf_acd_table[cvd2->config_fmt-TVIN_SIG_FMT_CVBS_NTSC_M][0x2e]));
-	if(cvd_dbg_en)
-		pr_info("[tvafe..]%s set default de %s.\n",__func__,tvin_sig_fmt_str(cvd2->config_fmt));
-	scene_colorful_old=1;
-#endif 
-}
-#ifdef TVAFE_CVD2_ADC_REG_CHECK
-/*
- * tvafe cvd2 check adc Reg table for esd test
- */
-static void tvafe_cvd2_check_adc_reg(struct tvafe_cvd2_s *cvd2)
-{
-	int i = 0, tmp = 0;
-
-	if (cvd2->info.normal_cnt++ == TVAFE_CVD2_NORMAL_REG_CHECK_CNT)
-	{
-		cvd2->info.normal_cnt = 0;
-		cvd2->info.adc_reload_en = false;
-		for (i=1; i<ADC_REG_NUM; i++)
-		{
-			//0x20 has output buffer register, I have not list it here, should I?
-			//0x21 has reset & sleep mode, should I watch it here?
-			if ((i==0x05) || (i==0x1d) || (i==0x20) || (i==0x24) || (i==0x2b) ||
-					(i==0x35) || (i==0x3a) || (i==0x53) || (i==0x54) || (i==0x6a) ||
-					(i==0x34) || (i==0x46) || (i==0x57) || (i==0x67) ||
-					(i>=0x4a && i<=0x55) ||
-					(i>=0x6a && i<ADC_REG_NUM))
-				continue;
-
-			tmp = READ_APB_REG(((ADC_BASE_ADD + i) << 2));
-			if (i == 0x06) //pga enable/disable
-			{
-				tmp &= 0x10;
-				if(((cvd2->vd_port >= TVIN_PORT_CVBS0) && (cvd2->vd_port <= TVIN_PORT_CVBS7)) &&
-						(tmp != 0x10))
-					cvd2->info.adc_reload_en = true;
-			}
-			else if (i == 0x17)  //input pga mux
-			{
-				tmp &= 0x30;
-				if (((cvd2->vd_port == TVIN_PORT_CVBS0) && (tmp != 0x00)) ||
-						((cvd2->vd_port == TVIN_PORT_CVBS1) && (tmp != 0x10)) ||
-						((cvd2->vd_port == TVIN_PORT_CVBS2) && (tmp != 0x20)) ||
-						((cvd2->vd_port == TVIN_PORT_CVBS3) && (tmp != 0x30))
-				   )
-					cvd2->info.adc_reload_en = true;
-			}
-			else if (i == 0x3d)  //FILTPLLHSYNC
-			{
-				tmp &= 0x80;
-				if (tmp != 0x80)
-					cvd2->info.adc_reload_en = true;
-			}
-			else
-			{
-				if (tmp != adc_cvbs_table[i])
-					cvd2->info.adc_reload_en = true;
-			}
-		}
-
-		/* if adc reg readback error reload adc reg table */
-		if (cvd2->info.adc_reload_en)
-		{
-			/** write 7740 register **/
-			tvafe_adc_configure(TVIN_SIG_FMT_CVBS_PAL_I);
-			if (cvd_dbg_en)
-				pr_info("[tvafe..] %s: Reg error!!!! reload adc table.\n",__func__);
-		}
-	}
-
-}
-#endif
-
-/*
- * tvafe cvd2 init if no signal input
- */
-static void tvafe_cvd2_reinit(struct tvafe_cvd2_s *cvd2)
-{
-	if (cvd2->cvd2_init_en)
-		return;
-
-
-
-	if ((CVD2_CHROMA_DTO_PAL_I != tvafe_cvd2_get_cdto()) &&
-			(cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I))
-	{
-		tvafe_cvd2_set_cdto(CVD2_CHROMA_DTO_PAL_I);
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: set default cdto. \n",__func__);
-
-	}
-	/* reset pga value */
-#ifdef TVAFE_SET_CVBS_PGA_EN
-	tvafe_cvd2_reset_pga();
-#endif
-	/* init variable */
-	memset(&cvd2->info, 0, sizeof(struct tvafe_cvd2_info_s));
-	cvd2->cvd2_init_en = true;
-
-	if (cvd_dbg_en)
-		pr_info("[tvafe..] %s: reinit cvd2. \n",__func__);
-}
-
-/*
- * tvafe cvd2 signal status
- */
-inline bool tvafe_cvd2_no_sig(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem)
-{
-	bool ret = false;
-	// get signal status from HW
-	tvafe_cvd2_get_signal_status(cvd2);
-
-	// search video mode
-	tvafe_cvd2_search_video_mode(cvd2, mem);
-
-	// verify adc register for esd test
-#ifdef TVAFE_CVD2_ADC_REG_CHECK
-	tvafe_cvd2_check_adc_reg(cvd2);
-#endif
-
-	// init if no signal input
-	if (cvd2->hw.no_sig)
-	{
-		ret = true;
-		tvafe_cvd2_reinit(cvd2);
-	}
-	else
-	{
-		cvd2->cvd2_init_en = false;
-#ifdef TVAFE_CVD2_AUTO_DE_ENABLE
-	if((!scene_colorful) && auto_de_en)
-		tvafe_cvd2_auto_de(cvd2);
-	else 
-		tvafe_cvd2_set_default_de(cvd2);
-		
-	
-#endif
-	}
-	if(ret&try_format_cnt)
-	{
-		try_format_cnt = 0;
-		if(cvd_dbg_en)
-			pr_info("[tvafe..] %s: initialize try_format_cnt to zero.\n",__func__);
-	}
-	return (ret);
-}
-
-/*
- * tvafe cvd2 mode change status
- */
-inline bool tvafe_cvd2_fmt_chg(struct tvafe_cvd2_s *cvd2)
-{
-	if (cvd2->info.state == TVAFE_CVD2_STATE_FIND)
-		return false;
-	else
-		return true;
-}
-
-/*
- * tvafe cvd2 find the configured format
- */
-inline enum tvin_sig_fmt_e tvafe_cvd2_get_format(struct tvafe_cvd2_s *cvd2)
-{
-	if (cvd2->info.state == TVAFE_CVD2_STATE_FIND)
-		return cvd2->config_fmt;
-	else
-		return TVIN_SIG_FMT_NULL;
-}
-
-#ifdef TVAFE_SET_CVBS_PGA_EN
-/*
- * tvafe cvd2 pag ajustment in vsync interval
- */
-inline void tvafe_cvd2_adj_pga(struct tvafe_cvd2_s *cvd2)
-{
-	unsigned short dg_max = 0, dg_min = 0xffff, dg_ave = 0, i = 0, pga = 0;
-	unsigned int tmp = 0;
-	unsigned char step = 0;
-
-    if ((cvd_isr_en & 0x100) == 0)
-        return;
-
-	cvd2->info.dgain[0] = cvd2->info.dgain[1];
-	cvd2->info.dgain[1] = cvd2->info.dgain[2];
-	cvd2->info.dgain[2] = cvd2->info.dgain[3];
-	cvd2->info.dgain[3] = READ_APB_REG_BITS(CVD2_AGC_GAIN_STATUS_7_0,
-			AGC_GAIN_7_0_BIT, AGC_GAIN_7_0_WID);
-	cvd2->info.dgain[3] |= READ_APB_REG_BITS(CVD2_AGC_GAIN_STATUS_11_8,
-			AGC_GAIN_11_8_BIT, AGC_GAIN_11_8_WID)<<8;
-	for (i = 0; i < 4; i++)
-	{
-		if (dg_max < cvd2->info.dgain[i])
-			dg_max = cvd2->info.dgain[i];
-		if (dg_min > cvd2->info.dgain[i])
-			dg_min = cvd2->info.dgain[i];
-		dg_ave += cvd2->info.dgain[i];
-	}
-	if (++cvd2->info.dgain_cnt >= TVAFE_SET_CVBS_PGA_START + TVAFE_SET_CVBS_PGA_STEP)
-	{
-		cvd2->info.dgain_cnt = TVAFE_SET_CVBS_PGA_START;
-	}
-	if (cvd2->info.dgain_cnt == TVAFE_SET_CVBS_PGA_START)
-	{
-		cvd2->info.dgain_cnt = 0;
-		dg_ave = (dg_ave - dg_max - dg_min + 1) >> 1;
-		pga = READ_APB_REG_BITS(ADC_REG_05, PGAGAIN_BIT, PGAGAIN_WID);
-
-		if (READ_APB_REG_BITS(ADC_REG_06, PGAMODE_BIT, PGAMODE_WID))
-		{
-			//pga += 64;
-			pga += 97;
-		}
-		if (((dg_ave >= CVD2_DGAIN_LIMITL) && (dg_ave <= CVD2_DGAIN_LIMITH)) ||
-				(pga >= (255+97)) ||
-				(pga == 0))
-		{
-			return;
-		}
-		tmp = abs((signed short)dg_ave - (signed short)CVD2_DGAIN_MIDDLE);
-
-		if (tmp > CVD2_DGAIN_MIDDLE)
-			step = 16;
-		else if (tmp > (CVD2_DGAIN_MIDDLE >> 1))
-			step = 5;
-		else if (tmp > (CVD2_DGAIN_MIDDLE >> 2))
-			step = 2;
-		else
-			step = 1;
-		if (dg_ave > CVD2_DGAIN_LIMITH)
-		{
-			pga += step;
-			if (pga >= (255+97))  //set max value
-				pga = (255+97);
-		}
-		else
-		{
-			if (pga < step)  //set min value
-				pga = 0;
-			else
-				pga -= step;
-		}
-		if (pga > 255)
-		{
-			//pga -= 64;
-			pga -= 97;
-			WRITE_APB_REG_BITS(ADC_REG_06, 1, PGAMODE_BIT, PGAMODE_WID);
-		}
-		else
-		{
-			if (pga < 2)
-				pga = 2;
-			WRITE_APB_REG_BITS(ADC_REG_06, 0, PGAMODE_BIT, PGAMODE_WID);
-		}
-
-		if (pga != READ_APB_REG_BITS(ADC_REG_05 , PGAGAIN_BIT, PGAGAIN_WID))
-		{
-			 if (cvd_dbg_en)
-                                pr_info("%s: set pag:0x%x. current dgain 0x%x.\n",__func__, pga,cvd2->info.dgain[3]);
-			WRITE_APB_REG_BITS(ADC_REG_05, pga, PGAGAIN_BIT, PGAGAIN_WID);
-		}
-	}
-
-	return;
-}
-#endif
-
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-/*
- * tvafe cvd2 cdto tune in vsync interval
- */
-static void tvafe_cvd2_cdto_tune(unsigned int cur, unsigned int dest)
-{
-	unsigned int diff = 0, step = 0;
-
-	diff = (unsigned int)abs((signed int)cur - (signed int)dest);
-
-	if (diff == 0)
-	{
-		return;
-	}
-
-	if ((diff > (diff>>1)) && (diff > (0x1<<cdto_adj_step)))
-		step = diff >> cdto_adj_step;
-	else
-		step = 1;
-
-	if (cur > dest)
-		cur -= step;
-	else
-		cur += step;
-
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_29_24, (cur >> 24) & 0x0000003f);
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_23_16, (cur >> 16) & 0x000000ff);
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_15_8,  (cur >>  8) & 0x000000ff);
-	WRITE_APB_REG(CVD2_CHROMA_DTO_INCREMENT_7_0,   (cur >>  0) & 0x000000ff);
-
-}
-
-/*
- * tvafe cvd2 cdto adjustment in vsync interval
- */
-inline void tvafe_cvd2_adj_cdto(struct tvafe_cvd2_s *cvd2, unsigned int hcnt64)
-{
-	unsigned int hcnt64_max = 0, hcnt64_min = 0xffffffff, hcnt64_ave = 0, i = 0;
-	unsigned int cur_cdto = 0, diff = 0;
-	u64 cal_cdto = 0;
-
-    if ((cvd_isr_en & 0x001) == 0)
-        return;
-
-	/* only for pal-i adjusment */
-	if (cvd2->config_fmt != TVIN_SIG_FMT_CVBS_PAL_I)
-		return;
-
-	cvd2->info.hcnt64[0] = cvd2->info.hcnt64[1];
-	cvd2->info.hcnt64[1] = cvd2->info.hcnt64[2];
-	cvd2->info.hcnt64[2] = cvd2->info.hcnt64[3];
-	cvd2->info.hcnt64[3] = hcnt64;
-	for (i = 0; i < 4; i++)
-	{
-		if (hcnt64_max < cvd2->info.hcnt64[i])
-			hcnt64_max = cvd2->info.hcnt64[i];
-		if (hcnt64_min > cvd2->info.hcnt64[i])
-			hcnt64_min = cvd2->info.hcnt64[i];
-		hcnt64_ave += cvd2->info.hcnt64[i];
-	}
-	if (++cvd2->info.hcnt64_cnt >= TVAFE_SET_CVBS_CDTO_START + TVAFE_SET_CVBS_CDTO_STEP)
-	{
-		cvd2->info.hcnt64_cnt = TVAFE_SET_CVBS_CDTO_START;
-	}
-	if (cvd2->info.hcnt64_cnt == TVAFE_SET_CVBS_CDTO_START)
-	{
-		hcnt64_ave = (hcnt64_ave - hcnt64_max - hcnt64_min + 1) >> cdto_filter_factor;
-		if (hcnt64_ave == 0)  // to avoid kernel crash
-			return;
-		cal_cdto = CVD2_CHROMA_DTO_PAL_I;
-		cal_cdto *= cdto_clamp;
-		do_div(cal_cdto, hcnt64_ave);
-
-		cur_cdto = tvafe_cvd2_get_cdto();
-		diff = (unsigned int)abs((signed int)cal_cdto - (signed int)CVD2_CHROMA_DTO_PAL_I);
-
-		if (diff < cdto_adj_th)
-		{
-			/* reset cdto to default value */
-			if (cur_cdto != CVD2_CHROMA_DTO_PAL_I)
-				tvafe_cvd2_cdto_tune(cur_cdto, (unsigned int)CVD2_CHROMA_DTO_PAL_I);
-			cvd2->info.non_std_worst = 0;
-			return;
-		}
-		else
-			cvd2->info.non_std_worst = 1;
-
-		if (cvd_dbg_en)
-			pr_info("[tvafe..] %s: adj cdto from:0x%x to:0x%x\n",__func__,(u32)cur_cdto, (u32)cal_cdto);
-		tvafe_cvd2_cdto_tune(cur_cdto, (unsigned int)cal_cdto);
-	}
-
-	return;
-}
-#endif
-
-#ifdef SYNC_HEIGHT_AUTO_TUNING
-/*
- * tvafe cvd2 sync height ajustment for picture quality in vsync interval
- */
-static inline void tvafe_cvd2_sync_hight_tune(struct tvafe_cvd2_s *cvd2)
-{
-	int burst_mag = 0;
-	int burst_mag_16msb = 0, burst_mag_16lsb = 0;
-	unsigned int reg_sync_height = 0;
-	int burst_mag_upper_limitation = 0;
-	int burst_mag_lower_limitation = 0;
-	unsigned int std_sync_height = 0xdd;
-	unsigned int cur_div_result = 0;
-	unsigned int mult_result = 0;
-	unsigned int final_contrast = 0;
-	unsigned int reg_contrast_default = 0;
-
-	if (cvd2->info.non_std_config) { }
-	else if (cvd2->vd_port == TVIN_PORT_CVBS0) { }
-	else if ((cvd2->config_fmt == TVIN_SIG_FMT_CVBS_NTSC_M) ||
-			(cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I))
-	{ //try to detect AVin NTSCM/PALI
-		if (cvd2->config_fmt == TVIN_SIG_FMT_CVBS_NTSC_M)
-		{
-			burst_mag_upper_limitation = NTSC_BURST_MAG_UPPER_LIMIT & 0xffff;
-			burst_mag_lower_limitation = NTSC_BURST_MAG_LOWER_LIMIT & 0xffff;
-			reg_contrast_default = 0x7b;
-		}
-		else if (cvd2->config_fmt == TVIN_SIG_FMT_CVBS_PAL_I)
-		{
-			burst_mag_upper_limitation = PAL_BURST_MAG_UPPER_LIMIT & 0xffff;
-			burst_mag_lower_limitation = PAL_BURST_MAG_LOWER_LIMIT & 0xffff;
-			reg_contrast_default = 0x7d ;
-		}
-
-		burst_mag_16msb = READ_APB_REG(CVD2_STATUS_BURST_MAGNITUDE_LSB);
-		burst_mag_16lsb = READ_APB_REG(CVD2_STATUS_BURST_MAGNITUDE_MSB);
-		burst_mag = ((burst_mag_16msb&0xff) << 8) | (burst_mag_16lsb&0xff);
-		if (burst_mag > burst_mag_upper_limitation)
-		{
-			reg_sync_height = READ_APB_REG(CVD2_LUMA_AGC_VALUE);
-			if (reg_sync_height > SYNC_HEIGHT_LOWER_LIMIT )
-			{
-				reg_sync_height = reg_sync_height - 1;
-				WRITE_APB_REG(CVD2_LUMA_AGC_VALUE, reg_sync_height&0xff);
-
-				cur_div_result = std_sync_height << 16;
-				do_div(cur_div_result,reg_sync_height);
-				mult_result = cur_div_result * (reg_contrast_default&0xff);
-				final_contrast = (mult_result + 0x8000) >> 16;
-				if (final_contrast > 0xff)
-					WRITE_APB_REG(CVD2_LUMA_CONTRAST_ADJUSTMENT, 0xff);
-				else if (final_contrast > 0x50)
-					WRITE_APB_REG(CVD2_LUMA_CONTRAST_ADJUSTMENT, final_contrast&0xff);
-			}
-		}
-		else if (burst_mag < burst_mag_lower_limitation)
-		{
-			reg_sync_height = READ_APB_REG(CVD2_LUMA_AGC_VALUE);
-			if (reg_sync_height < SYNC_HEIGHT_UPPER_LIMIT)
-			{
-				reg_sync_height = reg_sync_height + 1;
-				WRITE_APB_REG(CVD2_LUMA_AGC_VALUE, reg_sync_height&0xff);
-				cur_div_result = std_sync_height << 16;
-				do_div(cur_div_result, reg_sync_height);
-				mult_result = cur_div_result * (reg_contrast_default&0xff);
-				final_contrast = (mult_result + 0x8000) >> 16;
-				if (final_contrast > 0xff)
-					WRITE_APB_REG(CVD2_LUMA_CONTRAST_ADJUSTMENT, 0xff);
-				else if (final_contrast > 0x50)
-					WRITE_APB_REG(CVD2_LUMA_CONTRAST_ADJUSTMENT, final_contrast&0xff);
-			}
-		}
-	}
-}
-#endif
-
-/*
- * tvafe cvd2 3d comb error checking in vsync interval
- */
-inline void tvafe_cvd2_check_3d_comb(struct tvafe_cvd2_s *cvd2)
-{
-	unsigned int cvd2_3d_status = READ_APB_REG(CVD2_REG_95);
-
-    if ((cvd_isr_en & 0x010) == 0)
-        return;
-
-#ifdef SYNC_HEIGHT_AUTO_TUNING
-	tvafe_cvd2_sync_hight_tune(cvd2);
-#endif
-
-	if (cvd2->info.comb_check_cnt++ > CVD_3D_COMB_CHECK_MAX_CNT)
-	{
-
-		cvd2->info.comb_check_cnt = 0;
-	}
-	if (cvd2_3d_status & 0x1ffff)
-	{
-		WRITE_APB_REG_BITS(CVD2_REG_B2, 1, COMB2D_ONLY_BIT, COMB2D_ONLY_WID);
-		WRITE_APB_REG_BITS(CVD2_REG_B2, 0, COMB2D_ONLY_BIT, COMB2D_ONLY_WID);
-		//if (cvd_dbg_en)
-		//    pr_info("%s: reset 3d comb  sts:0x%x \n",__func__, cvd2_3d_status);
-	}
-}
-
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-
-/*
- * tvafe cvd2 video position reg setting
- */
-static void tvafe_cvd2_set_video_pos(enum tvin_sig_fmt_e fmt)
-{
-	if (fmt == TVIN_SIG_FMT_CVBS_PAL_I)
-	{
-		if (READ_APB_REG(ACD_REG_2E) != 0x00170137)
-		{
-			/* set positon with ntsc fmt */
-			WRITE_APB_REG(CVD2_ACTIVE_VIDEO_VSTART, 0x2a);
-			WRITE_APB_REG(CVD2_ACTIVE_VIDEO_VHEIGHT, 0xc0);
-			WRITE_APB_REG_BITS(CVD2_CONTROL0, 1, VLINE_625_BIT, VLINE_625_WID);
-			WRITE_APB_REG(ACD_REG_2E, 0x00170137);
-			if (cvd_dbg_en)
-				pr_info("[tvafe..] %s: set:%s position. \n",__func__, tvin_sig_fmt_str(fmt));
-		}
-	}
-	else
-	{
-		if (READ_APB_REG(ACD_REG_2E) != 0x00110101)
-		{
-			/* set positon with ntsc fmt */
-			WRITE_APB_REG(CVD2_ACTIVE_VIDEO_VSTART, 0x22);
-			WRITE_APB_REG(CVD2_ACTIVE_VIDEO_VHEIGHTt, 0x61);
-			WRITE_APB_REG_BITS(CVD2_CONTROL0, 0, VLINE_625_BIT, VLINE_625_WID);
-			WRITE_APB_REG(ACD_REG_2E, 0x00110101);
-			if (cvd_dbg_en)
-				pr_info("[tvafe..] %s: set:%s position. \n",__func__, tvin_sig_fmt_str(fmt));
-		}
-	}
-}
-
-/*
- * tvafe cvd2 video position adjustment
- */
-inline enum tvin_cvbs_pos_ctl_e tvafe_cvd2_set_pos(struct tvafe_cvd2_s *cvd2)
-{
-	/* Get the per-device structure that contains this frontend */
-	enum tvin_cvbs_pos_ctl_e cvbs_pos_ctl = TVIN_CVBS_POS_NULL;
-
-	if (cvd2->manual_fmt == TVIN_SIG_FMT_CVBS_PAL_I)
-	{
-		if (!cvd2->hw.line625)  //wrong format, change video size
-		{
-			cvbs_pos_ctl = TVIN_CVBS_POS_P_TO_N;
-			tvafe_cvd2_set_video_pos(TVIN_SIG_FMT_CVBS_NTSC_M);
-		}
-		else  //right format, reload video size
-		{
-			cvbs_pos_ctl = TVIN_CVBS_POS_P_TO_P;
-			tvafe_cvd2_set_video_pos((TVIN_SIG_FMT_CVBS_PAL_I);
-					}
-					}
-					else if ((cvd2->manual_fmt == TVIN_SIG_FMT_CVBS_NTSC_M) )
-					{
-					if (cvd2->hw.line625)  //wrong format, change video size
-					{
-					cvbs_pos_ctl = TVIN_CVBS_POS_N_TO_P;
-					tvafe_cvd2_set_video_pos((TVIN_SIG_FMT_CVBS_PAL_I);
-						}
-						else  //right format, reload video size
-						{
-						cvbs_pos_ctl = TVIN_CVBS_POS_N_TO_N;
-						tvafe_cvd2_set_video_pos((TVIN_SIG_FMT_CVBS_NTSC_M);
-							}
-							}
-							else  // reset default postion
-							{
-							tvafe_cvd2_set_video_pos(cvd2->config_fmt);
-							}
-
-							return (cvbs_pos_ctl);
-							}
-#endif
-
-							/*
-							 * tvafe cvd2 set reset to high
-							 */
-							inline void tvafe_cvd2_hold_rst(struct tvafe_cvd2_s *cvd2)
-							{
-							WRITE_APB_REG_BITS(CVD2_RESET_REGISTER, 1, SOFT_RST_BIT, SOFT_RST_WID);
-							}
-void tvafe_cvd2_set_reg8a(unsigned int v)
-{
-	cvd_reg8a = v;
-	WRITE_APB_REG(CVD2_CHROMA_LOOPFILTER_STATE, cvd_reg8a);
-}
-
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_cvd.h b/drivers/amlogic/tvin/tvafe/tvafe_cvd.h
deleted file mode 100755
index 2508d26ee030..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_cvd.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/*******************************************************************
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *  File name: TVAFE_CVD.h
- *  Description: IO function, structure, enum, used in TVIN AFE sub-module processing
- *******************************************************************/
-#ifndef _TVAFE_CVD_H
-#define _TVAFE_CVD_H
-
-#include <linux/amlogic/tvin/tvin.h>
-
-/***************************Local defines**********************************/
-/* cvd2 memory size defines */
-#define DECODER_MOTION_BUFFER_ADDR_OFFSET   0x70000
-#define DECODER_MOTION_BUFFER_4F_LENGTH     0x15a60
-#define DECODER_VBI_ADDR_OFFSET             0x86000
-#define DECODER_VBI_VBI_SIZE                0x1000
-#define DECODER_VBI_START_ADDR              0x0
-
-/* cvd2 function enable/disable defines*/
-//#define TVAFE_CVD2_NOT_TRUST_NOSIG  // Do not trust Reg no signal flag
-//#define SYNC_HEIGHT_AUTO_TUNING
-//#define TVAFE_CVD2_ADC_REG_CHECK
-
-/* cvd2 function enable/disable defines*/
-//#define TVAFE_CVD2_TUNER_DET_ACCELERATED  // accelerate tuner mode detection
-
-/* cvd2 VBI function enable/disable defines*/
-//#define TVAFE_CVD2_CC_ENABLE  // enable cvd2 close caption
-
-/* cvd2 auto adjust de enable/disable defines*/
-#define TVAFE_CVD2_AUTO_DE_ENABLE                  // enable cvd2 de auto ajust
-#define TVAFE_CVD2_AUTO_DE_CHECK_CNT        100    // check lines counter 100*10ms
-#define TVAFE_CVD2_AUTO_DE_TH               0xd0   // audo de threshold
-#define TVAFE_CVD2_PAL_DE_START             0x17   // default de start value for pal
-
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-typedef enum tvafe_cvd2_state_e {
-	TVAFE_CVD2_STATE_INIT = 0,
-	TVAFE_CVD2_STATE_FIND,
-} tvafe_cvd2_state_t;
-
-// ***************************************************************************
-// *** structure definitions *********************************************
-// ***************************************************************************
-typedef struct tvafe_cvd2_hw_data_s {
-	bool no_sig;
-	bool h_lock;
-	bool v_lock;
-	bool h_nonstd;
-	bool v_nonstd;
-	bool no_color_burst;
-	bool comb3d_off;
-	bool chroma_lock;
-	bool pal;
-	bool secam;
-	bool line625;
-	bool noisy;
-	bool vcr;
-	bool vcrtrick;
-	bool vcrff;
-	bool vcrrew;
-	unsigned char cordic;
-
-	unsigned char acc4xx_cnt;
-	unsigned char acc425_cnt;
-	unsigned char acc3xx_cnt;
-	unsigned char acc358_cnt;
-	bool secam_detected;
-	bool secam_phase;
-	bool fsc_358;
-	bool fsc_425;
-	bool fsc_443;
-
-} tvafe_cvd2_hw_data_t;
-
-/* cvd2 memory */
-typedef struct tvafe_cvd2_mem_s {
-	unsigned int                start;  //memory start addr for cvd2 module
-	unsigned int                size;   //memory size for cvd2 module
-} tvafe_cvd2_mem_t;
-
-#ifdef TVAFE_CVD2_AUTO_DE_ENABLE
-typedef struct tvafe_cvd2_lines_s {
-	unsigned int                val[4];
-	unsigned int                check_cnt;
-	unsigned int                de_offset;
-} tvafe_cvd2_lines_t;
-#endif
-
-/* cvd2 signal information */
-typedef struct tvafe_cvd2_info_s {
-	enum tvafe_cvd2_state_e     state;
-	unsigned int                state_cnt;
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-	unsigned int                hcnt64[4];
-	unsigned int                hcnt64_cnt;
-#endif
-#ifdef TVAFE_SET_CVBS_PGA_EN
-	unsigned short              dgain[4];
-	unsigned short              dgain_cnt;
-#endif
-	unsigned int                comb_check_cnt;
-	unsigned int                fmt_shift_cnt;
-	bool                        non_std_enable;
-	bool                        non_std_config;
-	bool                        non_std_worst;
-	bool                        adc_reload_en;
-
-
-#ifdef TVAFE_CVD2_ADC_REG_CHECK
-	unsigned int                normal_cnt;
-#endif
-
-#ifdef TVAFE_CVD2_AUTO_DE_ENABLE
-	struct tvafe_cvd2_lines_s   vlines;
-#endif
-	unsigned int                ntsc_switch_cnt;
-} tvafe_cvd2_info_t;
-
-//CVD2 status list
-typedef struct tvafe_cvd2_s {
-	struct tvafe_cvd2_hw_data_s hw_data[3];
-	struct tvafe_cvd2_hw_data_s hw;
-	unsigned char               hw_data_cur;
-	enum tvin_port_e            vd_port;
-	bool                        cvd2_init_en;
-	enum tvin_sig_fmt_e         config_fmt;
-	enum tvin_sig_fmt_e         manual_fmt;
-	unsigned int                fmt_loop_cnt;
-	struct tvafe_cvd2_info_s    info;
-} tvafe_cvd2_t;
-
-// *****************************************************************************
-// ******** GLOBAL FUNCTION CLAIM ********
-// *****************************************************************************
-extern int cvd_get_rf_strength(void);
-
-extern void tvafe_cvd2_try_format(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem, enum tvin_sig_fmt_e fmt);
-extern bool tvafe_cvd2_no_sig(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem);
-extern bool tvafe_cvd2_fmt_chg(struct tvafe_cvd2_s *cvd2);
-extern enum tvin_sig_fmt_e tvafe_cvd2_get_format(struct tvafe_cvd2_s *cvd2);
-#ifdef TVAFE_SET_CVBS_PGA_EN
-extern void tvafe_cvd2_adj_pga(struct tvafe_cvd2_s *cvd2);
-#endif
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-extern void tvafe_cvd2_adj_cdto(struct tvafe_cvd2_s *cvd2, unsigned int hcnt64);
-#endif
-extern void tvafe_cvd2_set_default_cdto(struct tvafe_cvd2_s *cvd2);
-extern void tvafe_cvd2_set_default_de(struct tvafe_cvd2_s *cvd2);
-extern void tvafe_cvd2_check_3d_comb(struct tvafe_cvd2_s *cvd2);
-extern void tvafe_cvd2_reset_pga(void);
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-extern enum tvin_cvbs_pos_ctl_e tvafe_cvd2_set_pos(struct tvafe_cvd2_s *cvd2);
-#endif
-extern enum tvafe_cvbs_video_e tvafe_cvd2_get_lock_status(struct tvafe_cvd2_s *cvd2);
-extern void tvafe_cvd2_hold_rst(struct tvafe_cvd2_s *cvd2);
-extern void tvafe_cvd2_set_reg8a(unsigned int v);
-#endif // _TVAFE_CVD_H
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_general.c b/drivers/amlogic/tvin/tvafe/tvafe_general.c
deleted file mode 100755
index 20ac82f19086..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_general.c
+++ /dev/null
@@ -1,3196 +0,0 @@
-/******************************Includes************************************/
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <mach/am_regs.h>
-
-#include <mach/am_regs.h>
-
-#include <linux/amlogic/tvin/tvin.h>
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "tvafe_regs.h"
-#include "tvafe_adc.h"
-#include "tvafe_cvd.h"
-#include "tvafe_general.h"
-/***************************Local defines**********************************/
-/* calibration validation funtion enable/disable */
-// #define TVAFE_ADC_CAL_VALIDATION
-
-/* edid config reg value */
-#define TVAFE_EDID_CONFIG           0x03800050
-
-/* calibration defines */
-#define TVAFE_ADC_CAL_STEP_GAIN     1
-#define TVAFE_ADC_CAL_STEP_CLAMP    1
-#define TVAFE_ADC_CAL_STEP_SHIFT    1
-#define TVAFE_ADC_CAL_STEP_STAGE    (TVAFE_ADC_CAL_STEP_GAIN*16 + TVAFE_ADC_CAL_STEP_SHIFT)
-
-/***************************local Variables**********************************/
-struct tvafe_adc_cal_s cal_std_value_component = {
-	.a_analog_clamp	   = 73,
-	.a_analog_gain 	   = 112,
-	.a_digital_gain	   = 975, // 0dB
-	.a_digital_offset1 = 1,
-	.a_digital_offset2 = 28,
-	.b_analog_clamp	   = 65,
-	.b_analog_gain 	   = 122,
-	.b_digital_gain	   = 899, // 0dB
-	.b_digital_offset1 = 3,
-	.b_digital_offset2 = 64,
-	.c_analog_clamp	   = 62,
-	.c_analog_gain 	   = 121,
-	.c_digital_gain	   = 899, // 0dB
-	.c_digital_offset1 = 2,
-	.c_digital_offset2 = 64,
-};
-
-struct tvafe_adc_cal_s cal_std_value_vga = {
-	.a_analog_clamp    = 66,
-	.a_analog_gain     = 153,
-	.a_digital_gain    = 1024, // 0dB
-	.a_digital_offset1 = 0,
-	.a_digital_offset2 = 0,
-	.b_analog_clamp    = 71,
-	.b_analog_gain     = 162,
-	.b_digital_gain    = 1024, // 0dB
-	.b_digital_offset1 = 0,
-	.b_digital_offset2 = 0,
-	.c_analog_clamp    = 65,
-	.c_analog_gain     = 162,
-	.c_digital_gain    = 1024,// 0dB
-	.c_digital_offset1 = 0,
-	.c_digital_offset2 = 0,
-};
-
-static int threshold_value = 32;
-static enum tvafe_adc_pin_e tvafe_default_cvbs_out = TVAFE_ADC_PIN_A_PGA_0;
-
-const signed short tvafe_comp_hs_patch[TVIN_SIG_FMT_COMP_MAX - TVIN_SIG_FMT_COMP_480P_60HZ_D000] =
-{
-	//VGA
-#if 0
-	0,  // TVIN_SIG_FMT_VGA_560X384P_60D147,
-	0,  // TVIN_SIG_FMT_VGA_640X200P_59D924,
-	0,  // TVIN_SIG_FMT_VGA_640X350P_85D080,
-	0,  // TVIN_SIG_FMT_VGA_640X400P_59D940,
-	0,  // TVIN_SIG_FMT_VGA_640X400P_85D080,
-	0,  // TVIN_SIG_FMT_VGA_640X400P_59D638,
-	0,  // TVIN_SIG_FMT_VGA_640X400P_56D416,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_66D619,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_66D667,   // 10
-	0,  // TVIN_SIG_FMT_VGA_640X480P_59D940,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_60D000,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_72D809,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_75D000_A,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_85D008,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_59D638,
-	0,  // TVIN_SIG_FMT_VGA_640X480P_75D000_B,
-	0,  // TVIN_SIG_FMT_VGA_640X870P_75D000,
-	0,  // TVIN_SIG_FMT_VGA_720X350P_70D086,
-	0,  // TVIN_SIG_FMT_VGA_720X400P_85D039,   // 20
-	0,  // TVIN_SIG_FMT_VGA_720X400P_70D086,
-	0,  // TVIN_SIG_FMT_VGA_720X400P_87D849,
-	0,  // TVIN_SIG_FMT_VGA_720X400P_59D940,
-	0,  // TVIN_SIG_FMT_VGA_720X480P_59D940,
-	0,  // TVIN_SIG_FMT_VGA_768X480P_59D896,
-	0,  // TVIN_SIG_FMT_VGA_800X600P_56D250,
-	0,  // TVIN_SIG_FMT_VGA_800X600P_60D317,
-	0,  // TVIN_SIG_FMT_VGA_800X600P_72D188,
-	0,  // TVIN_SIG_FMT_VGA_800X600P_75D000,
-	0,  // TVIN_SIG_FMT_VGA_800X600P_85D061,   // 30
-	0,  // TVIN_SIG_FMT_VGA_832X624P_75D087,
-	0,  // TVIN_SIG_FMT_VGA_848X480P_84D751,
-	0,  // TVIN_SIG_FMT_VGA_960X600P_59D635,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_59D278,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_74D927,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_60D004,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_70D069,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_75D029,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_84D997,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_60D000,   // 40
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_74D925,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_75D020,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_70D008,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_75D782,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_77D069,
-	0,  // TVIN_SIG_FMT_VGA_1024X768P_71D799,
-	0,  // TVIN_SIG_FMT_VGA_1024X1024P_60D000,
-	0,  // TVIN_SIG_FMT_VGA_1152X864P_70D012,
-	0,  // TVIN_SIG_FMT_VGA_1152X864P_75D000,
-	0,  // TVIN_SIG_FMT_VGA_1152X864P_84D999,   // 50
-	0,  // TVIN_SIG_FMT_VGA_1152X870P_75D062,
-	0,  // TVIN_SIG_FMT_VGA_1152X900P_65D950,
-	0,  // TVIN_SIG_FMT_VGA_1152X900P_66D004,
-	0,  // TVIN_SIG_FMT_VGA_1152X900P_76D047,
-	0,  // TVIN_SIG_FMT_VGA_1152X900P_76D149,
-	0,  // TVIN_SIG_FMT_VGA_1280X720P_59D855,
-	0,  // TVIN_SIG_FMT_VGA_1280X768P_59D870,
-	0,  // TVIN_SIG_FMT_VGA_1280X768P_59D995,
-	0,  // TVIN_SIG_FMT_VGA_1280X768P_60D100,
-	0,  // TVIN_SIG_FMT_VGA_1280X768P_74D893,   // 60
-	0,  // TVIN_SIG_FMT_VGA_1280X768P_84D837,
-	0,  // TVIN_SIG_FMT_VGA_1280X800P_59D810,
-	0,  // TVIN_SIG_FMT_VGA_1280X960P_60D000,
-	0,  // TVIN_SIG_FMT_VGA_1280X960P_75D000,
-	0,  // TVIN_SIG_FMT_VGA_1280X960P_85D002,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_60D020,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_75D025,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_85D024,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_59D979,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_72D005,   // 70
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_60D002,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_67D003,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_74D112,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_76D179,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_66D718,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_66D677,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_76D107,
-	0,  // TVIN_SIG_FMT_VGA_1280X1024P_59D996,
-	0,  // TVIN_SIG_FMT_VGA_1360X768P_59D799,
-	0,  // TVIN_SIG_FMT_VGA_1440X1080P_60D000,   // 80
-	0,  // TVIN_SIG_FMT_VGA_1600X1200P_60D000,
-	0,  // TVIN_SIG_FMT_VGA_1600X1200P_65D000,
-	0,  // TVIN_SIG_FMT_VGA_1600X1200P_70D000,
-	0,  // TVIN_SIG_FMT_VGA_1680X1080P_60D000,
-	0,  // TVIN_SIG_FMT_VGA_1920X1080P_59D963,
-	0,  // TVIN_SIG_FMT_VGA_1920X1080P_60D000,
-	0,  // TVIN_SIG_FMT_VGA_1920X1200P_59D950,
-	0,  // TVIN_SIG_FMT_VGA_MAX,
-#endif
-	//Component format
-#ifdef CONFIG_ADC_DOUBLE_SAMPLING_FOR_SD
-	-47,   	// TVIN_SIG_FMT_COMPONENT_480P_60D000,
-	17,  	// TVIN_SIG_FMT_COMPONENT_480I_59D940,
-	-44,   	// TVIN_SIG_FMT_COMPONENT_576P_50D000,
-	7,  	//TVIN_SIG_FMT_COMPONENT_576I_50D000,
-#else
-	-47,   // TVIN_SIG_FMT_COMPONENT_480P_60D000,
-	6,   // TVIN_SIG_FMT_COMPONENT_480I_59D940,
-	-47,   // TVIN_SIG_FMT_COMPONENT_576P_50D000,
-	3,   // TVIN_SIG_FMT_COMPONENT_576I_50D000,
-#endif
-	-29,   // TVIN_SIG_FMT_COMPONENT_720P_59D940,
-	-29,   // TVIN_SIG_FMT_COMPONENT_720P_50D000,
-	0,   // TVIN_SIG_FMT_COMPONENT_1080P_23D976,
-	0,   // TVIN_SIG_FMT_COMPONENT_1080P_24D000,
-	14,   // TVIN_SIG_FMT_COMPONENT_1080P_25D000,    // 90
-	-33,   // TVIN_SIG_FMT_COMPONENT_1080P_30D000,
-	-29,   // TVIN_SIG_FMT_COMPONENT_1080P_50D000,
-	-30,   // TVIN_SIG_FMT_COMPONENT_1080P_60D000,
-	0,   // TVIN_SIG_FMT_COMPONENT_1080I_47D952,
-	0,   // TVIN_SIG_FMT_COMPONENT_1080I_48D000,
-	-29,   // TVIN_SIG_FMT_COMPONENT_1080I_50D000_A,
-	0,   // TVIN_SIG_FMT_COMPONENT_1080I_50D000_B,
-	0,   // TVIN_SIG_FMT_COMPONENT_1080I_50D000_C,
-	-28,   // TVIN_SIG_FMT_COMPONENT_1080I_60D000,    //99
-};
-
-/* TOP */ //TVIN_SIG_FMT_VGA_800X600P_60D317
-const static  int vga_top_reg_default[][2] = {
-	{TVFE_DVSS_MUXCTRL             , 0x017000008,} ,// TVFE_DVSS_MUXCTRL
-	{TVFE_DVSS_MUXVS_REF           , 0x00000000,} ,// TVFE_DVSS_MUXVS_REF
-	{TVFE_DVSS_MUXCOAST_V          , 0x0200000c,} ,// TVFE_DVSS_MUXCOAST_V
-	{TVFE_DVSS_SEP_HVWIDTH         , 0x000a0073,} ,// TVFE_DVSS_SEP_HVWIDTH
-	{TVFE_DVSS_SEP_HPARA           , 0x026b0343,} ,// TVFE_DVSS_SEP_HPARA
-	{TVFE_DVSS_SEP_VINTEG          , 0x0fff0100,} ,// TVFE_DVSS_SEP_VINTEG
-	{TVFE_DVSS_SEP_H_THR           , 0x00005002,} ,// TVFE_DVSS_SEP_H_THR
-	{TVFE_DVSS_SEP_CTRL            , 0x40000008,} ,// TVFE_DVSS_SEP_CTRL
-	{TVFE_DVSS_GEN_WIDTH           , 0x00080008,} ,// TVFE_DVSS_GEN_WIDTH
-	{TVFE_DVSS_GEN_PRD             , 0x020d0359,} ,// TVFE_DVSS_GEN_PRD
-	{TVFE_DVSS_GEN_COAST           , 0x01cc001c,} ,// TVFE_DVSS_GEN_COAST
-	{TVFE_DVSS_NOSIG_PARA          , 0x00000009,} ,// TVFE_DVSS_NOSIG_PARA
-	{TVFE_DVSS_NOSIG_PLS_TH        , 0x05000010,} ,// TVFE_DVSS_NOSIG_PLS_TH
-	{TVFE_DVSS_GATE_H              , 0x00260010,} ,// TVFE_DVSS_GATE_H
-	{TVFE_DVSS_GATE_V              , 0x00000000,} ,// TVFE_DVSS_GATE_V
-	{TVFE_DVSS_INDICATOR1          , 0x00000000,} ,// TVFE_DVSS_INDICATOR1
-	{TVFE_DVSS_INDICATOR2          , 0x00000000,} ,// TVFE_DVSS_INDICATOR2
-	{TVFE_DVSS_MVDET_CTRL1         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL1
-	{TVFE_DVSS_MVDET_CTRL2         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL2
-	{TVFE_DVSS_MVDET_CTRL3         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL3
-	{TVFE_DVSS_MVDET_CTRL4         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL4
-	{TVFE_DVSS_MVDET_CTRL5         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL5
-	{TVFE_DVSS_MVDET_CTRL6         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL6
-	{TVFE_DVSS_MVDET_CTRL7         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL7
-	{TVFE_SYNCTOP_SPOL_MUXCTRL     , 0x0002f009,} ,// TVFE_SYNCTOP_SPOL_MUXCTRL
-	{TVFE_SYNCTOP_INDICATOR1_HCNT  , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR1_HCNT
-	{TVFE_SYNCTOP_INDICATOR2_VCNT  , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR2_VCNT
-	{TVFE_SYNCTOP_INDICATOR3       , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR3
-	{TVFE_SYNCTOP_SFG_MUXCTRL1     , 0x81315107,} ,// TVFE_SYNCTOP_SFG_MUXCTRL1
-	{TVFE_SYNCTOP_SFG_MUXCTRL2     , 0x01330000,} ,// TVFE_SYNCTOP_SFG_MUXCTRL2
-	{TVFE_SYNCTOP_INDICATOR4       , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR4
-	{TVFE_SYNCTOP_SAM_MUXCTRL      , 0x00082001,} ,// TVFE_SYNCTOP_SAM_MUXCTRL
-	{TVFE_MISC_WSS1_MUXCTRL1       , 0x00000000,} ,// TVFE_MISC_WSS1_MUXCTRL1
-	{TVFE_MISC_WSS1_MUXCTRL2       , 0x00000000,} ,// TVFE_MISC_WSS1_MUXCTRL2
-	{TVFE_MISC_WSS2_MUXCTRL1       , 0x00000000,} ,// TVFE_MISC_WSS2_MUXCTRL1
-	{TVFE_MISC_WSS2_MUXCTRL2       , 0x00000000,} ,// TVFE_MISC_WSS2_MUXCTRL2
-	{TVFE_MISC_WSS1_INDICATOR1     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR1
-	{TVFE_MISC_WSS1_INDICATOR2     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR2
-	{TVFE_MISC_WSS1_INDICATOR3     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR3
-	{TVFE_MISC_WSS1_INDICATOR4     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR4
-	{TVFE_MISC_WSS1_INDICATOR5     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR5
-	{TVFE_MISC_WSS2_INDICATOR1     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR1
-	{TVFE_MISC_WSS2_INDICATOR2     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR2
-	{TVFE_MISC_WSS2_INDICATOR3     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR3
-	{TVFE_MISC_WSS2_INDICATOR4     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR4
-	{TVFE_MISC_WSS2_INDICATOR5     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR5
-	{TVFE_AP_MUXCTRL1              , 0x11310010,} ,// TVFE_AP_MUXCTRL1
-	{TVFE_AP_MUXCTRL2              , 0x00200010,} ,// TVFE_AP_MUXCTRL2
-	{TVFE_AP_MUXCTRL3              , 0x10000030,} ,// TVFE_AP_MUXCTRL3
-	{TVFE_AP_MUXCTRL4              , 0x00000000,} ,// TVFE_AP_MUXCTRL4
-	{TVFE_AP_MUXCTRL5              , 0x10040000,} ,// TVFE_AP_MUXCTRL5
-	{TVFE_AP_INDICATOR1            , 0x00000000,} ,// TVFE_AP_INDICATOR1
-	{TVFE_AP_INDICATOR2            , 0x00000000,} ,// TVFE_AP_INDICATOR2
-	{TVFE_AP_INDICATOR3            , 0x00000000,} ,// TVFE_AP_INDICATOR3
-	{TVFE_AP_INDICATOR4            , 0x00000000,} ,// TVFE_AP_INDICATOR4
-	{TVFE_AP_INDICATOR5            , 0x00000000,} ,// TVFE_AP_INDICATOR5
-	{TVFE_AP_INDICATOR6            , 0x00000000,} ,// TVFE_AP_INDICATOR6
-	{TVFE_AP_INDICATOR7            , 0x00000000,} ,// TVFE_AP_INDICATOR7
-	{TVFE_AP_INDICATOR8            , 0x00000000,} ,// TVFE_AP_INDICATOR8
-	{TVFE_AP_INDICATOR9            , 0x00000000,} ,// TVFE_AP_INDICATOR9
-	{TVFE_AP_INDICATOR10           , 0x00000000,} ,// TVFE_AP_INDICATOR10
-	{TVFE_AP_INDICATOR11           , 0x00000000,} ,// TVFE_AP_INDICATOR11
-	{TVFE_AP_INDICATOR12           , 0x00000000,} ,// TVFE_AP_INDICATOR12
-	{TVFE_AP_INDICATOR13           , 0x00000000,} ,// TVFE_AP_INDICATOR13
-	{TVFE_AP_INDICATOR14           , 0x00000000,} ,// TVFE_AP_INDICATOR14
-	{TVFE_AP_INDICATOR15           , 0x00000000,} ,// TVFE_AP_INDICATOR15
-	{TVFE_AP_INDICATOR16           , 0x00000000,} ,// TVFE_AP_INDICATOR16
-	{TVFE_AP_INDICATOR17           , 0x00000000,} ,// TVFE_AP_INDICATOR17
-	{TVFE_AP_INDICATOR18           , 0x00000000,} ,// TVFE_AP_INDICATOR18
-	{TVFE_AP_INDICATOR19           , 0x00000000,} ,// TVFE_AP_INDICATOR19
-	{TVFE_BD_MUXCTRL1              , 0x01320000,} ,// TVFE_BD_MUXCTRL1
-	{TVFE_BD_MUXCTRL2              , 0x0020d000,} ,// TVFE_BD_MUXCTRL2
-	{TVFE_BD_MUXCTRL3              , 0x00000000,} ,// TVFE_BD_MUXCTRL3
-	{TVFE_BD_MUXCTRL4              , 0x00000000,} ,// TVFE_BD_MUXCTRL4
-	{TVFE_CLP_MUXCTRL1             , 0x00000000,} ,// TVFE_CLP_MUXCTRL1
-	{TVFE_CLP_MUXCTRL2             , 0x00000000,} ,// TVFE_CLP_MUXCTRL2
-	{TVFE_CLP_MUXCTRL3             , 0x00000000,} ,// TVFE_CLP_MUXCTRL3
-	{TVFE_CLP_MUXCTRL4             , 0x00000000,} ,// TVFE_CLP_MUXCTRL4
-	{TVFE_CLP_INDICATOR1           , 0x00000000,} ,// TVFE_CLP_INDICATOR1
-	{TVFE_BPG_BACKP_H              , 0x00000000,} ,// TVFE_BPG_BACKP_H
-	{TVFE_BPG_BACKP_V              , 0x00000000,} ,// TVFE_BPG_BACKP_V
-	{TVFE_DEG_H                    , 0x003f80d8,} ,// TVFE_DEG_H
-	{TVFE_DEG_VODD                 , 0x0027301b,} ,// TVFE_DEG_VODD
-	{TVFE_DEG_VEVEN                , 0x0027301b,} ,// TVFE_DEG_VEVEN
-	{TVFE_OGO_OFFSET1              , 0x00000000,} ,// TVFE_OGO_OFFSET1
-	{TVFE_OGO_GAIN1                , 0x00000000,} ,// TVFE_OGO_GAIN1
-	{TVFE_OGO_GAIN2                , 0x00000000,} ,// TVFE_OGO_GAIN2
-	{TVFE_OGO_OFFSET2              , 0x00000000,} ,// TVFE_OGO_OFFSET2
-	{TVFE_OGO_OFFSET3              , 0x00000000,} ,// TVFE_OGO_OFFSET3
-	{TVFE_VAFE_CTRL                , 0x00000001,} ,// TVFE_VAFE_CTRL
-	{TVFE_VAFE_STATUS              , 0x00000000,} ,// TVFE_VAFE_STATUS
-	{TVFE_TOP_CTRL                 , 0x00008740,} ,// TVFE_TOP_CTRL
-	{TVFE_CLAMP_INTF               , 0x00000000,} ,// TVFE_CLAMP_INTF
-	{TVFE_RST_CTRL                 , 0x00000000,} ,// TVFE_RST_CTRL
-	{TVFE_EXT_VIDEO_AFE_CTRL_MUX1  , 0x00000000,} ,// TVFE_EXT_VIDEO_AFE_CTRL_MUX1
-	//{TVFE_AAFILTER_CTRL1           , 0x00082222,} ,// TVFE_AAFILTER_CTRL1
-	//{TVFE_AAFILTER_CTRL2           , 0x252b39c6,} ,// TVFE_AAFILTER_CTRL2
-	{TVFE_EDID_CONFIG              , TVAFE_EDID_CONFIG,} ,// TVFE_EDID_CONFIG
-	{TVFE_EDID_RAM_ADDR            , 0x00000100,} ,// TVFE_EDID_RAM_ADDR
-	{TVFE_EDID_RAM_WDATA           , 0x00000000,} ,// TVFE_EDID_RAM_WDATA
-	{TVFE_EDID_RAM_RDATA           , 0x00000000,} ,// TVFE_EDID_RAM_RDATA
-	{TVFE_APB_ERR_CTRL_MUX1        , 0x8fff8fff,} ,// TVFE_APB_ERR_CTRL_MUX1
-	{TVFE_APB_ERR_CTRL_MUX2        , 0x00008fff,} ,// TVFE_APB_ERR_CTRL_MUX2
-	{TVFE_APB_INDICATOR1           , 0x00000000,} ,// TVFE_APB_INDICATOR1
-	{TVFE_APB_INDICATOR2           , 0x00000000,} ,// TVFE_APB_INDICATOR2
-	{TVFE_ADC_READBACK_CTRL        , 0xa0142003,} ,// TVFE_ADC_READBACK_CTRL
-	{TVFE_ADC_READBACK_INDICATOR   , 0x00000000,} ,// TVFE_ADC_READBACK_INDICATOR
-	{TVFE_INT_CLR                  , 0x00000000,} ,// TVFE_INT_CLR
-	{TVFE_INT_MSKN                 , 0x00000000,} ,// TVFE_INT_MASKN
-	{TVFE_INT_INDICATOR1           , 0x00000000,} ,// TVFE_INT_INDICATOR1
-	{TVFE_INT_SET                  , 0x00000000,} ,// TVFE_INT_SET
-	{TVFE_CHIP_VERSION             , 0x00000000,} ,// TVFE_CHIP_VERSION
-	{TVFE_FREERUN_GEN_WIDTH        , 0x00080008,},//TVFE_FREERUN_GEN_WIDTH
-	{TVFE_FREERUN_GEN_PRD          , 0x020d0359,},//TVFE_FREERUN_GEN_PRD
-	{TVFE_FREERUN_GEN_COAST        , 0x01cc001c,},//TVFE_FREERUN_GEN_COAST
-	{TVFE_FREERUN_GEN_CTRL         , 0x00000001,},//TVFE_FREERUN_GEN_CTRL
-	{TVFE_AAFILTER_CTRL1            ,   0x00100000,},//TVFE_AAFILTER_CTRL1 bypass all
-	{TVFE_AAFILTER_CTRL2            ,   0x00000000,},//TVFE_AAFILTER_CTRL2
-	{TVFE_AAFILTER_CTRL3            ,   0x00000000,},//TVFE_AAFILTER_CTRL3
-	{TVFE_AAFILTER_CTRL4            ,   0x00000000,},//TVFE_AAFILTER_CTRL4
-	{TVFE_AAFILTER_CTRL5            ,   0x00000000,},//TVFE_AAFILTER_CTRL5
-	{TVFE_SOG_MON_CTRL1            ,   0x00000000,},//TVFE_SOG_MON_CTRL1
-	{TVFE_ADC_READBACK_CTRL1,    0x00000000,},//TVFE_ADC_READBACK_CTRL1
-	{TVFE_ADC_READBACK_CTRL2,    0x00000000,},//TVFE_ADC_READBACK_CTRL2
-	{TVFE_AFC_CTRL1                      ,    0x00000000,},//TVFE_AFC_CTRL1
-	{TVFE_AFC_CTRL2                      ,    0x00000000,},//TVFE_AFC_CTRL2
-	{TVFE_AFC_CTRL3                      ,    0x00000000,},//TVFE_AFC_CTRL3
-	{TVFE_AFC_CTRL4                      ,    0x00000000,},//TVFE_AFC_CTRL4
-	{TVFE_AFC_CTRL5                      ,    0x00000000,},//TVFE_AFC_CTRL5
-	{0xFFFFFFFF                    , 0x00000000,}, // TVFE_CHIP_VERSION
-}; //TVIN_SIG_FMT_VGA_800X600P_60D317
-/* TOP */
-
-///zhuang wei
-const static  int comp_top_reg_default[][2] = {
-	{TVFE_DVSS_MUXCTRL              , 0x172a4083/*0x072a1480*/,} ,// TVFE_DVSS_MUXCTRL //zhuang
-	{TVFE_DVSS_MUXVS_REF           , 0x00000000,} ,// TVFE_DVSS_MUXVS_REF
-	{TVFE_DVSS_MUXCOAST_V          , 0x00000000,} ,// TVFE_DVSS_MUXCOAST_V
-	{TVFE_DVSS_SEP_HVWIDTH         , 0x00000000,} ,// TVFE_DVSS_SEP_HVWIDTH
-	{TVFE_DVSS_SEP_HPARA           , 0x00000000,} ,// TVFE_DVSS_SEP_HPARA
-	{TVFE_DVSS_SEP_VINTEG          , 0x00000000,} ,// TVFE_DVSS_SEP_VINTEG
-	{TVFE_DVSS_SEP_H_THR           , 0x00000000,} ,// TVFE_DVSS_SEP_H_THR
-	{TVFE_DVSS_SEP_CTRL            , 0x00000000,} ,// TVFE_DVSS_SEP_CTRL
-	{TVFE_DVSS_GEN_WIDTH           , 0x00080008,} ,// TVFE_DVSS_GEN_WIDTH
-	{TVFE_DVSS_GEN_PRD             , 0x020d035a,} ,// TVFE_DVSS_GEN_PRD
-	{TVFE_DVSS_GEN_COAST           , 0x00000000,} ,// TVFE_DVSS_GEN_COAST
-	{TVFE_DVSS_NOSIG_PARA          , 0x0000000d/*0x00000000*/,} ,// TVFE_DVSS_NOSIG_PARA
-	{TVFE_DVSS_NOSIG_PLS_TH        , 0x00FF0010/*0x00000000*/,} ,// TVFE_DVSS_NOSIG_PLS_TH
-	{TVFE_DVSS_GATE_H              , 0x00260010,} ,// TVFE_DVSS_GATE_H
-	{TVFE_DVSS_GATE_V              , 0x00000000,} ,// TVFE_DVSS_GATE_V
-	{TVFE_DVSS_INDICATOR1          , 0x00000000,} ,// TVFE_DVSS_INDICATOR1
-	{TVFE_DVSS_INDICATOR2          , 0x00000000,} ,// TVFE_DVSS_INDICATOR2
-	{TVFE_DVSS_MVDET_CTRL1         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL1
-	{TVFE_DVSS_MVDET_CTRL2         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL2
-	{TVFE_DVSS_MVDET_CTRL3         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL3
-	{TVFE_DVSS_MVDET_CTRL4         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL4
-	{TVFE_DVSS_MVDET_CTRL5         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL5
-	{TVFE_DVSS_MVDET_CTRL6         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL6
-	{TVFE_DVSS_MVDET_CTRL7         , 0x00000000,} ,// TVFE_DVSS_MVDET_CTRL7
-	{TVFE_SYNCTOP_SPOL_MUXCTRL     , 0x00000009,} ,// TVFE_SYNCTOP_SPOL_MUXCTRL
-	{TVFE_SYNCTOP_INDICATOR1_HCNT  , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR1_HCNT
-	{TVFE_SYNCTOP_INDICATOR2_VCNT  , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR2_VCNT
-	{TVFE_SYNCTOP_INDICATOR3       , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR3
-	{TVFE_SYNCTOP_SFG_MUXCTRL1     , 0x812880d8,} ,// TVFE_SYNCTOP_SFG_MUXCTRL1
-	{TVFE_SYNCTOP_SFG_MUXCTRL2     , 0x00334400,} ,// TVFE_SYNCTOP_SFG_MUXCTRL2
-	{TVFE_SYNCTOP_INDICATOR4       , 0x00000000,} ,// TVFE_SYNCTOP_INDICATOR4
-	{TVFE_SYNCTOP_SAM_MUXCTRL      , 0x00088000,} ,// TVFE_SYNCTOP_SAM_MUXCTRL
-	{TVFE_MISC_WSS1_MUXCTRL1       , 0x00000000,} ,// TVFE_MISC_WSS1_MUXCTRL1
-	{TVFE_MISC_WSS1_MUXCTRL2       , 0x00000000,} ,// TVFE_MISC_WSS1_MUXCTRL2
-	{TVFE_MISC_WSS2_MUXCTRL1       , 0x00000000,} ,// TVFE_MISC_WSS2_MUXCTRL1
-	{TVFE_MISC_WSS2_MUXCTRL2       , 0x00000000,} ,// TVFE_MISC_WSS2_MUXCTRL2
-	{TVFE_MISC_WSS1_INDICATOR1     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR1
-	{TVFE_MISC_WSS1_INDICATOR2     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR2
-	{TVFE_MISC_WSS1_INDICATOR3     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR3
-	{TVFE_MISC_WSS1_INDICATOR4     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR4
-	{TVFE_MISC_WSS1_INDICATOR5     , 0x00000000,} ,// TVFE_MISC_WSS1_INDICATOR5
-	{TVFE_MISC_WSS2_INDICATOR1     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR1
-	{TVFE_MISC_WSS2_INDICATOR2     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR2
-	{TVFE_MISC_WSS2_INDICATOR3     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR3
-	{TVFE_MISC_WSS2_INDICATOR4     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR4
-	{TVFE_MISC_WSS2_INDICATOR5     , 0x00000000,} ,// TVFE_MISC_WSS2_INDICATOR5
-	{TVFE_AP_MUXCTRL1              , 0x00000000,} ,// TVFE_AP_MUXCTRL1
-	{TVFE_AP_MUXCTRL2              , 0x00000000,} ,// TVFE_AP_MUXCTRL2
-	{TVFE_AP_MUXCTRL3              , 0x00000000,} ,// TVFE_AP_MUXCTRL3
-	{TVFE_AP_MUXCTRL4              , 0x00000000,} ,// TVFE_AP_MUXCTRL4
-	{TVFE_AP_MUXCTRL5              , 0x00000000,} ,// TVFE_AP_MUXCTRL5
-	{TVFE_AP_INDICATOR1            , 0x00000000,} ,// TVFE_AP_INDICATOR1
-	{TVFE_AP_INDICATOR2            , 0x00000000,} ,// TVFE_AP_INDICATOR2
-	{TVFE_AP_INDICATOR3            , 0x00000000,} ,// TVFE_AP_INDICATOR3
-	{TVFE_AP_INDICATOR4            , 0x00000000,} ,// TVFE_AP_INDICATOR4
-	{TVFE_AP_INDICATOR5            , 0x00000000,} ,// TVFE_AP_INDICATOR5
-	{TVFE_AP_INDICATOR6            , 0x00000000,} ,// TVFE_AP_INDICATOR6
-	{TVFE_AP_INDICATOR7            , 0x00000000,} ,// TVFE_AP_INDICATOR7
-	{TVFE_AP_INDICATOR8            , 0x00000000,} ,// TVFE_AP_INDICATOR8
-	{TVFE_AP_INDICATOR9            , 0x00000000,} ,// TVFE_AP_INDICATOR9
-	{TVFE_AP_INDICATOR10           , 0x00000000,} ,// TVFE_AP_INDICATOR10
-	{TVFE_AP_INDICATOR11           , 0x00000000,} ,// TVFE_AP_INDICATOR11
-	{TVFE_AP_INDICATOR12           , 0x00000000,} ,// TVFE_AP_INDICATOR12
-	{TVFE_AP_INDICATOR13           , 0x00000000,} ,// TVFE_AP_INDICATOR13
-	{TVFE_AP_INDICATOR14           , 0x00000000,} ,// TVFE_AP_INDICATOR14
-	{TVFE_AP_INDICATOR15           , 0x00000000,} ,// TVFE_AP_INDICATOR15
-	{TVFE_AP_INDICATOR16           , 0x00000000,} ,// TVFE_AP_INDICATOR16
-	{TVFE_AP_INDICATOR17           , 0x00000000,} ,// TVFE_AP_INDICATOR17
-	{TVFE_AP_INDICATOR18           , 0x00000000,} ,// TVFE_AP_INDICATOR18
-	{TVFE_AP_INDICATOR19           , 0x00000000,} ,// TVFE_AP_INDICATOR19
-	{TVFE_BD_MUXCTRL1              , 0x00000000,} ,// TVFE_BD_MUXCTRL1
-	{TVFE_BD_MUXCTRL2              , 0x00000000,} ,// TVFE_BD_MUXCTRL2
-	{TVFE_BD_MUXCTRL3              , 0x00000000,} ,// TVFE_BD_MUXCTRL3
-	{TVFE_BD_MUXCTRL4              , 0x00000000,} ,// TVFE_BD_MUXCTRL4
-	{TVFE_CLP_MUXCTRL1             , 0x00000000,} ,// TVFE_CLP_MUXCTRL1
-	{TVFE_CLP_MUXCTRL2             , 0x00000000,} ,// TVFE_CLP_MUXCTRL2
-	{TVFE_CLP_MUXCTRL3             , 0x00000000,} ,// TVFE_CLP_MUXCTRL3
-	{TVFE_CLP_MUXCTRL4             , 0x00000000,} ,// TVFE_CLP_MUXCTRL4
-	{TVFE_CLP_INDICATOR1           , 0x00000000,} ,// TVFE_CLP_INDICATOR1
-	{TVFE_BPG_BACKP_H              , 0x00000000,} ,// TVFE_BPG_BACKP_H
-	{TVFE_BPG_BACKP_V              , 0x00000000,} ,// TVFE_BPG_BACKP_V
-	{TVFE_DEG_H                    , 0x00621121,} ,// TVFE_DEG_H
-	{TVFE_DEG_VODD                 , 0x002e8018,} ,// TVFE_DEG_VODD //zhuang
-	{TVFE_DEG_VEVEN                , 0x002e8018,} ,// TVFE_DEG_VEVEN //zhuang
-	{TVFE_OGO_OFFSET1              , 0x00000000,} ,// TVFE_OGO_OFFSET1
-	{TVFE_OGO_GAIN1                , 0x00000000,} ,// TVFE_OGO_GAIN1
-	{TVFE_OGO_GAIN2                , 0x00000000,} ,// TVFE_OGO_GAIN2
-	{TVFE_OGO_OFFSET2              , 0x00000000,} ,// TVFE_OGO_OFFSET2
-	{TVFE_OGO_OFFSET3              , 0x00000000,} ,// TVFE_OGO_OFFSET3
-	{TVFE_VAFE_CTRL                , 0x00000201,} ,// TVFE_VAFE_CTRL //zhuang
-	{TVFE_VAFE_STATUS              , 0x00000000,} ,// TVFE_VAFE_STATUS
-	{TVFE_TOP_CTRL                 , 0x00008340,} ,// TVFE_TOP_CTRL
-	{TVFE_CLAMP_INTF               , 0x00000000,} ,// TVFE_CLAMP_INTF
-	{TVFE_RST_CTRL                 , 0x00000000,} ,// TVFE_RST_CTRL
-	{TVFE_EXT_VIDEO_AFE_CTRL_MUX1  , 0x00000000,} ,// TVFE_EXT_VIDEO_AFE_CTRL_MUX1
-	//{TVFE_AAFILTER_CTRL1           , 0x00082222,} ,// TVFE_AAFILTER_CTRL1
-	//{TVFE_AAFILTER_CTRL2           , 0x252b39c6,} ,// TVFE_AAFILTER_CTRL2
-	{TVFE_EDID_CONFIG              , TVAFE_EDID_CONFIG,} ,// TVFE_EDID_CONFIG
-	{TVFE_EDID_RAM_ADDR            , 0x00000100,} ,// TVFE_EDID_RAM_ADDR
-	{TVFE_EDID_RAM_WDATA           , 0x00000000,} ,// TVFE_EDID_RAM_WDATA
-	{TVFE_EDID_RAM_RDATA           , 0x00000000,} ,// TVFE_EDID_RAM_RDATA
-	{TVFE_APB_ERR_CTRL_MUX1        , 0x8fff8fff,} ,// TVFE_APB_ERR_CTRL_MUX1
-	{TVFE_APB_ERR_CTRL_MUX2        , 0x00008fff,} ,// TVFE_APB_ERR_CTRL_MUX2
-	{TVFE_APB_INDICATOR1           , 0x00000000,} ,// TVFE_APB_INDICATOR1
-	{TVFE_APB_INDICATOR2           , 0x00000000,} ,// TVFE_APB_INDICATOR2
-	{TVFE_ADC_READBACK_CTRL        , 0x00000000,} ,// TVFE_ADC_READBACK_CTRL
-	{TVFE_ADC_READBACK_INDICATOR   , 0x00000000,} ,// TVFE_ADC_READBACK_INDICATOR
-	{TVFE_INT_CLR                  , 0x00000000,} ,// TVFE_INT_CLR
-	{TVFE_INT_MSKN                 , 0x00000000,} ,// TVFE_INT_MASKN
-	{TVFE_INT_INDICATOR1           , 0x00000000,} ,// TVFE_INT_INDICATOR1
-	{TVFE_INT_SET                  , 0x00000000,} ,// TVFE_INT_SET
-	{TVFE_CHIP_VERSION             , 0x00000000,} ,// TVFE_CHIP_VERSION
-	{TVFE_FREERUN_GEN_WIDTH        , 0x00080008,},//TVFE_FREERUN_GEN_WIDTH
-	{TVFE_FREERUN_GEN_PRD          , 0x020d035a,},//TVFE_FREERUN_GEN_PRD
-	{TVFE_FREERUN_GEN_COAST        , 0x00000000,},//TVFE_FREERUN_GEN_COAST
-	{TVFE_FREERUN_GEN_CTRL         , 0x00000001,},//TVFE_FREERUN_GEN_CTRL
-	{TVFE_AAFILTER_CTRL1            ,   0x00100000,},//TVFE_AAFILTER_CTRL1 bypass all
-	{TVFE_AAFILTER_CTRL2            ,   0x00000000,},//TVFE_AAFILTER_CTRL2
-	{TVFE_AAFILTER_CTRL3            ,   0x00000000,},//TVFE_AAFILTER_CTRL3
-	{TVFE_AAFILTER_CTRL4            ,   0x00000000,},//TVFE_AAFILTER_CTRL4
-	{TVFE_AAFILTER_CTRL5            ,   0x00000000,},//TVFE_AAFILTER_CTRL5
-	{TVFE_SOG_MON_CTRL1            ,   0x8000c804,},//TVFE_SOG_MON_CTRL1
-	{TVFE_ADC_READBACK_CTRL1,    0x00000000,},//TVFE_ADC_READBACK_CTRL1
-	{TVFE_ADC_READBACK_CTRL2,    0x00000000,},//TVFE_ADC_READBACK_CTRL2
-	{TVFE_AFC_CTRL1                      ,    0x00000000,},//TVFE_AFC_CTRL1
-	{TVFE_AFC_CTRL2                      ,    0x00000000,},//TVFE_AFC_CTRL2
-	{TVFE_AFC_CTRL3                      ,    0x00000000,},//TVFE_AFC_CTRL3
-	{TVFE_AFC_CTRL4                      ,    0x00000000,},//TVFE_AFC_CTRL4
-	{TVFE_AFC_CTRL5                      ,    0x00000000,},//TVFE_AFC_CTRL5
-	{0xFFFFFFFF                    , 0x00000000,}
-};
-
-/* TOP */
-const static unsigned int cvbs_top_reg_default[][2] = {
-	{TVFE_DVSS_MUXCTRL                      ,0x07000008/*0x00000000*/,}, // TVFE_DVSS_MUXCTRL
-	{TVFE_DVSS_MUXVS_REF                    ,0x00000000,}, // TVFE_DVSS_MUXVS_REF
-	{TVFE_DVSS_MUXCOAST_V                   ,0x00000000,}, // TVFE_DVSS_MUXCOAST_V
-	{TVFE_DVSS_SEP_HVWIDTH                  ,0x00000000,}, // TVFE_DVSS_SEP_HVWIDTH
-	{TVFE_DVSS_SEP_HPARA                    ,0x00000000,}, // TVFE_DVSS_SEP_HPARA
-	{TVFE_DVSS_SEP_VINTEG                   ,0x00000000,}, // TVFE_DVSS_SEP_VINTEG
-	{TVFE_DVSS_SEP_H_THR                    ,0x00000000,}, // TVFE_DVSS_SEP_H_THR
-	{TVFE_DVSS_SEP_CTRL                     ,0x00000000,}, // TVFE_DVSS_SEP_CTRL
-	{TVFE_DVSS_GEN_WIDTH                    ,0x00000000,}, // TVFE_DVSS_GEN_WIDTH
-	{TVFE_DVSS_GEN_PRD                      ,0x00000000,}, // TVFE_DVSS_GEN_PRD
-	{TVFE_DVSS_GEN_COAST                    ,0x00000000,}, // TVFE_DVSS_GEN_COAST
-	{TVFE_DVSS_NOSIG_PARA                   ,0x00000000,}, // TVFE_DVSS_NOSIG_PARA
-	{TVFE_DVSS_NOSIG_PLS_TH                 ,0x00000000,}, // TVFE_DVSS_NOSIG_PLS_TH
-	{TVFE_DVSS_GATE_H                       ,0x00000000,}, // TVFE_DVSS_GATE_H
-	{TVFE_DVSS_GATE_V                       ,0x00000000,}, // TVFE_DVSS_GATE_V
-	{TVFE_DVSS_INDICATOR1                   ,0x00000000,}, // TVFE_DVSS_INDICATOR1
-	{TVFE_DVSS_INDICATOR2                   ,0x00000000,}, // TVFE_DVSS_INDICATOR2
-	{TVFE_DVSS_MVDET_CTRL1                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL1
-	{TVFE_DVSS_MVDET_CTRL2                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL2
-	{TVFE_DVSS_MVDET_CTRL3                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL3
-	{TVFE_DVSS_MVDET_CTRL4                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL4
-	{TVFE_DVSS_MVDET_CTRL5                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL5
-	{TVFE_DVSS_MVDET_CTRL6                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL6
-	{TVFE_DVSS_MVDET_CTRL7                  ,0x00000000,}, // TVFE_DVSS_MVDET_CTRL7
-	{TVFE_SYNCTOP_SPOL_MUXCTRL              ,0x00000009,}, // TVFE_SYNCTOP_SPOL_MUXCTRL
-	{TVFE_SYNCTOP_INDICATOR1_HCNT           ,0x00000000,}, // TVFE_SYNCTOP_INDICATOR1_HCNT
-	{TVFE_SYNCTOP_INDICATOR2_VCNT           ,0x00000000,}, // TVFE_SYNCTOP_INDICATOR2_VCNT
-	{TVFE_SYNCTOP_INDICATOR3                ,0x00000000,}, // TVFE_SYNCTOP_INDICATOR3
-	{TVFE_SYNCTOP_SFG_MUXCTRL1              ,0x00000000,}, // TVFE_SYNCTOP_SFG_MUXCTRL1
-	{TVFE_SYNCTOP_SFG_MUXCTRL2              ,0x00330000,}, // TVFE_SYNCTOP_SFG_MUXCTRL2
-	{TVFE_SYNCTOP_INDICATOR4                ,0x00000000,}, // TVFE_SYNCTOP_INDICATOR4
-	{TVFE_SYNCTOP_SAM_MUXCTRL               ,0x00082001,}, // TVFE_SYNCTOP_SAM_MUXCTRL
-	{TVFE_MISC_WSS1_MUXCTRL1                ,0x00000000,}, // TVFE_MISC_WSS1_MUXCTRL1
-	{TVFE_MISC_WSS1_MUXCTRL2                ,0x00000000,}, // TVFE_MISC_WSS1_MUXCTRL2
-	{TVFE_MISC_WSS2_MUXCTRL1                ,0x00000000,}, // TVFE_MISC_WSS2_MUXCTRL1
-	{TVFE_MISC_WSS2_MUXCTRL2                ,0x00000000,}, // TVFE_MISC_WSS2_MUXCTRL2
-	{TVFE_MISC_WSS1_INDICATOR1              ,0x00000000,}, // TVFE_MISC_WSS1_INDICATOR1
-	{TVFE_MISC_WSS1_INDICATOR2              ,0x00000000,}, // TVFE_MISC_WSS1_INDICATOR2
-	{TVFE_MISC_WSS1_INDICATOR3              ,0x00000000,}, // TVFE_MISC_WSS1_INDICATOR3
-	{TVFE_MISC_WSS1_INDICATOR4              ,0x00000000,}, // TVFE_MISC_WSS1_INDICATOR4
-	{TVFE_MISC_WSS1_INDICATOR5              ,0x00000000,}, // TVFE_MISC_WSS1_INDICATOR5
-	{TVFE_MISC_WSS2_INDICATOR1              ,0x00000000,}, // TVFE_MISC_WSS2_INDICATOR1
-	{TVFE_MISC_WSS2_INDICATOR2              ,0x00000000,}, // TVFE_MISC_WSS2_INDICATOR2
-	{TVFE_MISC_WSS2_INDICATOR3              ,0x00000000,}, // TVFE_MISC_WSS2_INDICATOR3
-	{TVFE_MISC_WSS2_INDICATOR4              ,0x00000000,}, // TVFE_MISC_WSS2_INDICATOR4
-	{TVFE_MISC_WSS2_INDICATOR5              ,0x00000000,}, // TVFE_MISC_WSS2_INDICATOR5
-	{TVFE_AP_MUXCTRL1                       ,0x00000000,}, // TVFE_AP_MUXCTRL1
-	{TVFE_AP_MUXCTRL2                       ,0x00000000,}, // TVFE_AP_MUXCTRL2
-	{TVFE_AP_MUXCTRL3                       ,0x00000000,}, // TVFE_AP_MUXCTRL3
-	{TVFE_AP_MUXCTRL4                       ,0x00000000,}, // TVFE_AP_MUXCTRL4
-	{TVFE_AP_MUXCTRL5                       ,0x00000000,}, // TVFE_AP_MUXCTRL5
-	{TVFE_AP_INDICATOR1                     ,0x00000000,}, // TVFE_AP_INDICATOR1
-	{TVFE_AP_INDICATOR2                     ,0x00000000,}, // TVFE_AP_INDICATOR2
-	{TVFE_AP_INDICATOR3                     ,0x00000000,}, // TVFE_AP_INDICATOR3
-	{TVFE_AP_INDICATOR4                     ,0x00000000,}, // TVFE_AP_INDICATOR4
-	{TVFE_AP_INDICATOR5                     ,0x00000000,}, // TVFE_AP_INDICATOR5
-	{TVFE_AP_INDICATOR6                     ,0x00000000,}, // TVFE_AP_INDICATOR6
-	{TVFE_AP_INDICATOR7                     ,0x00000000,}, // TVFE_AP_INDICATOR7
-	{TVFE_AP_INDICATOR8                     ,0x00000000,}, // TVFE_AP_INDICATOR8
-	{TVFE_AP_INDICATOR9                     ,0x00000000,}, // TVFE_AP_INDICATOR9
-	{TVFE_AP_INDICATOR10                    ,0x00000000,}, // TVFE_AP_INDICATOR10
-	{TVFE_AP_INDICATOR11                    ,0x00000000,}, // TVFE_AP_INDICATOR11
-	{TVFE_AP_INDICATOR12                    ,0x00000000,}, // TVFE_AP_INDICATOR12
-	{TVFE_AP_INDICATOR13                    ,0x00000000,}, // TVFE_AP_INDICATOR13
-	{TVFE_AP_INDICATOR14                    ,0x00000000,}, // TVFE_AP_INDICATOR14
-	{TVFE_AP_INDICATOR15                    ,0x00000000,}, // TVFE_AP_INDICATOR15
-	{TVFE_AP_INDICATOR16                    ,0x00000000,}, // TVFE_AP_INDICATOR16
-	{TVFE_AP_INDICATOR17                    ,0x00000000,}, // TVFE_AP_INDICATOR17
-	{TVFE_AP_INDICATOR18                    ,0x00000000,}, // TVFE_AP_INDICATOR18
-	{TVFE_AP_INDICATOR19                    ,0x00000000,}, // TVFE_AP_INDICATOR19
-	{TVFE_BD_MUXCTRL1                       ,0x00000000,}, // TVFE_BD_MUXCTRL1
-	{TVFE_BD_MUXCTRL2                       ,0x00000000,}, // TVFE_BD_MUXCTRL2
-	{TVFE_BD_MUXCTRL3                       ,0x00000000,}, // TVFE_BD_MUXCTRL3
-	{TVFE_BD_MUXCTRL4                       ,0x00000000,}, // TVFE_BD_MUXCTRL4
-	{TVFE_CLP_MUXCTRL1                      ,0x00000000,}, // TVFE_CLP_MUXCTRL1
-	{TVFE_CLP_MUXCTRL2                      ,0x00000000,}, // TVFE_CLP_MUXCTRL2
-	{TVFE_CLP_MUXCTRL3                      ,0x00000000,}, // TVFE_CLP_MUXCTRL3
-	{TVFE_CLP_MUXCTRL4                      ,0x00000000,}, // TVFE_CLP_MUXCTRL4
-	{TVFE_CLP_INDICATOR1                    ,0x00000000,}, // TVFE_CLP_INDICATOR1
-	{TVFE_BPG_BACKP_H                       ,0x00000000,}, // TVFE_BPG_BACKP_H
-	{TVFE_BPG_BACKP_V                       ,0x00000000,}, // TVFE_BPG_BACKP_V
-	{TVFE_DEG_H                             ,0x00000000,}, // TVFE_DEG_H
-	{TVFE_DEG_VODD                          ,0x00000000,}, // TVFE_DEG_VODD
-	{TVFE_DEG_VEVEN                         ,0x00000000,}, // TVFE_DEG_VEVEN
-	{TVFE_OGO_OFFSET1                       ,0x00000000,}, // TVFE_OGO_OFFSET1
-	{TVFE_OGO_GAIN1                         ,0x00000000,}, // TVFE_OGO_GAIN1
-	{TVFE_OGO_GAIN2                         ,0x00000000,}, // TVFE_OGO_GAIN2
-	{TVFE_OGO_OFFSET2                       ,0x00000000,}, // TVFE_OGO_OFFSET2
-	{TVFE_OGO_OFFSET3                       ,0x00000000,}, // TVFE_OGO_OFFSET3
-	{TVFE_VAFE_CTRL                         ,0x00000000,}, // TVFE_VAFE_CTRL
-	{TVFE_VAFE_STATUS                       ,0x00000000,}, // TVFE_VAFE_STATUS
-	{TVFE_TOP_CTRL                          ,0xc4f64 /*0x00004B60*/,}, // TVFE_TOP_CTRL
-	{TVFE_CLAMP_INTF                        ,0x00008666,}, // TVFE_CLAMP_INTF
-	{TVFE_RST_CTRL                          ,0x00000000,}, // TVFE_RST_CTRL
-	{TVFE_EXT_VIDEO_AFE_CTRL_MUX1           ,0x00000000,}, // TVFE_EXT_VIDEO_AFE_CTRL_MUX1
-	//{TVFE_AAFILTER_CTRL1                    ,0x00082222,}, // TVFE_AAFILTER_CTRL1
-	//{TVFE_AAFILTER_CTRL2                    ,0x252b39c6,}, // TVFE_AAFILTER_CTRL2
-	{TVFE_EDID_CONFIG                       ,TVAFE_EDID_CONFIG,}, // TVFE_EDID_CONFIG
-	{TVFE_EDID_RAM_ADDR                     ,0x00000000,}, // TVFE_EDID_RAM_ADDR
-	{TVFE_EDID_RAM_WDATA                    ,0x00000000,}, // TVFE_EDID_RAM_WDATA
-	{TVFE_EDID_RAM_RDATA                    ,0x00000000,}, // TVFE_EDID_RAM_RDATA
-	{TVFE_APB_ERR_CTRL_MUX1                 ,0x8fff8fff,}, // TVFE_APB_ERR_CTRL_MUX1
-	{TVFE_APB_ERR_CTRL_MUX2                 ,0x00008fff,}, // TVFE_APB_ERR_CTRL_MUX2
-	{TVFE_APB_INDICATOR1                    ,0x00000000,}, // TVFE_APB_INDICATOR1
-	{TVFE_APB_INDICATOR2                    ,0x00000000,}, // TVFE_APB_INDICATOR2
-	{TVFE_ADC_READBACK_CTRL                 ,0x80140003,}, // TVFE_ADC_READBACK_CTRL
-	{TVFE_ADC_READBACK_INDICATOR            ,0x00000000,}, // TVFE_ADC_READBACK_INDICATOR
-	{TVFE_INT_CLR                           ,0x00000000,}, // TVFE_INT_CLR
-	{TVFE_INT_MSKN                          ,0x00000000,}, // TVFE_INT_MASKN
-	{TVFE_INT_INDICATOR1                    ,0x00000000,}, // TVFE_INT_INDICATOR1
-	{TVFE_INT_SET                           ,0x00000000,}, // TVFE_INT_SET
-	//{TVFE_CHIP_VERSION                      ,0x00000000,}, // TVFE_CHIP_VERSION
-	{TVFE_FREERUN_GEN_WIDTH   , 0x00000000,},//TVFE_FREERUN_GEN_WIDTH
-	{TVFE_FREERUN_GEN_PRD       ,  0x00000000,},//TVFE_FREERUN_GEN_PRD
-	{TVFE_FREERUN_GEN_COAST   , 0x00000000,},//TVFE_FREERUN_GEN_COAST
-	{TVFE_FREERUN_GEN_CTRL      , 0x00000000,},//TVFE_FREERUN_GEN_CTRL
-	{TVFE_AAFILTER_CTRL1            ,   0x00100000,},//TVFE_AAFILTER_CTRL1 bypass all
-	{TVFE_AAFILTER_CTRL2            ,   0x00000000,},//TVFE_AAFILTER_CTRL2
-	{TVFE_AAFILTER_CTRL3            ,   0x00000000,},//TVFE_AAFILTER_CTRL3
-	{TVFE_AAFILTER_CTRL4            ,   0x00000000,},//TVFE_AAFILTER_CTRL4
-	{TVFE_AAFILTER_CTRL5            ,   0x00000000,},//TVFE_AAFILTER_CTRL5
-	{TVFE_SOG_MON_CTRL1            ,   0x00000000,},//TVFE_SOG_MON_CTRL1
-	{TVFE_ADC_READBACK_CTRL1,   0x00000000,},//TVFE_ADC_READBACK_CTRL1
-	{TVFE_ADC_READBACK_CTRL2,   0x00000000,},//TVFE_ADC_READBACK_CTRL2
-	{TVFE_AFC_CTRL1                      ,   0x893904d2,},//TVFE_AFC_CTRL1
-	{TVFE_AFC_CTRL2                      ,   0xf4b9ac9,},//TVFE_AFC_CTRL2
-	{TVFE_AFC_CTRL3                      ,   0x1fd8c36,},//TVFE_AFC_CTRL3
-	{TVFE_AFC_CTRL4                      ,   0x2de6d04f,},//TVFE_AFC_CTRL4
-	{TVFE_AFC_CTRL5                      ,          0x4,},//TVFE_AFC_CTRL5
-	{0xFFFFFFFF                             ,0x00000000,}
-};
-
-
-/*
- * tvafe cvd2 video poaition reg setting
- */
-static enum tvafe_adc_ch_e tvafe_adc_pin_muxing(enum tvafe_adc_pin_e pin)
-{
-	enum tvafe_adc_ch_e ret = TVAFE_ADC_CH_NULL;
-
-	if ((pin >= TVAFE_ADC_PIN_A_PGA_0) && (pin <= TVAFE_ADC_PIN_A_PGA_3))
-	{
-		WRITE_APB_REG_BITS(ADC_REG_06, 1, ENPGA_BIT, ENPGA_WID);
-		WRITE_APB_REG_BITS(ADC_REG_17, pin-TVAFE_ADC_PIN_A_PGA_0, INMUXA_BIT, INMUXA_WID);
-		ret = TVAFE_ADC_CH_PGA;
-	}
-	else if ((pin >= TVAFE_ADC_PIN_A_0) && (pin <= TVAFE_ADC_PIN_A_3))
-	{
-		WRITE_APB_REG_BITS(ADC_REG_06, 0, ENPGA_BIT, ENPGA_WID);
-		WRITE_APB_REG_BITS(ADC_REG_17, pin-TVAFE_ADC_PIN_A_0, INMUXA_BIT, INMUXA_WID);
-		ret = TVAFE_ADC_CH_A;
-	}
-	else if ((pin >= TVAFE_ADC_PIN_B_0) && (pin <= TVAFE_ADC_PIN_B_4))
-	{
-		WRITE_APB_REG_BITS(ADC_REG_17, pin-TVAFE_ADC_PIN_B_0, INMUXB_BIT, INMUXB_WID);
-		ret = TVAFE_ADC_CH_B;
-	}
-	else if ((pin >= TVAFE_ADC_PIN_C_0) && (pin <= TVAFE_ADC_PIN_C_4))
-	{
-		WRITE_APB_REG_BITS(ADC_REG_18, pin-TVAFE_ADC_PIN_C_0, INMUXC_BIT, INMUXC_WID);
-		ret = TVAFE_ADC_CH_C;
-	}
-	return ret;
-}
-
-/*
-000: abc
-001: acb
-010: bac
-011: bca
-100: cab
-101: cba
- * tvafe top mux setting for yuv channel
- */
-static int tvafe_adc_top_muxing(enum tvafe_adc_ch_e gy,
-		enum tvafe_adc_ch_e bpb,
-		enum tvafe_adc_ch_e rpr,
-		unsigned int s_video_flag)
-{
-	int ret = 0;
-
-	switch (gy)
-	{
-		case TVAFE_ADC_CH_PGA:
-		case TVAFE_ADC_CH_A:
-			switch (bpb)
-			{
-				case TVAFE_ADC_CH_B:
-					// abc => abc
-					if (s_video_flag || (rpr == TVAFE_ADC_CH_C))
-					{
-						WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 0, SWT_GY_BCB_RCR_IN_BIT,
-								SWT_GY_BCB_RCR_IN_WID);
-					}
-					else
-					{
-						ret = -EFAULT;
-					}
-					break;
-				case TVAFE_ADC_CH_C:
-					// acb => abc
-					if (s_video_flag || (rpr == TVAFE_ADC_CH_B))
-					{
-						WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 1, SWT_GY_BCB_RCR_IN_BIT,
-								SWT_GY_BCB_RCR_IN_WID);
-					}
-					else
-					{
-						ret = -EFAULT;
-					}
-					break;
-				default:
-					ret = -EFAULT;
-					break;
-			}
-			break;
-		case TVAFE_ADC_CH_B:
-			switch (bpb)
-			{
-				case TVAFE_ADC_CH_PGA:
-				case TVAFE_ADC_CH_A:
-					// bac => abc
-					if (s_video_flag || (rpr == TVAFE_ADC_CH_C))
-					{
-						WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 2, SWT_GY_BCB_RCR_IN_BIT,
-								SWT_GY_BCB_RCR_IN_WID);
-					}
-					else
-					{
-						ret = -EFAULT;
-					}
-					break;
-				case TVAFE_ADC_CH_C:
-					// bca => abc
-					if (s_video_flag || (rpr == TVAFE_ADC_CH_PGA)
-							|| (rpr == TVAFE_ADC_CH_A))
-					{
-						WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 3, SWT_GY_BCB_RCR_IN_BIT,
-								SWT_GY_BCB_RCR_IN_WID);
-					}
-					else
-					{
-						ret = -EFAULT;
-					}
-					break;
-				default:
-					ret = -EFAULT;
-					break;
-			}
-			break;
-		case TVAFE_ADC_CH_C:
-			switch (bpb)
-			{
-				case TVAFE_ADC_CH_PGA:
-				case TVAFE_ADC_CH_A:
-					// cab => abc
-					if (s_video_flag || (rpr == TVAFE_ADC_CH_B))
-					{
-						WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 4, SWT_GY_BCB_RCR_IN_BIT,
-								SWT_GY_BCB_RCR_IN_WID);
-					}
-					else
-					{
-						ret = -EFAULT;
-					}
-					break;
-				case TVAFE_ADC_CH_B:
-					// cba => abc
-					if (s_video_flag || (rpr == TVAFE_ADC_CH_PGA)
-							|| (rpr == TVAFE_ADC_CH_A))
-					{
-						WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 5, SWT_GY_BCB_RCR_IN_BIT,
-								SWT_GY_BCB_RCR_IN_WID);
-					}
-					else
-					{
-						ret = -EFAULT;
-					}
-					break;
-				default:
-					ret = -EFAULT;
-					break;
-			}
-			break;
-		default:
-			ret = -EFAULT;
-			break;
-	}
-	return ret;
-}
-
-/*
- * tvafe pin mux setting for input source
- */
-int tvafe_set_source_muxing(enum tvin_port_e port, struct tvafe_pin_mux_s *pinmux)
-{
-	int ret = 0;
-
-	switch (port)
-	{
-		case TVIN_PORT_CVBS0:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS0_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS0_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS0_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS0_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS1:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS1_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS1_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS1_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS1_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS2:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS2_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS2_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS2_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS2_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS3:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS3_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS3_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS3_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS3_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS4:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS4_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS4_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS4_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS5_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS5:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS5_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS5_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS5_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS5_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS6:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS6_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS6_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS6_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS6_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_CVBS7:
-			if (tvafe_adc_pin_muxing(pinmux->pin[CVBS7_Y]) == TVAFE_ADC_CH_PGA)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, pinmux->pin[CVBS7_Y]-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[CVBS7_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[CVBS7_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO0:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO0_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO0_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO0_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO0_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO1:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO1_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO1_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO1_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO1_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO2:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO2_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO2_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO2_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO2_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO3:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO3_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO3_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20 , tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO3_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO3_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO4:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO4_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO4_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO4_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO4_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO5:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO5_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO5_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO5_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO5_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO6:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO6_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO6_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO6_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO6_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_SVIDEO7:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO7_Y]), tvafe_adc_pin_muxing(pinmux->pin[S_VIDEO7_C]), TVAFE_ADC_CH_NULL, 1) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[S_VIDEO7_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[S_VIDEO7_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA0:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA0_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA0_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA0_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA0_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA0_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-
-				WRITE_APB_REG_BITS(ADC_REG_39, 0, INSYNCMUXCTRL_BIT, INSYNCMUXCTRL_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA1:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA1_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA1_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA1_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA1_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA1_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-				WRITE_APB_REG_BITS(ADC_REG_39, 1, INSYNCMUXCTRL_BIT, INSYNCMUXCTRL_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA2:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA2_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA2_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA2_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA2_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA2_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA3:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA3_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA3_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA3_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA3_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA3_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA4:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA4_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA4_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA4_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA4_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA4_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA5:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA5_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA5_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA5_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA5_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA5_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA6:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA6_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA6_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA6_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA6_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA6_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_VGA7:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[VGA7_G]), tvafe_adc_pin_muxing(pinmux->pin[VGA7_B]), tvafe_adc_pin_muxing(pinmux->pin[VGA7_R]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[VGA7_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[VGA7_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP0:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP0_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP0_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP0_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP0_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP0_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP1:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP1_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP1_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP1_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP1_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP1_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP2:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP2_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP2_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP2_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP2_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP2_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP3:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing( pinmux->pin[COMP3_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP3_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP3_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP3_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP3_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP4:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP4_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP4_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP4_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP4_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP4_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP5:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP5_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP5_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP5_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP5_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP5_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP6:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP6_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP6_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP6_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP6_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP6_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		case TVIN_PORT_COMP7:
-			if (tvafe_adc_top_muxing(tvafe_adc_pin_muxing(pinmux->pin[COMP7_Y]), tvafe_adc_pin_muxing(pinmux->pin[COMP7_PB]), tvafe_adc_pin_muxing(pinmux->pin[COMP7_PR]), 0) == 0)
-			{
-				WRITE_APB_REG_BITS(ADC_REG_20, tvafe_default_cvbs_out-TVAFE_ADC_PIN_A_PGA_0, INMUXBUF_BIT, INMUXBUF_WID);
-				if (pinmux->pin[COMP7_SOG] >= TVAFE_ADC_PIN_SOG_0)
-					WRITE_APB_REG_BITS(ADC_REG_24, (pinmux->pin[COMP7_SOG] - TVAFE_ADC_PIN_SOG_0), INMUXSOG_BIT, INMUXSOG_WID);
-			}
-			else
-			{
-				ret = -EFAULT;
-			}
-			break;
-		default:
-			ret = -EFAULT;
-			break;
-	}
-	if (ret == 0)
-		pr_info("[tvafe..] %s set pin mux to port:0x%x ok.\n", __func__, port);
-	else
-		pr_info("[tvafe..] %s set pin mux error!!!!!.\n", __func__);
-
-	return ret;
-}
-
-/*
- * tvafe load edid table
- */
-void tvafe_vga_set_edid(struct tvafe_vga_edid_s *edid)
-{
-	unsigned int i = 0;
-
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 1, EDID_CLK_EN_BIT,EDID_CLK_EN_WID); // VGA_CLK_EN
-	// APB Bus accessing mode
-	WRITE_APB_REG(TVFE_EDID_CONFIG , 0x00000000);
-	WRITE_APB_REG(TVFE_EDID_RAM_ADDR, 0x00000000);
-	for (i=0; i<256; i++)
-		WRITE_APB_REG(TVFE_EDID_RAM_WDATA, (unsigned int)edid->value[i]);
-	// Slave IIC acessing mode, 8-bit standard IIC protocol
-	WRITE_APB_REG(TVFE_EDID_CONFIG, TVAFE_EDID_CONFIG);
-}
-
-/*
- * tvafe get edid table from Reg
- */
-void tvafe_vga_get_edid(struct tvafe_vga_edid_s *edid)
-{
-	unsigned int i = 0;
-
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL , 1, EDID_CLK_EN_BIT,EDID_CLK_EN_WID); // VGA_CLK_EN
-	// APB Bus accessing mode
-	WRITE_APB_REG(TVFE_EDID_CONFIG, 0x00000000);
-	WRITE_APB_REG(TVFE_EDID_RAM_ADDR, 0x00000100);
-	for (i=0; i<256; i++)
-		edid->value[i] = (unsigned char)(READ_APB_REG_BITS(TVFE_EDID_RAM_RDATA,
-					EDID_RAM_RDATA_BIT, EDID_RAM_RDATA_WID));
-	// Slave IIC acessing mode, 8-bit standard IIC protocol
-	WRITE_APB_REG(TVFE_EDID_CONFIG, TVAFE_EDID_CONFIG);
-
-	return;
-}
-
-#if 0
-///////////////////TVFE top control////////////////////
-const static unsigned int aafilter_ctl[][2] = {
-
-	//TVIN_SIG_FMT_NULL = 0,
-	{0,0},
-	//VDIN_SIG_FORMAT_VGA_512X384P_60D147,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_560X384P_60D147,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X200P_59D924,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X350P_85D080,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X400P_59D940,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X400P_85D080,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X400P_59D638,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X400P_56D416,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480I_29D970,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_66D619,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_66D667,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_59D940,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_72D809,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_75D000_A,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_85D008,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_59D638,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X480P_75D000_B,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_640X870P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_720X350P_70D086,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_720X400P_85D039,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_720X400P_70D086,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_720X400P_87D849,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_720X400P_59D940,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_720X480P_59D940,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_752X484I_29D970,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_768X574I_25D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_800X600P_56D250,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_800X600P_60D317,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_800X600P_72D188,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_800X600P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_800X600P_85D061,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_832X624P_75D087,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_848X480P_84D751,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_59D278,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_74D927,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768I_43D479,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_60D004,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_70D069,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_75D029,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_84D997,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_74D925,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_75D020,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_70D008,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_75D782,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_77D069,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X768P_71D799,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1024X1024P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1053X754I_43D453,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1056X768I_43D470,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1120X750I_40D021,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X864P_70D012,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X864P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X864P_84D999,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X870P_75D062,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X900P_65D950,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X900P_66D004,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X900P_76D047,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1152X900P_76D149,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1244X842I_30D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X768P_59D995,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X768P_74D893,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X768P_84D837,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X960P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X960P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X960P_85D002,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024I_43D436,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_60D020,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_75D025,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_85D024,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_59D979,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_72D005,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_60D002,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_67D003,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_74D112,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_76D179,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_66D718,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_66D677,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_76D107,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1280X1024P_59D996,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1360X768P_59D799,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1360X1024I_51D476,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1440X1080P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200I_48D040,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200P_65D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200P_70D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200P_80D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1200P_85D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1600X1280P_66D931,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1680X1080P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1792X1344P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1792X1344P_74D997,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1856X1392P_59D995,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1856X1392P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1868X1200P_75D000,
-	//VDIN_SIG_FORMAT_VGA_1920X1080P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1080P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1080P_85D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1200P_84D932,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1200P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1200P_85D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1234P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1234P_85D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1440P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_1920X1440P_75D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_VGA_2048X1536P_60D000_A,
-	{
-		0x00082222, //
-		0x252b39c6, //
-	},
-	//VDIN_SIG_FORMAT_VGA_2048X1536P_75D000,
-	{0,0},
-	//VDIN_SIG_FORMAT_VGA_2048X1536P_60D000_B,
-	{0,0},
-	//VDIN_SIG_FORMAT_VGA_2048X2048P_60D008,
-	{0,0},
-	//TVIN_SIG_FMT_VGA_MAX,
-	{0,0},
-
-	///////////////////////////////////////////////////////////////
-	//VDIN_SIG_FORMAT_COMPONENT_480P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_480I_59D940,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_576P_50D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_576I_50D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_720P_59D940,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_720P_50D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080P_23D976,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080P_24D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080P_25D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080P_30D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080P_50D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080P_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_29D970,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_47D952,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_48D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_50D000_A,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_50D000_B,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_50D000_C,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_COMPONENT_1080I_60D000,
-	{
-		0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//TVIN_SIG_FMT_COMP_MAX,
-	{0,0},
-
-	//VDIN_SIG_FORMAT_CVBS_NTSC_M,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_CVBS_NTSC_443,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_CVBS_PAL_I,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_CVBS_PAL_M,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_CVBS_PAL_60,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_CVBS_PAL_CN,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-	//VDIN_SIG_FORMAT_CVBS_SECAM,
-	{       0x00082222, // TVFE_AAFILTER_CTRL1
-		0x252b39c6, // TVFE_AAFILTER_CTRL2
-	},
-
-	//VDIN_SIG_FORMAT_MAX,
-	{0,0 }
-};
-
-// *****************************************************************************
-// Function:set aafilter control
-//
-//   Params: format index
-//
-//   Return: none
-//
-// *****************************************************************************
-void tvafe_top_set_aafilter_control(num tvin_sig_fmt_e fmt)
-{
-
-	WRITE_APB_REG(TVFE_AAFILTER_CTRL1, aafilter_ctl[fmt][0]);
-	WRITE_APB_REG(TVFE_AAFILTER_CTRL2, aafilter_ctl[fmt][1]);
-
-
-	return;
-}
-
-// *****************************************************************************
-// Function:set bp gate of tvfe top module
-//
-//   Params: format index
-//
-//   Return: none
-//
-// *****************************************************************************
-void tvafe_top_set_bp_gate(enum tvin_sig_fmt_e fmt)
-{
-	unsigned int h_bp_end,h_bp_start;
-	unsigned int v_bp_end,v_bp_start;
-	const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-
-	h_bp_start = fmt_info->hs_width + 1;
-	WRITE_APB_REG_BITS(TVFE_BPG_BACKP_H, h_bp_start, BACKP_H_ST_BIT, BACKP_H_ST_WID);
-
-	h_bp_end = fmt_info->h_total - fmt_info->hs_front + 1;
-	WRITE_APB_REG_BITS(TVFE_BPG_BACKP_H, h_bp_end, BACKP_H_ED_BIT, BACKP_H_ED_WID);
-
-	v_bp_start = fmt_info->vs_width + 1;
-	WRITE_APB_REG_BITS(TVFE_BPG_BACKP_V, v_bp_start, BACKP_V_ST_BIT, BACKP_V_ST_WID);
-
-	v_bp_end = fmt_info->v_total - fmt_info->vs_front + 1;
-	WRITE_APB_REG_BITS(TVFE_BPG_BACKP_V, v_bp_end, BACKP_V_ED_BIT, BACKP_V_ED_WID);
-
-	return;
-}
-
-// *****************************************************************************
-// Function:set mvdet control of tvfe module
-//
-//   Params: format index
-//
-//   Return: none
-//
-// *****************************************************************************
-void tvafe_top_set_mvdet_control(enum tvin_sig_fmt_e fmt)
-{
-	unsigned int sd_mvd_reg_15_1b[] = {0, 0, 0, 0, 0, 0, 0,};
-
-	if ((fmt > TVIN_SIG_FMT_COMP_480P_60D000)
-			&& (fmt < TVIN_SIG_FMT_COMP_576I_50D000)) {
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL1, sd_mvd_reg_15_1b[0]);
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL2, sd_mvd_reg_15_1b[1]);
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL3, sd_mvd_reg_15_1b[2]);
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL4, sd_mvd_reg_15_1b[3]);
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL5, sd_mvd_reg_15_1b[4]);
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL6, sd_mvd_reg_15_1b[5]);
-		WRITE_APB_REG(TVFE_DVSS_MVDET_CTRL7, sd_mvd_reg_15_1b[6]);
-
-	}
-
-	return;
-}
-#endif
-
-/*
- * tvafe wss setting
- */
-void tvafe_top_set_wss_control(enum tvin_sig_fmt_e fmt)
-{
-	unsigned int hd_mvd_reg_2a_2d[] = {0, 0, 0, 0};
-
-	if (fmt > TVIN_SIG_FMT_COMP_720P_59HZ_D940
-			&& fmt < TVIN_SIG_FMT_COMP_1080I_60HZ_D000) {
-		WRITE_APB_REG(TVFE_MISC_WSS1_MUXCTRL1, hd_mvd_reg_2a_2d[0]);
-		WRITE_APB_REG(TVFE_MISC_WSS1_MUXCTRL2, hd_mvd_reg_2a_2d[1]);
-		WRITE_APB_REG(TVFE_MISC_WSS2_MUXCTRL1, hd_mvd_reg_2a_2d[2]);
-		WRITE_APB_REG(TVFE_MISC_WSS2_MUXCTRL2, hd_mvd_reg_2a_2d[3]);
-	}
-
-	return;
-}
-
-/*
- * tvafe top field generation setting
- */
-void tvafe_top_set_sfg_mux_control(enum tvin_sig_fmt_e fmt)
-{
-	unsigned short h_total = 0,pixel_clk = 0,tmp = 0;
-
-	if (fmt < TVIN_SIG_FMT_VGA_MAX)
-	{
-		h_total = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].h_total;
-		pixel_clk = tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147].pixel_clk;
-	}
-	else
-	{
-		h_total = tvin_comp_fmt_tbl[fmt-TVIN_SIG_FMT_COMP_480P_60HZ_D000].h_total;
-		pixel_clk = tvin_comp_fmt_tbl[fmt-TVIN_SIG_FMT_COMP_480P_60HZ_D000].pixel_clk;
-	}
-
-	if (pixel_clk)
-	{
-		//tmp = (h_total*219)/pixel_clk; // ((h_total*5M/(pixel_clk*10K))/2)*7/8 = h_total*219/pixel_clk
-		//if (tmp > 255)
-		//    tmp = 255;
-		//WRITE_APB_REG(ADC_REG_31, tmp);
-		tmp = (h_total+2)>>2;
-		WRITE_APB_REG_BITS(TVFE_SYNCTOP_SFG_MUXCTRL1, tmp, SFG_DET_HSTART_BIT, SFG_DET_HSTART_WID);
-		tmp = (h_total+h_total+h_total+2)>>2;
-		WRITE_APB_REG_BITS(TVFE_SYNCTOP_SFG_MUXCTRL1, tmp, SFG_DET_HEND_BIT, SFG_DET_HEND_WID);
-	}
-
-	return;
-}
-
-/*
- * tvafe top field generation setting
- * the parameter stdvalue  replace the parameter original
- */
-void tvafe_reset_cal_value(struct tvafe_adc_cal_s *original,struct tvafe_adc_cal_s *stdvalue)
-{
-#ifdef LOG_ADC_CAL
-	printk("++++++reset cal value\n");
-#endif
-	//a
-	original->a_analog_clamp    = stdvalue->a_analog_clamp;
-	original->a_analog_gain     = stdvalue->a_analog_gain;
-	original->a_digital_offset1 = stdvalue->a_digital_offset1;
-	//b
-	original->b_analog_clamp    = stdvalue->b_analog_clamp;
-	original->b_analog_gain     = stdvalue->b_analog_gain;
-	original->b_digital_offset1 = stdvalue->b_digital_offset1;
-	//c
-	original->c_analog_clamp    = stdvalue->c_analog_clamp;
-	original->c_analog_gain     = stdvalue->c_analog_gain;
-	original->c_digital_offset1 = stdvalue->c_digital_offset1;
-}
-
-/*
- * compare calibration value (calvalue) with standard value (stdvalue)
- */
-unsigned char tvafe_compare_cal_value(unsigned short calvalue,unsigned short stdvalue)
-{
-	unsigned char ret=0;
-	if(calvalue > stdvalue)
-	{
-		if((calvalue - stdvalue) > threshold_value)
-		{
-			ret =1;
-			return ret;
-		}
-	}
-	else if((stdvalue - calvalue) > threshold_value)
-	{
-		ret=1;
-		return ret;
-	}
-	return ret;
-
-}
-
-/*
- * if adc_cal value is not valid,then adc_cal value will been replaced
- */
-void tvafe_adjust_cal_value(struct tvafe_adc_cal_s *para,bool iscomponent)
-{
-	unsigned char flag = 0;
-	struct tvafe_adc_cal_s *stdvaluep = iscomponent ? (&cal_std_value_component) : (&cal_std_value_vga);
-
-	flag |= tvafe_compare_cal_value(para->a_analog_clamp,   stdvaluep->a_analog_clamp   );
-	flag |= tvafe_compare_cal_value(para->a_analog_gain,    stdvaluep->a_analog_gain    );
-
-	flag |= tvafe_compare_cal_value(para->b_analog_clamp,   stdvaluep->b_analog_clamp   );
-	flag |= tvafe_compare_cal_value(para->b_analog_gain,    stdvaluep->b_analog_gain    );
-
-	flag |= tvafe_compare_cal_value(para->c_analog_clamp,   stdvaluep->c_analog_clamp   );
-	flag |= tvafe_compare_cal_value(para->c_analog_gain,    stdvaluep->c_analog_gain    );
-
-	if(flag)
-		tvafe_reset_cal_value(para,stdvaluep);
-
-}
-
-/*
- * tvafe set the calibartion value
- */
-void tvafe_set_cal_value(struct tvafe_cal_s *cal)
-{
-	struct tvafe_adc_cal_s *para = &cal->cal_val;
-	unsigned int clamp_h = 0, clamp_l = 0;
-
-	if (!(para->reserved & TVAFE_ADC_CAL_VALID))
-		return;
-
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET1, 1, OGO_EN_BIT, OGO_EN_WID);
-
-	clamp_h = (para->a_analog_clamp)>>2;
-	clamp_l = (para->a_analog_clamp)&3;
-	WRITE_APB_REG_BITS(ADC_REG_0B, clamp_h, CTRCLREFA_0B_BIT, CTRCLREFA_0B_WID);
-	WRITE_APB_REG_BITS(ADC_REG_0F, clamp_l, CTRCLREFA_0F_BIT, CTRCLREFA_0F_WID);
-	clamp_h = (para->b_analog_clamp)>>2;
-	clamp_l = (para->b_analog_clamp)&3;
-	WRITE_APB_REG_BITS(ADC_REG_0C, clamp_h, CTRCLREFB_0C_BIT, CTRCLREFB_0C_WID);
-	WRITE_APB_REG_BITS(ADC_REG_10, clamp_l, CTRCLREFB_10_BIT, CTRCLREFB_10_WID);
-	clamp_h = (para->c_analog_clamp)>>2;
-	clamp_l = (para->c_analog_clamp)&3;
-	WRITE_APB_REG_BITS(ADC_REG_0D, clamp_h, CTRCLREFC_0D_BIT, CTRCLREFC_0D_WID);
-	WRITE_APB_REG_BITS(ADC_REG_11, clamp_l, CTRCLREFC_11_BIT, CTRCLREFC_11_WID);
-
-	WRITE_APB_REG_BITS(ADC_REG_07, para->a_analog_gain, ADCGAINA_BIT, ADCGAINA_WID);
-	WRITE_APB_REG_BITS(ADC_REG_08, para->b_analog_gain, ADCGAINB_BIT, ADCGAINB_WID);
-	WRITE_APB_REG_BITS(ADC_REG_09, para->c_analog_gain, ADCGAINC_BIT, ADCGAINC_WID);
-
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET1, para->a_digital_offset1,
-			OGO_YG_OFFSET1_BIT, OGO_YG_OFFSET1_WID);
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET1, para->b_digital_offset1,
-			OGO_UB_OFFSET1_BIT, OGO_UB_OFFSET1_WID);
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET3, para->c_digital_offset1,
-			OGO_VR_OFFSET1_BIT, OGO_VR_OFFSET1_WID);
-
-	WRITE_APB_REG_BITS(TVFE_OGO_GAIN1, para->a_digital_gain,
-			OGO_YG_GAIN_BIT, OGO_YG_GAIN_WID);
-	WRITE_APB_REG_BITS(TVFE_OGO_GAIN1, para->b_digital_gain,
-			OGO_UB_GAIN_BIT, OGO_UB_GAIN_WID);
-	WRITE_APB_REG_BITS(TVFE_OGO_GAIN2, para->c_digital_gain,
-			OGO_VR_GAIN_BIT, OGO_VR_GAIN_WID);
-
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET2, para->a_digital_offset2,
-			OGO_YG_OFFSET2_BIT, OGO_YG_OFFSET2_WID);
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET2, para->b_digital_offset2,
-			OGO_UB_OFFSET2_BIT, OGO_UB_OFFSET2_WID);
-	WRITE_APB_REG_BITS(TVFE_OGO_OFFSET3, para->c_digital_offset2,
-			OGO_VR_OFFSET2_BIT, OGO_VR_OFFSET2_WID);
-
-}
-
-void tvafe_set_cal_value2(struct tvafe_adc_cal_s *cal)
-{
-    struct tvafe_adc_cal_s *para = cal;
-    unsigned int clamp_h = 0, clamp_l = 0;
-
-    if (!(para->reserved & TVAFE_ADC_CAL_VALID))
-        return;
-
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET1, 1, OGO_EN_BIT, OGO_EN_WID);
-
-    clamp_h = (para->a_analog_clamp)>>2;
-    clamp_l = (para->a_analog_clamp)&3;
-    WRITE_APB_REG_BITS(ADC_REG_0B, clamp_h, CTRCLREFA_0B_BIT, CTRCLREFA_0B_WID);
-    WRITE_APB_REG_BITS(ADC_REG_0F, clamp_l, CTRCLREFA_0F_BIT, CTRCLREFA_0F_WID);
-    clamp_h = (para->b_analog_clamp)>>2;
-    clamp_l = (para->b_analog_clamp)&3;
-    WRITE_APB_REG_BITS(ADC_REG_0C, clamp_h, CTRCLREFB_0C_BIT, CTRCLREFB_0C_WID);
-    WRITE_APB_REG_BITS(ADC_REG_10, clamp_l, CTRCLREFB_10_BIT, CTRCLREFB_10_WID);
-    clamp_h = (para->c_analog_clamp)>>2;
-    clamp_l = (para->c_analog_clamp)&3;
-    WRITE_APB_REG_BITS(ADC_REG_0D, clamp_h, CTRCLREFC_0D_BIT, CTRCLREFC_0D_WID);
-    WRITE_APB_REG_BITS(ADC_REG_11, clamp_l, CTRCLREFC_11_BIT, CTRCLREFC_11_WID);
-
-    WRITE_APB_REG_BITS(ADC_REG_07, para->a_analog_gain, ADCGAINA_BIT, ADCGAINA_WID);
-    WRITE_APB_REG_BITS(ADC_REG_08, para->b_analog_gain, ADCGAINB_BIT, ADCGAINB_WID);
-    WRITE_APB_REG_BITS(ADC_REG_09, para->c_analog_gain, ADCGAINC_BIT, ADCGAINC_WID);
-
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET1, para->a_digital_offset1,
-        OGO_YG_OFFSET1_BIT, OGO_YG_OFFSET1_WID);
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET1, para->b_digital_offset1,
-        OGO_UB_OFFSET1_BIT, OGO_UB_OFFSET1_WID);
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET3, para->c_digital_offset1,
-        OGO_VR_OFFSET1_BIT, OGO_VR_OFFSET1_WID);
-
-    WRITE_APB_REG_BITS(TVFE_OGO_GAIN1, para->a_digital_gain,
-        OGO_YG_GAIN_BIT, OGO_YG_GAIN_WID);
-    WRITE_APB_REG_BITS(TVFE_OGO_GAIN1, para->b_digital_gain,
-        OGO_UB_GAIN_BIT, OGO_UB_GAIN_WID);
-    WRITE_APB_REG_BITS(TVFE_OGO_GAIN2, para->c_digital_gain,
-        OGO_VR_GAIN_BIT, OGO_VR_GAIN_WID);
-
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET2, para->a_digital_offset2,
-        OGO_YG_OFFSET2_BIT, OGO_YG_OFFSET2_WID);
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET2, para->b_digital_offset2,
-        OGO_UB_OFFSET2_BIT, OGO_UB_OFFSET2_WID);
-    WRITE_APB_REG_BITS(TVFE_OGO_OFFSET3, para->c_digital_offset2,
-        OGO_VR_OFFSET2_BIT, OGO_VR_OFFSET2_WID);
-
-}
-
-
-/*
- * tvafe get the calibration value from Reg
- */
-int tvafe_get_cal_value(struct tvafe_cal_s *cal)
-{
-	struct tvafe_adc_cal_s *para = &cal->cal_val;
-	unsigned int clamp_h = 0, clamp_l = 0;
-
-	clamp_h = READ_APB_REG_BITS(ADC_REG_0B, CTRCLREFA_0B_BIT, CTRCLREFA_0B_WID);
-	clamp_l = READ_APB_REG_BITS(ADC_REG_0F, CTRCLREFA_0F_BIT, CTRCLREFA_0F_WID);
-	para->a_analog_clamp = (clamp_h<<2)|clamp_l;
-	clamp_h = READ_APB_REG_BITS(ADC_REG_0C, CTRCLREFB_0C_BIT, CTRCLREFB_0C_WID);
-	clamp_l = READ_APB_REG_BITS(ADC_REG_10, CTRCLREFB_10_BIT, CTRCLREFB_10_WID);
-	para->b_analog_clamp = (clamp_h<<2)|clamp_l;
-	clamp_h = READ_APB_REG_BITS(ADC_REG_0D, CTRCLREFC_0D_BIT, CTRCLREFC_0D_WID);
-	clamp_l = READ_APB_REG_BITS(ADC_REG_11, CTRCLREFC_11_BIT, CTRCLREFC_11_WID);
-	para->c_analog_clamp = (clamp_h<<2)|clamp_l;
-
-	para->a_analog_gain = READ_APB_REG_BITS(ADC_REG_07, ADCGAINA_BIT, ADCGAINA_WID);
-	para->b_analog_gain = READ_APB_REG_BITS(ADC_REG_08, ADCGAINB_BIT, ADCGAINB_WID);
-	para->c_analog_gain = READ_APB_REG_BITS(ADC_REG_09, ADCGAINC_BIT, ADCGAINC_WID);
-
-	para->a_digital_offset1 = READ_APB_REG_BITS(TVFE_OGO_OFFSET1,
-			OGO_YG_OFFSET1_BIT, OGO_YG_OFFSET1_WID);
-	para->b_digital_offset1 = READ_APB_REG_BITS(TVFE_OGO_OFFSET1,
-			OGO_UB_OFFSET1_BIT, OGO_UB_OFFSET1_WID);
-	para->c_digital_offset1 = READ_APB_REG_BITS(TVFE_OGO_OFFSET3,
-			OGO_VR_OFFSET1_BIT, OGO_VR_OFFSET1_WID);
-
-	para->a_digital_gain = READ_APB_REG_BITS(TVFE_OGO_GAIN1,
-			OGO_YG_GAIN_BIT, OGO_YG_GAIN_WID);
-	para->b_digital_gain = READ_APB_REG_BITS(TVFE_OGO_GAIN1,
-			OGO_UB_GAIN_BIT, OGO_UB_GAIN_WID);
-	para->c_digital_gain = READ_APB_REG_BITS(TVFE_OGO_GAIN2,
-			OGO_VR_GAIN_BIT, OGO_VR_GAIN_WID);
-
-	para->a_digital_offset2 = READ_APB_REG_BITS(TVFE_OGO_OFFSET2,
-			OGO_YG_OFFSET2_BIT, OGO_YG_OFFSET2_WID);
-	para->b_digital_offset2 = READ_APB_REG_BITS(TVFE_OGO_OFFSET2,
-			OGO_UB_OFFSET2_BIT, OGO_UB_OFFSET2_WID);
-	para->c_digital_offset2 = READ_APB_REG_BITS(TVFE_OGO_OFFSET3,
-			OGO_VR_OFFSET2_BIT, OGO_VR_OFFSET2_WID);
-	/*protect for adc calibriation failed*/
-	if( 10 > para->a_analog_clamp ||120 < para->a_analog_clamp ||
-			10 > para->b_analog_clamp ||120 < para->b_analog_clamp ||
-			10 > para->c_analog_clamp ||120 < para->c_analog_clamp
-	  )
-	{
-		pr_info("[%s]:adc calibriation error.a_analog_clamp:%u.a_analog_clamp:%u. a_analog_clamp:%u.\n",
-				__func__,para->a_analog_clamp,para->b_analog_clamp,para->c_analog_clamp);
-		return -EFAULT;
-	}
-	else
-		return 0;
-}
-
-int tvafe_get_cal_value2(struct tvafe_adc_cal_s *cal)
-{
-    struct tvafe_adc_cal_s *para = cal;
-    unsigned int clamp_h = 0, clamp_l = 0;
-
-    clamp_h = READ_APB_REG_BITS(ADC_REG_0B, CTRCLREFA_0B_BIT, CTRCLREFA_0B_WID);
-    clamp_l = READ_APB_REG_BITS(ADC_REG_0F, CTRCLREFA_0F_BIT, CTRCLREFA_0F_WID);
-    para->a_analog_clamp = (clamp_h<<2)|clamp_l;
-    clamp_h = READ_APB_REG_BITS(ADC_REG_0C, CTRCLREFB_0C_BIT, CTRCLREFB_0C_WID);
-    clamp_l = READ_APB_REG_BITS(ADC_REG_10, CTRCLREFB_10_BIT, CTRCLREFB_10_WID);
-    para->b_analog_clamp = (clamp_h<<2)|clamp_l;
-    clamp_h = READ_APB_REG_BITS(ADC_REG_0D, CTRCLREFC_0D_BIT, CTRCLREFC_0D_WID);
-    clamp_l = READ_APB_REG_BITS(ADC_REG_11, CTRCLREFC_11_BIT, CTRCLREFC_11_WID);
-    para->c_analog_clamp = (clamp_h<<2)|clamp_l;
-
-    para->a_analog_gain = READ_APB_REG_BITS(ADC_REG_07, ADCGAINA_BIT, ADCGAINA_WID);
-    para->b_analog_gain = READ_APB_REG_BITS(ADC_REG_08, ADCGAINB_BIT, ADCGAINB_WID);
-    para->c_analog_gain = READ_APB_REG_BITS(ADC_REG_09, ADCGAINC_BIT, ADCGAINC_WID);
-
-    para->a_digital_offset1 = READ_APB_REG_BITS(TVFE_OGO_OFFSET1,
-        OGO_YG_OFFSET1_BIT, OGO_YG_OFFSET1_WID);
-    para->b_digital_offset1 = READ_APB_REG_BITS(TVFE_OGO_OFFSET1,
-        OGO_UB_OFFSET1_BIT, OGO_UB_OFFSET1_WID);
-    para->c_digital_offset1 = READ_APB_REG_BITS(TVFE_OGO_OFFSET3,
-        OGO_VR_OFFSET1_BIT, OGO_VR_OFFSET1_WID);
-
-    para->a_digital_gain = READ_APB_REG_BITS(TVFE_OGO_GAIN1,
-        OGO_YG_GAIN_BIT, OGO_YG_GAIN_WID);
-    para->b_digital_gain = READ_APB_REG_BITS(TVFE_OGO_GAIN1,
-        OGO_UB_GAIN_BIT, OGO_UB_GAIN_WID);
-    para->c_digital_gain = READ_APB_REG_BITS(TVFE_OGO_GAIN2,
-        OGO_VR_GAIN_BIT, OGO_VR_GAIN_WID);
-
-    para->a_digital_offset2 = READ_APB_REG_BITS(TVFE_OGO_OFFSET2,
-        OGO_YG_OFFSET2_BIT, OGO_YG_OFFSET2_WID);
-    para->b_digital_offset2 = READ_APB_REG_BITS(TVFE_OGO_OFFSET2,
-        OGO_UB_OFFSET2_BIT, OGO_UB_OFFSET2_WID);
-    para->c_digital_offset2 = READ_APB_REG_BITS(TVFE_OGO_OFFSET3,
-        OGO_VR_OFFSET2_BIT, OGO_VR_OFFSET2_WID);
-    /*protect for adc calibriation failed*/
-    if( 10 > para->a_analog_clamp ||120 < para->a_analog_clamp ||
-        10 > para->b_analog_clamp ||120 < para->b_analog_clamp ||
-        10 > para->c_analog_clamp ||120 < para->c_analog_clamp
-      )
-    {
-        pr_info("[%s]:adc calibriation error.a_analog_clamp:%u.a_analog_clamp:%u. a_analog_clamp:%u.\n",
-                    __func__,para->a_analog_clamp,para->b_analog_clamp,para->c_analog_clamp);
-        return -EFAULT;
-    }
-    else
-        return 0;
-}
-
-
-/*
- * tvafe read the calibration value from adc readback module
- */
-void tvafe_adc_cal_read(unsigned char *ch, unsigned int *a, unsigned int *b, unsigned int *c)
-{
-	unsigned int i = 0, j = 0, data = 0, da[16], db[16], dc[16];
-
-	for (i = 0; i < 16; i++)
-	{
-		data = READ_APB_REG(TVFE_ADC_READBACK_INDICATOR);
-		da[i] = (data >> ADC_READBACK_DA_BIT) & ((1 << ADC_READBACK_DA_WID) - 1);
-		db[i] = (data >> ADC_READBACK_DB_BIT) & ((1 << ADC_READBACK_DB_WID) - 1);
-		dc[i] = (data >> ADC_READBACK_DC_BIT) & ((1 << ADC_READBACK_DC_WID) - 1);
-	}
-	for (i = 0; i < 15; i++)
-	{
-		for (j = i + 1; j < 16; j++)
-		{
-			if (da[i] > da[j])
-			{
-				data  = da[i];
-				da[i] = da[j];
-				da[j] = data;
-			}
-			if (db[i] > db[j])
-			{
-				data  = db[i];
-				db[i] = db[j];
-				db[j] = data;
-			}
-			if (dc[i] > dc[j])
-			{
-				data  = dc[i];
-				dc[i] = dc[j];
-				dc[j] = data;
-			}
-		}
-	}
-	*a = *b = *c = 4;
-	for (i = 4; i < 12; i++)
-	{
-		*a += da[i];
-		*b += db[i];
-		*c += dc[i];
-	}
-	*a >>= 3;
-	*b >>= 3;
-	*c >>= 3;
-#ifdef LOG_ADC_CAL
-	pr_info("%s = %4d %4d %4d\n", ch, (int)*a, (int)*b, (int)*c);
-#endif
-}
-
-/*
- * if adc_cal value is not valid,then adc_cal value will been replaced
- *  for Y:
- *  diff*0.777V/(479/1023)V <= 1023, diff <=616
- *  standard is 0.7V, to support -4% ~ +107% supper black/white, increase the range to 111% of 0.7V
- *  for Cb/Cr/R/G/B:
- *  diff*0.7V/(479/1023)V <= 1023, diff <= 684
- *  standard is 0.7V
- */
-bool tvafe_cal_gain_overflow(unsigned int a1, unsigned int a2, bool is_component)
-{
-	unsigned int win = is_component ? 578 : 630;//616 : 684;add a patch for adc gain overflow
-
-	if ((a2 - a1) > win)
-		return (true);
-	else
-		return (false);
-}
-
-/*
- * standard is 16~235, supper black/white is 7~250
- */
-bool tvafe_adc_cal(struct tvin_parm_s *parm, struct tvafe_cal_s *cal)
-{
-	enum tvin_port_e port = parm->port;
-	struct tvafe_cal_operand_s *operand = &cal->cal_operand;
-	struct tvafe_adc_cal_s *adc_cal = &cal->cal_val;
-	bool is_component = (port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7);
-	unsigned int a = 0, b = 0, c = 0, mutex = 0;
-	unsigned int z_lu = is_component ?  37 :    0; //  37 = 1023*4%/111%
-	unsigned int z_ch = is_component ? 512 :    0;
-	unsigned int l_dg = is_component ? 975 : 1024; // 976 = 219*111%*4+3
-	unsigned int l_do = is_component ?  28 :    0; //  28 = 7*4
-	unsigned int c_dg = is_component ? 899 : 1024; // 899 = 224*4+3
-	unsigned int c_do = is_component ?  64 :    0; //  64 = 16*4
-	unsigned short step_up = 0, step_dn = 0;
-
-	if(is_component){
-		adc_cal = &(cal->fmt_cal_val.comp_cal_val[0]);
-		operand->cal_fmt_max = 3;
-	}else{
-		adc_cal = &(cal->cal_val);
-		operand->cal_fmt_max = 1;
-	}
-	switch (operand->step++)
-	{
-		case TVAFE_ADC_CAL_STEP_GAIN*0:
-			// init
-            adc_cal[operand->cal_fmt_cnt].a_analog_clamp    =   64;
-            adc_cal[operand->cal_fmt_cnt].a_analog_gain     =  128;
-            adc_cal[operand->cal_fmt_cnt].a_digital_gain    = l_dg; // 0dB
-            adc_cal[operand->cal_fmt_cnt].a_digital_offset1 =    0;
-            adc_cal[operand->cal_fmt_cnt].a_digital_offset2 = l_do;
-            adc_cal[operand->cal_fmt_cnt].b_analog_clamp    =   64;
-            adc_cal[operand->cal_fmt_cnt].b_analog_gain     =  128;
-            adc_cal[operand->cal_fmt_cnt].b_digital_gain    = c_dg; // 0dB
-            adc_cal[operand->cal_fmt_cnt].b_digital_offset1 =    0;
-            adc_cal[operand->cal_fmt_cnt].b_digital_offset2 = c_do;
-            adc_cal[operand->cal_fmt_cnt].c_analog_clamp    =   64;
-            adc_cal[operand->cal_fmt_cnt].c_analog_gain     =  128;
-            adc_cal[operand->cal_fmt_cnt].c_digital_gain    = c_dg; // 0dB
-            adc_cal[operand->cal_fmt_cnt].c_digital_offset1 =    0;
-            adc_cal[operand->cal_fmt_cnt].c_digital_offset2 = c_do;
-			// config readback
-			WRITE_APB_REG_BITS(TVFE_ADC_READBACK_CTRL, 0,
-					ADC_READBACK_MODE_BIT , ADC_READBACK_MODE_WID );
-			// record bpg_h, bpg_v, bpg_m, clamp_inv, clamp_ext, clk_ext, clk_ctl, lpf_a, lpf_b, lpf_c
-			operand->bpg_h     = READ_APB_REG(TVFE_BPG_BACKP_H);
-			operand->bpg_v     = READ_APB_REG(TVFE_BPG_BACKP_V);
-			operand->bpg_m     = READ_APB_REG_BITS(TVFE_TOP_CTRL,
-					TVFE_BACKP_GATE_MUX_BIT, TVFE_BACKP_GATE_MUX_WID);
-			operand->clamp_inv = READ_APB_REG_BITS(TVFE_DVSS_MUXCTRL,
-					DVSS_CLAMP_INV_BIT,      DVSS_CLAMP_INV_WID     );
-			operand->clamp_ext = READ_APB_REG_BITS(ADC_REG_2F,
-					CLAMPEXT_BIT,            CLAMPEXT_WID           );
-			//  operand->lpf_a     = READ_APB_REG_BITS(ADC_REG_19, ENLPFA_BIT,    ENLPFA_WID   );
-			//  operand->lpf_b     = READ_APB_REG_BITS(ADC_REG_1A, ENLPFB_BIT,    ENLPFB_WID   );
-			//  operand->lpf_c     = READ_APB_REG_BITS(ADC_REG_1B, ENLPFC_BIT,    ENLPFC_WID   );
-			operand->clk_ext   = READ_APB_REG_BITS(ADC_REG_58,
-					EXTCLKSEL_BIT, EXTCLKSEL_WID);
-			operand->clk_ctl   = READ_CBUS_REG(HHI_VAFE_CLKIN_CNTL);
-			operand->vafe_ctl  = READ_APB_REG(TVFE_VAFE_CTRL);
-			operand->sync_mux  = READ_APB_REG_BITS(ADC_REG_39,INSYNCMUXCTRL_BIT,INSYNCMUXCTRL_WID);
-			// disable lpf_a, lpf_b, lpf_c
-			//  WRITE_APB_REG_BITS(ADC_REG_19, 0, ENLPFA_BIT, ENLPFA_WID);
-			//  WRITE_APB_REG_BITS(ADC_REG_1A, 0, ENLPFB_BIT, ENLPFB_WID);
-			//  WRITE_APB_REG_BITS(ADC_REG_1B, 0, ENLPFC_BIT, ENLPFC_WID);
-			// set clk_ext & clk_ctl
-			WRITE_APB_REG_BITS(ADC_REG_58, 1, EXTCLKSEL_BIT, EXTCLKSEL_WID);
-			if (!is_component){
-				WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL , 0x00000100); //vga
-			}else{
-				if(operand->cal_fmt_cnt == 0){
-	            	WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL , 0x00000b00); //1080p
-	            }else if(operand->cal_fmt_cnt == 1){
-					WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL , 0x00000b01); //720p,1080i
-				}else{
-					WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL , 0x00000100); //480,576
-				}
-			}	
-			// set vfe mux
-			WRITE_APB_REG_BITS(ADC_REG_39, 1, INSYNCMUXCTRL_BIT, INSYNCMUXCTRL_WID);
-			WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 1,
-					VAFE_HS_VS_MUX_BIT, VAFE_HS_VS_MUX_WID);			
-			// load adc cal values
-            adc_cal[operand->cal_fmt_cnt].reserved |= TVAFE_ADC_CAL_VALID;
-            tvafe_set_cal_value2(&adc_cal[operand->cal_fmt_cnt]);
-            adc_cal[operand->cal_fmt_cnt].reserved &= ~TVAFE_ADC_CAL_VALID;
-			// disable offset calibration
-			WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 0,
-					VAFE_ENOFFSETCAL_BIT, VAFE_ENOFFSETCAL_WID);
-			// enable gain calibration
-			WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 1,
-					VAFE_ENGAINCAL_BIT, VAFE_ENGAINCAL_WID);
-			// select level 1
-			WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 1,
-					VAFE_SELGAINCALLVL_BIT, VAFE_SELGAINCALLVL_WID);
-			break;
-		case TVAFE_ADC_CAL_STEP_GAIN*1:
-		case TVAFE_ADC_CAL_STEP_GAIN*3:
-		case TVAFE_ADC_CAL_STEP_GAIN*5:
-		case TVAFE_ADC_CAL_STEP_GAIN*7:
-		case TVAFE_ADC_CAL_STEP_GAIN*9:
-		case TVAFE_ADC_CAL_STEP_GAIN*11:
-		case TVAFE_ADC_CAL_STEP_GAIN*13:
-		case TVAFE_ADC_CAL_STEP_GAIN*15:
-#ifdef LOG_ADC_CAL
-                pr_info("\nA_gn = %4d %4d %4d\n", (int)adc_cal[operand->cal_fmt_cnt].a_analog_gain,
-                    (int)adc_cal[operand->cal_fmt_cnt].b_analog_gain, (int)adc_cal[operand->cal_fmt_cnt].c_analog_gain);
-            #endif
-			// get data of level 1
-			tvafe_adc_cal_read("Lvl1", &operand->a, &operand->b, &operand->c);
-			// select level 2
-			WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 2,
-					VAFE_SELGAINCALLVL_BIT, VAFE_SELGAINCALLVL_WID);
-			break;
-		case TVAFE_ADC_CAL_STEP_GAIN*2:
-			if (!mutex)
-			{
-				mutex   =  1;
-				step_up = 64;
-				step_dn = 64;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*4:
-			if (!mutex)
-			{
-				mutex   =  1;
-				step_up = 32;
-				step_dn = 32;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*6:
-			if (!mutex)
-			{
-				mutex   =  1;
-				step_up = 16;
-				step_dn = 16;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*8:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 8;
-				step_dn = 8;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*10:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 4;
-				step_dn = 4;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*12:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 2;
-				step_dn = 2;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*14:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 1;
-				step_dn = 1;
-			}
-		case TVAFE_ADC_CAL_STEP_GAIN*16:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 0;
-				step_dn = 1;
-			}
-			// get data of level 2
-			tvafe_adc_cal_read("Lvl2", &a, &b, &c);
-#ifdef LOG_ADC_CAL
-			pr_info("Diff = %4d %4d %4d\n", (int)(a - operand->a),
-					(int)(b - operand->b), (int)(c - operand->c));
-#endif
-			// tune analog gain
-			if (tvafe_cal_gain_overflow(operand->a, a, is_component))
-                adc_cal[operand->cal_fmt_cnt].a_analog_gain -= step_dn;
-            else
-                adc_cal[operand->cal_fmt_cnt].a_analog_gain += step_up;
-            if (tvafe_cal_gain_overflow(operand->b, b, false))
-                adc_cal[operand->cal_fmt_cnt].b_analog_gain -= step_dn;
-            else
-                adc_cal[operand->cal_fmt_cnt].b_analog_gain += step_up;
-            if (tvafe_cal_gain_overflow(operand->c, c, false))
-                adc_cal[operand->cal_fmt_cnt].c_analog_gain -= step_dn;
-            else
-                adc_cal[operand->cal_fmt_cnt].c_analog_gain += step_up;
-            // load adc cal values
-            adc_cal[operand->cal_fmt_cnt].reserved |= TVAFE_ADC_CAL_VALID;
-            tvafe_set_cal_value2( &adc_cal[operand->cal_fmt_cnt]);
-            adc_cal[operand->cal_fmt_cnt].reserved &= ~TVAFE_ADC_CAL_VALID;
-			// select level 1
-			WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 1,
-					VAFE_SELGAINCALLVL_BIT, VAFE_SELGAINCALLVL_WID);
-			if (operand->step == TVAFE_ADC_CAL_STEP_GAIN*16 + 1)
-			{
-#ifdef LOG_ADC_CAL
-                    pr_info("\nfresh_adc_cal after gain\n");
-                    pr_info("A_cl = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_analog_clamp),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_analog_clamp),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_analog_clamp));
-                    pr_info("A_gn = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_analog_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_analog_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_analog_gain));
-                    pr_info("D_gn = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_digital_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_digital_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_digital_gain));
-                    pr_info("D_o1 = %4d %4d %4d\n", ((int)(adc_cal[operand->cal_fmt_cnt].a_digital_offset1) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].b_digital_offset1) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].c_digital_offset1) << 21) >> 21);
-                    pr_info("D_o2 = %4d %4d %4d\n", ((int)(adc_cal[operand->cal_fmt_cnt].a_digital_offset2) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].b_digital_offset2) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].c_digital_offset2) << 21) >> 21);
-				pr_info("\n");
-#endif
-
-				// disable gain calibration
-				WRITE_APB_REG_BITS(TVFE_VAFE_CTRL, 0, VAFE_ENGAINCAL_BIT, VAFE_ENGAINCAL_WID);
-				// set bpg_h, bpg_v, bpg_m, clamp_inv, clamp_ext
-				WRITE_APB_REG(TVFE_BPG_BACKP_H, 1);
-				WRITE_APB_REG(TVFE_BPG_BACKP_V, 1);
-				//WRITE_APB_REG_BITS(TVFE_TOP_CTRL,     1, TVFE_BACKP_GATE_MUX_BIT, TVFE_BACKP_GATE_MUX_WID);
-				//WRITE_APB_REG_BITS(TVFE_DVSS_MUXCTRL, 1, DVSS_CLAMP_INV_BIT,      DVSS_CLAMP_INV_WID     );
-				WRITE_APB_REG_BITS(ADC_REG_2F, 1, CLAMPEXT_BIT, CLAMPEXT_WID);
-				WRITE_APB_REG_BITS(ADC_REG_58, 1, EXTCLKSEL_BIT, EXTCLKSEL_WID);
-			}
-			break;
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*1:
-			if (!mutex)
-			{
-				mutex   =  1;
-				step_up = 32;
-				step_dn = 32;
-			}
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*2:
-			if (!mutex)
-			{
-				mutex   =  1;
-				step_up = 16;
-				step_dn = 16;
-			}
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*3:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 8;
-				step_dn = 8;
-			}
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*4:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 4;
-				step_dn = 4;
-			}
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*5:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 2;
-				step_dn = 2;
-			}
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*6:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 1;
-				step_dn = 1;
-			}
-		case TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*7:
-			if (!mutex)
-			{
-				mutex   = 1;
-				step_up = 0;
-				step_dn = 1;
-			}
-#ifdef LOG_ADC_CAL
-                pr_info("\nA_cl = %4d %4d %4d\n", (int)adc_cal[operand->cal_fmt_cnt].a_analog_clamp,
-                    (int)adc_cal[operand->cal_fmt_cnt].b_analog_clamp, (int)adc_cal[operand->cal_fmt_cnt].c_analog_clamp);
-#endif
-			// get data of blank
-			tvafe_adc_cal_read("Dark", &a, &b, &c);
-			// tune analog clamp
-			if (a > z_lu)
-                adc_cal[operand->cal_fmt_cnt].a_analog_clamp -= step_dn;
-			else
-                adc_cal[operand->cal_fmt_cnt].a_analog_clamp += step_up;
-			if (b > z_ch)
-                adc_cal[operand->cal_fmt_cnt].b_analog_clamp -= step_dn;
-            else
-                adc_cal[operand->cal_fmt_cnt].b_analog_clamp += step_up;
-            if (c > z_ch)
-                adc_cal[operand->cal_fmt_cnt].c_analog_clamp -= step_dn;
-            else
-                adc_cal[operand->cal_fmt_cnt].c_analog_clamp += step_up;
-			// load adc cal values
-            adc_cal[operand->cal_fmt_cnt].reserved |= TVAFE_ADC_CAL_VALID;
-            tvafe_set_cal_value2(&adc_cal[operand->cal_fmt_cnt]);
-            adc_cal[operand->cal_fmt_cnt].reserved &= ~TVAFE_ADC_CAL_VALID;
-			if (operand->step == TVAFE_ADC_CAL_STEP_STAGE + TVAFE_ADC_CAL_STEP_CLAMP*7 + 1)
-			{
-#ifdef LOG_ADC_CAL
-                    pr_info("\nfresh_adc_cal after clamp\n");
-                    pr_info("A_cl = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_analog_clamp),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_analog_clamp),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_analog_clamp));
-                    pr_info("A_gn = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_analog_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_analog_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_analog_gain));
-                    pr_info("D_gn = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_digital_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_digital_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_digital_gain));
-                    pr_info("D_o1 = %4d %4d %4d\n", ((int)(adc_cal[operand->cal_fmt_cnt].a_digital_offset1) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].b_digital_offset1) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].c_digital_offset1) << 21) >> 21);
-                    pr_info("D_o2 = %4d %4d %4d\n", ((int)(adc_cal[operand->cal_fmt_cnt].a_digital_offset2) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].b_digital_offset2) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].c_digital_offset2) << 21) >> 21);
-                    pr_info("\n");
-#endif
-#ifdef TVAFE_ADC_CAL_VALIDATION
-				// adjust adc cal values
-                    tvafe_adjust_cal_value(adc_cal[operand->cal_fmt_cnt],is_component);
-				// load adc cal values
-				adc_cal->reserved |= TVAFE_ADC_CAL_VALID;
-                    tvafe_set_cal_value2(&adc_cal[operand->cal_fmt_cnt]);
-                    adc_cal[operand->cal_fmt_cnt].reserved &= ~TVAFE_ADC_CAL_VALID;
-                #endif
-#ifdef LOG_ADC_CAL
-                    pr_info("\nfinal_adc_cal after validation\n");
-                    pr_info("A_cl = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_analog_clamp),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_analog_clamp),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_analog_clamp));
-                    pr_info("A_gn = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_analog_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_analog_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_analog_gain));
-                    pr_info("D_gn = %4d %4d %4d\n",  (int)(adc_cal[operand->cal_fmt_cnt].a_digital_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].b_digital_gain),
-                                                     (int)(adc_cal[operand->cal_fmt_cnt].c_digital_gain));
-                    pr_info("D_o1 = %4d %4d %4d\n", ((int)(adc_cal[operand->cal_fmt_cnt].a_digital_offset1) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].b_digital_offset1) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].c_digital_offset1) << 21) >> 21);
-                    pr_info("D_o2 = %4d %4d %4d\n", ((int)(adc_cal[operand->cal_fmt_cnt].a_digital_offset2) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].b_digital_offset2) << 21) >> 21,
-                                                    ((int)(adc_cal[operand->cal_fmt_cnt].c_digital_offset2) << 21) >> 21);
-                    //pr_info("\n");
-#endif
-
-				// restore bpg_h, bpg_v, bpg_m, clamp_inv, clamp_ext, clk_ext, clk_ctl, lpf_a, lpf_b, lpf_c
-				WRITE_APB_REG(TVFE_BPG_BACKP_H, operand->bpg_h);
-				WRITE_APB_REG(TVFE_BPG_BACKP_V, operand->bpg_v);
-				WRITE_APB_REG_BITS(TVFE_TOP_CTRL, operand->bpg_m,
-						TVFE_BACKP_GATE_MUX_BIT, TVFE_BACKP_GATE_MUX_WID);
-				//WRITE_APB_REG_BITS(TVFE_DVSS_MUXCTRL, operand->clamp_inv, DVSS_CLAMP_INV_BIT,      DVSS_CLAMP_INV_WID     );
-				WRITE_APB_REG_BITS(ADC_REG_2F, operand->clamp_ext,
-						CLAMPEXT_BIT,            CLAMPEXT_WID           );
-				// WRITE_APB_REG_BITS(ADC_REG_19, operand->lpf_a, ENLPFA_BIT,    ENLPFA_WID   );
-				// WRITE_APB_REG_BITS(ADC_REG_1A, operand->lpf_b, ENLPFB_BIT,    ENLPFB_WID   );
-				// WRITE_APB_REG_BITS(ADC_REG_1B, operand->lpf_c, ENLPFC_BIT,    ENLPFC_WID   );
-				WRITE_APB_REG_BITS(ADC_REG_58, operand->clk_ext, EXTCLKSEL_BIT, EXTCLKSEL_WID);
-				WRITE_APB_REG_BITS(ADC_REG_39, operand->sync_mux, INSYNCMUXCTRL_BIT,INSYNCMUXCTRL_WID);
-				WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL, operand->clk_ctl);
-				WRITE_APB_REG(TVFE_VAFE_CTRL, operand->vafe_ctl);
-				// validate result
-				// adc_cal->reserved |= TVAFE_ADC_CAL_VALID;
-				// end of cal
-				operand->step = 0;
-				operand->cal_fmt_cnt++;
-			}
-			break;
-		default:
-			break;
-	}
-
-    if (operand->step || operand->cal_fmt_cnt < operand->cal_fmt_max){
-			if(operand->step == 0 && operand->cal_fmt_cnt == 1)
-				pr_info("COMP Calbration for 1080p End\n\n");
-			else if(operand->step == 0 && operand->cal_fmt_cnt == 2)
-				pr_info("COMP Calbration for 720p and 1080i End\n\n");
-            return (true);
-    }else{
-		operand->cal_fmt_cnt = 0;
-
-		if(operand->cal_fmt_max == 1){
-			pr_info("VGA Calbration End\n\n");
-		}else{
-			pr_info("COMP Calbration for 480 and 576 End\n");
-			pr_info("COMP Calbration End\n\n");
-		}
-        return (false);
-    }
-}
-
-/*
- * tvafe clamp adjustmen by adc readback module
- */
-void tvafe_adc_clamp_adjust(struct tvin_parm_s *parm, struct tvafe_cal_s *cal)
-{
-	enum tvin_port_e port = parm->port;
-	struct tvafe_cal_operand_s *operand = &cal->cal_operand;
-	struct tvafe_adc_cal_s *adc_cal = &cal->cal_val;
-	unsigned int data = READ_APB_REG(TVFE_ADC_READBACK_INDICATOR);
-	unsigned int tgt_y = 0, tgt_c = 0;
-	bool cond = true;
-
-	// do adjust after TVIN_IOC_S_AFE_ADC_CAL is executed
-	if (!(adc_cal->reserved & TVAFE_ADC_CAL_VALID))
-		return;
-
-	// skip over the 1st vsync after TVIN_IOC_S_AFE_ADC_CAL is executed
-	operand->cnt++;
-	if (operand->cnt <= 1)
-		return;
-
-	if ((!adc_cal->a_analog_clamp) ||
-			(!adc_cal->b_analog_clamp) ||
-			(!adc_cal->c_analog_clamp) ||
-			(adc_cal->a_analog_clamp == 127) ||
-			(adc_cal->b_analog_clamp == 127) ||
-			(adc_cal->c_analog_clamp == 127)
-	   )
-		return;
-
-	if ((port >= TVIN_PORT_COMP0) &&
-			(port <= TVIN_PORT_COMP7)
-	   )
-	{
-		tgt_y = 37;
-		tgt_c = 512;
-	}
-	else if ((port >= TVIN_PORT_VGA0) &&
-			(port <= TVIN_PORT_VGA7)
-		)
-	{
-		tgt_y = 0;
-		tgt_c = 0;
-	}
-	else
-		return;
-
-	operand->adc0 += (data >> 20) & 0x000003ff;
-	operand->adc1 += (data >> 10) & 0x000003ff;
-	operand->adc2 += (data >>  0) & 0x000003ff;
-	if (operand->cnt == 5)
-	{
-		operand->adj  = 0;
-		operand->adc0  = (operand->adc0 + 2) >> 2;
-		operand->adc1  = (operand->adc1 + 2) >> 2;
-		operand->adc2  = (operand->adc2 + 2) >> 2;
-		if (operand->adc0 > tgt_y)
-		{
-			cond = (!operand->dir) || (operand->dir0);
-			if ((adc_cal->a_analog_clamp) && cond)
-			{
-				adc_cal->a_analog_clamp--;
-				operand->dir   = 1;
-				operand->dir0  = 1;
-				operand->adj  = 1;
-			}
-		}
-		else
-		{
-			cond = (!operand->dir) || (!operand->dir0);
-			if ((adc_cal->a_analog_clamp < 127) && cond)
-			{
-				adc_cal->a_analog_clamp++;
-				operand->dir   = 1;
-				operand->adj = 1;
-			}
-		}
-		if (operand->adc1 > tgt_c)
-		{
-			cond = (!operand->dir) || (operand->dir1);
-			if ((adc_cal->b_analog_clamp) && cond)
-			{
-				adc_cal->b_analog_clamp--;
-				operand->dir   = 1;
-				operand->dir1  = 1;
-				operand->adj  = 1;
-			}
-		}
-		else
-		{
-			cond = (!operand->dir) || (!operand->dir1);
-			if ((adc_cal->b_analog_clamp < 127) && cond)
-			{
-				adc_cal->b_analog_clamp++;
-				operand->dir   = 1;
-				operand->adj = 1;
-			}
-		}
-		if (operand->adc2 > tgt_c)
-		{
-			cond = (!operand->dir) || (operand->dir2);
-			if ((adc_cal->c_analog_clamp) && cond)
-			{
-				adc_cal->c_analog_clamp--;
-				operand->dir   = 1;
-				operand->dir0  = 1;
-				operand->adj  = 1;
-			}
-		}
-		else
-		{
-			cond = (!operand->dir) || (!operand->dir2);
-			if ((adc_cal->c_analog_clamp < 127) && cond)
-			{
-				adc_cal->c_analog_clamp++;
-				operand->dir   = 1;
-				operand->adj = 1;
-			}
-		}
-		if (operand->adj)
-		{
-			tvafe_set_cal_value(cal);
-			operand->data0 = operand->adc0;
-			operand->data1 = operand->adc1;
-			operand->data2 = operand->adc2;
-		}
-		operand->cnt  = 1;
-		operand->adc0 = 0;
-		operand->adc1 = 0;
-		operand->adc2 = 0;
-	}
-}
-
-/*
- * tvafe get the wss data from Reg
- */
-void tvafe_get_wss_data(struct tvafe_comp_wss_s *wss)
-{
-	wss->wss1[0] = READ_APB_REG(TVFE_MISC_WSS1_INDICATOR1);
-	wss->wss1[1] = READ_APB_REG(TVFE_MISC_WSS1_INDICATOR2);
-	wss->wss1[2] = READ_APB_REG(TVFE_MISC_WSS1_INDICATOR3);
-	wss->wss1[3] = READ_APB_REG(TVFE_MISC_WSS1_INDICATOR4);
-	wss->wss1[4] = READ_APB_REG_BITS(TVFE_MISC_WSS1_INDICATOR5,
-			WSS1_DATA_143_128_BIT, WSS1_DATA_143_128_WID);
-	wss->wss2[0] = READ_APB_REG(TVFE_MISC_WSS2_INDICATOR1);
-	wss->wss2[1] = READ_APB_REG(TVFE_MISC_WSS2_INDICATOR2);
-	wss->wss2[2] = READ_APB_REG(TVFE_MISC_WSS2_INDICATOR3);
-	wss->wss2[3] = READ_APB_REG(TVFE_MISC_WSS2_INDICATOR4);
-	wss->wss2[4] = READ_APB_REG_BITS(TVFE_MISC_WSS2_INDICATOR5,
-			WSS2_DATA_143_128_BIT, WSS2_DATA_143_128_WID);
-}
-
-/*
- * tvafe set the de by format
- */
-void tvafe_top_set_de(enum tvin_sig_fmt_e fmt)
-{
-	unsigned int hs = 0, he = 0, vs = 0, ve = 0;
-	const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-
-    if(!fmt_info) {
-        pr_err("[tvafe..] %s: error,fmt is null!!! \n",__func__);
-        return;
-    }
-
-	hs = fmt_info->hs_width + fmt_info->hs_bp;
-
-	/* fix Comp de bug*/
-	if (fmt < TVIN_SIG_FMT_COMP_MAX && fmt >= TVIN_SIG_FMT_COMP_480P_60HZ_D000)
-		hs = (unsigned int)((signed int)hs + (signed int)tvafe_comp_hs_patch[fmt- TVIN_SIG_FMT_COMP_480P_60HZ_D000]);
-
-	vs = fmt_info->vs_width + fmt_info->vs_bp;
-	he = hs + fmt_info->h_active - 1;
-	ve = vs + fmt_info->v_active - 1;
-
-
-	WRITE_APB_REG_BITS(TVFE_DEG_H, hs,
-			DEG_HSTART_BIT, DEG_HSTART_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_H, he,
-			DEG_HEND_BIT, DEG_HEND_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_VODD, vs,
-			DEG_VSTART_ODD_BIT, DEG_VSTART_ODD_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_VODD, ve,
-			DEG_VEND_ODD_BIT, DEG_VEND_ODD_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_VEVEN, vs,
-			DEG_VSTART_EVEN_BIT, DEG_VSTART_EVEN_WID);
-	WRITE_APB_REG_BITS(TVFE_DEG_VEVEN, ve,
-			DEG_VEND_EVEN_BIT, DEG_VEND_EVEN_WID);
-
-	//fix 1080i60 field gen bug
-	if ((fmt == TVIN_SIG_FMT_COMP_1080I_60HZ_D000) |(fmt== TVIN_SIG_FMT_COMP_1080I_50HZ_D000_A))
-		WRITE_APB_REG_BITS(TVFE_SYNCTOP_SFG_MUXCTRL1, 0,
-				SFG_FLD_MANUAL_INV_BIT, SFG_FLD_MANUAL_INV_WID);
-	else
-		WRITE_APB_REG_BITS(TVFE_SYNCTOP_SFG_MUXCTRL1, 1,
-				SFG_FLD_MANUAL_INV_BIT, SFG_FLD_MANUAL_INV_WID);
-}
-
-/*
- * tvafe congigure top setting by format
- */
-static void tvafe_top_config(enum tvin_sig_fmt_e fmt)
-{
-
-	//tvafe_top_set_aafilter_control(fmt);
-	//tvafe_top_set_bp_gate(fmt);
-	//tvafe_top_set_mvdet_control(fmt);
-	tvafe_top_set_sfg_mux_control(fmt);
-	tvafe_top_set_wss_control(fmt);
-	tvafe_top_set_de(fmt);
-}
-
-/*
- * tvafe configure vga setting by format
- */
-void tvafe_set_vga_fmt(struct tvin_parm_s *parm, struct tvafe_cal_s *cal, struct tvafe_pin_mux_s *pinmux)
-{
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-	enum tvin_port_e port = parm->port;
-	unsigned int i = 0;
-
-	/**enable auto mode clock**/
-	WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0x100);
-
-	/** write top register **/
-	while (vga_top_reg_default[i][0] != 0xFFFFFFFF) {
-		WRITE_APB_REG(vga_top_reg_default[i][0], vga_top_reg_default[i][1]);
-		i++;
-	}
-
-	/** write 7740 register **/
-	tvafe_adc_configure(fmt);
-
-	//set top register
-	tvafe_top_config(fmt);
-
-	/* load calibration data */
-	tvafe_set_cal_value(cal);
-
-	/* must reload mux if you change adc reg table!!! */
-	tvafe_set_source_muxing(port, pinmux);
-
-}
-
-/*
- * tvafe configure comp setting by format
- */
-void tvafe_set_comp_fmt(struct tvin_parm_s *parm, struct tvafe_cal_s *cal, struct tvafe_pin_mux_s *pinmux)
-{
-	enum tvin_sig_fmt_e fmt = parm->info.fmt;
-	enum tvin_port_e port = parm->port;
-	unsigned int i = 0;
-
-	/**enable auto mode clock**/
-	WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0x100);
-	WRITE_CBUS_REG(HHI_VAFE_CLKOSCIN_CNTL, 0x100);
-
-	/** write top register **/
-	while (comp_top_reg_default[i][0] != 0xFFFFFFFF) {
-		WRITE_APB_REG(comp_top_reg_default[i][0], comp_top_reg_default[i][1]);
-		i++;
-	}
-
-	/** write 7740 register **/
-	tvafe_adc_configure(fmt);
-
-	//set top register
-	tvafe_top_config(fmt);
-
-	/* load calibration data */
-	tvafe_set_cal_value(cal);
-
-	/* must reload mux if you change adc reg table!!! */
-	tvafe_set_source_muxing(port, pinmux);
-}
-
-/*
- * tvafe init cvbs setting with pal-i
- */
-static void tvafe_set_cvbs_default(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem, enum tvin_port_e port, struct tvafe_pin_mux_s *mux)
-{
-	unsigned int i = 0;
-
-	/**disable auto mode clock**/
-	WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0);
-
-	/** write 7740 register **/
-	tvafe_adc_configure(TVIN_SIG_FMT_CVBS_PAL_I);
-
-
-	/** write top register **/
-	i = 0;
-	while (cvbs_top_reg_default[i][0] != 0xFFFFFFFF) {
-		WRITE_APB_REG(cvbs_top_reg_default[i][0], cvbs_top_reg_default[i][1]);
-		i++;
-	}
-
-	/* init some variables  */
-	cvd2->vd_port = port;
-
-	/* set cvd2 default format to pal-i */
-	tvafe_cvd2_try_format(cvd2, mem, TVIN_SIG_FMT_CVBS_PAL_I);
-
-}
-
-void tvafe_enable_avout(bool enable)
-{
-	if(enable)
-		//close/open av out
-		WRITE_APB_REG_BITS(ADC_REG_20, 1, ENCVBSBUF_BIT,ENCVBSBUF_WID);
-	else
-		//close av out
-		WRITE_APB_REG_BITS(ADC_REG_20, 0, ENCVBSBUF_BIT,ENCVBSBUF_WID);
-}
-/*
- * tvafe init the whole module
- */
-static bool enableavout = true;
-module_param(enableavout, bool, 0644);
-MODULE_PARM_DESC(enableavout, "disable av out when load adc reg");
-void tvafe_init_reg(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem, enum tvin_port_e port, struct tvafe_pin_mux_s *pinmux)
-{
-	unsigned int i = 0;
-
-	if ((port >= TVIN_PORT_VGA0) && (port <= TVIN_PORT_VGA7))
-	{
-		/**enable auto mode clock**/
-		WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0x100);
-
-
-		/** write top register don't after write 7740 register**/
-		while (vga_top_reg_default[i][0] != 0xFFFFFFFF) {
-			WRITE_APB_REG(vga_top_reg_default[i][0], vga_top_reg_default[i][1]);
-			i++;
-		}
-		/** write 7740 register **/
-		tvafe_adc_configure(TVIN_SIG_FMT_VGA_1024X768P_60HZ_D004);
-
-		tvafe_top_config(TVIN_SIG_FMT_VGA_1024X768P_60HZ_D004);
-	}
-	else if ((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7))
-	{
-		/**enable auto mode clock**/
-		WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0x100);
-		WRITE_CBUS_REG(HHI_VAFE_CLKOSCIN_CNTL, 0x100);
-
-		/** write top register don't after write 7740 register**/
-		while (comp_top_reg_default[i][0] != 0xFFFFFFFF) {
-			WRITE_APB_REG(comp_top_reg_default[i][0], comp_top_reg_default[i][1]);
-			i++;
-		}
-		/** write 7740 register **/
-		tvafe_adc_configure(TVIN_SIG_FMT_COMP_720P_59HZ_D940);
-
-		tvafe_top_config(TVIN_SIG_FMT_COMP_720P_59HZ_D940);
-	}
-	else if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7))
-	{
-		tvafe_set_cvbs_default(cvd2, mem, port, pinmux);
-		/*turn on/off av out*/
-		tvafe_enable_avout(enableavout);
-	}
-
-	/* must reload mux if you change adc reg table!!! */
-	tvafe_set_source_muxing(port, pinmux);
-
-	pr_info("[tvafe..] %s ok.\n", __func__);
-
-}
-
-/*
- * tvafe set APB bus register accessing error exception
- */
-void tvafe_set_apb_bus_err_ctrl(void)
-{
-	WRITE_APB_REG(TVFE_APB_ERR_CTRL_MUX1, 0x8fff8fff);
-	WRITE_APB_REG(TVFE_APB_ERR_CTRL_MUX2, 0x00008fff);
-}
-
-/*
- * tvafe reset the whole module
- */
-static void tvafe_reset_module(void)
-{
-	WRITE_APB_REG_BITS(TVFE_RST_CTRL, 1, ALL_CLK_RST_BIT, ALL_CLK_RST_WID);
-	WRITE_APB_REG_BITS(TVFE_RST_CTRL, 0, ALL_CLK_RST_BIT, ALL_CLK_RST_WID);
-}
-
-/*
- * tvafe power control of the module
- */
-void tvafe_enable_module(bool enable)
-{
-	// enable
-
-	//main clk up
-	WRITE_CBUS_REG(HHI_VAFE_CLKXTALIN_CNTL, 0x100);
-	WRITE_CBUS_REG(HHI_VAFE_CLKOSCIN_CNTL, 0x100);
-	WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL, 0x100);
-	WRITE_CBUS_REG(HHI_VAFE_CLKPI_CNTL, 0x100);
-	WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0x100);
-
-	//tvfe power up
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 1, COMP_CLK_ENABLE_BIT, COMP_CLK_ENABLE_WID);
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 1, EDID_CLK_EN_BIT, EDID_CLK_EN_WID);
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 1, DCLK_ENABLE_BIT, DCLK_ENABLE_WID);
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 1, VAFE_MCLK_EN_BIT, VAFE_MCLK_EN_WID);
-	WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 3, TVFE_ADC_CLK_DIV_BIT, TVFE_ADC_CLK_DIV_WID);
-	//adc power up
-	WRITE_APB_REG_BITS(ADC_REG_21, 1, FULLPDZ_BIT, FULLPDZ_WID);
-
-	/*reset module*/
-	tvafe_reset_module();
-
-	// disable
-	if (!enable)
-	{
-		//adc power down
-		WRITE_APB_REG_BITS(ADC_REG_21, 0, FULLPDZ_BIT, FULLPDZ_WID);
-
-		//tvfe power down
-		WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 0, COMP_CLK_ENABLE_BIT, COMP_CLK_ENABLE_WID);
-		WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 0, EDID_CLK_EN_BIT, EDID_CLK_EN_WID);
-		WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 0, DCLK_ENABLE_BIT, DCLK_ENABLE_WID);
-		WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 0, VAFE_MCLK_EN_BIT, VAFE_MCLK_EN_WID);
-		WRITE_APB_REG_BITS(TVFE_TOP_CTRL, 0, TVFE_ADC_CLK_DIV_BIT, TVFE_ADC_CLK_DIV_WID);
-
-		//main clk down
-		WRITE_CBUS_REG(HHI_VAFE_CLKXTALIN_CNTL, 0);
-		WRITE_CBUS_REG(HHI_VAFE_CLKOSCIN_CNTL, 0);
-		WRITE_CBUS_REG(HHI_VAFE_CLKIN_CNTL, 0);
-		WRITE_CBUS_REG(HHI_VAFE_CLKPI_CNTL, 0);
-		WRITE_CBUS_REG(HHI_TVFE_AUTOMODE_CLK_CNTL, 0);
-	}
-}
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_general.h b/drivers/amlogic/tvin/tvafe/tvafe_general.h
deleted file mode 100755
index d048847428dd..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_general.h
+++ /dev/null
@@ -1,87 +0,0 @@
-#ifndef _TVAFE_GENERAL_H
-#define _TVAFE_GENERAL_H
-
-#include <linux/amlogic/tvin/tvin.h>
-#include "tvafe_cvd.h"
-
-// ***************************************************************************
-// *** macro definitions *********************************************
-// ***************************************************************************
-
-#define LOG_ADC_CAL
-//#define LOG_VGA_EDID
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-typedef enum tvafe_adc_ch_e {
-	TVAFE_ADC_CH_NULL = 0,
-	TVAFE_ADC_CH_PGA,
-	TVAFE_ADC_CH_A,
-	TVAFE_ADC_CH_B,
-	TVAFE_ADC_CH_C,
-} tvafe_adc_ch_t;
-
-// ***************************************************************************
-// *** structure definitions *********************************************
-// ***************************************************************************
-typedef struct tvafe_cal_operand_s {
-	unsigned int a;
-	unsigned int b;
-	unsigned int c;
-	unsigned int step;
-	unsigned int bpg_h;
-	unsigned int bpg_v;
-	unsigned int clk_ctl;
-	unsigned int vafe_ctl;
-	unsigned int sync_mux :1;
-	unsigned int clk_ext  :1;
-	unsigned int bpg_m    :2;
-	unsigned int lpf_a    :1;
-	unsigned int lpf_b    :1;
-	unsigned int lpf_c    :1;
-	unsigned int clamp_inv:1;
-	unsigned int clamp_ext:1;
-	unsigned int adj      :1;
-	unsigned int cnt      :3;
-	unsigned int dir      :1;
-	unsigned int dir0     :1;
-	unsigned int dir1     :1;
-	unsigned int dir2     :1;
-	unsigned int adc0;
-	unsigned int adc1;
-	unsigned int adc2;
-	unsigned int data0;
-	unsigned int data1;
-	unsigned int data2;
-	unsigned int cal_fmt_cnt;
-	unsigned int cal_fmt_max;
-} tvafe_cal_operand_t;
-
-typedef struct tvafe_cal_s {
-	//adc calibration data
-	struct tvafe_adc_cal_s      cal_val;
-    struct tvafe_adc_comp_cal_s  fmt_cal_val;
-	struct tvafe_cal_operand_s  cal_operand;
-} tvafe_cal_t;
-
-// *****************************************************************************
-// ******** function claims ********
-// *****************************************************************************
-extern int  tvafe_set_source_muxing(enum tvin_port_e port, struct tvafe_pin_mux_s *pinmux);
-extern void tvafe_vga_set_edid(struct tvafe_vga_edid_s *edid);
-extern void tvafe_vga_get_edid(struct tvafe_vga_edid_s *edid);
-extern void tvafe_set_cal_value(struct tvafe_cal_s *cal);
-extern int tvafe_get_cal_value(struct tvafe_cal_s *cal);
-extern void tvafe_set_cal_value2(struct tvafe_adc_cal_s *cal);
-extern int tvafe_get_cal_value2(struct tvafe_adc_cal_s *cal);
-extern bool tvafe_adc_cal(struct tvin_parm_s *parm, struct tvafe_cal_s *cal);
-extern void tvafe_adc_clamp_adjust(struct tvin_parm_s *parm, struct tvafe_cal_s *cal);
-extern void tvafe_get_wss_data(struct tvafe_comp_wss_s *wss);
-extern void tvafe_set_vga_fmt(struct tvin_parm_s *parm, struct tvafe_cal_s *cal, struct tvafe_pin_mux_s *pinmux);
-extern void tvafe_set_comp_fmt(struct tvin_parm_s *parm, struct tvafe_cal_s *cal, struct tvafe_pin_mux_s *pinmux);
-extern void tvafe_init_reg(struct tvafe_cvd2_s *cvd2, struct tvafe_cvd2_mem_s *mem, enum tvin_port_e port, struct tvafe_pin_mux_s *pinmux);
-extern void tvafe_set_apb_bus_err_ctrl(void);
-extern void tvafe_enable_module(bool enable);
-extern void tvafe_enable_avout(bool enable);
-#endif  // _TVAFE_GENERAL_H
-
diff --git a/drivers/amlogic/tvin/tvafe/tvafe_regs.h b/drivers/amlogic/tvin/tvafe/tvafe_regs.h
deleted file mode 100755
index 515cc8910720..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvafe_regs.h
+++ /dev/null
@@ -1,4185 +0,0 @@
-/*
- * TVAFE register bit-field definition
- * Sorted by the appearing order of registers in am_regs.h.
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef _TVAFE_REG_H
-#define _TVAFE_REG_H
-
-// *****************************************************************************
-// ******** ACD REGISTERS ********
-// *****************************************************************************
-
-#define ACD_BASE_ADD                                    0x3100//0x1900
-
-#define ACD_REG_00                                      ((ACD_BASE_ADD+0x00)<<2)
-#define MD_LUT_STEP06_BIT              28
-#define MD_LUT_STEP06_WID              4
-#define MD_LUT_STEP05_BIT              24
-#define MD_LUT_STEP05_WID              4
-#define MD_LUT_STEP04_BIT              20
-#define MD_LUT_STEP04_WID              4
-#define MD_LUT_STEP03_BIT              16
-#define MD_LUT_STEP03_WID              4
-#define MD_LUT_STEP02_BIT              12
-#define MD_LUT_STEP02_WID              4
-#define MD_LUT_STEP01_BIT              8
-#define MD_LUT_STEP01_WID              4
-#define MD_LUT_STEP00_BIT              0
-#define MD_LUT_STEP00_WID              8
-
-#define ACD_REG_01                                      ((ACD_BASE_ADD+0x01)<<2)
-#define MD_LUT_STEP14_BIT              28
-#define MD_LUT_STEP14_WID              4
-#define MD_LUT_STEP13_BIT              24
-#define MD_LUT_STEP13_WID              4
-#define MD_LUT_STEP12_BIT              20
-#define MD_LUT_STEP12_WID              4
-#define MD_LUT_STEP11_BIT              16
-#define MD_LUT_STEP11_WID              4
-#define MD_LUT_STEP10_BIT              12
-#define MD_LUT_STEP10_WID              4
-#define MD_LUT_STEP09_BIT              8
-#define MD_LUT_STEP09_WID              4
-#define MD_LUT_STEP08_BIT              4
-#define MD_LUT_STEP08_WID              4
-#define MD_LUT_STEP07_BIT              0
-#define MD_LUT_STEP07_WID              4
-
-#define ACD_REG_02                                      ((ACD_BASE_ADD+0x02)<<2)
-#define MD_LF_ADJ_EN_BIT               31
-#define MD_LF_ADJ_EN_WID               1
-#define MD_LF_ADJ_BIT                  24
-#define MD_LF_ADJ_WID                  4
-#define MD_LF_OLD_SEL_BIT              15
-#define MD_LF_OLD_SEL_WID              1
-#define MD_HF_FINAL_SEL_BIT            14
-#define MD_HF_FINAL_SEL_WID            1
-#define MD_LF_FINAL_MODE_BIT           12
-#define MD_LF_FINAL_MODE_WID           2
-#define MD_MODE3_BIT                   11
-#define MD_MODE3_WID                   1
-#define MD_MODE2_BIT                   10
-#define MD_MODE2_WID                   1
-#define MD_MODE1_BIT                   9
-#define MD_MODE1_WID                   1
-#define MD_MODE0_BIT                   8
-#define MD_MODE0_WID                   1
-#define MD_LUT_STEP15_BIT              0
-#define MD_LUT_STEP15_WID              4
-
-#define ACD_REG_03                                      ((ACD_BASE_ADD+0x03)<<2)
-#define MD_DETAIL_SEL_BIT              31
-#define MD_DETAIL_SEL_WID              1
-#define MD_DETAIL_STEP3_BIT            24
-#define MD_DETAIL_STEP3_WID            4
-#define MD_DETAIL_STEP2_BIT            20
-#define MD_DETAIL_STEP2_WID            4
-#define MD_DETAIL_STEP1_BIT            16
-#define MD_DETAIL_STEP1_WID            4
-#define MD_HF_MIDDLE_BIT               15
-#define MD_HF_MIDDLE_WID               1
-#define MD_HF56_MAX_BIT                14
-#define MD_HF56_MAX_WID                1
-#define MD_HF56_MAX2_BIT               13
-#define MD_HF56_MAX2_WID               1
-#define MD_LF56_MAX_BIT                12
-#define MD_LF56_MAX_WID                1
-#define AML_YCSEP_MODE_BIT             11
-#define AML_YCSEP_MODE_WID             1
-#define MD_HF_AVG_SEL_BIT              8
-#define MD_HF_AVG_SEL_WID              2
-#define MD_REGION_HF_TH_BIT            0
-#define MD_REGION_HF_TH_WID            7
-
-#define ACD_REG_04                                      ((ACD_BASE_ADD+0x04)<<2)
-#define HWIDTH_CENABLE_BIT             24
-#define HWIDTH_CENABLE_WID             8
-#define HSTART_CENABLE_BIT             16
-#define HSTART_CENABLE_WID             8
-#define MD_REGION_LF_TH_BIT            8
-#define MD_REGION_LF_TH_WID            7
-#define MD_DETAIL_TH_BIT               0
-#define MD_DETAIL_TH_WID               8
-
-#define ACD_REG_05                                      ((ACD_BASE_ADD+0x05)<<2)
-#define APL_TH1_BIT                    24
-#define APL_TH1_WID                    8
-#define GM_NOISE_TH_BIT                16
-#define GM_NOISE_TH_WID                7
-#define VWIDTH_CENABLE_BIT             8
-#define VWIDTH_CENABLE_WID             8
-#define VSTART_CENABLE_BIT             0
-#define VSTART_CENABLE_WID             8
-
-#define ACD_REG_06                                      ((ACD_BASE_ADD+0x06)<<2)
-#define GM_TH3_BIT                     24
-#define GM_TH3_WID                     8
-#define GM_TH2_BIT                     16
-#define GM_TH2_WID                     8
-#define GM_TH1_BIT                     8
-#define GM_TH1_WID                     8
-#define APL_TH2_BIT                    0
-#define APL_TH2_WID                    8
-
-#define ACD_REG_07                                      ((ACD_BASE_ADD+0x07)<<2)
-#define GM_GAIN4_BIT                   24
-#define GM_GAIN4_WID                   8
-#define GM_GAIN3_BIT                   16
-#define GM_GAIN3_WID                   8
-#define GM_GAIN2_BIT                   8
-#define GM_GAIN2_WID                   8
-#define GM_GAIN1_BIT                   0
-#define GM_GAIN1_WID                   8
-
-#define ACD_REG_08                                      ((ACD_BASE_ADD+0x08)<<2)
-#define MD_BPF_COEF3_BIT               24
-#define MD_BPF_COEF3_WID               8
-#define MD_BPF_COEF2_BIT               16
-#define MD_BPF_COEF2_WID               8
-#define MD_BPF_COEF1_BIT               8
-#define MD_BPF_COEF1_WID               8
-#define MD_BPF_COEF0_BIT               0
-#define MD_BPF_COEF0_WID               8
-
-#define ACD_REG_09                                      ((ACD_BASE_ADD+0x09)<<2)
-#define GM2LUT_EN_BIT                  15
-#define GM2LUT_EN_WID                  1
-#define MD_BPF_EN_BIT                  8
-#define MD_BPF_EN_WID                  1
-#define MD_BPF_COEF4_BIT               0
-#define MD_BPF_COEF4_WID               8
-
-#define ACD_REG_0A                                      ((ACD_BASE_ADD+0x0A)<<2)
-#define GM2LUT_TH2_BIT                 16
-#define GM2LUT_TH2_WID                 16
-#define GM2LUT_TH1_BIT                 0
-#define GM2LUT_TH1_WID                 16
-
-#define ACD_REG_0B                                      ((ACD_BASE_ADD+0x0B)<<2)
-#define YCSEP_DEMO_BIT                 24
-#define YCSEP_DEMO_WID                 8
-#define GM2LUT_STEP2_BIT               16
-#define GM2LUT_STEP2_WID               8
-#define GM2LUT_STEP1_BIT               8
-#define GM2LUT_STEP1_WID               8
-#define GM2LUT_STEP0_BIT               0
-#define GM2LUT_STEP0_WID               8
-
-#define ACD_REG_0C                                      ((ACD_BASE_ADD+0x0C)<<2)
-#define WR_ADDR5_VS_REG_BIT            0
-#define WR_ADDR5_VS_REG_WID            23
-
-#define ACD_REG_0D                                      ((ACD_BASE_ADD+0x0D)<<2)
-#define GM_APL_BIT                     0
-#define GM_APL_WID                     11
-
-#define ACD_REG_0E                                      ((ACD_BASE_ADD+0x0E)<<2)
-#define GLOBAL_MOTION_HF_BIT           16
-#define GLOBAL_MOTION_HF_WID           16
-#define GLOBAL_MOTION_HF_MIN_BIT       0
-#define GLOBAL_MOTION_HF_MIN_WID       16
-
-#define ACD_REG_0F                                      ((ACD_BASE_ADD+0x0F)<<2)
-#define GLOBAL_MOTION_IIR_BIT          16
-#define GLOBAL_MOTION_IIR_WID          16
-#define GLOBAL_MOTION_LF_BIT           0
-#define GLOBAL_MOTION_LF_WID           16
-
-#define ACD_REG_10                                      ((ACD_BASE_ADD+0x10)<<2)
-#define YCSEP_TEST43_BIT               24
-#define YCSEP_TEST43_WID               8
-#define YCSEP_TEST42_BIT               16
-#define YCSEP_TEST42_WID               8
-#define YCSEP_TEST41_BIT               8
-#define YCSEP_TEST41_WID               8
-#define YCSEP_TEST40_BIT               0
-#define YCSEP_TEST40_WID               8
-
-#define ACD_REG_11                                      ((ACD_BASE_ADD+0x11)<<2)
-#define YCSEP_TEST47_BIT               24
-#define YCSEP_TEST47_WID               8
-#define YCSEP_TEST46_BIT               16
-#define YCSEP_TEST46_WID               8
-#define YCSEP_TEST45_BIT               8
-#define YCSEP_TEST45_WID               8
-#define YCSEP_TEST44_BIT               0
-#define YCSEP_TEST44_WID               8
-
-#define ACD_REG_12                                      ((ACD_BASE_ADD+0x12)<<2)
-#define YCSEP_TEST4B_BIT               24
-#define YCSEP_TEST4B_WID               8
-#define YCSEP_TEST4A_BIT               16
-#define YCSEP_TEST4A_WID               8
-#define YCSEP_TEST49_BIT               8
-#define YCSEP_TEST49_WID               8
-#define YCSEP_TEST48_BIT               0
-#define YCSEP_TEST48_WID               8
-
-#define ACD_REG_13                                      ((ACD_BASE_ADD+0x13)<<2)
-#define YCSEP_TEST4F_BIT               24
-#define YCSEP_TEST4F_WID               8
-#define YCSEP_TEST4E_BIT               16
-#define YCSEP_TEST4E_WID               8
-#define YCSEP_TEST4D_BIT               8
-#define YCSEP_TEST4D_WID               8
-#define YCSEP_TEST4C_BIT               0
-#define YCSEP_TEST4C_WID               8
-
-#define ACD_REG_14                                      ((ACD_BASE_ADD+0x14)<<2)
-#define YCSEP_TEST53_BIT               24
-#define YCSEP_TEST53_WID               8
-#define YCSEP_TEST52_BIT               16
-#define YCSEP_TEST52_WID               8
-#define YCSEP_TEST51_BIT               8
-#define YCSEP_TEST51_WID               8
-#define YCSEP_TEST50_BIT               0
-#define YCSEP_TEST50_WID               8
-
-#define ACD_REG_15                                      ((ACD_BASE_ADD+0x15)<<2)
-#define YCSEP_TEST57_BIT               24
-#define YCSEP_TEST57_WID               8
-#define YCSEP_TEST56_BIT               16
-#define YCSEP_TEST56_WID               8
-#define YCSEP_TEST55_BIT               8
-#define YCSEP_TEST55_WID               8
-#define YCSEP_TEST54_BIT               0
-#define YCSEP_TEST54_WID               8
-
-#define ACD_REG_16                                      ((ACD_BASE_ADD+0x16)<<2)
-#define YCSEP_TEST5B_BIT               24
-#define YCSEP_TEST5B_WID               8
-#define YCSEP_TEST5A_BIT               16
-#define YCSEP_TEST5A_WID               8
-#define YCSEP_TEST59_BIT               8
-#define YCSEP_TEST59_WID               8
-#define YCSEP_TEST58_BIT               0
-#define YCSEP_TEST58_WID               8
-
-#define ACD_REG_17                                      ((ACD_BASE_ADD+0x17)<<2)
-#define YCSEP_TEST5F_BIT               24
-#define YCSEP_TEST5F_WID               8
-#define YCSEP_TEST5E_BIT               16
-#define YCSEP_TEST5E_WID               8
-#define YCSEP_TEST5D_BIT               8
-#define YCSEP_TEST5D_WID               8
-#define YCSEP_TEST5C_BIT               0
-#define YCSEP_TEST5C_WID               8
-
-#define ACD_REG_18                                      ((ACD_BASE_ADD+0x18)<<2)
-#define YCSEP_TEST63_BIT               24
-#define YCSEP_TEST63_WID               8
-#define YCSEP_TEST62_BIT               16
-#define YCSEP_TEST62_WID               8
-#define YCSEP_TEST61_BIT               8
-#define YCSEP_TEST61_WID               8
-#define YCSEP_TEST60_BIT               0
-#define YCSEP_TEST60_WID               8
-
-#define ACD_REG_19                                      ((ACD_BASE_ADD+0x19)<<2)
-#define YCSEP_TEST67_BIT               24
-#define YCSEP_TEST67_WID               8
-#define YCSEP_TEST66_BIT               16
-#define YCSEP_TEST66_WID               8
-#define YCSEP_TEST65_BIT               8
-#define YCSEP_TEST65_WID               8
-#define YCSEP_TEST64_BIT               0
-#define YCSEP_TEST64_WID               8
-
-#define ACD_REG_1A                                      ((ACD_BASE_ADD+0x1A)<<2)
-#define YCSEP_TEST6B_BIT               24
-#define YCSEP_TEST6B_WID               8
-#define YCSEP_TEST6A_BIT               16
-#define YCSEP_TEST6A_WID               8
-#define YCSEP_TEST69_BIT               8
-#define YCSEP_TEST69_WID               8
-#define YCSEP_TEST68_BIT               0
-#define YCSEP_TEST68_WID               8
-
-#define ACD_REG_1B                                      ((ACD_BASE_ADD+0x1B)<<2)
-#define YCSEP_TEST6F_BIT               24
-#define YCSEP_TEST6F_WID               8
-#define YCSEP_TEST6E_BIT               16
-#define YCSEP_TEST6E_WID               8
-#define YCSEP_TEST6D_BIT               8
-#define YCSEP_TEST6D_WID               8
-#define YCSEP_TEST6C_BIT               0
-#define YCSEP_TEST6C_WID               8
-
-#define ACD_REG_1C                                      ((ACD_BASE_ADD+0x1C)<<2)
-#define YCSEP_TEST73_BIT               24
-#define YCSEP_TEST73_WID               8
-#define YCSEP_TEST72_BIT               16
-#define YCSEP_TEST72_WID               8
-#define YCSEP_TEST71_BIT               8
-#define YCSEP_TEST71_WID               8
-#define YCSEP_TEST70_BIT               0
-#define YCSEP_TEST70_WID               8
-
-#define ACD_REG_1D                                      ((ACD_BASE_ADD+0x1D)<<2)
-#define YCSEP_TEST75_BIT               8
-#define YCSEP_TEST75_WID               8
-#define YCSEP_TEST74_BIT               0
-#define YCSEP_TEST74_WID               8
-
-#define ACD_REG_1F                                      ((ACD_BASE_ADD+0x1F)<<2)
-#define GLOBAL_DETAIL_BIT              16
-#define GLOBAL_DETAIL_WID              16
-#define GLOBAL_MOTION_PIX_BIT          0
-#define GLOBAL_MOTION_PIX_WID          16
-
-#define ACD_REG_20                                      ((ACD_BASE_ADD+0x20)<<2)
-#define VBIDE_TEST76_BIT               0
-#define VBIDE_TEST76_WID               8
-
-#define ACD_REG_21                                      ((ACD_BASE_ADD+0x21)<<2)
-#define AML_VBI_SIZE_BIT               16
-#define AML_VBI_SIZE_WID               16
-#define AML_VBI_START_ADDR_BIT         0
-#define AML_VBI_START_ADDR_WID         16
-
-#define ACD_REG_22                                      ((ACD_BASE_ADD+0x22)<<2)
-#define AML_VBI_RST_BIT                31
-#define AML_VBI_RST_WID                1
-#define AML_ADDR_VS_EN_BIT             27
-#define AML_ADDR_VS_EN_WID             1
-#define AML_FLUSH_IN_EN_BIT            26
-#define AML_FLUSH_IN_EN_WID            1
-#define AML_DISAGENT_BIT               24
-#define AML_DISAGENT_WID               2
-#define AML_VBIDATA_SEL_BIT            23
-#define AML_VBIDATA_SEL_WID            1
-#define AML_VBI_TH_BIT                 16
-#define AML_VBI_TH_WID                 7
-
-#define ACD_REG_23                                      ((ACD_BASE_ADD+0x23)<<2)
-#define YCSEP_IFCOMP3_BIT              24
-#define YCSEP_IFCOMP3_WID              8
-#define YCSEP_IFCOMP2_BIT              16
-#define YCSEP_IFCOMP2_WID              8
-#define YCSEP_IFCOMP1_BIT              8
-#define YCSEP_IFCOMP1_WID              8
-#define YCSEP_IFCOMP0_BIT              0
-#define YCSEP_IFCOMP0_WID              8
-
-#define ACD_REG_24                                      ((ACD_BASE_ADD+0x24)<<2)
-#define YCSEP_IFCOMP_SCALE_BIT         9
-#define YCSEP_IFCOMP_SCALE_WID         2
-#define YCSEP_IFCOMP_EN_BIT            8
-#define YCSEP_IFCOMP_EN_WID            1
-#define YCSEP_IFCOMP4_BIT              0
-#define YCSEP_IFCOMP4_WID              8
-
-#define ACD_REG_25                                      ((ACD_BASE_ADD+0x25)<<2)
-#define FRONT_LPF3_VIDEO_BIT           24
-#define FRONT_LPF3_VIDEO_WID           8
-#define FRONT_LPF2_VIDEO_BIT           16
-#define FRONT_LPF2_VIDEO_WID           8
-#define FRONT_LPF1_VIDEO_BIT           8
-#define FRONT_LPF1_VIDEO_WID           8
-#define FRONT_LPF0_VIDEO_BIT           0
-#define FRONT_LPF0_VIDEO_WID           8
-
-#define ACD_REG_26                                      ((ACD_BASE_ADD+0x26)<<2)
-#define FRONT_LPF_SCALE_VIDEO_BIT      9
-#define FRONT_LPF_SCALE_VIDEO_WID      1
-#define FRONT_LPF_EN_VIDEO_BIT         8
-#define FRONT_LPF_EN_VIDEO_WID         1
-#define FRONT_LPF4_VIDEO_BIT           0
-#define FRONT_LPF4_VIDEO_WID           8
-
-#define ACD_REG_27                                      ((ACD_BASE_ADD+0x27)<<2)
-#define FRONT_LPF3_VBI_BIT             24
-#define FRONT_LPF3_VBI_WID             8
-#define FRONT_LPF2_VBI_BIT             16
-#define FRONT_LPF2_VBI_WID             8
-#define FRONT_LPF1_VBI_BIT             8
-#define FRONT_LPF1_VBI_WID             8
-#define FRONT_LPF0_VBI_BIT             0
-#define FRONT_LPF0_VBI_WID             8
-
-#define ACD_REG_28                                      ((ACD_BASE_ADD+0x28)<<2)
-#define ACD_CHROMA_MODE_BIT            14
-#define ACD_CHROMA_MODE_WID            2
-#define ACD_DEBYPASS_BIT               13
-#define ACD_DEBYPASS_WID               1
-#define GM_APL_GAIN_MANUEL_BIT         11
-#define GM_APL_GAIN_MANUEL_WID         1
-#define FRONT_LPF_SCALE_VBI_BIT        9
-#define FRONT_LPF_SCALE_VBI_WID        1
-#define FRONT_LPF_EN_VBI_BIT           8
-#define FRONT_LPF_EN_VBI_WID           1
-#define FRONT_LPF4_VBI_BIT             0
-#define FRONT_LPF4_VBI_WID             8
-
-#define ACD_REG_29                                      ((ACD_BASE_ADD+0x29)<<2)
-#define REG_4F_BUF_END_CNT_BIT         28
-#define REG_4F_BUF_END_CNT_WID         3
-#define REG_4F_RD_OFFSET_BIT           24
-#define REG_4F_RD_OFFSET_WID           4
-#define REG_4FRAME_MODE_BIT            23
-#define REG_4FRAME_MODE_WID            1
-//#define REG_4F_MOTION_ADDR_OFFSET_BIT  0  //removed by IC design
-//#define REG_4F_MOTION_ADDR_OFFSET_WID  23
-
-#define ACD_REG_2A                                      ((ACD_BASE_ADD+0x2A)<<2)
-#define REG_4F_DISAGENT_BIT            20
-#define REG_4F_DISAGENT_WID            2
-#define REG_4F_BUF_INI_CNT_BIT         17
-#define REG_4F_BUF_INI_CNT_WID         3
-#define REG_4F_MOTION_LENGTH_BIT       0
-#define REG_4F_MOTION_LENGTH_WID       17
-
-#define ACD_REG_2B                                      ((ACD_BASE_ADD+0x2B)<<2)
-#define CPUMP_UP_OFFSET_BIT            24
-#define CPUMP_UP_OFFSET_WID            8
-#define CPUMP_DN_OFFSET_BIT            16
-#define CPUMP_DN_OFFSET_WID            8
-#define CPUMP_UPDN_AML_EN_BIT          15
-#define CPUMP_UPDN_AML_EN_WID          1
-#define CPUMP_UPDN_RATIO_BIT           8
-#define CPUMP_UPDN_RATIO_WID           7
-#define BP_GATE_VENABLE_BIT            0
-#define BP_GATE_VENABLE_WID            1
-
-#define ACD_REG_2C                                      ((ACD_BASE_ADD+0x2C)<<2)
-#define BP_GATE_VSTART_BIT             24
-#define BP_GATE_VSTART_WID             8
-#define BP_GATE_VEND_BIT               16
-#define BP_GATE_VEND_WID               8
-#define BP_GATE_HSTART_BIT             8
-#define BP_GATE_HSTART_WID             8
-#define BP_GATE_HEND_BIT               0
-#define BP_GATE_HEND_WID               8
-
-#define ACD_REG_2D                                      ((ACD_BASE_ADD+0x2D)<<2)
-#define ACD_HSTART_BIT                 16
-#define ACD_HSTART_WID                 16
-#define ACD_HEND_BIT                   0
-#define ACD_HEND_WID                   16
-
-#define ACD_REG_2E                                      ((ACD_BASE_ADD+0x2E)<<2)
-#define ACD_VSTART_BIT                 16
-#define ACD_VSTART_WID                 16
-#define ACD_VEND_BIT                   0
-#define ACD_VEND_WID                   16
-
-#define ACD_REG_2F                                      ((ACD_BASE_ADD+0x2F)<<2)
-#define VBI_ADDR_OFFSET_BIT            0
-#define VBI_ADDR_OFFSET_WID            32
-
-#define ACD_REG_30                                      ((ACD_BASE_ADD+0x30)<<2)
-#define MOTION_ADDR_OFFSET_BIT         0
-#define MOTION_ADDR_OFFSET_WID         32
-
-#define ACD_REG_31                                      ((ACD_BASE_ADD+0x31)<<2)
-#define MEM_WARNING_CLR_BIT            2
-#define MEM_WARNING_CLR_WID            1
-#define REG_AFIFO_SIZE_BIT             0
-#define REG_AFIFO_SIZE_WID             2
-
-#define ACD_REG_33                                      ((ACD_BASE_ADD+0x33)<<2)
-#define NOTCH_BW_SEL_BIT                0
-#define NOTCH_BW_SEL_WID          8
-
-#define ACD_REG_34                                      ((ACD_BASE_ADD+0x34)<<2)
-#define PK_SEARCH_EN_BIT                0
-#define PK_SEARCH_EN_WID          1
-
-#define ACD_REG_35                                      ((ACD_BASE_ADD+0x35)<<2)
-#define MAX_DAT_REPORT_BIT              0
-#define MAX_DAT_REPORT_WID        10
-
-#define ACD_REG_36                                      ((ACD_BASE_ADD+0x36)<<2)
-#define MIN_DAT_REPORT_BIT              0
-#define MIN_DAT_REPORT_WID        10
-
-#define ACD_REG_37                                      ((ACD_BASE_ADD+0x37)<<2)
-#define HIGH_THD_BIT                            0
-#define HIGH_THD_WID                      10
-
-#define ACD_REG_38                                      ((ACD_BASE_ADD+0x38)<<2)
-#define LOW_THD_BIT                            0
-#define LOW_THD_WID                      10
-
-#define ACD_REG_39                                      ((ACD_BASE_ADD+0x39)<<2)
-#define MAX_CNT_REPORT_BIT             0
-#define MAX_CNT_REPORT_WID       32
-#define ACD_REG_3A                                      ((ACD_BASE_ADD+0x3A)<<2)
-#define MIN_CNT_REPORT_BIT             0
-#define MIN_CNT_REPORT_WID       32
-
-#define ACD_REG_3B                                      ((ACD_BASE_ADD+0x3B)<<2)
-#define CLAMP_LEVEL_BIT                     0
-#define CLAMP_LEVEL_WID               10
-
-#define ACD_REG_3C                                      ((ACD_BASE_ADD+0x3C)<<2)
-#define NOISE_LINE_SEL_BIT                0
-#define NOISE_LINE_SEL_WID          10
-
-#define ACD_REG_3D                                      ((ACD_BASE_ADD+0x3D)<<2)
-#define NOISE_LEVEL_REPORT_BIT          0
-#define NOISE_LEVEL_REPORT_WID    16
-
-#define ACD_REG_3E                                      ((ACD_BASE_ADD+0x3E)<<2)
-#define DAT_SUM_REPORT_BIT              0
-#define DAT_SUM_REPORT_WID        21
-
-#define ACD_REG_3F                                      ((ACD_BASE_ADD+0x3F)<<2)
-#define DAT_MEAN_BIT                           0
-#define DAT_MEAN_WID                     10
-
-#define ACD_REG_40                                      ((ACD_BASE_ADD+0x40)<<2)
-#define DAT_START_POINT_BIT             0
-#define DAT_START_POINT_WID       11
-
-#define ACD_REG_41                                      ((ACD_BASE_ADD+0x41)<<2)
-#define DAT_END_POINT_BIT             0
-#define DAT_END_POINT_WID       11
-
-#define ACD_REG_53                                      ((ACD_BASE_ADD+0x53)<<2)
-#define K4_INPHASE2D_BIT                24
-#define K4_INPHASE2D_WID          8
-#define K3_TEXTURE3D_BIT               16
-#define K3_TEXTURE3D_WID         8
-#define K2_INPHASE3D_BIT                8
-#define K2_INPHASE3D_WID          8
-#define K1_INPHASE3D_BIT                0
-#define K1_INPHASE3D_WID          8
-
-#define ACD_REG_54                                      ((ACD_BASE_ADD+0x54)<<2)
-#define K8_OOPHASE_B_BIT               24
-#define K8_OOPHASE_B_WID         8
-#define K7_OOPHASE_N_BIT               16
-#define K7_OOPHASE_N_WID         8
-#define K6_INPHASE2D_BIT                16
-#define K6_INPHASE2D_WID          8
-#define K5_TEXTURE3D_BIT               0
-#define K5_TEXTURE3D_WID         8
-
-#define ACD_REG_55                                              ((ACD_BASE_ADD+0x55)<<2)
-#define HCFD_MTN_BIT                                        31
-#define HCFD_MTN_WID                                  1
-#define MD2_MAINPATH_MTN_EN_BIT                 30
-#define MD2_MAINPATH_MTN_EN_WID           1
-#define MD2_HCFD_TXT3D_INP2D_MIN_BIT        23
-#define MD2_HCFD_TXT3D_INP2D_MIN_WID  1
-#define MD2_INP2D_MIN_BIT                               22
-#define MD2_INP2D_MIN_WID                         1
-#define MAINPATH_MTN_TH_BIT                         12
-#define MAINPATH_MTN_TH_WID                   10
-#define HCFD_MTN_TH_BIT                                 0
-#define HCFD_MTN_TH_WID                           10
-
-#define ACD_REG_56                                      ((ACD_BASE_ADD+0x56)<<2)
-#define CDETECT_CAGC_LOOPIN2_EN_BIT             31
-#define CDETECT_CAGC_LOOPIN2_EN_WID       1
-#define CHROMA_DUALLOWPASS_MTN2_SEL_BIT  28
-#define CHROMA_DUALLOWPASS_MTN2_SEL_WID  2
-#define CHROMA_DUALLOWPASS_MTN1_SEL_BIT        26
-#define CHROMA_DUALLOWPASS_MTN1_SEL_WID  2
-#define CHROMA_DUALLOWPASS_MTN_SEL_BIT          24
-#define CHROMA_DUALLOWPASS_MTN_SEL_WID    2    
-#define HXCR_MOT_FILT_SEL_BIT                               22
-#define HXCR_MOT_FILT_SEL_WID                         2
-#define HXCR_NOMOT_FILT_SEL_BIT                          20
-#define HXCR_NOMOT_FILT_SEL_WID                    2
-#define CDETECT_CHROMA_GAIN_MAX_DEC_TC_BIT         16
-#define CDETECT_CHROMA_GAIN_MAX_DEC_TC_WID      3
-#define CDETECT_CHROMA_GAIN_MAX_DEC_VALUE_BIT         8
-#define CDETECT_CHROMA_GAIN_MAX_DEC_VALUE_WID   8    
-#define CDETECT_CHROMA_ALLOWED_MAX_BIT          0
-#define CDETECT_CHROMA_ALLOWED_MAX_WID    8
-
-#define ACD_REG_57                                          ((ACD_BASE_ADD+0x57)<<2)
-#define CONTRAST_AML_EN_BIT                 31
-#define CONTRAST_AML_EN_WID           1
-#define CONTRAST_AML_BIT                        16
-#define CONTRAST_AML_WID                  10
-#define BRIGHTNESS_AML_EN_BIT              15
-#define BRIGHTNESS_AML_EN_WID        1
-#define BRIGHTNESS_AML_BIT                     0
-#define BRIGHTNESS_AML_WID               9
-
-#define ACD_REG_58                                          ((ACD_BASE_ADD+0x58)<<2)
-#define F01234_STILL_EN_BIT                             31        
-#define F01234_STILL_EN_WID                       1
-#define MD2_MAIN_PATH_MTN_SHIFT_BIT         25
-#define MD2_MAIN_PATH_MTN_SHIFT_WID   3
-#define F4_STILL_EN_BIT                                     24
-#define F4_STILL_EN_WID                               1
-#define F3_STILL_EN_BIT                                     23
-#define F3_STILL_EN_WID                               1
-#define F2_STILL_EN_BIT                                     22
-#define F2_STILL_EN_WID                               1
-#define F1_STILL_EN_BIT                                     21
-#define F1_STILL_EN_WID                               1
-#define F0_STILL_EN_BIT                                     20
-#define F0_STILL_EN_WID                               1
-#define F4_STILL_TH_BIT                                     16
-#define F4_STILL_TH_WID                               4
-#define F3_STILL_TH_BIT                                     12
-#define F3_STILL_TH_WID                               4
-#define F2_STILL_TH_BIT                                     8
-#define F2_STILL_TH_WID                               4
-#define F1_STILL_TH_BIT                                     4
-#define F1_STILL_TH_WID                               4
-#define F0_STILL_TH_BIT                                     0
-#define F0_STILL_TH_WID                               4
-
-#define ACD_REG_59                                      ((ACD_BASE_ADD+0x59)<<2)
-#define F01234_MOV_EN_BIT                       31
-#define F01234_MOV_EN_WID                 1
-#define F4_MOV_EN_BIT                               24
-#define F4_MOV_EN_WID                         1
-#define F3_MOV_EN_BIT                               23
-#define F3_MOV_EN_WID                         1
-#define F2_MOV_EN_BIT                               22
-#define F2_MOV_EN_WID                         1
-#define F1_MOV_EN_BIT                               21
-#define F1_MOV_EN_WID                         1
-#define F0_MOV_EN_BIT                               20
-#define F0_MOV_EN_WID                         1
-#define F4_MOV_TH_BIT                               16
-#define F4_MOV_TH_WID                         4
-#define F3_MOV_TH_BIT                               12
-#define F3_MOV_TH_WID                         4
-#define F2_MOV_TH_BIT                               8
-#define F2_MOV_TH_WID                         4
-#define F1_MOV_TH_BIT                               4
-#define F1_MOV_TH_WID                         4
-#define F0_MOV_TH_BIT                               0
-#define F0_MOV_TH_WID                         4
-
-#define ACD_REG_5A                                      ((ACD_BASE_ADD+0x5A)<<2)
-#define LF_DIFF_F4_F2_TH_BIT                   16
-#define LF_DIFF_F4_F2_TH_WID             10
-#define LF_DIFF_F0_F2_TH_BIT                   0
-#define LF_DIFF_F0_F2_TH_WID             10
-
-#define ACD_REG_5B                                  ((ACD_BASE_ADD+0x5B)<<2)
-#define  REG_MIN_TXT3D_INP2D_BIT     16
-#define  REG_MIN_TXT3D_INP2D_WID    1
-#define  REG_K10_P0N_M625N_BIT         8
-#define  REG_K10_P0N_M625N_WID        8
-#define  REG_K9_P0N_P625N_BIT           0
-#define  REG_K9_P0N_P625N_WID          8
-
-
-
-#define ACD_REG_5D                                      ((ACD_BASE_ADD+0x5D)<<2)
-#define CHROMA_PEAK_TAP_SEL_BIT       0
-#define CHROMA_PEAK_TAP_SEL_WID     3
-
-#define ACD_REG_64                                      ((ACD_BASE_ADD+0x64)<<2)
-#define K4_IP_ERR_BIT                               24
-#define K4_IP_ERR_WID                         8
-#define K3_CORE_IP_BIT                            16
-#define K3_CORE_IP_WID                      8
-#define K2_LP_ERR_BIT                              8
-#define K2_LP_ERR_WID                        8
-#define K1_HP_ERR_BIT                             0
-#define K1_HP_ERR_WID                       8
-
-#define ACD_REG_65                                      ((ACD_BASE_ADD+0x65)<<2)
-#define K8_DISABLE_TB_BIT                      24
-#define K8_DISABLE_TB_WID                8
-#define K7_DISABLE_TB_BIT                      16
-#define K7_DISABLE_TB_WID                8
-#define K6_DISABLE_TB_BIT                      8
-#define K6_DISABLE_TB_WID                8
-#define K5_FC_TB_GAIN_BIT                      0
-#define K5_FC_TB_GAIN_WID                8
-
-#define ACD_REG_66                                      ((ACD_BASE_ADD+0x66)<<2)
-#define AML_2DCOMB_EN_BIT                   31
-#define AML_2DCOMB_EN_WID             1
-#define NOTCH_VCOMB_YIN_SEL_BIT      10  
-#define NOTCH_VCOMB_YIN_SEL_WID   2
-#define NOTCH_VCOMB_CIN_SEL_BIT         8  
-#define NOTCH_VCOMB_CIN_SEL_WID   2
-#define HP_IP_ERR_MIN_BIT                       7
-#define HP_IP_ERR_MIN_WID                 1
-#define AML_HDIFF_IN_SEL_BIT                 6
-#define AML_HDIFF_IN_SEL_WID           1
-#define VCOMB_IN_SEL_BIT                        4
-#define VCOMB_IN_SEL_WID                  2
-#define CORE_IP_SEL_BIT                           2
-#define CORE_IP_SEL_WID                     2
-#define HP_ERR_SEL_BIT                            0
-#define HP_ERR_SEL_WID                      2
-
-#define ACD_REG_67                                      ((ACD_BASE_ADD+0x67)<<2)
-#define FC1D_100PCT_HP_ENERGY_TH_BIT            24
-#define FC1D_100PCT_HP_ENERGY_TH_WID      8
-#define HP_CONLY_CTH_BIT                                       16
-#define HP_CONLY_CTH_WID                                 8
-#define HP_ENERGY_SMALL_TH_BIT                          8
-#define HP_ENERGY_SMALL_TH_WID                    8
-#define REG_HP_CONY_YTH_BIT                           0
-#define REG_HP_CONY_YTH_WID                         8
-#define ACD_REG_68                                      ((ACD_BASE_ADD+0x68)<<2)
-#define FC1D_100PCT_EN_BIT						31
-#define FC1D_100PCT_EN_WID					1
-#define FC2D_100PCT_PSBMB_MB_TH_BIT				20
-#define FC2D_100PCT_PSBMB_MB_TH_WID				8
-#define FC2D_100PCT_PSBMB_MB_ERR_TB_TH_BIT			8
-#define FC2D_100PCT_PSBMB_MB_ERR_TB_TH_WID		12
-#define FC_MIC_MB_TH_BIT							0
-#define FC_MIC_MB_TH_WID							8
-
-#define ACD_REG_69                                      ((ACD_BASE_ADD+0x69)<<2)
-#define DISABLE_TB_TH1_BIT						24
-#define DISABLE_TB_TH1_WID					8
-#define DISABLE_TB_TH0_BIT						16
-#define DISABLE_TB_TH0_WID					8
-#define DIS_TB_EN_BIT							13
-#define DIS_TB_EN_WID							1
-#define	FC_TB_EN_BIT							12
-#define FC_TB_EN_WID							1
-#define FC_TB_TH_BIT                 0
-#define FC_TB_TH_WID                12
-
-#define ACD_REG_6A                                      ((ACD_BASE_ADD+0x6A)<<2)
-#define DISABLE_TB_OFFSET_BIT					24
-#define DISABLE_TB_OFFSET_WID					8
-#define DISABLE_TB_TH3_BIT						12
-#define DISABLE_TB_TH3_WID					12
-#define DISABLE_TB_TH2_BIT						0
-#define DISABLE_TB_TH2_WID					12
-
-#define ACD_REG_6B                                      ((ACD_BASE_ADD+0x6B)<<2)
-#define FC_MID_TH_BIT							0
-#define FC_MID_TH_WID							12
-
-#define ACD_REG_6C                                      ((ACD_BASE_ADD+0x6C)<<2)
-#define AML_NTSC_LBUF_SEL_BIT					31
-#define AML_NTSC_LBUF_SEL_WID					1
-#define DBG_2DCOMB_OFFSET_BIT					8
-#define DBG_2DCOMB_OFFSET_WID					10
-#define AML_2DCOMB_DBG_SEL_BIT					0
-#define AML_2DCOMB_DBG_SEL_WID				8
-
-#define ACD_REG_6F                                      ((ACD_BASE_ADD+0x6F)<<2)
-#define AML_LNOTCH_EN_BIT						31
-#define AML_LNOTCH_EN_WID						1
-#define LNOTCH_SCALE_BIT						29
-#define LNOTCH_SCALE_WID						2
-#define LNOTCH_ALPHA1_BIT						12
-#define LNOTCH_ALPHA1_WID						10
-#define LNOTCH_ALPHA0_BIT						0
-#define LNOTCH_ALPHA0_WID						12
-
-#define ACD_REG_70                                      ((ACD_BASE_ADD+0x70)<<2)
-#define LNOTCH_ALPHA4_BIT						24
-#define LNOTCH_ALPHA4_WID						8
-#define LNOTCH_ALPHA3_BIT						16
-#define LNOTCH_ALPHA3_WID						8
-#define LNOTCH_ALPHA2_BIT						0
-#define LNOTCH_ALPHA2_WID						10
-
-#define ACD_REG_71                                      ((ACD_BASE_ADD+0x71)<<2)
-#define LNOTCH_ALPHA8_BIT						24
-#define LNOTCH_ALPHA8_WID						8
-#define LNOTCH_ALPHA7_BIT						16
-#define LNOTCH_ALPHA7_WID						8
-#define LNOTCH_ALPHA6_BIT						8
-#define LNOTCH_ALPHA6_WID						8
-#define LNOTCH_ALPHA5_BIT						0
-#define LNOTCH_ALPHA5_WID						8
-
-#define ACD_REG_74                                      ((ACD_BASE_ADD+0x74)<<2)
-#define WIND_COR_RATE_BIT						24
-#define WIND_COR_RATE_WID						8
-#define WIND_COR_OFST_BIT						16
-#define WIND_COR_OFST_WID						8
-#define WIND_NORM_BIT							8
-#define WIND_NORM_WID							8
-#define WIND_SIZE_BIT							0
-#define WIND_SIZE_WID							8
-
-#define ACD_REG_75                                      ((ACD_BASE_ADD+0x75)<<2)
-#define ALPHA_FORCE_MAX_BIT						31
-#define ALPHA_FORCE_MAX_WID					1
-#define ADPT_NOTCH_DELAY_BIT					8
-#define ADPT_NOTCH_DELAY_WID					11
-#define WIND_ALPHA_GAIN_BIT						0
-#define WIND_ALPHA_GAIN_WIDHT 					8
-#define ACD_REG_78                                      ((ACD_BASE_ADD+0x78)<<2)
-#define AML_2DCOMB_FULL_SIG_IP_ERR_UPLO_TH_BIT		12
-#define AML_2DCOMB_FULL_SIG_IP_ERR_UPLO_TH_WID	12
-#define AML_2DCOMB_FULL_SIG_IP_ERR_TH_BIT			0
-#define AML_2DCOMB_FULL_SIG_IP_ERR_TH_WID			12
-
-#define ACD_REG_79                                      ((ACD_BASE_ADD+0x79)<<2)
-#define AML_2DCOMB_FULL_SIG_EN_BIT					31
-#define AML_2DCOMB_FULL_SIG_EN_WID				        1
-#define AML_2DCOMB_FULL_SIG_SHIFT_BIT				28
-#define AML_2DCOMB_FULL_SIG_SHIFT_WID				3
-#define AML_2DCOMB_FULL_SIG_WIN_BIT					24
-#define AML_2DCOMB_FULL_SIG_WIN_WID				2
-#define AML_2DCOMB_FULL_SIG_LP_HTRANS_TH_BIT		12
-#define AML_2DCOMB_FULL_SIG_LP_HTRANS_TH_WID		10
-#define AML_2DCOMB_FULL_SIG_HP_ENG_TH_BIT			0
-#define AML_2DCOMB_FULL_SIG_HP_ENG_TH_WID			10
-
-#define ACD_REG_7B                                      ((ACD_BASE_ADD+0x7B)<<2)
-#define BD_VACTIVE_HEIGHT_BIT						24
-#define BD_VACTIVE_HEIGHT_WID						8
-#define BD_VACTIVE_START_BIT						16
-#define BD_VACTIVE_START_WID						8
-#define BD_BURST_GATE_END_BIT						8
-#define BD_BURST_GATE_END_WID						8
-#define BD_BURST_GATE_START_BIT						0
-#define BD_BURST_GATE_START_WID					8
-
-#define ACD_REG_7C                                      ((ACD_BASE_ADD+0x7C)<<2)
-#define HP_IIR_COEF1_BIT							12
-#define HP_IIR_COEF1_WID							12
-#define HP_IIR_COEF0_BIT							0
-#define HP_IIR_COEF0_WID							12
-
-#define ACD_REG_7D                                      ((ACD_BASE_ADD+0x7D)<<2)
-#define HP_IIR358_COEF1_BIT							12
-#define HP_IIR358_COEF1_WID						12
-#define HP_IIR358_COEF0_BIT							0
-#define HP_IIR358_COEF0_WID						12
-
-#define ACD_REG_7E                                      ((ACD_BASE_ADD+0x7E)<<2)
-#define HP_IIR425_COEF1_BIT							12
-#define HP_IIR425_COEF1_WID						12
-#define HP_IIR425_COEF0_BIT							0
-#define HP_IIR425_COEF0_WID						12
-
-#define ACD_REG_80                                      ((ACD_BASE_ADD+0x80)<<2)
-#define HP_IIR443_COEF1_BIT							12
-#define HP_IIR443_COEF1_WID						12
-#define HP_IIR443_COEF0_BIT							0
-#define HP_IIR443_COEF0_WID						12
-#define ACD_REG_81                                      ((ACD_BASE_ADD+0x81)<<2)
-#define BD_BURST_VLD_TH0_BIT						16
-#define BD_BURST_VLD_TH0_WID						16
-#define BD_BURST_VLD_TH1_BIT						0
-#define BD_BURST_VLD_TH1_WID						16
-
-#define ACD_REG_82                                      ((ACD_BASE_ADD+0x82)<<2)
-#define BD_CLEAR_SECAM_STATUS_BIT					31
-#define BD_CLEAR_SECAM_STATUS_WID					1
-#define BD_CLEAR_SECAM_VSYNC_BIT					30
-#define BD_CLEAR_SECAM_VSYNC_WID					1
-#define BD_SECAM_DETECTED_FLD_CNT_BIT				24
-#define BD_SECAM_DETECTED_FLD_CNT_WID				3
-#define BD_SECAM_CFD_LEVEL_TH_BIT					16
-#define BD_SECAM_CFD_LEVEL_TH_WID					6
-#define BD_SECAM_CFD_DEC_STEP_BIT					12
-#define BD_SECAM_CFD_DEC_STEP_WID					4
-#define BD_SECAM_CFD_INC_STEP_BIT					8
-#define BD_SECAM_CFD_INC_STEP_WID					4
-#define BD_BDDR_CFD_DEC_STEP_BIT					4
-#define BD_BDDR_CFD_DEC_STEP_WID					4
-#define BD_BDDR_CFD_INC_STEP_BIT					0
-#define BD_BDDR_CFD_INC_STEP_WID					4
-
-#define ACD_REG_83                                      ((ACD_BASE_ADD+0x83)<<2)
-#define RO_BD_ACC4XX_CNT_BIT						24
-#define RO_BD_ACC4XX_CNT_WID						8
-#define RO_BD_ACC425_CNT_BIT						16
-#define RO_BD_ACC425_CNT_WID						8
-#define RO_BD_ACC3XX_CNT_BIT						8
-#define RO_BD_ACC3XX_CNT_WID						8
-#define RO_BD_ACC358_CNT_BIT						0
-#define RO_BD_ACC358_CNT_WID						8
-
-#define ACD_REG_84                                      ((ACD_BASE_ADD+0x84)<<2)
-#define RO_DBDR_PHASE_BIT							1
-#define RO_DBDR_PHASE_WID							1
-#define RO_BD_SECAM_DETECTED_BIT					0
-#define RO_BD_SECAM_DETECTED_WID					1
-
-#define ACD_REG_85                                      ((ACD_BASE_ADD+0x85)<<2)
-#define DBDR_SLICE_VCOUNTER_BIT						14
-#define DBDR_SLICE_VCOUNTER_WID					11
-#define IIR_ROUND_BIT								12
-#define IIR_ROUND_WID								2
-#define BD_IIR_MUTE_OOBW_EN_BIT						8
-#define BD_IIR_MUTE_OOBW_EN_WID					4
-#define BD_SECAM_CFD_INC_MAX_BIT					4
-#define BD_SECAM_CFD_INC_MAX_WID					4
-#define BD_DBDR_CFD_INC_MAX_BIT						0
-#define BD_DBDR_CFD_INC_MAX_WID					4
-
-#define ACD_REG_86                                      ((ACD_BASE_ADD+0x86)<<2)
-#define CNARROW_SCALE_BIT							30
-#define CNARROW_SCALE_WID							2
-#define CNARROW_ALPHA2_BIT							20
-#define CNARROW_ALPHA2_WID						10
-#define CNARROW_ALPHA1_BIT							10
-#define CNARROW_ALPHA1_WID						10
-#define CNARROW_ALPHA0_BIT							0
-#define CNARROW_ALPHA0_WID						10
-
-#define ACD_REG_87                                      ((ACD_BASE_ADD+0x87)<<2)
-#define CNARROW_ALPHA5_BIT							20
-#define CNARROW_ALPHA5_WID						10
-#define CNARROW_ALPHA4_BIT							10
-#define CNARROW_ALPHA4_WID						10
-#define CNARROW_ALPHA3_BIT							0
-#define CNARROW_ALPHA3_WID						10
-
-#define ACD_REG_88                                      ((ACD_BASE_ADD+0x88)<<2)
-#define CNARROW_ALPHA8_BIT							20
-#define CNARROW_ALPHA8_WID						10
-#define CNARROW_ALPHA7_BIT							10
-#define CNARROW_ALPHA7_WID						10
-#define CNARROW_ALPHA6_BIT							0
-#define CNARROW_ALPHA6_WID						10
-
-#define ACD_REG_89                                      ((ACD_BASE_ADD+0x89)<<2)
-#define MD2_DOT_SUP_MODE_EN_BIT						31
-#define MD2_DOT_SUP_MODE_EN_WID					1
-#define MD2_DOT_SUP_HP_ENG_BIT						12
-#define MD2_DOT_SUP_HP_ENG_WID					10
-#define MD2_DOT_SUP_INP3D_TH_BIT					0
-#define MD2_DOT_SUP_INP3D_TH_WID					10
-
-#define ACD_REG_A3                                      ((ACD_BASE_ADD+0xA3)<<2)
-#define	DAGC_LOOPIN2_EN_BIT							31
-#define DAGC_LOOPIN2_EN_WID						1
-#define CLAMPAGC_COMPLUMA_MAX_TH_BIT				16
-#define CLAMPAGC_COMPLUMA_MAX_TH_WID				12
-#define CLAMPAGC_COMPLUMA_MIN_TH_BIT				0
-#define CLAMPAGC_COMPLUMA_MIN_TH_WID				12
-
-#define ACD_REG_A4                                      ((ACD_BASE_ADD+0xA4)<<2)
-#define CLMPAGC_COMPLUMA_MAXMIN_TC_BIT				16
-#define CLMPAGC_COMPLUMA_MAXMIN_TC_WID			3
-#define CLMPAGC_COMPLUMA_DEC_VALUE_BIT				0
-#define CLMPAGC_COMPLUMA_DEC_VALUE_WID			12
-
-//reg of acd below of here is to be reserved
-
-#define ACD_REG_1E					((ACD_BASE_ADD+0x1E)<<2)
-#define ACD_REG_32					((ACD_BASE_ADD+0x32)<<2)
-#define ACD_REG_42					((ACD_BASE_ADD+0x42)<<2)
-#define ACD_REG_43					((ACD_BASE_ADD+0x43)<<2)
-#define ACD_REG_44					((ACD_BASE_ADD+0x44)<<2)
-#define ACD_REG_45					((ACD_BASE_ADD+0x45)<<2)
-#define ACD_REG_46					((ACD_BASE_ADD+0x46)<<2)
-#define ACD_REG_47					((ACD_BASE_ADD+0x47)<<2)
-#define ACD_REG_48					((ACD_BASE_ADD+0x48)<<2)
-#define ACD_REG_49					((ACD_BASE_ADD+0x49)<<2)
-#define ACD_REG_4A					((ACD_BASE_ADD+0x4A)<<2)
-#define ACD_REG_4B					((ACD_BASE_ADD+0x4B)<<2)
-#define ACD_REG_4C					((ACD_BASE_ADD+0x4C)<<2)
-#define ACD_REG_4D					((ACD_BASE_ADD+0x4D)<<2)
-#define ACD_REG_4E					((ACD_BASE_ADD+0x4E)<<2)
-#define ACD_REG_4F					((ACD_BASE_ADD+0x4F)<<2)
-#define ACD_REG_50					((ACD_BASE_ADD+0x50)<<2)
-#define ACD_REG_51					((ACD_BASE_ADD+0x51)<<2)
-#define ACD_REG_52					((ACD_BASE_ADD+0x52)<<2)
-#define ACD_REG_5C					((ACD_BASE_ADD+0x5C)<<2)
-#define ACD_REG_5E					((ACD_BASE_ADD+0x5E)<<2)
-#define ACD_REG_5F					((ACD_BASE_ADD+0x5F)<<2)
-#define ACD_REG_60					((ACD_BASE_ADD+0x60)<<2)
-#define ACD_REG_61					((ACD_BASE_ADD+0x61)<<2)
-#define ACD_REG_62					((ACD_BASE_ADD+0x62)<<2)
-#define ACD_REG_63					((ACD_BASE_ADD+0x63)<<2)
-#define ACD_REG_6D					((ACD_BASE_ADD+0x6D)<<2)
-#define ACD_REG_6E					((ACD_BASE_ADD+0x6E)<<2)
-#define ACD_REG_72					((ACD_BASE_ADD+0x72)<<2)
-#define ACD_REG_73					((ACD_BASE_ADD+0x73)<<2)
-#define ACD_REG_76					((ACD_BASE_ADD+0x76)<<2)
-#define ACD_REG_77					((ACD_BASE_ADD+0x77)<<2)
-#define ACD_REG_7A					((ACD_BASE_ADD+0x7A)<<2)
-#define ACD_REG_7F					((ACD_BASE_ADD+0x7F)<<2)
-#define ACD_REG_8A					((ACD_BASE_ADD+0x8A)<<2)
-#define ACD_REG_8B					((ACD_BASE_ADD+0x8B)<<2)
-#define ACD_REG_8C					((ACD_BASE_ADD+0x8C)<<2)
-#define ACD_REG_8D					((ACD_BASE_ADD+0x8D)<<2)
-#define ACD_REG_8E					((ACD_BASE_ADD+0x8E)<<2)
-#define ACD_REG_8F					((ACD_BASE_ADD+0x8F)<<2)
-#define ACD_REG_90					((ACD_BASE_ADD+0x90)<<2)
-#define ACD_REG_91					((ACD_BASE_ADD+0x91)<<2)
-#define ACD_REG_92					((ACD_BASE_ADD+0x92)<<2)
-#define ACD_REG_93					((ACD_BASE_ADD+0x93)<<2)
-#define ACD_REG_94					((ACD_BASE_ADD+0x94)<<2)
-#define ACD_REG_95					((ACD_BASE_ADD+0x95)<<2)
-#define ACD_REG_96					((ACD_BASE_ADD+0x96)<<2)
-#define ACD_REG_97					((ACD_BASE_ADD+0x97)<<2)
-#define ACD_REG_98					((ACD_BASE_ADD+0x98)<<2)
-#define ACD_REG_99					((ACD_BASE_ADD+0x99)<<2)
-#define ACD_REG_9A					((ACD_BASE_ADD+0x9A)<<2)
-#define ACD_REG_9B					((ACD_BASE_ADD+0x9B)<<2)
-#define ACD_REG_9C					((ACD_BASE_ADD+0x9C)<<2)
-#define ACD_REG_9D					((ACD_BASE_ADD+0x9D)<<2)
-#define ACD_REG_9E					((ACD_BASE_ADD+0x9E)<<2)
-#define ACD_REG_9F					((ACD_BASE_ADD+0x9F)<<2)
-#define ACD_REG_A0					((ACD_BASE_ADD+0xA0)<<2)
-#define ACD_REG_A1					((ACD_BASE_ADD+0xA1)<<2)
-#define ACD_REG_A2					((ACD_BASE_ADD+0xA2)<<2)
-
-//reg of acd below of here is to be reserved
-
-
-#define ACD_REG_A5					((ACD_BASE_ADD+0xA5)<<2)
-#define ACD_REG_A6					((ACD_BASE_ADD+0xA6)<<2)
-#define ACD_REG_A7					((ACD_BASE_ADD+0xA7)<<2)
-#define ACD_REG_A8					((ACD_BASE_ADD+0xA8)<<2)
-#define ACD_REG_A9					((ACD_BASE_ADD+0xA9)<<2)
-#define ACD_REG_AA					((ACD_BASE_ADD+0xAA)<<2)
-#define ACD_REG_AB					((ACD_BASE_ADD+0xAB)<<2)
-#define ACD_REG_AC					((ACD_BASE_ADD+0xAC)<<2)
-#define ACD_REG_AD					((ACD_BASE_ADD+0xAD)<<2)
-#define ACD_REG_AE					((ACD_BASE_ADD+0xAE)<<2)
-#define ACD_REG_AF					((ACD_BASE_ADD+0xAF)<<2)
-#define ACD_REG_B0					((ACD_BASE_ADD+0xB0)<<2)
-#define ACD_REG_B1					((ACD_BASE_ADD+0xB1)<<2)
-#define ACD_REG_B2					((ACD_BASE_ADD+0xB2)<<2)
-#define ACD_REG_B3					((ACD_BASE_ADD+0xB3)<<2)
-#define ACD_REG_B4					((ACD_BASE_ADD+0xB4)<<2)
-#define ACD_REG_B5					((ACD_BASE_ADD+0xB5)<<2)
-#define ACD_REG_B6					((ACD_BASE_ADD+0xB6)<<2)
-#define ACD_REG_B7					((ACD_BASE_ADD+0xB7)<<2)
-#define ACD_REG_B8					((ACD_BASE_ADD+0xB8)<<2)
-#define ACD_REG_B9					((ACD_BASE_ADD+0xB9)<<2)
-#define ACD_REG_BA					((ACD_BASE_ADD+0xBA)<<2)
-#define ACD_REG_BB					((ACD_BASE_ADD+0xBB)<<2)
-#define ACD_REG_BC					((ACD_BASE_ADD+0xBC)<<2)
-#define ACD_REG_BD					((ACD_BASE_ADD+0xBD)<<2)
-#define ACD_REG_BE					((ACD_BASE_ADD+0xBE)<<2)
-#define ACD_REG_BF					((ACD_BASE_ADD+0xBF)<<2)
-#define ACD_REG_C0					((ACD_BASE_ADD+0xC0)<<2)
-#define ACD_REG_C1					((ACD_BASE_ADD+0xC1)<<2)
-#define ACD_REG_C2					((ACD_BASE_ADD+0xC2)<<2)
-#define ACD_REG_C3					((ACD_BASE_ADD+0xC3)<<2)
-#define ACD_REG_C4					((ACD_BASE_ADD+0xC4)<<2)
-#define ACD_REG_C5					((ACD_BASE_ADD+0xC5)<<2)
-#define ACD_REG_C6					((ACD_BASE_ADD+0xC6)<<2)
-#define ACD_REG_C7					((ACD_BASE_ADD+0xC7)<<2)
-#define ACD_REG_C8					((ACD_BASE_ADD+0xC8)<<2)
-#define ACD_REG_C9					((ACD_BASE_ADD+0xC9)<<2)
-#define ACD_REG_CA					((ACD_BASE_ADD+0xCA)<<2)
-#define ACD_REG_CB					((ACD_BASE_ADD+0xCB)<<2)
-#define ACD_REG_CC					((ACD_BASE_ADD+0xCC)<<2)
-#define ACD_REG_CD					((ACD_BASE_ADD+0xCD)<<2)
-#define ACD_REG_CE					((ACD_BASE_ADD+0xCE)<<2)
-#define ACD_REG_CF					((ACD_BASE_ADD+0xCF)<<2)
-#define ACD_REG_D0					((ACD_BASE_ADD+0xD0)<<2)
-#define ACD_REG_D1					((ACD_BASE_ADD+0xD1)<<2)
-#define ACD_REG_D2					((ACD_BASE_ADD+0xD2)<<2)
-#define ACD_REG_D3					((ACD_BASE_ADD+0xD3)<<2)
-#define ACD_REG_D4					((ACD_BASE_ADD+0xD4)<<2)
-#define ACD_REG_D5					((ACD_BASE_ADD+0xD5)<<2)
-#define ACD_REG_D6					((ACD_BASE_ADD+0xD6)<<2)
-#define ACD_REG_D7					((ACD_BASE_ADD+0xD7)<<2)
-#define ACD_REG_D8					((ACD_BASE_ADD+0xD8)<<2)
-#define ACD_REG_D9					((ACD_BASE_ADD+0xD9)<<2)
-#define ACD_REG_DA					((ACD_BASE_ADD+0xDA)<<2)
-#define ACD_REG_DB					((ACD_BASE_ADD+0xDB)<<2)
-#define ACD_REG_DC					((ACD_BASE_ADD+0xDC)<<2)
-#define ACD_REG_DD					((ACD_BASE_ADD+0xDD)<<2)
-#define ACD_REG_DE					((ACD_BASE_ADD+0xDE)<<2)
-#define ACD_REG_DF					((ACD_BASE_ADD+0xDF)<<2)
-#define ACD_REG_E0					((ACD_BASE_ADD+0xE0)<<2)
-#define ACD_REG_E1					((ACD_BASE_ADD+0xE1)<<2)
-#define ACD_REG_E2					((ACD_BASE_ADD+0xE2)<<2)
-#define ACD_REG_E3					((ACD_BASE_ADD+0xE3)<<2)
-#define ACD_REG_E4					((ACD_BASE_ADD+0xE4)<<2)
-#define ACD_REG_E5					((ACD_BASE_ADD+0xE5)<<2)
-#define ACD_REG_E6					((ACD_BASE_ADD+0xE6)<<2)
-#define ACD_REG_E7					((ACD_BASE_ADD+0xE7)<<2)
-#define ACD_REG_E8					((ACD_BASE_ADD+0xE8)<<2)
-#define ACD_REG_E9					((ACD_BASE_ADD+0xE9)<<2)
-#define ACD_REG_EA					((ACD_BASE_ADD+0xEA)<<2)
-#define ACD_REG_EB					((ACD_BASE_ADD+0xEB)<<2)
-#define ACD_REG_EC					((ACD_BASE_ADD+0xEC)<<2)
-#define ACD_REG_ED					((ACD_BASE_ADD+0xED)<<2)
-#define ACD_REG_EE					((ACD_BASE_ADD+0xEE)<<2)
-#define ACD_REG_EF					((ACD_BASE_ADD+0xEF)<<2)
-#define ACD_REG_F0					((ACD_BASE_ADD+0xF0)<<2)
-#define ACD_REG_F1					((ACD_BASE_ADD+0xF1)<<2)
-#define ACD_REG_F2					((ACD_BASE_ADD+0xF2)<<2)
-#define ACD_REG_F3					((ACD_BASE_ADD+0xF3)<<2)
-#define ACD_REG_F4					((ACD_BASE_ADD+0xF4)<<2)
-#define ACD_REG_F5					((ACD_BASE_ADD+0xF5)<<2)
-#define ACD_REG_F6					((ACD_BASE_ADD+0xF6)<<2)
-#define ACD_REG_F7					((ACD_BASE_ADD+0xF7)<<2)
-#define ACD_REG_F8					((ACD_BASE_ADD+0xF8)<<2)
-#define ACD_REG_F9					((ACD_BASE_ADD+0xF9)<<2)
-#define ACD_REG_FA					((ACD_BASE_ADD+0xFA)<<2)
-#define ACD_REG_FB					((ACD_BASE_ADD+0xFB)<<2)
-#define ACD_REG_FC					((ACD_BASE_ADD+0xFC)<<2)
-#define ACD_REG_FD					((ACD_BASE_ADD+0xFD)<<2)
-#define ACD_REG_FE					((ACD_BASE_ADD+0xFE)<<2)
-#define ACD_REG_FF					((ACD_BASE_ADD+0xFF)<<2)
-
-
-
-// ****************************************************************************
-// ******** ADC REGISTERS ********
-// ****************************************************************************
-
-#define ADC_BASE_ADD                                    0x3200//0x1A00
-
-#define ADC_REG_00                                      ((ADC_BASE_ADD+0x00)<<2)
-#define CHIPREV_BIT                    0
-#define CHIPREV_WID                    8
-
-#define ADC_REG_01                                      ((ADC_BASE_ADD+0x01)<<2)
-#define PLLDIVRATIO_MSB_BIT            0
-#define PLLDIVRATIO_MSB_WID            8
-
-#define ADC_REG_02                                      ((ADC_BASE_ADD+0x02)<<2)
-#define PLLDIVRATIO_LSB_BIT            4
-#define PLLDIVRATIO_LSB_WID            4
-
-#define ADC_REG_03                                      ((ADC_BASE_ADD+0x03)<<2)
-#define CLAMPPLACEM_BIT                0
-#define CLAMPPLACEM_WID                8
-
-#define ADC_REG_04                                      ((ADC_BASE_ADD+0x04)<<2)
-#define CLAMPDURATION_BIT              0
-#define CLAMPDURATION_WID              8
-
-#define ADC_REG_05                                      ((ADC_BASE_ADD+0x05)<<2)
-#define PGAGAIN_BIT                    0
-#define PGAGAIN_WID                    8
-
-#define ADC_REG_06                                      ((ADC_BASE_ADD+0x06)<<2)
-#define PGAMODE_BIT                    5
-#define PGAMODE_WID                    1
-#define ENPGA_BIT                      4
-#define ENPGA_WID                      1
-
-#define ADC_REG_07                                      ((ADC_BASE_ADD+0x07)<<2)
-#define ADCGAINA_BIT                   0
-#define ADCGAINA_WID                   8
-
-#define ADC_REG_08                                      ((ADC_BASE_ADD+0x08)<<2)
-#define ADCGAINB_BIT                   0
-#define ADCGAINB_WID                   8
-
-#define ADC_REG_09                                      ((ADC_BASE_ADD+0x09)<<2)
-#define ADCGAINC_BIT                   0
-#define ADCGAINC_WID                   8
-
-//#define ADC_REG_0A                                    ((ADC_BASE_ADD+0x0A)<<2)
-#define ADC_REG_0B                                      ((ADC_BASE_ADD+0x0B)<<2)
-#define ENSTCA_BIT                     7
-#define ENSTCA_WID                     1
-#define CTRCLREFA_0B_BIT               0
-#define CTRCLREFA_0B_WID               5
-
-#define ADC_REG_0C                                      ((ADC_BASE_ADD+0x0C)<<2)
-#define ENSTCB_BIT                     7
-#define ENSTCB_WID                     1
-#define CTRCLREFB_0C_BIT               0
-#define CTRCLREFB_0C_WID               5
-
-#define ADC_REG_0D                                      ((ADC_BASE_ADD+0x0D)<<2)
-#define ENSTCC_BIT                     7
-#define ENSTCC_WID                     1
-#define CTRCLREFC_0D_BIT               0
-#define CTRCLREFC_0D_WID               5
-
-//#define ADC_REG_0E                                    ((ADC_BASE_ADD+0x0E)<<2)
-#define ADC_REG_0F                                      ((ADC_BASE_ADD+0x0F)<<2)
-#define ENMRCA_BIT                     7
-#define ENMRCA_WID                     1
-#define ENBRCA_BIT                     6
-#define ENBRCA_WID                     1
-#define ENMBCA_BIT                     4
-#define ENMBCA_WID                     1
-#define CTRCLREFA_0F_BIT               2
-#define CTRCLREFA_0F_WID               2
-
-#define ADC_REG_10                                      ((ADC_BASE_ADD+0x10)<<2)
-#define ENMRCB_BIT                     7
-#define ENMRCB_WID                     1
-#define ENBRCB_BIT                     6
-#define ENBRCB_WID                     1
-#define ENMBCB_BIT                     4
-#define ENMBCB_WID                     1
-#define CTRCLREFB_10_BIT               2
-#define CTRCLREFB_10_WID               2
-
-#define ADC_REG_11                                      ((ADC_BASE_ADD+0x11)<<2)
-#define ENMRCC_BIT                     7
-#define ENMRCC_WID                     1
-#define ENBRCC_BIT                     6
-#define ENBRCC_WID                     1
-#define ENMBCC_BIT                     4
-#define ENMBCC_WID                     1
-#define CTRCLREFC_11_BIT               2
-#define CTRCLREFC_11_WID               2
-
-//#define ADC_REG_12                                    ((ADC_BASE_ADD+0x12)<<2)
-#define ADC_REG_13                                      ((ADC_BASE_ADD+0x13)<<2)
-#define ENADCA_BIT                     5
-#define ENADCA_WID                     1
-#define ENADCASTDBY_BIT                4
-#define ENADCASTDBY_WID                1
-#define STARTADCCALA_BIT               2
-#define STARTADCCALA_WID               1
-#define OEA_BIT                        1
-#define OEA_WID                        1
-#define OFCENA_BIT                     0
-#define OFCENA_WID                     1
-
-#define ADC_REG_14                                      ((ADC_BASE_ADD+0x14)<<2)
-#define ENADCB_BIT                     5
-#define ENADCB_WID                     1
-#define ENADCBSTDBY_BIT                4
-#define ENADCBSTDBY_WID                1
-#define STARTADCCALB_BIT               2
-#define STARTADCCALB_WID               1
-#define OEB_BIT                        1
-#define OEB_WID                        1
-#define OFCENB_BIT                     0
-#define OFCENB_WID                     1
-
-#define ADC_REG_15                                      ((ADC_BASE_ADD+0x15)<<2)
-#define ENVSOUT2ADC_BIT                6
-#define ENVSOUT2ADC_WID                1
-#define ENADCC_BIT                     5
-#define ENADCC_WID                     1
-#define ENADCCSTDBY_BIT                4
-#define ENADCCSTDBY_WID                1
-#define STARTADCCALC_BIT               2
-#define STARTADCCALC_WID               1
-#define OEC_BIT                        1
-#define OEC_WID                        1
-#define OFCENC_BIT                     0
-#define OFCENC_WID                     1
-
-//#define ADC_REG_16                                    ((ADC_BASE_ADD+0x16)<<2)
-#define ADC_REG_17                                      ((ADC_BASE_ADD+0x17)<<2)
-#define INMUXA_BIT                     4
-#define INMUXA_WID                     2
-#define INMUXB_BIT                     0
-#define INMUXB_WID                     3
-
-#define ADC_REG_18                                      ((ADC_BASE_ADD+0x18)<<2)
-#define INMUXC_BIT                     4
-#define INMUXC_WID                     3
-
-#define ADC_REG_19                                      ((ADC_BASE_ADD+0x19)<<2)
-#define ENLPFA_BIT                     7
-#define ENLPFA_WID                     1
-#define ANABWCTRLA_BIT                 4
-#define ANABWCTRLA_WID                 3
-#define LPFBWCTRA_BIT                  0
-#define LPFBWCTRA_WID                  4
-
-#define ADC_REG_1A                                      ((ADC_BASE_ADD+0x1A)<<2)
-#define ENLPFB_BIT                     7
-#define ENLPFB_WID                     1
-#define ANABWCTRLB_BIT                 4
-#define ANABWCTRLB_WID                 3
-#define LPFBWCTRB_BIT                  0
-#define LPFBWCTRB_WID                  4
-
-#define ADC_REG_1B                                      ((ADC_BASE_ADD+0x1B)<<2)
-#define ENLPFC_BIT                     7
-#define ENLPFC_WID                     1
-#define ANABWCTRLC_BIT                 4
-#define ANABWCTRLC_WID                 3
-#define LPFBWCTRC_BIT                  0
-#define LPFBWCTRC_WID                  4
-
-//#define ADC_REG_1C                                    ((ADC_BASE_ADD+0x1C)<<2)
-#define ADC_REG_1D                                    ((ADC_BASE_ADD+0x1D)<<2)
-#define ADC_REG_1E                                      ((ADC_BASE_ADD+0x1E)<<2)
-#define ENEXTBGAPV_BIT                 7
-#define ENEXTBGAPV_WID                 1
-#define ENIB_BIT                       5
-#define ENIB_WID                       1
-#define ENEXTBIAS_BIT                  4
-#define ENEXTBIAS_WID                  1
-#define IREFGENADJ_BIT                 0
-#define IREFGENADJ_WID                 4
-
-#define ADC_REG_1F                                      ((ADC_BASE_ADD+0x1F)<<2)
-#define ENVBG_BIT                      3
-#define ENVBG_WID                      1
-
-#define ADC_REG_20                                      ((ADC_BASE_ADD+0x20)<<2)
-#define ENSTCBUF_BIT                   6
-#define ENSTCBUF_WID                   1
-#define ENCVBSBUF_BIT                  5
-#define ENCVBSBUF_WID                  1
-#define CTRGAINCVBSBUF_BIT             4
-#define CTRGAINCVBSBUF_WID             1
-#define INMUXBUF_BIT                   0
-#define INMUXBUF_WID                   2
-
-#define ADC_REG_21                                      ((ADC_BASE_ADD+0x21)<<2)
-#define SLEEPMODE_BIT                  3
-#define SLEEPMODE_WID                  1
-#define POWERDOWNZ_BIT                 2
-#define POWERDOWNZ_WID                 1
-#define RSTDIGZ_BIT                    1
-#define RSTDIGZ_WID                    1
-#define FULLPDZ_BIT                    0
-#define FULLPDZ_WID                    1
-#define ADC_REG_22                                      ((ADC_BASE_ADD+0x22)<<2)
-#define OUTMODESEL_BIT                 6
-#define OUTMODESEL_WID                 2
-
-#define ADC_REG_23                                    ((ADC_BASE_ADD+0x23)<<2)
-#define ADC_REG_24                                      ((ADC_BASE_ADD+0x24)<<2)
-#define INMUXSOG_BIT                   0
-#define INMUXSOG_WID                   3
-
-//#define ADC_REG_25                                    ((ADC_BASE_ADD+0x25)<<2)
-#define ADC_REG_26                                      ((ADC_BASE_ADD+0x26)<<2)
-#define SOGSLCRTHRES_BIT               3
-#define SOGSLCRTHRES_WID               5
-#define SOGLPF_BIT                     0
-#define SOGLPF_WID                     3
-
-#define ADC_REG_27                                      ((ADC_BASE_ADD+0x27)<<2)
-#define SOGSLCRTHRESAUX_BIT            3
-#define SOGSLCRTHRESAUX_WID            5
-#define SOGLPFAUX_BIT                  0
-#define SOGLPFAUX_WID                  3
-
-#define ADC_REG_28                                      ((ADC_BASE_ADD+0x28)<<2)
-#define SOGBIASAUX_BIT                 6
-#define SOGBIASAUX_WID                 2
-#define SOGCLAMPAUX_BIT                4
-#define SOGCLAMPAUX_WID                2
-#define SOGBIAS_BIT                    2
-#define SOGBIAS_WID                    2
-#define SOGCLAMP_BIT                   0
-#define SOGCLAMP_WID                   2
-
-//#define ADC_REG_29                                    ((ADC_BASE_ADD+0x29)<<2)
-#define ADC_REG_2A                                      ((ADC_BASE_ADD+0x2A)<<2)
-#define SOGOFFSETAUX_BIT               4
-#define SOGOFFSETAUX_WID               3
-#define SOGOFFSET_BIT                  0
-#define SOGOFFSET_WID                  3
-
-#define ADC_REG_2B                                      ((ADC_BASE_ADD+0x2B)<<2)
-#define SOGDETAUX_BIT                  0
-#define SOGDETAUX_WID                  8
-
-//#define ADC_REG_2C                                    ((ADC_BASE_ADD+0x2C)<<2)
-//#define ADC_REG_2D                                    ((ADC_BASE_ADD+0x2D)<<2)
-#define ADC_REG_2E                                      ((ADC_BASE_ADD+0x2E)<<2)
-#define HSYNCPOLOVRD1_BIT              7
-#define HSYNCPOLOVRD1_WID              1
-#define HSYNCPOLSEL_BIT                6
-#define HSYNCPOLSEL_WID                1
-#define HSYNCOUTPOL_BIT                5
-#define HSYNCOUTPOL_WID                1
-#define HSYNCACTVOVRD_BIT              4
-#define HSYNCACTVOVRD_WID              1
-#define HSYNCACTVSEL_BIT               3
-#define HSYNCACTVSEL_WID               1
-#define VSYNCOUTPOL_BIT                2
-#define VSYNCOUTPOL_WID                1
-#define VSYNCACTVOVRD_BIT              1
-#define VSYNCACTVOVRD_WID              1
-#define VSYNCACTVSEL_BIT               0
-#define VSYNCACTVSEL_WID               1
-
-#define ADC_REG_2F                                      ((ADC_BASE_ADD+0x2F)<<2)
-#define CLAMPEXT_BIT                   7
-#define CLAMPEXT_WID                   1
-#define CLAMPPOL_BIT                   6
-#define CLAMPPOL_WID                   1
-#define COASTSEL_BIT                   5
-#define COASTSEL_WID                   1
-#define COASTPOLOVRD_BIT               4
-#define COASTPOLOVRD_WID               1
-#define COASTPOLSEL_BIT                3
-#define COASTPOLSEL_WID                1
-
-#define ADC_REG_30                                      ((ADC_BASE_ADD+0x30)<<2)
-#define HSYNCOUTWIDTH_BIT              0
-#define HSYNCOUTWIDTH_WID              8
-
-#define ADC_REG_31                                      ((ADC_BASE_ADD+0x31)<<2)
-#define SYNCSEPTHRES_BIT               0
-#define SYNCSEPTHRES_WID               8
-
-#define ADC_REG_32                                      ((ADC_BASE_ADD+0x32)<<2)
-#define PRECOAST_BIT                   0
-#define PRECOAST_WID                   8
-
-#define ADC_REG_33                                      ((ADC_BASE_ADD+0x33)<<2)
-#define POSTCOAST_BIT                  0
-#define POSTCOAST_WID                  8
-
-#define ADC_REG_34                                      ((ADC_BASE_ADD+0x34)<<2)
-#define HSYNCDET_BIT                   7
-#define HSYNCDET_WID                   1
-#define HSYNCACTV_BIT                  6
-#define HSYNCACTV_WID                  1
-#define HSYNCPOL_BIT                   5
-#define HSYNCPOL_WID                   1
-#define VSYNCDET_BIT                   4
-#define VSYNCDET_WID                   1
-#define VSYNCACTV_BIT                  3
-#define VSYNCACTV_WID                  1
-#define VSYNCPOL_BIT                   2
-#define VSYNCPOL_WID                   1
-#define SOGDET_BIT                     1
-#define SOGDET_WID                     1
-#define COASTPOL_BIT                   0
-#define COASTPOL_WID                   1
-
-#define ADC_REG_35                                      ((ADC_BASE_ADD+0x35)<<2)
-#define PLLLOCKED_BIT                  0
-#define PLLLOCKED_WID                  1
-
-#define ADC_REG_36                                      ((ADC_BASE_ADD+0x36)<<2)
-#define OSCBYPASS_BIT                  0
-#define OSCBYPASS_WID                  1
-
-//#define ADC_REG_37                                    ((ADC_BASE_ADD+0x37)<<2)
-#define ADC_REG_38                                      ((ADC_BASE_ADD+0x38)<<2)
-#define ENPLLCOASTWIN_BIT              5
-#define ENPLLCOASTWIN_WID              1
-
-#define ADC_REG_39                                      ((ADC_BASE_ADD+0x39)<<2)
-#define ENCOASTFWIDTHSEL_BIT           6
-#define ENCOASTFWIDTHSEL_WID           1
-#define INSYNCMUXCTRL_BIT              2
-#define INSYNCMUXCTRL_WID              1
-#define SYNCMUXCTRLBYPASS_BIT          1
-#define SYNCMUXCTRLBYPASS_WID          1
-#define SYNCMUXCTRL_BIT                0
-#define SYNCMUXCTRL_WID                1
-
-#define ADC_REG_3A                                      ((ADC_BASE_ADD+0x3A)<<2)
-#define ADCRDYA_BIT                    7
-#define ADCRDYA_WID                    1
-#define ADCRDYB_BIT                    6
-#define ADCRDYB_WID                    1
-#define ADCRDYC_BIT                    5
-#define ADCRDYC_WID                    1
-
-#define ADC_REG_3B                                      ((ADC_BASE_ADD+0x3B)<<2)
-#define DISCLPDRGCST_BIT               4
-#define DISCLPDRGCST_WID               1
-#define HFSMRETRY_BIT                  2
-#define HFSMRETRY_WID                  2
-
-#define ADC_REG_3C                                      ((ADC_BASE_ADD+0x3C)<<2)
-#define HSYNCFWIDTHSEL_BIT             4
-#define HSYNCFWIDTHSEL_WID             4
-#define COASTFWIDTHSEL_BIT             0
-#define COASTFWIDTHSEL_WID             4
-
-#define ADC_REG_3D                                      ((ADC_BASE_ADD+0x3D)<<2)
-#define FILTPLLHSYNC_BIT               7
-#define FILTPLLHSYNC_WID               1
-#define HSYNCLOCKWINDOW_BIT            5
-#define HSYNCLOCKWINDOW_WID            1
-
-#define ADC_REG_3E                                      ((ADC_BASE_ADD+0x3E)<<2)
-#define PREHSYNC_BIT                   0
-#define PREHSYNC_WID                   8
-
-#define ADC_REG_3F                                      ((ADC_BASE_ADD+0x3F)<<2)
-#define POSTHSYNC_BIT                  0
-#define POSTHSYNC_WID                  8
-
-//#define ADC_REG_40                                    ((ADC_BASE_ADD+0x40)<<2)
-#define ADC_REG_41                                      ((ADC_BASE_ADD+0x41)<<2)
-#define GLITCHSEL_BIT                  0
-#define GLITCHSEL_WID                  3
-
-//#define ADC_REG_42                                    ((ADC_BASE_ADD+0x42)<<2)
-#define ADC_REG_43                                      ((ADC_BASE_ADD+0x43)<<2)
-#define GLITCHBYPASS_BIT               4
-#define GLITCHBYPASS_WID               3
-
-//#define ADC_REG_44                                    ((ADC_BASE_ADD+0x44)<<2)
-//#define ADC_REG_45                                    ((ADC_BASE_ADD+0x45)<<2)
-#define ADC_REG_46                                      ((ADC_BASE_ADD+0x46)<<2)
-#define VSYNCLOCKWINDOW_BIT            2
-#define VSYNCLOCKWINDOW_WID            1
-
-#define ADC_REG_47                                      ((ADC_BASE_ADD+0x47)<<2)
-#define HSOUTDLYCTR_BIT                4
-#define HSOUTDLYCTR_WID                3
-
-//#define ADC_REG_48                                    ((ADC_BASE_ADD+0x48)<<2)
-//#define ADC_REG_49                                    ((ADC_BASE_ADD+0x49)<<2)
-//#define ADC_REG_4A                                    ((ADC_BASE_ADD+0x4A)<<2)
-//#define ADC_REG_4B                                    ((ADC_BASE_ADD+0x4B)<<2)
-//#define ADC_REG_4C                                    ((ADC_BASE_ADD+0x4C)<<2)
-//#define ADC_REG_4D                                    ((ADC_BASE_ADD+0x4D)<<2)
-//#define ADC_REG_4E                                    ((ADC_BASE_ADD+0x4E)<<2)
-//#define ADC_REG_4F                                    ((ADC_BASE_ADD+0x4F)<<2)
-//#define ADC_REG_50                                    ((ADC_BASE_ADD+0x50)<<2)
-//#define ADC_REG_51                                    ((ADC_BASE_ADD+0x51)<<2)
-//#define ADC_REG_52                                    ((ADC_BASE_ADD+0x52)<<2)
-//#define ADC_REG_53                                    ((ADC_BASE_ADD+0x53)<<2)
-//#define ADC_REG_54                                    ((ADC_BASE_ADD+0x54)<<2)
-//#define ADC_REG_55                                    ((ADC_BASE_ADD+0x55)<<2)
-#define ADC_REG_56                                      ((ADC_BASE_ADD+0x56)<<2)
-#define CLKPHASEADJ_BIT                0
-#define CLKPHASEADJ_WID                5
-
-//#define ADC_REG_57                                    ((ADC_BASE_ADD+0x57)<<2)
-#define ADC_REG_58                                      ((ADC_BASE_ADD+0x58)<<2)
-#define EXTCLKSEL_BIT                  3
-#define EXTCLKSEL_WID                  1
-#define PLLTESTMODE_BIT                0
-#define PLLTESTMODE_WID                2
-
-#define ADC_REG_59                                      ((ADC_BASE_ADD+0x59)<<2)
-#define PLLALFA_BIT                    0
-#define PLLALFA_WID                    5
-
-#define ADC_REG_5A                                      ((ADC_BASE_ADD+0x5A)<<2)
-#define PLLSEL_BIT                     5
-#define PLLSEL_WID                     1
-#define PLLBETA_BIT                    0
-#define PLLBETA_WID                    5
-
-#define ADC_REG_5B                                      ((ADC_BASE_ADD+0x5B)<<2)
-#define PLLARMENA_BIT                  7
-#define PLLARMENA_WID                  1
-#define PLLARMCNT_BIT                  5
-#define PLLARMCNT_WID                  2
-#define PLLENCTR_BIT                   0
-#define PLLENCTR_WID                   5
-
-#define ADC_REG_5C                                      ((ADC_BASE_ADD+0x5C)<<2)
-#define PLLFLOCKBW_BIT                 4
-#define PLLFLOCKBW_WID                 4
-#define ENAPLL_BIT                     3
-#define ENAPLL_WID                     1
-#define PLLFLOCKEN_BIT                 2
-#define PLLFLOCKEN_WID                 1
-#define PLLFLOCKCNT_BIT                0
-#define PLLFLOCKCNT_WID                2
-
-#define ADC_REG_5D                                      ((ADC_BASE_ADD+0x5D)<<2)
-#define PLLGAIN_BIT                    4
-#define PLLGAIN_WID                    4
-#define PLLLOCKCNTTH_BIT               0
-#define PLLLOCKCNTTH_WID               4
-
-#define ADC_REG_5E                                      ((ADC_BASE_ADD+0x5E)<<2)
-#define PLLLOCKTH_BIT                  0
-#define PLLLOCKTH_WID                  7
-
-#define ADC_REG_5F                                      ((ADC_BASE_ADD+0x5F)<<2)
-#define PLLSDDIV_BIT                   0
-#define PLLSDDIV_WID                   7
-
-#define ADC_REG_60                                      ((ADC_BASE_ADD+0x60)<<2)
-#define PLLSDRANGE_BIT                 4
-#define PLLSDRANGE_WID                 4
-#define PLLUNLOCKCNTTH_BIT             0
-#define PLLUNLOCKCNTTH_WID             4
-
-#define ADC_REG_61                                      ((ADC_BASE_ADD+0x61)<<2)
-#define PLLRANGEEXT_BIT                4
-#define PLLRANGEEXT_WID                4
-#define PLLRNGNO_BIT                   0
-#define PLLRNGNO_WID                   4
-
-#define ADC_REG_62                                      ((ADC_BASE_ADD+0x62)<<2)
-#define PLLUNLOCKTH_BIT                0
-#define PLLUNLOCKTH_WID                7
-
-#define ADC_REG_63                                      ((ADC_BASE_ADD+0x63)<<2)
-#define PLLRANGEOVR_BIT                7
-#define PLLRANGEOVR_WID                1
-#define PLLLPFOUTOVR_BIT               6
-#define PLLLPFOUTOVR_WID               1
-#define PLLVCOOUTDIVCTR_BIT            4
-#define PLLVCOOUTDIVCTR_WID            2
-#define PLLT2DSENS_BIT                 2
-#define PLLT2DSENS_WID                 2
-#define PLLIOFFSET_BIT                 0
-#define PLLIOFFSET_WID                 2
-
-#define ADC_REG_64                                      ((ADC_BASE_ADD+0x64)<<2)
-#define PLLLPFOUTEXT_MSB_BIT           0
-#define PLLLPFOUTEXT_MSB_WID           8
-
-#define ADC_REG_65                                      ((ADC_BASE_ADD+0x65)<<2)
-#define PLLLPFOUTEXT_LSB_BIT           0
-#define PLLLPFOUTEXT_LSB_WID           4
-
-#define ADC_REG_66                                      ((ADC_BASE_ADD+0x66)<<2)
-#define ADC_REG_PLLSDENA_BIT           4
-#define ADC_REG_PLLSDENA_WID           1
-
-//#define ADC_REG_67                                    ((ADC_BASE_ADD+0x67)<<2)
-#define ADC_REG_68                                      ((ADC_BASE_ADD+0x68)<<2)
-#define ENDPLL_BIT                     5
-#define ENDPLL_WID                     1
-#define PLLCMASKENZ_BIT                4
-#define PLLCMASKENZ_WID                1
-#define PLLCMASKCTR_BIT                3
-#define PLLCMASKCTR_WID                1
-#define ENPLLCOAST_BIT                 2
-#define ENPLLCOAST_WID                 1
-#define VCORANGESEL_BIT                0
-#define VCORANGESEL_WID                2
-
-#define ADC_REG_69                                      ((ADC_BASE_ADD+0x69)<<2)
-#define CHARGEPUMPCURR_BIT             4
-#define CHARGEPUMPCURR_WID             3
-#define BIASCP_BIT                     2
-#define BIASCP_WID                     2
-#define LDCOUNTER_BIT                  0
-#define LDCOUNTER_WID                  2
-
-//#define ADC_REG_6A                                    (ADC_BASE_ADD+0x6A)<<2)
-//#define ADC_REG_6B                                    (ADC_BASE_ADD+0x6B)<<2)
-//#define ADC_REG_6C                                    (ADC_BASE_ADD+0x6C)<<2)
-//#define ADC_REG_6D                                    (ADC_BASE_ADD+0x6D)<<2)
-
-// **************************************************** ************************
-// ******** TOP REGISTERS ********
-// **************************************************** ************************
-
-#define TOP_BASE_ADD                                    0x3300//0x1B00
-
-// ******** DVSS -- YPBPR & RGB *********************** ************************
-
-#define TVFE_DVSS_MUXCTRL                               ((TOP_BASE_ADD+0x00)<<2)
-#define DVSS_CLAMP_INV_BIT              31
-#define DVSS_CLAMP_INV_WID              1
-#define DVSS_COAST_INV_BIT              30
-#define DVSS_COAST_INV_WID              1
-#define CLAMP_V_EN_BIT                  29
-#define CLAMP_V_EN_WID                  1
-#define DVSS_XSYNC_GEN_EN_BIT           28
-#define DVSS_XSYNC_GEN_EN_WID           1
-#define VS_MDET_SEL_BIT                 27
-#define VS_MDET_SEL_WID                 1
-#define DVSS_COAST_EN_BIT               25
-#define DVSS_COAST_EN_WID               2
-#define DVSS_COAST_EDGE_TEST_BIT        24
-#define DVSS_COAST_EDGE_TEST_WID        1
-#define DVSS_VS_REFINE_TEST_BIT         23
-#define DVSS_VS_REFINE_TEST_WID         1
-#define DVSS_VS_OUT_SEL_BIT             21
-#define DVSS_VS_OUT_SEL_WID             2
-#define DVSS_HS_COAST_SEL_BIT           19
-#define DVSS_HS_COAST_SEL_WID           2
-#define DVSS_HS_OUT_SEL_BIT             17
-#define DVSS_HS_OUT_SEL_WID             2
-#define DVSS_TO_GEN_VS_SEL_BIT          16
-#define DVSS_TO_GEN_VS_SEL_WID          1
-#define DVSS_TO_GEN_HS_SEL_BIT          15
-#define DVSS_TO_GEN_HS_SEL_WID          1
-#define DVSS_TO_NOSIG_SEL_BIT           14
-#define DVSS_TO_NOSIG_SEL_WID           1
-#define DVSS_TO_GATE_VS_SEL_BIT         12
-#define DVSS_TO_GATE_VS_SEL_WID         2
-#define DVSS_TO_GATE_HS_SEL_BIT         10
-#define DVSS_TO_GATE_HS_SEL_WID         2
-#define DVSS_FROM_LLPLL_INV_BIT         9
-#define DVSS_FROM_LLPLL_INV_WID         1
-#define DVSS_TO_LLPLL_INV_BIT           8
-#define DVSS_TO_LLPLL_INV_WID           1
-#define DVSS_TO_LLLPLL_SEL_BIT          6
-#define DVSS_TO_LLLPLL_SEL_WID          2
-#define DVSS_RM_GLITCH_BIT              4
-#define DVSS_RM_GLITCH_WID              2
-#define DVSS_HS_IN_INV_BIT              3
-#define DVSS_HS_IN_INV_WID              1
-#define DVSS_VS_IN_INV_BIT              2
-#define DVSS_VS_IN_INV_WID              1
-#define DVSS_XSYNCH_IN_SEL_BIT          0
-#define DVSS_XSYNCH_IN_SEL_WID          2
-
-#define TVFE_DVSS_MUXVS_REF                             ((TOP_BASE_ADD+0x01)<<2)
-#define DVSS_REFINE_TH_BIT              0
-#define DVSS_REFINE_TH_WID              16
-
-#define TVFE_DVSS_MUXCOAST_V                            ((TOP_BASE_ADD+0x02)<<2)
-#define MUXCOAST_VER_ED_BIT             16
-#define MUXCOAST_VER_ED_WID             16
-#define MUXCOAST_VER_ST_BIT             0
-#define MUXCOAST_VER_ST_WID             16
-
-#define TVFE_DVSS_SEP_HVWIDTH                           ((TOP_BASE_ADD+0x03)<<2)
-#define VS_WIDTH_BIT                    16
-#define VS_WIDTH_WID                    16
-#define HS_WIDTH_BIT                    0
-#define HS_WIDTH_WID                    16
-
-#define TVFE_DVSS_SEP_HPARA                             ((TOP_BASE_ADD+0x04)<<2)
-#define HS_MSK_BIT                      16
-#define HS_MSK_WID                      16
-#define HS_GEN_PRD_BIT                  16
-#define HS_GEN_PRD_WID                  0
-
-#define TVFE_DVSS_SEP_VINTEG                            ((TOP_BASE_ADD+0x05)<<2)
-#define VS_INTEGRAL_TH2_BIT             16
-#define VS_INTEGRAL_TH2_WID             16
-#define VS_INTEGRAL_TH1_BIT             0
-#define VS_INTEGRAL_TH1_WID             16
-
-#define TVFE_DVSS_SEP_H_THR                             ((TOP_BASE_ADD+0x06)<<2)
-#define DVSS_HS_WTH2_BIT                16
-#define DVSS_HS_WTH2_WID                16
-#define DVSS_HS_WTH1_BIT                0
-#define DVSS_HS_WTH1_WID                16
-
-#define TVFE_DVSS_SEP_CTRL                              ((TOP_BASE_ADD+0x07)<<2)
-#define DVSS_VS_TEST_BIT                29
-#define DVSS_VS_TEST_WID                3
-#define DVSS_HD_BIT                     28
-#define DVSS_HD_WID                     1
-#define DVSS_SEP_RESERVED_BIT           0
-#define DVSS_SEP_RESERVED_WID           16
-
-#define TVFE_DVSS_GEN_WIDTH                             ((TOP_BASE_ADD+0x08)<<2)
-#define DVSS_GEN_VS_WIDTH_BIT           16
-#define DVSS_GEN_VS_WIDTH_WID           16
-#define DVSS_GEN_HS_WIDTH_BIT           0
-#define DVSS_GEN_HS_WIDTH_WID           16
-
-#define TVFE_DVSS_GEN_PRD                                  ((TOP_BASE_ADD+0x09)<<2)
-#define VS_GEN_PRD_BIT                  16
-#define VS_GEN_PRD_WID                  16
-#define HSYNC_GEN_PRD_BIT               0
-#define HSYNC_GEN_PRD_WID               16
-
-#define TVFE_DVSS_GEN_COAST                             ((TOP_BASE_ADD+0x0A)<<2)
-#define HSGEN_COAST_ST_BIT              16
-#define HSGEN_COAST_ST_WID              16
-#define HSGEN_COAST_ED_BIT              0
-#define HSGEN_COAST_ED_WID              16
-
-#define TVFE_DVSS_NOSIG_PARA                            ((TOP_BASE_ADD+0x0B)<<2)
-#define DVSS_HS_WIDTH_NOSIG_BIT         0
-#define DVSS_HS_WIDTH_NOSIG_WID         10
-
-#define TVFE_DVSS_NOSIG_PLS_TH                          ((TOP_BASE_ADD+0x0C)<<2)
-#define DVSS_READ_EN_BIT                31
-#define DVSS_READ_EN_WID                1
-#define INTEGRAL_STEP_NOSIG_BIT         28
-#define INTEGRAL_STEP_NOSIG_WID         2
-#define DVSS_PLS_CNT_TH2_BIT            16
-#define DVSS_PLS_CNT_TH2_WID            12
-#define DVSS_PLS_CNT_TH1_BIT            0
-#define DVSS_PLS_CNT_TH1_WID            12
-
-#define TVFE_DVSS_GATE_H                                ((TOP_BASE_ADD+0x0D)<<2)
-#define DVSS_BACKP_H_ED_BIT             16
-#define DVSS_BACKP_H_ED_WID             16
-#define DVSS_BACKP_H_ST_BIT             0
-#define DVSS_BACKP_H_ST_WID             16
-
-#define TVFE_DVSS_GATE_V                                ((TOP_BASE_ADD+0x0E)<<2)
-#define DVSS_CLAMP_V_ED_BIT             16
-#define DVSS_CLAMP_V_ED_WID             16
-#define DVSS_CLAMP_V_ST_BIT             0
-#define DVSS_CLAMP_V_ST_WID             16
-
-#define TVFE_DVSS_INDICATOR1                            ((TOP_BASE_ADD+0x0F)<<2)
-#define MVDET_BIT                       14
-#define MVDET_WID                       1
-#define HI_BIT                          13
-#define HI_WID                          1
-#define NOSIG_BIT                       12
-#define NOSIG_WID                       1
-#define PLS_NUM_BIT                     0
-#define PLS_NUM_WID                     12
-
-#define TVFE_DVSS_INDICATOR2                            ((TOP_BASE_ADD+0x10)<<2)
-#define DVSS_HITMASK_CNT_BIT            16
-#define DVSS_HITMASK_CNT_WID            16
-#define DVSS_CLK_CNT_BIT                0
-#define DVSS_CLK_CNT_WID                16
-
-// ********Freerun syn gen ****************************************************
-#define TVFE_FREERUN_GEN_WIDTH                       ((TOP_BASE_ADD+0x11)<<2)
-#define FREERUN_VSYNC_WIDTH_BIT                 16
-#define FREERUN_VSYNC_WIDTH_WID           16
-#define FREERUN_HSYNC_WIDTH_BIT                0
-#define FREERUN_HSYNC_WIDTH_WID          16
-
-#define TVFE_FREERUN_GEN_PRD                           ((TOP_BASE_ADD+0x12)<<2)
-#define FREERUN_VSYNC_PRD_BIT                 16
-#define FREERUN_VSYNC_PRD_WID           16
-#define FREERUN_HSYNC_PRD_BIT                 0
-#define FREERUN_HSYNC_PRD_WID           16    
-
-#define TVFE_FREERUN_GEN_COAST                       ((TOP_BASE_ADD+0x13)<<2)
-#define FREERUN_VSYNC_ST_BIT                 16
-#define FREERUN_VSYNC_ST_WID           16
-#define FREERUN_HSYNC_ST_BIT                 0
-#define FREERUN_HSYNC_ST_WID           16  
-
-#define TVFE_FREERUN_GEN_CTRL                          ((TOP_BASE_ADD+0x14)<<2)
-#define FREERUN_CTRL_ENABLE_BIT               0
-#define FREERUN_CTRL_ENABLE_WID         1
-
-
-// ******** MV DET -- YPBPR *************************** **********************
-
-#define TVFE_DVSS_MVDET_CTRL1                           ((TOP_BASE_ADD+0x15)<<2)
-#define MV_HS_RISING_END_BIT            16
-#define MV_HS_RISING_END_WID            16
-#define MV_HS_RISING_START_BIT          0
-#define MV_HS_RISING_START_WID          16
-
-#define TVFE_DVSS_MVDET_CTRL2                           ((TOP_BASE_ADD+0x16)<<2)
-#define MV_VEND_BIT                     16
-#define MV_VEND_WID                     16
-#define MV_VSTART_BIT                   0
-#define MV_VSTART_WID                   16
-
-#define TVFE_DVSS_MVDET_CTRL3                           ((TOP_BASE_ADD+0x17)<<2)
-#define MV_AVG_VEND_BIT                 16
-#define MV_AVG_VEND_WID                 16
-#define MV_AVG_VSTART_BIT               0
-#define MV_AVG_VSTART_WID               16
-
-#define TVFE_DVSS_MVDET_CTRL4                           ((TOP_BASE_ADD+0x18)<<2)
-#define COAST_VER_ST_BIT                16
-#define COAST_VER_ST_WID                16
-#define COAST_VER_ED_BIT                0
-#define COAST_VER_ED_WID                16
-
-#define TVFE_DVSS_MVDET_CTRL5                           ((TOP_BASE_ADD+0x19)<<2)
-#define HS_GATE_MSK_BIT                 16
-#define HS_GATE_MSK_WID                 16
-#define HS_GATE_WIDTH_BIT               0
-#define HS_GATE_WIDTH_WID               16
-
-#define TVFE_DVSS_MVDET_CTRL6                           ((TOP_BASE_ADD+0x1A)<<2)
-#define DVSS_HS_GATE_GEN_PRD_BIT        16
-#define DVSS_HS_GATE_GEN_PRD_WID        16
-#define DVSS_HS_RISING_END_BIT          0
-#define DVSS_HS_RISING_END_WID          16
-
-#define TVFE_DVSS_MVDET_CTRL7                           ((TOP_BASE_ADD+0x1B)<<2)
-#define VBI_SEL_BIT                     17
-#define VBI_SEL_WID                     1
-#define RST_BIT                         16
-#define RST_WID                         1
-#define VCENTER_BIT                     0
-#define VCENTER_WID                     16
-
-// ******** AUTO MODE AND AUTO POLARITY -- YPBP R & RGB  ***********************
-
-#define TVFE_SYNCTOP_SPOL_MUXCTRL                       ((TOP_BASE_ADD+0x20)<<2)
-#define SPOL_D_COMP_SYNCIN_BIT          26
-#define SPOL_D_COMP_SYNCIN_WID          1
-#define SMUX_SRC_SEL_BIT                23
-#define SMUX_SRC_SEL_WID                3
-#define SPOL_AUTOMODE_LN_POS_BIT        12
-#define SPOL_AUTOMODE_LN_POS_WID        11
-#define SPOL_AUTOMODE_LN_TH_BIT         4
-#define SPOL_AUTOMODE_LN_TH_WID         8
-#define SPOL_AUTOMODE_EN_BIT            3
-#define SPOL_AUTOMODE_EN_WID            1
-#define SPOL_MANNUAL_INV_VS_BIT         2
-#define SPOL_MANNUAL_INV_VS_WID         1
-#define SPOL_MANNUAL_INV_HS_BIT         1
-#define SPOL_MANNUAL_INV_HS_WID         1
-#define SPOL_AUTO_POL_BIT               0
-#define SPOL_AUTO_POL_WID               1
-
-#define TVFE_SYNCTOP_INDICATOR1_HCNT                    ((TOP_BASE_ADD+0x21)<<2)
-#define SPOL_HCNT_NEG_BIT               16
-#define SPOL_HCNT_NEG_WID               16
-#define SPOL_HCNT_POS_BIT               0
-#define SPOL_HCNT_POS_WID               16
-
-#define TVFE_SYNCTOP_INDICATOR2_VCNT                    ((TOP_BASE_ADD+0x22)<<2)
-#define SPOL_VCNT_NEG_BIT               16
-#define SPOL_VCNT_NEG_WID               16
-#define SPOL_VCNT_POS_BIT               0
-#define SPOL_VCNT_POS_WID               16
-
-#define TVFE_SYNCTOP_INDICATOR3                         ((TOP_BASE_ADD+0x23)<<2)
-#define SFG_PROGRESSIVE_BIT             2
-#define SFG_PROGRESSIVE_WID             1
-#define SPOL_V_POL_BIT                  1
-#define SPOL_V_POL_WID                  1
-#define SPOL_H_POL_BIT                  0
-#define SPOL_H_POL_WID                  1
-
-// ******** FIELD GEN -- YPBPR & RGB ********** ******* ************************
-
-#define TVFE_SYNCTOP_SFG_MUXCTRL1                       ((TOP_BASE_ADD+0x24)<<2)
-#define SFG_VS_WIDTH_BIT                28
-#define SFG_VS_WIDTH_WID                8
-#define SFG_VFILTER_EN_BIT              27
-#define SFG_VFILTER_EN_WID              1
-#define SFG_FLD_MANUAL_INV_BIT          26
-#define SFG_FLD_MANUAL_INV_WID          1
-#define SFG_FLD_AUTO_INV_BIT            25
-#define SFG_FLD_AUTO_INV_WID            1
-#define SFG_DET_EN_BIT                  24
-#define SFG_DET_EN_WID                  1
-#define SFG_DET_HEND_BIT                12
-#define SFG_DET_HEND_WID                12
-#define SFG_DET_HSTART_BIT              0
-#define SFG_DET_HSTART_WID              12
-
-#define TVFE_SYNCTOP_SFG_MUXCTRL2                       ((TOP_BASE_ADD+0x25)<<2)
-#define SFG_MANUAL_INV_VS_BIT           26
-#define SFG_MANUAL_INV_VS_WID           1
-#define SFG_MANUAL_INV_HS_BIT           25
-#define SFG_MANUAL_INV_HS_WID           1
-#define SFG_AUTO_POL_BIT                24
-#define SFG_AUTO_POL_WID                1
-#define SMUX_SP_VS_SRC_SEL_BIT          20
-#define SMUX_SP_VS_SRC_SEL_WID          8
-#define SMUX_SP_HS_SRC_SEL_BIT          16
-#define SMUX_SP_HS_SRC_SEL_WID          4
-#define SMUX_SM_VS_SRC_SEL_BIT          12
-#define SMUX_SM_VS_SRC_SEL_WID          4
-#define SMUX_SM_HS_SRC_SEL_BIT          8
-#define SMUX_SM_HS_SRC_SEL_WID          4
-#define SFG_VSIN_INV_BIT                7
-#define SFG_VSIN_INV_WID                1
-#define SFG_VSIN_SEL_BIT                4
-#define SFG_VSIN_SEL_WID                3
-#define SFG_HSIN_INV_BIT                3
-#define SFG_HSIN_INV_WID                1
-#define SFG_HSIN_SEL_BIT                0
-#define SFG_HSIN_SEL_WID                3
-
-// ******** AUTO MODE -- YPBPR & RGB ********** ******* ************************
-
-#define TVFE_SYNCTOP_INDICATOR4                         ((TOP_BASE_ADD+0x26)<<2)
-#define SAM_VCNT_BIT                    16
-#define SAM_VCNT_WID                    16
-#define SAM_HCNT_BIT                    0
-#define SAM_HCNT_WID                    16
-
-#define TVFE_SYNCTOP_SAM_MUXCTRL                        ((TOP_BASE_ADD+0x27)<<2)
-#define CSYNC_SEL_BIT                   20
-#define CSYNC_SEL_WID                   2
-#define SAM_AUTOMODE_EN_BIT             19
-#define SAM_AUTOMODE_EN_WID             1
-#define SAM_AUTOMODE_LN_POS_BIT         8
-#define SAM_AUTOMODE_LN_POS_WID         11
-#define SAM_AUTOMODE_SIG_WIDTH_BIT      0
-#define SAM_AUTOMODE_SIG_WIDTH_WID      8
-
-// ******** WSS -- YPBPR ********************** ******* ************************
-
-#define TVFE_MISC_WSS1_MUXCTRL1                         ((TOP_BASE_ADD+0x2A)<<2)
-#define WSS1_DATA_START_BIT             11
-#define WSS1_DATA_START_WID             11
-#define WSS1_LN_POS_BIT                 0
-#define WSS1_LN_POS_WID                 11
-
-#define TVFE_MISC_WSS1_MUXCTRL2                         ((TOP_BASE_ADD+0x2B)<<2)
-#define WSS1_TH_BIT                     19
-#define WSS1_TH_WID                     8
-#define WSS1_STEP_BIT                   11
-#define WSS1_STEP_WID                   8
-#define WSS1_DATA_END_BIT               0
-#define WSS1_DATA_END_WID               11
-
-#define TVFE_MISC_WSS2_MUXCTRL1                         ((TOP_BASE_ADD+0x2C)<<2)
-#define WSS2_DATA_START_BIT             11
-#define WSS2_DATA_START_WID             11
-#define WSS2_LN_POS_BIT                 0
-#define WSS2_LN_POS_WID                 11
-
-#define TVFE_MISC_WSS2_MUXCTRL2                         ((TOP_BASE_ADD+0x2D)<<2)
-#define WSS2_TH_BIT                     19
-#define WSS2_TH_WID                     8
-#define WSS2_STEP_BIT                   11
-#define WSS2_STEP_WID                   8
-#define WSS2_DATA_END_BIT               0
-#define WSS2_DATA_END_WID               11
-
-#define TVFE_MISC_WSS1_INDICATOR1                       ((TOP_BASE_ADD+0x2E)<<2)
-#define WSS1_DATA_31_0_BIT              0
-#define WSS1_DATA_31_0_WID              32
-
-#define TVFE_MISC_WSS1_INDICATOR2                       ((TOP_BASE_ADD+0x2F)<<2)
-#define WSS1_DATA_63_32_BIT             0
-#define WSS1_DATA_63_32_WID             32
-
-#define TVFE_MISC_WSS1_INDICATOR3                       ((TOP_BASE_ADD+0x30)<<2)
-#define WSS1_DATA_95_64_BIT             0
-#define WSS1_DATA_95_64_WID             32
-
-#define TVFE_MISC_WSS1_INDICATOR4                       ((TOP_BASE_ADD+0x31)<<2)
-#define WSS1_DATA_127_96_BIT            0
-#define WSS1_DATA_127_96_WID            32
-
-#define TVFE_MISC_WSS1_INDICATOR5                       ((TOP_BASE_ADD+0x32)<<2)
-#define WSS1_DATA_143_128_BIT           0
-#define WSS1_DATA_143_128_WID           16
-
-#define TVFE_MISC_WSS2_INDICATOR1                       ((TOP_BASE_ADD+0x33)<<2)
-#define WSS2_DATA_31_0_BIT              0
-#define WSS2_DATA_31_0_WID              32
-
-#define TVFE_MISC_WSS2_INDICATOR2                       ((TOP_BASE_ADD+0x34)<<2)
-#define WSS2_DATA_63_32_BIT             0
-#define WSS2_DATA_63_32_WID             32
-
-#define TVFE_MISC_WSS2_INDICATOR3                       ((TOP_BASE_ADD+0x35)<<2)
-#define WSS2_DATA_95_64_BIT             0
-#define WSS2_DATA_95_64_WID             32
-
-#define TVFE_MISC_WSS2_INDICATOR4                       ((TOP_BASE_ADD+0x36)<<2)
-#define WSS2_DATA_127_96_BIT            0
-#define WSS2_DATA_127_96_WID            32
-
-#define TVFE_MISC_WSS2_INDICATOR5                       ((TOP_BASE_ADD+0x37)<<2)
-#define WSS2_DATA_143_128_BIT           0
-#define WSS2_DATA_143_128_WID           16
-
-// ******** AUTO PHASE AND BORDER DETECTION --  RGB *** ************************
-
-#define TVFE_AP_MUXCTRL1                                ((TOP_BASE_ADD+0x39)<<2)
-#define AP_DIFFMAX_2ND_BIT              29
-#define AP_DIFFMAX_2ND_WID              1
-#define BD_DET_METHOD_BIT               28
-#define BD_DET_METHOD_WID               1
-#define BD_DET_EN_BIT                   27
-#define BD_DET_EN_WID                   1
-#define AP_SPECIFIC_POINT_OUT_BIT       26
-#define AP_SPECIFIC_POINT_OUT_WID       1
-#define AP_DIFF_SEL_BIT                 25
-#define AP_DIFF_SEL_WID                 1
-#define AUTOPHASE_EN_BIT                24
-#define AUTOPHASE_EN_WID                1
-#define AP_HEND_BIT                     12
-#define AP_HEND_WID                     12
-#define AP_HSTART_BIT                   0
-#define AP_HSTART_WID                   12
-
-#define TVFE_AP_MUXCTRL2                                ((TOP_BASE_ADD+0x3A)<<2)
-#define AP_VEND_BIT                     12
-#define AP_VEND_WID                     12
-#define AP_VSTART_BIT                   0
-#define AP_VSTART_WID                   12
-
-#define TVFE_AP_MUXCTRL3                                ((TOP_BASE_ADD+0x3B)<<2)
-#define BD_R_TH_BIT                     22
-#define BD_R_TH_WID                     10
-#define AP_SPECIFIC_MAX_HPOS_BIT        10
-#define AP_SPECIFIC_MAX_HPOS_WID        12
-#define AP_CORING_TH_BIT                0
-#define AP_CORING_TH_WID                10
-
-#define TVFE_AP_MUXCTRL4                                ((TOP_BASE_ADD+0x3C)<<2)
-#define AP_SPECIFIC_MIN_HPOS_BIT        12
-#define AP_SPECIFIC_MIN_HPOS_WID        12
-#define AP_SPECIFIC_MAX_VPOS_BIT        0
-#define AP_SPECIFIC_MAX_VPOS_WID        12
-
-#define TVFE_AP_MUXCTRL5                                ((TOP_BASE_ADD+0x3D)<<2)
-#define BD_B_TH_BIT                     22
-#define BD_B_TH_WID                     10
-#define BD_G_TH_BIT                     12
-#define BD_G_TH_WID                     10
-#define AP_SPECIFIC_MIN_VPOS_BIT        0
-#define AP_SPECIFIC_MIN_VPOS_WID        12
-
-#define TVFE_AP_INDICATOR1                              ((TOP_BASE_ADD+0x3E)<<2)
-#define AP_R_SUM_W_BIT                  0
-#define AP_R_SUM_W_WID                  32
-
-#define TVFE_AP_INDICATOR2                              ((TOP_BASE_ADD+0x3F)<<2)
-#define AP_G_SUM_W_BIT                  0
-#define AP_G_SUM_W_WID                  32
-
-#define TVFE_AP_INDICATOR3                              ((TOP_BASE_ADD+0x40)<<2)
-#define AP_B_SUM_W_BIT                  0
-#define AP_B_SUM_W_WID                  32
-
-#define TVFE_AP_INDICATOR4                              ((TOP_BASE_ADD+0x41)<<2)
-#define AP_R_MIN_BIT                    12
-#define AP_R_MIN_WID                    11
-#define AP_R_MAX_BIT                    0
-#define AP_R_MAX_WID                    11
-
-#define TVFE_AP_INDICATOR5                              ((TOP_BASE_ADD+0x42)<<2)
-#define AP_G_MIN_BIT                    12
-#define AP_G_MIN_WID                    11
-#define AP_G_MAX_BIT                    0
-#define AP_G_MAX_WID                    11
-
-#define TVFE_AP_INDICATOR6                              ((TOP_BASE_ADD+0x43)<<2)
-#define AP_B_MIN_BIT                    12
-#define AP_B_MIN_WID                    11
-#define AP_B_MAX_BIT                    0
-#define AP_B_MAX_WID                    11
-
-#define TVFE_AP_INDICATOR7                              ((TOP_BASE_ADD+0x44)<<2)
-#define AP_R_MAX_HCNT_BIT               12
-#define AP_R_MAX_HCNT_WID               12
-#define AP_R_MAX_VCNT_BIT               0
-#define AP_R_MAX_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR8                              ((TOP_BASE_ADD+0x45)<<2)
-#define AP_G_MAX_HCNT_BIT               12
-#define AP_G_MAX_HCNT_WID               12
-#define AP_G_MAX_VCNT_BIT               0
-#define AP_G_MAX_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR9                              ((TOP_BASE_ADD+0x46)<<2)
-#define AP_B_MAX_HCNT_BIT               12
-#define AP_B_MAX_HCNT_WID               12
-#define AP_B_MAX_VCNT_BIT               0
-#define AP_B_MAX_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR10                             ((TOP_BASE_ADD+0x47)<<2)
-#define AP_R_MIN_HCNT_BIT               12
-#define AP_R_MIN_HCNT_WID               12
-#define AP_R_MIN_VCNT_BIT               0
-#define AP_R_MIN_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR11                             ((TOP_BASE_ADD+0x48)<<2)
-#define AP_G_MIN_HCNT_BIT               12
-#define AP_G_MIN_HCNT_WID               12
-#define AP_G_MIN_VCNT_BIT               0
-#define AP_G_MIN_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR12                             ((TOP_BASE_ADD+0x49)<<2)
-#define AP_B_MIN_HCNT_BIT               12
-#define AP_B_MIN_HCNT_WID               12
-#define AP_B_MIN_VCNT_BIT               0
-#define AP_B_MIN_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR13                             ((TOP_BASE_ADD+0x4A)<<2)
-#define BD_R_BOT_VCNT_BIT               12
-#define BD_R_BOT_VCNT_WID               12
-#define BD_R_TOP_VCNT_BIT               0
-#define BD_R_TOP_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR14                             ((TOP_BASE_ADD+0x4B)<<2)
-#define BD_R_RIGHT_HCNT_BIT             12
-#define BD_R_RIGHT_HCNT_WID             12
-#define BD_R_LEFT_HCNT_BIT              0
-#define BD_R_LEFT_HCNT_WID              12
-
-#define TVFE_AP_INDICATOR15                             ((TOP_BASE_ADD+0x4C)<<2)
-#define BD_G_BOT_VCNT_BIT               12
-#define BD_G_BOT_VCNT_WID               12
-#define BD_G_TOP_VCNT_BIT               0
-#define BD_G_TOP_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR16                             ((TOP_BASE_ADD+0x4D)<<2)
-#define BD_G_RIGHT_HCNT_BIT             12
-#define BD_G_RIGHT_HCNT_WID             12
-#define BD_G_LEFT_HCNT_BIT              0
-#define BD_G_LEFT_HCNT_WID              12
-
-#define TVFE_AP_INDICATOR17                             ((TOP_BASE_ADD+0x4E)<<2)
-#define BD_B_BOT_VCNT_BIT               12
-#define BD_B_BOT_VCNT_WID               12
-#define BD_B_TOP_VCNT_BIT               0
-#define BD_B_TOP_VCNT_WID               12
-
-#define TVFE_AP_INDICATOR18                             ((TOP_BASE_ADD+0x4F)<<2)
-#define BD_B_RIGHT_HCNT_BIT             12
-#define BD_B_RIGHT_HCNT_WID             12
-#define BD_B_LEFT_HCNT_BIT              0
-#define BD_B_LEFT_HCNT_WID              12
-
-#define TVFE_AP_INDICATOR19                             ((TOP_BASE_ADD+0x50)<<2)
-#define GTTH_NUM_BIT                    0
-#define GTTH_NUM_WID                    12
-
-#define TVFE_BD_MUXCTRL1                                ((TOP_BASE_ADD+0x53)<<2)
-#define BD_WIN_EN_BIT                   24
-#define BD_WIN_EN_WID                   1
-#define BD_HEND_BIT                     12
-#define BD_HEND_WID                     12
-#define BD_HSTART_BIT                   0
-#define BD_HSTART_WID                   12
-
-#define TVFE_BD_MUXCTRL2                                ((TOP_BASE_ADD+0x54)<<2)
-#define BD_VEND_BIT                     12
-#define BD_VEND_WID                     12
-#define BD_VSTART_BIT                   0
-#define BD_VSTART_WID                   12
-
-#define TVFE_BD_MUXCTRL3                                ((TOP_BASE_ADD+0x55)<<2)
-#define BD_VALID_LN_EN_BIT              12
-#define BD_VALID_LN_EN_WID              1
-#define BD_VLD_LN_TH_BIT                0
-#define BD_VLD_LN_TH_WID                12
-
-#define TVFE_BD_MUXCTRL4                                ((TOP_BASE_ADD+0x56)<<2)
-#define BD_LIMITED_FLD_RECORD_BIT       5
-#define BD_LIMITED_FLD_RECORD_WID       1
-#define BD_FLD_CD_NUM_BIT               0
-#define BD_FLD_CD_NUM_WID               5
-
-// ******** CLAMPING -- YPBPR & RGB *********** ******* ************************
-
-#define TVFE_CLP_MUXCTRL1                               ((TOP_BASE_ADD+0x59)<<2)
-#define CLAMPING_LOW_EN_BIT             30
-#define CLAMPING_LOW_EN_WID             1
-#define CLAMPING_HIGH_EN_BIT            29
-#define CLAMPING_HIGH_EN_WID            1
-#define CLAMPING_DLY_BIT                18
-#define CLAMPING_DLY_WID                11
-#define CLAMPING_SCALE_BIT              14
-#define CLAMPING_SCALE_WID              4
-#define CLAMPING_UPDN_RATIO_BIT         8
-#define CLAMPING_UPDN_RATIO_WID         6
-#define CLAMPING_IIR_COEFF_BIT          0
-#define CLAMPING_IIR_COEFF_WID          4
-
-#define TVFE_CLP_MUXCTRL2                               ((TOP_BASE_ADD+0x5A)<<2)
-#define CLAMPING_PRIORITY_BIT           20
-#define CLAMPING_PRIORITY_WID           2
-#define CLAMPING_LOW_LENGTH_BIT         10
-#define CLAMPING_LOW_LENGTH_WID         10
-#define CLAMPING_HIGH_LENGTH_BIT        0
-#define CLAMPING_HIGH_LENGTH_WID        10
-
-#define TVFE_CLP_MUXCTRL3                               ((TOP_BASE_ADD+0x5B)<<2)
-#define CLAMPING_TARGET_CRR_BIT         20
-#define CLAMPING_TARGET_CRR_WID         10
-#define CLAMPING_TARGET_CBB_BIT         10
-#define CLAMPING_TARGET_CBB_WID         10
-#define CLAMPING_TARGET_YG_BIT          0
-#define CLAMPING_TARGET_YG_WID          10
-
-#define TVFE_CLP_MUXCTRL4                               ((TOP_BASE_ADD+0x5C)<<2)
-#define CLAMPING_UP_OFFSET_BIT          8
-#define CLAMPING_UP_OFFSET_WID          8
-#define CLAMPING_DN_OFFSET_BIT          0
-#define CLAMPING_DN_OFFSET_WID          8
-
-#define TVFE_CLP_INDICATOR1                             ((TOP_BASE_ADD+0x5D)<<2)
-#define IIR_RESULT_CRR_BIT              20
-#define IIR_RESULT_CRR_WID              10
-#define IIR_RESULT_CBB_BIT              10
-#define IIR_RESULT_CBB_WID              10
-#define IIR_RESULT_YG_BIT               0
-#define IIR_RESULT_YG_WID               10
-
-// ******** DVSS BPG_BACKP_GATE (BACK PORCH GAT E) -- YPBPR & RGB **************
-
-#define TVFE_BPG_BACKP_H                                ((TOP_BASE_ADD+0x61)<<2)
-#define BACKP_H_ED_BIT                  16
-#define BACKP_H_ED_WID                  16
-#define BACKP_H_ST_BIT                  0
-#define BACKP_H_ST_WID                  16
-
-#define TVFE_BPG_BACKP_V                                ((TOP_BASE_ADD+0x62)<<2)
-#define BACKP_V_ED_BIT                  16
-#define BACKP_V_ED_WID                  16
-#define BACKP_V_EN_BIT                  15
-#define BACKP_V_EN_WID                  1
-#define BACKP_V_ST_BIT                  0
-#define BACKP_V_ST_WID                  15
-
-// ******** DE GENERATION -- YPBPR & RGB ****** *********************************
-
-#define TVFE_DEG_H                                      ((TOP_BASE_ADD+0x63)<<2)
-#define DATAPROC_DLY_BIT                28
-#define DATAPROC_DLY_WID                4
-#define SYNCPROC_DLY_BIT                24
-#define SYNCPROC_DLY_WID                4
-#define DEG_HEND_BIT                    12
-#define DEG_HEND_WID                    12
-#define DEG_HSTART_BIT                  0
-#define DEG_HSTART_WID                  12
-
-#define TVFE_DEG_VODD                                   ((TOP_BASE_ADD+0x64)<<2)
-#define DEG_VEND_ODD_BIT                12
-#define DEG_VEND_ODD_WID                12
-#define DEG_VSTART_ODD_BIT              0
-#define DEG_VSTART_ODD_WID              12
-
-#define TVFE_DEG_VEVEN                                  ((TOP_BASE_ADD+0x65)<<2)
-#define DEG_VEND_EVEN_BIT               12
-#define DEG_VEND_EVEN_WID               12
-#define DEG_VSTART_EVEN_BIT             0
-#define DEG_VSTART_EVEN_WID             12
-
-// ******** OFFSET_GAIN_OFFSET -- ALL ******************************************
-
-#define TVFE_OGO_OFFSET1                                ((TOP_BASE_ADD+0x69)<<2)
-#define OGO_EN_BIT                      31
-#define OGO_EN_WID                      1
-#define OGO_UB_OFFSET1_BIT              12
-#define OGO_UB_OFFSET1_WID              11
-#define OGO_YG_OFFSET1_BIT              0
-#define OGO_YG_OFFSET1_WID              11
-
-#define TVFE_OGO_GAIN1                                  ((TOP_BASE_ADD+0x6A)<<2)
-#define OGO_UB_GAIN_BIT                 12
-#define OGO_UB_GAIN_WID                 12
-#define OGO_YG_GAIN_BIT                 0
-#define OGO_YG_GAIN_WID                 12
-
-#define TVFE_OGO_GAIN2                                  ((TOP_BASE_ADD+0x6B)<<2)
-#define OGO_VR_GAIN_BIT                 0
-#define OGO_VR_GAIN_WID                 12
-
-#define TVFE_OGO_OFFSET2                                ((TOP_BASE_ADD+0x6C)<<2)
-#define OGO_UB_OFFSET2_BIT              12
-#define OGO_UB_OFFSET2_WID              11
-#define OGO_YG_OFFSET2_BIT              0
-#define OGO_YG_OFFSET2_WID              11
-
-#define TVFE_OGO_OFFSET3                                ((TOP_BASE_ADD+0x6D)<<2)
-#define OGO_VR_OFFSET2_BIT              12
-#define OGO_VR_OFFSET2_WID              11
-#define OGO_VR_OFFSET1_BIT              0
-#define OGO_VR_OFFSET1_WID              11
-
-// ******** CI7740KN RELATED -- ALL ********************************************
-
-#define TVFE_VAFE_CTRL                                  ((TOP_BASE_ADD+0x70)<<2)
-#define VAFE_CLK_PHASE_BIT              16
-#define VAFE_CLK_PHASE_WID              5
-#define VAFE_ENGAINCAL_BIT              15
-#define VAFE_ENGAINCAL_WID              1
-#define VAFE_ENOFFSETCAL_BIT            14
-#define VAFE_ENOFFSETCAL_WID            1
-#define VAFE_SELGAINCALLVL_BIT          12
-#define VAFE_SELGAINCALLVL_WID          2
-#define VAFE_ADC_REG_ADDR_H_BIT         4
-#define VAFE_ADC_REG_ADDR_H_WID         3
-#define VAFE_HS_VS_MUX_BIT              0
-#define VAFE_HS_VS_MUX_WID              1
-
-#define TVFE_VAFE_STATUS                                ((TOP_BASE_ADD+0x71)<<2)
-#define VAFE_STATUS_PLLLOCK             4
-#define VAFE_STATUS_PLLLOCK_WID         1
-#define VAFE_HSOUT2VALID_BIT            3
-#define VAFE_HSOUT2VALID_WID            1
-#define VAFE_ADCRDYC_BIT                2
-#define VAFE_ADCRDYC_WID                1
-#define VAFE_ADCRDYB_BIT                1
-#define VAFE_ADCRDYB_WID                1
-#define VAFE_ADCRDYA_BIT                0
-#define VAFE_ADCRDYA_WID                1
-
-#define TVFE_TOP_CTRL                                   ((TOP_BASE_ADD+0x72)<<2)
-/*
-000: abc
-001: acb
-010: bac
-011: bca
-100: cab
-101: cba
- */
-#define SWT_GY_BCB_RCR_IN_BIT           28
-#define SWT_GY_BCB_RCR_IN_WID           3
-#define ADC_AUTO_CAL_MASK_BIT           27
-#define ADC_AUTO_CAL_MASK_WID           1
-#define VGA_DDC_SEL_BIT_WID             22
-#define VGA_DDC_SEL_WID                 1
-#define ABLC_ENABLE_BIT                 21
-#define ABLC_ENABLE_WID                 1
-#define DEBUG_MUX_BIT                   16
-#define DEBUG_MUX_WID                   5
-#define COMP_CLK_ENABLE_BIT             15
-#define COMP_CLK_ENABLE_WID             1
-#define DCLK_ENABLE_BIT                 14
-#define DCLK_ENABLE_WID                 1
-#define ADC_CLK_INV_BIT                 13
-#define ADC_CLK_INV_WID                 1
-#define DATACK_INV_SEL_BIT              12
-#define DATACK_INV_SEL_WID              1
-#define VAFE_MCLK_EN_BIT                11
-#define VAFE_MCLK_EN_WID                1
-#define EDID_CLK_EN_BIT                 10
-#define EDID_CLK_EN_WID                 1
-#define TVFE_ADC_CLK_DIV_BIT            8
-#define TVFE_ADC_CLK_DIV_WID            2
-#define ADC_EXT_COAST_EN_BIT            6
-#define ADC_EXT_COAST_EN_WID            1
-#define TVFE_BACKP_GATE_MUX_BIT         4
-#define TVFE_BACKP_GATE_MUX_WID         2
-#define SCAN_REG_BIT                    0
-#define SCAN_REG_WID                    1
-
-#define TVFE_CLAMP_INTF                                 ((TOP_BASE_ADD+0x73)<<2)
-#define CLAMP_EN_BIT                    15
-#define CLAMP_EN_WID                    1
-#define CLAMP_C_CURRENT_SEL_BIT         8
-#define CLAMP_C_CURRENT_SEL_WID         3
-#define CLAMP_SIGNAL_DLY_BIT            7
-#define CLAMP_SIGNAL_DLY_WID            1
-#define CLAMP_B_CURRENT_SEL_BIT         4
-#define CLAMP_B_CURRENT_SEL_WID         3
-#define CLAMP_UP_DN_SRC_BIT             3
-#define CLAMP_UP_DN_SRC_WID             1
-#define CLAMP_A_CURRENT_SEL_BIT         0
-#define CLAMP_A_CURRENT_SEL_WID         3
-
-#define TVFE_RST_CTRL                                   ((TOP_BASE_ADD+0x74)<<2)
-#define DCLK_RST_BIT                    10
-#define DCLK_RST_WID                    1
-#define SAMPLE_OUT_RST_BIT              9
-#define SAMPLE_OUT_RST_WID              1
-#define ACD_REG_INF_RST_BIT             8
-#define ACD_REG_INF_RST_WID             1
-#define CVD_REG_INF_RST_BIT             7
-#define CVD_REG_INF_RST_WID             1
-#define VAFE_REG_INF_RST_BIT            6
-#define VAFE_REG_INF_RST_WID            1
-#define EDID_RST_BIT                    5
-#define EDID_RST_WID                    1
-#define VAFE_RST_BIT                    4
-#define VAFE_RST_WID                    1
-#define ADC_CLK_RST_BIT                 3
-#define ADC_CLK_RST_WID                 1
-#define MCLK_RST_BIT                    2
-#define MCLK_RST_WID                    1
-#define AUTO_MODE_CLK_RST_BIT           1
-#define AUTO_MODE_CLK_RST_WID           1
-#define ALL_CLK_RST_BIT                 0
-#define ALL_CLK_RST_WID                 1
-
-#define TVFE_EXT_VIDEO_AFE_CTRL_MUX1                    ((TOP_BASE_ADD+0x75)<<2)
-
-// ******** EDID -- RGB ********************************************************
-
-#define TVFE_EDID_CONFIG                                ((TOP_BASE_ADD+0x7A)<<2)
-#define EDID_INT_MODE_BIT               26
-#define EDID_INT_MODE_WID               2
-#define EDID_SEGMENT_MISS_MSK_BIT       25
-#define EDID_SEGMENT_MISS_MSK_WID       1
-#define EDID_I2C_MODE_BIT               24
-#define EDID_I2C_MODE_WID               1
-#define EDID_I2C_8BIT_MODE_BIT          23
-#define EDID_I2C_8BIT_MODE_WID          1
-#define EDID_SEGMENT_INDEX_BIT          16
-#define EDID_SEGMENT_INDEX_WID          7
-#define EDID_I2C_EDDC_MODE_BIT          15
-#define EDID_I2C_EDDC_MODE_WID          1
-#define EDID_I2C_SEGMENT_ID_BIT         8
-#define EDID_I2C_SEGMENT_ID_WID         7
-#define EDID_I2C_DEV_ID_BIT             0
-#define EDID_I2C_DEV_ID_WID             7
-
-#define TVFE_EDID_RAM_ADDR                              ((TOP_BASE_ADD+0x7B)<<2)
-#define EDID_RAM_ACCESS_MODE_BIT        8
-#define EDID_RAM_ACCESS_MODE_WID        1
-#define EDID_RAM_ADDR_BIT               0
-#define EDID_RAM_ADDR_WID               8
-
-#define TVFE_EDID_RAM_WDATA                             ((TOP_BASE_ADD+0x7C)<<2)
-#define EDID_RAM_WDATA_BIT              0
-#define EDID_RAM_WDATA_WID              8
-
-#define TVFE_EDID_RAM_RDATA                             ((TOP_BASE_ADD+0x7D)<<2)
-#define EDID_I2C_ST_BIT                 25
-#define EDID_I2C_ST_WID                 3
-#define EDID_RAM_SEGMENT_ST_BIT         24
-#define EDID_RAM_SEGMENT_ST_WID         1
-#define EDID_ACCESSED_RAM_ADDR_BIT      8
-#define EDID_ACCESSED_RAM_ADDR_WID      16
-#define EDID_RAM_RDATA_BIT              0
-#define EDID_RAM_RDATA_WID              8
-
-// ******** APB BUS -- ALL *****************************************************
-
-#define TVFE_APB_ERR_CTRL_MUX1                          ((TOP_BASE_ADD+0x80)<<2)
-#define ERR_CTRL_ACD_BIT                16
-#define ERR_CTRL_ACD_WID                16
-#define ERR_CTRL_CVD_BIT                0
-#define ERR_CTRL_CVD_WID                16
-
-#define TVFE_APB_ERR_CTRL_MUX2                          ((TOP_BASE_ADD+0x81)<<2)
-#define ERR_CTRL_CVD_BIT                0
-#define ERR_CTRL_CVD_WID                16
-
-#define TVFE_APB_INDICATOR1                                  ((TOP_BASE_ADD+0x82)<<2)
-#define ERR_CNT_ACD_BIT                 12
-#define ERR_CNT_ACD_WID                 12
-#define ERR_CNT_CVD_BIT                 0
-#define ERR_CNT_CVD_WID                 12
-
-#define TVFE_APB_INDICATOR2                                 ((TOP_BASE_ADD+0x83)<<2)
-#define ERR_CNT_AFEIP_BIT               0
-#define ERR_CNT_AFEIP_WID               12
-
-// ******** ADC READBACK -- ALL ************************************************
-
-#define TVFE_ADC_READBACK_CTRL1                     ((TOP_BASE_ADD+0x84)<<2)
-#define READBACK_H_END_BIT                  16
-#define READBACK_H_END_WID            13
-#define READBACK_H_START_BIT              0
-#define READBACK_H_START_WID        13
-#define TVFE_ADC_READBACK_CTRL2                     ((TOP_BASE_ADD+0x85)<<2)
-#define READBACK_V_END_BIT                  16
-#define READBACK_V_END_WID            13
-#define READBACK_V_START_BIT              0
-#define READBACK_V_START_WID        13
-
-
-#define TVFE_ADC_READBACK_CTRL                       ((TOP_BASE_ADD+0x86)<<2)
-#define ADC_READBACK_MODE_BIT           31
-#define ADC_READBACK_MODE_WID           1
-#define ADC_READBACK_HSSEL_BIT          29
-#define ADC_READBACK_HSSEL_WID          2
-#define ADC_READBACK_HCNT_BIT           16
-#define ADC_READBACK_HCNT_WID           13
-#define ADC_READBACK_VSSEL_BIT          13
-#define ADC_READBACK_VSSEL_WID          2
-#define ADC_READBACK_VCNT_BIT           0
-#define ADC_READBACK_VCNT_WID           13
-
-#define TVFE_INT_CLR                                    ((TOP_BASE_ADD+0x8A)<<2)
-#define INT_CLR_BIT                     0
-#define INT_CLR_WID                     17
-
-#define TVFE_INT_MSKN                                   ((TOP_BASE_ADD+0x8B)<<2)
-#define INT_MSKN_BIT                    0
-#define INT_MSKN_WID                    17
-
-#define TVFE_INT_INDICATOR1                             ((TOP_BASE_ADD+0x8C)<<2)
-#define WARNING_3D_BIT                  17
-#define WARNING_3D_WID                  1
-#define VAFE_INT_INDICATOR1_PLLLOCK_BIT 16
-#define VAFE_INT_INDICATOR1_PLLLOCK_WID 1
-#define VAFE_LOST_PLLLOCK_BIT           15
-#define VAFE_LOST_PLLLOCK_WID           1
-#define CVD2_VS_BIT                     14
-#define CVD2_VS_WID                     1
-#define TVFE_VS_BIT                     13
-#define TVFE_VS_WID                     1
-#define TVFE_EDID_INT_BIT               12
-#define TVFE_EDID_INT_WID               1
-#define CVD2_LOST_EXT_LOCKED_BIT        11
-#define CVD2_LOST_EXT_LOCKED_WID        1
-#define CVD2_EXT_LOCKED_BIT             10
-#define CVD2_EXT_LOCKED_WID             1
-#define CVD2_LOST_FINE_LOCK_BIT         9
-#define CVD2_LOST_FINE_LOCK_WID         1
-#define CVD2_FINE_LOCK_BIT              8
-#define CVD2_FINE_LOCK_WID              1
-#define CVD2_LOST_CHROMA_LOCK_BIT       7
-#define CVD2_LOST_CHROMA_LOCK_WID       1
-#define CVD2_CHROMA_LOCK_BIT            6
-#define CVD2_CHROMA_LOCK_WID            1
-#define CVD2_LOST_VLOCK_BIT             5
-#define CVD2_LOST_VLOCK_WID             1
-#define CVD2_VLOCK_BIT                  4
-#define CVD2_VLOCK_WID                  1
-#define CVD2_MV_DETECTED_BIT            3
-#define CVD2_MV_DETECTED_WID            3
-#define CVD2_NO_SIGNAL_BIT              2
-#define CVD2_NO_SIGNAL_WID              1
-#define INDICATOR_DVSS_MVDET_BIT        1
-#define INDICATOR_DVSS_MVDET_WID        1
-#define INDICATOR_DVSS_NOSIG_BIT        0
-#define INDICATOR_DVSS_NOSIG_WID        1
-
-#define TVFE_INT_SET                                    ((TOP_BASE_ADD+0x8D)<<2)
-#define INT_SET_BIT                     0
-#define INT_SET_WID                     17
-
-#define TVFE_CHIP_VERSION                               ((TOP_BASE_ADD+0x90)<<2)
-
-// ********TVAFE AA FITER ********************************************************
-#define TVFE_AAFILTER_CTRL1                           ((TOP_BASE_ADD+0x91)<<2)
-#define AAFILER_BYPASS_BIT                 20
-//[20]:all [21]:bypass y[22]:bypass cb [23]:bypass cr
-#define AAFILTER_BYPASS_WID         4
-#define AAFILTER_UV_BIT                        17
-#define AAFILTER_UV_WID                  1
-#define AAFILTER_SCALE_BIT                 16
-#define AAFILTER_SCALE_WID                1
-#define AAFILTER_Y_ALPHA0_BIT           8
-#define AAFILTER_Y_ALPHA0_WID     8
-#define AAFILTER_Y_ALPHA1_BIT           0
-#define AAFILTER_Y_ALPHA1_WID     8
-
-#define TVFE_AAFILTER_CTRL2                           ((TOP_BASE_ADD+0x92)<<2)
-#define AAFILTER_Y_ALPHA2_BIT           24
-#define AAFILTER_Y_ALPHA2_WID     8
-#define AAFILTER_Y_ALPHA3_BIT           16
-#define AAFILTER_Y_ALPHA3_WID     8
-#define AAFILTER_Y_ALPHA4_BIT           8
-#define AAFILTER_Y_ALPHA4_WID     8
-#define AAFILTER_Y_ALPHA5_BIT           0
-#define AAFILTER_Y_ALPHA5_WID     8
-
-#define TVFE_AAFILTER_CTRL3                           ((TOP_BASE_ADD+0x93)<<2)
-#define AAFILTER_CB_ALPHA0_BIT           24
-#define AAFILTER_CB_ALPHA0_WID     8
-#define AAFILTER_CB_ALPHA1_BIT           16
-#define AAFILTER_CB_ALPHA1_WID     8
-#define AAFILTER_CB_ALPHA2_BIT           8
-#define AAFILTER_CB_ALPHA2_WID     8
-#define AAFILTER_CB_ALPHA3_BIT           0
-#define AAFILTER_CB_ALPHA3_WID     8
-
-#define TVFE_AAFILTER_CTRL4                          ((TOP_BASE_ADD+0x94)<<2)
-#define AAFILTER_CB_ALPHA4_BIT           24
-#define AAFILTER_CB_ALPHA4_WID     8
-#define AAFILTER_CB_ALPHA5_BIT           16
-#define AAFILTER_CB_ALPHA5_WID     8
-#define AAFILTER_CR_ALPHA0_BIT           8
-#define AAFILTER_CR_ALPHA0_WID     8
-#define AAFILTER_CR_ALPHA1_BIT           0
-#define AAFILTER_CR_ALPHA1_WID     8
-
-#define TVFE_AAFILTER_CTRL5                          ((TOP_BASE_ADD+0x95)<<2)
-#define AAFILTER_CR_ALPHA2_BIT           24
-#define AAFILTER_CR_ALPHA2_WID     8
-#define AAFILTER_CR_ALPHA3_BIT           16
-#define AAFILTER_CR_ALPHA3_WID     8
-#define AAFILTER_CR_ALPHA4_BIT           8
-#define AAFILTER_CR_ALPHA4_WID     8
-#define AAFILTER_CR_ALPHA5_BIT           0
-#define AAFILTER_CR_ALPHA5_WID     8
-
-//*************TVFE_SOG_MON***************************************************
-#define TVFE_SOG_MON_CTRL1                           ((TOP_BASE_ADD+0x96)<<2)
-#define SOGTOP_AUTO_ENABLE_BIT          31
-#define SOGTOP_AUTO_ENABLE_WID    1
-#define SOGTOP_INV_MASK_BIT                  30
-#define SOGTOP_INV_MASK_WID            1
-#define SOGTOP_INV_SOG_BIT                    29
-#define SOGTOP_INV_SOG_WID              1
-#define SOGTOP_AUTO_LCNT_BIT               8
-#define SOGTOP_AUTO_LCNT_WID         12
-#define SOGTOP_MASK_EN_BIT                  7
-#define SOGTOP_MASK_EN_WID            1
-#define SOGTOP_MASK_FMAT_BIT             4
-#define SOGTOP_MASK_FMAT_WID       3
-#define SOGTOP_VSYNC_SLE_BIT              2
-#define SOGTOP_VSYNC_SLE_WID        2
-#define SOGTOP_MASK_SEL_BIT                0
-#define SOGTOP_MASK_SEL_WID          2
-
-#define TVFE_SOG_MON_INDICATOR1                ((TOP_BASE_ADD+0x97)<<2)
-#define SOG_CNT_NEG_BIT                         16
-#define SOG_CNT_NEG_WID                   16
-#define SOG_CNT_POS_BIT                         0
-#define SOG_CNT_POS_WID                   16
-
-#define TVFE_SOG_MON_INDICATOR2                ((TOP_BASE_ADD+0x98)<<2)
-#define SOG_VTOTAL_BIT                         0
-#define SOG_VTOTAL_WID                   16
-// ********TVFE_READBACK_INDICATOR*********************************************
-#define TVFE_ADC_READBACK_INDICATOR             ((TOP_BASE_ADD+0x9A)<<2)
-#define ADC_READBACK_DA_BIT               20
-#define ADC_READBACK_DA_WID               10
-#define ADC_READBACK_DB_BIT               10
-#define ADC_READBACK_DB_WID               10
-#define ADC_READBACK_DC_BIT                0
-#define ADC_READBACK_DC_WID               10
-
-#define TVFE_READBACK_INDICATOR1                ((TOP_BASE_ADD+0x9B)<<2)
-#define INDICATOR_RB_DA_AREA_BIT               0
-#define INDICATOR_RB_DA_AREA_WID         32
-
-#define TVFE_READBACK_INDICATOR2                ((TOP_BASE_ADD+0x9C)<<2)
-#define INDICATOR_RB_DB_AREA_BIT               0
-#define INDICATOR_RB_DB_AREA_WID         32
-
-#define TVFE_READBACK_INDICATOR3                ((TOP_BASE_ADD+0x9D)<<2)
-#define INDICATOR_RB_DC_AREA_BIT               0
-#define INDICATOR_RB_DC_AREA_WID         32
-// ********CVBS AA FITER SIGNAL***************************************************
-#define TVFE_AFC_CTRL1                                       ((TOP_BASE_ADD+0xA0)<<2)
-#define AFC_EN_BIT                                              31
-#define AFC_EN_WID                                        1
-#define AFC_BYPASS_BIT                                     30
-#define AFC_BYPASS_WID                               1
-#define AFC_CDELAY_BIT                                     29
-#define AFC_CDELAY_WID                               1
-#define AFC_YC_ALHPA0_BIT                               16
-#define AFC_YC_ALHPA0_WID                         12
-#define AFC_YC_ALHPA1_BIT                               0
-#define AFC_YC_ALHPA1_WID                         12
-
-#define TVFE_AFC_CTRL2                                       ((TOP_BASE_ADD+0xA1)<<2)
-#define AFC_YC_ALHPA4_BIT                               20
-#define AFC_YC_ALHPA4_WID                         10
-#define AFC_YC_ALHPA3_BIT                               10
-#define AFC_YC_ALHPA3_WID                         10
-#define AFC_YC_ALHPA2_BIT                               0
-#define AFC_YC_ALHPA2_WID                         10
-
-#define TVFE_AFC_CTRL3                                       ((TOP_BASE_ADD+0xA2)<<2)
-#define AFC_YC_ALHPA7_BIT                               20
-#define AFC_YC_ALHPA7_WID                         8
-#define AFC_YC_ALHPA6_BIT                               10
-#define AFC_YC_ALHPA6_WID                         10
-#define AFC_YC_ALHPA5_BIT                               0
-#define AFC_YC_ALHPA5_WID                         10
-
-#define TVFE_AFC_CTRL4                                       ((TOP_BASE_ADD+0xA3)<<2)
-#define AFC_YC_ALHPA11_BIT                           24
-#define AFC_YC_ALHPA11_WID                     8
-#define AFC_YC_ALHPA10_BIT                           16
-#define AFC_YC_ALHPA10_WID                     8
-#define AFC_YC_ALHPA9_BIT                         8
-#define AFC_YC_ALHPA9_WID                   8
-#define AFC_YC_ALHPA8_BIT                         0
-#define AFC_YC_ALHPA8_WID                   8
-
-#define TVFE_AFC_CTRL5                                       ((TOP_BASE_ADD+0xA4)<<2)
-#define AFC_VDELAY_BIT                               10
-#define AFC_VDELAY_WID                         2
-#define AFC_UDELAY_BIT                               8
-#define AFC_UDELAY_WID                         2
-#define AFC_YC_ALHPA12_BIT                       0
-#define AFC_YC_ALHPA12_WID                 8
-
-
-// **************************************************** *************************
-// ******** CVD2 REGISTERS ********
-// **************************************************** *************************
-
-#define CVD_BASE_ADD                                    0x3000//0x1800
-
-#define CVD2_CONTROL0                                   ((CVD_BASE_ADD+0x00)<<2)
-#define HV_DLY_BIT                      7
-#define HV_DLY_WID                      1
-#define HPIXEL_BIT                      5
-#define HPIXEL_WID                      2
-#define VLINE_625_BIT                   4
-#define VLINE_625_WID                   1
-#define COLOUR_MODE_BIT                 1
-#define COLOUR_MODE_WID                 3
-#define YC_SRC_BIT                      0
-#define YC_SRC_WID                      1
-
-#define CVD2_CONTROL1                                   ((CVD_BASE_ADD+0x01)<<2)
-#define CV_INV_BIT                      7
-#define CV_INV_WID                      1
-#define CV_SRC_BIT                      6
-#define CV_SRC_WID                      1
-#define LUMA_NOTCH_BW_BIT               4
-#define LUMA_NOTCH_BW_WID               2
-#define CHROMA_BW_LO_BIT                2
-#define CHROMA_BW_LO_WID                2
-#define CHROMA_BURST5OR10_BIT           1
-#define CHROMA_BURST5OR10_WID           1
-#define PED_BIT                         0
-#define PED_WID                         1
-
-#define CVD2_CONTROL2                                   ((CVD_BASE_ADD+0x02)<<2)
-#define HAGC_FLD_MODE_BIT               7
-#define HAGC_FLD_MODE_WID               1
-#define MV_HAGC_MODE_BIT                6
-#define MV_HAGC_MODE_WID                1
-#define DC_CLAMP_MODE_BIT               4
-#define DC_CLAMP_MODE_WID               2
-#define DAGC_EN_BIT                     3
-#define DAGC_EN_WID                     1
-#define AGC_HALF_EN_BIT                 2
-#define AGC_HALF_EN_WID                 1
-#define CAGC_EN_BIT                     1
-#define CAGC_EN_WID                     1
-#define HAGC_EN_BIT                     0
-#define HAGC_EN_WID                     1
-
-#define CVD2_YC_SEPARATION_CONTROL                      ((CVD_BASE_ADD+0x03)<<2)
-#define NTSC443_3DMODE_BIT              7
-#define NTSC443_3DMODE_WID              1
-#define ADAPTIVE_3DMODE_BIT             4
-#define ADAPTIVE_3DMODE_WID             3
-#define COLOUR_TRAP_BIT                 3
-#define COLOUR_TRAP_WID                 1
-#define ADAPTIVE_MODE_BIT               0
-#define ADAPTIVE_MODE_WID               3
-
-#define CVD2_LUMA_AGC_VALUE                             ((CVD_BASE_ADD+0x04)<<2)
-#define HAGC_BIT                        0
-#define HAGC_WID                        8
-
-#define CVD2_NOISE_THRESHOLD                            ((CVD_BASE_ADD+0x05)<<2)
-#define NOISE_TH_BIT                    0
-#define NOISE_TH_WID                    8
-
-#define CVD2_REG_06                                     ((CVD_BASE_ADD+0x06)<<2)
-#define ADC_UPDN_SWAP_BIT               7
-#define ADC_UPDN_SWAP_WID               1
-#define ADC_IN_SWAP_BIT                 6
-#define ADC_IN_SWAP_WID                 1
-#define FORCE_VCR_EN_BIT                4
-#define FORCE_VCR_EN_WID                1
-#define FORCE_VCR_REW_BIT               3
-#define FORCE_VCR_REW_WID               1
-#define FORCE_VCR_FF_BIT                2
-#define FORCE_VCR_FF_WID                1
-#define FORCE_VCR_TRICK_BIT             1
-#define FORCE_VCR_TRICK_WID             1
-#define FORCE_VCR_BIT                   0
-#define FORCE_VCR_WID                   1
-
-#define CVD2_OUTPUT_CONTROL                             ((CVD_BASE_ADD+0x07)<<2)
-#define CCIR656_EN_BIT                  7
-#define CCIR656_EN_WID                  1
-#define CBCR_SWAP_BIT                   6
-#define CBCR_SWAP_WID                   1
-#define BLUE_MODE_BIT                   4
-#define BLUE_MODE_WID                   2
-#define YC_DLY_BIT                      0
-#define YC_DLY_WID                      4
-
-#define CVD2_LUMA_CONTRAST_ADJUSTMENT                   ((CVD_BASE_ADD+0x08)<<2)
-#define CONTRAST_BIT                    0
-#define CONTRAST_WID                    8
-
-#define CVD2_LUMA_BRIGHTNESS_ADJUSTMENT                 ((CVD_BASE_ADD+0x09)<<2)
-#define BRIGHTNESS_BIT                  0
-#define BRIGHTNESS_WID                  8
-
-#define CVD2_CHROMA_SATURATION_ADJUSTMENT               ((CVD_BASE_ADD+0x0A)<<2)
-#define SATURATION_BIT                  0
-#define SATURATION_WID                  8
-
-#define CVD2_CHROMA_HUE_PHASE_ADJUSTMENT                ((CVD_BASE_ADD+0x0B)<<2)
-#define HUE_BIT                         0
-#define HUE_WID                         8
-
-#define CVD2_CHROMA_AGC                                 ((CVD_BASE_ADD+0x0C)<<2)
-#define CAGC_BIT                        0
-#define CAGC_WID                        8
-
-#define CVD2_CHROMA_KILL                                ((CVD_BASE_ADD+0x0D)<<2)
-#define USER_CKILL_MODE_BIT             6
-#define USER_CKILL_MODE_WID             2
-#define VBI_CKILL_BIT                   5
-#define VBI_CKILL_WID                   1
-#define HLOCK_CKILL_BIT                 4
-#define HLOCK_CKILL_WID                 1
-#define PAL60_MODE_BIT                  0
-#define PAL60_MODE_WID                  1
-
-#define CVD2_NON_STANDARD_SIGNAL_THRESHOLD              ((CVD_BASE_ADD+0x0E)<<2)
-#define VNON_STD_TH_BIT                 6
-#define VNON_STD_TH_WID                 2
-#define HNON_STD_TH_BIT                 0
-#define HNON_STD_TH_WID                 6
-
-#define CVD2_CONTROL0F                                  ((CVD_BASE_ADD+0x0F)<<2)
-#define NSTD_HYSIS_BIT                  6
-#define NSTD_HYSIS_WID                  2
-#define DISABLE_CLAMP_ON_VS_BIT         5
-#define DISABLE_CLAMP_ON_VS_WID         1
-#define BYPASS_BIT                      4
-#define BYPASS_WID                      1
-#define NOBURST_CKILL_BIT               0
-#define NOBURST_CKILL_WID               1
-
-#define CVD2_AGC_PEAK_NOMINAL                           ((CVD_BASE_ADD+0x10)<<2)
-#define AGC_PEAK_NOMINAL_BIT            0
-#define AGC_PEAK_NOMINAL_WID            7
-
-#define CVD2_AGC_PEAK_AND_GATE_CONTROLS                 ((CVD_BASE_ADD+0x11)<<2)
-#define AGC_PEAK_EN_BIT                 3
-#define AGC_PEAK_EN_WID                 1
-#define AGC_PEAK_CNTL_BIT               0
-#define AGC_PEAK_CNTL_WID               3
-
-#define CVD2_BLUE_SCREEN_Y                              ((CVD_BASE_ADD+0x12)<<2)
-#define BLUE_SCREEN_Y_BIT               0
-#define BLUE_SCREEN_Y_WID               8
-
-#define CVD2_BLUE_SCREEN_CB                             ((CVD_BASE_ADD+0x13)<<2)
-#define BLUE_SCREEN_CB_BIT              0
-#define BLUE_SCREEN_CB_WID              8
-
-#define CVD2_BLUE_SCREEN_CR                             ((CVD_BASE_ADD+0x14)<<2)
-#define BLUE_SCREEN_CR_BIT              0
-#define BLUE_SCREEN_CR_WID              8
-
-#define CVD2_HDETECT_CLAMP_LEVEL                        ((CVD_BASE_ADD+0x15)<<2)
-#define HDETECT_CLAMP_LVL_BIT           0
-#define HDETECT_CLAMP_LVL_WID           8
-
-#define CVD2_LOCK_COUNT                                 ((CVD_BASE_ADD+0x16)<<2)
-#define HLOCK_CNT_NOISY_MAX_BIT         4
-#define HLOCK_CNT_NOISY_MAX_WID         4
-#define HLOCK_CNT_CLEAN_MAX_BIT         0
-#define HLOCK_CNT_CLEAN_MAX_WID         4
-
-#define CVD2_H_LOOP_MAXSTATE                            ((CVD_BASE_ADD+0x17)<<2)
-#define HLOCK_VS_MODE_BIT               6
-#define HLOCK_VS_MODE_WID               2
-#define HSTATE_FIXED_BIT                5
-#define HSTATE_FIXED_WID                1
-#define DISABLE_HFINE_BIT               4
-#define DISABLE_HFINE_WID               1
-#define HSTATE_UNLOCKED_BIT             3
-#define HSTATE_UNLOCKED_WID             1
-#define HSTATE_MAX_BIT                  0
-#define HSTATE_MAX_WID                  3
-
-#define CVD2_CHROMA_DTO_INCREMENT_29_24                 ((CVD_BASE_ADD+0x18)<<2)
-#define CDTO_INC_29_24_BIT              0
-#define CDTO_INC_29_24_WID              6
-
-#define CVD2_CHROMA_DTO_INCREMENT_23_16                 ((CVD_BASE_ADD+0x19)<<2)
-#define CDTO_INC_23_16_BIT              0
-#define CDTO_INC_23_16_WID              8
-
-#define CVD2_CHROMA_DTO_INCREMENT_15_8                  ((CVD_BASE_ADD+0x1A)<<2)
-#define CDTO_INC_15_8_BIT               0
-#define CDTO_INC_15_8_WID               8
-
-#define CVD2_CHROMA_DTO_INCREMENT_7_0                   ((CVD_BASE_ADD+0x1B)<<2)
-#define CDTO_INC_7_0_BIT                0
-#define CDTO_INC_7_0_WID                8
-
-#define CVD2_HSYNC_DTO_INCREMENT_31_24                  ((CVD_BASE_ADD+0x1C)<<2)
-#define HDTO_INC_31_24_BIT              0
-#define HDTO_INC_31_24_WID              8
-
-#define CVD2_HSYNC_DTO_INCREMENT_23_16                  ((CVD_BASE_ADD+0x1D)<<2)
-#define HDTO_INC_23_16_BIT              0
-#define HDTO_INC_23_16_WID              8
-
-#define CVD2_HSYNC_DTO_INCREMENT_15_8                   ((CVD_BASE_ADD+0x1E)<<2)
-#define HDTO_INC_15_8_BIT               0
-#define HDTO_INC_15_8_WID               8
-
-#define CVD2_HSYNC_DTO_INCREMENT_7_0                    ((CVD_BASE_ADD+0x1F)<<2)
-#define HDTO_INC_7_0_BIT                0
-#define HDTO_INC_7_0_WID                8
-
-#define CVD2_HSYNC_RISING_EDGE                          ((CVD_BASE_ADD+0x20)<<2)
-#define HS_RISING_BIT                   0
-#define HS_RISING_WID                   8
-
-#define CVD2_HSYNC_PHASE_OFFSET                         ((CVD_BASE_ADD+0x21)<<2)
-#define HS_PHASE_OFFSET_BIT             0
-#define HS_PHASE_OFFSET_WID             8
-
-#define CVD2_HSYNC_DETECT_WINDOW_START                  ((CVD_BASE_ADD+0x22)<<2)
-#define HS_GATE_START_BIT               0
-#define HS_GATE_START_WID               8
-
-#define CVD2_HSYNC_DETECT_WINDOW_END                    ((CVD_BASE_ADD+0x23)<<2)
-#define HS_GATE_END_BIT                 0
-#define HS_GATE_END_WID                 8
-
-#define CVD2_CLAMPAGC_CONTROL                           ((CVD_BASE_ADD+0x24)<<2)
-#define HS_SIMILAR_BIT                  7
-#define HS_SIMILAR_WID                  1
-#define HS_LOW_BIT                      6
-#define HS_LOW_WID                      1
-#define HDETECT_NOISE_EN_BIT            5
-#define HDETECT_NOISE_EN_WID            1
-#define HFINE_LT_COARSE_BIT             4
-#define HFINE_LT_COARSE_WID             1
-#define HLPF_CLAMP_SEL_BIT              3
-#define HLPF_CLAMP_SEL_WID              1
-#define HLFP_CLAMP_NOISY_EN_BIT         2
-#define HLFP_CLAMP_NOISY_EN_WID         1
-#define HLPF_CLAMP_VBI_EN_BIT           1
-#define HLPF_CLAMP_VBI_EN_WID           1
-#define HLPF_CLAMP_EN_BIT               0
-#define HLPF_CLAMP_EN_WID               1
-
-#define CVD2_HSYNC_WIDTH_STATUS                         ((CVD_BASE_ADD+0x25)<<2)
-#define STATUS_HS_WIDTH_BIT             0
-#define STATUS_HS_WIDTH_WID             8
-
-#define CVD2_HSYNC_RISING_EDGE_START                    ((CVD_BASE_ADD+0x26)<<2)
-#define HS_RISING_AUTO_BIT              6
-#define HS_RISING_AUTO_WID              2
-#define HS_RISING_START_BIT             0
-#define HS_RISING_START_WID             6
-
-#define CVD2_HSYNC_RISING_EDGE_END                      ((CVD_BASE_ADD+0x27)<<2)
-#define HS_RISING_END_BIT               0
-#define HS_RISING_END_WID               8
-
-#define CVD2_STATUS_BURST_MAGNITUDE_LSB                 ((CVD_BASE_ADD+0x28)<<2)
-#define STATUS_BURST_MAG_LSB_BIT        0
-#define STATUS_BURST_MAG_LSB_WID        8
-
-#define CVD2_STATUS_BURST_MAGNITUDE_MSB                 ((CVD_BASE_ADD+0x29)<<2)
-#define STATUS_BURST_MAG_MSB_BIT        0
-#define STATUS_BURST_MAG_MSB_WID        8
-
-#define CVD2_HSYNC_FILTER_GATE_START                    ((CVD_BASE_ADD+0x2A)<<2)
-#define HBLANK_START_BIT                0
-#define HBLANK_START_WID                8
-
-#define CVD2_HSYNC_FILTER_GATE_END                      ((CVD_BASE_ADD+0x2B)<<2)
-#define HBLANK_END_BIT                  0
-#define HBLANK_END_WID                  8
-
-#define CVD2_CHROMA_BURST_GATE_START                    ((CVD_BASE_ADD+0x2C)<<2)
-#define BURST_GATE_START_BIT            0
-#define BURST_GATE_START_WID            8
-
-#define CVD2_CHROMA_BURST_GATE_END                      ((CVD_BASE_ADD+0x2D)<<2)
-#define BURST_GATE_END_BIT              0
-#define BURST_GATE_END_WID              8
-
-#define CVD2_ACTIVE_VIDEO_HSTART                        ((CVD_BASE_ADD+0x2E)<<2)
-#define HACTIVE_START_BIT               0
-#define HACTIVE_START_WID               8
-
-#define CVD2_ACTIVE_VIDEO_HWIDTH                        ((CVD_BASE_ADD+0x2F)<<2)
-#define HACTIVE_WIDTH_BIT               0
-#define HACTIVE_WIDTH_WID               8
-
-#define CVD2_ACTIVE_VIDEO_VSTART                        ((CVD_BASE_ADD+0x30)<<2)
-#define VACTIVE_START_BIT               0
-#define VACTIVE_START_WID               8
-
-#define CVD2_ACTIVE_VIDEO_VHEIGHT                       ((CVD_BASE_ADD+0x31)<<2)
-#define VACTIVE_HEIGHT_BIT              0
-#define VACTIVE_HEIGHT_WID              8
-
-#define CVD2_VSYNC_H_LOCKOUT_START                      ((CVD_BASE_ADD+0x32)<<2)
-#define VS_H_MIN_BIT                    0
-#define VS_H_MIN_WID                    7
-
-#define CVD2_VSYNC_H_LOCKOUT_END                        ((CVD_BASE_ADD+0x33)<<2)
-#define VS_H_MAX_BIT                    0
-#define VS_H_MAX_WID                    7
-
-#define CVD2_VSYNC_AGC_LOCKOUT_START                    ((CVD_BASE_ADD+0x34)<<2)
-#define VS_AGC_MIN_BIT                  0
-#define VS_AGC_MIN_WID                  7
-
-#define CVD2_VSYNC_AGC_LOCKOUT_END                      ((CVD_BASE_ADD+0x35)<<2)
-#define VS_AGC_MAX_BIT                  0
-#define VS_AGC_MAX_WID                  6
-
-#define CVD2_VSYNC_VBI_LOCKOUT_START                    ((CVD_BASE_ADD+0x36)<<2)
-#define VS_VBI_MIN_BIT                  0
-#define VS_VBI_MIN_WID                  7
-
-#define CVD2_VSYNC_VBI_LOCKOUT_END                      ((CVD_BASE_ADD+0x37)<<2)
-#define VLOCK_WIDE_RANGE_BIT            7
-#define VLOCK_WIDE_RANGE_WID            1
-#define VS_VBI_MAX_BIT                  0
-#define VS_VBI_MAX_WID                  7
-
-#define CVD2_VSYNC_CNTL                                 ((CVD_BASE_ADD+0x38)<<2)
-#define PROSCAN_1FIELD_MODE_BIT         6
-#define PROSCAN_1FIELD_MODE_WID         2
-#define VS_CNTL_NOISY_BIT               5
-#define VS_CNTL_NOISY_WID               1
-#define VS_CNTL_FF_REW_BIT              4
-#define VS_CNTL_FF_REW_WID              1
-#define VS_CNTL_TRICK_BIT               3
-#define VS_CNTL_TRICK_WID               1
-#define VS_CNTL_VCR_BIT                 2
-#define VS_CNTL_VCR_WID                 1
-#define VS_CNTL_BIT                     0
-#define VS_CNTL_WID                     2
-
-#define CVD2_VSYNC_TIME_CONSTANT                        ((CVD_BASE_ADD+0x39)<<2)
-#define FLD_POL_BIT                     7
-#define FLD_POL_WID                     1
-#define FLIP_FLD_BIT                    6
-#define FLIP_FLD_WID                    1
-#define VEVEN_DELAYED_BIT               5
-#define VEVEN_DELAYED_WID               1
-#define VODD_DELAYED_BIT                4
-#define VODD_DELAYED_WID                1
-#define FLD_DET_MODE_BIT                2
-#define FLD_DET_MODE_WID                2
-#define VLOOP_TC_BIT                    0
-#define VLOOP_TC_WID                    2
-
-#define CVD2_STATUS_REGISTER1                           ((CVD_BASE_ADD+0x3A)<<2)
-#define MV_COLOURSTRIPES_BIT            5
-#define MV_COLOURSTRIPES_WID            3
-#define MV_VBI_DETECTED_BIT             4
-#define MV_VBI_DETECTED_WID             1
-#define CHROMALOCK_BIT                  3
-#define CHROMALOCK_WID                  1
-#define VLOCK_BIT                       2
-#define VLOCK_WID                       1
-#define HLOCK_BIT                       1
-#define HLOCK_WID                       1
-#define NO_SIGNAL_BIT                   0
-#define NO_SIGNAL_WID                   1
-
-#define CVD2_STATUS_REGISTER2                           ((CVD_BASE_ADD+0x3B)<<2)
-#define STATUS_COMB3D_OFF_BIT           4
-#define STATUS_COMB3D_OFF_WID           1
-#define BKNWT_DETECTED_BIT              3
-#define BKNWT_DETECTED_WID              1
-#define VNON_STD_BIT                    2
-#define VNON_STD_WID                    1
-#define HNON_STD_BIT                    1
-#define HNON_STD_WID                    1
-#define PROSCAN_DETECTED_BIT            0
-#define PROSCAN_DETECTED_WID            1
-
-#define CVD2_STATUS_REGISTER3                           ((CVD_BASE_ADD+0x3C)<<2)
-#define VCR_REW_BIT                     7
-#define VCR_REW_WID                     1
-#define VCR_FF_BIT                      6
-#define VCR_FF_WID                      1
-#define VCR_TRICK_BIT                   5
-#define VCR_TRICK_WID                   1
-#define VCR_BIT                         4
-#define VCR_WID                         1
-#define NOISY_BIT                       3
-#define NOISY_WID                       1
-#define LINES625_DETECTED_BIT           2
-#define LINES625_DETECTED_WID           1
-#define SECAM_DETECTED_BIT              1
-#define SECAM_DETECTED_WID              1
-#define PAL_DETECTED_BIT                0
-#define PAL_DETECTED_WID                1
-
-#define CVD2_DEBUG_ANALOG                               ((CVD_BASE_ADD+0x3D)<<2)
-#define MUXANALOGB_BIT                  4
-#define MUXANALOGB_WID                  4
-#define MUXANALOGA_BIT                  0
-#define MUXANALOGA_WID                  4
-
-#define CVD2_DEBUG_DIGITAL                              ((CVD_BASE_ADD+0x3E)<<2)
-#define DBG_SYNCS_BIT                   4
-#define DBG_SYNCS_WID                   1
-#define MUXDIGITAL_BIT                  0
-#define MUXDIGITAL_WID                  3
-
-#define CVD2_RESET_REGISTER                             ((CVD_BASE_ADD+0x3F)<<2)
-#define SOFT_RST_BIT                    0
-#define SOFT_RST_WID                    1
-
-#define CVD2_HSYNC_DTO_INC_STATUS_29_24                 ((CVD_BASE_ADD+0x70)<<2)
-#define STATUS_HDTO_INC_29_24_BIT       0
-#define STATUS_HDTO_INC_29_24_WID       6
-
-#define CVD2_HSYNC_DTO_INC_STATUS_23_16                 ((CVD_BASE_ADD+0x71)<<2)
-#define STATUS_HDTO_INC_23_16_BIT       0
-#define STATUS_HDTO_INC_23_16_WID       8
-
-#define CVD2_HSYNC_DTO_INC_STATUS_15_8                  ((CVD_BASE_ADD+0x72)<<2)
-#define STATUS_HDTO_INC_15_8_BIT        0
-#define STATUS_HDTO_INC_15_8_WID        8
-
-#define CVD2_HSYNC_DTO_INC_STATUS_7_0                   ((CVD_BASE_ADD+0x73)<<2)
-#define STATUS_HDTO_INC_7_0_BIT         0
-#define STATUS_HDTO_INC_7_0_WID         8
-
-#define CVD2_CHROMA_DTO_INC_STATUS_29_24                ((CVD_BASE_ADD+0x74)<<2)
-#define STATUS_CDTO_INC_29_24_BIT       0
-#define STATUS_CDTO_INC_29_24_WID       6
-
-#define CVD2_CHROMA_DTO_INC_STATUS_23_16                ((CVD_BASE_ADD+0x75)<<2)
-#define STATUS_CDTO_INC_23_16_BIT       0
-#define STATUS_CDTO_INC_23_16_WID       8
-
-#define CVD2_CHROMA_DTO_INC_STATUS_15_8                 ((CVD_BASE_ADD+0x76)<<2)
-#define STATUS_CDTO_INC_15_8_BIT        0
-#define STATUS_CDTO_INC_15_8_WID        8
-
-#define CVD2_CHROMA_DTO_INC_STATUS_7_0                  ((CVD_BASE_ADD+0x77)<<2)
-#define STATUS_CDTO_INC_7_0_BIT         0
-#define STATUS_CDTO_INC_7_0_WID         8
-
-#define CVD2_AGC_GAIN_STATUS_11_8                       ((CVD_BASE_ADD+0x78)<<2)
-#define AGC_GAIN_11_8_BIT               0
-#define AGC_GAIN_11_8_WID               4
-
-#define CVD2_AGC_GAIN_STATUS_7_0                        ((CVD_BASE_ADD+0x79)<<2)
-#define AGC_GAIN_7_0_BIT                0
-#define AGC_GAIN_7_0_WID                8
-
-#define CVD2_CHROMA_MAGNITUDE_STATUS                    ((CVD_BASE_ADD+0x7A)<<2)
-#define STATUS_CMAG_BIT                 0
-#define STATUS_CMAG_WID                 8
-
-#define CVD2_CHROMA_GAIN_STATUS_13_8                    ((CVD_BASE_ADD+0x7B)<<2)
-#define STATUS_CGAIN_13_8_BIT           0
-#define STATUS_CGAIN_13_8_WID           6
-
-#define CVD2_CHROMA_GAIN_STATUS_7_0                     ((CVD_BASE_ADD+0x7C)<<2)
-#define STATUS_CGAIN_7_0_BIT            0
-#define STATUS_CGAIN_7_0_WID            8
-
-#define CVD2_CORDIC_FREQUENCY_STATUS                    ((CVD_BASE_ADD+0x7D)<<2)
-#define STATUS_CORDIQ_FRERQ_BIT         0
-#define STATUS_CORDIQ_FRERQ_WID         8
-
-#define CVD2_SYNC_HEIGHT_STATUS                         ((CVD_BASE_ADD+0x7E)<<2)
-#define STATUS_SYNC_HEIGHT_BIT          0
-#define STATUS_SYNC_HEIGHT_WID          8
-
-#define CVD2_SYNC_NOISE_STATUS                          ((CVD_BASE_ADD+0x7F)<<2)
-#define STATUS_NOISE_BIT                0
-#define STATUS_NOISE_WID                8
-
-#define CVD2_COMB_FILTER_THRESHOLD1                     ((CVD_BASE_ADD+0x80)<<2)
-#define SECAM_YBW_BIT                   6
-#define SECAM_YBW_WID                   2
-#define PEAK_RANGE_BIT                  4
-#define PEAK_RANGE_WID                  2
-#define PEAK_GAIN_BIT                   1
-#define PEAK_GAIN_WID                   3
-#define PEAK_EN_BIT                     0
-#define PEAK_EN_WID                     1
-
-#define CVD2_COMB_FILTER_CONFIG                         ((CVD_BASE_ADD+0x82)<<2)
-#define AUTO_SECAM_LVL_BIT              7
-#define AUTO_SECAM_LVL_WID              1
-#define SV_BF_BIT                       6
-#define SV_BF_WID                       1
-#define PALSW_LVL_BIT                   0
-#define PALSW_LVL_WID                   2
-
-#define CVD2_COMB_LOCK_CONFIG                           ((CVD_BASE_ADD+0x83)<<2)
-#define LOSE_CHROMALOCK_CNT_BIT         4
-#define LOSE_CHROMALOCK_CNT_WID         4
-#define LOSE_CHROMALOCK_LVL_BIT         1
-#define LOSE_CHROMALOCK_LVL_WID         3
-#define LOSE_CHROMALOCK_CKILL_BIT       0
-#define LOSE_CHROMALOCK_CKILL_WID       1
-
-#define CVD2_COMB_LOCK_MODE                             ((CVD_BASE_ADD+0x84)<<2)
-#define LOSE_CHROMALOCK_MODE_BIT        0
-#define LOSE_CHROMALOCK_MODE_WID        2
-
-#define CVD2_NONSTANDARD_SIGNAL_STATUS_10_8             ((CVD_BASE_ADD+0x85)<<2)
-#define STATUS_NSTD_10_8_BIT            0
-#define STATUS_NSTD_10_8_WID            3
-
-#define CVD2_NONSTANDARD_SIGNAL_STATUS_7_0              ((CVD_BASE_ADD+0x86)<<2)
-#define STATUS_NSTD_7_0_BIT             0
-#define STATUS_NSTD_7_0_WID             8
-
-#define CVD2_REG_87                                     ((CVD_BASE_ADD+0x87)<<2)
-#define CDETECT_VFILTER_SEL_BIT         6
-#define CDETECT_VFILTER_SEL_WID         2
-#define CDETECT_HLOCK_SEL_BIT           4
-#define CDETECT_HLOCK_SEL_WID           2
-#define FORCE_BW_BIT                    3
-#define FORCE_BW_WID                    1
-#define HSTATE_EN_SEL_BIT               2
-#define HSTATE_EN_SEL_WID               1
-#define HDSW_SEL_BIT                    0
-#define HDSW_SEL_WID                    2
-
-#define CVD2_COLORSTRIPE_DETECTION_CONTROL              ((CVD_BASE_ADD+0x88)<<2)
-#define CSTRIPE_DET_CONT_2_BIT          2
-#define CSTRIPE_DET_CONT_2_WID          1
-#define CSTRIPE_DET_CONT_1_BIT          1
-#define CSTRIPE_DET_CONT_1_WID          1
-#define CSTRIPE_DET_CONT_0_BIT          0
-#define CSTRIPE_DET_CONT_0_WID          1
-
-#define CVD2_CHROMA_LOOPFILTER_STATE                    ((CVD_BASE_ADD+0x8A)<<2)
-#define CSTATE_BIT                      1
-#define CSTATE_WID                      3
-#define FIXED_CSTATE_BIT                0
-#define FIXED_CSTATE_WID                1
-
-#define CVD2_CHROMA_HRESAMPLER_CONTROL                  ((CVD_BASE_ADD+0x8B)<<2)
-#define HFINE_VCR_TRICK_EN_BIT          5
-#define HFINE_VCR_TRICK_EN_WID          1
-#define HFINE_VCR_EN_BIT                4
-#define HFINE_VCR_EN_WID                1
-#define HRESAMPLER_2UP_BIT              0
-#define HRESAMPLER_2UP_WID              1
-
-#define CVD2_CHARGE_PUMP_DELAY_CONTROL                  ((CVD_BASE_ADD+0x8D)<<2)
-#define CPUMP_DLY_EN_BIT                7
-#define CPUMP_DLY_EN_WID                1
-#define CPUMP_ADJ_POL_BIT               6
-#define CPUMP_ADJ_POL_WID               1
-#define CPUMP_ADJ_DLY_BIT               0
-#define CPUMP_ADJ_DLY_WID               6
-
-#define CVD2_CHARGE_PUMP_ADJUSTMENT                     ((CVD_BASE_ADD+0x8E)<<2)
-#define CPUMP_ADJ_BIT                   0
-#define CPUMP_ADJ_WID                   8
-
-#define CVD2_CHARGE_PUMP_DELAY                          ((CVD_BASE_ADD+0x8F)<<2)
-#define CPUMP_DLY_BIT                   0
-#define CPUMP_DLY_WID                   8
-
-#define CVD2_MACROVISION_SELECTION                      ((CVD_BASE_ADD+0x90)<<2)
-#define MV_COLOURSTRIPES_SEL_BIT        1
-#define MV_COLOURSTRIPES_SEL_WID        1
-#define MV_VBI_SEL_BIT                  0
-#define MV_VBI_SEL_WID                  1
-
-#define CVD2_CPUMP_KILL                                 ((CVD_BASE_ADD+0x91)<<2)
-#define CPUMP_KILL_CR_BIT               2
-#define CPUMP_KILL_CR_WID               1
-#define CPUMP_KILL_CB_BIT               1
-#define CPUMP_KILL_CB_WID               1
-#define CPUMP_KILL_Y_BIT                0
-#define CPUMP_KILL_Y_WID                1
-
-#define CVD2_CVBS_Y_DELAY                               ((CVD_BASE_ADD+0x92)<<2)
-#define CVBS_Y_DLY_BIT                  0
-#define CVBS_Y_DLY_WID                  5
-
-#define CVD2_REG_93                                     ((CVD_BASE_ADD+0x93)<<2)
-#define AML_TIMER_EN_BIT                31
-#define AML_TIMER_EN_WID                1
-#define AML_SOFT_RST_BIT                30
-#define AML_SOFT_RST_WID                1
-#define AML_TIMER_BIT                   24
-#define AML_TIMER_WID                   6
-#define AML_ADDR_OFFSET_BIT             0
-#define AML_ADDR_OFFSET_WID             23
-
-#define CVD2_REG_94                                     ((CVD_BASE_ADD+0x94)<<2)
-#define MEM_BIST_SEL_BIT                31
-#define MEM_BIST_SEL_WID                1
-#define EXT_RST_L_BIT                   30
-#define EXT_RST_L_WID                   1
-#define BIST_INC_BIT                    24
-#define BIST_INC_WID                    6
-#define BIST_SOFT_RST_BIT               23
-#define BIST_SOFT_RST_WID               1
-#define PATCH4WAITINI_BIT               16
-#define PATCH4WAITINI_WID               1
-#define AMLOGIC_HOLD_BIT                8
-#define AMLOGIC_HOLD_WID                7
-#define AML_TH_BIT                      0
-#define AML_TH_WID                      5
-
-#define CVD2_REG_95                                     ((CVD_BASE_ADD+0x95)<<2)
-#define MCLKCHECK_ERR_BIT               24
-#define MCLKCHECK_ERR_WID               7
-#define ERR_WARNING_BIT                 18
-#define ERR_WARNING_WID                 5
-#define SUBID_FULLWR_BIT                16
-#define SUBID_FULLWR_WID                1
-#define SUBID_EMPTYRD_BIT               15
-#define SUBID_EMPTYRD_WID               1
-#define FB_RD_WARNING_BIT               9
-#define FB_RD_WARNING_WID               6
-#define WARNING_3D_AML_REG_NEW_BIT      0
-#define WARNING_3D_AML_REG_NEW_WID      9
-
-#define CVD2_REG_96                                     ((CVD_BASE_ADD+0x96)<<2)
-#define AML_3D_ADDR_OFFSET_BIT          0
-#define AML_3D_ADDR_OFFSET_WID          32
-
-#define CVD2_CHARGE_PUMP_AUTO_CONTROL                   ((CVD_BASE_ADD+0xA0)<<2)
-#define CPUMP_NOISY_FILTER_EN_BIT       7
-#define CPUMP_NOISY_FILTER_EN_WID       1
-#define CPUMP_AUTO_STIP_NOBP_BIT        6
-#define CPUMP_AUTO_STIP_NOBP_WID        1
-#define CPUMP_AUTO_STIP_UNLOCKED_BIT    5
-#define CPUMP_AUTO_STIP_UNLOCKED_WID    1
-#define CPUMP_AUTO_STIP_NO_SIGNAL_BIT   4
-#define CPUMP_AUTO_STIP_NO_SIGNAL_WID   1
-#define CPUMP_AUTO_STIP_NOISY_BIT       3
-#define CPUMP_AUTO_STIP_NOISY_WID       1
-#define CPUMP_AUTO_STIP_VACTIVE_BIT     2
-#define CPUMP_AUTO_STIP_VACTIVE_WID     1
-#define CPUMP_AUTO_STIP_MODE_BIT        0
-#define CPUMP_AUTO_STIP_MODE_WID        2
-
-#define CVD2_CHARGE_PUMP_FILTER_CONTROL                 ((CVD_BASE_ADD+0xA1)<<2)
-#define CPUMP_VS_BLANK_FILTER_BIT       7
-#define CPUMP_VS_BLANK_FILTER_WID       1
-#define CPUMP_VS_SYNCMID_FILTER_BIT     6
-#define CPUMP_VS_SYNCMID_FILTER_WID     1
-#define CPUMP_VS_MODE_BIT               4
-#define CPUMP_VS_MODE_WID               2
-#define CPUMP_ACCUM_MODE_BIT            3
-#define CPUMP_ACCUM_MODE_WID            1
-#define CPUMP_FIXED_SYNCMID_BIT         2
-#define CPUMP_FIXED_SYNCMID_WID         1
-#define CPUMP_LVL_FILTER_GAIN_BIT       0
-#define CPUMP_LVL_FILTER_GAIN_WID       2
-
-#define CVD2_CHARGE_PUMP_UP_MAX                         ((CVD_BASE_ADD+0xA2)<<2)
-#define CPUMP_UP_MAX_BIT                0
-#define CPUMP_UP_MAX_WID                7
-
-#define CVD2_CHARGE_PUMP_DN_MAX                         ((CVD_BASE_ADD+0xA3)<<2)
-#define CPUMP_DN_MAX_BIT                0
-#define CPUMP_DN_MAX_WID                7
-
-#define CVD2_CHARGE_PUMP_UP_DIFF_MAX                    ((CVD_BASE_ADD+0xA4)<<2)
-#define CPUMP_DIFF_SIGNAL_ONLY_BIT      7
-#define CPUMP_DIFF_SIGNAL_ONLY_WID      1
-#define CPUMP_UP_DIFF_MAX_BIT           0
-#define CPUMP_UP_DIFF_MAX_WID           7
-
-#define CVD2_CHARGE_PUMP_DN_DIFF_MAX                    ((CVD_BASE_ADD+0xA5)<<2)
-#define CPUMP_DIFF_NOISY_ONLY_BIT       7
-#define CPUMP_DIFF_NOISY_ONLY_WID       1
-#define CPUMP_DN_DIFF_MAX_BIT           0
-#define CPUMP_DN_DIFF_MAX_WID           7
-
-#define CVD2_CHARGE_PUMP_Y_OVERRIDE                     ((CVD_BASE_ADD+0xA6)<<2)
-#define CPUMP_Y_OVERRIDE_BIT            0
-#define CPUMP_Y_OVERRIDE_WID            8
-
-#define CVD2_CHARGE_PUMP_PB_OVERRIDE                    ((CVD_BASE_ADD+0xA7)<<2)
-#define CPUMP_PB_OVERRIDE_BIT           0
-#define CPUMP_PB_OVERRIDE_WID           8
-
-#define CVD2_CHARGE_PUMP_PR_OVERRIDE                    ((CVD_BASE_ADD+0xA8)<<2)
-#define CPUMP_PR_OVERRIDE_BIT           0
-#define CPUMP_PR_OVERRIDE_WID           8
-
-#define CVD2_DR_FREQ_11_8                               ((CVD_BASE_ADD+0xA9)<<2)
-#define DR_FREQ_11_8_BIT                0
-#define DR_FREQ_11_8_WID                4
-
-#define CVD2_DR_FREQ_7_0                                ((CVD_BASE_ADD+0xAA)<<2)
-#define DR_FREQ_7_0_BIT                 0
-#define DR_FREQ_7_0_WID                 8
-
-#define CVD2_DB_FREQ_11_8                               ((CVD_BASE_ADD+0xAB)<<2)
-#define DB_FREQ_11_8_BIT                0
-#define DB_FREQ_11_8_WID                4
-
-#define CVD2_DB_FREQ_7_0                                ((CVD_BASE_ADD+0xAC)<<2)
-#define DB_FREQ_7_0_BIT                 0
-#define DB_FREQ_7_0_WID                 8
-
-#define CVD2_2DCOMB_VCHROMA_TH                          ((CVD_BASE_ADD+0xAE)<<2)
-#define VACTIVITY_EN_BIT                7
-#define VACTIVITY_EN_WID                1
-#define VACTIVE_ON2FRAME_BIT            6
-#define VACTIVE_ON2FRAME_WID            1
-#define VACTIVITY_TH_BIT                0
-#define VACTIVITY_TH_WID                6
-
-#define CVD2_2DCOMB_NOISE_TH                            ((CVD_BASE_ADD+0xAF)<<2)
-#define COMB_NOISE_TH_EN_BIT            7
-#define COMB_NOISE_TH_EN_WID            1
-#define COMB_NOISE_TH_BIT               0
-#define COMB_NOISE_TH_WID               7
-
-#define CVD2_REG_B0                                     ((CVD_BASE_ADD+0xB0)<<2)
-#define HORIZ_DIFF_CGAIN_BIT            6
-#define HORIZ_DIFF_CGAIN_WID            2
-#define HORIZ_DIFF_YGAIN_BIT            4
-#define HORIZ_DIFF_YGAIN_WID            2
-#define CHROMA_VDIFF_GAIN_BIT           2
-#define CHROMA_VDIFF_GAIN_WID           2
-#define LOWFREQ_VDIFF_GAIN_BIT          0
-#define LOWFREQ_VDIFF_GAIN_WID          2
-
-#define CVD2_3DCOMB_FILTER                              ((CVD_BASE_ADD+0xB1)<<2)
-#define VADAP_BURST_NOISE_TH_GAIN_BIT   6
-#define VADAP_BURST_NOISE_TH_GAIN_WID   2
-#define BURST_NOISE_TH_GAIN_BIT         4
-#define BURST_NOISE_TH_GAIN_WID         2
-#define C_NOISE_TH_GAIN_BIT             2
-#define C_NOISE_TH_GAIN_WID             2
-#define Y_NOISE_TH_GAIN_BIT             0
-#define Y_NOISE_TH_GAIN_WID             2
-
-#define CVD2_REG_B2                                     ((CVD_BASE_ADD+0xB2)<<2)
-#define LBADRGEN_RST_BIT                7
-#define LBADRGEN_RST_WID                1
-#define COMB2D_ONLY_BIT                 6
-#define COMB2D_ONLY_WID                 1
-#define ADAPTIVE_CHROMA_MODE_BIT        3
-#define ADAPTIVE_CHROMA_MODE_WID        2
-#define DOT_SUPPRESS_MODE_BIT           1
-#define DOT_SUPPRESS_MODE_WID           1
-#define MOTION_MODE_BIT                 0
-#define MOTION_MODE_WID                 2
-
-#define CVD2_2DCOMB_ADAPTIVE_GAIN_CONTROL               ((CVD_BASE_ADD+0xB3)<<2)
-#define PAL3DCOMB_VACTIVE_OFFSET_BIT    7
-#define PAL3DCOMB_VACTIVE_OFFSET_WID    1
-#define FB_SYNC_BIT                     5
-#define FB_SYNC_WID                     2
-#define FB_HOLD_BIT                     4
-#define FB_HOLD_WID                     1
-#define FB_CTL_BIT                      3
-#define FB_CTL_WID                      1
-#define FLD_LATENCY_BIT                 0
-#define FLD_LATENCY_WID                 3
-
-#define CVD2_MOTION_DETECTOR_NOISE_TH                   ((CVD_BASE_ADD+0xB4)<<2)
-#define MD_NOISE_TH_EN_BIT              7
-#define MD_NOISE_TH_EN_WID              1
-#define MD_NOISE_TH_BIT                 0
-#define MD_NOISE_TH_WID                 7
-
-#define CVD2_CHROMA_EDGE_ENHANCEMENT                    ((CVD_BASE_ADD+0xB5)<<2)
-#define SCHROMA_PEAK_EN_BIT             7
-#define SCHROMA_PEAK_EN_WID             1
-#define SCHROMA_CORING_EN_BIT           6
-#define SCHROMA_CORING_EN_WID           1
-#define SCHROMA_PEAK_BIT                4
-#define SCHROMA_PEAK_WID                2
-#define PCHROMA_PEAK_EN_BIT             3
-#define PCHROMA_PEAK_EN_WID             1
-#define PCHROMA_CORING_EN_BIT           2
-#define PCHROMA_CORING_EN_WID           1
-#define PCHROMA_PEAK_BIT                0
-#define PCHROMA_PEAK_WID                2
-
-#define CVD2_REG_B6                                     ((CVD_BASE_ADD+0xB6)<<2)
-#define LDPAUSE_TH_BIT                  4
-#define LDPAUSE_TH_WID                  4
-#define VF_NSTD_EN_BIT                  1
-#define VF_NSTD_EN_WID                  1
-#define VCR_AUTO_SWT_EN_BIT             0
-#define VCR_AUTO_SWT_EN_WID             1
-
-#define CVD2_2D_COMB_NOTCH_GAIN                         ((CVD_BASE_ADD+0xB7)<<2)
-#define NOTCH_GAIN_BIT                  4
-#define NOTCH_GAIN_WID                  3
-#define COMB_GAIN_BIT                   0
-#define COMB_GAIN_WID                   3
-
-#define CVD2_TEMPORAL_COMB_FILTER_GAIN                  ((CVD_BASE_ADD+0xB8)<<2)
-#define COMB_CORING_BIT                 4
-#define COMB_CORING_WID                 4
-#define TCOMB_GAIN_BIT                  0
-#define TCOMB_GAIN_WID                  3
-
-#define CVD2_ACTIVE_VSTART_FRAME_BUFFER                 ((CVD_BASE_ADD+0xBA)<<2)
-#define VACTIVE_FB_START_BIT            0
-#define VACTIVE_FB_START_WID            8
-
-#define CVD2_ACTIVE_VHEIGHT_FRAME_BUFFER                ((CVD_BASE_ADD+0xBB)<<2)
-#define VACTIVE_FB_HEIGHT_BIT           0
-#define VACTIVE_FB_HEIGHT_WID           8
-
-#define CVD2_HSYNC_PULSE_CONFIG                         ((CVD_BASE_ADD+0xBC)<<2)
-#define HS_PULSE_WIDTH_BIT              0
-#define HS_PULSE_WIDTH_WID              4
-
-#define CVD2_CAGC_TIME_CONSTANT_CONTROL                 ((CVD_BASE_ADD+0xBD)<<2)
-#define CAGC_TC_P_BIT                   6
-#define CAGC_TC_P_WID                   2
-#define CAGC_TC_IBIG_BIT                3
-#define CAGC_TC_IBIG_WID                3
-#define CAGC_TC_ISMALL_BIT              0
-#define CAGC_TC_ISMALL_WID              3
-
-#define CVD2_CAGC_CORING_FUNCTION_CONTROL               ((CVD_BASE_ADD+0xBE)<<2)
-#define CAGC_CORING_TH_BIT              5
-#define CAGC_CORING_TH_WID              4
-#define CAGC_UNITY_GAIN_BIT             4
-#define CAGC_UNITY_GAIN_WID             1
-#define CAGC_CORING_BIT                 0
-#define CAGC_CORING_WID                 3
-
-#define CVD2_NEW_DCRESTORE_CNTL                         ((CVD_BASE_ADD+0xC0)<<2)
-#define DCRESTORE_NO_BAD_BP_BIT         7
-#define DCRESTORE_NO_BAD_BP_WID         1
-#define DCRESTORE_KILL_EN_BIT           6
-#define DCRESTORE_KILL_EN_WID           1
-#define DCRESTORE_BP_DLY_BIT            4
-#define DCRESTORE_BP_DLY_WID            2
-#define SYNCMID_NOBP_EN_BIT             3
-#define SYNCMID_NOBP_EN_WID             1
-#define SYNCMID_FILTER_EN_BIT           2
-#define SYNCMID_FILTER_EN_WID           1
-#define DCRESTORE_GAIN_BIT              0
-#define DCRESTORE_GAIN_WID              2
-
-#define CVD2_DCRESTORE_ACCUM_WIDTH                      ((CVD_BASE_ADD+0xC1)<<2)
-#define DCRESTORE_LPF_EN_BIT            7
-#define DCRESTORE_LPF_EN_WID            1
-#define DCRESTORE_KILL_EN_NOISY_BIT     6
-#define DCRESTORE_KILL_EN_NOISY_WID     1
-#define DCRESTORE_ACCUM_WIDTH_BIT       0
-#define DCRESTORE_ACCUM_WIDTH_WID       6
-
-#define CVD2_MANUAL_GAIN_CONTROL                        ((CVD_BASE_ADD+0xC2)<<2)
-#define HMGC_BIT                        0
-#define HMGC_WID                        8
-
-#define CVD2_BACKPORCH_KILL_THRESHOLD                   ((CVD_BASE_ADD+0xC3)<<2)
-#define BP_KILL_TH_BIT                  0
-#define BP_KILL_TH_WID                  8
-
-#define CVD2_DCRESTORE_HSYNC_MIDPOINT                   ((CVD_BASE_ADD+0xC4)<<2)
-#define DCRESTORE_HS_HMID_BIT           0
-#define DCRESTORE_HS_HMID_WID           8
-
-#define CVD2_SYNC_HEIGHT                                ((CVD_BASE_ADD+0xC5)<<2)
-#define AUTO_MIN_SYNC_HEIGHT_BIT        7
-#define AUTO_MIN_SYNC_HEIGHT_WID        1
-#define MIN_SYNC_HEIGHT_BIT             0
-#define MIN_SYNC_HEIGHT_WID             7
-
-#define CVD2_VSYNC_SIGNAL_THRESHOLD                     ((CVD_BASE_ADD+0xC6)<<2)
-#define VS_SIGNAL_TH_BIT                2
-#define VS_SIGNAL_TH_WID                6
-#define VS_SIGNAL_AUTO_TH_BIT           0
-#define VS_SIGNAL_AUTO_TH_WID           2
-
-#define CVD2_VSYNC_NO_SIGNAL_THRESHOLD                  ((CVD_BASE_ADD+0xC7)<<2)
-#define VS_NO_SIGNAL_TH_BIT             0
-#define VS_NO_SIGNAL_TH_WID             8
-
-#define CVD2_VSYNC_CNTL2                                ((CVD_BASE_ADD+0xC8)<<2)
-#define VACTIVE_HALF_LINES_BIT          6
-#define VACTIVE_HALF_LINES_WID          1
-#define VDETECT_NOISE_EN_BIT            5
-#define VDETECT_NOISE_EN_WID            1
-#define VCRTRICK_PROSCAN_BIT            4
-#define VCRTRICK_PROSCAN_WID            1
-#define VEVEN_EARLY_DELAYED_BIT         3
-#define VEVEN_EARLY_DELAYED_WID         1
-#define VODD_EARLY_DELAYED_BIT          2
-#define VODD_EARLY_DELAYED_WID          1
-#define VFIELD_HOFFSET_FIXED_BIT        1
-#define VFIELD_HOFFSET_FIXED_WID        1
-#define VFIELD_HOFFSET_MSB_BIT          0
-#define VFIELD_HOFFSET_MSB_WID          1
-
-#define CVD2_VSYNC_POLARITY_CONTROL                     ((CVD_BASE_ADD+0xC9)<<2)
-#define VFIELD_HOFFSET_LSB_BIT          0
-#define VFIELD_HOFFSET_LSB_WID          8
-
-#define CVD2_VBI_HDETECT_CNTL                           ((CVD_BASE_ADD+0xCA)<<2)
-#define NO_HSYNCS_MODE_BIT              6
-#define NO_HSYNCS_MODE_WID              2
-#define MANY_HSYNCS_MODE_BIT            5
-#define MANY_HSYNCS_MODE_WID            1
-#define DUAL_HEDGE_DIS_BIT              4
-#define DUAL_HEDGE_DIS_WID              1
-#define DUAL_HEDGE_AUTO_WIDTH_BIT       3
-#define DUAL_HEDGE_AUTO_WIDTH_WID       1
-#define DUAL_FINE_HEDGE_VBI_BIT         2
-#define DUAL_FINE_HEDGE_VBI_WID         1
-#define DUAL_COARSE_HEDGE_VBI_BIT       0
-#define DUAL_COARSE_HEDGE_VBI_WID       2
-
-#define CVD2_MV_PSEUDO_SYNC_RISING_START                ((CVD_BASE_ADD+0xCB)<<2)
-#define VCR_STATE2_LONG_BIT             7
-#define VCR_STATE2_LONG_WID             1
-#define SLOW_HDSW_BIT                   6
-#define SLOW_HDSW_WID                   1
-#define HS_RISING_START_BIT             0
-#define HS_RISING_START_WID             6
-
-#define CVD2_MV_PSEUDO_SYNC_RISING_END                  ((CVD_BASE_ADD+0xCC)<<2)
-#define NO_HSYNCS_WEAK_BIT              7
-#define NO_HSYNCS_WEAK_WID              1
-#define DISABLE_HDSW_WEAK_BIT           6
-#define DISABLE_HDSW_WEAK_WID           1
-#define CVD2_MV_HS_RISING_END_BIT       0
-#define CVD2_MV_HS_RISING_END_WID       6
-
-#define CVD2_REG_CD                                     ((CVD_BASE_ADD+0xCD)<<2)
-#define VACTIVE_HDSW_MODE_BIT           6
-#define VACTIVE_HDSW_MODE_WID           2
-#define DISABLE_HDSW_MODE_BIT           4
-#define DISABLE_HDSW_MODE_WID           2
-#define HS_FALLING_FILTER_BIT           3
-#define HS_FALLING_FILTER_WID           1
-#define NO_HSYNCS_NOISY_BIT             2
-#define NO_HSYNCS_NOISY_WID             1
-#define HLOOP_RANGE_BIT                 0
-#define HLOOP_RANGE_WID                 2
-
-#define CVD2_BIG_HLUMA_TH                               ((CVD_BASE_ADD+0xCE)<<2)
-#define MD_C_NOISE_TH_EN_BIT            7
-#define MD_C_NOISE_TH_EN_WID            1
-#define MD_C_NOISE_TH_BIT               0
-#define MD_C_NOISE_TH_WID               7
-
-#define CVD2_MOTION_DETECTOR_CONTROL                    ((CVD_BASE_ADD+0xD0)<<2)
-#define MD_CF_ACTIVITY_EN_BIT           6
-#define MD_CF_ACTIVITY_EN_WID           2
-#define MD_HF_MAX_BIT                   5
-#define MD_HF_MAX_WID                   1
-#define MD_HF_SAD_BIT                   3
-#define MD_HF_SAD_WID                   2
-#define MD_LF_SAD_BIT                   2
-#define MD_LF_SAD_WID                   1
-#define MD_LF_SHIFT_BIT                 0
-#define MD_LF_SHIFT_WID                 2
-
-#define CVD2_MD_CF_LACTIVITY_LOW                        ((CVD_BASE_ADD+0xD1)<<2)
-#define MD_CF_LACTIVITY_LOW_BIT         0
-#define MD_CF_LACTIVITY_LOW_WID         8
-
-#define CVD2_MD_CF_CACTIVITY_LOW                        ((CVD_BASE_ADD+0xD2)<<2)
-#define MD_CF_CACTIVITY_LOW_BIT         0
-#define MD_CF_CACTIVITY_LOW_WID         8
-
-#define CVD2_MD_CF_LACTIVITY_HIGH                       ((CVD_BASE_ADD+0xD3)<<2)
-#define MD_CF_LACTIVITY_HIGH_BIT        0
-#define MD_CF_LACTIVITY_HIGH_WID        8
-
-#define CVD2_MD_CF_CACTIVITY_HIGH                       ((CVD_BASE_ADD+0xD4)<<2)
-#define MD_CF_CACTIVITY_HIGH_BIT        0
-#define MD_CF_CACTIVITY_HIGH_WID        8
-
-#define CVD2_MD_K_THRESHOLD                             ((CVD_BASE_ADD+0xD5)<<2)
-#define MD_K_TH_BIT                     0
-#define MD_K_TH_WID                     8
-
-#define CVD2_CHROMA_LEVEL                               ((CVD_BASE_ADD+0xD6)<<2)
-#define CHROMA_LVL_BIT                  0
-#define CHROMA_LVL_WID                  8
-
-#define CVD2_SPATIAL_LUMA_LEVEL                         ((CVD_BASE_ADD+0xD7)<<2)
-#define SPATIAL_LUMA_LVL_BIT            0
-#define SPATIAL_LUMA_LVL_WID            8
-
-#define CVD2_SPATIAL_CHROMA_LEVEL                       ((CVD_BASE_ADD+0xD8)<<2)
-#define HF_LUMA_CHROMA_OFFSET_BIT       0
-#define HF_LUMA_CHROMA_OFFSET_WID       8
-
-#define CVD2_TCOMB_CHROMA_LEVEL                         ((CVD_BASE_ADD+0xD9)<<2)
-#define TCOMB_CHROMA_LVL_BIT            0
-#define TCOMB_CHROMA_LVL_WID            8
-
-#define CVD2_FMDLF_TH                                   ((CVD_BASE_ADD+0xDA)<<2)
-#define LF_LUMA_OFFSET_BIT              0
-#define LF_LUMA_OFFSET_WID              8
-
-#define CVD2_CHROMA_ACTIVITY_LEVEL                      ((CVD_BASE_ADD+0xDB)<<2)
-#define CHROMA_ACTIVITY_LVL_BIT         0
-#define CHROMA_ACTIVITY_LVL_WID         8
-
-#define CVD2_SECAM_FREQ_OFFSET_RANGE                    ((CVD_BASE_ADD+0xDC)<<2)
-#define FREQ_OFFSET_RANGE_BIT           0
-#define FREQ_OFFSET_RANGE_WID           8
-
-#define CVD2_SECAM_FLAG_THRESHOLD                       ((CVD_BASE_ADD+0xDE)<<2)
-#define AVG_FREQ_RANGE_BIT              6
-#define AVG_FREQ_RANGE_WID              2
-#define ISSECAM_TH_BIT                  0
-#define ISSECAM_TH_WID                  6
-
-#define CVD2_3DCOMB_MOTION_STATUS_31_24                 ((CVD_BASE_ADD+0xE0)<<2)
-#define STATUS_COMB3D_MOTION_31_24_BIT  0
-#define STATUS_COMB3D_MOTION_31_24_WID  8
-
-#define CVD2_3DCOMB_MOTION_STATUS_23_16                 ((CVD_BASE_ADD+0xE1)<<2)
-#define STATUS_COMB3D_MOTION_23_16_BIT  0
-#define STATUS_COMB3D_MOTION_23_16_WID  8
-
-#define CVD2_3DCOMB_MOTION_STATUS_15_8                  ((CVD_BASE_ADD+0xE2)<<2)
-#define STATUS_COMB3D_MOTION_15_8_BIT   0
-#define STATUS_COMB3D_MOTION_15_8_WID   8
-
-#define CVD2_3DCOMB_MOTION_STATUS_7_0                   ((CVD_BASE_ADD+0xE3)<<2)
-#define STATUS_COMB3D_MOTION_7_0_BIT    0
-#define STATUS_COMB3D_MOTION_7_0_WID    8
-
-#define CVD2_HACTIVE_MD_START                           ((CVD_BASE_ADD+0xE4)<<2)
-#define HACTIVE_MD_START_BIT            0
-#define HACTIVE_MD_START_WID            8
-
-#define CVD2_HACTIVE_MD_WIDTH                           ((CVD_BASE_ADD+0xE5)<<2)
-#define HACTIVE_MD_WIDTH_BIT            0
-#define HACTIVE_MD_WIDTH_WID            8
-
-#define CVD2_REG_E6                                     ((CVD_BASE_ADD+0xE6)<<2)
-#define STATUS_VLINES_BIT               0
-#define STATUS_VLINES_WID               8
-
-#define CVD2_MOTION_CONFIG                              ((CVD_BASE_ADD+0xE7)<<2)
-#define MOTION_CONFIG_BIT               0
-#define MOTION_CONFIG_WID               8
-
-#define CVD2_CHROMA_BW_MOTION                           ((CVD_BASE_ADD+0xE8)<<2)
-#define CHROMA_BW_MOTION_TH_BIT         0
-#define CHROMA_BW_MOTION_TH_WID         8
-
-#define CVD2_FLAT_LUMA_SHIFT                            ((CVD_BASE_ADD+0xE9)<<2)
-#define FLAT_CHROMA_SHIFT_BIT           6
-#define FLAT_CHROMA_SHIFT_WID           2
-#define FLAT_LUMA_MODE_BIT              4
-#define FLAT_LUMA_MODE_WID              2
-#define STATUS_MOTION_MODE_BIT          2
-#define STATUS_MOTION_MODE_WID          2
-#define CHROMA_BW_MOTION_BIT            0
-#define CHROMA_BW_MOTION_WID            2
-
-#define CVD2_FRAME_MOTION_TH                            ((CVD_BASE_ADD+0xEA)<<2)
-#define FRAME_MOTION_TH_BIT             0
-#define FRAME_MOTION_TH_WID             8
-
-#define CVD2_FLAT_LUMA_OFFSET                           ((CVD_BASE_ADD+0xEB)<<2)
-#define FLAT_LUMA_OFFSET_BIT            0
-#define FLAT_LUMA_OFFSET_WID            8
-
-#define CVD2_FLAT_CHROMA_OFFSET                         ((CVD_BASE_ADD+0xEC)<<2)
-#define FLAT_CHROMA_OFFSET_BIT          0
-#define FLAT_CHROMA_OFFSET_WID          8
-
-#define CVD2_CF_FLAT_MOTION_SHIFT                       ((CVD_BASE_ADD+0xED)<<2)
-#define CF_FLAT_MOTION_SHIFT_BIT        2
-#define CF_FLAT_MOTION_SHIFT_WID        2
-#define MOTION_C_MODE_BIT               0
-#define MOTION_C_MODE_WID               2
-
-#define CVD2_MOTION_DEBUG                               ((CVD_BASE_ADD+0xEE)<<2)
-#define MOTION_DEBUG_BIT                0
-#define MOTION_DEBUG_WID                8
-
-#define CVD2_PHASE_OFFSE_RANGE                          ((CVD_BASE_ADD+0xF0)<<2)
-#define PHASE_OFFSET_RANGE_BIT          0
-#define PHASE_OFFSET_RANGE_WID          8
-
-#define CVD2_PAL_DETECTION_THRESHOLD                    ((CVD_BASE_ADD+0xF1)<<2)
-#define PAL_DET_TH_BIT                  0
-#define PAL_DET_TH_WID                  8
-
-#define CVD2_CORDIC_FREQUENCY_GATE_START                ((CVD_BASE_ADD+0xF2)<<2)
-#define CORDIC_GATE_START_BIT           0
-#define CORDIC_GATE_START_WID           8
-
-#define CVD2_CORDIC_FREQUENCY_GATE_END                  ((CVD_BASE_ADD+0xF3)<<2)
-#define CORDIC_GATE_END_BIT             0
-#define CORDIC_GATE_END_WID             8
-
-#define CVD2_ADC_CPUMP_SWAP                             ((CVD_BASE_ADD+0xF4)<<2)
-#define PAL3TAP_ONLY_C_BIT              7
-#define PAL3TAP_ONLY_C_WID              1
-#define PAL3TAP_ONLY_Y_BIT              6
-#define PAL3TAP_ONLY_Y_WID              1
-#define ADC_CPUMP_SWAP_BIT              0
-#define ADC_CPUMP_SWAP_WID              6
-
-#define CVD2_COMB3D_CONFIG                              ((CVD_BASE_ADD+0xF9)<<2)
-#define VBI_FIXGATE_EN_BIT              0
-#define VBI_FIXGATE_EN_WID              1
-
-#define CVD2_REG_FA                                     ((CVD_BASE_ADD+0xFA)<<2)
-#define VLINES_SEL_BIT                  6
-#define VLINES_SEL_WID                  1
-#define UV_FILTER_BYPASS_BIT            5
-#define UV_FILTER_BYPASS_WID            1
-#define ADC_CHROMA_FOR_TB_BIT           4
-#define ADC_CHROMA_FOR_TB_WID           1
-#define ADC_SV_CHROMA_SEL_BIT           3
-#define ADC_SV_CHROMA_SEL_WID           1
-#define ADC_CV_CHROMA_SEL_BIT           0
-#define ADC_CV_CHROMA_SEL_WID           2
-
-#define CVD2_CAGC_GATE_START                            ((CVD_BASE_ADD+0xFB)<<2)
-#define CAGC_GATE_START_BIT             0
-#define CAGC_GATE_START_WID             8
-
-#define CVD2_CAGC_GATE_END                              ((CVD_BASE_ADD+0xFC)<<2)
-#define CAGC_GATE_END_BIT               0
-#define CAGC_GATE_END_WID               8
-
-#define CVD2_CKILL_LEVEL_15_8                           ((CVD_BASE_ADD+0xFD)<<2)
-#define CKILL_15_8_BIT                  0
-#define CKILL_15_8_WID                  8
-
-#define CVD2_CKILL_LEVEL_7_0                            ((CVD_BASE_ADD+0xFE)<<2)
-#define CKILL_7_0_BIT                   0
-#define CKILL_7_0_WID                   8
-
-/* VBI decoder */
-#define CVD2_VBI_FRAME_CODE_CTL                         ((CVD_BASE_ADD+0x40)<<2)
-#define VBI_LPF_BW_BIT                  6
-#define VBI_LPF_BW_WID                  2
-#define CC_SHORT_START_BIT              5
-#define CC_SHORT_START_WID              1
-#define VBI_MUXOUT_BIT                  4
-#define VBI_MUXOUT_WID                  1
-#define VBI_HSYNCOUT_BIT                3
-#define VBI_HSYNCOUT_WID                1
-#define ADAP_SLVL_EN_BIT                2
-#define ADAP_SLVL_EN_WID                1
-#define VBI_ST_ERR_IGNORED_BIT          1
-#define VBI_ST_ERR_IGNORED_WID          1
-#define VBI_EN_BIT                      0
-#define VBI_EN_WID                      1
-
-#define CVD2_VBI_TT_FRAME_CODE_CTL                       ((CVD_BASE_ADD+0x41)<<2)
-#define START_CODE_BIT                  0
-#define START_CODE_WID                  8
-
-#define CVD2_VBI_DATA_HLVL                               ((CVD_BASE_ADD+0x42)<<2)
-#define VBI_DATA_HLVL_BIT               0
-#define VBI_DATA_HLVL_WID               8
-
-#define CVD2_VBI_DATA_TYPE_LINE6                         ((CVD_BASE_ADD+0x6A)<<2)
-#define VBIL6E_BIT                      4
-#define VBIL6E_WID                      4
-#define VBIL6O_BIT                      0
-#define VBIL6O_WID                      4
-
-#define CVD2_VBI_DATA_TYPE_LINE7                         ((CVD_BASE_ADD+0x43)<<2)
-#define VBIL7E_BIT                      4
-#define VBIL7E_WID                      4
-#define VBIL7O_BIT                      0
-#define VBIL7O_WID                      4
-
-#define CVD2_VBI_DATA_TYPE_LINE8                         ((CVD_BASE_ADD+0x44)<<2)
-#define VBIL8E_BIT                      4
-#define VBIL8E_WID                      4
-#define VBIL8O_BIT                      0
-#define VBIL8O_WID                      4
-
-#define CVD2_VBI_DATA_TYPE_LINE9                         ((CVD_BASE_ADD+0x45)<<2)
-#define VBIL9E_BIT                      4
-#define VBIL9E_WID                      4
-#define VBIL9O_BIT                      0
-#define VBIL9O_WID                      4
-
-#define CVD2_VBI_DATA_TYPE_LINE10                        ((CVD_BASE_ADD+0x46)<<2)
-#define VBIL10E_BIT                     4
-#define VBIL10E_WID                     4
-#define VBIL10O_BIT                     0
-#define VBIL10O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE11                        ((CVD_BASE_ADD+0x47)<<2)
-#define VBIL11E_BIT                     4
-#define VBIL11E_WID                     4
-#define VBIL11O_BIT                     0
-#define VBIL11O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE12                        ((CVD_BASE_ADD+0x48)<<2)
-#define VBIL12E_BIT                     4
-#define VBIL12E_WID                     4
-#define VBIL12O_BIT                     0
-#define VBIL12O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE13                        ((CVD_BASE_ADD+0x49)<<2)
-#define VBIL13E_BIT                     4
-#define VBIL13E_WID                     4
-#define VBIL13O_BIT                     0
-#define VBIL13O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE14                        ((CVD_BASE_ADD+0x4A)<<2)
-#define VBIL14E_BIT                     4
-#define VBIL14E_WID                     4
-#define VBIL14O_BIT                     0
-#define VBIL14O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE15                        ((CVD_BASE_ADD+0x4B)<<2)
-#define VBIL15E_BIT                     4
-#define VBIL15E_WID                     4
-#define VBIL15O_BIT                     0
-#define VBIL15O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE16                        ((CVD_BASE_ADD+0x4C)<<2)
-#define VBIL16E_BIT                     4
-#define VBIL16E_WID                     4
-#define VBIL16O_BIT                     0
-#define VBIL16O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE17                        ((CVD_BASE_ADD+0x4D)<<2)
-#define VBIL17E_BIT                     4
-#define VBIL17E_WID                     4
-#define VBIL17O_BIT                     0
-#define VBIL17O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE18                        ((CVD_BASE_ADD+0x4E)<<2)
-#define VBIL18E_BIT                     4
-#define VBIL18E_WID                     4
-#define VBIL18O_BIT                     0
-#define VBIL18O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE19                        ((CVD_BASE_ADD+0x4F)<<2)
-#define VBIL19E_BIT                     4
-#define VBIL19E_WID                     4
-#define VBIL19O_BIT                     0
-#define VBIL19O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE20                        ((CVD_BASE_ADD+0x50)<<2)
-#define VBIL20E_BIT                     4
-#define VBIL20E_WID                     4
-#define VBIL20O_BIT                     0
-#define VBIL20O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE21                        ((CVD_BASE_ADD+0x51)<<2)
-#define VBIL21E_BIT                     4
-#define VBIL21E_WID                     4
-#define VBIL21O_BIT                     0
-#define VBIL21O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE22                        ((CVD_BASE_ADD+0x52)<<2)
-#define VBIL22E_BIT                     4
-#define VBIL22E_WID                     4
-#define VBIL22O_BIT                     0
-#define VBIL22O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE23                        ((CVD_BASE_ADD+0x53)<<2)
-#define VBIL23E_BIT                     4
-#define VBIL23E_WID                     4
-#define VBIL23O_BIT                     0
-#define VBIL23O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE24                        ((CVD_BASE_ADD+0x54)<<2)
-#define VBIL24E_BIT                     4
-#define VBIL24E_WID                     4
-#define VBIL24O_BIT                     0
-#define VBIL24O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE25                        ((CVD_BASE_ADD+0x55)<<2)
-#define VBIL25E_BIT                     4
-#define VBIL25E_WID                     4
-#define VBIL25O_BIT                     0
-#define VBIL25O_WID                     4
-
-#define CVD2_VBI_DATA_TYPE_LINE26                        ((CVD_BASE_ADD+0x56)<<2)
-#define VBIL26E_BIT                     4
-#define VBIL26E_WID                     4
-#define VBIL26O_BIT                     0
-#define VBIL26O_WID                     4
-
-#define CVD2_VBI_SLIER_MODE_SEL                          ((CVD_BASE_ADD+0x57)<<2)
-#define VPS_SLICER_MODE_BIT             6
-#define VPS_SLICER_MODE_WID             2
-#define WSS_SLICER_MODE_BIT             4
-#define WSS_SLICER_MODE_WID             2
-#define TT_SLICER_MODE_BIT              2
-#define TT_SLICER_MODE_WID              2
-#define CC_SLICER_MODE_BIT              0
-#define CC_SLICER_MODE_WID              2
-
-#define CVD2_VBI_LPF_FINE_GAIN                           ((CVD_BASE_ADD+0x58)<<2)
-#define VPS_LPF_FINE_GAIN_BIT           6
-#define VPS_LPF_FINE_GAIN_WID           2
-#define WSS_LPF_FINE_GAIN_BIT           4
-#define WSS_LPF_FINE_GAIN_WID           2
-#define TT_LPF_FINE_GAIN_BIT            2
-#define TT_LPF_FINE_GAIN_WID            2
-#define CC_LPF_FINE_GAIN_BIT            0
-#define CC_LPF_FINE_GAIN_WID            2
-
-#define CVD2_VBI_CC_DTO_MSB                              ((CVD_BASE_ADD+0x59)<<2)
-#define CC_DTO_MSB_BIT                  0
-#define CC_DTO_MSB_WID                  8
-
-#define CVD2_VBI_CC_DTO_LSB                              ((CVD_BASE_ADD+0x5A)<<2)
-#define CC_DTO_LSB_BIT                  0
-#define CC_DTO_LSB_WID                  8
-
-#define CVD2_VBI_TT_DTO_MSB                              ((CVD_BASE_ADD+0x5B)<<2)
-#define TT_DTO_MSB_BIT                  0
-#define TT_DTO_MSB_WID                  8
-
-#define CVD2_VBI_TT_DTO_LSB                              ((CVD_BASE_ADD+0x5C)<<2)
-#define TT_DTO_LSB_BIT                  0
-#define TT_DTO_LSB_WID                  8
-
-#define CVD2_VBI_WSS_DTO_MSB                             ((CVD_BASE_ADD+0x5D)<<2)
-#define WSS_DTO_MSB_BIT                 0
-#define WSS_DTO_MSB_WID                 8
-
-#define CVD2_VBI_WSS_DTO_LSB                             ((CVD_BASE_ADD+0x5E)<<2)
-#define WSS_DTO_LSB_BIT                 0
-#define WSS_DTO_LSB_WID                 8
-
-#define CVD2_VBI_VPS_DTO_MSB                             ((CVD_BASE_ADD+0x5F)<<2)
-#define VPS_DTO_MSB_BIT                 0
-#define VPS_DTO_MSB_WID                 8
-
-#define CVD2_VBI_VPS_DTO_LSB                             ((CVD_BASE_ADD+0x60)<<2)
-#define VPS_DTO_LSB_BIT                 0
-#define VPS_DTO_LSB_WID                 8
-
-#define CVD2_VBI_FRAME_START                             ((CVD_BASE_ADD+0x61)<<2)
-#define VPS_FRAME_START_BIT             6
-#define VPS_FRAME_START_WID             2
-#define TT_FRAME_START_BIT              2
-#define TT_FRAME_START_WID              2
-#define WSS_FRAME_START_BIT             4
-#define WSS_FRAME_START_WID             2
-#define CC_FRAME_START_BIT              0
-#define CC_FRAME_START_WID              2
-
-#define CVD2_VBI_CC_DATA1                                ((CVD_BASE_ADD+0x62)<<2)
-#define CC_DATA0_BIT                    0
-#define CC_DATA0_WID                    8
-
-#define CVD2_VBI_CC_DATA2                                ((CVD_BASE_ADD+0x63)<<2)
-#define CC_DATA1_BIT                    0
-#define CC_DATA1_WID                    8
-
-#define CVD2_VBI_WSSJ_DELTA_AMPL                         ((CVD_BASE_ADD+0x64)<<2)
-#define WSSJ_DELTA_AMPL_BIT             0
-#define WSSJ_DELTA_AMPL_WID             8
-
-#define CVD2_VBI_DATA_STATUS                             ((CVD_BASE_ADD+0x65)<<2)
-
-
-#define CVD2_VBI_CC_LPF                                  ((CVD_BASE_ADD+0x66)<<2)
-#define CC_LPFIL_TRACK_GAIN_BIT         4
-#define CC_LPFIL_TRACK_GAIN_WID         8
-#define CC_LPFIL_ACQ_GAIN_BIT           0
-#define CC_LPFIL_ACQ_GAIN_WID           4
-
-#define CVD2_VBI_TT_LPF                                  ((CVD_BASE_ADD+0x67)<<2)
-#define TT_LPFIL_TRACK_GAIN_BIT         4
-#define TT_LPFIL_TRACK_GAIN_WID         8
-#define TT_LPFIL_ACQ_GAIN_BIT           0
-#define TT_LPFIL_ACQ_GAIN_WID           4
-
-#define CVD2_VBI_WSS_LPF                                  ((CVD_BASE_ADD+0x68)<<2)
-#define WSS_LPFIL_TRACK_GAIN_BIT        4
-#define WSS_LPFIL_TRACK_GAIN_WID        8
-#define WSS_LPFIL_ACQ_GAIN_BIT          0
-#define WSS_LPFIL_ACQ_GAIN_WID          4
-
-#define CVD2_VBI_VPS_LPF                                  ((CVD_BASE_ADD+0x69)<<2)
-#define VPS_LPFIL_TRACK_GAIN_BIT        4
-#define VPS_LPFIL_TRACK_GAIN_WID        8
-#define VPS_LPFIL_ACQ_GAIN_BIT          0
-#define VPS_LPFIL_ACQ_GAIN_WID          4
-
-//#define CVD2_VBI_DATA_TYPE_LINE6                         ((CVD_BASE_ADD+0x6A)<<2)
-//    #define VBIL6E_BIT                      4
-//    #define VBIL6E_WID                      4
-//    #define VBIL6O_BIT                      0
-//    #define VBIL6O_WID                      4
-
-#define CVD2_VBI_CC_RUNIN_ACCUM_AMPLF                      ((CVD_BASE_ADD+0x6B)<<2)
-#define CC_RUNIN_ACCUM_AMPLF_BIT         0
-#define CC_RUNIN_ACCUM_AMPLF_WID         8
-
-#define CVD2_VBI_TT_RUNIN_ACCUM_AMPLF                      ((CVD_BASE_ADD+0x6C)<<2)
-#define TT_RUNIN_ACCUM_AMPLF_BIT         0
-#define TT_RUNIN_ACCUM_AMPLF_WID         8
-
-#define CVD2_VBI_WSS_DATA2                                 ((CVD_BASE_ADD+0x6D)<<2)
-#define WSSDATA2_BIT                     0
-#define WSSDATA2_WID                     8
-
-#define CVD2_VBI_WSS_DATA1                                 ((CVD_BASE_ADD+0x6E)<<2)
-#define WSSDATA1_BIT                     0
-#define WSSDATA1_WID                     8
-
-#define CVD2_VBI_WSS_DATA0                                 ((CVD_BASE_ADD+0x6F)<<2)
-#define WSSDATA0_BIT                     0
-#define WSSDATA0_WID                     8
-
-#define CVD2_VBI_CC_START                                  ((CVD_BASE_ADD+0xF5)<<2)
-#define CC_START_BIT                     0
-#define CC_START_WID                     8
-
-#define CVD2_VBI_WSS_START                                 ((CVD_BASE_ADD+0xF6)<<2)
-#define WSS_START_BIT                    0
-#define WSS_START_WID                    8
-
-#define CVD2_VBI_TT_START                                  ((CVD_BASE_ADD+0xF7)<<2)
-#define TT_START_BIT                     0
-#define TT_START_WID                     8
-
-#define CVD2_VBI_VPS_START                                 ((CVD_BASE_ADD+0xF8)<<2)
-#define VPS_START_BIT                    0
-#define VPS_START_WID                    8
-
-#define CVD2_VBI_CONTROL                                   ((CVD_BASE_ADD+0xF9)<<2)
-#define VBI_FIXGATE_EN_BIT               0
-#define VBI_FIXGATE_EN_WID               1
-
-#endif  // _TVAFE_REG_H
diff --git a/drivers/amlogic/tvin/tvafe/tvin_vbi.c b/drivers/amlogic/tvin/tvafe/tvin_vbi.c
deleted file mode 100755
index d6579dd98939..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvin_vbi.c
+++ /dev/null
@@ -1,1199 +0,0 @@
-/*
- * TVAFE char device driver.
- *
- * Copyright (c) 2010 Frank zhao <frank.zhao@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the smems of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- */
-
-/* Standard Linux headers */
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/cdev.h>
-#include <linux/platform_device.h>
-#include <asm/uaccess.h>
-//#include <linux/mutex.h>
-#include <linux/mm.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/vmalloc.h>
-#include <asm/io.h> /* for virt_to_phys */
-
-/* Amlogic headers */
-#include <mach/am_regs.h>
-#include <mach/irqs.h>
-
-/* Local include */
-#include "tvafe_regs.h"
-#include "tvin_vbi.h"
-
-#define VBI_NAME               "vbi"
-#define VBI_DRIVER_NAME        "vbi"
-#define VBI_MODULE_NAME        "vbi"
-#define VBI_DEVICE_NAME        "vbi"
-#define VBI_CLASS_NAME         "vbi"
-
-static dev_t vbi_id;
-static struct class *vbi_clsp;
-static struct vbi_dev_s *vbi_dev;
-
-#define VBI_DEFAULT_BUFFER_SIZE 8192 //default buffer size
-#define VBI_IRQ_EN //kuka add
-#define VBI_TIMER_INTERVAL     (HZ/100)   //10ms, #define HZ 100 kuka add
-#define MEM_TEST //kuka add
-/******debug********/
-static int vbi_dbg_en = 0;
-MODULE_PARM_DESC(vbi_dbg_en, "\n vbi_dbg_en\n");
-module_param(vbi_dbg_en, int, 0664);
-
-static int capture_print_en = 0;
-MODULE_PARM_DESC(capture_print_en, "\n capture_print_en\n");
-module_param(capture_print_en, int, 0664);
-
-static int data_print_en = 0;
-MODULE_PARM_DESC(data_print_en, "\n data_print_en\n");
-module_param(data_print_en, int, 0664);
-
-static int bypass_slicer = 1;
-MODULE_PARM_DESC(bypass_slicer, "\n bypass_slicer\n");
-module_param(bypass_slicer, int, 0664);
-
-#if 0  //not used now
-static void vbi_enable_lines(unsigned short start_line, unsigned short end_line, unsigned char data_type)
-{
-    int i = 0;
-
-    /*@todo*/
-    if ((start_line < VBI_LINE_MIN)) {
-        if (vbi_dbg_en)
-            pr_info("[vbi..]: start line abnormal!!! line:%d \n", start_line);
-        start_line = VBI_LINE_MIN;
-    }
-
-    if ((end_line > VBI_LINE_MAX)) {
-        if (vbi_dbg_en)
-            pr_info("[vbi..]: end line abnormal!!! line:%d \n", end_line);
-        end_line = VBI_LINE_MAX;
-    }
-
-    for(i = VBI_LINE_MIN; i <= VBI_LINE_MAX ; i++) {
-        if ((i < start_line) || (i > end_line)){
-            WRITE_APB_REG((CVD2_VBI_DATA_TYPE_LINE7 + i - VBI_LINE_MIN), 0);
-            continue;
-        }
-        if (i == VBI_LINE_MIN) {
-            WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE6, data_type);
-        } else {
-            WRITE_APB_REG((CVD2_VBI_DATA_TYPE_LINE7 + i - VBI_LINE_MIN), data_type);
-            if (vbi_dbg_en)
-                pr_info("[vbi..]: set line:%d type to 0x%x \n", i, data_type);
-        }
-    }
-}
-#endif 
-static void vbi_hw_init(struct vbi_dev_s *devp)
-{
-    /* vbi memory setting */
-    WRITE_APB_REG(ACD_REG_2F, devp->mem_start >> 3);
-    WRITE_APB_REG_BITS(ACD_REG_21, ((devp->mem_size >> 3) - 1), 16, 16);
-    WRITE_APB_REG_BITS(ACD_REG_21, 0, AML_VBI_START_ADDR_BIT, AML_VBI_START_ADDR_WID);
-
-#if defined(VBI_CC_SUPPORT)
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE21, 0x11);
-    WRITE_APB_REG(CVD2_VSYNC_VBI_LOCKOUT_START, 0x00000000);
-    WRITE_APB_REG(CVD2_VSYNC_VBI_LOCKOUT_END, 0x00000025);
-    WRITE_APB_REG(CVD2_VSYNC_TIME_CONSTANT, 0x0000004a);
-    WRITE_APB_REG(ACD_REG_22, 0x82080000); // manuel reset vbi
-    WRITE_APB_REG(ACD_REG_22, 0x04080000); // vbi reset release, vbi agent enable
-    WRITE_APB_REG(CVD2_VBI_CC_START, 0x00000054);
-    WRITE_APB_REG(CVD2_VBI_FRAME_CODE_CTL, 0x00000015);
-#endif
-
-#if defined(VBI_TT_SUPPORT)
-    //625B
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE6,  0x66);  // > /sys/class/amdbg/reg             //  0x6    0x6
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE7 , 0x66);  // > /sys/class/amdbg/reg             //  0x7    0x7
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE8 , 0x66);  // > /sys/class/amdbg/reg             //  0x8    0x8
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE9 , 0x66);  // > /sys/class/amdbg/reg             //  0x9    0x9
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE10, 0x66);  // > /sys/class/amdbg/reg             //  0xa    0xa
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE11, 0x66);  // > /sys/class/amdbg/reg             //  0xb    0xb
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE12, 0x66);  // > /sys/class/amdbg/reg             //  0xc    0xc
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE13, 0x66);  // > /sys/class/amdbg/reg             //  0xd    0xd
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE14, 0x66);  // > /sys/class/amdbg/reg             //  0xe    0xe
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE15, 0x66);  // > /sys/class/amdbg/reg             //  0xf    0xf
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE16, 0x66);  // > /sys/class/amdbg/reg             //  0x10   0x10
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE17, 0x66);  // > /sys/class/amdbg/reg             //  0x11   0x11
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE18, 0x66);  // > /sys/class/amdbg/reg             //  0x12   0x12
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE19, 0x66);  // > /sys/class/amdbg/reg             //  0x13   0x13
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE20, 0x66);  // > /sys/class/amdbg/reg             //  0x14   0x14
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE21, 0x66);  // > /sys/class/amdbg/reg             //  0x15   0x15
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE22, 0x66);  // > /sys/class/amdbg/reg             //  0x16   0x16
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE23, 0x66);  // > /sys/class/amdbg/reg             //  0x17   0x17
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE24, 0x66);  // > /sys/class/amdbg/reg             //  0x18   0x18
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE25, 0x66);  // > /sys/class/amdbg/reg             //  0x19   0x19
-    WRITE_APB_REG(CVD2_VBI_DATA_TYPE_LINE26, 0x66);  // > /sys/class/amdbg/reg             //  0x20   0x20
-
-    WRITE_APB_REG(CVD2_VSYNC_VBI_LOCKOUT_START, 0x00000000);
-    WRITE_APB_REG(CVD2_VSYNC_VBI_LOCKOUT_END, 0x00000025);
-    WRITE_APB_REG(CVD2_VSYNC_TIME_CONSTANT, 0x0000004a);
-    WRITE_APB_REG(ACD_REG_22, 0x82080000); // manuel reset vbi
-    WRITE_APB_REG(ACD_REG_22, 0x04080000); // vbi reset release, vbi agent enable
-
-    WRITE_APB_REG(CVD2_VBI_TT_FRAME_CODE_CTL,0x27);  //echo wa 0x1841 27 > /sys/class/amdbg/reg
-
-    WRITE_APB_REG(CVD2_VBI_TT_DTO_MSB,       0x0d);  //echo wa 0x185b 0x0d > /sys/class/amdbg/reg
-    WRITE_APB_REG(CVD2_VBI_TT_DTO_LSB,       0xd6);  //echo wa 0x185c 0xd6 > /sys/class/amdbg/reg
-
-    WRITE_APB_REG(CVD2_VBI_FRAME_START,      0xaa);  //echo wa 0x1861 0xaa > /sys/class/amdbg/reg
-    WRITE_APB_REG(CVD2_VBI_TT_START,         0x64);  //echo wa 0x18f7 0x64 > /sys/class/amdbg/reg
-
-    WRITE_APB_REG(CVD2_VBI_FRAME_CODE_CTL,   0x14);  //echo wa 0x1840 0x14 > /sys/class/amdbg/reg
-    WRITE_APB_REG(CVD2_VBI_FRAME_CODE_CTL,   0x15);  //echo wa 0x1840 0x15 > /sys/class/amdbg/reg
-
-#endif
-    pr_info("[vbi..] %s: vbi hw init.\n", __func__);
-
-}
-
-static inline int odd_parity_check(int b)
-{
-    int chk, k;
-
-    chk = (b & 1);
-    for (k=0; k<7; k++){
-        b >>= 1;
-        chk ^= (b & 1);
-    }
-    return (chk & 1);
-}
-
-//retbyte = ioread8(rdptr); 
-//retbyte = *(rdptr); 
-#ifdef MEM_TEST
-#if 0
-#define vbi_get_byte(rdptr, total_buffer, devp, retbyte) \
-{\
-    retbyte = *(rdptr); \
-    rdptr +=1; \
-    if (rdptr > devp->pac_addr_end) \
-        rdptr = devp->pac_addr_start; \
-    total_buffer--; \
-}
-#else
-#define vbi_get_byte(rdptr, total_buffer, retbyte) \
-{\
-    retbyte = *(rdptr); \
-    rdptr +=1; \
-}
-
-#endif
-#else
-#define vbi_get_byte(rdptr, total_buffer, devp, retbyte) \
-{\
-	retbyte = ioread8(rdptr); \
-    rdptr +=1; \
-    if (rdptr > devp->pac_addr_end) \
-        rdptr = devp->pac_addr_start; \
-    total_buffer--; \
-}
-
-#endif
-#define vbi_skip_bytes(rdptr, total_buffer, devp, nbytes) \
-{\
-    rdptr += nbytes;\
-    if (rdptr > devp->pac_addr_end)\
-        rdptr = devp->pac_addr_start;\
-    total_buffer -=nbytes;\
-}
-
-#define vbi_get_last_byte_addr(rdptr, devp, nbytes, retaddr)  \
-{\
-    uint i;\
-    u8 *p = rdptr;\
-    for (i=0; i<nbytes; i++){\
-        p -= 1;\
-        if (p < devp->pac_addr_start)\
-            p = devp->pac_addr_end;\
-    }\
-    retaddr = p;\
-}
-
-ssize_t vbi_ringbuffer_free(struct vbi_ringbuffer_s *rbuf)
-{
-    ssize_t free;
-
-    free = rbuf->pread - rbuf->pwrite;
-
-    if (free <= 0) {
-        free += rbuf->size;
-        if (capture_print_en)
-            pr_info("[vbi..] %s: pread: %6d pwrite: %6d\n", __func__,rbuf->pread , rbuf->pwrite);
-    }
-    return free-1;
-}
-
-
-ssize_t vbi_ringbuffer_write(struct vbi_ringbuffer_s *rbuf, const struct cc_data_s *buf, size_t len)
-{
-    size_t todo = len;
-    size_t split;
-	//unsigned int i;
-    split = (rbuf->pwrite + len > rbuf->size) ? rbuf->size - rbuf->pwrite : 0;
-
-    if (split > 0) {
-        if (capture_print_en)
-            pr_info("[vbi..] %s: pwrite: %6d\n", __func__, rbuf->pwrite);
-        memcpy((char*)rbuf->data+rbuf->pwrite, (char*)buf, split);
-        buf += split;
-        todo -= split;
-        rbuf->pwrite = 0;
-    }
-    memcpy((char*)rbuf->data+rbuf->pwrite, (char*)buf, todo);
-    rbuf->pwrite = (rbuf->pwrite + todo) % rbuf->size;
-
-    return len;
-}
-
-
-static int vbi_buffer_write(struct vbi_ringbuffer_s *buf,
-                   const struct cc_data_s *src, size_t len)
-{
-    ssize_t free;
-
-    if (!len) {
-        if (capture_print_en)
-            pr_info("[vbi..] %s: buffer len is zero\n", __func__);
-        return 0;
-    }
-    if (!buf->data) {
-        if (capture_print_en)
-            pr_info("[vbi..] %s: buffer data pointer is zero\n", __func__);
-        return 0;
-    }
-
-    free = vbi_ringbuffer_free(buf);
-    if (len > free) {
-        if (capture_print_en)
-            pr_info("[vbi..] %s: buffer overflow ,len: %6d, free: %6d\n", __func__, len, free);
-        return -EOVERFLOW;
-    }
-
-    return vbi_ringbuffer_write(buf, src, len);
-}
-
-#ifdef VBI_IRQ_EN
-static irqreturn_t vbi_isr(int irq, void *dev_id)
-{
-    ulong flags;
-    struct vbi_dev_s *devp = (struct vbi_dev_s *)dev_id;
-    spin_lock_irqsave(&devp->vbi_isr_lock, flags);
-#if 0//no use
-    if (devp->vs_delay > 0) {
-        devp->vs_delay--;
-        devp->current_pac_wptr = READ_APB_REG(ACD_REG_0C);//addr - (devp->mem_start);
-        devp->last_pac_wptr = devp->current_pac_wptr;
-        devp->pac_addr = devp->pac_addr_start + (devp->current_pac_wptr << 3) - devp->mem_start;  //last data package address
-        pr_info("[vbi..]: vsync cnt:%d, wptr: %6d... ... ........\n", devp->vs_delay, devp->current_pac_wptr);
-        devp->vbi_start = true;
-        spin_unlock_irqrestore(&devp->vbi_isr_lock, flags);
-        return IRQ_HANDLED;
-    }
-#else
-		devp->vbi_start = true;
-#endif
-    if (devp->vbi_start == false) {
-        spin_unlock_irqrestore(&devp->vbi_isr_lock, flags);
-        return IRQ_HANDLED;
-    }
-    /* Mark tasklet as pending */
-    tasklet_schedule(&vbi_dev->tsklt_slicer);
-
-    spin_unlock_irqrestore(&devp->vbi_isr_lock, flags);
-
-    return IRQ_HANDLED;
-}
-#else
-//kuka add begin
-void vbi_timer_handler(unsigned long dev_id)
-{
-	ulong flags;
-	struct vbi_dev_s *devp = (struct vbi_dev_s *)dev_id;
-    devp->timer.expires = jiffies + VBI_TIMER_INTERVAL;
-    add_timer(&devp->timer);
-
-	spin_lock_irqsave(&devp->vbi_isr_lock, flags);
-#if 0//for no use
-	if (devp->vs_delay > 0) {
-		devp->vs_delay--;
-		devp->current_pac_wptr = READ_APB_REG(ACD_REG_0C);//addr - (devp->mem_start);
-		devp->last_pac_wptr = devp->current_pac_wptr;
-		if(devp->current_pac_wptr != 0){
-			devp->pac_addr = devp->pac_addr_start + (devp->current_pac_wptr << 3) - devp->mem_start;  //last data package address
-		}
-		pr_info("[vbi..]: vsync cnt:%d, wptr: %6d... ... ........\n", devp->vs_delay, devp->current_pac_wptr);
-		devp->vbi_start = true;
-		spin_unlock_irqrestore(&devp->vbi_isr_lock, flags);
-		return ;
-	}
-#else
-	devp->vbi_start = true;
-#endif
-	if (devp->vbi_start == false) {
-		spin_unlock_irqrestore(&devp->vbi_isr_lock, flags);
-		return ;
-	}
-	/* Mark tasklet as pending */
-	tasklet_schedule(&vbi_dev->tsklt_slicer);
-	spin_unlock_irqrestore(&devp->vbi_isr_lock, flags);
-
-	return ;
-}
-//kuka add end
-#endif
-
-static void vbi_slicer_task(unsigned long arg)
-{
-    struct vbi_dev_s *devp = (struct vbi_dev_s *)arg;
-    unsigned char rbyte = 0;
-    unsigned short pre_val = 0;
-    int i = 0;
-    int bytes_buffer = 0, bytes_buf_backup = 0;
-    unsigned char *current_pac_addr, *wr_addr,*rptr,*sync_addr,*addr,*local_rptr;
-    unsigned char wr_burst = VBI_WRITE_BURST_BYTE;
-    uint sync_code = (uint)-1;
-    struct cc_data_s sliced_data;
-    unsigned int len;
-    if (devp->vbi_start == false)
-        return;
-    rptr = devp->pac_addr;  //backup package data pointer
-    devp->current_pac_wptr = READ_APB_REG(ACD_REG_0C);
-	if(devp->current_pac_wptr != 0)
-    	current_pac_addr = devp->pac_addr_start + (devp->current_pac_wptr<<3) - devp->mem_start;
-	else
-		current_pac_addr = devp->pac_addr_start;
-
-    if (devp->last_pac_wptr != devp->current_pac_wptr) {
-         // Go back 8 BEATS! Don't remove this if running with > 1 BEAT VBI burst.
-        vbi_get_last_byte_addr(current_pac_addr, devp, wr_burst, wr_addr)
-        //if (vbi_dbg_en)
-        //    pr_info("[vbi..]: Start rptr:0x%p, current_pac_addr:0x%p , wr_addr:0x%p...\n", rptr, current_pac_addr, wr_addr);
-    } else {
-        wr_addr = current_pac_addr;
-        if (vbi_dbg_en)
-            pr_info("[vbi..]: last_wptr == current_wptr:0x%x ...\n",  devp->current_pac_wptr);
-    }
-    devp->last_pac_wptr = devp->current_pac_wptr;  //backup current wptr
-
-    //get tatal bytes
-    bytes_buffer = (wr_addr >= devp->pac_addr)?
-        (wr_addr - devp->pac_addr):((devp->mem_size + wr_addr) - devp->pac_addr);
-	memcpy(devp->pac_addr_end + 1,rptr,bytes_buffer);
-    bytes_buffer -= VBI_WRITE_BURST_BYTE;//???
-    //temp_bytes_buffer = bytes_buffer;
-	local_rptr = devp->pac_addr_end + 1;
-	
-    //  wordsInBuffer >>=3; /* in 8 bytes word*/
-    if(bytes_buffer < VBI_WRITE_BURST_BYTE) {
-        if (vbi_dbg_en)
-            pr_info("[vbi..]: over range bytes_buffer:0x%x, wr_addr:0x%p,rptr:0x%p ... ...\n", bytes_buffer,wr_addr, rptr);
-        goto err_exit;
-    }
-    //if (vbi_dbg_en)
-    //    pr_info("[vbi..]: Start, bytes_buffer:%d, rptr:0x%p, wr_addr:0x%p, current_pac_addr:0x%p ...\n", bytes_buffer,rptr, wr_addr, current_pac_addr);
-    while(bytes_buffer >= -3) {
-		vbi_get_byte(local_rptr, bytes_buffer, rbyte)
-        vbi_skip_bytes(rptr, bytes_buffer, devp, 1)
-        sync_code <<= 8;
-        sync_code |= rbyte;
-		
-        if ((sync_code & 0xFFFFFF) != 0x00FFFF) {
-            if((0 == rbyte) && (bytes_buffer < -2))
-            {
-                vbi_get_last_byte_addr(rptr, devp, 1, devp->pac_addr)
-                //if (vbi_dbg_en)
-                //    pr_info("[vbi..]:  PRE1 rptr:%p=0x%x, pac_addr:%p ... ...\n", rptr,rbyte, devp->pac_addr);
-
-                goto err_exit;
-            } else if((0xFF == rbyte) && (bytes_buffer < -3)) {
-                vbi_get_last_byte_addr(rptr, devp, 2, devp->pac_addr)
-                //if (vbi_dbg_en)
-                //    pr_info("[vbi..]: PRE2 rptr:%p=0x%x, pac_addr:%p ... ...\n", rptr,rbyte, devp->pac_addr);
-
-                goto err_exit;
-            } else {
-                //if (vbi_dbg_en && rbyte != 0)
-                //    pr_info("[vbi..]:  not find PRE,bytes_buffer:%d rptr:%p,val:%x, pac_addr:%p ... ...\n", bytes_buffer,rptr,rbyte, devp->pac_addr);
-                continue;
-            }
-        }
-        vbi_get_last_byte_addr(rptr, devp, 3, sync_addr)
-
-        /* if we don't have packet ID and length byte in the buffer then wait for next time */
-        if(bytes_buffer < -3) {
-            devp->pac_addr = sync_addr;
-            if (vbi_dbg_en)
-                pr_info("[vbi..]: wait next vs pac; pac_addr:%p ... ...\n",  devp->pac_addr);
-            goto err_exit;
-        }
-        vbi_get_byte(local_rptr, bytes_buffer, rbyte)  // status
-        vbi_skip_bytes(rptr, bytes_buffer, devp, 1)
-        sliced_data.vbi_type = (rbyte>>1) & 0x7;
-        sliced_data.field_id = rbyte & 1;
-#if defined(VBI_TT_SUPPORT)
-        sliced_data->tt_sys = rbyte >> 5;
-#endif
-        if(sliced_data.vbi_type > MAX_PACKET_TYPE) {
-            vbi_skip_bytes(rptr, bytes_buffer, devp, 1)
-            if (vbi_dbg_en)
-                pr_info("[vbi..]: invalid pac type, go on; pac_addr:%p ... ...\n",  devp->pac_addr);
-            continue;
-        }
-
-        vbi_get_byte(local_rptr, bytes_buffer, rbyte)  // byte counter
-		vbi_skip_bytes(rptr, bytes_buffer, devp, 1)
-        //check range by byte counter
-        bytes_buf_backup = bytes_buffer;
-        addr = rptr;
-        vbi_skip_bytes(rptr, bytes_buffer, devp, rbyte)
-        if(bytes_buffer < -3) {
-            devp->pac_addr = sync_addr;
-            if (vbi_dbg_en)
-                pr_info("[vbi..]: wait next vs pac; pac_addr:%p ... ...\n",  devp->pac_addr);
-            goto err_exit;
-        }
-        bytes_buffer = bytes_buf_backup;
-        rptr = addr;
-        sliced_data.nbytes = rbyte;
-
-        vbi_get_byte(local_rptr, bytes_buffer, rbyte)  // line number
-        vbi_skip_bytes(rptr, bytes_buffer, devp, 1)
-        pre_val = (u16)rbyte;
-        vbi_get_byte(local_rptr, bytes_buffer, rbyte)
-		vbi_skip_bytes(rptr, bytes_buffer, devp, 1)
-        pre_val |= ((u16)rbyte & 0x3 )<< 8;
-        sliced_data.line_num = pre_val;
-		addr = rptr;
-
-        if ((rptr + sliced_data.nbytes) <= vbi_dev->pac_addr_end) {
-			#ifdef MEM_TEST
-            memcpy(&(sliced_data.b[0]), rptr, sliced_data.nbytes);
-			#else
-            memcpy_fromio(&(sliced_data.b[0]), rptr, sliced_data.nbytes);
-			#endif
-            //rptr += buf[devp->sli_wr].nbytes;
-            //if (vbi_dbg_en)
-            //    pr_info("[vbi..] %s: normal addr pac = 0x%p ; bytes: %2d ... ... \n", __func__, vbi_dev->pac_addr,(sliced_data.nbytes));
-        }  else {
-            i = (vbi_dev->pac_addr_end - rptr + 1);
-			#ifdef MEM_TEST
-            memcpy(&sliced_data.b[0], rptr, i);
-            memcpy(&sliced_data.b[i], vbi_dev->pac_addr_start, (sliced_data.nbytes - i));
-			#else			
-            memcpy_fromio(&sliced_data.b[0], rptr, i);
-            //pr_info("[vbi..] %s: over range addr pac = 0x%p; cnt:%d ... ... \n", __func__, vbi_dev->pac_addr, i);
-            //rptr = vbi_dev->pac_addr_start;
-            memcpy_fromio(&sliced_data.b[i], vbi_dev->pac_addr_start, (sliced_data.nbytes - i));
-            //rptr += (buf[devp->sli_wr].nbytes - i);
-            //if (vbi_dbg_en)
-            //    pr_info("[vbi..] %s: over range addr pac = 0x%p; cnt:%d ... ... \n", __func__, vbi_dev->pac_addr, (buf[devp->sli_wr].nbytes - i));
-            #endif
-        }
-			
-        vbi_skip_bytes(rptr, bytes_buffer, devp, sliced_data.nbytes)  //go to next package
-        if (data_print_en) {
-            printk("[vbi..]: cnt:%4d, line:%3x; ", bytes_buffer, sliced_data.line_num);
-
-            for(i=0; i<sliced_data.nbytes ; i++) {
-                printk("%2x ", sliced_data.b[i]);
-            }
-            printk("\n" );
-        }
-        //capture data to vbi buffer
-        len = sizeof(struct cc_data_s);
-        vbi_buffer_write(&devp->slicer->buffer, &sliced_data, len);
-		//pr_info("[vbi..]%s: sliced_data.field_id : %d; sliced_data.line_num : %d \n", __FUNCTION__, sliced_data.field_id,sliced_data.line_num);
-		if(devp->slicer->buffer.pread != devp->slicer->buffer.pwrite){
-			wake_up(&devp->slicer->buffer.queue);
-		}	
-    }
-    devp->pac_addr = rptr;
-err_exit:
-
-    return;
-}
-
-void vbi_ringbuffer_flush(struct vbi_ringbuffer_s *rbuf)
-{
-    rbuf->pread = rbuf->pwrite;
-    rbuf->error = 0;
-}
-
-static inline void vbi_slicer_state_set(struct vbi_dev_s *dev, int state)
-{
-    spin_lock_irq(&dev->lock);
-    dev->slicer->state = state;
-    spin_unlock_irq(&dev->lock);
-}
-
-static inline int vbi_slicer_reset(struct vbi_dev_s *dev)
-{
-    if (dev->slicer->state < VBI_STATE_SET)
-        return 0;
-
-    dev->slicer->type = VBI_TYPE_NULL;
-    vbi_slicer_state_set(dev, VBI_STATE_ALLOCATED);
-    return 0;
-}
-
-static int vbi_slicer_stop(struct vbi_slicer_s *vbi_slicer)
-{
-    if (vbi_slicer->state < VBI_STATE_GO)
-        return 0;
-    vbi_slicer->state = VBI_STATE_DONE;
-
-    vbi_ringbuffer_flush(&vbi_slicer->buffer);
-
-    return 0;
-}
-
-static int vbi_slicer_free(struct vbi_dev_s *vbi_dev,
-                  struct vbi_slicer_s *vbi_slicer)
-{
-    mutex_lock(&vbi_dev->mutex);
-    mutex_lock(&vbi_slicer->mutex);
-
-    vbi_slicer_stop(vbi_slicer);
-    vbi_slicer_reset(vbi_dev);
-
-    if (vbi_slicer->buffer.data) {
-        void *mem = vbi_slicer->buffer.data;
-
-        spin_lock_irq(&vbi_dev->lock);
-        vbi_slicer->buffer.data = NULL;
-        spin_unlock_irq(&vbi_dev->lock);
-        vfree(mem);
-    }
-
-    vbi_slicer_state_set(vbi_dev, VBI_STATE_FREE);
-    wake_up(&vbi_slicer->buffer.queue);
-    mutex_unlock(&vbi_slicer->mutex);
-    mutex_unlock(&vbi_dev->mutex);
-
-    return 0;
-}
-
-static void vbi_ringbuffer_init(struct vbi_ringbuffer_s *rbuf, void *data, size_t len)
-{
-    rbuf->pread = rbuf->pwrite = 0;
-    rbuf->data = data;
-    rbuf->size = len;
-    rbuf->error = 0;
-
-    init_waitqueue_head(&rbuf->queue);
-
-    spin_lock_init(&(rbuf->lock));
-}
-
-void vbi_ringbuffer_reset(struct vbi_ringbuffer_s *rbuf)
-{
-    rbuf->pread = rbuf->pwrite = 0;
-    rbuf->error = 0;
-}
-
-static int vbi_set_buffer_size(struct vbi_dev_s *dev,
-                      unsigned long size)
-{
-    struct vbi_slicer_s *vbi_slicer = dev->slicer;
-    struct vbi_ringbuffer_s *buf = &vbi_slicer->buffer;
-    void *newmem;
-    void *oldmem;
-
-    if (buf->size == size) {
-        pr_info("[vbi..] %s: buf->size == size \n", __func__);
-        return 0;
-    }
-    if (!size) {
-        pr_info("[vbi..] %s: buffer size is 0!!! \n", __func__);
-        return -EINVAL;
-    }
-    if (vbi_slicer->state >= VBI_STATE_GO) {
-        pr_info("[vbi..] %s: vbi_slicer busy!!! \n", __func__);
-        return -EBUSY;
-    }
-
-    newmem = vmalloc(size);
-    if (!newmem) {
-        pr_info("[vbi..] %s: get memory error!!! \n", __func__);
-        return -ENOMEM;
-    }
-
-    oldmem = buf->data;
-
-    spin_lock_irq(&dev->lock);
-    buf->data = newmem;
-    buf->size = size;
-
-    /* reset and not flush in case the buffer shrinks */
-    vbi_ringbuffer_reset(buf);
-    spin_unlock_irq(&dev->lock);
-
-    vfree(oldmem);
-
-    return 0;
-}
-
-static int vbi_slicer_start(struct vbi_dev_s *dev)
-{
-    struct vbi_slicer_s *vbi_slicer = dev->slicer;
-    void *mem;
-
-    if (vbi_slicer->state < VBI_STATE_SET)
-        return -EINVAL;
-
-    if (vbi_slicer->state >= VBI_STATE_GO)
-        vbi_slicer_stop(vbi_slicer);
-
-    if (!vbi_slicer->buffer.data) {
-        mem = vmalloc(vbi_slicer->buffer.size);
-        if (!mem) {
-            pr_info("[vbi..] %s: get memory error!!! \n", __func__);
-            return -ENOMEM;
-        }
-        spin_lock_irq(&dev->lock);
-        vbi_slicer->buffer.data = mem;
-        spin_unlock_irq(&dev->lock);
-    }
-
-    vbi_ringbuffer_flush(&vbi_slicer->buffer);
-
-    vbi_slicer_state_set(dev, VBI_STATE_GO);
-
-    return 0;
-}
-
-static int vbi_slicer_set(struct vbi_dev_s *vbi_dev,
-                 struct vbi_slicer_s *vbi_slicer)
-{
-    vbi_slicer_stop(vbi_slicer);
-
-    vbi_slicer_state_set(vbi_dev, VBI_STATE_SET);
-
-    return 0;//vbi_slicer_start(vbi_dev);
-}
-
-ssize_t vbi_ringbuffer_avail(struct vbi_ringbuffer_s *rbuf)
-{
-    ssize_t avail;
-
-    avail = rbuf->pwrite - rbuf->pread;
-    if (avail < 0)
-        avail += rbuf->size;
-    return avail;
-}
-
-int vbi_ringbuffer_empty(struct vbi_ringbuffer_s *rbuf)
-{
-    return (rbuf->pread == rbuf->pwrite);
-}
-
-ssize_t vbi_ringbuffer_read_user(struct vbi_ringbuffer_s *rbuf, u8 __user *buf, size_t len)
-{
-    size_t todo = len;
-    size_t split;
-    split = (rbuf->pread + len > rbuf->size) ? rbuf->size - rbuf->pread : 0;
-    if (split > 0) {
-		if (copy_to_user(buf, (char*)rbuf->data+rbuf->pread, split))
-            return -EFAULT;
-        buf += split;
-        todo -= split;
-        rbuf->pread = 0;
-    }
-	if (copy_to_user(buf, (char*)rbuf->data+rbuf->pread, todo))
-        return -EFAULT;
-    rbuf->pread = (rbuf->pread + todo) % rbuf->size;
-
-    return len;
-}
-
-static ssize_t vbi_buffer_read(struct vbi_ringbuffer_s *src,
-                      int non_blocking, char __user *buf,
-                      size_t count, loff_t *ppos)
-{
-    size_t todo;
-    ssize_t avail;
-    ssize_t ret = 0;
-
-    if (!src->data) {
-        pr_info("[vbi..] %s: data null \n", __func__);
-        return 0;
-    }
-
-    if (src->error) {
-        ret = src->error;
-        vbi_ringbuffer_flush(src);
-        pr_info("[vbi..] %s: data error \n", __func__);
-        return ret;
-    }
-
-    for (todo = count; todo > 0; todo -= ret) {
-        if (non_blocking && vbi_ringbuffer_empty(src)) {
-            ret = -EWOULDBLOCK;
-            pr_info("[vbi..] %s: buffer empty, non_blocking: 0x%x, empty?: %d \n", __func__, non_blocking, vbi_ringbuffer_empty(src));
-            break;
-        }
-
-        ret = wait_event_interruptible(src->queue, !vbi_ringbuffer_empty(src) || (src->error != 0));
-		//pr_info("[vbi...]%s:src->pread = %d;src->pwrite = %d\n",__FUNCTION__,src->pread,src->pwrite);
-        if (ret < 0) {
-            pr_info("[vbi..] %s: read wait_event_interruptible error \n", __func__);
-            break;
-        }
-
-        if (src->error) {
-            ret = src->error;
-            vbi_ringbuffer_flush(src);
-            pr_info("[vbi..] %s: read buffer error \n", __func__);
-            break;
-        }
-
-        avail = vbi_ringbuffer_avail(src);
-        if (avail > todo)
-            avail = todo;
-
-        ret = vbi_ringbuffer_read_user(src, buf, avail);
-        if (ret < 0) {
-            pr_info("[vbi..] %s: vbi_ringbuffer_read_user error \n", __func__);
-            break;
-        }
-        buf += ret;
-    }
-    if ((count - todo) <= 0)
-        pr_info("[vbi..] %s: read error!! counter: %x or %x \n", __func__,(count - todo) , ret);
-
-    return (count - todo) ? (count - todo) : ret;
-}
-
-static int vbi_read(struct file *file, char __user *buf, size_t count,
-        loff_t *ppos)
-{
-    struct vbi_dev_s *vbi_dev = file->private_data;
-    struct vbi_slicer_s *vbi_slicer = vbi_dev->slicer;
-    int ret;
-
-    if (mutex_lock_interruptible(&vbi_slicer->mutex)) {
-        pr_info("[vbi..] %s: slicer mutex error \n", __func__);
-        return -ERESTARTSYS;
-    }
-
-    ret = vbi_buffer_read(&vbi_slicer->buffer,
-                     file->f_flags & O_NONBLOCK,
-                     buf, count, ppos);
-
-    mutex_unlock(&vbi_slicer->mutex);
-
-    return ret;
-}
-
-static int vbi_open(struct inode *inode, struct file *file)
-{
-    struct vbi_dev_s *vbi_dev;// = file->private_data;
-
-    pr_info("[vbi..] %s: open start. \n", __func__);
-
-    vbi_dev = container_of(inode->i_cdev, struct vbi_dev_s, cdev);
-    file->private_data = vbi_dev;
-
-    if (mutex_lock_interruptible(&vbi_dev->mutex)) {
-        pr_info("[vbi..] %s: dev mutex_lock_interruptible error \n", __func__);
-        return -ERESTARTSYS;
-    }
-
-    mutex_init(&vbi_dev->slicer->mutex);
-
-    vbi_ringbuffer_init(&vbi_dev->slicer->buffer, NULL, VBI_DEFAULT_BUFFER_SIZE);  //set default buffer size--8KByte
-    vbi_dev->slicer->type = 0;
-    vbi_slicer_state_set(vbi_dev, VBI_STATE_ALLOCATED);
-
-    mutex_unlock(&vbi_dev->mutex);
-
-    pr_info("[vbi..]%s: open device ok. \n", __func__);
-
-    return 0;
-}
-
-static int vbi_release(struct inode *inode, struct file *file)
-{
-    struct vbi_dev_s *vbi_dev = file->private_data;
-    struct vbi_slicer_s *vbi_slicer = vbi_dev->slicer;
-    int ret;
-
-    ret = vbi_slicer_free(vbi_dev, vbi_slicer);
-#ifdef 	VBI_IRQ_EN
-	/* free irq */
-	free_irq(vbi_dev->vs_irq, (void *)vbi_dev);
-#else
-	del_timer_sync(&vbi_dev->timer);	
-#endif
-	//WRITE_APB_REG(ACD_REG_22, 0x82080000); // manuel reset vbi
-	WRITE_APB_REG(ACD_REG_22, 0x06080000); // vbi reset release, vbi agent enable
-	//WRITE_APB_REG(CVD2_VBI_CC_START, 0x00000054);
-	WRITE_APB_REG(CVD2_VBI_FRAME_CODE_CTL, 0x00000014);
-	pr_info("[vbi..] %s: disable vbi function \n", __func__);
-
-    pr_info("[vbi..]%s: device release OK. \n", __func__);
-
-    return ret;
-}
-
-//static int vbi_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-static long vbi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-    int ret = 0;
-    void __user *argp = (void __user *)arg;
-	unsigned long buffer_size_t;
-
-    struct vbi_dev_s *vbi_dev = file->private_data;
-    struct vbi_slicer_s *vbi_slicer = vbi_dev->slicer;
-
-    if (mutex_lock_interruptible(&vbi_dev->mutex))
-        return -ERESTARTSYS;
-
-    switch (cmd) {
-    case VBI_IOC_START:
-        if (mutex_lock_interruptible(&vbi_slicer->mutex)) {
-            mutex_unlock(&vbi_dev->mutex);
-            pr_info("[vbi..] %s: slicer mutex error \n", __func__);
-            return -ERESTARTSYS;
-        }
-		//pr_info("[vbi..]%s:  HZ:0x%x ...\n", __FUNCTION__,HZ);
-
-        vbi_hw_init(vbi_dev);
-#ifdef VBI_IRQ_EN
-        vbi_dev->vs_irq = INT_VDIN0_VSYNC;
-        spin_lock_init(&vbi_dev->vbi_isr_lock);//vbi_dev->vbi_isr_lock = SPIN_LOCK_UNLOCKED;
-        /* request irq */
-        snprintf(vbi_dev->irq_name, sizeof(vbi_dev->irq_name),  "vbi%d-irq", vbi_dev->index);
-        ret = request_irq(vbi_dev->vs_irq, vbi_isr, IRQF_SHARED, vbi_dev->irq_name, (void *)vbi_dev);
-#else
-		spin_lock_init(&vbi_dev->vbi_isr_lock);
-		init_timer(&vbi_dev->timer);
-		vbi_dev->timer.data = (unsigned long)vbi_dev;
-		vbi_dev->timer.function = vbi_timer_handler;
-		vbi_dev->timer.expires = jiffies + (VBI_TIMER_INTERVAL);
-		add_timer(&vbi_dev->timer);
-
-#endif
-		
-		if(ret < 0) {
-			pr_err("[vbi..] %s: request_irq fail \n", __func__);
-		}
-		
-        if (vbi_slicer->state < VBI_STATE_SET)
-            ret = -EINVAL;
-        else
-            ret = vbi_slicer_start(vbi_dev);
-
-        vbi_dev->vbi_start = false;  //enable data capture function
-        vbi_dev->vs_delay = 4;
-
-        mutex_unlock(&vbi_slicer->mutex);
-        pr_info("[vbi..] %s: start slicer state:%d \n", __func__, vbi_slicer->state);
-        break;
-
-    case VBI_IOC_STOP:
-        if (mutex_lock_interruptible(&vbi_slicer->mutex)) {
-            mutex_unlock(&vbi_dev->mutex);
-            pr_info("[vbi..] %s: slicer mutex error \n", __func__);
-            return -ERESTARTSYS;
-        }
-        ret = vbi_slicer_stop(vbi_slicer);
-#if 0//avoid double free_irq or del_timer_sync
-#ifdef 	VBI_IRQ_EN
-        /* free irq */
-        free_irq(vbi_dev->vs_irq, (void *)vbi_dev);
-#else
-		del_timer_sync(&vbi_dev->timer);
-#endif
-#endif
-		//WRITE_APB_REG(ACD_REG_22, 0x82080000); // manuel reset vbi
-		WRITE_APB_REG(ACD_REG_22, 0x06080000); // vbi reset release, vbi agent enable
-		//WRITE_APB_REG(CVD2_VBI_CC_START, 0x00000054);
-		WRITE_APB_REG(CVD2_VBI_FRAME_CODE_CTL, 0x00000014);
-		pr_info("[vbi..] %s: disable vbi function \n", __func__);
-
-        mutex_unlock(&vbi_slicer->mutex);
-        pr_info("[vbi..] %s: stop slicer state:%d \n", __func__, vbi_slicer->state);
-        break;
-
-    case VBI_IOC_SET_FILTER:
-        if (mutex_lock_interruptible(&vbi_slicer->mutex)) {
-            mutex_unlock(&vbi_dev->mutex);
-            pr_info("[vbi..] %s: slicer mutex error \n", __func__);
-            return -ERESTARTSYS;
-        }
-        if (copy_from_user(&vbi_slicer->type, argp, sizeof(int)))
-        {
-            ret = -EFAULT;
-            break;
-        }
-        ret = vbi_slicer_set(vbi_dev, vbi_slicer);
-        mutex_unlock(&vbi_slicer->mutex);
-        pr_info("[vbi..] %s: set slicer to %d ,state:%d\n", __func__, vbi_slicer->type, vbi_slicer->state);
-        break;
-
-    case VBI_IOC_S_BUF_SIZE:
-        if (mutex_lock_interruptible(&vbi_slicer->mutex)) {
-            mutex_unlock(&vbi_dev->mutex);
-            pr_info("[vbi..] %s: slicer mutex error \n", __func__);
-            return -ERESTARTSYS;
-        }
-        if (copy_from_user(&buffer_size_t, argp, sizeof(int)))
-        {
-            ret = -EFAULT;
-            break;
-        }		
-        ret = vbi_set_buffer_size(vbi_dev, buffer_size_t);
-        mutex_unlock(&vbi_slicer->mutex);
-        break;
-
-    default:
-        ret = -EINVAL;
-        break;
-    }
-    mutex_unlock(&vbi_dev->mutex);
-
-    return ret;
-}
-
-/* vbi package data capture */
-static int vbi_mmap(struct file *file, struct vm_area_struct * vma)
-{
-    unsigned long start, len, off;
-    unsigned long pfn, size;
-    vbi_dev_t *devp = file->private_data;
-
-    if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
-        return -EINVAL;
-    }
-
-    /* capture the vbi data  */
-    start = ((devp->mem_start)) & PAGE_MASK;
-    pr_info("[vbi..]: cat start add:0x%x ,size:%x \n", ((devp->mem_start)), (devp->mem_size));
-    len = PAGE_ALIGN((start & ~PAGE_MASK) + (devp->mem_size));
-
-    off = vma->vm_pgoff << PAGE_SHIFT;
-
-    pr_info("[vbi..]: vend:%lx,vm_start:%lx, len:%lx  \n", (vma->vm_end), vma->vm_start, len);
-    //if ((vma->vm_end - vma->vm_start + off) > len) {
-    //    pr_info("[vbi..]: error!! vend:%p,vm_start:%p, len:%x  \n", (vma->vm_end), vma->vm_start, len);
-    //    return -EINVAL;
-    //}
-    //pr_info("[vbi..]: cat mem_size add:0x%x \n", ((devp->mem_size) << 3));
-    off += start;
-    vma->vm_pgoff = off >> PAGE_SHIFT;
-
-    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-    vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
-
-    size = vma->vm_end - vma->vm_start;
-    pfn  = off >> PAGE_SHIFT;
-
-    if (io_remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot))
-        return -EAGAIN;
-
-    return 0;
-}
-
-static unsigned int vbi_poll(struct file *file, poll_table *wait)
-{
-    vbi_dev_t *devp = file->private_data;
-    struct vbi_slicer_s *vbi_slicer = devp->slicer;
-    unsigned int mask = 0;
-
-    if (!vbi_slicer) {
-        pr_info("[vbi..] %s: slicer null \n", __func__);
-        return -EINVAL;
-    }
-    poll_wait(file, &vbi_slicer->buffer.queue, wait);
-
-    if (vbi_slicer->state != VBI_STATE_GO &&
-        vbi_slicer->state != VBI_STATE_DONE &&
-        vbi_slicer->state != VBI_STATE_TIMEDOUT)
-        return 0;
-
-    if (vbi_slicer->buffer.error)
-        mask |= (POLLIN | POLLRDNORM | POLLPRI | POLLERR);
-
-    if (!vbi_ringbuffer_empty(&vbi_slicer->buffer))
-        mask |= (POLLIN | POLLRDNORM | POLLPRI);
-
-    return mask;
-}
-
-/* File operations structure. Defined in linux/fs.h */
-static struct file_operations vbi_fops = {
-    .owner   = THIS_MODULE,         /* Owner */
-    .open    = vbi_open,            /* Open method */
-    .release = vbi_release,         /* Release method */
-    .unlocked_ioctl   = vbi_ioctl,           /* Ioctl method */
-    .mmap    = vbi_mmap,
-    .read    = vbi_read,
-    .poll    = vbi_poll,
-    /* ... */
-};
-
-static int vbi_probe(struct platform_device *pdev)
-{
-    int ret;
-    struct resource *res;
-
-    ret = alloc_chrdev_region(&vbi_id, 0, 1, VBI_NAME);
-    if (ret < 0) {
-        pr_err("[vbi..]: failed to allocate major number\n");
-        return 0;
-    }
-
-    vbi_clsp = class_create(THIS_MODULE, VBI_NAME);
-    if (IS_ERR(vbi_clsp))
-    {
-        pr_err("[vbi..]: can't get vbi_clsp\n");
-        unregister_chrdev_region(vbi_id, 1);
-        return PTR_ERR(vbi_clsp);
-    }
-
-     /* allocate memory for the per-device structure */
-    vbi_dev = kmalloc(sizeof(struct vbi_dev_s), GFP_KERNEL);
-    if (!vbi_dev)
-    {
-        pr_err("[vbi..]: failed to allocate memory for vbi device\n");
-        return -ENOMEM;
-    }
-
-    /* connect the file operations with cdev */
-    cdev_init(&vbi_dev->cdev, &vbi_fops);
-    vbi_dev->cdev.owner = THIS_MODULE;
-    /* connect the major/minor number to the cdev */
-    ret = cdev_add(&vbi_dev->cdev, vbi_id, 1);
-    if (ret) {
-        pr_err("[vbi..]: failed to add device\n");
-        /* @todo do with error */
-        return ret;
-    }
-    /* create /dev nodes */
-    vbi_dev->dev = device_create(vbi_clsp, NULL, MKDEV(MAJOR(vbi_id), 0), NULL, "%s", VBI_NAME);
-    if (IS_ERR(vbi_dev->dev)) {
-        pr_err("[vbi..]: failed to create device node\n");
-        cdev_del(&vbi_dev->cdev);
-        kfree(vbi_dev);
-        return PTR_ERR(vbi_dev->dev);
-    }
-
-    /* get device memory */
-    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-    if (!res) {
-        pr_err("[vbi..]: can't get memory resource\n");
-        return -EFAULT;
-    }
-    vbi_dev->mem_start = res->start;
-#if 1
-    vbi_dev->mem_size = res->end - res->start + 1;
-	//vbi_dev->mem_size = (res->end - res->start + 1)/2;
-#else
-    vbi_dev->mem_size = VBI_MEM_SIZE;
-#endif
-    pr_info("[vbi..]: start_addr is:0x%x, size is:0x%x \n", vbi_dev->mem_start, vbi_dev->mem_size);
-
-    /* remap the package vbi hardware address for our conversion */
-    vbi_dev->pac_addr_start = ioremap_nocache(vbi_dev->mem_start, vbi_dev->mem_size);
-	memset(vbi_dev->pac_addr_start,0,vbi_dev->mem_size);//kuku add
-	vbi_dev->mem_size = vbi_dev->mem_size/2;
-    vbi_dev->pac_addr_end = vbi_dev->pac_addr_start + vbi_dev->mem_size - 1;
-    if (vbi_dev->pac_addr_start == NULL)
-        pr_err("[vbi..]: ioremap error!!! \n");
-    else
-        pr_info("[vbi..]: vbi_dev->pac_addr_start=0x%p, end:0x%p, size:0x%x .......  \n", vbi_dev->pac_addr_start, vbi_dev->pac_addr_end, vbi_dev->mem_size);
-    vbi_dev->pac_addr = vbi_dev->pac_addr_start;
-	
-    mutex_init(&vbi_dev->mutex);
-    spin_lock_init(&vbi_dev->lock);
-
-    /* Initialize tasklet */
-    tasklet_init(&vbi_dev->tsklt_slicer, vbi_slicer_task, (unsigned long)vbi_dev);
-
-    vbi_dev->vbi_start = false;
-    vbi_dev->vs_delay = 4;
-
-    vbi_dev->slicer = vmalloc(sizeof(struct vbi_slicer_s));
-    if (!vbi_dev->slicer) {
-        pr_err("[vbi..]: vmalloc error!!! \n");
-        return -ENOMEM;
-    }
-    vbi_dev->slicer->buffer.data = NULL;
-    vbi_dev->slicer->state = VBI_STATE_FREE;
-
-    pr_info("[vbi..]: driver probe ok\n");
-
-    return 0;
-}
-
-static int vbi_remove(struct platform_device *pdev)
-{
-    tasklet_kill(&vbi_dev->tsklt_slicer);
-
-    if (vbi_dev->pac_addr_start)
-        iounmap(vbi_dev->pac_addr_start);
-    vfree(vbi_dev->slicer);
-    device_destroy(vbi_clsp, MKDEV(MAJOR(vbi_id), 0));
-    cdev_del(&vbi_dev->cdev);
-    kfree(vbi_dev);
-    class_destroy(vbi_clsp);
-    unregister_chrdev_region(vbi_id, 0);
-
-    pr_info("[vbi..] : driver removed ok.\n");
-
-    return 0;
-}
-
-static struct platform_driver vbi_driver = {
-    .probe      = vbi_probe,
-    .remove     = vbi_remove,
-    .driver     = {
-    .name   = VBI_DRIVER_NAME,
-    }
-};
-
-static int __init vbi_init(void)
-{
-    int ret = 0;
-
-    ret = platform_driver_register(&vbi_driver);
-    if (ret != 0) {
-        pr_err("[vbi..] failed to register vbi module, error %d\n", ret);
-        return -ENODEV;
-    }
-
-    return ret;
-}
-
-static void __exit vbi_exit(void)
-{
-    platform_driver_unregister(&vbi_driver);
-}
-
-module_init(vbi_init);
-module_exit(vbi_exit);
-
-MODULE_DESCRIPTION("AMLOGIC vbi driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("frank  <frank.zhao@amlogic.com>");
-
diff --git a/drivers/amlogic/tvin/tvafe/tvin_vbi.h b/drivers/amlogic/tvin/tvafe/tvin_vbi.h
deleted file mode 100755
index d1f43f8414fd..000000000000
--- a/drivers/amlogic/tvin/tvafe/tvin_vbi.h
+++ /dev/null
@@ -1,214 +0,0 @@
-/*******************************************************************
-*  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
-*  File name: tvin_vbi.h
-*  Description: IO function, structure, enum, used in TVIN vbi sub-module processing
-*******************************************************************/
-
-#ifndef TVIN_VBI_H_
-#define TVIN_VBI_H_
-
-/* Standard Linux Headers */
-#include <linux/cdev.h>
-#include <linux/timer.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-
-// ***************************************************************************
-// *** macro definitions *********************************************
-// ***************************************************************************
-/* defines for vbi spec */
-//vbi type id
-#define VBI_ID_USCC                0
-#define VBI_ID_TT                  3
-#define VBI_ID_WSS625              4
-#define VBI_ID_WSSJ                5
-#define VBI_ID_VPS                 6
-#define MAX_PACKET_TYPE            VBI_ID_VPS
-
-//vbi package data bytes
-#define VBI_PCNT_USCC              2
-#define VBI_PCNT_WSS625            2
-#define VBI_PCNT_WSSJ              3
-#define VBI_PCNT_VPS               8
-
-//teletext package data bytes
-#define VBI_PCNT_TT_625A           37
-#define VBI_PCNT_TT_625B           42
-#define VBI_PCNT_TT_625C           33
-#define VBI_PCNT_TT_625D           34
-#define VBI_PCNT_TT_525B           34
-#define VBI_PCNT_TT_525C           33
-#define VBI_PCNT_TT_525D           34
-
-//Teletext system type
-#define VBI_SYS_TT_625A            0
-#define VBI_SYS_TT_625B            1
-#define VBI_SYS_TT_625C            2
-#define VBI_SYS_TT_625D            3
-#define VBI_SYS_TT_525B            5
-#define VBI_SYS_TT_525C            6
-#define VBI_SYS_TT_525D            7
-
-
-//vbi data type setting
-#define VBI_DATA_TYPE_USCC         0x11
-#define VBI_DATA_TYPE_EUROCC       0x22
-#define VBI_DATA_TYPE_VPS          0x33
-#define VBI_DATA_TYPE_TT_625A      0x55
-#define VBI_DATA_TYPE_TT_625B      0x66
-#define VBI_DATA_TYPE_TT_625C      0x77
-#define VBI_DATA_TYPE_TT_625D      0x88
-#define VBI_DATA_TYPE_TT_525B      0x99
-#define VBI_DATA_TYPE_TT_525C      0xaa
-#define VBI_DATA_TYPE_TT_525D      0xbb
-#define VBI_DATA_TYPE_WSS625       0xcc
-#define VBI_DATA_TYPE_WSSJ         0xdd
-
-#define VBI_LINE_MIN               6
-#define VBI_LINE_MAX               25
-
-//closed caption type
-#define VBI_PACKAGE_CC1            1
-#define VBI_PACKAGE_CC2            2
-#define VBI_PACKAGE_CC3            4
-#define VBI_PACKAGE_CC4            8
-#define VBI_PACKAGE_TT1            16
-#define VBI_PACKAGE_TT2            32
-#define VBI_PACKAGE_TT3            64
-#define VBI_PACKAGE_TT4            128
-#define VBI_PACKAGE_XDS            256
-
-#define VBI_PACKAGE_FILTER_MAX     3
-
-#define VBI_IOC_MAGIC 'X'
-
-#define VBI_IOC_CC_EN              _IO (VBI_IOC_MAGIC, 0x01)
-#define VBI_IOC_CC_DISABLE         _IO (VBI_IOC_MAGIC, 0x02)
-#define VBI_IOC_SET_FILTER         _IOW(VBI_IOC_MAGIC, 0x03, int)
-#define VBI_IOC_S_BUF_SIZE         _IOW(VBI_IOC_MAGIC, 0x04, int)
-#define VBI_IOC_START              _IO (VBI_IOC_MAGIC, 0x05)
-#define VBI_IOC_STOP               _IO (VBI_IOC_MAGIC, 0x06)
-
-
-#define VBI_MEM_SIZE               0x1000//0x8000   // 32768 hw address with 8bit not 64bit
-//#define VBI_SLICED_MAX            64   // 32768 hw address with 8bit not 64bit
-#define VBI_WRITE_BURST_BYTE        8
-#define SLICED_BUF_MAX              4096
-
-//debug defines
-#define VBI_CC_SUPPORT
-//#define VBI_TT_SUPPORT
-
-
-#define VBI_DATA_TYPE_LEN          16
-#define VBI_DATA_TYPE_MASK         0xf0000
-
-#define VBI_PAC_TYPE_LEN           0
-#define VBI_PAC_TYPE_MASK          0x0ffff
-
-#define VBI_PAC_CC_FIELD_LEN       4
-#define VBI_PAC_CC_FIELD_MASK      0xf0
-#define VBI_PAC_CC_FIELD1          0
-#define VBI_PAC_CC_FIELD2          1
-
-/* vbi type */
-#define VBI_TYPE_NULL           0
-#define VBI_TYPE_USCC           0x00001  //
-#define VBI_TYPE_EUROCC         0x00020
-#define VBI_TYPE_VPS            0x00040  //Germany, Austria and Switzerland.
-#define VBI_TYPE_TT_625A        0x00080  //
-#define VBI_TYPE_TT_625B        0x00100  //
-#define VBI_TYPE_TT_625C        0x00200  //
-#define VBI_TYPE_TT_625D        0x00400  //
-#define VBI_TYPE_TT_525B        0x00800  //
-#define VBI_TYPE_TT_525C        0x01000  //
-#define VBI_TYPE_TT_525D        0x02000  //
-#define VBI_TYPE_WSS625         0x04000  //
-#define VBI_TYPE_WSSJ           0x08000  //
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-
-typedef enum field_id_e {
-    FIELD_1 = 0,
-    FIELD_2 = 1,
-} field_id_t;
-
-enum vbi_state_e {
-    VBI_STATE_FREE      = 0,
-    VBI_STATE_ALLOCATED = 1,
-    VBI_STATE_SET       = 2,
-    VBI_STATE_GO        = 3,
-    VBI_STATE_DONE      = 4,
-    VBI_STATE_TIMEDOUT  = 5
-} vbi_state_t;
-
-// ***************************************************************************
-// *** structure definitions *********************************************
-// ***************************************************************************
-
-typedef struct cc_data_s {
-    unsigned int vbi_type :  8; // vbi data type: us_cc, teletext,wss_625,wssj,vps....
-    unsigned int field_id :  8; // field type: 0:even; 1:odd;
-    unsigned int nbytes   : 16; // data byte count: cc:two bytes; tt: depends on tt spec
-    unsigned int line_num : 16; // vbi data line number
-    unsigned char b[2];         //       : 8;  // cc data1
-} cc_data_t;
-
-struct vbi_ringbuffer_s {
-    struct cc_data_s *data;
-    ssize_t           size;
-    ssize_t           pread;
-    ssize_t           pwrite;
-    int               error;
-
-    wait_queue_head_t queue;
-    spinlock_t        lock;
-} vbi_ringbuffer_t;
-
-typedef struct vbi_slicer_s {
-    unsigned int           type;
-    enum vbi_state_e        state;
-
-    struct vbi_ringbuffer_s buffer;
-    struct mutex            mutex;
-
-    unsigned int           reserve;
-} vbi_slicer_t;
-
-/* vbi device structure */
-typedef struct vbi_dev_s {
-    int                   index;
-
-    dev_t                 devt;
-    struct cdev          cdev;
-    struct device        *dev;
-
-    struct tasklet_struct tsklt_slicer;
-
-    char                 irq_name[12];
-    unsigned int        vs_irq;
-    spinlock_t            vbi_isr_lock;
-
-
-    /* vbi memory */
-    unsigned int         mem_start;
-    unsigned int         mem_size;
-
-    unsigned char        *pac_addr;
-    unsigned char        *pac_addr_start;
-    unsigned char        *pac_addr_end;
-    unsigned int         current_pac_wptr;
-    unsigned int         last_pac_wptr;
-    unsigned int         vs_delay;
-
-    struct vbi_slicer_s   *slicer;
-    bool                   vbi_start;
-    struct mutex          mutex;
-    spinlock_t             lock;
-	struct timer_list		timer;
-
-} vbi_dev_t;
-
-#endif /* TVIN_VBI_H_ */
diff --git a/drivers/amlogic/tvin/tvin_format_table.c b/drivers/amlogic/tvin/tvin_format_table.c
deleted file mode 100755
index 7bc7f6abb087..000000000000
--- a/drivers/amlogic/tvin/tvin_format_table.c
+++ /dev/null
@@ -1,3263 +0,0 @@
-/*
- * TVIN signal format table
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#include <linux/module.h>
-
-#include "tvin_global.h"
-#include "tvin_format_table.h"
-
-const char * tvin_sig_fmt_str(enum tvin_sig_fmt_e fmt)
-{
-	switch (fmt)
-	{
-		case TVIN_SIG_FMT_NULL:
-			return "TVIN_SIG_FMT_NULL";
-			break;
-		case TVIN_SIG_FMT_VGA_512X384P_60HZ_D147:
-			return "TVIN_SIG_FMT_VGA_512X384P_60D147";
-			break;
-		case TVIN_SIG_FMT_VGA_560X384P_60HZ_D147:
-			return "TVIN_SIG_FMT_VGA_560X384P_60D147";
-			break;
-		case TVIN_SIG_FMT_VGA_640X200P_59HZ_D924:
-			return "TVIN_SIG_FMT_VGA_640X200P_59D924";
-			break;
-		case TVIN_SIG_FMT_VGA_640X350P_85HZ_D080:
-			return "TVIN_SIG_FMT_VGA_640X200P_59D924";
-			break;
-		case TVIN_SIG_FMT_VGA_640X400P_59HZ_D940:
-			return "TVIN_SIG_FMT_VGA_640X400P_59D940";
-			break;
-		case TVIN_SIG_FMT_VGA_640X400P_85HZ_D080:
-			return "TVIN_SIG_FMT_VGA_640X400P_85D080";
-			break;
-		case TVIN_SIG_FMT_VGA_640X400P_59HZ_D638:
-			return "TVIN_SIG_FMT_VGA_640X400P_59D638";
-			break;
-		case TVIN_SIG_FMT_VGA_640X400P_56HZ_D416:
-			return "TVIN_SIG_FMT_VGA_640X400P_56D416";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_66HZ_D619:
-			return "TVIN_SIG_FMT_VGA_640X480P_66D619";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_66HZ_D667: //10
-			return "TVIN_SIG_FMT_VGA_640X480P_66D667";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_59HZ_D940:
-			return "TVIN_SIG_FMT_VGA_640X480P_59D940";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_640X480P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_72HZ_D809:
-			return "TVIN_SIG_FMT_VGA_640X480P_72D809";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_75HZ_D000_A:
-			return "TVIN_SIG_FMT_VGA_640X480P_75D000_A";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_85HZ_D008:
-			return "TVIN_SIG_FMT_VGA_640X480P_85D008";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_59HZ_D638:
-			return "TVIN_SIG_FMT_VGA_640X480P_59D638";
-			break;
-		case TVIN_SIG_FMT_VGA_640X480P_75HZ_D000_B:
-			return "TVIN_SIG_FMT_VGA_640X480P_75D000_B";
-			break;
-		case TVIN_SIG_FMT_VGA_640X870P_75HZ_D000:
-			return "TVIN_SIG_FMT_VGA_640X870P_75D000";
-			break;
-		case TVIN_SIG_FMT_VGA_720X350P_70HZ_D086:
-			return "TVIN_SIG_FMT_VGA_720X350P_70D086";
-			break;
-		case TVIN_SIG_FMT_VGA_720X400P_85HZ_D039: //20
-			return "TVIN_SIG_FMT_VGA_720X400P_85D039";
-			break;
-		case TVIN_SIG_FMT_VGA_720X400P_70HZ_D086:
-			return "TVIN_SIG_FMT_VGA_720X400P_70D086";
-			break;
-		case TVIN_SIG_FMT_VGA_720X400P_87HZ_D849:
-			return "TVIN_SIG_FMT_VGA_720X400P_87D849";
-			break;
-		case TVIN_SIG_FMT_VGA_720X400P_59HZ_D940:
-			return "TVIN_SIG_FMT_VGA_720X400P_59D940";
-			break;
-		case TVIN_SIG_FMT_VGA_720X480P_59HZ_D940:
-			return "TVIN_SIG_FMT_VGA_720X480P_59D940";
-			break;
-		case TVIN_SIG_FMT_VGA_768X480P_59HZ_D896:
-			return "TVIN_SIG_FMT_VGA_768X480P_59D896";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_56HZ_D250:
-			return "TVIN_SIG_FMT_VGA_800X600P_56D250";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_800X600P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_60HZ_D000_A:
-			return "TVIN_SIG_FMT_VGA_800X600P_60D000_A";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_60HZ_D317:
-			return "TVIN_SIG_FMT_VGA_800X600P_60D317";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_72HZ_D188: //30
-			return "TVIN_SIG_FMT_VGA_800X600P_72D188";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_75HZ_D000:
-			return "TVIN_SIG_FMT_VGA_800X600P_75D000";
-			break;
-		case TVIN_SIG_FMT_VGA_800X600P_85HZ_D061:
-			return "TVIN_SIG_FMT_VGA_800X600P_85D061";
-			break;
-		case TVIN_SIG_FMT_VGA_832X624P_75HZ_D087:
-			return "TVIN_SIG_FMT_VGA_832X624P_75D087";
-			break;
-		case TVIN_SIG_FMT_VGA_848X480P_84HZ_D751:
-			return "TVIN_SIG_FMT_VGA_848X480P_84D751";
-			break;
-		case TVIN_SIG_FMT_VGA_960X600P_59HZ_D635:
-			return "TVIN_SIG_FMT_VGA_960X600P_59D635";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_59HZ_D278:
-			return "TVIN_SIG_FMT_VGA_1024X768P_59D278";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1024X768P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_A:
-			return "TVIN_SIG_FMT_VGA_1024X768P_60D000_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_B:
-			return "TVIN_SIG_FMT_VGA_1024X768P_60D000_B";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_74HZ_D927:  //40
-			return "TVIN_SIG_FMT_VGA_1024X768P_74D927";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_60HZ_D004:
-			return "TVIN_SIG_FMT_VGA_1024X768P_60D004";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_70HZ_D069:
-			return "TVIN_SIG_FMT_VGA_1024X768P_70D069";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_75HZ_D029:
-			return "TVIN_SIG_FMT_VGA_1024X768P_75D029";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_84HZ_D997:
-			return "TVIN_SIG_FMT_VGA_1024X768P_84D997";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_74HZ_D925:
-			return "TVIN_SIG_FMT_VGA_1024X768P_74D925";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_75HZ_D020:
-			return "TVIN_SIG_FMT_VGA_1024X768P_75D020";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_70HZ_D008:
-			return "TVIN_SIG_FMT_VGA_1024X768P_70D008";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_75HZ_D782:
-			return "TVIN_SIG_FMT_VGA_1024X768P_75D782";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_77HZ_D069:
-			return "TVIN_SIG_FMT_VGA_1024X768P_77D069";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_71HZ_D799:  //50
-			return "TVIN_SIG_FMT_VGA_1024X768P_71D799";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X1024P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1024X1024P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X864P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1152X864P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X864P_70HZ_D012:
-			return "TVIN_SIG_FMT_VGA_1152X864P_70D012";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X864P_75HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1152X864P_75D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X864P_84HZ_D999:
-			return "TVIN_SIG_FMT_VGA_1152X864P_84D999";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X870P_75HZ_D062:
-			return "TVIN_SIG_FMT_VGA_1152X870P_75D062";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X900P_65HZ_D950:
-			return "TVIN_SIG_FMT_VGA_1152X900P_65D950";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X900P_66HZ_D004:
-			return "TVIN_SIG_FMT_VGA_1152X900P_66D004";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X900P_76HZ_D047:
-			return "TVIN_SIG_FMT_VGA_1152X900P_76D047";
-			break;
-		case TVIN_SIG_FMT_VGA_1152X900P_76HZ_D149: //60
-			return "TVIN_SIG_FMT_VGA_1152X900P_76D149";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X720P_59HZ_D855:
-			return "TVIN_SIG_FMT_VGA_1280X720P_59D855";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_A:
-			return "TVIN_SIG_FMT_VGA_1280X720P_60D000_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_B:
-			return "TVIN_SIG_FMT_VGA_1280X720P_60D000_B";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_C:
-			return "TVIN_SIG_FMT_VGA_1280X720P_60D000_C";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X720P_60HZ_D000_D:
-			return "TVIN_SIG_FMT_VGA_1280X720P_60D000_D";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X768P_59HZ_D870:
-			return "TVIN_SIG_FMT_VGA_1280X768P_59D870";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X768P_59HZ_D995:
-			return "TVIN_SIG_FMT_VGA_1280X768P_59D995";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X768P_60HZ_D100:
-			return "TVIN_SIG_FMT_VGA_1280X768P_60D100";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X768P_85HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1280X768P_85HZ_D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X768P_74HZ_D893: //70
-			return "TVIN_SIG_FMT_VGA_1280X768P_74D893";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X768P_84HZ_D837:
-			return "TVIN_SIG_FMT_VGA_1280X768P_84D837";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X800P_59HZ_D810:
-			return "TVIN_SIG_FMT_VGA_1280X800P_59D810";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X800P_59HZ_D810_A:
-			return "TVIN_SIG_FMT_VGA_1280X800P_59D810_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X800P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1280X800P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X800P_85HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1280X800P_85D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X960P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1280X960P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X960P_60HZ_D000_A:
-			return "TVIN_SIG_FMT_VGA_1280X960P_60D000_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X960P_75HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1280X960P_75D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X960P_85HZ_D002:
-			return "TVIN_SIG_FMT_VGA_1280X960P_85D002";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D020: //80
-			return "TVIN_SIG_FMT_VGA_1280X1024P_60D020";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D020_A:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_60D020_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_75HZ_D025:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_75D025";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_85HZ_D024:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_85D024";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_59HZ_D979:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_59D979";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_72HZ_D005:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_72D005";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D002:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_60D002";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_67HZ_D003:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_67D003";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_74HZ_D112:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_74D112";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_76HZ_D179:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_76D179";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_66HZ_D718: //90
-			return "TVIN_SIG_FMT_VGA_1280X1024P_66D718";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_66HZ_D677:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_66D677";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_76HZ_D107:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_76D107";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_59HZ_D996:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_59D996";
-			break;
-		case TVIN_SIG_FMT_VGA_1280X1024P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1280X1024P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1360X768P_59HZ_D799:
-			return "TVIN_SIG_FMT_VGA_1360X768P_59D799";
-			break;
-		case TVIN_SIG_FMT_VGA_1360X768P_60HZ_D015:
-			return "TVIN_SIG_FMT_VGA_1360X768P_60D015";
-			break;
-		case TVIN_SIG_FMT_VGA_1360X768P_60HZ_D015_A:
-			return "TVIN_SIG_FMT_VGA_1360X768P_60D015_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1360X850P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1360X850P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1360X1024P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1360X1024P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1366X768P_59HZ_D790: //100
-			return "TVIN_SIG_FMT_VGA_1366X768P_59D790";
-			break;
-		case TVIN_SIG_FMT_VGA_1366X768P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1366X768P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1400X1050P_59HZ_D978:
-			return "TVIN_SIG_FMT_VGA_1400X1050P_59D978";
-			break;
-		case TVIN_SIG_FMT_VGA_1440X900P_59HZ_D887:
-			return "TVIN_SIG_FMT_VGA_1440X900P_59D887";
-			break;
-		case TVIN_SIG_FMT_VGA_1440X1080P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1440X1080P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1600X900P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1600X900P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1600X1024P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1600X1024P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1600X1200P_59HZ_D869:
-			return "TVIN_SIG_FMT_VGA_1600X1200P_59HZ_D869";
-			break;
-		case TVIN_SIG_FMT_VGA_1600X1200P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1600X1200P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1600X1200P_65HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1600X1200P_65D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1600X1200P_70HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1600X1200P_70D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1680X1050P_59HZ_D954: //110
-			return "TVIN_SIG_FMT_VGA_1680X1050P_59D954";
-			break;
-		case TVIN_SIG_FMT_VGA_1680X1080P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1680X1080P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1920X1080P_49HZ_D929:
-			return "TVIN_SIG_FMT_VGA_1920X1080P_49HZ_D929";
-			break;
-		case TVIN_SIG_FMT_VGA_1920X1080P_59HZ_D963_A:
-			return "TVIN_SIG_FMT_VGA_1920X1080P_59HZ_D963_A";
-			break;
-		case TVIN_SIG_FMT_VGA_1920X1080P_59HZ_D963:
-			return "TVIN_SIG_FMT_VGA_1920X1080P_59D963";
-			break;
-		case TVIN_SIG_FMT_VGA_1920X1080P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1920X1080P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_1920X1200P_59HZ_D950:
-			return "TVIN_SIG_FMT_VGA_1920X1200P_59D950";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_C:
-			return "TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_C";
-			break;
-		case TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_D:
-			return "TVIN_SIG_FMT_VGA_1024X768P_60HZ_D000_D";
-			break;
-                case TVIN_SIG_FMT_VGA_1920X1200P_59HZ_D988:
-                        return "TVIN_SIG_FMT_VGA_1920X1200P_59D988";
-                        break;
-		case TVIN_SIG_FMT_VGA_1400X900P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1400X900P_60D00";
-			break;
-		case TVIN_SIG_FMT_VGA_1680X1050P_60HZ_D000:
-			return "TVIN_SIG_FMT_VGA_1680X1050P_60D000";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE6: //120
-			return "TVIN_SIG_FMT_VGA_RESERVE6";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE7:
-			return "TVIN_SIG_FMT_VGA_RESERVE7";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE8:
-			return "TVIN_SIG_FMT_VGA_RESERVE8";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE9:
-			return "TVIN_SIG_FMT_VGA_RESERVE9";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE10:
-			return "TVIN_SIG_FMT_VGA_RESERVE10";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE11:
-			return "TVIN_SIG_FMT_VGA_RESERVE11";
-			break;
-		case TVIN_SIG_FMT_VGA_RESERVE12: //126
-			return "TVIN_SIG_FMT_VGA_RESERVE12";
-			break;
-		case TVIN_SIG_FMT_VGA_MAX:
-			return "TVIN_SIG_FMT_VGA_MAX";
-			break;
-			//Component Formats
-		case TVIN_SIG_FMT_COMP_480P_60HZ_D000:
-			return "TVIN_SIG_FMT_COMP_480P_60D000";
-			break;
-		case TVIN_SIG_FMT_COMP_480I_59HZ_D940:
-			return "TVIN_SIG_FMT_COMP_480I_59D940";
-			break;
-		case TVIN_SIG_FMT_COMP_576P_50HZ_D000:
-			return "TVIN_SIG_FMT_COMP_576P_50D000";
-			break;
-		case TVIN_SIG_FMT_COMP_576I_50HZ_D000:
-			return "TVIN_SIG_FMT_COMP_576I_50D000";
-			break;
-		case TVIN_SIG_FMT_COMP_720P_59HZ_D940:
-			return "TVIN_SIG_FMT_COMP_720P_59D940";
-			break;
-		case TVIN_SIG_FMT_COMP_720P_50HZ_D000:
-			return "TVIN_SIG_FMT_COMP_720P_50D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080P_23HZ_D976:
-			return "TVIN_SIG_FMT_COMP_1080P_23D976";
-			break;
-		case TVIN_SIG_FMT_COMP_1080P_24HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080P_24D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080P_25HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080P_25D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080P_30HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080P_30D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080P_50HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080P_50D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080P_60HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080P_60D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080I_47HZ_D952:
-			return "TVIN_SIG_FMT_COMP_1080I_47D952";
-			break;
-		case TVIN_SIG_FMT_COMP_1080I_48HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080I_48D000";
-			break;
-		case TVIN_SIG_FMT_COMP_1080I_50HZ_D000_A:
-			return "TVIN_SIG_FMT_COMP_1080I_50D000_A";
-			break;
-		case TVIN_SIG_FMT_COMP_1080I_50HZ_D000_B:
-			return "TVIN_SIG_FMT_COMP_1080I_50D000_B";
-			break;
-		case TVIN_SIG_FMT_COMP_1080I_50HZ_D000_C:
-			return "TVIN_SIG_FMT_COMP_1080I_50D000_C";
-			break;
-		case TVIN_SIG_FMT_COMP_1080I_60HZ_D000:
-			return "TVIN_SIG_FMT_COMP_1080I_60D000";
-			break;
-		case TVIN_SIG_FMT_COMP_MAX:
-			return "TVIN_SIG_FMT_COMP_MAX";
-			break;
-			//HDMI Formats
-		case TVIN_SIG_FMT_HDMI_640X480P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_640x480P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X480P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_720x480P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_60HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X480I_60HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x480I_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X240P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x240P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_2880X480I_60HZ:
-			return "TVIN_SIG_FMT_HDMI_2880x480I_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_2880X240P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_2880x240P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X480P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x480P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X576P_50HZ:
-			return "TVIN_SIG_FMT_HDMI_720x576P_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_50HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_A:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_50Hz_A";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X576I_50HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x576I_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X288P_50HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x288P_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_2880X576I_50HZ:
-			return "TVIN_SIG_FMT_HDMI_2880x576I_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_2880X288P_50HZ:
-			return "TVIN_SIG_FMT_HDMI_2880x288P_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X576P_50HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x576P_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_50HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_50Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_24HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_24Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_25HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_25Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_30HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_30Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_2880X480P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_2880x480P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_2880X576P_60HZ:
-			return "TVIN_SIG_FMT_HDMI_2880x576P_60Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_B:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_50Hz_B";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_100HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_100Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_100HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_100Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X576P_100HZ:
-			return "TVIN_SIG_FMT_HDMI_720x576P_100Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X576I_100HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x576I_100Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_120HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_120Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_120HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_120Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X480P_120HZ:
-			return "TVIN_SIG_FMT_HDMI_720x480P_120Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X480I_120HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x480I_120Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X576P_200HZ:
-			return "TVIN_SIG_FMT_HDMI_720x576P_200Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X576I_200HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x576I_200Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X480P_240HZ:
-			return "TVIN_SIG_FMT_HDMI_720x480P_240Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1440X480I_240HZ:
-			return "TVIN_SIG_FMT_HDMI_1440x480I_240Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_24HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_24Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_25HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_25Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_30HZ:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_30Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_120HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_120Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_100HZ:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_100Hz";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_60HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_60Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_50HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_50Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_24HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_24Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X720P_30HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1280x720P_30Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_60Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1920x1080I_50Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_24Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_1920x1080P_30Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_800X600_00HZ:
-			return "TVIN_SIG_FMT_HDMI_800x600";
-			break;
-		case TVIN_SIG_FMT_HDMI_1024X768_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1024x768";
-			break;
-		case TVIN_SIG_FMT_HDMI_720X400_00HZ:
-			return "TVIN_SIG_FMT_HDMI_720_400";
-			break;
-		case TVIN_SIG_FMT_HDMI_1280X768_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1280_768";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1280X800_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1280_800";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1280X960_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1280_960";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1280X1024_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1280_1024";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1360X768_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1360_768";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1366X768_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1366_768";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1600X1200_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1600_1200";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1920X1200_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1920_1200";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1440X900_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1440X900_00HZ";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1400X1050_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1400X1050_00HZ";
-			break;
-		case     TVIN_SIG_FMT_HDMI_1680X1050_00HZ:
-			return "TVIN_SIG_FMT_HDMI_1680X1050_00HZ";
-			break;
-			/* for alternative and 4k2k */
-		case     TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_ALTERNATIVE:
-			return "TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_ALTERNATIVE";
-			break;
-       case     TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_ALTERNATIVE:
-            return "TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_ALTERNATIVE";
-            break;
-		case     TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_ALTERNATIVE:
-		    return "TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_ALTERNATIVE";
-		    break;
-       case     TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_ALTERNATIVE:
-            return "TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_ALTERNATIVE";
-            break;
-		case     TVIN_SIG_FMT_HDMI_3840_2160_00HZ:
-			return "TVIN_SIG_FMT_HDMI_3840_2160_00HZ";
-			break;
-		case     TVIN_SIG_FMT_HDMI_4096_2160_00HZ:
-			return "TVIN_SIG_FMT_HDMI_4096_2160_00HZ";
-			break;
-		case     TVIN_SIG_FMT_HDMI_RESERVE7:
-			return "TVIN_SIG_FMT_HDMI_RESERVE7";
-			break;
-		case     TVIN_SIG_FMT_HDMI_RESERVE8:
-			return "TVIN_SIG_FMT_HDMI_RESERVE8";
-			break;
-		case     TVIN_SIG_FMT_HDMI_RESERVE9:
-			return "TVIN_SIG_FMT_HDMI_RESERVE9";
-			break;
-		case     TVIN_SIG_FMT_HDMI_RESERVE10:
-			return "TVIN_SIG_FMT_HDMI_RESERVE10";
-			break;
-		case     TVIN_SIG_FMT_HDMI_RESERVE11:
-			return "TVIN_SIG_FMT_HDMI_RESERVE11";
-			break;
-		case     TVIN_SIG_FMT_HDMI_720X480P_60HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_720x480P_60Hz_FRAME_PACKING";
-			break;
-		case     TVIN_SIG_FMT_HDMI_720X576P_50HZ_FRAME_PACKING:
-			return "TVIN_SIG_FMT_HDMI_720x576P_50Hz_FRAME_PACKING";
-			break;
-		case TVIN_SIG_FMT_HDMI_MAX:
-			return "TVIN_SIG_FMT_HDMI_MAX";
-			break;
-			//Video Formats
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-			return "TVIN_SIG_FMT_CVBS_NTSC_M";
-			break;
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-			return "TVIN_SIG_FMT_CVBS_NTSC_443";
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-			return "TVIN_SIG_FMT_CVBS_PAL_I";
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-			return "TVIN_SIG_FMT_CVBS_PAL_M";
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-			return "TVIN_SIG_FMT_CVBS_PAL_60";
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-			return "TVIN_SIG_FMT_CVBS_PAL_CN";
-			break;
-		case TVIN_SIG_FMT_CVBS_SECAM:
-			return "TVIN_SIG_FMT_CVBS_SECAM";
-			break;
-			//656 Formats
-		case TVIN_SIG_FMT_BT656IN_576I_50HZ:
-			return "TVIN_SIG_FMT_BT656IN_576I";
-			break;
-		case TVIN_SIG_FMT_BT656IN_480I_60HZ:
-			return "TVIN_SIG_FMT_BT656IN_480I";
-			break;
-			//601 Formats
-		case TVIN_SIG_FMT_BT601IN_576I_50HZ:
-			return "TVIN_SIG_FMT_BT601IN_576I";
-			break;
-		case TVIN_SIG_FMT_BT601IN_480I_60HZ:
-			return "TVIN_SIG_FMT_BT601IN_480I";
-			break;
-			//Camera Formats
-		case TVIN_SIG_FMT_CAMERA_640X480P_30HZ:
-			return "TVIN_SIG_FMT_CAMERA_640X480P_30Hz";
-			break;
-		case TVIN_SIG_FMT_CAMERA_800X600P_30HZ:
-			return "TVIN_SIG_FMT_CAMERA_800X600P_30Hz";
-			break;
-		case TVIN_SIG_FMT_CAMERA_1024X768P_30HZ:
-			return "TVIN_SIG_FMT_CAMERA_1024X768P_30Hz";
-			break;
-		case TVIN_SIG_FMT_CAMERA_1920X1080P_30HZ:
-			return "TVIN_SIG_FMT_CAMERA_1920X1080P_30Hz";
-			break;
-		case TVIN_SIG_FMT_CAMERA_1280X720P_30HZ:
-			return "TVIN_SIG_FMT_CAMERA_1280X720P_30Hz";
-			break;
-		case TVIN_SIG_FMT_MAX:
-			return "TVIN_SIG_FMT_MAX";
-			break;
-		default:
-			return "TVIN_SIG_FMT_NULL";
-			break;
-	}
-}
-EXPORT_SYMBOL(tvin_sig_fmt_str);
-
-
-const struct tvin_format_s *tvin_get_fmt_info(enum tvin_sig_fmt_e fmt)
-{
-	//find  format table through format
-	if (fmt < TVIN_SIG_FMT_VGA_MAX && fmt > TVIN_SIG_FMT_NULL)
-		return &tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147];
-	else if (fmt < TVIN_SIG_FMT_COMP_MAX && fmt > TVIN_SIG_FMT_VGA_THRESHOLD)
-		return  &tvin_comp_fmt_tbl[fmt-TVIN_SIG_FMT_COMP_480P_60HZ_D000];
-	else if (fmt < TVIN_SIG_FMT_HDMI_MAX && fmt > TVIN_SIG_FMT_COMP_THRESHOLD)
-		return &tvin_hdmi_fmt_tbl[fmt-TVIN_SIG_FMT_HDMI_640X480P_60HZ];
-	else if (fmt < TVIN_SIG_FMT_CVBS_MAX && fmt > TVIN_SIG_FMT_HDMI_THRESHOLD)
-		return &tvin_cvbs_fmt_tbl[fmt-TVIN_SIG_FMT_CVBS_NTSC_M];
-	else if (fmt < TVIN_SIG_FMT_BT601_MAX && fmt > TVIN_SIG_FMT_CVBS_THRESHOLD)
-		return &tvin_bt601_fmt_tbl[fmt-TVIN_SIG_FMT_BT656IN_576I_50HZ];
-    else
-        return NULL;
-	//we also can find  format table through port
-	/* 
-	   if(port != TVIN_PORT_NULL)
-	   {
-	   if ((port >= TVIN_PORT_VGA0) && (port < TVIN_PORT_VGA7))
-	   return &tvin_vga_fmt_tbl[fmt-TVIN_SIG_FMT_VGA_512X384P_60HZ_D147];
-	   else if ((port >= TVIN_PORT_COMP0) && (port < TVIN_PORT_COMP7)) 
-	   return  &tvin_comp_fmt_tbl[fmt-TVIN_SIG_FMT_COMP_480P_60HZ_D000];
-	   else if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7)) 
-	   return &tvin_cvbs_fmt_tbl[fmt-TVIN_SIG_FMT_CVBS_NTSC_M];
-	   else if ((port >= TVIN_PORT_HDMI0) && (port <= TVIN_PORT_HDMI7)) 
-	   return &tvin_hdmi_fmt_tbl[fmt-TVIN_SIG_FMT_HDMI_640X480P_60HZ];
-	   else if ((port >= TVIN_PORT_BT656) && (port <= TVIN_PORT_CAMERA)) 
-	   return &tvin_bt601_fmt_tbl[fmt-TVIN_SIG_FMT_BT656IN_576I_50HZ];		
-	   }
-	 */
-}
-EXPORT_SYMBOL(tvin_get_fmt_info);
-
-const struct tvin_format_s tvin_vga_fmt_tbl[TVIN_SIG_FMT_VGA_MAX - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147 + 1] =
-{
-	//   H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity             Vs_Polarity             Scan_Mode                   Pixel_Clk(Khz/10) VBIs VBIe
-	{ 512,     384,      0 ,        10,    10,       49 ,        10,    640,    407,     16,     32,     80,       1,       3,   19,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  1567,   0,   0, 1596 }, // TVIN_SIG_FMT_VGA_512X384P_60D147,
-	{ 560,     384,      0 ,        10,    10,       67 ,        10,    704,    407,     16,     48,     80,       1,       3,   19,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  1723,   0,   0, 1596 }, // TVIN_SIG_FMT_VGA_560X384P_60D147,
-	{ 640,     200,      0 ,        10,    10,       94 ,        10,    912,    262,     94,     56,    122,      25,       3,   34,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  1432,   0,   0, 1602 }, // TVIN_SIG_FMT_VGA_640X200P_59D924,
-	{ 640,     350,      0 ,        10,    10,       49 ,        10,    832,    445,     32,     64,     96,      32,       3,   60,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3150,   0,   0, 1128 }, // TVIN_SIG_FMT_VGA_640X350P_85D080,
-	{ 640,     400,      0 ,        10,    10,       92 ,         2,    800,    525,     16,     96,     48,      50,       2,   73,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2517,   0,   0, 1602 }, // TVIN_SIG_FMT_VGA_640X400P_59D940,
-	{ 640,     400,      0 ,        10,    10,       49 ,        10,    832,    445,     32,     64,     96,       1,       3,   41,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3150,   0,   0, 1128 }, // TVIN_SIG_FMT_VGA_640X400P_85D080,
-	{ 640,     400,      0 ,        10,    10,       111,        10,    824,    508,      3,    115,     66,      42,       2,   64,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2496,   0,   0, 1610 }, // TVIN_SIG_FMT_VGA_640X400P_59D638,
-	{ 640,     400,      0 ,        10,    10,       73 ,        10,    848,    440,     64,     64,     80,       7,       8,   25,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2105,   0,   0, 1702 }, // TVIN_SIG_FMT_VGA_640X400P_56D416,
-	{ 640,     480,      0 ,        10,    10,       49 ,        10,    896,    525,     80,     64,    112,       3,       3,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3134,   0,   0, 1441 }, // TVIN_SIG_FMT_VGA_640X480P_66D619,
-	{ 640,     480,      0 ,        10,    10,       51 ,        10,    864,    525,     64,     64,     96,       3,       3,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3024,   0,   0, 1440 }, // TVIN_SIG_FMT_VGA_640X480P_66D667,   // 10
-	{ 640,     480,      0 ,        10,    10,       92 ,        10,    800,    525,     16,     96,     48,      10,       2,   33,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2517,   0,   0, 1602 }, // TVIN_SIG_FMT_VGA_640X480P_59D940,
-	{ 640,     480,    762 ,        10,    10,       91 ,         2,    800,    525,     16,     96,     48,      10,       2,   33,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2520,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_640X480P_60D000,
-	{ 640,     480,    634 ,        10,    10,       30 ,        10,    832,    520,     24,     40,    128,       9,       3,   28,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3150,   0,   0, 1319 }, // TVIN_SIG_FMT_VGA_640X480P_72D809,
-	{ 640,     480,    640 ,        10,    10,       49 ,        10,    840,    500,     16,     64,    120,       1,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3150,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_640X480P_75D000_A,
-	{ 640,     480,      0 ,        10,    10,       37 ,        10,    832,    509,     56,     56,     80,       1,       3,   25,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3600,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_640X480P_85D008,
-	{ 640,     480,    792 ,        10,    10,       105,        10,    826,    508,      3,    110,     73,       4,       2,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2502,   0,   0, 1610 }, // TVIN_SIG_FMT_VGA_640X480P_59D638,
-	{ 640,     480,      0 ,        10,    10,       73 ,        10,    800,    525,     16,     96,     48,      11,       2,   32,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3150,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_640X480P_75D000_B,
-	{ 640,     870,      0 ,        10,    10,       34 ,        10,    832,    918,     32,     80,     80,       3,       3,   42,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5728,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_640X870P_75D000,
-	{ 720,     350,      0 ,        10,    10,       92 ,        10,    900,    449,     18,    108,     54,      37,       2,   60,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2832,   0,   0, 1370 }, // TVIN_SIG_FMT_VGA_720X350P_70D086,
-	{ 720,     400,      0 ,        10,    10,       49 ,        10,    936,    446,     36,     72,    108,       1,       3,   42,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3550,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_720X400P_85D039,   // 20
-	{ 720,     400,    763 ,        10,    10,       92 ,        10,    900,    449,     18,    108,     54,      12,       2,   35,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2832,   0,   0, 1370 }, // TVIN_SIG_FMT_VGA_720X400P_70D086,
-	{ 720,     400,      0 ,        10,    10,       73 ,        10,    900,    449,     18,    108,     54,      21,       2,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3550,   0,   0, 1093 }, // TVIN_SIG_FMT_VGA_720X400P_87D849,
-	{ 720,     400,      0 ,        10,    10,       92 ,        10,    900,    525,     18,    108,     54,      50,       2,   73,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2832,   0,   0, 1602 }, // TVIN_SIG_FMT_VGA_720X400P_59D940,
-	{ 720,     480,    763 ,        10,    10,       92 ,        10,    900,    525,     18,    108,     54,      10,       2,   33,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2832,   0,   0, 1602 }, // TVIN_SIG_FMT_VGA_720X480P_59D940,
-	{ 768,     480,    801 ,        10,    10,       60 ,        10,    960,    500,     24,     72,     96,       3,       6,   11,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2875,   0,   0, 1603 }, // TVIN_SIG_FMT_VGA_768X480P_59D896,
-	//H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity             Vs_Polarity             Scan_Mode                   Pixel_Clk(Khz/10) VBIs VBIe
-	{ 800,     600,    682 ,        10,    10,       48 ,        10,   1024,    625,     24,     72,    128,       1,       2,   22,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3600,   0,   0, 1707 }, // TVIN_SIG_FMT_VGA_800X600P_56D250,
-	{ 800,     600,    634 ,        10,    10,       30 ,        50,   1024,    622,     32,     80,    112,       1,       4,   17,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  3812,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_800X600P_60D000,
-	{ 800,     600,    547 ,        10,    10,       42 ,        10,   1040,    625,     64,     68,    108,       3,       3,   19,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  4000,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_800X600P_60D000_A,
-	{ 800,     600,    634 ,        10,    10,       77 ,        10,   1055,    628,     40,    128,     88,       1,       4,   23,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  4000,   0,   0, 1592 }, // TVIN_SIG_FMT_VGA_800X600P_60D317,
-	{ 800,     600,    499 ,        10,    10,       58 ,        10,   1040,    666,     56,    120,     64,      37,       6,   23,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5000,   0,   0, 1330 }, // TVIN_SIG_FMT_VGA_800X600P_72D188,   //30
-	{ 800,     600,    512 ,        10,    10,       39 ,        10,   1056,    625,     16,     80,    160,       1,       3,   21,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  4950,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_800X600P_75D000,
-	{ 800,     600,    447 ,        10,    10,       27 ,        10,   1048,    631,     32,     64,    152,       1,       3,   27,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5625,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_800X600P_85D061,
-	{ 832,     624,      0 ,        10,    10,       42 ,        10,   1120,    654,     32,     96,    160,       3,       3,   24,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5500,   0,   0, 1279 }, // TVIN_SIG_FMT_VGA_832X624P_75D087,
-	{ 848,     480,      0 ,        10,    10,       41 ,        10,   1088,    507,     40,     80,    120,       3,       5,   19,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  4675,   0,   0, 1133 }, // TVIN_SIG_FMT_VGA_848X480P_84D751,
-	{ 960,     600,    645 ,        10,    10,       51 ,        10,   1216,    624,     32,     96,    128,       3,       6,   15,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  4525,   0,   0, 1610 }, // TVIN_SIG_FMT_VGA_960X600P_59D635,
-	{1024,     768,    349 ,        10,    10,       27 ,        10,   1344,    807,     96,     80,    144,       9,       1,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  6400,   0,   0, 1619 }, // TVIN_SIG_FMT_VGA_1024X768P_59D278,
-	{1024,     768,    355 ,        10,    10,        0 ,        10,   1328,   1120,     80,     80,    144,      11,       4,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  6400,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1024X768P_60D000,
-	{1024,     768,    495 ,         8,     6,       35 ,        35,   1344,    806,     56,    120,    144,       1,       6,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1024X768P_60D000_A,//for hdmi and vga
-	{1024,     768,    495 ,         8,     8,       50 ,        10,   1344,    806,     56,    120,    144,       1,       6,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1024X768P_60D000_B,//for hdmi and vga
-	{1024,     768,    398 ,        10,    10,       29 ,        10,   1328,    804,     32,     96,    176,       3,       3,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8000,   0,   0, 1281 }, // TVIN_SIG_FMT_VGA_1024X768P_74D927,  //40
-	{1024,     768,    496 ,        10,    10,       50 ,        10,   1344,    806,     28,    136,    156,       3,       6,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  6500,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1024X768P_60D004,
-	{1024,     768,    425 ,        10,    10,       44 ,        10,   1328,    806,     24,    136,    144,       3,       6,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7500,   0,   0, 1370 }, // TVIN_SIG_FMT_VGA_1024X768P_70D069,
-	{1024,     768,    400 ,        10,    10,       29 ,        10,   1312,    800,     16,     96,    176,       1,       3,   28,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7875,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_1024X768P_75D029,
-	{1024,     768,      0 ,        10,    10,       24 ,        10,   1376,    808,     48,     96,    208,       1,       3,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9450,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_1024X768P_84D997,
-	{1024,     768,    381 ,        10,    10,       36 ,        10,   1344,    840,     64,    128,    128,       4,       4,   64,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8459,   0,   0, 1281 }, // TVIN_SIG_FMT_VGA_1024X768P_74D925,
-	{1024,     768,      0 ,        10,    10,       29 ,        10,   1328,    803,     16,     96,    192,       6,       6,   23,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8000,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_1024X768P_75D020,
-	{1024,     768,      0 ,        10,    10,       85 ,        10,   1368,    804,     18,    273,     53,       0,       8,   28,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7700,   0,   0, 1371 }, // TVIN_SIG_FMT_VGA_1024X768P_70D008,
-	{1024,     768,      0 ,        10,    10,       89 ,        10,   1408,    806,      8,    320,     56,       0,       8,   30,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8600,   0,   0, 1267 }, // TVIN_SIG_FMT_VGA_1024X768P_75D782,
-	{1024,     768,      0 ,        10,    10,       36 ,        10,   1360,    805,     32,    128,    176,       2,       4,   31,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8437,   0,   0, 1246 }, // TVIN_SIG_FMT_VGA_1024X768P_77D069,
-	{1024,     768,      0 ,        10,    10,       44 ,        10,   1296,    806,     24,    136,    112,       3,       6,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7500,   0,   0, 1337 }, // TVIN_SIG_FMT_VGA_1024X768P_71D799,   //50
-	{1024,    1024,      0 ,        10,    10,       43 ,        10,   1408,   1056,     21,    160,    203,       3,       3,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8921,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1024X1024P_60D000,
-	{1152,     864,    446 ,        10,    10,       36 ,        10,   1520,    895,     54,     96,    172,       16,      3,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1152X864P_60D000,
-	{1152,     864,      0 ,        10,    10,       24 ,        10,   1480,    912,     32,     96,    200,       1,       3,   44,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9450,   0,   0, 1371 }, // TVIN_SIG_FMT_VGA_1152X864P_70D012,
-	{1152,     864,      0 ,        10,    10,       28 ,        10,   1600,    900,     64,    128,    256,       1,       3,   32,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_1152X864P_75D000,
-	{1152,     864,      0 ,        10,    10,       25 ,        10,   1576,    907,     64,    128,    232,       1,       3,   39,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 12150,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_1152X864P_84D999,
-	{1152,     870,      0 ,        10,    10,       31 ,        10,   1456,    915,     32,    128,    144,       3,       3,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10000,   0,   0, 1279 }, // TVIN_SIG_FMT_VGA_1152X870P_75D062,
-	{1152,     900,      0 ,        10,    10,       33 ,        10,   1504,    937,     29,    128,    195,       2,       4,   31,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9294,   0,   0, 1456 }, // TVIN_SIG_FMT_VGA_1152X900P_65D950,
-	{1152,     900,      0 ,        10,    10,       33 ,        10,   1528,    937,     40,    128,    208,       2,       4,   31,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  9450,   0,   0, 1454 }, // TVIN_SIG_FMT_VGA_1152X900P_66D004,
-	{1152,     900,      0 ,        10,    10,       22 ,        10,   1472,    943,     16,     96,    208,       2,       8,   33,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10556,   0,   0, 1262 }, // TVIN_SIG_FMT_VGA_1152X900P_76D047,
-	{1152,     900,      0 ,        10,    10,       28 ,        10,   1504,    943,     32,    128,    192,       2,       8,   33,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1261 }, // TVIN_SIG_FMT_VGA_1152X900P_76D149,   //60
-	{1280,     720,    536 ,        10,    10,       41 ,        10,   1664,    748,     64,    128,    192,       3,       5,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7450,   0,   0, 1604 }, // TVIN_SIG_FMT_VGA_1280X720P_59D855,
-	{1280,     720,    536 ,        10,    10,       13 ,        10,   1664,    748,     64,    128,    192,       4,       4,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X720P_60D000_A,
-	{1280,     720,    536 ,        10,    10,       41 ,        10,   1664,    748,     64,    128,    192,       3,       5,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X720P_60D000_B,
-	{1280,     720,    532 ,        10,    10,       13 ,        10,   1650,    748,     100,    78,    192,       4,       4,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X720P_60D000_C,
-	{1280,     720,    372 ,        10,    10,       30 ,        10,   1664,    755,     64,    128,    192,      12,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7450,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X720P_60D000_D,
-	{1280,     768,    502 ,        10,    10,       39 ,        10,   1663,    798,     64,    128,    192,       3,       7,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7950,   0,   0, 1603 }, // TVIN_SIG_FMT_VGA_1280X768P_59D870,
-	{1280,     768,    506 ,        10,    10,       11 ,        10,   1440,    790,     48,     32,     80,       3,       7,   12,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  6825,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X768P_59D995,
-	{1280,     768,    502 ,        10,    10,       39 ,        10,   1680,    798,     64,    128,    192,       7,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7950,   0,   0, 1597 }, // TVIN_SIG_FMT_VGA_1280X768P_60D100,
-	{1280,     768,    349 ,        10,    10,       29 ,        10,   1712,    808,    132,    118,    182,      13,       7,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7950,   0,   0, 1597 }, /// TVIN_SIG_FMT_VGA_1280X768P_85D000,
-	{1280,     768,      0 ,        10,    10,       30 ,        10,   1696,    805,     80,    128,    208,       3,       7,   27,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10225,   0,   0, 1282 }, // TVIN_SIG_FMT_VGA_1280X768P_74D893,   //70
-	{1280,     768,      0 ,        10,    10,       28 ,        10,   1712,    809,     80,    136,    216,       3,       7,   31,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 11750,   0,   0, 1132 }, // TVIN_SIG_FMT_VGA_1280X768P_84D837,
-	{1280,     800,    483 ,        10,    10,       37 ,        10,   1680,    831,     72,    128,    200,       3,       6,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8350,   0,   0, 1605 }, // TVIN_SIG_FMT_VGA_1280X800P_59D810,
-	{1280,     800,    483 ,        10,    10,       40 ,        10,   1680,    827,     72,    128,    200,       2,       3,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8350,   0,   0, 1605 }, // TVIN_SIG_FMT_VGA_1280X800P_59D810_A,
-	{1280,     800,    334 ,        10,    10,       26 ,        10,   1680,    843,     72,    128,    200,      18,       3,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8350,   0,   0, 1605 }, // TVIN_SIG_FMT_VGA_1280X800P_60D000,
-	{1280,     800,    334 ,        10,    10,       26 ,        10,   1712,    843,     80,    136,    216,       3,       6,   34,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8350,   0,   0, 1605 }, // TVIN_SIG_FMT_VGA_1280X800P_85D000,
-	{1280,     960,    399 ,        10,    10,       25 ,        5,   1800,   1000,     96,    112,    312,       1,       3,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X960P_60D000,
-	{1280,     960,    399 ,        10,    10,       25 ,        10,   1712,   994,     80,    136,    216,       1,       3,   29,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X960P_60D000_A,
-	{1280,     960,      0 ,        10,    10,       27 ,        10,   1680,   1000,     32,    144,    224,       1,       3,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 12600,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_1280X960P_75D000,
-	{1280,     960,      0 ,        10,    10,       26 ,        10,   1728,   1011,     64,    160,    224,       1,       3,   47,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_1280X960P_85D002,
-	{1280,    1024,    375 ,        10,    10,       25 ,        10,   1688,   1066,     48,    112,    248,       1,       3,   38,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1599 }, // TVIN_SIG_FMT_VGA_1280X1024P_60D020,  //80
-	{1280,    1024,    375 ,        10,     5,       25 ,         4,   1688,   1067,     92,    112,    204,       1,       3,   38,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1599 }, // TVIN_SIG_FMT_VGA_1280X1024P_60D020_A,
-	{1280,    1024,    300 ,        10,    10,       26 ,        10,   1688,   1066,     16,    144,    248,       1,       3,   38,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 13500,   0,   0, 1280 }, // TVIN_SIG_FMT_VGA_1280X1024P_75D025,
-	{1280,    1024,      0 ,        10,    10,       24 ,        10,   1728,   1072,     64,    160,    224,       1,       3,   44,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 15750,   0,   0, 1129 }, // TVIN_SIG_FMT_VGA_1280X1024P_85D024,
-	{1280,    1024,      0 ,        10,    10,       41 ,        10,   1708,   1056,     44,    184,    200,       3,       3,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10818,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1280X1024P_59D979,
-	{1280,    1024,      0 ,        10,    10,       34 ,        10,   1728,   1085,     64,    192,    192,       3,       3,   55,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 13500,   0,   0, 1333 }, // TVIN_SIG_FMT_VGA_1280X1024P_72D005,
-	{1280,    1024,      0 ,        10,    10,       43 ,        10,   1760,   1056,     26,    200,    254,       3,       3,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 11152,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X1024P_60D002,
-	{1280,    1024,      0 ,        10,    10,       32 ,        10,   1696,   1056,     32,    160,    224,       3,       3,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 12000,   0,   0, 1433 }, // TVIN_SIG_FMT_VGA_1280X1024P_67D003,
-	{1280,    1024,      0 ,        10,    10,       26 ,        10,   1712,   1064,     32,    144,    256,       3,       3,   34,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 13500,   0,   0, 1295 }, // TVIN_SIG_FMT_VGA_1280X1024P_74D112,
-	{1280,    1024,      0 ,        10,    10,       17 ,        10,   1724,   1066,     32,    100,    312,       3,       3,   36,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14000,   0,   0, 1260 }, // TVIN_SIG_FMT_VGA_1280X1024P_76D179,
-	{1280,    1024,      0 ,        10,    10,       23 ,        10,   1632,   1075,     16,    112,    224,       6,       8,   37,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 11705,   0,   0, 1439 }, // TVIN_SIG_FMT_VGA_1280X1024P_66D718,  //90
-	{1280,    1024,      0 ,        10,    10,       26 ,        10,   1648,   1075,     24,    128,    216,       2,       8,   41,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 11812,   0,   0, 1440 }, // TVIN_SIG_FMT_VGA_1280X1024P_66D677,
-	{1280,    1024,      0 ,        10,    10,       11 ,        10,   1664,   1066,     32,     64,    288,       2,       8,   32,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 13500,   0,   0, 1261 }, // TVIN_SIG_FMT_VGA_1280X1024P_76D107,
-	{1280,    1024,      0 ,        10,    10,       25 ,        10,   1688,   1065,     48,    112,    248,       1,       3,   37,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10786,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X1024P_59D996,
-	{1280,    1024,    374 ,        10,    10,        0 ,        10,   1688,   1065,     48,    112,    248,       2,       2,   37,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10786,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1280X1024P_60D000,
-	{1360,     768,    349 ,        10,    10,       28 ,        10,   1824,    806,    130,    126,    208,      12,       4,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8475,   0,   0, 1605 }, // TVIN_SIG_FMT_VGA_1360X768P_59D799,
-	{1360,     768,    503 ,        10,    10,       32 ,         7,   1792,    795,     64,    112,    256,       3,       6,   18,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8550,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1360X768P_60D015,
-	{1360,     768,    503 ,        7 ,     8,        32 ,         7,   1792,    795,    104,    112,    216,       3,       6,   18,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8550,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1360X768P_60D015_A,
-	{1360,     850,    454 ,        10,    10,       37 ,        10,   1776,    879,     72,    136,    208,       3,       5,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8475,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1360X850P_60D000,
-	{1360,    1024,   377  ,        10,    10,       30 ,        10,   1776,   1059,     72,    136,    208,       8,       5,   22,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8475,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1360X1024P_60D000,
-	{1366,     768,    503 ,        10,    10,       40 ,        10,   1790,    798,     64,    143,    217,       3,       3,   24,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  8550,   0,   0, 1606 }, // TVIN_SIG_FMT_VGA_1366X768P_59D790,  //100
-	{1366,     768,    500 ,        10,    10,       22 ,        10,   1500,    800,     14,     56,     64,       1,       3,   28,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7200,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1366X768P_60D000,
-	{1400,    1050,   367  ,        10,    10,       28 ,        10,   1878,   1089,     88,    144,    232,       3,       4,   32,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 12175,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1400X1050P_59D978,
-	{1440,     900,    429 ,        10,    10,       34 ,        10,   1904,    934,    120,    132,    212,       3,       6,   25,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10650,   0,   0, 1603 }, // TVIN_SIG_FMT_VGA_1440X900P_59D887,
-	{1440,    1080,      0 ,        10,    10,       28 ,        10,   1936,   1118,     96,    152,    248,       1,       3,   34,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 12987,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1440X1080P_60D000,
-	{1600,     900,    298 ,        10,    10,       23 ,        10,   2160,    945,     64,    192,    304,       1,       3,   41,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 16200,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1600X900P_60D000,
-	{1600,    1024,   261  ,        10,    10,       21 ,        10,   2160,   1075,     64,    192,    304,       2,       3,   46,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 16200,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1600X1024P_60D000,
-	{1600,    1200,   321  ,        10,     3,       25 ,        10,   2150,   1246,     64,    182,    304,       1,       4,   46,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 16100,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1600X1200P_59D869,
-	{1600,    1200,   320  ,        10,    10,       28 ,        10,   2160,   1250,     64,    192,    304,       1,       3,   46,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 16200,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1600X1200P_60D000,
-	{1600,    1200,      0 ,        10,    10,       26 ,        10,   2160,   1250,     64,    192,    304,       1,       3,   46,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 17550,   0,   0, 1477 }, // TVIN_SIG_FMT_VGA_1600X1200P_65D000,
-	{1600,    1200,   274  ,        10,    10,       24 ,        10,   2160,   1250,     64,    192,    304,       1,       3,   46,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 18900,   0,   0, 1371 }, // TVIN_SIG_FMT_VGA_1600X1200P_70D000,
-	{1680,    1051,   367 ,        10 ,    10,       28 ,        10,   2238,   1089,    104,    176,    280,       3,       6,   31,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14625,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1680X1050P_59D954,  //110
-	{1680,    1080,      0 ,        10,    10,       29 ,        10,   2256,   1118,    104,    184,    288,       1,       3,   34,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 15133,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1680X1080P_60D000,
-	{1920,    1080,   431  ,        10,    10,       34 ,        10,   2543,   1114,    112,    200,    312,       3,       5,   26,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14150,   0,   0, 1923 }, // TVIN_SIG_FMT_VGA_1920X1080P_49D929,
-	{1920,    1080,   357  ,        10,    10,       28 ,        10,   2576,   1120,    152,    200,    304,       5,       3,   32,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 17280,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1920X1080P_59D963_A,
-	{1920,    1080,   357  ,        10,    10,       28 ,        10,   2574,   1120,    128,    200,    328,       3,       5,   32,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 17280,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1920X1080P_59D963,
-	{1920,    1080,   356  ,        10,    10,        7 ,        10,   2200,   1125,     72,     88,    120,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1920X1080P_60D000,
-	{1920,    1200,    324 ,        10,    10,        5 ,        10,   2080,   1235,     48,    32,      80,       3,       6,   26,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 15400,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1920X1200P_59D950,//116
-	{1024,     768,    495 ,        10,    10,       76 ,        10,   1350,    805,     26,    244,     46,      1,       3,    33,    TVIN_SYNC_POL_NEGATIVE,     TVIN_SYNC_POL_NEGATIVE,    TVIN_SCAN_MODE_PROGRESSIVE, 10237,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_1024x768P_60D000_C,
-	{1024,     768,    496 ,        10,    10,       50 ,        10,   1344,    806,     24,    136,    160,       3,       6,   29,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  6500,   0,   0, 1600 }, //TVIN_SIG_FMT_VGA_1024x768P_60D000_D,
-	{1920,    1200,    320 ,        10,    10,        25,        10,   2592,   1242,    136,    200,    336,       3,       4,   36,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 19325,   0,   0, 1601 }, // TVIN_SIG_FMT_VGA_1920X1200P_59D988, //120	
-	{1400,	   900,	    432,	10,	10,	   9,	     10,   1600,   926 ,     48,    32,	     80,       3,	6,   17,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE,TVIN_SCAN_MODE_PROGRESSIVE,  8875,   0,	0,  1600},//TVIN_SIG_FMT_VGA_1400X900P_60D00,
-	{1680,	  1050,    370 , 	10,	10,	  7 ,	     10,   1840,   1080,     48,    32,      80,       3,	6,   21,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 11900,	0,	 0, 1600 }, // TVIN_SIG_FMT_VGA_1680X1050P_60D000,	
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE6,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE7,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE8,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE9,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE10,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE11,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_RESERVE12,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_VGA_MAX,
-};
-
-const struct tvin_format_s tvin_comp_fmt_tbl[TVIN_SIG_FMT_COMP_MAX - TVIN_SIG_FMT_COMP_480P_60HZ_D000 + 1] =
-{
-	//   H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity             Vs_Polarity             Scan_Mode                   Pixel_Clk(Khz/10) VBIs VBIe
-#ifdef CONFIG_ADC_DOUBLE_SAMPLING_FOR_SD
-	{1440,     480,    762 ,        20,    20,       55 ,        10,   1716,    525,     32,    124,    120,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_PROGRESSIVE, 5406,   0,   0, 1600 }, // TVIN_SIG_FMT_COMPONENT_480P_60D000,
-	{1440,     240,    1525,        20,    20,       110,        10,   1716,    263,     38,    124,    114,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,   2700,   0,   0, 1602 }, // TVIN_SIG_FMT_COMPONENT_480I_59D940,
-	{1440,     576,    768 ,        20,    20,       57 ,        10,   1728,    625,     24,    128,    136,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_PROGRESSIVE, 5400,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_576P_50D000,
-	{1440,     288,    1536,        20,    20,       112,        10,   1728,    313,     24,    126,    138,       2,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,   2700,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_576I_50D000,
-#else
-	{ 720,     480,    762 ,        20,    20,       55 ,        10,    858,    525,     16,     62,     60,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_PROGRESSIVE, 2703,   0,   0, 1600 }, // TVIN_SIG_FMT_COMPONENT_480P_60D000,
-	{ 720,     240,    1525,        20,    20,       110,        10,    858,    263,     19,     62,     57,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,   1350,   0,   0, 1602 }, // TVIN_SIG_FMT_COMPONENT_480I_59D940,
-	{ 720,     576,    768 ,        20,    20,       57 ,        10,    864,    625,     12,     64,     68,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_PROGRESSIVE, 2700,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_576P_50D000,
-	{ 720,     288,    1536,        20,    20,       112,        10,    864,    313,     12,     63,     69,       2,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,   1350,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_576I_50D000,
-#endif
-	{1280,     720,    534 ,        10,    20,       13 ,        10,   1650,    750,     70,     80,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7418,   0,   0, 1602 }, // TVIN_SIG_FMT_COMPONENT_720P_59D940,
-	{1280,     720,    640 ,        10,    20,       13 ,        10,   1980,    750,    400,     80,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_720P_50D000,
-	{1920,    1080,      0 ,        10,    20,       14 ,        10,   2750,   1125,    594,     88,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7418,   0,   0, 4004 }, // TVIN_SIG_FMT_COMPONENT_1080P_23D976,
-	{1920,    1080,    889 ,        20,    20,       14 ,        10,   2750,   1125,    594,     88,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 4000 }, // TVIN_SIG_FMT_COMPONENT_1080P_24D000,
-	{1920,    1080,    853 ,        20,    20,       14 ,        10,   2640,   1125,    484,     88,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 3840 }, // TVIN_SIG_FMT_COMPONENT_1080P_25D000,
-	{1920,    1080,    711 ,        10,    20,       14 ,        10,   2200,   1125,     44,     88,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 3200 }, // TVIN_SIG_FMT_COMPONENT_1080P_30D000,//140
-	{1920,    1080,    427 ,        10,    20,       7  ,        10,   2640,   1125,    484,     88,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_1080P_50D000,
-	{1920,    1080,    356 ,        10,    20,       7  ,        10,   2200,   1125,     44,     88,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1600 }, // TVIN_SIG_FMT_COMPONENT_1080P_60D000,
-	{1920,     540,      0 ,        10,    20,       14 ,        10,   2750,    563,    594,     88,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7418,   0,   0, 2002 }, // TVIN_SIG_FMT_COMPONENT_1080I_47D952,
-	{1920,     540,      0 ,        10,    20,       14 ,        10,   2750,    563,    594,     88,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7425,   0,   0, 2000 }, // TVIN_SIG_FMT_COMPONENT_1080I_48D000,
-	{1920,     540,    853 ,        10,    20,       14 ,        10,   2640,    563,    484,     88,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7425,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_1080I_50D000_A,
-	{1920,     540,      0 ,        10,    20,       56 ,        10,   2304,    625,     32,    168,    184,      23,       5,   57,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  7200,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_1080I_50D000_B,
-	{1920,     540,      0 ,        10,    20,       21 ,        10,   2376,    625,     81,    132,    243,       4,       1,   80,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7425,   0,   0, 1920 }, // TVIN_SIG_FMT_COMPONENT_1080I_50D000_C,
-	{1920,     540,    711 ,        10,    20,       14 ,        10,   2200,    563,     44,     88,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7425,   0,   0, 1600 }, // TVIN_SIG_FMT_COMPONENT_1080I_60D000,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,   0,         TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0, 1600 }, // TVIN_SIG_FMT_COMPONENT_MAX,
-};
-const struct tvin_format_s tvin_hdmi_fmt_tbl[TVIN_SIG_FMT_HDMI_MAX - TVIN_SIG_FMT_HDMI_640X480P_60HZ + 1] =
-{
-	//   H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity             Vs_Polarity             Scan_Mode                   Pixel_Clk(Khz/10) VBIs VBIe
-	{ 640,     480,       0,        10,    10,         0,        10,    800,    525,     16,     96,     48,      10,       2,   33,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2518,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_640x480P_60Hz,
-	{ 720,     480,       0,        10,    10,         0,        10,    858,    525,     16,     62,     60,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2700,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_720x480P_60Hz,
-	{1280,     720,       0,        10,    10,         0,        10,   1650,    750,    110,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1280x720P_60Hz,
-	{1920,     540,       0,        10,    10,         0,        10,   2200,    563,     88,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7425,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1920x1080I_60Hz,
-	{1440,     240,       0,        10,    10,         0,        10,   1716,    263,     38,    124,    114,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  2700,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1440x480I_60Hz,
-	{1440,     240,       0,        10,    10,         0,        10,   1716,    262,     38,    124,    114,       4,       3,   15,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2700,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1440x240P_60Hz,
-	{2880,     240,       0,        10,    10,         0,        10,   3432,    263,     76,    248,    228,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  5400,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_2880x480I_60Hz,
-	{2880,     240,       0,        10,    10,         0,        10,   3432,    262,     76,    248,    228,       4,       3,   15,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 1590 }, // TVIN_SIG_FMT_HDMI_2880x240P_60Hz,
-	{1440,     480,       0,        10,    10,         0,        10,   1716,    525,     32,    124,    120,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1440x480P_60Hz,
-	{1920,    1080,       0,        10,    10,         0,        10,   2200,   1125,     88,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1920x1080P_60Hz,
-	{ 720,     576,       0,        10,    10,         0,        10,    864,    625,     12,     64,     68,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2700,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_720x576P_50Hz, //160
-	{1280,     720,       0,        10,    10,         0,        10,   1980,    750,    440,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1280x720P_50Hz,
-	{1920,     540,       0,        10,    10,         0,        10,   2640,    563,    528,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED,  7425,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1920x1080I_50Hz_A,
-	{1440,     288,       0,        10,    10,         0,        10,   1728,    313,     24,    126,    138,       2,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  2700,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1440x576I_50Hz,
-	{1440,     288,       0,        10,    10,         0,        10,   1728,    312,     24,    126,    138,       2,       3,   19,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  2700,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1440x288P_50Hz,
-	{2880,     288,       0,        10,    10,         0,        10,   3456,    313,     48,    252,    276,       2,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  5400,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_2880x576I_50Hz,
-	{2880,     288,       0,        10,    10,         0,        10,   3456,    312,     48,    252,    276,       2,       3,   19,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_2880x288P_50Hz,
-	{1440,     576,       0,        10,    10,         0,        10,   1728,    625,     24,    128,    136,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1440x576P_50Hz,
-	{1920,    1080,       0,        10,    10,         0,        10,   2640,   1125,    528,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1920x1080P_50Hz,
-	{1920,    1080,       0,        10,    10,         0,        10,   2750,   1125,    638,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 4000 }, // TVIN_SIG_FMT_HDMI_1920x1080P_24Hz,
-	{1920,    1080,       0,        10,    10,         0,        10,   2640,   1125,    528,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 3840 }, // TVIN_SIG_FMT_HDMI_1920x1080P_25Hz,//170
-	{1920,    1080,       0,        10,    10,         0,        10,   2200,   1125,     88,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 3200 }, // TVIN_SIG_FMT_HDMI_1920x1080P_30Hz,
-	{2880,     480,       0,        10,    10,         0,        10,   3432,    525,     64,    248,    240,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_2880x480P_60Hz,
-	{2880,     576,       0,        10,    10,         0,        10,   3456,    625,     48,    256,    272,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_2880x576P_60Hz,
-	{1920,     540,       0,        10,    10,         0,        10,   2304,    625,     32,    168,    184,      23,       5,   57,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  7200,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1920x1080I_50Hz_B,
-	{1920,     540,       0,        10,    10,         0,        10,   2640,    563,    528,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED, 14850,   0,   0, 960  }, // TVIN_SIG_FMT_HDMI_1920x1080I_100Hz,
-	{1280,     720,       0,        10,    10,         0,        10,   1980,    750,    440,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 960  }, // TVIN_SIG_FMT_HDMI_1280x720P_100Hz,
-	{ 720,     576,       0,        10,    10,         0,        10,    864,    625,     12,     64,     68,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 960  }, // TVIN_SIG_FMT_HDMI_720x576P_100Hz,
-	{1440,     288,       0,        10,    10,         0,        10,   1728,    313,     24,     12,    252,       2,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  5400,   0,   0, 960  }, // TVIN_SIG_FMT_HDMI_1440x576I_100Hz,
-	{1920,     540,       0,        10,    10,         0,        10,   2200,    563,     88,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED, 14850,   0,   0, 800  }, // TVIN_SIG_FMT_HDMI_1920x1080I_120Hz,
-	{1280,     720,       0,        10,    10,         0,        10,   1650,    750,    110,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 800  }, // TVIN_SIG_FMT_HDMI_1280x720P_120Hz,//180
-	{ 720,     480,       0,        10,    10,         0,        10,    858,    525,     16,     62,     60,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 800  }, // TVIN_SIG_FMT_HDMI_720x480P_120Hz,
-	{1440,     240,       0,        10,    10,         0,        10,   1716,    263,     38,     12,    226,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  5400,   0,   0, 800  }, // TVIN_SIG_FMT_HDMI_1440x480I_120Hz,
-	{ 720,     576,       0,        10,    10,         0,        10,    864,    625,     13,     64,     67,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 480  }, // TVIN_SIG_FMT_HDMI_720x576P_200Hz,
-	{1440,     288,       0,        10,    10,         0,        10,   1728,    313,     24,     12,    252,       2,       3,   20,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED, 10800,   0,   0, 480  }, // TVIN_SIG_FMT_HDMI_1440x576I_200Hz,
-	{ 720,     480,       0,        10,    10,         0,        10,    858,    525,     16,     62,     60,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 10800,   0,   0, 400  }, // TVIN_SIG_FMT_HDMI_720x480P_240Hz,
-	{1440,     240,       0,        10,    10,         0,        10,   1716,    263,     38,     12,    226,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED, 10800,   0,   0, 400  }, // TVIN_SIG_FMT_HDMI_1440x480I_240Hz,
-	{1280,     720,       0,        10,    10,         0,        10,   3300,    750,   1760,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5940,   0,   0, 4000 }, // TVIN_SIG_FMT_HDMI_1280x720P_24Hz,
-	{1280,     720,       0,        10,    10,         0,        10,   3960,    750,   2420,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 3840 }, // TVIN_SIG_FMT_HDMI_1280x720P_25Hz,
-	{1280,     720,       0,        10,    10,         0,        10,   3300,    750,   1760,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  7425,   0,   0, 3200 }, // TVIN_SIG_FMT_HDMI_1280x720P_30Hz,
-	{1920,    1080,       0,        10,    10,         0,        10,   2200,   1125,     88,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 29700,   0,   0, 800  }, // TVIN_SIG_FMT_HDMI_1920x1080P_120Hz,//190
-	{1920,    1080,       0,        10,    10,         0,        10,   2640,   1125,    528,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 29700,   0,   0, 960  }, // TVIN_SIG_FMT_HDMI_1920x1080P_100Hz,
-	{1280,    1470,       0,        10,    10,         0,        10,   1650,   1500,    110,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1280x720P_60Hz_FRAME_PACKING,
-	{1280,    1470,       0,        10,    10,         0,        10,   1980,   1500,    440,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1280x720P_50Hz_FRAME_PACKING,
-	{1280,    1470,       0,        10,    10,         0,        10,   3300,   1500,   1760,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 11880,   0,   0, 4000 }, // TVIN_SIG_FMT_HDMI_1280x720P_24Hz_FRAME_PACKING,
-	{1280,    1470,       0,        10,    10,         0,        10,   3300,   1500,   1760,     40,    220,       5,       5,   20,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 3200 }, // TVIN_SIG_FMT_HDMI_1280x720P_30Hz_FRAME_PACKING,
-	{1920,    2228,       0,        10,    10,         0,        10,   2200,   2250,     88,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED, 14850,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_1920x1080I_60Hz_FRAME_PACKING,
-	{1920,    2228,       0,        10,    10,         0,        10,   2640,   2250,    528,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE,  TVIN_SCAN_MODE_INTERLACED, 14850,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_1920x1080I_50Hz_FRAME_PACKING,
-	{1920,    2205,       0,        10,    10,         0,        10,   2750,   2250,    638,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 4000 }, // TVIN_SIG_FMT_HDMI_1920x1080P_24Hz_FRAME_PACKING,
-	{1920,    2205,       0,        10,    10,         0,        10,   2200,   2250,     88,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 14850,   0,   0, 3200 }, // TVIN_SIG_FMT_HDMI_1920x1080P_30Hz_FRAME_PACKING,
-	//	 H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity			 Vs_Polarity			 Scan_Mode					 Pixel_Clk(Khz/10) VBIs VBIe
-	{ 800,     600,       0,        10,    10,         0,        10,   1056,    627,     40,    128,     88,       1,       3,   23,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  4000,   0,   0, 1600 }, // 800x600_60HZ, //200
-	//{	0,		 0, 	  0,		 0, 	0,		   0,		  0,	  0,	  0,	  0,	  0,	  0,	   0,		0,	  0,		TVIN_SYNC_POL_NULL, 	TVIN_SYNC_POL_NULL, 	   TVIN_SCAN_MODE_NULL, 	0,	 0,   0,   0  }, // TVIN_SIG_FMT_HDMI_MAX,
-	{1024,	   768, 	  0,		10,    10,		   0,		 10,   1344,	806,	 24,	136,	160,	   3,		6,	 29,	TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  6500,	 0,   0, 1600 }, // 1024x768_60HZ,
-	{720,     400,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0,   1600}, // TVIN_SIG_FMT_HDMI_720_400,
-	{1280,     768,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0,  1600}, // TVIN_SIG_FMT_HDMI_1280_768,
-	{1280,     800,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0,  1600}, // TVIN_SIG_FMT_HDMI_1280_800,
-	{1280,     960,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0,  1600}, // TVIN_SIG_FMT_HDMI_1280_960,
-	{1280,     1024,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_1280_1024,
-	{1360,     768,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0,  1600}, // TVIN_SIG_FMT_HDMI_1360_768,
-	{1366,     768,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0,  1600}, // TVIN_SIG_FMT_HDMI_1366_768,
-	{1600,     1200,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_1600_1200,
-	{1920,     1200,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_1920_1200, //210
-	{1440,     900,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_1440_900,
-	{1400,     1050,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_1400_1050,
-	{1680,     1050,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_1680X1050_60HZ
-    {1920,     1103,       0,        0,    0,         0,        0,   2200,   2250,     88,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_INTERLACED,  14850,   0,   0, 4000}, // TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_ALTERNATIVE,
-    {1920,     1103,       0,        0,    0,         0,        0,   2640,   2250,    528,     44,    148,       2,       5,   16,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_INTERLACED,  14850,   0,   0, 4000}, // TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_ALTERNATIVE,
-    {1920,     2160,       0,        0,    0,         0,        0,   2750,   2250,    638,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  14850,   0,   0, 3840}, // TVIN_SIG_FMT_HDMI_1920X1080P_24HZ_ALTERNATIVE,
-    {1920,     2160,       0,        0,    0,         0,        0,   2200,   2250,     88,     44,    148,       4,       5,   36,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  14850,   0,   0, 3840}, // TVIN_SIG_FMT_HDMI_1920X1080P_30HZ_ALTERNATIVE,
-    {3840,     2160,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  29700,   0,   0, 3200}, // TVIN_SIG_FMT_HDMI_3840_2160_00HZ,
-    {4096,     2160,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,  29700,   0,   0, 4000}, // TVIN_SIG_FMT_HDMI_4096_2160_00HZ,
-	{0,     0,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_RESERVE7, //220
-	{0,     0,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_RESERVE8,
-	{0,     0,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_RESERVE9,
-	{0,     0,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_RESERVE10,
-	{0,     0,       0,        0,    0,         0,        0,   0,    0,     0,    0,    0,       0,       0,   0,    TVIN_SYNC_POL_NULL, TVIN_SYNC_POL_NULL, TVIN_SCAN_MODE_PROGRESSIVE,  0,   0,   0, 1600}, // TVIN_SIG_FMT_HDMI_RESERVE11,
-	{ 720,     1005,       0,        10,    10,         0,        10,    858,    1050,     16,     62,     60,       9,       6,   30,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 1600 }, // TVIN_SIG_FMT_HDMI_720x480P_60Hz_FRAME_PACKING,
-	{ 720,     1201,       0,        10,    10,         0,        10,    864,    1250,     12,     64,     68,       5,       5,   39,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE,  5400,   0,   0, 1920 }, // TVIN_SIG_FMT_HDMI_720x576P_50Hz_FRAME_PACKING,
-	{0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,      0,       0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0,   1600  }, // TVIN_SIG_FMT_HDMI_MAX,//227
-};
-
-const struct tvin_format_s tvin_cvbs_fmt_tbl[TVIN_SIG_FMT_CVBS_MAX - TVIN_SIG_FMT_CVBS_NTSC_M + 1] =
-{
-	//   H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity             Vs_Polarity             Scan_Mode                   Pixel_Clk(Khz/10) VBIs VBIe
-	{ 720,     240,       0,         0,     0,         0,         0,    858,    263,     16,     62,     0,        4,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1600 }, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{ 720,     240,       0,         0,     0,         0,         0,    858,    263,     16,     62,     0,        4,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1600 }, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{ 720,     288,       0,         0,     0,         0,         0,    864,    313,     20,     62,     0,        3,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1920 }, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{ 720,     240,       0,         0,     0,         0,         0,    858,    263,     20,     62,     0,        4,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1600 }, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{ 720,     240,       0,         0,     0,         0,         0,    858,    263,     16,     62,     0,        4,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1600 }, // TVIN_SIG_FMT_CVBS_PAL_60,
-	{ 720,     288,       0,         0,     0,         0,         0,    864,    313,     12,     62,     0,        3,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1920 }, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{ 720,     288,       0,         0,     0,         0,         0,    864,    313,     12,     62,     0,        3,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE,  TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1920 }, // TVIN_SIG_FMT_CVBS_SECAM,
-	{   0,       0,       0,         0,     0,         0,         0,      0,      0,      0,      0,     0,        0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0,  1600}, // TVIN_SIG_FMT_CVBS_MAX,
-};
-const struct tvin_format_s tvin_bt601_fmt_tbl[TVIN_SIG_FMT_BT601_MAX - TVIN_SIG_FMT_BT656IN_576I_50HZ + 1] =
-{
-	//   H_Active V_Active H_cnt Hcnt_offset Vcnt_offset Hs_cnt Hscnt_offset H_Total V_Total Hs_Front Hs_Width Hs_bp Vs_Front Vs_Width Vs_bp Hs_Polarity             Vs_Polarity             Scan_Mode                   Pixel_Clk(Khz/10) VBIs VBIe
-	{ 720,     288,    6400,        20,    10,         0,         10,    864,    625,     12,     64,     0,        5,       5,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1920 }, // TVIN_SIG_FMT_BT656IN_576I,
-	{ 720,     240,    6356,        20,    10,         0,         10,    858,    525,     16,     62,     0,        9,       6,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1600 }, // TVIN_SIG_FMT_BT656IN_480I, // 160
-	{ 720,     288,    6400,        20,    10,         0,         10,    864,    625,     12,     64,     0,        5,       5,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1920 }, // TVIN_SIG_FMT_BT601IN_576I,
-	{ 720,     240,    6356,        20,    10,         0,         10,    858,    525,     16,     62,     0,        9,       6,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_INTERLACED,  1350,   0,   0, 1600 }, // TVIN_SIG_FMT_BT601IN_480I,
-	{ 640,     480,    6356,        20,    10,       473,         10,    780,    525,     18,     58,     64,       4,       3,   16,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 1227,   0,   0, 3200 }, // TVIN_SIG_FMT_CAMERA_640X480P_30HZ,
-	{ 800,     600,       0,        20,    10,         0,         10,   1056,    628,     40,    128,     0,        1,       4,    0,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE, 4000,   0,   0, 3200 }, // TVIN_SIG_FMT_CAMERA_800X600P_30HZ,
-	{1024,     768,       0,        10,    10,         0,         10,   1344,    795,     64,    128,     0,        3,       3,    0,    TVIN_SYNC_POL_NEGATIVE, TVIN_SYNC_POL_NEGATIVE, TVIN_SCAN_MODE_PROGRESSIVE, 6411,   0,   0, 3200 }, // TVIN_SIG_FMT_CAMERA_1024X768P_30HZ,
-	{1920,    1080,       0,        10,    10,         0,         10,   2576,   1118,    120,    208,     0,        1,       3,    0,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,17280,   0,   0, 3200 }, // TVIN_SIG_FMT_CAMERA_1920X1080P_30HZ,
-	{1280,    720,        0,        10,    10,         0,         10,   1650,    750,    120,    208,     0,        1,       3,    0,    TVIN_SYNC_POL_POSITIVE, TVIN_SYNC_POL_POSITIVE, TVIN_SCAN_MODE_PROGRESSIVE,17280,   0,   0, 3200 }, // TVIN_SIG_FMT_CAMERA_1280X720P_30HZ,
-	//format max
-	{   0,       0,       0,         0,     0,         0,          0,      0,      0,      0,      0,     0,        0,       0,    0,        TVIN_SYNC_POL_NULL,     TVIN_SYNC_POL_NULL,        TVIN_SCAN_MODE_NULL,     0,   0,   0,     1600},  //TVIN_SIG_FMT_MAX,        // 160
-};
-
-
-#define r_0a 0x00
-#define r_0e 0x00
-#define r_12 0x00
-#define r_16 0x00
-#define r_1c 0x00
-#define r_1d 0x00
-#define r_22 0x00
-#define r_23 0x00
-#define r_25 0x00
-#define r_29 0x00
-#define r_2c 0x00
-#define r_2d 0x00
-#define r_36 0x00
-#define r_37 0x00
-#define r_40 0x00
-#define r_42 0x00
-#define r_44 0x00
-#define r_45 0x00
-#define r_48 0x00
-#define r_49 0x00
-#define r_4a 0x00
-#define r_4b 0x00
-#define r_4c 0x00
-#define r_4d 0x00
-#define r_4e 0x00
-#define r_4f 0x00
-#define r_50 0x00
-#define r_51 0x00
-#define r_52 0x00
-#define r_53 0x00
-#define r_54 0x00
-#define r_55 0x00
-#define r_57 0x00
-#define r_67 0x00
-#define r_6a 0x00
-#define r_6b 0x00
-#define r_6c 0x00
-#define r_6d 0x00
-#define r_6e 0x00
-#define r_6f 0x00
-
-const unsigned char adc_vga_table[TVIN_SIG_FMT_VGA_MAX - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147][ADC_REG_NUM] =
-{
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_512X384P_60D147,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_560X384P_60D147,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X200P_59D924,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X350P_85D080,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X400P_59D940,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22,0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X400P_85D080,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X400P_59D638,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X400P_56D416,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X480P_66D619,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X480P_66D667,   // 10
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X480P_59D940,
-	{
-		0x32, 0x31, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x99, 0x99, 0x99, 0x80, 0x11, 0x10, 0x10, 0x10, 0x40,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x23, 0x23, 0x33, 0x30, 0x10, 0x10, 0x10, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x10, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0xBF, 0x28, 0x02,
-		0xF4, 0x00, 0x28, 0x39, 0x00, 0x00, 0x10, 0x00, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_VGA_640X480P_60D000,
-	{
-		0x32, 0x33, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x98, 0x90, 0x99, 0x80, 0x11, 0x12, 0x10, 0x10, 0x40,
-		0x4F, 0x45, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x10, 0x10, 0x10, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x10, 0x00, 0x00, 0x08, 0x20, 0x22, 0x8f, 0x6F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x21, 0x00, 0x00, 0x10, 0x00, 0x30, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_640X480P_72D809,
-	{
-		0x32, 0x34, 0x70, 0x08, 0x14, 0x12, 0x00, 0x98, 0x90, 0x99, 0x80, 0x11, 0x12, 0x10, 0x10, 0x40,
-		0x4F, 0x45, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x10, 0x10, 0x10, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x10, 0x00, 0x00, 0x08, 0x20, 0x22, 0x8f, 0x6F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x21, 0x00, 0x00, 0x10, 0x00, 0x30, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_640X480P_75D000_A,
-	{
-		0x32, 0x34, 0x70, 0x08, 0x14, 0x12, 0x00, 0x98, 0x90, 0x99, 0x80, 0x11, 0x12, 0x10, 0x10, 0x40,
-		0x4F, 0x45, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x10, 0x10, 0x10, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x10, 0x00, 0x00, 0x08, 0x20, 0x22, 0x8f, 0x6F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x30, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_640X480P_85D008,
-	{
-		0x32, 0x31, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x98, 0x90, 0x99, 0x80, 0x11, 0x12, 0x10, 0x10, 0x40,
-		0x4F, 0x45, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x10, 0x10, 0x10, 0x30, 0x00, 0x29, 0x88,         //why is no lpf open
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x10, 0x00, 0x00, 0x08, 0x20, 0x22, 0x8f, 0x6F, 0x28, 0x00,  //for dpll lock make 0x59 = 0x06->0x08
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_640X480P_59D638,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X480P_75D000_B,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_640X870P_75D000,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_720X350P_70D086,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_720X400P_85D039,  // 20
-	{
-		0x32, 0x38, 0x40, 0x08, 0x14, 0x12, 0x00, 0x98, 0x90, 0x99, 0x80, 0x11, 0x12, 0x10, 0x10, 0x40,
-		0x4F, 0x45, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x10, 0x10, 0x10, 0x30, 0x00, 0x29, 0x88,         //why is no lpf open
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x10, 0x00, 0x00, 0x08, 0x20, 0x22, 0x8f, 0x6F, 0x28, 0x00,  //for dpll lock make 0x59 = 0x06->0x08
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_720X400P_70D086,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x20, 0x20, 0x20, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_720X400P_87D849,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_720X400P_59D940,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_720X480P_59D940,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x10, 0x10, 0x10, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_768X480P_59D896,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x20, 0x20, 0x20, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_800X600P_56D250,
-	{
-		0x32, 0x3f, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x99, 0x99, 0x99, 0x80, 0x10, 0x10, 0x10, 0x10, 0x40,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x23, 0x23, 0x33, 0x30, 0x20, 0x20, 0x20, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x03, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x27, 0x00, 0x13, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x03,
-		0xF4, 0x00, 0x28, 0x29, 0x00, 0x00, 0x10, 0x00, 0x25, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_VGA_800X600P_60D000,
-	{
-		0x32, 0x41, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x99, 0x99, 0x99, 0x80, 0x10, 0x10, 0x10, 0x10, 0x40,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x23, 0x23, 0x33, 0x30, 0x20, 0x20, 0x20, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x03, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x27, 0x00, 0x13, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x03,
-		0xF4, 0x00, 0x28, 0x29, 0x00, 0x00, 0x10, 0x00, 0x25, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_VGA_800X600P_60D000_A,
-	{
-		0x32, 0x41, 0xe0, 0x08, 0x14, 0x12, 0x00, 0x99, 0x99, 0x99, 0x80, 0x10, 0x10, 0x10, 0x10, 0x40,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x23, 0x23, 0x33, 0x30, 0x20, 0x20, 0x20, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x03, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x27, 0x00, 0x13, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x03,
-		0xF4, 0x00, 0x28, 0x29, 0x00, 0x00, 0x10, 0x00, 0x21, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_VGA_800X600P_60D317,
-	{
-		0x32, 0x40, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x9F, 0xB0, 0xAF, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x47,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x03, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x27, 0x00, 0x13, 0x00, 0x00, 0x0a, 0x26, 0x22, 0x8f, 0x6F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x21, 0x00, 0x00, 0x10, 0x00, 0x21, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_800X600P_72D188, //30
-	{
-		0x32, 0x41, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x9F, 0xB0, 0xAF, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x47,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x03, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x27, 0x00, 0x13, 0x00, 0x00, 0x0a, 0x24, 0x22, 0x8f, 0x6F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x21, 0x00, 0x00, 0x10, 0x00, 0x21, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_800X600P_75D000,
-	{
-		0x32, 0x41, 0x70, 0x08, 0x14, 0x12, 0x00, 0x9F, 0xB0, 0xAF, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x47,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x03, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x27, 0x00, 0x13, 0x00, 0x00, 0x07, 0x24, 0x22, 0x8f, 0x6F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x21, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_800X600P_85D061,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x30, 0x30, 0x30, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_832X624P_75D087,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x30, 0x30, 0x30, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_848X480P_84D751,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x30, 0x30, 0x30, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_960X600P_59D635,
-	{
-		0x32, 0x53, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x05, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_59D278,
-	{
-		0x32, 0x53, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x05, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x03,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_60D000,
-	{
-		0x32, 0x52, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x05, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x03,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_60D000_A,
-	{
-		0x32, 0x52, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x05, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x12, 0x00, 0x00, 0x10, 0x00, 0x26, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_60D000_B,
-	{
-		0x32, 0x52, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_74D927,  //40
-	{
-		0x32, 0x53, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_60D004,
-	{
-		0x32, 0x52, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_70D069,
-	{
-		0x32, 0x51, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_75D029,
-	{
-		0x32, 0x55, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x20, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_84D997,
-	{
-		0x32, 0x53, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_74D925,
-	{
-		0x32, 0x52, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_75D020,
-	{
-		0x32, 0x55, 0x70, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_70D008,
-	{
-		0x32, 0x57, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_75D782,
-	{
-		0x32, 0x54, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_77D069,
-	{
-		0x32, 0x50, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_71D799, //50
-	{
-		0x32, 0x57, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X1024P_60D000,
-	{
-		0x32, 0x5e, 0xf0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1152X864P_60D000,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X864P_70D012,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X864P_75D000,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X864P_84D999,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X870P_75D062,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X900P_65D950,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X900P_66D004,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X900P_76D047,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1152X900P_76D149, //60
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X720P_59D855,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X720P_60D000_A,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X720P_60D000_B,
-	{
-		0x32, 0x67, 0x10, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x07, 0x25, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X720P_60D000_C,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X720P_60D000_D,
-	{
-		0x32, 0x67, 0xe0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x05, 0x0a, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X768P_59D870,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X768P_59D995,
-	{
-		0x32, 0x68, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X768P_60D100,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X768P_60D100_A,
-	{
-		0x32, 0x69, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X768P_74D893, //70
-	{
-		0x32, 0x6a, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x23, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X768P_84D837,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X800P_59D810,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X800P_59D810_A,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x25, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X800P_60D000,
-	{
-		0x32, 0x6a, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x03, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x0a, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x25, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X800P_85D000,
-	{
-		0x32, 0x67, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x25, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X960P_60D000,
-	{
-		0x32, 0x6A, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x25, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X960P_60D000_A,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X960P_75D000,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X960P_85D002,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_60D020,  //80
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x09, 0x25, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_60D020_A,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_75D025,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x23, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_85D024,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_59D979,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_72D005,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_60D002,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_67D003,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_74D112,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_76D179,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_66D718, //90
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_66D677,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x70, 0x70, 0x70, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1280X1024P_76D107,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,   //why the lpfbwctr 1280x1024 < 1024x768
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, //TVIN_SIG_FMT_VGA_1280X1024P_59D996,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,   //why the lpfbwctr 1280x1024 < 1024x768
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, //TVIN_SIG_FMT_VGA_1280X1024P_60D000,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,   //why the lpfbwctr 1280x1024 < 1024x768
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1360X768P_59D799,
-	{
-		0x32, 0x6f, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1360X768P_60D015,
-	{
-		0x32, 0x6f, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x12, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1360X768P_60D015_A,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,   //why the lpfbwctr 1280x1024 < 1024x768
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1360X850P_60D000,
-	{
-		0x32, 0x69, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,   //why the lpfbwctr 1280x1024 < 1024x768
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1360X1024P_60D000,
-	{
-		0x32, 0x6f, 0xd0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1366X768P_59D790,  //100
-	{
-		0x32, 0x5d, 0xb0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x22, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1366X768P_60D000,
-	{
-		0x32, 0x75, 0x50, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1400X1050P_59D978,
-	{
-		0x32, 0x76, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1440X900P_59D887,
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x40, 0x40, 0x40, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1440X1080P_60D000,
-	{
-		0x32, 0x86, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x0A, 0x24, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x23, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1600X900P_60D000,
-	{
-		0x32, 0x86, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x0A, 0x24, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x23, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1600X1024P_60D000,
-	{
-		0x32, 0x86, 0x50, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x0A, 0x24, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x23, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1600X1200P_59D869,
-	{
-		0x32, 0x86, 0xf0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x0A, 0x24, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x23, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1600X1200P_60D000,
-	{
-		0x32, 0x86, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01 ,0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x0A, 0x26, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x23, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1600X1200P_65D000,
-	{
-		0x32, 0x86, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x0A, 0x26, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x23, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1600X1200P_70D000,
-	{
-		0x32, 0x8b, 0xd0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x23, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1680X1050P_59D954, //110
-	{
-		0x00, 0x41, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x40, 0x40, r_12, 0x23, 0x23, 0x63, r_16, 0x00, 0x00, 0x70, 0x70, 0x70, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x46, 0x28,
-		0x20, 0x20, 0x0c, 0x0f, 0x25, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5c, 0x54, 0x81, 0x08, 0x08,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x22, 0x22, 0x5f, 0x6f, 0x04, 0x04,
-		0xf4, 0x00, 0x05, 0x29, 0x00, 0x00, 0x10, r_67, 0x2d, 0x39, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f,
-	}, // TVIN_SIG_FMT_VGA_1680X1080P_60D000,
-	{
-		0x32, 0x9e, 0xe0, 0x08, 0x14, 0x12, 0x00, 0x95, 0xA9, 0xA9, 0x80, 0x12, 0x11, 0x14, 0x10, 0x4F,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,     //1b why = 70 ?what is the diff
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x97, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0xAF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x23, 0xE1, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1920X1080P_49D929
-	{
-		0x32, 0xA0, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x95, 0xA9, 0xA9, 0x80, 0x12, 0x11, 0x14, 0x10, 0x4F,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,     //1b why = 70 ?what is the diff
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x97, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0xAF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x23, 0xE1, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1920X1080P_59D963_A,
-	{
-		0x32, 0xA0, 0xd0, 0x08, 0x14, 0x12, 0x00, 0x95, 0xA9, 0xA9, 0x80, 0x12, 0x11, 0x14, 0x10, 0x4F,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,     //1b why = 70 ?what is the diff
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x97, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0xAF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x23, 0xE1, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1920X1080P_59D963,
-	{
-		0x32, 0x89, 0x70, 0x08, 0x14, 0x12, 0x00, 0x99, 0x99, 0x99, 0x00, 0x10, 0x10, 0x10, 0x00, 0x40, //VGA_1920_1080P_IN
-		0x40, 0x40, 0x00, 0x23, 0x23, 0x63, 0x00, 0x33, 0x30, 0x70, 0x70, 0x70, 0x00, 0x00, 0x29, 0x88,
-		0x00, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x56, 0x28,
-		0x02, 0x20, 0x03, 0x03, 0xB7, 0x02, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x59, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x20, 0x00, 0x00,
-		0x13, 0x10, 0x02, 0x01, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x08, 0x27, 0x22, 0x8f, 0x0F, 0x04, 0x3f,
-		0xF4, 0x00, 0x05, 0x09, 0x00, 0x00, 0x10, 0x00, 0x23, 0x59, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_VGA_1920X1080P_60D000,
-	{
-		0x32, 0x81, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x95, 0xA9, 0xA9, 0x80, 0x12, 0x11, 0x14, 0x10, 0x4F,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,     //1b why = 70 ?what is the diff
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x97, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x0A, 0x26, 0x22, 0x8f, 0xAF, 0x28, 0x08,
-		0xFF, 0x00, 0x28, 0x02, 0x00, 0x00, 0x10, 0x00, 0x23, 0xE1, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1920X1200P_59D950,  // 113
-	{
-		0x32, 0x54, 0x50, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x00,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_60D000_C,
-	{
-		0x32, 0x52, 0xF0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB3, 0xB1, 0x80, 0x11, 0x0E, 0x12, 0x10, 0x48,
-		0x49, 0x4B, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x92, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x08,    ///what 54 mean
-		0xFF, 0x00, 0x28, 0x12, 0x00, 0x00, 0x10, 0x00, 0x26, 0x29, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1024X768P_60D000_D,
-	{
-		0x32, 0xA1, 0xF0, 0x08, 0x14, 0x12, 0x00, 0x95, 0xA9, 0xA9, 0x80, 0x12, 0x11, 0x14, 0x10, 0x4F,
-		0x40, 0x40, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,     //1b why = 70 ?what is the diff
-		0x10, 0x05, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0x97, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x0A, 0x26, 0x22, 0x8f, 0xAF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x02, 0x00, 0x00, 0x10, 0x00, 0x23, 0xE1, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1920X1200P_59D988, 
-		{
-		0x32, 0x63, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x99, 0xAC, 0xAD, 0x80, 0x12, 0x0F, 0x13, 0x10, 0x46,
-		0x47, 0x48, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x40, 0x40, 0x40, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x07, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x18, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x22, 0x8f, 0x8F, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, //TVIN_SIG_FMT_VGA_1400X900P_60D00,	
-		{
-		0x32, 0x72, 0xf0, 0x08, 0x14, 0x12, 0x00, 0xA0, 0xB2, 0xB1, 0x80, 0x13, 0x12, 0x14, 0x10, 0x42,
-		0x46, 0x47, 0x40, 0x23, 0x23, 0x63, 0x23, 0x33, 0x30, 0x70, 0x70, 0x70, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x01, 0xC0, 0x00, 0x03, 0x00, 0x78, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x76, 0x28,
-		0x20, 0x20, 0x08, 0x15, 0xB7, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5F, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x32, 0x00, 0x0D, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0xBF, 0x28, 0x3f,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x23, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_VGA_1680X1050P_60D000, 
-};
-
-const unsigned char adc_component_table[TVIN_SIG_FMT_COMP_MAX - TVIN_SIG_FMT_COMP_480P_60HZ_D000][ADC_REG_NUM] =
-{
-#ifdef CONFIG_ADC_DOUBLE_SAMPLING_FOR_SD
-	{
-		0x32, 0x6b, 0x30, 0x08, 0x14, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x83, 0x83, 0x83, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x30, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x13, 0x00, 0x00, 0x04, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x25, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	},// TVIN_SIG_FMT_COMPONENT_480P_60D000,zhuangwei	
-	{
-		0x32, 0x6b, 0x30, 0x40, 0x25, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x81, 0x81, 0x81, 0x30, 0x00, 0x29, 0x88,    ///why the lpfbwctr 480i == 480p = 28?
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x4B, 0x78, 0x00, 0x0D, 0x02, 0x01, 0xFF, 0x00, 0x7F, 0x28,
-		0x17, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x84, 0xE3, 0x14, 0x14,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x18, 0x00, 0x00, 0x04, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x21, 0x00, 0x00, 0x10, 0x00, 0x24, 0x99, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_480I_59D940,wangfeng	
-	{
-		0x32, 0x6b, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x83, 0x83, 0x83, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x30, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00,  0xa, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x25, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_576P_50D000,wan gfeng
-	{
-		0x32, 0x6b, 0xf0, 0x40, 0x25, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x81, 0x81, 0x81, 0x30, 0x00, 0x29, 0x88,    ///why the lpfbwctr 480i == 480p = 28?
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x4B, 0x78, 0x01, 0x0D, 0x02, 0x01, 0xFF, 0x00, 0x7F, 0x28,
-		0x30, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x84, 0xe3, 0x14, 0x14,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x18, 0x00, 0x00, 0x04, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x24, 0xa9, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_576I_50D000,wangfeng
-#else
-	{
-		0x32, 0x35, 0x90, 0x08, 0x14, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x83, 0x83, 0x83, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x30, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x13, 0x00, 0x00, 0x0a, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x25, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	},// TVIN_SIG_FMT_COMPONENT_480P_60D000,zhuangwei
-	{
-		0x32, 0x35, 0x90, 0x20, 0x14, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x81, 0x81, 0x81, 0x30, 0x00, 0x29, 0x88,    ///why the lpfbwctr 480i == 480p = 28?
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x30, 0x78, 0x00, 0x0D, 0x00, 0x01, 0xFF, 0x00, 0x7F, 0x28,
-		0x17, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x84, 0xE3, 0x14, 0x14,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00, 0x0f, 0x00, 0x00, 0x06, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x24, 0x99, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_480I_59D940,wangfeng
-	{
-		0x32, 0x35, 0xf0, 0x08, 0x14, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x83, 0x83, 0x83, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x30, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x01, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00,  0xa, 0x00, 0x00, 0x08, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x25, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_576P_50D000,wan gfeng
-	{
-		0x32, 0x35, 0xf0, 0x20, 0x14, 0x12, 0x00, 0x98, 0x91, 0x9A, 0x80, 0x11, 0x11, 0x10, 0x10, 0x40,
-		0x87, 0x88, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x81, 0x81, 0x81, 0x30, 0x00, 0x29, 0x88,    ///why the lpfbwctr 480i == 480p = 28?
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x0f, 0x0D, 0x00, 0x01, 0xFF, 0x00, 0x7F, 0x28,
-		0x30, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x84, 0xe3, 0x14, 0x14,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x10, 0x00,  0xa, 0x00, 0x00, 0x06, 0x24, 0x22, 0x8f, 0x8F, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x31, 0x00, 0x00, 0x10, 0x00, 0x24, 0xa9, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_576I_50D000,wangfeng
-#endif
-	{
-		0x32, 0x67, 0x10, 0x40, 0x14, 0x12, 0x00, 0x98, 0x92, 0x9A, 0x80, 0x12, 0x11, 0x10, 0x10, 0x42,
-		0x8D, 0x8E, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x0f, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x20, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x04, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x22, 0x00, 0x07, 0x00, 0x00, 0x05, 0x26, 0x02, 0x8f, 0xAF, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	},// TVIN_SIG_FMT_COMPONENT_720P_59D940,zhuangwei
-	{
-		0x32, 0x7b, 0xb0, 0x40, 0x14, 0x12, 0x00, 0x98, 0x92, 0x9A, 0x80, 0x12, 0x11, 0x10, 0x10, 0x42,
-		0x8D, 0x8E, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,    //why no open lpf
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x0f, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x20, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x22, 0x00, 0x08, 0x00, 0x00, 0x08, 0x26, 0x02, 0x8f, 0xAF, 0x28, 0x00,     //0x59 0x08->0x09 ;0x60 0x00->0x04
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_720P_50D000,wangfeng
-	{
-		0x00, 0x35, 0xf0, 0x14, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x80, 0x80, r_12, 0x23, 0x23, 0x23, r_16, 0x00, 0x00, 0xda, 0xda, 0xda, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x64, 0x28,
-		0x20, 0x32, 0x08, 0x0f, 0x6f, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5D, 0x54, 0x81, 0x04, 0x02,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x23, 0x22, 0x8f, 0x6f, 0x0e, 0x02,
-		0xf4, 0x00, 0x0e, 0x39, 0x00, 0x00, 0x10, r_67, 0x2c, 0x29, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f
-	}, // TVIN_SIG_FMT_COMPONENT_1080P_23D976,
-	{
-		0x32, 0xab, 0xd0, 0x40, 0x14, 0x12, 0x00, 0x98, 0x92, 0x9A, 0x80, 0x12, 0x11, 0x10, 0x10, 0x42,
-		0x8D, 0x8E, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,    //why no open lpf
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x02, 0x00, 0x04, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x20, 0x80, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5A, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x22, 0x00, 0x19, 0x00, 0x00, 0x08, 0x24, 0x02, 0x8f, 0xAF, 0x28, 0x00, 	//0x59 0x08->0x09 ;0x60 0x00->0x04
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_1080P_24D000,
-	{
-		0x32, 0xa4, 0xf0, 0x40, 0x14, 0x12, 0x00, 0x98, 0x92, 0x9A, 0x80, 0x12, 0x11, 0x10, 0x10, 0x42,
-		0x8D, 0x8E, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,    //why no open lpf
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x02, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x20, 0x80, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0xE3, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x22, 0x00, 0x1e, 0x00, 0x00, 0x08, 0x24, 0x02, 0x8f, 0xAF, 0x28, 0x00, 	//0x59 0x08->0x09 ;0x60 0x00->0x04
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_1080P_25D000,
-	{
-		0x32, 0x89, 0x70, 0x40, 0x14, 0x12, 0x00, 0x98, 0x92, 0x9A, 0x80, 0x12, 0x11, 0x10, 0x10, 0x42,
-		0x8D, 0x8E, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x40, 0x78, 0x0f, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x5F, 0x28,
-		0x20, 0x32, 0x03, 0x03, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x04, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x22, 0x00, 0x12, 0x00, 0x00, 0x05, 0x24, 0x02, 0x8f, 0xAF, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x26, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_1080P_30D000,
-	{
-		0x32, 0xa4, 0xf0, 0x40, 0x40, 0x12, 0x00, 0x93, 0x8D, 0x94, 0x80, 0x13, 0x12, 0x11, 0x10, 0x41,
-		0x87, 0x87, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x8f, 0x8f, 0x8f, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x79, 0x78, 0x02, 0x0d, 0x02, 0x01, 0xFF, 0x00, 0x5f, 0x28,
-		0x20, 0x32, 0x02, 0x02, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x31, 0x00, 0x1d, 0x00, 0x00, 0x08, 0x24, 0x02, 0x8f, 0xAF, 0x28, 0x00,    ////dpll
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x27, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	},// TVIN_SIG_FMT_COMPONENT_1080P_50D000,zhuangwei wangfeng
-	{
-		0x32, 0x89, 0x70, 0x40, 0x40, 0x12, 0x00, 0x93, 0x8D, 0x94, 0x80, 0x13, 0x12, 0x11, 0x10, 0x41,
-		0x87, 0x87, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x8f, 0x8f, 0x8f, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x79, 0x78, 0x00, 0x0d, 0x02, 0x01, 0xFF, 0x00, 0x5f, 0x28,
-		0x20, 0x32, 0x02, 0x02, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x31, 0x00, 0x0a, 0x00, 0x00, 0x0a, 0x27, 0x02, 0x8f, 0xAF, 0x28, 0x00,
-		0xFF, 0x00, 0x28, 0x01, 0x00, 0x00, 0x10, 0x00, 0x27, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	},// TVIN_SIG_FMT_COMPONENT_1080P_60D000,
-	{
-		0x00, 0x35, 0xf0, 0x14, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x80, 0x80, r_12, 0x23, 0x23, 0x23, r_16, 0x00, 0x00, 0xda, 0xda, 0xda, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x64, 0x28,
-		0x20, 0x32, 0x08, 0x0f, 0x6f, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5D, 0x54, 0x81, 0x04, 0x02,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x23, 0x22, 0x8f, 0x6f, 0x0e, 0x02,
-		0xf4, 0x00, 0x0e, 0x39, 0x00, 0x00, 0x10, r_67, 0x2c, 0x29, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f
-	}, // TVIN_SIG_FMT_COMPONENT_1080I_47D952,
-	{
-		0x00, 0x35, 0xf0, 0x14, 0x14, 0x12, 0x00, 0x00, 0x00, 0x00, r_0a, 0x10, 0x10, 0x10, r_0e, 0x40,
-		0x80, 0x80, r_12, 0x23, 0x23, 0x23, r_16, 0x00, 0x00, 0xda, 0xda, 0xda, r_1c, r_1d, 0x69, 0x88,
-		0x10, 0x03, r_22, r_23, 0x00, r_25, 0x78, 0x78, 0x00, r_29, 0x00, 0x00, r_2c, r_2d, 0x64, 0x28,
-		0x20, 0x32, 0x08, 0x0f, 0x6f, 0x02, r_36, r_37, 0x20, 0xc0, 0x03, 0x5D, 0x54, 0x81, 0x04, 0x02,
-		r_40, 0x07, r_42, 0xf0, r_44, r_45, 0x51, 0x5a, r_48, r_49, r_4a, r_4b, r_4c, r_4d, r_4e, r_4f,
-		r_50, r_51, r_52, r_53, r_54, r_55, 0x10, r_57, 0x00, 0x06, 0x23, 0x22, 0x8f, 0x6f, 0x0e, 0x02,
-		0xf4, 0x00, 0x0e, 0x39, 0x00, 0x00, 0x10, r_67, 0x2c, 0x29, r_6a, r_6b, r_6c, r_6d, r_6e, r_6f
-	}, // TVIN_SIG_FMT_COMPONENT_1080I_48D000,
-
-	{
-		0x32, 0xa4, 0xf0, 0x40, 0x40, 0x12, 0x00, 0x93, 0x8D, 0x94, 0x80, 0x13, 0x12, 0x11, 0x10, 0x41,
-		0x87, 0x87, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x60, 0x78, 0x0f, 0x00, 0x02, 0x01, 0xFF, 0x00, 0x5f, 0x28,
-		0x20, 0x3f, 0x02, 0x02, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x31, 0x00,  0x5, 0x00, 0x00, 0x05, 0x26, 0x02, 0x8f, 0xAF, 0x28, 0x00,    ////dpll
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_1080I_50D000_A,
-
-	{
-		0x32, 0xa4, 0xf0, 0x40, 0x40, 0x12, 0x00, 0x93, 0x8D, 0x94, 0x80, 0x13, 0x12, 0x11, 0x10, 0x41,
-		0x87, 0x87, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x60, 0x78, 0x02, 0x00, 0x02, 0x01, 0xFF, 0x00, 0x5f, 0x28,
-		0x20, 0x32, 0x02, 0x02, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x31, 0x00,  0x5, 0x00, 0x00, 0x08, 0x26, 0x02, 0x8f, 0xAF, 0x28, 0x00,    ////dpll
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_1080I_50D000_B,
-	{
-		0x32, 0xa4, 0xf0, 0x40, 0x40, 0x12, 0x00, 0x93, 0x8D, 0x94, 0x80, 0x13, 0x12, 0x11, 0x10, 0x41,
-		0x87, 0x87, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x60, 0x78, 0x02, 0x00, 0x02, 0x01, 0xFF, 0x00, 0x5f, 0x28,
-		0x20, 0x32, 0x02, 0x02, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x31, 0x00, 0x10, 0x00, 0x00, 0x08, 0x26, 0x02, 0x8f, 0xAF, 0x28, 0x00,    ////dpll
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	}, // TVIN_SIG_FMT_COMPONENT_1080I_50D000_C,
-
-	{
-		0x32, 0x89, 0x70, 0x40, 0x40, 0x12, 0x00, 0x93, 0x8D, 0x94, 0x80, 0x13, 0x12, 0x11, 0x10, 0x41,
-		0x87, 0x87, 0x40, 0x23, 0x23, 0x63, 0x23, 0x11, 0x10, 0x88, 0x88, 0x88, 0x30, 0x00, 0x29, 0x88,
-		0x10, 0x05, 0xC0, 0x00, 0x01, 0x00, 0x60, 0x78, 0x0d, 0x00, 0x02, 0x01, 0xFF, 0x00, 0x5f, 0x28,
-		0x20, 0x32, 0x02, 0x02, 0x6B, 0x07, 0x10, 0x00, 0x00, 0xC0, 0xE3, 0x5D, 0x54, 0x63, 0x08, 0x08,
-		0x70, 0x07, 0x75, 0xF0, 0xF0, 0xF0, 0x5D, 0x5A, 0x00, 0x00, 0x85, 0x09, 0x00, 0x29, 0x00, 0x00,
-		0x1D, 0x28, 0x02, 0x01, 0x31, 0x00, 0x10, 0x00, 0x00, 0x08, 0x26, 0x02, 0x8f, 0xAF, 0x28, 0x00,    ////dpll
-		0xFF, 0x00, 0x28, 0x11, 0x00, 0x00, 0x10, 0x00, 0x27, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
-	},// TVIN_SIG_FMT_COMPONENT_1080I_60D000,
-};
-
-const unsigned char adc_cvbs_table[ADC_REG_NUM] =
-{
-	/*0x40*/
-	0x00, 0x6b, 0xf0, 0x08, 0x14, 0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x00, 0x00,
-	0x00, 0x00, 0x40, 0x23, 0x03, 0x83, 0x22, 0x10, 0x00, 0x81, 0x30, 0x00, 0x00, 0x00, 0x69, 0x88,
-	0x30, 0x07, 0xc0, 0x00, 0x05, 0x00, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x40, 0x28,
-	0x20, 0x20, 0x08, 0x0f, 0x25, 0x02, 0x10, 0x00, 0x00, 0xc0, 0xe3, 0x5c, 0x54, 0x81, 0x01, 0x08,
-	0x70, 0x07, 0x75, 0xf8, 0xf0, 0xf0, 0x51, 0x5a, 0x00, 0x00, 0x85, 0x01, 0x00, 0x30, 0x00, 0x00,
-	0x18, 0x15, 0x03, 0x00, 0xe0, 0x00, 0x10, 0x00, 0x09, 0x07, 0x02, 0x22, 0x8e, 0x6f, 0x0f, 0x09,
-	0xf4, 0x00, 0x0f, 0x19, 0x00, 0x00, 0x10, 0x00, 0x0b, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-#define r180 (unsigned char)((CVD2_CHROMA_DTO_NTSC_M  >>24)&0x000000ff)
-#define r190 (unsigned char)((CVD2_CHROMA_DTO_NTSC_M  >>16)&0x000000ff)
-#define r1a0 (unsigned char)((CVD2_CHROMA_DTO_NTSC_M  >> 8)&0x000000ff)
-#define r1b0 (unsigned char)((CVD2_CHROMA_DTO_NTSC_M  >> 0)&0x000000ff)
-#define r1c0 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_M  >>24)&0x000000ff)
-#define r1d0 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_M  >>16)&0x000000ff)
-#define r1e0 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_M  >> 8)&0x000000ff)
-#define r1f0 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_M  >> 0)&0x000000ff)
-
-#define r181 (unsigned char)((CVD2_CHROMA_DTO_NTSC_443>>24)&0x000000ff)
-#define r191 (unsigned char)((CVD2_CHROMA_DTO_NTSC_443>>16)&0x000000ff)
-#define r1a1 (unsigned char)((CVD2_CHROMA_DTO_NTSC_443>> 8)&0x000000ff)
-#define r1b1 (unsigned char)((CVD2_CHROMA_DTO_NTSC_443>> 0)&0x000000ff)
-#define r1c1 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_443>>24)&0x000000ff)
-#define r1d1 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_443>>16)&0x000000ff)
-#define r1e1 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_443>> 8)&0x000000ff)
-#define r1f1 (unsigned char)(( CVD2_HSYNC_DTO_NTSC_443>> 0)&0x000000ff)
-
-#define r182 (unsigned char)((CVD2_CHROMA_DTO_PAL_I   >>24)&0x000000ff)
-#define r192 (unsigned char)((CVD2_CHROMA_DTO_PAL_I   >>16)&0x000000ff)
-#define r1a2 (unsigned char)((CVD2_CHROMA_DTO_PAL_I   >> 8)&0x000000ff)
-#define r1b2 (unsigned char)((CVD2_CHROMA_DTO_PAL_I   >> 0)&0x000000ff)
-#define r1c2 (unsigned char)(( CVD2_HSYNC_DTO_PAL_I   >>24)&0x000000ff)
-#define r1d2 (unsigned char)(( CVD2_HSYNC_DTO_PAL_I   >>16)&0x000000ff)
-#define r1e2 (unsigned char)(( CVD2_HSYNC_DTO_PAL_I   >> 8)&0x000000ff)
-#define r1f2 (unsigned char)(( CVD2_HSYNC_DTO_PAL_I   >> 0)&0x000000ff)
-
-#define r183 (unsigned char)((CVD2_CHROMA_DTO_PAL_M   >>24)&0x000000ff)
-#define r193 (unsigned char)((CVD2_CHROMA_DTO_PAL_M   >>16)&0x000000ff)
-#define r1a3 (unsigned char)((CVD2_CHROMA_DTO_PAL_M   >> 8)&0x000000ff)
-#define r1b3 (unsigned char)((CVD2_CHROMA_DTO_PAL_M   >> 0)&0x000000ff)
-#define r1c3 (unsigned char)(( CVD2_HSYNC_DTO_PAL_M   >>24)&0x000000ff)
-#define r1d3 (unsigned char)(( CVD2_HSYNC_DTO_PAL_M   >>16)&0x000000ff)
-#define r1e3 (unsigned char)(( CVD2_HSYNC_DTO_PAL_M   >> 8)&0x000000ff)
-#define r1f3 (unsigned char)(( CVD2_HSYNC_DTO_PAL_M   >> 0)&0x000000ff)
-
-#define r184 (unsigned char)((CVD2_CHROMA_DTO_PAL_60  >>24)&0x000000ff)
-#define r194 (unsigned char)((CVD2_CHROMA_DTO_PAL_60  >>16)&0x000000ff)
-#define r1a4 (unsigned char)((CVD2_CHROMA_DTO_PAL_60  >> 8)&0x000000ff)
-#define r1b4 (unsigned char)((CVD2_CHROMA_DTO_PAL_60  >> 0)&0x000000ff)
-#define r1c4 (unsigned char)(( CVD2_HSYNC_DTO_PAL_60  >>24)&0x000000ff)
-#define r1d4 (unsigned char)(( CVD2_HSYNC_DTO_PAL_60  >>16)&0x000000ff)
-#define r1e4 (unsigned char)(( CVD2_HSYNC_DTO_PAL_60  >> 8)&0x000000ff)
-#define r1f4 (unsigned char)(( CVD2_HSYNC_DTO_PAL_60  >> 0)&0x000000ff)
-
-#define r185 (unsigned char)((CVD2_CHROMA_DTO_PAL_CN  >>24)&0x000000ff)
-#define r195 (unsigned char)((CVD2_CHROMA_DTO_PAL_CN  >>16)&0x000000ff)
-#define r1a5 (unsigned char)((CVD2_CHROMA_DTO_PAL_CN  >> 8)&0x000000ff)
-#define r1b5 (unsigned char)((CVD2_CHROMA_DTO_PAL_CN  >> 0)&0x000000ff)
-#define r1c5 (unsigned char)(( CVD2_HSYNC_DTO_PAL_CN  >>24)&0x000000ff)
-#define r1d5 (unsigned char)(( CVD2_HSYNC_DTO_PAL_CN  >>16)&0x000000ff)
-#define r1e5 (unsigned char)(( CVD2_HSYNC_DTO_PAL_CN  >> 8)&0x000000ff)
-#define r1f5 (unsigned char)(( CVD2_HSYNC_DTO_PAL_CN  >> 0)&0x000000ff)
-
-#define r186 (unsigned char)((CVD2_CHROMA_DTO_SECAM   >>24)&0x000000ff)
-#define r196 (unsigned char)((CVD2_CHROMA_DTO_SECAM   >>16)&0x000000ff)
-#define r1a6 (unsigned char)((CVD2_CHROMA_DTO_SECAM   >> 8)&0x000000ff)
-#define r1b6 (unsigned char)((CVD2_CHROMA_DTO_SECAM   >> 0)&0x000000ff)
-#define r1c6 (unsigned char)(( CVD2_HSYNC_DTO_SECAM   >>24)&0x000000ff)
-#define r1d6 (unsigned char)(( CVD2_HSYNC_DTO_SECAM   >>16)&0x000000ff)
-#define r1e6 (unsigned char)(( CVD2_HSYNC_DTO_SECAM   >> 8)&0x000000ff)
-#define r1f6 (unsigned char)(( CVD2_HSYNC_DTO_SECAM   >> 0)&0x000000ff)
-
-// 00~3f
-const unsigned char cvd_part1_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][CVD_PART1_REG_NUM] =
-{
-	{
-		0x00, 0x08, 0x43, 0x10, 0xdd, 0x32, 0x80, 0x4e, 0x7b, 0x1c, 0x78, 0x00, 0x90, 0x00, 0x06, 0x00,
-		0x00, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r180, r190, r1a0, r1b0, r1c0, r1d0, r1e0, r1f0,
-		0x3e, 0x3e, 0x00, 0x80, 0xf3, 0x3e, 0x6d, 0x5a, 0x07, 0x29, 0xd6, 0x4e, 0x32, 0x46, 0x82, 0x50,
-		0x22, 0x61, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x00, 0x01, 0x43, 0x82, 0xdd, 0x32, 0x80, 0x40, 0x7e, 0x20, 0x80, 0x00, 0x8a, 0x00, 0x06, 0x00,
-		0x37, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r181, r191, r1a1, r1b1, r1c1, r1d1, r1e1, r1f1,
-		0x3e, 0x3e, 0x00, 0x80, 0xf3, 0x3e, 0x6d, 0x5a, 0x07, 0x29, 0xd6, 0x4e, 0x32, 0x46, 0x7a, 0x50,
-		0x22, 0x61, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x32, 0x04, 0x43, 0x12, 0xdd, 0x32, 0x80, 0x03, 0x7d, 0x20, 0x78, 0x00, 0x90, 0x00, 0x06, 0x00,
-		0x37, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r182, r192, r1a2, r1b2, r1c2, r1d2, r1e2, r1f2,
-		0x3e, 0x3e, 0x00, 0x80, 0xe7, 0x42, 0x6d, 0x5a, 0x1d, 0xb9, 0xd6, 0x4e, 0x32, 0x46, 0x8c, 0x50,
-		0x2a, 0xc0, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x8a, 0x2e, 0x00, 0x0d, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x04, 0x01, 0x43, 0x12, 0xdd, 0x32, 0x80, 0x00, 0x7d, 0x20, 0x80, 0x00, 0x8a, 0x00, 0x06, 0x00,
-		0x37, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r183, r193, r1a3, r1b3, r1c3, r1d3, r1e3, r1f3,
-		0x3e, 0x3e, 0x00, 0x80, 0xf3, 0x3e, 0x6d, 0x5a, 0x07, 0x29, 0xd6, 0x4e, 0x32, 0x46, 0x82, 0x50,
-		0x22, 0x61, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x04, 0x00, 0x43, 0x02, 0xdd, 0x32, 0x80, 0x00, 0x80, 0x20, 0x80, 0x00, 0x67, 0x01, 0x06, 0x00,
-		0x37, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r184, r194, r1a4, r1b4, r1c4, r1d4, r1e4, r1f4,
-		0x3e, 0x3e, 0x00, 0x80, 0xf3, 0x3e, 0x6d, 0x5a, 0x07, 0x29, 0xd6, 0x4e, 0x32, 0x46, 0x84, 0x50,
-		0x2a, 0x61, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,
-	{
-		0x36, 0x01, 0x43, 0x12, 0xdd, 0x32, 0x80, 0x00, 0x7d, 0x31, 0x80, 0x00, 0x8a, 0x00, 0x06, 0x00,
-		0x37, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r185, r195, r1a5, r1b5, r1c5, r1d5, r1e5, r1f5,
-		0x3e, 0x3e, 0x00, 0x80, 0xf3, 0x3e, 0x6d, 0x5a, 0x07, 0x29, 0xd6, 0x4e, 0x32, 0x46, 0x8a, 0x50,
-		0x2d, 0xc1, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{
-		0x38, 0x00, 0x43, 0x00, 0xdc, 0x32, 0x80, 0x00, 0x80, 0x20, 0x80, 0x00, 0xc8, 0x00, 0x06, 0x00,
-		0x37, 0x09, 0x10, 0xb4, 0x80, 0x20, 0xf6, 0x0d, r186, r196, r1a6, r1b6, r1c6, r1d6, r1e6, r1f6,
-		0x3e, 0x3e, 0x00, 0x80, 0xf3, 0x3e, 0x6d, 0x5a, 0x07, 0x29, 0xd6, 0x4e, 0x3c, 0x6e, 0x76, 0x58,
-		0x29, 0xbf, 0x70, 0x0e, 0x6c, 0x10, 0x00, 0x23, 0x01, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-#define r_81 0x00
-#define r_89 0x00
-#define r_8c 0x00
-#define r_97 0x00
-#define r_98 0x00
-#define r_99 0x00
-#define r_9a 0x00
-#define r_9b 0x00
-#define r_9c 0x00
-#define r_9d 0x00
-#define r_9e 0x00
-#define r_9f 0x00
-#define r_ad 0x00
-#define r_b9 0x00
-#define r_bf 0x00
-#define r_c1 (unsigned char)(CVD2_DCRESTORE_ACCUM)
-#define r_cf 0x00
-#define r_dd 0x00
-#define r_df 0x00
-#define r_ef 0x00
-#define r_f5 0x00
-#define r_f6 0x00
-#define r_f7 0x00
-#define r_f8 0x00
-#define r_ff 0x00
-// 70~ff
-const unsigned char cvd_part2_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][CVD_PART2_REG_NUM] =
-{
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x04, r_81, 0x42, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x01, 0x08, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0f, 0xc1, r_ad, 0xcf, 0x0f,
-		0x30, 0x2d, 0x04, 0x0b, 0x23, 0xa2, 0x02, 0x00, 0x00, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x14, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0xf0, 0x01, 0x50, 0x60, 0x90, 0xe3, 0x0c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x50, r_dd, 0x08, r_df,
-		0x00, 0x00, 0x00, 0x00, 0x6e, 0x50, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x40, 0x32, 0x46, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x00, 0x32, 0x50, 0x1c, 0x00, r_ff
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x04, r_81, 0x42, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0f, 0xc1, r_ad, 0xcf, 0x8c,
-		0xe0, 0x2f, 0x8,  0x03, 0x24, 0xa2, 0x02, 0x00, 0x00, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x17, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0x00, 0x01, 0x50, 0x62, 0x90, 0xe3, 0x0c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x50, r_dd, 0x08, r_df,
-		0x00, 0x00, 0x00, 0x00, 0x6e, 0x40, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x40, 0x32, 0x46, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x00, 0x32, 0x50, 0x1c, 0x00, r_ff
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x04, 0x7f, 0x42, 0x6f, 0x03, 0x00, 0x04, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x1f, 0x00, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0f, 0xc1, r_ad, 0xcf, 0x86,
-		0xfa, 0x2f, 0x0c, 0x03, 0x23, 0xa2, 0x02, 0x00, 0x08, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x14, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0xf0, 0x01, 0x50, 0x62, 0x90, 0xe3, 0x2c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x40, r_dd, 0x08, r_df,
-		0x00, 0x01, 0xc2, 0x88, 0x6e, 0x50, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x1f, 0x32, 0x46, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x80, 0x32, 0x50, 0x1c, 0x00, r_ff
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x04, r_81, 0x42, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0f, 0xc1, r_ad, 0xcf, 0x8c,
-		0x3a, 0xf3, 0x0c, 0x03, 0x23, 0xa2, 0x02, 0x00, 0x00, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x14, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0x00, 0x01, 0x50, 0x62, 0x90, 0xe3, 0x2c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x50, r_dd, 0x08, r_df,
-		0x00, 0x00, 0x00, 0x00, 0x6e, 0x50, 0x8c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x1f, 0x32, 0x46, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x00, 0x32, 0x50, 0x1c, 0x00, r_ff
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x04, r_81, 0x42, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0f, 0xc1, r_ad, 0xcf, 0x8c,
-		0xe0, 0x2f, 0x0c, 0x0b, 0x24, 0xa2, 0x02, 0x00, 0x00, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x14, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0x00, 0x01, 0x50, 0x62, 0x90, 0xe3, 0x0c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x50, r_dd, 0x08, r_df,
-		0x00, 0x00, 0x00, 0x00, 0x6e, 0x40, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x40, 0x32, 0x46, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x00, 0x32, 0x50, 0x05, 0x00, r_ff
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x04, r_81, 0x42, 0x6f, 0x03, 0x00, 0x03, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x16, 0x0f, 0xc1, r_ad, 0xcf, 0x8c,
-		0xe0, 0x2f, 0x0c, 0x03, 0x24, 0xa2, 0x02, 0x00, 0x00, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x14, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0x00, 0x01, 0x50, 0x62, 0x90, 0xe3, 0x2c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x50, r_dd, 0x08, r_df,
-		0x00, 0x00, 0x00, 0x00, 0x6e, 0x50, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x1f, 0x32, 0x46, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x00, 0x32, 0x50, 0x1c, 0xdc, r_ff
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x84, r_81, 0x42, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, r_89, 0x0a, 0x11, r_8c, 0x0a, 0x00, 0xe2,
-		0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, r_97, r_98, r_99, r_9a, r_9b, r_9c, r_9d, r_9e, r_9f,
-		0xf2, 0x0b, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x0f, 0x00, r_ad, 0xcf, 0x8c,
-		0xe0, 0x2f, 0x0c, 0x03, 0x24, 0x22, 0x02, 0x00, 0x00, r_b9, 0x24, 0x5f, 0x00, 0x25, 0x55, r_bf,
-		0x14, r_c1, 0x40, 0xc0, 0xfe, 0x90, 0x00, 0x00, 0x01, 0x50, 0x62, 0x90, 0xe3, 0x0c, 0x23, r_cf,
-		0xc0, 0x08, 0x10, 0x10, 0x0a, 0x00, 0x0d, 0x00, 0x00, 0x05, 0x00, 0x05, 0x50, r_dd, 0x1f, r_df,
-		0x00, 0x00, 0x00, 0x00, 0x6e, 0x40, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, r_ef,
-		0x20, 0x40, 0x3c, 0x6e, 0xe4, r_f5, r_f6, r_f7, r_f8, 0x01, 0x00, 0x50, 0x6e, 0x05, 0xdc, r_ff
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-// 0x87, 0x93, 0x94, 0x95, 0x96, 0xe6, 0xfa
-const unsigned int cvd_part3_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][CVD_PART3_REG_NUM] =
-{
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000000
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000000
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000080
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000080
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000080
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000080
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{
-		0x00000000, 0x98000000, 0x0000FF08, 0x00000000, 0x8b000000, 0x0000008c, 0x00000080
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-
-};
-
-
-const unsigned int cvbs_acd_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][ACD_REG_NUM+1] =
-{	
-	{
-		0x10101002,0x0,       0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG0:0-7
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0x1010403c,0x44060606,0x08080044,0x00080808,0xc006844b,0x40200808,0x44440044,0x00008c80,//REG1
-		0xf0008888,0xa0461006,0x70ff0404,0x0400208c,0x48484848,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x08000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x2,       0xe7f14e8e,//REG2:0-7
-		0x00000008,0x20070000,0x0036e946,0x00001001,0x10e0474f,0x00930363,0x00130103,0x00000000,//REG2:8-F
-		0x00000000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004cfb0,0x00000000,0x030000f0,0x0000000a,0x0000164e,0x0003d55e,0x000000f0,//REG3
-		0x00000001,0x00000400,0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG4
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x50502070,0x401020,  0xc9801c0c,0x21f00ff, 0x8080801c,//REG5
-		0x81f11111,0x81f85852,0x00680068,0x0487101c,0x00000001,0x00000000,0x00012002,0x80028040,//REG5
-		0x00000000,0x08000000,0x7f1ff000,0x00000000,0x10101040,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x80000000,0x00000000,0x00000000,0xa00833da,//REG6
-		0xba5b0391,0x000ae232,0x00000000,0xf0080610,0x3000180a,0x9c10,    0x00000182,0x00000000,//REG7
-		0x81000002,0x83020010,0x000121ff,0x000c0340,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x75777577,0x00000000,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x002468b5,0x002fa63a,0x0143a740,//REG8
-		0x00032864,0x00001b10,0x0371d249,0x0003ebde,0x00032864,0x00001b10,0x0371d249,0x0003ebde,//REG9
-		0X00032864,0x00001b10,0x0371d249,0x0003ebde,0x00032864,0x00001b10,0x0371d249,0x0003ebde,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x75777577,0x00000000,0x00192718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x00247e04,0x002fa52a,0x0143a2ef,//REGC
-		0x000327bf,0x00001b03,0x0371b470,0x0003f28b,0x000327bf,0x00001b03,0x0371b470,0x0003f28b,//REGD
-		0x000327bf,0x00001b03,0x0371b470,0x0003f28b,0x000327bf,0x00001b03,0x0371b470,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x0f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF:0-7
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff//REGF:8-F
-
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x10101002,0x10101010,0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG0:0-7
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0x1010603c,0x44060606,0x08080044,0x00080808,0x0c06844b,0x40200808,0x44440044,0x00008c80,//REG1:0-7
-		0xf0008888,0xa0461006,0x70ff0404,0x0000208c,0x48484848,0x00004444,0x00000000,0x00000000,//REG1:8-F
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00000008,0x20070000,0x0036e946,0x00001001,0x10e0474f,0x00930363,0x00120102,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d068,0x00000000,0x030000f0,0x0000000a,0x000013f0,0x0003d300,0x000000f0,//REG3
-		0x00000001,0x00000400,0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG4
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x40403070,0x04281020,0x00000000,0x021000ff,0x80688030,//REG5
-		0x81f11111,0x81f85852,0x00680068,0x0487101c,0x00000001,0x00000000,0x00012002,0x80028040,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x10101040,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0xa00833da,//REG6
-		0xba5b0391,0x000ae232,0x00000000,0xf0080610,0x60001808,0x00009410,0x00000003,0x00000000,//REG7
-		0x81018014,0x83020010,0x000121ff,0x000c0340,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x75757577,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x01c12807,0x00000000,0x00000000,//REG8
-		0x000ff511,0x00000000,0x0012198b,0x037d7036,0x000ff511,0x00000000,0x0012198b,0x037d7036,//REG9
-		0x000ff511,0x00000000,0x0012198b,0x037d7036,0x000ff511,0x00000000,0x0012198b,0x037d7036,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x75757577,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x01c08fed,0x00000000,0x00000000,//REGC
-		0x000feeef,0x00000000,0x001213ab,0x037b5071,0x000feeef,0x00000000,0x001213ab,0x037b5071,//REGD
-		0x000feeef,0x00000000,0x001213ab,0x037b5071,0x000feeef,0x00000000,0x001213ab,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x22222202,0x22222222,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0x1010403c,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x70ff0404,0x400208c, 0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x08000000,0x02020000,0x0209c832,0x00000000,0xfcf44396,0x2,       0xe7f14e8e,//REG2
-		0x00000008,0x20800000,0x00275a60,0x00001001,0x10e0474f,0x00890359,0x00170137,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d206,0x00000000,0x030000f0,0x0000000a,0x0000523e,0x0004114e,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x18188080,0x601838,  0xc9804c18,0x020f00ff,0x80808020,//REG5
-		0x88711111,0x81f24742,0x80380038,0x10000,   0x00000001,0x00000000,0x00000000,0x80300000,//REG5
-		0x00000000,0x08000000,0x7f1ff000,0x00000000,0x80c0c080,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0xa00833da,//REG6
-		0xba5b0391,0x000ae232,0x00000000,0xf0080610,0x08104008,0x2c10,    0x00000003,0x00000000,//REG7
-		0x88001002,0x3020010, 0x000281ff,0x000803c0,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x74777477,0x00000000,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x18004,   0x00200000,0x00000000,0x00000000,0x00eb2aac,0x00000000,0x00000000,//REG8
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x74777477,0x00000000,0x00192718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018004,0x00200000,0x00000000,0x00000000,0x010d753b,0x00000000,0x00000000,//REGC
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x05520b96,//REGD
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00002108,0x00000000,0x0026e905,0x00001001,0x10e0474f,0x00700340,0x00100100,0x000a0000,//REG2
-		0x00080000,0x00000000,0x000a0000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d019,0x00000000,0x030000f0,0x0000000a,0x0000442d,0x0004033d,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205040,0x0050c0c0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x81f11111,0x81f24742,0x80200020,0x03000000,0x00000001,0x00000000,0x00000000,0x80300000,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x40404040,0x40404040,0x00000000,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG 6
-		0xb3640378,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x00400040,0x00080040,0x000281ff,0x000803c0,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x75767576,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x027d7b59,0x00000000,0x00000000,//REG 8
-		0x001540c8,0x00000000,0x00000000,0x03ca7af4,0x001540c8,0x00000000,0x00000000,0x03ca7af4,//REG9
-		0x001540c8,0x00000000,0x00000000,0x03ca7af4,0x001540c8,0x00000000,0x00000000,0x03ca7af4,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x75767576,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x0282ce1c,0x00000000,0x00000000,//REGC
-		0x00153fb2,0x00000000,0x00000000,0x03ca7c7c,0x00153be2,0x00000000,0x00000000,0x03ca7c7c,//REGD
-		0x00153be2,0x00000000,0x00000000,0x03ca7c7c,0x00153be2,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x08000000,0x02020000,0x0209c832,0x00000000,0xfcf44396,0x00000102,0xe7f14e8e,//REG2
-		0x00000008,0x20800000,0x00275a60,0x00001001,0x10e0474f,0x00890359,0x00170137,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d206,0x00000000,0x030000f0,0x0000000a,0x0000523e,0x0004114e,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205070,0x0050a0a0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x80711111,0x81f24742,0x80380038,0x03061010,0x00000001,0x00000000,0x00000000,0x80300000,//REG5
-		0x00000000,0x08000000,0x7f1ff000,0x00000000,0x80c0c080,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0xa00833da,//REG6
-		0xba5b0391,0x000ae232,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x88001002,0x83024016,0x000281ff,0x000803c0,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x74777477,0x00000000,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018004,0x00200000,0x00000000,0x00000000,0x00eb2aac,0x00000000,0x00000000,//REG8
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x74777477,0x00000000,0x00192718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018004,0x00200000,0x00000000,0x00000000,0x010d753b,0x00000000,0x00000000,//REGC
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x05520b96,//REGD
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,the same to TVIN_SIG_FMT_CVBS_PAL_I
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00002108,0x00070000,0x002717d9,0x00001001,0x10e0474f,0x00700340,0x00100100,0x00000000,//REG2 
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d1fb,0x00000000,0x030000f0,0x0000000a,0x00005fef,0x00041eff,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205040,0x0050c0c0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x81f11111,0x81f24742,0x80200020,0x03000000,0x00000001,0x00000000,0x00000000,0x00000000,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x40404040,0x40404040,0x00000000,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3640378,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x00400040,0x00080040,0x00fff000,0x00040000,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00c2befd,0x00000000,0x00000000,//REG8
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00b57c68,0x00000000,0x00000000,//REGC
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,//REGD
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x00000003,//REG D
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REG E
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{	
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG 1
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00000108,0x00070000,0x002717d9,0x00001001,0x10e0474f,0x00700340,0x00170137,0x00000000,//REG 2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d1fb,0x00000000,0x030000f0,0x0000000a,0x00005fef,0x00041eff,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205040,0x0050c0c0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x81f11111,0x81f24742,0x80200020,0x03000000,0x00000001,0x00000000,0x00000000,0x00000000,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x40404040,0x40404040,0x00000000,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3640378,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x00400040,0x00080040,0x00fff000,0x00040000,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00c2befd,0x00000000,0x00000000,//REG8
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00b57c68,0x00000000,0x00000000,//REGC
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,//REGD
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x00000003,//REG D
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REG E
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-
-const unsigned int rf_acd_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][ACD_REG_NUM+1] =
-{
-	{
-		0x10101002,0x0,       0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG0:0-7
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0x1010403c,0x44060606,0x08080044,0x00080808,0xc006844b,0x40200808,0x44440044,0x00008c80,//REG1
-		0xf0008888,0xa0461006,0x70ff0404,0x0400208c,0x48484848,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x08000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x2,       0xe7f14e8e,//REG2:0-7
-		0x00000008,0x20070000,0x0036e946,0x00001001,0x10e0474f,0x00930363,0x00130103,0x00000000,//REG2:8-F
-		0x00000000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004cfb0,0x00000000,0x030000f0,0x0000000a,0x0000164e,0x0003d55e,0x000000f0,//REG3
-		0x00000001,0x00000400,0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG4
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x50502070,0x401020,  0xc9801c0c,0x21f00ff, 0x8080801c,//REG5
-		0x81f11111,0x81f85852,0x00680068,0x0487101c,0x00000001,0x00000000,0x00012002,0x80028040,//REG5
-		0x00000000,0x08000000,0x7f1ff000,0x00000000,0x10101040,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x80000000,0x00000000,0x00000000,0xa00833da,//REG6
-		0xba5b0391,0x000ae232,0x00000000,0xf0080610,0x3000180a,0x9c10,    0x00000182,0x00000000,//REG7
-		0x81000002,0x83020010,0x000121ff,0x000c0340,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x75777577,0x00000000,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x002468b5,0x002fa63a,0x0143a740,//REG8
-		0x00032864,0x00001b10,0x0371d249,0x0003ebde,0x00032864,0x00001b10,0x0371d249,0x0003ebde,//REG9
-		0X00032864,0x00001b10,0x0371d249,0x0003ebde,0x00032864,0x00001b10,0x0371d249,0x0003ebde,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x75777577,0x00000000,0x00192718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x00247e04,0x002fa52a,0x0143a2ef,//REGC
-		0x000327bf,0x00001b03,0x0371b470,0x0003f28b,0x000327bf,0x00001b03,0x0371b470,0x0003f28b,//REGD
-		0x000327bf,0x00001b03,0x0371b470,0x0003f28b,0x000327bf,0x00001b03,0x0371b470,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x0f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF:0-7
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff//REGF:8-F
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x10101002,0x10101010,0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG0:0-7
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0x1010603c,0x44060606,0x08080044,0x00080808,0x0c06844b,0x40200808,0x44440044,0x00008c80,//REG1:0-7
-		0xf0008888,0xa0461006,0x70ff0404,0x0000208c,0x48484848,0x00004444,0x00000000,0x00000000,//REG1:8-F
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00000008,0x20070000,0x0036e946,0x00001001,0x10e0474f,0x00930363,0x00120102,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d068,0x00000000,0x030000f0,0x0000000a,0x000013f0,0x0003d300,0x000000f0,//REG3
-		0x00000001,0x00000400,0x7f00e110,0x08881e18,0xb36d1858,0x00007612,0x00000000,0x77444444,//REG4
-		0x20e000fe,0x00000101,0x0c000100,0x80010909,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x40403070,0x04281020,0x00000000,0x021000ff,0x80688030,//REG5
-		0x81f11111,0x81f85852,0x00680068,0x0487101c,0x00000001,0x00000000,0x00012002,0x80028040,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x10101040,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3630387,0x000bdf37,0x00000000,0xf0080610,0x60001808,0x00009410,0x00000003,0x00000000,//REG7
-		0x81018014,0x83020010,0x000121ff,0x000c0340,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x75757577,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x01c12807,0x00000000,0x00000000,//REG8
-		0x000ff511,0x00000000,0x0012198b,0x037d7036,0x000ff511,0x00000000,0x0012198b,0x037d7036,//REG9
-		0x000ff511,0x00000000,0x0012198b,0x037d7036,0x000ff511,0x00000000,0x0012198b,0x037d7036,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x75757577,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x00018018,0x00040010,0x00000000,0x00000000,0x01c08fed,0x00000000,0x00000000,//REGC
-		0x000feeef,0x00000000,0x001213ab,0x037b5071,0x000feeef,0x00000000,0x001213ab,0x037b5071,//REGD
-		0x000feeef,0x00000000,0x001213ab,0x037b5071,0x000feeef,0x00000000,0x001213ab,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x22222202,0x22222222,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0x1010403c,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x70ff0404,0x208c,    0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x08000000,0x02020000,0x0209c832,0x00000000,0xfcf44396,0x2,       0xe7f14e8e,//REG2
-		0x00000008,0x20800000,0x00275a60,0x00001001,0x10e0474f,0x00890359,0x00170137,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d206,0x00000000,0x030000f0,0x0000000a,0x0000523e,0x0004114e,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x28284080,0x602020,  0xc9804c08,0x020f00ff,0x80808020,//REG5
-		0x88711111,0x81f24742,0x80380038,0x10000,   0x00000001,0x00000000,0x00000000,0x80300000,//REG5
-		0x00000000,0x08000000,0x7f1ff000,0x00000000,0x80c0c080,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0xa00833da,//REG6
-		0xba5b0391,0x000ae232,0x00000000,0xf0080610,0x08104008,0x2c10,    0x00000003,0x00000000,//REG7
-		0x88001002,0x3020010, 0x000281ff,0x000803c0,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x74777477,0x00000000,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x18004,   0x00200000,0x00000000,0x00000000,0x00eb2aac,0x00000000,0x00000000,//REG8
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x74777477,0x00000000,0x00192718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018004,0x00200000,0x00000000,0x00000000,0x010d753b,0x00000000,0x00000000,//REGC
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x05520b96,//REGD
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00000108,0x00000000,0x0026e905,0x00001001,0x10e0474f,0x00880358,0x00130103,0x000a0000,//REG2
-		0x00080000,0x00000000,0x000a0000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d019,0x00000000,0x030000f0,0x0000000a,0x0000442d,0x0004033d,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205040,0x0050c0c0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x81f11111,0x81f24742,0x80200020,0x03000000,0x00000001,0x00000000,0x00000000,0x80300000,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x40404040,0x40404040,0x00000000,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3640378,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x00400040,0x00080040,0x000281ff,0x000803c0,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x75767576,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x027d7b59,0x00000000,0x00000000,//REG8
-		0x001540c8,0x00000000,0x00000000,0x03ca7af4,0x001540c8,0x00000000,0x00000000,0x03ca7af4,//REG9
-		0x001540c8,0x00000000,0x00000000,0x03ca7af4,0x001540c8,0x00000000,0x00000000,0x03ca7af4,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x75767576,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x0282ce1c,0x00000000,0x00000000,//REGC
-		0x00153fb2,0x00000000,0x00000000,0x03ca7c7c,0x00153be2,0x00000000,0x00000000,0x03ca7c7c,//REGD
-		0x00153be2,0x00000000,0x00000000,0x03ca7c7c,0x00153be2,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x08000000,0x02020000,0x0209c832,0x00000000,0xfcf44396,0x00000102,0xe7f14e8e,//REG2
-		0x00000008,0x20800000,0x00275a60,0x00001001,0x10e0474f,0x00890359,0x00170137,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d206,0x00000000,0x030000f0,0x0000000a,0x0000523e,0x0004114e,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205070,0x0050a0a0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x80711111,0x81f24742,0x80380038,0x03061010,0x00000001,0x00000000,0x00000000,0x80300000,//REG5
-		0x00000000,0x08000000,0x7f1ff000,0x00000000,0x80c0c080,0x40404040,0x80000f5c,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3630387,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x88001002,0x83024016,0x000281ff,0x000803c0,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0x74777477,0x00000000,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018004,0x00200000,0x00000000,0x00000000,0x00eb2aac,0x00000000,0x00000000,//REG8
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x001652f7,0x00000000,0x00000000,0x04974980,0x001652f7,0x00000000,0x00000000,0x04974980,//REG9
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGA
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0x74777477,0x00000000,0x00192718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018004,0x00200000,0x00000000,0x00000000,0x010d753b,0x00000000,0x00000000,//REGC
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x05520b96,//REGD
-		0x0018c65f,0x00000000,0x00000000,0x05520b96,0x0018c65f,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGE
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-		0x3f000100,0x8f000004,0x3f000100,0x8f000004,0x00000002,0x90000fff,0x00000002,0x90000fff,//REGF
-
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,the same to TVIN_SIG_FMT_CVBS_PAL_I
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00002108,0x00070000,0x002717d9,0x00001001,0x10e0474f,0x00700340,0x00100100,0x00000000,//REG2 
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d1fb,0x00000000,0x030000f0,0x0000000a,0x00005fef,0x00041eff,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205040,0x0050c0c0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x81f11111,0x81f24742,0x80200020,0x03000000,0x00000001,0x00000000,0x00000000,0x00000000,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x40404040,0x40404040,0x00000000,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3640378,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x00400040,0x00080040,0x00fff000,0x00040000,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00c2befd,0x00000000,0x00000000,//REG8
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00b57c68,0x00000000,0x00000000,//REGC
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,//REGD
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{
-		0x01010101,0x01010101,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG0:0-7
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG0:8-F
-		0xc0c0600f,0x44441010,0x10100444,0x00101010,0x40c09008,0x44808080,0x44440844,0x00008c80,//REG1
-		0x01008888,0x30100c01,0x40ff0400,0x0427208c,0x88888888,0x00004444,0x00000000,0x00000000,//REG1
-		0x00000000,0x10000000,0x02020000,0x0209c832,0x00000000,0xeafb4e8e,0x00000102,0xe7f14e8e,//REG2
-		0x00000108,0x00070000,0x002717d9,0x00001001,0x10e0474f,0x00700340,0x00170137,0x00000000,//REG2
-		0x00070000,0x00000000,0x00000000,0x00000050,0x00000000,0x000003ff,0x00000000,0x00000000,//REG3
-		0x00000000,0x0004d1fb,0x00000000,0x030000f0,0x0000000a,0x00005fef,0x00041eff,0x000000f0,//REG3
-		0x00000001,0x00000400,0x00004110,0x08881e28,0xe4962858,0x00008e19,0x00000000,0x66666442,//REG4
-		0x20e00044,0x00000101,0x00000000,0x80010101,0x00000000,0x00000000,0x00000000,0x00000000,//REG4
-		0x00000000,0x00000000,0x00000000,0x08205040,0x0050c0c0,0x00000000,0x020f00ff,0x80808020,//REG5
-		0x81f11111,0x81f24742,0x80200020,0x03000000,0x00000001,0x00000000,0x00000000,0x00000000,//REG5
-		0x00000000,0x10000000,0x7f1ff000,0x00000000,0x40404040,0x40404040,0x00000000,0xff000000,//REG6
-		0x00000000,0x00000000,0x00ffffff,0x00000fff,0x00000000,0x00000000,0x00000000,0x2008f433,//REG6
-		0xb3640378,0x000bdf37,0x00000000,0xf0080610,0x08104008,0x00002410,0x00000003,0x00000000,//REG7
-		0x00400040,0x00080040,0x00fff000,0x00040000,0x40305c1c,0x00d63650,0x00c184af,0x00c1837f,//REG7
-		0x00c18329,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REG8
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00c2befd,0x00000000,0x00000000,//REG8
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x00047fcc,0x00000000,0x00000000,0x04591a41,0x00047fcc,0x00000000,0x00000000,0x04591a41,//REG9
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGA
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGB
-		0x00c1837e,0x01000100,0x43062222,0xf3f6f4f8,0x00000002,0x00000718,0x9968edd6,0x3553fab0,//REGC
-		0x026f2865,0x80018018,0x00800000,0x00000000,0x00000000,0x00b57c68,0x00000000,0x00000000,//REGC
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,//REGD
-		0x00042c0d,0x00000000,0x00000000,0x03dc2e7a,0x00042c0d,0x00000000,0x00000000,0x00000003,//REGD
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGE
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-		0x3f000100,0x0fff0000,0x3f000100,0x0fff0000,0x00000000,0x90000fff,0x00000000,0x90000fff,//REGF
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-
-//0x00-0x03
-const unsigned char cvd_yc_reg_0x00_0x03[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][4] =
-{
-	{
-		0x01, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x01, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x33, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x00, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x00, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,
-	{
-		0x00, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{
-		0x00, 0x08, 0x42, 0x22,
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-//0x18-0x1f
-const unsigned char cvd_yc_reg_0x18_0x1f[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][8] =
-{
-	{
-		0x21, 0xf0, 0x7c, 0x1f, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_NTSC_M,
-	{
-		0x21, 0xf0, 0x7c, 0x1f, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_NTSC_443,
-	{
-		0x2f, 0x4a, 0xbc, 0x24, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_PAL_I,
-	{
-		0x21, 0xe6, 0xef, 0xa4, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_PAL_M,
-	{
-		0x21, 0xf6, 0x94, 0x46, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_PAL_60,
-	{
-		0x21, 0xf6, 0x94, 0x46, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_PAL_CN,
-	{
-		0x28, 0xa3, 0x3b, 0xb2, 0x24, 0x00, 0x00, 0x00,
-	}, // TVIN_SIG_FMT_CVBS_SECAM,
-};
-
-
-EXPORT_SYMBOL(tvin_vga_fmt_tbl);
-EXPORT_SYMBOL(tvin_comp_fmt_tbl);
-EXPORT_SYMBOL(tvin_hdmi_fmt_tbl);
-EXPORT_SYMBOL(tvin_cvbs_fmt_tbl);
-EXPORT_SYMBOL(tvin_bt601_fmt_tbl);
-
-EXPORT_SYMBOL(adc_vga_table);
-EXPORT_SYMBOL(adc_component_table);
-EXPORT_SYMBOL(adc_cvbs_table);
-EXPORT_SYMBOL(cvd_part1_table);
-EXPORT_SYMBOL(cvd_part2_table);
-EXPORT_SYMBOL(cvd_part3_table);
-EXPORT_SYMBOL(cvbs_acd_table);
-EXPORT_SYMBOL(rf_acd_table);
-
-
-EXPORT_SYMBOL(cvd_yc_reg_0x00_0x03);
-EXPORT_SYMBOL(cvd_yc_reg_0x18_0x1f);
-
-
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/amlogic/tvin/tvin_format_table.h b/drivers/amlogic/tvin/tvin_format_table.h
deleted file mode 100755
index 6a88e2623eb7..000000000000
--- a/drivers/amlogic/tvin/tvin_format_table.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * TVIN signal format table
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_FORMAT_TABLE_H
-#define __TVIN_FORMAT_TABLE_H
-
-#include <linux/amlogic/tvin/tvin.h>
-
-#include "tvin_global.h"
-extern const char * tvin_sig_fmt_str(enum tvin_sig_fmt_e fmt);
-extern const struct tvin_format_s *tvin_get_fmt_info(enum tvin_sig_fmt_e fmt);
-
-extern const struct tvin_format_s tvin_vga_fmt_tbl[TVIN_SIG_FMT_VGA_MAX - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147 + 1];
-extern const struct tvin_format_s tvin_comp_fmt_tbl[TVIN_SIG_FMT_COMP_MAX - TVIN_SIG_FMT_COMP_480P_60HZ_D000 + 1];
-extern const struct tvin_format_s tvin_hdmi_fmt_tbl[TVIN_SIG_FMT_HDMI_MAX - TVIN_SIG_FMT_HDMI_640X480P_60HZ + 1];
-extern const struct tvin_format_s tvin_cvbs_fmt_tbl[TVIN_SIG_FMT_CVBS_MAX - TVIN_SIG_FMT_CVBS_NTSC_M + 1];
-extern const struct tvin_format_s tvin_bt601_fmt_tbl[TVIN_SIG_FMT_BT601_MAX - TVIN_SIG_FMT_BT656IN_576I_50HZ + 1];
-
-extern const unsigned char adc_vga_table[TVIN_SIG_FMT_VGA_MAX - TVIN_SIG_FMT_VGA_512X384P_60HZ_D147][ADC_REG_NUM];
-extern const unsigned char adc_component_table[TVIN_SIG_FMT_COMP_MAX - TVIN_SIG_FMT_COMP_480P_60HZ_D000][ADC_REG_NUM];
-extern const unsigned char adc_cvbs_table[ADC_REG_NUM];
-extern const unsigned char cvd_part1_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][CVD_PART1_REG_NUM];
-extern const unsigned char cvd_part2_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][CVD_PART2_REG_NUM];
-// 0x87, 0x93, 0x94, 0x95, 0x96, 0xe6, 0xfa
-extern const unsigned int cvd_part3_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][CVD_PART3_REG_NUM];
-extern const unsigned int cvbs_acd_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][ACD_REG_NUM+1];
-extern const unsigned int rf_acd_table[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][ACD_REG_NUM+1];
-
-
-extern const unsigned char cvd_yc_reg_0x00_0x03[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][4];
-extern const unsigned char cvd_yc_reg_0x18_0x1f[TVIN_SIG_FMT_CVBS_SECAM-TVIN_SIG_FMT_CVBS_NTSC_M+1][8];
-
-
-#endif
-
diff --git a/drivers/amlogic/tvin/tvin_frontend.c b/drivers/amlogic/tvin/tvin_frontend.c
deleted file mode 100755
index 8ff96abad63e..000000000000
--- a/drivers/amlogic/tvin/tvin_frontend.c
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * TVIN Decoder Device Driver Subsystem
- *
- * Author: Bobby Yang <bo.yang@amlogic.com>
- *
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/* Standard Linux headers */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/device.h>
-/* Amlogic headers */
-#include <linux/amlogic/amports/vframe.h>
-
-/* Local headers */
-#include "tvin_frontend.h"
-
-#define CLASS_NAME      "tvin"
-
-static struct class *tvcom_clsp;
-static struct list_head head = LIST_HEAD_INIT(head);
-static DEFINE_SPINLOCK(list_lock);
-
-int tvin_frontend_init(tvin_frontend_t *fe,
-                tvin_decoder_ops_t *dec_ops, tvin_state_machine_ops_t *sm_ops, int index)
-{
-        if (!fe)
-                return -1;
-        fe->dec_ops = dec_ops;
-        fe->sm_ops  = sm_ops;
-        fe->index   = index;
-
-        INIT_LIST_HEAD(&fe->list);
-        return 0;
-}
-EXPORT_SYMBOL(tvin_frontend_init);
-
-
-int tvin_reg_frontend(struct tvin_frontend_s *fe)
-{
-        ulong flags;
-        struct tvin_frontend_s *f, *t;
-
-        if (!fe->name || !fe->dec_ops || !fe->dec_ops->support || !fe->sm_ops)
-                return -1;
-
-        /* check whether the frontend is registered already */
-        list_for_each_entry_safe(f, t, &head, list) {
-                if (!strcmp(f->name, fe->name))
-                        return -1;
-        }
-        spin_lock_irqsave(&list_lock, flags);
-        list_add_tail(&fe->list, &head);
-        spin_unlock_irqrestore(&list_lock, flags);
-        return 0;
-}
-EXPORT_SYMBOL(tvin_reg_frontend);
-
-/*
- * Notes: This unregister interface doesn't call kfree to free memory
- * for the object, because the register interface doesn't call kmalloc
- * to allocate memory for the object. You should call the kfree yourself
- * to free memory for the object you allocated.
- */
-void tvin_unreg_frontend(struct tvin_frontend_s *fe)
-{
-        ulong flags;
-        struct tvin_frontend_s *f, *t;
-
-        list_for_each_entry_safe(f, t, &head, list) {
-                if (!strcmp(f->name, fe->name)) {
-                        spin_lock_irqsave(&list_lock, flags);
-                        list_del(&f->list);
-                        spin_unlock_irqrestore(&list_lock, flags);
-                        return;
-                }
-        }
-}
-EXPORT_SYMBOL(tvin_unreg_frontend);
-
-struct tvin_frontend_s * tvin_get_frontend(enum tvin_port_e port, int index)
-{
-        struct tvin_frontend_s *f = NULL;
-
-        list_for_each_entry(f, &head, list) {
-                if (f->dec_ops && f->dec_ops->support)
-                        if ((!f->dec_ops->support(f, port)) && (f->index == index)) {
-                                return f;
-                        }
-        }
-        return NULL;
-}
-EXPORT_SYMBOL(tvin_get_frontend);
-
-struct tvin_decoder_ops_s *tvin_get_fe_ops(enum tvin_port_e port, int index)
-{
-	struct tvin_frontend_s *f = NULL;
-	if(f=tvin_get_frontend(port,index)&&f->dec_ops) {
-		return f->dec_ops;
-	}
-	return NULL;
-}
-
-EXPORT_SYMBOL(tvin_get_fe_ops);
-
-struct tvin_decoder_ops_s *tvin_get_sm_ops(enum tvin_port_e port, int index)
-{
-	struct tvin_frontend_s *f = NULL;
-	if(f=tvin_get_frontend(port,index)&&f->dec_ops) {
-		return f->sm_ops;
-	}
-	return NULL;
-}
-
-EXPORT_SYMBOL(tvin_get_sm_ops);
-
-static ssize_t frontend_name_show(struct class *cls,struct class_attribute *attr,char *buf)
-{
-        size_t len = 0;
-        struct tvin_frontend_s *f = NULL;
-        list_for_each_entry(f,&head,list){
-                len += sprintf(buf+len,"%s\n",f->name);
-        }
-        return len;
-}
-static CLASS_ATTR(frontend_names,S_IRUGO,frontend_name_show,NULL);
-
-static int __init  tvin_common_init(void)
-{
-        int ret = 0;
-        tvcom_clsp = class_create(THIS_MODULE,CLASS_NAME);
-        if(!tvcom_clsp){
-                pr_err("[tvin_com..]%s: create tvin common class error.\n",__func__);
-                return -1;
-        }
-        ret = class_create_file(tvcom_clsp,&class_attr_frontend_names);
-        return ret;
-}
-static void __exit tvin_common_exit(void)
-{
-        class_remove_file(tvcom_clsp,&class_attr_frontend_names);
-        class_destroy(tvcom_clsp);
-}
-module_init(tvin_common_init);
-module_exit(tvin_common_exit);
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/amlogic/tvin/tvin_frontend.h b/drivers/amlogic/tvin/tvin_frontend.h
deleted file mode 100755
index 71f5e853195f..000000000000
--- a/drivers/amlogic/tvin/tvin_frontend.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * TVIN Decoder
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_DECODER_H
-#define __TVIN_DECODER_H
-
-/* Standard Linux Headers */
-#include <linux/list.h>
-
-/* Amlogic Headers */
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/tvin/tvin.h>
-
-/* Local Headers */
-#include "tvin_global.h"
-
-struct tvin_frontend_s;
-
-
-typedef struct tvin_decoder_ops_s {
-        /*
-         * check whether the port is supported.
-         * return 0 if not supported, return other if supported.
-         */
-        int  (*support)        (struct tvin_frontend_s *fe, enum tvin_port_e port);
-        int  (*open)           (struct tvin_frontend_s *fe, enum tvin_port_e port);
-        void (*start)          (struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt);
-        void (*stop)           (struct tvin_frontend_s *fe, enum tvin_port_e port);
-        void (*close)          (struct tvin_frontend_s *fe);
-        int  (*decode_isr)     (struct tvin_frontend_s *fe, unsigned int hcnt64);
-	int  (*callmaster_det) (enum tvin_port_e port,struct tvin_frontend_s *fe);
-	int  (*ioctl)          (struct tvin_frontend_s *fe, void *args);
-        int  (*decode_tsk)    (struct tvin_frontend_s *fe);
-} tvin_decoder_ops_t;
-
-typedef struct tvin_state_machine_ops_s {
-        bool (*nosig) (struct tvin_frontend_s *fe);
-        bool (*fmt_changed) (struct tvin_frontend_s *fe);
-        enum tvin_sig_fmt_e (*get_fmt) (struct tvin_frontend_s *fe);
-        void (*fmt_config)(struct tvin_frontend_s *fe);
-        bool (*adc_cal)(struct tvin_frontend_s *fe);
-        bool (*pll_lock) (struct tvin_frontend_s *fe);
-        void (*get_sig_propery)(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop);
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-        enum tvin_cvbs_pos_ctl_e (*set_cvbs_fmt_pos) (struct tvin_frontend_s *fe);
-#endif
-        void (*vga_set_param)(struct tvafe_vga_parm_s *vga_parm, struct tvin_frontend_s *fe);
-        void (*vga_get_param)(struct tvafe_vga_parm_s *vga_parm, struct tvin_frontend_s *fe);
-        bool (*check_frame_skip)(struct tvin_frontend_s *fe);
-        bool (*get_secam_phase)(struct tvin_frontend_s *fe);
-} tvin_state_machine_ops_t;
-
-typedef struct tvin_frontend_s {
-        int index; /* support multi-frontend of same decoder */
-        char name[15]; /* just name of frontend, not port name or format name */
-        int port; /* current port */
-        struct tvin_decoder_ops_s *dec_ops;
-        struct tvin_state_machine_ops_s *sm_ops;
-        unsigned int flag;
-        void *private_data;
-        unsigned reserved;
-        struct list_head list;
-} tvin_frontend_t;
-
-
-int tvin_frontend_init(tvin_frontend_t *fe,
-                tvin_decoder_ops_t *dec_ops, tvin_state_machine_ops_t *sm_ops, int index);
-int tvin_reg_frontend(struct tvin_frontend_s *fe);
-void tvin_unreg_frontend(struct tvin_frontend_s *fe);
-struct tvin_frontend_s * tvin_get_frontend(enum tvin_port_e port, int index);
-struct tvin_decoder_ops_s *tvin_get_fe_ops(enum tvin_port_e port, int index);
-struct tvin_decoder_ops_s *tvin_get_sm_ops(enum tvin_port_e port, int index);
-
-#endif
-
diff --git a/drivers/amlogic/tvin/tvin_global.c b/drivers/amlogic/tvin/tvin_global.c
deleted file mode 100755
index 833472eee99f..000000000000
--- a/drivers/amlogic/tvin/tvin_global.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * TVIN global definition
- * enum, structure & global parameters used in all TVIN modules.
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-#include <linux/amlogic/tvin/tvin.h>
-#include "tvin_global.h"
-
-
-const char *tvin_color_fmt_str(enum tvin_color_fmt_e color_fmt)
-{
-        switch (color_fmt)
-        {
-                case TVIN_RGB444:
-                        return "COLOR_FMT_RGB444";
-                        break;
-                case TVIN_YUV422:
-                        return "COLOR_FMT_YUV422";
-                        break;
-                case TVIN_YUV444:
-                        return "COLOR_FMT_YUV444";
-                        break;
-                case TVIN_YUYV422:
-                        return "COLOR_FMT_TVIN_YUYV422";
-                        break;
-                case TVIN_YVYU422:
-                        return "COLOR_FMT_TVIN_YVYU422";
-                        break;
-                case TVIN_VYUY422:
-                        return "COLOR_FMT_TVIN_VYUY422";
-                        break;
-                case TVIN_UYVY422:
-                        return "COLOR_FMT_TVIN_UYVY422";
-                        break;
-                case TVIN_NV12:
-                        return "COLOR_FMT_TVIN_NV12";
-                        break;
-                case TVIN_NV21:
-                        return "COLOR_FMT_TVIN_NV21";
-                        break;
-		case TVIN_BGGR:
-			return "COLOR_FMT_TVIN_BGGR";
-			break;
-		case TVIN_RGGB:
-			return "COLOR_FMT_TVIN_RGGB";
-			break;
-		case TVIN_GBRG:
-			return "COLOR_FMT_TVIN_GBRG";
-			break;
-        	case TVIN_GRBG:
-			return "COLOR_FMT_TVIN_GRBG";
-			break;
-                default:
-                        return "COLOR_FMT_NULL";
-                        break;
-        }
-}
-
-EXPORT_SYMBOL(tvin_color_fmt_str);
-
-const char *tvin_aspect_ratio_str(enum tvin_aspect_ratio_e aspect_ratio)
-{
-        switch (aspect_ratio)
-        {
-                case TVIN_ASPECT_1x1:
-                        return "TVIN_ASPECT_1x1";
-                        break;
-                case TVIN_ASPECT_4x3:
-                        return "TVIN_ASPECT_4x3";
-                        break;
-                case TVIN_ASPECT_16x9:
-                        return "TVIN_ASPECT_16x9";
-                        break;
-                default:
-                        return "TVIN_ASPECT_NULL";
-                        break;
-        }
-}
-
-EXPORT_SYMBOL(tvin_aspect_ratio_str);
-
-
-const char * tvin_port_str(enum tvin_port_e port)
-{
-        switch (port)
-        {
-                case TVIN_PORT_MPEG0:
-                        return "TVIN_PORT_MPEG0";
-                        break;
-                case TVIN_PORT_BT656:
-                        return "TVIN_PORT_BT656";
-                        break;
-                case TVIN_PORT_BT601:
-                        return "TVIN_PORT_BT601";
-                        break;
-                case TVIN_PORT_CAMERA:
-                        return "TVIN_PORT_CAMERA";
-                        break;
-                case TVIN_PORT_VGA0:
-                        return "TVIN_PORT_VGA0";
-                        break;
-                case TVIN_PORT_VGA1:
-                        return "TVIN_PORT_VGA1";
-                        break;
-                case TVIN_PORT_VGA2:
-                        return "TVIN_PORT_VGA2";
-                        break;
-                case TVIN_PORT_VGA3:
-                        return "TVIN_PORT_VGA3";
-                        break;
-                case TVIN_PORT_VGA4:
-                        return "TVIN_PORT_VGA4";
-                        break;
-                case TVIN_PORT_VGA5:
-                        return "TVIN_PORT_VGA5";
-                        break;
-                case TVIN_PORT_VGA6:
-                        return "TVIN_PORT_VGA6";
-                        break;
-                case TVIN_PORT_VGA7:
-                        return "TVIN_PORT_VGA7";
-                        break;
-                case TVIN_PORT_COMP0:
-                        return "TVIN_PORT_COMP0";
-                        break;
-                case TVIN_PORT_COMP1:
-                        return "TVIN_PORT_COMP1";
-                        break;
-                case TVIN_PORT_COMP2:
-                        return "TVIN_PORT_COMP2";
-                        break;
-                case TVIN_PORT_COMP3:
-                        return "TVIN_PORT_COMP3";
-                        break;
-                case TVIN_PORT_COMP4:
-                        return "TVIN_PORT_COMP4";
-                        break;
-                case TVIN_PORT_COMP5:
-                        return "TVIN_PORT_COMP5";
-                        break;
-                case TVIN_PORT_COMP6:
-                        return "TVIN_PORT_COMP6";
-                        break;
-                case TVIN_PORT_COMP7:
-                        return "TVIN_PORT_COMP7";
-                        break;
-                case TVIN_PORT_CVBS0:
-                        return "TVIN_PORT_CVBS0";
-                        break;
-                case TVIN_PORT_CVBS1:
-                        return "TVIN_PORT_CVBS1";
-                        break;
-                case TVIN_PORT_CVBS2:
-                        return "TVIN_PORT_CVBS2";
-                        break;
-                case TVIN_PORT_CVBS3:
-                        return "TVIN_PORT_CVBS3";
-                        break;
-                case TVIN_PORT_CVBS4:
-                        return "TVIN_PORT_CVBS4";
-                        break;
-                case TVIN_PORT_CVBS5:
-                        return "TVIN_PORT_CVBS5";
-                        break;
-                case TVIN_PORT_CVBS6:
-                        return "TVIN_PORT_CVBS6";
-                        break;
-                case TVIN_PORT_CVBS7:
-                        return "TVIN_PORT_CVBS7";
-                        break;
-                case TVIN_PORT_SVIDEO0:
-                        return "TVIN_PORT_SVIDEO0";
-                        break;
-                case TVIN_PORT_SVIDEO1:
-                        return "TVIN_PORT_SVIDEO1";
-                        break;
-                case TVIN_PORT_SVIDEO2:
-                        return "TVIN_PORT_SVIDEO2";
-                        break;
-                case TVIN_PORT_SVIDEO3:
-                        return "TVIN_PORT_SVIDEO3";
-                        break;
-                case TVIN_PORT_SVIDEO4:
-                        return "TVIN_PORT_SVIDEO4";
-                        break;
-                case TVIN_PORT_SVIDEO5:
-                        return "TVIN_PORT_SVIDEO5";
-                        break;
-                case TVIN_PORT_SVIDEO6:
-                        return "TVIN_PORT_SVIDEO6";
-                        break;
-                case TVIN_PORT_SVIDEO7:
-                        return "TVIN_PORT_SVIDEO7";
-                        break;
-                case TVIN_PORT_HDMI0:
-                        return "TVIN_PORT_HDMI0";
-                        break;
-                case TVIN_PORT_HDMI1:
-                        return "TVIN_PORT_HDMI1";
-                        break;
-                case TVIN_PORT_HDMI2:
-                        return "TVIN_PORT_HDMI2";
-                        break;
-                case TVIN_PORT_HDMI3:
-                        return "TVIN_PORT_HDMI3";
-                        break;
-                case TVIN_PORT_HDMI4:
-                        return "TVIN_PORT_HDMI4";
-                        break;
-                case TVIN_PORT_HDMI5:
-                        return "TVIN_PORT_HDMI5";
-                        break;
-                case TVIN_PORT_HDMI6:
-                        return "TVIN_PORT_HDMI6";
-                        break;
-                case TVIN_PORT_HDMI7:
-                        return "TVIN_PORT_HDMI7";
-                        break;
-                case TVIN_PORT_DVIN0:
-                        return "TVIN_PORT_DVIN0";
-                        break;
-                case TVIN_PORT_VIU:
-                        return "TVIN_PORT_VIU";
-                        break;
-                case TVIN_PORT_MIPI:
-                        return "TVIN_PORT_MIPI";
-                        break;
-		case TVIN_PORT_ISP:
-			return "TVIN_PORT_ISP";
-			break;
-                case TVIN_PORT_MAX:
-                        return "TVIN_PORT_MAX";
-                        break;
-                default:
-                        return "TVIN_PORT_NULL";
-                        break;
-        }
-}
-
-EXPORT_SYMBOL(tvin_port_str);
-
-const char *tvin_sig_status_str(enum tvin_sig_status_e status)
-{
-        switch (status)
-        {
-                case TVIN_SIG_STATUS_NULL:
-                        return "TVIN_SIG_STATUS_NULL";
-                        break;
-                case TVIN_SIG_STATUS_NOSIG:
-                        return "TVIN_SIG_STATUS_NOSIG";
-                        break;
-                case TVIN_SIG_STATUS_UNSTABLE:
-                        return "TVIN_SIG_STATUS_UNSTABLE";
-                        break;
-                case TVIN_SIG_STATUS_NOTSUP:
-                        return "TVIN_SIG_STATUS_NOTSUP";
-                        break;
-                case TVIN_SIG_STATUS_STABLE:
-                        return "TVIN_SIG_STATUS_STABLE";
-                        break;
-                default:
-                        return "TVIN_SIG_STATUS_NULL";
-                        break;
-        }
-}
-
-EXPORT_SYMBOL(tvin_sig_status_str);
-
-const char *tvin_trans_fmt_str(enum tvin_trans_fmt trans_fmt)
-{
-        switch (trans_fmt)
-        {
-                case TVIN_TFMT_2D:
-                        return "TVIN_TFMT_2D";
-                        break;
-                case TVIN_TFMT_3D_LRH_OLOR:
-                        return "TVIN_TFMT_3D_LRH_OLOR";
-                        break;
-                case TVIN_TFMT_3D_LRH_OLER:
-                        return "TVIN_TFMT_3D_LRH_OLER";
-                        break;
-                case TVIN_TFMT_3D_LRH_ELOR:
-                        return "TVIN_TFMT_3D_LRH_ELOR";
-                        break;
-                case TVIN_TFMT_3D_LRH_ELER:
-                        return "TVIN_TFMT_3D_LRH_ELER";
-                        break;
-                case TVIN_TFMT_3D_TB:
-                        return "TVIN_TFMT_3D_TB";
-                        break;
-                case TVIN_TFMT_3D_FP:
-                        return "TVIN_TFMT_3D_FP";
-                        break;
-                case TVIN_TFMT_3D_FA:
-                        return "TVIN_TFMT_3D_FA";
-                        break;
-                case TVIN_TFMT_3D_LA:
-                        return "TVIN_TFMT_3D_LA";
-                        break;
-                case TVIN_TFMT_3D_LRF:
-                        return "TVIN_TFMT_3D_LRF";
-                        break;
-                case TVIN_TFMT_3D_LD:
-                        return "TVIN_TFMT_3D_LD";
-                        break;
-                case TVIN_TFMT_3D_LDGD:
-                        return "TVIN_TFMT_3D_LDGD";
-                        break;
-		case TVIN_TFMT_3D_DET_TB:
-			return "TVIN_TFMT_3D_DET_TB";
-			break;
-		case TVIN_TFMT_3D_DET_LR:
-			return "TVIN_TFMT_3D_DET_LR";
-			break;
-		case TVIN_TFMT_3D_DET_INTERLACE:
-			return "TVIN_TFMT_3D_DET_INTERLACE";
-			break;
-		case TVIN_TFMT_3D_DET_CHESSBOARD:
-			return "TVIN_TFMT_3D_DET_CHESSBOARD";
-			break;
-                default:
-                        return "TVIN_TFMT_NULL";
-                        break;
-        }
-}
-
-EXPORT_SYMBOL(tvin_trans_fmt_str);
-
-
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/amlogic/tvin/tvin_global.h b/drivers/amlogic/tvin/tvin_global.h
deleted file mode 100755
index 44c492585859..000000000000
--- a/drivers/amlogic/tvin/tvin_global.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * TVIN global definition
- * enum, structure & global parameters used in all TVIN modules.
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_GLOBAL_H
-#define __TVIN_GLOBAL_H
-
-#include <linux/amlogic/tvin/tvin.h>
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-
-#define STATUS_ANTI_SHOCKING    3
-#define MINIMUM_H_CNT           1400
-
-#define ADC_REG_NUM             112
-#define CVD_PART1_REG_NUM       64
-#define CVD_PART1_REG_MIN       0x00
-#define CVD_PART2_REG_NUM       144
-#define CVD_PART2_REG_MIN       0x70
-#define CVD_PART3_REG_NUM       7 // 0x87, 0x93, 0x94, 0x95, 0x96, 0xe6, 0xfa
-#define CVD_PART3_REG_0         0x87
-#define CVD_PART3_REG_1         0x93
-#define CVD_PART3_REG_2         0x94
-#define CVD_PART3_REG_3         0x95
-#define CVD_PART3_REG_4         0x96
-#define CVD_PART3_REG_5         0xe6
-#define CVD_PART3_REG_6         0xfa
-
-//#define ACD_REG_NUM1            0x32  //0x00-0x32 except 0x1E&0x31
-//#define ACD_REG_NUM2            0x39  //the sum of the part2 acd register 
-#define ACD_REG_NUM            0xff//the sum all of the acd register
-
-#define CRYSTAL_24M
-
-#ifndef CRYSTAL_24M
-#define CRYSTAL_25M
-#endif
-
-#ifdef CRYSTAL_24M
-#define CVD2_CHROMA_DTO_NTSC_M   0x262e8ba2
-#define CVD2_CHROMA_DTO_NTSC_443 0x2f4abc24
-#define CVD2_CHROMA_DTO_PAL_I    0x2f4abc24
-#define CVD2_CHROMA_DTO_PAL_M    0x2623cd98
-#define CVD2_CHROMA_DTO_PAL_CN   0x263566cf
-#define CVD2_CHROMA_DTO_PAL_60   0x2f4abc24
-#define CVD2_CHROMA_DTO_SECAM    0x2db7a328
-#define CVD2_HSYNC_DTO_NTSC_M    0x24000000
-#define CVD2_HSYNC_DTO_NTSC_443  0x24000000
-#define CVD2_HSYNC_DTO_PAL_I     0x24000000
-#define CVD2_HSYNC_DTO_PAL_M     0x24000000
-#define CVD2_HSYNC_DTO_PAL_CN    0x24000000
-#define CVD2_HSYNC_DTO_PAL_60    0x24000000
-#define CVD2_HSYNC_DTO_SECAM     0x24000000
-#define CVD2_DCRESTORE_ACCUM     0x98       // [5:0] = 24(MHz)
-#endif
-
-#ifdef CRYSTAL_25M
-#define CVD2_CHROMA_DTO_NTSC_M   0x24a7904a
-#define CVD2_CHROMA_DTO_NTSC_443 0x2d66772d
-#define CVD2_CHROMA_DTO_PAL_I    0x2d66772d
-#define CVD2_CHROMA_DTO_PAL_M    0x249d4040
-#define CVD2_CHROMA_DTO_PAL_CN   0x24ae2541
-#define CVD2_CHROMA_DTO_PAL_60   0x2d66772d
-#define CVD2_CHROMA_DTO_SECAM    0x2be37de9
-#define CVD2_HSYNC_DTO_NTSC_M    0x228f5c28
-#define CVD2_HSYNC_DTO_NTSC_443  0x228f5c28
-#define CVD2_HSYNC_DTO_PAL_I     0x228f5c28
-#define CVD2_HSYNC_DTO_PAL_M     0x228f5c28
-#define CVD2_HSYNC_DTO_PAL_CN    0x228f5c28
-#define CVD2_HSYNC_DTO_PAL_60    0x228f5c28
-#define CVD2_HSYNC_DTO_SECAM     0x228f5c28
-#define CVD2_DCRESTORE_ACCUM     0x99       // [5:0] = 25(MHz)
-#endif
-
-
-
-
-#define TVAFE_SET_CVBS_PGA_EN
-#ifdef TVAFE_SET_CVBS_PGA_EN
-#define TVAFE_SET_CVBS_PGA_START    5
-#define TVAFE_SET_CVBS_PGA_STEP     1
-#define CVD2_DGAIN_MIDDLE           0x0200
-#define CVD2_DGAIN_WINDOW           0x000F
-#define CVD2_DGAIN_LIMITH CVD2_DGAIN_MIDDLE + CVD2_DGAIN_WINDOW
-#define CVD2_DGAIN_LIMITL CVD2_DGAIN_MIDDLE - CVD2_DGAIN_WINDOW
-#endif
-
-#define TVAFE_SET_CVBS_CDTO_EN
-#ifdef TVAFE_SET_CVBS_CDTO_EN
-#define TVAFE_SET_CVBS_CDTO_START   300
-#define TVAFE_SET_CVBS_CDTO_STEP    0
-#define HS_CNT_STANDARD             0x17a00
-#endif
-
-//#define TVAFE_SET_CVBS_MANUAL_FMT_POS  //enable manual format video position setting
-
-typedef enum tvin_sync_pol_e {
-        TVIN_SYNC_POL_NULL = 0,
-        TVIN_SYNC_POL_NEGATIVE,
-        TVIN_SYNC_POL_POSITIVE,
-} tvin_sync_pol_t;
-
-typedef enum tvin_color_space_e {
-        TVIN_CS_RGB444 = 0,
-        TVIN_CS_YUV444,
-        TVIN_CS_YUV422_16BITS,
-        TVIN_CS_YCbCr422_8BITS,
-        TVIN_CS_MAX
-} tvin_color_space_t;
-/*vdin buffer control for tvin frontend*/
-typedef enum tvin_buffer_ctl_e {
-	TVIN_BUF_NULL,
-	TVIN_BUF_SKIP,
-	TVIN_BUF_TMP,
-	TVIN_BUF_RECYCLE_TMP,
-} tvin_buffer_ctl_t;
-
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-/* cvbs manual format video postion setting */
-typedef enum tvin_cvbs_pos_ctl_e {
-        TVIN_CVBS_POS_NULL = 1,  //do not need change position
-        TVIN_CVBS_POS_P_TO_N,    //input is N, manual format is P, set N postion
-        TVIN_CVBS_POS_P_TO_P,    //input is P, manual format is P, reload P postion
-        TVIN_CVBS_POS_N_TO_P,    //input is P, manual format is N, set P postion
-        TVIN_CVBS_POS_N_TO_N,    //input is N, manual format is N, reload N postion
-} tvin_cvbs_pos_ctl_t;
-#endif
-
-// ***************************************************************************
-// *** structure definitions *********************************************
-// ***************************************************************************
-//      Hs_cnt        Pixel_Clk(Khz/10)
-
-typedef struct tvin_format_s {
-        unsigned short         h_active;        //Th in the unit of pixel
-        unsigned short         v_active;        //Tv in the unit of line
-        unsigned short         h_cnt;           //Th in the unit of T, while 1/T = 24MHz or 27MHz or even 100MHz
-        unsigned short         h_cnt_offset;    //Tolerance of h_cnt
-        unsigned short         v_cnt_offset;    //Tolerance of v_cnt
-        unsigned short         hs_cnt;          //Ths in the unit of T, while 1/T = 24MHz or 27MHz or even 100MHz
-        unsigned short         hs_cnt_offset;   //Tolerance of hs_cnt
-        unsigned short         h_total;         //Th in the unit of pixel
-        unsigned short         v_total;         //Tv in the unit of line
-        unsigned short         hs_front;        //h front proch
-        unsigned short         hs_width;        //HS in the unit of pixel
-        unsigned short         hs_bp;           //HS in the unit of pixel
-        unsigned short         vs_front;        //vs front proch in the unit of line
-        unsigned short         vs_width;        //VS width in the unit of line
-        unsigned short         vs_bp;           //vs back proch in the unit of line
-        enum tvin_sync_pol_e   hs_pol;
-        enum tvin_sync_pol_e   vs_pol;
-        enum tvin_scan_mode_e  scan_mode;
-        unsigned short         pixel_clk;       //(Khz/10)
-        unsigned short         vbi_line_start;
-        unsigned short         vbi_line_end;
-        unsigned int           duration;
-} tvin_format_t;
-
-typedef enum tvin_aspect_ratio_e {
-        TVIN_ASPECT_NULL = 0,
-        TVIN_ASPECT_1x1,
-        TVIN_ASPECT_4x3,
-        TVIN_ASPECT_16x9,
-        TVIN_ASPECT_MAX,
-} tvin_aspect_ratio_t;
-
-const char *tvin_aspect_ratio_str(enum tvin_aspect_ratio_e aspect_ratio);
-
-typedef struct tvin_sig_property_s {
-        enum tvin_trans_fmt      trans_fmt;
-        enum tvin_color_fmt_e    color_format;
-	enum tvin_color_fmt_e    dest_cfmt;//for vdin matrix destination color fmt
-        enum tvin_aspect_ratio_e aspect_ratio;
-        unsigned int             pixel_repeat;
-        unsigned int            dvi_info;
-} tvin_sig_property_t;
-
-#define TVAFE_VF_POOL_SIZE              6//8
-#define VDIN_VF_POOL_MAX_SIZE           6//8
-#define TVHDMI_VF_POOL_SIZE              6//8
-
-#define BT656IN_ANCI_DATA_SIZE          0x4000 //save anci data from bt656in
-#define CAMERA_IN_ANCI_DATA_SIZE        0x4000 //save anci data from bt656in
-
-#endif // __TVIN_GLOBAL_H
-
diff --git a/drivers/amlogic/tvin/tvin_regs.h b/drivers/amlogic/tvin/tvin_regs.h
deleted file mode 100755
index f5767d2a1e09..000000000000
--- a/drivers/amlogic/tvin/tvin_regs.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * TVIN register bit-field definition
- * Sorted by the appearing order of registers in am_regs.h.
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_REGS_H
-#define __TVIN_REGS_H
-
-
-
-
-
-#endif
-
diff --git a/drivers/amlogic/tvin/vdin/Kconfig b/drivers/amlogic/tvin/vdin/Kconfig
deleted file mode 100755
index c22777561f4c..000000000000
--- a/drivers/amlogic/tvin/vdin/Kconfig
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# VDIN Device Driver Configuration
-#
-
-
-config TVIN_VDIN
-	tristate "Amlogic VDIN device driver"
-	default n
-	help
-	  VDIN device driver.
-
diff --git a/drivers/amlogic/tvin/vdin/Makefile b/drivers/amlogic/tvin/vdin/Makefile
deleted file mode 100755
index 9b5daef24e79..000000000000
--- a/drivers/amlogic/tvin/vdin/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-#
-# Makefile for VDIN.
-#
-obj-$(CONFIG_TVIN_VDIN) = tvin_vdin.o
-tvin_vdin-objs := vdin_vf.o vdin_drv.o vdin_ctl.o vdin_sm.o vdin_canvas.o
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_canvas.c b/drivers/amlogic/tvin/vdin/vdin_canvas.c
deleted file mode 100755
index f6627c925bbb..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_canvas.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * TVIN Canvas
- *
- * Author: Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-//#include <mach/dmc.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-
-#include "../tvin_format_table.h"
-#include "vdin_drv.h"
-#include "vdin_canvas.h"
-
-static unsigned int max_buf_num = 4;
-module_param(max_buf_num, uint, 0664);
-MODULE_PARM_DESC(max_buf_num, "vdin max buf num.\n");
-
-const unsigned int vdin_canvas_ids[2][VDIN_CANVAS_MAX_CNT] = {
-	{
-		12, 13, 14, 15, 16, 17,
-		18, 19, 20, 21, 22, 23,
-		24, 25, 26, 27, 28, 29,
-		30, 31, 32, 33, 34, 35,
-
-	},
-	{
-		36, 37, 38, 39, 40, 41,
-		42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53,
-		54, 55, 56, 57, 58, 59,
-	},
-
-};
-
-inline void vdin_canvas_init(struct vdin_dev_s *devp)
-{
-	int i, canvas_id;
-	unsigned int canvas_addr;
-	int canvas_max_w = VDIN_CANVAS_MAX_WIDTH << 1;
-	int canvas_max_h = VDIN_CANVAS_MAX_HEIGH;
-	devp->canvas_max_size = PAGE_ALIGN(canvas_max_w*canvas_max_h);
-	devp->canvas_max_num  = devp->mem_size / devp->canvas_max_size;
-	if (devp->canvas_max_num > VDIN_CANVAS_MAX_CNT)
-		devp->canvas_max_num = VDIN_CANVAS_MAX_CNT;
-        
-	devp->mem_start = roundup(devp->mem_start,32);
-	pr_info("vdin.%d cnavas initial table:\n", devp->index);
-	for ( i = 0; i < devp->canvas_max_num; i++){
-		canvas_id = vdin_canvas_ids[devp->index][i];
-		canvas_addr = devp->mem_start + devp->canvas_max_size * i;
-                
-		canvas_config(canvas_id, canvas_addr, canvas_max_w, canvas_max_h,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		pr_info("\t%d: 0x%x-0x%x  %dx%d (%d KB)\n",
-				canvas_id, canvas_addr, (canvas_addr + devp->canvas_max_size),
-				canvas_max_w, canvas_max_h, (devp->canvas_max_size >> 10));
-	}
-}
-
-inline void vdin_canvas_start_config(struct vdin_dev_s *devp)
-{
-	int i, canvas_id;
-	unsigned long canvas_addr;
-	unsigned int canvas_max_w = VDIN_CANVAS_MAX_WIDTH << 1;
-	unsigned int canvas_max_h = VDIN_CANVAS_MAX_HEIGH;
-	unsigned int canvas_num = VDIN_CANVAS_MAX_CNT;
-	unsigned int chroma_size = 0;
-	unsigned int canvas_step = 1;
-
-	if ((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV444) ||
-	    (devp->format_convert == VDIN_FORMAT_CONVERT_YUV_RGB) ||
-	    (devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV444) ||
-	    (devp->format_convert == VDIN_FORMAT_CONVERT_RGB_RGB)){
-		devp->canvas_w = devp->h_active * 3;
-	}else if((devp->prop.dest_cfmt == TVIN_NV12) ||
-                (devp->prop.dest_cfmt == TVIN_NV21)){
-		canvas_max_w = VDIN_CANVAS_MAX_WIDTH;
-		canvas_max_h = VDIN_CANVAS_MAX_HEIGH;
-		canvas_num >>= 1;
-		canvas_step = 2;
-		devp->canvas_w = devp->h_active;
-	}else{
-		devp->canvas_w = devp->h_active * 2;
-	}
-#if 0
-	const struct tvin_format_s *fmt_info = tvin_get_fmt_info(devp->parm.info.fmt);
-	if(fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)
-		devp->canvas_h = devp->v_active * 2;
-	else
-		devp->canvas_h = devp->v_active;
-#else
-	devp->canvas_h = devp->v_active;
-#endif
-	if((devp->prop.dest_cfmt == TVIN_NV12) ||(devp->prop.dest_cfmt == TVIN_NV21))
-		chroma_size = canvas_max_w*canvas_max_h/2;
-	devp->canvas_max_size = PAGE_ALIGN((canvas_max_w*canvas_max_h+chroma_size));
-	devp->canvas_max_num  = devp->mem_size / devp->canvas_max_size;
-	devp->canvas_max_num = min(devp->canvas_max_num,canvas_num);
-	devp->canvas_max_num = min(devp->canvas_max_num,max_buf_num);
-	devp->canvas_w = roundup(devp->canvas_w,32);
-	devp->mem_start = roundup(devp->mem_start,32);
-#ifdef VDIN_DEBUG	
-	pr_info("vdin.%d cnavas configuration table:\n", devp->index);
-#endif
-	for (i = 0; i < devp->canvas_max_num; i++){
-		canvas_id = vdin_canvas_ids[devp->index][i*canvas_step];
-		//canvas_addr = canvas_get_addr(canvas_id);
-		/*reinitlize the canvas*/
-		canvas_addr = devp->mem_start + devp->canvas_max_size * i;
-		canvas_config(canvas_id, canvas_addr, devp->canvas_w, devp->canvas_h,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		if(chroma_size)
-			canvas_config(canvas_id+1, canvas_addr+devp->canvas_w*devp->canvas_h, devp->canvas_w, devp->canvas_h/2,
-					CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-#ifdef VDIN_DEBUG
-		pr_info("\t0x%2x: 0x%lx-0x%lx %ux%u\n",
-				canvas_id, canvas_addr, canvas_addr + devp->canvas_max_size, devp->canvas_w, devp->canvas_h);
-#endif
-	}
-}
-/*
-*this function used for configure canvas base on the input format
-*also used for input resalution over 1080p such as camera input 200M,500M
-*/
-void vdin_canvas_auto_config(struct vdin_dev_s *devp)
-{
-	int i = 0;
-	int canvas_id;
-	unsigned long canvas_addr;
-	unsigned int chroma_size = 0;
-	unsigned int canvas_step = 1;
-	unsigned int canvas_num = VDIN_CANVAS_MAX_CNT;
-
-	if ((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV444) ||
-	    (devp->format_convert == VDIN_FORMAT_CONVERT_YUV_RGB   ) ||
-	    (devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV444) ||
-	    (devp->format_convert == VDIN_FORMAT_CONVERT_RGB_RGB   )){
-		devp->canvas_w = devp->h_active * 3;
-	}else if((devp->prop.dest_cfmt == TVIN_NV12) ||(devp->prop.dest_cfmt == TVIN_NV21)){
-		devp->canvas_w = devp->h_active;
-		canvas_num = canvas_num/2;
-		canvas_step = 2;
-	}else{
-		devp->canvas_w = devp->h_active * 2;
-	}
-	devp->canvas_w = roundup(devp->canvas_w,32);
-	devp->canvas_h = devp->v_active;
-
-	if((devp->prop.dest_cfmt == TVIN_NV12) ||(devp->prop.dest_cfmt == TVIN_NV21))
-		chroma_size = devp->canvas_w*devp->canvas_h/2;
-
-	devp->canvas_max_size = PAGE_ALIGN(devp->canvas_w*devp->canvas_h+chroma_size);
-	devp->canvas_max_num  = devp->mem_size / devp->canvas_max_size;
-
-	devp->canvas_max_num = min(devp->canvas_max_num,canvas_num);
-	devp->canvas_max_num = min(devp->canvas_max_num,max_buf_num);
-
-	devp->mem_start = roundup(devp->mem_start,32);
-#ifdef VDIN_DEBUG
-	pr_info("vdin%d cnavas auto configuration table:\n", devp->index);
-#endif
-	for (i = 0; i < devp->canvas_max_num; i++){
-		canvas_id = vdin_canvas_ids[devp->index][i*canvas_step];
-		canvas_addr = devp->mem_start + devp->canvas_max_size * i;
-		canvas_config(canvas_id, canvas_addr, devp->canvas_w, devp->canvas_h,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		if(chroma_size)
-			canvas_config(canvas_id+1, canvas_addr+devp->canvas_w*devp->canvas_h, devp->canvas_w, devp->canvas_h/2,
-					CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-#ifdef VDIN_DEBUG
-		pr_info("\t%3d: 0x%lx-0x%lx %ux%u\n",
-				canvas_id, canvas_addr, canvas_addr + devp->canvas_max_size,
-				devp->canvas_w, devp->canvas_h);
-#endif
-	}
-}
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_canvas.h b/drivers/amlogic/tvin/vdin/vdin_canvas.h
deleted file mode 100755
index 87f99582b121..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_canvas.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * VDIN Canvas
- *
- * Author: Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __VDIN_CANVAS_H
-#define __VDIN_CANVAS_H
-
-#include <asm/sizes.h>
-
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-
-#define VDIN_CANVAS_MAX_WIDTH			1920
-#define VDIN_CANVAS_MAX_HEIGH			2228
-#define VDIN_CANVAS_MAX_CNT			24
-
-extern const unsigned int vdin_canvas_ids[2][VDIN_CANVAS_MAX_CNT];
-extern void vdin_canvas_init(struct vdin_dev_s *devp);
-extern void vdin_canvas_start_config(struct vdin_dev_s *devp);
-
-extern void vdin_canvas_auto_config(struct vdin_dev_s *devp);
-
-#endif /* __VDIN_CANVAS_H */
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_ctl.c b/drivers/amlogic/tvin/vdin/vdin_ctl.c
deleted file mode 100755
index 4cdb7e57d79f..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_ctl.c
+++ /dev/null
@@ -1,2093 +0,0 @@
-/*
- * VDIN driver
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-#include <mach/am_regs.h>
-#include <mach/register.h>
-#include <mach/cpu.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/tvin/tvin.h>
-#include <linux/amlogic/aml_common.h>
-
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "vdin_ctl.h"
-#include "vdin_regs.h"
-#include "vdin_drv.h"
-#include "vdin_vf.h"
-#include "vdin_canvas.h"
-#include "../../amports/ve_regs.h"
-
-#define VDIN_MEAS_24M_1MS 24000
-
-#define TVIN_MAX_PIXCLK 20000
-
-#define TVIN_MAX_HACTIVE 1920
-
-/*
-*protection for vga vertical de adjustment,if vertical blanking too short
-*mybe too short to process one field data 
-*/
-static int vbp_offset = 17;
-module_param(vbp_offset, short, 0664);
-MODULE_PARM_DESC(vbp_offset, "the mix lines after vsync");
-
-/* black bar det enable/disable test */
-static int black_bar_enable = 0;
-module_param(black_bar_enable, bool, 0664);
-MODULE_PARM_DESC(black_bar_enable, "black bar enable/disable");
-
-static int color_convert = 0;
-module_param(color_convert, int, 0664);
-MODULE_PARM_DESC(color_convert, "color_convert");
-
-static int vga_yuv422_enable = 0;
-module_param(vga_yuv422_enable, int, 0664);
-MODULE_PARM_DESC(vga_yuv422_enable, "vga_yuv422_enable");
-
-static unsigned int max_undone_cnt = 60;
-module_param(max_undone_cnt,uint,0644);
-MODULE_PARM_DESC(max_undone_cnt,"the max vdin undone cnt to reset vpp");
-
-static unsigned int use_frame_rate = 1;
-module_param(use_frame_rate,uint,0644);
-MODULE_PARM_DESC(use_frame_rate,"use frame rate to cal duraton");
-
-static bool cm_enable = 1;
-module_param(cm_enable, bool, 0644);
-MODULE_PARM_DESC(cm_enable,"cm_enable");
-
-
-/***************************Local defines**********************************/
-#define BBAR_BLOCK_THR_FACTOR           3
-#define BBAR_LINE_THR_FACTOR            7
-
-#define VDIN_MUX_NULL                   0
-#define VDIN_MUX_MPEG                   1
-#define VDIN_MUX_656                    2
-#define VDIN_MUX_TVFE                   3
-#define VDIN_MUX_CVD2                   4
-#define VDIN_MUX_HDMI                   5
-#define VDIN_MUX_DVIN                   6
-
-#define VDIN_MUX_VIU                    7
-#define VDIN_MUX_MIPI                   8
-#define VDIN_MUX_ISP					9
-
-#define VDIN_MAP_Y_G                    0
-#define VDIN_MAP_BPB                    1
-#define VDIN_MAP_RCR                    2
-
-#define MEAS_MUX_NULL                   0
-#define MEAS_MUX_656                    1
-#define MEAS_MUX_TVFE                   2
-#define MEAS_MUX_CVD2                   3
-#define MEAS_MUX_HDMI                   4
-#define MEAS_MUX_DVIN                   5
-#define MEAS_MUX_DTV                    6
-#define MEAS_MUX_ISP                    8
-
-#define MEAS_MUX_VIU                    6
-
-#define VDIN_WAIT_VALID_VS      2  // check hcnt/vcnt after N*vs.
-#define VDIN_IGNORE_VS_CNT      20  // ignore n*vs which have wrong data.
-#define VDIN_MEAS_HSCNT_DIFF    0x50  // the diff value between normal/bad data
-#define VDIN_MEAS_VSCNT_DIFF    0x50  // the diff value between normal/bad data
-
-
-/***************************Local Structures**********************************/
-static struct vdin_matrix_lup_s vdin_matrix_lup[] =
-{
-	{0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-		0x00000000, 0x0400200, 0x00000200,},
-	// VDIN_MATRIX_RGB_YUV601
-	//    0     0.257  0.504  0.098     16
-	//    0    -0.148 -0.291  0.439    128
-	//    0     0.439 -0.368 -0.071    128
-	{0x00000000, 0x00000000, 0x01070204, 0x00641f68, 0x1ed601c2, 0x01c21e87,
-		0x00001fb7, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_GBR_YUV601
-	//  0 	    0.504  0.098  0.257     16
-	//  0      -0.291  0.439 -0.148    128
-	//  0 	   -0.368 -0.071  0.439    128
-	{0x00000000, 0x00000000, 0x02040064, 0x01071ed6, 0x01c21f68, 0x1e871fb7,
-		0x000001c2, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_BRG_YUV601
-	//  0 	    0.098  0.257  0.504     16
-	//  0       0.439 -0.148 -0.291    128
-	//  0      -0.071  0.439 -0.368    128
-	{0x00000000, 0x00000000, 0x00640107, 0x020401c2, 0x1f681ed6, 0x1fb701c2,
-		0x00001e87, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV601_RGB
-	//  -16     1.164  0      1.596      0
-	// -128     1.164 -0.391 -0.813      0
-	// -128     1.164  2.018  0          0
-	{0x07c00600, 0x00000600, 0x04a80000, 0x066204a8, 0x1e701cbf, 0x04a80812,
-		0x00000000, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_YUV601_GBR
-	//  -16     1.164 -0.391 -0.813      0
-	// -128     1.164  2.018  0 	     0
-	// -128     1.164  0	  1.596      0
-	{0x07c00600, 0x00000600, 0x04a81e70, 0x1cbf04a8, 0x08120000, 0x04a80000,
-		0x00000662, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_YUV601_BRG
-	//  -16     1.164  2.018  0          0
-	// -128     1.164  0      1.596      0
-	// -128     1.164 -0.391 -0.813      0
-	{0x07c00600, 0x00000600, 0x04a80812, 0x000004a8, 0x00000662, 0x04a81e70,
-		0x00001cbf, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_RGB_YUV601F
-	//    0     0.299  0.587  0.114      0
-	//    0    -0.169 -0.331  0.5      128
-	//    0     0.5   -0.419 -0.081    128
-	{0x00000000, 0x00000000, 0x01320259, 0x00751f53, 0x1ead0200, 0x02001e53,
-		0x00001fad, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV601F_RGB
-	//    0     1      0      1.402      0
-	// -128     1     -0.344 -0.714      0
-	// -128     1      1.772  0          0
-	{0x00000600, 0x00000600, 0x04000000, 0x059c0400, 0x1ea01d25, 0x04000717,
-		0x00000000, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_RGBS_YUV601
-	//  -16     0.299  0.587  0.114     16
-	//  -16    -0.173 -0.339  0.511    128
-	//  -16     0.511 -0.429 -0.083    128
-	{0x07c007c0, 0x000007c0, 0x01320259, 0x00751f4f, 0x1ea5020b, 0x020b1e49,
-		0x00001fab, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV601_RGBS
-	//  -16     1      0      1.371     16
-	// -128     1     -0.336 -0.698     16
-	// -128     1      1.733  0         16
-	{0x07c00600, 0x00000600, 0x04000000, 0x057c0400, 0x1ea81d35, 0x040006ef,
-		0x00000000, 0x00400040, 0x00000040,},
-	// VDIN_MATRIX_RGBS_YUV601F
-	//  -16     0.348  0.683  0.133      0
-	//  -16    -0.197 -0.385  0.582    128
-	//  -16     0.582 -0.488 -0.094    128
-	{0x07c007c0, 0x000007c0, 0x016402bb, 0x00881f36, 0x1e760254, 0x02541e0c,
-		0x00001fa0, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV601F_RGBS
-	//    0     0.859  0      1.204     16
-	// -128     0.859 -0.295 -0.613     16
-	// -128     0.859  1.522  0         16
-	{0x00000600, 0x00000600, 0x03700000, 0x04d10370, 0x1ed21d8c, 0x03700617,
-		0x00000000, 0x00400040, 0x00000040,},
-	// VDIN_MATRIX_YUV601F_YUV601
-	//    0     0.859  0      0         16
-	// -128     0      0.878  0        128
-	// -128     0      0      0.878    128
-	{0x00000600, 0x00000600, 0x03700000, 0x00000000, 0x03830000, 0x00000000,
-		0x00000383, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV601_YUV601F
-	//  -16     1.164  0      0          0
-	// -128     0      1.138  0        128
-	// -128     0      0      1.138    128
-	{0x07c00600, 0x00000600, 0x04a80000, 0x00000000, 0x048d0000, 0x00000000,
-		0x0000048d, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_RGB_YUV709
-	//    0     0.183  0.614  0.062     16
-	//    0    -0.101 -0.338  0.439    128
-	//    0     0.439 -0.399 -0.04     128
-	{0x00000000, 0x00000000, 0x00bb0275, 0x003f1f99, 0x1ea601c2, 0x01c21e67,
-		0x00001fd7, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV709_RGB
-	//  -16     1.164  0      1.793      0
-	// -128     1.164 -0.213 -0.534      0
-	// -128     1.164  2.115  0          0
-	{0x07c00600, 0x00000600, 0x04a80000, 0x072c04a8, 0x1f261ddd, 0x04a80876,
-		0x00000000, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_YUV709_GBR
-	//  -16 	1.164 -0.213 -0.534 	 0
-	// -128 	1.164  2.115  0 	 0
-	// -128 	1.164  0      1.793 	 0
-	{0x07c00600, 0x00000600, 0x04a81f26, 0x1ddd04a8, 0x08760000, 0x04a80000,
-		0x0000072c, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_YUV709_BRG
-	//  -16 	1.164  2.115  0 	 0
-	// -128 	1.164  0      1.793 	 0
-	// -128 	1.164 -0.213 -0.534 	 0
-	{0x07c00600, 0x00000600, 0x04a80876, 0x000004a8, 0x0000072c, 0x04a81f26,
-		0x00001ddd, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_RGB_YUV709F
-	//    0     0.213  0.715  0.072      0
-	//    0    -0.115 -0.385  0.5      128
-	//    0     0.5   -0.454 -0.046    128
-	{0x00000000, 0x00000000, 0x00da02dc, 0x004a1f8a, 0x1e760200, 0x02001e2f,
-		0x00001fd1, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV709F_RGB
-	//    0     1      0      1.575      0
-	// -128     1     -0.187 -0.468      0
-	// -128     1      1.856  0          0
-	{0x00000600, 0x00000600, 0x04000000, 0x064d0400, 0x1f411e21, 0x0400076d,
-		0x00000000, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_RGBS_YUV709
-	//  -16     0.213  0.715  0.072     16
-	//  -16    -0.118 -0.394  0.511    128
-	//  -16     0.511 -0.464 -0.047    128
-	{0x07c007c0, 0x000007c0, 0x00da02dc, 0x004a1f87, 0x1e6d020b, 0x020b1e25,
-		0x00001fd0, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV709_RGBS
-	//  -16     1      0      1.54      16
-	// -128     1     -0.183 -0.459     16
-	// -128     1      1.816  0         16
-	{0x07c00600, 0x00000600, 0x04000000, 0x06290400, 0x1f451e2a, 0x04000744,
-		0x00000000, 0x00400040, 0x00000040,},
-	// VDIN_MATRIX_RGBS_YUV709F
-	//  -16     0.248  0.833  0.084      0
-	//  -16    -0.134 -0.448  0.582    128
-	//  -16     0.582 -0.529 -0.054    128
-	{0x07c007c0, 0x000007c0, 0x00fe0355, 0x00561f77, 0x1e350254, 0x02541de2,
-		0x00001fc9, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV709F_RGBS
-	//    0     0.859  0      1.353     16
-	// -128     0.859 -0.161 -0.402     16
-	// -128     0.859  1.594  0         16
-	{0x00000600, 0x00000600, 0x03700000, 0x05690370, 0x1f5b1e64, 0x03700660,
-		0x00000000, 0x00400040, 0x00000040,},
-	// VDIN_MATRIX_YUV709F_YUV709
-	//    0     0.859  0      0         16
-	// -128     0      0.878  0        128
-	// -128     0      0      0.878    128
-	{0x00000600, 0x00000600, 0x03700000, 0x00000000, 0x03830000, 0x00000000,
-		0x00000383, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV709_YUV709F
-	//  -16     1.164  0      0          0
-	// -128     0      1.138  0        128
-	// -128     0      0      1.138    128
-	{0x07c00600, 0x00000600, 0x04a80000, 0x00000000, 0x048d0000, 0x00000000,
-		0x0000048d, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV601_YUV709
-	//  -16     1     -0.115 -0.207     16
-	// -128     0      1.018  0.114    128
-	// -128     0      0.075  1.025    128
-	{0x07c00600, 0x00000600, 0x04001f8a, 0x1f2c0000, 0x04120075, 0x0000004d,
-		0x0000041a, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV709_YUV601
-	//  -16     1      0.100  0.192     16
-	// -128     0      0.990 -0.110    128
-	// -128     0     -0.072  0.984    128
-	{0x07c00600, 0x00000600, 0x04000066, 0x00c50000, 0x03f61f8f, 0x00001fb6,
-		0x000003f0, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV601_YUV709F
-	//  -16     1.164 -0.134 -0.241      0
-	// -128     0      1.160  0.129    128
-	// -128     0      0.085  1.167    128
-	{0x07c00600, 0x00000600, 0x04a81f77, 0x1f090000, 0x04a40084, 0x00000057,
-		0x000004ab, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV709F_YUV601
-	//    0     0.859  0.088  0.169     16
-	// -128     0      0.869 -0.097    128
-	// -128     0     -0.063  0.864    128
-	{0x00000600, 0x00000600, 0x0370005a, 0x00ad0000, 0x037a1f9d, 0x00001fbf,
-		0x00000375, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV601F_YUV709
-	//    0     0.859 -0.101 -0.182     16
-	// -128     0      0.894  0.100    128
-	// -128     0      0.066  0.900    128
-	{0x00000600, 0x00000600, 0x03701f99, 0x1f460000, 0x03930066, 0x00000044,
-		0x0000039a, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV709_YUV601F
-	//  -16     1.164  0.116  0.223      0
-	// -128     0      1.128 -0.126    128
-	// -128     0     -0.082  1.120    128
-	{0x07c00600, 0x00000600, 0x04a80077, 0x00e40000, 0x04831f7f, 0x00001fac,
-		0x0000047b, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_YUV601F_YUV709F
-	//    0     1     -0.118 -0.212     16
-	// -128     0      1.018  0.114    128
-	// -128     0      0.075  1.025    128
-	{0x00000600, 0x00000600, 0x04001f87, 0x1f270000, 0x04120075, 0x0000004d,
-		0x0000041a, 0x00400200, 0x00000200,},
-	// VDIN_MATRIX_YUV709F_YUV601F
-	//    0     1      0.102  0.196      0
-	// -128     0      0.990 -0.111    128
-	// -128     0     -0.072  0.984    128
-	{0x00000600, 0x00000600, 0x04000068, 0x00c90000, 0x03f61f8e, 0x00001fb6,
-		0x000003f0, 0x00000200, 0x00000200,},
-	// VDIN_MATRIX_RGBS_RGB
-	//  -16     1.164  0      0          0
-	//  -16     0      1.164  0          0
-	//  -16     0      0      1.164      0
-	{0x07c007c0, 0x000007c0, 0x04a80000, 0x00000000, 0x04a80000, 0x00000000,
-		0x000004a8, 0x00000000, 0x00000000,},
-	// VDIN_MATRIX_RGB_RGBS
-	//    0     0.859  0      0         16
-	//    0     0      0.859  0         16
-	//    0     0      0      0.859     16
-	{0x00000000, 0x00000000, 0x03700000, 0x00000000, 0x03700000, 0x00000000,
-		0x00000370, 0x00400040, 0x00000040,},
-};
-
-/***************************Local function**********************************/
-
-inline void vdin_get_format_convert(struct vdin_dev_s *devp)
-{
-	if (devp->prop.color_format == TVIN_RGB444)
-	{
-		if ((devp->parm.port >= TVIN_PORT_VGA0) &&
-				(devp->parm.port <= TVIN_PORT_VGA7) &&
-				!vga_yuv422_enable
-		   ) {
-			devp->format_convert = VDIN_FORMAT_CONVERT_RGB_YUV444;
-		} else if(devp->parm.port == TVIN_PORT_VIU) {
-			if(devp->prop.dest_cfmt == TVIN_NV12)
-				devp->format_convert = VDIN_FORMAT_CONVERT_RGB_NV12;
-			else if(devp->prop.dest_cfmt == TVIN_NV21)
-				devp->format_convert = VDIN_FORMAT_CONVERT_RGB_NV21;
-			else
-				devp->format_convert = VDIN_FORMAT_CONVERT_RGB_YUV422;
-		} else if(devp->prop.dest_cfmt == TVIN_RGB444) {
-			devp->format_convert = VDIN_FORMAT_CONVERT_RGB_RGB;
-		} else {
-			devp->format_convert = VDIN_FORMAT_CONVERT_RGB_YUV422;
-		}
-	}    
-	else if(devp->prop.color_format >= TVIN_YUV422 && devp->prop.color_format <= TVIN_VYUY422)
-	{
-		devp->format_convert = VDIN_FORMAT_CONVERT_YUV_YUV422;
-		
-                if(devp->prop.dest_cfmt == TVIN_NV12)
-			devp->format_convert = VDIN_FORMAT_CONVERT_YUV_NV12;
-		else if(devp->prop.dest_cfmt == TVIN_NV21)
-			devp->format_convert = VDIN_FORMAT_CONVERT_YUV_NV21;
-	}
-	else
-	        devp->format_convert = VDIN_FORMAT_CONVERT_YUV_YUV422;
-}
-
-
-void vdin_set_meas_mux(unsigned int offset, enum tvin_port_e port_)
-{
-	//    unsigned int offset = devp->addr_offset;
-	unsigned int meas_mux = MEAS_MUX_NULL;
-
-	switch ((port_)>>8)
-	{
-		case 0x01: // mpeg
-			meas_mux = MEAS_MUX_NULL;
-			break;
-		case 0x02: // 656
-			meas_mux = MEAS_MUX_656;
-			break;
-		case 0x04: // VGA
-			meas_mux = MEAS_MUX_TVFE;
-			break;
-		case 0x08: // COMPONENT
-			meas_mux = MEAS_MUX_TVFE;
-			break;
-		case 0x10: // CVBS
-			meas_mux = MEAS_MUX_CVD2;
-			break;
-		case 0x20: // SVIDEO
-			meas_mux = MEAS_MUX_CVD2;
-			break;
-		case 0x40: // hdmi
-			meas_mux = MEAS_MUX_HDMI;
-			break;
-		case 0x80: // dvin
-			meas_mux = MEAS_MUX_DVIN;
-			break;
-		case 0xc0://viu
-			meas_mux = MEAS_MUX_VIU;
-			break;
-		case 0x100://dtv mipi
-			meas_mux = MEAS_MUX_DTV;
-			break;
-		case 0x200://isp
-			meas_mux = MEAS_MUX_ISP;
-			break;
-		default:
-			meas_mux = MEAS_MUX_NULL;
-			break;
-	}
-	// set VDIN_MEAS in accumulation mode
-	WR_BITS(VDIN_MEAS_CTRL0, 1, MEAS_VS_TOTAL_CNT_EN_BIT, MEAS_VS_TOTAL_CNT_EN_WID);
-	// set VPP_VDO_MEAS in accumulation mode
-	WRITE_VCBUS_REG_BITS(VPP_VDO_MEAS_CTRL,
-			1, VDO_MEAS_ACCUM_CNT_BIT, VDO_MEAS_ACCUM_CNT_WID);
-	// set VPP_MEAS in latch-on-falling-edge mode
-	WRITE_VCBUS_REG_BITS(VPP_VDO_MEAS_CTRL,
-			1, VDO_MEAS_EDGE_BIT, VDO_MEAS_EDGE_WID);
-	// set VDIN_MEAS mux
-	WR_BITS(VDIN_MEAS_CTRL0,meas_mux, MEAS_HS_VS_SEL_BIT, MEAS_HS_VS_SEL_WID);
-	// manual reset VDIN_MEAS & VPP_VDO_MEAS at the same time, rst = 1 & 0
-	WR_BITS(VDIN_MEAS_CTRL0, 1, MEAS_RST_BIT, MEAS_RST_WID);
-	WRITE_VCBUS_REG_BITS(VPP_VDO_MEAS_CTRL, 1, VDO_MEAS_RST_BIT, VDO_MEAS_RST_WID);
-	WR_BITS(VDIN_MEAS_CTRL0,0, MEAS_RST_BIT, MEAS_RST_WID);
-	WRITE_VCBUS_REG_BITS(VPP_VDO_MEAS_CTRL,0, VDO_MEAS_RST_BIT, VDO_MEAS_RST_WID);
-}
-
-
-static inline void vdin_set_top(unsigned int offset, enum tvin_port_e port, enum tvin_color_fmt_e input_cfmt,unsigned int h)
-{
-	//    unsigned int offset = devp->addr_offset;
-	unsigned int vdin_mux = VDIN_MUX_NULL;
-	unsigned int vdin_data_bus_0 = VDIN_MAP_Y_G;
-	unsigned int vdin_data_bus_1 = VDIN_MAP_BPB;
-	unsigned int vdin_data_bus_2 = VDIN_MAP_RCR;
-
-	// [28:16]         top.input_width_m1   = h-1
-	// [12: 0]         top.output_width_m1  = h-1
-	WR(VDIN_WIDTHM1I_WIDTHM1O, ((h-1)<<16)|(h-1));
-	switch ((port)>>8)
-	{
-		case 0x01: // mpeg
-			vdin_mux = VDIN_MUX_MPEG;
-			WR_BITS(VDIN_ASFIFO_CTRL0, 0xe0, VDI1_ASFIFO_CTRL_BIT, VDI1_ASFIFO_CTRL_WID);
-			break;
-		case 0x02: // bt656
-			vdin_mux = VDIN_MUX_656;
-			WR_BITS(VDIN_ASFIFO_CTRL0, 0xe4, VDI1_ASFIFO_CTRL_BIT, VDI1_ASFIFO_CTRL_WID);			
-			break;
-		case 0x04: // VGA
-			vdin_mux = VDIN_MUX_TVFE;
-			WR_BITS(VDIN_ASFIFO_CTRL1, 0xe4, VDI3_ASFIFO_CTRL_BIT,VDI3_ASFIFO_CTRL_WID);
-			// In the order of RGB for further RGB->YUV601 or RGB->YUV709 convertion
-			vdin_data_bus_0 = VDIN_MAP_RCR;
-			vdin_data_bus_1 = VDIN_MAP_Y_G;
-			vdin_data_bus_2 = VDIN_MAP_BPB;
-			break;
-		case 0x08: // COMPONENT
-			vdin_mux = VDIN_MUX_TVFE;
-			WR_BITS(VDIN_ASFIFO_CTRL1, 0xe4, VDI3_ASFIFO_CTRL_BIT,VDI3_ASFIFO_CTRL_WID);
-			break;
-		case 0x10: // CVBS
-			vdin_mux = VDIN_MUX_CVD2;
-			WR_BITS(VDIN_ASFIFO_CTRL1, 0xe4, VDI4_ASFIFO_CTRL_BIT, VDI4_ASFIFO_CTRL_WID);
-			break;
-		case 0x20: // SVIDEO
-			vdin_mux = VDIN_MUX_CVD2;
-			WR_BITS(VDIN_ASFIFO_CTRL1, 0xe4, VDI4_ASFIFO_CTRL_BIT, VDI4_ASFIFO_CTRL_WID);
-			break;
-		case 0x40: // hdmi
-			vdin_mux = VDIN_MUX_HDMI;
-			WR_BITS(VDIN_ASFIFO_CTRL2, 0xe4, VDI5_ASFIFO_CTRL_BIT, VDI5_ASFIFO_CTRL_WID);
-			break;
-		case 0x80: // dvin
-			vdin_mux = VDIN_MUX_DVIN;
-			WR_BITS(VDIN_ASFIFO_CTRL3, 0xe2, VDI6_ASFIFO_CTRL_BIT, VDI6_ASFIFO_CTRL_WID);
-			break;
-		case 0xc0: //viu
-			vdin_mux = VDIN_MUX_VIU;
-			WR_BITS(VDIN_ASFIFO_CTRL3, 0xf4, VDI6_ASFIFO_CTRL_BIT, VDI6_ASFIFO_CTRL_WID);
-			break;
-		case 0x100://mipi in mybe need modify base on truth
-			vdin_mux = VDIN_MUX_MIPI;
-			WR_BITS(VDIN_ASFIFO_CTRL3, 0xe0, VDI7_ASFIFO_CTRL_BIT, VDI7_ASFIFO_CTRL_WID);
-			break;
-		case 0x200:
-			vdin_mux = VDIN_MUX_ISP;
-			WR_BITS(VDIN_ASFIFO_CTRL3, 0xe4, VDI8_ASFIFO_CTRL_BIT, VDI8_ASFIFO_CTRL_WID);
-			break;
-		default:
-			vdin_mux = VDIN_MUX_NULL;
-			break;
-	}
-	switch(input_cfmt) {
-                case TVIN_YVYU422:
-                        vdin_data_bus_1 = VDIN_MAP_RCR;
-                        vdin_data_bus_2 = VDIN_MAP_BPB;
-                        break;
-                case TVIN_UYVY422:
-                        vdin_data_bus_0 = VDIN_MAP_BPB;
-                        vdin_data_bus_1 = VDIN_MAP_RCR;
-                        vdin_data_bus_2 = VDIN_MAP_Y_G;
-                        break;
-                case TVIN_VYUY422:
-                        vdin_data_bus_0 = VDIN_MAP_BPB;
-                        vdin_data_bus_1 = VDIN_MAP_RCR;
-                        vdin_data_bus_2 = VDIN_MAP_Y_G;
-                        break;
-                default:
-                        break;
-        }
-	WR_BITS(VDIN_COM_CTRL0, vdin_mux, VDIN_SEL_BIT, VDIN_SEL_WID);
-	WR_BITS(VDIN_COM_CTRL0, vdin_data_bus_0, COMP0_OUT_SWT_BIT, COMP0_OUT_SWT_WID);
-	WR_BITS(VDIN_COM_CTRL0, vdin_data_bus_1, COMP1_OUT_SWT_BIT, COMP1_OUT_SWT_WID);
-	WR_BITS(VDIN_COM_CTRL0, vdin_data_bus_2, COMP2_OUT_SWT_BIT, COMP2_OUT_SWT_WID);
-}
-
-/*
-   this fucntion will set the bellow parameters of devp:
-   1.h_active
-   2.v_active
- */
-void vdin_set_decimation(struct vdin_dev_s *devp)
-{
-	unsigned int offset = devp->addr_offset;
-	unsigned int decimation_ratio = 0;
-	unsigned short new_clk = 0;
-	//enum tvin_sig_fmt_e fmt = devp->parm.info.fmt;
-	//const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-
-	if ((devp->prop.pixel_repeat >=  2) &&
-			(devp->prop.pixel_repeat <= 16))
-		decimation_ratio = devp->prop.pixel_repeat - 1;
-	new_clk = devp->fmt_info_p->pixel_clk / (decimation_ratio + 1);
-
-	while (new_clk > TVIN_MAX_PIXCLK)
-	{
-		decimation_ratio++;
-		new_clk = devp->fmt_info_p->pixel_clk / (decimation_ratio + 1);
-	}
-	pr_info("%s decimation_ratio = %d\n",__func__, decimation_ratio);
-
-	devp->h_active = devp->fmt_info_p->h_active / (decimation_ratio + 1);
-	devp->v_active = devp->fmt_info_p->v_active;
-
-	/* disable decimation function for hdmi input */
-	if ((devp->parm.port >= TVIN_PORT_HDMI0) &&
-	    (devp->parm.port <= TVIN_PORT_HDMI7) &&
-       (devp->fmt_info_p->pixel_clk <= TVIN_MAX_PIXCLK))
-	    decimation_ratio = 0;
-	if (decimation_ratio)
-	{
-		// ratio
-		WR_BITS(VDIN_ASFIFO_CTRL2,
-				decimation_ratio, ASFIFO_DECIMATION_NUM_BIT, ASFIFO_DECIMATION_NUM_WID);
-		// en
-		WR_BITS(VDIN_ASFIFO_CTRL2,
-				1, ASFIFO_DECIMATION_DE_EN_BIT, ASFIFO_DECIMATION_DE_EN_WID);
-		// manual reset, rst = 1 & 0
-		WR_BITS(VDIN_ASFIFO_CTRL2,
-				1, ASFIFO_DECIMATION_SYNC_WITH_DE_BIT, ASFIFO_DECIMATION_SYNC_WITH_DE_WID);
-		WR_BITS(VDIN_ASFIFO_CTRL2,
-				0, ASFIFO_DECIMATION_SYNC_WITH_DE_BIT, ASFIFO_DECIMATION_SYNC_WITH_DE_WID);
-	}
-
-	// output_width_m1
-	WR_BITS(VDIN_INTF_WIDTHM1,(devp->h_active - 1), VDIN_INTF_WIDTHM1_BIT, VDIN_INTF_WIDTHM1_WID);
-	return ;
-}
-
-/*
-   this fucntion will set the bellow parameters of devp:
-   1.h_active
-   2.v_active
- */
-void vdin_set_cutwin(struct vdin_dev_s *devp)
-{
-	unsigned int offset = devp->addr_offset;
-	unsigned int he = 0,ve = 0;
-
-#if 1
-	if (((devp->parm.cutwin.hs) ||
-				(devp->parm.cutwin.he) ||
-				(devp->parm.cutwin.vs) ||
-				(devp->parm.cutwin.ve)
-	    )                                                                     &&
-			(devp->h_active > (devp->parm.cutwin.hs + devp->parm.cutwin.he)) &&
-			(devp->v_active > (devp->parm.cutwin.vs + devp->parm.cutwin.ve)) &&
-			(devp->parm.port == TVIN_PORT_ISP)
-	   )
-	{
-		devp->h_active -= (devp->parm.cutwin.he + devp->parm.cutwin.hs);
-		devp->v_active -= (devp->parm.cutwin.ve + devp->parm.cutwin.vs);
-		he = devp->parm.cutwin.hs + devp->h_active - 1;
-		ve = devp->parm.cutwin.vs + devp->v_active - 1;
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-		/* set new video size, change size only if manual fmt is wrong */
-		if ((devp->parm.port >= TVIN_PORT_CVBS0) &&
-				(devp->parm.port <= TVIN_PORT_SVIDEO7))
-		{
-			if ((devp->cvbs_pos_chg == TVIN_CVBS_POS_P_TO_N) ||
-					(devp->cvbs_pos_chg == TVIN_CVBS_POS_N_TO_P))
-			{
-				if (devp->parm.info.fmt == TVIN_SIG_FMT_CVBS_PAL_I)  //288-240
-				{
-					devp->v_active -= 48;
-					devp->parm.cutwin.ve -= 48;
-				}
-				else
-				{
-					devp->v_active += 48;
-					devp->parm.cutwin.ve += 48;
-				}
-			}
-		}
-#endif
-		WR(VDIN_WIN_H_START_END, (devp->parm.cutwin.hs << INPUT_WIN_H_START_BIT) | (he << INPUT_WIN_H_END_BIT));
-		WR(VDIN_WIN_V_START_END, (devp->parm.cutwin.vs << INPUT_WIN_V_START_BIT) | (ve << INPUT_WIN_V_END_BIT));
-		WR_BITS(VDIN_COM_CTRL0, 1, INPUT_WIN_SEL_EN_BIT, INPUT_WIN_SEL_EN_WID);
-		pr_info("%s enable cutwin hs = %d, he = %d,  vs = %d, ve = %d\n", __func__,
-				devp->parm.cutwin.hs, devp->parm.cutwin.he, devp->parm.cutwin.vs, devp->parm.cutwin.ve);
-	}
-	else{
-		pr_info("%s disable cutwin!!! hs = %d, he = %d,  vs = %d, ve = %d\n", __func__,
-				devp->parm.cutwin.hs, devp->parm.cutwin.he, devp->parm.cutwin.vs, devp->parm.cutwin.ve);
-	}
-#endif
-}
-
-
-
-static inline void vdin_set_color_matrix1(unsigned int offset, tvin_format_t *tvin_fmt_p, enum vdin_format_convert_e format_convert)
-{
-        #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-	//    unsigned int offset = devp->addr_offset;
-	enum vdin_matrix_csc_e    matrix_csc = VDIN_MATRIX_NULL;
-	struct vdin_matrix_lup_s *matrix_tbl;
-	struct tvin_format_s *fmt_info = tvin_fmt_p;
-
-	switch (format_convert)
-	{
-		case VDIN_MATRIX_XXX_YUV_BLACK:
-			matrix_csc = VDIN_MATRIX_XXX_YUV601_BLACK;
-			break;
-		case VDIN_FORMAT_CONVERT_RGB_YUV422:
-		case VDIN_FORMAT_CONVERT_RGB_NV12:
-		case VDIN_FORMAT_CONVERT_RGB_NV21:
-			matrix_csc = VDIN_MATRIX_RGBS_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_BRG_YUV422:
-			matrix_csc = VDIN_MATRIX_BRG_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_GBR_YUV422:
-			matrix_csc = VDIN_MATRIX_GBR_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_RGB_YUV444:
-			matrix_csc = VDIN_MATRIX_RGB_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_RGB:
-			if (
-		              ((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-		       	      ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-				matrix_csc = VDIN_MATRIX_YUV709_RGB;
-			else
-				matrix_csc = VDIN_MATRIX_YUV601_RGB;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_GBR:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-			    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-				matrix_csc = VDIN_MATRIX_YUV709_GBR;
-			else
-				matrix_csc = VDIN_MATRIX_YUV601_GBR;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_BRG:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-			    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-				matrix_csc = VDIN_MATRIX_YUV709_BRG;
-			else
-				matrix_csc = VDIN_MATRIX_YUV601_BRG;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_YUV422:
-		case VDIN_FORMAT_CONVERT_YUV_YUV444:
-		case VDIN_FORMAT_CONVERT_YUV_NV12:
-		case VDIN_FORMAT_CONVERT_YUV_NV21:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-         		    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-			{
-				if (color_convert == 0)
-					matrix_csc = VDIN_MATRIX_YUV709_YUV601;
-				else if (color_convert == 1)
-					matrix_csc = VDIN_MATRIX_YUV709_YUV601F;
-				else if (color_convert == 2)
-					matrix_csc = VDIN_MATRIX_YUV709_YUV709F;
-				else if (color_convert == 3)
-					matrix_csc = VDIN_MATRIX_YUV709F_YUV601;
-				else if (color_convert == 4)
-					matrix_csc = VDIN_MATRIX_YUV709F_YUV601F;
-				else
-					matrix_csc = VDIN_MATRIX_YUV709_YUV601;
-			}
-			break;
-		default:
-			matrix_csc = VDIN_MATRIX_NULL;
-			break;
-	}
-
-	if (matrix_csc == VDIN_MATRIX_NULL)
-	{
-		WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX1_EN_BIT, VDIN_MATRIX1_EN_WID);
-	}
-	else
-	{
-		matrix_tbl = &vdin_matrix_lup[matrix_csc - 1];
-		/*select matrix1 post probe and postion(200,100)*/
-		WR_BITS(VDIN_MATRIX_CTRL, 1, VDIN_PROBE_POST_BIT, VDIN_PROBE_POST_WID);
-		WR_BITS(VDIN_MATRIX_CTRL, 1, VDIN_PROBE_SEL_BIT, VDIN_PROBE_SEL_WID);
-		WR(VDIN_MATRIX_PROBE_POS, 0xc812);
-		/*coefficient index select matrix1*/
-		WR_BITS(VDIN_MATRIX_CTRL, 1, VDIN_MATRIX_COEF_INDEX_BIT, VDIN_MATRIX_COEF_INDEX_WID);
-		WR(VDIN_MATRIX_PRE_OFFSET0_1,matrix_tbl->pre_offset0_1);
-		WR(VDIN_MATRIX_PRE_OFFSET2, matrix_tbl->pre_offset2);
-		WR(VDIN_MATRIX_COEF00_01, matrix_tbl->coef00_01);
-		WR(VDIN_MATRIX_COEF02_10, matrix_tbl->coef02_10);
-		WR(VDIN_MATRIX_COEF11_12, matrix_tbl->coef11_12);
-		WR(VDIN_MATRIX_COEF20_21, matrix_tbl->coef20_21);
-		WR(VDIN_MATRIX_COEF22, matrix_tbl->coef22);
-		WR(VDIN_MATRIX_OFFSET0_1, matrix_tbl->post_offset0_1);
-		WR(VDIN_MATRIX_OFFSET2, matrix_tbl->post_offset2);
-                WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX1_BYPASS_BIT, VDIN_MATRIX1_BYPASS_WID);
-		WR_BITS(VDIN_MATRIX_CTRL, 1, VDIN_MATRIX1_EN_BIT, VDIN_MATRIX1_EN_WID);
-	}
-        #endif
-}
-
-static inline void vdin_set_color_matrix0(unsigned int offset, tvin_format_t *tvin_fmt_p, enum vdin_format_convert_e format_convert)
-{
-	enum vdin_matrix_csc_e    matrix_csc = VDIN_MATRIX_NULL;
-	struct vdin_matrix_lup_s *matrix_tbl;
-	struct tvin_format_s *fmt_info = tvin_fmt_p;
-
-	switch (format_convert)
-	{
-		case VDIN_MATRIX_XXX_YUV_BLACK:
-			matrix_csc = VDIN_MATRIX_XXX_YUV601_BLACK;
-			break;
-		case VDIN_FORMAT_CONVERT_RGB_YUV422:
-		case VDIN_FORMAT_CONVERT_RGB_NV12:
-		case VDIN_FORMAT_CONVERT_RGB_NV21:
-			matrix_csc = VDIN_MATRIX_RGBS_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_GBR_YUV422:
-			matrix_csc = VDIN_MATRIX_GBR_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_BRG_YUV422:
-			matrix_csc = VDIN_MATRIX_BRG_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_RGB_YUV444:
-			matrix_csc = VDIN_MATRIX_RGB_YUV601;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_RGB:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-			    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-				matrix_csc = VDIN_MATRIX_YUV709_RGB;
-			else
-				matrix_csc = VDIN_MATRIX_YUV601_RGB;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_GBR:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-			    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-				matrix_csc = VDIN_MATRIX_YUV709_GBR;
-			else
-				matrix_csc = VDIN_MATRIX_YUV601_GBR;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_BRG:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-			    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-				matrix_csc = VDIN_MATRIX_YUV709_BRG;
-			else
-				matrix_csc = VDIN_MATRIX_YUV601_BRG;
-			break;
-		case VDIN_FORMAT_CONVERT_YUV_YUV422:
-		case VDIN_FORMAT_CONVERT_YUV_YUV444:
-		case VDIN_FORMAT_CONVERT_YUV_NV12:
-		case VDIN_FORMAT_CONVERT_YUV_NV21:
-			if (((fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE) && (fmt_info->v_active >= 720)) || //  720p & above
-               		    ((fmt_info->scan_mode == TVIN_SCAN_MODE_INTERLACED)  && (fmt_info->v_active >= 540))    // 1080i & above
-			   )
-			{
-				if (color_convert == 0)
-					matrix_csc = VDIN_MATRIX_YUV709_YUV601;
-				else if (color_convert == 1)
-					matrix_csc = VDIN_MATRIX_YUV709_YUV601F;
-				else if (color_convert == 2)
-					matrix_csc = VDIN_MATRIX_YUV709_YUV709F;
-				else if (color_convert == 3)
-					matrix_csc = VDIN_MATRIX_YUV709F_YUV601;
-				else if (color_convert == 4)
-					matrix_csc = VDIN_MATRIX_YUV709F_YUV601F;
-				else
-					matrix_csc = VDIN_MATRIX_YUV709_YUV601;
-			}
-			break;
-		default:
-			matrix_csc = VDIN_MATRIX_NULL;
-			break;
-	}
-
-	if (matrix_csc == VDIN_MATRIX_NULL)
-	{
-		WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX_EN_BIT, VDIN_MATRIX_EN_WID);
-	}
-	else
-	{
-		matrix_tbl = &vdin_matrix_lup[matrix_csc - 1];
-
-		/*coefficient index select matrix0*/
-		WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX_COEF_INDEX_BIT, VDIN_MATRIX_COEF_INDEX_WID);
-
-		WR(VDIN_MATRIX_PRE_OFFSET0_1,matrix_tbl->pre_offset0_1);
-		WR(VDIN_MATRIX_PRE_OFFSET2, matrix_tbl->pre_offset2);
-		WR(VDIN_MATRIX_COEF00_01, matrix_tbl->coef00_01);
-		WR(VDIN_MATRIX_COEF02_10, matrix_tbl->coef02_10);
-		WR(VDIN_MATRIX_COEF11_12, matrix_tbl->coef11_12);
-		WR(VDIN_MATRIX_COEF20_21, matrix_tbl->coef20_21);
-		WR(VDIN_MATRIX_COEF22, matrix_tbl->coef22);
-		WR(VDIN_MATRIX_OFFSET0_1, matrix_tbl->post_offset0_1);
-		WR(VDIN_MATRIX_OFFSET2, matrix_tbl->post_offset2);
-       WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX0_BYPASS_BIT, VDIN_MATRIX0_BYPASS_WID);
-		WR_BITS(VDIN_MATRIX_CTRL, 1, VDIN_MATRIX_EN_BIT, VDIN_MATRIX_EN_WID);
-	}
-}
-void vdin_set_matrix(struct vdin_dev_s *devp)
-{
-
-	//vdin_set_color_matrix1(devp->addr_offset, devp->fmt_info_p, devp->format_convert);
-
-	vdin_set_color_matrix0(devp->addr_offset, devp->fmt_info_p, devp->format_convert);
-}
-
-void vdin_set_matrixs(struct vdin_dev_s *devp, unsigned char id, enum vdin_format_convert_e csc)
-{
-	switch(id){
-		case 0:
-			vdin_set_color_matrix0(devp->addr_offset,devp->fmt_info_p,csc);
-			break;
-		case 1:
-			vdin_set_color_matrix1(devp->addr_offset,devp->fmt_info_p,csc);
-			break;
-		default:
-			break;
-	}
-}
-
-void vdin_set_matrix_blank(struct vdin_dev_s *devp)
-{
-	vdin_set_color_matrix0(devp->addr_offset, devp->fmt_info_p, VDIN_MATRIX_XXX_YUV_BLACK);
-}
-static inline void vdin_set_bbar(unsigned int offset, unsigned int v, unsigned int h)
-{
-	unsigned int region_width = 1, block_thr = 0, line_thr = 0;
-	while ((region_width<<1) < h)
-	{
-		region_width <<= 1;
-	}
-
-	block_thr = (region_width>>1) * v;
-	block_thr = block_thr - (block_thr >> BBAR_BLOCK_THR_FACTOR); // bblk=(bpix>thr)
-	line_thr  = h >> BBAR_LINE_THR_FACTOR;                        // bln=!(wpix>=thr)
-
-	// region_width
-	WR_BITS(VDIN_BLKBAR_CTRL0,
-			region_width, BLKBAR_H_WIDTH_BIT, BLKBAR_H_WIDTH_WID);
-	// win_he
-	WR_BITS(VDIN_BLKBAR_H_START_END,
-			(h - 1), BLKBAR_HEND_BIT, BLKBAR_HEND_WID);
-	// win_ve
-	WR_BITS(VDIN_BLKBAR_V_START_END,
-			(v - 1), BLKBAR_VEND_BIT, BLKBAR_VEND_WID);
-	// bblk_thr_on_bpix
-	WR_BITS(VDIN_BLKBAR_CNT_THRESHOLD,
-			block_thr, BLKBAR_CNT_TH_BIT, BLKBAR_CNT_TH_WID);
-	// blnt_thr_on_wpix
-	WR_BITS(VDIN_BLKBAR_ROW_TH1_TH2,
-			line_thr, BLKBAR_ROW_TH1_BIT, BLKBAR_ROW_TH1_WID);
-	// blnb_thr_on_wpix
-	WR_BITS(VDIN_BLKBAR_ROW_TH1_TH2,
-			line_thr, BLKBAR_ROW_TH2_BIT, BLKBAR_ROW_TH2_WID);
-	// en
-	WR_BITS(VDIN_BLKBAR_CTRL0,
-			1, BLKBAR_DET_TOP_EN_BIT, BLKBAR_DET_TOP_EN_WID);
-	// manual reset, rst = 0 & 1, raising edge mode
-	WR_BITS(VDIN_BLKBAR_CTRL0,
-			0, BLKBAR_DET_SOFT_RST_N_BIT, BLKBAR_DET_SOFT_RST_N_WID);
-	WR_BITS(VDIN_BLKBAR_CTRL0,
-			1, BLKBAR_DET_SOFT_RST_N_BIT, BLKBAR_DET_SOFT_RST_N_WID);
-}
-
-static inline void vdin_set_histogram(unsigned int offset, unsigned int hs, unsigned int he, unsigned int vs, unsigned int ve)
-{
-	unsigned int pixel_sum = 0, record_len = 0, hist_pow = 0;
-	if ((hs < he) && (vs < ve))
-	{
-		pixel_sum = (he - hs + 1) * (ve - vs + 1);
-		record_len = 0xffff<<3;
-		while ((pixel_sum > record_len) && (hist_pow < 3))
-		{
-			hist_pow++;
-			record_len <<= 1;
-		}
-		//#ifdef CONFIG_MESON2_CHIP
-		// pow
-		WR_BITS(VDIN_HIST_CTRL, hist_pow, HIST_POW_BIT, HIST_POW_WID);
-		// win_hs
-		WR_BITS(VDIN_HIST_H_START_END, hs, HIST_HSTART_BIT, HIST_HSTART_WID);
-		// win_he
-		WR_BITS(VDIN_HIST_H_START_END, he, HIST_HEND_BIT, HIST_HEND_WID);
-		// win_vs
-		WR_BITS(VDIN_HIST_V_START_END, vs, HIST_VSTART_BIT, HIST_VSTART_WID);
-		// win_ve
-		WR_BITS(VDIN_HIST_V_START_END, ve, HIST_VEND_BIT, HIST_VEND_WID);
-	}
-}
-
-static inline void vdin_set_wr_ctrl(unsigned int offset, unsigned int v, unsigned int h, enum vdin_format_convert_e format_convert)
-{
-	unsigned int write_format444=0, swap_cbcr=0;
-        unsigned int def_canvas_id = offset? vdin_canvas_ids[1][0]:vdin_canvas_ids[0][0];
-
-	switch (format_convert)
-	{
-		case VDIN_FORMAT_CONVERT_YUV_YUV422:
-		case VDIN_FORMAT_CONVERT_RGB_YUV422:
-			write_format444 = 0;
-			break;
-                case VDIN_FORMAT_CONVERT_YUV_NV12:
-		case VDIN_FORMAT_CONVERT_RGB_NV12:
-			write_format444 = 2;
-			swap_cbcr = 1;
-			break;
-                case VDIN_FORMAT_CONVERT_YUV_NV21:
-		case VDIN_FORMAT_CONVERT_RGB_NV21:
-                        write_format444 = 2;
-			swap_cbcr = 0;
-                        break;
-		default:
-			write_format444 = 1;
-			break;
-	}
-
-	// win_he
-	WR_BITS(VDIN_WR_H_START_END, (h -1), WR_HEND_BIT, WR_HEND_WID);
-	// win_ve
-	WR_BITS(VDIN_WR_V_START_END, (v -1), WR_VEND_BIT, WR_VEND_WID);
-	// hconv_mode
-	WR_BITS(VDIN_WR_CTRL, 0, HCONV_MODE_BIT, HCONV_MODE_WID);
-	// vconv_mode
-	WR_BITS(VDIN_WR_CTRL, 0, VCONV_MODE_BIT, VCONV_MODE_WID);
-	if(write_format444 == 2){
-		// swap_cbcr
-		WR_BITS(VDIN_WR_CTRL, swap_cbcr, SWAP_CBCR_BIT, SWAP_CBCR_WID);
-		//output even lines's cbcr
-		WR_BITS(VDIN_WR_CTRL, 0, VCONV_MODE_BIT, VCONV_MODE_WID);
-		WR_BITS(VDIN_WR_CTRL, 2, HCONV_MODE_BIT, HCONV_MODE_WID);
-		//chroma canvas
-		//WR_BITS(VDIN_WR_CTRL2, def_canvas_id+1, WRITE_CHROMA_CANVAS_ADDR_BIT, WRITE_CHROMA_CANVAS_ADDR_WID);
-	}else{
-		// swap_cbcr
-		WR_BITS(VDIN_WR_CTRL, 0, SWAP_CBCR_BIT, SWAP_CBCR_WID);
-		//chroma canvas
-		//WR_BITS(VDIN_WR_CTRL2,  0, WRITE_CHROMA_CANVAS_ADDR_BIT,
-		//WRITE_CHROMA_CANVAS_ADDR_WID);
-	}
-	// format444
-	WR_BITS(VDIN_WR_CTRL, write_format444, WR_FMT_BIT, WR_FMT_WID);
-/*
-	// canvas_id
-	WR_BITS(VDIN_WR_CTRL, def_canvas_id, WR_CANVAS_BIT, WR_CANVAS_WID);
-*/
-	// req_urgent
-	WR_BITS(VDIN_WR_CTRL, 1, WR_REQ_URGENT_BIT, WR_REQ_URGENT_WID);
-	// req_en
-	WR_BITS(VDIN_WR_CTRL, 1, WR_REQ_EN_BIT, WR_REQ_EN_WID);
-}
-
-void set_wr_ctrl(int h_pos,int v_pos,struct vdin_dev_s *devp)
-{
-	enum tvin_sig_fmt_e fmt = devp->parm.info.fmt;
-	unsigned int offset = devp->addr_offset;
-    unsigned int ve = 0;
-	const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-
-    if(!fmt_info) {
-        pr_err("[tvafe..] %s: error,fmt is null!!! \n",__func__);
-        return;
-    }
-
-	//disable cut window
-	ve = fmt_info->v_active;
-	WR_BITS(VDIN_COM_CTRL0, 0, INPUT_WIN_SEL_EN_BIT, INPUT_WIN_SEL_EN_WID);
-	if(h_pos + fmt_info->hs_bp <0)
-	{
-		unsigned int w_s = abs(h_pos + fmt_info->hs_bp);
-		w_s = (1 + (w_s>>3))<<3;
-		WR_BITS(VDIN_WR_H_START_END, w_s, WR_HSTART_BIT, WR_HSTART_WID);
-	}
-	else
-	{
-		WR_BITS(VDIN_WR_H_START_END, 0, WR_HSTART_BIT, WR_HSTART_WID);
-	}
-	if(v_pos + fmt_info->vs_bp - vbp_offset <0)
-	{
-		WR_BITS(VDIN_WR_V_START_END,
-				abs(v_pos + fmt_info->vs_bp - vbp_offset), WR_VSTART_BIT, WR_VSTART_WID);
-	}
-	else if(v_pos > fmt_info->vs_front)
-	{//config write window and cut window when v pos > v front porch
-		WR(VDIN_WIN_V_START_END,
-				((v_pos - fmt_info->vs_front)<< INPUT_WIN_V_START_BIT) | ve << INPUT_WIN_V_END_BIT);
-		WR(VDIN_WIN_H_START_END,
-				(0 << INPUT_WIN_H_START_BIT) | ((devp->h_active - 1) << INPUT_WIN_H_END_BIT));
-		WR_BITS(VDIN_COM_CTRL0, 1, INPUT_WIN_SEL_EN_BIT, INPUT_WIN_SEL_EN_WID);
-		ve -= v_pos - fmt_info->vs_front;
-	}
-	else
-	{
-		WR_BITS(VDIN_WR_V_START_END, 0, WR_VSTART_BIT, WR_VSTART_WID);
-	}
-	vdin_set_wr_ctrl(devp->addr_offset,ve, devp->h_active, devp->format_convert);
-}
-
-/***************************global function**********************************/
-
-
-inline unsigned int vdin_get_meas_hcnt64(unsigned int offset)
-{
-	return (RD_BITS(VDIN_MEAS_HS_COUNT, MEAS_HS_CNT_BIT, MEAS_HS_CNT_WID));
-}
-inline unsigned int vdin_get_meas_vstamp(unsigned int offset)
-{
-	return (RD(VDIN_MEAS_VS_COUNT_LO ));
-}
-
-
-
-inline unsigned int vdin_get_active_h(unsigned int offset)
-{
-	return (RD_BITS(VDIN_ACTIVE_MAX_PIX_CNT_STATUS , ACTIVE_MAX_PIX_CNT_SDW_BIT, ACTIVE_MAX_PIX_CNT_SDW_WID) );
-}
-
-inline unsigned int vdin_get_active_v(unsigned int offset)
-{
-	return (RD_BITS(VDIN_LCNT_SHADOW_STATUS, ACTIVE_LN_CNT_SDW_BIT, ACTIVE_LN_CNT_SDW_WID) );
-}
-
-inline unsigned int vdin_get_total_v(unsigned int offset)
-{
-	return (RD_BITS(VDIN_LCNT_SHADOW_STATUS, GO_LN_CNT_SDW_BIT, GO_LN_CNT_SDW_WID));
-}
-
-inline void vdin_set_canvas_id(unsigned int offset, unsigned int canvas_id)
-{
-	WR_BITS(VDIN_WR_CTRL, canvas_id, WR_CANVAS_BIT, WR_CANVAS_WID);
-}
-inline unsigned int vdin_get_canvas_id(unsigned int offset)
-{
-	return RD_BITS(VDIN_WR_CTRL, WR_CANVAS_BIT, WR_CANVAS_WID);
-}
-
-inline void vdin_set_chma_canvas_id(unsigned int offset, unsigned int canvas_id)
-{
-        WR_BITS(VDIN_WR_CTRL2,  canvas_id, WRITE_CHROMA_CANVAS_ADDR_BIT,
-                WRITE_CHROMA_CANVAS_ADDR_WID);
-}
-inline unsigned int vdin_get_chma_canvas_id(unsigned int offset)
-{
-	return RD_BITS(VDIN_WR_CTRL2, WRITE_CHROMA_CANVAS_ADDR_BIT,
-                        WRITE_CHROMA_CANVAS_ADDR_WID);
-}
-
-/* reset default writing cavnas register */
-inline void vdin_set_def_wr_canvas(struct vdin_dev_s *devp)
-{
-	unsigned int offset = devp->addr_offset;
-	unsigned int def_canvas;
-	def_canvas = vdin_canvas_ids[devp->index][0];
-
-	// [31:24]       write.out_ctrl         = 0x0b
-	// [   23]       write.frame_rst_on_vs  = 1
-	// [   22]       write.lfifo_rst_on_vs  = 1
-	// [   21]       write.clr_direct_done  = 0
-	// [   20]       write.clr_nr_done      = 0
-	// [   12]       write.format444        = 1/(422, 444)
-	// [   11]       write.canvas_latch_en  = 0
-	// [    9]       write.req_urgent       = 0 ***sub_module.enable***
-	// [    8]       write.req_en           = 0 ***sub_module.enable***
-	// [ 7: 0]       write.canvas           = 0
-	WR(VDIN_WR_CTRL, (0x0bc01000 | def_canvas));
-}
-
-#ifdef AML_LOCAL_DIMMING
-inline void vdin_set_ldim_max_init(unsigned int offset, int pic_h, int pic_v, int blk_vnum, int blk_hnum)
-{
-        int k;
-        struct ldim_max_s ldimmax;
-        int ldim_pic_rowmax = 1080;
-        int ldim_pic_colmax = 1920;
-        int ldim_blk_vnum = 2;
-        int ldim_blk_hnum = 8;
-	ldim_pic_rowmax = pic_v;
-        ldim_pic_colmax = pic_h;
-        ldim_blk_vnum = blk_vnum; //8;
-        ldim_blk_hnum = blk_hnum; //2;
-	ldimmax.ld_stamax_hidx[0]=0;
-	for (k=1; k<9; k++){
-	        ldimmax.ld_stamax_hidx[k] = ((ldim_pic_colmax + ldim_blk_hnum - 1)/ldim_blk_hnum)*k;
-		if (ldimmax.ld_stamax_hidx[k]> 4095)
-                        ldimmax.ld_stamax_hidx[k] = 4095; // clip U12
-	}
-	ldimmax.ld_stamax_vidx[0]=0;
-	for (k=1; k<9; k++)
-	{
-		 ldimmax.ld_stamax_vidx[k] = ((ldim_pic_rowmax + ldim_blk_vnum - 1)/ldim_blk_vnum)*k;
-		 if (ldimmax.ld_stamax_vidx[k]> 4095)
-                        ldimmax.ld_stamax_vidx[k] = 4095;  // clip to U12
-	}
-	WR(VDIN_LDIM_STTS_HIST_REGION_IDX, (1 << LOCAL_DIM_STATISTIC_EN_BIT)  |
-		                               (0 << EOL_EN_BIT)                  |
-		                               (2 << VLINE_OVERLAP_NUMBER_BIT)    |
-		                               (1 << HLINE_OVERLAP_NUMBER_BIT)    |
-		                               (1 << LPF_BEFORE_STATISTIC_EN_BIT) |
-		                               (1 << REGION_RD_INDEX_INC_BIT)
-		);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,0,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_vidx[0]<<12|ldimmax.ld_stamax_hidx[0]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,1,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_hidx[2]<<12|ldimmax.ld_stamax_hidx[1]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,2,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_vidx[2]<<12|ldimmax.ld_stamax_vidx[1]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,3,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_hidx[4]<<12|ldimmax.ld_stamax_hidx[3]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,4,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_vidx[4]<<12|ldimmax.ld_stamax_vidx[3]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,5,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_hidx[6]<<12|ldimmax.ld_stamax_hidx[5]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,6,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_vidx[6]<<12|ldimmax.ld_stamax_vidx[5]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,7,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_hidx[8]<<12|ldimmax.ld_stamax_hidx[7]);
-	WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,8,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-	WR(VDIN_LDIM_STTS_HIST_SET_REGION,ldimmax.ld_stamax_vidx[8]<<12|ldimmax.ld_stamax_vidx[7]);
-}
-#endif
-
-inline void vdin_set_vframe_prop_info(struct vframe_s *vf, struct vdin_dev_s *devp)
-{
-	unsigned int offset = devp->addr_offset;
-	struct vframe_bbar_s bbar = {0};
-#ifdef AML_LOCAL_DIMMING
-	int i;
-#endif
-	// fetch hist info
-	//vf->prop.hist.luma_sum   = READ_CBUS_REG_BITS(VDIN_HIST_SPL_VAL,     HIST_LUMA_SUM_BIT,    HIST_LUMA_SUM_WID   );
-	vf->prop.hist.hist_pow   = RD_BITS(VDIN_HIST_CTRL, HIST_POW_BIT, HIST_POW_WID);
-	vf->prop.hist.luma_sum   = RD(VDIN_HIST_SPL_VAL);
-	//vf->prop.hist.chroma_sum = READ_CBUS_REG_BITS(VDIN_HIST_CHROMA_SUM,  HIST_CHROMA_SUM_BIT,  HIST_CHROMA_SUM_WID );
-	vf->prop.hist.chroma_sum = RD(VDIN_HIST_CHROMA_SUM);
-	vf->prop.hist.pixel_sum  = RD_BITS(VDIN_HIST_SPL_PIX_CNT, HIST_PIX_CNT_BIT, HIST_PIX_CNT_WID);
-	vf->prop.hist.height     = RD_BITS(VDIN_HIST_V_START_END,HIST_VEND_BIT,HIST_VEND_WID) -
-		RD_BITS(VDIN_HIST_V_START_END,HIST_VSTART_BIT,HIST_VSTART_WID)+1;
-	vf->prop.hist.width      = RD_BITS(VDIN_HIST_H_START_END,HIST_HEND_BIT,HIST_HEND_WID) -
-		RD_BITS(VDIN_HIST_V_START_END,HIST_HSTART_BIT,HIST_HSTART_WID)+1;
-	vf->prop.hist.luma_max   = RD_BITS(VDIN_HIST_MAX_MIN, HIST_MAX_BIT, HIST_MAX_WID);
-	vf->prop.hist.luma_min   = RD_BITS(VDIN_HIST_MAX_MIN, HIST_MIN_BIT, HIST_MIN_WID);
-	vf->prop.hist.gamma[0]   = RD_BITS(VDIN_DNLP_HIST00, HIST_ON_BIN_00_BIT, HIST_ON_BIN_00_WID);
-	vf->prop.hist.gamma[1]   = RD_BITS(VDIN_DNLP_HIST00, HIST_ON_BIN_01_BIT, HIST_ON_BIN_01_WID);
-	vf->prop.hist.gamma[2]   = RD_BITS(VDIN_DNLP_HIST01, HIST_ON_BIN_02_BIT, HIST_ON_BIN_02_WID);
-	vf->prop.hist.gamma[3]   = RD_BITS(VDIN_DNLP_HIST01, HIST_ON_BIN_03_BIT, HIST_ON_BIN_03_WID);
-	vf->prop.hist.gamma[4]   = RD_BITS(VDIN_DNLP_HIST02, HIST_ON_BIN_04_BIT, HIST_ON_BIN_04_WID);
-	vf->prop.hist.gamma[5]   = RD_BITS(VDIN_DNLP_HIST02, HIST_ON_BIN_05_BIT, HIST_ON_BIN_05_WID);
-	vf->prop.hist.gamma[6]   = RD_BITS(VDIN_DNLP_HIST03, HIST_ON_BIN_06_BIT, HIST_ON_BIN_06_WID);
-	vf->prop.hist.gamma[7]   = RD_BITS(VDIN_DNLP_HIST03, HIST_ON_BIN_07_BIT, HIST_ON_BIN_07_WID);
-	vf->prop.hist.gamma[8]   = RD_BITS(VDIN_DNLP_HIST04, HIST_ON_BIN_08_BIT, HIST_ON_BIN_08_WID);
-	vf->prop.hist.gamma[9]   = RD_BITS(VDIN_DNLP_HIST04, HIST_ON_BIN_09_BIT, HIST_ON_BIN_09_WID);
-	vf->prop.hist.gamma[10]  = RD_BITS(VDIN_DNLP_HIST05, HIST_ON_BIN_10_BIT, HIST_ON_BIN_10_WID);
-	vf->prop.hist.gamma[11]  = RD_BITS(VDIN_DNLP_HIST05, HIST_ON_BIN_11_BIT, HIST_ON_BIN_11_WID);
-	vf->prop.hist.gamma[12]  = RD_BITS(VDIN_DNLP_HIST06, HIST_ON_BIN_12_BIT, HIST_ON_BIN_12_WID);
-	vf->prop.hist.gamma[13]  = RD_BITS(VDIN_DNLP_HIST06, HIST_ON_BIN_13_BIT, HIST_ON_BIN_13_WID);
-	vf->prop.hist.gamma[14]  = RD_BITS(VDIN_DNLP_HIST07, HIST_ON_BIN_14_BIT, HIST_ON_BIN_14_WID);
-	vf->prop.hist.gamma[15]  = RD_BITS(VDIN_DNLP_HIST07, HIST_ON_BIN_15_BIT, HIST_ON_BIN_15_WID);
-	vf->prop.hist.gamma[16]  = RD_BITS(VDIN_DNLP_HIST08, HIST_ON_BIN_16_BIT, HIST_ON_BIN_16_WID);
-	vf->prop.hist.gamma[17]  = RD_BITS(VDIN_DNLP_HIST08, HIST_ON_BIN_17_BIT, HIST_ON_BIN_17_WID);
-	vf->prop.hist.gamma[18]  = RD_BITS(VDIN_DNLP_HIST09, HIST_ON_BIN_18_BIT, HIST_ON_BIN_18_WID);
-	vf->prop.hist.gamma[19]  = RD_BITS(VDIN_DNLP_HIST09, HIST_ON_BIN_19_BIT, HIST_ON_BIN_19_WID);
-	vf->prop.hist.gamma[20]  = RD_BITS(VDIN_DNLP_HIST10, HIST_ON_BIN_20_BIT, HIST_ON_BIN_20_WID);
-	vf->prop.hist.gamma[21]  = RD_BITS(VDIN_DNLP_HIST10, HIST_ON_BIN_21_BIT, HIST_ON_BIN_21_WID);
-	vf->prop.hist.gamma[22]  = RD_BITS(VDIN_DNLP_HIST11, HIST_ON_BIN_22_BIT, HIST_ON_BIN_22_WID);
-	vf->prop.hist.gamma[23]  = RD_BITS(VDIN_DNLP_HIST11, HIST_ON_BIN_23_BIT, HIST_ON_BIN_23_WID);
-	vf->prop.hist.gamma[24]  = RD_BITS(VDIN_DNLP_HIST12, HIST_ON_BIN_24_BIT, HIST_ON_BIN_24_WID);
-	vf->prop.hist.gamma[25]  = RD_BITS(VDIN_DNLP_HIST12, HIST_ON_BIN_25_BIT, HIST_ON_BIN_25_WID);
-	vf->prop.hist.gamma[26]  = RD_BITS(VDIN_DNLP_HIST13, HIST_ON_BIN_26_BIT, HIST_ON_BIN_26_WID);
-	vf->prop.hist.gamma[27]  = RD_BITS(VDIN_DNLP_HIST13, HIST_ON_BIN_27_BIT, HIST_ON_BIN_27_WID);
-	vf->prop.hist.gamma[28]  = RD_BITS(VDIN_DNLP_HIST14, HIST_ON_BIN_28_BIT, HIST_ON_BIN_28_WID);
-	vf->prop.hist.gamma[29]  = RD_BITS(VDIN_DNLP_HIST14, HIST_ON_BIN_29_BIT, HIST_ON_BIN_29_WID);
-	vf->prop.hist.gamma[30]  = RD_BITS(VDIN_DNLP_HIST15, HIST_ON_BIN_30_BIT, HIST_ON_BIN_30_WID);
-	vf->prop.hist.gamma[31]  = RD_BITS(VDIN_DNLP_HIST15, HIST_ON_BIN_31_BIT, HIST_ON_BIN_31_WID);
-	vf->prop.hist.gamma[32]  = RD_BITS(VDIN_DNLP_HIST16, HIST_ON_BIN_32_BIT, HIST_ON_BIN_32_WID);
-	vf->prop.hist.gamma[33]  = RD_BITS(VDIN_DNLP_HIST16, HIST_ON_BIN_33_BIT, HIST_ON_BIN_33_WID);
-	vf->prop.hist.gamma[34]  = RD_BITS(VDIN_DNLP_HIST17, HIST_ON_BIN_34_BIT, HIST_ON_BIN_34_WID);
-	vf->prop.hist.gamma[35]  = RD_BITS(VDIN_DNLP_HIST17, HIST_ON_BIN_35_BIT, HIST_ON_BIN_35_WID);
-	vf->prop.hist.gamma[36]  = RD_BITS(VDIN_DNLP_HIST18, HIST_ON_BIN_36_BIT, HIST_ON_BIN_36_WID);
-	vf->prop.hist.gamma[37]  = RD_BITS(VDIN_DNLP_HIST18, HIST_ON_BIN_37_BIT, HIST_ON_BIN_37_WID);
-	vf->prop.hist.gamma[38]  = RD_BITS(VDIN_DNLP_HIST19, HIST_ON_BIN_38_BIT, HIST_ON_BIN_38_WID);
-	vf->prop.hist.gamma[39]  = RD_BITS(VDIN_DNLP_HIST19, HIST_ON_BIN_39_BIT, HIST_ON_BIN_39_WID);
-	vf->prop.hist.gamma[40]  = RD_BITS(VDIN_DNLP_HIST20, HIST_ON_BIN_40_BIT, HIST_ON_BIN_40_WID);
-	vf->prop.hist.gamma[41]  = RD_BITS(VDIN_DNLP_HIST20, HIST_ON_BIN_41_BIT, HIST_ON_BIN_41_WID);
-	vf->prop.hist.gamma[42]  = RD_BITS(VDIN_DNLP_HIST21, HIST_ON_BIN_42_BIT, HIST_ON_BIN_42_WID);
-	vf->prop.hist.gamma[43]  = RD_BITS(VDIN_DNLP_HIST21, HIST_ON_BIN_43_BIT, HIST_ON_BIN_43_WID);
-	vf->prop.hist.gamma[44]  = RD_BITS(VDIN_DNLP_HIST22, HIST_ON_BIN_44_BIT, HIST_ON_BIN_44_WID);
-	vf->prop.hist.gamma[45]  = RD_BITS(VDIN_DNLP_HIST22, HIST_ON_BIN_45_BIT, HIST_ON_BIN_45_WID);
-	vf->prop.hist.gamma[46]  = RD_BITS(VDIN_DNLP_HIST23, HIST_ON_BIN_46_BIT, HIST_ON_BIN_46_WID);
-	vf->prop.hist.gamma[47]  = RD_BITS(VDIN_DNLP_HIST23, HIST_ON_BIN_47_BIT, HIST_ON_BIN_47_WID);
-	vf->prop.hist.gamma[48]  = RD_BITS(VDIN_DNLP_HIST24, HIST_ON_BIN_48_BIT, HIST_ON_BIN_48_WID);
-	vf->prop.hist.gamma[49]  = RD_BITS(VDIN_DNLP_HIST24, HIST_ON_BIN_49_BIT, HIST_ON_BIN_49_WID);
-	vf->prop.hist.gamma[50]  = RD_BITS(VDIN_DNLP_HIST25, HIST_ON_BIN_50_BIT, HIST_ON_BIN_50_WID);
-	vf->prop.hist.gamma[51]  = RD_BITS(VDIN_DNLP_HIST25, HIST_ON_BIN_51_BIT, HIST_ON_BIN_51_WID);
-	vf->prop.hist.gamma[52]  = RD_BITS(VDIN_DNLP_HIST26, HIST_ON_BIN_52_BIT, HIST_ON_BIN_52_WID);
-	vf->prop.hist.gamma[53]  = RD_BITS(VDIN_DNLP_HIST26, HIST_ON_BIN_53_BIT, HIST_ON_BIN_53_WID);
-	vf->prop.hist.gamma[54]  = RD_BITS(VDIN_DNLP_HIST27, HIST_ON_BIN_54_BIT, HIST_ON_BIN_54_WID);
-	vf->prop.hist.gamma[55]  = RD_BITS(VDIN_DNLP_HIST27, HIST_ON_BIN_55_BIT, HIST_ON_BIN_55_WID);
-	vf->prop.hist.gamma[56]  = RD_BITS(VDIN_DNLP_HIST28, HIST_ON_BIN_56_BIT, HIST_ON_BIN_56_WID);
-	vf->prop.hist.gamma[57]  = RD_BITS(VDIN_DNLP_HIST28, HIST_ON_BIN_57_BIT, HIST_ON_BIN_57_WID);
-	vf->prop.hist.gamma[58]  = RD_BITS(VDIN_DNLP_HIST29, HIST_ON_BIN_58_BIT, HIST_ON_BIN_58_WID);
-	vf->prop.hist.gamma[59]  = RD_BITS(VDIN_DNLP_HIST29, HIST_ON_BIN_59_BIT, HIST_ON_BIN_59_WID);
-	vf->prop.hist.gamma[60]  = RD_BITS(VDIN_DNLP_HIST30, HIST_ON_BIN_60_BIT, HIST_ON_BIN_60_WID);
-	vf->prop.hist.gamma[61]  = RD_BITS(VDIN_DNLP_HIST30, HIST_ON_BIN_61_BIT, HIST_ON_BIN_61_WID);
-	vf->prop.hist.gamma[62]  = RD_BITS(VDIN_DNLP_HIST31, HIST_ON_BIN_62_BIT, HIST_ON_BIN_62_WID);
-	vf->prop.hist.gamma[63]  = RD_BITS(VDIN_DNLP_HIST31, HIST_ON_BIN_63_BIT, HIST_ON_BIN_63_WID);
-
-	// fetch bbar info
-	bbar.top        = RD_BITS(VDIN_BLKBAR_STATUS0, BLKBAR_TOP_POS_BIT, BLKBAR_TOP_POS_WID);
-	bbar.bottom     = RD_BITS(VDIN_BLKBAR_STATUS0, BLKBAR_BTM_POS_BIT,   BLKBAR_BTM_POS_WID);
-	bbar.left       = RD_BITS(VDIN_BLKBAR_STATUS1, BLKBAR_LEFT_POS_BIT, BLKBAR_LEFT_POS_WID);
-	bbar.right      = RD_BITS(VDIN_BLKBAR_STATUS1,BLKBAR_RIGHT_POS_BIT, BLKBAR_RIGHT_POS_WID);
-	if(bbar.top > bbar.bottom){
-		bbar.top = 0;
-		bbar.bottom = vf->height - 1;
-	}
-	if(bbar.left > bbar.right){
-		bbar.left = 0;
-		bbar.right = vf->width - 1;
-	}
-
-	// Update Histgram windown with detected BlackBar window
-	vdin_set_histogram(offset, bbar.left, bbar.right, bbar.top, bbar.bottom);
-
-	if (black_bar_enable)
-	{
-		vf->prop.bbar.top        = bbar.top;
-		vf->prop.bbar.bottom     = bbar.bottom;
-		vf->prop.bbar.left       = bbar.left;
-		vf->prop.bbar.right      = bbar.right;
-	}
-	else
-		memset(&vf->prop.bbar, 0, sizeof(struct vframe_bbar_s));
-
-	// fetch meas info - For M2 or further chips only, not for M1 chip
-	vf->prop.meas.vs_stamp = devp->stamp;
-	vf->prop.meas.vs_cycle = devp->cycle;
-#ifdef AML_LOCAL_DIMMING
-    //get ldim max
-        WR_BITS(VDIN_LDIM_STTS_HIST_REGION_IDX,0,REGION_RD_INDEX_BIT,REGION_RD_INDEX_WID);
-        for(i=0;i<64;i++)
-	        vf->prop.hist.ldim_max[i] = RD(P_VDIN_LDIM_STTS_HIST_READ_REGION);
-#endif
-}
-
-static inline ulong vdin_reg_limit(ulong val, ulong wid)
-{
-	if (val < (1<<wid))
-		return(val);
-	else
-		return((1<<wid)-1);
-}
-
-
-void vdin_set_all_regs(struct vdin_dev_s *devp)
-{
-
-	/* matrix sub-module */
-	vdin_set_color_matrix0(devp->addr_offset, devp->fmt_info_p, devp->format_convert);
-
-	/* bbar sub-module */
-	vdin_set_bbar(devp->addr_offset, devp->v_active, devp->h_active);
-#ifdef AML_LOCAL_DIMMING
-	/* ldim sub-module */
-	vdin_set_ldim_max_init(devp->addr_offset, 1920, 1080, 8, 2);
-#endif
-	/* hist sub-module */
-	vdin_set_histogram(devp->addr_offset, 0, devp->h_active - 1, 0, devp->v_active - 1);
-
-	/* write sub-module */
-	vdin_set_wr_ctrl(devp->addr_offset, devp->v_active, devp->h_active, devp->format_convert);
-
-	/* top sub-module */
-	vdin_set_top(devp->addr_offset, devp->parm.port, devp->prop.color_format,devp->h_active);
-
-	/*  */
-
-	vdin_set_meas_mux(devp->addr_offset, devp->parm.port);
-
-}
-
-void vdin_delay_line(unsigned short num,unsigned int offset)
-{
-	WR_BITS(VDIN_COM_CTRL0, num, DLY_GO_FLD_LN_NUM_BIT, DLY_GO_FLD_LN_NUM_WID);
-}
-inline void vdin_set_default_regmap(unsigned int offset)
-{
-	unsigned int def_canvas_id;
-	//    unsigned int offset = devp->addr_offset;
-
-	// [   31]        mpeg.en               = 0 ***sub_module.enable***
-	// [   30]        mpeg.even_fld         = 0/(odd, even)
-
-
-
-	// [26:20]         top.hold_ln          = 0    //8
-	// [   19]      vs_dly.en               = 0 ***sub_module.enable***
-	// [18:12]      vs_dly.dly_ln           = 0
-	// [11:10]         map.comp2            = 2/(comp0, comp1, comp2)
-	// [ 9: 8]         map.comp1            = 1/(comp0, comp1, comp2)
-	// [ 7: 6]         map.comp0            = 0/(comp0, comp1, comp2)
-
-
-	// [    4]         top.datapath_en      = 1
-	// [ 3: 0]         top.mux              = 0/(null, mpeg, 656, tvfe, cvd2, hdmi, dvin)
-	WR(VDIN_COM_CTRL0, 0x00000910);
-	// [   23] asfifo_tvfe.de_en            = 1
-	// [   22] asfifo_tvfe.vs_en            = 1
-	// [   21] asfifo_tvfe.hs_en            = 1
-	// [   20] asfifo_tvfe.vs_inv           = 0/(positive-active, negative-active)
-	// [   19] asfifo_tvfe.hs_inv           = 0/(positive-active, negative-active)
-	// [   18] asfifo_tvfe.rst_on_vs        = 1
-	// [   17] asfifo_tvfe.clr_ov_flag      = 0
-	// [   16] asfifo_tvfe.rst              = 0
-	// [    7]  asfifo_656.de_en            = 1
-	// [    6]  asfifo_656.vs_en            = 1
-	// [    5]  asfifo_656.hs_en            = 1
-	// [    4]  asfifo_656.vs_inv           = 0/(positive-active, negative-active)
-	// [    3]  asfifo_656.hs_inv           = 0/(positive-active, negative-active)
-	// [    2]  asfifo_656.rst_on_vs        = 0
-	// [    1]  asfifo_656.clr_ov_flag      = 0
-	// [    0]  asfifo_656.rst              = 0
-	//WR(VDIN_ASFIFO_CTRL0, 0x00000000);
-	// [   23] asfifo_hdmi.de_en            = 1
-	// [   22] asfifo_hdmi.vs_en            = 1
-	// [   21] asfifo_hdmi.hs_en            = 1
-	// [   20] asfifo_hdmi.vs_inv           = 0/(positive-active, negative-active)
-	// [   19] asfifo_hdmi.hs_inv           = 0/(positive-active, negative-active)
-	// [   18] asfifo_hdmi.rst_on_vs        = 1
-	// [   17] asfifo_hdmi.clr_ov_flag      = 0
-	// [   16] asfifo_hdmi.rst              = 0
-	// [    7] asfifo_cvd2.de_en            = 1
-	// [    6] asfifo_cvd2.vs_en            = 1
-	// [    5] asfifo_cvd2.hs_en            = 1
-	// [    4] asfifo_cvd2.vs_inv           = 0/(positive-active, negative-active)
-	// [    3] asfifo_cvd2.hs_inv           = 0/(positive-active, negative-active)
-	// [    2] asfifo_cvd2.rst_on_vs        = 1
-	// [    1] asfifo_cvd2.clr_ov_flag      = 0
-	// [    0] asfifo_cvd2.rst              = 0
-	//WR(VDIN_ASFIFO_CTRL1, 0x00000000);
-	// [28:16]         top.input_width_m1   = 0
-	// [12: 0]         top.output_width_m1  = 0
-	WR(VDIN_WIDTHM1I_WIDTHM1O, 0x00000000);
-	// [14: 8]         hsc.init_pix_in_ptr  = 0
-	// [    7]         hsc.phsc_en          = 0
-	// [    6]         hsc.en               = 0 ***sub_module.enable***
-	// [    5]         hsc.short_ln_en      = 1
-	// [    4]         hsc.nearest_en       = 0
-	// [    3]         hsc.phase0_always    = 1
-	// [ 2: 0]         hsc.filt_dep         = 0/(DEPTH4,DEPTH1, DEPTH2, DEPTH3)
-	WR(VDIN_SC_MISC_CTRL, 0x00000028);
-	// [28:24]         hsc.phase_step_int   = 0 <u5.0>
-	// [23: 0]         hsc.phase_step_fra   = 0 <u0.24>
-	WR(VDIN_HSC_PHASE_STEP, 0x00000000);
-	// [30:29]         hsc.repeat_pix0_num  = 1 // ? to confirm pix0 is always used
-	// [28:24]         hsc.ini_receive_num  = 4 // ? to confirm pix0 is always used
-	// [23: 0]         hsc.ini_phase        = 0
-	WR(VDIN_HSC_INI_CTRL, 0x24000000);
-
-
-	// [   25]  decimation.rst              = 0
-	// [   24]  decimation.en               = 0 ***sub_module.enable***
-	// [23:20]  decimation.phase            = 0
-	// [19:16]  decimation.ratio            = 0/(1, 1/2, ..., 1/16)
-	// [    7] asfifo_dvin.de_en            = 1
-	// [    6] asfifo_dvin.vs_en            = 1
-	// [    5] asfifo_dvin.hs_en            = 1
-	// [    4] asfifo_dvin.vs_inv           = 0/(positive-active, negative-active)
-	// [    3] asfifo_dvin.hs_inv           = 0/(positive-active, negative-active)
-	// [    2] asfifo_dvin.rst_on_vs        = 1
-	// [    1] asfifo_dvin.clr_ov_flag      = 0
-	// [    0] asfifo_dvin.rst              = 0
-	//WR(VDIN_ASFIFO_CTRL2, 0x00000000);
-        //Bit 15:8 vdi7 asfifo_ctrl
-	//Bit 7:0 vdi6 asfifo_ctrl
-	//WR(VDIN_ASFIFO_CTRL3, 0x00000000);
-
-
-	// [    0]      matrix.en               = 0 ***sub_module.enable***
-	WR(VDIN_MATRIX_CTRL, 0x00000000);
-	// [28:16]      matrix.coef00           = 0 <s2.10>
-	// [12: 0]      matrix.coef01           = 0 <s2.10>
-	WR(VDIN_MATRIX_COEF00_01, 0x00000000);
-	// [28:16]      matrix.coef02           = 0 <s2.10>
-	// [12: 0]      matrix.coef10           = 0 <s2.10>
-	WR(VDIN_MATRIX_COEF02_10, 0x00000000);
-	// [28:16]      matrix.coef11           = 0 <s2.10>
-	// [12: 0]      matrix.coef12           = 0 <s2.10>
-	WR(VDIN_MATRIX_COEF11_12, 0x00000000);
-	// [28:16]      matrix.coef20           = 0 <s2.10>
-	// [12: 0]      matrix.coef21           = 0 <s2.10>
-	WR(VDIN_MATRIX_COEF20_21, 0x00000000);
-	// [12: 0]      matrix.coef22           = 0 <s2.10>
-	WR(VDIN_MATRIX_COEF22, 0x00000000);
-	// [26:16]      matrix.offset0          = 0 <s8.2>
-	// [10: 0]      matrix.ofsset1          = 0 <s8.2>
-	WR(VDIN_MATRIX_OFFSET0_1, 0x00000000);
-	// [10: 0]      matrix.ofsset2          = 0 <s8.2>
-	WR(VDIN_MATRIX_OFFSET2, 0x00000000);
-	// [26:16]      matrix.pre_offset0      = 0 <s8.2>
-	// [10: 0]      matrix.pre_ofsset1      = 0 <s8.2>
-	WR(VDIN_MATRIX_PRE_OFFSET0_1, 0x00000000);
-	// [10: 0]      matrix.pre_ofsset2      = 0 <s8.2>
-	WR(VDIN_MATRIX_PRE_OFFSET2, 0x00000000);
-	// [11: 0]       write.lfifo_buf_size   = 0x100
-	WR(VDIN_LFIFO_CTRL,     0x00000780);
-	// [15:14]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [13:12]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [11:10]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [ 9: 8]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [ 7: 6]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [ 5: 4]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [ 3: 2]     clkgate.bbar             = 0/(auto, off, on, on)
-	// [    0]     clkgate.bbar             = 0/(auto, off!!!!!!!!)
-	WR(VDIN_COM_GCLK_CTRL, 0x00000000);
-
-
-	// [12: 0]  decimation.output_width_m1  = 0
-	WR(VDIN_INTF_WIDTHM1, 0x00000000);
-
-
-	def_canvas_id = offset? vdin_canvas_ids[1][0]:vdin_canvas_ids[0][0];
-
-	// [31:24]       write.out_ctrl         = 0x0b
-	// [   23]       write.frame_rst_on_vs  = 1
-	// [   22]       write.lfifo_rst_on_vs  = 1
-	// [   21]       write.clr_direct_done  = 0
-	// [   20]       write.clr_nr_done      = 0
-	// [   12]       write.format444        = 1/(422, 444)
-	// [   11]       write.canvas_latch_en  = 0
-	// [    9]       write.req_urgent       = 0 ***sub_module.enable***
-	// [    8]       write.req_en           = 0 ***sub_module.enable***
-	// [ 7: 0]       write.canvas           = 0
-	WR(VDIN_WR_CTRL, (0x0bc01000 | def_canvas_id));
-
-	//[8]   discard data before line fifo= 0  normal mode
-	//[7:0] write chroma addr = 1
-	WR_BITS(VDIN_WR_CTRL2, def_canvas_id+1,WRITE_CHROMA_CANVAS_ADDR_BIT,
-	                WRITE_CHROMA_CANVAS_ADDR_WID);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-                WR_BITS(VDIN_WR_CTRL2, 0,DISCARD_BEF_LINE_FIFO_BIT,
-	                DISCARD_BEF_LINE_FIFO_WID);
-	//[20:25] interger = 0
-	//[0:19] fraction = 0
-	WR(VDIN_VSC_PHASE_STEP, 0x0000000);
-	//Bit 23, vsc_en, vertical scaler enable
-	//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
-	//Bit 20:16 ini skip_line_num
-	//Bit 15:0 vscaler ini_phase
-	WR(VDIN_VSC_INI_CTRL, 0x000000);
-	//Bit 12:0, scaler input height minus 1
-	WR(VDIN_SCIN_HEIGHTM1, 0x00000);
-	//Bit 23:16, dummy component 0
-	//Bit 15:8, dummy component 1
-	//Bit 7:0, dummy component 2
-	WR(VDIN_DUMMY_DATA, 0x8080);
-	//Bit 23:16 component 0
-	//Bit 15:8  component 1
-	//Bit 7:0 component 2
-	WR(VDIN_MATRIX_HL_COLOR, 0x000000);
-	//28:16 probe x, postion
-	//12:0  probe y, position
-	WR(VDIN_MATRIX_PROBE_POS, 0x00000000);
-	//Bit 31, local dimming statistic enable
-	//Bit 28, eol enable
-	//Bit 27:25, vertical line overlap number for max finding
-	//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
-	//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
-	//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
-	//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION
-	//Bit 6:0, region read index
-	WR(VDIN_LDIM_STTS_HIST_REGION_IDX, 0x00000000);
-#endif
-	// [27:16]       write.output_hs        = 0
-	// [11: 0]       write.output_he        = 0
-	WR(VDIN_WR_H_START_END, 0x00000000);
-	// [27:16]       write.output_vs        = 0
-	// [11: 0]       write.output_ve        = 0
-	WR(VDIN_WR_V_START_END, 0x00000000);
-	// [ 6: 5]        hist.pow              = 0
-	// [ 3: 2]        hist.mux              = 0/(matrix_out, hsc_out, phsc_in)
-	// [    1]        hist.win_en           = 1
-	// [    0]        hist.read_en          = 1
-	WR(VDIN_HIST_CTRL, 0x00000003);
-	// [28:16]        hist.win_hs           = 0
-	// [12: 0]        hist.win_he           = 0
-	WR(VDIN_HIST_H_START_END, 0x00000000);
-	// [28:16]        hist.win_vs           = 0
-	// [12: 0]        hist.win_ve           = 0
-	WR(VDIN_HIST_V_START_END, 0x00000000);
-
-
-	//set VDIN_MEAS_CLK_CNTL, select XTAL clock
-	WRITE_CBUS_REG(HHI_VDIN_MEAS_CLK_CNTL, 0x00000100);
-
-	// [   18]        meas.rst              = 0
-	// [   17]        meas.widen_hs_vs_en   = 1
-	// [   16]        meas.vs_cnt_accum_en  = 0
-	// [14:12]        meas.mux              = 0/(null, 656, tvfe, cvd2, hdmi, dvin)
-	// [11: 4]        meas.vs_span_m1       = 0
-	// [ 2: 0]        meas.hs_ind           = 0
-	WR(VDIN_MEAS_CTRL0, 0x00020000);
-	// [28:16]        meas.hs_range_start   = 112  // HS range0: Line #112 ~ Line #175
-	// [12: 0]        meas.hs_range_end     = 175
-	WR(VDIN_MEAS_HS_RANGE, 0x007000af);
-
-
-
-	// [    8]        bbar.white_en         = 0
-	// [ 7: 0]        bbar.white_thr        = 0
-	WR(VDIN_BLKBAR_CTRL1, 0x00000000);
-
-
-
-
-	// [20: 8]        bbar.region_width     = 0
-	// [ 7: 5]        bbar.src_on_v         = 0/(Y, sU, sV, U, V)
-	// [    4]        bbar.search_one_step  = 0
-	// [    3]        bbar.raising_edge_rst = 0
-	// [ 2: 1]        bbar.mux              = 0/(matrix_out, hsc_out, phsc_in)
-	// [    0]        bbar.en               = 0 ***sub_module.enable***
-	WR(VDIN_BLKBAR_CTRL0 , 0x14000000);
-	// [28:16]        bbar.win_hs           = 0
-	// [12: 0]        bbar.win_he           = 0
-	WR(VDIN_BLKBAR_H_START_END, 0x00000000);
-	// [28:16]        bbar.win_vs           = 0
-	// [12: 0]        bbar.win_ve           = 0
-	WR(VDIN_BLKBAR_V_START_END, 0x00000000);
-	// [19: 0]        bbar.bblk_thr_on_bpix = 0
-	WR(VDIN_BLKBAR_CNT_THRESHOLD, 0x00000000);
-	// [28:16]        bbar.blnt_thr_on_wpix = 0
-	// [12: 0]        bbar.blnb_thr_on_wpix = 0
-	WR(VDIN_BLKBAR_ROW_TH1_TH2, 0x00000000);
-
-
-	// [28:16]   input_win.hs               = 0
-	// [12: 0]   input_win.he               = 0
-	WR(VDIN_WIN_H_START_END, 0x00000000);
-	// [28:16]   input_win.vs               = 0
-	// [12: 0]   input_win.ve               = 0
-	WR(VDIN_WIN_V_START_END, 0x00000000);
-
-}
-
-inline void vdin_hw_enable(unsigned int offset)
-{
-	/* enable video data input */
-	// [    4]  top.datapath_en  = 1
-	WR_BITS(VDIN_COM_CTRL0, 1, 4, 1);
-
-	/* mux input */
-	// [ 3: 0]  top.mux  = 0/(null, mpeg, 656, tvfe, cvd2, hdmi, dvin)
-	WR_BITS(VDIN_COM_CTRL0, 0, 0, 4);
-
-	/* enable clock of blackbar, histogram, histogram, line fifo1, matrix,
-	 * hscaler, pre hscaler, clock0
-	 */
-	// [15:14]  Enable blackbar clock       = 00/(auto, off, on, on)
-	// [13:12]  Enable histogram clock      = 00/(auto, off, on, on)
-	// [11:10]  Enable line fifo1 clock     = 00/(auto, off, on, on)
-	// [ 9: 8]  Enable matrix clock         = 00/(auto, off, on, on)
-	// [ 7: 6]  Enable hscaler clock        = 00/(auto, off, on, on)
-	// [ 5: 4]  Enable pre hscaler clock    = 00/(auto, off, on, on)
-	// [ 3: 2]  Enable clock0               = 00/(auto, off, on, on)
-	// [    0]  Enable register clock       = 00/(auto, off!!!!!!!!)
-	WR(VDIN_COM_GCLK_CTRL, 0x0);
-}
-
-
-inline void vdin_hw_disable(unsigned int offset)
-{
-	/* disable cm2 */
-	WR_BITS(VDIN_CM_BRI_CON_CTRL,0,CM_TOP_EN_BIT,CM_TOP_EN_WID);
-	/* disable video data input */
-	// [    4]  top.datapath_en  = 0
-	WR_BITS(VDIN_COM_CTRL0, 0, 4, 1);
-
-	/* mux null input */
-	// [ 3: 0]  top.mux  = 0/(null, mpeg, 656, tvfe, cvd2, hdmi, dvin)
-	WR_BITS(VDIN_COM_CTRL0, 0, 0, 4);
-
-	/* disable clock of blackbar, histogram, histogram, line fifo1, matrix,
-	 * hscaler, pre hscaler, clock0
-	 */
-	// [15:14]  Disable blackbar clock      = 01/(auto, off, on, on)
-	// [13:12]  Disable histogram clock     = 01/(auto, off, on, on)
-	// [11:10]  Disable line fifo1 clock    = 01/(auto, off, on, on)
-	// [ 9: 8]  Disable matrix clock        = 01/(auto, off, on, on)
-	// [ 7: 6]  Disable hscaler clock       = 01/(auto, off, on, on)
-	// [ 5: 4]  Disable pre hscaler clock   = 01/(auto, off, on, on)
-	// [ 3: 2]  Disable clock0              = 01/(auto, off, on, on)
-	// [    0]  Enable register clock       = 00/(auto, off!!!!!!!!)
-	WR(VDIN_COM_GCLK_CTRL, 0x5554);
-}
-
-/* get current vsync field type 0:top 1 bottom */
-inline unsigned int vdin_get_field_type(unsigned int offset)
-{
-	return RD_BITS(VDIN_COM_STATUS0, 0, 1);
-}
-
-
-
-void vdin_enable_module(unsigned int offset, bool enable)
-{
-	if (enable)
-	{
-		//set VDIN_MEAS_CLK_CNTL, select XTAL clock
-		WRITE_CBUS_REG(HHI_VDIN_MEAS_CLK_CNTL, 0x00000100);
-		//vdin_hw_enable(offset);
-		//todo: check them
-	}
-	else
-	{
-		//set VDIN_MEAS_CLK_CNTL, select XTAL clock
-		WRITE_CBUS_REG(HHI_VDIN_MEAS_CLK_CNTL, 0x00000000);
-		vdin_hw_disable(offset);
-	}
-}
-#if 0
-inline bool vdin_write_done_check(unsigned int offset, struct vdin_dev_s *devp)
-{
-
-	if (RD_BITS(VDIN_COM_STATUS0, DIRECT_DONE_STATUS_BIT, DIRECT_DONE_STATUS_WID))
-	{
-		WR_BITS(VDIN_WR_CTRL, 1, DIRECT_DONE_CLR_BIT, DIRECT_DONE_CLR_WID);
-		WR_BITS(VDIN_WR_CTRL, 0, DIRECT_DONE_CLR_BIT, DIRECT_DONE_CLR_WID);
-		devp->abnormal_cnt = 0;
-	}
-	else if ((vdin_get_active_v(offset) >= devp->v_active) &&
-			(vdin_get_active_h(offset) >= devp->h_active)
-		)
-		devp->abnormal_cnt++;
-	else
-		devp->abnormal_cnt = 0;
-
-	if (devp->abnormal_cnt > max_undone_cnt)
-	{
-		devp->abnormal_cnt = 0;
-		devp->flags |= VDIN_FLAG_FORCE_UNSTABLE;
-	}
-	//check the event
-	if (get_foreign_affairs(FOREIGN_AFFAIRS_02))
-	{
-		//clean the event flag
-		rst_foreign_affairs(FOREIGN_AFFAIRS_02);
-		//notify api to stop vdin
-		devp->flags |= VDIN_FLAG_FORCE_UNSTABLE;
-	}
-}
-#else
-inline bool vdin_write_done_check(unsigned int offset, struct vdin_dev_s *devp)
-{
-
-	if (RD_BITS(VDIN_COM_STATUS0, DIRECT_DONE_STATUS_BIT, DIRECT_DONE_STATUS_WID))
-	{
-		WR_BITS(VDIN_WR_CTRL, 1, DIRECT_DONE_CLR_BIT, DIRECT_DONE_CLR_WID);
-		WR_BITS(VDIN_WR_CTRL, 0, DIRECT_DONE_CLR_BIT, DIRECT_DONE_CLR_WID);
-		return true;
-	}
-	devp->abnormal_cnt++;
-	return false;
-}
-
-#endif
-/* check invalid vs to avoid screen flicker */
-inline bool vdin_check_vs(struct vdin_dev_s *devp)
-{
-	bool ret = false;
-	unsigned int dh = 0, dv = 0;
-
-	if ((devp->parm.port < TVIN_PORT_COMP0) || (devp->parm.port > TVIN_PORT_COMP7))
-	        return ret;
-
-	/* check vs after n*vs avoid unstable signal after TVIN_IOC_START_DEC*/
-	if (devp->vs_cnt_valid++ >= VDIN_WAIT_VALID_VS)
-		devp->vs_cnt_valid = VDIN_WAIT_VALID_VS;
-
-	/* check hcnt64/cycle to find format changed */
-	if (devp->hcnt64 < devp->hcnt64_tag)
-		dh = devp->hcnt64_tag - devp->hcnt64;
-	else
-		dh = devp->hcnt64 - devp->hcnt64_tag;
-	if (devp->cycle < devp->cycle_tag)
-		dv = devp->cycle_tag - devp->cycle;
-	else
-		dv = devp->cycle - devp->cycle_tag;
-	if ((dh > VDIN_MEAS_HSCNT_DIFF) || (dv > VDIN_MEAS_VSCNT_DIFF))
-	{
-		devp->hcnt64_tag = devp->hcnt64;
-		devp->cycle_tag  = devp->cycle;
-		if (devp->vs_cnt_valid >= VDIN_WAIT_VALID_VS)
-			devp->vs_cnt_ignore = VDIN_IGNORE_VS_CNT;
-	}
-
-	/* Do not send data of format changed to video buffer */
-	if (devp->vs_cnt_ignore)
-	{
-		devp->vs_cnt_ignore--;
-		ret = true;
-	}
-
-	return ret;
-}
-inline bool vdin_check_cycle(struct vdin_dev_s *devp)
-{
-	unsigned int stamp, cycle;
-	stamp = vdin_get_meas_vstamp(devp->addr_offset);
-
-	if (stamp < devp->stamp)
-		cycle = 0xffffffff - devp->stamp + stamp + 1;
-	else
-		cycle = stamp - devp->stamp;
-	if (cycle <= VDIN_MEAS_24M_1MS)
-		return true;
-	else
-	{
-		devp->stamp = stamp;
-		devp->cycle  = cycle;
-		return false;
-	}
-}
-inline void vdin_calculate_duration(struct vdin_dev_s *devp)
-{
-	unsigned int last_field_type;
-	struct vframe_s *curr_wr_vf = NULL;
-	//enum tvin_sig_fmt_e fmt = devp->parm.info.fmt;
-    const struct tvin_format_s *fmt_info = devp->fmt_info_p;
-    unsigned int frame_rate = (VDIN_CRYSTAL + (devp->cycle>>3))/devp->cycle;
-    enum tvin_port_e port = devp->parm.port;
-
-	curr_wr_vf = &devp->curr_wr_vfe->vf;
-	last_field_type = devp->curr_field_type;
-#ifdef VDIN_DYNAMIC_DURATION
-	devp->curr_wr_vf->duration = (devp->cycle + 125) / 250;
-#else
-
-    if ((use_frame_rate == 1) &&
-        ((port >= TVIN_PORT_HDMI0) && (port <= TVIN_PORT_HDMI7))) {
-        curr_wr_vf->duration = (devp->cycle + 125) / 250;
-    } else {
-        if (!fmt_info->duration)
-            curr_wr_vf->duration = (devp->cycle + 125) / 250;
-    }
-
-#endif
-	/* for 2D->3D mode & interlaced format, double top field duration to match software frame lock */
-#ifdef VDIN_DYNAMIC_DURATION
-	if ((devp->parm.flag & TVIN_PARM_FLAG_2D_TO_3D) &&
-			(last_field_type & VIDTYPE_INTERLACE))
-		curr_wr_vf->duration <<= 1;
-#else
-	if ((devp->parm.flag & TVIN_PARM_FLAG_2D_TO_3D) &&
-			(last_field_type & VIDTYPE_INTERLACE))
-	{
-		if (!fmt_info->duration)
-			curr_wr_vf->duration = ((devp->cycle << 1) + 125) / 250;
-		else
-			curr_wr_vf->duration = fmt_info->duration << 1;
-	}
-#endif
-}
-inline void vdin_output_ctl(unsigned int offset, unsigned int output_nr_flag)
-{
-	WR_BITS(VDIN_WR_CTRL, 1, VCP_IN_EN_BIT, VCP_IN_EN_WID);
-	if(output_nr_flag){
-		WR_BITS(VDIN_WR_CTRL, 0, VCP_WR_EN_BIT, VCP_WR_EN_WID);
-		WR_BITS(VDIN_WR_CTRL, 1, VCP_NR_EN_BIT, VCP_NR_EN_WID);
-	}
-	else{
-		WR_BITS(VDIN_WR_CTRL, 1, VCP_WR_EN_BIT, VCP_WR_EN_WID);
-		WR_BITS(VDIN_WR_CTRL, 0, VCP_NR_EN_BIT, VCP_NR_EN_WID);
-	}
-}
-
-/*
- *just for horizontal down scale src_w is origin width,dst_w is width after scale down
- */
-inline void vdin_set_hscale(unsigned int offset, unsigned int src_w, unsigned int dst_w)
-{
-
-	unsigned int filt_coef0[] =  { //bicubic
-		0x00800000, 0x007f0100, 0xff7f0200, 0xfe7f0300, 0xfd7e0500, 0xfc7e0600,
-		0xfb7d0800, 0xfb7c0900, 0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
-		0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe, 0xf76f1dfd, 0xf76d1ffd,
-		0xf76b21fd, 0xf76824fd, 0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
-		0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa, 0xf8523cfa, 0xf8503ff9,
-		0xf84d42f9, 0xf84a45f9, 0xf84848f8
-	};
-
-	unsigned int filt_coef1[] =  {//2 point bilinear
-		0x00800000, 0x007e0200, 0x007c0400, 0x007a0600, 0x00780800, 0x00760a00,
-		0x00740c00, 0x00720e00, 0x00701000, 0x006e1200, 0x006c1400, 0x006a1600,
-		0x00681800, 0x00661a00, 0x00641c00, 0x00621e00, 0x00602000, 0x005e2200,
-		0x005c2400, 0x005a2600, 0x00582800, 0x00562a00, 0x00542c00, 0x00522e00,
-		0x00503000, 0x004e3200, 0x004c3400, 0x004a3600, 0x00483800, 0x00463a00,
-		0x00443c00, 0x00423e00, 0x00404000
-	};
-
-	unsigned int filt_coef2[] = { //2 point bilinear, bank_length == 2
-		0x80000000, 0x7e020000, 0x7c040000, 0x7a060000, 0x78080000, 0x760a0000,
-		0x740c0000, 0x720e0000, 0x70100000, 0x6e120000, 0x6c140000, 0x6a160000,
-		0x68180000, 0x661a0000, 0x641c0000, 0x621e0000, 0x60200000, 0x5e220000,
-		0x5c240000, 0x5a260000, 0x58280000, 0x562a0000, 0x542c0000, 0x522e0000,
-		0x50300000, 0x4e320000, 0x4c340000, 0x4a360000, 0x48380000, 0x463a0000,
-		0x443c0000, 0x423e0000, 0x40400000
-	};
-	int horz_phase_step,i;
-	if(!dst_w)
-	{
-		pr_err("[vdin..]%s parameter dst_w error.\n",__func__);
-		return;
-	}
-	//disable hscale&pre hscale
-	WR_BITS(VDIN_SC_MISC_CTRL, 0, PRE_HSCL_EN_BIT, PRE_HSCL_EN_WID);
-	WR_BITS(VDIN_SC_MISC_CTRL, 0, HSCL_EN_BIT, HSCL_EN_WID);
-	//write horz filter coefs
-	WR(VDIN_SCALE_COEF_IDX, 0x0100);
-	for (i = 0; i < 33; i++)
-	{
-		WR(VDIN_SCALE_COEF, filt_coef0[i]); //bicubic
-	}
-
-	horz_phase_step = (src_w << 20) / dst_w;
-	horz_phase_step = (horz_phase_step << 4);
-
-	WR(VDIN_WIDTHM1I_WIDTHM1O, ((src_w - 1) << WIDTHM1I_BIT) |
-			(dst_w  - 1)
-		      );
-
-	WR(VDIN_HSC_PHASE_STEP, horz_phase_step);
-	WR(VDIN_HSC_INI_CTRL, (1 << HSCL_RPT_P0_NUM_BIT) |//hsc_p0_num
-			( 4 << HSCL_INI_RCV_NUM_BIT) |//hsc_ini_rcv_num
-			( 0 << HSCL_INI_PHASE_BIT)//hsc_ini_phase
-		      );
-
-	WR(VDIN_SC_MISC_CTRL,
-			(0 << INIT_PIX_IN_PTR_BIT) |
-			(0 << PRE_HSCL_EN_BIT) |//pre_hscale_en
-			(1 << HSCL_EN_BIT) |//hsc_en
-			(1 << SHORT_LN_OUT_EN_BIT) |//short_lineo_en
-			(0 << HSCL_NEAREST_EN_BIT) |//nearest_en
-			(0 << PHASE0_ALWAYS_EN_BIT) |//phase0_always_en
-			(4 << HSCL_BANK_LEN_BIT)//hsc_bank_length
-		      );
-}
-
-
-/*
- *just for veritical scale src_w is origin height,dst_h is the height after scale
- */
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-inline void vdin_set_vscale(unsigned int offset, unsigned int src_h,  unsigned int dst_h)
-{
-	int veri_phase_step,tmp;
-	if(!dst_h){
-		pr_err("[vdin..]%s parameter dst_h error.\n",__func__);
-		return;
-	}
-	//disable vscale
-	WR_BITS(VDIN_VSC_INI_CTRL, 0, VSC_EN_BIT, VSC_EN_WID);
-
-	veri_phase_step = (src_h << 20) / dst_h;
-	tmp = veri_phase_step >> 25;
-	if(tmp){
-		pr_err("[vdin..]%s error. cannot be divided more than 31.9999.\n",__func__);
-		return;
-	}
-	WR(VDIN_VSC_PHASE_STEP, veri_phase_step);
-	if(!(veri_phase_step>>20)) {//scale up the bit should be 1
-		WR_BITS(VDIN_VSC_INI_CTRL, 1, VSC_PHASE0_ALWAYS_EN_BIT, VSC_PHASE0_ALWAYS_EN_WID);
-		//scale phase is 0
-		WR_BITS(VDIN_VSC_INI_CTRL, 0, VSCALER_INI_PHASE_BIT, VSCALER_INI_PHASE_WID);
-	} else {
-		WR_BITS(VDIN_VSC_INI_CTRL, 0, VSC_PHASE0_ALWAYS_EN_BIT, VSC_PHASE0_ALWAYS_EN_WID);
-		//scale phase is 0x8000
-		WR_BITS(VDIN_VSC_INI_CTRL, 0x8000, VSCALER_INI_PHASE_BIT, VSCALER_INI_PHASE_WID);
-	}
-	//skip 0 line in the beginning
-	WR_BITS(VDIN_VSC_INI_CTRL, 0, INI_SKIP_LINE_NUM_BIT, INI_SKIP_LINE_NUM_WID);
-
-	WR(VDIN_SCIN_HEIGHTM1, src_h -1);
-	WR(VDIN_DUMMY_DATA, 0x008080);
-	//enable vscale
-	WR_BITS(VDIN_VSC_INI_CTRL, 1, VSC_EN_BIT, VSC_EN_WID);
-
-}
-#endif
-
-inline void vdin_set_hvscale(struct vdin_dev_s *devp)
-{
-        unsigned int offset = devp->addr_offset;
-    
-        if (((devp->scaler4w < devp->h_active) && (devp->scaler4w != 0)) ||
-                (devp->h_active > TVIN_MAX_HACTIVE)	&&
-                ((devp->parm.port >= TVIN_PORT_HDMI0)&&(devp->parm.port <= TVIN_PORT_HDMI7))
-           ){
-            if ((devp->h_active > TVIN_MAX_HACTIVE)&&(devp->scaler4w == 0)) {
-                vdin_set_hscale(offset, devp->h_active, TVIN_MAX_HACTIVE);
-                devp->h_active = TVIN_MAX_HACTIVE;
-            } else {
-                vdin_set_hscale(offset, devp->h_active, devp->scaler4w);
-                devp->h_active = devp->scaler4w;
-            }
-            pr_info("[vdin.%d] dst hactive:%u.\n",devp->index, devp->h_active);
-        } //else
-        //  pr_err("[vdin%x..] dst hactive:0x%x not valid.\n",devp->addr_offset, dst_w);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-        if ((devp->scaler4h < devp->v_active) && (devp->scaler4h != 0)) {
-                vdin_set_vscale(offset, devp->v_active, devp->scaler4h);
-                devp->v_active = devp->scaler4h;
-                pr_info("[vdin.%d] dst vactive:%u.\n",devp->index, devp->v_active);
-        } //else
-        //  pr_err("[vdin%x..] dst vactive:0x%x not valid.\n",devp->addr_offset, dst_h);
-#endif
-
-}
-
-inline void vdin_wr_reverse(unsigned int offset, bool hreverse, bool vreverse)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-	if(hreverse)
-		WR_BITS(VDIN_WR_H_START_END, 1,
-				HORIZONTAL_REVERSE_BIT, HORIZONTAL_REVERSE_WID);
-	else
-		WR_BITS(VDIN_WR_H_START_END, 0,
-				HORIZONTAL_REVERSE_BIT, HORIZONTAL_REVERSE_WID);
-	if(vreverse)
-		WR_BITS(VDIN_WR_V_START_END, 1,
-				VERTICAL_REVERSE_BIT, VERTICAL_REVERSE_WID);
-	else
-		WR_BITS(VDIN_WR_V_START_END, 0,
-				VERTICAL_REVERSE_BIT, VERTICAL_REVERSE_WID);
-#endif
-}
-
-void vdin_bypass_isp(unsigned int offset)
-{
-	WR_BITS(VDIN_CM_BRI_CON_CTRL, 0,CM_TOP_EN_BIT, CM_TOP_EN_WID);
-	WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX_EN_BIT, VDIN_MATRIX_EN_WID);
-	WR_BITS(VDIN_MATRIX_CTRL, 0, VDIN_MATRIX1_EN_BIT, VDIN_MATRIX1_EN_WID);
-}
-void set_chroma_regs(unsigned int offset, unsigned int h_active,unsigned int v_active)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-
-        int i,j,k;
-        int cm2_cfg_reg[640];
-        int tmp[20];
-        int tmp_cfg;
-
-        //tmp_cfg = -8;
-        for ( i=0; i<640 ; i=i+1 ) {
-                //tmp_cfg = tmp_cfg>5 ? -5 : (tmp_cfg+1); 
-                //cm2_cfg_reg[i] = tmp_cfg;
-                cm2_cfg_reg[i] = (i&15)-8;
-        }
-
-        for ( j = 0; j<32; j++) {
-                WR(VDIN_CHROMA_ADDR_PORT, 256+j*8);
-                for ( i = 0; i<20; i++) {
-                        tmp[i] = cm2_cfg_reg[j+32*i];
-                }
-                for ( k = 0; k<5; k++) {
-                        WR(VDIN_CHROMA_DATA_PORT,( ((tmp[k*4+3]&255)<<24)+
-                                      ((tmp[k*4+2]&255)<<16)+
-                                      ((tmp[k*4+1]&255)<< 8)+
-                                      ((tmp[k*4+0]&255)    ) ) );
-                }
-        }
-
-
-        WR(VDIN_CHROMA_ADDR_PORT, SAT_BYYB_NODE_REG0);
-        WR(VDIN_CHROMA_DATA_PORT, 0xfffefdfc);
-
-        WR(VDIN_CHROMA_ADDR_PORT, SAT_BYYB_NODE_REG1);
-        WR(VDIN_CHROMA_DATA_PORT, 0x03020100);
-
-        WR(VDIN_CHROMA_ADDR_PORT, SAT_BYYB_NODE_REG2);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00000004);
-
-        WR(VDIN_CHROMA_ADDR_PORT, SAT_SRC_NODE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x0bb80400);
-
-        WR(VDIN_CHROMA_ADDR_PORT, CM_ENH_SFT_MODE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00000000);
-
-        WR(VDIN_CHROMA_ADDR_PORT, FRM_SIZE_REG);
-        //Wr(VDIN0_CHROMA_DATA_PORT, 0x02d00500);
-        WR(VDIN_CHROMA_DATA_PORT, v_active<<16|h_active);
-
-        WR(VDIN_CHROMA_ADDR_PORT, FITLER_CFG_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x0000001f);
-
-        WR(VDIN_CHROMA_ADDR_PORT, CM_GLOBAL_GAIN_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x01000000);
-
-        WR(VDIN_CHROMA_ADDR_PORT, CM_ENH_CTL_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00000077);
-
-        WR(VDIN_CHROMA_ADDR_PORT, ROI_X_SCOPE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x02000100);
-
-        WR(VDIN_CHROMA_ADDR_PORT, ROI_Y_SCOPE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x03000200);
-
-        WR(VDIN_CHROMA_ADDR_PORT, POI_XY_DIR_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00110011);
-
-        WR(VDIN_CHROMA_ADDR_PORT, COI_Y_SCOPE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00008000);
-
-        WR(VDIN_CHROMA_ADDR_PORT, COI_H_SCOPE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00800000);
-
-        WR(VDIN_CHROMA_ADDR_PORT, COI_S_SCOPE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00800000);
-
-        WR(VDIN_CHROMA_ADDR_PORT, IFO_MODE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x0000000c);
-
-        WR(VDIN_CHROMA_ADDR_PORT, POI_RPL_MODE_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x00000000);
-
-        WR(VDIN_CHROMA_ADDR_PORT, DEMO_OWR_YHS_REG);
-        WR(VDIN_CHROMA_DATA_PORT, 0x33222111);
-	//enable cm2
-	WR_BITS(VDIN_CM_BRI_CON_CTRL,1,CM_TOP_EN_BIT,CM_TOP_EN_WID);
-	pr_info("%s cm2 init ok.\n",__func__);
-#endif
-}
-void vdin_set_cm2(unsigned int offset,unsigned int w,unsigned int h,unsigned int *cm2)
-{
-	unsigned int i=0,j=0,start_addr=0x100;
-
-    if(!cm_enable)
-	return;
-	WR_BITS(VDIN_CM_BRI_CON_CTRL,0,CM_TOP_EN_BIT,CM_TOP_EN_WID);
-	for(i=0;i<160;i++){
-		j=i/5;
-		WR(VDIN_CHROMA_ADDR_PORT,start_addr+(j<<3)+(i%5));
-		WR(VDIN_CHROMA_DATA_PORT,cm2[i]);
-	}
-	for(i=0;i<28;i++){
-		WR(VDIN_CHROMA_ADDR_PORT,0x200+i);
-		WR(VDIN_CHROMA_DATA_PORT,cm2[160+i]);
-	}
-	/*config cm2 frame size*/
-	WR(VDIN_CHROMA_ADDR_PORT,FRM_SIZE_REG);
-	WR(VDIN_CHROMA_DATA_PORT,h<<16|w);
-	
-    WR_BITS(VDIN_CM_BRI_CON_CTRL, 1, CM_TOP_EN_BIT,CM_TOP_EN_WID);
-}
diff --git a/drivers/amlogic/tvin/vdin/vdin_ctl.h b/drivers/amlogic/tvin/vdin/vdin_ctl.h
deleted file mode 100755
index 6b65a77eb43c..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_ctl.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * VDIN driver
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_VDIN_CTL_H
-#define __TVIN_VDIN_CTL_H
-
-
-#include <linux/amlogic/amports/vframe.h>
-
-#include "vdin_drv.h"
-
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-/*
-YUV601:  SDTV BT.601            YCbCr (16~235, 16~240, 16~240)
-YUV601F: SDTV BT.601 Full_Range YCbCr ( 0~255,  0~255,  0~255)
-YUV709:  HDTV BT.709            YCbCr (16~235, 16~240, 16~240)
-YUV709F: HDTV BT.709 Full_Range YCbCr ( 0~255,  0~255,  0~255)
-RGBS:                       StudioRGB (16~235, 16~235, 16~235)
-RGB:                              RGB ( 0~255,  0~255,  0~255)
- */
-#define WR(x,val)                                       WRITE_VCBUS_REG(x+offset,val)
-#define WR_BITS(x,val,start,length)                     WRITE_VCBUS_REG_BITS(x+offset,val,start,length)
-#define RD(x)                                           READ_VCBUS_REG(x+offset)
-#define RD_BITS(x,start,length)                         READ_VCBUS_REG_BITS(x+offset,start,length)
-
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-#define WRITE_VCBUS_REG(x,val)                          WRITE_CBUS_REG(x,val)
-#define WRITE_VCBUS_REG_BITS(x,val,start,length)        WRITE_CBUS_REG_BITS(x,val,start,length)
-#define READ_VCBUS_REG(x)                               READ_CBUS_REG(x)
-#define READ_VCBUS_REG_BITS(x,start,length)             READ_CBUS_REG_BITS(x,start,length)
-#endif
-
-typedef enum vdin_matrix_csc_e {
-        VDIN_MATRIX_NULL = 0,
-        VDIN_MATRIX_XXX_YUV601_BLACK,
-        VDIN_MATRIX_RGB_YUV601,
-        VDIN_MATRIX_GBR_YUV601,
-        VDIN_MATRIX_BRG_YUV601,
-        VDIN_MATRIX_YUV601_RGB,
-        VDIN_MATRIX_YUV601_GBR,
-        VDIN_MATRIX_YUV601_BRG,
-        VDIN_MATRIX_RGB_YUV601F,
-        VDIN_MATRIX_YUV601F_RGB,
-        VDIN_MATRIX_RGBS_YUV601,
-        VDIN_MATRIX_YUV601_RGBS,
-        VDIN_MATRIX_RGBS_YUV601F,
-        VDIN_MATRIX_YUV601F_RGBS,
-        VDIN_MATRIX_YUV601F_YUV601,
-        VDIN_MATRIX_YUV601_YUV601F,
-        VDIN_MATRIX_RGB_YUV709,
-        VDIN_MATRIX_YUV709_RGB,
-        VDIN_MATRIX_YUV709_GBR,
-        VDIN_MATRIX_YUV709_BRG,
-        VDIN_MATRIX_RGB_YUV709F,
-        VDIN_MATRIX_YUV709F_RGB,
-        VDIN_MATRIX_RGBS_YUV709,
-        VDIN_MATRIX_YUV709_RGBS,
-        VDIN_MATRIX_RGBS_YUV709F,
-        VDIN_MATRIX_YUV709F_RGBS,
-        VDIN_MATRIX_YUV709F_YUV709,
-        VDIN_MATRIX_YUV709_YUV709F,
-        VDIN_MATRIX_YUV601_YUV709,
-        VDIN_MATRIX_YUV709_YUV601,
-        VDIN_MATRIX_YUV601_YUV709F,
-        VDIN_MATRIX_YUV709F_YUV601,
-        VDIN_MATRIX_YUV601F_YUV709,
-        VDIN_MATRIX_YUV709_YUV601F,
-        VDIN_MATRIX_YUV601F_YUV709F,
-        VDIN_MATRIX_YUV709F_YUV601F,
-        VDIN_MATRIX_RGBS_RGB,
-        VDIN_MATRIX_RGB_RGBS,
-} vdin_matrix_csc_t;
-
-// ***************************************************************************
-// *** structure definitions *********************************************
-// ***************************************************************************
-typedef struct vdin_matrix_lup_s {
-        unsigned int pre_offset0_1;
-        unsigned int pre_offset2;
-        unsigned int coef00_01;
-        unsigned int coef02_10;
-        unsigned int coef11_12;
-        unsigned int coef20_21;
-        unsigned int coef22;
-        unsigned int post_offset0_1;
-        unsigned int post_offset2;
-} vdin_matrix_lup_t;
-
-typedef struct vdin_stat_s {
-        unsigned int   sum_luma;  // VDIN_HIST_LUMA_SUM_REG
-        unsigned int   sum_pixel; // VDIN_HIST_PIX_CNT_REG
-} vdin_stat_t;
-
-#ifdef AML_LOCAL_DIMMING
-struct ldim_max_s{
-    // general parameters
-    int ld_pic_rowmax;
-    int ld_pic_colmax;
-    int ld_stamax_hidx[9];  // U12* 9
-    int ld_stamax_vidx[9];  // u12x 9
-};
-#endif
-
-typedef struct vdin_hist_cfg_s {
-        unsigned int                pow;
-        unsigned int                win_en;
-        unsigned int                rd_en;
-        unsigned int                hstart;
-        unsigned int                hend;
-        unsigned int                vstart;
-        unsigned int                vend;
-} vdin_hist_cfg_t;
-
-typedef struct vdin_cm2_s {
-	unsigned short addr;
-	unsigned int   mask;
-	unsigned int   value;
-} vdin_cm2_t;
-
-// *****************************************************************************
-// ******** GLOBAL FUNCTION CLAIM ********
-// *****************************************************************************
-extern void vdin_set_vframe_prop_info(struct vframe_s *vf, struct vdin_dev_s *devp);
-extern void vdin_get_format_convert(struct vdin_dev_s *devp);
-extern void vdin_set_all_regs(struct vdin_dev_s *devp);
-extern void vdin_set_default_regmap(unsigned int offset);
-extern void vdin_set_def_wr_canvas(struct vdin_dev_s *devp);
-extern void vdin_hw_enable(unsigned int offset);
-extern void vdin_hw_disable(unsigned int offset);
-extern void vdin_set_meas_mux(unsigned int offset, enum tvin_port_e port_);
-extern unsigned int vdin_get_field_type(unsigned int offset);
-extern void vdin_set_cutwin(struct vdin_dev_s *devp);
-extern void vdin_set_decimation(struct vdin_dev_s *devp);
-extern unsigned int vdin_get_meas_hcnt64(unsigned int offset);
-extern unsigned int vdin_get_meas_vstamp(unsigned int offset);
-extern unsigned int vdin_get_active_h(unsigned int offset);
-extern unsigned int vdin_get_active_v(unsigned int offset);
-extern unsigned int vdin_get_total_v(unsigned int offset);
-extern unsigned int vdin_get_canvas_id(unsigned int offset);
-extern void vdin_set_canvas_id(unsigned int offset, unsigned int canvas_id);
-extern unsigned int vdin_get_chma_canvas_id(unsigned int offset);
-extern void vdin_set_chma_canvas_id(unsigned int offset, unsigned int canvas_id);
-extern void vdin_enable_module(unsigned int offset, bool enable);
-extern void vdin_set_matrix(struct vdin_dev_s *devp);
-void vdin_set_matrixs(struct vdin_dev_s *devp, unsigned char no, enum vdin_format_convert_e csc);
-extern void vdin_set_matrix_blank(struct vdin_dev_s *devp);
-extern void vdin_delay_line(unsigned short num,unsigned int offset);
-extern void set_wr_ctrl(int h_pos,int v_pos,struct vdin_dev_s *devp);
-extern bool vdin_check_cycle(struct vdin_dev_s *devp);
-extern bool vdin_write_done_check(unsigned int offset, struct vdin_dev_s *devp);
-extern bool vdin_check_vs(struct vdin_dev_s *devp);
-extern void vdin_calculate_duration(struct vdin_dev_s *devp);
-extern void vdin_output_ctl(unsigned int offset, unsigned int output_flag);
-extern void vdin_wr_reverse(unsigned int offset, bool hreverse, bool vreverse);
-extern void vdin_set_hvscale(struct vdin_dev_s *devp);
-extern void set_chroma_regs(unsigned int offset, unsigned int h_active,unsigned int v_active);
-extern void vdin_set_cm2(unsigned int offset,unsigned int w,unsigned int h,unsigned int *data);
-extern void vdin_bypass_isp(unsigned int offset);
-#endif
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.c b/drivers/amlogic/tvin/vdin/vdin_drv.c
deleted file mode 100755
index 641898b8e795..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_drv.c
+++ /dev/null
@@ -1,2975 +0,0 @@
-/*
- * VDIN driver
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *		   Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-/* Standard Linux Headers */
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/cdev.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/errno.h>
-#include <asm/uaccess.h>
-#include <linux/delay.h>
-#include <linux/workqueue.h>
-#include <linux/time.h>
-#include <linux/mm.h>
-#include <asm/fiq.h>
-#include <asm/div64.h>
-#include <linux/of.h>
-#include <linux/of_fdt.h>
-/* Amlogic Headers */
-#include <linux/amlogic/amports/canvas.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vframe_receiver.h>
-#include <linux/amlogic/amports/timestamp.h>
-#include <linux/amlogic/amports/tsync.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include <linux/amlogic/aml_common.h>
-#include <mach/irqs.h>
-#include <mach/mod_gate.h>
-#include <mach/vpu.h>
-/* Local Headers */
-#include "../tvin_global.h"
-#include "../tvin_format_table.h"
-#include "../tvin_frontend.h"
-#include "vdin_regs.h"
-#include "vdin_drv.h"
-#include "vdin_ctl.h"
-#include "vdin_sm.h"
-#include "vdin_vf.h"
-#include "vdin_canvas.h"
-
-
-#define VDIN_NAME		"vdin"
-#define VDIN_DRV_NAME		"vdin"
-#define VDIN_MOD_NAME		"vdin"
-#define VDIN_DEV_NAME		"vdin"
-#define VDIN_CLS_NAME		"vdin"
-#define PROVIDER_NAME		"vdin"
-
-#define SMOOTH_DEBUG
-
-#define VDIN_PUT_INTERVAL		(HZ/100)   //10ms, #define HZ 100
-
-#define INVALID_VDIN_INPUT		0xffffffff
-
-static dev_t vdin_devno;
-static struct class *vdin_clsp;
-
-unsigned int vdin_addr_offset[VDIN_MAX_DEVS] = {0x00, 0x70};
-struct vdin_dev_s *vdin_devp[VDIN_MAX_DEVS];
-static int callmaster_status = 0;
-
-
-
-
-/*
- * canvas_config_mode
- * 0: canvas_config in driver probe
- * 1: start cofig
- * 2: auto config
- */
-static int canvas_config_mode = 2;
-module_param(canvas_config_mode, int, 0664);
-MODULE_PARM_DESC(canvas_config_mode, "canvas configure mode");
-
-static int work_mode_simple = 0;
-module_param(work_mode_simple, bool, 0664);
-MODULE_PARM_DESC(work_mode_simple, "enable/disable simple work mode");
-
-static char *first_field_type = NULL;
-module_param(first_field_type, charp, 0664);
-MODULE_PARM_DESC(first_field_type, "first field type in simple work mode");
-
-static int max_ignore_frames = 0;
-module_param(max_ignore_frames, int, 0664);
-MODULE_PARM_DESC(max_ignore_frames, "ignore first <n> frames");
-
-static int ignore_frames = 0;
-module_param(ignore_frames, int, 0664);
-MODULE_PARM_DESC(ignore_frames, "ignore first <n> frames");
-
-static int start_provider_delay = 0;
-module_param(start_provider_delay, int, 0664);
-MODULE_PARM_DESC(start_provider_delay, "ignore first <n> frames");
-static bool vdin_dbg_en = 0;
-module_param(vdin_dbg_en,bool,0664);
-MODULE_PARM_DESC(vdin_dbg_en,"enable/disable vdin debug information");
-
-static bool reverse_flag = false;
-module_param(reverse_flag,bool,0644);
-MODULE_PARM_DESC(reverse_flag,"reverse/disreverse vdin buffer & osd");
-
-static bool invert_top_bot = false;
-module_param(invert_top_bot,bool,0644);
-MODULE_PARM_DESC(invert_top_bot,"invert field type top or bottom");
-
-static unsigned short v_cut_offset = 0;
-module_param(v_cut_offset,ushort,0664);
-MODULE_PARM_DESC(v_cut_offset,"the cut window vertical offset for isp");
-
-/*
-*the check flag in vdin_isr
-*bit0:bypass stop check,bit1:bypass cyc check
-*bit2:bypass vsync check,bit3:bypass vga check
-*/
-static unsigned int isr_flag = 0;
-module_param(isr_flag,uint,0664);
-MODULE_PARM_DESC(isr_flag,"flag which affect the skip field");
-
-static unsigned int irq_cnt = 0;
-module_param(irq_cnt,uint,0664);
-MODULE_PARM_DESC(irq_cnt,"counter of irq");
-
-static int irq_max_count = 0;
-
-static irqreturn_t vdin_isr_simple(int irq, void *dev_id);
-static irqreturn_t vdin_isr(int irq, void *dev_id);
-static irqreturn_t vdin_v4l2_isr(int irq, void *dev_id);
-
-static u32 vdin_get_curr_field_type(struct vdin_dev_s *devp)
-{
-	u32 field_status;
-	u32 type = VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD ;
-	//struct tvin_parm_s *parm = &devp->parm;
-	const struct tvin_format_s *fmt_info = devp->fmt_info_p;
-
-	if (fmt_info->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE){
-		type |= VIDTYPE_PROGRESSIVE;
-	}
-	else{
-		field_status = vdin_get_field_type(devp->addr_offset);
-                if(invert_top_bot)
-                        type |= field_status ? VIDTYPE_INTERLACE_TOP : VIDTYPE_INTERLACE_BOTTOM;
-                else
-		        type |= field_status ? VIDTYPE_INTERLACE_BOTTOM : VIDTYPE_INTERLACE_TOP;
-	}
-	if ((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV444) ||
-			(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV444))
-		type |= VIDTYPE_VIU_444;
-	else if ((devp->format_convert == VDIN_FORMAT_CONVERT_YUV_YUV422) ||
-			(devp->format_convert == VDIN_FORMAT_CONVERT_RGB_YUV422))
-		type |= VIDTYPE_VIU_422;
-	else if(devp->prop.dest_cfmt == TVIN_NV21)
-	{
-		type |= VIDTYPE_VIU_NV21;
-		type &= (~VIDTYPE_VIU_SINGLE_PLANE);
-	}
-        else if(devp->prop.dest_cfmt == TVIN_NV12)
-        {
-		//type |= VIDTYPE_VIU_NV12;
-		type &= (~VIDTYPE_VIU_SINGLE_PLANE);
-
-        }
-	return type;
-}
-
-void set_invert_top_bot(bool invert_flag)
-{
-    invert_top_bot = invert_flag;
-}
-
-
-void vdin_timer_func(unsigned long arg)
-{
-	struct vdin_dev_s *devp = (struct vdin_dev_s *)arg;
-
-	/* state machine routine */
-	tvin_smr(devp);
-	/* add timer */
-	devp->timer.expires = jiffies + VDIN_PUT_INTERVAL;
-	add_timer(&devp->timer);
-}
-static void parse_param(char *buf_orig,char **parm)
-{
-	char *ps, *token;
-	unsigned int n=0;
-	ps = buf_orig;
-        while(1) {
-                token = strsep(&ps, " \n");
-                if (token == NULL)
-                        break;
-                if (*token == '\0')
-                        continue;
-                parm[n++] = token;
-        }
-}
-
-static ssize_t sig_det_show(struct device *dev,struct device_attribute *attr,char *buf)
-{
-	return sprintf(buf,"%d\n",callmaster_status);
-}
-
-static ssize_t sig_det_store(struct device *dev,struct device_attribute *attr,const char *buf,size_t len)
-{
-	enum tvin_port_e port = TVIN_PORT_NULL;
-	tvin_frontend_t *frontend = NULL;
-	struct vdin_dev_s *devp = dev_get_drvdata(dev);
-	if(!buf)
-		return len;
-	port = simple_strtol(buf,NULL,10);
-	frontend = tvin_get_frontend(port,0);
-	if(frontend&&frontend->dec_ops&&frontend->dec_ops->callmaster_det){
-		/*call the frontend det function*/
-		callmaster_status = frontend->dec_ops->callmaster_det(port,frontend);
-		//pr_info("%d\n",callmaster_status);
-	}
-	printk("[vdin.%d]:%s callmaster_status=%d,port=[%s]\n",devp->index,__func__,callmaster_status,tvin_port_str(port));
-	return len;
-}
-static DEVICE_ATTR(sig_det, 0664, sig_det_show, sig_det_store);
-
-static const struct vframe_operations_s vdin_vf_ops =
-{
-	.peek = vdin_vf_peek,
-	.get  = vdin_vf_get,
-	.put  = vdin_vf_put,
-	.vf_states = vdin_vf_states,
-};
-
-
-/*
- * 1. find the corresponding frontend according to the port & save it.
- * 2. set default register, including:
- *		a. set default write canvas address.
- *		b. mux null input.
- *		c. set clock auto.
- *		a&b will enable hw work.
- * 3. call the callback function of the frontend to open.
- * 4. regiseter provider.
- * 5. create timer for state machine.
- *
- * port: the port suported by frontend
- * index: the index of frontend
- * 0 success, otherwise failed
- */
-static int vdin_open_fe(enum tvin_port_e port, int index,  struct vdin_dev_s *devp)
-{
-	struct tvin_frontend_s *fe = tvin_get_frontend(port, index);
-	int ret = 0;
-	if (!fe) {
-		pr_err("%s(%d): not supported port 0x%x \n", __func__, devp->index, port);
-		return -1;
-	}
-
-	devp->frontend = fe;
-	devp->parm.port        = port;
-	devp->parm.info.fmt    = TVIN_SIG_FMT_NULL;
-	devp->parm.info.status = TVIN_SIG_STATUS_NULL;
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-	devp->cvbs_pos_chg = TVIN_CVBS_POS_NULL;  //init position value
-#endif
-	devp->dec_enable = 1;  //enable decoder
-
-	vdin_set_default_regmap(devp->addr_offset);
-
-	if (devp->frontend->dec_ops && devp->frontend->dec_ops->open)
-		ret = devp->frontend->dec_ops->open(devp->frontend, port);
-	/* check open status */
-	if (ret)
-	    return 1;
-
-	/* init vdin state machine */
-	tvin_smr_init(devp->index);
-	init_timer(&devp->timer);
-	devp->timer.data = (ulong) devp;
-	devp->timer.function = vdin_timer_func;
-	devp->timer.expires = jiffies + VDIN_PUT_INTERVAL;
-	add_timer(&devp->timer);
-
-	pr_info("%s port:0x%x ok\n", __func__, port);
-	return 0;
-}
-
-/*
- *
- * 1. disable hw work, including:
- *		a. mux null input.
- *		b. set clock off.
- * 2. delete timer for state machine.
- * 3. unregiseter provider & notify receiver.
- * 4. call the callback function of the frontend to close.
- *
- */
-static void vdin_close_fe(struct vdin_dev_s *devp)
-{
-	/* avoid null pointer oops */
-	if (!devp || !devp->frontend)
-		return;
-	devp->dec_enable = 0;  //disable decoder
-
-	vdin_hw_disable(devp->addr_offset);
-	del_timer_sync(&devp->timer);
-	if (devp->frontend && devp->frontend->dec_ops->close) {
-		devp->frontend->dec_ops->close(devp->frontend);
-		devp->frontend = NULL;
-	}
-	devp->parm.port = TVIN_PORT_NULL;
-	devp->parm.info.fmt  = TVIN_SIG_FMT_NULL;
-	devp->parm.info.status = TVIN_SIG_STATUS_NULL;
-
-	pr_info("%s ok\n", __func__);
-}
-
-static inline void vdin_set_source_type(struct vdin_dev_s *devp, struct vframe_s *vf)
-{
-	switch (devp->parm.port)
-	{
-		case TVIN_PORT_CVBS0:
-			vf->source_type= VFRAME_SOURCE_TYPE_TUNER;
-			break;
-		case TVIN_PORT_CVBS1:
-		case TVIN_PORT_CVBS2:
-		case TVIN_PORT_CVBS3:
-		case TVIN_PORT_CVBS4:
-		case TVIN_PORT_CVBS5:
-		case TVIN_PORT_CVBS6:
-		case TVIN_PORT_CVBS7:
-			vf->source_type = VFRAME_SOURCE_TYPE_CVBS;
-			break;
-		case TVIN_PORT_COMP0:
-		case TVIN_PORT_COMP1:
-		case TVIN_PORT_COMP2:
-		case TVIN_PORT_COMP3:
-		case TVIN_PORT_COMP4:
-		case TVIN_PORT_COMP5:
-		case TVIN_PORT_COMP6:
-		case TVIN_PORT_COMP7:
-			vf->source_type = VFRAME_SOURCE_TYPE_COMP;
-			break;
-		default:
-			vf->source_type = VFRAME_SOURCE_TYPE_OTHERS;
-			break;
-	}
-}
-
-
-
-static inline void vdin_set_source_mode(struct vdin_dev_s *devp, struct vframe_s *vf)
-{
-	switch (devp->parm.info.fmt)
-	{
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-			vf->source_mode = VFRAME_SOURCE_MODE_NTSC;
-			break;
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-			vf->source_mode = VFRAME_SOURCE_MODE_PAL;
-			break;
-		case TVIN_SIG_FMT_CVBS_SECAM:
-			vf->source_mode = VFRAME_SOURCE_MODE_SECAM;
-			break;
-		default:
-			vf->source_mode = VFRAME_SOURCE_MODE_OTHERS;
-			break;
-	}
-}
-
-/*
- * 480p/i = 9:8
- * 576p/i = 16:15
- * 720p and 1080p/i = 1:1
- * All VGA format = 1:1
- */
-static void vdin_set_pixel_aspect_ratio(struct vdin_dev_s *devp, struct vframe_s *vf)
-{
-	switch (devp->parm.info.fmt)
-	{
-		/* 480P */
-		case TVIN_SIG_FMT_COMP_480P_60HZ_D000:
-		case TVIN_SIG_FMT_HDMI_640X480P_60HZ:
-		case TVIN_SIG_FMT_HDMI_720X480P_60HZ:
-		case TVIN_SIG_FMT_HDMI_1440X480P_60HZ:
-		case TVIN_SIG_FMT_HDMI_2880X480P_60HZ:
-		case TVIN_SIG_FMT_HDMI_720X480P_120HZ:
-		case TVIN_SIG_FMT_HDMI_720X480P_240HZ:
-		case TVIN_SIG_FMT_HDMI_720X480P_60HZ_FRAME_PACKING:
-		case TVIN_SIG_FMT_CAMERA_640X480P_30HZ:
-			/* 480I */
-		case TVIN_SIG_FMT_CVBS_NTSC_M:
-		case TVIN_SIG_FMT_CVBS_NTSC_443:
-		case TVIN_SIG_FMT_CVBS_PAL_M:
-		case TVIN_SIG_FMT_CVBS_PAL_60:
-		case TVIN_SIG_FMT_COMP_480I_59HZ_D940:
-		case TVIN_SIG_FMT_HDMI_1440X480I_60HZ:
-		case TVIN_SIG_FMT_HDMI_2880X480I_60HZ:
-		case TVIN_SIG_FMT_HDMI_1440X480I_120HZ:
-		case TVIN_SIG_FMT_HDMI_1440X480I_240HZ:
-		case TVIN_SIG_FMT_BT656IN_480I_60HZ:
-		case TVIN_SIG_FMT_BT601IN_480I_60HZ:
-			vf->pixel_ratio = PIXEL_ASPECT_RATIO_8_9;
-			break;
-			/* 576P */
-		case TVIN_SIG_FMT_COMP_576P_50HZ_D000:
-		case TVIN_SIG_FMT_HDMI_720X576P_50HZ:
-		case TVIN_SIG_FMT_HDMI_1440X576P_50HZ:
-		case TVIN_SIG_FMT_HDMI_2880X576P_60HZ:
-		case TVIN_SIG_FMT_HDMI_720X576P_100HZ:
-		case TVIN_SIG_FMT_HDMI_720X576P_200HZ:
-		case TVIN_SIG_FMT_HDMI_720X576P_50HZ_FRAME_PACKING:
-			/* 576I */
-		case TVIN_SIG_FMT_CVBS_PAL_I:
-		case TVIN_SIG_FMT_CVBS_PAL_CN:
-		case TVIN_SIG_FMT_CVBS_SECAM:
-		case TVIN_SIG_FMT_COMP_576I_50HZ_D000:
-		case TVIN_SIG_FMT_HDMI_1440X576I_50HZ:
-		case TVIN_SIG_FMT_HDMI_2880X576I_50HZ:
-		case TVIN_SIG_FMT_HDMI_1440X576I_100HZ:
-		case TVIN_SIG_FMT_HDMI_1440X576I_200HZ:
-		case TVIN_SIG_FMT_BT656IN_576I_50HZ:
-		case TVIN_SIG_FMT_BT601IN_576I_50HZ:
-			vf->pixel_ratio = PIXEL_ASPECT_RATIO_16_15;
-			break;
-		default:
-			vf->pixel_ratio = PIXEL_ASPECT_RATIO_1_1;
-			break;
-	}
-}
-
-
-/*
-   based on the bellow parameters:
-   1.h_active
-   2.v_active
- */
-static void vdin_vf_init(struct vdin_dev_s *devp)
-{
-	int i = 0;
-        unsigned int chromaid, addr;
-	struct vf_entry *master, *slave;
-	struct vframe_s *vf;
-	struct vf_pool *p = devp->vfp;
-	//const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-	#ifdef VDIN_DEBUG
-	pr_info("vdin.%d vframe initial infomation table: (%d of %d)\n",
-	 		 devp->index, p->size, p->max_size);
-	#endif
-	for (i = 0; i < p->size; ++i)
-	{
-		master = vf_get_master(p, i);
-		master->flag |= VF_FLAG_NORMAL_FRAME;
-		vf = &master->vf;
-		memset(vf, 0, sizeof(struct vframe_s));
-		vf->index = i;
-		vf->width = devp->h_active;
-		vf->height = devp->v_active;
-		if ((devp->fmt_info_p->scan_mode == TVIN_SCAN_MODE_INTERLACED) &&
-		    (!(devp->parm.flag & TVIN_PARM_FLAG_2D_TO_3D) &&
-                      (devp->parm.info.fmt != TVIN_SIG_FMT_NULL))
-		   )
-			vf->height <<= 1;
-#ifndef VDIN_DYNAMIC_DURATION
-		vf->duration = devp->fmt_info_p->duration;
-#endif
-                /*if output fmt is nv21 or nv12 ,use the two continuous canvas for one field*/
-                if((devp->prop.dest_cfmt == TVIN_NV12) ||
-                   (devp->prop.dest_cfmt == TVIN_NV21))
-                {
-                        chromaid = (vdin_canvas_ids[devp->index][(vf->index<<1)+1])<<8;
-                        addr = vdin_canvas_ids[devp->index][vf->index<<1] |chromaid;
-                }
-                else
-                        addr = vdin_canvas_ids[devp->index][vf->index];
-
-                vf->canvas0Addr = vf->canvas1Addr = addr;
-
-		/* set source type & mode */
-		vdin_set_source_type(devp, vf);
-		vdin_set_source_mode(devp, vf);
-		/* set pixel aspect ratio */
-		vdin_set_pixel_aspect_ratio(devp, vf);
-
-		/* init slave vframe */
-		slave  = vf_get_slave(p, i);
-		slave->flag = master->flag;
-		memset(&slave->vf, 0, sizeof(struct vframe_s));
-		slave->vf.index 	  = vf->index;
-		slave->vf.width 	  = vf->width;
-		slave->vf.height	  = vf->height;
-		slave->vf.duration	  = vf->duration;
-		slave->vf.canvas0Addr = vf->canvas0Addr;
-		slave->vf.canvas1Addr = vf->canvas1Addr;
-		/* set slave vf source type & mode */
-		slave->vf.source_type = vf->source_type;
-		slave->vf.source_mode = vf->source_mode;
-		#ifdef VDIN_DEBUG
-		pr_info("\t%2d: 0x%2x %ux%u, duration = %u\n", vf->index,
-			vf->canvas0Addr, vf->width, vf->height, vf->duration);
-		#endif
-	}
-}
-
-/*
- * 1. config canvas for video frame.
- * 2. enable hw work, including:
- *		a. mux null input.
- *		b. set clock auto.
- * 3. set all registeres including:
- *		a. mux input.
- * 4. call the callback function of the frontend to start.
- * 5. enable irq .
- *
- */
-static void vdin_start_dec(struct vdin_dev_s *devp)
-{
-	struct tvin_state_machine_ops_s *sm_ops;
-	//enum tvin_sig_fmt_e fmt = 0;
-	/* avoid null pointer oops */
-	if (!devp ||!devp->fmt_info_p){
-                printk("[vdin..]%s null error.\n",__func__);
-	        return;
-	}
-        //fmt = devp->parm.info.fmt;
-        if(devp->frontend && devp->frontend->sm_ops){
-	        sm_ops = devp->frontend->sm_ops;
-	        sm_ops->get_sig_propery(devp->frontend, &devp->prop);
-		if(devp->flags & VDIN_FLAG_MANUAL_CONVERTION)
-			devp->prop.dest_cfmt = devp->dest_cfmt;
-        }
-	
-	vdin_get_format_convert(devp);
-	devp->curr_wr_vfe = NULL;
-	/* h_active/v_active will be recalculated by bellow calling */
-	vdin_set_decimation(devp);
-	vdin_set_cutwin(devp);
-	vdin_set_hvscale(devp);
-        /*reverse / disable reverse write buffer*/
-        vdin_wr_reverse(devp->addr_offset,reverse_flag,reverse_flag);
-
-	/* h_active/v_active will be used by bellow calling */
-	if (canvas_config_mode == 1) {
-		vdin_canvas_start_config(devp);
-	}
-	else if (canvas_config_mode == 2){
-		vdin_canvas_auto_config(devp);
-	}
-#if 0
-	if((devp->prop.dest_cfmt == TVIN_NV12)||(devp->prop.dest_cfmt == TVIN_NV21)){
-		devp->vfp->size = devp->canvas_max_num;
-	} else {
-		devp->vfp->size = devp->canvas_max_num;
-	}
-#endif
-
-	devp->vfp->size = devp->canvas_max_num;
-	vf_pool_init(devp->vfp, devp->vfp->size);
-	vdin_vf_init(devp);
-
-	devp->abnormal_cnt = 0;
-	devp->last_wr_vfe = NULL;
-	irq_max_count = 0;
-	//devp->stamp_valid = false;
-	devp->stamp = 0;
-	devp->cycle = 0;
-	devp->cycle_tag = 0;
-	devp->hcnt64 = 0;
-	devp->hcnt64_tag = 0;
-	/*
-	   devp->v.isr_count = 0;
-	   devp->v.tval.tv_sec = 0;
-	   devp->v.tval.tv_usec = 0;
-	   devp->v.min_isr_time = 0;
-	   devp->v.max_isr_time = 0;
-	   devp->v.avg_isr_time = 0;
-	   devp->v.less_5ms_cnt = 0;
-	   devp->v.isr_interval = 0;
-	 */
-
-	devp->vga_clr_cnt = devp->canvas_max_num;
-
-	devp->vs_cnt_valid = 0;
-	devp->vs_cnt_ignore = 0;
-
-        devp->curr_field_type = vdin_get_curr_field_type(devp);
-	//pr_info("start clean_counter is %d\n",clean_counter);
-	/* configure regs and enable hw */
-	#ifdef CONFIG_ARCH_MESON8
-	switch_vpu_mem_pd_vmod(devp->addr_offset?VPU_VIU_VDIN1:VPU_VIU_VDIN0,VPU_MEM_POWER_ON);
-	#endif
-	vdin_hw_enable(devp->addr_offset);
-	vdin_set_all_regs(devp);
-
-	if ((devp->parm.port >= TVIN_PORT_VGA0) && (devp->parm.port <= TVIN_PORT_VGA7))
-		vdin_set_matrix_blank(devp);
-
-	if (!(devp->parm.flag & TVIN_PARM_FLAG_CAP) &&
-			devp->frontend->dec_ops && devp->frontend->dec_ops->start)
-		devp->frontend->dec_ops->start(devp->frontend, devp->parm.info.fmt);
-
-	/* register provider, so the receiver can get the valid vframe */
-	udelay(start_provider_delay);
-	vf_reg_provider(&devp->vprov);
-	vf_notify_receiver(devp->name,VFRAME_EVENT_PROVIDER_START,NULL);
-	if(devp->parm.port != TVIN_PORT_VIU){
-		/*enable irq */
-		enable_irq(devp->irq);
-	}
-	/*disable audio&video sync used for libplayer*/
-	tsync_set_enable(0);
-	/* enable system_time */
-	timestamp_pcrscr_enable(1);
-}
-
-/*
- * 1. disable irq.
- * 2. disable hw work, including:
- *		a. mux null input.
- *		b. set clock off.
- * 3. call the callback function of the frontend to stop.
- *
- */
-static void vdin_stop_dec(struct vdin_dev_s *devp)
-{
-	/* avoid null pointer oops */
-	if (!devp || !devp->frontend)
-		return;
-
-	vf_unreg_provider(&devp->vprov);
-	if (!(devp->parm.flag & TVIN_PARM_FLAG_CAP) &&
-			devp->frontend->dec_ops && devp->frontend->dec_ops->stop)
-		devp->frontend->dec_ops->stop(devp->frontend, devp->parm.port);
-	vdin_set_default_regmap(devp->addr_offset);
-	vdin_hw_disable(devp->addr_offset);
-	disable_irq_nosync(devp->irq);
-	/* reset default canvas  */
-	vdin_set_def_wr_canvas(devp);	
-	#ifdef CONFIG_ARCH_MESON8
-	switch_vpu_mem_pd_vmod(devp->addr_offset?VPU_VIU_VDIN1:VPU_VIU_VDIN0,VPU_MEM_POWER_DOWN);
-	#endif
-	memset(&devp->prop, 0, sizeof(struct tvin_sig_property_s));
-	ignore_frames = 0;
-	devp->cycle = 0;
-	pr_info("%s ok\n", __func__);
-}
-//@todo
-
-int start_tvin_service(int no ,vdin_parm_t *para)
-{
-	struct tvin_frontend_s *fe;
-	int ret = 0;
-	struct vdin_dev_s *devp = vdin_devp[no];
-	if(IS_ERR(devp)){
-		printk(KERN_ERR "[vdin..]%s vdin%d has't registered,please register.\n",__func__,no);
-		return -1;
-	}
-	devp->start_time = jiffies_to_msecs(jiffies);
-	if (devp->flags & VDIN_FLAG_DEC_STARTED) {
-	pr_err("%s: port 0x%x, decode started already.\n",__func__,para->port);
-		ret = -EBUSY;
-	}
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	if(para->port != TVIN_PORT_VIU){
-		ret = request_irq(devp->irq, vdin_v4l2_isr, IRQF_SHARED, devp->irq_name, (void *)devp);
-		/*disable vsync irq until vdin configured completely*/
-		disable_irq_nosync(devp->irq);
-	}
-#else
-	ret = request_irq(devp->irq, vdin_v4l2_isr, IRQF_SHARED, devp->irq_name, (void *)devp);
-	/*disable vsync irq until vdin configured completely*/
-	disable_irq_nosync(devp->irq);
-#endif
-	/*config the vdin use default value*/
-	vdin_set_default_regmap(devp->addr_offset);
-
-	devp->parm.port = para->port;
-#ifdef CONFIG_ARCH_MESON6
-	if(para->port == TVIN_PORT_ISP)
-		devp->parm.port = TVIN_PORT_CAMERA;
-#endif
-	devp->parm.info.fmt     = para->fmt;
-	//add for camera random resolution
-	if(para->fmt >= TVIN_SIG_FMT_MAX){
-                devp->fmt_info_p = kmalloc(sizeof(tvin_format_t),GFP_KERNEL);
-                if(!devp->fmt_info_p){
-                        printk("[vdin..]%s kmalloc error.\n",__func__);
-                        return -ENOMEM;
-                }
-                devp->fmt_info_p->hs_bp     = para->hs_bp;
-                devp->fmt_info_p->vs_bp     = para->vs_bp;
-                devp->fmt_info_p->hs_pol    = para->hsync_phase;
-                devp->fmt_info_p->vs_pol    = para->vsync_phase;
-	        devp->fmt_info_p->h_active  = para->h_active;
-	        devp->fmt_info_p->v_active  = para->v_active;
-                devp->fmt_info_p->scan_mode = para->scan_mode;
-                devp->fmt_info_p->duration  = 96000/para->frame_rate;
-                devp->fmt_info_p->pixel_clk = para->h_active*para->v_active*para->frame_rate;
-                devp->fmt_info_p->pixel_clk /=10000;
-	}else{
-                devp->fmt_info_p = tvin_get_fmt_info(devp->parm.info.fmt);
-        }
-        if(!devp->fmt_info_p) {
-		pr_err("%s(%d): error, fmt is null!!!\n", __func__, no);
-		return -1;
-        }
-        fe = tvin_get_frontend(para->port, 0);
-        if(fe){
-                fe->private_data = para;
-                fe->port         = para->port;
-	        devp->frontend   = fe;
-                if(fe->dec_ops->open)
-                        fe->dec_ops->open(fe,fe->port);
-        }else{
-		pr_err("%s(%d): not supported port 0x%x \n", __func__, no, para->port);
-		return -1;
-	}
-	//disable cut window?
-	if(para->port == TVIN_PORT_VIU) {
-		devp->parm.cutwin.vs = v_cut_offset;
-	} 
-        /*add for scaler down*/
-	if(!(devp->flags & VDIN_FLAG_MANUAL_CONVERTION)) {
-		devp->scaler4w = para->dest_hactive;
-		devp->scaler4h = para->dest_vactive;
-	}
-        #ifdef CONFIG_ARCH_MESON6
-        switch_mod_gate_by_name("vdin", 1);
-        #endif
-	vdin_start_dec(devp);
-	devp->flags |= VDIN_FLAG_DEC_OPENED;
-	devp->flags |= VDIN_FLAG_DEC_STARTED;
-	irq_cnt = 0;
-	return 0;
-}
-
-EXPORT_SYMBOL(start_tvin_service);
-//@todo
-int stop_tvin_service(int no)
-{
-	struct vdin_dev_s *devp;
-	unsigned int end_time;
-	devp = vdin_devp[no];
-	
-	if(!(devp->flags&VDIN_FLAG_DEC_STARTED)){
-		pr_err("%s:decode hasn't started.\n",__func__);
-		return -EBUSY;
-	}
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-	devp->flags |= VDIN_FLAG_DEC_STOP_ISR;
-#endif
-	vdin_stop_dec(devp);
-        /*close fe*/
-        if(devp->frontend->dec_ops->close)
-                devp->frontend->dec_ops->close(devp->frontend);
-        /*free the memory allocated in start tvin service*/
-	if(devp->parm.info.fmt >= TVIN_SIG_FMT_MAX)
-                kfree(devp->fmt_info_p);
-#ifdef CONFIG_ARCH_MESON6
-        switch_mod_gate_by_name("vdin", 0);
-#endif
-	devp->flags &= (~VDIN_FLAG_DEC_OPENED);
-	devp->flags &= (~VDIN_FLAG_DEC_STARTED);
-	if(devp->parm.port!= TVIN_PORT_VIU){
-		/* free irq */
-		free_irq(devp->irq,(void *)devp);
-	}
-	end_time = jiffies_to_msecs(jiffies);
-	pr_info("[vdin]:vdin start time:%ums,stop time:%ums,run time:%u.\n",devp->start_time,end_time,end_time-devp->start_time);
-	return 0;
-}
-EXPORT_SYMBOL(stop_tvin_service);
-
-void get_tvin_canvas_info(int* start , int* num)
-{
-        *start = vdin_canvas_ids[0][0];
-	*num = vdin_devp[0]->canvas_max_num;
-}
-EXPORT_SYMBOL(get_tvin_canvas_info);
-
-static int vdin_ioctl_fe(int no, fe_arg_t *parm)
-{
-	struct vdin_dev_s *devp = vdin_devp[no];
-	int ret = 0;
-        if(IS_ERR(devp)){
-                pr_err("[vdin..]%s vdin%d has't registered,please register.\n",__func__,no);
-                return -1;
-        }
-	if(devp->frontend && devp->frontend->dec_ops && devp->frontend->dec_ops->ioctl)
-		ret = devp->frontend->dec_ops->ioctl(devp->frontend, parm->arg);
-	else if(!devp->frontend) {
-		devp->frontend = tvin_get_frontend(parm->port,parm->index);
-		if(devp->frontend && devp->frontend->dec_ops && devp->frontend->dec_ops->ioctl)
-		        ret = devp->frontend->dec_ops->ioctl(devp->frontend, parm->arg);
-	}
-	return ret;
-}
-static void vdin_rdma_isr(struct vdin_dev_s *devp)
-{
-	if(devp->parm.port==TVIN_PORT_VIU)
-		vdin_v4l2_isr(devp->irq,devp);
-}
-static int vdin_func(int no, vdin_arg_t *arg)
-{
-	struct vdin_dev_s *devp = vdin_devp[no];
-	int ret = 0;
-	struct vdin_arg_s *parm = NULL;
-        if(IS_ERR_OR_NULL(devp)){
-		if(vdin_dbg_en)
-		        pr_err("[vdin..]%s vdin%d has't registered,please register.\n",__func__,no);
-                return -1;
-        }else if(!(devp->flags&VDIN_FLAG_DEC_STARTED)){
-        	if(vdin_dbg_en)
-			pr_err("[vdin..]%s vdin%d has't started.\n",__func__,no);
-		return -1;
-	}
-	parm = arg;
-	switch(parm->cmd){
-                /*ajust vdin1 matrix1 & matrix2 for isp to get histogram information*/
-		case VDIN_CMD_SET_CSC:
-			vdin_set_matrixs(devp,parm->matrix_id,parm->color_convert);
-			break;
-		case VDIN_CMD_SET_CM2:
-			vdin_set_cm2(devp->addr_offset,devp->h_active,devp->v_active,parm->cm2);
-			break;
-		case VDIN_CMD_ISR:
-			vdin_rdma_isr(devp);
-			break;
-		default:
-			break;
-	}
-	return ret;
-}
-static vdin_v4l2_ops_t vdin_4v4l2_ops = {
-        .start_tvin_service   = start_tvin_service,
-        .stop_tvin_service    = stop_tvin_service,
-        .get_tvin_canvas_info = get_tvin_canvas_info,
-        .set_tvin_canvas_info = NULL,
-        .tvin_fe_func         = vdin_ioctl_fe,
-        .tvin_vdin_func	      = vdin_func,
-};
-
-static void vdin_pause_dec(struct vdin_dev_s *devp)
-{
-	vdin_hw_disable(devp->addr_offset);
-}
-
-static void vdin_resume_dec(struct vdin_dev_s *devp)
-{
-	vdin_hw_enable(devp->addr_offset);
-}
-
-static void vdin_vf_reg(struct vdin_dev_s *devp)
-{
-	vf_reg_provider(&devp->vprov);
-	vf_notify_receiver(devp->name,VFRAME_EVENT_PROVIDER_START,NULL);
-}
-
-static void vdin_vf_unreg(struct vdin_dev_s *devp)
-{
-	vf_unreg_provider(&devp->vprov);
-}
-
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-static inline void vdin_set_view(struct vdin_dev_s *devp, struct vframe_s *vf)
-{
-	struct vframe_view_s *left_eye, *right_eye;
-	enum tvin_sig_fmt_e fmt = devp->parm.info.fmt;
-	const struct tvin_format_s *fmt_info = tvin_get_fmt_info(fmt);
-
-    if(!fmt_info) {
-        pr_err("[tvafe..] %s: error,fmt is null!!! \n",__func__);
-        return;
-    }
-
-	left_eye  = &vf->left_eye;
-	right_eye = &vf->right_eye;
-
-	switch (devp->parm.info.trans_fmt)
-	{
-		case TVIN_TFMT_3D_LRH_OLOR:
-		case TVIN_TFMT_3D_LRH_OLER:
-			left_eye->start_x	 = 0;
-			left_eye->start_y	 = 0;
-			left_eye->width 	 = devp->h_active >> 1;
-			left_eye->height	 = devp->v_active;
-			right_eye->start_x	 = devp->h_active >> 1;
-			right_eye->start_y	 = 0;
-			right_eye->width	 = devp->h_active >> 1;
-			right_eye->height	 = devp->v_active;
-			break;
-		case TVIN_TFMT_3D_TB:
-			left_eye->start_x	 = 0;
-			left_eye->start_y	 = 0;
-			left_eye->width 	 = devp->h_active;
-			left_eye->height	 = devp->v_active >> 1;
-			right_eye->start_x	 = 0;
-			right_eye->start_y	 = devp->v_active >> 1;
-			right_eye->width	 = devp->h_active;
-			right_eye->height	 = devp->v_active >> 1;
-			break;
-		case TVIN_TFMT_3D_FP:
-			{
-				unsigned int vactive = 0;
-				unsigned int vspace = 0;
-				struct vf_entry *slave = NULL;
-
-				vspace  = fmt_info->vs_front + fmt_info->vs_width + fmt_info->vs_bp;
-
-				if ((devp->parm.info.fmt == TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_FRAME_PACKING) ||
-						(devp->parm.info.fmt == TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_FRAME_PACKING))
-				{
-					vactive = (fmt_info->v_active - vspace - vspace - vspace + 1) >> 2;
-					slave = vf_get_slave(devp->vfp, vf->index);
-
-					slave->vf.left_eye.start_x  = 0;
-					slave->vf.left_eye.start_y  = vactive + vspace + vactive + vspace - 1;
-					slave->vf.left_eye.width    = devp->h_active;
-					slave->vf.left_eye.height   = vactive;
-					slave->vf.right_eye.start_x = 0;
-					slave->vf.right_eye.start_y = vactive + vspace + vactive + vspace + vactive + vspace - 1;
-					slave->vf.right_eye.width   = devp->h_active;
-					slave->vf.right_eye.height  = vactive;
-				}
-				else
-					vactive = (fmt_info->v_active - vspace) >> 1;
-
-
-				left_eye->start_x	 = 0;
-				left_eye->start_y	 = 0;
-				left_eye->width 	 = devp->h_active;
-				left_eye->height	 = vactive;
-				right_eye->start_x	 = 0;
-				right_eye->start_y	 = vactive + vspace;
-				right_eye->width	 = devp->h_active;
-				right_eye->height	 = vactive;
-				break;
-			}
-        case TVIN_TFMT_3D_FA:
-            {
-                unsigned int vactive = 0;
-                unsigned int vspace = 0;
-
-                vspace  = fmt_info->vs_front + fmt_info->vs_width + fmt_info->vs_bp;
-
-                vactive = (fmt_info->v_active - vspace + 1) >> 1;
-
-                left_eye->start_x    = 0;
-                left_eye->start_y    = 0;
-                left_eye->width      = devp->h_active;
-                left_eye->height     = vactive;
-                right_eye->start_x   = 0;
-                right_eye->start_y   = vactive + vspace;
-                right_eye->width     = devp->h_active;
-                right_eye->height    = vactive;
-                break;
-            }
-        case TVIN_TFMT_3D_LA:
-            {
-                left_eye->start_x    = 0;
-                left_eye->start_y    = 0;
-                left_eye->width      = devp->h_active;
-                left_eye->height     = (devp->v_active) >> 1;
-                right_eye->start_x   = 0;
-                right_eye->start_y   = 0;
-                right_eye->width     = devp->h_active;
-                right_eye->height    = (devp->v_active) >> 1;
-                break;
-            }
-		default:
-			left_eye->start_x	 = 0;
-			left_eye->start_y	 = 0;
-			left_eye->width 	 = 0;
-			left_eye->height	 = 0;
-			right_eye->start_x	 = 0;
-			right_eye->start_y	 = 0;
-			right_eye->width	 = 0;
-			right_eye->height	 = 0;
-			break;
-	}
-}
-#endif
-static irqreturn_t vdin_isr_simple(int irq, void *dev_id)
-{
-	struct vdin_dev_s *devp = (struct vdin_dev_s *)dev_id;
-	struct tvin_decoder_ops_s *decops;
-	unsigned int last_field_type;
-
-	if (irq_max_count >= devp->canvas_max_num) {
-		vdin_hw_disable(devp->addr_offset);
-		return IRQ_HANDLED;
-	}
-
-	last_field_type = devp->curr_field_type;
-	devp->curr_field_type = vdin_get_curr_field_type(devp);
-
-	decops =devp->frontend->dec_ops;
-	if (decops->decode_isr(devp->frontend, vdin_get_meas_hcnt64(devp->addr_offset)) == -1)
-		return IRQ_HANDLED;
-	/* set canvas address */
-
-	vdin_set_canvas_id(devp->addr_offset, vdin_canvas_ids[devp->index][irq_max_count]);
-	pr_info("%2d: canvas id %d, field type %s\n", irq_max_count,
-			vdin_canvas_ids[devp->index][irq_max_count],
-			((last_field_type & VIDTYPE_TYPEMASK)== VIDTYPE_INTERLACE_TOP ? "top":"buttom"));
-
-	irq_max_count++;
-	return IRQ_HANDLED;
-}
-
-static void vdin_backup_histgram(struct vframe_s *vf, struct vdin_dev_s *devp)
-{
-	unsigned int i = 0;
-    devp->parm.hist_pow = vf->prop.hist.hist_pow;
-	for (i = 0; i < 64; i++)
-		devp->parm.histgram[i] = vf->prop.hist.gamma[i];
-}
-/*as use the spin_lock,
- *1--there is no sleep,
- *2--it is better to shorter the time,
- *3--it is better to shorter the time,
- */
-#define VDIN_MEAS_24M_1MS 24000
-
-#ifdef SMOOTH_DEBUG
-static int isr_count = 0;
-static int notify_count = 0;
-static unsigned char count_start = 0;
-int get_vsync_count(unsigned char reset);
-static void dump_count(void)
-{
-    int output_vsync_count = get_vsync_count(0);
-    printk("display %d vdin %d diff %d notify %d\n",output_vsync_count, isr_count, output_vsync_count-isr_count, notify_count);
-}
-#endif
-
-static irqreturn_t vdin_isr(int irq, void *dev_id)
-{
-	ulong flags;
-	struct vdin_dev_s *devp = (struct vdin_dev_s *)dev_id;
-	enum tvin_sm_status_e state;
-
-	struct vf_entry *next_wr_vfe = NULL;
-	struct vf_entry *curr_wr_vfe = NULL;
-	struct vframe_s *curr_wr_vf = NULL;
-	unsigned int last_field_type;
-	signed short step = 0;
-	struct tvin_decoder_ops_s *decops;
-	unsigned int stamp = 0;
-	struct tvin_state_machine_ops_s *sm_ops;
-	//unsigned long long total_time;
-	//unsigned long long total_tmp;
-	struct tvafe_vga_parm_s vga_parm = {0};
-	bool is_vga = false;
-
-	if (!devp) return IRQ_HANDLED;
-
-        isr_log(devp->vfp);
-	/* debug interrupt interval time
-	 *
-	 * this code about system time must be outside of spinlock.
-	 * because the spinlock may affect the system time.
-
-	 devp->v.isr_count++;
-	 */
-
-#ifdef SMOOTH_DEBUG
-	 if(count_start == 0){
-	    get_vsync_count(1);
-	    count_start = 1;
-	 }
-	 isr_count++;
-#endif
-
-	spin_lock_irqsave(&devp->isr_lock, flags);
-
-	/* avoid null pointer oops */
-	if (!devp || !devp->frontend) {
-		goto irq_handled;
-	}
-	//vdin_write_done_check(devp->addr_offset, devp);
-
-	if ((devp->flags & VDIN_FLAG_DEC_STOP_ISR)&&
-                        (!(isr_flag & VDIN_BYPASS_STOP_CHECK)))
-	{
-		vdin_hw_disable(devp->addr_offset);
-		devp->flags &= ~VDIN_FLAG_DEC_STOP_ISR;
-		goto irq_handled;
-	}
-	stamp  = vdin_get_meas_vstamp(devp->addr_offset);
-	if (!devp->curr_wr_vfe) {
-		devp->curr_wr_vfe = provider_vf_get(devp->vfp);
-		/*save the first field stamp*/
-		devp->stamp = stamp;
-		goto irq_handled;
-	}
-	/*check vs is valid base on the time during continuous vs*/
-	if(vdin_check_cycle(devp) && (!(isr_flag & VDIN_BYPASS_CYC_CHECK)))
-		goto irq_handled;
-
-	devp->hcnt64 = vdin_get_meas_hcnt64(devp->addr_offset);
-
-	/* ignore invalid vs base on the continuous fields different cnt to void screen flicker */
-	if (vdin_check_vs(devp)&&(!(isr_flag & VDIN_BYPASS_VSYNC_CHECK)))
-	{
-		goto irq_handled;
-	}
-	sm_ops = devp->frontend->sm_ops;
-
-	if ((devp->parm.port >= TVIN_PORT_VGA0) &&
-			(devp->parm.port <= TVIN_PORT_VGA7) &&
-			(devp->dec_enable))
-	{
-                if(!(isr_flag && VDIN_BYPASS_VGA_CHECK))
-		        is_vga = true;
-	}
-	else{
-		is_vga = false;
-	}
-	last_field_type = devp->curr_field_type;
-	devp->curr_field_type = vdin_get_curr_field_type(devp);
-
-	/* ignore the unstable signal */
-	state = tvin_get_sm_status(devp->index);
-	if (devp->parm.info.status != TVIN_SIG_STATUS_STABLE ||
-			state != TVIN_SM_STATUS_STABLE) {
-		goto irq_handled;
-	}
-
-	/* for 3D mode & interlaced format, give up bottom field to avoid odd/even phase different*/
-	if (((devp->parm.flag & TVIN_PARM_FLAG_2D_TO_3D) ||
-	    (devp->parm.info.trans_fmt&&(devp->parm.info.trans_fmt!=TVIN_TFMT_3D_FP))) &&
-	    ((last_field_type & VIDTYPE_INTERLACE_BOTTOM) == VIDTYPE_INTERLACE_BOTTOM)
-	   )
-	{
-		goto irq_handled;
-	}
-	curr_wr_vfe = devp->curr_wr_vfe;
-	curr_wr_vf  = &curr_wr_vfe->vf;
-
-	decops = devp->frontend->dec_ops;
-	if (decops->decode_isr(devp->frontend, devp->hcnt64) == TVIN_BUF_SKIP) {
-		goto irq_handled;
-	}
-	if(devp->parm.port >= TVIN_PORT_CVBS0 && devp->parm.port <= TVIN_PORT_CVBS7)
-		curr_wr_vf->phase = sm_ops->get_secam_phase(devp->frontend)? VFRAME_PHASE_DB : VFRAME_PHASE_DR;
-	if (is_vga)
-		sm_ops->vga_get_param(&vga_parm, devp->frontend);
-	/* 4.csc=default wr=zoomed */
-	if ((curr_wr_vf->vga_parm.vga_in_clean == 1) && is_vga)
-	{
-		curr_wr_vf->vga_parm.vga_in_clean--;
-		vdin_set_matrix(devp);
-		//sm_ops->vga_set_param(&curr_wr_vf->vga_parm, devp->frontend);
-		sm_ops->vga_set_param((struct tvafe_vga_parm_s*)VDIN_FLAG_BLACK_SCREEN_OFF, devp->frontend);
-		step = curr_wr_vf->vga_parm.vpos_step;
-		if (step > 0)
-			vdin_delay_line(1, devp->addr_offset);
-		else
-			vdin_delay_line(0, devp->addr_offset);
-
-		goto irq_handled;
-	}
-	/* 3.csc=blank wr=zoomed */
-	if ((curr_wr_vf->vga_parm.vga_in_clean == 2) && is_vga)
-	{
-		curr_wr_vf->vga_parm.vga_in_clean--;
-		curr_wr_vf->vga_parm.clk_step = vga_parm.clk_step;
-		curr_wr_vf->vga_parm.phase = vga_parm.phase;
-		curr_wr_vf->vga_parm.hpos_step = vga_parm.hpos_step;
-		curr_wr_vf->vga_parm.vpos_step = vga_parm.vpos_step;
-		set_wr_ctrl(curr_wr_vf->vga_parm.hpos_step, curr_wr_vf->vga_parm.vpos_step,devp);
-
-		goto irq_handled;
-	}
-	/* 2.csc=blank wr=default */
-	if ((curr_wr_vf->vga_parm.vga_in_clean == 3) && is_vga)
-	{
-		curr_wr_vf->vga_parm.vga_in_clean--;
-
-		goto irq_handled;
-	}
-
-
-	if (ignore_frames < max_ignore_frames ) {
-		ignore_frames++;
-
-		goto irq_handled;
-	}
-
-	if (sm_ops->check_frame_skip && sm_ops->check_frame_skip(devp->frontend)) {
-		goto irq_handled;
-	}
-
-	next_wr_vfe = provider_vf_peek(devp->vfp);
-	if (!next_wr_vfe) {
-		goto irq_handled;
-	}
-	/*if vdin-nr,di must get vdin current field type which di pre will read*/
-  if(vf_notify_receiver(devp->name,VFRAME_EVENT_PROVIDER_QUREY_VDIN2NR,NULL))
-		curr_wr_vf->type = devp->curr_field_type;
-	else
-		curr_wr_vf->type = last_field_type;
-
-	/* for 2D->3D mode or hdmi 3d mode& interlaced format, fill-in as progressive format */
-	if (((devp->parm.flag & TVIN_PARM_FLAG_2D_TO_3D)||(curr_wr_vf->trans_fmt)) &&
-	    (last_field_type & VIDTYPE_INTERLACE)
-	   )
-	{
-		curr_wr_vf->type &= ~VIDTYPE_INTERLACE_TOP;
-		curr_wr_vf->type |=  VIDTYPE_PROGRESSIVE;
-		curr_wr_vf->type |=  VIDTYPE_PRE_INTERLACE;
-	}
-
-	vdin_set_vframe_prop_info(curr_wr_vf, devp);
-	vdin_backup_histgram(curr_wr_vf, devp);
-
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-	curr_wr_vf->trans_fmt = devp->parm.info.trans_fmt;
-
-	vdin_set_view(devp, curr_wr_vf);
-#endif
-	vdin_calculate_duration(devp);
-	/* put for receiver
-
-	   ppmgr had handled master and slave vf by itself,vdin do not to declare them respectively
-	   ppmgr put the vf that included master vf and slave vf
-	 */
-#if 0
-	if ((devp->parm.info.fmt == TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_FRAME_PACKING) ||
-			(devp->parm.info.fmt == TVIN_SIG_FMT_HDMI_1920X1080I_60HZ_FRAME_PACKING))
-	{
-		struct vf_entry *slave = vf_get_slave(devp->vfp, curr_wr_vf->index);
-		slave->vf.type = curr_wr_vf->type;
-		slave->vf.trans_fmt = curr_wr_vf->trans_fmt;
-		memcpy(&slave->vf.prop, &curr_wr_vf->prop, sizeof(struct vframe_prop_s));
-		slave->flag &= (~VF_FLAG_NORMAL_FRAME);
-		curr_wr_vf->duration = (curr_wr_vf->duration + 1) >> 1;
-		slave->vf.duration = curr_wr_vf->duration;
-		curr_wr_vfe->flag &= (~VF_FLAG_NORMAL_FRAME);
-		provider_vf_put(curr_wr_vfe, devp->vfp);
-		provider_vf_put(slave, devp->vfp);
-	}
-	else
-#endif
-	{
-	        /*config height according to 3d mode dynamically*/
-		if ((devp->fmt_info_p->scan_mode == TVIN_SCAN_MODE_INTERLACED) &&
-		    (!(devp->parm.flag & TVIN_PARM_FLAG_2D_TO_3D) &&
-                      (devp->parm.info.fmt != TVIN_SIG_FMT_NULL))
-		   )
-			curr_wr_vf->height = devp->v_active<<1;
-		else
-			curr_wr_vf->height = devp->v_active;
-		curr_wr_vfe->flag |= VF_FLAG_NORMAL_FRAME;
-		provider_vf_put(curr_wr_vfe, devp->vfp);
-	}
-
-
-	/* prepare for next input data */
-	next_wr_vfe = provider_vf_get(devp->vfp);
-	vdin_set_canvas_id(devp->addr_offset, (next_wr_vfe->vf.canvas0Addr&0xff));
-        /* prepare for chroma canvas*/
-        if((devp->prop.dest_cfmt == TVIN_NV12)||(devp->prop.dest_cfmt == TVIN_NV21))
-                vdin_set_chma_canvas_id(devp->addr_offset,(next_wr_vfe->vf.canvas0Addr>>8)&0xff);
-
-        devp->curr_wr_vfe = next_wr_vfe;
-	vf_notify_receiver(devp->name,VFRAME_EVENT_PROVIDER_VFRAME_READY,NULL);
-
-#ifdef SMOOTH_DEBUG
-	 notify_count++;
-#endif
-
-	/* 1.csc=blank wr=default*/
-	if (is_vga &&
-			((vga_parm.hpos_step != next_wr_vfe->vf.vga_parm.hpos_step) ||
-			 (vga_parm.vpos_step != next_wr_vfe->vf.vga_parm.vpos_step) ||
-			 (vga_parm.clk_step  != next_wr_vfe->vf.vga_parm.clk_step ) ||
-			 (vga_parm.phase	 != next_wr_vfe->vf.vga_parm.phase) ||
-			 (devp->vga_clr_cnt > 0 				  )
-			)
-	   )
-	{
-		set_wr_ctrl(0, 0, devp);
-		vdin_set_matrix_blank(devp);
-		vga_parm.hpos_step = 0;
-		vga_parm.vpos_step = 0;
-		vga_parm.phase	   = next_wr_vfe->vf.vga_parm.phase;
-		//sm_ops->vga_set_param(&vga_parm, devp->frontend);
-		sm_ops->vga_set_param((struct tvafe_vga_parm_s*)VDIN_FLAG_BLACK_SCREEN_ON, devp->frontend);
-
-		if (next_wr_vfe->vf.vga_parm.vga_in_clean == 0)
-			next_wr_vfe->vf.vga_parm.vga_in_clean = 3;
-		else
-			next_wr_vfe->vf.vga_parm.vga_in_clean--;
-		if (devp->vga_clr_cnt > 0)
-			devp->vga_clr_cnt--;
-	}
-irq_handled:
-	spin_unlock_irqrestore(&devp->isr_lock, flags);
-
-        isr_log(devp->vfp);
-	return IRQ_HANDLED;
-}
-/*
-* there are too much logic in vdin_isr which is useless in camera&viu
-*so vdin_v4l2_isr use to the sample v4l2 application such as camera,viu
-*/
-static unsigned char skip_ratio = 1;
-module_param(skip_ratio,uint,0664);
-MODULE_PARM_DESC(skip_ratio,"\n vdin skip frame ratio 1/ratio will reserved.\n");
-
-static irqreturn_t vdin_v4l2_isr(int irq, void *dev_id)
-{
-	ulong flags;
-	struct vdin_dev_s *devp = (struct vdin_dev_s *)dev_id;
-
-	struct vf_entry *next_wr_vfe = NULL,*curr_wr_vfe = NULL;
-	struct vframe_s *curr_wr_vf = NULL;
-	unsigned int last_field_type, stamp;
-	struct tvin_decoder_ops_s *decops;
-        struct tvin_state_machine_ops_s *sm_ops;
-	int ret = 0;
-	if (!devp)
-                return IRQ_HANDLED;
-	isr_log(devp->vfp);
-        irq_cnt++;
-	spin_lock_irqsave(&devp->isr_lock, flags);
-        if(devp)
-	        /* avoid null pointer oops */
-	        stamp  = vdin_get_meas_vstamp(devp->addr_offset);
-	if (!devp->curr_wr_vfe) {
-		devp->curr_wr_vfe = provider_vf_get(devp->vfp);
-		/*save the first field stamp*/
-		devp->stamp = stamp;
-		goto irq_handled;
-	}
-	
-        if(!vdin_write_done_check(devp->addr_offset, devp)){
-		if(vdin_dbg_en)
-			pr_info("[vdin.%u] write undone skiped.\n",devp->index);
-                goto irq_handled;
-        }   
-
-
-	if(devp->last_wr_vfe){
-		provider_vf_put(devp->last_wr_vfe, devp->vfp);
-	        devp->last_wr_vfe = NULL;
-		vf_notify_receiver(devp->name,VFRAME_EVENT_PROVIDER_VFRAME_READY,NULL);
-	}
-	/*check vs is valid base on the time during continuous vs*/
-        vdin_check_cycle(devp);
-        
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-	if (devp->flags & VDIN_FLAG_DEC_STOP_ISR){
-		vdin_hw_disable(devp->addr_offset);
-		devp->flags &= ~VDIN_FLAG_DEC_STOP_ISR;
-		goto irq_handled;
-	}
-#endif
-	/* ignore invalid vs base on the continuous fields different cnt to void screen flicker */
-
-	last_field_type = devp->curr_field_type;
-	devp->curr_field_type = vdin_get_curr_field_type(devp);
-
-	curr_wr_vfe = devp->curr_wr_vfe;
-	curr_wr_vf  = &curr_wr_vfe->vf;
-
-	curr_wr_vf->type = last_field_type;
-
-	vdin_set_vframe_prop_info(curr_wr_vf, devp);
-	vdin_backup_histgram(curr_wr_vf, devp);
-
-        if(devp->frontend && devp->frontend->dec_ops){
-		decops = devp->frontend->dec_ops;
-                /*pass the histogram information to viuin frontend*/
-                devp->frontend->private_data = &curr_wr_vf->prop;
-          	ret = decops->decode_isr(devp->frontend, devp->hcnt64);
-		if (ret == TVIN_BUF_SKIP) {
-			if(vdin_dbg_en)
-				pr_info("%s bufffer(%u) skiped.\n",__func__,curr_wr_vf->index);
-			goto irq_handled;
-		/*if the current buffer is reserved,recycle tmp list,put current buffer to tmp list*/
-		} else if(ret == TVIN_BUF_TMP) {
-			recycle_tmp_vfs(devp->vfp);
-			tmp_vf_put(curr_wr_vfe,devp->vfp);
-			curr_wr_vfe = NULL;
-                /*function of capture end,the reserved is the best*/
-		} else if(ret == TVIN_BUF_RECYCLE_TMP) {
-                        tmp_to_rd(devp->vfp);
-			goto irq_handled;
-                }
-	}
-	/*check the skip frame*/
-        if(devp->frontend && devp->frontend->sm_ops){
-    	        sm_ops = devp->frontend->sm_ops;
-                if(sm_ops->check_frame_skip && 
-        	        sm_ops->check_frame_skip(devp->frontend)) {
-            	        goto irq_handled;
-                }
-        }
-        next_wr_vfe = provider_vf_peek(devp->vfp);
-
-	if (!next_wr_vfe) {
-                /*add for force vdin buffer recycle*/
-                if(devp->flags && VDIN_FLAG_FORCE_RECYCLE) {
-                        next_wr_vfe = receiver_vf_get(devp->vfp);
-                        if(next_wr_vfe)
-                                receiver_vf_put(&next_wr_vfe->vf,devp->vfp);
-                        else
-                                pr_err("[vdin.%d] force recycle error, no buffer in ready list.",devp->index);
-                }
-                else {
-		        goto irq_handled;
-                }
-	}
-	if(curr_wr_vfe){
-		curr_wr_vfe->flag |= VF_FLAG_NORMAL_FRAME;
-		//provider_vf_put(curr_wr_vfe, devp->vfp);
-		devp->last_wr_vfe = curr_wr_vfe;
-	}
-
-	/* prepare for next input data */
-	next_wr_vfe = provider_vf_get(devp->vfp);
-	if(devp->parm.port == TVIN_PORT_VIU){
-	        VSYNC_WR_MPEG_REG_BITS(VDIN_WR_CTRL+devp->addr_offset, (next_wr_vfe->vf.canvas0Addr&0xff), WR_CANVAS_BIT, WR_CANVAS_WID);
-                /* prepare for chroma canvas*/
-                if((devp->prop.dest_cfmt == TVIN_NV12)||(devp->prop.dest_cfmt == TVIN_NV21))
-			VSYNC_WR_MPEG_REG_BITS(VDIN_WR_CTRL2+devp->addr_offset, (next_wr_vfe->vf.canvas0Addr>>8)&0xff, WRITE_CHROMA_CANVAS_ADDR_BIT,WRITE_CHROMA_CANVAS_ADDR_WID);
-	}else{	
-		vdin_set_canvas_id(devp->addr_offset, (next_wr_vfe->vf.canvas0Addr&0xff));
-                if((devp->prop.dest_cfmt == TVIN_NV12)||(devp->prop.dest_cfmt == TVIN_NV21))
-                        vdin_set_chma_canvas_id(devp->addr_offset, (next_wr_vfe->vf.canvas0Addr>>8)&0xff);
-	}
-        devp->curr_wr_vfe = next_wr_vfe;
-	vf_notify_receiver(devp->name,VFRAME_EVENT_PROVIDER_VFRAME_READY,NULL);
-
-
-irq_handled:
-	spin_unlock_irqrestore(&devp->isr_lock, flags);
-	isr_log(devp->vfp);
-	return IRQ_HANDLED;
-}
-
-
-static int vdin_open(struct inode *inode, struct file *file)
-{
-	vdin_dev_t *devp;
-                int ret = 0;
-	/* Get the per-device structure that contains this cdev */
-	devp = container_of(inode->i_cdev, vdin_dev_t, cdev);
-	file->private_data = devp;
-
-	if (devp->index >= VDIN_MAX_DEVS)
-		return -ENXIO;
-
-	if (devp->flags &= VDIN_FLAG_FS_OPENED) {
-		pr_info("%s, device %s opened already\n", __func__, dev_name(devp->dev));
-		return 0;
-	}
-
-	devp->flags |= VDIN_FLAG_FS_OPENED;
-
-	/* request irq */
-	if (work_mode_simple) {
-		pr_info("vdin.%d work in simple mode.\n",devp->index);
-		ret = request_irq(devp->irq, vdin_isr_simple, IRQF_SHARED, devp->irq_name, (void *)devp);
-	}
-	else {
-		pr_info("vdin.%d work in normal mode.\n",devp->index);
-		ret = request_irq(devp->irq, vdin_isr, IRQF_SHARED, devp->irq_name, (void *)devp);
-	}
-        /*disable irq untill vdin is configured completely*/
-        disable_irq_nosync(devp->irq);
-
-	/* remove the hardware limit to vertical [0-max]*/
-    WRITE_VCBUS_REG(VPP_PREBLEND_VD1_V_START_END, 0x00000fff);
-	pr_info("open device %s ok\n", dev_name(devp->dev));
-	return ret;
-}
-
-static int vdin_release(struct inode *inode, struct file *file)
-{
-	vdin_dev_t *devp = file->private_data;
-
-	if (!(devp->flags &= VDIN_FLAG_FS_OPENED)) {
-		pr_info("%s, device %s not opened\n", __func__, dev_name(devp->dev));
-		return 0;
-	}
-
-	devp->flags &= (~VDIN_FLAG_FS_OPENED);
-
-	/* free irq */
-	free_irq(devp->irq,(void *)devp);
-
-	file->private_data = NULL;
-
-	/* reset the hardware limit to vertical [0-1079]  */
-        WRITE_VCBUS_REG(VPP_PREBLEND_VD1_V_START_END, 0x00000437);
-	pr_info("close device %s ok\n", dev_name(devp->dev));
-	return 0;
-}
-
-static long vdin_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	long ret = 0;
-	unsigned int delay_cnt = 0;
-	vdin_dev_t *devp = NULL;
-	void __user *argp = (void __user *)arg;
-
-	if (_IOC_TYPE(cmd) != TVIN_IOC_MAGIC) {
-		pr_err("%s invalid command: %u\n", __func__, cmd);
-		return -ENOSYS;
-	}
-
-
-	/* Get the per-device structure that contains this cdev */
-	devp = file->private_data;
-
-	switch (cmd)
-	{
-		case TVIN_IOC_OPEN:
-			{
-				struct tvin_parm_s parm = {0};
-
-				mutex_lock(&devp->fe_lock);
-
-				if (copy_from_user(&parm, argp, sizeof(struct tvin_parm_s)))
-				{
-					pr_err("TVIN_IOC_OPEN(%d) invalid parameter\n", devp->index);
-					ret = -EFAULT;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-
-				if (devp->flags & VDIN_FLAG_DEC_OPENED) {
-					pr_err("TVIN_IOC_OPEN(%d) port %s opend already\n",
-							parm.index, tvin_port_str(parm.port));
-					ret = -EBUSY;
-					mutex_unlock(&devp->fe_lock);
-					break;
-
-				}
-
-				devp->parm.index = parm.index;
-				devp->parm.port  = parm.port;
-				devp->unstable_flag = false;
-				ret = vdin_open_fe(devp->parm.port, devp->parm.index, devp);
-				if (ret) {
-					pr_err("TVIN_IOC_OPEN(%d) failed to open port 0x%x\n",
-							devp->index, parm.port);
-					ret = -EFAULT;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-
-				devp->flags |= VDIN_FLAG_DEC_OPENED;
-				pr_info("TVIN_IOC_OPEN(%d) port %s opened ok\n\n", parm.index,
-						tvin_port_str(devp->parm.port));
-				mutex_unlock(&devp->fe_lock);
-				break;
-			}
-		case TVIN_IOC_START_DEC:
-			{
-				struct tvin_parm_s parm = {0};
-
-				mutex_lock(&devp->fe_lock);
-				if (devp->flags & VDIN_FLAG_DEC_STARTED) {
-					pr_err("TVIN_IOC_START_DEC(%d) port 0x%x, decode started already\n", parm.index, parm.port);
-					ret = -EBUSY;
-					mutex_unlock(&devp->fe_lock);
-				}
-
-				if ((devp->parm.info.status != TVIN_SIG_STATUS_STABLE) ||
-						(devp->parm.info.fmt == TVIN_SIG_FMT_NULL))
-				{
-					pr_err("TVIN_IOC_START_DEC: port %s start invalid\n",
-							tvin_port_str(devp->parm.port));
-					pr_err("	status: %s, fmt: %s\n",
-							tvin_sig_status_str(devp->parm.info.status),
-							tvin_sig_fmt_str(devp->parm.info.fmt));
-					ret = -EPERM;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-
-				if (copy_from_user(&parm, argp, sizeof(struct tvin_parm_s)))
-				{
-					pr_err("TVIN_IOC_START_DEC(%d) invalid parameter\n", devp->index);
-					ret = -EFAULT;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-				devp->parm.cutwin.hs = parm.cutwin.hs;
-				// odd number in line width => decrease to even number in line width
-				if (((parm.cutwin.hs != 0) || (parm.cutwin.he != 0)) &&
-						((parm.cutwin.hs + parm.cutwin.he) & 1)
-				   )
-					devp->parm.cutwin.hs++;
-				devp->parm.cutwin.he = parm.cutwin.he;
-				devp->parm.cutwin.vs = parm.cutwin.vs;
-				devp->parm.cutwin.ve = parm.cutwin.ve;
-                                devp->parm.info.fmt = parm.info.fmt;
-                                devp->fmt_info_p  = tvin_get_fmt_info(devp->parm.info.fmt);
-                                if(!devp->fmt_info_p) {
-					pr_err("TVIN_IOC_START_DEC(%d) error, fmt is null \n", devp->index);
-					ret = -EFAULT;
-					mutex_unlock(&devp->fe_lock);
-					break;
-                                }
-				vdin_start_dec(devp);
-
-				devp->flags |= VDIN_FLAG_DEC_STARTED;
-				pr_info("TVIN_IOC_START_DEC port %s, decode started ok\n\n",
-						tvin_port_str(devp->parm.port));
-				mutex_unlock(&devp->fe_lock);
-				break;
-			}
-		case TVIN_IOC_STOP_DEC:
-			{
-				struct tvin_parm_s *parm = &devp->parm;
-
-				mutex_lock(&devp->fe_lock);
-				if(!(devp->flags & VDIN_FLAG_DEC_STARTED)) {
-					pr_err("TVIN_IOC_STOP_DEC(%d) decode havn't started\n", devp->index);
-					ret = -EPERM;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-
-				devp->flags |= VDIN_FLAG_DEC_STOP_ISR;
-				delay_cnt = 7;
-				while ((devp->flags & VDIN_FLAG_DEC_STOP_ISR) && delay_cnt)
-				{
-					mdelay(10);
-					delay_cnt--;
-				}
-
-				vdin_stop_dec(devp);
-                                /*
-				if (devp->flags & VDIN_FLAG_FORCE_UNSTABLE)
-				{
-					set_foreign_affairs(FOREIGN_AFFAIRS_00);
-					pr_info("video reset vpp.\n");
-				}
-				delay_cnt = 7;
-				while (get_foreign_affairs(FOREIGN_AFFAIRS_00) && delay_cnt)
-				{
-					mdelay(10);
-					delay_cnt--;
-				}
-                                */
-				/* init flag */
-				devp->flags &= ~VDIN_FLAG_DEC_STOP_ISR;
-				devp->flags &= ~VDIN_FLAG_FORCE_UNSTABLE;
-
-				/* clear the flag of decode started */
-				devp->flags &= (~VDIN_FLAG_DEC_STARTED);
-				pr_info("TVIN_IOC_STOP_DEC(%d) port %s, decode stop ok\n\n",
-						parm->index, tvin_port_str(parm->port));
-				mutex_unlock(&devp->fe_lock);
-				break;
-			}
-		case TVIN_IOC_VF_REG:
-			if ((devp->flags & VDIN_FLAG_DEC_REGED) == VDIN_FLAG_DEC_REGED) {
-				pr_err("TVIN_IOC_VF_REG(%d) decoder is registered already\n", devp->index);
-				ret = -EINVAL;
-				break;
-			}
-			devp->flags |= VDIN_FLAG_DEC_REGED;
-			vdin_vf_reg(devp);
-			pr_info("TVIN_IOC_VF_REG(%d) ok\n\n", devp->index);
-			break;
-		case TVIN_IOC_VF_UNREG:
-			if ((devp->flags & VDIN_FLAG_DEC_REGED) != VDIN_FLAG_DEC_REGED) {
-				pr_err("TVIN_IOC_VF_UNREG(%d) decoder isn't registered\n", devp->index);
-				ret = -EINVAL;
-				break;
-			}
-			devp->flags &= (~VDIN_FLAG_DEC_REGED);
-			vdin_vf_unreg(devp);
-			pr_info("TVIN_IOC_VF_REG(%d) ok\n\n", devp->index);
-			break;
-		case TVIN_IOC_CLOSE:
-			{
-				struct tvin_parm_s *parm = &devp->parm;
-				enum tvin_port_e port = parm->port;
-
-				mutex_lock(&devp->fe_lock);
-				if (!(devp->flags & VDIN_FLAG_DEC_OPENED)) {
-					pr_err("TVIN_IOC_CLOSE(%d) you have not opened port\n", devp->index);
-					ret = -EPERM;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-				vdin_close_fe(devp);
-
-				devp->flags &= (~VDIN_FLAG_DEC_OPENED);
-				pr_info("TVIN_IOC_CLOSE(%d) port %s closed ok\n\n", parm->index,
-						tvin_port_str(port));
-				mutex_unlock(&devp->fe_lock);
-				break;
-			}
-		case TVIN_IOC_S_PARM:
-			{
-				struct tvin_parm_s parm = {0};
-				if (copy_from_user(&parm, argp, sizeof(struct tvin_parm_s))) {
-					ret = -EFAULT;
-					break;
-				}
-				devp->parm.flag = parm.flag;
-				devp->parm.reserved = parm.reserved;
-				break;
-			}
-		case TVIN_IOC_G_PARM:
-			{
-				struct tvin_parm_s parm;
-				memcpy(&parm, &devp->parm, sizeof(tvin_parm_t));
-				if (devp->flags & VDIN_FLAG_FORCE_UNSTABLE)
-					parm.info.status = TVIN_SIG_STATUS_UNSTABLE;
-				if (copy_to_user(argp, &parm, sizeof(tvin_parm_t)))
-					ret = -EFAULT;
-				break;
-			}
-		case TVIN_IOC_G_SIG_INFO:
-			{
-				struct tvin_info_s info;
-				unsigned int frame_ratio = 0;
-				memset(&info, 0, sizeof(tvin_info_t));
-				mutex_lock(&devp->fe_lock);
-				/* if port is not opened, ignore this command */
-				if (!(devp->flags & VDIN_FLAG_DEC_OPENED)) {
-					ret = -EPERM;
-					mutex_unlock(&devp->fe_lock);
-					break;
-				}
-				memcpy(&info, &devp->parm.info, sizeof(tvin_info_t));
-				if (devp->flags & VDIN_FLAG_FORCE_UNSTABLE)
-					info.status = TVIN_SIG_STATUS_UNSTABLE;
-				/*meas the frame ratio for dvi save use parm.reserved high 8 bit*/
-				if ((devp->parm.port >= TVIN_PORT_HDMI0) &&
-						(devp->parm.port <= TVIN_PORT_HDMI7) )
-				{
-					info.reserved &= 0xffffff;
-					if(devp->cycle)
-					{
-						frame_ratio = (VDIN_CRYSTAL + (devp->cycle>>3))/devp->cycle;
-						info.reserved  |= (frame_ratio<<24);
-					}
-					if(vdin_dbg_en)
-						pr_info("current dvi frame ratio is %u.cycle is %u.\n",(info.reserved>>24),devp->cycle);
-				}
-				if (copy_to_user(argp, &info, sizeof(tvin_info_t))) {
-					ret = -EFAULT;
-					mutex_unlock(&devp->fe_lock);
-				}
-				mutex_unlock(&devp->fe_lock);
-				break;
-			}
-		case TVIN_IOC_G_BUF_INFO:
-			{
-				struct tvin_buf_info_s buf_info;
-				buf_info.buf_count	= devp->canvas_max_num;
-				buf_info.buf_width	= devp->canvas_w;
-				buf_info.buf_height = devp->canvas_h;
-				buf_info.buf_size	= devp->canvas_max_size;
-				buf_info.wr_list_size = devp->vfp->wr_list_size;
-				if (copy_to_user(argp, &buf_info, sizeof(struct tvin_buf_info_s)))
-					ret = -EFAULT;
-				break;
-			}
-		case TVIN_IOC_START_GET_BUF:
-			devp->vfp->wr_next = devp->vfp->wr_list.next;
-			break;
-		case TVIN_IOC_GET_BUF:
-			{
-				struct tvin_video_buf_s tvbuf;
-				struct vf_entry *vfe;
-				vfe = list_entry(devp->vfp->wr_next, struct vf_entry, list);
-				devp->vfp->wr_next = devp->vfp->wr_next->next;
-				if (devp->vfp->wr_next != &devp->vfp->wr_list) {
-					tvbuf.index = vfe->vf.index;
-				}
-				else {
-					tvbuf.index = -1;
-				}
-				if (copy_to_user(argp, &tvbuf, sizeof(struct tvin_video_buf_s)))
-					ret = -EFAULT;
-				break;
-			}
-		case TVIN_IOC_PAUSE_DEC:
-			vdin_pause_dec(devp);
-			break;
-		case TVIN_IOC_RESUME_DEC:
-			vdin_resume_dec(devp);
-			break;
-                case TVIN_IOC_FREEZE_VF:
-                        {
-                                mutex_lock(&devp->fe_lock);
-		                if(!(devp->flags & VDIN_FLAG_DEC_STARTED)) {
-		                        pr_err("TVIN_IOC_FREEZE_BUF(%d) decode havn't started\n", devp->index);
-			                ret = -EPERM;
-			                mutex_unlock(&devp->fe_lock);
-			                break;
-                                }
-
-                                if(devp->fmt_info_p->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE)
-                                        vdin_vf_freeze(devp->vfp, 1);
-                                else
-                                        vdin_vf_freeze(devp->vfp, 2);
-                                mutex_lock(&devp->fe_lock);
-                                break;
-                        }
-                case TVIN_IOC_UNFREEZE_VF:
-                        {
-                                mutex_lock(&devp->fe_lock);
-		                if(!(devp->flags & VDIN_FLAG_DEC_STARTED)) {
-		                        pr_err("TVIN_IOC_FREEZE_BUF(%d) decode havn't started\n", devp->index);
-			                ret = -EPERM;
-			                mutex_unlock(&devp->fe_lock);
-			                break;
-		                }
-                                vdin_vf_unfreeze(devp->vfp);
-                                mutex_lock(&devp->fe_lock);
-                                break;
-                        }
-		case TVIN_IOC_CALLMASTER_SET:
-			{
-				enum tvin_port_e port_call = TVIN_PORT_NULL;
-				tvin_frontend_t *frontend = NULL;
-				//struct vdin_dev_s *devp = dev_get_drvdata(dev);
-				if (copy_from_user(&port_call, argp, sizeof(enum tvin_port_e))) {
-					ret = -EFAULT;
-					break;
-				}
-				frontend = tvin_get_frontend(port_call,0);
-				if(frontend&&frontend->dec_ops&&frontend->dec_ops->callmaster_det){
-					/*call the frontend det function*/
-					callmaster_status = frontend->dec_ops->callmaster_det(port_call,frontend);
-				}
-				if(vdin_dbg_en)
-					printk("[vdin.%d]:%s callmaster_status=%d,port_call=[%s]\n",devp->index,__func__,callmaster_status,tvin_port_str(port_call));
-				break;
-			}
-		case TVIN_IOC_CALLMASTER_GET:
-			{
-				if (copy_to_user(argp, &callmaster_status, sizeof(int))){
-					ret = -EFAULT;
-					break;
-				}
-				callmaster_status=0;
-				break;
-			}
-		default:
-			ret = -ENOIOCTLCMD;
-			pr_info("%s %d is not supported command\n", __func__, cmd);
-			break;
-	}
-	return ret;
-}
-
-static int vdin_mmap(struct file *file, struct vm_area_struct * vma)
-{
-	vdin_dev_t *devp = file->private_data;
-	unsigned long start, len, off;
-	unsigned long pfn, size;
-
-	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
-		return -EINVAL;
-	}
-
-	start = devp->mem_start & PAGE_MASK;
-	len = PAGE_ALIGN((start & ~PAGE_MASK) + devp->mem_size);
-
-	off = vma->vm_pgoff << PAGE_SHIFT;
-
-	if ((vma->vm_end - vma->vm_start + off) > len) {
-		return -EINVAL;
-	}
-
-	off += start;
-	vma->vm_pgoff = off >> PAGE_SHIFT;
-
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-	vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
-
-	size = vma->vm_end - vma->vm_start;
-	pfn  = off >> PAGE_SHIFT;
-
-	if (io_remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot))
-		return -EAGAIN;
-
-	return 0;
-}
-
-static struct file_operations vdin_fops = {
-	.owner	         = THIS_MODULE,
-	.open	         = vdin_open,
-	.release         = vdin_release,
-	.unlocked_ioctl  = vdin_ioctl,
-	.mmap	         = vdin_mmap,
-};
-
-static ssize_t vdin_attr_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-        //struct vdin_dev_s *devp = dev_get_drvdata(dev);
-        ssize_t len = 0;
-        len += sprintf(buf+len,"\n0 HDMI0\t1 HDMI1\t2 HDMI2\t3 Component0\t4 Component1"
-                               "\n5 CVBS0\t6 CVBS1\t7 Vga0\t8 CVBS2\n");
-        len += sprintf(buf+len,"echo tvstart/v4l2start port fmt_id/resolution >/sys/class/vdin/vdinx/attr.\n");
-        return len;
-}
-static void vdin_dump_mem(char *path, vdin_dev_t *devp)
-{
-        struct file *filp = NULL;
-        loff_t pos = 0;
-        void * buf = NULL;
-        int i = 0;
-        unsigned int canvas_real_size = devp->canvas_h * devp->canvas_w;
-        mm_segment_t old_fs = get_fs();
-        set_fs(KERNEL_DS);
-        filp = filp_open(path,O_RDWR|O_CREAT,0666);
-
-        if(IS_ERR(filp)){
-                printk(KERN_ERR"create %s error.\n",path);
-                return;
-        }
-
-        for(i=0; i < devp->canvas_max_num; i++){
-                pos = canvas_real_size * i;
-                buf = phys_to_virt(devp->mem_start + devp->canvas_max_size*i);
-                vfs_write(filp,buf,canvas_real_size,&pos);
-                pr_info("write buffer %2d of %2u  to %s.\n",i,devp->canvas_max_num,path);
-        }
-        vfs_fsync(filp,0);
-        filp_close(filp,NULL);
-        set_fs(old_fs);
-}
-
-static void dump_other_mem(char *path,unsigned int start,unsigned int offset)
-{
-	struct file *filp = NULL;
-        loff_t pos = 0;
-        void * buf = NULL;
-        int i = 0;
-        mm_segment_t old_fs = get_fs();
-        set_fs(KERNEL_DS);
-        filp = filp_open(path,O_RDWR|O_CREAT,0666);
-        
-        if(IS_ERR(filp)){
-                printk(KERN_ERR"create %s error.\n",path);
-                return;
-       	}
-        buf = phys_to_virt(start);
-        vfs_write(filp,buf,offset,&pos);
-        pr_info("write from 0x%x to 0x%x to %s.\n",start,start+offset,path);
-        vfs_fsync(filp,0);
-        filp_close(filp,NULL);
-        set_fs(old_fs);
-}
-static void vdin_dump_state(vdin_dev_t *devp)
-{
-	struct vframe_s *vf = &devp->curr_wr_vfe->vf;
-        struct tvin_parm_s *curparm = &devp->parm;
-	int i = 0;
-	pr_info("h_active = %d, v_active = %d\n", devp->h_active, devp->v_active);
-	pr_info("signal format	= %s(0x%x)\n"
-			"trans_fmt	= %s(%d)\n"
-			"color_format	= %s(%d)\n"
-			"format_convert = %s(%d)\n"
-			"aspect_ratio	= %s(%d)\n"
-			"pixel_repeat/dvi	= %u / %u\n",
-			tvin_sig_fmt_str(devp->parm.info.fmt), devp->parm.info.fmt,
-			tvin_trans_fmt_str(devp->prop.trans_fmt), devp->prop.trans_fmt,
-			tvin_color_fmt_str(devp->prop.color_format), devp->prop.color_format,
-			vdin_fmt_convert_str(devp->format_convert), devp->format_convert,
-			tvin_aspect_ratio_str(devp->prop.aspect_ratio), devp->prop.aspect_ratio,
-			devp->prop.pixel_repeat, devp->prop.dvi_info);
-	vdin_dump_vf_state(devp->vfp);
-	if(vf){
-		pr_info("current vframe(%u):\n buf(w%u,h%u),type (0x%x,%u), duration(%d)\n",
-                          vf->index,vf->width,vf->height,vf->type,vf->type, vf->duration);
-		pr_info(" trans fmt %u,left_start_x %u,right_start_x %u,width_x %u\n"
-	      		  " left_start_y %u,right_start_y %u,height_y %u\n",
-	      		  vf->trans_fmt,vf->left_eye.start_x,vf->right_eye.start_x,vf->left_eye.width,
-	      		  vf->left_eye.start_y,vf->right_eye.start_y,vf->left_eye.height);
-                pr_info("current parameters:\n frontend of vdin index: %d, 3d flag: 0x%x, reserved 0x%x,"
-                        " devp->flags:0x%x, max buffer num %u.\n",curparm->index,  curparm->flag,
-                        curparm->reserved, devp->flags,devp->canvas_max_num);
-        }
-
-	pr_info("Vdin driver version: %s\n",VDIN_VER);
-}
-/*
-* 1.show the current frame rate
-* echo fps >/sys/class/vdin/vdinx/attr
-* 2.dump the data from vdin memory
-* echo capture dir >/sys/class/vdin/vdinx/attr
-* 3.start the vdin hardware
-* echo tvstart/v4l2start port fmt_id/resolution(width height frame_rate) >dir
-* 4.freeze the vdin buffer
-* echo freeze/unfreeze >/sys/class/vdin/vdinx/attr
-* 5.enable vdin0-nr path or vdin0-mem
-* echo output2nr >/sys/class/vdin/vdin0/attr
-* echo output2mem >/sys/class/vdin/vdin0/attr
-* 6.modify for vdin fmt & color fmt convertion
-* echo convertion w h cfmt >/sys/class/vdin/vdin0/attr
-*/
-static ssize_t vdin_attr_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t len)
-{
-        unsigned int n=0, fps=0;
-        char ret=0,*buf_orig,*parm[6] = {NULL};
-        cam_parameter_t tmp_isp;
-        struct vdin_dev_s *devp;
-
-        if(!buf)
-		return len;
-        buf_orig = kstrdup(buf, GFP_KERNEL);
-        //printk(KERN_INFO "input cmd : %s",buf_orig);
-        devp = dev_get_drvdata(dev);
-        parse_param(buf_orig,&parm);
-
-        if(!strcmp(parm[0],"cm2")){
-		set_chroma_regs(devp->addr_offset,devp->h_active,devp->v_active);
-	}else if(!strncmp(parm[0], "fps", 3)){
-		if(devp->cycle)
-			fps = (VDIN_CRYSTAL + (devp->cycle>>3))/devp->cycle;
-                pr_info("%u f/s\n",fps);
-        }
-        else if(!strcmp(parm[0],"capture")){
-		if(parm[3] != NULL){
-			unsigned int start,offset;
-			start = simple_strtol(parm[2],NULL,16);
-			offset = simple_strtol(parm[3],NULL,16);
-			dump_other_mem(parm[1],start,offset);	
-		}else if(parm[1] != NULL){                        
-                        vdin_dump_mem(parm[1],devp);
-                }
-        }
-        else if(!strcmp(parm[0],"tvstart")){
-                unsigned int port, fmt;
-                port = simple_strtol(parm[1],NULL,10);
-                switch(port){
-                        case 0://HDMI0
-                                port = TVIN_PORT_HDMI0;
-                                break;
-                        case 1://HDMI1
-                                port = TVIN_PORT_HDMI1;
-                                break;
-                        case 2://HDMI2
-                                port = TVIN_PORT_HDMI2;
-                                break;
-                        case 3://Component0
-                                port = TVIN_PORT_COMP0;
-                                break;
-                        case 4://Component1
-                                port = TVIN_PORT_COMP1;
-                                break;
-                        case 5://CVBS0
-                                port = TVIN_PORT_CVBS0;
-                                break;
-                        case 6://CVBS1
-                                port = TVIN_PORT_CVBS1;
-                                break;
-                        case 7://Vga0
-                                port = TVIN_PORT_VGA0;
-                                break;
-                        case 8://CVBS2
-                                port = TVIN_PORT_CVBS2;
-                                break;
-                        default:
-                                port = TVIN_PORT_CVBS0;
-                                break;
-                }
-                fmt = simple_strtol(parm[2],NULL,16);
-
-                devp->flags |= VDIN_FLAG_FS_OPENED;
-	        /* request irq */
-	        snprintf(devp->irq_name, sizeof(devp->irq_name),  "vdin%d-irq", devp->index);
-	        if (work_mode_simple) {
-		        pr_info("vdin work in simple mode\n");
-		        ret = request_irq(devp->irq, vdin_isr_simple, IRQF_SHARED, devp->irq_name, (void *)devp);
-	        }
-	        else {
-		        pr_info("vdin work in normal mode\n");
-		        ret = request_irq(devp->irq, vdin_isr, IRQF_SHARED, devp->irq_name, (void *)devp);
-	        }
-
-                /*disable irq untill vdin is configured completely*/
-                disable_irq_nosync(devp->irq);
-	        /* remove the hardware limit to vertical [0-max]*/
-	        WRITE_VCBUS_REG(VPP_PREBLEND_VD1_V_START_END, 0x00000fff);
-	        pr_info("open device %s ok\n", dev_name(devp->dev));
-                vdin_open_fe(port,0,devp);
-                devp->parm.port = port;
-                devp->parm.info.fmt = fmt;
-                devp->fmt_info_p  = tvin_get_fmt_info(fmt);
-		devp->flags |= VDIN_FLAG_DEC_STARTED;
-                vdin_start_dec(devp);
-        }
-        else if(!strcmp(parm[0],"tvstop")){
-                vdin_stop_dec(devp);
-                vdin_close_fe(devp);
-                devp->flags &= (~VDIN_FLAG_FS_OPENED);
-		devp->flags &= (~VDIN_FLAG_DEC_STARTED);
-	        /* free irq */
-	        free_irq(devp->irq,(void *)devp);
-	        /* reset the hardware limit to vertical [0-1079]  */
-	        WRITE_VCBUS_REG(VPP_PREBLEND_VD1_V_START_END, 0x00000437);
-        }
-        else if(!strcmp(parm[0],"v4l2stop")){
-                stop_tvin_service(devp->index);
-        }
-        else if(!strcmp(parm[0],"v4l2start")){
-                struct vdin_parm_s param;
-                if(!parm[4]){
-                        pr_err("usage: echo v4l2start port width height fps cfmt >/sys/class/vdin/vdinx/attr."
-                                     "\n port mybe bt656 or viuin,fps the frame rate of input.\n");
-                        return len;
-                }
-                memset(&param,0,sizeof(vdin_parm_t));
-                /*parse the port*/
-                if(!strcmp(parm[1],"bt656"))
-                        param.port = TVIN_PORT_CAMERA;
-                else if(!strcmp(parm[1],"viuin"))
-                        param.port = TVIN_PORT_VIU;
-		if(!strcmp(parm[1],"isp"))
-                        param.port = TVIN_PORT_ISP;
-                /*parse the resolution*/
-                param.h_active = simple_strtol(parm[2],NULL,10);
-                param.v_active = simple_strtol(parm[3],NULL,10);
-                param.frame_rate = simple_strtol(parm[4],NULL,10);
-		if(!parm[5])
-			param.cfmt = TVIN_YUV422;
-		else
-		        param.cfmt = simple_strtol(parm[5],NULL,10);
-                param.fmt = TVIN_SIG_FMT_MAX;
-                param.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
-                /*start the vdin hardware*/
-                start_tvin_service(devp->index, &param);
-        }
-        else if(!strcmp(parm[0],"disablesm"))
-                del_timer_sync(&devp->timer);
-        else if(!strcmp(parm[0],"freeze")){
-                if (!(devp->flags & VDIN_FLAG_DEC_STARTED))
-                        return len;
-                if(devp->fmt_info_p->scan_mode == TVIN_SCAN_MODE_PROGRESSIVE)
-                        vdin_vf_freeze(devp->vfp, 1);
-                else
-                        vdin_vf_freeze(devp->vfp, 2);
-
-        }
-        else if(!strcmp(parm[0],"unfreeze")){
-                if (!(devp->flags & VDIN_FLAG_DEC_STARTED))
-                        return len;
-                vdin_vf_unfreeze(devp->vfp);
-        }
-        else if(!strcmp(parm[0],"convertion")){
-                if(parm[1] && parm[2] && parm[3]){
-                        devp->scaler4w  = simple_strtoul(parm[1],NULL,10);
-                        devp->scaler4h  = simple_strtoul(parm[2],NULL,10);
-			devp->dest_cfmt = simple_strtoul(parm[3],NULL,10); 
-			devp->flags |= VDIN_FLAG_MANUAL_CONVERTION;
-			pr_info("enable manual convertion w=%u h=%u dest_cfmt=%s.\n",
-				devp->scaler4w,devp->scaler4h,tvin_color_fmt_str(devp->dest_cfmt));
-                } else {
-                	devp->flags &= (~VDIN_FLAG_MANUAL_CONVERTION);
-                        pr_info("disable manual convertion w=%u h=%u dest_cfmt=%s.\n",
-				devp->scaler4w,devp->scaler4h,tvin_color_fmt_str(devp->dest_cfmt));
-                }
-        }
-        else if(!strcmp(parm[0],"state")){
-
-				vdin_dump_state(devp);
-
-	}
-        else if(!strcmp(parm[0],"force_recycle")) {
-                devp->flags |= VDIN_FLAG_FORCE_RECYCLE;
-        }
-
-
-        kfree(buf_orig);
-        return len;
-}
-static DEVICE_ATTR(attr, 0664, vdin_attr_show, vdin_attr_store);
-#ifdef VF_LOG_EN
-static ssize_t vdin_vf_log_show(struct device * dev,
-		struct device_attribute *attr, char * buf)
-{
-	int len = 0;
-	struct vdin_dev_s *devp = dev_get_drvdata(dev);
-	struct vf_log_s *log = &devp->vfp->log;
-
-	len += sprintf(buf + len, "%d of %d\n", log->log_cur, VF_LOG_LEN);
-	return len;
-}
-
-static ssize_t vdin_vf_log_store(struct device * dev,
-		struct device_attribute *attr, const char * buf, size_t count)
-{
-	struct vdin_dev_s *devp = dev_get_drvdata(dev);
-
-#ifdef SMOOTH_DEBUG
-  if(!strncmp(buf, "count", 5)){
-    dump_count();
-  }
-	else
-#endif
-	if(!strncmp(buf, "start", 5)){
-		vf_log_init(devp->vfp);
-	}
-	else if (!strncmp(buf, "print", 5)) {
-		vf_log_print(devp->vfp);
-	}
-	else
-	{
-		pr_info("unknow command: %s\n"
-				"Usage:\n"
-				"a. show log messsage:\n"
-				"echo print > /sys/class/vdin/vdin0/vf_log\n"
-				"b. restart log message:\n"
-				"echo start > /sys/class/vdin/vdin0/vf_log\n"
-				"c. show log records\n"
-				"cat > /sys/class/vdin/vdin0/vf_log\n" , buf);
-	}
-	return count;
-}
-
-/*
-   1. show log length.
-   cat /sys/class/vdin/vdin0/vf_log
-   cat /sys/class/vdin/vdin1/vf_log
-   2. clear log buffer and start log.
-   echo start > /sys/class/vdin/vdin0/vf_log
-   echo start > /sys/class/vdin/vdin1/vf_log
-   3. print log
-   echo print > /sys/class/vdin/vdin0/vf_log
-   echo print > /sys/class/vdin/vdin1/vf_log
- */
-static DEVICE_ATTR(vf_log, 0664, vdin_vf_log_show, vdin_vf_log_store);
-#endif //VF_LOG_EN
-
-static ssize_t vdin_debug_for_isp_show(struct device * dev,
-   struct device_attribute *attr, char * buf)
-{
-   int len = 0;
-   
-   return len;
-   }
-
-static ssize_t vdin_debug_for_isp_store(struct device * dev,
-   struct device_attribute *attr, const char * buf, size_t count)
-{
-        char ret=0,*buf_orig,*parm[6] = {NULL};
-        cam_parameter_t tmp_isp;
-        struct vdin_dev_s *devp;
-
-        if(!buf)
-		return count;
-        buf_orig = kstrdup(buf, GFP_KERNEL);
-        devp = dev_get_drvdata(dev);
-        parse_param(buf_orig,&parm);
-
-	if(!strcmp(parm[0], "bypass_isp")){
-                vdin_bypass_isp(devp->addr_offset);
-		tmp_isp.cam_command = CMD_ISP_BYPASS;
-		if(devp->frontend->dec_ops->ioctl)
-			devp->frontend->dec_ops->ioctl(devp->frontend,(void *)&tmp_isp);
-		pr_info("vdin bypass isp for raw data.\n");              
-        }
-        return count;
-}
-
-static DEVICE_ATTR(debug_for_isp, 0664, vdin_debug_for_isp_show, vdin_debug_for_isp_store);
- 
-
-
-#ifdef ISR_LOG_EN
-static ssize_t vdin_isr_log_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	u32 len = 0;
-	struct vdin_dev_s *vdevp;
-	vdevp = dev_get_drvdata(dev);
-                len += sprintf(buf + len, "%d of %d\n", vdevp->vfp->isr_log.log_cur, ISR_LOG_LEN);
-	return len;
-}
-/*
-*1. show isr log length.
-*cat /sys/class/vdin/vdin0/vf_log
-*2. clear isr log buffer and start log.
-*echo start > /sys/class/vdin/vdinx/isr_log
-*3. print isr log
-*echo print > /sys/class/vdin/vdinx/isr_log
-*/
-static ssize_t vdin_isr_log_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct vdin_dev_s *vdevp;
-	vdevp = dev_get_drvdata(dev);
-        if(!strncmp(buf,"start",5))
-	        isr_log_init(vdevp->vfp);
-        else if(!strncmp(buf,"print",5))
-                isr_log_print(vdevp->vfp);
-	return count;
-}
-
-static DEVICE_ATTR(isr_log,  0664, vdin_isr_log_show, vdin_isr_log_store);
-#endif
-
-static ssize_t vdin_crop_show(struct device * dev,
-struct device_attribute *attr, char * buf)
-{
-        int len = 0;
-        struct vdin_dev_s *devp = dev_get_drvdata(dev);
-        tvin_cutwin_t *crop = &devp->parm.cutwin;
-
-        len += sprintf(buf+len,"hs_offset %u,he_offset %u,vs_offset %u,ve_offset %u.\n",
-				crop->hs,crop->he,crop->vs,crop->ve);
-	return len;
-}
-
-static ssize_t vdin_crop_store(struct device * dev,
-struct device_attribute *attr, const char * buf, size_t count)
-{
-	char *parm[4]={NULL},*buf_orig;
-	struct vdin_dev_s *devp = dev_get_drvdata(dev);
-	tvin_cutwin_t *crop = &devp->parm.cutwin;
-	if(!buf)
-		return count;
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	parse_param(buf_orig,parm);
-	
-	crop->hs = simple_strtol(parm[0],NULL,10);
-	crop->he = simple_strtol(parm[1],NULL,10);
-	crop->vs = simple_strtol(parm[2],NULL,10);
-	crop->ve = simple_strtol(parm[3],NULL,10);
-
-	pr_info("hs_offset %u,he_offset %u,vs_offset %u,ve_offset %u.\n",	
-                                crop->hs,crop->he,crop->vs,crop->ve);
-			
-	return count;
-}
-
-static DEVICE_ATTR(crop, 0664, vdin_crop_show, vdin_crop_store);
-
-static int memp = -1;
-
-static char * memp_str(int profile)
-{
-	switch (profile) {
-	case MEMP_VDIN_WITHOUT_3D:
-		return "vdin without 3d";
-	case MEMP_VDIN_WITH_3D:
-		return "vdin with 3d";
-	case MEMP_DCDR_WITHOUT_3D:
-		return "decoder without 3d";
-	case MEMP_DCDR_WITH_3D:
-		return "decoder with 3d";
-	case MEMP_ATV_WITHOUT_3D:
-		return "atv without 3d";
-	case MEMP_ATV_WITH_3D:
-		return "atv with 3d";
-	default:
-		return "unkown";
-	}
-}
-
-/*
- * cat /sys/class/vdin/memp
- */
-static ssize_t memp_show(struct class *class,
-	struct class_attribute *attr, char *buf)
-{
-	int len = 0;
-	len += sprintf(buf+len, "%d: %s\n", memp, memp_str(memp));
-	return len;
-}
-
-/*
- * echo 0|1|2|3|4|5 > /sys/class/vdin/memp
- */
-static ssize_t memp_store(struct class *class,
-	struct class_attribute *attr, const char *buf, size_t count)
-{
-	memp = simple_strtol(buf, NULL, 0);
-
-	switch (memp) {
-	case MEMP_VDIN_WITHOUT_3D:
-	case MEMP_VDIN_WITH_3D:
-#ifdef CONFIG_ARCH_MESON6TV
-#ifndef CONFIG_MESON_M6C_ENHANCEMENT
-                aml_set_reg32_mask(P_MMC_QOS0_CTRL, 1<<25);
-		aml_set_reg32_mask(P_MMC_QOS3_CTRL, 1<<25);
-		aml_set_reg32_mask(P_MMC_QOS4_CTRL, 1<<25);
-		aml_set_reg32_mask(P_MMC_QOS5_CTRL, 1<<25);
-                aml_set_reg32_mask(P_VPU_VD1_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_MEM_MMC_CTRL, 1<<12);
-		aml_set_reg32_mask(P_VPU_DI_INP_MMC_CTRL, 1<<12);
-		aml_set_reg32_mask(P_VPU_DI_CHAN2_MMC_CTRL, 1<<12);
-		aml_set_reg32_mask(P_VPU_DI_MTNWR_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_NRWR_MMC_CTRL, 1<<12);
-		aml_write_reg32(P_MMC_CHAN0_CTRL, 0x610ff);
-		aml_write_reg32(P_MMC_CHAN1_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN2_CTRL, 0x70ff);
-		aml_write_reg32(P_MMC_CHAN3_CTRL, 0xc01f);
-		aml_write_reg32(P_MMC_CHAN6_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN7_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN8_CTRL, 0x10ff);
-#else
-                // echo 0 > /sys/module/di/parameters/pre_urgent     //           disable urgent for DI pre
-                // echo 0 > /sys/module/di/parameters/input2pre      //           disable input2pre
-                aml_clr_reg32_mask(P_MMC_PARB_CTRL, 1<<16);          //           enable A9 urgent for better CPU performance
-                aml_set_reg32_mask(P_VPU_VD1_MMC_CTRL, 1<<12);       //           arb0
-                aml_set_reg32_mask(P_VPU_VD2_MMC_CTRL, 1<<12);       //           arb0
-                aml_set_reg32_mask(P_VPU_DI_IF1_MMC_CTRL, 1<<12);    //           arb0
-                aml_clr_reg32_mask(P_VPU_DI_MEM_MMC_CTRL, 1<<12);    //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_INP_MMC_CTRL, 1<<12);    //           arb1
-                aml_set_reg32_mask(P_VPU_DI_MTNRD_MMC_CTRL, 1<<12);  //           arb0
-                aml_clr_reg32_mask(P_VPU_DI_CHAN2_MMC_CTRL, 1<<12);  //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_MTNWR_MMC_CTRL, 1<<12);  //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_NRWR_MMC_CTRL, 1<<12);   //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_DIWR_MMC_CTRL, 1<<12);   //           arb1
-#endif
-#endif
-		break;
-	case MEMP_DCDR_WITHOUT_3D:
-	case MEMP_DCDR_WITH_3D:
-#ifdef CONFIG_ARCH_MESON6TV
-#ifndef CONFIG_MESON_M6C_ENHANCEMENT
-                aml_set_reg32_mask(P_MMC_QOS0_CTRL, 1<<25);
-		aml_set_reg32_mask(P_MMC_QOS3_CTRL, 1<<25);
-		aml_set_reg32_mask(P_MMC_QOS4_CTRL, 1<<25);
-		aml_clr_reg32_mask(P_MMC_QOS5_CTRL, 1<<25);
-                aml_set_reg32_mask(P_VPU_VD1_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_MEM_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_INP_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_CHAN2_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_MTNWR_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_NRWR_MMC_CTRL, 1<<12);
-		aml_write_reg32(P_MMC_CHAN0_CTRL, 0x6307f);
-		aml_write_reg32(P_MMC_CHAN1_CTRL, 0x70ff);
-		aml_write_reg32(P_MMC_CHAN2_CTRL, 0x30ff);
-		aml_write_reg32(P_MMC_CHAN3_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN6_CTRL, 0x30ff);
-		aml_write_reg32(P_MMC_CHAN7_CTRL, 0x307f);
-		aml_write_reg32(P_MMC_CHAN8_CTRL, 0x30ff);
-#else
-                // echo 0 > /sys/module/di/parameters/pre_urgent     //           disable urgent for DI pre
-                aml_clr_reg32_mask(P_MMC_PARB_CTRL, 1<<16);          //           enable A9 urgent for better CPU performance
-                aml_set_reg32_mask(P_VPU_VD1_MMC_CTRL, 1<<12);       //           arb0
-                aml_set_reg32_mask(P_VPU_VD2_MMC_CTRL, 1<<12);       //           arb0
-                aml_set_reg32_mask(P_VPU_DI_IF1_MMC_CTRL, 1<<12);    //           arb0
-                aml_clr_reg32_mask(P_VPU_DI_MEM_MMC_CTRL, 1<<12);    //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_INP_MMC_CTRL, 1<<12);    //           arb1
-                aml_set_reg32_mask(P_VPU_DI_MTNRD_MMC_CTRL, 1<<12);  //           arb0
-                aml_clr_reg32_mask(P_VPU_DI_CHAN2_MMC_CTRL, 1<<12);  //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_MTNWR_MMC_CTRL, 1<<12);  //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_NRWR_MMC_CTRL, 1<<12);   //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_DIWR_MMC_CTRL, 1<<12);   //           arb1
-#endif
-#endif
-		break;
-	case MEMP_ATV_WITHOUT_3D:
-	case MEMP_ATV_WITH_3D:
-#ifdef CONFIG_ARCH_MESON6TV
-#ifndef CONFIG_MESON_M6C_ENHANCEMENT
-                aml_set_reg32_mask(P_MMC_QOS0_CTRL, 1<<25);
-		aml_clr_reg32_mask(P_MMC_QOS3_CTRL, 1<<25);
-		aml_set_reg32_mask(P_MMC_QOS4_CTRL, 1<<25);
-		aml_clr_reg32_mask(P_MMC_QOS5_CTRL, 1<<25);
-                aml_set_reg32_mask(P_VPU_VD1_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_MEM_MMC_CTRL, 1<<12);
-		aml_set_reg32_mask(P_VPU_DI_INP_MMC_CTRL, 1<<12);
-		aml_set_reg32_mask(P_VPU_DI_CHAN2_MMC_CTRL, 1<<12);
-		aml_set_reg32_mask(P_VPU_DI_MTNWR_MMC_CTRL, 1<<12);
-		aml_clr_reg32_mask(P_VPU_DI_NRWR_MMC_CTRL, 1<<12);
-		aml_write_reg32(P_MMC_CHAN0_CTRL, 0x610ff);
-		aml_write_reg32(P_MMC_CHAN1_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN2_CTRL, 0x70ff);
-		aml_write_reg32(P_MMC_CHAN3_CTRL, 0xc01f);
-		aml_write_reg32(P_MMC_CHAN6_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN7_CTRL, 0x10ff);
-		aml_write_reg32(P_MMC_CHAN8_CTRL, 0x10ff);
-#else
-                // echo 0 > /sys/module/di/parameters/pre_urgent     //           disable urgent for DI pre
-                // echo 0 > /sys/module/di/parameters/input2pre      //           disable input2pre
-                aml_clr_reg32_mask(P_MMC_PARB_CTRL, 1<<16);          //           enable A9 urgent for better CPU performance
-                aml_set_reg32_mask(P_VPU_VD1_MMC_CTRL, 1<<12);       //           arb0
-                aml_set_reg32_mask(P_VPU_VD2_MMC_CTRL, 1<<12);       //           arb0
-                aml_set_reg32_mask(P_VPU_DI_IF1_MMC_CTRL, 1<<12);    //           arb0
-                aml_clr_reg32_mask(P_VPU_DI_MEM_MMC_CTRL, 1<<12);    //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_INP_MMC_CTRL, 1<<12);    //           arb1
-                aml_set_reg32_mask(P_VPU_DI_MTNRD_MMC_CTRL, 1<<12);  //           arb0
-                aml_clr_reg32_mask(P_VPU_DI_CHAN2_MMC_CTRL, 1<<12);  //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_MTNWR_MMC_CTRL, 1<<12);  //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_NRWR_MMC_CTRL, 1<<12);   //           arb1
-                aml_clr_reg32_mask(P_VPU_DI_DIWR_MMC_CTRL, 1<<12);   //           arb1
-
-                aml_set_reg32_mask(P_VPU_TVD3D_MMC_CTRL, 1<<14);     //           arb2
-                aml_set_reg32_mask(P_VPU_TVD3D_MMC_CTRL, 1<<15);     //           urgent
-                aml_set_reg32_mask(P_VPU_TVDVBI_MMC_CTRL, 1<<14);    //           arb2
-                aml_set_reg32_mask(P_VPU_TVD3D_MMC_CTRL, 1<<15);     //           urgent
-#endif
-#endif
-		break;
-	default:
-		/* @todo */
-		break;
-	}
-	return count;
-}
-
-static CLASS_ATTR(memp, 0644, memp_show, memp_store);
-
-static ssize_t vdin_cm2_show(struct device *dev, 
-             struct device_attribute *attr,
-			                     char *buf)
-{
-    struct vdin_dev_s *devp;
-	unsigned int addr_port = VDIN_CHROMA_ADDR_PORT;
-	unsigned int data_port = VDIN_CHROMA_DATA_PORT;
-	
-    devp = dev_get_drvdata(dev);
-    if (devp->addr_offset != 0)     {
-        addr_port = VDIN_CHROMA_ADDR_PORT + devp->addr_offset;
-	    data_port = VDIN_CHROMA_DATA_PORT + devp->addr_offset;	    
-    }
-    pr_info("addr_port: [0x%x] data_port: : [0x%x]\n",addr_port, data_port);
-    
-	pr_info("Usage:");
-	pr_info("	echo wm addr data0 data1 data2 data3 data4 > /sys/class/vdin/vdin0/cm2 \n");
-	pr_info("	echo rm addr > /sys/class/vdin/vdin0/cm2 \n");
-	pr_info("	echo wm addr data0 data1 data2 data3 data4 > /sys/class/vdin/vdin1/cm2 \n");
-	pr_info("	echo rm addr > /sys/class/vdin/vdin1/cm2 \n");
-	return 0;
-}
-
-static ssize_t vdin_cm2_store(struct device *dev, 
-              struct device_attribute *attr,
-		   const char *buffer, size_t count)
-{
-    struct vdin_dev_s *devp;	        
-	int n = 0;
-	char *buf_orig, *ps, *token;
-	char *parm[7];
-	u32 addr, val, bit;
-	int data[5] = {0};
-	unsigned int addr_port = VDIN_CHROMA_ADDR_PORT;
-	unsigned int data_port = VDIN_CHROMA_DATA_PORT;
-	
-    devp = dev_get_drvdata(dev);
-    if (devp->addr_offset != 0)     {
-        addr_port = VDIN_CHROMA_ADDR_PORT + devp->addr_offset;
-	    data_port = VDIN_CHROMA_DATA_PORT + devp->addr_offset;	    
-    }
-	buf_orig = kstrdup(buffer, GFP_KERNEL);
-	ps = buf_orig;
-	while (1) {
-		token = strsep(&ps, " \n");
-		if (token == NULL)
-			break;
-		if (*token == '\0')
-			continue;
-		parm[n++] = token;
-	}
-
-	if ((parm[0][0] == 'w') && parm[0][1] == 'm' ) {
-		if (n != 7) {
-			pr_info("read: invalid parameter\n");
-			pr_info("please: cat /sys/class/vdin/vdin0/cm2 \n");
-			kfree(buf_orig);
-			return count;
-		}
-		addr = simple_strtol(parm[1], NULL, 16);
-		addr = addr - addr%8;
-		data[0] = simple_strtol(parm[2], NULL, 16);
-		data[1] = simple_strtol(parm[3], NULL, 16);
-		data[2] = simple_strtol(parm[4], NULL, 16);
-		data[3] = simple_strtol(parm[5], NULL, 16);
-		data[4] = simple_strtol(parm[6], NULL, 16);
-
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr);
-		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[0]);
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 1);
-		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[1]);
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 2);
-		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[2]);
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 3);
-		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[3]);
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 4);
-		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[4]);
-
-		pr_info("wm: [0x%x] <-- 0x0 \n",addr);
-	}
-	else if ((parm[0][0] == 'r') && parm[0][1] == 'm' ) {
-		if (n != 2) {
-			pr_info("read: invalid parameter\n");
-			pr_info("please: cat /sys/class/vdin/vdin0/cm2 \n");
-			kfree(buf_orig);
-			return count;
-		}
-		addr = simple_strtol(parm[1], NULL, 16);
-		addr = addr - addr%8;
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr);
-		data[0] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[0] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[0] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+1);
-		data[1] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[1] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[1] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+2);
-		data[2] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[2] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[2] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+3);
-		data[3] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[3] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[3] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+4);
-		data[4] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[4] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-		data[4] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
-
-		pr_info("rm:[0x%x]-->[0x%x][0x%x][0x%x][0x%x][0x%x] \n",addr, data[0],data[1],data[2],data[3],data[4]);
-	}else if (!strcmp(parm[0],"enable")){
-		WRITE_VCBUS_REG_BITS(VDIN_CM_BRI_CON_CTRL+devp->addr_offset,1,CM_TOP_EN_BIT,CM_TOP_EN_WID);
-	}else if (!strcmp(parm[0],"disable")){
-		WRITE_VCBUS_REG_BITS(VDIN_CM_BRI_CON_CTRL+devp->addr_offset,0,CM_TOP_EN_BIT,CM_TOP_EN_WID);
-	} else {
-		pr_info("invalid command\n");
-		pr_info("please: cat /sys/class/vdin/vdin0/bit");
-	}
-	kfree(buf_orig);
-	return count;
-
-}
-
-static DEVICE_ATTR(cm2, S_IWUSR | S_IRUGO, vdin_cm2_show, vdin_cm2_store);
-
-
-static int vdin_add_cdev(struct cdev *cdevp, struct file_operations *fops,
-		int minor)
-{
-	int ret;
-	dev_t devno = MKDEV(MAJOR(vdin_devno), minor);
-	cdev_init(cdevp, fops);
-	cdevp->owner = THIS_MODULE;
-	ret = cdev_add(cdevp, devno, 1);
-	return ret;
-}
-
-static struct device * vdin_create_device(struct device *parent, int minor)
-{
-	dev_t devno = MKDEV(MAJOR(vdin_devno), minor);
-	return device_create(vdin_clsp, parent, devno, NULL, "%s%d",
-			VDIN_DEV_NAME, minor);
-}
-
-static void vdin_delete_device(int minor)
-{
-	dev_t devno = MKDEV(MAJOR(vdin_devno), minor);
-	device_destroy(vdin_clsp, devno);
-}
-
-static struct resource memobj;
-static int vdin_drv_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct vdin_dev_s *vdevp;
-	struct resource *res;
-
-	/* malloc vdev */
-	vdevp = kmalloc(sizeof(struct vdin_dev_s), GFP_KERNEL);
-	if (!vdevp) {
-		pr_err("%s: failed to allocate memory.\n", __func__);
-		goto fail_kmalloc_vdev;
-	}
-	memset(vdevp, 0, sizeof(struct vdin_dev_s));
-	#ifdef CONFIG_USE_OF
-	if (pdev->dev.of_node) {
-	        ret = of_property_read_u32(pdev->dev.of_node,"vdin_id",&(vdevp->index));
-		if(ret) {
-			pr_err("don't find  vdin id.\n");
-			goto fail_get_resource_irq;
-		}
-	}
-	#else
-	vdevp->index = pdev->id;
-        #endif
-	vdin_devp[vdevp->index] = vdevp;
-	/* create cdev and reigser with sysfs */
-	ret = vdin_add_cdev(&vdevp->cdev, &vdin_fops, pdev->id);
-	if (ret) {
-		pr_err("%s: failed to add cdev.\n", __func__);
-		goto fail_add_cdev;
-	}
-	vdevp->dev = vdin_create_device(&pdev->dev, vdevp->index);
-	if (IS_ERR(vdevp->dev)) {
-		pr_err("%s: failed to create device.\n", __func__);
-		ret = PTR_ERR(vdevp->dev);
-		goto fail_create_device;
-	}
-
-	ret = device_create_file(vdevp->dev,&dev_attr_sig_det);
-	/* create sysfs attribute files */
-        #ifdef VF_LOG_EN
-        ret = device_create_file(vdevp->dev,&dev_attr_vf_log);
-        #endif
-        #ifdef ISR_LOG_EN
-        ret = device_create_file(vdevp->dev,&dev_attr_isr_log);
-        #endif
-        ret = device_create_file(vdevp->dev,&dev_attr_attr);
-        ret = device_create_file(vdevp->dev,&dev_attr_cm2);
-	ret = device_create_file(vdevp->dev,&dev_attr_crop);
-	ret = device_create_file(vdevp->dev,&dev_attr_debug_for_isp);
-	if(ret < 0) {
-		pr_err("%s: fail to create vdin attribute files.\n", __func__);
-		goto fail_create_dev_file;
-	}
-	/* get memory address from resource */
-#if 0	
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-#else
-    res = &memobj;
-    ret = find_reserve_block(pdev->dev.of_node->name,0);
-    if(ret < 0){
-        pr_err("\nvdin memory resource undefined.\n");
-        return -EFAULT;
-    }
-    res->start = (phys_addr_t)get_reserve_block_addr(ret);
-    res->end = res->start+ (phys_addr_t)get_reserve_block_size(ret)-1;
-#endif
-	if (!res) {
-		pr_err("%s: can't get mem resource\n", __func__);
-		ret = -ENXIO;
-		goto fail_get_resource_mem;
-	}
-
-	vdevp->mem_start = res->start;
-	vdevp->mem_size  = res->end - res->start + 1;
-	pr_info("vdin%d mem_start = 0x%x, mem_size = 0x%x\n", vdevp->index,
-			vdevp->mem_start,vdevp->mem_size);
-
-
-	/* get irq from resource */
-	#ifdef CONFIG_USE_OF
-	if (pdev->dev.of_node) {
-	        ret = of_property_read_u32(pdev->dev.of_node,"irq",&(res->start));
-		if(ret) {
-			pr_err("don't find  match irq\n");
-			goto fail_get_resource_irq;
-		}
-		res->end = res->start;
-		res->flags = IORESOURCE_IRQ;
-	}
-	#else
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!res) {
-		pr_err("%s: can't get irq resource\n", __func__);
-		ret = -ENXIO;
-		goto fail_get_resource_irq;
-	}
-	#endif
-	vdevp->irq = res->start;
-        snprintf(vdevp->irq_name, sizeof(vdevp->irq_name),  "vdin%d-irq", vdevp->index);
-	/* init vdin parameters */
-	vdevp->flags = VDIN_FLAG_NULL;
-	vdevp->flags &= (~VDIN_FLAG_FS_OPENED);
-	mutex_init(&vdevp->mm_lock);
-	mutex_init(&vdevp->fe_lock);
-	spin_lock_init(&vdevp->isr_lock);
-	vdevp->frontend = NULL;
-
-	/* @todo vdin_addr_offset */
-	vdevp->addr_offset = vdin_addr_offset[vdevp->index];
-        /*disable vdin hardware*/
-        vdin_enable_module(vdevp->addr_offset, false);
-	vdevp->flags = 0;
-
-	/* create vf pool */
-	vdevp->vfp = vf_pool_alloc(VDIN_CANVAS_MAX_CNT);
-
-	/* init vframe provider */
-	/* @todo provider name */
-	sprintf(vdevp->name, "%s%d", PROVIDER_NAME, vdevp->index);
-	vf_provider_init(&vdevp->vprov, vdevp->name, &vdin_vf_ops, vdevp->vfp);
-	/* @todo canvas_config_mode */
-	if (canvas_config_mode == 0 || canvas_config_mode == 1) {
-		vdin_canvas_init(vdevp);
-	}
-
-	/* set drvdata */
-	dev_set_drvdata(vdevp->dev, vdevp);
-	platform_set_drvdata(pdev, vdevp);
-
-	pr_info("%s: driver initialized ok\n", __func__);
-	return 0;
-
-fail_get_resource_irq:
-fail_get_resource_mem:
-fail_create_dev_file:
-	vdin_delete_device(vdevp->index);
-fail_create_device:
-	cdev_del(&vdevp->cdev);
-fail_add_cdev:
-	kfree(vdevp);
-fail_kmalloc_vdev:
-	return ret;
-}
-
-static int vdin_drv_remove(struct platform_device *pdev)
-{
-	struct vdin_dev_s *vdevp;
-	vdevp = platform_get_drvdata(pdev);
-
-	mutex_destroy(&vdevp->mm_lock);
-	mutex_destroy(&vdevp->fe_lock);
-	
-	vf_pool_free(vdevp->vfp);
-
-        #ifdef VF_LOG_EN
-        device_remove_file(vdevp->dev,&dev_attr_vf_log);
-        #endif
-        #ifdef ISR_LOG_EN
-        device_remove_file(vdevp->dev,&dev_attr_isr_log);
-        #endif
-        device_remove_file(vdevp->dev,&dev_attr_attr);
-		device_remove_file(vdevp->dev,&dev_attr_cm2);
-	device_remove_file(vdevp->dev,&dev_attr_sig_det);
-
-	vdin_delete_device(vdevp->index);
-	cdev_del(&vdevp->cdev);
-	vdin_devp[vdevp->index] = NULL;
-	kfree(vdevp);
-	
-	/* free drvdata */
-	dev_set_drvdata(vdevp->dev, NULL);
-	platform_set_drvdata(pdev, NULL);
-
-	pr_info("%s: driver removed ok\n", __func__);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int vdin_drv_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct vdin_dev_s *vdevp;
-	vdevp = platform_get_drvdata(pdev);
-        vdin_enable_module(vdevp->addr_offset, false);
-        pr_info("%s ok.\n",__func__);
-	return 0;
-}
-
-static int vdin_drv_resume(struct platform_device *pdev)
-{
-	struct vdin_dev_s *vdevp;
-	vdevp = platform_get_drvdata(pdev);
-        vdin_enable_module(vdevp->addr_offset, true);
-        pr_info("%s ok.\n",__func__);
-	return 0;
-}
-#endif
-#ifdef CONFIG_OF
-static const struct of_device_id vdin_dt_match[]={
-        {       .compatible = "amlogic,vdin",   },
-        {},
-};
-#else
-#define vdin_dt_match NULL
-#endif
-static struct platform_driver vdin_driver = {
-	.probe		= vdin_drv_probe,
-	.remove		= vdin_drv_remove,
-#ifdef CONFIG_PM
-	.suspend	= vdin_drv_suspend,
-	.resume		= vdin_drv_resume,
-#endif
-	.driver 	= {
-		.name	        = VDIN_DRV_NAME,
-                .of_match_table = vdin_dt_match,
-}
-};
-
-extern int vdin_reg_v4l2(vdin_v4l2_ops_t *v4l2_ops);
-extern void vdin_unreg_v4l2(void);
-
-static int __init vdin_drv_init(void)
-{
-	int ret = 0;
-
-	ret = alloc_chrdev_region(&vdin_devno, 0, VDIN_MAX_DEVS, VDIN_DEV_NAME);
-	if (ret < 0) {
-		pr_err("%s: failed to allocate major number\n", __func__);
-		goto fail_alloc_cdev_region;
-	}
-
-	pr_info("%s: major %d\n", __func__, MAJOR(vdin_devno));
-
-	vdin_clsp = class_create(THIS_MODULE, VDIN_CLS_NAME);
-	if (IS_ERR(vdin_clsp)) {
-		ret = PTR_ERR(vdin_clsp);
-		pr_err("%s: failed to create class\n", __func__);
-		goto fail_class_create;
-	}
-
-	/* @todo class_attr_test */
-	//device_create_file(vdin_clsp, &dev_attr_test);
-	ret = class_create_file(vdin_clsp, &class_attr_memp);
-
-	ret = platform_driver_register(&vdin_driver);
-	
-	if (ret != 0) {
-		pr_err("%s: failed to register driver\n", __func__);
-		goto fail_pdrv_register;
-	}
-	/*register vdin for v4l2 interface*/
-        if(vdin_reg_v4l2(&vdin_4v4l2_ops))
-                pr_err("[vdin..] %s: register vdin v4l2 error.\n",__func__);
-#ifdef CONFIG_ARCH_MESON6TV
-#ifndef CONFIG_MESON_M6C_ENHANCEMENT
-	aml_write_reg32(P_MMC_CHAN5_CTRL, 0xc01f); // adjust vdin weight and age limit
-#endif
-#endif
-	return 0;
-
-fail_pdrv_register:
-	class_destroy(vdin_clsp);
-fail_class_create:
-	unregister_chrdev_region(vdin_devno, VDIN_MAX_DEVS);
-fail_alloc_cdev_region:
-	return ret;
-}
-
-static void __exit vdin_drv_exit(void)
-{
-	vdin_unreg_v4l2();
-	//device_remove_file(vdin_clsp, &dev_attr_test);
-	class_remove_file(vdin_clsp, &class_attr_memp);
-	class_destroy(vdin_clsp);
-	unregister_chrdev_region(vdin_devno, VDIN_MAX_DEVS);
-	platform_driver_unregister(&vdin_driver);
-}
-
-module_init(vdin_drv_init);
-module_exit(vdin_drv_exit);
-
-
-MODULE_VERSION(VDIN_VER);
-
-MODULE_DESCRIPTION("AMLOGIC VDIN Driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Xu Lin <lin.xu@amlogic.com>");
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_drv.h b/drivers/amlogic/tvin/vdin/vdin_drv.h
deleted file mode 100755
index 24edfeb3a907..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_drv.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * VDIN driver
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __TVIN_VDIN_DRV_H
-#define __TVIN_VDIN_DRV_H
-
-/* Standard Linux Headers */
-#include <linux/cdev.h>
-#include <linux/spinlock.h>
-#include <linux/irqreturn.h>
-#include <linux/timer.h>
-#include <linux/mutex.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-
-/* Amlogic Headers */
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-
-/* Local Headers */
-#include "../tvin_global.h"
-#include "../tvin_frontend.h"
-#include "vdin_vf.h"
-
-#define VDIN_VER "Ref.2013/12/19a"
-
-/*the counter of vdin*/
-#define VDIN_MAX_DEVS			2
-#define VDIN_CRYSTAL                    24000000
-/* values of vdin_dev_t.flags */
-#define VDIN_FLAG_NULL			0x00000000
-#define VDIN_FLAG_DEC_INIT		0x00000001
-#define VDIN_FLAG_DEC_STARTED		0x00000002
-#define VDIN_FLAG_DEC_OPENED		0x00000004
-#define VDIN_FLAG_DEC_REGED		0x00000008
-#define VDIN_FLAG_DEC_STOP_ISR		0x00000010
-#define VDIN_FLAG_FORCE_UNSTABLE	0x00000020
-#define VDIN_FLAG_FS_OPENED		0x00000100
-#define VDIN_FLAG_SKIP_ISR              0x00000200
-/*flag for vdin0 output*/
-#define VDIN_FLAG_OUTPUT_TO_NR		0x00000400
-/*flag for force vdin buffer recycle*/
-#define VDIN_FLAG_FORCE_RECYCLE         0x00000800
-/*flag for vdin scale down,color fmt convertion*/
-#define VDIN_FLAG_MANUAL_CONVERTION     0x00001000
-
-/*values of vdin isr bypass check flag */
-#define VDIN_BYPASS_STOP_CHECK          0x00000001
-#define VDIN_BYPASS_CYC_CHECK           0x00000002
-#define VDIN_BYPASS_VSYNC_CHECK         0x00000004
-#define VDIN_BYPASS_VGA_CHECK           0x00000008
-
-
-/*flag for flush vdin buff*/
-#define VDIN_FLAG_BLACK_SCREEN_ON	1
-#define VDIN_FLAG_BLACK_SCREEN_OFF	0
-
-//#define VDIN_DEBUG                      
-
-static inline const char *vdin_fmt_convert_str(enum vdin_format_convert_e fmt_cvt)
-{
-	switch (fmt_cvt) {
-	case VDIN_FORMAT_CONVERT_YUV_YUV422:
-		return "FMT_CONVERT_YUV_YUV422";
-		break;
-	case VDIN_FORMAT_CONVERT_YUV_YUV444:
-		return "FMT_CONVERT_YUV_YUV444";
-		break;
-	case VDIN_FORMAT_CONVERT_YUV_RGB:
-		return "FMT_CONVERT_YUV_RGB";
-		break;
-	case VDIN_FORMAT_CONVERT_RGB_YUV422:
-		return "FMT_CONVERT_RGB_YUV422";
-		break;
-	case VDIN_FORMAT_CONVERT_RGB_YUV444:
-		return "FMT_CONVERT_RGB_YUV444";
-		break;
-	case VDIN_FORMAT_CONVERT_RGB_RGB:
-		return "FMT_CONVERT_RGB_RGB";
-		break;
-        case VDIN_FORMAT_CONVERT_YUV_NV12:
-		return "VDIN_FORMAT_CONVERT_YUV_NV12";
-		break;
-        case VDIN_FORMAT_CONVERT_YUV_NV21:
-		return "VDIN_FORMAT_CONVERT_YUV_NV21";
-		break;
-	case VDIN_FORMAT_CONVERT_RGB_NV12:
-		return "VDIN_FORMAT_CONVERT_RGB_NV12";
-		break;
-        case VDIN_FORMAT_CONVERT_RGB_NV21:
-		return "VDIN_FORMAT_CONVERT_RGB_NV21";
-		break;
-	default:
-		return "FMT_CONVERT_NULL";
-		break;
-	}
-}
-
-extern int vdin_reg_v4l2(vdin_v4l2_ops_t *ops);
-
-typedef struct vdin_dev_s {
-	unsigned int		        index;
-
-	dev_t				devt;
-	struct cdev			cdev;
-	struct device			*dev;
-
-	char				name[15];
-	unsigned int			flags;	// bit0 TVIN_PARM_FLAG_CAP
-						//bit31: TVIN_PARM_FLAG_WORK_ON
-
-	unsigned int			mem_start;
-	unsigned int			mem_size;
-
-	// start address of captured frame data [8 bits] in memory
-	// for Component input, frame data [8 bits] order is Y0Cb0Y1Cr0Y2nCb2nY2n+1Cr2n
-	// for VGA       input, frame data [8 bits] order is R0G0B0RnGnBn
-	unsigned int			cap_addr;
-	unsigned int			cap_size;
-
-	unsigned int			h_active;
-	unsigned int			v_active;
-	enum vdin_format_convert_e	format_convert;
-
-	enum vframe_source_type_e	source_type;
-	enum vframe_source_mode_e	source_mode;
-
-	unsigned int			*canvas_ids;
-	unsigned int			canvas_h;
-	unsigned int			canvas_w;
-	unsigned int			canvas_max_size;
-	unsigned int			canvas_max_num;
-	struct vf_entry			*curr_wr_vfe;
-	struct vf_entry         *last_wr_vfe;
-	unsigned int			curr_field_type;
-
-	unsigned int			irq;
-	char				irq_name[12];
-	unsigned int			addr_offset;  //address offset(vdin0/vdin1/...)
-	unsigned int			vga_clr_cnt;
-	unsigned int			vs_cnt_valid;
-	unsigned int			vs_cnt_ignore;
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-	enum tvin_cvbs_pos_ctl_e	cvbs_pos_chg;
-#endif
-	struct tvin_parm_s		parm;
-                struct tvin_format_s                 *fmt_info_p;
-	struct vf_pool			*vfp;
-
-	struct tvin_frontend_s		*frontend;
-	struct tvin_sig_property_s	pre_prop;
-	struct tvin_sig_property_s	prop;
-	struct vframe_provider_s	vprov;
-
-
-	struct timer_list		timer;
-	spinlock_t			dec_lock;
-	struct tasklet_struct		isr_tasklet;
-	spinlock_t			isr_lock;
-	struct mutex			mm_lock; /* lock for mmap */
-	struct mutex			fe_lock;
-
-	unsigned int			unstable_flag;
-	unsigned int			dec_enable;
-	unsigned int			abnormal_cnt;
-        //bool                        stamp_valid; use vfe replace tell the first frame  
-	unsigned int			stamp;
-	unsigned int			hcnt64;
-	unsigned int			cycle;
-	unsigned int			hcnt64_tag;
-	unsigned int			cycle_tag;
-        unsigned int                    start_time;//ms vdin start time    
-        unsigned short                  scaler4h;//for vscaler
-        unsigned short                  scaler4w;//for hscaler
-        unsigned short                  dest_cfmt;//for color fmt convertion
-} vdin_dev_t;
-
-#endif /* __TVIN_VDIN_DRV_H */
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_regs.h b/drivers/amlogic/tvin/vdin/vdin_regs.h
deleted file mode 100755
index 19439bc744b3..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_regs.h
+++ /dev/null
@@ -1,1303 +0,0 @@
-/*
- * VDIN register bit-field definition
- * Sorted by the appearing order of registers in am_regs.h.
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef __VDIN_REGS_H
-#define __VDIN_REGS_H
-
-//#define VDIN_SCALE_COEF_IDX                        0x1200
-//#define VDIN_SCALE_COEF                            0x1201
-
-//#define VDIN_COM_CTRL0                             0x1202
-/* used by other modules,indicates that MPEG input.
-0: mpeg source to NR directly,
-1: mpeg source pass through here */
-#define MPEG_TO_VDIN_SEL_BIT            31
-#define MPEG_TO_VDIN_SEL_WID            1
-/* indicates MPEG field ID,written by software.
-0: EVEN FIELD 1: ODD FIELD */
-#define MPEG_FLD_BIT                    30
-#define MPEG_FLD_WID                    1
-
-
-
-
-#define MPEG_GO_FLD_EN_BIT              27     // enable external MPEG Go_field (VS)
-#define MPEG_GO_FLD_EN_WID              1
-
-
-/* vdin read enable after hold lines counting from delayed Go-field (VS). */
-#define HOLD_LN_BIT                     20
-#define HOLD_LN_WID                     7
-#define DLY_GO_FLD_EN_BIT               19
-#define DLY_GO_FLD_EN_WID               1
-#define DLY_GO_FLD_LN_NUM_BIT           12
-#define DLY_GO_FLD_LN_NUM_WID           7    // delay go field lines
-/* 00: component0_in 01: component1_in 10: component2_in */
-#define COMP2_OUT_SWT_BIT               10
-#define COMP2_OUT_SWT_WID               2
-/* 00: component0_in 01: component1_in 10: component2_in */
-#define COMP1_OUT_SWT_BIT               8
-#define COMP1_OUT_SWT_WID               2
-/* 00: component0_in 01: component1_in 10: component2_in */
-#define COMP0_OUT_SWT_BIT               6
-#define COMP0_OUT_SWT_WID               2
-
-
-#define INPUT_WIN_SEL_EN_BIT            5
-#define INPUT_WIN_SEL_EN_WID            1
-
-
-/* 0: no data input 1: common data input */
-#define COMMON_DATA_IN_EN_BIT           4
-#define COMMON_DATA_IN_EN_WID           1
-/* 1: MPEG, 2: 656, 3: TVFE, 4: CVD2, 5: HDMI_Rx,6: DVIN otherwise: NULL 
-*7: loopback from VIU1, 8: MIPI csi2 in meson6
-*/
-#define VDIN_SEL_BIT                    0
-#define VDIN_SEL_WID                    4
-
-//#define VDIN_ACTIVE_MAX_PIX_CNT_STATUS             0x1203
-/* ~field_hold & prehsc input active max pixel every line output of window */
-#define ACTIVE_MAX_PIX_CNT_BIT          16
-#define ACTIVE_MAX_PIX_CNT_WID          13
-#define ACTIVE_MAX_PIX_CNT_SDW_BIT      0    // latch by go_field
-#define ACTIVE_MAX_PIX_CNT_SDW_WID      13
-
-//#define VDIN_LCNT_STATUS                           0x1204
-/* line count by force_go_line |sel_go_line :output of decimate */
-#define GO_LN_CNT_BIT                   16
-#define GO_LN_CNT_WID                   13
-/* line  count prehsc input active max pixel every active line output of window */
-#define ACTIVE_LN_CNT_BIT               0
-#define ACTIVE_LN_CNT_WID               13
-
-//#define VDIN_COM_STATUS0                        0x1205                     S
-#define LFIFO_BUF_CNT_BIT               3
-#define LFIFO_BUF_CNT_WID               10   //wren + read -
-#define DIRECT_DONE_STATUS_BIT          2
-#define DIRECT_DONE_STATUS_WID          1    // direct_done_clr_bit & reg_wpluse
-#define NR_DONE_STATUS_BIT              1
-#define NR_DONE_STATUS_WID              1    // nr_done_clr_bit & reg_wpluse
-#define VDIN_FLD_EVEN_BIT               0
-#define VDIN_FLD_EVEN_WID               1
-
-//#define VDIN_COM_STATUS1                        0x1206
-#define FIFO4_OVFL_BIT                  31
-#define FIFO4_OVFL_WID                  1
-#define ASFIFO4_CNT_BIT                 24
-#define ASFIFO4_CNT_WID                 6
-#define FIFO3_OVFL_BIT                  23
-#define FIFO3_OVFL_WID                  1
-#define ASFIFO3_CNT_BIT                 16
-#define ASFIFO3_CNT_WID                 6
-#define FIFO2_OVFL_BIT                  15
-#define FIFO2_OVFL_WID                  1
-#define ASFIFO2_CNT_BIT                 8
-#define ASFIFO2_CNT_WID                 6
-#define FIFO1_OVFL_BIT                  7
-#define FIFO1_OVFL_WID                  1
-#define ASFIFO1_CNT_BIT                 0
-#define ASFIFO1_CNT_WID                 6
-
-//#define VDIN_LCNT_SHADOW_STATUS                 0x1207
-#define GO_LN_CNT_SDW_BIT               16
-#define GO_LN_CNT_SDW_WID               13   // latch by go_field
-#define ACTIVE_LN_CNT_SDW_BIT           0
-#define ACTIVE_LN_CNT_SDW_WID           13   // latch by go_field
-
-//#define VDIN_ASFIFO_CTRL0                       0x1208
-#define VDI2_ASFIFO_CTRL_BIT			16
-#define VDI2_ASFIFO_CTRL_WID			8
-#define ASFIFO2_DE_EN_BIT               23
-#define ASFIFO2_DE_EN_WID               1
-#define ASFIFO2_GO_FLD_EN_BIT           22
-#define ASFIFO2_GO_FLD_EN_WID           1
-#define ASFIFO2_GO_LN_EN_BIT            21
-#define ASFIFO2_GO_LN_EN_WID            1
-#define ASFIFO2_NEG_ACTIVE_IN_VS_BIT    20
-#define ASFIFO2_NEG_ACTIVE_IN_VS_WID    1
-#define ASFIFO2_NEG_ACTIVE_IN_HS_BIT    19
-#define ASFIFO2_NEG_ACTIVE_IN_HS_WID    1
-#define ASFIFO2_VS_SOFT_RST_FIFO_EN_BIT 18
-#define ASFIFO2_VS_SOFT_RST_FIFO_EN_WID 1
-#define ASFIFO2_OVFL_STATUS_CLR_BIT     17
-#define ASFIFO2_OVFL_STATUS_CLR_WID     1
-#define ASFIFO2_SOFT_RST_BIT            16
-#define ASFIFO2_SOFT_RST_WID            1    // write 1 & then 0 to reset
-#define VDI1_ASFIFO_CTRL_BIT			0
-#define VDI1_ASFIFO_CTRL_WID			8
-#define ASFIFO1_DE_EN_BIT               7
-#define ASFIFO1_DE_EN_WID               1
-#define ASFIFO1_GO_FLD_EN_BIT           6
-#define ASFIFO1_GO_FLD_EN_WID           1
-#define ASFIFO1_GO_LN_EN_BIT            5
-#define ASFIFO1_GO_LN_EN_WID            1
-#define ASFIFO1_NEG_ACTIVE_IN_VS_BIT    4
-#define ASFIFO1_NEG_ACTIVE_IN_VS_WID    1
-#define ASFIFO1_NEG_ACTIVE_IN_HS_BIT    3
-#define ASFIFO1_NEG_ACTIVE_IN_HS_WID    1
-#define ASFIFO1_VS_SOFT_RST_FIFO_EN_BIT 2
-#define ASFIFO1_VS_SOFT_RST_FIFO_EN_WID 1
-#define ASFIFO1_OVFL_STATUS_CLR_BIT     1
-#define ASFIFO1_OVFL_STATUS_CLR_WID     1
-#define ASFIFO1_SOFT_RST_BIT            0
-#define ASFIFO1_SOFT_RST_WID            1    // write 1 & then 0 to reset
-
-//#define VDIN_ASFIFO_CTRL1                         0x1209
-#define VDI4_ASFIFO_CTRL_BIT			16
-#define VDI4_ASFIFO_CTRL_WID			8
-#define ASFIFO4_DE_EN_BIT               23
-#define ASFIFO4_DE_EN_WID               1
-#define ASFIFO4_GO_FLD_EN_BIT           22
-#define ASFIFO4_GO_FLD_EN_WID           1
-#define ASFIFO4_GO_LN_EN_BIT            21
-#define ASFIFO4_GO_LN_EN_WID            1
-#define ASFIFO4_NEG_ACTIVE_IN_VS_BIT    20
-#define ASFIFO4_NEG_ACTIVE_IN_VS_WID    1
-#define ASFIFO4_NEG_ACTIVE_IN_HS_BIT    19
-#define ASFIFO4_NEG_ACTIVE_IN_HS_WID    1
-#define ASFIFO4_VS_SOFT_RST_FIFO_EN_BIT 18
-#define ASFIFO4_VS_SOFT_RST_FIFO_EN_WID 1
-#define ASFIFO4_OVFL_STATUS_CLR_BIT     17
-#define ASFIFO4_OVFL_STATUS_CLR_WID     1
-#define ASFIFO4_SOFT_RST_BIT            16
-#define ASFIFO4_SOFT_RST_WID            1    // write 1 & then 0 to reset
-#define VDI3_ASFIFO_CTRL_BIT			0
-#define VDI3_ASFIFO_CTRL_WID			8
-#define ASFIFO3_DE_EN_BIT               7
-#define ASFIFO3_DE_EN_WID               1
-#define ASFIFO3_GO_FLD_EN_BIT           6
-#define ASFIFO3_GO_FLD_EN_WID           1
-#define ASFIFO3_GO_LN_EN_BIT            5
-#define ASFIFO3_GO_LN_EN_WID            1
-#define ASFIFO3_NEG_ACTIVE_IN_VS_BIT    4
-#define ASFIFO3_NEG_ACTIVE_IN_VS_WID    1
-#define ASFIFO3_NEG_ACTIVE_IN_HS_BIT    3
-#define ASFIFO3_NEG_ACTIVE_IN_HS_WID    1
-#define ASFIFO3_VS_SOFT_RST_FIFO_EN_BIT 2
-#define ASFIFO3_VS_SOFT_RST_FIFO_EN_WID 1
-#define ASFIFO3_OVFL_STATUS_CLR_BIT     1
-#define ASFIFO3_OVFL_STATUS_CLR_WID     1
-#define ASFIFO3_SOFT_RST_BIT            0
-#define ASFIFO3_SOFT_RST_WID            1    // write 1 & then 0 to reset
-
-//#define VDIN_WIDTHM1I_WIDTHM1O                  0x120a
-#define WIDTHM1I_BIT                    16
-#define WIDTHM1I_WID                    13
-#define WIDTHM1O_BIT                    0
-#define WIDTHM1O_WID                    13
-
-//#define VDIN_SC_MISC_CTRL                       0x120b
-#define INIT_PIX_IN_PTR_BIT             8
-#define INIT_PIX_IN_PTR_WID             7    // signed value for short line output
-#define INIT_PIX_IN_PTR_MSK             0x0000007f
-#define PRE_HSCL_EN_BIT                 7
-#define PRE_HSCL_EN_WID                 1    // pre-hscaler: 1/2 coarse scale down
-#define HSCL_EN_BIT                     6
-#define HSCL_EN_WID                     1    // hscaler: fine scale down
-#define SHORT_LN_OUT_EN_BIT             5
-#define SHORT_LN_OUT_EN_WID             1
-/*when decimation timing located in between 2 input pixels, decimate the nearest one*/
-#define HSCL_NEAREST_EN_BIT             4
-#define HSCL_NEAREST_EN_WID             1
-#define PHASE0_ALWAYS_EN_BIT            3    // Start decimation from phase 0 for each line
-#define PHASE0_ALWAYS_EN_WID            1
-/* filter pixel buf len (depth), max is 3 in IP design */
-#define HSCL_BANK_LEN_BIT               0
-#define HSCL_BANK_LEN_WID               3
-
-
-//#define VDIN_HSC_PHASE_STEP                     0x120c
-#define HSCL_PHASE_STEP_INT_BIT         24
-#define HSCL_PHASE_STEP_INT_WID         5
-#define HSCL_PHASE_STEP_FRA_BIT         0
-#define HSCL_PHASE_STEP_FRA_WID         24
-
-//#define VDIN_HSC_INI_CTRL                          0x120d
-/* repeatedly decimation of pixel #0 of each line? */
-#define HSCL_RPT_P0_NUM_BIT             29
-#define HSCL_RPT_P0_NUM_WID             2
-/* if rev>rpt_p0+1, then start decimation upon ini_phase? */
-#define HSCL_INI_RCV_NUM_BIT            24
-#define HSCL_INI_RCV_NUM_WID            5
-/* which one every some pixels is decimated */
-#define HSCL_INI_PHASE_BIT              0
-#define HSCL_INI_PHASE_WID              24
-
-
-//#define VDIN_COM_STATUS2                           0x120e
-//Read only
-
-#define VDI7_FIFO_OVFL_BIT              23  //vdi7 fifo overflow
-#define VDI7_FIFO_OVFL_WID              1
-#define VDI7_ASFIFO_CNT_BIT             16  //vdi7_asfifo_cnt
-#define VDI7_ASFIFO_CNT_WID             6
-#define VDI6_FIFO_OVFL_BIT              15  //vdi6 fifo overflow
-#define VDI6_FIFO_OVFL_WID              1
-#define VDI6_ASFIFO_CNT_BIT             8  //vdi6_asfifo_cnt
-#define VDI6_ASFIFO_CNT_WID             6
-
-#define VDI5_FIFO_OVFL_BIT              7  //vdi5 fifo overflow
-#define VDI5_FIFO_OVFL_WID              1
-#define VDI5_ASFIFO_CNT_BIT             0  //vdi5_asfifo_cnt
-#define VDI5_ASFIFO_CNT_WID             6
-
-
-
-//#define VDIN_ASFIFO_CTRL2                          0x120f
-#define ASFIFO_DECIMATION_SYNC_WITH_DE_BIT        25
-#define ASFIFO_DECIMATION_SYNC_WITH_DE_WID        1
-#define ASFIFO_DECIMATION_DE_EN_BIT               24
-#define ASFIFO_DECIMATION_DE_EN_WID               1
-#define ASFIFO_DECIMATION_PHASE_BIT               20
-#define ASFIFO_DECIMATION_PHASE_WID               4 // which counter value used to decimate
-#define ASFIFO_DECIMATION_NUM_BIT                 16
-#define ASFIFO_DECIMATION_NUM_WID                 4 // 0: not decimation, 1: decimation 2, 2: decimation 3 ...
-#define VDI5_ASFIFO_CTRL_BIT					  0
-#define VDI5_ASFIFO_CTRL_WID					  8
-#define ASFIFO5_DE_EN_BIT                         7
-#define ASFIFO5_DE_EN_WID                         1
-#define ASFIFO5_GO_FLD_EN_BIT                     6
-#define ASFIFO5_GO_FLD_EN_WID                     1
-#define ASFIFO5_GO_LN_EN_BIT                      5
-#define ASFIFO5_GO_LN_EN_WID                      1
-#define ASFIFO5_NEG_ACTIVE_IN_VS_BIT              4
-#define ASFIFO5_NEG_ACTIVE_IN_VS_WID              1
-#define ASFIFO5_NEG_ACTIVE_IN_HS_BIT              3
-#define ASFIFO5_NEG_ACTIVE_IN_HS_WID              1
-#define ASFIFO5_VS_SOFT_RST_FIFO_EN_BIT           2
-#define ASFIFO5_VS_SOFT_RST_FIFO_EN_WID           1
-#define ASFIFO5_OVFL_STATUS_CLR_BIT               1
-#define ASFIFO5_OVFL_STATUS_CLR_WID               1
-#define ASFIFO5_SOFT_RST_BIT                      0
-#define ASFIFO5_SOFT_RST_WID                      1 // write 1 & then 0 to reset
-
-
-//#define VDIN_MATRIX_CTRL                        0x1210
-#define VDIN_MATRIX0_BYPASS_BIT             9//1:bypass 0:pass
-#define VDIN_MATRIX0_BYPASS_WID             1
-#define VDIN_MATRIX1_BYPASS_BIT             8
-#define VDIN_MATRIX1_BYPASS_WID             1
-#define VDIN_HIGHLIGHT_EN_BIT               7
-#define VDIN_HIGHLIGHT_EN_WID               1
-#define VDIN_PROBE_POST_BIT                 6//1: probe pixel data after matrix, 0:probe pixel data before matrix
-#define VDIN_PROBE_POST_WID                 1
-#define VDIN_PROBE_SEL_BIT                  4//00: select matrix0, 01: select matrix1,otherwise select nothing
-#define VDIN_PROBE_SEL_WID                  2
-#define VDIN_MATRIX_COEF_INDEX_BIT          2//00: select mat0, 01: select mat1, otherwise slect nothing 
-#define VDIN_MATRIX_COEF_INDEX_WID          2
-#define VDIN_MATRIX1_EN_BIT                 1//Bit 1   mat1 conversion matrix enable
-#define VDIN_MATRIX1_EN_WID                 1
-#define VDIN_MATRIX_EN_BIT                  0//Bit 0   mat0 conversion matrix enable
-#define VDIN_MATRIX_EN_WID                  1
-
-//#define VDIN_MATRIX_COEF00_01                   0x1211
-#define MATRIX_C00_BIT                  16
-#define MATRIX_C00_WID                  13   // s2.10
-#define MATRIX_C01_BIT                  0
-#define MATRIX_C01_WID                  13   // s2.10
-
-//#define VDIN_MATRIX_COEF02_10                   0x1212
-#define MATRIX_C02_BIT                  16
-#define MATRIX_C02_WID                  13   // s2.10
-#define MATRIX_C10_BIT                  0
-#define MATRIX_C10_WID                  13   // s2.10
-
-//#define VDIN_MATRIX_COEF11_12                   0x1213
-#define MATRIX_C11_BIT                  16
-#define MATRIX_C11_WID                  13   // s2.10
-#define MATRIX_C12_BIT                  0
-#define MATRIX_C12_WID                  13   // s2.10
-
-//#define VDIN_MATRIX_COEF20_21                   0x1214
-#define MATRIX_C20_BIT                  16
-#define MATRIX_C20_WID                  13   // s2.10
-#define MATRIX_C21_BIT                  0
-#define MATRIX_C21_WID                  13   // s2.10
-
-//#define VDIN_MATRIX_COEF22                      0x1215
-#define MATRIX_C22_BIT                  0
-#define MATRIX_C22_WID                  13   // s2.10
-
-//#define VDIN_MATRIX_OFFSET0_1                   0x1216
-#define MATRIX_OFFSET0_BIT              16
-#define MATRIX_OFFSET0_WID              11   // s8.2
-#define MATRIX_OFFSET1_BIT              0
-#define MATRIX_OFFSET1_WID              11   // s8.2
-
-//#define VDIN_MATRIX_OFFSET2                     0x1217
-#define MATRIX_OFFSET2_BIT              0
-#define MATRIX_OFFSET2_WID              11   // s8.2
-
-//#define VDIN_MATRIX_PRE_OFFSET0_1               0x1218
-#define MATRIX_PRE_OFFSET0_BIT          16
-#define MATRIX_PRE_OFFSET0_WID          11   // s8.2
-#define MATRIX_PRE_OFFSET1_BIT          0
-#define MATRIX_PRE_OFFSET1_WID          11   // s8.2
-
-//#define VDIN_MATRIX_PRE_OFFSET2                 0x1219
-#define MATRIX_PRE_OFFSET2_BIT          0
-#define MATRIX_PRE_OFFSET2_WID          11   // s8.2
-
-//#define VDIN_LFIFO_CTRL                         0x121a
-#define LFIFO_BUF_SIZE_BIT              0
-#define LFIFO_BUF_SIZE_WID              12
-
-//#define VDIN_COM_GCLK_CTRL                      0x121b
-#define COM_GCLK_BLKBAR_BIT             14
-#define COM_GCLK_BLKBAR_WID             2    // 00: auto, 01: off, 1x: on
-#define COM_GCLK_HIST_BIT               12
-#define COM_GCLK_HIST_WID               2    // 00: auto, 01: off, 1x: on
-#define COM_GCLK_LFIFO_BIT              10
-#define COM_GCLK_LFIFO_WID              2    // 00: auto, 01: off, 1x: on
-#define COM_GCLK_MATRIX_BIT             8
-#define COM_GCLK_MATRIX_WID             2    // 00: auto, 01: off, 1x: on
-#define COM_GCLK_HSCL_BIT               6
-#define COM_GCLK_HSCL_WID               2    // 00: auto, 01: off, 1x: on
-#define COM_GCLK_PRE_HSCL_BIT           4
-#define COM_GCLK_PRE_HSCL_WID           2    // 00: auto, 01: off, 1x: on
-#define COM_GCLK_TOP_BIT                2
-#define COM_GCLK_TOP_WID                2    // 00: auto, 01: off, 1x: on
-/* Caution !!! never turn it off, otherwise no way to wake up VDIN unless power reset  */
-#define COM_GCLK_REG_BIT                0
-#define COM_GCLK_REG_WID                1    //  0: auto,  1: off. Caution !!!
-
-
-//#define VDIN_INTF_WIDTHM1                        0x121c
-#define VDIN_INTF_WIDTHM1_BIT           0
-#define VDIN_INTF_WIDTHM1_WID           13 // before the cut window function, after the de decimation function
-
-
-//#define VDIN_WR_CTRL2                           0x121f
-#define DISCARD_BEF_LINE_FIFO_BIT                8//1: discard data before line fifo, 0: normal mode
-#define DISCARD_BEF_LINE_FIFO_WID               1
-#define WRITE_CHROMA_CANVAS_ADDR_BIT    0//Write chroma canvas address
-#define WRITE_CHROMA_CANVAS_ADDR_WID   8
-
-//#define VDIN_WR_CTRL                            0x1220
-
-//Applicable only bit[13:12]=0 or 10. 
-//0: Output every even pixels' CbCr;
-//1: Output every odd pixels' CbCr;
-//10: Output an average value per even&odd pair of pixels;
-//11: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
-#define HCONV_MODE_BIT                          30
-#define HCONV_MODE_WID                          2
-#define NO_CLOCK_GATE_BIT                       29// 1:disable vid_wr_mif clock gating function
-#define NO_CLOCK_GATE_WID                      1
-#define WR_RESPONSE_CNT_CLR_BIT         28
-#define WR_RESPONSE_CNT_CLR_WID         1
-#define EOL_SEL_BIT                     27
-#define EOL_SEL_WID                     1
-#define VCP_NR_EN_BIT                   26//ONLY VDIN0
-#define VCP_NR_EN_WID                   1
-#define VCP_WR_EN_BIT                   25//ONLY VDIN0
-#define VCP_WR_EN_WID                   1
-#define VCP_IN_EN_BIT                   24//ONLY VDIN0
-#define VCP_IN_EN_WID                   1
-//#define WR_OUT_CTRL_BIT                 24 ?
-//#define WR_OUT_CTRL_WID                 8    //directly send out
-#define FRAME_SOFT_RST_EN_BIT           23
-#define FRAME_SOFT_RST_EN_WID           1
-#define LFIFO_SOFT_RST_EN_BIT           22   // reset LFIFO on VS (Go_field)
-#define LFIFO_SOFT_RST_EN_WID           1
-#define DIRECT_DONE_CLR_BIT             21   // used by other modules
-#define DIRECT_DONE_CLR_WID             1
-#define NR_DONE_CLR_BIT                 20   // used by other modules
-#define NR_DONE_CLR_WID                 1
-#define SWAP_CBCR_BIT                      18//only [13:12]=10;0 output cbcr(nv12);1 output cbcr(nv21)
-#define SWAP_CBCR_WID                      1
-#define VCONV_MODE_BIT                     16//0: Output even lines' CbCr; 01: Output odd lines' CbCr;
-                                                                    //10: Reserved; 11: Output all CbCr.
-#define VCONV_MODE_WID                    2
-// 0: 422;1: 444;10:Y to luma canvas cbcr to chroma canvas for NV12/21
-#define WR_FMT_BIT                      12
-#define WR_FMT_WID                     2
-/* vdin_wr_canvas = vdin_wr_canvas_dbuf_en ? wr_canvas_shadow :wr_canvas;  */
-#define WR_CANVAS_DOUBLE_BUF_EN_BIT            11   //shadow is latch by go_field
-#define WR_CANVAS_DOUBLE_BUF_EN_WID            1
-#define WR_REQ_URGENT_BIT               9
-#define WR_REQ_URGENT_WID               1    // directly send out
-#define WR_REQ_EN_BIT                   8
-#define WR_REQ_EN_WID                   1    // directly send out
-#define WR_CANVAS_BIT                   0
-#define WR_CANVAS_WID                   8
-
-
-
-//#define VDIN_WR_H_START_END                        0x1221
-
-#define HORIZONTAL_REVERSE_BIT          29//if true horizontal reverse
-#define HORIZONTAL_REVERSE_WID         1
-#define WR_HSTART_BIT                   16
-#define WR_HSTART_WID                   13   // directly send out
-#define WR_HEND_BIT                     0
-#define WR_HEND_WID                     13   // directly send out
-
-//#define VDIN_WR_V_START_END                        0x1222
-
-#define VERTICAL_REVERSE_BIT          29//if true vertical reverse
-#define VERTICAL_REVERSE_WID         1
-#define WR_VSTART_BIT                   16
-#define WR_VSTART_WID                   13   // directly send out
-#define WR_VEND_BIT                     0
-#define WR_VEND_WID                     13  // directly send out
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
-//#define VDIN_VSC_PHASE_STEP                       0x1223
-#define INTERGER_PORTION_BIT            20
-#define INTERGER_PORTION_WID           5
-#define FRACTION_PORTION_BIT            0
-#define FRACTION_PORTION_WID           20
-
-//#define VDIN_VSC_INI_CTRL                             0x1224
-#define VSC_EN_BIT                                  23
-#define VSC_EN_WID                                 1
-#define VSC_PHASE0_ALWAYS_EN_BIT      21//to be 1 when scale up
-#define VSC_PHASE0_ALWAYS_EN_WID     1
-#define INI_SKIP_LINE_NUM_BIT                  16
-#define INI_SKIP_LINE_NUM_WID                 5
-#define VSCALER_INI_PHASE_BIT                0
-#define VSCALER_INI_PHASE_WID               16
-
-//#define VDIN_SCIN_HEIGHTM1                          0x1225
-//Bit 12:0, scaler input height minus 1
-#define SCALER_INPUT_HEIGHT_BIT            0
-#define SCALER_INPUT_HEIGHT_WID           12
-
-//#define `define VDIN_DUMMY_DATA                0x1226
-#define DUMMY_COMPONENT0_BIT                16
-#define DUMMY_COMPONENT0_WID               8
-#define DUMMY_COMPONENT1_BIT                8
-#define DUMMY_COMPONENT1_WID               8
-#define DUMMY_COMPONENT2_BIT                0
-#define DUMMY_COMPONENT2_WID               8
-
-//#define VDIN_MATRIX_PROBE_COLOR           0x1228
-//Read only 
-#define COMPONENT0_PROBE_COLOR_BIT                     20
-#define COMPONENT0_PROBE_COLOR_WID                    10
-#define COMPONENT1_PROBE_COLOR_BIT                     10
-#define COMPONENT1_PROBE_COLOR_WID                    10
-#define COMPONENT2_PROBE_COLOR_BIT                     0
-#define COMPONENT2_PROBE_COLOR_WID                    10
-
-//#define VDIN_MATRIX_HL_COLOR                  0x1229 
-#define COMPONENT0_HL_COLOR_BIT                     16
-#define COMPONENT0_HL_COLOR_WID                    8
-#define COMPONENT1_HL_COLOR_BIT                     8
-#define COMPONENT1_HL_COLOR_WID                    8
-#define COMPONENT2_HL_COLOR_BIT                     0
-#define COMPONENT2_HL_COLOR_WID                    8
-
-//#define VDIN_MATRIX_PROBE_POS               0x122a
-#define PROBE_POS_X_BIT                             16
-#define PROBE_POS_X_WID                            13
-#define PROBE_POX_Y_BIT                             0
-#define PROBE_POX_Y_WID                            13
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-
-//#define VDIN_CHROMA_ADDR_PORT 	      0x122b
-
-//#define VDIN_CHROMA_DATA_PORT 	      0x122c 	
-
-//#define VDIN_CM_BRI_CON_CTRL 		      0x122d 	
-#define CM_TOP_EN_BIT				  28
-#define CM_TOP_EN_WID				  1
-#define BRI_CON_EN_BIT				  27
-#define BRI_CON_EN_WID				  1
-#define SED_YUVINVEN_BIT			  24
-#define SED_YUVINVEN_WID			  3
-#define REG_ADJ_BRI_BIT				  12
-#define REGADJ_BRI_WID				  11
-#define REG_ADJ_CON_BIT				  0
-#define REG_ADJ_CON_WID				  12
-
-//#define VDIN_GO_LINE_CTRL 		     0x122f 
-#define CLK_CYC_CNT_CLR_BIT                       17
-#define CLK_CYC_CNT_CLR_WID                       1
-//Bit 17  clk_cyc_cnt_clr, if true, clear this register
-#define LINE_CNT_SRC_SEL_BIT                      16
-#define LINE_CNT_SRC_SEL_WID                      1
-//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt 
-//Bit 15:0   line width using vpu clk
-#define LINE_WID_USING_VPU_CLK_BIT                0
-#define LINE_WID_USING_VPU_CLK_WID                16
-#endif
-//#define VDIN_HIST_CTRL                             0x1230
-//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din 
-#define LDIM_STTS_DIN_SEL_BIT        9
-#define LDIM_STTS_DIN_SEL_WID       2
-#define LDIM_STTS_EN_BIT                  8
-#define LDIM_STTS_EN_WID                 1
-//00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
-#define HIST_DIN_SEL_BIT                    2
-#define HIST_DIN_SEL_WID                   2
-#endif
-
-//#define VDIN_HIST_CTRL                             0x1230
-/* the total pixels = VDIN_HISTXX*(2^(VDIN_HIST_POW+3)) */
-#define HIST_POW_BIT                    5
-#define HIST_POW_WID                    2
-/* Histgram range: 0: full picture, 1: histgram window defined by VDIN_HIST_H_START_END & VDIN_HIST_V_START_END */
-#define HIST_WIN_EN_BIT                 1
-#define HIST_WIN_EN_WID                 1
-/* Histgram readback: 0: disable, 1: enable */
-#define HIST_RD_EN_BIT                  0
-#define HIST_RD_EN_WID                  1
-
-//#define VDIN_HIST_H_START_END                   0x1231
-#define HIST_HSTART_BIT                 16
-#define HIST_HSTART_WID                 13
-#define HIST_HEND_BIT                   0
-#define HIST_HEND_WID                   13
-
-//#define VDIN_HIST_V_START_END                   0x1232
-#define HIST_VSTART_BIT                 16
-#define HIST_VSTART_WID                 13
-#define HIST_VEND_BIT                   0
-#define HIST_VEND_WID                   13
-
-//#define VDIN_HIST_MAX_MIN                       0x1233
-#define HIST_MAX_BIT                    8
-#define HIST_MAX_WID                    8
-#define HIST_MIN_BIT                    0
-#define HIST_MIN_WID                    8
-
-//#define VDIN_HIST_SPL_VAL                       0x1234
-#define HIST_LUMA_SUM_BIT               0
-#define HIST_LUMA_SUM_WID               32
-
-//#define VDIN_HIST_SPL_PIX_CNT                   0x1235
-#define HIST_PIX_CNT_BIT                0
-#define HIST_PIX_CNT_WID                22   // the total calculated pixels
-
-//#define VDIN_HIST_CHROMA_SUM                    0x1236
-#define HIST_CHROMA_SUM_BIT             0
-#define HIST_CHROMA_SUM_WID             32   // the total chroma value
-
-//#define VDIN_DNLP_HIST00                        0x1237
-#define HIST_ON_BIN_01_BIT              16
-#define HIST_ON_BIN_01_WID              16
-#define HIST_ON_BIN_00_BIT              0
-#define HIST_ON_BIN_00_WID              16
-
-//#define VDIN_DNLP_HIST01                        0x1238
-#define HIST_ON_BIN_03_BIT              16
-#define HIST_ON_BIN_03_WID              16
-#define HIST_ON_BIN_02_BIT              0
-#define HIST_ON_BIN_02_WID              16
-
-//#define VDIN_DNLP_HIST02                        0x1239
-#define HIST_ON_BIN_05_BIT              16
-#define HIST_ON_BIN_05_WID              16
-#define HIST_ON_BIN_04_BIT              0
-#define HIST_ON_BIN_04_WID              16
-
-//#define VDIN_DNLP_HIST03                        0x123a
-#define HIST_ON_BIN_07_BIT              16
-#define HIST_ON_BIN_07_WID              16
-#define HIST_ON_BIN_06_BIT              0
-#define HIST_ON_BIN_06_WID              16
-
-//#define VDIN_DNLP_HIST04                        0x123b
-#define HIST_ON_BIN_09_BIT              16
-#define HIST_ON_BIN_09_WID              16
-#define HIST_ON_BIN_08_BIT              0
-#define HIST_ON_BIN_08_WID              16
-
-//#define VDIN_DNLP_HIST05                        0x123c
-#define HIST_ON_BIN_11_BIT              16
-#define HIST_ON_BIN_11_WID              16
-#define HIST_ON_BIN_10_BIT              0
-#define HIST_ON_BIN_10_WID              16
-
-//#define VDIN_DNLP_HIST06                        0x123d
-#define HIST_ON_BIN_13_BIT              16
-#define HIST_ON_BIN_13_WID              16
-#define HIST_ON_BIN_12_BIT              0
-#define HIST_ON_BIN_12_WID              16
-
-//#define VDIN_DNLP_HIST07                        0x123e
-#define HIST_ON_BIN_15_BIT              16
-#define HIST_ON_BIN_15_WID              16
-#define HIST_ON_BIN_14_BIT              0
-#define HIST_ON_BIN_14_WID              16
-
-//#define VDIN_DNLP_HIST08                        0x123f
-#define HIST_ON_BIN_17_BIT              16
-#define HIST_ON_BIN_17_WID              16
-#define HIST_ON_BIN_16_BIT              0
-#define HIST_ON_BIN_16_WID              16
-
-//#define VDIN_DNLP_HIST09                        0x1240
-#define HIST_ON_BIN_19_BIT              16
-#define HIST_ON_BIN_19_WID              16
-#define HIST_ON_BIN_18_BIT              0
-#define HIST_ON_BIN_18_WID              16
-
-//#define VDIN_DNLP_HIST10                        0x1241
-#define HIST_ON_BIN_21_BIT              16
-#define HIST_ON_BIN_21_WID              16
-#define HIST_ON_BIN_20_BIT              0
-#define HIST_ON_BIN_20_WID              16
-
-//#define VDIN_DNLP_HIST11                        0x1242
-#define HIST_ON_BIN_23_BIT              16
-#define HIST_ON_BIN_23_WID              16
-#define HIST_ON_BIN_22_BIT              0
-#define HIST_ON_BIN_22_WID              16
-
-//#define VDIN_DNLP_HIST12                        0x1243
-#define HIST_ON_BIN_25_BIT              16
-#define HIST_ON_BIN_25_WID              16
-#define HIST_ON_BIN_24_BIT              0
-#define HIST_ON_BIN_24_WID              16
-
-//#define VDIN_DNLP_HIST13                        0x1244
-#define HIST_ON_BIN_27_BIT              16
-#define HIST_ON_BIN_27_WID              16
-#define HIST_ON_BIN_26_BIT              0
-#define HIST_ON_BIN_26_WID              16
-
-//#define VDIN_DNLP_HIST14                        0x1245
-#define HIST_ON_BIN_29_BIT              16
-#define HIST_ON_BIN_29_WID              16
-#define HIST_ON_BIN_28_BIT              0
-#define HIST_ON_BIN_28_WID              16
-
-//#define VDIN_DNLP_HIST15                        0x1246
-#define HIST_ON_BIN_31_BIT              16
-#define HIST_ON_BIN_31_WID              16
-#define HIST_ON_BIN_30_BIT              0
-#define HIST_ON_BIN_30_WID              16
-
-//#define VDIN_DNLP_HIST16                        0x1247
-#define HIST_ON_BIN_33_BIT              16
-#define HIST_ON_BIN_33_WID              16
-#define HIST_ON_BIN_32_BIT              0
-#define HIST_ON_BIN_32_WID              16
-
-//#define VDIN_DNLP_HIST17                        0x1248
-#define HIST_ON_BIN_35_BIT              16
-#define HIST_ON_BIN_35_WID              16
-#define HIST_ON_BIN_34_BIT              0
-#define HIST_ON_BIN_34_WID              16
-
-//#define VDIN_DNLP_HIST18                        0x1249
-#define HIST_ON_BIN_37_BIT              16
-#define HIST_ON_BIN_37_WID              16
-#define HIST_ON_BIN_36_BIT              0
-#define HIST_ON_BIN_36_WID              16
-
-//#define VDIN_DNLP_HIST19                        0x124a
-#define HIST_ON_BIN_39_BIT              16
-#define HIST_ON_BIN_39_WID              16
-#define HIST_ON_BIN_38_BIT              0
-#define HIST_ON_BIN_38_WID              16
-
-//#define VDIN_DNLP_HIST20                        0x124b
-#define HIST_ON_BIN_41_BIT              16
-#define HIST_ON_BIN_41_WID              16
-#define HIST_ON_BIN_40_BIT              0
-#define HIST_ON_BIN_40_WID              16
-
-//#define VDIN_DNLP_HIST21                        0x124c
-#define HIST_ON_BIN_43_BIT              16
-#define HIST_ON_BIN_43_WID              16
-#define HIST_ON_BIN_42_BIT              0
-#define HIST_ON_BIN_42_WID              16
-
-//#define VDIN_DNLP_HIST22                        0x124d
-#define HIST_ON_BIN_45_BIT              16
-#define HIST_ON_BIN_45_WID              16
-#define HIST_ON_BIN_44_BIT              0
-#define HIST_ON_BIN_44_WID              16
-
-//#define VDIN_DNLP_HIST23                        0x124e
-#define HIST_ON_BIN_47_BIT              16
-#define HIST_ON_BIN_47_WID              16
-#define HIST_ON_BIN_46_BIT              0
-#define HIST_ON_BIN_46_WID              16
-
-//#define VDIN_DNLP_HIST24                        0x124f
-#define HIST_ON_BIN_49_BIT              16
-#define HIST_ON_BIN_49_WID              16
-#define HIST_ON_BIN_48_BIT              0
-#define HIST_ON_BIN_48_WID              16
-
-//#define VDIN_DNLP_HIST25                        0x1250
-#define HIST_ON_BIN_51_BIT              16
-#define HIST_ON_BIN_51_WID              16
-#define HIST_ON_BIN_50_BIT              0
-#define HIST_ON_BIN_50_WID              16
-
-//#define VDIN_DNLP_HIST26                        0x1251
-#define HIST_ON_BIN_53_BIT              16
-#define HIST_ON_BIN_53_WID              16
-#define HIST_ON_BIN_52_BIT              0
-#define HIST_ON_BIN_52_WID              16
-
-//#define VDIN_DNLP_HIST27                        0x1252
-#define HIST_ON_BIN_55_BIT              16
-#define HIST_ON_BIN_55_WID              16
-#define HIST_ON_BIN_54_BIT              0
-#define HIST_ON_BIN_54_WID              16
-
-//#define VDIN_DNLP_HIST28                        0x1253
-#define HIST_ON_BIN_57_BIT              16
-#define HIST_ON_BIN_57_WID              16
-#define HIST_ON_BIN_56_BIT              0
-#define HIST_ON_BIN_56_WID              16
-
-//#define VDIN_DNLP_HIST29                        0x1254
-#define HIST_ON_BIN_59_BIT              16
-#define HIST_ON_BIN_59_WID              16
-#define HIST_ON_BIN_58_BIT              0
-#define HIST_ON_BIN_58_WID              16
-
-//#define VDIN_DNLP_HIST30                        0x1255
-#define HIST_ON_BIN_61_BIT              16
-#define HIST_ON_BIN_61_WID              16
-#define HIST_ON_BIN_60_BIT              0
-#define HIST_ON_BIN_60_WID              16
-
-//#define VDIN_DNLP_HIST31                        0x1256
-#define HIST_ON_BIN_63_BIT              16
-#define HIST_ON_BIN_63_WID              16
-#define HIST_ON_BIN_62_BIT              0
-#define HIST_ON_BIN_62_WID              16
-#ifdef CONFIG_ARCH_MESON6TV
-//#define VDIN_LDIM_STTS_HIST_REGION_IDX       0x1257
-#define LOCAL_DIM_STATISTIC_EN_BIT          31
-#define LOCAL_DIM_STATISTIC_EN_WID         1
-#define EOL_EN_BIT                                          28
-#define EOL_EN_WID                                        1
-#define VLINE_OVERLAP_NUMBER_BIT        25
-#define VLINE_OVERLAP_NUMBER_WID       3
-//0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
-#define HLINE_OVERLAP_NUMBER_BIT        22
-#define HLINE_OVERLAP_NUMBER_WID       3
-#define LPF_BEFORE_STATISTIC_EN_BIT    20
-#define LPF_BEFORE_STATISTIC_EN_WID    1
-// region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
-#define BLK_HV_POS_IDXS_BIT                     16
-#define BLK_HV_POS_IDXS_WID                    4
-#define REGION_RD_INDEX_INC_BIT             15
-#define REGION_RD_INDEX_INC_WID            1
-#define REGION_RD_INDEX_BIT                      0
-#define REGION_RD_INDEX_WID                     7
-
-//# VDIN_LDIM_STTS_HIST_SET_REGION                    0x1258
-//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
-//if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
-//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
-//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
-//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
-//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
-//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
-//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
-//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
-//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
-//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
-//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
-//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
-#define HI_16_28_BIT                        16
-#define HI_16_28_WID                       13
-#define LOW_0_12_BIT                      0
-#define LOW_0_12_WID                    13
-
-//#define VDIN_LDIM_STTS_HIST_READ_REGION           0x1259
-//REGION STATISTIC DATA READ OUT PORT, 
-#define MAX_COMP2_BIT                   20
-#define MAX_COMP2_WID                  10
-#define MAX_COMP1_BIT                   10
-#define MAX_COMP1_WID                  10
-#define MAX_COMP0_BIT                   0
-#define MAX_COMP0_WID                  10
-#endif
-
-
-//#define VDIN_MEAS_CTRL0                            0x125a
-#define MEAS_RST_BIT                    18 // write 1 & then 0 to reset
-#define MEAS_RST_WID                    1
-#define MEAS_WIDEN_HS_VS_EN_BIT         17 //make hs ,vs at lest 12 pulse wide
-#define MEAS_WIDEN_HS_VS_EN_WID         1
-#define MEAS_VS_TOTAL_CNT_EN_BIT        16 // vsync total counter always accumulating enable
-#define MEAS_VS_TOTAL_CNT_EN_WID        1
-#define MEAS_HS_VS_SEL_BIT              12 // 0: null, 1: vdi1, 2: vdi2, 3: vdi3, 4:vdi4, 5:vdi5,for m6 6:vdi6,7:vdi7 8:vdi8-isp
-#define MEAS_HS_VS_SEL_WID              4
-#define MEAS_VS_SPAN_BIT                4  // define how many VS span need to measure
-#define MEAS_VS_SPAN_WID                8
-#define MEAS_HS_INDEX_BIT               0  // select which HS counter/range
-#define MEAS_HS_INDEX_WID               3
-
-
-
-//#define VDIN_MEAS_VS_COUNT_HI                      0x125b // read only
-#define MEAS_IND_VS_TOTAL_CNT_N_BIT     16 // after every VDIN_MEAS_VS_SPAN number of VS pulses, VDIN_MEAS_IND_TOTAL_COUNT_N++
-#define MEAS_IND_VS_TOTAL_CNT_N_WID     4
-#define MEAS_VS_TOTAL_CNT_HI_BIT        0  // vsync_total_counter[47:32]
-#define MEAS_VS_TOTAL_CNT_HI_WID        16
-
-
-
-//#define VDIN_MEAS_VS_COUNT_LO                      0x125c // read only
-#define MEAS_VS_TOTAL_CNT_LO_BIT        0  // vsync_total_counter[31:0]
-#define MEAS_VS_TOTAL_CNT_LO_WID        32
-
-
-
-//#define VDIN_MEAS_HS_RANGE                         0x125d // 1st/2nd/3rd/4th hs range according to VDIN_MEAS_HS_INDEX
-#define MEAS_HS_RANGE_CNT_START_BIT     16
-#define MEAS_HS_RANGE_CNT_START_WID     13
-#define MEAS_HS_RANGE_CNT_END_BIT       0
-#define MEAS_HS_RANGE_CNT_END_WID       13
-
-
-
-//#define VDIN_MEAS_HS_COUNT                         0x125e // read only
-#define MEAS_HS_CNT_BIT                 0 // hs count as per 1st/2nd/3rd/4th hs range according to VDIN_MEAS_HS_INDEX
-#define MEAS_HS_CNT_WID                 24
-
-
-
-//#define VDIN_BLKBAR_CTRL1                          0x125f
-#define BLKBAR_WHITE_EN_BIT             8
-#define BLKBAR_WHITE_EN_WID             1
-#define BLKBAR_WHITE_LVL_BIT            0
-#define BLKBAR_WHITE_LVL_WID            8
-
-
-//#define VDIN_BLKBAR_CTRL0                       0x1260
-
-
-
-#define BLKBAR_BLK_LVL_BIT              24
-#define BLKBAR_BLK_LVL_WID              8   // threshold to judge a black point
-
-
-#define BLKBAR_H_WIDTH_BIT              8
-#define BLKBAR_H_WIDTH_WID              13   // left and right region width
-/* select yin or uin or vin to be the valid input */
-#define BLKBAR_COMP_SEL_BIT             5
-#define BLKBAR_COMP_SEL_WID             3
-/* sw statistic of black pixels of each block,
-1: search once, 0: search continuously till the exact edge */
-#define BLKBAR_SW_STAT_EN_BIT           4
-#define BLKBAR_SW_STAT_EN_WID           1
-#define BLKBAR_DET_SOFT_RST_N_BIT       3
-#define BLKBAR_DET_SOFT_RST_N_WID       1    // write 0 & then 1 to reset
-/* 0: matrix_dout, 1: hscaler_dout, 2/3: pre-hscaler_din */
-#define BLKBAR_DIN_SEL_BIT              1
-#define BLKBAR_DIN_SEL_WID              2
-/* blkbar_din_srdy blkbar_din_rrdy  enable */
-#define BLKBAR_DET_TOP_EN_BIT           0
-#define BLKBAR_DET_TOP_EN_WID           1
-
-//#define VDIN_BLKBAR_H_START_END                    0x1261
-#define BLKBAR_HSTART_BIT               16
-#define BLKBAR_HSTART_WID               13   // Left region start
-#define BLKBAR_HEND_BIT                 0
-#define BLKBAR_HEND_WID                 13   // Right region end
-
-//#define VDIN_BLKBAR_V_START_END                    0x1262
-#define BLKBAR_VSTART_BIT               16
-#define BLKBAR_VSTART_WID               13
-#define BLKBAR_VEND_BIT                 0
-#define BLKBAR_VEND_WID                 13
-
-//#define VDIN_BLKBAR_CNT_THRESHOLD                  0x1263
-/* black pixel number threshold to judge whether a block is totally black */
-#define BLKBAR_CNT_TH_BIT               0
-#define BLKBAR_CNT_TH_WID               20
-
-//#define VDIN_BLKBAR_ROW_TH1_TH2                    0x1264
-/* white pixel number threshold of black line on top */
-#define BLKBAR_ROW_TH1_BIT              16
-#define BLKBAR_ROW_TH1_WID              13
-/* white pixel number threshold of black line on bottom */
-#define BLKBAR_ROW_TH2_BIT              0
-#define BLKBAR_ROW_TH2_WID              13
-
-//#define VDIN_BLKBAR_IND_LEFT_START_END             0x1265
-#define BLKBAR_LEFT_HSTART_BIT          16
-#define BLKBAR_LEFT_HSTART_WID          13
-#define BLKBAR_LEFT_HEND_BIT            0
-#define BLKBAR_LEFT_HEND_WID            13
-
-//#define VDIN_BLKBAR_IND_RIGHT_START_END            0x1266
-#define BLKBAR_RIGHT_HSTART_BIT         16
-#define BLKBAR_RIGHT_HSTART_WID         13
-#define BLKBAR_RIGHT_HEND_BIT           0
-#define BLKBAR_RIGHT_HEND_WID           13
-
-//#define VDIN_BLKBAR_IND_LEFT1_CNT                  0x1267
-/* Black pixels at left part of the left region */
-#define BLKBAR_LEFT1_CNT_BIT            0
-#define BLKBAR_LEFT1_CNT_WID            20
-
-//#define VDIN_BLKBAR_IND_LEFT2_CNT                  0x1268
-/* Black pixels at right part of the left region */
-#define BLKBAR_LEFT2_CNT_BIT            0
-#define BLKBAR_LEFT2_CNT_WID            20
-
-//#define VDIN_BLKBAR_IND_RIGHT1_CNT                 0x1269
-/* Black pixels at right part of the left region */
-#define BLKBAR_RIGHT1_CNT_BIT           0
-#define BLKBAR_RIGHT1_CNT_WID           20
-
-//#define VDIN_BLKBAR_IND_RIGHT2_CNT                 0x126a
-/* Black pixels at right part of the right region */
-#define BLKBAR_RIGHT2_CNT_BIT           0
-#define BLKBAR_RIGHT2_CNT_WID           20
-
-//#define VDIN_BLKBAR_STATUS0                        0x126b
-/* LEFT/RIGHT Black Bar detection done */
-#define BLKBAR_DET_DONE_BIT             29
-#define BLKBAR_DET_DONE_WID             1
-#define BLKBAR_TOP_POS_BIT              16
-#define BLKBAR_TOP_POS_WID              13
-#define BLKBAR_BTM_POS_BIT              0
-#define BLKBAR_BTM_POS_WID              13
-
-//#define VDIN_BLKBAR_STATUS1                        0x126c
-#define BLKBAR_LEFT_POS_BIT             16
-#define BLKBAR_LEFT_POS_WID             13
-#define BLKBAR_RIGHT_POS_BIT            0
-#define BLKBAR_RIGHT_POS_WID            13
-
-
-//#define VDIN_WIN_H_START_END                       0x126d
-#define INPUT_WIN_H_START_BIT            16
-#define INPUT_WIN_H_START_WID            13
-#define INPUT_WIN_H_END_BIT              0
-#define INPUT_WIN_H_END_WID              13
-
-
-
-//#define VDIN_WIN_V_START_END                       0x126e
-#define INPUT_WIN_V_START_BIT            16
-#define INPUT_WIN_V_START_WID            13
-#define INPUT_WIN_V_END_BIT              0
-#define INPUT_WIN_V_END_WID              13
-
-
-//Bit 15:8 vdi7 asfifo_ctrl 
-//Bit 7:0 vdi6 asfifo_ctrl 
-//#define VDIN_ASFIFO_CTRL3                                 0x126f
-#define VDI8_ASFIFO_CTRL_BIT		16
-#define VDI8_ASFIFO_CTRL_WID            8
-#define VDI7_ASFIFO_CTRL_BIT            8
-#define VDI7_ASFIFO_CTRL_WID            8
-#define VDI6_ASFIFO_CTRL_BIT            0
-#define VDI6_ASFIFO_CTRL_WID            8
-
-
-////===========================================////
-//// CM2 ADDR
-////===========================================////
-
-#define SAT_BYYB_NODE_REG0          0x200   // default 32'h0 
-#define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
-#define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
-#define SAT_SRC_NODE_REG            0x203   // default 32'h0
-#define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
-#define FRM_SIZE_REG                0x205   // default 32'h0
-#define FITLER_CFG_REG              0x206   // default 32'h0
-#define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
-#define CM_ENH_CTL_REG              0x208   // default 32'h0
-
-#define ROI_X_SCOPE_REG             0x209   // default 32'h0
-#define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
-#define POI_XY_DIR_REG              0x20b   // default 32'h0
-#define COI_Y_SCOPE_REG             0x20c   // default 32'h0
-#define COI_H_SCOPE_REG             0x20d   // default 32'h0
-#define COI_S_SCOPE_REG             0x20e   // default 32'h0
-#define IFO_MODE_REG                0x20f   // default 32'h0
-#define POI_RPL_MODE_REG            0x210   // default 32'h0
-#define DEMO_OWR_YHS_REG            0x211   // default 32'h0
-#define DEMO_POI_Y_REG              0x212   // default 32'h0
-#define DEMO_POI_H_REG              0x213   // default 32'h0
-#define DEMO_POI_S_REG              0x214   // default 32'h0
-//#define LUMA_BYH_LIMT_REG           0x215   // default 32'h0
-#define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
-#define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
-#define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
-#define UVHS_OFST_REG               0x218   // default 32'h0
-#define HUE_CFG_PARA_REG            0x219   // default 32'h0
-#define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
-#define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0    
-
-////========= NODE 0 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 1 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 2 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 3 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 4 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 5 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 6 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 7 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 8 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 9 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 10 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 11 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-//========= NODE 12 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-
-////========= NODE 13 COEFFICIENT ==============////
-
-#define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
-                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
-                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
-#define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
-                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
-                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
-#define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
-                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
-                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
-#define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
-                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
-                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
-#define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
-                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
-                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
-#endif // __VDIN_REGS_H
diff --git a/drivers/amlogic/tvin/vdin/vdin_sm.c b/drivers/amlogic/tvin/vdin/vdin_sm.c
deleted file mode 100755
index 3f20bff6ecd3..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_sm.c
+++ /dev/null
@@ -1,511 +0,0 @@
-/*
- * TVIN Signal State Machine
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/* Standard Linux Headers */
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-
-/* Amlogic Headers */
-#include <linux/amlogic/tvin/tvin.h>
-
-/* Local Headers */
-#include "../tvin_frontend.h"
-#include "../tvin_format_table.h"
-#include "vdin_sm.h"
-#include "vdin_ctl.h"
-#include "vdin_drv.h"
-
-
-/* Stay in TVIN_SIG_STATE_NOSIG for some cycles => be sure TVIN_SIG_STATE_NOSIG */
-#define NOSIG_MAX_CNT               8
-/* Stay in TVIN_SIG_STATE_UNSTABLE for some cycles => be sure TVIN_SIG_STATE_UNSTABLE */
-#define UNSTABLE_MAX_CNT            2// 4
-/* Have signal for some cycles  => exit TVIN_SIG_STATE_NOSIG */
-#define EXIT_NOSIG_MAX_CNT          2// 1
-/* No signal for some cycles  => back to TVAFE_STATE_NOSIG */
-#define BACK_NOSIG_MAX_CNT          24 //8
-/* Signal unstable for some cycles => exit TVAFE_STATE_STABLE */
-#define EXIT_STABLE_MAX_CNT         1
-/* Signal stable for some cycles  => back to TVAFE_STATE_STABLE */
-#define BACK_STABLE_MAX_CNT         50  //must >=500ms,for new api function
-
-#define EXIT_PRESTABLE_MAX_CNT      50
-
-static struct tvin_sm_s sm_dev[VDIN_MAX_DEVS];
-
-#if 0
-static enum tvin_sm_status_e state = TVIN_SM_STATUS_NULL;    //TVIN_SIG_STATUS_NOSIG;
-
-static unsigned int state_counter          = 0; // STATE_NOSIG, STATE_UNSTABLE
-static unsigned int exit_nosig_counter     = 0; // STATE_NOSIG
-static unsigned int back_nosig_counter     = 0; // STATE_UNSTABLE
-static unsigned int back_stable_counter    = 0; // STATE_UNSTABLE
-static unsigned int exit_prestable_counter = 0; // STATE_PRESTABLE
-#endif
-static int sm_debug_enable = 1;
-
-static int sm_print_nosig  = 0;
-static int sm_print_notsup = 0;
-static int sm_print_unstable = 0;
-static int sm_print_fmt_nosig = 0;
-static int sm_print_fmt_chg = 0;
-
-module_param(sm_debug_enable, bool, 0664);
-MODULE_PARM_DESC(sm_debug_enable, "enable/disable state machine debug message");
-#if 1
-static int back_nosig_max_cnt = BACK_NOSIG_MAX_CNT;
-module_param(back_nosig_max_cnt, int, 0664);
-MODULE_PARM_DESC(back_nosig_max_cnt, "unstable enter nosignal state max count");
-
-static int atv_unstable_in_cnt = 45;
-module_param(atv_unstable_in_cnt, int, 0664);
-MODULE_PARM_DESC(atv_unstable_in_cnt, "atv_unstable_in_cnt");
-
-static int atv_unstable_out_cnt = 50;
-module_param(atv_unstable_out_cnt, int, 0664);
-MODULE_PARM_DESC(atv_unstable_out_cnt, "atv_unstable_out_cnt");
-
-static int atv_stable_out_cnt = 10;
-module_param(atv_stable_out_cnt, int, 0664);
-MODULE_PARM_DESC(atv_stable_out_cnt, "atv_stable_out_cnt");
-
-static int other_stable_out_cnt = EXIT_STABLE_MAX_CNT;
-module_param(other_stable_out_cnt, int, 0664);
-MODULE_PARM_DESC(other_stable_out_cnt, "other_stable_out_cnt");
-
-static int other_unstable_out_cnt = BACK_STABLE_MAX_CNT;
-module_param(other_unstable_out_cnt, int, 0664);
-MODULE_PARM_DESC(other_unstable_out_cnt, "other_unstable_out_cnt");
-
-static int other_unstable_in_cnt = UNSTABLE_MAX_CNT;
-module_param(other_unstable_in_cnt, int, 0664);
-MODULE_PARM_DESC(other_unstable_in_cnt, "other_unstable_in_cnt");
-
-static int comp_pre2_stable_cnt = EXIT_PRESTABLE_MAX_CNT;
-module_param(comp_pre2_stable_cnt, int, 0664);
-MODULE_PARM_DESC(comp_pre2_stable_cnt, "comp_pre2_stable_cnt");
-
-static int nosig_in_cnt = NOSIG_MAX_CNT;
-module_param(nosig_in_cnt, int, 0664);
-MODULE_PARM_DESC(nosig_in_cnt, "nosig_in_cnt");
-
-static int nosig2_unstable_cnt = EXIT_NOSIG_MAX_CNT;
-module_param(nosig2_unstable_cnt, int, 0664);
-MODULE_PARM_DESC(nosig2_unstable_cnt, "nosig2_unstable_cnt");
-
-/*
-   void tvin_smr_init_counter(void)
-   {
-   state_counter          = 0;
-   exit_nosig_counter     = 0;
-   back_nosig_counter     = 0;
-   back_stable_counter    = 0;
-   exit_prestable_counter = 0;
-   }
- */
-#endif
-/*
- * check hdmirx color format
- */
-static void hdmirx_color_fmt_handler(struct vdin_dev_s *devp)
-{
-    struct tvin_state_machine_ops_s *sm_ops;
-    enum tvin_port_e port = TVIN_PORT_NULL;
-
-    if (!devp || !devp->frontend) {
-            sm_dev[devp->index].state = TVIN_SM_STATUS_NULL;
-            return;
-    }
-
-    sm_ops = devp->frontend->sm_ops;
-    port = devp->parm.port;
-
-    if ((port < TVIN_PORT_HDMI0) || (port > TVIN_PORT_HDMI7))
-        return;
-
-    if (devp->flags & VDIN_FLAG_DEC_STARTED) {
-        if (sm_ops->get_sig_propery) {
-            sm_ops->get_sig_propery(devp->frontend, &devp->prop);
-            if ((devp->prop.color_format != devp->pre_prop.color_format)) {
-                pr_info("[smr.%d] : config hdmi color fmt(%d->%d)\n",
-                        devp->index, devp->pre_prop.color_format, devp->prop.color_format);
-                devp->pre_prop.color_format = devp->prop.color_format;
-                vdin_get_format_convert(devp);
-                vdin_set_matrix(devp);
-            }
-        }
-    }
-}
-
-void tvin_smr_init_counter(int index)
-{
-        sm_dev[index].state_counter          = 0;
-        sm_dev[index].exit_nosig_counter     = 0;
-        sm_dev[index].back_nosig_counter     = 0;
-        sm_dev[index].back_stable_counter    = 0;
-        sm_dev[index].exit_prestable_counter = 0;
-}
-
-/*
- * tvin state machine routine
- *
- */
-void tvin_smr(struct vdin_dev_s *devp)
-{
-        struct tvin_state_machine_ops_s *sm_ops;
-        struct tvin_info_s *info;
-        enum tvin_port_e port = TVIN_PORT_NULL;
-        unsigned int unstable_in_cnt;
-        struct tvin_sm_s *sm_p;
-        if (!devp || !devp->frontend)
-        {
-                sm_dev[devp->index].state = TVIN_SM_STATUS_NULL;
-                return;
-        }
-
-        sm_ops = devp->frontend->sm_ops;
-        info = &devp->parm.info;
-        port = devp->parm.port;
-        sm_p = &sm_dev[devp->index];
-
-        switch (sm_p->state)
-        {
-                case TVIN_SM_STATUS_NOSIG:
-                        ++sm_p->state_counter;
-                        if (devp->parm.flag & TVIN_PARM_FLAG_CAL)
-                        {
-                                if ((((port >= TVIN_PORT_COMP0) && (port <= TVIN_PORT_COMP7)) ||
-                                                        ((port >= TVIN_PORT_VGA0 ) && (port <= TVIN_PORT_VGA7 ))
-                                    ) &&
-                                                (sm_ops->adc_cal)
-                                   )
-                                {
-                                        if (!sm_ops->adc_cal(devp->frontend))
-                                                devp->parm.flag &= ~TVIN_PARM_FLAG_CAL;
-                                }
-                                else
-                                        devp->parm.flag &= ~TVIN_PARM_FLAG_CAL;
-                        }
-                        else if (sm_ops->nosig(devp->frontend))
-                        {
-                                sm_p->exit_nosig_counter = 0;
-                                if (sm_p->state_counter >= nosig_in_cnt)
-                                {
-                                        sm_p->state_counter       = nosig_in_cnt;
-                                        info->status        = TVIN_SIG_STATUS_NOSIG;
-                                        info->fmt           = TVIN_SIG_FMT_NULL;
-                                        if (sm_debug_enable && !sm_print_nosig) {
-                                                pr_info("[smr.%d] no signal\n",devp->index);
-                                                sm_print_nosig = 1;
-                                        }
-                                        sm_print_unstable = 0;
-                                }
-                        }
-                        else
-                        {
-                                ++sm_p->exit_nosig_counter;
-                                if (sm_p->exit_nosig_counter >= nosig2_unstable_cnt)
-                                {
-                                        tvin_smr_init_counter(devp->index);
-                                        sm_p->state = TVIN_SM_STATUS_UNSTABLE;
-                                        if (sm_debug_enable)
-                                                pr_info("[smr.%d] no signal --> unstable\n",devp->index);
-                                        sm_print_nosig  = 0;
-                                        sm_print_unstable = 0;
-                                }
-                        }
-                        break;
-
-                case TVIN_SM_STATUS_UNSTABLE:
-                        ++sm_p->state_counter;
-                        if (devp->parm.flag & TVIN_PARM_FLAG_CAL)
-                                devp->parm.flag &= ~TVIN_PARM_FLAG_CAL;
-                        if (sm_ops->nosig(devp->frontend))
-                        {
-                                sm_p->back_stable_counter = 0;
-                                ++sm_p->back_nosig_counter;
-                                if (sm_p->back_nosig_counter >= sm_p->back_nosig_max_cnt)
-                                {
-                                        tvin_smr_init_counter(devp->index);
-                                        sm_p->state = TVIN_SM_STATUS_NOSIG;
-                                        info->status = TVIN_SIG_STATUS_NOSIG;
-                                        info->fmt    = TVIN_SIG_FMT_NULL;
-                                        if (sm_debug_enable)
-                                                pr_info("[smr.%d] unstable --> no signal\n",devp->index);
-                                        sm_print_nosig  = 0;
-                                        sm_print_unstable = 0;
-                                }
-                        }
-                        else
-                        {
-                                sm_p->back_nosig_counter = 0;
-                                if (sm_ops->fmt_changed(devp->frontend) )
-
-                                {
-                                        sm_p->back_stable_counter = 0;
-                                        if((port == TVIN_PORT_CVBS0)&&devp->unstable_flag)
-                                                unstable_in_cnt = sm_p->atv_unstable_in_cnt;//UNSTABLE_ATV_MAX_CNT;
-                                        else
-                                                unstable_in_cnt = other_unstable_in_cnt;
-                                        if (sm_p->state_counter >= unstable_in_cnt)
-                                        {
-                                                sm_p->state_counter  = unstable_in_cnt;
-                                                info->status   = TVIN_SIG_STATUS_UNSTABLE;
-                                                info->fmt      = TVIN_SIG_FMT_NULL;
-                                                if (sm_debug_enable && !sm_print_unstable) {
-                                                        pr_info("[smr.%d] unstable\n",devp->index);
-                                                        sm_print_unstable = 1;
-                                                }
-                                                sm_print_nosig  = 0;
-                                        }
-                                }
-                                else
-                                {
-                                        ++sm_p->back_stable_counter;
-                                        if(port == TVIN_PORT_CVBS0)
-                                                unstable_in_cnt = sm_p->atv_unstable_out_cnt;//UNSTABLE_ATV_MAX_CNT;
-                                        else
-                                                unstable_in_cnt = other_unstable_out_cnt;
-                                        if (sm_p->back_stable_counter >= unstable_in_cnt)
-                                        {   //must wait enough time for cvd signal lock
-                                                sm_p->back_stable_counter    = 0;
-                                                sm_p->state_counter               = 0;
-                                                if (sm_ops->get_fmt) {
-                                                        info->fmt   = sm_ops->get_fmt(devp->frontend);
-                                                        if (sm_ops->get_sig_propery)
-                                                        {
-                                                                sm_ops->get_sig_propery(devp->frontend, &devp->prop);
-                                                                devp->parm.info.trans_fmt = devp->prop.trans_fmt;
-                                                                devp->parm.info.reserved = devp->prop.dvi_info;
-								devp->pre_prop.color_format = devp->prop.color_format;
-                                                        }
-                                                }
-                                                else
-                                                        info->fmt   = TVIN_SIG_FMT_NULL;
-
-                                                /* set signal status */
-                                                if(info->fmt == TVIN_SIG_FMT_NULL)
-                                                {
-                                                        info->status = TVIN_SIG_STATUS_NOTSUP;
-                                                        if (sm_debug_enable && !sm_print_notsup) {
-                                                                pr_info("[smr.%d] unstable --> not support\n",devp->index);
-                                                                sm_print_notsup = 1;
-                                                        }
-                                                }
-                                                else
-                                                {
-                                                        if (sm_ops->fmt_config)
-                                                                sm_ops->fmt_config(devp->frontend);
-                                                        tvin_smr_init_counter(devp->index);
-                                                        sm_p->state = TVIN_SM_STATUS_PRESTABLE;
-                                                        if (sm_debug_enable)
-                                                                pr_info("[smr.%d] unstable --> prestable, and format is %d(%s)\n",
-                                                                                devp->index,info->fmt, tvin_sig_fmt_str(info->fmt));
-                                                        sm_print_nosig  = 0;
-                                                        sm_print_unstable = 0;
-                                                        sm_print_fmt_nosig = 0;
-                                                        sm_print_fmt_chg = 0;
-                                                }
-                                        }
-                                }
-                        }
-                        break;
-
-                case TVIN_SM_STATUS_PRESTABLE:
-                        {
-                                bool nosig = false, fmt_changed = false;//, pll_lock = false;
-                                devp->unstable_flag = true;
-
-                                if (devp->parm.flag & TVIN_PARM_FLAG_CAL)
-                                        devp->parm.flag &= ~TVIN_PARM_FLAG_CAL;
-                                if (sm_ops->nosig(devp->frontend)) {
-                                        nosig = true;
-                                        if (sm_debug_enable)
-                                                pr_info("[smr.%d] warning: no signal\n",devp->index);
-                                }
-
-                                if (sm_ops->fmt_changed(devp->frontend)) {
-                                        fmt_changed = true;
-                                        if (sm_debug_enable)
-                                                pr_info("[smr.%d] warning: format changed\n",devp->index);
-                                }
-
-                                if (nosig || fmt_changed)
-                                {
-                                        ++sm_p->state_counter;
-                                        if (sm_p->state_counter >= other_stable_out_cnt)
-                                        {
-                                                tvin_smr_init_counter(devp->index);
-                                                sm_p->state = TVIN_SM_STATUS_UNSTABLE;
-                                                if (sm_debug_enable)
-                                                        pr_info("[smr.%d] prestable --> unstable\n",devp->index);
-                                                sm_print_nosig  = 0;
-                                                sm_print_notsup = 0;
-                                                sm_print_unstable = 0;
-
-                                                break;
-                                        }
-                                }
-                                else
-                                {
-                                        sm_p->state_counter = 0;
-                                }
-
-                                /* wait comp stable */
-                                if ((port >= TVIN_PORT_COMP0) &&
-                                                (port <= TVIN_PORT_COMP7))
-                                {
-                                        ++sm_p->exit_prestable_counter;
-                                        if (sm_p->exit_prestable_counter >= comp_pre2_stable_cnt)
-                                        {
-                                                tvin_smr_init_counter(devp->index);
-                                                sm_p->state       = TVIN_SM_STATUS_STABLE;
-                                                info->status        = TVIN_SIG_STATUS_STABLE;
-                                                if (sm_debug_enable)
-                                                        pr_info("[smr.%d] prestable --> stable\n",devp->index);
-                                                sm_print_nosig  = 0;
-                                                sm_print_notsup = 0;
-                                        }
-                                }
-                                else
-                                {
-                                        sm_p->state       = TVIN_SM_STATUS_STABLE;
-                                        info->status        = TVIN_SIG_STATUS_STABLE;
-                                        if (sm_debug_enable)
-                                                pr_info("[smr.%d] prestable --> stable\n",devp->index);
-                                        sm_print_nosig  = 0;
-                                        sm_print_notsup = 0;
-                                }
-                                break;
-                        }
-                case TVIN_SM_STATUS_STABLE:
-                        {
-                                bool nosig = false, fmt_changed = false;//, pll_lock = false;
-                                unsigned int stable_out_cnt = 0;
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-                                enum tvin_cvbs_pos_ctl_e pos_ctl = TVIN_CVBS_POS_NULL;
-#endif
-
-                                devp->unstable_flag = true;
-
-                                if (devp->parm.flag & TVIN_PARM_FLAG_CAL)
-                                        devp->parm.flag &= ~TVIN_PARM_FLAG_CAL;
-#ifdef TVAFE_SET_CVBS_MANUAL_FMT_POS
-                                /* cvbs manual fmt video size checking */
-                                if ((port >= TVIN_PORT_CVBS0) && (port <= TVIN_PORT_SVIDEO7) && (sm_ops->set_cvbs_fmt_pos))
-                                {
-                                        pos_ctl = sm_ops->set_cvbs_fmt_pos(devp->frontend);
-                                        if (devp->cvbs_pos_chg != pos_ctl)
-                                        {
-                                                if (pos_ctl != TVIN_CVBS_POS_NULL)
-                                                {
-                                                        /* avoid black screen for auto<-->fmt switch */
-                                                        if (devp->cvbs_pos_chg != TVIN_CVBS_POS_NULL)
-                                                        {
-                                                                fmt_changed = true;
-                                                                info->status = TVIN_SIG_STATUS_UNSTABLE;
-                                                                if (sm_debug_enable)
-                                                                        pr_info("[smr.%d] warning: cvbs manual fmt change:%d \n", 
-                                                                                        devp->index,devp->cvbs_pos_chg);
-                                                        }
-                                                }
-                                                devp->cvbs_pos_chg = pos_ctl;
-                                        }
-                                }
-#endif
-                                if (sm_ops->nosig(devp->frontend)) {
-                                        nosig = true;
-                                        if (sm_debug_enable && !sm_print_fmt_nosig)
-                                        {
-                                                pr_info("[smr.%d] warning: no signal\n",devp->index);
-                                                sm_print_fmt_nosig = 1;
-                                        }
-                                }
-
-                                if (sm_ops->fmt_changed(devp->frontend)) {
-                                        fmt_changed = true;
-                                        if (sm_debug_enable && !sm_print_fmt_chg)
-                                        {
-                                                pr_info("[smr.%d] warning: format changed\n",devp->index);
-                                                sm_print_fmt_chg = 1;
-                                        }
-                                }
-                            hdmirx_color_fmt_handler(devp);
-#if 0
-                                if (sm_ops->pll_lock(devp->frontend)) {
-                                        pll_lock = true;
-                                }
-                                else {
-                                        pll_lock = false;
-                                        if (sm_debug_enable)
-                                                pr_info("[smr] warning: pll lock failed\n");
-                                }
-#endif
-
-                                if (nosig || fmt_changed /* || !pll_lock */)
-                                {
-                                        ++sm_p->state_counter;
-                                        if (port == TVIN_PORT_CVBS0)
-                                                stable_out_cnt = sm_p->atv_stable_out_cnt;
-                                        else
-                                                stable_out_cnt = other_stable_out_cnt;
-                                        if (sm_p->state_counter >= stable_out_cnt)
-                                        {
-                                                tvin_smr_init_counter(devp->index);
-                                                sm_p->state = TVIN_SM_STATUS_UNSTABLE;
-                                                if (sm_debug_enable)
-                                                        pr_info("[smr.%d] stable --> unstable\n",devp->index);
-                                                sm_print_nosig  = 0;
-                                                sm_print_notsup = 0;
-                                                sm_print_unstable = 0;
-                                                sm_print_fmt_nosig = 0;
-                                                sm_print_fmt_chg = 0;
-                                        }
-                                }
-                                else
-                                {
-                                        sm_p->state_counter = 0;
-                                }
-                                break;
-                        }
-                case TVIN_SM_STATUS_NULL:
-                default:
-                        if (devp->parm.flag & TVIN_PARM_FLAG_CAL)
-                                devp->parm.flag &= ~TVIN_PARM_FLAG_CAL;
-                        sm_p->state = TVIN_SM_STATUS_NOSIG;
-                        break;
-        }
-}
-
-/*
- * tvin state machine routine init
- *
- */
-
-void tvin_smr_init(int index)
-{
-        sm_dev[index].state = TVIN_SM_STATUS_NULL;
-        sm_dev[index].atv_stable_out_cnt = atv_stable_out_cnt;
-        sm_dev[index].atv_unstable_in_cnt = atv_unstable_in_cnt;
-        sm_dev[index].back_nosig_max_cnt =back_nosig_max_cnt;
-        sm_dev[index].atv_unstable_out_cnt = atv_unstable_out_cnt;
-        tvin_smr_init_counter(index);
-}
-
-enum tvin_sm_status_e tvin_get_sm_status(int index)
-{
-        return sm_dev[index].state;
-}
-
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_sm.h b/drivers/amlogic/tvin/vdin/vdin_sm.h
deleted file mode 100755
index 5a2e7c29687c..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_sm.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * TVIN Signal State Machine
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __TVIN_STATE_MACHINE_H
-#define __TVIN_STATE_MACHINE_H
-
-#include "vdin_drv.h"
-
-typedef enum tvin_sm_status_e {
-    TVIN_SM_STATUS_NULL = 0, // processing status from init to the finding of the 1st confirmed status
-    TVIN_SM_STATUS_NOSIG,    // no signal - physically no signal
-    TVIN_SM_STATUS_UNSTABLE, // unstable - physically bad signal
-    TVIN_SM_STATUS_NOTSUP,   // not supported - physically good signal & not supported
-    TVIN_SM_STATUS_PRESTABLE,
-    TVIN_SM_STATUS_STABLE,   // stable - physically good signal & supported
-} tvin_sm_status_t;
-typedef struct tvin_sm_s {
-    enum tvin_sm_status_e state;
-    unsigned int state_counter; // STATE_NOSIG, STATE_UNSTABLE
-    unsigned int exit_nosig_counter; // STATE_NOSIG
-    unsigned int back_nosig_counter; // STATE_UNSTABLE
-    unsigned int back_stable_counter; // STATE_UNSTABLE
-    unsigned int exit_prestable_counter; // STATE_PRESTABLE
-    //thresholds of state switchted  
-    int back_nosig_max_cnt ;
-    int atv_unstable_in_cnt ;
-    int atv_unstable_out_cnt;
-    int atv_stable_out_cnt;
-}tvin_sm_t;
-void tvin_smr(struct vdin_dev_s *pdev);
-void tvin_smr_init(int index);
-
-enum tvin_sm_status_e tvin_get_sm_status(int index);
-
-#endif
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_vf.c b/drivers/amlogic/tvin/vdin/vdin_vf.c
deleted file mode 100755
index 4ffde9bae8fd..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_vf.c
+++ /dev/null
@@ -1,821 +0,0 @@
-/*
- * VDIN vframe support
- *
- * Author: Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-/* Standard Linux headers */
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/time.h>
-
-
-/* Amlogic Headers */
-#include <linux/amlogic/amports/vframe.h>
-
-/* Local Headers */
-#include "vdin_vf.h"
-
-static int vf_log_enable = 1;
-static int vf_log_fe = 1;
-static int vf_log_be = 1;
-
-module_param(vf_log_enable, bool, 0664);
-MODULE_PARM_DESC(vf_log_enable, "enable/disable vframe manager log");
-
-module_param(vf_log_fe, bool, 0664);
-MODULE_PARM_DESC(vf_log_fe, "enable/disable vframe manager log frontend");
-
-module_param(vf_log_be, bool, 0664);
-MODULE_PARM_DESC(vf_log_be, "enable/disable vframe manager log backen");
-
-
-#ifdef VF_LOG_EN
-inline void vf_log_init(struct vf_pool *p)
-{
-	memset(&p->log, 0, sizeof(struct vf_log_s));
-}
-#else
-inline void vf_log_init(struct vf_pool *p)
-{
-}
-#endif
-
-#ifdef VF_LOG_EN
-static void vf_log(struct vf_pool *p, enum vf_operation_e operation, bool operation_done)
-{
-	unsigned int i = 0;
-	struct vf_log_s *log = &p->log;
-
-	if (!vf_log_enable)
-		return;
-
-	if (!vf_log_fe)
-		if (operation == VF_OPERATION_FPEEK ||
-		    operation == VF_OPERATION_FGET ||
-		    operation == VF_OPERATION_FPUT)
-			return;
-
-	if (!vf_log_be)
-		if (operation == VF_OPERATION_BPEEK ||
-		    operation == VF_OPERATION_BGET ||
-		    operation == VF_OPERATION_BPUT)
-			return;
-
-	if (log->log_cur >= VF_LOG_LEN) {
-		return;
-	}
-	do_gettimeofday(&log->log_time[log->log_cur]);
-	for (i = 0; i < 11; i++)
-		log->log_buf[log->log_cur][i] = 0x00;
-	for (i = 0; i < p->size; i++)
-	{
-		switch (p->master[i].status)
-		{
-		case VF_STATUS_WL:
-			log->log_buf[log->log_cur][0] |= 1 << i;
-			break;
-		case VF_STATUS_WM:
-			log->log_buf[log->log_cur][1] |= 1 << i;
-			break;
-		case  VF_STATUS_RL:
-			log->log_buf[log->log_cur][2] |= 1 << i;
-			break;
-		case  VF_STATUS_RM:
-			log->log_buf[log->log_cur][3] |= 1 << i;
-			break;
-		case  VF_STATUS_WT:
-			log->log_buf[log->log_cur][4] |= 1 << i;
-			break;
-		default:
-			break;
-		}
-
-		switch (p->slave[i].status)
-		{
-		case VF_STATUS_WL:
-			log->log_buf[log->log_cur][5] |= 1 << i;
-			break;
-		case VF_STATUS_WM:
-			log->log_buf[log->log_cur][6] |= 1 << i;
-			break;
-		case  VF_STATUS_RL:
-			log->log_buf[log->log_cur][7] |= 1 << i;
-			break;
-		case  VF_STATUS_RM:
-			log->log_buf[log->log_cur][8] |= 1 << i;
-			break;
-		case  VF_STATUS_WT:
-			log->log_buf[log->log_cur][9] |= 1 << i;
-			break;
-		default:
-			break;
-		}
-	}
-	log->log_buf[log->log_cur][10] = operation;
-	if (!operation_done)
-	{
-		log->log_buf[log->log_cur][10] |= 0x80;
-	}
-	log->log_cur++;
-}
-#else
-static void vf_log(struct vf_pool *p, enum vf_operation_e operation, bool failure)
-{
-}
-#endif
-
-#ifdef VF_LOG_EN
-void vf_log_print(struct vf_pool *p)
-{
-	unsigned int i = 0, j = 0, k = 0;
-	int len = 0;
-	char buf1[100];
-	char buf2[100];
-	struct vf_log_s *log = &p->log;
-
-	pr_info("%-10s %-10s %-10s %-10s %-10s %-10s %5s\n",
-			"WR_LIST", "RW_MODE", "RD_LIST", "RD_MODE", "WT_LIST",
-			"OPERATIOIN", "TIME");
-
-	for (i = 0; i < log->log_cur; i++)
-	{
-		memset(buf1, 0, sizeof(buf1));
-		len = 0;
-
-		for (j = 0; j < 5; j++)
-		{
-			for (k = 0; k < 8; k++)
-			{
-				if (k == 4)
-					len += sprintf(buf1+len, "-");
-				len += sprintf(buf1+len, "%1d",(log->log_buf[i][j] >> (7 - k)) & 1);
-			}
-			len += sprintf(buf1+len, "  ");
-		}
-
-		if (log->log_buf[i][10] & 0x80)
-			len += sprintf(buf1+len, "(X)");
-		else
-			len += sprintf(buf1+len, "	 ");
-		switch (log->log_buf[i][10] & 0x7)
-		{
-			case VF_OPERATION_INIT:
-				len += sprintf(buf1+len, "%-7s", "INIT");
-				break;
-			case VF_OPERATION_FPEEK:
-				len += sprintf(buf1+len, "%-7s", "FE_PEEK");
-				break;
-			case VF_OPERATION_FGET:
-				len += sprintf(buf1+len, "%-7s", "FE_GET");
-				break;
-			case VF_OPERATION_FPUT:
-				len += sprintf(buf1+len, "%-7s", "FE_PUT");
-				break;
-			case VF_OPERATION_BPEEK:
-				len += sprintf(buf1+len, "%-7s", "BE_PEEK");
-				break;
-			case VF_OPERATION_BGET:
-				len += sprintf(buf1+len, "%-7s", "BE_GET");
-				break;
-			case VF_OPERATION_BPUT:
-				len += sprintf(buf1+len, "%-7s", "BE_PUT");
-				break;
-			case VF_OPERATION_FREE:
-				len += sprintf(buf1+len, "%-7s", "FREE");
-				break;
-			default:
-				break;
-		}
-		len += sprintf(buf1+len, " %ld.%03ld", (long)log->log_time[i].tv_sec,
-			(long)log->log_time[i].tv_usec/1000);
-
-		memset(buf2, 0, sizeof(buf2));
-		len = 0;
-		for (j = 5; j < 10; j++)
-		{
-			for (k = 0; k < 8; k++)
-			{
-				if (k == 4)
-					len += sprintf(buf2 + len, "-");
-				len += sprintf(buf2 + len, "%1d",(log->log_buf[i][j] >> (7 - k)) & 1);
-			}
-			len += sprintf(buf2 + len, "  ");
-		}
-		printk("%s\n", buf1);
-		printk("%s\n\n", buf2);
-	}
-}
-#else
-void vf_log_print(struct vf_pool *p)
-{
-}
-#endif
-#ifdef ISR_LOG_EN
-inline void isr_log_init(struct vf_pool *p)
-{       
-     memset(&p->isr_log, 0, sizeof(struct isr_log_s));
-     p->isr_log.isr_log_en = 1;
-     
-}
-inline void isr_log_print(struct vf_pool *p)
-{
-        unsigned int i = 0;
-        struct isr_log_s *log = &p->isr_log;
-        log->isr_log_en = 0;
-        pr_info("%-7s\t%-7s\t%-7s\n",
-			"ID", "ITIME", "OTIME");
-        for(i=0; i<= log->log_cur; i+=2){
-                pr_info("%u\t %7ld.%03ld\t%7ld.%03ld\n", i>>1, (long)log->isr_time[i].tv_sec,
-	                (long)log->isr_time[i].tv_usec,(long)log->isr_time[i+1].tv_sec,
-		        (long)log->isr_time[i+1].tv_usec);
-        }
-        
-        
-}
-inline void isr_log(struct vf_pool *p)
-{
-        struct isr_log_s *log = &p->isr_log;
-        if(!log->isr_log_en)
-                return;
-        if(log->log_cur >= ISR_LOG_LEN)
-                return;
-        do_gettimeofday(&log->isr_time[log->log_cur]);
-        log->log_cur++;
-}
-#else
-inline void isr_log_init(struct vf_pool *p)
-{        
-        
-}
-inline void isr_log_print(struct vf_pool *p)
-{
-        
-}
-inline void isr_log(struct vf_pool *p)
-{
-        
-}
-#endif
-inline struct vf_entry *vf_get_master(struct vf_pool *p, int index)
-{
-	return &p->master[index];
-}
-
-inline struct vf_entry *vf_get_slave(struct vf_pool *p, int index)
-{
-	return &p->slave[index];
-}
-
-/* size : max canvas quantity */
-struct vf_pool *vf_pool_alloc(int size)
-{
-	struct vf_pool *p;
-	p = kmalloc(sizeof(struct vf_pool), GFP_KERNEL);
-	if (!p) {
-		return NULL;
-	}
-	p->master = kmalloc((sizeof(struct vf_entry) * size), GFP_KERNEL);
-	if (!p->master) {
-		kfree(p);
-		return NULL;
-	}
-	p->slave  = kmalloc((sizeof(struct vf_entry) * size), GFP_KERNEL);
-	if (!p->slave) {
-		kfree(p->master);
-		kfree(p);
-		return NULL;
-	}
-	memset(p->master, 0, (sizeof(struct vf_entry) * size));
-	memset(p->slave, 0, (sizeof(struct vf_entry) * size));
-	p->max_size = size;
-	/* initialize list lock */
-	spin_lock_init(&p->wr_lock);
-        spin_lock_init(&p->rd_lock);
-        spin_lock_init(&p->wt_lock);
-        spin_lock_init(&p->fz_lock);
-	spin_lock_init(&p->tmp_lock);
-	/* initialize list head */
-	INIT_LIST_HEAD(&p->wr_list);
-	INIT_LIST_HEAD(&p->rd_list);
-	INIT_LIST_HEAD(&p->wt_list);
-        INIT_LIST_HEAD(&p->fz_list);
-	INIT_LIST_HEAD(&p->tmp_list);
-	return p;
-}
-
-/* size: valid canvas quantity*/
-int vf_pool_init(struct vf_pool *p, int size)
-{
-	int i = 0;
-	unsigned long flags;
-	struct vf_entry *master, *slave;
-	struct vf_entry *pos = NULL, *tmp = NULL;
-
-	if (!p)
-		return -1;
-	if (size > p->max_size)
-		return -1;
-	p->size = size;
-        
-        /*clear pool flag*/
-        p->pool_flag = 0;
-	/* clear write list */
-	spin_lock_irqsave(&p->wr_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->wr_list, list) {
-		list_del(&pos->list);
-	}
-	spin_unlock_irqrestore(&p->wr_lock, flags);
-
-	/* clear read list */
-	spin_lock_irqsave(&p->rd_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->rd_list, list) {
-		list_del(&pos->list);
-	}
-	spin_unlock_irqrestore(&p->rd_lock, flags);
-
-	spin_lock_irqsave(&p->wt_lock, flags);
-	/* clear wait list */
-	list_for_each_entry_safe(pos, tmp, &p->wt_list, list) {
-		list_del(&pos->list);
-	}
-	spin_unlock_irqrestore(&p->wt_lock, flags);
-        /* clear freeze list*/
-        spin_lock_irqsave(&p->fz_lock, flags);
-        list_for_each_entry_safe(pos, tmp, &p->fz_list, list) {
-		list_del(&pos->list);
-	}
-	spin_unlock_irqrestore(&p->fz_lock,flags);
-	/* clear tmp list*/
-        spin_lock_irqsave(&p->tmp_lock, flags);
-        list_for_each_entry_safe(pos, tmp, &p->tmp_list, list) {
-		list_del(&pos->list);
-	}
-        spin_unlock_irqrestore(&p->tmp_lock,flags);
-	p->wr_list_size = 0;
-	p->rd_list_size = 0;
-        p->fz_list_size = 0;
-	p->tmp_list_size = 0;
-	/* initialize provider write list */
-	for (i = 0; i < size; i++) {
-		master = vf_get_master(p, i);
-		master->status = VF_STATUS_WL;
-		master->flag |= VF_FLAG_NORMAL_FRAME;
-                master->flag &= (~VF_FLAG_FREEZED_FRAME);
-		spin_lock_irqsave(&p->wr_lock, flags);
-		list_add(&master->list, &p->wr_list);
-		p->wr_list_size++;
-		spin_unlock_irqrestore(&p->wr_lock, flags);
-	}
-
-	for (i = 0; i < size; i++) {
-		slave = vf_get_slave(p, i);
-		slave->status = VF_STATUS_SL;
-	}
-
-#ifdef VF_LOG_EN
-	vf_log_init(p);
-	vf_log(p, VF_OPERATION_INIT, true);
-#endif
-	return 0;
-}
-
-
-/* free the vframe pool of the vfp */
-void vf_pool_free(struct vf_pool *p)
-{
-	if (p) {
-		vf_log(p, VF_OPERATION_FREE, true);
-		if (p->master)
-			kfree(p->master);
-		if (p->slave)
-			kfree(p->master);
-		kfree(p);
-	}
-}
-
-/* return the last entry */
-static inline struct vf_entry *vf_pool_peek(struct list_head *head)
-{
-	struct vf_entry *vfe;
-	if (list_empty(head))
-		return NULL;
-	vfe = list_entry(head->prev, struct vf_entry, list);
-	return vfe;
-}
-
-/* return and del the last entry*/
-static inline struct vf_entry *vf_pool_get(struct list_head *head)
-{
-	struct vf_entry *vfe;
-	if (list_empty(head))
-		return NULL;
-	vfe = list_entry(head->prev, struct vf_entry, list);
-	list_del(&vfe->list);
-	return vfe;
-}
-
-/* add entry in the list head */
-static inline void vf_pool_put(struct vf_entry *vfe, struct list_head *head)
-{
-	list_add(&vfe->list, head);
-}
-/*
-*move all vf_entrys in tmp list to writable list
-*/
-void recycle_tmp_vfs(struct vf_pool *p)
-{
-	struct vf_entry *pos = NULL, *tmp = NULL;
-	unsigned long flags;
-	spin_lock_irqsave(&p->tmp_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->tmp_list, list) {
-		list_del(&pos->list);
-		receiver_vf_put(&pos->vf,p);
-		p->tmp_list_size--;
-	}
-	spin_unlock_irqrestore(&p->tmp_lock, flags);
-}
-/*
-*put vf_entry to tmp list
-*/
-void tmp_vf_put(struct vf_entry *vfe,struct vf_pool *p)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&p->tmp_lock, flags);
-	vf_pool_put(vfe, &p->tmp_list);
-	p->tmp_list_size++;
-	spin_unlock_irqrestore(&p->tmp_lock, flags);
-}
-/*
-*move all vf_entry in tmp list to readable list
-*/
-void tmp_to_rd(struct vf_pool *p)
-{
-	struct vf_entry *pos = NULL, *tmp = NULL;
-	unsigned long flags;
-	spin_lock_irqsave(&p->tmp_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->tmp_list, list) {
-		list_del(&pos->list);
-		provider_vf_put(&pos->vf,p);
-		p->tmp_list_size--;
-	}
-	spin_unlock_irqrestore(&p->tmp_lock, flags);
-}
-inline struct vf_entry *provider_vf_peek(struct vf_pool *p)
-{
-	struct vf_entry *vfe;
-	unsigned long flags;
-
-	spin_lock_irqsave(&p->wr_lock, flags);
-	vfe = vf_pool_peek(&p->wr_list);
-	spin_unlock_irqrestore(&p->wr_lock, flags);
-	if (!vfe)
-		vf_log(p, VF_OPERATION_FPEEK, false);
-	else
-		vf_log(p, VF_OPERATION_FPEEK, true);
-	return vfe;
-}
-
-/* provider get last vframe to write */
-inline struct vf_entry *provider_vf_get(struct vf_pool *p)
-{
-	struct vf_entry *vfe;
-	unsigned long flags;
-
-	spin_lock_irqsave(&p->wr_lock, flags);
-	vfe = vf_pool_get(&p->wr_list);
-	spin_unlock_irqrestore(&p->wr_lock, flags);
-	if (!vfe) {
-		vf_log(p, VF_OPERATION_FGET, false);
-		return NULL;
-	}
-	p->wr_list_size--;
-	vfe->status = VF_STATUS_WM;
-	vf_log(p, VF_OPERATION_FGET, true);
-	return vfe;
-}
-
-inline void provider_vf_put(struct vf_entry *vfe, struct vf_pool *p)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&p->rd_lock, flags);
-	vfe->status = VF_STATUS_RL;
-	vf_pool_put(vfe, &p->rd_list);
-	p->rd_list_size++;
-	spin_unlock_irqrestore(&p->rd_lock, flags);
-	vf_log(p, VF_OPERATION_FPUT, true);
-}
-
-/* receiver peek to read */
-inline struct vf_entry *receiver_vf_peek(struct vf_pool *p)
-{
-	struct vf_entry *vfe;
-	unsigned long flags;
-        
-        if(p->pool_flag & VDIN_VF_POOL_FREEZE){
-                spin_lock_irqsave(&p->fz_lock, flags);
-                vfe = vf_pool_peek(&p->fz_list);
-                spin_unlock_irqrestore(&p->fz_lock, flags);
-                return vfe;
-        }
-                
-	spin_lock_irqsave(&p->rd_lock, flags);
-	vfe = vf_pool_peek(&p->rd_list);
-	spin_unlock_irqrestore(&p->rd_lock, flags);
-	if (!vfe)
-		vf_log(p, VF_OPERATION_BPEEK, false);
-	else
-		vf_log(p, VF_OPERATION_BPEEK, true);
-	if (!vfe)
-		return NULL;                
-	return vfe;
-}
-
-/* receiver get vframe to read */
-inline struct vf_entry *receiver_vf_get(struct vf_pool *p)
-{
-	struct vf_entry *vfe;
-	unsigned long flags;
-        /*get the vframe from the frozen list*/
-        if(p->pool_flag & VDIN_VF_POOL_FREEZE){
-                spin_lock_irqsave(&p->fz_lock, flags);
-                if(list_empty(&p->fz_list)){
-                       spin_unlock_irqrestore(&p->fz_lock, flags);
-		       return NULL;
-                }
-                vfe = vf_pool_get(&p->fz_list);
-                spin_unlock_irqrestore(&p->fz_lock, flags);
-                return vfe;
-        }
-
-	spin_lock_irqsave(&p->rd_lock, flags);
-	if (list_empty(&p->rd_list)) {
-		spin_unlock_irqrestore(&p->rd_lock, flags);
-		vf_log(p, VF_OPERATION_BGET, false);
-		return NULL;
-	}
-        
-	vfe = vf_pool_get(&p->rd_list);
-	p->rd_list_size--;
-	spin_unlock_irqrestore(&p->rd_lock, flags);
-	vfe->status = VF_STATUS_RM;
-                
-	vf_log(p, VF_OPERATION_BGET, true);
-	return vfe;
-}
-
-inline void receiver_vf_put(struct vframe_s *vf, struct vf_pool *p)
-{
-	struct vf_entry *master, *slave;
-	unsigned long flags;
-	struct vf_entry *pos = NULL, *tmp = NULL;
-	int found_in_wt_list = 0;
-        
-
-	master = vf_get_master(p, vf->index);
-        
-        /*keep the frozen frame in rd list&recycle the frame which not in fz list when unfreeze*/
-        if(master->flag & VF_FLAG_FREEZED_FRAME){
-                if(p->pool_flag & VDIN_VF_POOL_FREEZE ){
-                        spin_lock_irqsave(&p->fz_lock, flags);
-                        vf_pool_put(master, &p->fz_list);
-                        spin_unlock_irqrestore(&p->fz_lock, flags);
-                        return;
-                }
-                master->flag &= (~VF_FLAG_FREEZED_FRAME);
-                pr_info("%s: del frame %u from fz list.\n",__func__,master->vf.index);
-        }
-                
-	/* normal vframe */
-	if (master->flag & VF_FLAG_NORMAL_FRAME) {
-		master->status = VF_STATUS_WL;
-		spin_lock_irqsave(&p->wr_lock, flags);
-		vf_pool_put(master, &p->wr_list);
-		p->wr_list_size++;
-		spin_unlock_irqrestore(&p->wr_lock, flags);
-		vf_log(p, VF_OPERATION_BPUT, true);
-	}
-	else {
-		spin_lock_irqsave(&p->wt_lock, flags);
-		list_for_each_entry_safe(pos, tmp, &p->wt_list, list) {
-			/*
-			 * if the index to be putted is same with one in wt_list,
-			 * we consider that they are the same entry.
-			 * so the same vfrmae hold by receiver should not be putted
-			 * more than one times.
-			 */
-			if (pos->vf.index == vf->index) {
-				found_in_wt_list = 1;
-				break;
-			}
-		}
-		/*
-		 * the entry 'pos' found in wt_list maybe entry 'master' or 'slave'
-		 */
-		slave = vf_get_slave(p, vf->index);
-		/* if found associated entry in wait list */
-		if (found_in_wt_list) {
-			/* remove from wait list, and put the master entry in wr_list */
-			list_del(&pos->list);
-			spin_unlock_irqrestore(&p->wt_lock, flags);
-
-			master->status = VF_STATUS_WL;
-			spin_lock_irqsave(&p->wr_lock, flags);
-			vf_pool_put(master, &p->wr_list);
-			p->wr_list_size++;
-			spin_unlock_irqrestore(&p->wr_lock, flags);
-			slave->status = VF_STATUS_SL;
-			vf_log(p, VF_OPERATION_BPUT, true);
-		}
-		/* if not found associated entry in wait list */
-		else {
-			/*
-			 * put the recycled vframe in wait list
-			 *
-			 * you should put the vframe that you getted, you should not put
-			 * the copy one. because we also compare the address of vframe
-			 * structure to determine it is master or slave.
-			 */
-			if (&slave->vf == vf) {
-				slave->status = VF_STATUS_WT;
-				list_add(&slave->list, &p->wt_list);
-			}
-			else {
-				master->status = VF_STATUS_WT;
-				list_add(&master->list, &p->wt_list);
-			}
-			spin_unlock_irqrestore(&p->wt_lock, flags);
-			vf_log(p, VF_OPERATION_BPUT, true);
-		}
-	}
-}
-
-struct vframe_s *vdin_vf_peek(void* op_arg)
-{
-	struct vf_pool *p;
-	struct vf_entry *vfe;
-	if (!op_arg)
-		return NULL;
-	p = (struct vf_pool*)op_arg;
-	vfe =  receiver_vf_peek(p);
-	if (!vfe)
-		return NULL;
-	return &vfe->vf;
-}
-
-struct vframe_s *vdin_vf_get (void* op_arg)
-{
-	struct vf_pool *p;
-	struct vf_entry *vfe;
-	if (!op_arg)
-		return NULL;
-	p = (struct vf_pool*)op_arg;
-	vfe =  receiver_vf_get(p);
-	if (!vfe)
-		return NULL;
-	return &vfe->vf;
-}
-
-void vdin_vf_put(struct vframe_s *vf, void* op_arg)
-{
-	struct vf_pool *p;
-	if (!op_arg)
-		return;
-	p = (struct vf_pool*)op_arg;
-	receiver_vf_put(vf, p);
-}
-int vdin_vf_states(vframe_states_t *vf_ste, void* op_arg)
-{
-	struct vf_pool *p;
-	if(!vf_ste)
-		return -1;
-	p = (struct vf_pool*)op_arg;
-	vf_ste->vf_pool_size = p->size;
-	vf_ste->buf_free_num = p->wr_list_size - 1;
-	vf_ste->buf_avail_num = p->wr_list_size;
-	vf_ste->buf_recycle_num = p->size - p->wr_list_size - p->rd_list_size;
-	return 0;
-}
-
-/*
-*hold the buffer from rd list,if rd list is not enough,
-*get buffer from wr list
-*/
-void vdin_vf_freeze(struct vf_pool *p, unsigned int num)
-{
-        struct vf_entry *vfe,*tmp;
-        struct list_head *rd_head, *wr_head,*fz_head;
-        unsigned long flags;
-        rd_head  = &p->rd_list;
-        wr_head = &p->wr_list;
-        fz_head  = &p->fz_list;
-        p->pool_flag |= VDIN_VF_POOL_FREEZE;
-        if(p->fz_list_size < num){
-                /*add the buffer in rd list to fz list*/
-                spin_lock_irqsave(&p->rd_lock, flags);
-                list_for_each_entry_safe(vfe, tmp, rd_head, list){
-                        list_del(&vfe->list);
-                        spin_lock_irqsave(&p->fz_lock, flags);
-                        list_add_tail(&vfe->list,fz_head);
-                        spin_unlock_irqrestore(&p->fz_lock, flags);                                        
-                        vfe->flag |=  VF_FLAG_FREEZED_FRAME;
-                        pr_info("%s: add  %u frame from rd list.\n",__func__,vfe->vf.index);
-                        if(++p->fz_list_size >= num)
-                                break;
-                }
-                spin_unlock_irqrestore(&p->rd_lock, flags);
-                if(p->fz_list_size < num){            
-                        spin_lock_irqsave(&p->wr_lock, flags);
-                        spin_lock_irqsave(&p->fz_lock, flags);
-                        list_for_each_entry_safe_reverse(vfe, tmp, wr_head, list){
-                                list_del(&vfe->list);                                
-                                list_add(&vfe->list,fz_head);                                                                    
-                                vfe->flag |=  VF_FLAG_FREEZED_FRAME;
-                                pr_info("%s: add frame %u from wr list.\n",__func__,vfe->vf.index);
-                                if(++p->fz_list_size >= num)
-                                        break;
-                       }
-                        spin_unlock_irqrestore(&p->fz_lock, flags);    
-                       spin_unlock_irqrestore(&p->wr_lock, flags);
-
-                 }                
-
-        }
-}
-
-void vdin_vf_unfreeze(struct vf_pool *p)
-{
-        struct list_head *fz_head, *wr_head;
-        struct vf_entry *vfe, *tmp;
-        unsigned long flags;
-        fz_head = &p->fz_list;
-        wr_head = &p->wr_list;
-        if(p->fz_list_size > 0){
-                p->pool_flag &= (~VDIN_VF_POOL_FREEZE);
-                p->fz_list_size = 0;
-                spin_lock_irqsave(&p->fz_lock, flags);
-                spin_lock_irqsave(&p->wr_lock, flags);
-                list_for_each_entry_safe(vfe, tmp, fz_head, list){
-                        list_del(&vfe->list);
-                        list_add_tail(&vfe->list,wr_head);
-                        vfe->flag &=  (~VF_FLAG_FREEZED_FRAME);
-                pr_info("%s: del frame %u from fz list.\n",__func__,vfe->vf.index);
-                }
-                spin_unlock_irqrestore(&p->wr_lock, flags);
-                spin_unlock_irqrestore(&p->fz_lock, flags);
-        }        
-}
-
-void vdin_dump_vf_state(struct vf_pool *p)
-{
-        unsigned long flags;
-        struct vf_entry *pos = NULL, *tmp = NULL;
-
-	pr_info("buffers in writeable list:\n");
-        spin_lock_irqsave(&p->wr_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->wr_list, list){
-		pr_info("\t index: %2u,status %u, canvas index0: 0x%x, index1: 0x%x, vframe type: 0x%x.\n",
-			pos->vf.index,pos->status,pos->vf.canvas0Addr,pos->vf.canvas1Addr,pos->vf.type);
-	}
-        spin_unlock_irqrestore(&p->wr_lock, flags);
-
-	pr_info("buffer in readable list:\n");
-        spin_lock_irqsave(&p->rd_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->rd_list, list){
-		pr_info("\t index: %u,status %u, canvas index0: 0x%x, index1: 0x%x, vframe type: 0x%x.\n",
-		        pos->vf.index,pos->status,pos->vf.canvas0Addr,pos->vf.canvas1Addr,pos->vf.type);
-	}
-	spin_unlock_irqrestore(&p->rd_lock,flags);
-
-	pr_info("buffer in waiting list:\n");
-	spin_lock_irqsave(&p->wt_lock, flags);
-        list_for_each_entry_safe(pos, tmp, &p->wt_list, list){
-		pr_info("\t index: %u, status %u, canvas index0: 0x%x, index1: 0x%x, vframe type: 0x%x.\n",
-			pos->vf.index,pos->status,pos->vf.canvas0Addr,pos->vf.canvas1Addr,pos->vf.type);
-	}
-        spin_unlock_irqrestore(&p->wt_lock, flags);
-	pr_info("buffer in temp list:\n");
-	spin_lock_irqsave(&p->tmp_lock, flags);
-	list_for_each_entry_safe(pos, tmp, &p->tmp_list, list){
-		pr_info("\t index: %u, status %u, canvas index0: 0x%x, index1: 0x%x, vframe type: 0x%x.\n",
-			pos->vf.index,pos->status,pos->vf.canvas0Addr,pos->vf.canvas1Addr,pos->vf.type);
-	}
-	spin_unlock_irqrestore(&p->tmp_lock, flags);
-		
-}
-
diff --git a/drivers/amlogic/tvin/vdin/vdin_vf.h b/drivers/amlogic/tvin/vdin/vdin_vf.h
deleted file mode 100755
index a95be4e7b7b9..000000000000
--- a/drivers/amlogic/tvin/vdin/vdin_vf.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * VDIN vframe support
- *
- * Author: Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-
-#ifndef __VDIN_VF_H
-#define __VDIN_VF_H
-
-/* Standard Linux Headers */
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/list.h>
-
-/* Amlogic Linux Headers */
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#define VF_LOG_EN
-
-#ifdef VF_LOG_EN
-
-#define VF_LOG_LEN		 200
-/* only log frontend opertations */
-#define VF_LOG_FE
-/* only log backend opertations */
-#define VF_LOG_BE
-
-typedef enum vf_operation_e {
-	VF_OPERATION_INIT = 0,
-	VF_OPERATION_FPEEK,
-	VF_OPERATION_FGET,
-	VF_OPERATION_FPUT,
-	VF_OPERATION_BPEEK,
-	VF_OPERATION_BGET,
-	VF_OPERATION_BPUT,
-	VF_OPERATION_FREE,
-} vf_operation_t;
-
-typedef enum vf_status_e {
-	VF_STATUS_WL = 0, // In write list
-	VF_STATUS_WM,	  // In write mode
-	VF_STATUS_RL,	  // In read  list
-	VF_STATUS_RM,	  // In read  mode
-	VF_STATUS_WT,	  // In wait  list
-	VF_STATUS_SL,
-} vf_status_t;
-
-typedef struct vf_log_s {
-	/*
-	 * master
-	 */
-	// [ 0][  n] 1: buf[n] is in write list
-	// [ 1][  n] 1: buf[n] is in write mode
-	// [ 2][  n] 1: buf[n] is in read  list
-	// [ 3][  n] 1: buf[n] is in read  mode
-	// [ 4][  n] 1: buf[n] is in wait  list
-	/*
-	 * slave
-	 */
-	// [ 5][  n] 1: buf[n] is in write list
-	// [ 6][  n] 1: buf[n] is in write mode
-	// [ 7][  n] 1: buf[n] is in read  list
-	// [ 8][  n] 1: buf[n] is in read  mode
-	// [ 9][  n] 1: buf[n] is in wait  list
-	// [10][  7] 1: operation failure
-	//	   [6:3]	reserved
-	//	   [2:0]	operation ID
-	unsigned char  log_buf[VF_LOG_LEN][11];
-	unsigned int   log_cur;
-	struct timeval log_time[VF_LOG_LEN];
-} vf_log_t;
-
-#endif
-
-#define ISR_LOG_EN
-#ifdef  ISR_LOG_EN
-#define ISR_LOG_LEN		 2000
-typedef struct isr_log_s{
-        struct timeval isr_time[ISR_LOG_LEN];
-        unsigned int log_cur;
-        unsigned char isr_log_en;
-}isr_log_t;
-#endif
-
-#define VF_FLAG_NORMAL_FRAME		 0x00000001
-#define VF_FLAG_FREEZED_FRAME		 0x00000002
-
-
-typedef struct vf_entry {
-	struct vframe_s vf;
-	enum vf_status_e status;
-	struct list_head list;
-	unsigned int flag;
-} vf_entry_t;
-
-#define VDIN_VF_POOL_FREEZE              0x00000001
-typedef struct vf_pool {
-        unsigned int pool_flag;
-	unsigned int max_size, size;
-	struct vf_entry *master;
-	struct vf_entry *slave;
-	struct list_head wr_list; /* vf_entry */
-        spinlock_t       wr_lock;
-	unsigned int	 wr_list_size;
-	struct list_head *wr_next;
-	struct list_head rd_list; /* vf_entry */
-        spinlock_t       rd_lock;
-	unsigned int	 rd_list_size;
-	struct list_head wt_list; /* vframe_s */
-        spinlock_t       wt_lock;
-        unsigned int	 fz_list_size;
-        struct list_head fz_list;
-        spinlock_t       fz_lock;
-	unsigned int	 tmp_list_size;
-        struct list_head tmp_list;
-        spinlock_t tmp_lock;
-	spinlock_t lock;
-#ifdef VF_LOG_EN
-	struct vf_log_s log;
-#endif
-#ifdef ISR_LOG_EN
-        struct isr_log_s isr_log;
-#endif
-} vf_pool_t;
-
-extern void vf_log_init(struct vf_pool *p);
-extern void vf_log_print(struct vf_pool *p);
-
-extern void isr_log_init(struct vf_pool *p);
-extern void isr_log_print(struct vf_pool *p);
-extern void isr_log(struct vf_pool *p);
-
-extern struct vf_entry *vf_get_master(struct vf_pool *p, int index);
-extern struct vf_entry *vf_get_slave(struct vf_pool *p, int index);
-
-extern struct vf_pool *vf_pool_alloc(int size);
-extern int vf_pool_init(struct vf_pool *p, int size);
-extern void vf_pool_free(struct vf_pool *p);
-
-extern void recycle_tmp_vfs(struct vf_pool *p);
-extern void tmp_vf_put(struct vf_entry *vfe,struct vf_pool *p);
-extern void tmp_to_rd(struct vf_pool *p);
-
-extern struct vf_entry *provider_vf_peek(struct vf_pool *p);
-extern struct vf_entry *provider_vf_get(struct vf_pool *p);
-extern void provider_vf_put(struct vf_entry *vf, struct vf_pool *p);
-
-extern struct vf_entry *receiver_vf_peek(struct vf_pool *p);
-extern struct vf_entry *receiver_vf_get(struct vf_pool *p);
-extern void receiver_vf_put(struct vframe_s *vf, struct vf_pool *p);
-
-extern struct vframe_s *vdin_vf_peek(void* op_arg);
-extern struct vframe_s *vdin_vf_get (void* op_arg);
-extern void vdin_vf_put(struct vframe_s *vf, void* op_arg);
-extern int vdin_vf_states(vframe_states_t *vf_ste, void* op_arg);
-
-extern void vdin_vf_freeze(struct vf_pool *p, unsigned hold_num);
-extern void vdin_vf_unfreeze(struct vf_pool *p);
-
-extern void vdin_dump_vf_state(struct vf_pool *p);
-#endif /* __VDIN_VF_H */
-
diff --git a/drivers/amlogic/tvin/viu/Kconfig b/drivers/amlogic/tvin/viu/Kconfig
deleted file mode 100644
index 132d9c420fa2..000000000000
--- a/drivers/amlogic/tvin/viu/Kconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-
-config  VIUIN 
-	tristate "Amlogic VIUIN device driver"
-	default n
-	help
-		VIUIN device driver.
-if VIUIN
-   config GAMMA_AUTO_TUNE
-        bool "Enable gamma auto tune function"
-        default n
-        help
-                Auto tune the gamma.
-                
-endif 
diff --git a/drivers/amlogic/tvin/viu/Makefile b/drivers/amlogic/tvin/viu/Makefile
deleted file mode 100644
index 44c405e0f01d..000000000000
--- a/drivers/amlogic/tvin/viu/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-$(CONFIG_VIUIN) += tvin_viuin.o
-tvin_viuin-objs := viuin.o
diff --git a/drivers/amlogic/tvin/viu/viuin.c b/drivers/amlogic/tvin/viu/viuin.c
deleted file mode 100755
index 6399170aac5a..000000000000
--- a/drivers/amlogic/tvin/viu/viuin.c
+++ /dev/null
@@ -1,751 +0,0 @@
-/*
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/etherdevice.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/dma-mapping.h>
-#include <asm/delay.h>
-#include <asm/atomic.h>
-#include <linux/module.h>
-
-#include <linux/amlogic/amports/amstream.h>
-#include <linux/amlogic/amports/ptsserv.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/tvin/tvin_v4l2.h>
-#include <mach/am_regs.h>
-#ifdef CONFIG_GAMMA_AUTO_TUNE
-#include <linux/amlogic/vout/lcdoutc.h>
-#endif
-
-#include "../tvin_global.h"
-#include "../tvin_frontend.h"
-#include "../tvin_format_table.h"
-
-#define DEVICE_NAME "viuin"
-#define MODULE_NAME "viuin"
-
-#define AMVIUIN_DEC_START       1
-#define AMVIUIN_DEC_STOP        0
-
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-#define WR(x,val)                         WRITE_CBUS_REG(x,val)
-#define WR_BITS(x,val,start,length)       WRITE_CBUS_REG_BITS(x,val,start,length)
-#define RD(x)                             READ_CBUS_REG(x)
-#define RD_BITS(x,start,length)           READ_CBUS_REG_BITS(x,start,length)
-#else
-#define WR(x,val)                         WRITE_VCBUS_REG(x,val)
-#define WR_BITS(x,val,start,length)       WRITE_VCBUS_REG_BITS(x,val,start,length)
-#define RD(x)                             READ_VCBUS_REG(x)
-#define RD_BITS(x,start,length)           READ_VCBUS_REG_BITS(x,start,length)
-#endif
-
-static bool gamma_tune_en = false;
-module_param(gamma_tune_en,bool,0644);
-MODULE_PARM_DESC(gamma_tune_en,"enable/disable gamma auto tune function.");
-static bool gamma_dbg_en = 0;
-module_param(gamma_dbg_en, bool, 0664);
-MODULE_PARM_DESC(gamma_dbg_en, "enable/disable gamma log");
-
-static int gamma_type = 2;
-module_param(gamma_type, int, 0664);
-MODULE_PARM_DESC(gamma_type, "adjust gamma type");
-
-static unsigned int vsync_enter_line_curr = 0;
-module_param(vsync_enter_line_curr,uint,0664);
-MODULE_PARM_DESC(vsync_enter_line_curr,"\n encoder process line num when enter isr.\n");
-
-static unsigned int vsync_enter_line_max = 0;
-module_param(vsync_enter_line_max,uint,0664);
-MODULE_PARM_DESC(vsync_enter_line_max,"\n max encoder process line num when enter isr.\n");
-
-static unsigned int vsync_enter_line_threshold = 10000;
-module_param(vsync_enter_line_threshold,uint,0664);
-MODULE_PARM_DESC(vsync_enter_line_threshold,"\n max encoder process line num over threshold drop the frame.\n");
-
-static unsigned int vsync_enter_line_threshold_overflow_count = 0;
-module_param(vsync_enter_line_threshold_overflow_count,uint,0664);
-MODULE_PARM_DESC(vsync_enter_line_threshold_overflow_count,"\n count of overflow encoder process line num over threshold drop the frame.\n");
-
-typedef struct viuin_s{
-        unsigned int flag;
-        struct vframe_prop_s *prop;
-        /*add for tvin frontend*/
-        struct tvin_frontend_s frontend;
-        struct vdin_parm_s parm;
-	unsigned int enc_info_addr;
-}viuin_t;
-
-#ifdef CONFIG_GAMMA_AUTO_TUNE
-
-static unsigned char ve_dnlp_tgt[64];
-static unsigned int ve_dnlp_white_factor;
-static unsigned int ve_dnlp_rt;
-static unsigned int ve_dnlp_rl;
-static unsigned int ve_dnlp_black;
-static unsigned int ve_dnlp_white;
-static unsigned int ve_dnlp_luma_sum;
-//static ulong ve_dnlp_lpf[64], ve_dnlp_reg[16];
-static unsigned int backlight;
-
-static void ve_dnlp_calculate_tgt(struct vframe_prop_s *prop)
-{
-    struct vframe_prop_s *p = prop;
-    ulong data[5];
-    ulong i = 0, j = 0, ave = 0, max = 0, div = 0;
-    
-    // old historic luma sum
-    j = ve_dnlp_luma_sum;
-    // new historic luma sum
-    ve_dnlp_luma_sum = p->hist.luma_sum;
-
-    // picture mode: freeze dnlp curve
-    if (// new luma sum is 0, something is wrong, freeze dnlp curve
-        (!ve_dnlp_luma_sum) ||
-        // new luma sum is closed to old one, picture mode, freeze curve
-        ((ve_dnlp_luma_sum < j + (j >> 5)) &&
-         (ve_dnlp_luma_sum > j - (j >> 5))
-        )
-       )
-        return;
-
-    // get 5 regions
-    for (i = 0; i < 5; i++)
-    {
-        j = 4 + 11 * i;
-        data[i] = (ulong)p->hist.gamma[j     ] +
-                  (ulong)p->hist.gamma[j +  1] +
-                  (ulong)p->hist.gamma[j +  2] +
-                  (ulong)p->hist.gamma[j +  3] +
-                  (ulong)p->hist.gamma[j +  4] +
-                  (ulong)p->hist.gamma[j +  5] +
-                  (ulong)p->hist.gamma[j +  6] +
-                  (ulong)p->hist.gamma[j +  7] +
-                  (ulong)p->hist.gamma[j +  8] +
-                  (ulong)p->hist.gamma[j +  9] +
-                  (ulong)p->hist.gamma[j + 10];
-    }
-
-    // get max, ave, div
-    for (i = 0; i < 5; i++)
-    {
-        if (max < data[i])
-            max = data[i];
-        ave += data[i];
-        data[i] *= 5;
-    }
-    max *= 5;
-    div = (max - ave > ave) ? max - ave : ave;
-
-    // invalid histgram: freeze dnlp curve
-    if (!max)
-        return;
-
-    // get 1st 4 points
-    for (i = 0; i < 4; i++){
-        if (data[i] > ave)
-            data[i] = 64 + (((data[i] - ave) << 1) + div) * ve_dnlp_rl / (div << 1);
-        else if (data[i] < ave)
-            data[i] = 64 - (((ave - data[i]) << 1) + div) * ve_dnlp_rl / (div << 1);
-        else
-            data[i] = 64;
-        ve_dnlp_tgt[4 + 11 * (i + 1)] = ve_dnlp_tgt[4 + 11 * i] + ((44 * data[i] + 32) >> 6);
-    }
-
-    // fill in region 0 with black extension
-    data[0] = ve_dnlp_black;
-    if (data[0] > 16)
-        data[0] = 16;
-    data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[4]) * (16 - data[0]);
-    for (j = 1; j <= 6; j++)
-        ve_dnlp_tgt[4 + j] = ve_dnlp_tgt[4] + (data[0] * j + 88) / 176;
-    data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[10]) << 1;
-    for (j = 1; j <=4; j++)
-        ve_dnlp_tgt[10 + j] = ve_dnlp_tgt[10] + (data[0] * j + 5) / 10;
-
-    // fill in regions 1~3
-    for (i = 1; i <= 3; i++)
-    {
-        data[i] = (ve_dnlp_tgt[11 * i + 15] - ve_dnlp_tgt[11 * i + 4]) << 1;
-        for (j = 1; j <= 10; j++)
-            ve_dnlp_tgt[11 * i + 4 + j] = ve_dnlp_tgt[11 * i + 4] + (data[i] * j + 11) / 22;
-    }
-
-    // fill in region 4 with white extension
-    data[4] /= 5;
-    data[4] = (ve_dnlp_white * ((ave << 4) - data[4] * ve_dnlp_white_factor)  + (ave << 3)) / (ave << 4);
-    if (data[4] > 16)
-        data[4] = 16;
-    data[4] = (ve_dnlp_tgt[59] - ve_dnlp_tgt[48]) * (16 - data[4]);
-    for (j = 1; j <= 6; j++)
-        ve_dnlp_tgt[59 - j] = ve_dnlp_tgt[59] - (data[4] * j + 88) / 176;
-    data[4] = (ve_dnlp_tgt[53] - ve_dnlp_tgt[48]) << 1;
-    for (j = 1; j <= 4; j++)
-        ve_dnlp_tgt[53 - j] = ve_dnlp_tgt[53] - (data[4] * j + 5) / 10;
-        
-
-}
-
-static unsigned luma_sum;
-static short slope_ref;
-static unsigned int gamma_proc_enable = 0;
-
-static const unsigned short base_gamma_table[256] = {
-	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
-	32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
-	64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
-	96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
-	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
-	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
-	192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
-	224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
-};
-
-static unsigned short gamma_table[256];
-static unsigned short pdiv[256];
-
-extern void set_lcd_gamma_table_lvds(u16 *data, u32 rgb_mask);
-extern void _set_backlight_level(int level);
-
-int gamma_adjust2( int nLow, int nHigh, int fAlphaL, int fAlphaH, int *pDiv, int *pLut)
-{
-	int i, j;
-	int im1, im2, ip1, ip2;
-	int nStep;
-
-	// initial pGain
-	int pGain[256];
-	int pSlopeL[256];
-	int pSlopeH[256];
-	//pGain = (int *)calloc(256, sizeof(int));
-	for (i = 0; i < 256; i++) {
-		pGain[i] = 2048;
-	}//i
-
-	// basic low slope
-	//int *pSlopeL = NULL;
-	//pSlopeL = (int *)calloc(256, sizeof(int));
-
-	if ( fAlphaL > 10 ) {
-		nStep = (int)(((fAlphaL - 10) * 4 + 5)/10);
-		for (i = 0; i < 256; i++){
-			pSlopeL[i] = 2048 + (255 - i) * nStep;
-		}//i
-	} else {
-		nStep = (int)(((10 - fAlphaL) * 4 + 5)/10);
-		for (i = 0; i < 256; i++){
-			pSlopeL[i] = 2048 - (255 - i) * nStep;
-		}//i
-	}
-
-	// basic high slope
-	//int *pSlopeH = NULL;
-	//pSlopeH = (int *)calloc(256, sizeof(int));
-
-	if ( fAlphaH > 10 ){
-		nStep = (int)(((fAlphaH - 10) * 4 + 5)/10);
-		for (i = 0; i < 256; i++){
-			pSlopeH[i] = 2048 + (255 - i) * nStep;
-		}//i
-	} else {
-		nStep = (int)(((10 - fAlphaH) * 4 + 5)/10);
-		for (i = 0; i < 256; i++){
-			pSlopeH[i] = 2048 - (255 - i) * nStep;
-		}//i
-	}
-
-	// remapping to dark/bright curve
-	for (i = 0; i < nLow; i++){
-		j = (i * pDiv[nLow] + 1024) / 2048;
-		pGain[i] = pSlopeL[j];
-	}
-
-	for (i = nHigh; i < 256; i++) {
-		j = ((i - nHigh) * pDiv[255 - nHigh] + 1024) / 2048;
-		pGain[i] = pSlopeH[j];
-	}
-
-	// adjust lut
-	for (i = 0; i < 256; i++) {
-		if ( i < nHigh )
-			pLut[i] = (pGain[i] * pLut[i] + 1024) / 2048;
-		else
-			pLut[i] = pLut[nHigh] + (pGain[i] * 
-				(pLut[i] - pLut[nHigh]) + 1024) / 2048;
-		//printf("%d ", pGain[i]);
-	}
-
-	// 5 tap lpf
-	for (i = 0; i < 256; i++) {
-		im1 = i-1 < 0 ? 0 : i-1;
-		im2 = i-2 < 0 ? 0 : i-2;
-		ip1 = i+1 > 255 ? 255 : i+1;
-		ip2 = i+2 > 255 ? 255 : i+2;
-
-		pLut[i] = (pLut[im2] + 2 * pLut[im1] + 2 * pLut[i] +
-					 2 * pLut[ip1] + pLut[ip2] + 4) /8;
-		
-	}
-
-	return 0;
-}
-
-int nLow = 60;
-int nHigh = 190;
-int fAlphaL = 10;//<=2
-int fAlphaH = 10;//>=0
-
-int gamma_adjust(void)
-{
-	//printk("luma_sum = %d \n", luma_sum);
-	int i, j;
-	//unsigned long flags;
-		// set parameters
-
-	// caluclate and save to mem before
-	//int *pLut = NULL;
-	//pLut = (int *)calloc(256, sizeof(int));
-
-	int pDiv[256];
-	//pDiv = (int *)calloc(256, sizeof(int));
-	for (i = 0; i < 256; i++){
-		pDiv[i] = 256 * 2048 / (i+1);//256?
-	}//i
-	if (!gamma_proc_enable) 
-		return 0;
-	if (gamma_proc_enable == 2){
-		for (i = 0; i < 256; i++){
-			gamma_table[i] = base_gamma_table[i]<<2;
-			//if(gamma_dbg_en)
-			//printk("gamma_table[%d] = %d\n", i, gamma_table[i]);
-		}
-	        set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_R);
-	        set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_G);
-	        set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_B);
-	        gamma_proc_enable = 0;
-	}
-                if(gamma_type == 0){
-                        gamma_proc_enable = 0;
-                        for (i = 0; i < 256; i++){
-			gamma_table[i] = base_gamma_table[i]<<2;
-			if(gamma_dbg_en)
-			        printk("type %d,gamma_table[%d] = %d\n",gamma_type, i, gamma_table[i]);
-                        }
-	        set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_R);
-	        set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_G);
-	        set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_B);
-                }
-	else if (gamma_type == 1) {
-		gamma_proc_enable = 0;
-		for (i = 0; i < 256; i++) {
-			gamma_table[i] = base_gamma_table[i]<<2;
-		}	
-		for (i = 1; i < 64; i++)
-			for (j = 0; j < 4; j++) {
-				gamma_table[i*4 + j] = base_gamma_table[i*4 + j]*ve_dnlp_tgt[i]/i;
-		}
-		if (gamma_dbg_en) {
-			for (i = 0; i < 256; i++){
-				printk("type %d,gamma_table[%d] = %d\n",gamma_type, i, gamma_table[i]);
-			    }	
-		}
-		set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_R);
-		set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_G);
-		set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_B);
-		//printk("gamma_adjust\n");
-	} else if (gamma_type == 2) {
-		int pLut[256];
-		gamma_proc_enable = 0;
-		for (i = 0; i < 256; i++) {
-			gamma_table[i] = base_gamma_table[i]<<2;
-		}	
-		for (i = 1; i < 64; i++)
-			for (j = 0; j < 4; j++){
-				gamma_table[i*4 + j] = base_gamma_table[i*4 + j]*ve_dnlp_tgt[i]/i;
-			}
-		for (i = 0; i < 256; i++) {
-			pLut[i] = gamma_table[i];
-                                                
-		}
-
-		gamma_adjust2(nLow, nHigh, fAlphaL, fAlphaH, pDiv, pLut);
-		for (i = 0; i < 256; i++){
-			gamma_table[i] = pLut[i];
-                        if(gamma_dbg_en)
-			        printk("type %d,gamma table [%d] = %d\n",gamma_type, i, gamma_table[i]);
-		}				
-		set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_R);
-		set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_G);
-		set_lcd_gamma_table_lvds(gamma_table, LCD_H_SEL_B);
-		//printk("gamma_adjust\n");
-	}	
-		
-	return 0;
-}
-
-static ssize_t gamma_proc_show(struct class *cla, 
-		struct class_attribute *attr, char *buf)
-{
-    return sprintf(buf, "gamma_proc_enable=%d ,ve_dnlp_rt=0x%x,ve_dnlp_rl=0x%x,ve_dnlp_black=0x%x,ve_dnlp_white=0x%x\n",
-                         gamma_proc_enable,ve_dnlp_rt,ve_dnlp_rl,ve_dnlp_black,ve_dnlp_white);
-}
-
-// [   28] en    0~1
-// [27:24] rt    0~7
-// [23:16] rl    0~255
-// [15: 8] black 0~16
-// [ 7: 0] white 0~16
-//0x10200202
-
-static ssize_t 
-gamma_proc_store(struct class *cla,struct class_attribute *attr, 
-				const char *buf, size_t count)
-{
-	size_t r;
-	s32 val = 0;
-	vdin_parm_t para;
-	int en;
-	static int gamma_proc_on = 0;
-
-	r = sscanf(buf, "0x%x", &val);
-
-	if (r != 1){
-		return -EINVAL;
-	}
-	printk("val = %x, val>>28 = %d\n", val, val>>28);
-	en = (val>>28)&0x1;
-    
-	if (en) {  
-		ve_dnlp_rt = (val>>24)&0xf;  //7
-		ve_dnlp_rl = (val>>16)&0xff; //0
-		ve_dnlp_black = (val>>8)&0xff;   //2
-		ve_dnlp_white = val&0xff;     //2
-		if (ve_dnlp_rl > 64)
-			ve_dnlp_rl = 64;
-		if (ve_dnlp_black > 16)
-			ve_dnlp_black = 16;
-		if (ve_dnlp_white > 16)
-			ve_dnlp_white = 16;
-		
-		para.port  = TVIN_PORT_VIU;
-		para.fmt = TVIN_SIG_FMT_MAX;
-                para.cfmt = TVIN_RGB444;
-                para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
-		para.frame_rate = 50;
-		para.h_active = 1024;
-		para.v_active = 768;
-		para.hsync_phase = 1;
-		para.vsync_phase  = 0;                                
-                                
-		if (gamma_proc_on == 0){
-                        /*enable isr function*/
-                        gamma_tune_en = true;
-                        /*enable gamma function*/
-                        WR_BITS(L_GAMMA_CNTL_PORT,1,0,1);
-			start_tvin_service(0,&para);
-			gamma_proc_on = 1;
-			printk("start gamma calc function\n");
-		}
-	} else {
-		if (gamma_proc_on){
-                        /*disable isr function*/
-                        gamma_tune_en = false;
-			stop_tvin_service(0);
-			gamma_proc_on = 0;
-			printk("stop gamma calc function\n");
-		}
-	}
-
-	return count;
-}
-
-static ssize_t env_backlight_show(struct class *cla, 
-		struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", backlight);
-}
-
-
-static ssize_t env_backlight_store(struct class *cla, 
-		struct class_attribute *attr, const char *buf, size_t count)
-{
-	size_t r;
-	s32 val = 0;
-
-	r = sscanf(buf, "0x%x", &val);
-
-	if (r != 1) {
-		return -EINVAL;
-	}
-	printk("val = %x\n", val);
-	backlight = val;
-    
-	if (backlight > 255)
-		backlight = 255;
-	_set_backlight_level(backlight);
-	if (backlight > 0xa0)
-		fAlphaL = 17;
-	else
-		fAlphaL = 10;
-		
-	return count;
-}
-static struct class_attribute gamma_proc_class_attrs[] = {
-	__ATTR(gamma_proc, S_IRUGO | S_IWUSR,gamma_proc_show, gamma_proc_store),
-	__ATTR(env_backlight, S_IRUGO | S_IWUSR,env_backlight_show, env_backlight_store),
-	__ATTR_NULL,
-};
-#endif
-static int viuin_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        if(port == TVIN_PORT_VIU)
-                return 0;
-        else
-                return -1;
-}
-
-static int viuin_open(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-        viuin_t *devp = container_of(fe,viuin_t,frontend);
-        if(!memcpy(&devp->parm,fe->private_data,sizeof(vdin_parm_t))){
-                printk("[viuin..]%s memcpy error.\n",__func__); 
-                return -1;
-        }
-        /*open the venc to vdin path*/
-        switch(RD_BITS(VPU_VIU_VENC_MUX_CTRL,0,2)){
-                case 0:
-                        WR_BITS(VPU_VIU_VENC_MUX_CTRL,0x88,4,8);
-			devp->enc_info_addr = ENCL_INFO_READ;
-                        break;
-                case 1:                        
-                        WR_BITS(VPU_VIU_VENC_MUX_CTRL,0x11,4,8);
-			devp->enc_info_addr = ENCI_INFO_READ;
-                        break;
-                case 2:                        
-                        WR_BITS(VPU_VIU_VENC_MUX_CTRL,0x22,4,8);
-			devp->enc_info_addr = ENCP_INFO_READ;
-                        break;
-                case 3:                        
-                        WR_BITS(VPU_VIU_VENC_MUX_CTRL,0x44,4,8);
-			devp->enc_info_addr = ENCT_INFO_READ;
-                        break;
-                default:
-                        break;
-        }
-        devp->flag = 0; 
-        return 0;
-}
-static void viuin_close(struct tvin_frontend_s *fe)
-{        
-        viuin_t *devp = container_of(fe,viuin_t,frontend);
-        memset(&devp->parm,0,sizeof(vdin_parm_t));
-        /*close the venc to vdin path*/
-                        WR_BITS(VPU_VIU_VENC_MUX_CTRL,0,4,8);
-}
-
-static void viuin_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
-{
-        //do something the same as start_amvdec_viu_in
-        viuin_t *devp = container_of(fe,viuin_t,frontend);
-        	if (devp->flag && AMVIUIN_DEC_START) {
-		        printk("[viuin..]%s viu_in is started already.\n",__func__);
-		return;
-	}
-	vsync_enter_line_max = 0;
-	vsync_enter_line_threshold_overflow_count = 0;
-	devp->flag = AMVIUIN_DEC_START;
-	
-	return;
-}
-static void viuin_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
-{
-         
-        viuin_t *devp = container_of(fe,viuin_t,frontend);
-       	if (devp->flag && AMVIUIN_DEC_START) 
-	        devp->flag |= AMVIUIN_DEC_STOP;
-        else
-                printk("[viuin..]%s viu in dec isn't start.\n",__func__);
-        
-}
-
-static int viuin_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
-{	
-	viuin_t *devp = container_of(fe,viuin_t,frontend);
-	vsync_enter_line_curr = (READ_VCBUS_REG(devp->enc_info_addr)>>16)&0x1fff;
-	if(vsync_enter_line_curr > vsync_enter_line_max)
-                vsync_enter_line_max = vsync_enter_line_curr;
-	if(vsync_enter_line_curr > vsync_enter_line_threshold){
-		vsync_enter_line_threshold_overflow_count++;
-		return TVIN_BUF_SKIP;
-	}
-#ifdef CONFIG_GAMMA_AUTO_TUNE
-	if (gamma_tune_en) {	
-		devp->prop = fe->private_data;
-		// calculate dnlp target data
-		ve_dnlp_calculate_tgt(devp->prop);
-		gamma_proc_enable = 1;
-                gamma_adjust();
-                if(gamma_dbg_en)
-                        gamma_dbg_en = false; 
-	}
-#endif
-        return 0;
-        
-}
-
-static struct tvin_decoder_ops_s viu_dec_ops ={
-        .support            = viuin_support,
-	.open               = viuin_open,
-	.start              = viuin_start,
-	.stop               = viuin_stop,
-	.close              = viuin_close,
-	.decode_isr         = viuin_isr,
-};
-
-static void viuin_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
-{
-    viuin_t *devp = container_of(fe,viuin_t,frontend);
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8))
-    prop->color_format = TVIN_YUV422;
-#else
-    prop->color_format = TVIN_RGB444;
-#endif
-    prop->dest_cfmt = devp->parm.dfmt;
-    prop->pixel_repeat = 0;
-}
-
-static struct tvin_state_machine_ops_s viu_sm_ops ={
-       .get_sig_propery = viuin_sig_propery,
-};
-
-static struct class* gamma_proc_clsp;
-
-static int viuin_probe(struct platform_device *pdev)
-{
-	int ret = 0, i = 0;
-	struct viuin_s *viuin_devp;
-        viuin_devp = kmalloc(sizeof(viuin_t),GFP_KERNEL);
-        memset(viuin_devp,0,sizeof(viuin_t));
-        if(!viuin_devp){
-                printk("[viuin..]%s kmalloc error.\n",__func__);
-                return -ENOMEM;
-        }
-	gamma_proc_clsp = class_create(THIS_MODULE, MODULE_NAME);
-	if(IS_ERR(gamma_proc_clsp)){
-		ret = PTR_ERR(gamma_proc_clsp);
-		return ret;
-	}
-#ifdef CONFIG_GAMMA_AUTO_TUNE
-	for(i = 0; gamma_proc_class_attrs[i].attr.name; i++){
-		if(class_create_file(gamma_proc_clsp,&gamma_proc_class_attrs[i]) < 0)
-			goto err;
-	}
-	for (i = 0; i < 64; i++) {
-		ve_dnlp_tgt[i] = i << 2;
-		//ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
-	}
-#endif  
-        sprintf(viuin_devp->frontend.name, "%s", DEVICE_NAME);
-        if(!tvin_frontend_init(&viuin_devp->frontend,&viu_dec_ops,&viu_sm_ops,0)) {
-                if(tvin_reg_frontend(&viuin_devp->frontend))
-                        printk("[viuin..]%s register viu frontend error.\n",__func__);
-        }        
-        platform_set_drvdata(pdev,viuin_devp);
-        printk("[viuin..]%s probe ok.\n",__func__);
-	return 0;
-err:
-#ifdef CONFIG_GAMMA_AUTO_TUNE
-	for(i=0; gamma_proc_class_attrs[i].attr.name; i++){
-		class_remove_file(gamma_proc_clsp,&gamma_proc_class_attrs[i]);
-	}
-#endif
-	class_destroy(gamma_proc_clsp); 
-                
-	return -1;  
-}
-
-static int viuin_remove(struct platform_device *pdev)
-{
-        int i=0;
-        struct viuin_s *devp = platform_get_drvdata(pdev);
-  #ifdef CONFIG_GAMMA_AUTO_TUNE              
-        for(i=0; gamma_proc_class_attrs[i].attr.name; i++) {
-		class_remove_file(gamma_proc_clsp,&gamma_proc_class_attrs[i]);
-	}
-  #endif
-        class_destroy(gamma_proc_clsp);
-	if(devp){
-                tvin_unreg_frontend(&devp->frontend);
-                kfree(devp);
-        }
-	return 0;
-}
-
-static struct platform_driver viuin_driver = {
-	.probe	= viuin_probe,
-	.remove	= viuin_remove,
-	.driver	= {
-		.name	= DEVICE_NAME,
-	}
-};
-
-static struct platform_device* viuin_device = NULL;
-
-static int __init viuin_init_module(void)
-{
-	printk("[viuin..]%s viuin module init\n",__func__);
-	viuin_device = platform_device_alloc(DEVICE_NAME,0);
-	if (!viuin_device) {
-		printk("[viuin..]%s failed to alloc viuin_device.\n",__func__);
-		return -ENOMEM;
-	}
-
-	if (platform_device_add(viuin_device)) {
-		platform_device_put(viuin_device);
-		printk("[viuin..]%sfailed to add viuin_device.\n",__func__);
-		return -ENODEV;
-	}
-	if (platform_driver_register(&viuin_driver)) {
-		printk("[viuin..]%sfailed to register viuin driver.\n",__func__);
-		platform_device_del(viuin_device);
-		platform_device_put(viuin_device);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-static void __exit viuin_exit_module(void)
-{
-	printk("[viuin..]%s viuin module remove.\n",__func__);
-	platform_driver_unregister(&viuin_driver);
-                platform_device_unregister(viuin_device);
-	return ;
-}
-
-
-module_init(viuin_init_module);
-module_exit(viuin_exit_module);
-MODULE_DESCRIPTION("AMLOGIC viu input driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("3.0.0");
-- 
2.19.0

