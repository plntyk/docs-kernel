From 24dc20cde5fc4fcf1d743b99fad1eef50acd5c59 Mon Sep 17 00:00:00 2001
From: Zongdong Jiao <zongdong.jiao@amlogic.com>
Date: Fri, 10 Jan 2014 13:38:20 +0800
Subject: [PATCH 2951/5965] hdmitx: move hdmi hw to arch-mesonX

---
 arch/arm/mach-meson6/Makefile                 |    3 +
 arch/arm/mach-meson6/hdmi_tx_hw/Makefile      |    1 +
 arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c  | 2961 +++++++++++++++++
 .../arm/mach-meson6/hdmi_tx_hw}/hdmi_tx_reg.c |   31 +-
 .../arm/mach-meson6/hdmi_tx_hw}/tvenc_conf.h  |    0
 .../mach-meson6/include/mach}/hdmi_tx_reg.h   |   11 +-
 arch/arm/mach-meson8/Makefile                 |    3 +
 arch/arm/mach-meson8/hdmi_tx_hw/Makefile      |    1 +
 .../arm/mach-meson8/hdmi_tx_hw}/hdmi_tx_hw.c  | 1553 +++------
 arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c |   86 +
 arch/arm/mach-meson8/hdmi_tx_hw/tvenc_conf.h  |  231 ++
 .../mach-meson8/include/mach/hdmi_tx_reg.h    |  451 +++
 drivers/amlogic/display/vout/tvoutc.c         |    2 -
 drivers/amlogic/hdmi/hdmi_tx/Makefile         |   10 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c   |    3 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h | 1222 +++----
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c        |  958 ++----
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c  |   55 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.h  |   11 -
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c    |  205 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h    |  246 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c   |  878 +++--
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c   |   41 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h   |    8 +-
 .../amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c   |  606 ----
 .../amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.h   |    6 -
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c  |  196 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.h  |    7 -
 drivers/amlogic/hdmi/hdmi_tx/hw/Makefile      |    2 -
 drivers/amlogic/hdmi/hdmi_tx/test_prm.h       |   56 -
 .../linux/amlogic}/hdmi_tx/hdmi_info_global.h |   10 +-
 .../linux/amlogic}/hdmi_tx/hdmi_tx_module.h   |  141 +-
 32 files changed, 6006 insertions(+), 3989 deletions(-)
 create mode 100644 arch/arm/mach-meson6/hdmi_tx_hw/Makefile
 create mode 100644 arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c
 rename {drivers/amlogic/hdmi/hdmi_tx/hw => arch/arm/mach-meson6/hdmi_tx_hw}/hdmi_tx_reg.c (80%)
 rename {drivers/amlogic/hdmi/hdmi_tx/hw => arch/arm/mach-meson6/hdmi_tx_hw}/tvenc_conf.h (100%)
 rename {drivers/amlogic/hdmi/hdmi_tx/hw => arch/arm/mach-meson6/include/mach}/hdmi_tx_reg.h (95%)
 create mode 100644 arch/arm/mach-meson8/hdmi_tx_hw/Makefile
 rename {drivers/amlogic/hdmi/hdmi_tx/hw => arch/arm/mach-meson8/hdmi_tx_hw}/hdmi_tx_hw.c (69%)
 mode change 100755 => 100644
 create mode 100644 arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c
 create mode 100644 arch/arm/mach-meson8/hdmi_tx_hw/tvenc_conf.h
 create mode 100644 arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h
 delete mode 100755 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.h
 delete mode 100755 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c
 delete mode 100644 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.h
 delete mode 100755 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.h
 delete mode 100644 drivers/amlogic/hdmi/hdmi_tx/hw/Makefile
 delete mode 100644 drivers/amlogic/hdmi/hdmi_tx/test_prm.h
 rename {drivers/amlogic/hdmi => include/linux/amlogic}/hdmi_tx/hdmi_info_global.h (95%)
 mode change 100755 => 100644
 rename {drivers/amlogic/hdmi => include/linux/amlogic}/hdmi_tx/hdmi_tx_module.h (56%)
 mode change 100755 => 100644

diff --git a/arch/arm/mach-meson6/Makefile b/arch/arm/mach-meson6/Makefile
index 6ffce8c27d0f..5c84b118b621 100644
--- a/arch/arm/mach-meson6/Makefile
+++ b/arch/arm/mach-meson6/Makefile
@@ -39,3 +39,6 @@ obj-$(CONFIG_MESON_SUSPEND) += power_suspend.o
 #endif
 
 obj-$(CONFIG_CPU_IDLE) += cpuidle.o
+
+obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
+
diff --git a/arch/arm/mach-meson6/hdmi_tx_hw/Makefile b/arch/arm/mach-meson6/hdmi_tx_hw/Makefile
new file mode 100644
index 000000000000..ffa592f8ba00
--- /dev/null
+++ b/arch/arm/mach-meson6/hdmi_tx_hw/Makefile
@@ -0,0 +1 @@
+obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o
diff --git a/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c
new file mode 100644
index 000000000000..91a5d728f364
--- /dev/null
+++ b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c
@@ -0,0 +1,2961 @@
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+//#include <linux/amports/canvas.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/clock.h>
+#include <mach/power_gate.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
+#include <mach/io.h>
+#include <mach/register.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#if 0   //todo
+#include "../hdmi_tx_cec.h"
+#include "../hdmi_tx_hdcp.h"
+#include "../hdmi_tx_compliance.h"
+#endif
+#include <mach/hdmi_tx_reg.h>
+#include "tvenc_conf.h"
+#ifdef Wr
+#undef Wr
+#endif
+#ifdef Rd
+#undef Rd
+#endif
+#define Wr(reg,val) WRITE_MPEG_REG(reg,val)
+#define Rd(reg)   READ_MPEG_REG(reg)
+#define Wr_reg_bits(reg, val, start, len) \
+  Wr(reg, (Rd(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
+
+#define EDID_RAM_ADDR_SIZE      (4*128)
+
+static void hdmi_audio_init(unsigned char spdif_flag);
+static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag);
+
+static void hdmi_phy_suspend(void);
+static void hdmi_phy_wakeup(void);
+
+unsigned char hdmi_pll_mode = 0; /* 1, use external clk as hdmi pll source */
+static unsigned char aud_para = 0x49;
+
+#define HSYNC_POLARITY      1                       // HSYNC polarity: active high 
+#define VSYNC_POLARITY      1                       // VSYNC polarity: active high
+#define TX_INPUT_COLOR_DEPTH    0                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
+#define TX_INPUT_COLOR_FORMAT   1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
+#define TX_INPUT_COLOR_RANGE    0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
+
+
+#define TX_OUTPUT_COLOR_RANGE   0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
+
+#if 1
+//spdif
+#define TX_I2S_SPDIF        0                       // 0=SPDIF; 1=I2S.
+#define TX_I2S_8_CHANNEL    0                       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
+#else
+//i2s 8 channel
+#define TX_I2S_SPDIF        1                       // 0=SPDIF; 1=I2S.
+#define TX_I2S_8_CHANNEL    1                       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
+#endif
+
+//static struct tasklet_struct EDID_tasklet;
+static unsigned delay_flag = 0;
+static unsigned serial_reg_val=0x1; //0x22;
+static unsigned char i2s_to_spdif_flag=1;   // if current channel number is larger than 2ch, using i2s
+static unsigned color_depth_f=0;
+static unsigned color_space_f=0;
+static unsigned char new_reset_sequence_flag=1;
+static unsigned char power_mode=1;
+static unsigned char power_off_vdac_flag=0;
+    /* 0, do not use fixed tvenc val for all mode; 1, use fixed tvenc val mode for 480i; 2, use fixed tvenc val mode for all modes */
+static unsigned char use_tvenc_conf_flag=1;
+
+static unsigned char cur_vout_index = 1; //CONFIG_AM_TV_OUTPUT2
+
+static unsigned long modulo(unsigned long a, unsigned long b)
+{
+    if (a >= b) {
+        return(a-b);
+    } else {
+        return(a);
+    }
+}
+        
+static signed int to_signed(unsigned int a)
+{
+    if (a <= 7) {
+        return(a);
+    } else {
+        return(a-16);
+    }
+}
+
+static void delay_us (int us)
+{
+    //udelay(us);
+    if(delay_flag&0x1)
+        mdelay((us+999)/1000);
+    else
+    udelay(us);
+} /* delay_us */
+
+static irqreturn_t intr_handler(int irq, void *dev_instance)
+{
+    unsigned int data32;
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)dev_instance;
+    data32 = hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT); 
+    hdmi_print(IMP, SYS "irq %x\n", data32);
+    if(hdmitx_device->hpd_lock == 1) {
+        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0xf);
+        hdmi_print(IMP, HPD "HDMI hpd locked\n");
+        return IRQ_HANDLED;
+    }
+    if(hdmitx_device->internal_mode_change == 1){     // if the irq from the internal mode change, just do nothing and return
+        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0x7);
+        hdmi_print(IMP, SYS "hdmitx: ignore irq\n");
+        return IRQ_HANDLED;
+    }
+
+    WRITE_MPEG_REG(HHI_GCLK_MPEG2, READ_MPEG_REG(HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
+    
+    if (data32 & (1 << 1)) { //HPD falling
+        hdmitx_device->vic_count = 0;
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module 
+        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<6)); // Release sys_trigger_config
+        hdmitx_device->hpd_event = 2;
+    }
+    if (data32 & (1 << 0)) {  //HPD rising
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 0); //clear HPD rising interrupt in hdmi module
+        // If HPD asserts, then start DDC transaction
+        if (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<1)) {
+            // Start DDC transaction
+            hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & (~(1<<6))); // Assert sys_trigger_config
+            hdmitx_device->cur_edid_block=0;
+            hdmitx_device->cur_phy_block_ptr=0;
+            hdmitx_device->hpd_event = 1;
+            hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<6)); // Assert sys_trigger_config
+        // Error if HPD deasserts
+        } else {
+            hdmi_print(ERR, HPD "HPD deasserts!\n");
+        }
+    }
+    if (data32 & (1 << 2)) { //TX EDID interrupt
+        if((hdmitx_device->cur_edid_block+2)<=EDID_MAX_BLOCK){
+            int ii, jj;
+            for(jj=0;jj<2;jj++){
+                for(ii=0;ii<128;ii++){
+                    hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]
+                        =hdmi_rd_reg(0x600+hdmitx_device->cur_phy_block_ptr*128+ii);
+                }
+                hdmitx_device->cur_edid_block++;
+                hdmitx_device->cur_phy_block_ptr++;
+                hdmitx_device->cur_phy_block_ptr=hdmitx_device->cur_phy_block_ptr&0x3;
+            }
+        }        
+//#ifndef AML_A3
+//        /*walkaround: manually clear EDID interrupt*/
+//        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<1)); 
+//        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<1)); 
+//        /**/
+//#endif        
+        //tasklet_schedule(&EDID_tasklet);
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 2); //clear EDID rising interrupt in hdmi module 
+    }
+    if (!((data32 == 1) || (data32 == 2) || (data32 == 4))) {
+        hdmi_print(ERR, SYS "Unkown HDMI Interrupt Source\n");
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  data32); //clear unkown interrupt in hdmi module 
+    }
+//#ifdef AML_A3
+    hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR); // A read to allow the interrupt cleared in hdmi_module before next action
+    hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0xf); //clear HPD falling interrupt in hdmi module
+//#endif
+
+    //aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, 1 << 25);  //clear hdmi_tx interrupt
+    return IRQ_HANDLED;
+}
+
+static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2; // Annie 01Sep2011: Change value from 3 to 2, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS, PIXEL_REPEAT_HDMI, PIXEL_REPEAT_VENC, ACTIVE_PIXELS;
+    unsigned FRONT_PORCH = 88, HSYNC_PIXELS, ACTIVE_LINES = 0, INTERLACE_MODE, TOTAL_LINES, SOF_LINES, VSYNC_LINES;
+    unsigned LINES_F0, LINES_F1 = 563,BACK_PORCH, EOF_LINES = 2, TOTAL_FRAMES;
+
+    unsigned long total_pixels_venc ;
+    unsigned long active_pixels_venc;
+    unsigned long front_porch_venc  ;
+    unsigned long hsync_pixels_venc ;
+
+    unsigned long de_h_begin, de_h_end;
+    unsigned long de_v_begin_even, de_v_end_even, de_v_begin_odd, de_v_end_odd;
+    unsigned long hs_begin, hs_end;
+    unsigned long vs_adjust;
+    unsigned long vs_bline_evn, vs_eline_evn, vs_bline_odd, vs_eline_odd;
+    unsigned long vso_begin_evn, vso_begin_odd;
+    
+    if(param->VIC==HDMI_1080i60){
+         INTERLACE_MODE     = 1;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 0;                   
+         ACTIVE_PIXELS  =     (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 562;                 
+         LINES_F1           = 563;                 
+         FRONT_PORCH        = 88;                  
+         HSYNC_PIXELS       = 44;                  
+         BACK_PORCH         = 148;                  
+         EOF_LINES          = 2;                   
+         VSYNC_LINES        = 5;                   
+         SOF_LINES          = 15;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    else if(param->VIC==HDMI_1080i50){
+         INTERLACE_MODE     = 1;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 0;                   
+         ACTIVE_PIXELS  =     (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 562;                 
+         LINES_F1           = 563;                 
+         FRONT_PORCH        = 528;                  
+         HSYNC_PIXELS       = 44;                  
+         BACK_PORCH         = 148;                  
+         EOF_LINES          = 2;                   
+         VSYNC_LINES        = 5;                   
+         SOF_LINES          = 15;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    TOTAL_PIXELS =(FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES  =(LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 2200 / 1 * 2 = 4400
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 1920 / 1 * 2 = 3840
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 88   / 1 * 2 = 176
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 44   / 1 * 2 = 88
+
+    aml_write_reg32(P_ENCP_VIDEO_MODE, aml_read_reg32(P_ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
+
+    // Program DE timing
+    de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc); // (383 + 3) % 4400 = 386
+    de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc); // (386 + 3840) % 4400 = 4226
+    aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);    // 386
+    aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);      // 4226
+    // Program DE timing for even field
+    de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);       // 20
+    de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 20 + 540 = 560
+    aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);   // 20
+    aml_write_reg32(P_ENCP_DE_V_END_EVEN,  de_v_end_even);     // 560
+    // Program DE timing for odd field if needed
+    if (INTERLACE_MODE) {
+        // Calculate de_v_begin_odd according to enc480p_timing.v:
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
+        de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2; // 1 + 20 + (1125-1)/2 = 583
+        de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;    // 583 + 540 = 1123
+        aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);// 583
+        aml_write_reg32(P_ENCP_DE_V_END_ODD,   de_v_end_odd);  // 1123
+    }
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc; // 4226 + 176 - 4400 = 2
+
+
+
+
+
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc;
+        vs_adjust   = 0;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (2 + 88) % 4400 = 90
+    aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);  // 2
+    aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);    // 90
+    
+    // Program Vsync timing for even field
+    if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
+        vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust); // 20 - 15 - 5 - 0 = 0
+    } else {
+        vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
+    }
+    vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES); // (0 + 5) % 1125 = 5
+    aml_write_reg32(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   // 0
+    aml_write_reg32(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   // 5
+    vso_begin_evn = hs_begin; // 2
+    aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  // 2
+    aml_write_reg32(P_ENCP_DVI_VSO_END_EVN,   vso_begin_evn);  // 2
+    // Program Vsync timing for odd field if needed
+    if (INTERLACE_MODE) {
+        vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;  // 583-1 - 15 - 5   = 562
+        vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;                // 583-1 - 15       = 567
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc); // (2 + 4400/2) % 4400 = 2202
+        aml_write_reg32(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);   // 562
+        aml_write_reg32(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);   // 567
+        aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);  // 2202
+        aml_write_reg32(P_ENCP_DVI_VSO_END_ODD,   vso_begin_odd);  // 2202
+    }
+
+    // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+    aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                         (0                                 << 1) | // [    1] src_sel_encp
+                         (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                         (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                         (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                    //                          0=output CrYCb(BRG);
+                                                                    //                          1=output YCbCr(RGB);
+                                                                    //                          2=output YCrCb(RBG);
+                                                                    //                          3=output CbCrY(GBR);
+                                                                    //                          4=output CbYCr(GRB);
+                                                                    //                          5=output CrCbY(BGR);
+                                                                    //                          6,7=Rsrv.
+#ifdef DOUBLE_CLK_720P_1080I
+                         (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#else                         
+                         (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#endif                         
+                         (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+    );
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+
+}    
+
+static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 1; // Annie 01Sep2011: Change value from 2 to 1, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS, PIXEL_REPEAT_HDMI, PIXEL_REPEAT_VENC, ACTIVE_PIXELS;
+    unsigned FRONT_PORCH = 38, HSYNC_PIXELS = 124, ACTIVE_LINES = 0, INTERLACE_MODE, TOTAL_LINES, SOF_LINES, VSYNC_LINES;
+    unsigned LINES_F0 = 262, LINES_F1 = 263, BACK_PORCH = 114, EOF_LINES = 2, TOTAL_FRAMES;
+
+    unsigned long total_pixels_venc ;
+    unsigned long active_pixels_venc;
+    unsigned long front_porch_venc  ;
+    unsigned long hsync_pixels_venc ;
+
+    unsigned long de_h_begin, de_h_end;
+    unsigned long de_v_begin_even, de_v_end_even, de_v_begin_odd, de_v_end_odd;
+    unsigned long hs_begin, hs_end;
+    unsigned long vs_adjust;
+    unsigned long vs_bline_evn, vs_eline_evn, vs_bline_odd, vs_eline_odd;
+    unsigned long vso_begin_evn, vso_begin_odd;
+
+    if((param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)){
+         INTERLACE_MODE     = 1;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 1;                   
+         ACTIVE_PIXELS  =     (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (480/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 262;                 
+         LINES_F1           = 263;                 
+         FRONT_PORCH        = 38;                  
+         HSYNC_PIXELS       = 124;                  
+         BACK_PORCH         = 114;                  
+         EOF_LINES          = 4;                   
+         VSYNC_LINES        = 3;                   
+         SOF_LINES          = 15;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    else if((param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
+         INTERLACE_MODE     = 1;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 1;                   
+         ACTIVE_PIXELS  =     (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (576/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 312;                 
+         LINES_F1           = 313;                 
+         FRONT_PORCH        = 24;                  
+         HSYNC_PIXELS       = 126;                  
+         BACK_PORCH         = 138;                  
+         EOF_LINES          = 2;                   
+         VSYNC_LINES        = 3;                   
+         SOF_LINES          = 19;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    TOTAL_PIXELS =(FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES  =(LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 1716 / 2 * 2 = 1716
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 1440 / 2 * 2 = 1440
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 38   / 2 * 2 = 38
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 124  / 2 * 2 = 124
+
+    // Annie 01Sep2011: Comment out the following 2 lines. Because ENCP is not used for 480i and 576i.
+    //Wr(ENCP_VIDEO_MODE,Rd(ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
+
+    // Program DE timing
+    // Annie 01Sep2011: for 480/576i, replace VFIFO2VD_PIXEL_START with ENCI_VFIFO2VD_PIXEL_START.
+    de_h_begin = modulo(aml_read_reg32(P_ENCI_VFIFO2VD_PIXEL_START) + VFIFO2VD_TO_HDMI_LATENCY,   total_pixels_venc); // (233 + 2) % 1716 = 235
+    de_h_end   = modulo(de_h_begin + active_pixels_venc,                            total_pixels_venc); // (235 + 1440) % 1716 = 1675
+    aml_write_reg32(P_ENCI_DE_H_BEGIN, de_h_begin);    // 235
+    aml_write_reg32(P_ENCI_DE_H_END,   de_h_end);      // 1675
+
+    // Annie 01Sep2011: for 480/576i, replace VFIFO2VD_LINE_TOP/BOT_START with ENCI_VFIFO2VD_LINE_TOP/BOT_START.
+    de_v_begin_even = aml_read_reg32(P_ENCI_VFIFO2VD_LINE_TOP_START);      // 17
+    de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 17 + 240 = 257
+    de_v_begin_odd  = aml_read_reg32(P_ENCI_VFIFO2VD_LINE_BOT_START);      // 18
+    de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;    // 18 + 480/2 = 258
+    aml_write_reg32(P_ENCI_DE_V_BEGIN_EVEN,de_v_begin_even);   // 17
+    aml_write_reg32(P_ENCI_DE_V_END_EVEN,  de_v_end_even);     // 257
+    aml_write_reg32(P_ENCI_DE_V_BEGIN_ODD, de_v_begin_odd);    // 18
+    aml_write_reg32(P_ENCI_DE_V_END_ODD,   de_v_end_odd);      // 258
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc;
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc; // 1675 + 38 = 1713
+        vs_adjust   = 0;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (1713 + 124) % 1716 = 121
+    aml_write_reg32(P_ENCI_DVI_HSO_BEGIN,  hs_begin);  // 1713
+    aml_write_reg32(P_ENCI_DVI_HSO_END,    hs_end);    // 121
+    
+    // Program Vsync timing for even field
+    if (de_v_end_odd-1 + EOF_LINES + vs_adjust >= LINES_F1) {
+        vs_bline_evn = de_v_end_odd-1 + EOF_LINES + vs_adjust - LINES_F1;
+        vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn);
+        //vso_bline_evn_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+        //vso_eline_evn_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_EVN, hs_begin);
+        aml_write_reg32(P_ENCI_DVI_VSO_END_EVN,   hs_begin);
+    } else {
+        vs_bline_odd = de_v_end_odd-1 + EOF_LINES + vs_adjust; // 258-1 + 4 + 0 = 261
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd); // 261
+        //vso_bline_odd_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_ODD, hs_begin);  // 1713
+        if (vs_bline_odd + VSYNC_LINES >= LINES_F1) {
+            vs_eline_evn = vs_bline_odd + VSYNC_LINES - LINES_F1; // 261 + 3 - 263 = 1
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);   // 1
+            //vso_eline_evn_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_EVN,   hs_begin);       // 1713
+        } else {
+            vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+            //vso_eline_odd_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_ODD,   hs_begin);
+        }
+    }
+    // Program Vsync timing for odd field
+    if (de_v_end_even-1 + EOF_LINES + 1 >= LINES_F0) {
+        vs_bline_odd = de_v_end_even-1 + EOF_LINES + 1 - LINES_F0;
+        vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd);
+        //vso_bline_odd_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+        //vso_eline_odd_reg_wr_cnt ++;
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+        aml_write_reg32(P_ENCI_DVI_VSO_END_ODD,   vso_begin_odd);
+    } else {
+        vs_bline_evn = de_v_end_even-1 + EOF_LINES + 1; // 257-1 + 4 + 1 = 261
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn); // 261
+        //vso_bline_evn_reg_wr_cnt ++;
+        vso_begin_evn   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);   // (1713 + 1716/2) % 1716 = 855
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_EVN, vso_begin_evn);  // 855
+        if (vs_bline_evn + VSYNC_LINES >= LINES_F0) {
+            vs_eline_odd = vs_bline_evn + VSYNC_LINES - LINES_F0; // 261 + 3 - 262 = 2
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);   // 2
+            //vso_eline_odd_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_ODD,   vso_begin_evn);  // 855
+        } else {
+            vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+            //vso_eline_evn_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_EVN,   vso_begin_evn);
+        }
+    }
+
+    // Check if there are duplicate or missing timing settings
+    //if ((vso_bline_evn_reg_wr_cnt != 1) || (vso_bline_odd_reg_wr_cnt != 1) ||
+    //    (vso_eline_evn_reg_wr_cnt != 1) || (vso_eline_odd_reg_wr_cnt != 1)) {
+        //stimulus_print("[TEST.C] Error: Multiple or missing timing settings on reg ENCI_DVI_VSO_B(E)LINE_EVN(ODD)!\n");
+        //stimulus_finish_fail(1);
+    //}
+
+    // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+    aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                         (0                                 << 1) | // [    1] src_sel_encp
+                         (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                         (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                         (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                    //                          0=output CrYCb(BRG);
+                                                                    //                          1=output YCbCr(RGB);
+                                                                    //                          2=output YCrCb(RBG);
+                                                                    //                          3=output CbCrY(GBR);
+                                                                    //                          4=output CbYCr(GRB);
+                                                                    //                          5=output CrCbY(BGR);
+                                                                    //                          6,7=Rsrv.
+                         (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                         (1                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+    );
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 0, 1);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+
+}    
+
+static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2; // Annie 01Sep2011: Change value from 3 to 2, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS, PIXEL_REPEAT_HDMI, PIXEL_REPEAT_VENC, ACTIVE_PIXELS;
+    unsigned FRONT_PORCH, HSYNC_PIXELS, ACTIVE_LINES, INTERLACE_MODE, TOTAL_LINES, SOF_LINES, VSYNC_LINES;
+    unsigned LINES_F0, LINES_F1,BACK_PORCH, EOF_LINES, TOTAL_FRAMES;
+
+    unsigned long total_pixels_venc ;
+    unsigned long active_pixels_venc;
+    unsigned long front_porch_venc  ;
+    unsigned long hsync_pixels_venc ;
+
+    unsigned long de_h_begin, de_h_end;
+    unsigned long de_v_begin_even, de_v_end_even, de_v_begin_odd, de_v_end_odd;
+    unsigned long hs_begin, hs_end;
+    unsigned long vs_adjust;
+    unsigned long vs_bline_evn, vs_eline_evn, vs_bline_odd, vs_eline_odd;
+    unsigned long vso_begin_evn, vso_begin_odd;
+
+    if((param->VIC==HDMI_480p60)||(param->VIC==HDMI_480p60_16x9)){
+         INTERLACE_MODE     = 0;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 0;                   
+         ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES       = (480/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 525;                 
+         LINES_F1           = 525;                 
+         FRONT_PORCH        = 16;                  
+         HSYNC_PIXELS       = 62;                  
+         BACK_PORCH         = 60;                  
+         EOF_LINES          = 9;                   
+         VSYNC_LINES        = 6;                   
+         SOF_LINES          = 30;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    else if((param->VIC==HDMI_576p50)||(param->VIC==HDMI_576p50_16x9)){
+         INTERLACE_MODE     = 0;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 0;                   
+         ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES       = (576/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 625;                 
+         LINES_F1           = 625;                 
+         FRONT_PORCH        = 12;                  
+         HSYNC_PIXELS       = 64;                  
+         BACK_PORCH         = 68;                  
+         EOF_LINES          = 5;                   
+         VSYNC_LINES        = 5;                   
+         SOF_LINES          = 39;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    else if(param->VIC==HDMI_720p60){
+         INTERLACE_MODE     = 0;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 0;                   
+         ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES       = (720/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 750;                 
+         LINES_F1           = 750;                 
+         FRONT_PORCH        = 110;                  
+         HSYNC_PIXELS       = 40;                  
+         BACK_PORCH         = 220;                  
+         EOF_LINES          = 5;                   
+         VSYNC_LINES        = 5;                   
+         SOF_LINES          = 20;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    else if(param->VIC==HDMI_720p50){
+         INTERLACE_MODE     = 0;                   
+         PIXEL_REPEAT_VENC  = 1;                   
+         PIXEL_REPEAT_HDMI  = 0;                   
+         ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES       = (720/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 750;                 
+         LINES_F1           = 750;                 
+         FRONT_PORCH        = 440;                  
+         HSYNC_PIXELS       = 40;                  
+         BACK_PORCH         = 220;                  
+         EOF_LINES          = 5;                   
+         VSYNC_LINES        = 5;                   
+         SOF_LINES          = 20;                  
+         TOTAL_FRAMES       = 4;                   
+    }
+    else if(param->VIC==HDMI_1080p50){
+         INTERLACE_MODE      =0;              
+         PIXEL_REPEAT_VENC   =0;              
+         PIXEL_REPEAT_HDMI   =0;              
+         ACTIVE_PIXELS       =(1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES        =(1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0            =1125;           
+         LINES_F1            =1125;           
+         FRONT_PORCH         =528;             
+         HSYNC_PIXELS        =44;             
+         BACK_PORCH          =148;            
+         EOF_LINES           =4;              
+         VSYNC_LINES         =5;              
+         SOF_LINES           =36;             
+         TOTAL_FRAMES        =4;              
+    }
+    else if(param->VIC==HDMI_1080p24){//1080p24 support
+         INTERLACE_MODE      =0;              
+         PIXEL_REPEAT_VENC   =0;              
+         PIXEL_REPEAT_HDMI   =0;              
+         ACTIVE_PIXELS       =(1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES        =(1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0            =1125;           
+         LINES_F1            =1125;           
+         FRONT_PORCH         =638;             
+         HSYNC_PIXELS        =44;             
+         BACK_PORCH          =148;            
+         EOF_LINES           =4;              
+         VSYNC_LINES         =5;              
+         SOF_LINES           =36;             
+         TOTAL_FRAMES        =4;    
+    }
+    else{ //HDMI_1080p60, HDMI_1080p30
+         INTERLACE_MODE      =0;              
+         PIXEL_REPEAT_VENC   =0;              
+         PIXEL_REPEAT_HDMI   =0;              
+         ACTIVE_PIXELS       =(1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES        =(1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0            =1125;           
+         LINES_F1            =1125;           
+         FRONT_PORCH         =88;             
+         HSYNC_PIXELS        =44;             
+         BACK_PORCH          =148;            
+         EOF_LINES           =4;              
+         VSYNC_LINES         =5;              
+         SOF_LINES           =36;             
+         TOTAL_FRAMES        =4;              
+    }
+
+    TOTAL_PIXELS       = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES        = (LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 858 / 1 * 2 = 1716
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 720 / 1 * 2 = 1440
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 16   / 1 * 2 = 32
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 62   / 1 * 2 = 124
+
+    aml_write_reg32(P_ENCP_VIDEO_MODE,aml_read_reg32(P_ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
+    // Program DE timing
+    de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc); // (217 + 3) % 1716 = 220
+    de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc); // (220 + 1440) % 1716 = 1660
+    aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);    // 220
+    aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);      // 1660
+    // Program DE timing for even field
+    de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);       // 42
+    de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 42 + 480 = 522
+    aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);   // 42
+    aml_write_reg32(P_ENCP_DE_V_END_EVEN,  de_v_end_even);     // 522
+    // Program DE timing for odd field if needed
+    if (INTERLACE_MODE) {
+        // Calculate de_v_begin_odd according to enc480p_timing.v:
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
+        de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
+        de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;
+        aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+        aml_write_reg32(P_ENCP_DE_V_END_ODD,   de_v_end_odd);
+    }
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc;
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc; // 1660 + 32 = 1692
+        vs_adjust   = 0;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (1692 + 124) % 1716 = 100
+    aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);  // 1692
+    aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);    // 100
+    
+    // Program Vsync timing for even field
+    if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
+        vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust); // 42 - 30 - 6 - 1 = 5
+    } else {
+        vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
+    }
+    vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES); // (5 + 6) % 525 = 11
+    aml_write_reg32(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   // 5
+    aml_write_reg32(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   // 11
+    vso_begin_evn = hs_begin; // 1692
+    aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  // 1692
+    aml_write_reg32(P_ENCP_DVI_VSO_END_EVN,   vso_begin_evn);  // 1692
+    // Program Vsync timing for odd field if needed
+    if (INTERLACE_MODE) {
+        vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+        vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);
+        aml_write_reg32(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_END_ODD,   vso_begin_odd);
+    }
+    // Annie 01Sep2011: Remove the following line as register VENC_DVI_SETTING_MORE is no long valid, use VPU_HDMI_SETTING instead.
+    //Wr(VENC_DVI_SETTING_MORE, (TX_INPUT_COLOR_FORMAT==0)? 1 : 0); // [0] 0=Map data pins from Venc to Hdmi Tx as CrYCb mode;
+
+    switch(param->VIC)
+    {
+        case HDMI_480p60:
+        case HDMI_480p60_16x9:
+        case HDMI_576p50:
+        case HDMI_576p50_16x9:
+//Note: Hsync & Vsync polarity should be negative.
+//Refer to HDMI CTS 1.4A Page 169
+            // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+            aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                                 (0                                 << 1) | // [    1] src_sel_encp
+                                 (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                                 (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                                 (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                                 (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                            //                          0=output CrYCb(BRG);
+                                                                            //                          1=output YCbCr(RGB);
+                                                                            //                          2=output YCrCb(RBG);
+                                                                            //                          3=output CbCrY(GBR);
+                                                                            //                          4=output CbYCr(GRB);
+                                                                            //                          5=output CrCbY(BGR);
+                                                                            //                          6,7=Rsrv.
+                                 (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                                 (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+            );
+            break;
+        case HDMI_720p60:
+        case HDMI_720p50:
+            // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+            aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                                 (0                                 << 1) | // [    1] src_sel_encp
+                                 (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                                 (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                                 (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                                 (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                            //                          0=output CrYCb(BRG);
+                                                                            //                          1=output YCbCr(RGB);
+                                                                            //                          2=output YCrCb(RBG);
+                                                                            //                          3=output CbCrY(GBR);
+                                                                            //                          4=output CbYCr(GRB);
+                                                                            //                          5=output CrCbY(BGR);
+                                                                            //                          6,7=Rsrv.
+#ifdef DOUBLE_CLK_720P_1080I
+                                 (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#else
+                                 (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#endif                             
+                                 (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+            );
+            break;
+        default:
+            // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+            aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                                 (0                                 << 1) | // [    1] src_sel_encp
+                                 (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                                 (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                                 (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                                 (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                            //                          0=output CrYCb(BRG);
+                                                                            //                          1=output YCbCr(RGB);
+                                                                            //                          2=output YCrCb(RBG);
+                                                                            //                          3=output CbCrY(GBR);
+                                                                            //                          4=output CbYCr(GRB);
+                                                                            //                          5=output CrCbY(BGR);
+                                                                            //                          6,7=Rsrv.
+                                 (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                                 (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+            );
+    }
+
+    // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+}    
+
+/*
+hdmi on/off
+*/
+static int is_hpd_muxed(void)
+{
+    int ret;
+    ret = !!(aml_read_reg32(P_PERIPHS_PIN_MUX_1)&(1<<22));
+    return ret; 
+}    
+
+static void mux_hpd(void)
+{
+    aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1)|(1 << 22));
+}
+
+static void unmux_hpd(void)
+{
+    aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1)&~(1 << 22));
+    //GPIOC_10 0x2012[10]
+    aml_write_reg32(P_PREG_PAD_GPIO2_EN_N, aml_read_reg32(P_PREG_PAD_GPIO2_EN_N)|(1<<10)); //GPIOC_10 as input
+}
+
+extern int read_hpd_gpio(void);
+int read_hpd_gpio(void)
+{
+    int level;
+
+    level = !!(aml_read_reg32(P_PREG_PAD_GPIO2_I)&(1<<10)); //read GPIOC_10
+    return level;
+}
+EXPORT_SYMBOL(read_hpd_gpio);
+
+#if 0
+static unsigned long clk81_rate = 100000000;
+
+static void clk81_set(void)
+{
+    struct clk *clk_tmp;
+
+    clk_tmp = clk_get_sys("clk81", NULL);
+    if (clk_tmp)
+    {
+        clk81_rate = clk_get_rate(clk_tmp);
+        clk_set_rate(clk_tmp, 168000000);
+        CLEAR_AOBUS_REG_MASK(AO_UART_CONTROL, (1 << 19) | 0xFFF);
+        WRITE_AOBUS_REG_BITS(AO_UART_CONTROL, ((168000000 / (115200 * 4)) - 1) & 0xfff, 0, 12);
+    }
+    msleep(2);  //Waiting some time
+    //printk("%s clk81_rate: %d\n", __FUNCTION__, clk81_rate);
+}
+
+static void clk81_resume(void)
+{
+    struct clk *clk_tmp;
+    
+    clk_tmp = clk_get_sys("clk81", NULL);
+    if (clk_tmp)
+    {
+        clk_set_rate(clk_tmp, clk81_rate);
+        CLEAR_AOBUS_REG_MASK(AO_UART_CONTROL, (1 << 19) | 0xFFF);
+        WRITE_AOBUS_REG_BITS(AO_UART_CONTROL, ((clk81_rate / (115200 * 4)) - 1) & 0xfff, 0, 12);
+    }
+    msleep(2);  //Waiting some time
+    //printk("%s clk81_rate: %d\n", __FUNCTION__, clk81_rate);
+}
+#endif
+
+static void digital_clk_off(unsigned char flag)
+{
+//    clk81_resume();
+    if(flag&1){
+//#ifdef AML_A3
+    /* off hdmi audio clock */
+//        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL1,  hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL1)&(~(1<<13))); //
+//        hdmi_wr_reg(TX_AUDIO_FORMAT, hdmi_rd_reg(TX_AUDIO_FORMAT)|(1<<7));
+//        hdmi_wr_reg(TX_AUDIO_I2S, hdmi_rd_reg(TX_AUDIO_I2S)|(1<<1));
+//#endif    
+    }
+
+    if(flag&2){
+        /* off hdmi pixel clock */
+//        Wr(HHI_GCLK_MPEG2, Rd(HHI_GCLK_MPEG2)&(~(1<<4))); //disable pixel clock, set cbus reg HHI_GCLK_MPEG2 bit [4] = 0
+        aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)&(~(1<<17))); //disable VCLK1_HDMI GATE, set cbus reg HHI_GCLK_OTHER bit [17] = 0
+        aml_write_reg32(P_VENC_DVI_SETTING, (aml_read_reg32(P_VENC_DVI_SETTING)&(~(7<<4)))|(5<<4)); //set cbus reg VENC_DVI_SETTING bit[6:4] = 0x5
+        aml_write_reg32(P_HHI_VID_PLL_CNTL, (aml_read_reg32(P_HHI_VID_PLL_CNTL) | (1<<30)));     //0x105c[30]PD, 1: PowerDown
+        aml_write_reg32(P_HHI_VID_PLL_CNTL3, (aml_read_reg32(P_HHI_VID_PLL_CNTL3) & ~((1<<5)|(1<<3))));  //0x1058[5]VBG_PU [3]IREXT_PU
+    // Second turn off gate.
+        aml_write_reg32(P_HHI_GCLK_MPEG2, aml_read_reg32(P_HHI_GCLK_MPEG2) & (~(1<<4)));     //Disable HDMI PCLK
+    }
+    if(flag&4){
+        /* off hdmi sys clock */
+        aml_write_reg32(P_HHI_HDMI_CLK_CNTL, aml_read_reg32(P_HHI_HDMI_CLK_CNTL)&(~(1<<8))); // off hdmi sys clock gate
+    }
+}
+
+static void digital_clk_on(unsigned char flag)
+{
+//    clk81_set();
+    if(flag&4){
+        /* on hdmi sys clock */
+        // -----------------------------------------
+        // HDMI (90Mhz)
+        // -----------------------------------------
+        //         .clk_div            ( hi_hdmi_clk_cntl[6:0] ),
+        //         .clk_en             ( hi_hdmi_clk_cntl[8]   ),
+        //         .clk_sel            ( hi_hdmi_clk_cntl[11:9]),
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 0, 7);    // Divide the "other" PLL output by 1
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 9, 3);    // select "XTAL" PLL
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 1, 8, 1);    // Enable gated clock
+//        Wr( HHI_HDMI_CLK_CNTL,  ((2 << 9)  |   // select "misc" PLL
+//                                 (1 << 8)  |   // Enable gated clock
+//                                 (5 << 0)) );  // Divide the "other" PLL output by 6
+    }
+    if(flag&2){
+        /* on hdmi pixel clock */
+        aml_write_reg32(P_HHI_GCLK_MPEG2, aml_read_reg32(P_HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
+//        Wr(HHI_GCLK_MPEG2, Rd(HHI_GCLK_MPEG2)|(1<<4)); //enable pixel clock, set cbus reg HHI_GCLK_MPEG2 bit [4] = 1
+        aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)|(1<<17)); //enable VCLK1_HDMI GATE, set cbus reg HHI_GCLK_OTHER bit [17] = 1
+    }
+    if(flag&1){
+    }  
+}
+
+static void phy_pll_off(void)
+{
+    hdmi_phy_suspend();
+}
+
+/**/
+void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device)
+{
+    struct hdmi_phy_set_data *pdata = NULL;
+    int vic = hdmitx_device->cur_VIC;
+    power_mode = 1;
+    hdmi_phy_wakeup();
+    // relate to different board
+    if(hdmitx_device->config_data.phy_data){
+        pdata = hdmitx_device->config_data.phy_data;
+        printk("HDMI: get brd phy data\n");
+    }
+    printk("hdmi phy setting\n");
+#define SET_PHY_BRD(a)                                          \
+    do{                                                         \
+        pdata = hdmitx_device->config_data.phy_data;            \
+        if(pdata){                                              \
+            while((pdata->addr != -1)){                         \
+                if(pdata->freq == a)                            \
+                    hdmi_wr_reg(pdata->addr, pdata->data);      \
+                pdata++;                                        \
+            }                                                   \
+        }                                                       \
+      }while(0)            
+    // Default Setting
+//    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xfe << HDMI_COMMON_b7_b0);    //0x10
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG1, (0xf  <<HDMI_CTL_REG_b3_b0) |
+                                     (0xe  << HDMI_COMMON_b11_b8));    //0x10
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG2, 0xff << HDMI_CTL_REG_b11_b4);   //0xf7
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG3, (0xf << HDMI_MDR_PU)|
+                                     (0x7 << HDMI_L2H_CTL));    //0x16
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG4, (0x2 << HDMI_PREM_CTL) |
+                                     (0x0 << HDMI_MODE_P) |
+                                     (0x1 << HDMI_PHY_CLK_EN) |
+                                     (0x0 << HDMI_LF_PD)
+                                     );      //0x14 Prem
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG5, (0x7 << HDMI_VCM_CTL) | 
+                                     (0x7 << HDMI_PREFCTL));         //0x15 Slew
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG6, (0xa << HDMI_SWING_CTL) | 
+                                     (0x0 << HDMI_RTERM_CTL) );
+    // relate to different board
+    switch(vic)
+    {
+
+        case HDMI_480i60:
+        case HDMI_480i60_16x9:
+        case HDMI_576p50:
+        case HDMI_576p50_16x9:
+        case HDMI_576i50:
+        case HDMI_576i50_16x9:
+        case HDMI_480p60:
+        case HDMI_480p60_16x9:
+            SET_PHY_BRD(27);
+            break;
+        case HDMI_720p50:
+        case HDMI_720p60:
+        case HDMI_1080i50:
+        case HDMI_1080i60:
+        case HDMI_1080p24://1080p24 support
+            SET_PHY_BRD(74);
+            break;
+        case HDMI_1080p50:
+        case HDMI_1080p60:
+            SET_PHY_BRD(148);
+            break;
+        default:
+            break;
+    }
+    switch(power_mode){
+        case 1:
+            hdmi_wr_reg(TX_CORE_CALIB_MODE, 0xc);
+            hdmi_wr_reg(TX_CORE_CALIB_VALUE, 0x0);
+            break;
+        case 2:
+            break;
+        default:
+            break;
+    }
+}
+
+void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned int tmp_add_data;
+    HDMI_Video_Codes_t vic;
+    
+    digital_clk_on(7);
+    aml_write_reg32(P_HHI_HDMI_AFC_CNTL, aml_read_reg32(P_HHI_HDMI_AFC_CNTL) | 0x3);
+    vic = hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0);
+    if(vic != HDMI_Unkown) {
+        hdmi_print(IMP, SYS "ALREADY init VIC = %d\n", vic);
+        hdmitx_device->cur_VIC = vic;
+        return;
+    }
+    hdmi_phy_suspend();
+
+    hdmi_print(IMP, SYS "hw init\n");
+
+    hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down 
+    if(serial_reg_val<0x20){
+        hdmi_wr_reg(0x018, 0x24);
+    }
+    else{
+        hdmi_wr_reg(0x018, serial_reg_val);   //Serializer Internal clock setting ,please fix to vaue 24 ,other setting is only for debug  
+    }
+    hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK 
+
+    hdmi_hw_set_powermode(hdmitx_device);
+
+    hdmi_wr_reg(0x0F7, 0x0F);   // Termination resistor calib value
+
+    // --------------------------------------------------------
+    // Program core_pin_mux to enable HDMI pins
+    // --------------------------------------------------------
+    //wire            pm_hdmi_cec_en              = pin_mux_reg0[2];
+    //wire            pm_hdmi_hpd_5v_en           = pin_mux_reg0[1];
+    //wire            pm_hdmi_i2c_5v_en           = pin_mux_reg0[0];
+
+    // Enable these interrupts: [2] tx_edit_int_rise [1] tx_hpd_int_fall [0] tx_hpd_int_rise
+    hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0x0);
+    // HPD glitch filter
+    hdmi_wr_reg(TX_HDCP_HPD_FILTER_L, 0xa0);
+    hdmi_wr_reg(TX_HDCP_HPD_FILTER_H, 0xa0);
+
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x90); //bit5,6 is converted
+    delay_us(10);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
+    delay_us(10);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
+    delay_us(10);
+
+    /**/
+
+    // Enable software controlled DDC transaction
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7]   = 1'b0 ;  // forced_sys_trigger
+    //tmp_add_data[6]   = 1'b0 ;  // sys_trigger_config
+    //tmp_add_data[5]   = 1'b0 ;  // mem_acc_seq_mode
+    //tmp_add_data[4]   = 1'b0 ;  // mem_acc_seq_start
+    //tmp_add_data[3]   = 1'b1 ;  // forced_mem_copy_done
+    //tmp_add_data[2]   = 1'b1 ;  // mem_copy_done_config
+    //tmp_add_data[1]   = 1'b1 ;  // sys_trigger_config_semi_manu
+    //tmp_add_data[0]   = 1'b0 ;  // Rsrv
+    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, 0x0c); //// for hdcp, can not use 0x0e
+    hdmi_wr_reg(TX_CORE_EDID_CONFIG_MORE, (1 << 0));    // [1]: keep_edid_error
+                                                        // [0]: sys_trigger_config_semi_manu
+                                                        
+    hdmi_wr_reg(TX_PACKET_ALLOC_ACTIVE_1, 0);
+    hdmi_wr_reg(TX_PACKET_CONTROL_2, 2);
+    
+    hdmi_wr_reg(TX_HDCP_CONFIG0,      1<<3);  //set TX rom_encrypt_off=1
+    hdmi_wr_reg(TX_HDCP_MEM_CONFIG,   0<<3);  //set TX read_decrypt=0
+    hdmi_wr_reg(TX_HDCP_ENCRYPT_BYTE, 0);     //set TX encrypt_byte=0x00
+
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7] = 1'b0;       // Force packet timing
+    //tmp_add_data[6] = 1'b0;       // PACKET ALLOC MODE
+    //tmp_add_data[5:0] = 6'd47 ;   // PACKET_START_LATENCY
+    //tmp_add_data = 47;
+    tmp_add_data = 58;
+    hdmi_wr_reg(TX_PACKET_CONTROL_1, tmp_add_data); //this register should be set to ensure the first hdcp succeed
+
+    //tmp_add_data[7] = 1'b0;      // cp_desired
+    //tmp_add_data[6] = 1'b0;      // ess_config
+    //tmp_add_data[5] = 1'b0;      // set_avmute
+    //tmp_add_data[4] = 1'b1;      // clear_avmute
+    //tmp_add_data[3] = 1'b0;      // hdcp_1_1
+    //tmp_add_data[2] = 1'b0;      // Vsync/Hsync forced_polarity_select
+    //tmp_add_data[1] = 1'b0;      // forced_vsync_polarity
+    //tmp_add_data[0] = 1'b0;      // forced_hsync_polarity
+    //tmp_add_data = 0x10;
+    tmp_add_data = 0x0; //rain
+    hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
+    //config_hdmi(1);
+
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7:0]   = 0xa ; // time_divider[7:0] for DDC I2C bus clock
+    //tmp_add_data = 0xa; //800k
+    //tmp_add_data = 0x3f; //190k
+    tmp_add_data = 0x30 - 1; //50k     // hdmi system clock change to XTAL 24MHz
+    hdmi_wr_reg(TX_HDCP_CONFIG3, tmp_add_data);
+
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7]   = 8'b1 ;  //cp_desired 
+    //tmp_add_data[6]   = 8'b1 ;  //ess_config 
+    //tmp_add_data[5]   = 8'b0 ;  //set_avmute 
+    //tmp_add_data[4]   = 8'b0 ;  //clear_avmute 
+    //tmp_add_data[3]   = 8'b1 ;  //hdcp_1_1 
+    //tmp_add_data[2]   = 8'b0 ;  //forced_polarity 
+    //tmp_add_data[1]   = 8'b0 ;  //forced_vsync_polarity 
+    //tmp_add_data[0]   = 8'b0 ;  //forced_hsync_polarity
+    tmp_add_data = 0x40;
+    hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
+    
+    hdmi_wr_reg(TX_AUDIO_CONTROL_MORE, 1);
+
+    hdmi_hw_set_powermode(hdmitx_device);
+
+    // --------------------------------------------------------
+    // Release TX out of reset
+    // --------------------------------------------------------
+    //new reset sequence, 2010Sep09, rain
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
+    delay_us(10);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
+    delay_us(10);        
+
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
+    delay_us(10);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
+    delay_us(10);
+}    
+
+// When 1080p50hz output, we shall manually configure
+// bolow register to get stable Video Timing.
+static void hdmi_reconfig_packet_setting(void)
+{
+    hdmi_wr_reg(TX_PACKET_ALLOC_ACTIVE_1, 0x01);
+    hdmi_wr_reg(TX_PACKET_ALLOC_ACTIVE_2, 0x12);
+    hdmi_wr_reg(TX_PACKET_ALLOC_EOF_1, 0x10);
+    hdmi_wr_reg(TX_PACKET_ALLOC_EOF_2, 0x12);
+    hdmi_wr_reg(TX_PACKET_ALLOC_SOF_1, 0xb6);
+    hdmi_wr_reg(TX_PACKET_ALLOC_SOF_2, 0x11);
+    hdmi_wr_reg(TX_PACKET_CONTROL_1, (hdmi_rd_reg(TX_PACKET_CONTROL_1)) | (1 << 7));    // bit[7]: forced_packet_timing
+}
+
+static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *param)
+{
+    unsigned int tmp_add_data;
+    unsigned long TX_OUTPUT_COLOR_FORMAT;
+
+    hdmi_print(IMP, SYS "hw reset\n");
+    
+    digital_clk_on(7);
+
+    if(param->color==COLOR_SPACE_YUV444){
+        TX_OUTPUT_COLOR_FORMAT=1;
+    }
+    else if(param->color==COLOR_SPACE_YUV422){
+        TX_OUTPUT_COLOR_FORMAT=3;
+    }
+    else{
+        TX_OUTPUT_COLOR_FORMAT=0;
+    }
+
+    if(delay_flag&2)
+        delay_us(1000*100);
+    //printk("delay 100ms\n");
+
+    aml_write_reg32(P_HHI_HDMI_AFC_CNTL, aml_read_reg32(P_HHI_HDMI_AFC_CNTL) | 0x3);
+
+    hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down 
+    if(new_reset_sequence_flag==0){
+        if(serial_reg_val==0){
+            if((param->VIC==HDMI_1080p30)||(param->VIC==HDMI_720p60)||(param->VIC==HDMI_1080i60)
+                ||(param->VIC==HDMI_1080p24)){
+                hdmi_wr_reg(0x018, 0x22);   
+            }
+            else{
+                hdmi_wr_reg(0x018, 0x24);   
+            }
+        }
+        else if(serial_reg_val==1){
+            if((param->VIC==HDMI_480p60)||(param->VIC==HDMI_480p60_16x9)
+                ||(param->VIC==HDMI_576p50)||(param->VIC==HDMI_576p50_16x9)
+                ||(param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)
+                ||(param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
+                hdmi_wr_reg(0x018, 0x24);   
+            }
+            else{
+                hdmi_wr_reg(0x018, 0x22);   
+            }
+        }
+        else{
+            hdmi_wr_reg(0x018, serial_reg_val);
+        }
+        if((param->VIC==HDMI_1080p60)&&(param->color_depth==COLOR_30BIT)&&(hdmi_rd_reg(0x018)==0x22)){
+            hdmi_wr_reg(0x018,0x12);
+        }
+    }
+    hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK 
+
+    hdmi_hw_set_powermode(hdmitx_device);
+
+    hdmi_wr_reg(0x0F7, 0x0F);   // Termination resistor calib value
+
+    // delay 1000uS, then check HPLL_LOCK
+    delay_us(1000);
+    //while ( (Rd(HHI_VID_PLL_CNTL3) & (1<<31)) != (1<<31) );
+ 
+//////////////////////////////reset    
+    if(new_reset_sequence_flag){
+
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x90);
+        delay_us(10);
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
+        delay_us(10);
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
+        delay_us(10);
+    }
+    else{
+        // Keep TX (except register I/F) in reset, while programming the registers:
+        tmp_add_data  = 0;
+        tmp_add_data |= 1 << 7; // tx_pixel_rstn
+        tmp_add_data |= 1 << 6; // tx_tmds_rstn
+        tmp_add_data |= 1 << 5; // tx_audio_master_rstn
+        tmp_add_data |= 1 << 4; // tx_audio_sample_rstn
+        tmp_add_data |= 1 << 3; // tx_i2s_reset_rstn
+        tmp_add_data |= 1 << 2; // tx_dig_reset_n_ch2
+        tmp_add_data |= 1 << 1; // tx_dig_reset_n_ch1
+        tmp_add_data |= 1 << 0; // tx_dig_reset_n_ch0
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, tmp_add_data);
+    
+        tmp_add_data  = 0;
+        tmp_add_data |= 1 << 7; // HDMI_CH3_RST_IN
+        tmp_add_data |= 1 << 6; // HDMI_CH2_RST_IN
+        tmp_add_data |= 1 << 5; // HDMI_CH1_RST_IN
+        tmp_add_data |= 1 << 4; // HDMI_CH0_RST_IN
+        tmp_add_data |= 1 << 3; // HDMI_SR_RST
+        tmp_add_data |= 1 << 0; // tx_dig_reset_n_ch3
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, tmp_add_data);
+    }
+    // Enable software controlled DDC transaction
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7]   = 1'b0 ;  // forced_sys_trigger
+    //tmp_add_data[6]   = 1'b0 ;  // sys_trigger_config
+    //tmp_add_data[5]   = 1'b0 ;  // mem_acc_seq_mode
+    //tmp_add_data[4]   = 1'b0 ;  // mem_acc_seq_start
+    //tmp_add_data[3]   = 1'b1 ;  // forced_mem_copy_done
+    //tmp_add_data[2]   = 1'b1 ;  // mem_copy_done_config
+    //tmp_add_data[1]   = 1'b1 ;  // sys_trigger_config_semi_manu
+    //tmp_add_data[0]   = 1'b0 ;  // Rsrv
+
+    tmp_add_data = 0x0c; // for hdcp, can not use 0x0e 
+    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, tmp_add_data);
+    
+    hdmi_wr_reg(TX_HDCP_CONFIG0,      1<<3);  //set TX rom_encrypt_off=1
+    hdmi_wr_reg(TX_HDCP_MEM_CONFIG,   0<<3);  //set TX read_decrypt=0
+    hdmi_wr_reg(TX_HDCP_ENCRYPT_BYTE, 0);     //set TX encrypt_byte=0x00
+
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7] = 1'b0;      // Force DTV timing (Auto)
+    //tmp_add_data[6] = 1'b0;      // Force Video Scan, only if [7]is set
+    //tmp_add_data[5] = 1'b0 ;     // Force Video field, only if [7]is set
+    //tmp_add_data[4:0] = 5'b00 ;  // Rsrv
+    if(hdmitx_device->cur_VIC == 39)
+        tmp_add_data = 0;
+    else
+        tmp_add_data = (1<<4);
+    hdmi_wr_reg(TX_VIDEO_DTV_TIMING, tmp_add_data);
+    
+    tmp_add_data  = 0;
+    tmp_add_data |= 0                       << 7; // [7]   forced_default_phase
+    tmp_add_data |= 0                       << 2; // [6:2] Rsrv
+    tmp_add_data |= param->color_depth      << 0; // [1:0] Color_depth:0=24-bit pixel; 1=30-bit pixel; 2=36-bit pixel; 3=48-bit pixel
+    hdmi_wr_reg(TX_VIDEO_DTV_MODE, tmp_add_data); // 0x00
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7] = 1'b0;       // Force packet timing
+    //tmp_add_data[6] = 1'b0;       // PACKET ALLOC MODE
+    //tmp_add_data[5:0] = 6'd47 ;   // PACKET_START_LATENCY
+    //tmp_add_data = 47;
+    tmp_add_data = 58;
+    hdmi_wr_reg(TX_PACKET_CONTROL_1, tmp_add_data);
+
+    // For debug: disable packets of audio_request, acr_request, deep_color_request, and avmute_request
+    //hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) | 0x0f);
+    
+    //HDMI CT 7-19 GCP PB1 through PB6 not equal to 0 | 720 3 0 37 72 16367911819.90 31822 General Control Packet (GCP) 
+    //PACKET_CONTROL[~deep_color_request_enable]
+    //0: horizontal GC packet transport enabled
+    //1: horizontal GC packet masked
+    hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) | (0x1<<1));
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7:6] = 2'b0;     // audio_source_select[1:0]
+    //tmp_add_data[5] = 1'b0;       // external_packet_enable
+    //tmp_add_data[4] = 1'b1 ;      // internal_packet_enable
+    //tmp_add_data[3:2] = 2'b0;     // afe_fifo_source_select_lane_1[1:0]
+    //tmp_add_data[1:0] = 2'b0 ;    // afe_fifo_source_select_lane_0[1:0]
+    tmp_add_data = 0x10;
+    hdmi_wr_reg(TX_CORE_DATA_CAPTURE_2, tmp_add_data);
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7]   = 1'b0;     // monitor_lane_1
+    //tmp_add_data[6:4] = 3'd0;     // monitor_select_lane_1[2:0]
+    //tmp_add_data[3]   = 1'b1 ;    // monitor_lane_0
+    //tmp_add_data[2:0] = 3'd7;     // monitor_select_lane_0[2:0]
+    tmp_add_data = 0xf;
+    hdmi_wr_reg(TX_CORE_DATA_MONITOR_1, tmp_add_data);
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7:3] = 5'b0;     // Rsrv
+    //tmp_add_data[2:0] = 3'd2;     // monitor_select[2:0]
+    tmp_add_data = 0x2;
+    hdmi_wr_reg(TX_CORE_DATA_MONITOR_2, tmp_add_data);
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7] = 1'b1;     // forced_hdmi
+    //tmp_add_data[6] = 1'b1;     // hdmi_config
+    //tmp_add_data[5:4] = 2'b0;   // Rsrv
+    //tmp_add_data[3] = 1'b0;     // bit_swap.
+    //tmp_add_data[2:0] = 3'd0;   // channel_swap[2:0]
+    tmp_add_data = 0xc0;
+    hdmi_wr_reg(TX_TMDS_MODE, tmp_add_data);
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7] = 1'b0;  // Rsrv
+    //tmp_add_data[6] = 1'b0;  // TX_CONNECT_SEL: 0=use lower channel data[29:0]; 1=use upper channel data[59:30]
+    //tmp_add_data[5:0] = 'h0;  // Rsrv
+    tmp_add_data = 0x0;
+    hdmi_wr_reg(TX_SYS4_CONNECT_SEL_1, tmp_add_data);
+    
+    // Normally it makes sense to synch 3 channel output with clock channel's rising edge,
+    // as HDMI's serializer is LSB out first, invert tmds_clk pattern from "1111100000" to
+    // "0000011111" actually enable data synch with clock rising edge.
+    //if((param->VIC==HDMI_1080p30)||(param->VIC==HDMI_720p60)||(param->VIC==HDMI_1080i60)){
+    //    hdmi_wr_reg(TX_SYS4_CK_INV_VIDEO, 0xf0);
+    //}
+    //else{
+        tmp_add_data = 1 << 4; // Set tmds_clk pattern to be "0000011111" before being sent to AFE clock channel
+        hdmi_wr_reg(TX_SYS4_CK_INV_VIDEO, tmp_add_data);
+    //}            
+    
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7] = 1'b0;  // Rsrv
+    //tmp_add_data[6] = 1'b0;  // TX_AFE_FIFO channel 2 bypass=0
+    //tmp_add_data[5] = 1'b0;  // TX_AFE_FIFO channel 1 bypass=0
+    //tmp_add_data[4] = 1'b0;  // TX_AFE_FIFO channel 0 bypass=0
+    //tmp_add_data[3] = 1'b1;  // output enable of clk channel (channel 3)
+    //tmp_add_data[2] = 1'b1;  // TX_AFE_FIFO channel 2 enable
+    //tmp_add_data[1] = 1'b1;  // TX_AFE_FIFO channel 1 enable
+    //tmp_add_data[0] = 1'b1;  // TX_AFE_FIFO channel 0 enable
+    tmp_add_data = 0x0f;
+    hdmi_wr_reg(TX_SYS5_FIFO_CONFIG, tmp_add_data);
+    
+    tmp_add_data  = 0;
+    tmp_add_data |= TX_OUTPUT_COLOR_FORMAT  << 6; // [7:6] output_color_format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
+    tmp_add_data |= TX_INPUT_COLOR_FORMAT   << 4; // [5:4] input_color_format:  0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
+    tmp_add_data |= param->color_depth   << 2; // [3:2] output_color_depth:  0=24-b; 1=30-b; 2=36-b; 3=48-b.
+    tmp_add_data |= TX_INPUT_COLOR_DEPTH    << 0; // [1:0] input_color_depth:   0=24-b; 1=30-b; 2=36-b; 3=48-b.
+    hdmi_wr_reg(TX_VIDEO_DTV_OPTION_L, tmp_add_data); // 0x50
+
+    tmp_add_data  = 0;
+    tmp_add_data |= 0                       << 4; // [7:4] Rsrv
+    tmp_add_data |= TX_OUTPUT_COLOR_RANGE   << 2; // [3:2] output_color_range:  0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
+    tmp_add_data |= TX_INPUT_COLOR_RANGE    << 0; // [1:0] input_color_range:   0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
+    hdmi_wr_reg(TX_VIDEO_DTV_OPTION_H, tmp_add_data); // 0x00
+    
+    if(!hdmi_audio_off_flag){
+        hdmi_audio_init(i2s_to_spdif_flag);
+    }
+    hdmi_wr_reg(TX_AUDIO_CONTROL_MORE, 1);
+    //tmp_add_data[7] = 1'b0;      // cp_desired
+    //tmp_add_data[6] = 1'b0;      // ess_config
+    //tmp_add_data[5] = 1'b0;      // set_avmute
+    //tmp_add_data[4] = 1'b1;      // clear_avmute
+    //tmp_add_data[3] = 1'b0;      // hdcp_1_1
+    //tmp_add_data[2] = 1'b0;      // Vsync/Hsync forced_polarity_select
+    //tmp_add_data[1] = 1'b0;      // forced_vsync_polarity
+    //tmp_add_data[0] = 1'b0;      // forced_hsync_polarity
+    //tmp_add_data = 0x10;
+    tmp_add_data = 0x0; //rain
+//    hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
+    //config_hdmi(1);
+
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7:0]   = 0xa ; // time_divider[7:0] for DDC I2C bus clock
+    
+    //tmp_add_data = 0xa; //800k
+    //tmp_add_data = 0x3f; //190k
+    tmp_add_data = 0x30 - 1; //50k     // hdmi system clock change to XTAL 24MHz
+    hdmi_wr_reg(TX_HDCP_CONFIG3, tmp_add_data);
+
+    //tmp_add_data[15:8] = 0;
+    //tmp_add_data[7]   = 8'b1 ;  //cp_desired 
+    //tmp_add_data[6]   = 8'b1 ;  //ess_config 
+    //tmp_add_data[5]   = 8'b0 ;  //set_avmute 
+    //tmp_add_data[4]   = 8'b0 ;  //clear_avmute 
+    //tmp_add_data[3]   = 8'b1 ;  //hdcp_1_1 
+    //tmp_add_data[2]   = 8'b0 ;  //forced_polarity 
+    //tmp_add_data[1]   = 8'b0 ;  //forced_vsync_polarity 
+    //tmp_add_data[0]   = 8'b0 ;  //forced_hsync_polarity
+    tmp_add_data = 0x40;
+    hdmi_wr_reg(TX_HDCP_MODE, (hdmi_rd_reg(TX_HDCP_MODE) | tmp_add_data)&0xf0);
+
+    if(param->cc == CC_ITU709){
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_B0, 0x7b);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_B1, 0x12);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_R0, 0x6c);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_R1, 0x36);
+
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CB0, 0xf2);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CB1, 0x2f);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR0, 0xd4);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR1, 0x77);
+    }
+    else{
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_B0, 0x2f);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_B1, 0x1d);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_R0, 0x8b);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_R1, 0x4c);
+
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CB0, 0x18);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CB1, 0x58);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR0, 0xd0);
+        hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR1, 0xb6);
+    }    
+
+    hdmi_hw_set_powermode(hdmitx_device);
+    
+    // --------------------------------------------------------
+    // Release TX out of reset
+    // --------------------------------------------------------
+    if(new_reset_sequence_flag){
+        //new reset sequence, 2010Sep09, rain
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
+        delay_us(10);
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
+        delay_us(10);
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
+        delay_us(10);
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
+        delay_us(10);
+        /* select serial*/
+        if(serial_reg_val==0){
+            if((param->VIC==HDMI_1080p30)||(param->VIC==HDMI_720p60)||(param->VIC==HDMI_1080i60)
+                ||(param->VIC==HDMI_1080p24)){
+                hdmi_wr_reg(0x018, 0x22);   
+            }
+            else{
+                hdmi_wr_reg(0x018, 0x24);   
+            }
+        }
+        else if(serial_reg_val==1){
+            if((param->VIC==HDMI_480p60)||(param->VIC==HDMI_480p60_16x9)
+                ||(param->VIC==HDMI_576p50)||(param->VIC==HDMI_576p50_16x9)
+                ||(param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)
+                ||(param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
+                hdmi_wr_reg(0x018, 0x24);   
+            }
+            else{
+                hdmi_wr_reg(0x018, 0x22);   
+            }
+        }
+        else{
+            hdmi_wr_reg(0x018, serial_reg_val);
+        }
+        if((param->VIC==HDMI_1080p60)&&(param->color_depth==COLOR_30BIT)&&(hdmi_rd_reg(0x018)==0x22)){
+            hdmi_wr_reg(0x018,0x12);
+        }
+        
+    }
+    else{
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x01); // Release serializer resets
+        delay_us(10);
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00); // Release reset on TX digital clock channel
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
+        delay_us(10);
+    
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
+        
+        tmp_add_data = hdmi_rd_reg(0x018);
+        if((tmp_add_data==0x22)||(tmp_add_data==0x12)){
+            hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x08);        
+            delay_us(10);
+            hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);        
+        }
+    }
+    if(param->VIC == HDMI_1080p50) {
+        hdmi_reconfig_packet_setting();  // For 1080p50hz only
+    }
+}
+
+static void hdmi_audio_init(unsigned char spdif_flag)
+{
+    unsigned tmp_add_data;
+
+    /* If TX_AUDIO_FORMAT is set as 0, "Channel Status" will not be sent out correctly */
+    /* TX_AUDIO_CONTROL[bit 0] should be 1, otherwise no sound??? */
+    unsigned char tx_i2s_spdif;
+    unsigned char tx_i2s_8_channel;
+    
+    hdmi_print(IMP, AUD "%s", spdif_flag ? "SPDIF" : "I2S");
+    
+    if(spdif_flag){
+        tx_i2s_spdif=0;
+    }
+    else{
+        tx_i2s_spdif=1;
+    }
+    tx_i2s_8_channel = ((i2s_to_spdif_flag == 1)? 0:1 );
+
+    tmp_add_data  = 0;
+    tmp_add_data |= tx_i2s_spdif    << 7; // [7]    I2S or SPDIF
+    tmp_add_data |= tx_i2s_8_channel<< 6; // [6]    8 or 2ch
+    tmp_add_data |= 2               << 4; // [5:4]  Serial Format: I2S format
+    tmp_add_data |= 3               << 2; // [3:2]  Bit Width: 24-bit
+    tmp_add_data |= 0               << 1; // [1]    WS Polarity: 0=WS high is right
+    tmp_add_data |= 1               << 0; // [0]    For I2S: 0=one-bit audio; 1=I2S;
+                                          //        For SPDIF: 0= channel status from input data; 1=from register
+    hdmi_wr_reg(TX_AUDIO_FORMAT, tmp_add_data); // 0x2f
+
+    //tmp_add_data  = 0;
+    //tmp_add_data |= 0x4 << 4; // [7:4]  FIFO Depth=512
+    //tmp_add_data |= 0x2 << 2; // [3:2]  Critical threshold=Depth/16
+    //tmp_add_data |= 0x1 << 0; // [1:0]  Normal threshold=Depth/8
+    //hdmi_wr_reg(TX_AUDIO_FIFO, tmp_add_data); // 0x49
+    hdmi_wr_reg(TX_AUDIO_FIFO, aud_para); // 0x49
+
+    hdmi_wr_reg(TX_AUDIO_LIPSYNC, 0); // [7:0] Normalized lip-sync param: 0 means S(lipsync) = S(total)/2
+
+    tmp_add_data  = 0;
+    tmp_add_data |= 0   << 7; // [7]    forced_audio_fifo_clear
+    tmp_add_data |= 1   << 6; // [6]    auto_audio_fifo_clear
+    tmp_add_data |= 0x0 << 4; // [5:4]  audio_packet_type: 0=audio sample packet; 1=one bit audio; 2=HBR audio packet; 3=DST audio packet.
+    tmp_add_data |= 0   << 3; // [3]    Rsrv
+    tmp_add_data |= 0   << 2; // [2]    Audio sample packet's valid bit: 0=valid bit is 0 for I2S, is input data for SPDIF; 1=valid bit from register
+    tmp_add_data |= 0   << 1; // [1]    Audio sample packet's user bit: 0=user bit is 0 for I2S, is input data for SPDIF; 1=user bit from register
+    tmp_add_data |= 0   << 0; // [0]    0=Audio sample packet's sample_flat bit is 1; 1=sample_flat is 0.
+    hdmi_wr_reg(TX_AUDIO_CONTROL, tmp_add_data); // 0x40
+
+    tmp_add_data  = 0;
+    tmp_add_data |= tx_i2s_8_channel<< 7; // [7]    Audio sample packet's header layout bit: 0=layout0; 1=layout1
+    tmp_add_data |= 0               << 6; // [6]    Set normal_double bit in DST packet header.
+    tmp_add_data |= 0               << 0; // [5:0]  Rsrv
+    hdmi_wr_reg(TX_AUDIO_HEADER, tmp_add_data); // 0x00
+
+    tmp_add_data  = tx_i2s_8_channel ? 0xff : 0x03;
+    hdmi_wr_reg(TX_AUDIO_SAMPLE, tmp_add_data); // Channel valid for up to 8 channels, 1 bit per channel.
+
+    hdmi_wr_reg(TX_AUDIO_PACK, 0x01); // Enable audio sample packets
+
+    // Set N = 4096 (N is not measured, N must be configured so as to be a reference to clock_meter)
+    hdmi_wr_reg(TX_SYS1_ACR_N_0, 0x00); // N[7:0]
+    hdmi_wr_reg(TX_SYS1_ACR_N_1, 0x18 /*0x10*/); // N[15:8]
+
+    tmp_add_data  = 0;
+    tmp_add_data |= 0xa << 4;    // [7:4] Meas Tolerance
+    tmp_add_data |= 0x0 << 0;    // [3:0] N[19:16]
+    hdmi_wr_reg(TX_SYS1_ACR_N_2, tmp_add_data); // 0xa0
+
+    hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1); 
+}
+
+static void enable_audio_spdif(void)
+{
+    hdmi_print(INF, AUD "Enable audio spdif to HDMI\n");
+
+    /* enable audio*/        
+    hdmi_wr_reg(TX_AUDIO_I2S,   0x0 );  // Address  0x5A=0x0    TX_AUDIO_I2S
+
+    hdmi_wr_reg(TX_AUDIO_SPDIF, 1); // TX AUDIO SPDIF Enable
+}
+
+static void enable_audio_i2s(void)
+{
+    hdmi_print(INF, AUD "Enable audio i2s to HDMI\n");
+    hdmi_wr_reg(TX_AUDIO_I2S,   0x1 );  // Address  0x5A=0x0    TX_AUDIO_I2S
+    hdmi_wr_reg(TX_AUDIO_SPDIF, 0); // TX AUDIO SPDIF Enable
+}    
+
+/************************************
+*    hdmitx hardware level interface
+*************************************/
+
+static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag) 
+{
+    int i,j;
+    for(i=0;hdmi_tvenc_configs[i].vic!=HDMI_Unkown;i++){
+        if(cur_VIC==hdmi_tvenc_configs[i].vic){
+            reg_t* reg_set=hdmi_tvenc_configs[i].reg_set;
+            hdmi_print(printk_flag, "------dump tevenc reg for mode %d----\n", cur_VIC);
+            for(j=0;reg_set[j].reg;j++){
+                hdmi_print(printk_flag, "[%08x]=%08x\n",reg_set[j].reg,aml_read_reg32(CBUS_REG_ADDR(reg_set[j].reg)));
+            }
+            hdmi_print(printk_flag, "------------------\n");
+            break;
+        }
+    }
+}    
+
+static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
+{
+    int i,j;
+    for(i=0;hdmi_tvenc_configs[i].vic!=HDMI_Unkown;i++){
+        if(vic==hdmi_tvenc_configs[i].vic){
+            reg_t* reg_set=hdmi_tvenc_configs[i].reg_set;
+            for(j=0;reg_set[j].reg;j++){
+                if(reg_set[j].reg==reg){
+                    reg_set[j].val = val;    
+                    hdmi_print(INF, SYS "set [%08x]=%08x\n",reg_set[j].reg, reg_set[j].val);
+                    break;
+                }
+            }
+            if(reg_set[j].reg == 0){
+                hdmi_print(INF, SYS "no [%08x] in config\n", reg);
+            }
+            break;
+        }
+    }
+}
+
+static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
+{
+    hdmi_print(IMP, SYS "set pll\n");
+    hdmi_print(IMP, SYS "param->VIC:%d\n", param->VIC);
+    
+    cur_vout_index = get_cur_vout_index();
+    M6_PLL_RESET(P_HHI_VID_PLL_CNTL);
+    aml_write_reg32(P_HHI_VID_PLL_CNTL2, M6_VID_PLL_CNTL_2 );
+    aml_write_reg32(P_HHI_VID_PLL_CNTL3, M6_VID_PLL_CNTL_3 );
+    aml_write_reg32(P_HHI_VID_PLL_CNTL4, M6_VID_PLL_CNTL_4 );
+    switch(param->VIC)
+    {
+        case HDMI_480p60:
+        case HDMI_480p60_16x9:
+            set_vmode_clk(VMODE_480P);
+            break;
+        case HDMI_576p50:
+        case HDMI_576p50_16x9:
+            set_vmode_clk(VMODE_576P);
+            break;
+        case HDMI_480i60:
+        case HDMI_480i60_16x9:
+            set_vmode_clk(VMODE_480I);
+            break;
+        case HDMI_576i50:
+        case HDMI_576i50_16x9:
+            set_vmode_clk(VMODE_576I);
+            break;
+        case HDMI_1080p24://1080p24 support
+            set_vmode_clk(VMODE_1080P_24HZ);
+            break;
+        case HDMI_1080p30:
+
+        case HDMI_720p60:
+        case HDMI_720p50:
+            set_vmode_clk(VMODE_720P);
+            break;
+        case HDMI_1080i60:
+        case HDMI_1080i50:
+            set_vmode_clk(VMODE_1080I);
+            break;
+        case HDMI_1080p60:
+        case HDMI_1080p50:
+            set_vmode_clk(VMODE_1080P);
+            break;
+        case HDMI_4k2k_30:
+        case HDMI_4k2k_25:
+        case HDMI_4k2k_24:
+        case HDMI_4k2k_smpte_24:
+            set_vmode_clk(VMODE_4K2K_24HZ);
+        default:
+            break;
+    }
+    // Reset the exact pll for 148.5 and 74.25 MHz
+    // if we find that current VCO outputs 1488,
+    // then we will set to 1485, equals to 24MHz * 495 / 8, 
+    // to get exactly clock for 720/1080 mode
+    if((aml_read_reg32(P_HHI_VID_PLL_CNTL) & 0x3fff ) == 0x43e) {
+        aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x21ef, 0, 15);
+    }
+    M6_PLL_WAIT_FOR_LOCK(P_HHI_VID_PLL_CNTL);
+}
+
+static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *param)
+{
+    if(param == NULL){ //disable HDMI
+        return 0;
+    }
+    else if((param->VIC!=HDMI_480p60)&&(param->VIC!=HDMI_480p60_16x9)
+        &&(param->VIC!=HDMI_576p50)&&(param->VIC!=HDMI_576p50_16x9)
+        &&(param->VIC!=HDMI_480i60)&&(param->VIC!=HDMI_480i60_16x9)
+        &&(param->VIC!=HDMI_576i50)&&(param->VIC!=HDMI_576i50_16x9)
+        &&(param->VIC!=HDMI_1080p30)
+        &&(param->VIC!=HDMI_1080p24)
+        &&(param->VIC!=HDMI_1080p60)&&(param->VIC!=HDMI_1080p50)
+        &&(param->VIC!=HDMI_720p60)&&(param->VIC!=HDMI_720p50)
+        &&(param->VIC!=HDMI_4k2k_30)&&(param->VIC!=HDMI_4k2k_25)&&(param->VIC!=HDMI_4k2k_24)&&(param->VIC!=HDMI_4k2k_smpte_24)
+        &&(param->VIC!=HDMI_1080i60)&&(param->VIC!=HDMI_1080i50)){
+        return -1;
+    }
+
+    if(color_depth_f==24)
+        param->color_depth = COLOR_24BIT;
+    else if(color_depth_f==30)
+        param->color_depth = COLOR_30BIT;
+    else if(color_depth_f==36)
+        param->color_depth = COLOR_36BIT;
+    else if(color_depth_f==48)
+        param->color_depth = COLOR_48BIT;
+    hdmi_print(1,"set mode VIC %d (cd%d,cs%d,pm%d,vd%d,%x) \n",param->VIC, color_depth_f, color_space_f,power_mode,power_off_vdac_flag,serial_reg_val);
+    if(color_space_f != 0){
+        param->color = color_space_f;
+    }
+
+    hdmi_hw_reset(hdmitx_device, param);    
+    hdmitx_set_pll(param);
+
+    if((param->VIC==HDMI_720p60)||(param->VIC==HDMI_720p50)||
+        (param->VIC==HDMI_1080i60)||(param->VIC==HDMI_1080i50)){
+        aml_write_reg32(P_ENCP_VIDEO_HAVON_BEGIN,  aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN)-1);     
+        aml_write_reg32(P_ENCP_VIDEO_HAVON_END,  aml_read_reg32(P_ENCP_VIDEO_HAVON_END)-1);     
+    }
+
+    switch(param->VIC){
+        case HDMI_480i60:
+        case HDMI_480i60_16x9:
+        case HDMI_576i50:
+        case HDMI_576i50_16x9:
+            hdmi_tvenc480i_set(param);
+            break;
+        case HDMI_1080i60:
+        case HDMI_1080i50:
+            hdmi_tvenc1080i_set(param);
+            break;
+        default:
+            hdmi_tvenc_set(param);
+        }
+    hdmitx_dump_tvenc_reg(param->VIC, 0);
+
+//todo     hdmitx_special_handler_video(hdmitx_device);
+
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xdc);
+    // reset TX_SYS5_TX_SOFT_RESET_1/2 twice
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x9f);
+    mdelay(5);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
+    mdelay(5);
+
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x9f);
+    mdelay(5);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
+    mdelay(5);
+
+    // power comsumption
+#ifdef CONFIG_MESON_POWER_PROFILE_LOW
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xf0);
+#else
+    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xfe);
+#endif
+    
+    return 0;
+}    
+
+
+static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
+{
+    // AVI frame
+    int i ;
+    unsigned char ucData ;
+    unsigned int pkt_reg_base=TX_PKT_REG_AVI_INFO_BASE_ADDR;
+    int pkt_data_len=0;
+    
+    switch(type)
+    {
+        case HDMI_PACKET_AVI:
+            pkt_reg_base=TX_PKT_REG_AVI_INFO_BASE_ADDR; 
+            pkt_data_len=13;
+            break;
+        case HDMI_PACKET_VEND:
+            pkt_reg_base=TX_PKT_REG_VEND_INFO_BASE_ADDR;
+            pkt_data_len=6;
+            break;
+        case HDMI_AUDIO_INFO:
+            pkt_reg_base=TX_PKT_REG_AUDIO_INFO_BASE_ADDR;
+            pkt_data_len=9;
+            break;
+        case HDMI_SOURCE_DESCRIPTION:
+            pkt_reg_base=TX_PKT_REG_SPD_INFO_BASE_ADDR;
+            pkt_data_len=25;
+        default:
+            break;
+    }
+    
+    if(DB){
+        for(i=0;i<pkt_data_len;i++){
+            hdmi_wr_reg(pkt_reg_base+i+1, DB[i]);  
+        }
+    
+        for(i = 0,ucData = 0; i < pkt_data_len ; i++)
+        {
+            ucData -= DB[i] ;
+        }
+        for(i=0; i<3; i++){
+            ucData -= HB[i];
+        }
+        hdmi_wr_reg(pkt_reg_base+0x00, ucData);  
+    
+        hdmi_wr_reg(pkt_reg_base+0x1C, HB[0]);        
+        hdmi_wr_reg(pkt_reg_base+0x1D, HB[1]);        
+        hdmi_wr_reg(pkt_reg_base+0x1E, HB[2]);        
+        hdmi_wr_reg(pkt_reg_base+0x1F, 0x00ff);        // Enable packet generation
+    }
+    else{
+        hdmi_wr_reg(pkt_reg_base+0x1F, 0x0);        // disable packet generation
+    }
+}
+
+
+static void hdmitx_setaudioinfoframe(unsigned char* AUD_DB, unsigned char* CHAN_STAT_BUF)
+{
+    int i ;
+    unsigned char AUD_HB[3]={0x84, 0x1, 0xa};
+    hdmitx_set_packet(HDMI_AUDIO_INFO, AUD_DB, AUD_HB);    
+    //channel status
+    if(CHAN_STAT_BUF){
+        for(i=0;i<24;i++){
+            hdmi_wr_reg(TX_IEC60958_SUB1_OFFSET+i, CHAN_STAT_BUF[i]);        
+            hdmi_wr_reg(TX_IEC60958_SUB2_OFFSET+i, CHAN_STAT_BUF[24+i]);
+        }
+    }
+}
+
+
+//------------------------------------------------------------------------------
+// set_hdmi_audio_source(unsigned int src)
+//
+// Description:
+// Select HDMI audio clock source, and I2S input data source.
+//
+// Parameters:
+//  src -- 0=no audio clock to HDMI; 1=pcmout to HDMI; 2=Aiu I2S out to HDMI.
+//------------------------------------------------------------------------------
+static void set_hdmi_audio_source(unsigned int src)
+{
+    unsigned long data32;
+    unsigned int i;
+
+    // Disable HDMI audio clock input and its I2S input
+    data32  = 0;
+    data32 |= 0     << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= 0     << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+//    Wr(AIU_HDMI_CLK_DATA_CTRL, data32);
+    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+
+    switch(src)
+    {
+        case 0:
+            hdmi_print(ERR, AUD "No audio clock to HDMI\n");
+            break;
+        case 1:
+            hdmi_print(IMP, AUD "PCM out to HDMI\n");//SPDIF
+            // Enable HDMI audio clock from the selected source
+            data32  = 0;
+            data32 |= 0      << 4;  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+            data32 |= 2      << 0;  // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+            aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+
+            // Wait until clock change is settled
+            i = 0;
+            while ( (((aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL))>>8)&0x3) != 0x2 ) {
+            //    if (i > 255) {
+            //        //stimulus_print("[TEST.C] Error: set_hdmi_audio_source timeout!\n");
+            //        //stimulus_finish_fail(10);
+            //    }
+                i ++;
+                if(i>100000)
+                    break;
+            }
+            if(i>100000)
+                hdmi_print(ERR, AUD "Time out: AIU_HDMI_CLK_DATA_CTRL\n");
+           break;
+        case 2:
+            hdmi_print(INF, AUD "I2S out to HDMI\n");//I2S
+            // Enable HDMI audio clock from the selected source
+            data32  = 0;
+            data32 |= 0      << 4;  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+            data32 |= 2      << 0;  // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+            aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+
+            // Wait until clock change is settled
+            i = 0;
+            while ( (((aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL))>>8)&0x3) != 0x2 ) {
+            //    if (i > 255) {
+            //        //stimulus_print("[TEST.C] Error: set_hdmi_audio_source timeout!\n");
+            //        //stimulus_finish_fail(10);
+            //    }
+                i ++;
+                if(i>100000)
+                    break;
+            }
+            if(i>100000)
+            hdmi_print(ERR, AUD "Time out: AIU_HDMI_CLK_DATA_CTRL !\n");
+            // Enable HDMI I2S input from the selected source
+            data32  = 0;
+            data32 |= 2   << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+            data32 |= 2   << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+            aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+
+            // Wait until data change is settled
+            i = 0;
+            while ((((aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL))>>12)&0x3) != 0x2 ) {
+                i++;
+                if(i>100000)
+                    break;
+            }
+            if(i>100000)
+                hdmi_print(ERR, AUD "Time out: AIU_HDMI_CLK_DATA_CTRL...\n");
+            break;
+        default:
+            hdmi_print(ERR, AUD "Audio Src clock to HDMI Error\n");
+            break;
+    }
+} /* set_hdmi_audio_source */
+
+static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio_para_t* audio_param)
+{
+    unsigned int audio_N_para = 6272;
+    unsigned int audio_N_tolerance = 3;
+//    unsigned int audio_CTS = 30000;
+    
+    hdmi_print(INF, AUD "audio channel num is %d\n", hdmitx_device->cur_audio_param.channel_num);
+
+    if(!hdmi_audio_off_flag){
+        hdmi_audio_init(i2s_to_spdif_flag);
+    }
+    else {
+        hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // disable audio sample packets
+    }
+
+//Refer to HDMI SPEC V1.4 Page 137
+    hdmi_print(INF, AUD "current VIC: %d\n", hdmitx_device->cur_VIC);
+    hdmi_print(INF, AUD "audio sample rate: %d\n", audio_param->sample_rate);
+    switch(hdmitx_device->cur_VIC)
+    {
+        //TMDS Clock:27MHz
+        case HDMI_480p60:
+        case HDMI_480p60_16x9:
+        case HDMI_576p50:
+        case HDMI_576p50_16x9:
+        case HDMI_480i60:
+        case HDMI_480i60_16x9:
+        case HDMI_576i50:
+        case HDMI_576i50_16x9:
+            switch(audio_param->sample_rate)
+            {
+                case FS_32K:
+                    audio_N_para = 4096;
+                    break;
+                case FS_44K1:
+                    audio_N_para = 6272;
+                    break;
+                case FS_88K2:
+                    audio_N_para = 12544;
+                    break;
+                case FS_176K4:
+                    audio_N_para = 25088;
+                    break;
+                case FS_48K:
+                    audio_N_para = 6144;
+                    break;
+                case FS_96K:
+                    audio_N_para = 12288;
+                    break;
+                case FS_192K:
+                    audio_N_para = 24576;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        //TMDS Clock:74.176MHz
+        case HDMI_720p60:
+        case HDMI_720p50:
+        case HDMI_1080i60:
+        case HDMI_1080i50:
+        case HDMI_1080p30:
+        case HDMI_1080p24:
+            switch(audio_param->sample_rate)
+            {
+                case FS_32K:
+                    audio_N_para = 4096;
+                    break;
+                case FS_44K1:
+                    audio_N_para = 6272;
+                    break;
+                case FS_88K2:
+                    audio_N_para = 12544;
+                    break;
+                case FS_176K4:
+                    audio_N_para = 25088;
+                    break;
+                case FS_48K:
+                    audio_N_para = 6144;
+                    break;
+                case FS_96K:
+                    audio_N_para = 12288;
+                    break;
+                case FS_192K:
+                    audio_N_para = 24576;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        //TMDS Clock:148.5MHz
+        case HDMI_1080p50:
+        case HDMI_1080p60:
+            switch(audio_param->sample_rate)
+            {
+                case FS_32K:
+                    audio_N_para = 4096;
+                    break;
+                case FS_44K1:
+                    audio_N_para = 6272;
+                    break;
+                case FS_88K2:
+                    audio_N_para = 12544;
+                    break;
+                case FS_176K4:
+                    audio_N_para = 25088;
+                    break;
+                case FS_48K:
+                    audio_N_para = 6144;
+                    break;
+                case FS_96K:
+                    audio_N_para = 12288;
+                    break;
+                case FS_192K:
+                    audio_N_para = 24576;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        default:
+            break;
+    }    
+
+    hdmi_print(INF, AUD "reset audio N para\n");
+    switch(audio_param->sample_rate){
+        case FS_44K1:
+            audio_N_para = 6272 * 2;
+            break;
+        case FS_48K:
+            audio_N_para = 6144 * 2;
+            break;
+        default:
+            break;
+    }
+
+    //TODO. Different audio type, maybe have different settings
+    switch(audio_param->type){
+        case CT_PCM:
+            break;
+        case CT_AC_3:
+            break;
+        case CT_MPEG1:
+            break;
+        case CT_MP3:
+            break;
+        case CT_MPEG2:
+            break;
+        case CT_AAC:
+            break;
+        case CT_DTS:
+            break;
+        case CT_ATRAC:
+            break;
+        case CT_ONE_BIT_AUDIO:
+            break;
+        case CT_DOLBY_D:
+            audio_N_para *= 4;
+            break;
+        case CT_DTS_HD:
+            break;
+        case CT_MAT:
+            break;
+        case CT_DST:
+            break;
+        case CT_WMA:
+            break;
+        default:
+            break;
+    }
+
+    hdmi_wr_reg(TX_SYS1_ACR_N_0, (audio_N_para&0xff)); // N[7:0]
+    hdmi_wr_reg(TX_SYS1_ACR_N_1, (audio_N_para>>8)&0xff); // N[15:8]
+    hdmi_wr_reg(TX_SYS1_ACR_N_2, (audio_N_tolerance<<4)|((audio_N_para>>16)&0xf)); // N[19:16]
+    hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1); 
+
+    hdmi_wr_reg(TX_SYS0_ACR_CTS_0, 0);      //audio_CTS & 0xff);
+    hdmi_wr_reg(TX_SYS0_ACR_CTS_1, 0);      //(audio_CTS>>8) & 0xff);
+    hdmi_wr_reg(TX_SYS0_ACR_CTS_2, 1 << 5);      // set bit[5] force_arc_stable to 1
+    
+    set_hdmi_audio_source(i2s_to_spdif_flag ? 1 : 2);
+    
+    hdmi_print(INF, AUD "i2s_to_spdif_flag:%d \n", i2s_to_spdif_flag);
+    if(i2s_to_spdif_flag)
+        enable_audio_spdif();
+    else
+        enable_audio_i2s();
+
+    if((i2s_to_spdif_flag == 1) && (hdmitx_device->cur_audio_param.type != CT_PCM)) {
+        hdmi_wr_reg(TX_AUDIO_FORMAT, (hdmi_rd_reg(TX_AUDIO_FORMAT) & 0xfe));        // clear bit0, use channel status bit from input data
+    }
+
+//todo    hdmitx_special_handler_audio(hdmitx_device);
+
+    return 0;
+}    
+    
+static void hdmitx_setupirq(hdmitx_dev_t* hdmitx_device)
+{
+   int r;
+   r = request_irq(INT_HDMI_TX, &intr_handler,
+                    IRQF_SHARED, "amhdmitx",
+                    (void *)hdmitx_device);
+}    
+
+
+#if 1
+
+//Expect 8*10-Bit shift pattern data:
+//
+//0x2e3   = 1011100011
+//0x245   = 1001000101
+//0x1cb   = 0111001011
+//0x225   = 1000100101
+//0x2da   = 1011011010
+//0x3e0   = 1111100000
+//0x367   = 1101100111
+//0x000   = 0000000000
+
+static void turn_on_shift_pattern (void)
+{
+    unsigned int tmp_add_data;
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_0, 0x00);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_1, 0x6c);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_2, 0xfe);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_3, 0x41);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_4, 0x5b);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_5, 0x91);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_6, 0x3a);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_7, 0x9d);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_8, 0x68);
+    hdmi_wr_reg(TX_SYS0_BIST_DATA_9, 0xc7);
+
+    //tmp_add_data[7:6] = 2'b0;     // audio_source_select[1:0]
+    //tmp_add_data[5] = 1'b0;       // external_packet_enable
+    //tmp_add_data[4] = 1'b1 ;      // internal_packet_enable
+    //tmp_add_data[3:2] = 2'b0;     // afe_fifo_source_select_lane_1[1:0]
+    //tmp_add_data[1:0] = 2'd3 ;    // afe_fifo_source_select_lane_0[1:0] : 0=data path; 1=injected on lane 0; 2=inject on lane 1; 3=BIST.
+    tmp_add_data = 0x13;
+    hdmi_wr_reg(TX_CORE_DATA_CAPTURE_2, tmp_add_data);
+
+    hdmi_wr_reg(TX_SYS0_BIST_CONTROL, 0x00); // Reset BIST
+    hdmi_wr_reg(TX_SYS0_BIST_CONTROL, 0xc0); // Enable shift pattern BIST
+}
+
+static void turn_off_shift_pattern (void)
+{
+    unsigned int tmp_add_data;
+    hdmi_wr_reg(TX_SYS0_BIST_CONTROL, 0x00); // Reset BIST
+
+    //tmp_add_data[7:6] = 2'b0;     // audio_source_select[1:0]
+    //tmp_add_data[5] = 1'b0;       // external_packet_enable
+    //tmp_add_data[4] = 1'b1 ;      // internal_packet_enable
+    //tmp_add_data[3:2] = 2'b0;     // afe_fifo_source_select_lane_1[1:0]
+    //tmp_add_data[1:0] = 2'd0 ;    // afe_fifo_source_select_lane_0[1:0] : 0=data path; 1=injected on lane 0; 2=inject on lane 1; 3=BIST.
+    tmp_add_data = 0x10;
+    hdmi_wr_reg(TX_CORE_DATA_CAPTURE_2, tmp_add_data);
+}
+
+static void turn_on_prbs_mode(int prbs_mode)
+{
+    unsigned int tmp_add_data;
+   tmp_add_data     = 0;
+    tmp_add_data    |= 0    << 6;   // [7:6] audio_source_select[1:0]
+    tmp_add_data    |= 0    << 5;   //   [5] external_packet_enable
+    tmp_add_data    |= 0    << 4;   //   [4] internal_packet_enable
+    tmp_add_data    |= 0    << 2;   // [3:2] afe_fifo_source_select_lane_1[1:0]: 0=DATA_PATH; 1=TMDS_LANE_0; 2=TMDS_LANE_1; 3=BIST_PATTERN
+    tmp_add_data    |= 3    << 0;   // [1:0] afe_fifo_source_select_lane_0[1:0]: 0=DATA_PATH; 1=TMDS_LANE_0; 2=TMDS_LANE_1; 3=BIST_PATTERN
+    hdmi_wr_reg(TX_CORE_DATA_CAPTURE_2, tmp_add_data); // 0x03
+
+    tmp_add_data     = 0;
+    tmp_add_data    |= 0    << 7;   //   [7] monitor_lane_1
+    tmp_add_data    |= 0    << 4;   // [6:4] monitor_select_lane_1[2:0]
+    tmp_add_data    |= 1    << 3;   //   [3] monitor_lane_0
+    tmp_add_data    |= 7    << 0;   // [2:0] monitor_select_lane_0[2:0]: 7=TMDS_ENCODE
+    hdmi_wr_reg(TX_CORE_DATA_MONITOR_1, tmp_add_data); // 0x0f
+
+    // Program PRBS_MODE
+    hdmi_wr_reg(TX_SYS1_PRBS_DATA, prbs_mode); // 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31.
+    // Program PRBS BIST
+
+    tmp_add_data     = 0;
+    tmp_add_data    |= 1    << 7;   //   [7] afe_bist_enable
+    tmp_add_data    |= 0    << 6;   //   [6] tmds_shift_pattern_select
+    tmp_add_data    |= 3    << 4;   // [5:4] tmds_prbs_pattern_select[1:0]:
+                                    //       0=output all 0; 1=output 8-bit pattern;
+                                    //       2=output 1-bit differential pattern; 3=output 10-bit pattern
+    tmp_add_data    |= 0    << 3;   //   [3] Rsrv
+    tmp_add_data    |= 0    << 0;   // [2:0] tmds_repeat_bist_pattern[2:0]
+    hdmi_wr_reg(TX_SYS0_BIST_CONTROL, tmp_add_data); // 0xb0
+
+    hdmi_print(INF, SYS "PRBS mode %d On\n", prbs_mode);
+}
+    
+#endif
+
+static void hdmitx_uninit(hdmitx_dev_t* hdmitx_device)
+{
+    //aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR);
+    //aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK)&(~(1 << 25)));
+    free_irq(INT_HDMI_TX, (void *)hdmitx_device);
+    hdmi_print(1,"power off hdmi, unmux hpd\n");
+    
+    phy_pll_off();
+    digital_clk_off(7); //off sys clk
+    unmux_hpd();
+}    
+
+static char hdcp_log_buf[HDMITX_HDCP_MONITOR_BUF_SIZE] = { 0 };
+const static hdcp_sub_t hdcp_monitor_array[] = {
+    {"Aksv_shw", TX_HDCP_SHW_AKSV_0, 5},
+    {"Aksv_ram", 0x540, 5},
+    {"Bksv    ", TX_HDCP_SHW_BKSV_0, 5},
+    {"Ainfo   ", TX_HDCP_SHW_AINFO , 1},
+    {"An      ", TX_HDCP_SHW_AN_0 ,  8},
+    {"Bcaps   ", TX_HDCP_SHW_BCAPS,  1},
+    {"Bstatus ", TX_HDCP_SHW_BSTATUS_0, 2},
+    {"Km      ", 0x148,              7},
+    {"Ri      ", 0x150,              2},
+    {"Ri'     ", TX_HDCP_SHW_RI1_0 , 2},
+    {"Pj      ", 0x14f,              1},
+    {"Pj'     ", TX_HDCP_SHW_PJ1   , 1},
+    {"AuthSt  ", TX_HDCP_ST_AUTHENTICATION, 1},
+    {"EncrySt0", TX_HDCP_ST_STATUS_0, 1},
+    {"EncrySt1", TX_HDCP_ST_STATUS_1, 1},
+    {"EncrySt2", TX_HDCP_ST_STATUS_2, 1},
+    {"EncrySt3", TX_HDCP_ST_STATUS_3, 1},
+    {"FramCnt ", TX_HDCP_ST_FRAME_COUNT, 1},
+    {"EDIDStat", TX_HDCP_ST_EDID_STATUS, 1},
+    {"MEMStat ", TX_HDCP_ST_MEM_STATUS, 1},
+    {"EDID_Ext", 0x198, 1},
+    {"EDDC_SEG", 0x199, 1},
+    {"EDDC_ST ", 0x19a, 1},
+    {"HDCP_RSV", 0x19b, 4},
+    {"EDDC_SEG", 0x19c, 1},
+    {"HDCPMODE", TX_HDCP_ST_ST_MODE, 1},
+    {"TmdsMod ", TX_TMDS_MODE, 1},
+};
+
+static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(cmd == HDMITX_AVMUTE_CNTL) {
+        if(argv == AVMUTE_SET) {
+            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)&(~(1<<4)));
+            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)|(1<<5));
+        }
+        if(argv == AVMUTE_CLEAR) {
+            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)&(~(1<<5)));
+            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)|(1<<4));
+        }
+        if(argv == AVMUTE_OFF) {
+            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)&(~(1<<4)));
+            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)&(~(1<<5)));
+        }
+        return 0;
+    }
+    else if(cmd == HDMITX_SW_INTERNAL_HPD_TRIG){
+        if(argv == 1)   // soft trig rising
+            hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_INTR_STAT, 1);
+        else            // soft trig falling
+            hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_INTR_STAT, 2);
+    }
+    else if(cmd == HDMITX_EARLY_SUSPEND_RESUME_CNTL) {
+        if(argv == HDMITX_EARLY_SUSPEND) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);
+            hdmi_phy_suspend();
+        }
+        if(argv == HDMITX_LATE_RESUME) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);
+            hdmi_phy_wakeup();
+        }
+        return 0;
+    }
+    else if(cmd == HDMITX_HDCP_MONITOR) {
+        int i, len, st;
+        int array = sizeof(hdcp_monitor_array) / sizeof(hdcp_sub_t);
+
+        int pos;
+
+        if(!(hdmitx_device->log & HDMI_LOG_HDCP))
+            return 0;
+
+        memset(hdcp_log_buf, 0, HDMITX_HDCP_MONITOR_BUF_SIZE);
+        hdmi_print(INF, HDCP "\n\nMonitor HDCP start\n");
+        pos = 0;
+        for(i = 0; i < array; i ++){
+            len = hdcp_monitor_array[i].hdcp_sub_len;
+            st  = hdcp_monitor_array[i].hdcp_sub_addr_start;
+            pos += sprintf(hdcp_log_buf + pos, "   %s: ", hdcp_monitor_array[i].hdcp_sub_name);
+            do {
+                pos += sprintf(hdcp_log_buf + pos, "%02x", (unsigned)hdmi_rd_reg(st+len-1));
+            }while(--len);
+            pos += sprintf(hdcp_log_buf + pos, "\n");
+        }
+        pos += sprintf(hdcp_log_buf + pos, "HDCP %s",
+                                            ((hdmi_rd_reg(TX_HDCP_ST_STATUS_3)&0xa0)==0xa0)
+                                            ? "OK\n" : "BAD\n"
+                       );
+        printk("%s", hdcp_log_buf);
+        hdmi_print(INF, HDCP "Monitor HDCP end\n");
+        return 0;
+    }
+    else if(cmd == HDMITX_IP_SW_RST){
+        return 0;    //TODO
+        aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
+        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0, hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0) | (argv));
+        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0, hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0) & (~(argv)));
+        aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)&(~(1<<16)));
+        hdmi_print(INF, SYS "reset IP: 0x%x\n", argv);
+        return 0;
+    }
+    else if(cmd == HDMITX_CBUS_RST) {
+        return 0;//todo
+        aml_set_reg32_bits(P_RESET2_REGISTER, 1, 15, 1);
+        msleep(50);
+        hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_INTR_STAT_CLR, 0x7);
+        return 0;
+    }
+    else if(cmd == HDMITX_INTR_MASKN_CNTL) {
+        if(argv == INTR_MASKN_ENABLE) {
+            hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_INTR_MASKN, 0);
+        }
+        if(argv == INTR_MASKN_DISABLE) {
+            hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_INTR_MASKN, 0x7);
+        }
+        if(argv == INTR_CLEAR) {
+            hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0x7);
+        }
+        return 0;
+    }
+    else if(cmd == HDMITX_IP_INTR_MASN_RST){
+        hdmi_print(INF, SYS "reset intr mask\n");
+        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0);
+        msleep(2);
+        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0x7);
+    }
+    else if(cmd == HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH){
+        /* turnon digital module if gpio is high */
+        if(is_hpd_muxed() == 0){
+            if(read_hpd_gpio()){
+                hdmitx_device->internal_mode_change = 0;
+                msleep(500);
+                if(read_hpd_gpio()){
+                hdmi_print(IMP, HPD "mux hpd\n");
+                digital_clk_on(4);
+                delay_us(1000*100);
+                mux_hpd();
+                }
+            }
+        }
+    }
+    else if(cmd == HDMITX_HWCMD_MUX_HPD){
+         mux_hpd();
+    } 
+// For test only. 
+    else if(cmd == HDMITX_HWCMD_TURNOFF_HDMIHW){
+        int unmux_hpd_flag = argv;
+//        WRITE_MPEG_REG(VENC_DVI_SETTING, READ_MPEG_REG(VENC_DVI_SETTING)&(~(1<<13))); //bit 13 is used by HDMI only
+//        digital_clk_on(4); //enable sys clk so that hdmi registers can be accessed when calling phy_pll_off/digit_clk_off
+        if(unmux_hpd_flag){
+            hdmi_print(IMP, SYS "power off hdmi, unmux hpd\n");
+            phy_pll_off();
+            digital_clk_off(4); //off sys clk
+            unmux_hpd();
+        }
+        else{
+            hdmi_print(IMP, SYS "power off hdmi\n");
+            digital_clk_on(6);
+            phy_pll_off();      //should call digital_clk_on(), otherwise hdmi_rd/wr_reg will hungup
+            digital_clk_off(3); //do not off sys clk
+        }
+#ifdef CONFIG_HDMI_TX_PHY
+    digital_clk_off(7);
+#endif
+    }
+    else if(cmd == HDMITX_HWCMD_TURN_ON_PRBS){
+        turn_on_prbs_mode(argv);    
+    }
+    return 0;           
+}
+
+static void hdmitx_print_info(hdmitx_dev_t* hdmitx_device, int printk_flag)
+{
+    hdmi_print(INF, "------------------\nHdmitx driver version: %s\nSerial %x\nColor Depth %d\n", HDMITX_VER, serial_reg_val, color_depth_f);
+    hdmi_print(INF, "current vout index %d\n", cur_vout_index);
+    hdmi_print(INF, "reset sequence %d\n", new_reset_sequence_flag);
+    hdmi_print(INF, "power mode %d\n", power_mode);
+    hdmi_print(INF, "%spowerdown when unplug\n",hdmitx_device->unplug_powerdown?"":"do not ");
+    hdmi_print(INF, "use_tvenc_conf_flag=%d\n",use_tvenc_conf_flag); 
+    hdmi_print(INF, "vdac %s\n", power_off_vdac_flag?"off":"on");
+    hdmi_print(INF, "hdmi audio %s\n", hdmi_audio_off_flag?"off":"on");
+    if(!hdmi_audio_off_flag){
+        hdmi_print(INF, "audio out type %s\n", i2s_to_spdif_flag?"spdif":"i2s");
+    }
+    hdmi_print(INF, "delay flag %d\n", delay_flag);
+    hdmi_print(INF, "------------------\n");
+}
+
+static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
+{
+    char tmpbuf[128];
+    int i=0;
+    unsigned int adr;
+    unsigned int value=0;
+    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
+        tmpbuf[i]=buf[i];
+        i++;    
+    }
+    tmpbuf[i]=0;
+    if((strncmp(tmpbuf, "dumpreg", 7)==0) || (strncmp(tmpbuf, "dumptvencreg", 12)==0)){
+        hdmitx_dump_tvenc_reg(hdmitx_device->cur_VIC, 1);
+        return;
+    }
+    else if(strncmp(tmpbuf, "hpd_lock", 8) == 0) {
+        if(tmpbuf[8] == '1') {
+            hdmitx_device->hpd_lock = 1;
+            hdmi_print(INF, HPD "hdmitx: lock hpd\n");
+        }
+        else {
+            hdmitx_device->hpd_lock = 0;
+            hdmi_print(INF, HPD "hdmitx: unlock hpd\n");
+        }
+        return ;
+    }
+    else if(strncmp(tmpbuf, "vic", 3)==0) {
+        printk("hdmi vic count = %d\n", hdmitx_device->vic_count);
+        if((tmpbuf[3] >= '0') && (tmpbuf[3] <= '9')){
+            hdmitx_device->vic_count = tmpbuf[3] - '0';
+            hdmi_print(INF, SYS "set hdmi vic count = %d\n", hdmitx_device->vic_count);
+        }
+    }
+    else if(strncmp(tmpbuf, "cec", 3)==0) {
+        extern void cec_test_(unsigned int cmd);
+        cec_test_(tmpbuf[3] - '0');
+    }
+    else if(strncmp(tmpbuf, "dumphdmireg", 11)==0){
+        unsigned char reg_val = 0;
+        unsigned int reg_adr = 0;
+        for (reg_adr = 0; reg_adr < 0x800; reg_adr ++){        //HDMI Regs address range: 0 ~ 0x7ff
+            reg_val = hdmi_rd_reg(reg_adr);
+            hdmi_print(INF, "HDMI[0x%x]: 0x%x\n", reg_adr, reg_val);
+        }
+        return ;
+    }
+    else if(strncmp(tmpbuf, "dumpcecreg",10) == 0){
+        unsigned char cec_val = 0;
+        unsigned int cec_adr =0;
+        //HDMI CEC Regs address range:0xc000~0xc01c;0xc080~0xc094
+        for(cec_adr = 0xc000; cec_adr < 0xc01d; cec_adr ++){
+            cec_val = hdmi_rd_reg(cec_adr);
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
+        }
+         for(cec_adr = 0xc080; cec_adr < 0xc095; cec_adr ++){
+            cec_val = hdmi_rd_reg(cec_adr);
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
+        }
+        return;      
+    }
+    else if(strncmp(tmpbuf, "dumpcbusreg", 11)==0){
+        unsigned j;
+        adr=simple_strtoul(tmpbuf+11, NULL, 16);  //CBUS Start addr
+        value=simple_strtoul(buf+i+1, NULL, 16); //CBUS End addr
+        for(j = 0 ; j < value-adr+1 ; j++){
+//            printk("CBUS[0x%x]: 0x%x\n", adr+j, READ_MPEG_REG(adr+j));
+            hdmi_print(INF, "CBUS[0x%x]: 0x%x\n", adr+j, aml_read_reg32(CBUS_REG_ADDR(adr+j)));
+            
+        }
+    }
+    else if(strncmp(tmpbuf, "log", 3)==0){
+        if(strncmp(tmpbuf+3, "hdcp", 4)==0){
+            static unsigned int i = 1;
+            if(i & 1){
+                hdmitx_device->log |= HDMI_LOG_HDCP;
+            }
+            else{
+                hdmitx_device->log &= ~HDMI_LOG_HDCP;
+            }
+            i ++;
+        }
+        return ;
+    }
+    else if(strncmp(tmpbuf, "pllcalc", 7)==0){
+        clk_measure(0xff);
+        return;
+    }
+    else if(strncmp(tmpbuf, "hdmiaudio", 9)==0){
+        value=simple_strtoul(tmpbuf+9, NULL, 16);
+        if(value == 1){
+            hdmi_audio_off_flag = 0;
+            hdmi_audio_init(i2s_to_spdif_flag);
+        }
+        else if(value == 0){
+            hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // disable audio sample packets
+        }
+        return;
+    }
+    else if(strncmp(tmpbuf, "cfgreg", 6)==0){
+        adr=simple_strtoul(tmpbuf+6, NULL, 16);
+        value=simple_strtoul(buf+i+1, NULL, 16);
+        hdmitx_config_tvenc_reg(hdmitx_device->cur_VIC, adr, value);
+        return;
+    }
+    else if(strncmp(tmpbuf, "tvenc_flag", 10)==0){
+        use_tvenc_conf_flag = tmpbuf[10]-'0';
+        hdmi_print(INF, "set use_tvenc_conf_flag = %d\n", use_tvenc_conf_flag);
+    }
+    else if(strncmp(tmpbuf, "reset", 5)==0){
+        if(tmpbuf[5]=='0')
+            new_reset_sequence_flag=0;
+        else 
+            new_reset_sequence_flag=1;
+        return;
+    }
+    else if(strncmp(tmpbuf, "delay_flag", 10)==0){
+        delay_flag = tmpbuf[10]-'0';    
+    }
+    else if(tmpbuf[0]=='v'){
+        hdmitx_print_info(hdmitx_device, 1);
+        return;    
+    }
+    else if(tmpbuf[0]=='s'){
+        serial_reg_val=simple_strtoul(tmpbuf+1,NULL,16);
+        return;
+    }
+    else if(tmpbuf[0]=='c'){
+        if(tmpbuf[1]=='d'){
+            color_depth_f=simple_strtoul(tmpbuf+2,NULL,10);
+            if((color_depth_f!=24)&&(color_depth_f!=30)&&(color_depth_f!=36)){
+                printk("Color depth %d is not supported\n", color_depth_f);
+                color_depth_f=0;
+            }
+            return;
+        }
+        else if(tmpbuf[1]=='s'){
+            color_space_f=simple_strtoul(tmpbuf+2,NULL,10);
+            if(color_space_f>2){
+                printk("Color space %d is not supported\n", color_space_f);
+                color_space_f=0;
+            }
+        }
+    }
+    else if(strncmp(tmpbuf,"i2s",2)==0){
+        if(strncmp(tmpbuf+3,"off",3)==0)
+            i2s_to_spdif_flag=1;
+        else   
+            i2s_to_spdif_flag=0;
+    }
+    else if(strncmp(tmpbuf, "pattern_on", 10)==0){
+        turn_on_shift_pattern();
+        hdmi_print(INF, "Shift Pattern On\n");
+        return;        
+    }
+    else if(strncmp(tmpbuf, "pattern_off", 11)==0){
+        turn_off_shift_pattern();
+        hdmi_print(INF, "Shift Pattern Off\n");
+        return;        
+    }
+    else if(strncmp(tmpbuf, "prbs", 4)==0){
+        int prbs_mode =simple_strtoul(tmpbuf+4, NULL, 10);
+        turn_on_prbs_mode(prbs_mode);
+        return;
+    }
+    else if(tmpbuf[0]=='w'){
+        unsigned read_back = 0;
+        adr=simple_strtoul(tmpbuf+2, NULL, 16);
+        value=simple_strtoul(buf+i+1, NULL, 16);
+        if(buf[1]=='h'){
+            hdmi_wr_reg(adr, value);
+            read_back = hdmi_rd_reg(adr);
+        }
+        else if(buf[1]=='c'){
+            aml_write_reg32(CBUS_REG_ADDR(adr), value);
+            read_back = aml_read_reg32(CBUS_REG_ADDR(adr));
+            
+        }
+        else if(buf[1]=='p'){
+            aml_write_reg32(APB_REG_ADDR(adr), value);
+            read_back = aml_read_reg32(APB_REG_ADDR(adr));
+        }
+        hdmi_print(INF, "write %x to %s reg[%x]\n",value,buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr);
+        //Add read back function in order to judge writting is OK or NG.
+        hdmi_print(INF, "Read Back %s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, read_back);
+    }
+    else if(tmpbuf[0]=='r'){
+        adr=simple_strtoul(tmpbuf+2, NULL, 16);
+        if(buf[1]=='h'){
+            value = hdmi_rd_reg(adr);
+            
+        }
+        else if(buf[1]=='c'){
+            value = aml_read_reg32(CBUS_REG_ADDR(adr));
+        }
+        else if(buf[1]=='p'){
+            value = aml_read_reg32(APB_REG_ADDR(adr));
+        }
+        hdmi_print(INF, "%s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, value);
+    }
+}
+
+static void hdmitx_getediddata(hdmitx_dev_t* hdmitx_device)
+{
+    int ii, jj;
+    if((hdmitx_device->cur_edid_block+2)<=EDID_MAX_BLOCK){
+        for(jj=0;jj<2;jj++){
+            for(ii=0;ii<128;ii++){
+                hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]
+                    =hdmi_rd_reg(TX_RX_EDID_OFFSET+hdmitx_device->cur_phy_block_ptr*128+ii);
+            }
+            hdmitx_device->cur_edid_block++;
+            hdmitx_device->cur_phy_block_ptr++;
+            hdmitx_device->cur_phy_block_ptr=hdmitx_device->cur_phy_block_ptr&0x3;
+        }
+    }
+}    
+
+static int hdmitx_cntl_ddc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    int i = 0;
+    unsigned char *tmp_char = NULL;
+    
+    if(!(cmd & CMD_DDC_OFFSET))
+        hdmi_print(ERR, "ddc: " "w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "ddc: " "cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case DDC_RESET_EDID:
+    case DDC_RESET_HDCP:
+        hdmi_set_reg_bits(TX_HDCP_EDID_CONFIG, 0, 6, 1);
+        hdmi_set_reg_bits(TX_HDCP_EDID_CONFIG, 1, 6, 1);
+        break;
+    case DDC_IS_EDID_DATA_READY:
+        return !!(hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<4));
+        break;
+    case DDC_EDID_READ_DATA:
+        hdmi_set_reg_bits(TX_HDCP_EDID_CONFIG, 1, 6, 1);     // Assert sys_trigger_config
+        break;
+    case DDC_EDID_GET_DATA:
+        hdmitx_getediddata(hdmitx_device);
+        break;
+    case DDC_PIN_MUX_OP:
+        if(argv == PIN_MUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x3, 23, 2);    // Enable HDMI SDA(5v)/SCL(5V)
+        }
+        if(argv == PIN_UNMUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x0, 23, 2);    // Disable HDMI SDA(5v)/SCL(5V)
+        }
+        break;
+    case DDC_EDID_CLEAR_RAM:
+        for(i = 0; i < EDID_RAM_ADDR_SIZE; i++) {
+            hdmi_wr_reg(TX_RX_EDID_OFFSET + i, 0);
+        }
+
+        break;
+    case DDC_HDCP_OP:
+        if(argv == HDCP_ON) {
+            hdmi_set_reg_bits(TX_HDCP_MODE, 1, 7, 1);
+        }
+        if(argv == HDCP_OFF) {
+            hdmi_set_reg_bits(TX_HDCP_MODE, 0, 7, 1);
+        }
+        break;
+    case DDC_IS_HDCP_ON:
+        argv = !!((hdmi_rd_reg(TX_HDCP_MODE)) & (1 << 7));
+        break;
+    case DDC_HDCP_GET_AKSV:
+        tmp_char = (unsigned char *) argv;
+        for(i = 0; i < 5; i++) {
+            tmp_char[i] = (unsigned char)hdmi_rd_reg(TX_HDCP_AKSV_SHADOW + 4 - i);
+        }
+        break;
+    case DDC_HDCP_GET_BKSV:
+        tmp_char = (unsigned char *) argv;
+        for(i = 0; i < 5; i++) {
+            tmp_char[i] = (unsigned char)hdmi_rd_reg(TX_HDCP_BKSV_SHADOW + 4 - i);
+        }
+        break;
+    case DDC_HDCP_GET_AUTH:
+        if((hdmi_rd_reg(TX_HDCP_ST_STATUS_3)&0xa0)==0xa0) {
+            return 1;
+        }
+        else {
+            return 0;
+        }
+        break;
+    default:
+        hdmi_print(INF, "ddc: " "unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+// clear hdmi packet configure registers
+static void hdmitx_clr_sub_packet(unsigned int reg_base)
+{
+    int i = 0;
+    for(i = 0; i < 0x20; i++) {
+        hdmi_wr_reg(reg_base + i, 0x00);
+    }
+}
+
+static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_CONF_OFFSET))
+        hdmi_print(ERR, "config: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "config: " "hdmitx: conf cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case CONF_HDMI_DVI_MODE:
+        if(argv == HDMI_MODE) {
+            hdmi_set_reg_bits(TX_TMDS_MODE, 0x3, 6, 2);
+        }
+        if(argv == DVI_MODE) {
+            hdmi_set_reg_bits(TX_TMDS_MODE, 0x2, 6, 2);
+        }
+        break;
+    case CONF_SYSTEM_ST:
+        return (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) >> 6);
+        break;
+    case CONF_AUDIO_MUTE_OP:
+        if(argv == AUDIO_MUTE) {
+            hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // disable audio sample packets
+        }
+        if(argv == AUDIO_UNMUTE) {
+            hdmi_wr_reg(TX_AUDIO_PACK, 0x01); // disable audio sample packets
+        }
+        break;
+    case CONF_VIDEO_BLANK_OP:
+        if(argv == VIDEO_BLANK) {
+            aml_write_reg32(P_VPP_BLEND_ONECOLOR_CTRL, (0x3 << 24) | 0x008080);    // one bit osd blank enable
+        }
+        if(argv == VIDEO_UNBLANK) {
+            aml_set_reg32_bits(P_VPP_BLEND_ONECOLOR_CTRL, 0, 24, 2);    // one bit osd blank disable
+        }
+        break;
+    case CONF_CLR_AVI_PACKET:
+        hdmitx_clr_sub_packet(TX_PKT_REG_AVI_INFO_BASE_ADDR);
+        break;
+    case CONF_CLR_VSDB_PACKET:
+        hdmitx_clr_sub_packet(TX_PKT_REG_VEND_INFO_BASE_ADDR);
+        break;
+    case CONF_CLR_AUDINFO_PACKET:
+        hdmitx_clr_sub_packet(TX_PKT_REG_AUDIO_INFO_BASE_ADDR);
+        break;
+    default:
+        hdmi_print(ERR, "config: ""hdmitx: unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+static int hdmitx_cntl_misc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_MISC_OFFSET))
+        hdmi_print(ERR, "misc: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "misc: " "hdmitx: misc cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case MISC_HPD_MUX_OP:
+        if(argv == PIN_MUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x1, 22, 1);    // Mux HPD
+        }
+        if(argv == PIN_UNMUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x0, 22, 1);    // unMux HPD
+        }
+        break;
+    case MISC_HPD_GPI_ST:
+        return !!(aml_read_reg32(P_PREG_PAD_GPIO2_I) & (1 << 10));
+        break;
+    case MISC_HPLL_OP:
+        if(argv == HPLL_ENABLE) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);   // PowerUp hpll
+        }
+        if(argv == HPLL_DISABLE) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);   // PowerDown hpll
+        }
+        break;
+    case MISC_TMDS_PHY_OP:
+        if(argv == TMDS_PHY_ENABLE) {
+            hdmi_phy_wakeup();
+        }
+        if(argv == TMDS_PHY_DISABLE) {
+            hdmi_phy_suspend();
+        }
+    default:
+        hdmi_print(ERR, "misc: " "hdmitx: unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+static int hdmitx_get_state(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_STAT_OFFSET))
+        hdmi_print(ERR, "stat: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "stat: " "hdmitx: misc cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case STAT_VIDEO_VIC:
+        {
+            /*
+             * get current video vic directly from VIC packet or VSDB packet
+             */
+            HDMI_Video_Codes_t vic = HDMI_Unkown;
+            vic = (HDMI_Video_Codes_t)hdmi_rd_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR + 4);
+            if(vic == HDMI_Unkown) {
+                vic = (HDMI_Video_Codes_t)hdmi_rd_reg(TX_PKT_REG_VEND_INFO_BASE_ADDR + 5);
+                if(vic == 1) {
+                    vic = HDMI_4k2k_30;
+                } else if(vic == 2) {
+                    vic = HDMI_4k2k_25;
+                } else if(vic == 3) {
+                    vic = HDMI_4k2k_24;
+                } else if(vic == 4) {
+                    vic = HDMI_4k2k_smpte_24;
+                } else {
+                }
+            }
+            return (int)vic;
+        }
+        break;
+    case STAT_VIDEO_CLK:
+    default:
+        break;
+    }
+    return 0;
+}
+
+void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device)
+{
+    hdmitx_device->HWOp.SetPacket = hdmitx_set_packet;
+    hdmitx_device->HWOp.SetAudioInfoFrame = hdmitx_setaudioinfoframe;
+    hdmitx_device->HWOp.SetDispMode = hdmitx_set_dispmode;
+    hdmitx_device->HWOp.SetAudMode = hdmitx_set_audmode;
+    hdmitx_device->HWOp.SetupIRQ = hdmitx_setupirq;
+    hdmitx_device->HWOp.DebugFun = hdmitx_debug;
+    hdmitx_device->HWOp.UnInit = hdmitx_uninit;
+    hdmitx_device->HWOp.Cntl = hdmitx_cntl;             // todo
+    hdmitx_device->HWOp.CntlDDC = hdmitx_cntl_ddc;
+    hdmitx_device->HWOp.GetState = hdmitx_get_state;
+    hdmitx_device->HWOp.CntlPacket = hdmitx_cntl;
+    hdmitx_device->HWOp.CntlConfig = hdmitx_cntl_config;
+    hdmitx_device->HWOp.CntlMisc = hdmitx_cntl_misc;
+                                                                  //     1=Map data pins from Venc to Hdmi Tx as RGB mode.
+    // --------------------------------------------------------
+    // Configure HDMI TX analog, and use HDMI PLL to generate TMDS clock
+    // --------------------------------------------------------
+    // Enable APB3 fail on error
+//    WRITE_APB_REG(HDMI_CNTL_PORT, READ_APB_REG(HDMI_CNTL_PORT)|(1<<15)); //APB3 err_en
+//\\ TODO
+    aml_set_reg32_bits(P_PAD_PULL_UP_REG2, 1, 10, 1);       // Disable GPIOC_10 internal pull-up register
+    aml_write_reg32(P_HHI_HDMI_CLK_CNTL, aml_read_reg32(P_HHI_HDMI_CLK_CNTL)| (1 << 8));
+    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<15)); //APB3 err_en
+    hdmi_wr_reg(0x10, 0xff);
+
+    hdmi_phy_suspend();
+
+    /**/    
+    hdmi_hw_init(hdmitx_device);
+}    
+
+void hdmi_set_audio_para(int para)
+{
+    aud_para = para;
+
+}
+
+// The following two functions should move to 
+// static struct platform_driver amhdmitx_driver.suspend & .wakeup
+// For tempelet use only.
+// Later will change it.
+typedef struct 
+{
+    unsigned long reg;
+    unsigned long val_sleep;
+    unsigned long val_save;
+}hdmi_phy_t;
+
+static char hdmi_phy_reg_save_flag = 0;
+
+#define HDMI_PHY_REG_NUM    7
+static hdmi_phy_t hdmi_phy_reg [HDMI_PHY_REG_NUM] = {
+                         {0x10, 0xc0, 0x0},
+                         {0x11, 0xf1, 0x0},
+                         {0x12, 0xff, 0x0},
+                         {0x13, 0x07, 0x0},
+                         {0x14, 0x00, 0x0},
+                         {0x15, 0x04, 0x0},
+                         {0x16, 0x30, 0x00},
+                        };
+
+static void hdmi_phy_suspend(void)
+{
+    // First backup HDMI PHY register according to Chao Shi.
+    int i;
+    for(i = 0; i < HDMI_PHY_REG_NUM; i++)
+    {
+        hdmi_phy_reg[i].val_save = hdmi_rd_reg(hdmi_phy_reg[i].reg);
+    }
+    for(i = 0; i < HDMI_PHY_REG_NUM; i++)
+    {   
+        hdmi_wr_reg(hdmi_phy_reg[i].reg, hdmi_phy_reg[i].val_sleep);
+    }
+    //hdmi_print(INF, SYS "phy suspend\n");
+    hdmi_phy_reg_save_flag = 1;
+}
+
+static void hdmi_phy_wakeup(void)
+{
+    int i;
+    if(hdmi_phy_reg_save_flag){
+        for(i = 0; i < HDMI_PHY_REG_NUM; i++)
+        {
+            hdmi_wr_reg(hdmi_phy_reg[i].reg, hdmi_phy_reg[i].val_save);
+        }
+        //hdmi_print(INF, SYS "phy wakeup\n");
+        hdmi_phy_reg_save_flag = 0;
+    }
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_reg.c
similarity index 80%
rename from drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
rename to arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_reg.c
index e69c3363a953..82c0c5ea7ab6 100644
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.c
+++ b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_reg.c
@@ -30,7 +30,7 @@
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
-#include "hdmi_tx_reg.h"
+#include <mach/hdmi_tx_reg.h>
 static DEFINE_SPINLOCK(reg_lock);
 // if the following bits are 0, then access HDMI IP Port will cause system hungup
 #define GATE_NUM    2
@@ -50,53 +50,36 @@ static void check_cts_hdmi_sys_clk_status(void)
     }
 }
 
-unsigned long hdmi_rd_reg(unsigned long addr)
+unsigned int hdmi_rd_reg(unsigned int addr)
 {
-    unsigned long data;
-#ifdef CONFIG_ARCH_MESON6
+    unsigned int data;
     unsigned long flags, fiq_flag;
 
     spin_lock_irqsave(&reg_lock, flags);
     raw_local_save_flags(fiq_flag);
     local_fiq_disable();
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    spin_lock(&reg_lock);
-#endif
+
     check_cts_hdmi_sys_clk_status();
     aml_write_reg32(P_HDMI_ADDR_PORT, addr);
     aml_write_reg32(P_HDMI_ADDR_PORT, addr);
     data = aml_read_reg32(P_HDMI_DATA_PORT);
-#ifdef CONFIG_ARCH_MESON6
+
     raw_local_irq_restore(fiq_flag);
     spin_unlock_irqrestore(&reg_lock, flags);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    spin_unlock(&reg_lock);
-#endif
     return (data);
 }
 
-void hdmi_wr_reg(unsigned long addr, unsigned long data)
+void hdmi_wr_reg(unsigned int addr, unsigned int data)
 {
-#ifdef CONFIG_ARCH_MESON6
     unsigned long flags, fiq_flag;
     spin_lock_irqsave(&reg_lock, flags);
     raw_local_save_flags(fiq_flag);
     local_fiq_disable();
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    spin_lock(&reg_lock);
-#endif
+
     check_cts_hdmi_sys_clk_status();
     aml_write_reg32(P_HDMI_ADDR_PORT, addr);
     aml_write_reg32(P_HDMI_ADDR_PORT, addr);
     aml_write_reg32(P_HDMI_DATA_PORT, data);
-#ifdef CONFIG_ARCH_MESON6
     raw_local_irq_restore(fiq_flag);
     spin_unlock_irqrestore(&reg_lock, flags);
-#endif
-#ifdef CONFIG_ARCH_MESON8
-    spin_unlock(&reg_lock);
-#endif
 }
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/tvenc_conf.h b/arch/arm/mach-meson6/hdmi_tx_hw/tvenc_conf.h
similarity index 100%
rename from drivers/amlogic/hdmi/hdmi_tx/hw/tvenc_conf.h
rename to arch/arm/mach-meson6/hdmi_tx_hw/tvenc_conf.h
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h b/arch/arm/mach-meson6/include/mach/hdmi_tx_reg.h
similarity index 95%
rename from drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
rename to arch/arm/mach-meson6/include/mach/hdmi_tx_reg.h
index 3b0110d45d35..fedb8a82e693 100644
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_reg.h
+++ b/arch/arm/mach-meson6/include/mach/hdmi_tx_reg.h
@@ -20,11 +20,14 @@
 #define M6_VID_PLL_CNTL_3 (M6_PLL_CNTL_CST3)
 #define M6_VID_PLL_CNTL_4 (M6_PLL_CNTL_CST4)
 #endif
-unsigned long hdmi_rd_reg(unsigned long addr);
+unsigned int hdmi_rd_reg(unsigned int addr);
 
 #define hdmi_wr_only_reg(addr, data)   hdmi_wr_reg(addr, data)
 
-void hdmi_wr_reg(unsigned long addr, unsigned long data);
+void hdmi_wr_reg(unsigned int addr, unsigned int data);
+
+#define hdmi_set_reg_bits(reg, val, start, len) \
+  hdmi_wr_reg(reg, (hdmi_rd_reg(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
 
 typedef struct {
     unsigned short cbus_addr;
@@ -63,6 +66,8 @@ typedef struct {
 //********** TX related **********//
 #define TX_RX_EDID_OFFSET               TX_BASE_ADDR+0x600 
 #define TX_HDCP_SHADOW_OFFSET           TX_BASE_ADDR+0x100 
+#define TX_HDCP_BKSV_SHADOW             TX_HDCP_SHADOW_OFFSET
+#define TX_HDCP_AKSV_SHADOW             TX_HDCP_SHADOW_OFFSET + 0x10
 
 #define TX_IEC60958_SUB1_OFFSET         TX_BASE_ADDR+0x0B0 
 #define TX_IEC60958_SUB2_OFFSET         TX_BASE_ADDR+0x0C8 
@@ -100,7 +105,7 @@ typedef struct {
     #define HDMI_L2H_CTL            0
 #define TX_HDMI_PHY_CONFIG4        TX_BASE_ADDR+0x014 
     #define HDMI_PREM_CTL           4
-    #define HDMI_MODE               2   //0:narmal mode  1:clk chan(ch3) equals ch0  2:alternate high/low  3:alternate low/high
+    #define HDMI_MODE_P               2   //0:narmal mode  1:clk chan(ch3) equals ch0  2:alternate high/low  3:alternate low/high
     #define HDMI_PHY_CLK_EN         1   //1:enable serialzer clock
     #define HDMI_LF_PD              0
 #define TX_HDMI_PHY_CONFIG5        TX_BASE_ADDR+0x015 
diff --git a/arch/arm/mach-meson8/Makefile b/arch/arm/mach-meson8/Makefile
index dd6c69181148..65b431b8ea01 100755
--- a/arch/arm/mach-meson8/Makefile
+++ b/arch/arm/mach-meson8/Makefile
@@ -38,3 +38,6 @@ obj-$(CONFIG_MESON_SUSPEND) += power_suspend.o
 #ifneq ($(CONFIG_MESON_SUSPEND),y)
 #obj-$(CONFIG_SUSPEND) += sleep.o
 #endif
+
+obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
+
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/Makefile b/arch/arm/mach-meson8/hdmi_tx_hw/Makefile
new file mode 100644
index 000000000000..ffa592f8ba00
--- /dev/null
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/Makefile
@@ -0,0 +1 @@
+obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c
old mode 100755
new mode 100644
similarity index 69%
rename from drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
rename to arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c
index 0eb84ce17e16..6617a08a2889
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/hdmi_tx_hw.c
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c
@@ -13,7 +13,6 @@
  * GNU General Public License for more details.
  *
  */
-#define HDMI_DEBUG()  printk("HDMI DEBUG: %s [%d]\n", __FUNCTION__, __LINE__)
 
 #include <linux/version.h>
 #include <linux/module.h>
@@ -43,14 +42,15 @@
 #include <mach/io.h>
 #include <mach/register.h>
 
-#include "../hdmi_info_global.h"
-#include "../hdmi_tx_module.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#if 0   //todo
 #include "../hdmi_tx_cec.h"
 #include "../hdmi_tx_hdcp.h"
 #include "../hdmi_tx_compliance.h"
-#include "hdmi_tx_reg.h"
+#endif
+#include <mach/hdmi_tx_reg.h>
 #include "tvenc_conf.h"
-//#define XTAL_24MHZ
 #ifdef Wr
 #undef Wr
 #endif
@@ -62,21 +62,14 @@
 #define Wr_reg_bits(reg, val, start, len) \
   Wr(reg, (Rd(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
 
+#define EDID_RAM_ADDR_SIZE      (4*128)
+
 static void hdmi_audio_init(unsigned char spdif_flag);
 static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag);
 
 static void hdmi_phy_suspend(void);
 static void hdmi_phy_wakeup(void);
 
-//#define HPD_DELAY_CHECK
-
-//#define MORE_LOW_P
-#define LOG_EDID
-
-#define HDMI_M1A 'a'
-#define HDMI_M1B 'b'
-#define HDMI_M1C 'c'
-static unsigned char hdmi_chip_type = 0;
 unsigned char hdmi_pll_mode = 0; /* 1, use external clk as hdmi pll source */
 static unsigned char aud_para = 0x49;
 
@@ -99,10 +92,6 @@ static unsigned char aud_para = 0x49;
 #define TX_I2S_8_CHANNEL    1                       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
 #endif
 
-#ifdef HPD_DELAY_CHECK
-static struct timer_list hpd_timer;
-#endif
-
 //static struct tasklet_struct EDID_tasklet;
 static unsigned delay_flag = 0;
 static unsigned serial_reg_val=0x1; //0x22;
@@ -114,12 +103,9 @@ static unsigned char power_mode=1;
 static unsigned char power_off_vdac_flag=0;
     /* 0, do not use fixed tvenc val for all mode; 1, use fixed tvenc val mode for 480i; 2, use fixed tvenc val mode for all modes */
 static unsigned char use_tvenc_conf_flag=1;
-static unsigned char hpd_debug_mode=0;
 
 static unsigned char cur_vout_index = 1; //CONFIG_AM_TV_OUTPUT2
 
-#define HPD_DEBUG_IGNORE_UNPLUG   1
-
 static unsigned long modulo(unsigned long a, unsigned long b)
 {
     if (a >= b) {
@@ -152,55 +138,28 @@ static irqreturn_t intr_handler(int irq, void *dev_instance)
     unsigned int data32;
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)dev_instance;
     data32 = hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT); 
-    hdmi_print(1, "HDMI irq %x\n", data32);
+    hdmi_print(IMP, SYS "irq %x\n", data32);
     if(hdmitx_device->hpd_lock == 1) {
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0xf);
-        printk("hdmitx: hpd locked\n");
+        hdmi_print(IMP, HPD "HDMI hpd locked\n");
         return IRQ_HANDLED;
     }
     if(hdmitx_device->internal_mode_change == 1){     // if the irq from the internal mode change, just do nothing and return
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0x7);
-        printk("hdmitx: ignore irq\n");
+        hdmi_print(IMP, SYS "hdmitx: ignore irq\n");
         return IRQ_HANDLED;
     }
 
     WRITE_MPEG_REG(HHI_GCLK_MPEG2, READ_MPEG_REG(HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
     
     if (data32 & (1 << 1)) { //HPD falling
-#ifdef CONFIG_ARCH_MESON8
-        aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);   // disable hpll
-#endif
         hdmitx_device->vic_count = 0;
-#ifdef CONFIG_ARCH_MESON6
-        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x0, 23, 2); //Disable reg1[23:24]:HDMI SDA(5v)/SCL(5V)
-#endif
-        if(hpd_debug_mode&HPD_DEBUG_IGNORE_UNPLUG){
-            hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module     
-        }
-        else{
-            hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module 
-#ifdef HPD_DELAY_CHECK
-            del_timer(&hpd_timer);    
-            hpd_timer.expires = jiffies + HZ/2;
-            add_timer(&hpd_timer);
-#else
-            hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<6)); // Release sys_trigger_config
-            hdmitx_device->hpd_event = 2;
-
-#endif        
-        }
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module 
+        hdmitx_device->hpd_event = 2;
     }
     if (data32 & (1 << 0)) {  //HPD rising
-#ifdef CONFIG_ARCH_MESON6
-        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x3, 23, 2); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V)
-#endif
         hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 0); //clear HPD rising interrupt in hdmi module
         // If HPD asserts, then start DDC transaction
-#ifdef HPD_DELAY_CHECK
-        del_timer(&hpd_timer);    
-        hpd_timer.expires = jiffies + HZ/2;
-        add_timer(&hpd_timer);
-#else
         if (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<1)) {
             // Start DDC transaction
             hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & (~(1<<6))); // Assert sys_trigger_config
@@ -210,32 +169,17 @@ static irqreturn_t intr_handler(int irq, void *dev_instance)
             hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<6)); // Assert sys_trigger_config
         // Error if HPD deasserts
         } else {
-            hdmi_print(1,"HDMI Error: HDMI HPD deasserts!\n");
+            hdmi_print(ERR, HPD "HPD deasserts!\n");
         }
-#endif        
     }
     if (data32 & (1 << 2)) { //TX EDID interrupt
         if((hdmitx_device->cur_edid_block+2)<=EDID_MAX_BLOCK){
             int ii, jj;
             for(jj=0;jj<2;jj++){
-#ifdef LOG_EDID
-                int edid_log_pos=0;
-                edid_log_pos+=snprintf((char*)hdmitx_device->tmp_buf+edid_log_pos, HDMI_TMP_BUF_SIZE-edid_log_pos, "EDID Interrupt cur block %d:",hdmitx_device->cur_edid_block);
-#endif
                 for(ii=0;ii<128;ii++){
                     hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]
                         =hdmi_rd_reg(0x600+hdmitx_device->cur_phy_block_ptr*128+ii);
-#ifdef LOG_EDID
-                    if((ii&0xf)==0)
-                        edid_log_pos+=snprintf((char*)hdmitx_device->tmp_buf+edid_log_pos, HDMI_TMP_BUF_SIZE-edid_log_pos, "\n");
-                    edid_log_pos+=snprintf((char*)hdmitx_device->tmp_buf+edid_log_pos, HDMI_TMP_BUF_SIZE-edid_log_pos, "%02x ",hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]);
-#endif                    
                 }
-#ifdef LOG_EDID
-                hdmitx_device->tmp_buf[edid_log_pos]=0;
-                hdmi_print_buf((char*)hdmitx_device->tmp_buf, strlen((char*)hdmitx_device->tmp_buf));
-                hdmi_print(0,"\n");
-#endif
                 hdmitx_device->cur_edid_block++;
                 hdmitx_device->cur_phy_block_ptr++;
                 hdmitx_device->cur_phy_block_ptr=hdmitx_device->cur_phy_block_ptr&0x3;
@@ -251,7 +195,7 @@ static irqreturn_t intr_handler(int irq, void *dev_instance)
         hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 2); //clear EDID rising interrupt in hdmi module 
     }
     if (!((data32 == 1) || (data32 == 2) || (data32 == 4))) {
-        hdmi_print(1,"HDMI Error: Unkown HDMI Interrupt Source\n");
+        hdmi_print(ERR, SYS "Unkown HDMI Interrupt Source\n");
         hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  data32); //clear unkown interrupt in hdmi module 
     }
 //#ifdef AML_A3
@@ -322,18 +266,14 @@ static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
     front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 88   / 1 * 2 = 176
     hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 44   / 1 * 2 = 88
 
-//    hdmi_print(0, "[ENCP_VIDEO_MODE:%x]=%x\n",ENCP_VIDEO_MODE, Rd(ENCP_VIDEO_MODE)); 
-//    hdmi_print(0, "[ENCP_VIDEO_MODE:%x]=%x\n",ENCP_VIDEO_MODE, aml_read_reg32(P_ENCP_VIDEO_MODE)); 
     aml_write_reg32(P_ENCP_VIDEO_MODE, aml_read_reg32(P_ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
 
     // Program DE timing
-    hdmi_print(0, "[ENCP_VIDEO_HAVON_BEGIN:%x]=%x\n",ENCP_VIDEO_HAVON_BEGIN, aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN)); 
     de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc); // (383 + 3) % 4400 = 386
     de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc); // (386 + 3840) % 4400 = 4226
     aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);    // 386
     aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);      // 4226
     // Program DE timing for even field
-    hdmi_print(0, "[ENCP_VIDEO_VAVON_BLINE:%x]=%x\n",ENCP_VIDEO_VAVON_BLINE, aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE)); 
     de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);       // 20
     de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 20 + 540 = 560
     aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);   // 20
@@ -341,8 +281,7 @@ static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
     // Program DE timing for odd field if needed
     if (INTERLACE_MODE) {
         // Calculate de_v_begin_odd according to enc480p_timing.v:
-        //wire[10:0]	cfg_ofld_vavon_bline	= {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline	+ ofld_line;
-        hdmi_print(0, "[ENCP_VIDEO_OFLD_VOAV_OFST:%x]=%x\n",ENCP_VIDEO_OFLD_VOAV_OFST, aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST)); 
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
         de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2; // 1 + 20 + (1125-1)/2 = 583
         de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;    // 583 + 540 = 1123
         aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);// 583
@@ -417,7 +356,7 @@ static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
 static void hdmi_tvenc4k2k_set(Hdmi_tx_video_para_t* param)
 {
     unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2; // Annie 01Sep2011: Change value from 3 to 2, due to video encoder path delay change.
-    unsigned long TOTAL_PIXELS, PIXEL_REPEAT_HDMI, PIXEL_REPEAT_VENC, ACTIVE_PIXELS;
+    unsigned long TOTAL_PIXELS = 4400, PIXEL_REPEAT_HDMI, PIXEL_REPEAT_VENC, ACTIVE_PIXELS = 3840;
     unsigned FRONT_PORCH = 1020, HSYNC_PIXELS, ACTIVE_LINES = 2160, INTERLACE_MODE, TOTAL_LINES, SOF_LINES, VSYNC_LINES;
     unsigned LINES_F0 = 2250, LINES_F1 = 2250,BACK_PORCH, EOF_LINES = 8, TOTAL_FRAMES;
 
@@ -481,7 +420,7 @@ static void hdmi_tvenc4k2k_set(Hdmi_tx_video_para_t* param)
          SOF_LINES          = 72 + 1;
          TOTAL_FRAMES       = 3;
     }
-    else if(param->VIC==HDMI_4k2k_smpte){
+    else if(param->VIC==HDMI_4k2k_smpte_24){
          INTERLACE_MODE     = 0;
          PIXEL_REPEAT_VENC  = 0;
          PIXEL_REPEAT_HDMI  = 0;
@@ -521,7 +460,7 @@ static void hdmi_tvenc4k2k_set(Hdmi_tx_video_para_t* param)
     // Program DE timing for odd field if needed
     if (INTERLACE_MODE) {
         // Calculate de_v_begin_odd according to enc480p_timing.v:
-        //wire[10:0]	cfg_ofld_vavon_bline	= {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline	+ ofld_line;
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
         de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
         de_v_end_odd    = modulo(de_v_begin_odd + ACTIVE_LINES, TOTAL_LINES);
         aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
@@ -642,20 +581,16 @@ static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
     hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 124  / 2 * 2 = 124
 
     // Annie 01Sep2011: Comment out the following 2 lines. Because ENCP is not used for 480i and 576i.
-    //hdmi_print(0, "[ENCP_VIDEO_MODE:%x]=%x\n",ENCP_VIDEO_MODE, Rd(ENCP_VIDEO_MODE));
     //Wr(ENCP_VIDEO_MODE,Rd(ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
 
     // Program DE timing
     // Annie 01Sep2011: for 480/576i, replace VFIFO2VD_PIXEL_START with ENCI_VFIFO2VD_PIXEL_START.
-    hdmi_print(0, "[ENCI_VFIFO2VD_PIXEL_START:%x]=%x\n",ENCI_VFIFO2VD_PIXEL_START, aml_read_reg32(P_ENCI_VFIFO2VD_PIXEL_START)); 
     de_h_begin = modulo(aml_read_reg32(P_ENCI_VFIFO2VD_PIXEL_START) + VFIFO2VD_TO_HDMI_LATENCY,   total_pixels_venc); // (233 + 2) % 1716 = 235
     de_h_end   = modulo(de_h_begin + active_pixels_venc,                            total_pixels_venc); // (235 + 1440) % 1716 = 1675
     aml_write_reg32(P_ENCI_DE_H_BEGIN, de_h_begin);    // 235
     aml_write_reg32(P_ENCI_DE_H_END,   de_h_end);      // 1675
 
     // Annie 01Sep2011: for 480/576i, replace VFIFO2VD_LINE_TOP/BOT_START with ENCI_VFIFO2VD_LINE_TOP/BOT_START.
-    hdmi_print(0, "[ENCI_VFIFO2VD_LINE_TOP_START:%x]=%x\n",ENCI_VFIFO2VD_LINE_TOP_START, aml_read_reg32(P_ENCI_VFIFO2VD_LINE_TOP_START)); 
-    hdmi_print(0, "[ENCI_VFIFO2VD_LINE_BOT_START:%x]=%x\n",ENCI_VFIFO2VD_LINE_BOT_START, aml_read_reg32(P_ENCI_VFIFO2VD_LINE_BOT_START)); 
     de_v_begin_even = aml_read_reg32(P_ENCI_VFIFO2VD_LINE_TOP_START);      // 17
     de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 17 + 240 = 257
     de_v_begin_odd  = aml_read_reg32(P_ENCI_VFIFO2VD_LINE_BOT_START);      // 18
@@ -902,16 +837,13 @@ static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
     front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 16   / 1 * 2 = 32
     hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 62   / 1 * 2 = 124
 
-    hdmi_print(0, "[ENCP_VIDEO_MODE:%x]=%x\n",ENCP_VIDEO_MODE, aml_read_reg32(P_ENCP_VIDEO_MODE)); 
     aml_write_reg32(P_ENCP_VIDEO_MODE,aml_read_reg32(P_ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
     // Program DE timing
-    hdmi_print(0, "[ENCP_VIDEO_HAVON_BEGIN:%x]=%x\n",ENCP_VIDEO_HAVON_BEGIN, aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN)); 
     de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc); // (217 + 3) % 1716 = 220
     de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc); // (220 + 1440) % 1716 = 1660
     aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);    // 220
     aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);      // 1660
     // Program DE timing for even field
-    hdmi_print(0, "[ENCP_VIDEO_VAVON_BLINE:%x]=%x\n",ENCP_VIDEO_VAVON_BLINE, aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE)); 
     de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);       // 42
     de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 42 + 480 = 522
     aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);   // 42
@@ -920,7 +852,6 @@ static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
     if (INTERLACE_MODE) {
         // Calculate de_v_begin_odd according to enc480p_timing.v:
         //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
-        hdmi_print(0, "[ENCP_VIDEO_OFLD_VOAV_OFST:%x]=%x\n",ENCP_VIDEO_OFLD_VOAV_OFST, aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST)); 
         de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
         de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;
         aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
@@ -1044,48 +975,27 @@ hdmi on/off
 static int is_hpd_muxed(void)
 {
     int ret;
-#ifdef CONFIG_ARCH_MESON6
-    ret = !!(aml_read_reg32(P_PERIPHS_PIN_MUX_1)&(1<<22));
-#endif
-#ifdef CONFIG_ARCH_MESON8
     ret = !!(aml_read_reg32(P_PERIPHS_PIN_MUX_1)&(1<<26));
-#endif
     return ret; 
 }    
 
 static void mux_hpd(void)
 {
-#ifdef CONFIG_ARCH_MESON6
-    aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1)|(1 << 22));
-#endif
-#ifdef CONFIG_ARCH_MESON8
     aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1)|(1 << 26));
-#endif
 }
 
 static void unmux_hpd(void)
 {
-#ifdef CONFIG_ARCH_MESON6
-    aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1)&~(1 << 22));
-    //GPIOC_10 0x2012[10]
-    aml_write_reg32(P_PREG_PAD_GPIO2_EN_N, aml_read_reg32(P_PREG_PAD_GPIO2_EN_N)|(1<<10)); //GPIOC_10 as input
-#endif
-#ifdef CONFIG_ARCH_MESON8
     aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1)&~(1 << 26));
     aml_write_reg32(P_PREG_PAD_GPIO3_EN_N, aml_read_reg32(P_PREG_PAD_GPIO3_EN_N) | (1 << 19)); //GPIOH_0 as input
-#endif
 }
 
 extern int read_hpd_gpio(void);
 int read_hpd_gpio(void)
 {
     int level;
-#ifdef CONFIG_ARCH_MESON6
-    level = !!(aml_read_reg32(P_PREG_PAD_GPIO2_I)&(1<<10)); //read GPIOC_10
-#endif
-#ifdef CONFIG_ARCH_MESON8
-	level = !!(aml_read_reg32(P_PREG_PAD_GPIO3_I)&(1<<19)); //read GPIOH_0
-#endif
+
+    level = !!(aml_read_reg32(P_PREG_PAD_GPIO3_I)&(1<<19)); //read GPIOH_0
     return level;
 }
 EXPORT_SYMBOL(read_hpd_gpio);
@@ -1142,15 +1052,8 @@ static void digital_clk_off(unsigned char flag)
 //        Wr(HHI_GCLK_MPEG2, Rd(HHI_GCLK_MPEG2)&(~(1<<4))); //disable pixel clock, set cbus reg HHI_GCLK_MPEG2 bit [4] = 0
         aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)&(~(1<<17))); //disable VCLK1_HDMI GATE, set cbus reg HHI_GCLK_OTHER bit [17] = 0
         aml_write_reg32(P_VENC_DVI_SETTING, (aml_read_reg32(P_VENC_DVI_SETTING)&(~(7<<4)))|(5<<4)); //set cbus reg VENC_DVI_SETTING bit[6:4] = 0x5
-#ifdef CONFIG_ARCH_MESON6
-        aml_write_reg32(P_HHI_VID_PLL_CNTL, (aml_read_reg32(P_HHI_VID_PLL_CNTL) | (1<<30)));     //0x105c[30]PD, 1: PowerDown
-        aml_write_reg32(P_HHI_VID_PLL_CNTL3, (aml_read_reg32(P_HHI_VID_PLL_CNTL3) & ~((1<<5)|(1<<3))));  //0x1058[5]VBG_PU [3]IREXT_PU
-#endif
-#if 1
     // Second turn off gate.
         aml_write_reg32(P_HHI_GCLK_MPEG2, aml_read_reg32(P_HHI_GCLK_MPEG2) & (~(1<<4)));     //Disable HDMI PCLK
-#endif 
- 
     }
     if(flag&4){
         /* off hdmi sys clock */
@@ -1160,14 +1063,9 @@ static void digital_clk_off(unsigned char flag)
 
 static void digital_clk_on(unsigned char flag)
 {
-#ifdef CONFIG_ARCH_MESON6
-    int i;
-#endif
 //    clk81_set();
     if(flag&4){
         /* on hdmi sys clock */
-//#ifdef AML_A3
-#if 1
         // -----------------------------------------
         // HDMI (90Mhz)
         // -----------------------------------------
@@ -1177,230 +1075,75 @@ static void digital_clk_on(unsigned char flag)
         aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 0, 7);    // Divide the "other" PLL output by 1
         aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 9, 3);    // select "XTAL" PLL
         aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 1, 8, 1);    // Enable gated clock
-#ifdef CONFIG_ARCH_MESON8
-        //aml_write_reg32(P_HHI_VPU_CLK_CNTL,   0x101);       //todo DELETE LATER
-        //aml_write_reg32(P_HHI_VPU_CLK_CNTL, (aml_read_reg32(P_HHI_VPU_CLK_CNTL) | (1 << 8)) );	//moved to vpu.c, default config by dts
-#endif
 //        Wr( HHI_HDMI_CLK_CNTL,  ((2 << 9)  |   // select "misc" PLL
 //                                 (1 << 8)  |   // Enable gated clock
 //                                 (5 << 0)) );  // Divide the "other" PLL output by 6
-    
-#else    
-        // -----------------------------------------
-        // HDMI (90Mhz)
-        // -----------------------------------------
-        //         .clk_div            ( hi_hdmi_clk_cntl[6:0] ),
-        //         .clk_en             ( hi_hdmi_clk_cntl[8]   ),
-        //         .clk_sel            ( hi_hdmi_clk_cntl[11:9]),
-        aml_write_reg32(P_HHI_HDMI_CLK_CNTL,  ((1 << 9)  |   // select "other" PLL
-                                 (1 << 8)  |   // Enable gated clock
-                                 (5 << 0)) );  // Divide the "other" PLL output by 6
-#endif
     }
     if(flag&2){
         /* on hdmi pixel clock */
-#if 1
         aml_write_reg32(P_HHI_GCLK_MPEG2, aml_read_reg32(P_HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
-#ifdef CONFIG_ARCH_MESON6
-        aml_write_reg32(P_HHI_VID_PLL_CNTL3, (aml_read_reg32(P_HHI_VID_PLL_CNTL3) | ((1<<5)|(1<<3))));  //0x1058[5]VBG_PU [3]IREXT_PU
-        i=100;
-        while(i--);     //delay some time and then PowerUp HHI_VID_PLL
-        aml_write_reg32(P_HHI_VID_PLL_CNTL, (aml_read_reg32(P_HHI_VID_PLL_CNTL) & ~(1<<30)));     //0x105c[30]PD, 0: Power Up
-#endif
-#endif        
-
 //        Wr(HHI_GCLK_MPEG2, Rd(HHI_GCLK_MPEG2)|(1<<4)); //enable pixel clock, set cbus reg HHI_GCLK_MPEG2 bit [4] = 1
         aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)|(1<<17)); //enable VCLK1_HDMI GATE, set cbus reg HHI_GCLK_OTHER bit [17] = 1
     }
     if(flag&1){
-//#ifdef AML_A3
-        /* on hdmi audio clock */
-//        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL1,  hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL1)|(1<<13)); 
-//#endif  
     }  
 }
 
 static void phy_pll_off(void)
 {
-    /* power down hdmi phy */
-//    hdmi_wr_reg(TX_CORE_CALIB_MODE, 0x8);
-//    hdmi_wr_reg(TX_SYS1_TERMINATION, hdmi_rd_reg(TX_SYS1_TERMINATION)&(~0xf));
-//    hdmi_wr_reg(TX_SYS1_AFE_SPARE0, hdmi_rd_reg(TX_SYS1_AFE_SPARE0)&(~0xf));
-//    hdmi_wr_reg(TX_SYS1_AFE_TEST, hdmi_rd_reg(TX_SYS1_AFE_TEST)&(~0x1f));
-        /**/
     hdmi_phy_suspend();
-#if 0 
-//no HDMI PLL in M3   
-#ifndef AML_A3
-        /* no HDMI PLL in A3 */
-    Wr(HHI_VID_PLL_CNTL, Rd(HHI_VID_PLL_CNTL)|(1<<30)); //disable HDMI PLL
-    
-    Wr(HHI_VID_PLL_CNTL3, Rd(HHI_VID_PLL_CNTL3)&(~0x38));
-#endif 
-#endif  
 }
 
 /**/
-void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device, int power_mode, int vic)
+void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device)
 {
-#ifdef CONFIG_ARCH_MESON8
-    //todo
+    int vic = hdmitx_device->cur_VIC;
+
     switch(vic) {
-	case HDMI_480i60:
-	case HDMI_480i60_16x9:
-	case HDMI_576p50:
-	case HDMI_576p50_16x9:
-	case HDMI_576i50:
-	case HDMI_576i50_16x9:            
-	case HDMI_480p60:
-	case HDMI_480p60_16x9:
-	case HDMI_720p50:
-	case HDMI_720p60:
-	case HDMI_1080i50:
-	case HDMI_1080i60:
-	case HDMI_1080p24://1080p24 support
-	case HDMI_1080p50:
-	case HDMI_1080p60:
-	default:
+    case HDMI_480i60:
+    case HDMI_480i60_16x9:
+    case HDMI_576p50:
+    case HDMI_576p50_16x9:
+    case HDMI_576i50:
+    case HDMI_576i50_16x9:
+    case HDMI_480p60:
+    case HDMI_480p60_16x9:
+    case HDMI_720p50:
+    case HDMI_720p60:
+    case HDMI_1080i50:
+    case HDMI_1080i60:
+    case HDMI_1080p24://1080p24 support
+    case HDMI_1080p50:
+    case HDMI_1080p60:
+    default:
         aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x08c38d0b);
-	}
-    aml_write_reg32(P_HHI_HDMI_PHY_CNTL1, 2);
-#endif
-#ifdef CONFIG_ARCH_MESON6
-//\\TODO
-    struct hdmi_phy_set_data *pdata = NULL;
-    power_mode = 1;
-    hdmi_phy_wakeup();
-    // relate to different board
-    if(hdmitx_device->config_data.phy_data){
-        pdata = hdmitx_device->config_data.phy_data;
-        printk("HDMI: get brd phy data\n");
-    }
-    printk("hdmi phy setting\n");
-#define SET_PHY_BRD(a)                                          \
-    do{                                                         \
-        pdata = hdmitx_device->config_data.phy_data;                    \
-        if(pdata){                                              \
-            while((pdata->addr != -1)){                         \
-                if(pdata->freq == a)                            \
-                    hdmi_wr_reg(pdata->addr, pdata->data);      \
-                pdata++;                                        \
-            }                                                   \
-        }                                                       \
-      }while(0)            
-    // Default Setting
-//    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xfe << HDMI_COMMON_b7_b0);    //0x10
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG1, (0xf  <<HDMI_CTL_REG_b3_b0) |
-                                     (0xe  << HDMI_COMMON_b11_b8));    //0x10
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG2, 0xff << HDMI_CTL_REG_b11_b4);   //0xf7
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG3, (0xf << HDMI_MDR_PU)|
-                                     (0x7 << HDMI_L2H_CTL));    //0x16
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG4, (0x2 << HDMI_PREM_CTL) |
-                                     (0x0 << HDMI_MODE) |
-                                     (0x1 << HDMI_PHY_CLK_EN) |
-                                     (0x0 << HDMI_LF_PD)
-                                     );      //0x14 Prem
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG5, (0x7 << HDMI_VCM_CTL) | 
-                                     (0x7 << HDMI_PREFCTL));         //0x15 Slew
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG6, (0xa << HDMI_SWING_CTL) | 
-                                     (0x0 << HDMI_RTERM_CTL) );
-    // relate to different board
-    switch(vic)
-    {
-
-        case HDMI_480i60:
-        case HDMI_480i60_16x9:
-        case HDMI_576p50:
-        case HDMI_576p50_16x9:
-        case HDMI_576i50:
-        case HDMI_576i50_16x9:            
-        case HDMI_480p60:
-        case HDMI_480p60_16x9:
-            SET_PHY_BRD(27);
-            break;
-        case HDMI_720p50:
-        case HDMI_720p60:
-        case HDMI_1080i50:
-        case HDMI_1080i60:
-        case HDMI_1080p24://1080p24 support
-            SET_PHY_BRD(74);
-            break;
-        case HDMI_1080p50:
-        case HDMI_1080p60:
-            SET_PHY_BRD(148);
-            break;
-        default:
-            break;
-    }
-    switch(power_mode){
-        case 1:
-//            hdmi_wr_reg(0x016, 0x02);
-//            hdmi_wr_reg(0x014, 0x02);  
-
-            hdmi_wr_reg(TX_CORE_CALIB_MODE, 0xc);
-            hdmi_wr_reg(TX_CORE_CALIB_VALUE, 0x0);
-//            hdmi_wr_reg(0x010, 0x2);
-//#ifdef MORE_LOW_P
-//            hdmi_wr_reg(0x010, 0x0);
-//            hdmi_wr_reg(0x01a, 0x3);
-//#endif        
-            break;
-        case 2:
-//            hdmi_wr_reg(0x017, 0x1f);
-//            hdmi_wr_reg(0x016, 0x01);
-//            hdmi_wr_reg(0x015, 0x03);
-//            hdmi_wr_reg(0x0ec, 0x0f);
-//            if(vic == HDMI_1080p60){
-//                hdmi_wr_reg(0x014, 0x02); //for 1080p only
-//            }
-//            else{
-//                hdmi_wr_reg(0x014, 0x0); 
-//            }
-            break;
-        default:
-//            hdmi_wr_reg(0x016, 0x03); //hdmi_wr_reg(0x016, 0x04);   // Bit[3:0] is HDMI-PHY's output swing control register
-//            hdmi_wr_reg(TX_CORE_CALIB_MODE, 0x8);
-//            hdmi_wr_reg(TX_CORE_CALIB_VALUE, 0xf);
-//#ifdef MORE_LOW_P
-//            hdmi_wr_reg(0x010, 0x3);
-//            hdmi_wr_reg(0x01a, 0xfb);
-//#endif            
-            break;
     }
-#endif
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL1, 2);
 }
 
 void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
 {
     unsigned int tmp_add_data;
-
-#ifdef CONFIG_ARCH_MESON8
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0xf, 23, 4); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V)
-#endif
-
-    HDMI_DEBUG();
+    HDMI_Video_Codes_t vic;
     
     digital_clk_on(7);
-//TODO    hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0x7);
-//#ifndef AML_A3
-//    if((hdmi_chip_type == HDMI_M1A)||(hdmi_pll_mode == 1)){
-//        aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x50e8);
-//    }
-//    else{
-//        aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x40e8);
-//    }
-//
-//    aml_write_reg32(P_HHI_VID_PLL_CNTL, 0x0000043e); 
-//
-//    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x00040003);
-//#endif
-#ifdef CONFIG_ARCH_MESON8
-    aml_set_reg32_bits(P_HHI_MEM_PD_REG0, 0x00, 8, 8);	//disable HDMI memory PD  TODO: set in suspend/resume
-#endif
+
+    aml_set_reg32_bits(P_HHI_MEM_PD_REG0, 0x00, 8, 8);    //disable HDMI memory PD  TODO: set in suspend/resume
+
     aml_write_reg32(P_HHI_HDMI_AFC_CNTL, aml_read_reg32(P_HHI_HDMI_AFC_CNTL) | 0x3);
-    // Configure HDMI TX serializer:
-    //hdmi_wr_reg(0x011, 0x0f);   //Channels Power Up Setting ,"1" for Power-up ,"0" for Power-down,Bit[3:0]=CK,Data2,data1,data1,data0 Channels ;
-  //hdmi_wr_reg(0x015, 0x03);   //slew rate
+
+    vic = hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0);
+    if(vic != HDMI_Unkown) {
+        hdmi_print(IMP, SYS "ALREADY init VIC = %d\n", vic);
+        hdmitx_device->cur_VIC = vic;
+        return;
+    }
+    hdmi_phy_suspend();
+    //todo
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0xf, 23, 4); //Enable reg1[23:24]:HDMI SDA(5v)/SCL(5V)
+
+    hdmi_print(IMP, SYS "hw init\n");
+
     hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down 
     if(serial_reg_val<0x20){
         hdmi_wr_reg(0x018, 0x24);
@@ -1410,11 +1153,9 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
     }
     hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK 
 
-    hdmi_hw_set_powermode(hdmitx_device, power_mode, 0);
+    hdmi_hw_set_powermode(hdmitx_device);
 
     hdmi_wr_reg(0x0F7, 0x0F);   // Termination resistor calib value
-  //hdmi_wr_reg(0x014, 0x07);   // This register is for pre-emphasis control ,we need test different TMDS Clcok speed then write down the suggested     value for each one ;
-  //hdmi_wr_reg(0x014, 0x01);   // This is a sample for Pre-emphasis setting ,recommended for 225MHz's TMDS Setting & ** meters HDMI Cable  
 
     // --------------------------------------------------------
     // Program core_pin_mux to enable HDMI pins
@@ -1423,34 +1164,19 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
     //wire            pm_hdmi_hpd_5v_en           = pin_mux_reg0[1];
     //wire            pm_hdmi_i2c_5v_en           = pin_mux_reg0[0];
 
-#ifdef CONFIG_ARCH_MESON6
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, !!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)), 25, 1);
-#endif
-//TODO M8
-
     // Enable these interrupts: [2] tx_edit_int_rise [1] tx_hpd_int_fall [0] tx_hpd_int_rise
     hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0x0);
     // HPD glitch filter
     hdmi_wr_reg(TX_HDCP_HPD_FILTER_L, 0xa0);
     hdmi_wr_reg(TX_HDCP_HPD_FILTER_H, 0xa0);
 
-//#ifdef AML_A3
-#if 1
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x90); //bit5,6 is converted
     delay_us(10);
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
     delay_us(10);
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
     delay_us(10);
-#else
-    //new reset sequence, 2010Sep09, rain
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0xf0);
-    delay_us(10);
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);
-    delay_us(10);
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
-    delay_us(10);
-#endif    
+
     /**/
 
     // Enable software controlled DDC transaction
@@ -1516,31 +1242,21 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
     
     hdmi_wr_reg(TX_AUDIO_CONTROL_MORE, 1);
 
-    hdmi_hw_set_powermode(hdmitx_device, power_mode, 0);
+    hdmi_hw_set_powermode(hdmitx_device);
 
     // --------------------------------------------------------
     // Release TX out of reset
     // --------------------------------------------------------
     //new reset sequence, 2010Sep09, rain
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
-        delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
-        delay_us(10);        
-//#ifdef AML_A3
-#if 1
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
-        delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
-        delay_us(10);
-#else
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x08);        
-        delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);        
-        delay_us(10);
-#endif        
-    /**/
-//    cec_init(hdmitx_device);
-//    cec_set_pending(TV_CEC_PENDING_OFF);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
+    delay_us(10);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
+    delay_us(10);        
+
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
+    delay_us(10);
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
+    delay_us(10);
 }    
 
 #ifdef CONFIG_ARCH_MESON6
@@ -1564,7 +1280,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     unsigned int tmp_add_data;
     unsigned long TX_OUTPUT_COLOR_FORMAT;
 
-    HDMI_DEBUG();
+    hdmi_print(IMP, SYS "hw reset\n");
     
     digital_clk_on(7);
 
@@ -1577,32 +1293,13 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     else{
         TX_OUTPUT_COLOR_FORMAT=0;
     }
-#ifndef AML_A3
-#ifdef CONFIG_ARCH_MESON6
-    // Configure HDMI PLL
-    if((hdmi_chip_type == HDMI_M1A)||(hdmi_pll_mode == 1)){
-        aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x50e8);
-    }
-    else{
-        aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x40e8);
-    }
 
-    if(new_reset_sequence_flag){
-        aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x00040003); //should turn on always for new reset sequence
-    }
-    else{
-        aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x00040003); 
-    }
-#endif
-#endif
     if(delay_flag&2)
         delay_us(1000*100);
     //printk("delay 100ms\n");
 
     aml_write_reg32(P_HHI_HDMI_AFC_CNTL, aml_read_reg32(P_HHI_HDMI_AFC_CNTL) | 0x3);
-    // Configure HDMI TX serializer:
-    //hdmi_wr_reg(0x011, 0x0f);   //Channels Power Up Setting ,"1" for Power-up ,"0" for Power-down,Bit[3:0]=CK,Data2,data1,data1,data0 Channels ;
-  //hdmi_wr_reg(0x015, 0x03);   //slew rate
+
     hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down 
     if(new_reset_sequence_flag==0){
         if(serial_reg_val==0){
@@ -1634,38 +1331,25 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     }
     hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK 
 
-    hdmi_hw_set_powermode(hdmitx_device, power_mode, param->VIC);
+    hdmi_hw_set_powermode(hdmitx_device);
 
     hdmi_wr_reg(0x0F7, 0x0F);   // Termination resistor calib value
-  //hdmi_wr_reg(0x014, 0x07);   // This register is for pre-emphasis control ,we need test different TMDS Clcok speed then write down the suggested     value for each one ;
-  //hdmi_wr_reg(0x014, 0x01);   // This is a sample for Pre-emphasis setting ,recommended for 225MHz's TMDS Setting & ** meters HDMI Cable  
-    
+
     // delay 1000uS, then check HPLL_LOCK
     delay_us(1000);
     //while ( (Rd(HHI_VID_PLL_CNTL3) & (1<<31)) != (1<<31) );
  
 //////////////////////////////reset    
     if(new_reset_sequence_flag){
-//#ifdef AML_A3
-#if 1
+
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x90);
         delay_us(10);
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
         delay_us(10);
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
         delay_us(10);
-#else
-        //new reset sequence, 2010Sep09, rain
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0xf0);
-        delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);
-        delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
-        delay_us(10);
-#endif        
     }
     else{
-#ifndef AML_A3
         // Keep TX (except register I/F) in reset, while programming the registers:
         tmp_add_data  = 0;
         tmp_add_data |= 1 << 7; // tx_pixel_rstn
@@ -1686,7 +1370,6 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         tmp_add_data |= 1 << 3; // HDMI_SR_RST
         tmp_add_data |= 1 << 0; // tx_dig_reset_n_ch3
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, tmp_add_data);
-#endif        
     }
     // Enable software controlled DDC transaction
     //tmp_add_data[15:8] = 0;
@@ -1879,7 +1562,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR1, 0xb6);
     }    
 
-    hdmi_hw_set_powermode(hdmitx_device, power_mode, param->VIC);
+    hdmi_hw_set_powermode(hdmitx_device);
     
     // --------------------------------------------------------
     // Release TX out of reset
@@ -1889,19 +1572,11 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
         delay_us(10);
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
-        delay_us(10);        
-//#ifdef AML_A3
-#if 1
+        delay_us(10);
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
         delay_us(10);
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
         delay_us(10);
-#else
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x08);        
-        delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);        
-        delay_us(10);
-#endif
         /* select serial*/
         if(serial_reg_val==0){
             if((param->VIC==HDMI_1080p30)||(param->VIC==HDMI_720p60)||(param->VIC==HDMI_1080i60)
@@ -1932,17 +1607,8 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         
     }
     else{
-#ifndef AML_A3
-#ifdef CONFIG_ARCH_MESON6
-        aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x00040000); // turn off phy_clk
-        delay_us(10);
-#endif    
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x01); // Release serializer resets
         delay_us(10);
-#ifdef CONFIG_ARCH_MESON6
-        aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x00040003); // turn on phy_clk
-        delay_us(10);
-#endif
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00); // Release reset on TX digital clock channel
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
         delay_us(10);
@@ -1955,9 +1621,8 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
             delay_us(10);
             hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);        
         }
-#endif        
     }
-#ifdef CONFIG_ARCH_MESON6
+#ifdef CONFIG_ARCH_MESON6       //todo
     if(param->VIC == HDMI_1080p50) {
         hdmi_reconfig_packet_setting();  // For 1080p50hz only
     }
@@ -1967,13 +1632,13 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
 static void hdmi_audio_init(unsigned char spdif_flag)
 {
     unsigned tmp_add_data;
-#if 1
+
     /* If TX_AUDIO_FORMAT is set as 0, "Channel Status" will not be sent out correctly */
     /* TX_AUDIO_CONTROL[bit 0] should be 1, otherwise no sound??? */
     unsigned char tx_i2s_spdif;
     unsigned char tx_i2s_8_channel;
     
-    hdmi_print(1,"%s[%d] %d\n", __FUNCTION__, __LINE__, spdif_flag);
+    hdmi_print(IMP, AUD "%s", spdif_flag ? "SPDIF" : "I2S");
     
     if(spdif_flag){
         tx_i2s_spdif=0;
@@ -2033,87 +1698,21 @@ static void hdmi_audio_init(unsigned char spdif_flag)
     hdmi_wr_reg(TX_SYS1_ACR_N_2, tmp_add_data); // 0xa0
 
     hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1); 
-#else
-/* reference register setting */
-/* this register setting works for spdif_flag==1*/
-    if(spdif_flag){
-        hdmi_wr_reg(TX_AUDIO_CONTROL,   0x40);  // Address  0x5D=0x40   TX_AUDIO_CONTROL
-        hdmi_wr_reg(TX_AUDIO_FIFO,   0x1 );  // Address  0x5B=0x1    TX_AUDIO_FIFO
-        hdmi_wr_reg(TX_AUDIO_CONTROL,   0x40);  // Address  0x5D=0x40   TX_AUDIO_CONTROL
-        hdmi_wr_reg(TX_AUDIO_FIFO,   0xD );  // Address  0x5B=0xD    TX_AUDIO_FIFO
-        hdmi_wr_reg(TX_AUDIO_FIFO,   0x3D);  // Address  0x5B=0x3D   TX_AUDIO_FIFO
-        hdmi_wr_reg(TX_AUDIO_LIPSYNC,   0x1 );  // Address  0x5C=0x1    TX_AUDIO_LIPSYNC
-        //hdmi_wr_reg(TX_AUDIO_PACK,   0x1 );  // Address  0x62=0x1    TX_AUDIO_PACK
-        hdmi_wr_reg(TX_AUDIO_CONTROL,   0x40);  // Address  0x5D=0x40   TX_AUDIO_CONTROL
-        hdmi_wr_reg(TX_AUDIO_HEADER,   0x0 );  // Address  0x5E=0x0    TX_AUDIO_HEADER
-//        hdmi_wr_reg(TX_HDCP_MODE,   0x0 );  // Address  0x2F=0x0    TX_HDCP_MODE
-//        hdmi_wr_reg(TX_HDCP_MODE,   0x0 );  // Address  0x2F=0x0    TX_HDCP_MODE
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,    0x20);  // Address  0x4=0x20    TX_SYS0_ACR_CTS_2
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,    0x20);  // Address  0x4=0x20    TX_SYS0_ACR_CTS_2
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,    0x20);  // Address  0x4=0x20    TX_SYS0_ACR_CTS_2
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,    0x20);  // Address  0x4=0x20    TX_SYS0_ACR_CTS_2
-        hdmi_wr_reg(TX_AUDIO_CONTROL,   0x40);  // Address  0x5D=0x40   TX_AUDIO_CONTROL
-        hdmi_wr_reg(TX_AUDIO_SAMPLE,   0x3 );  // Address  0x5F=0x3    TX_AUDIO_SAMPLE
-        hdmi_wr_reg(TX_AUDIO_CONTROL,   0x41);  // Address  0x5D=0x41   TX_AUDIO_CONTROL
-        //hdmi_wr_reg(0x280,  0x70);  // Address  0x280=0x70  TX_PKT_REG_AUDIO_INFO_BASE_ADDR
-        //hdmi_wr_reg(0x29E,  0xA );  // Address  0x29E=0xA
-        //hdmi_wr_reg(0x29D,  0x1 );  // Address  0x29D=0x1
-        //hdmi_wr_reg(0x29C,  0x84);  // Address  0x29C=0x84
-        //hdmi_wr_reg(0x281,  0x1 );  // Address  0x281=0x1
-        //hdmi_wr_reg(0x29F,  0x80);  // Address  0x29F=0x80
-        hdmi_wr_reg(TX_AUDIO_FORMAT,   0x0 );  // Address  0x58=0x0    TX_AUDIO_FORMAT
-        hdmi_wr_reg(TX_AUDIO_I2S,   0x0 );  // Address  0x5A=0x0    TX_AUDIO_I2S
-        hdmi_wr_reg(TX_AUDIO_SPDIF,   0x1 );  // Address  0x59=0x1    TX_AUDIO_SPDIF
-        hdmi_wr_reg(TX_SYS1_ACR_N_2,   0x0 );  // Address  0x1E=0x0    TX_SYS1_ACR_N_2
-        hdmi_wr_reg(TX_SYS1_ACR_N_1,   0x2D);  // Address  0x1D=0x2D   TX_SYS1_ACR_N_1
-        hdmi_wr_reg(TX_SYS1_ACR_N_0,   0x80);  // Address  0x1C=0x80   TX_SYS1_ACR_N_0
-    }
-    else{
-        hdmi_wr_reg(TX_AUDIO_CONTROL,                   0x40); //Address  0x5D=0x40
-        hdmi_wr_reg(TX_AUDIO_FIFO,                      0x1 ); //Address  0x5B=0x1
-        hdmi_wr_reg(TX_AUDIO_CONTROL,                   0x40); //Address  0x5D=0x40
-        hdmi_wr_reg(TX_AUDIO_FIFO,                      0xD ); //Address  0x5B=0xD
-        hdmi_wr_reg(TX_AUDIO_FIFO,                      0x3D); //Address  0x5B=0x3D
-        hdmi_wr_reg(TX_AUDIO_LIPSYNC,                   0x1 ); //Address  0x5C=0x1
-        //hdmi_wr_reg(TX_AUDIO_PACK,                      0x1 ); //Address  0x62=0x1
-        hdmi_wr_reg(TX_AUDIO_CONTROL,                   0x40); //Address  0x5D=0x40
-        hdmi_wr_reg(TX_AUDIO_HEADER,                    0x0 ); //Address  0x5E=0x0
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,                  0x20); //Address  0x4=0x20
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,                  0x20); //Address  0x4=0x20
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,                  0x20); //Address  0x4=0x20
-        hdmi_wr_reg(TX_SYS0_ACR_CTS_2,                  0x20); //Address  0x4=0x20
-        hdmi_wr_reg(TX_AUDIO_CONTROL,                   0x40); //Address  0x5D=0x40
-        hdmi_wr_reg(TX_AUDIO_SAMPLE,                    0x15); //Address  0x5F=0x15
-        hdmi_wr_reg(TX_AUDIO_CONTROL,                   0x41); //Address  0x5D=0x41
-        hdmi_wr_reg(TX_AUDIO_FORMAT,                    0x0 ); //Address  0x58=0x0
-        hdmi_wr_reg(TX_AUDIO_HEADER,                    0x0 ); //Address  0x5E=0x0
-        hdmi_wr_reg(TX_AUDIO_SAMPLE,                    0x3 ); //Address  0x5F=0x3
-        hdmi_wr_reg(TX_AUDIO_SPDIF,                     0x0 ); //Address  0x59=0x0
-        hdmi_wr_reg(TX_AUDIO_FORMAT,                    0x80); //Address  0x58=0x80
-        hdmi_wr_reg(TX_AUDIO_I2S,                       0x1 ); //Address  0x5A=0x1
-        hdmi_wr_reg(TX_AUDIO_FORMAT,                    0x81); //Address  0x58=0x81
-        hdmi_wr_reg(TX_AUDIO_FORMAT,                    0xA1); //Address  0x58=0xA1
-        hdmi_wr_reg(TX_SYS1_ACR_N_2,                    0x0 ); //Address  0x1E=0x0
-        hdmi_wr_reg(TX_SYS1_ACR_N_1,                    0x2D); //Address  0x1D=0x2D
-        hdmi_wr_reg(TX_SYS1_ACR_N_0,                    0x80); //Address  0x1C=0x80
-    } 
-#endif      
 }
 
 static void enable_audio_spdif(void)
-{
-    
-    printk("Enable audio spdif to HDMI\n");
+{    
+    hdmi_print(INF, AUD "Enable audio spdif to HDMI\n");
 
     /* enable audio*/        
-        hdmi_wr_reg(TX_AUDIO_I2S,   0x0 );  // Address  0x5A=0x0    TX_AUDIO_I2S
+    hdmi_wr_reg(TX_AUDIO_I2S,   0x0 );  // Address  0x5A=0x0    TX_AUDIO_I2S
 
-        hdmi_wr_reg(TX_AUDIO_SPDIF, 1); // TX AUDIO SPDIF Enable
+    hdmi_wr_reg(TX_AUDIO_SPDIF, 1); // TX AUDIO SPDIF Enable
 }
 
 static void enable_audio_i2s(void)
 {
-    printk("Enable audio i2s to HDMI\n");
+    hdmi_print(INF, AUD "Enable audio i2s to HDMI\n");
     hdmi_wr_reg(TX_AUDIO_I2S,   0x1 );  // Address  0x5A=0x0    TX_AUDIO_I2S
     hdmi_wr_reg(TX_AUDIO_SPDIF, 0); // TX AUDIO SPDIF Enable
 }    
@@ -2121,92 +1720,7 @@ static void enable_audio_i2s(void)
 /************************************
 *    hdmitx hardware level interface
 *************************************/
-static unsigned char hdmitx_getediddata(hdmitx_dev_t* hdmitx_device)
-{
-    if(hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<4)){
-        if((hdmitx_device->cur_edid_block+2)<=EDID_MAX_BLOCK){
-            int ii, jj;
-            for(jj=0;jj<2;jj++){
-#ifdef LOG_EDID
-                int edid_log_pos=0;
-                edid_log_pos+=snprintf((char*)hdmitx_device->tmp_buf+edid_log_pos, HDMI_TMP_BUF_SIZE-edid_log_pos, "EDID Interrupt cur block %d:",hdmitx_device->cur_edid_block);
-#endif
-                for(ii=0;ii<128;ii++){
-                    hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]
-                        =hdmi_rd_reg(0x600+hdmitx_device->cur_phy_block_ptr*128+ii);
-
-#ifdef LOG_EDID
-                    if((ii&0xf)==0)
-                        edid_log_pos+=snprintf((char*)hdmitx_device->tmp_buf+edid_log_pos, HDMI_TMP_BUF_SIZE-edid_log_pos, "\n");
-                    edid_log_pos+=snprintf((char*)hdmitx_device->tmp_buf+edid_log_pos, HDMI_TMP_BUF_SIZE-edid_log_pos, "%02x ",hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]);
-#endif                    
-                }
-#ifdef LOG_EDID
-                hdmitx_device->tmp_buf[edid_log_pos]=0;
-                hdmi_print_buf((char*)hdmitx_device->tmp_buf, strlen((char*)hdmitx_device->tmp_buf));
-                hdmi_print(0,"\n");
-#endif
-                hdmitx_device->cur_edid_block++;
-                hdmitx_device->cur_phy_block_ptr++;
-                hdmitx_device->cur_phy_block_ptr=hdmitx_device->cur_phy_block_ptr&0x3;
-            }
-        }        
-        return 1;
-    }
-    else{
-        return 0;
-    }    
-}    
-
-static void check_chip_type(void)
-{
-#ifndef AML_A3
-    if(aml_read_reg32(P_HHI_MPEG_CLK_CNTL)&(1<<11)){ //audio pll is selected as video clk
-			if(hdmi_chip_type != HDMI_M1A){
-			    hdmi_chip_type = HDMI_M1A; 
-			    hdmi_print(1,"Set HDMI:Chip A\n");
-			}
-    }
-    else{
-			if((hdmi_chip_type != HDMI_M1B)&&(hdmi_chip_type != HDMI_M1C)){
-          hdmi_chip_type = HDMI_M1C;     			    
-			    hdmi_print(1,"Set HDMI:Chip C\n");
-			}
-		}
-#endif		
-}
-
-#if 0
-// Only applicable if external HPD is on and stable.
-// This function generates an HDMI TX internal sys_trigger pulse that will
-// restart EDID and then HDCP transfer on DDC channel.
-static void restart_edid_hdcp (void)
-{
-    // Force clear HDMI TX internal sys_trigger
-    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<6)); // Release sys_trigger_config
-    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<1)); // Assert sys_trigger_config_semi_manu
-    // Wait some time for both TX and RX to reset DDC channel
-    delay_us(10);
-    // Recover HDMI TX internal sys_trigger
-    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<6)); // Assert sys_trigger_config
-    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<1)); // Release sys_trigger_config_semi_manu
-}
-#endif
 
-//static void hdmitx_set_tvenc_reg(int cur_VIC)
-//{
-//    int i,j;
-//    for(i=0;hdmi_tvenc_configs[i].vic!=HDMI_Unkown;i++){
-//        if(cur_VIC==hdmi_tvenc_configs[i].vic){
-//            const  reg_t* reg_set=hdmi_tvenc_configs[i].reg_set;
-//            for(j=0;reg_set[j].reg;j++){
-//                Wr(reg_set[j].reg,reg_set[j].val);
-//            }
-//            break;
-//        }
-//    }
-//}    
- 
 static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag) 
 {
     int i,j;
@@ -2232,12 +1746,12 @@ static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
             for(j=0;reg_set[j].reg;j++){
                 if(reg_set[j].reg==reg){
                     reg_set[j].val = val;    
-                    hdmi_print(1, "set [%08x]=%08x\n",reg_set[j].reg, reg_set[j].val);
+                    hdmi_print(INF, SYS "set [%08x]=%08x\n",reg_set[j].reg, reg_set[j].val);
                     break;
                 }
             }
             if(reg_set[j].reg == 0){
-                hdmi_print(1, "no [%08x] in config\n", reg);
+                hdmi_print(INF, SYS "no [%08x] in config\n", reg);
             }
             break;
         }
@@ -2246,34 +1760,10 @@ static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
 
 static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
 {
-    HDMI_DEBUG();
-    printk("param->VIC:%d\n", param->VIC);
+    hdmi_print(IMP, SYS "set pll\n");
+    hdmi_print(IMP, SYS "param->VIC:%d\n", param->VIC);
     
     cur_vout_index = get_cur_vout_index();
-//    Wr_reg_bits(VPU_HDMI_SETTING, 2, 0, 2);     //[ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
-    
-    //reset HHI_VID_DIVIDER_CNTL
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, aml_read_reg32(P_HHI_VID_DIVIDER_CNTL)|(1<<7));    //0x1066[7]:SOFT_RESET_POST
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, aml_read_reg32(P_HHI_VID_DIVIDER_CNTL)|(1<<3));    //0x1066[3]:SOFT_RESET_PRE
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, aml_read_reg32(P_HHI_VID_DIVIDER_CNTL)&(~(1<<1)));    //0x1066[1]:RESET_N_POST
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, aml_read_reg32(P_HHI_VID_DIVIDER_CNTL)&(~(1<<0)));    //0x1066[0]:RESET_N_PRE
-//    msleep(2);
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, aml_read_reg32(P_HHI_VID_DIVIDER_CNTL)&(~((1<<7)|(1<<3))));
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, aml_read_reg32(P_HHI_VID_DIVIDER_CNTL)|((1<<1)|(1<<0)));
-//
-//    aml_write_reg32(P_HHI_VID_DIVIDER_CNTL, 0x10843);          //0x1066, set vid_pll_clk = HPLL_CLK_OUT_DIG / 5
-//
-//    if(cur_vout_index !=2 ){
-//        aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 16, 3);    //0x105f    0: vid_pll_clk
-//        aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0x1f, 0, 5);     //0x105f    1: DIV1_EN
-//        aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);    //0x105f    1: CLK_EN0
-//    }
-#ifdef CONFIG_ARCH_MESON6
-    M6_PLL_RESET(P_HHI_VID_PLL_CNTL);
-	aml_write_reg32(P_HHI_VID_PLL_CNTL2, M6_VID_PLL_CNTL_2 );
-	aml_write_reg32(P_HHI_VID_PLL_CNTL3, M6_VID_PLL_CNTL_3 );
-	aml_write_reg32(P_HHI_VID_PLL_CNTL4, M6_VID_PLL_CNTL_4 );
-#endif
     switch(param->VIC)
     {
         case HDMI_480p60:
@@ -2290,16 +1780,6 @@ static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
             break;
         case HDMI_576i50:
         case HDMI_576i50_16x9:
-//            //Wr(HHI_VID_PLL_CNTL, (3<<18)|(2<<10)|(90<<0));    //27MHz=24MHz*45/4/10
-//            aml_write_reg32(P_HHI_VID_PLL_CNTL, 0xc042d);//use value 0x42d calculated by "m3_pll_video.pl 1080 24 pll_out hpll"
-//            if(cur_vout_index !=2 ){
-//                aml_write_reg32(P_HHI_VID_CLK_DIV, 3);      //0x1059
-//                aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 1, 16, 4);   //cts_hdmi_tx_pixel_clk from clk_div2
-//            }
-//            else{
-
-//                aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 9, 16, 4);   //cts_hdmi_tx_pixel_clk from v2_clk_div2
-//            }
             set_vmode_clk(VMODE_576I);
             break;
         case HDMI_1080p24://1080p24 support
@@ -2313,48 +1793,20 @@ static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
             break;
         case HDMI_1080i60:
         case HDMI_1080i50:
-//            //Wr(HHI_VID_PLL_CNTL, (12<<10)|(371<<0));    //74.2MHz=24MHz*371/12/10
-//            aml_write_reg32(P_HHI_VID_PLL_CNTL, 0x5043e);//use value 0x15043e (0x15043e does not work in some TV, use 0x5043e) calculated by "m3_pll_video.pl 742.5 24 pll_out hpll", 
-//            if(cur_vout_index !=2 ){
-//                aml_write_reg32(P_HHI_VID_CLK_DIV, 0);      //0x1059
-//                aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 1, 16, 4);   //cts_hdmi_tx_pixel_clk from clk_div2
-//            }
-//            else{
-//                aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 9, 16, 4);   //cts_hdmi_tx_pixel_clk from v2_clk_div2
-//            }
             set_vmode_clk(VMODE_1080I);
             break;
         case HDMI_1080p60:
         case HDMI_1080p50:
-//            //Wr(HHI_VID_PLL_CNTL, (6<<10)|(371<<0));    //148.4MHz=24MHz*371/6/10
-//            aml_write_reg32(P_HHI_VID_PLL_CNTL, 0x43e);//use value calculated by "m3_pll_video.pl 1485 24 pll_out hpll"
-//            if(cur_vout_index !=2 ){
-//                aml_write_reg32(P_HHI_VID_CLK_DIV, 1);      //0x1059
-//                aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 16, 4);   //0x1073, cts_hdmi_tx_pixel_clk from clk_div1
-//            }
-//            else{
-//                aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 8, 16, 4);   //cts_hdmi_tx_pixel_clk from v2_clk_div1
-//            }
             set_vmode_clk(VMODE_1080P);
             break;
         case HDMI_4k2k_30:
         case HDMI_4k2k_25:
         case HDMI_4k2k_24:
-        case HDMI_4k2k_smpte:
+        case HDMI_4k2k_smpte_24:
             set_vmode_clk(VMODE_4K2K_24HZ);
         default:
             break;
     }
-#ifdef CONFIG_ARCH_MESON6
-    // Reset the exact pll for 148.5 and 74.25 MHz
-    // if we find that current VCO outputs 1488,
-    // then we will set to 1485, equals to 24MHz * 495 / 8, 
-    // to get exactly clock for 720/1080 mode
-    if((aml_read_reg32(P_HHI_VID_PLL_CNTL) & 0x3fff ) == 0x43e) {
-        aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x21ef, 0, 15);
-    }
-    M6_PLL_WAIT_FOR_LOCK(P_HHI_VID_PLL_CNTL);
-#endif
 }
 
 static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *param)
@@ -2370,22 +1822,19 @@ static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t
         &&(param->VIC!=HDMI_1080p24)
         &&(param->VIC!=HDMI_1080p60)&&(param->VIC!=HDMI_1080p50)
         &&(param->VIC!=HDMI_720p60)&&(param->VIC!=HDMI_720p50)
-        &&(param->VIC!=HDMI_4k2k_30)&&(param->VIC!=HDMI_4k2k_25)&&(param->VIC!=HDMI_4k2k_24)&&(param->VIC!=HDMI_4k2k_smpte)
+        &&(param->VIC!=HDMI_4k2k_30)&&(param->VIC!=HDMI_4k2k_25)&&(param->VIC!=HDMI_4k2k_24)&&(param->VIC!=HDMI_4k2k_smpte_24)
         &&(param->VIC!=HDMI_1080i60)&&(param->VIC!=HDMI_1080i50)){
         return -1;
     }
 
-    check_chip_type(); /* check chip_type again */
-    if((hdmi_chip_type == HDMI_M1B || hdmi_chip_type == HDMI_M1C)&&(color_depth_f != 0)){
-        if(color_depth_f==24)
-            param->color_depth = COLOR_24BIT;
-        else if(color_depth_f==30)
-            param->color_depth = COLOR_30BIT;
-        else if(color_depth_f==36)
-            param->color_depth = COLOR_36BIT;
-        else if(color_depth_f==48)
-            param->color_depth = COLOR_48BIT;
-    }
+    if(color_depth_f==24)
+        param->color_depth = COLOR_24BIT;
+    else if(color_depth_f==30)
+        param->color_depth = COLOR_30BIT;
+    else if(color_depth_f==36)
+        param->color_depth = COLOR_36BIT;
+    else if(color_depth_f==48)
+        param->color_depth = COLOR_48BIT;
     hdmi_print(1,"set mode VIC %d (cd%d,cs%d,pm%d,vd%d,%x) \n",param->VIC, color_depth_f, color_space_f,power_mode,power_off_vdac_flag,serial_reg_val);
     if(color_space_f != 0){
         param->color = color_space_f;
@@ -2414,42 +1863,16 @@ static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t
         case HDMI_4k2k_30:
         case HDMI_4k2k_25:
         case HDMI_4k2k_24:
-        case HDMI_4k2k_smpte:
+        case HDMI_4k2k_smpte_24:
             hdmi_tvenc4k2k_set(param);
             break;
         default:
             hdmi_tvenc_set(param);
         }
-    
-//    if(use_tvenc_conf_flag==1){
-//        if((param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)){
-//            hdmitx_set_tvenc_reg(param->VIC);    
-//        }
-//        else{
-//            goto set_tvenc;
-//        }
-//    }
-//    else if(use_tvenc_conf_flag==2){
-//            hdmitx_set_tvenc_reg(param->VIC);    
-//        }        
-//    else{
-//set_tvenc:        
-//        if((param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)
-//            ||(param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
-//            hdmi_tvenc480i_set(param);
-//        }            
-//        else if((param->VIC==HDMI_1080i60)||(param->VIC==HDMI_1080i50)){
-//            hdmi_tvenc1080i_set(param);
-//        } 
-//        else{
-//            hdmi_tvenc_set(param);
-//        }
-//    }
     hdmitx_dump_tvenc_reg(param->VIC, 0);
 
-    hdmitx_special_handler_video(hdmitx_device);
+//todo     hdmitx_special_handler_video(hdmitx_device);
 
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xdc);
     // reset TX_SYS5_TX_SOFT_RESET_1/2 twice
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0xff);
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x9f);
@@ -2465,13 +1888,6 @@ static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
     mdelay(5);
 
-    // power comsumption
-#ifdef CONFIG_MESON_POWER_PROFILE_LOW
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xf0);
-#else
-    hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, 0xfe);
-#endif
-    
     return 0;
 }    
 
@@ -2527,14 +1943,6 @@ static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
     else{
         hdmi_wr_reg(pkt_reg_base+0x1F, 0x0);        // disable packet generation
     }
-#if 0
-    printk("AVI:%02x\n",ucData);
-    for(i=0;i<13;i++)
-        printk("%02x ", DB[i]);
-    printk("\n");
-    for(i=0;i<3;i++)
-        printk("%02x ", HB[i]);
-#endif    
 }
 
 
@@ -2577,10 +1985,10 @@ static void set_hdmi_audio_source(unsigned int src)
     switch(src)
     {
         case 0:
-            printk("No audio clock to HDMI\n");
+            hdmi_print(ERR, AUD "No audio clock to HDMI\n");
             break;
         case 1:
-            printk("PCM out to HDMI\n");//SPDIF
+            hdmi_print(IMP, AUD "PCM out to HDMI\n");//SPDIF
             // Enable HDMI audio clock from the selected source
             data32  = 0;
             data32 |= 0      << 4;  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
@@ -2599,10 +2007,10 @@ static void set_hdmi_audio_source(unsigned int src)
                     break;
             }
             if(i>100000)
-                printk("Time out: AIU_HDMI_CLK_DATA_CTRL\n");
+                hdmi_print(ERR, AUD "Time out: AIU_HDMI_CLK_DATA_CTRL\n");
            break;
         case 2:
-            printk("I2S out to HDMI\n");//I2S
+            hdmi_print(INF, AUD "I2S out to HDMI\n");//I2S
             // Enable HDMI audio clock from the selected source
             data32  = 0;
             data32 |= 0      << 4;  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
@@ -2621,7 +2029,7 @@ static void set_hdmi_audio_source(unsigned int src)
                     break;
             }
             if(i>100000)
-            printk("Time out: AIU_HDMI_CLK_DATA_CTRL !\n");
+            hdmi_print(ERR, AUD "Time out: AIU_HDMI_CLK_DATA_CTRL !\n");
             // Enable HDMI I2S input from the selected source
             data32  = 0;
             data32 |= 2   << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
@@ -2636,58 +2044,12 @@ static void set_hdmi_audio_source(unsigned int src)
                     break;
             }
             if(i>100000)
-                printk("Time out: AIU_HDMI_CLK_DATA_CTRL...\n");
+                hdmi_print(ERR, AUD "Time out: AIU_HDMI_CLK_DATA_CTRL...\n");
             break;
         default:
-            printk("Audio Src clock to HDMI Error\n");
+            hdmi_print(ERR, AUD "Audio Src clock to HDMI Error\n");
             break;
     }
-    
-#if 0
-    // Disable HDMI audio clock input and its I2S input
-    data32  = 0;
-    data32 |= 0     << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= 0     << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-//    Wr(AIU_HDMI_CLK_DATA_CTRL, data32);
-    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
-
-    // Enable HDMI audio clock from the selected source
-    data32  = 0;
-    data32 |= 0      << 4;  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= src   << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
-    
-    // Wait until clock change is settled
-
-    i = 0;
-    while ( (((aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL))>>8)&0x3) != src ) {
-//        if (i > 255) {
-//            //stimulus_print("[TEST.C] Error: set_hdmi_audio_source timeout!\n");
-//            //stimulus_finish_fail(10);
-//        }
-        i ++;
-        if(i>100000)
-            break;
-    }
-    if(i>100000)
-        printk("Time out: AIU_HDMI_CLK_DATA_CTRL\n");
-
-    // Enable HDMI I2S input from the selected source
-    data32  = 0;
-    data32 |= src   << 4;   // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
-    data32 |= src   << 0;   // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
-    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, 0x2);
-
-    // Wait until data change is settled
-    i = 0;
-    while ((((aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL))>>12)&0x3) != src ) {
-        i++;
-        if(i>100000)
-            break;
-    }
-    if(i>100000)
-        printk("Time out: AIU_HDMI_CLK_DATA_CTRL\n");
-#endif
 } /* set_hdmi_audio_source */
 
 static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio_para_t* audio_param)
@@ -2695,10 +2057,8 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
     unsigned int audio_N_para = 6272;
     unsigned int audio_N_tolerance = 3;
 //    unsigned int audio_CTS = 30000;
-
-    hdmi_print(0,"HDMI DEBUG [%s] hdmitx_device->cur_VIC=[%d]\n", __FUNCTION__, hdmitx_device->cur_VIC);
     
-    printk("HDMI: audio channel num is %d\n", hdmitx_device->cur_audio_param.channel_num);
+    hdmi_print(INF, AUD "audio channel num is %d\n", hdmitx_device->cur_audio_param.channel_num);
 
     if(!hdmi_audio_off_flag){
         hdmi_audio_init(i2s_to_spdif_flag);
@@ -2708,8 +2068,8 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
     }
 
 //Refer to HDMI SPEC V1.4 Page 137
-    printk("current VIC: %d\n", hdmitx_device->cur_VIC);
-    printk("audio sample rate: %d\n", audio_param->sample_rate);
+    hdmi_print(INF, AUD "current VIC: %d\n", hdmitx_device->cur_VIC);
+    hdmi_print(INF, AUD "audio sample rate: %d\n", audio_param->sample_rate);
     switch(hdmitx_device->cur_VIC)
     {
         //TMDS Clock:27MHz
@@ -2816,7 +2176,7 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
             break;
     }    
 
-    printk("HDMI: reset audio N para\n");
+    hdmi_print(INF, AUD "reset audio N para\n");
     switch(audio_param->sample_rate){
         case FS_44K1:
             audio_N_para = 6272 * 2;
@@ -2848,8 +2208,8 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
             break;
         case CT_ONE_BIT_AUDIO:
             break;
-	case CT_DOLBY_D:
-	    audio_N_para *= 4;   
+        case CT_DOLBY_D:
+            audio_N_para *= 4;
             break;
         case CT_DTS_HD:
             break;
@@ -2874,7 +2234,7 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
     
     set_hdmi_audio_source(i2s_to_spdif_flag ? 1 : 2);
     
-    printk("i2s_to_spdif_flag:%d \n", i2s_to_spdif_flag);
+    hdmi_print(INF, AUD "i2s_to_spdif_flag:%d \n", i2s_to_spdif_flag);
     if(i2s_to_spdif_flag)
         enable_audio_spdif();
     else
@@ -2884,7 +2244,7 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
         hdmi_wr_reg(TX_AUDIO_FORMAT, (hdmi_rd_reg(TX_AUDIO_FORMAT) & 0xfe));        // clear bit0, use channel status bit from input data
     }
 
-    hdmitx_special_handler_audio(hdmitx_device);
+//todo    hdmitx_special_handler_audio(hdmitx_device);
 
     return 0;
 }    
@@ -2895,8 +2255,6 @@ static void hdmitx_setupirq(hdmitx_dev_t* hdmitx_device)
    r = request_irq(INT_HDMI_TX, &intr_handler,
                     IRQF_SHARED, "amhdmitx",
                     (void *)hdmitx_device);
-//    aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR);
-//    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK)|(1 << 25));
 }    
 
 
@@ -2983,9 +2341,9 @@ static void turn_on_prbs_mode(int prbs_mode)
                                     //       2=output 1-bit differential pattern; 3=output 10-bit pattern
     tmp_add_data    |= 0    << 3;   //   [3] Rsrv
     tmp_add_data    |= 0    << 0;   // [2:0] tmds_repeat_bist_pattern[2:0]
-   hdmi_wr_reg(TX_SYS0_BIST_CONTROL, tmp_add_data); // 0xb0
+    hdmi_wr_reg(TX_SYS0_BIST_CONTROL, tmp_add_data); // 0xb0
 
-   printk("PRBS mode %d On\n", prbs_mode);
+    hdmi_print(INF, SYS "PRBS mode %d On\n", prbs_mode);
 }
     
 #endif
@@ -2995,9 +2353,6 @@ static void hdmitx_uninit(hdmitx_dev_t* hdmitx_device)
     //aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR);
     //aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK)&(~(1 << 25)));
     free_irq(INT_HDMI_TX, (void *)hdmitx_device);
-#ifdef HPD_DELAY_CHECK
-    del_timer(&hpd_timer);    
-#endif
     hdmi_print(1,"power off hdmi, unmux hpd\n");
     
     phy_pll_off();
@@ -3036,13 +2391,9 @@ const static hdcp_sub_t hdcp_monitor_array[] = {
     {"TmdsMod ", TX_TMDS_MODE, 1},
 };
 
-static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
+static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
 {
-    if(cmd == HDMITX_HWCMD_POWERMODE_SWITCH){
-        power_mode=argv;
-        hdmi_hw_set_powermode(hdmitx_device, power_mode, hdmitx_device->cur_VIC);
-    }
-    else if(cmd == HDMITX_AVMUTE_CNTL) {
+    if(cmd == HDMITX_AVMUTE_CNTL) {
         if(argv == AVMUTE_SET) {
             hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)&(~(1<<4)));
             hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)|(1<<5));
@@ -3065,30 +2416,15 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
     }
     else if(cmd == HDMITX_EARLY_SUSPEND_RESUME_CNTL) {
         if(argv == HDMITX_EARLY_SUSPEND) {
-#ifdef CONFIG_ARCH_MESON6
-            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);
-#endif
-#ifdef CONFIG_ARCH_MESON8
             aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);
             hdmi_phy_suspend();
-#endif
         }
         if(argv == HDMITX_LATE_RESUME) {
-#ifdef CONFIG_ARCH_MESON6
-            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);
-            M6_PLL_WAIT_FOR_LOCK(P_HHI_VID_PLL_CNTL);
-#endif
-#ifdef CONFIG_ARCH_MESON8
             aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);
             hdmi_phy_wakeup();
-#endif
         }
         return 0;
     }
-    else if(cmd == HMDITX_PHY_SUSPEND) {
-        hdmi_phy_suspend();
-        return 0;
-    }
     else if(cmd == HDMITX_HDCP_MONITOR) {
         int i, len, st;
         int array = sizeof(hdcp_monitor_array) / sizeof(hdcp_sub_t);
@@ -3099,7 +2435,7 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
             return 0;
 
         memset(hdcp_log_buf, 0, HDMITX_HDCP_MONITOR_BUF_SIZE);
-        printk("\n\nHDMI: Monitor HDCP start\n");
+        hdmi_print(INF, HDCP "\n\nMonitor HDCP start\n");
         pos = 0;
         for(i = 0; i < array; i ++){
             len = hdcp_monitor_array[i].hdcp_sub_len;
@@ -3115,67 +2451,20 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
                                             ? "OK\n" : "BAD\n"
                        );
         printk("%s", hdcp_log_buf);
-        printk("HDMI: Monitor HDCP end\n");
+        hdmi_print(INF, HDCP "Monitor HDCP end\n");
         return 0;
     }
     else if(cmd == HDMITX_IP_SW_RST){
-		return 0;	//TODO
+        return 0;    //TODO
         aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0, hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0) | (argv));
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0, hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL0) & (~(argv)));
         aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)&(~(1<<16)));
-        printk("HDMI: reset IP: 0x%x\n", argv);
-        return 0;
-    }
-    else if(cmd == HDMITX_TMDS_PHY_CNTL) {
-        return 0;
-        if(argv == PHY_OFF) {
-           hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, hdmi_rd_reg(TX_HDMI_PHY_CONFIG0) & (~(1 << 5)));
-           hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, hdmi_rd_reg(TX_HDMI_PHY_CONFIG0) & (~(1 << 1)));
-        }
-        if(argv == PHY_ON) {
-           hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, hdmi_rd_reg(TX_HDMI_PHY_CONFIG0) | (1 << 5));
-           hdmi_wr_reg(TX_HDMI_PHY_CONFIG0, hdmi_rd_reg(TX_HDMI_PHY_CONFIG0) | (1 << 1));
-        }
+        hdmi_print(INF, SYS "reset IP: 0x%x\n", argv);
         return 0;
     }
-    else if(cmd == HDMITX_HDCP_CNTL) {
-		return 0;//todo
-        if(argv == HDCP_OFF ) {
-            hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)&(~0xC0)); //disable authentication
-            printk("HDMITX: HDCP disable\n");
-            return 0;
-        }
-        if(argv == HDCP_ON ) {
-            char aksv[5];
-
-            hdmi_hdcp_get_aksv(aksv, 0);
-            if(hdcp_ksv_valid(aksv) == 1) {
-                hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)|0x80); //enable authentication
-                printk("HDMITX: HDCP enable\n");
-            }
-            else {
-#ifdef CONFIG_AM_HDMI_REPEATER
-                hdmi_wr_reg(TX_HDCP_MODE, hdmi_rd_reg(TX_HDCP_MODE)|0x80); //enable authentication
-#endif
-                printk("HDMITX: HDCP Key error\n");
-            }
-            return 0;
-        }
-        if(argv == IS_HDCP_ON ){
-            return !!(hdmi_rd_reg(TX_HDCP_MODE) & 0x80);
-        }
-        
-#ifdef CONFIG_AM_HDMI_REPEATER
-        if(argv == HDCP_RESET ){
-            printk("hdcp reset\n");
-            hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<6)); // Release sys_trigger_config
-            hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<6)); // assert sys_trigger_config
-        }
-#endif
-    }
     else if(cmd == HDMITX_CBUS_RST) {
-		return 0;//todo
+        return 0;//todo
         aml_set_reg32_bits(P_RESET2_REGISTER, 1, 15, 1);
         msleep(50);
         hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_INTR_STAT_CLR, 0x7);
@@ -3193,18 +2482,8 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
         }
         return 0;
     }
-    else if(cmd == HDMITX_AUDIO_CNTL) {
-        return 0;   //todo
-        if(argv == AUDIO_OFF) {
-            hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // disable audio sample packets
-        }
-        else if(argv == AUDIO_ON) {
-            hdmi_wr_reg(TX_AUDIO_PACK, 0x01); // disable audio sample packets
-        }
-        return 0;
-    }
     else if(cmd == HDMITX_IP_INTR_MASN_RST){
-        printk("HDMI: reset intr mask\n");
+        hdmi_print(INF, SYS "reset intr mask\n");
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0);
         msleep(2);
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0x7);
@@ -3216,7 +2495,7 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
                 hdmitx_device->internal_mode_change = 0;
                 msleep(500);
                 if(read_hpd_gpio()){
-                hdmi_print(1,"mux hpd\n");
+                hdmi_print(IMP, HPD "mux hpd\n");
                 digital_clk_on(4);
                 delay_us(1000*100);
                 mux_hpd();
@@ -3224,18 +2503,6 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
             }
         }
     }
-    else if(cmd == HDMITX_HWCMD_HPD_GPI_TEST) {
-        return read_hpd_gpio();
-    }
-    else if(cmd == HDMITX_HWCMD_HPD_RESET){
-#ifdef CONFIG_ARCH_MESON6
-        aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1) & (~(1<<22)) );        //unmux
-        aml_write_reg32(P_PREG_PAD_GPIO2_EN_N, aml_read_reg32(P_PREG_PAD_GPIO2_EN_N) & (~(1<<10)));
-        aml_write_reg32(P_PREG_PAD_GPIO2_O, aml_read_reg32(P_PREG_PAD_GPIO2_O) & (~(1<<10)));
-        msleep(1000);
-        aml_write_reg32(P_PERIPHS_PIN_MUX_1, aml_read_reg32(P_PERIPHS_PIN_MUX_1) | (1<<22) );
-#endif
-    }    
     else if(cmd == HDMITX_HWCMD_MUX_HPD){
          mux_hpd();
     } 
@@ -3245,129 +2512,42 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, int cmd, unsigned argv)
 //        WRITE_MPEG_REG(VENC_DVI_SETTING, READ_MPEG_REG(VENC_DVI_SETTING)&(~(1<<13))); //bit 13 is used by HDMI only
 //        digital_clk_on(4); //enable sys clk so that hdmi registers can be accessed when calling phy_pll_off/digit_clk_off
         if(unmux_hpd_flag){
-            hdmi_print(1,"power off hdmi, unmux hpd\n");
+            hdmi_print(IMP, SYS "power off hdmi, unmux hpd\n");
             phy_pll_off();
             digital_clk_off(4); //off sys clk
             unmux_hpd();
         }
         else{
-            hdmi_print(1,"power off hdmi\n");
+            hdmi_print(IMP, SYS "power off hdmi\n");
             digital_clk_on(6);
             phy_pll_off();      //should call digital_clk_on(), otherwise hdmi_rd/wr_reg will hungup
             digital_clk_off(3); //do not off sys clk
         }
 #ifdef CONFIG_HDMI_TX_PHY
-	digital_clk_off(7);
+    digital_clk_off(7);
 #endif
     }
-    
-//    else if(cmd == HDMITX_HWCMD_TURNOFF_HDMIHW){
-//        int unmux_hpd_flag = argv;
-//        WRITE_MPEG_REG(VENC_DVI_SETTING, READ_MPEG_REG(VENC_DVI_SETTING)&(~(1<<13))); //bit 13 is used by HDMI only
-//        digital_clk_on(4); //enable sys clk so that hdmi registers can be accessed when calling phy_pll_off/digit_clk_off
-//        if(unmux_hpd_flag){
-//            hdmi_print(1,"power off hdmi, unmux hpd\n");
-//            phy_pll_off();
-//            digital_clk_off(7); //off sys clk
-//            unmux_hpd();
-//        }
-//        else{
-//            hdmi_print(1,"power off hdmi\n");
-//            phy_pll_off();
-//            digital_clk_off(3); //do not off sys clk
-//        }
-//    }
     else if(cmd == HDMITX_HWCMD_TURN_ON_PRBS){
         turn_on_prbs_mode(argv);    
     }
-    else if(cmd == HDMITX_OUTPUT_ENABLE){
-        return 0; //TODO
-//Bit 25   if true, change screen to one color value for preblender
-//Bit 24   if true, change screen to one color value for postblender
-// Bit 23:16 one color Y
-// Bit 15:8 one color Cb
-// Bit  7:0 one color  Cr
-// P_VPP_BLEND_ONECOLOR_CTRL
-        if(argv){
-            // ENCP bist disable
-            aml_set_reg32_bits(P_VPP_BLEND_ONECOLOR_CTRL, 0, 24, 2);    // one bit osd blank disable
-        }
-        else{
-            // ENCP bist enable
-            aml_write_reg32(P_VPP_BLEND_ONECOLOR_CTRL, (0x3 << 24) | 0x008080);    // one bit osd blank enable
-        }
-    }
-    else if(cmd == HDMITX_GET_AUTHENTICATE_STATE){
-        if((hdmi_rd_reg(TX_HDCP_ST_STATUS_3)&0xa0)==0xa0){
-            return 1;
-        }
-        else{
-            return 0;
-        }
-    }
-     return 0;           
-}
-#if 0
-#include <mach/gpio.h>
-struct gpio_addr
-{
-	unsigned long mode_addr;
-	unsigned long out_addr;
-	unsigned long in_addr;
-};
-static struct gpio_addr gpio_addrs[]=
-{
-	[PREG_EGPIO]={PREG_EGPIO_EN_N,PREG_EGPIO_O,PREG_EGPIO_I},
-	[PREG_FGPIO]={PREG_FGPIO_EN_N,PREG_FGPIO_O,PREG_FGPIO_I},
-	[PREG_GGPIO]={PREG_GGPIO_EN_N,PREG_GGPIO_O,PREG_GGPIO_I},
-	[PREG_HGPIO]={PREG_HGPIO_EN_N,PREG_HGPIO_O,PREG_HGPIO_I},
-};
-
-
-static int set_gpio_valaaa(gpio_bank_t bank,int bit,unsigned long val)
-{
-	unsigned long addr=gpio_addrs[bank].out_addr;
-	WRITE_CBUS_REG_BITS(addr,val?1:0,bit,1);
-
-	return 0;
-}
-
-static unsigned long  get_gpio_valaaa(gpio_bank_t bank,int bit)
-{
-	unsigned long addr=gpio_addrs[bank].in_addr;
-	return READ_CBUS_REG_BITS(addr,bit,1);
-}
-
-static int set_gpio_modeaaa(gpio_bank_t bank,int bit,gpio_mode_t mode)
-{
-	unsigned long addr=gpio_addrs[bank].mode_addr;
-	WRITE_CBUS_REG_BITS(addr,mode,bit,1);
-	return 0;
-}
-static gpio_mode_t get_gpio_modeaaa(gpio_bank_t bank,int bit)
-{
-	unsigned long addr=gpio_addrs[bank].mode_addr;
-	return (READ_CBUS_REG_BITS(addr,bit,1)>0)?(GPIO_INPUT_MODE):(GPIO_OUTPUT_MODE);
+    return 0;           
 }
 
-#endif
-
 static void hdmitx_print_info(hdmitx_dev_t* hdmitx_device, int printk_flag)
 {
-    hdmi_print(printk_flag, "------------------\nHdmitx driver version: %s\nSerial %x\nColor Depth %d\n", HDMITX_VER, serial_reg_val, color_depth_f);
-    hdmi_print(printk_flag, "chip type %c\n", hdmi_chip_type);
-    hdmi_print(printk_flag, "current vout index %d\n", cur_vout_index);
-    hdmi_print(printk_flag, "reset sequence %d\n", new_reset_sequence_flag);
-    hdmi_print(printk_flag, "power mode %d\n", power_mode);
-    hdmi_print(printk_flag, "%spowerdown when unplug\n",hdmitx_device->unplug_powerdown?"":"do not ");
-    hdmi_print(printk_flag, "use_tvenc_conf_flag=%d\n",use_tvenc_conf_flag); 
-    hdmi_print(printk_flag, "vdac %s\n", power_off_vdac_flag?"off":"on");
-    hdmi_print(printk_flag, "hdmi audio %s\n", hdmi_audio_off_flag?"off":"on");
+    hdmi_print(INF, "------------------\nHdmitx driver version: %s\nSerial %x\nColor Depth %d\n", HDMITX_VER, serial_reg_val, color_depth_f);
+    hdmi_print(INF, "current vout index %d\n", cur_vout_index);
+    hdmi_print(INF, "reset sequence %d\n", new_reset_sequence_flag);
+    hdmi_print(INF, "power mode %d\n", power_mode);
+    hdmi_print(INF, "%spowerdown when unplug\n",hdmitx_device->unplug_powerdown?"":"do not ");
+    hdmi_print(INF, "use_tvenc_conf_flag=%d\n",use_tvenc_conf_flag); 
+    hdmi_print(INF, "vdac %s\n", power_off_vdac_flag?"off":"on");
+    hdmi_print(INF, "hdmi audio %s\n", hdmi_audio_off_flag?"off":"on");
     if(!hdmi_audio_off_flag){
-        hdmi_print(printk_flag, "audio out type %s\n", i2s_to_spdif_flag?"spdif":"i2s");
+        hdmi_print(INF, "audio out type %s\n", i2s_to_spdif_flag?"spdif":"i2s");
     }
-    hdmi_print(printk_flag, "delay flag %d\n", delay_flag);
-    hdmi_print(printk_flag, "------------------\n");
+    hdmi_print(INF, "delay flag %d\n", delay_flag);
+    hdmi_print(INF, "------------------\n");
 }
 
 static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
@@ -3388,17 +2568,19 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
     else if(strncmp(tmpbuf, "hpd_lock", 8) == 0) {
         if(tmpbuf[8] == '1') {
             hdmitx_device->hpd_lock = 1;
+            hdmi_print(INF, HPD "hdmitx: lock hpd\n");
         }
         else {
             hdmitx_device->hpd_lock = 0;
+            hdmi_print(INF, HPD "hdmitx: unlock hpd\n");
         }
-        return;
+        return ;
     }
     else if(strncmp(tmpbuf, "vic", 3)==0) {
         printk("hdmi vic count = %d\n", hdmitx_device->vic_count);
         if((tmpbuf[3] >= '0') && (tmpbuf[3] <= '9')){
             hdmitx_device->vic_count = tmpbuf[3] - '0';
-            printk("set hdmi vic count = %d\n", hdmitx_device->vic_count);
+            hdmi_print(INF, SYS "set hdmi vic count = %d\n", hdmitx_device->vic_count);
         }
     }
     else if(strncmp(tmpbuf, "cec", 3)==0) {
@@ -3410,7 +2592,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         unsigned int reg_adr = 0;
         for (reg_adr = 0; reg_adr < 0x800; reg_adr ++){        //HDMI Regs address range: 0 ~ 0x7ff
             reg_val = hdmi_rd_reg(reg_adr);
-            printk("HDMI[0x%x]: 0x%x\n", reg_adr, reg_val);
+            hdmi_print(INF, "HDMI[0x%x]: 0x%x\n", reg_adr, reg_val);
         }
         return ;
     }
@@ -3420,11 +2602,11 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         //HDMI CEC Regs address range:0xc000~0xc01c;0xc080~0xc094
         for(cec_adr = 0xc000; cec_adr < 0xc01d; cec_adr ++){
             cec_val = hdmi_rd_reg(cec_adr);
-            printk("HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
         }
          for(cec_adr = 0xc080; cec_adr < 0xc095; cec_adr ++){
             cec_val = hdmi_rd_reg(cec_adr);
-            printk("HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
         }
         return;      
     }
@@ -3434,7 +2616,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         value=simple_strtoul(buf+i+1, NULL, 16); //CBUS End addr
         for(j = 0 ; j < value-adr+1 ; j++){
 //            printk("CBUS[0x%x]: 0x%x\n", adr+j, READ_MPEG_REG(adr+j));
-            printk("CBUS[0x%x]: 0x%x\n", adr+j, aml_read_reg32(CBUS_REG_ADDR(adr+j)));
+            hdmi_print(INF, "CBUS[0x%x]: 0x%x\n", adr+j, aml_read_reg32(CBUS_REG_ADDR(adr+j)));
             
         }
     }
@@ -3474,13 +2656,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
     }
     else if(strncmp(tmpbuf, "tvenc_flag", 10)==0){
         use_tvenc_conf_flag = tmpbuf[10]-'0';
-        printk("set use_tvenc_conf_flag = %d\n", use_tvenc_conf_flag);
-    }
-    else if(strncmp(tmpbuf, "ignore_unplug_on", 16)==0){
-        hpd_debug_mode|=HPD_DEBUG_IGNORE_UNPLUG;
-    }
-    else if(strncmp(tmpbuf, "force_plug_off", 17)==0){
-        hpd_debug_mode&=~HPD_DEBUG_IGNORE_UNPLUG;
+        hdmi_print(INF, "set use_tvenc_conf_flag = %d\n", use_tvenc_conf_flag);
     }
     else if(strncmp(tmpbuf, "reset", 5)==0){
         if(tmpbuf[5]=='0')
@@ -3525,12 +2701,12 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
     }
     else if(strncmp(tmpbuf, "pattern_on", 10)==0){
         turn_on_shift_pattern();
-        printk("Shift Pattern On\n");
+        hdmi_print(INF, "Shift Pattern On\n");
         return;        
     }
     else if(strncmp(tmpbuf, "pattern_off", 11)==0){
         turn_off_shift_pattern();
-        printk("Shift Pattern Off\n");
+        hdmi_print(INF, "Shift Pattern Off\n");
         return;        
     }
     else if(strncmp(tmpbuf, "prbs", 4)==0){
@@ -3547,21 +2723,17 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
             read_back = hdmi_rd_reg(adr);
         }
         else if(buf[1]=='c'){
-//            WRITE_MPEG_REG(adr, value);
-//            read_back = READ_MPEG_REG(adr);
             aml_write_reg32(CBUS_REG_ADDR(adr), value);
             read_back = aml_read_reg32(CBUS_REG_ADDR(adr));
             
         }
         else if(buf[1]=='p'){
-//            WRITE_APB_REG(adr, value);
-//            read_back = READ_APB_REG(adr);
             aml_write_reg32(APB_REG_ADDR(adr), value);
             read_back = aml_read_reg32(APB_REG_ADDR(adr));
         }
-        printk("write %x to %s reg[%x]\n",value,buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr);
+        hdmi_print(INF, "write %x to %s reg[%x]\n",value,buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr);
         //Add read back function in order to judge writting is OK or NG.
-        printk("Read Back %s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, read_back);
+        hdmi_print(INF, "Read Back %s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, read_back);
     }
     else if(tmpbuf[0]=='r'){
         adr=simple_strtoul(tmpbuf+2, NULL, 16);
@@ -3575,59 +2747,258 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         else if(buf[1]=='p'){
             value = aml_read_reg32(APB_REG_ADDR(adr));
         }
-        printk("%s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, value);
+        hdmi_print(INF, "%s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, value);
     }
 }
 
-#ifdef HPD_DELAY_CHECK
-static void hpd_post_process(unsigned long arg)
+static void hdmitx_getediddata(hdmitx_dev_t* hdmitx_device)
 {
-    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)arg;
-    hdmi_print(1,"hpd_post_process\n");
-    if (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<1)) {
-        // Start DDC transaction
-        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<6)); // Assert sys_trigger_config
-        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<1)); // Release sys_trigger_config_semi_manu
+    int ii, jj;
+    if((hdmitx_device->cur_edid_block+2)<=EDID_MAX_BLOCK){
+        for(jj=0;jj<2;jj++){
+            for(ii=0;ii<128;ii++){
+                hdmitx_device->EDID_buf[hdmitx_device->cur_edid_block*128+ii]
+                    =hdmi_rd_reg(TX_RX_EDID_OFFSET+hdmitx_device->cur_phy_block_ptr*128+ii);
+            }
+            hdmitx_device->cur_edid_block++;
+            hdmitx_device->cur_phy_block_ptr++;
+            hdmitx_device->cur_phy_block_ptr=hdmitx_device->cur_phy_block_ptr&0x3;
+        }
+    }
+}    
+
+static int hdmitx_cntl_ddc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    int i = 0;
+    unsigned char *tmp_char = NULL;
     
-        hdmitx_device->cur_edid_block=0;
-        hdmitx_device->cur_phy_block_ptr=0;
-        hdmitx_device->hpd_event = 1;
-        hdmi_print(1,"hpd_event 1\n");
-    } 
-    else{ //HPD falling
-        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module 
-        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<6)); // Release sys_trigger_config
-        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<1)); // Assert sys_trigger_config_semi_manu
-        hdmitx_device->hpd_event = 2;
-        hdmi_print(1,"hpd_event 2\n");
+    if(!(cmd & CMD_DDC_OFFSET))
+        hdmi_print(ERR, "ddc: " "w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "ddc: " "cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case DDC_RESET_EDID:
+        hdmi_set_reg_bits(TX_SYS5_TX_SOFT_RESET_2, 1, 1, 1);
+        hdmi_set_reg_bits(TX_SYS5_TX_SOFT_RESET_2, 0, 1, 1);
+        break;
+    case DDC_IS_EDID_DATA_READY:
+        return !!(hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<4));
+        break;
+    case DDC_EDID_READ_DATA:
+        hdmi_set_reg_bits(TX_HDCP_EDID_CONFIG, 1, 6, 1);     // Assert sys_trigger_config
+        break;
+    case DDC_EDID_GET_DATA:
+        hdmitx_getediddata(hdmitx_device);
+        break;
+    case DDC_PIN_MUX_OP:
+        if(argv == PIN_MUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x3, 24, 2);    // Mux HDMI SDA(5v)/SCL(5V)
+        }
+        if(argv == PIN_UNMUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x0, 24, 2);    // unMux HDMI SDA(5v)/SCL(5V)
+        }
+        break;
+    case DDC_EDID_CLEAR_RAM:
+        for(i = 0; i < EDID_RAM_ADDR_SIZE; i++) {
+            hdmi_wr_reg(TX_RX_EDID_OFFSET + i, 0);
+        }
+        break;
+    case DDC_RESET_HDCP:
+        hdmi_set_reg_bits(TX_SYS5_TX_SOFT_RESET_2, 1, 2, 1);
+        hdmi_set_reg_bits(TX_SYS5_TX_SOFT_RESET_2, 0, 2, 1);
+        break;
+    case DDC_HDCP_OP:
+        if(argv == HDCP_ON) {
+            hdmi_set_reg_bits(TX_HDCP_MODE, 1, 7, 1);
+        }
+        if(argv == HDCP_OFF) {
+            hdmi_set_reg_bits(TX_HDCP_MODE, 0, 7, 1);
+        }
+        break;
+    case DDC_IS_HDCP_ON:
+        argv = !!((hdmi_rd_reg(TX_HDCP_MODE)) & (1 << 7));
+        break;
+    case DDC_HDCP_GET_AKSV:
+        tmp_char = (unsigned char *) argv;
+        for(i = 0; i < 5; i++) {
+            tmp_char[i] = (unsigned char)hdmi_rd_reg(TX_HDCP_AKSV_SHADOW + 4 - i);
+        }
+        break;
+    case DDC_HDCP_GET_BKSV:
+        tmp_char = (unsigned char *) argv;
+        for(i = 0; i < 5; i++) {
+            tmp_char[i] = (unsigned char)hdmi_rd_reg(TX_HDCP_BKSV_SHADOW + 4 - i);
+        }
+        break;
+    case DDC_HDCP_GET_AUTH:
+        if((hdmi_rd_reg(TX_HDCP_ST_STATUS_3)&0xa0)==0xa0) {
+            return 1;
+        }
+        else {
+            return 0;
+        }
+        break;
+    default:
+        hdmi_print(INF, "ddc: " "unknown cmd: 0x%x\n", cmd);
     }
+    return 1;
+}
 
-    del_timer(&hpd_timer);    
-}    
-#endif
+// clear hdmi packet configure registers
+static void hdmitx_clr_sub_packet(unsigned int reg_base)
+{
+    int i = 0;
+    for(i = 0; i < 0x20; i++) {
+        hdmi_wr_reg(reg_base + i, 0x00);
+    }
+}
+
+static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_CONF_OFFSET))
+        hdmi_print(ERR, "config: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "config: " "hdmitx: conf cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case CONF_HDMI_DVI_MODE:
+        if(argv == HDMI_MODE) {
+            hdmi_set_reg_bits(TX_TMDS_MODE, 0x3, 6, 2);
+        }
+        if(argv == DVI_MODE) {
+            hdmi_set_reg_bits(TX_TMDS_MODE, 0x2, 6, 2);
+        }
+        break;
+    case CONF_SYSTEM_ST:
+        return (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) >> 6);
+        break;
+    case CONF_AUDIO_MUTE_OP:
+        if(argv == AUDIO_MUTE) {
+            hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // disable audio sample packets
+        }
+        if(argv == AUDIO_UNMUTE) {
+            hdmi_wr_reg(TX_AUDIO_PACK, 0x01); // disable audio sample packets
+        }
+        break;
+    case CONF_VIDEO_BLANK_OP:
+        if(argv == VIDEO_BLANK) {
+            aml_write_reg32(P_VPU_HDMI_DATA_OVR, (0x1 << 31));    // todo
+        }
+        if(argv == VIDEO_UNBLANK) {
+            aml_set_reg32_bits(P_VPU_HDMI_DATA_OVR, 0, 31, 1);    // 
+        }
+        break;
+    case CONF_CLR_AVI_PACKET:
+        hdmitx_clr_sub_packet(TX_PKT_REG_AVI_INFO_BASE_ADDR);
+        break;
+    case CONF_CLR_VSDB_PACKET:
+        hdmitx_clr_sub_packet(TX_PKT_REG_VEND_INFO_BASE_ADDR);
+        break;
+    case CONF_CLR_AUDINFO_PACKET:
+        hdmitx_clr_sub_packet(TX_PKT_REG_AUDIO_INFO_BASE_ADDR);
+        break;
+    default:
+        hdmi_print(ERR, "config: ""hdmitx: unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+static int hdmitx_cntl_misc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_MISC_OFFSET))
+        hdmi_print(ERR, "misc: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "misc: " "hdmitx: misc cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case MISC_HPD_MUX_OP:
+        if(argv == PIN_MUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x1, 26, 1);    // Mux HPD
+        }
+        if(argv == PIN_UNMUX) {
+            aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0x0, 26, 1);    // unMux HPD
+        }
+        break;
+    case MISC_HPD_GPI_ST:
+        return read_hpd_gpio();
+        break;
+    case MISC_HPLL_OP:
+        if(argv == HPLL_ENABLE) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);   // disable hpll
+        }
+        if(argv == HPLL_DISABLE) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);   // disable hpll
+        }
+        break;
+    case MISC_TMDS_PHY_OP:
+        if(argv == TMDS_PHY_ENABLE) {
+            hdmi_phy_wakeup();  // TODO
+        }
+        if(argv == TMDS_PHY_DISABLE) {
+            hdmi_phy_suspend();
+        }
+        break;
+    default:
+        hdmi_print(ERR, "misc: " "hdmitx: unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+static int hdmitx_get_state(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_STAT_OFFSET))
+        hdmi_print(ERR, "stat: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "stat: " "hdmitx: misc cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case STAT_VIDEO_VIC:
+        {
+            /*
+             * get current video vic directly from VIC packet or VSDB packet
+             */
+            HDMI_Video_Codes_t vic = HDMI_Unkown;
+            vic = (HDMI_Video_Codes_t)hdmi_rd_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR + 4);
+            if(vic == HDMI_Unkown) {
+                vic = (HDMI_Video_Codes_t)hdmi_rd_reg(TX_PKT_REG_VEND_INFO_BASE_ADDR + 5);
+                if(vic == 1) {
+                    vic = HDMI_4k2k_30;
+                } else if(vic == 2) {
+                    vic = HDMI_4k2k_25;
+                } else if(vic == 3) {
+                    vic = HDMI_4k2k_24;
+                } else if(vic == 4) {
+                    vic = HDMI_4k2k_smpte_24;
+                } else {
+                }
+            }
+            return (int)vic;
+        }
+        break;
+    case STAT_VIDEO_CLK:
+        break;
+    default:
+        break;
+    }
+    return 0;
+}
 
 void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device)
 {
     hdmitx_device->HWOp.SetPacket = hdmitx_set_packet;
     hdmitx_device->HWOp.SetAudioInfoFrame = hdmitx_setaudioinfoframe;
-    hdmitx_device->HWOp.GetEDIDData = hdmitx_getediddata;
     hdmitx_device->HWOp.SetDispMode = hdmitx_set_dispmode;
     hdmitx_device->HWOp.SetAudMode = hdmitx_set_audmode;
     hdmitx_device->HWOp.SetupIRQ = hdmitx_setupirq;
     hdmitx_device->HWOp.DebugFun = hdmitx_debug;
     hdmitx_device->HWOp.UnInit = hdmitx_uninit;
-    hdmitx_device->HWOp.Cntl = hdmitx_cntl;
-#ifdef HPD_DELAY_CHECK
-    /*hdp timer*/
-    init_timer(&hpd_timer);
-    hpd_timer.function = &hpd_post_process;
-    hpd_timer.data = (unsigned long)hdmitx_device;
-    /**/
-#endif
-    
-    if(hdmi_chip_type==0){
-        check_chip_type();
-    }    
+    hdmitx_device->HWOp.Cntl = hdmitx_cntl;             // todo
+    hdmitx_device->HWOp.CntlDDC = hdmitx_cntl_ddc;
+    hdmitx_device->HWOp.GetState = hdmitx_get_state;
+    hdmitx_device->HWOp.CntlPacket = hdmitx_cntl;
+    hdmitx_device->HWOp.CntlConfig = hdmitx_cntl_config;
+    hdmitx_device->HWOp.CntlMisc = hdmitx_cntl_misc;
                                                                   //     1=Map data pins from Venc to Hdmi Tx as RGB mode.
     // --------------------------------------------------------
     // Configure HDMI TX analog, and use HDMI PLL to generate TMDS clock
@@ -3635,51 +3006,18 @@ void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device)
     // Enable APB3 fail on error
 //    WRITE_APB_REG(HDMI_CNTL_PORT, READ_APB_REG(HDMI_CNTL_PORT)|(1<<15)); //APB3 err_en
 //\\ TODO
-#ifdef CONFIG_ARCH_MESON6
-    aml_set_reg32_bits(P_PAD_PULL_UP_REG2, 1, 10, 1);       // Disable GPIOC_10 internal pull-up register
-#endif
-#ifdef CONFIG_ARCH_MESON8
     aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG1, 0, 16, 1);       // Disable GPIOH_0 internal pull-up register
-#endif
     aml_write_reg32(P_HHI_HDMI_CLK_CNTL, aml_read_reg32(P_HHI_HDMI_CLK_CNTL)| (1 << 8));
-    HDMI_DEBUG();
     aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<15)); //APB3 err_en
     hdmi_wr_reg(0x10, 0xff);
-    HDMI_DEBUG();
-
-    hdmi_phy_suspend();
 
     /**/    
     hdmi_hw_init(hdmitx_device);
 }    
 
-static  int __init hdmi_chip_select(char *s)
-{
-#ifndef AML_A3
-	switch(s[0])
-	{
-		case 'a':
-		case 'A':
-			hdmi_chip_type = HDMI_M1A;
-			break;
-		case 'b':
-		case 'B':
-      i2s_to_spdif_flag=1;
-		  hdmi_chip_type = HDMI_M1B;
-		  break;
-    default:
-			hdmi_chip_type = HDMI_M1C;
-			break;
-	}
-#endif	
-	return 0;
-}
-
-__setup("chip=",hdmi_chip_select);
-
 void hdmi_set_audio_para(int para)
 {
-	aud_para = para;
+    aud_para = para;
 
 }
 
@@ -3694,124 +3032,17 @@ typedef struct
     unsigned long val_save;
 }hdmi_phy_t;
 
-#ifdef CONFIG_ARCH_MESON6
-static char hdmi_phy_reg_save_flag = 0;
-
-#define HDMI_PHY_REG_NUM    7
-static hdmi_phy_t hdmi_phy_reg [HDMI_PHY_REG_NUM] = {
-                         {0x10, 0xc0, 0x0},
-                         {0x11, 0xf1, 0x0},
-                         {0x12, 0xff, 0x0},
-                         {0x13, 0x07, 0x0},
-                         {0x14, 0x00, 0x0},
-                         {0x15, 0x04, 0x0},
-                         {0x16, 0x30, 0x00},
-                        };
-#endif
-
-#ifdef CONFIG_ARCH_MESON8
 static unsigned int hdmi_phy_save = 0x08930e9b;     // Default setting
-#endif
 
 static void hdmi_phy_suspend(void)
 {
-#ifdef CONFIG_ARCH_MESON6
-    // First backup HDMI PHY register according to Chao Shi.
-    int i;
-#if 0    
-    WRITE_MPEG_REG(HHI_GCLK_MPEG2, READ_MPEG_REG(HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
-    WRITE_MPEG_REG(0x1073, READ_MPEG_REG(0x1073) | (1<<8));
-    for(i = 0 ; i< 10000; i++)
-    {
-        //Delay some time
-    }
-#endif    
-    for(i = 0; i < HDMI_PHY_REG_NUM; i++)
-    {
-        hdmi_phy_reg[i].val_save = hdmi_rd_reg(hdmi_phy_reg[i].reg);
-    }
-    for(i = 0; i < HDMI_PHY_REG_NUM; i++)
-    {   
-        hdmi_wr_reg(hdmi_phy_reg[i].reg, hdmi_phy_reg[i].val_sleep);
-    }
-    hdmi_phy_reg_save_flag = 1;
-#if 0 
-//move this code to digital_clk_off(), rain
-    // Second turn off gate.
-    WRITE_MPEG_REG(0x1073, 0x0);
-    WRITE_MPEG_REG(HHI_GCLK_MPEG2, READ_MPEG_REG(HHI_GCLK_MPEG2) & (~(1<<4)));     //Disable HDMI PCLK
-#endif
-//    printk("Hdmi phy suspend\n");
-#endif
-#ifdef CONFIG_ARCH_MESON8
     hdmi_phy_save = aml_read_reg32(P_HHI_HDMI_PHY_CNTL0);
     aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x08418d00);
-#endif
+    //hdmi_print(INF, SYS "phy suspend\n");
 }
 
 static void hdmi_phy_wakeup(void)
 {
-#ifdef CONFIG_ARCH_MESON6
-    int i;
-#if 0  
-//move this code to digital_clk_on(), rain
-    WRITE_MPEG_REG(HHI_GCLK_MPEG2, READ_MPEG_REG(HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
-    WRITE_MPEG_REG(0x1073, READ_MPEG_REG(0x1073) | (1<<8));
-    for(i = 0 ; i< 10000; i++)
-    {
-        //Delay some time
-    }
-#endif
-    if(hdmi_phy_reg_save_flag){
-        for(i = 0; i < HDMI_PHY_REG_NUM; i++)
-        {
-            hdmi_wr_reg(hdmi_phy_reg[i].reg, hdmi_phy_reg[i].val_save);
-        }
-        printk("Hdmi phy wakeup\n");
-        hdmi_phy_reg_save_flag = 0;
-    }
-#endif
-#ifdef CONFIG_ARCH_MESON8
     aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, hdmi_phy_save);
-#endif
+    //hdmi_print(INF, SYS "phy wakeup\n");
 }
-
-#if 0
-static void hdcp_status_loop_check()
-{
-    static unsigned reg190=0;
-    static unsigned reg192=0;
-    static unsigned reg195=0;
-    static unsigned reg19f=0;
-    static unsigned reg194=0;
-    unsigned char check_flag=0;
-    if(hdmi_rd_reg(0x190)!=reg190){
-        reg190=hdmi_rd_reg(0x190);
-        check_flag|=0x1;
-    }
-    if(hdmi_rd_reg(0x192)!=reg192){
-        reg192=hdmi_rd_reg(0x192);
-        check_flag|=0x2;
-    }
-    if(hdmi_rd_reg(0x195)!=reg195){
-        reg195=hdmi_rd_reg(0x195);
-        check_flag|=0x4;
-    }
-    if(hdmi_rd_reg(0x19f)!=reg19f){
-        reg19f=hdmi_rd_reg(0x19f);
-        check_flag|=0x8;
-    }
-    if(hdmi_rd_reg(0x194)!=reg194){
-        reg194=hdmi_rd_reg(0x194);
-        check_flag|=0x10;
-    }
-    if(check_flag){
-        printk("[%c190,%c192,%c195,%c19f,%c194]=%02x,%02x,%02x,%02x,%02x\n",
-            (check_flag&0x1)?'*':' ',(check_flag&0x2)?'*':' ', 
-            (check_flag&0x4)?'*':' ',(check_flag&0x8)?'*':' ',
-                (check_flag&0x10)?'*':' ',
-                reg190,reg192,reg195,reg19f,reg194);
-    }
-}            
-#endif            
-    
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c
new file mode 100644
index 000000000000..8d765b938549
--- /dev/null
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c
@@ -0,0 +1,86 @@
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * frame buffer driver-----------HDMI_TX
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+
+#include <mach/hdmi_tx_reg.h>
+static DEFINE_SPINLOCK(reg_lock);
+// if the following bits are 0, then access HDMI IP Port will cause system hungup
+#define GATE_NUM    2
+Hdmi_Gate_s hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
+                                        {HHI_GCLK_MPEG2   , 4},
+                                    };
+
+// In order to prevent system hangup, add check_cts_hdmi_sys_clk_status() to check 
+static void check_cts_hdmi_sys_clk_status(void)
+{
+    int i;
+
+    for(i = 0; i < GATE_NUM; i++){
+        if(!(aml_read_reg32(CBUS_REG_ADDR(hdmi_gate[i].cbus_addr)) & (1<<hdmi_gate[i].gate_bit))){
+            aml_set_reg32_bits(CBUS_REG_ADDR(hdmi_gate[i].cbus_addr), 1, hdmi_gate[i].gate_bit, 1);
+        }
+    }
+}
+
+unsigned int hdmi_rd_reg(unsigned int addr)
+{
+    unsigned int data;
+
+    unsigned long flags, fiq_flag;
+
+    spin_lock_irqsave(&reg_lock, flags);
+    raw_local_save_flags(fiq_flag);
+    local_fiq_disable();
+
+    check_cts_hdmi_sys_clk_status();
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    data = aml_read_reg32(P_HDMI_DATA_PORT);
+
+    raw_local_irq_restore(fiq_flag);
+    spin_unlock_irqrestore(&reg_lock, flags);
+    return (data);
+}
+
+void hdmi_wr_reg(unsigned int addr, unsigned int data)
+{
+    unsigned long flags, fiq_flag;
+    spin_lock_irqsave(&reg_lock, flags);
+    raw_local_save_flags(fiq_flag);
+    local_fiq_disable();
+
+    check_cts_hdmi_sys_clk_status();
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    aml_write_reg32(P_HDMI_DATA_PORT, data);
+    raw_local_irq_restore(fiq_flag);
+    spin_unlock_irqrestore(&reg_lock, flags);
+}
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/tvenc_conf.h b/arch/arm/mach-meson8/hdmi_tx_hw/tvenc_conf.h
new file mode 100644
index 000000000000..0be2cfe625b3
--- /dev/null
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/tvenc_conf.h
@@ -0,0 +1,231 @@
+typedef struct reg_s {
+    uint reg;
+    uint val;
+} reg_t;
+
+static  reg_t hdmi_tvenc_regs_480i[] = {
+    /*1st col: recommmended, but eof/sof/vs_lines +/- 1 from spec; 2nd col: from simu */
+    {ENCP_VIDEO_MODE,             0      /*0     */  },
+    {ENCI_DE_H_BEGIN,             229    /*0xeb  */  },
+    {ENCI_DE_H_END,               1669   /*0x68b */  },
+    {ENCI_DE_V_BEGIN_EVEN,        18     /*0x11  */  },
+    {ENCI_DE_V_END_EVEN,          258    /*0x101 */  },
+    {ENCI_DE_V_BEGIN_ODD,         19     /*0x12  */  },
+    {ENCI_DE_V_END_ODD,           259    /*0x102 */  },
+    {ENCI_DVI_HSO_BEGIN,          1707   /*0x6b1 */  },
+    {ENCI_DVI_HSO_END,            115    /*0x79  */  },
+    {ENCI_DVI_VSO_BLINE_EVN,      0      /*0x105 */  },
+    {ENCI_DVI_VSO_ELINE_EVN,      2      /*0x1   */  },
+    {ENCI_DVI_VSO_BEGIN_EVN,      1707   /*0x357 */  },
+    {ENCI_DVI_VSO_END_EVN,        1707   /*0x6b1 */  },
+    {ENCI_DVI_VSO_BLINE_ODD,      0      /*0x105 */  },
+    {ENCI_DVI_VSO_BEGIN_ODD,      849    /*0x6b1 */  },
+    {ENCI_DVI_VSO_ELINE_ODD,      3      /*0x2   */  },
+    {ENCI_DVI_VSO_END_ODD,        849    /*0x357 */  },
+    {VENC_DVI_SETTING,            0x809c /*0x809c*/  },
+    {VENC_DVI_SETTING_MORE,       0x0    /*0x0   */  },
+    {0,0}
+};
+
+static  reg_t hdmi_tvenc_regs_576i[] = {
+    {ENCP_VIDEO_MODE,                    0x00004000},
+    {ENCI_DE_H_BEGIN,                    0x000000f9},
+    {ENCI_DE_H_END,                      0x00000699},
+    {ENCI_DE_V_BEGIN_EVEN,               0x00000015},
+    {ENCI_DE_V_END_EVEN,                 0x00000135},
+    {ENCI_DE_V_BEGIN_ODD,                0x00000016},
+    {ENCI_DE_V_END_ODD,                  0x00000136},
+    {ENCI_DVI_HSO_BEGIN,                 0x000006b1},
+    {ENCI_DVI_HSO_END,                   0x0000006f},
+    {ENCI_DVI_VSO_BLINE_EVN,             0x00000137},
+    {ENCI_DVI_VSO_ELINE_EVN,             0x00000001},
+    {ENCI_DVI_VSO_BEGIN_EVN,             0x00000351},
+    {ENCI_DVI_VSO_END_EVN,               0x000006b1},
+    {ENCI_DVI_VSO_BLINE_ODD,             0x00000137},
+    {ENCI_DVI_VSO_BEGIN_ODD,             0x000006b1},
+    {ENCI_DVI_VSO_ELINE_ODD,             0x00000002},
+    {ENCI_DVI_VSO_END_ODD,               0x00000351},
+    {VENC_DVI_SETTING,                   0x0000809c},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {0,0}
+};
+
+static  reg_t hdmi_tvenc_regs_1080i[] = {
+    {ENCP_VIDEO_MODE,                    0x00005ffc},
+    {ENCP_DE_H_BEGIN,                    0x00000210},
+    {ENCP_DE_H_END,                      0x00001110},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000014},
+    {ENCP_DE_V_END_EVEN,                 0x00000230},
+    {ENCP_DE_V_BEGIN_ODD,                0x00000247},
+    {ENCP_DE_V_END_ODD,                  0x00000463},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000090},
+    {ENCP_DVI_HSO_END,                   0x000000e8},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000090},
+    {ENCP_DVI_VSO_END_EVN,               0x00000090},
+    {ENCP_DVI_VSO_BLINE_ODD,             0x00000232},
+    {ENCP_DVI_VSO_ELINE_ODD,             0x00000237},
+    {ENCP_DVI_VSO_BEGIN_ODD,             0x00000928},
+    {ENCP_DVI_VSO_END_ODD,               0x00000928},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {VENC_DVI_SETTING_MORE,              0x00000000}, 
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_1080i50[] = {
+    {ENCP_VIDEO_MODE,                    0x00005ffc},
+    {ENCP_DE_H_BEGIN,                    0x00000210},
+    {ENCP_DE_H_END,                      0x00001110},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000014},
+    {ENCP_DE_V_END_EVEN,                 0x00000230},
+    {ENCP_DE_V_BEGIN_ODD,                0x00000247},
+    {ENCP_DE_V_END_ODD,                  0x00000463},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000090},
+    {ENCP_DVI_HSO_END,                   0x000000e8},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000090},
+    {ENCP_DVI_VSO_END_EVN,               0x00000090},
+    {ENCP_DVI_VSO_BLINE_ODD,             0x00000232},
+    {ENCP_DVI_VSO_ELINE_ODD,             0x00000237},
+    {ENCP_DVI_VSO_BEGIN_ODD,             0x00000ae0},
+    {ENCP_DVI_VSO_END_ODD,               0x00000ae0},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {VENC_DVI_SETTING_MORE,              0x00000000}, 
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_480p[] = {
+    {ENCP_VIDEO_MODE,                   /*0x4000 */ 0x00004000},
+    {ENCP_DE_H_BEGIN,                   /*0xdc   */ 0x000000d7},
+    {ENCP_DE_H_END,                     /*0x67c  */ 0x00000677},
+    {ENCP_DE_V_BEGIN_EVEN,              /*0x2a   */ 0x0000002b},
+    {ENCP_DE_V_END_EVEN,                /*0x2a   */ 0x0000020b},
+    {ENCP_DVI_HSO_BEGIN,                /*0x69c  */ 0x00000697},
+    {ENCP_DVI_HSO_END,                  /*0x64   */ 0x0000005f},
+    {ENCP_DVI_VSO_BLINE_EVN,            /*0x5    */ 0x00000006},
+    {ENCP_DVI_VSO_ELINE_EVN,            /*0xb    */ 0x0000000c},
+    {ENCP_DVI_VSO_BEGIN_EVN,            /*0x69c  */ 0x00000697},
+    {ENCP_DVI_VSO_END_EVN,              /*0x69c  */ 0x00000697},
+    {VENC_DVI_SETTING_MORE,             /*0x0    */ 0x00000000},
+    {VENC_DVI_SETTING,                  /*0x80ad */ 0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_576p[] = {
+    {ENCP_VIDEO_MODE,                    0x00004000},
+    {ENCP_DE_H_BEGIN,                    0x000000ef},
+    {ENCP_DE_H_END,                      0x0000068f},
+    {ENCP_DE_V_BEGIN_EVEN,               0x0000002d},
+    {ENCP_DE_V_END_EVEN,                 0x0000026d},
+    {ENCP_DVI_HSO_BEGIN,                 0x000006a7},
+    {ENCP_DVI_HSO_END,                   0x00000067},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x000006a7},
+    {ENCP_DVI_VSO_END_EVN,               0x000006a7},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_720p[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x0000028a},
+    {ENCP_DE_H_END,                      0x00000c8a},
+    {ENCP_DE_V_BEGIN_EVEN,               0x0000001d},
+    {ENCP_DE_V_END_EVEN,                 0x000002ed},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000082},
+    {ENCP_DVI_HSO_END,                   0x000000d2},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000004},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000009},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000082},
+    {ENCP_DVI_VSO_END_EVN,               0x00000082},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_1080p[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x00000112},
+    {ENCP_DE_H_END,                      0x00000892},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000029},
+    {ENCP_DE_V_END_EVEN,                 0x00000461},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000052},
+    {ENCP_DVI_HSO_END,                   0x0000007e},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
+    {ENCP_DVI_VSO_END_EVN,               0x00000052},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x0000809d},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_720p50[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x0000028a},
+    {ENCP_DE_H_END,                      0x00000c8a},
+    {ENCP_DE_V_BEGIN_EVEN,               0x0000001d},
+    {ENCP_DE_V_END_EVEN,                 0x000002ed},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000082},
+    {ENCP_DVI_HSO_END,                   0x000000d2},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000004},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000009},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000082},
+    {ENCP_DVI_VSO_END_EVN,               0x00000082},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_1080p50[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x00000112},
+    {ENCP_DE_H_END,                      0x00000892},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000029},
+    {ENCP_DE_V_END_EVEN,                 0x00000461},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000052},
+    {ENCP_DVI_HSO_END,                   0x0000007e},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
+    {ENCP_DVI_VSO_END_EVN,               0x00000052},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x0000809d},
+    {0,0}
+};    
+
+typedef struct hdmi_tvenc_config_
+{
+    int vic;
+    reg_t* reg_set;
+}hdmi_tvenc_config_t;
+
+static const hdmi_tvenc_config_t hdmi_tvenc_configs[] = {
+    {HDMI_640x480p60  ,          NULL          },
+    {HDMI_480p60,                hdmi_tvenc_regs_480p},
+    {HDMI_480p60_16x9,           hdmi_tvenc_regs_480p},
+    {HDMI_720p60,                hdmi_tvenc_regs_720p},
+    {HDMI_1080i60,               hdmi_tvenc_regs_1080i},
+    {HDMI_480i60,                hdmi_tvenc_regs_480i},
+    {HDMI_480i60_16x9,           hdmi_tvenc_regs_480i},
+    {HDMI_1440x480p60  ,         NULL          },
+    {HDMI_1440x480p60_16x9  ,    NULL          },
+    {HDMI_1080p60 ,              hdmi_tvenc_regs_1080p},
+    {HDMI_576p50,                hdmi_tvenc_regs_576p},
+    {HDMI_576p50_16x9,           hdmi_tvenc_regs_576p},
+    {HDMI_720p50,                hdmi_tvenc_regs_720p50},
+    {HDMI_1080i50,               hdmi_tvenc_regs_1080i50},
+    {HDMI_576i50,                hdmi_tvenc_regs_576i},
+    {HDMI_576i50_16x9,           hdmi_tvenc_regs_576i},
+    {HDMI_1080p50 ,              hdmi_tvenc_regs_1080p50},
+    {HDMI_1080p24,               hdmi_tvenc_regs_1080p},
+    {HDMI_1080p25,               hdmi_tvenc_regs_1080p},
+    {HDMI_1080p30,               hdmi_tvenc_regs_1080p},
+    {HDMI_Unkown,               NULL},
+};
+
+
diff --git a/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h b/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h
new file mode 100644
index 000000000000..65ebaa95ad5f
--- /dev/null
+++ b/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h
@@ -0,0 +1,451 @@
+#ifndef _HDMI_TX_REG_H
+#define _HDMI_TX_REG_H
+
+//wait for pll lock
+//must wait first (100us+) then polling lock bit to check
+/*
+#define M6_PLL_WAIT_FOR_LOCK(pll) \
+	do{\
+		__udelay(1000);\
+	}while((aml_read_reg32(pll)&0x80000000)==0);
+*/
+#ifdef CONFIG_ARCH_MESON6
+//M6 PLL control value 
+#define M6_PLL_CNTL_CST2 (0x814d3928)
+#define M6_PLL_CNTL_CST3 (0x6b425012)
+#define M6_PLL_CNTL_CST4 (0x110)
+
+//VID PLL
+#define M6_VID_PLL_CNTL_2 (M6_PLL_CNTL_CST2)
+#define M6_VID_PLL_CNTL_3 (M6_PLL_CNTL_CST3)
+#define M6_VID_PLL_CNTL_4 (M6_PLL_CNTL_CST4)
+#endif
+unsigned int hdmi_rd_reg(unsigned int addr);
+
+#define hdmi_wr_only_reg(addr, data)   hdmi_wr_reg(addr, data)
+
+void hdmi_wr_reg(unsigned int addr, unsigned int data);
+
+#define hdmi_set_reg_bits(reg, val, start, len) \
+  hdmi_wr_reg(reg, (hdmi_rd_reg(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
+
+typedef struct {
+    unsigned short cbus_addr;
+    unsigned char gate_bit;
+}Hdmi_Gate_s;
+
+
+//inside chip
+// tx base addr  : 0x00000 ~ 0x03fff
+// rx base addr  : 0x04000 ~ 0x07fff
+// sim base addr : 0x08000 ~ 0x0bfff
+// cec0 base addr : 0x0c000 ~ 0x0c0ff
+//external module
+// tx base addr  : 0x10000 ~ 0x13fff
+// rx base addr  : 0x14000 ~ 0x17fff
+// sim base addr : 0x18000 ~ 0x1bfff
+// cec0 base addr : 0x1c000 ~ 0x1c0ff
+// cec1 base addr : 0x1c100 ~ 0x1c1ff
+
+#define TX_BASE_ADDR     0x00000        //inside chip
+
+#define CEC0_BASE_ADDR    0x0c000       //inside chip 
+#define CEC1_BASE_ADDR    0x1c100       //outside chip 
+
+#define OTHER_BASE_ADDR  0x08000        //inside chip
+
+//********** OTHER BASE related **********//
+#define HDMI_OTHER_CTRL0            0x0
+#define HDMI_OTHER_CTRL1            0x1
+#define HDMI_OTHER_STATUS0          0x2
+#define HDMI_OTHER_CTRL2            0x3
+#define HDMI_OTHER_INTR_MASKN       0x4
+#define HDMI_OTHER_INTR_STAT        0x5
+#define HDMI_OTHER_INTR_STAT_CLR    0x6
+
+//********** TX related **********//
+#define TX_RX_EDID_OFFSET               TX_BASE_ADDR+0x600 
+#define TX_HDCP_SHADOW_OFFSET           TX_BASE_ADDR+0x100
+#define TX_HDCP_BKSV_SHADOW             TX_HDCP_SHADOW_OFFSET
+#define TX_HDCP_AKSV_SHADOW             TX_HDCP_SHADOW_OFFSET + 0x10
+
+#define TX_IEC60958_SUB1_OFFSET         TX_BASE_ADDR+0x0B0 
+#define TX_IEC60958_SUB2_OFFSET         TX_BASE_ADDR+0x0C8 
+
+#define TX_IEC60958_ST_SUB1_OFFSET      TX_BASE_ADDR+0x1B0 
+#define TX_IEC60958_ST_SUB2_OFFSET      TX_BASE_ADDR+0x1C8 
+
+// System config 0
+#define TX_SYS0_AFE_SIGNAL        TX_BASE_ADDR+0x000 
+#define TX_SYS0_AFE_LOOP          TX_BASE_ADDR+0x001 
+#define TX_SYS0_ACR_CTS_0         TX_BASE_ADDR+0x002 
+#define TX_SYS0_ACR_CTS_1         TX_BASE_ADDR+0x003 
+#define TX_SYS0_ACR_CTS_2         TX_BASE_ADDR+0x004 
+#define TX_SYS0_BIST_CONTROL      TX_BASE_ADDR+0x005 
+#define TX_SYS0_BIST_DATA_0       TX_BASE_ADDR+0x006 
+#define TX_SYS0_BIST_DATA_1       TX_BASE_ADDR+0x007 
+#define TX_SYS0_BIST_DATA_2       TX_BASE_ADDR+0x008 
+#define TX_SYS0_BIST_DATA_3       TX_BASE_ADDR+0x009 
+#define TX_SYS0_BIST_DATA_4       TX_BASE_ADDR+0x00A 
+#define TX_SYS0_BIST_DATA_5       TX_BASE_ADDR+0x00B 
+#define TX_SYS0_BIST_DATA_6       TX_BASE_ADDR+0x00C 
+#define TX_SYS0_BIST_DATA_7       TX_BASE_ADDR+0x00D 
+#define TX_SYS0_BIST_DATA_8       TX_BASE_ADDR+0x00E 
+#define TX_SYS0_BIST_DATA_9       TX_BASE_ADDR+0x00F 
+
+#define TX_SYS1_ACR_N_0           TX_BASE_ADDR+0x01C 
+#define TX_SYS1_ACR_N_1           TX_BASE_ADDR+0x01D 
+#define TX_SYS1_ACR_N_2           TX_BASE_ADDR+0x01E 
+#define TX_SYS1_PRBS_DATA         TX_BASE_ADDR+0x01F 
+// system config 4
+#define TX_SYS4_TX_CKI_DDR        TX_BASE_ADDR+0x0A0 
+#define TX_SYS4_TX_CKO_DDR        TX_BASE_ADDR+0x0A1 
+#define TX_SYS4_RX_CKI_DDR        TX_BASE_ADDR+0x0A2 
+#define TX_SYS4_RX_CKO_DDR        TX_BASE_ADDR+0x0A3 
+#define TX_SYS4_CONNECT_SEL_0     TX_BASE_ADDR+0x0A4 
+#define TX_SYS4_CONNECT_SEL_1     TX_BASE_ADDR+0x0A5 
+#define TX_SYS4_CONNECT_SEL_2     TX_BASE_ADDR+0x0A6 
+#define TX_SYS4_CONNECT_SEL_3     TX_BASE_ADDR+0x0A7 
+#define TX_SYS4_CK_INV_VIDEO      TX_BASE_ADDR+0x0A8 
+#define TX_SYS4_CK_INV_AUDIO      TX_BASE_ADDR+0x0A9 
+#define TX_SYS4_CK_INV_AFE        TX_BASE_ADDR+0x0AA 
+#define TX_SYS4_CK_INV_CH01       TX_BASE_ADDR+0x0AB 
+#define TX_SYS4_CK_INV_CH2        TX_BASE_ADDR+0x0AC 
+#define TX_SYS4_CK_CEC            TX_BASE_ADDR+0x0AD 
+#define TX_SYS4_CK_SOURCE_1       TX_BASE_ADDR+0x0AE 
+#define TX_SYS4_CK_SOURCE_2       TX_BASE_ADDR+0x0AF 
+// system config 5
+#define TX_SYS5_TX_SOFT_RESET_1   TX_BASE_ADDR+0x0E0 
+#define TX_SYS5_TX_SOFT_RESET_2   TX_BASE_ADDR+0x0E1 
+#define TX_SYS5_RX_SOFT_RESET_1   TX_BASE_ADDR+0x0E2 
+#define TX_SYS5_RX_SOFT_RESET_2   TX_BASE_ADDR+0x0E3 
+#define TX_SYS5_RX_SOFT_RESET_3   TX_BASE_ADDR+0x0E4 
+#define TX_SYS5_SSTL_BIDIR_IN     TX_BASE_ADDR+0x0E5 
+#define TX_SYS5_SSTL_IN           TX_BASE_ADDR+0x0E6 
+#define TX_SYS5_SSTL_DIFF_IN      TX_BASE_ADDR+0x0E7 
+#define TX_SYS5_FIFO_CONFIG       TX_BASE_ADDR+0x0E8 
+#define TX_SYS5_FIFO_SAMP01_CFG   TX_BASE_ADDR+0x0E9 
+#define TX_SYS5_FIFO_SAMP23_CFG   TX_BASE_ADDR+0x0EA 
+#define TX_SYS5_CONNECT_FIFO_CFG  TX_BASE_ADDR+0x0EB 
+#define TX_SYS5_IO_CALIB_CONTROL  TX_BASE_ADDR+0x0EC 
+#define TX_SYS5_SSTL_BIDIR_OUT    TX_BASE_ADDR+0x0ED 
+#define TX_SYS5_SSTL_OUT          TX_BASE_ADDR+0x0EE 
+#define TX_SYS5_SSTL_DIFF_OUT     TX_BASE_ADDR+0x0EF 
+
+// HDCP CONFIG
+#define TX_HDCP_ECC_CONFIG        TX_BASE_ADDR+0x024 
+#define TX_HDCP_CRC_CONFIG        TX_BASE_ADDR+0x025 
+#define TX_HDCP_EDID_CONFIG       TX_BASE_ADDR+0x026 
+#define TX_HDCP_MEM_CONFIG        TX_BASE_ADDR+0x027 
+#define TX_HDCP_HPD_FILTER_L      TX_BASE_ADDR+0x028 
+#define TX_HDCP_HPD_FILTER_H      TX_BASE_ADDR+0x029 
+#define TX_HDCP_ENCRYPT_BYTE      TX_BASE_ADDR+0x02A 
+#define TX_HDCP_CONFIG0           TX_BASE_ADDR+0x02B 
+#define TX_HDCP_CONFIG1           TX_BASE_ADDR+0x02C 
+#define TX_HDCP_CONFIG2           TX_BASE_ADDR+0x02D 
+#define TX_HDCP_CONFIG3           TX_BASE_ADDR+0x02E 
+#define TX_HDCP_MODE              TX_BASE_ADDR+0x02F 
+
+// Video config, part 1
+#define TX_VIDEO_ACTIVE_PIXELS_0  TX_BASE_ADDR+0x030 
+#define TX_VIDEO_ACTIVE_PIXELS_1  TX_BASE_ADDR+0x031 
+#define TX_VIDEO_FRONT_PIXELS     TX_BASE_ADDR+0x032 
+#define TX_VIDEO_HSYNC_PIXELS     TX_BASE_ADDR+0x033 
+#define TX_VIDEO_BACK_PIXELS      TX_BASE_ADDR+0x034 
+#define TX_VIDEO_ACTIVE_LINES_0   TX_BASE_ADDR+0x035 
+#define TX_VIDEO_ACTIVE_LINES_1   TX_BASE_ADDR+0x036 
+#define TX_VIDEO_EOF_LINES        TX_BASE_ADDR+0x037 
+#define TX_VIDEO_VSYNC_LINES      TX_BASE_ADDR+0x038 
+#define TX_VIDEO_SOF_LINES        TX_BASE_ADDR+0x039 
+#define TX_VIDEO_DTV_TIMING       TX_BASE_ADDR+0x03A 
+#define TX_VIDEO_DTV_MODE         TX_BASE_ADDR+0x03B 
+#define TX_VIDEO_DTV_FORMAT0      TX_BASE_ADDR+0x03C 
+#define TX_VIDEO_DTV_FORMAT1      TX_BASE_ADDR+0x03D 
+#define TX_VIDEO_PIXEL_PACK       TX_BASE_ADDR+0x03F 
+// video config, part 2
+#define TX_VIDEO_CSC_COEFF_B0     TX_BASE_ADDR+0x040 
+#define TX_VIDEO_CSC_COEFF_B1     TX_BASE_ADDR+0x041 
+#define TX_VIDEO_CSC_COEFF_R0     TX_BASE_ADDR+0x042 
+#define TX_VIDEO_CSC_COEFF_R1     TX_BASE_ADDR+0x043 
+#define TX_VIDEO_CSC_COEFF_CB0    TX_BASE_ADDR+0x044 
+#define TX_VIDEO_CSC_COEFF_CB1    TX_BASE_ADDR+0x045 
+#define TX_VIDEO_CSC_COEFF_CR0    TX_BASE_ADDR+0x046 
+#define TX_VIDEO_CSC_COEFF_CR1    TX_BASE_ADDR+0x047 
+#define TX_VIDEO_DTV_OPTION_L     TX_BASE_ADDR+0x048 
+#define TX_VIDEO_DTV_OPTION_H     TX_BASE_ADDR+0x049 
+#define TX_VIDEO_DTV_FILTER       TX_BASE_ADDR+0x04A 
+#define TX_VIDEO_DTV_DITHER       TX_BASE_ADDR+0x04B 
+#define TX_VIDEO_DTV_DEDITHER     TX_BASE_ADDR+0x04C 
+#define TX_VIDEO_PROC_CONFIG0     TX_BASE_ADDR+0x04E 
+#define TX_VIDEO_PROC_CONFIG1     TX_BASE_ADDR+0x04F 
+
+// Audio config
+#define TX_AUDIO_FORMAT           TX_BASE_ADDR+0x058 
+#define TX_AUDIO_SPDIF            TX_BASE_ADDR+0x059 
+#define TX_AUDIO_I2S              TX_BASE_ADDR+0x05A 
+#define TX_AUDIO_FIFO             TX_BASE_ADDR+0x05B 
+#define TX_AUDIO_LIPSYNC          TX_BASE_ADDR+0x05C 
+#define TX_AUDIO_CONTROL          TX_BASE_ADDR+0x05D 
+#define TX_AUDIO_HEADER           TX_BASE_ADDR+0x05E 
+#define TX_AUDIO_SAMPLE           TX_BASE_ADDR+0x05F 
+#define TX_AUDIO_VALID            TX_BASE_ADDR+0x060 
+#define TX_AUDIO_USER             TX_BASE_ADDR+0x061 
+#define TX_AUDIO_PACK             TX_BASE_ADDR+0x062 
+#define TX_AUDIO_CONTROL_MORE     TX_BASE_ADDR+0x064
+
+// tmds config
+#define TX_TMDS_MODE              TX_BASE_ADDR+0x068 
+#define TX_TMDS_CONFIG0           TX_BASE_ADDR+0x06C 
+#define TX_TMDS_CONFIG1           TX_BASE_ADDR+0x06D 
+
+// packet config
+#define TX_PACKET_ALLOC_ACTIVE_1  TX_BASE_ADDR+0x078 
+#define TX_PACKET_ALLOC_ACTIVE_2  TX_BASE_ADDR+0x079 
+#define TX_PACKET_ALLOC_EOF_1     TX_BASE_ADDR+0x07A 
+#define TX_PACKET_ALLOC_EOF_2     TX_BASE_ADDR+0x07B 
+#define TX_PACKET_ALLOC_SOF_1     TX_BASE_ADDR+0x07C 
+#define TX_PACKET_ALLOC_SOF_2     TX_BASE_ADDR+0x07D 
+#define TX_PACKET_CONTROL_1       TX_BASE_ADDR+0x07E 
+#define TX_PACKET_CONTROL_2       TX_BASE_ADDR+0x07F 
+
+// core config
+#define TX_CORE_DATA_CAPTURE_1    TX_BASE_ADDR+0x0F0 
+#define TX_CORE_DATA_CAPTURE_2    TX_BASE_ADDR+0x0F1 
+#define TX_CORE_DATA_MONITOR_1    TX_BASE_ADDR+0x0F2 
+#define TX_CORE_DATA_MONITOR_2    TX_BASE_ADDR+0x0F3 
+#define TX_CORE_CALIB_MODE        TX_BASE_ADDR+0x0F4 
+#define TX_CORE_CALIB_SAMPLE_DELAY  TX_BASE_ADDR+0x0F5 
+#define TX_CORE_CALIB_VALUE_AUTO  TX_BASE_ADDR+0x0F6 
+#define TX_CORE_CALIB_VALUE       TX_BASE_ADDR+0x0F7 
+
+#define TX_CORE_EDID_CONFIG_MORE  TX_BASE_ADDR+0x080
+
+// HDCP shadow register
+#define TX_HDCP_SHW_BKSV_0        TX_BASE_ADDR+0x100 
+#define TX_HDCP_SHW_BKSV_1        TX_BASE_ADDR+0x101 
+#define TX_HDCP_SHW_BKSV_2        TX_BASE_ADDR+0x102 
+#define TX_HDCP_SHW_BKSV_3        TX_BASE_ADDR+0x103 
+#define TX_HDCP_SHW_BKSV_4        TX_BASE_ADDR+0x104 
+#define TX_HDCP_SHW_RI1_0         TX_BASE_ADDR+0x108 
+#define TX_HDCP_SHW_RI1_1         TX_BASE_ADDR+0x109 
+#define TX_HDCP_SHW_PJ1           TX_BASE_ADDR+0x10A 
+#define TX_HDCP_SHW_AKSV_0        TX_BASE_ADDR+0x110 
+#define TX_HDCP_SHW_AKSV_1        TX_BASE_ADDR+0x111 
+#define TX_HDCP_SHW_AKSV_2        TX_BASE_ADDR+0x112 
+#define TX_HDCP_SHW_AKSV_3        TX_BASE_ADDR+0x113 
+#define TX_HDCP_SHW_AKSV_4        TX_BASE_ADDR+0x114 
+#define TX_HDCP_SHW_AINFO         TX_BASE_ADDR+0x115 
+#define TX_HDCP_SHW_AN_0          TX_BASE_ADDR+0x118 
+#define TX_HDCP_SHW_AN_1          TX_BASE_ADDR+0x119 
+#define TX_HDCP_SHW_AN_2          TX_BASE_ADDR+0x11A 
+#define TX_HDCP_SHW_AN_3          TX_BASE_ADDR+0x11B 
+#define TX_HDCP_SHW_AN_4          TX_BASE_ADDR+0x11C 
+#define TX_HDCP_SHW_AN_5          TX_BASE_ADDR+0x11D 
+#define TX_HDCP_SHW_AN_6          TX_BASE_ADDR+0x11E 
+#define TX_HDCP_SHW_AN_7          TX_BASE_ADDR+0x11F 
+#define TX_HDCP_SHW_V1_H0_0       TX_BASE_ADDR+0x120 
+#define TX_HDCP_SHW_V1_H0_1       TX_BASE_ADDR+0x121 
+#define TX_HDCP_SHW_V1_H0_2       TX_BASE_ADDR+0x122 
+#define TX_HDCP_SHW_V1_H0_3       TX_BASE_ADDR+0x123 
+#define TX_HDCP_SHW_V1_H1_0       TX_BASE_ADDR+0x124 
+#define TX_HDCP_SHW_V1_H1_1       TX_BASE_ADDR+0x125 
+#define TX_HDCP_SHW_V1_H1_2       TX_BASE_ADDR+0x126 
+#define TX_HDCP_SHW_V1_H1_3       TX_BASE_ADDR+0x127 
+#define TX_HDCP_SHW_V1_H2_0       TX_BASE_ADDR+0x128 
+#define TX_HDCP_SHW_V1_H2_1       TX_BASE_ADDR+0x129 
+#define TX_HDCP_SHW_V1_H2_2       TX_BASE_ADDR+0x12A 
+#define TX_HDCP_SHW_V1_H2_3       TX_BASE_ADDR+0x12B 
+#define TX_HDCP_SHW_V1_H3_0       TX_BASE_ADDR+0x12C 
+#define TX_HDCP_SHW_V1_H3_1       TX_BASE_ADDR+0x12D 
+#define TX_HDCP_SHW_V1_H3_2       TX_BASE_ADDR+0x12E 
+#define TX_HDCP_SHW_V1_H3_3       TX_BASE_ADDR+0x12F 
+#define TX_HDCP_SHW_V1_H4_0       TX_BASE_ADDR+0x130 
+#define TX_HDCP_SHW_V1_H4_1       TX_BASE_ADDR+0x131 
+#define TX_HDCP_SHW_V1_H4_2       TX_BASE_ADDR+0x132 
+#define TX_HDCP_SHW_V1_H4_3       TX_BASE_ADDR+0x133 
+#define TX_HDCP_SHW_BCAPS         TX_BASE_ADDR+0x140 
+#define TX_HDCP_SHW_BSTATUS_0     TX_BASE_ADDR+0x141 
+#define TX_HDCP_SHW_BSTATUS_1     TX_BASE_ADDR+0x142 
+#define TX_HDCP_SHW_KSV_FIFO      TX_BASE_ADDR+0x143 
+
+// system status 0
+#define TX_SYSST0_CONNECT_FIFO    TX_BASE_ADDR+0x180 
+#define TX_SYSST0_PLL_MONITOR     TX_BASE_ADDR+0x181 
+#define TX_SYSST0_AFE_FIFO        TX_BASE_ADDR+0x182 
+#define TX_SYSST0_ROM_STATUS      TX_BASE_ADDR+0x18F 
+
+// system status 1
+#define TX_SYSST1_CALIB_BIT_RESULT_0     TX_BASE_ADDR+0x1E0 
+#define TX_SYSST1_CALIB_BIT_RESULT_1     TX_BASE_ADDR+0x1E1 
+//HDMI_STATUS_OUT[7:0]
+#define TX_HDMI_PHY_READBACK_0           TX_BASE_ADDR+0x1E2 
+//HDMI_COMP_OUT[4]
+//HDMI_STATUS_OUT[11:8]
+#define TX_HDMI_PHY_READBACK_1           TX_BASE_ADDR+0x1E3 
+#define TX_SYSST1_CALIB_BIT_RESULT_4     TX_BASE_ADDR+0x1E4 
+#define TX_SYSST1_CALIB_BIT_RESULT_5     TX_BASE_ADDR+0x1E5 
+#define TX_SYSST1_CALIB_BIT_RESULT_6     TX_BASE_ADDR+0x1E6 
+#define TX_SYSST1_CALIB_BIT_RESULT_7     TX_BASE_ADDR+0x1E7 
+#define TX_SYSST1_CALIB_BUS_RESULT_0     TX_BASE_ADDR+0x1E8 
+#define TX_SYSST1_CALIB_BUS_RESULT_1     TX_BASE_ADDR+0x1E9 
+#define TX_SYSST1_CALIB_BUS_RESULT_2     TX_BASE_ADDR+0x1EA 
+#define TX_SYSST1_CALIB_BUS_RESULT_3     TX_BASE_ADDR+0x1EB 
+#define TX_SYSST1_CALIB_BUS_RESULT_4     TX_BASE_ADDR+0x1EC 
+#define TX_SYSST1_CALIB_BUS_RESULT_5     TX_BASE_ADDR+0x1ED 
+#define TX_SYSST1_CALIB_BUS_RESULT_6     TX_BASE_ADDR+0x1EE 
+#define TX_SYSST1_CALIB_BUS_RESULT_7     TX_BASE_ADDR+0x1EF 
+
+// hdcp status
+#define TX_HDCP_ST_AUTHENTICATION        TX_BASE_ADDR+0x190 
+#define TX_HDCP_ST_FRAME_COUNT           TX_BASE_ADDR+0x191 
+#define TX_HDCP_ST_STATUS_0              TX_BASE_ADDR+0x192 
+#define TX_HDCP_ST_STATUS_1              TX_BASE_ADDR+0x193 
+#define TX_HDCP_ST_STATUS_2              TX_BASE_ADDR+0x194 
+#define TX_HDCP_ST_STATUS_3              TX_BASE_ADDR+0x195 
+#define TX_HDCP_ST_EDID_STATUS           TX_BASE_ADDR+0x196 
+#define TX_HDCP_ST_MEM_STATUS            TX_BASE_ADDR+0x197 
+#define TX_HDCP_ST_ST_MODE               TX_BASE_ADDR+0x19F 
+
+// video status
+#define TX_VIDEO_ST_ACTIVE_PIXELS_1      TX_BASE_ADDR+0x1A0 
+#define TX_VIDEO_ST_ACTIVE_PIXELS_2      TX_BASE_ADDR+0x1A1 
+#define TX_VIDEO_ST_FRONT_PIXELS         TX_BASE_ADDR+0x1A2 
+#define TX_VIDEO_ST_HSYNC_PIXELS         TX_BASE_ADDR+0x1A3 
+#define TX_VIDEO_ST_BACK_PIXELS          TX_BASE_ADDR+0x1A4 
+#define TX_VIDEO_ST_ACTIVE_LINES_1       TX_BASE_ADDR+0x1A5 
+#define TX_VIDEO_ST_ACTIVE_LINES_2       TX_BASE_ADDR+0x1A6 
+#define TX_VIDEO_ST_EOF_LINES            TX_BASE_ADDR+0x1A7 
+#define TX_VIDEO_ST_VSYNC_LINES          TX_BASE_ADDR+0x1A8 
+#define TX_VIDEO_ST_SOF_LINES            TX_BASE_ADDR+0x1A9 
+#define TX_VIDEO_ST_DTV_TIMING           TX_BASE_ADDR+0x1AA 
+#define TX_VIDEO_ST_DTV_MODE             TX_BASE_ADDR+0x1AB 
+// audio status
+#define TX_VIDEO_ST_AUDIO_STATUS         TX_BASE_ADDR+0x1AC 
+#define TX_AFE_STATUS_0                  TX_BASE_ADDR+0x1AE 
+#define TX_AFE_STATUS_1                  TX_BASE_ADDR+0x1AF 
+
+// Packet status
+#define TX_PACKET_ST_REQUEST_STATUS_1    TX_BASE_ADDR+0x1F0 
+#define TX_PACKET_ST_REQUEST_STATUS_2    TX_BASE_ADDR+0x1F1 
+#define TX_PACKET_ST_REQUEST_MISSED_1    TX_BASE_ADDR+0x1F2 
+#define TX_PACKET_ST_REQUEST_MISSED_2    TX_BASE_ADDR+0x1F3 
+#define TX_PACKET_ST_ENCODE_STATUS_0     TX_BASE_ADDR+0x1F4 
+#define TX_PACKET_ST_ENCODE_STATUS_1     TX_BASE_ADDR+0x1F5 
+#define TX_PACKET_ST_ENCODE_STATUS_2     TX_BASE_ADDR+0x1F6 
+#define TX_PACKET_ST_TIMER_STATUS        TX_BASE_ADDR+0x1F7 
+
+// tmds status
+#define TX_TMDS_ST_CLOCK_METER_1         TX_BASE_ADDR+0x1F8 
+#define TX_TMDS_ST_CLOCK_METER_2         TX_BASE_ADDR+0x1F9 
+#define TX_TMDS_ST_CLOCK_METER_3         TX_BASE_ADDR+0x1FA 
+#define TX_TMDS_ST_TMDS_STATUS_1         TX_BASE_ADDR+0x1FC 
+#define TX_TMDS_ST_TMDS_STATUS_2         TX_BASE_ADDR+0x1FD 
+#define TX_TMDS_ST_TMDS_STATUS_3         TX_BASE_ADDR+0x1FE 
+#define TX_TMDS_ST_TMDS_STATUS_4         TX_BASE_ADDR+0x1FF 
+
+
+// Packet register
+#define TX_PKT_REG_SPD_INFO_BASE_ADDR     TX_BASE_ADDR+0x200 
+#define TX_PKT_REG_VEND_INFO_BASE_ADDR    TX_BASE_ADDR+0x220 
+#define TX_PKT_REG_MPEG_INFO_BASE_ADDR    TX_BASE_ADDR+0x240 
+#define TX_PKT_REG_AVI_INFO_BASE_ADDR     TX_BASE_ADDR+0x260 
+#define TX_PKT_REG_AUDIO_INFO_BASE_ADDR   TX_BASE_ADDR+0x280 
+#define TX_PKT_REG_ACP_INFO_BASE_ADDR     TX_BASE_ADDR+0x2A0 
+#define TX_PKT_REG_ISRC1_BASE_ADDR        TX_BASE_ADDR+0x2C0 
+#define TX_PKT_REG_ISRC2_BASE_ADDR        TX_BASE_ADDR+0x2E0 
+#define TX_PKT_REG_EXCEPT0_BASE_ADDR      TX_BASE_ADDR+0x300 
+#define TX_PKT_REG_EXCEPT1_BASE_ADDR      TX_BASE_ADDR+0x320 
+#define TX_PKT_REG_EXCEPT2_BASE_ADDR      TX_BASE_ADDR+0x340 
+#define TX_PKT_REG_EXCEPT3_BASE_ADDR      TX_BASE_ADDR+0x360 
+#define TX_PKT_REG_EXCEPT4_BASE_ADDR      TX_BASE_ADDR+0x380 
+#define TX_PKT_REG_GAMUT_P0_BASE_ADDR     TX_BASE_ADDR+0x3A0 
+#define TX_PKT_REG_GAMUT_P1_1_BASE_ADDR   TX_BASE_ADDR+0x3C0 
+#define TX_PKT_REG_GAMUT_P1_2_BASE_ADDR   TX_BASE_ADDR+0x3E0 
+
+
+
+//********** CEC related **********//
+//read/write
+#define CEC_TX_MSG_0_HEADER        0x00 
+#define CEC_TX_MSG_1_OPCODE        0x01 
+#define CEC_TX_MSG_2_OP1           0x02 
+#define CEC_TX_MSG_3_OP2           0x03 
+#define CEC_TX_MSG_4_OP3           0x04 
+#define CEC_TX_MSG_5_OP4           0x05 
+#define CEC_TX_MSG_6_OP5           0x06 
+#define CEC_TX_MSG_7_OP6           0x07 
+#define CEC_TX_MSG_8_OP7           0x08 
+#define CEC_TX_MSG_9_OP8           0x09 
+#define CEC_TX_MSG_A_OP9           0x0A 
+#define CEC_TX_MSG_B_OP10          0x0B 
+#define CEC_TX_MSG_C_OP11          0x0C 
+#define CEC_TX_MSG_D_OP12          0x0D 
+#define CEC_TX_MSG_E_OP13          0x0E 
+#define CEC_TX_MSG_F_OP14          0x0F 
+
+//read only
+#define CEC_TX_MSG_LENGTH          0x10 
+#define CEC_TX_MSG_CMD             0x11 
+#define CEC_TX_WRITE_BUF           0x12 
+#define CEC_TX_CLEAR_BUF           0x13 
+#define CEC_RX_MSG_CMD             0x14 
+#define CEC_RX_CLEAR_BUF           0x15 
+#define CEC_LOGICAL_ADDR0          0x16 
+#define CEC_LOGICAL_ADDR1          0x17 
+#define CEC_LOGICAL_ADDR2          0x18 
+#define CEC_LOGICAL_ADDR3          0x19 
+#define CEC_LOGICAL_ADDR4          0x1A 
+#define CEC_CLOCK_DIV_H            0x1B 
+#define CEC_CLOCK_DIV_L            0x1C 
+
+//read/write
+#define CEC_RX_MSG_0_HEADER        0x80 
+#define CEC_RX_MSG_1_OPCODE        0x81 
+#define CEC_RX_MSG_2_OP1           0x82 
+#define CEC_RX_MSG_3_OP2           0x83 
+#define CEC_RX_MSG_4_OP3           0x84 
+#define CEC_RX_MSG_5_OP4           0x85 
+#define CEC_RX_MSG_6_OP5           0x86 
+#define CEC_RX_MSG_7_OP6           0x87 
+#define CEC_RX_MSG_8_OP7           0x88 
+#define CEC_RX_MSG_9_OP8           0x89 
+#define CEC_RX_MSG_A_OP9           0x8A 
+#define CEC_RX_MSG_B_OP10          0x8B 
+#define CEC_RX_MSG_C_OP11          0x8C 
+#define CEC_RX_MSG_D_OP12          0x8D 
+#define CEC_RX_MSG_E_OP13          0x8E 
+#define CEC_RX_MSG_F_OP14          0x8F 
+
+//read only
+#define CEC_RX_MSG_LENGTH          0x90 
+#define CEC_RX_MSG_STATUS          0x91 
+#define CEC_RX_NUM_MSG             0x92 
+#define CEC_TX_MSG_STATUS          0x93 
+#define CEC_TX_NUM_MSG             0x94 
+
+// tx_msg_cmd definition
+#define TX_NO_OP                0  // No transaction
+#define TX_REQ_CURRENT          1  // Transmit earliest message in buffer
+#define TX_ABORT                2  // Abort transmitting earliest message
+#define TX_REQ_NEXT             3  // Overwrite earliest message in buffer and transmit next message
+
+// tx_msg_status definition
+#define TX_IDLE                 0  // No transaction
+#define TX_BUSY                 1  // Transmitter is busy
+#define TX_DONE                 2  // Message has been successfully transmitted
+#define TX_ERROR                3  // Message has been transmitted with error
+
+// rx_msg_cmd
+#define RX_NO_OP                0  // No transaction
+#define RX_ACK_CURRENT          1  // Read earliest message in buffer
+#define RX_DISABLE              2  // Disable receiving latest message
+#define RX_ACK_NEXT             3  // Clear earliest message from buffer and read next message
+
+// rx_msg_status
+#define RX_IDLE                 0  // No transaction
+#define RX_BUSY                 1  // Receiver is busy
+#define RX_DONE                 2  // Message has been received successfully
+#define RX_ERROR                3  // Message has been received with error
+
+#endif
+
diff --git a/drivers/amlogic/display/vout/tvoutc.c b/drivers/amlogic/display/vout/tvoutc.c
index 52878f3d2dc3..809a4549bfbd 100755
--- a/drivers/amlogic/display/vout/tvoutc.c
+++ b/drivers/amlogic/display/vout/tvoutc.c
@@ -310,9 +310,7 @@ int tvoutc_setmode(tvmode_t mode)
     }else{
 	aml_write_reg32(P_PERIPHS_PIN_MUX_0,aml_read_reg32(P_PERIPHS_PIN_MUX_0)&(~(3<<20)));
     }
-#if 0       //todo
     set_tvmode_misc(mode);
-#endif
 #ifdef CONFIG_ARCH_MESON1
 	tvoutc_setclk(mode);
     printk("%s[%d]\n", __func__, __LINE__);
diff --git a/drivers/amlogic/hdmi/hdmi_tx/Makefile b/drivers/amlogic/hdmi/hdmi_tx/Makefile
index 7398f9c73d1f..64395d7ec758 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/Makefile
+++ b/drivers/amlogic/hdmi/hdmi_tx/Makefile
@@ -1,13 +1,5 @@
 obj-$(CONFIG_AML_HDMI_TX)		+= hdmitx.o
 
-hdmitx-objs := hdmi_tx.o hdmi_tx_cec.o hdmi_cec_key.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_compliance.o \
-
-ifeq ($(CONFIG_ARCH_MESON8),y)
-obj-$(CONFIG_AML_HDMI_TX)  += hdmi_tx_miniboot.o
-endif
-
-obj-$(CONFIG_AML_HDMI_TX)	+= hw/
+hdmitx-objs := hdmi_tx.o hdmi_tx_cec.o hdmi_cec_key.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o \
 
 #EXTRA_CFLAGS += -O2
-
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
index 94ccd1645c21..732cb2de1845 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
@@ -32,8 +32,7 @@
 
 #include <mach/gpio.h>
 
-#include "hw/hdmi_tx_reg.h"
-#include "hdmi_tx_module.h"
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 #include "hdmi_tx_cec.h"
 
 hdmitx_dev_t *hdmitx_device = NULL;
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h
index 9dc3ac1bac6c..ef9afa3aac52 100644
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h
@@ -30,9 +30,9 @@
 //#define RX_BASE_ADDR     0x04000        //inside chip
 //#endif
 
-#define SIM_BASE_ADDR    0x18000        //outside chip 
-#define CEC0_BASE_ADDR    0x0c000       //inside chip 
-#define CEC1_BASE_ADDR    0x1c100       //outside chip 
+#define SIM_BASE_ADDR    0x18000        //outside chip
+#define CEC0_BASE_ADDR    0x0c000       //inside chip
+#define CEC1_BASE_ADDR    0x1c100       //outside chip
 
 #define OTHER_BASE_ADDR  0x08000        //inside chip
 
@@ -52,150 +52,150 @@
 #define HDMI_OTHER_RX_PACKET_INTR_CLR       0xc
 
 //********** TX related **********//
-#define TX_HDCP_DKEY_OFFSET             TX_BASE_ADDR+0x400 
-#define TX_RX_EDID_OFFSET               TX_BASE_ADDR+0x600 
-#define TX_HDCP_SHADOW_OFFSET           TX_BASE_ADDR+0x100 
+#define TX_HDCP_DKEY_OFFSET             TX_BASE_ADDR+0x400
+#define TX_RX_EDID_OFFSET               TX_BASE_ADDR+0x600
+#define TX_HDCP_SHADOW_OFFSET           TX_BASE_ADDR+0x100
 
-#define TX_IEC60958_SUB1_OFFSET         TX_BASE_ADDR+0x0B0 
-#define TX_IEC60958_SUB2_OFFSET         TX_BASE_ADDR+0x0C8 
+#define TX_IEC60958_SUB1_OFFSET         TX_BASE_ADDR+0x0B0
+#define TX_IEC60958_SUB2_OFFSET         TX_BASE_ADDR+0x0C8
 
-#define TX_IEC60958_ST_SUB1_OFFSET      TX_BASE_ADDR+0x1B0 
-#define TX_IEC60958_ST_SUB2_OFFSET      TX_BASE_ADDR+0x1C8 
+#define TX_IEC60958_ST_SUB1_OFFSET      TX_BASE_ADDR+0x1B0
+#define TX_IEC60958_ST_SUB2_OFFSET      TX_BASE_ADDR+0x1C8
 
 // System config 0
-#define TX_SYS0_AFE_SIGNAL        TX_BASE_ADDR+0x000 
-#define TX_SYS0_AFE_LOOP          TX_BASE_ADDR+0x001 
-#define TX_SYS0_ACR_CTS_0         TX_BASE_ADDR+0x002 
-#define TX_SYS0_ACR_CTS_1         TX_BASE_ADDR+0x003 
-#define TX_SYS0_ACR_CTS_2         TX_BASE_ADDR+0x004 
-#define TX_SYS0_BIST_CONTROL      TX_BASE_ADDR+0x005 
-#define TX_SYS0_BIST_DATA_0       TX_BASE_ADDR+0x006 
-#define TX_SYS0_BIST_DATA_1       TX_BASE_ADDR+0x007 
-#define TX_SYS0_BIST_DATA_2       TX_BASE_ADDR+0x008 
-#define TX_SYS0_BIST_DATA_3       TX_BASE_ADDR+0x009 
-#define TX_SYS0_BIST_DATA_4       TX_BASE_ADDR+0x00A 
-#define TX_SYS0_BIST_DATA_5       TX_BASE_ADDR+0x00B 
-#define TX_SYS0_BIST_DATA_6       TX_BASE_ADDR+0x00C 
-#define TX_SYS0_BIST_DATA_7       TX_BASE_ADDR+0x00D 
-#define TX_SYS0_BIST_DATA_8       TX_BASE_ADDR+0x00E 
-#define TX_SYS0_BIST_DATA_9       TX_BASE_ADDR+0x00F 
+#define TX_SYS0_AFE_SIGNAL        TX_BASE_ADDR+0x000
+#define TX_SYS0_AFE_LOOP          TX_BASE_ADDR+0x001
+#define TX_SYS0_ACR_CTS_0         TX_BASE_ADDR+0x002
+#define TX_SYS0_ACR_CTS_1         TX_BASE_ADDR+0x003
+#define TX_SYS0_ACR_CTS_2         TX_BASE_ADDR+0x004
+#define TX_SYS0_BIST_CONTROL      TX_BASE_ADDR+0x005
+#define TX_SYS0_BIST_DATA_0       TX_BASE_ADDR+0x006
+#define TX_SYS0_BIST_DATA_1       TX_BASE_ADDR+0x007
+#define TX_SYS0_BIST_DATA_2       TX_BASE_ADDR+0x008
+#define TX_SYS0_BIST_DATA_3       TX_BASE_ADDR+0x009
+#define TX_SYS0_BIST_DATA_4       TX_BASE_ADDR+0x00A
+#define TX_SYS0_BIST_DATA_5       TX_BASE_ADDR+0x00B
+#define TX_SYS0_BIST_DATA_6       TX_BASE_ADDR+0x00C
+#define TX_SYS0_BIST_DATA_7       TX_BASE_ADDR+0x00D
+#define TX_SYS0_BIST_DATA_8       TX_BASE_ADDR+0x00E
+#define TX_SYS0_BIST_DATA_9       TX_BASE_ADDR+0x00F
 // system config 1
-#define TX_SYS1_ACR_N_0           TX_BASE_ADDR+0x01C 
-#define TX_SYS1_ACR_N_1           TX_BASE_ADDR+0x01D 
-#define TX_SYS1_ACR_N_2           TX_BASE_ADDR+0x01E 
-#define TX_SYS1_PRBS_DATA         TX_BASE_ADDR+0x01F 
+#define TX_SYS1_ACR_N_0           TX_BASE_ADDR+0x01C
+#define TX_SYS1_ACR_N_1           TX_BASE_ADDR+0x01D
+#define TX_SYS1_ACR_N_2           TX_BASE_ADDR+0x01E
+#define TX_SYS1_PRBS_DATA         TX_BASE_ADDR+0x01F
 // system config 4
-#define TX_SYS4_TX_CKI_DDR        TX_BASE_ADDR+0x0A0 
-#define TX_SYS4_TX_CKO_DDR        TX_BASE_ADDR+0x0A1 
-#define TX_SYS4_RX_CKI_DDR        TX_BASE_ADDR+0x0A2 
-#define TX_SYS4_RX_CKO_DDR        TX_BASE_ADDR+0x0A3 
-#define TX_SYS4_CONNECT_SEL_0     TX_BASE_ADDR+0x0A4 
-#define TX_SYS4_CONNECT_SEL_1     TX_BASE_ADDR+0x0A5 
-#define TX_SYS4_CONNECT_SEL_2     TX_BASE_ADDR+0x0A6 
-#define TX_SYS4_CONNECT_SEL_3     TX_BASE_ADDR+0x0A7 
-#define TX_SYS4_CK_INV_VIDEO      TX_BASE_ADDR+0x0A8 
-#define TX_SYS4_CK_INV_AUDIO      TX_BASE_ADDR+0x0A9 
-#define TX_SYS4_CK_INV_AFE        TX_BASE_ADDR+0x0AA 
-#define TX_SYS4_CK_INV_CH01       TX_BASE_ADDR+0x0AB 
-#define TX_SYS4_CK_INV_CH2        TX_BASE_ADDR+0x0AC 
-#define TX_SYS4_CK_CEC            TX_BASE_ADDR+0x0AD 
-#define TX_SYS4_CK_SOURCE_1       TX_BASE_ADDR+0x0AE 
-#define TX_SYS4_CK_SOURCE_2       TX_BASE_ADDR+0x0AF 
+#define TX_SYS4_TX_CKI_DDR        TX_BASE_ADDR+0x0A0
+#define TX_SYS4_TX_CKO_DDR        TX_BASE_ADDR+0x0A1
+#define TX_SYS4_RX_CKI_DDR        TX_BASE_ADDR+0x0A2
+#define TX_SYS4_RX_CKO_DDR        TX_BASE_ADDR+0x0A3
+#define TX_SYS4_CONNECT_SEL_0     TX_BASE_ADDR+0x0A4
+#define TX_SYS4_CONNECT_SEL_1     TX_BASE_ADDR+0x0A5
+#define TX_SYS4_CONNECT_SEL_2     TX_BASE_ADDR+0x0A6
+#define TX_SYS4_CONNECT_SEL_3     TX_BASE_ADDR+0x0A7
+#define TX_SYS4_CK_INV_VIDEO      TX_BASE_ADDR+0x0A8
+#define TX_SYS4_CK_INV_AUDIO      TX_BASE_ADDR+0x0A9
+#define TX_SYS4_CK_INV_AFE        TX_BASE_ADDR+0x0AA
+#define TX_SYS4_CK_INV_CH01       TX_BASE_ADDR+0x0AB
+#define TX_SYS4_CK_INV_CH2        TX_BASE_ADDR+0x0AC
+#define TX_SYS4_CK_CEC            TX_BASE_ADDR+0x0AD
+#define TX_SYS4_CK_SOURCE_1       TX_BASE_ADDR+0x0AE
+#define TX_SYS4_CK_SOURCE_2       TX_BASE_ADDR+0x0AF
 // system config 5
-#define TX_SYS5_TX_SOFT_RESET_1   TX_BASE_ADDR+0x0E0 
-#define TX_SYS5_TX_SOFT_RESET_2   TX_BASE_ADDR+0x0E1 
-#define TX_SYS5_RX_SOFT_RESET_1   TX_BASE_ADDR+0x0E2 
-#define TX_SYS5_RX_SOFT_RESET_2   TX_BASE_ADDR+0x0E3 
-#define TX_SYS5_RX_SOFT_RESET_3   TX_BASE_ADDR+0x0E4 
-#define TX_SYS5_SSTL_BIDIR_IN     TX_BASE_ADDR+0x0E5 
-#define TX_SYS5_SSTL_IN           TX_BASE_ADDR+0x0E6 
-#define TX_SYS5_SSTL_DIFF_IN      TX_BASE_ADDR+0x0E7 
-#define TX_SYS5_FIFO_CONFIG       TX_BASE_ADDR+0x0E8 
-#define TX_SYS5_FIFO_SAMP01_CFG   TX_BASE_ADDR+0x0E9 
-#define TX_SYS5_FIFO_SAMP23_CFG   TX_BASE_ADDR+0x0EA 
-#define TX_SYS5_CONNECT_FIFO_CFG  TX_BASE_ADDR+0x0EB 
-#define TX_SYS5_IO_CALIB_CONTROL  TX_BASE_ADDR+0x0EC 
-#define TX_SYS5_SSTL_BIDIR_OUT    TX_BASE_ADDR+0x0ED 
-#define TX_SYS5_SSTL_OUT          TX_BASE_ADDR+0x0EE 
-#define TX_SYS5_SSTL_DIFF_OUT     TX_BASE_ADDR+0x0EF 
+#define TX_SYS5_TX_SOFT_RESET_1   TX_BASE_ADDR+0x0E0
+#define TX_SYS5_TX_SOFT_RESET_2   TX_BASE_ADDR+0x0E1
+#define TX_SYS5_RX_SOFT_RESET_1   TX_BASE_ADDR+0x0E2
+#define TX_SYS5_RX_SOFT_RESET_2   TX_BASE_ADDR+0x0E3
+#define TX_SYS5_RX_SOFT_RESET_3   TX_BASE_ADDR+0x0E4
+#define TX_SYS5_SSTL_BIDIR_IN     TX_BASE_ADDR+0x0E5
+#define TX_SYS5_SSTL_IN           TX_BASE_ADDR+0x0E6
+#define TX_SYS5_SSTL_DIFF_IN      TX_BASE_ADDR+0x0E7
+#define TX_SYS5_FIFO_CONFIG       TX_BASE_ADDR+0x0E8
+#define TX_SYS5_FIFO_SAMP01_CFG   TX_BASE_ADDR+0x0E9
+#define TX_SYS5_FIFO_SAMP23_CFG   TX_BASE_ADDR+0x0EA
+#define TX_SYS5_CONNECT_FIFO_CFG  TX_BASE_ADDR+0x0EB
+#define TX_SYS5_IO_CALIB_CONTROL  TX_BASE_ADDR+0x0EC
+#define TX_SYS5_SSTL_BIDIR_OUT    TX_BASE_ADDR+0x0ED
+#define TX_SYS5_SSTL_OUT          TX_BASE_ADDR+0x0EE
+#define TX_SYS5_SSTL_DIFF_OUT     TX_BASE_ADDR+0x0EF
 
 // HDCP CONFIG
-#define TX_HDCP_ECC_CONFIG        TX_BASE_ADDR+0x024 
-#define TX_HDCP_CRC_CONFIG        TX_BASE_ADDR+0x025 
-#define TX_HDCP_EDID_CONFIG       TX_BASE_ADDR+0x026 
-#define TX_HDCP_MEM_CONFIG        TX_BASE_ADDR+0x027 
-#define TX_HDCP_HPD_FILTER_L      TX_BASE_ADDR+0x028 
-#define TX_HDCP_HPD_FILTER_H      TX_BASE_ADDR+0x029 
-#define TX_HDCP_ENCRYPT_BYTE      TX_BASE_ADDR+0x02A 
-#define TX_HDCP_CONFIG0           TX_BASE_ADDR+0x02B 
-#define TX_HDCP_CONFIG1           TX_BASE_ADDR+0x02C 
-#define TX_HDCP_CONFIG2           TX_BASE_ADDR+0x02D 
-#define TX_HDCP_CONFIG3           TX_BASE_ADDR+0x02E 
-#define TX_HDCP_MODE              TX_BASE_ADDR+0x02F 
+#define TX_HDCP_ECC_CONFIG        TX_BASE_ADDR+0x024
+#define TX_HDCP_CRC_CONFIG        TX_BASE_ADDR+0x025
+#define TX_HDCP_EDID_CONFIG       TX_BASE_ADDR+0x026
+#define TX_HDCP_MEM_CONFIG        TX_BASE_ADDR+0x027
+#define TX_HDCP_HPD_FILTER_L      TX_BASE_ADDR+0x028
+#define TX_HDCP_HPD_FILTER_H      TX_BASE_ADDR+0x029
+#define TX_HDCP_ENCRYPT_BYTE      TX_BASE_ADDR+0x02A
+#define TX_HDCP_CONFIG0           TX_BASE_ADDR+0x02B
+#define TX_HDCP_CONFIG1           TX_BASE_ADDR+0x02C
+#define TX_HDCP_CONFIG2           TX_BASE_ADDR+0x02D
+#define TX_HDCP_CONFIG3           TX_BASE_ADDR+0x02E
+#define TX_HDCP_MODE              TX_BASE_ADDR+0x02F
 
 // Video config, part 1
-#define TX_VIDEO_ACTIVE_PIXELS_0  TX_BASE_ADDR+0x030 
-#define TX_VIDEO_ACTIVE_PIXELS_1  TX_BASE_ADDR+0x031 
-#define TX_VIDEO_FRONT_PIXELS     TX_BASE_ADDR+0x032 
-#define TX_VIDEO_HSYNC_PIXELS     TX_BASE_ADDR+0x033 
-#define TX_VIDEO_BACK_PIXELS      TX_BASE_ADDR+0x034 
-#define TX_VIDEO_ACTIVE_LINES_0   TX_BASE_ADDR+0x035 
-#define TX_VIDEO_ACTIVE_LINES_1   TX_BASE_ADDR+0x036 
-#define TX_VIDEO_EOF_LINES        TX_BASE_ADDR+0x037 
-#define TX_VIDEO_VSYNC_LINES      TX_BASE_ADDR+0x038 
-#define TX_VIDEO_SOF_LINES        TX_BASE_ADDR+0x039 
-#define TX_VIDEO_DTV_TIMING       TX_BASE_ADDR+0x03A 
-#define TX_VIDEO_DTV_MODE         TX_BASE_ADDR+0x03B 
-#define TX_VIDEO_DTV_FORMAT0      TX_BASE_ADDR+0x03C 
-#define TX_VIDEO_DTV_FORMAT1      TX_BASE_ADDR+0x03D 
-#define TX_VIDEO_EXTENSION_4K2K   TX_BASE_ADDR+0x03E 
-#define TX_VIDEO_PIXEL_PACK       TX_BASE_ADDR+0x03F 
+#define TX_VIDEO_ACTIVE_PIXELS_0  TX_BASE_ADDR+0x030
+#define TX_VIDEO_ACTIVE_PIXELS_1  TX_BASE_ADDR+0x031
+#define TX_VIDEO_FRONT_PIXELS     TX_BASE_ADDR+0x032
+#define TX_VIDEO_HSYNC_PIXELS     TX_BASE_ADDR+0x033
+#define TX_VIDEO_BACK_PIXELS      TX_BASE_ADDR+0x034
+#define TX_VIDEO_ACTIVE_LINES_0   TX_BASE_ADDR+0x035
+#define TX_VIDEO_ACTIVE_LINES_1   TX_BASE_ADDR+0x036
+#define TX_VIDEO_EOF_LINES        TX_BASE_ADDR+0x037
+#define TX_VIDEO_VSYNC_LINES      TX_BASE_ADDR+0x038
+#define TX_VIDEO_SOF_LINES        TX_BASE_ADDR+0x039
+#define TX_VIDEO_DTV_TIMING       TX_BASE_ADDR+0x03A
+#define TX_VIDEO_DTV_MODE         TX_BASE_ADDR+0x03B
+#define TX_VIDEO_DTV_FORMAT0      TX_BASE_ADDR+0x03C
+#define TX_VIDEO_DTV_FORMAT1      TX_BASE_ADDR+0x03D
+#define TX_VIDEO_EXTENSION_4K2K   TX_BASE_ADDR+0x03E
+#define TX_VIDEO_PIXEL_PACK       TX_BASE_ADDR+0x03F
 // video config, part 2
-#define TX_VIDEO_CSC_COEFF_B0     TX_BASE_ADDR+0x040 
-#define TX_VIDEO_CSC_COEFF_B1     TX_BASE_ADDR+0x041 
-#define TX_VIDEO_CSC_COEFF_R0     TX_BASE_ADDR+0x042 
-#define TX_VIDEO_CSC_COEFF_R1     TX_BASE_ADDR+0x043 
-#define TX_VIDEO_CSC_COEFF_CB0    TX_BASE_ADDR+0x044 
-#define TX_VIDEO_CSC_COEFF_CB1    TX_BASE_ADDR+0x045 
-#define TX_VIDEO_CSC_COEFF_CR0    TX_BASE_ADDR+0x046 
-#define TX_VIDEO_CSC_COEFF_CR1    TX_BASE_ADDR+0x047 
-#define TX_VIDEO_DTV_OPTION_L     TX_BASE_ADDR+0x048 
-#define TX_VIDEO_DTV_OPTION_H     TX_BASE_ADDR+0x049 
-#define TX_VIDEO_DTV_FILTER       TX_BASE_ADDR+0x04A 
-#define TX_VIDEO_DTV_DITHER       TX_BASE_ADDR+0x04B 
-#define TX_VIDEO_DTV_DEDITHER     TX_BASE_ADDR+0x04C 
-#define TX_VIDEO_PROC_CONFIG0     TX_BASE_ADDR+0x04E 
-#define TX_VIDEO_PROC_CONFIG1     TX_BASE_ADDR+0x04F 
+#define TX_VIDEO_CSC_COEFF_B0     TX_BASE_ADDR+0x040
+#define TX_VIDEO_CSC_COEFF_B1     TX_BASE_ADDR+0x041
+#define TX_VIDEO_CSC_COEFF_R0     TX_BASE_ADDR+0x042
+#define TX_VIDEO_CSC_COEFF_R1     TX_BASE_ADDR+0x043
+#define TX_VIDEO_CSC_COEFF_CB0    TX_BASE_ADDR+0x044
+#define TX_VIDEO_CSC_COEFF_CB1    TX_BASE_ADDR+0x045
+#define TX_VIDEO_CSC_COEFF_CR0    TX_BASE_ADDR+0x046
+#define TX_VIDEO_CSC_COEFF_CR1    TX_BASE_ADDR+0x047
+#define TX_VIDEO_DTV_OPTION_L     TX_BASE_ADDR+0x048
+#define TX_VIDEO_DTV_OPTION_H     TX_BASE_ADDR+0x049
+#define TX_VIDEO_DTV_FILTER       TX_BASE_ADDR+0x04A
+#define TX_VIDEO_DTV_DITHER       TX_BASE_ADDR+0x04B
+#define TX_VIDEO_DTV_DEDITHER     TX_BASE_ADDR+0x04C
+#define TX_VIDEO_PROC_CONFIG0     TX_BASE_ADDR+0x04E
+#define TX_VIDEO_PROC_CONFIG1     TX_BASE_ADDR+0x04F
 
 // Audio config
-#define TX_AUDIO_FORMAT           TX_BASE_ADDR+0x058 
-#define TX_AUDIO_SPDIF            TX_BASE_ADDR+0x059 
-#define TX_AUDIO_I2S              TX_BASE_ADDR+0x05A 
-#define TX_AUDIO_FIFO             TX_BASE_ADDR+0x05B 
-#define TX_AUDIO_LIPSYNC          TX_BASE_ADDR+0x05C 
-#define TX_AUDIO_CONTROL          TX_BASE_ADDR+0x05D 
-#define TX_AUDIO_HEADER           TX_BASE_ADDR+0x05E 
-#define TX_AUDIO_SAMPLE           TX_BASE_ADDR+0x05F 
-#define TX_AUDIO_VALID            TX_BASE_ADDR+0x060 
-#define TX_AUDIO_USER             TX_BASE_ADDR+0x061 
-#define TX_AUDIO_PACK             TX_BASE_ADDR+0x062 
+#define TX_AUDIO_FORMAT           TX_BASE_ADDR+0x058
+#define TX_AUDIO_SPDIF            TX_BASE_ADDR+0x059
+#define TX_AUDIO_I2S              TX_BASE_ADDR+0x05A
+#define TX_AUDIO_FIFO             TX_BASE_ADDR+0x05B
+#define TX_AUDIO_LIPSYNC          TX_BASE_ADDR+0x05C
+#define TX_AUDIO_CONTROL          TX_BASE_ADDR+0x05D
+#define TX_AUDIO_HEADER           TX_BASE_ADDR+0x05E
+#define TX_AUDIO_SAMPLE           TX_BASE_ADDR+0x05F
+#define TX_AUDIO_VALID            TX_BASE_ADDR+0x060
+#define TX_AUDIO_USER             TX_BASE_ADDR+0x061
+#define TX_AUDIO_PACK             TX_BASE_ADDR+0x062
 #define TX_AUDIO_CLOCK_METER      TX_BASE_ADDR+0x063
 #define TX_AUDIO_CONTROL_MORE     TX_BASE_ADDR+0x064
 
 // tmds config
-#define TX_TMDS_MODE              TX_BASE_ADDR+0x068 
-#define TX_TMDS_CONFIG0           TX_BASE_ADDR+0x06C 
-#define TX_TMDS_CONFIG1           TX_BASE_ADDR+0x06D 
+#define TX_TMDS_MODE              TX_BASE_ADDR+0x068
+#define TX_TMDS_CONFIG0           TX_BASE_ADDR+0x06C
+#define TX_TMDS_CONFIG1           TX_BASE_ADDR+0x06D
 
 // packet config
-#define TX_PACKET_ALLOC_ACTIVE_1  TX_BASE_ADDR+0x078 
-#define TX_PACKET_ALLOC_ACTIVE_2  TX_BASE_ADDR+0x079 
-#define TX_PACKET_ALLOC_EOF_1     TX_BASE_ADDR+0x07A 
-#define TX_PACKET_ALLOC_EOF_2     TX_BASE_ADDR+0x07B 
-#define TX_PACKET_ALLOC_SOF_1     TX_BASE_ADDR+0x07C 
-#define TX_PACKET_ALLOC_SOF_2     TX_BASE_ADDR+0x07D 
-#define TX_PACKET_CONTROL_1       TX_BASE_ADDR+0x07E 
-#define TX_PACKET_CONTROL_2       TX_BASE_ADDR+0x07F 
+#define TX_PACKET_ALLOC_ACTIVE_1  TX_BASE_ADDR+0x078
+#define TX_PACKET_ALLOC_ACTIVE_2  TX_BASE_ADDR+0x079
+#define TX_PACKET_ALLOC_EOF_1     TX_BASE_ADDR+0x07A
+#define TX_PACKET_ALLOC_EOF_2     TX_BASE_ADDR+0x07B
+#define TX_PACKET_ALLOC_SOF_1     TX_BASE_ADDR+0x07C
+#define TX_PACKET_ALLOC_SOF_2     TX_BASE_ADDR+0x07D
+#define TX_PACKET_CONTROL_1       TX_BASE_ADDR+0x07E
+#define TX_PACKET_CONTROL_2       TX_BASE_ADDR+0x07F
 
 #define TX_EDID_CONFIG_MORE       TX_BASE_ADDR+0x080
 #define TX_ALLOC_VSYNC_1          TX_BASE_ADDR+0x081
@@ -204,527 +204,527 @@
 #define TX_MEM_PD_REG0            TX_BASE_ADDR+0x084
 
 // core config
-#define TX_CORE_DATA_CAPTURE_1    TX_BASE_ADDR+0x0F0 
-#define TX_CORE_DATA_CAPTURE_2    TX_BASE_ADDR+0x0F1 
-#define TX_CORE_DATA_MONITOR_1    TX_BASE_ADDR+0x0F2 
-#define TX_CORE_DATA_MONITOR_2    TX_BASE_ADDR+0x0F3 
-#define TX_CORE_CALIB_MODE        TX_BASE_ADDR+0x0F4 
-#define TX_CORE_CALIB_SAMPLE_DELAY  TX_BASE_ADDR+0x0F5 
-#define TX_CORE_CALIB_VALUE_AUTO  TX_BASE_ADDR+0x0F6 
-#define TX_CORE_CALIB_VALUE       TX_BASE_ADDR+0x0F7 
+#define TX_CORE_DATA_CAPTURE_1    TX_BASE_ADDR+0x0F0
+#define TX_CORE_DATA_CAPTURE_2    TX_BASE_ADDR+0x0F1
+#define TX_CORE_DATA_MONITOR_1    TX_BASE_ADDR+0x0F2
+#define TX_CORE_DATA_MONITOR_2    TX_BASE_ADDR+0x0F3
+#define TX_CORE_CALIB_MODE        TX_BASE_ADDR+0x0F4
+#define TX_CORE_CALIB_SAMPLE_DELAY  TX_BASE_ADDR+0x0F5
+#define TX_CORE_CALIB_VALUE_AUTO  TX_BASE_ADDR+0x0F6
+#define TX_CORE_CALIB_VALUE       TX_BASE_ADDR+0x0F7
 
 // HDCP shadow register
-#define TX_HDCP_SHW_BKSV_0        TX_BASE_ADDR+0x100 
-#define TX_HDCP_SHW_BKSV_1        TX_BASE_ADDR+0x101 
-#define TX_HDCP_SHW_BKSV_2        TX_BASE_ADDR+0x102 
-#define TX_HDCP_SHW_BKSV_3        TX_BASE_ADDR+0x103 
-#define TX_HDCP_SHW_BKSV_4        TX_BASE_ADDR+0x104 
-#define TX_HDCP_SHW_RI1_0         TX_BASE_ADDR+0x108 
-#define TX_HDCP_SHW_RI1_1         TX_BASE_ADDR+0x109 
-#define TX_HDCP_SHW_PJ1           TX_BASE_ADDR+0x10A 
-#define TX_HDCP_SHW_AKSV_0        TX_BASE_ADDR+0x110 
-#define TX_HDCP_SHW_AKSV_1        TX_BASE_ADDR+0x111 
-#define TX_HDCP_SHW_AKSV_2        TX_BASE_ADDR+0x112 
-#define TX_HDCP_SHW_AKSV_3        TX_BASE_ADDR+0x113 
-#define TX_HDCP_SHW_AKSV_4        TX_BASE_ADDR+0x114 
-#define TX_HDCP_SHW_AINFO         TX_BASE_ADDR+0x115 
-#define TX_HDCP_SHW_AN_0          TX_BASE_ADDR+0x118 
-#define TX_HDCP_SHW_AN_1          TX_BASE_ADDR+0x119 
-#define TX_HDCP_SHW_AN_2          TX_BASE_ADDR+0x11A 
-#define TX_HDCP_SHW_AN_3          TX_BASE_ADDR+0x11B 
-#define TX_HDCP_SHW_AN_4          TX_BASE_ADDR+0x11C 
-#define TX_HDCP_SHW_AN_5          TX_BASE_ADDR+0x11D 
-#define TX_HDCP_SHW_AN_6          TX_BASE_ADDR+0x11E 
-#define TX_HDCP_SHW_AN_7          TX_BASE_ADDR+0x11F 
-#define TX_HDCP_SHW_V1_H0_0       TX_BASE_ADDR+0x120 
-#define TX_HDCP_SHW_V1_H0_1       TX_BASE_ADDR+0x121 
-#define TX_HDCP_SHW_V1_H0_2       TX_BASE_ADDR+0x122 
-#define TX_HDCP_SHW_V1_H0_3       TX_BASE_ADDR+0x123 
-#define TX_HDCP_SHW_V1_H1_0       TX_BASE_ADDR+0x124 
-#define TX_HDCP_SHW_V1_H1_1       TX_BASE_ADDR+0x125 
-#define TX_HDCP_SHW_V1_H1_2       TX_BASE_ADDR+0x126 
-#define TX_HDCP_SHW_V1_H1_3       TX_BASE_ADDR+0x127 
-#define TX_HDCP_SHW_V1_H2_0       TX_BASE_ADDR+0x128 
-#define TX_HDCP_SHW_V1_H2_1       TX_BASE_ADDR+0x129 
-#define TX_HDCP_SHW_V1_H2_2       TX_BASE_ADDR+0x12A 
-#define TX_HDCP_SHW_V1_H2_3       TX_BASE_ADDR+0x12B 
-#define TX_HDCP_SHW_V1_H3_0       TX_BASE_ADDR+0x12C 
-#define TX_HDCP_SHW_V1_H3_1       TX_BASE_ADDR+0x12D 
-#define TX_HDCP_SHW_V1_H3_2       TX_BASE_ADDR+0x12E 
-#define TX_HDCP_SHW_V1_H3_3       TX_BASE_ADDR+0x12F 
-#define TX_HDCP_SHW_V1_H4_0       TX_BASE_ADDR+0x130 
-#define TX_HDCP_SHW_V1_H4_1       TX_BASE_ADDR+0x131 
-#define TX_HDCP_SHW_V1_H4_2       TX_BASE_ADDR+0x132 
-#define TX_HDCP_SHW_V1_H4_3       TX_BASE_ADDR+0x133 
-#define TX_HDCP_SHW_BCAPS         TX_BASE_ADDR+0x140 
-#define TX_HDCP_SHW_BSTATUS_0     TX_BASE_ADDR+0x141 
-#define TX_HDCP_SHW_BSTATUS_1     TX_BASE_ADDR+0x142 
-#define TX_HDCP_SHW_KSV_FIFO      TX_BASE_ADDR+0x143 
+#define TX_HDCP_SHW_BKSV_0        TX_BASE_ADDR+0x100
+#define TX_HDCP_SHW_BKSV_1        TX_BASE_ADDR+0x101
+#define TX_HDCP_SHW_BKSV_2        TX_BASE_ADDR+0x102
+#define TX_HDCP_SHW_BKSV_3        TX_BASE_ADDR+0x103
+#define TX_HDCP_SHW_BKSV_4        TX_BASE_ADDR+0x104
+#define TX_HDCP_SHW_RI1_0         TX_BASE_ADDR+0x108
+#define TX_HDCP_SHW_RI1_1         TX_BASE_ADDR+0x109
+#define TX_HDCP_SHW_PJ1           TX_BASE_ADDR+0x10A
+#define TX_HDCP_SHW_AKSV_0        TX_BASE_ADDR+0x110
+#define TX_HDCP_SHW_AKSV_1        TX_BASE_ADDR+0x111
+#define TX_HDCP_SHW_AKSV_2        TX_BASE_ADDR+0x112
+#define TX_HDCP_SHW_AKSV_3        TX_BASE_ADDR+0x113
+#define TX_HDCP_SHW_AKSV_4        TX_BASE_ADDR+0x114
+#define TX_HDCP_SHW_AINFO         TX_BASE_ADDR+0x115
+#define TX_HDCP_SHW_AN_0          TX_BASE_ADDR+0x118
+#define TX_HDCP_SHW_AN_1          TX_BASE_ADDR+0x119
+#define TX_HDCP_SHW_AN_2          TX_BASE_ADDR+0x11A
+#define TX_HDCP_SHW_AN_3          TX_BASE_ADDR+0x11B
+#define TX_HDCP_SHW_AN_4          TX_BASE_ADDR+0x11C
+#define TX_HDCP_SHW_AN_5          TX_BASE_ADDR+0x11D
+#define TX_HDCP_SHW_AN_6          TX_BASE_ADDR+0x11E
+#define TX_HDCP_SHW_AN_7          TX_BASE_ADDR+0x11F
+#define TX_HDCP_SHW_V1_H0_0       TX_BASE_ADDR+0x120
+#define TX_HDCP_SHW_V1_H0_1       TX_BASE_ADDR+0x121
+#define TX_HDCP_SHW_V1_H0_2       TX_BASE_ADDR+0x122
+#define TX_HDCP_SHW_V1_H0_3       TX_BASE_ADDR+0x123
+#define TX_HDCP_SHW_V1_H1_0       TX_BASE_ADDR+0x124
+#define TX_HDCP_SHW_V1_H1_1       TX_BASE_ADDR+0x125
+#define TX_HDCP_SHW_V1_H1_2       TX_BASE_ADDR+0x126
+#define TX_HDCP_SHW_V1_H1_3       TX_BASE_ADDR+0x127
+#define TX_HDCP_SHW_V1_H2_0       TX_BASE_ADDR+0x128
+#define TX_HDCP_SHW_V1_H2_1       TX_BASE_ADDR+0x129
+#define TX_HDCP_SHW_V1_H2_2       TX_BASE_ADDR+0x12A
+#define TX_HDCP_SHW_V1_H2_3       TX_BASE_ADDR+0x12B
+#define TX_HDCP_SHW_V1_H3_0       TX_BASE_ADDR+0x12C
+#define TX_HDCP_SHW_V1_H3_1       TX_BASE_ADDR+0x12D
+#define TX_HDCP_SHW_V1_H3_2       TX_BASE_ADDR+0x12E
+#define TX_HDCP_SHW_V1_H3_3       TX_BASE_ADDR+0x12F
+#define TX_HDCP_SHW_V1_H4_0       TX_BASE_ADDR+0x130
+#define TX_HDCP_SHW_V1_H4_1       TX_BASE_ADDR+0x131
+#define TX_HDCP_SHW_V1_H4_2       TX_BASE_ADDR+0x132
+#define TX_HDCP_SHW_V1_H4_3       TX_BASE_ADDR+0x133
+#define TX_HDCP_SHW_BCAPS         TX_BASE_ADDR+0x140
+#define TX_HDCP_SHW_BSTATUS_0     TX_BASE_ADDR+0x141
+#define TX_HDCP_SHW_BSTATUS_1     TX_BASE_ADDR+0x142
+#define TX_HDCP_SHW_KSV_FIFO      TX_BASE_ADDR+0x143
 
 // system status 0
-#define TX_SYSST0_CONNECT_FIFO    TX_BASE_ADDR+0x180 
-#define TX_SYSST0_PLL_MONITOR     TX_BASE_ADDR+0x181 
-#define TX_SYSST0_AFE_FIFO        TX_BASE_ADDR+0x182 
-#define TX_SYSST0_ROM_STATUS      TX_BASE_ADDR+0x18F 
+#define TX_SYSST0_CONNECT_FIFO    TX_BASE_ADDR+0x180
+#define TX_SYSST0_PLL_MONITOR     TX_BASE_ADDR+0x181
+#define TX_SYSST0_AFE_FIFO        TX_BASE_ADDR+0x182
+#define TX_SYSST0_ROM_STATUS      TX_BASE_ADDR+0x18F
 
 // system status 1
-#define TX_SYSST1_CALIB_BIT_RESULT_0     TX_BASE_ADDR+0x1E0 
-#define TX_SYSST1_CALIB_BIT_RESULT_1     TX_BASE_ADDR+0x1E1 
-#define TX_SYSST1_CALIB_BIT_RESULT_2     TX_BASE_ADDR+0x1E2 
-#define TX_SYSST1_CALIB_BIT_RESULT_3     TX_BASE_ADDR+0x1E3 
-#define TX_SYSST1_CALIB_BIT_RESULT_4     TX_BASE_ADDR+0x1E4 
-#define TX_SYSST1_CALIB_BIT_RESULT_5     TX_BASE_ADDR+0x1E5 
-#define TX_SYSST1_CALIB_BIT_RESULT_6     TX_BASE_ADDR+0x1E6 
-#define TX_SYSST1_CALIB_BIT_RESULT_7     TX_BASE_ADDR+0x1E7 
-#define TX_SYSST1_CALIB_BUS_RESULT_0     TX_BASE_ADDR+0x1E8 
-#define TX_SYSST1_CALIB_BUS_RESULT_1     TX_BASE_ADDR+0x1E9 
-#define TX_SYSST1_CALIB_BUS_RESULT_2     TX_BASE_ADDR+0x1EA 
-#define TX_SYSST1_CALIB_BUS_RESULT_3     TX_BASE_ADDR+0x1EB 
-#define TX_SYSST1_CALIB_BUS_RESULT_4     TX_BASE_ADDR+0x1EC 
-#define TX_SYSST1_CALIB_BUS_RESULT_5     TX_BASE_ADDR+0x1ED 
-#define TX_SYSST1_CALIB_BUS_RESULT_6     TX_BASE_ADDR+0x1EE 
-#define TX_SYSST1_CALIB_BUS_RESULT_7     TX_BASE_ADDR+0x1EF 
+#define TX_SYSST1_CALIB_BIT_RESULT_0     TX_BASE_ADDR+0x1E0
+#define TX_SYSST1_CALIB_BIT_RESULT_1     TX_BASE_ADDR+0x1E1
+#define TX_SYSST1_CALIB_BIT_RESULT_2     TX_BASE_ADDR+0x1E2
+#define TX_SYSST1_CALIB_BIT_RESULT_3     TX_BASE_ADDR+0x1E3
+#define TX_SYSST1_CALIB_BIT_RESULT_4     TX_BASE_ADDR+0x1E4
+#define TX_SYSST1_CALIB_BIT_RESULT_5     TX_BASE_ADDR+0x1E5
+#define TX_SYSST1_CALIB_BIT_RESULT_6     TX_BASE_ADDR+0x1E6
+#define TX_SYSST1_CALIB_BIT_RESULT_7     TX_BASE_ADDR+0x1E7
+#define TX_SYSST1_CALIB_BUS_RESULT_0     TX_BASE_ADDR+0x1E8
+#define TX_SYSST1_CALIB_BUS_RESULT_1     TX_BASE_ADDR+0x1E9
+#define TX_SYSST1_CALIB_BUS_RESULT_2     TX_BASE_ADDR+0x1EA
+#define TX_SYSST1_CALIB_BUS_RESULT_3     TX_BASE_ADDR+0x1EB
+#define TX_SYSST1_CALIB_BUS_RESULT_4     TX_BASE_ADDR+0x1EC
+#define TX_SYSST1_CALIB_BUS_RESULT_5     TX_BASE_ADDR+0x1ED
+#define TX_SYSST1_CALIB_BUS_RESULT_6     TX_BASE_ADDR+0x1EE
+#define TX_SYSST1_CALIB_BUS_RESULT_7     TX_BASE_ADDR+0x1EF
 
 // hdcp status
-#define TX_HDCP_ST_AUTHENTICATION        TX_BASE_ADDR+0x190 
-#define TX_HDCP_ST_FRAME_COUNT           TX_BASE_ADDR+0x191 
-#define TX_HDCP_ST_STATUS_0              TX_BASE_ADDR+0x192 
-#define TX_HDCP_ST_STATUS_1              TX_BASE_ADDR+0x193 
-#define TX_HDCP_ST_STATUS_2              TX_BASE_ADDR+0x194 
-#define TX_HDCP_ST_STATUS_3              TX_BASE_ADDR+0x195 
-#define TX_HDCP_ST_EDID_STATUS           TX_BASE_ADDR+0x196 
-#define TX_HDCP_ST_MEM_STATUS            TX_BASE_ADDR+0x197 
-#define TX_HDCP_ST_ST_MODE               TX_BASE_ADDR+0x19F 
+#define TX_HDCP_ST_AUTHENTICATION        TX_BASE_ADDR+0x190
+#define TX_HDCP_ST_FRAME_COUNT           TX_BASE_ADDR+0x191
+#define TX_HDCP_ST_STATUS_0              TX_BASE_ADDR+0x192
+#define TX_HDCP_ST_STATUS_1              TX_BASE_ADDR+0x193
+#define TX_HDCP_ST_STATUS_2              TX_BASE_ADDR+0x194
+#define TX_HDCP_ST_STATUS_3              TX_BASE_ADDR+0x195
+#define TX_HDCP_ST_EDID_STATUS           TX_BASE_ADDR+0x196
+#define TX_HDCP_ST_MEM_STATUS            TX_BASE_ADDR+0x197
+#define TX_HDCP_ST_ST_MODE               TX_BASE_ADDR+0x19F
 
 // video status
-#define TX_VIDEO_ST_ACTIVE_PIXELS_1      TX_BASE_ADDR+0x1A0 
-#define TX_VIDEO_ST_ACTIVE_PIXELS_2      TX_BASE_ADDR+0x1A1 
-#define TX_VIDEO_ST_FRONT_PIXELS         TX_BASE_ADDR+0x1A2 
-#define TX_VIDEO_ST_HSYNC_PIXELS         TX_BASE_ADDR+0x1A3 
-#define TX_VIDEO_ST_BACK_PIXELS          TX_BASE_ADDR+0x1A4 
-#define TX_VIDEO_ST_ACTIVE_LINES_1       TX_BASE_ADDR+0x1A5 
-#define TX_VIDEO_ST_ACTIVE_LINES_2       TX_BASE_ADDR+0x1A6 
-#define TX_VIDEO_ST_EOF_LINES            TX_BASE_ADDR+0x1A7 
-#define TX_VIDEO_ST_VSYNC_LINES          TX_BASE_ADDR+0x1A8 
-#define TX_VIDEO_ST_SOF_LINES            TX_BASE_ADDR+0x1A9 
-#define TX_VIDEO_ST_DTV_TIMING           TX_BASE_ADDR+0x1AA 
-#define TX_VIDEO_ST_DTV_MODE             TX_BASE_ADDR+0x1AB 
+#define TX_VIDEO_ST_ACTIVE_PIXELS_1      TX_BASE_ADDR+0x1A0
+#define TX_VIDEO_ST_ACTIVE_PIXELS_2      TX_BASE_ADDR+0x1A1
+#define TX_VIDEO_ST_FRONT_PIXELS         TX_BASE_ADDR+0x1A2
+#define TX_VIDEO_ST_HSYNC_PIXELS         TX_BASE_ADDR+0x1A3
+#define TX_VIDEO_ST_BACK_PIXELS          TX_BASE_ADDR+0x1A4
+#define TX_VIDEO_ST_ACTIVE_LINES_1       TX_BASE_ADDR+0x1A5
+#define TX_VIDEO_ST_ACTIVE_LINES_2       TX_BASE_ADDR+0x1A6
+#define TX_VIDEO_ST_EOF_LINES            TX_BASE_ADDR+0x1A7
+#define TX_VIDEO_ST_VSYNC_LINES          TX_BASE_ADDR+0x1A8
+#define TX_VIDEO_ST_SOF_LINES            TX_BASE_ADDR+0x1A9
+#define TX_VIDEO_ST_DTV_TIMING           TX_BASE_ADDR+0x1AA
+#define TX_VIDEO_ST_DTV_MODE             TX_BASE_ADDR+0x1AB
 // audio status
-#define TX_VIDEO_ST_AUDIO_STATUS         TX_BASE_ADDR+0x1AC 
-#define TX_AFE_STATUS_0                  TX_BASE_ADDR+0x1AE 
-#define TX_AFE_STATUS_1                  TX_BASE_ADDR+0x1AF 
+#define TX_VIDEO_ST_AUDIO_STATUS         TX_BASE_ADDR+0x1AC
+#define TX_AFE_STATUS_0                  TX_BASE_ADDR+0x1AE
+#define TX_AFE_STATUS_1                  TX_BASE_ADDR+0x1AF
 
 // Packet status
-#define TX_PACKET_ST_REQUEST_STATUS_1    TX_BASE_ADDR+0x1F0 
-#define TX_PACKET_ST_REQUEST_STATUS_2    TX_BASE_ADDR+0x1F1 
-#define TX_PACKET_ST_REQUEST_MISSED_1    TX_BASE_ADDR+0x1F2 
-#define TX_PACKET_ST_REQUEST_MISSED_2    TX_BASE_ADDR+0x1F3 
-#define TX_PACKET_ST_ENCODE_STATUS_0     TX_BASE_ADDR+0x1F4 
-#define TX_PACKET_ST_ENCODE_STATUS_1     TX_BASE_ADDR+0x1F5 
-#define TX_PACKET_ST_ENCODE_STATUS_2     TX_BASE_ADDR+0x1F6 
-#define TX_PACKET_ST_TIMER_STATUS        TX_BASE_ADDR+0x1F7 
+#define TX_PACKET_ST_REQUEST_STATUS_1    TX_BASE_ADDR+0x1F0
+#define TX_PACKET_ST_REQUEST_STATUS_2    TX_BASE_ADDR+0x1F1
+#define TX_PACKET_ST_REQUEST_MISSED_1    TX_BASE_ADDR+0x1F2
+#define TX_PACKET_ST_REQUEST_MISSED_2    TX_BASE_ADDR+0x1F3
+#define TX_PACKET_ST_ENCODE_STATUS_0     TX_BASE_ADDR+0x1F4
+#define TX_PACKET_ST_ENCODE_STATUS_1     TX_BASE_ADDR+0x1F5
+#define TX_PACKET_ST_ENCODE_STATUS_2     TX_BASE_ADDR+0x1F6
+#define TX_PACKET_ST_TIMER_STATUS        TX_BASE_ADDR+0x1F7
 
 // tmds status
-#define TX_TMDS_ST_CLOCK_METER_1         TX_BASE_ADDR+0x1F8 
-#define TX_TMDS_ST_CLOCK_METER_2         TX_BASE_ADDR+0x1F9 
-#define TX_TMDS_ST_CLOCK_METER_3         TX_BASE_ADDR+0x1FA 
-#define TX_TMDS_ST_TMDS_STATUS_1         TX_BASE_ADDR+0x1FC 
-#define TX_TMDS_ST_TMDS_STATUS_2         TX_BASE_ADDR+0x1FD 
-#define TX_TMDS_ST_TMDS_STATUS_3         TX_BASE_ADDR+0x1FE 
-#define TX_TMDS_ST_TMDS_STATUS_4         TX_BASE_ADDR+0x1FF 
+#define TX_TMDS_ST_CLOCK_METER_1         TX_BASE_ADDR+0x1F8
+#define TX_TMDS_ST_CLOCK_METER_2         TX_BASE_ADDR+0x1F9
+#define TX_TMDS_ST_CLOCK_METER_3         TX_BASE_ADDR+0x1FA
+#define TX_TMDS_ST_TMDS_STATUS_1         TX_BASE_ADDR+0x1FC
+#define TX_TMDS_ST_TMDS_STATUS_2         TX_BASE_ADDR+0x1FD
+#define TX_TMDS_ST_TMDS_STATUS_3         TX_BASE_ADDR+0x1FE
+#define TX_TMDS_ST_TMDS_STATUS_4         TX_BASE_ADDR+0x1FF
 
 
 // Packet register
-#define TX_PKT_REG_SPD_INFO_BASE_ADDR     TX_BASE_ADDR+0x200 
-#define TX_PKT_REG_VEND_INFO_BASE_ADDR    TX_BASE_ADDR+0x220 
-#define TX_PKT_REG_MPEG_INFO_BASE_ADDR    TX_BASE_ADDR+0x240 
-#define TX_PKT_REG_AVI_INFO_BASE_ADDR     TX_BASE_ADDR+0x260 
-#define TX_PKT_REG_AUDIO_INFO_BASE_ADDR   TX_BASE_ADDR+0x280 
-#define TX_PKT_REG_ACP_INFO_BASE_ADDR     TX_BASE_ADDR+0x2A0 
-#define TX_PKT_REG_ISRC1_BASE_ADDR        TX_BASE_ADDR+0x2C0 
-#define TX_PKT_REG_ISRC2_BASE_ADDR        TX_BASE_ADDR+0x2E0 
-#define TX_PKT_REG_EXCEPT0_BASE_ADDR      TX_BASE_ADDR+0x300 
-#define TX_PKT_REG_EXCEPT1_BASE_ADDR      TX_BASE_ADDR+0x320 
-#define TX_PKT_REG_EXCEPT2_BASE_ADDR      TX_BASE_ADDR+0x340 
-#define TX_PKT_REG_EXCEPT3_BASE_ADDR      TX_BASE_ADDR+0x360 
-#define TX_PKT_REG_EXCEPT4_BASE_ADDR      TX_BASE_ADDR+0x380 
-#define TX_PKT_REG_GAMUT_P0_BASE_ADDR     TX_BASE_ADDR+0x3A0 
-#define TX_PKT_REG_GAMUT_P1_1_BASE_ADDR   TX_BASE_ADDR+0x3C0 
-#define TX_PKT_REG_GAMUT_P1_2_BASE_ADDR   TX_BASE_ADDR+0x3E0 
+#define TX_PKT_REG_SPD_INFO_BASE_ADDR     TX_BASE_ADDR+0x200
+#define TX_PKT_REG_VEND_INFO_BASE_ADDR    TX_BASE_ADDR+0x220
+#define TX_PKT_REG_MPEG_INFO_BASE_ADDR    TX_BASE_ADDR+0x240
+#define TX_PKT_REG_AVI_INFO_BASE_ADDR     TX_BASE_ADDR+0x260
+#define TX_PKT_REG_AUDIO_INFO_BASE_ADDR   TX_BASE_ADDR+0x280
+#define TX_PKT_REG_ACP_INFO_BASE_ADDR     TX_BASE_ADDR+0x2A0
+#define TX_PKT_REG_ISRC1_BASE_ADDR        TX_BASE_ADDR+0x2C0
+#define TX_PKT_REG_ISRC2_BASE_ADDR        TX_BASE_ADDR+0x2E0
+#define TX_PKT_REG_EXCEPT0_BASE_ADDR      TX_BASE_ADDR+0x300
+#define TX_PKT_REG_EXCEPT1_BASE_ADDR      TX_BASE_ADDR+0x320
+#define TX_PKT_REG_EXCEPT2_BASE_ADDR      TX_BASE_ADDR+0x340
+#define TX_PKT_REG_EXCEPT3_BASE_ADDR      TX_BASE_ADDR+0x360
+#define TX_PKT_REG_EXCEPT4_BASE_ADDR      TX_BASE_ADDR+0x380
+#define TX_PKT_REG_GAMUT_P0_BASE_ADDR     TX_BASE_ADDR+0x3A0
+#define TX_PKT_REG_GAMUT_P1_1_BASE_ADDR   TX_BASE_ADDR+0x3C0
+#define TX_PKT_REG_GAMUT_P1_2_BASE_ADDR   TX_BASE_ADDR+0x3E0
 
 
 
 
 
 //************ RX related ************//
-#define RX_HDCP_DKEY_OFFSET             RX_BASE_ADDR+0x400 
-#define RX_EDID_OFFSET                  RX_BASE_ADDR+0x600 
+#define RX_HDCP_DKEY_OFFSET             RX_BASE_ADDR+0x400
+#define RX_EDID_OFFSET                  RX_BASE_ADDR+0x600
 
-#define RX_IEC60958_SUB1_OFFSET         RX_BASE_ADDR+0x0B0 
-#define RX_IEC60958_SUB2_OFFSET         RX_BASE_ADDR+0x0C8 
+#define RX_IEC60958_SUB1_OFFSET         RX_BASE_ADDR+0x0B0
+#define RX_IEC60958_SUB2_OFFSET         RX_BASE_ADDR+0x0C8
 
-#define RX_IEC60958_ST_SUB1_OFFSET      RX_BASE_ADDR+0x1B0 
-#define RX_IEC60958_ST_SUB2_OFFSET      RX_BASE_ADDR+0x1C8 
+#define RX_IEC60958_ST_SUB1_OFFSET      RX_BASE_ADDR+0x1B0
+#define RX_IEC60958_ST_SUB2_OFFSET      RX_BASE_ADDR+0x1C8
 
 
 // System config 0
-#define RX_SYS0_CDR_0_1_BYPASS          RX_BASE_ADDR+0x006 
-#define RX_SYS0_CDR_2_3_BYPASS          RX_BASE_ADDR+0x007 
-#define RX_SYS0_EQ_MASK_CH0_0           RX_BASE_ADDR+0x008 
-#define RX_SYS0_EQ_MASK_CH0_1           RX_BASE_ADDR+0x009 
-#define RX_SYS0_EQ_MASK_CH1_0           RX_BASE_ADDR+0x00A 
-#define RX_SYS0_EQ_MASK_CH1_1           RX_BASE_ADDR+0x00B 
-#define RX_SYS0_EQ_MASK_CH2_0           RX_BASE_ADDR+0x00C 
-#define RX_SYS0_EQ_MASK_CH2_1           RX_BASE_ADDR+0x00D 
-#define RX_SYS0_EQ_MASK_CH3_0           RX_BASE_ADDR+0x00E 
-#define RX_SYS0_EQ_MASK_CH3_1           RX_BASE_ADDR+0x00F 
+#define RX_SYS0_CDR_0_1_BYPASS          RX_BASE_ADDR+0x006
+#define RX_SYS0_CDR_2_3_BYPASS          RX_BASE_ADDR+0x007
+#define RX_SYS0_EQ_MASK_CH0_0           RX_BASE_ADDR+0x008
+#define RX_SYS0_EQ_MASK_CH0_1           RX_BASE_ADDR+0x009
+#define RX_SYS0_EQ_MASK_CH1_0           RX_BASE_ADDR+0x00A
+#define RX_SYS0_EQ_MASK_CH1_1           RX_BASE_ADDR+0x00B
+#define RX_SYS0_EQ_MASK_CH2_0           RX_BASE_ADDR+0x00C
+#define RX_SYS0_EQ_MASK_CH2_1           RX_BASE_ADDR+0x00D
+#define RX_SYS0_EQ_MASK_CH3_0           RX_BASE_ADDR+0x00E
+#define RX_SYS0_EQ_MASK_CH3_1           RX_BASE_ADDR+0x00F
 // System config 1
-#define RX_SYS1_CLOCK_CONTROL_M_EXP_0   RX_BASE_ADDR+0x010 
-#define RX_SYS1_CLOCK_CONTROL_M_EXP_1   RX_BASE_ADDR+0x011 
-#define RX_SYS1_CLOCK_CONTROL_M_EXP_2   RX_BASE_ADDR+0x012 
-#define RX_SYS1_CLOCK_CONTROL_N_EXP_0   RX_BASE_ADDR+0x013 
-#define RX_SYS1_CLOCK_CONTROL_N_EXP_1   RX_BASE_ADDR+0x014 
-#define RX_SYS1_CLOCK_CONTROL_N_EXP_2   RX_BASE_ADDR+0x015 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_0   RX_BASE_ADDR+0x016 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_1   RX_BASE_ADDR+0x017 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_2   RX_BASE_ADDR+0x018 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_3   RX_BASE_ADDR+0x019 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_4   RX_BASE_ADDR+0x01A 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_5   RX_BASE_ADDR+0x01B 
-#define RX_SYS1_CLOCK_CONTROL_K1_IN_6   RX_BASE_ADDR+0x01C 
-#define RX_SYS1_CLOCK_CONTROL_TIMER_0   RX_BASE_ADDR+0x01D 
-#define RX_SYS1_CLOCK_CONTROL_TIMER_1   RX_BASE_ADDR+0x01E 
-#define RX_SYS1_CLOCK_CONTROL_FSM       RX_BASE_ADDR+0x01F 
+#define RX_SYS1_CLOCK_CONTROL_M_EXP_0   RX_BASE_ADDR+0x010
+#define RX_SYS1_CLOCK_CONTROL_M_EXP_1   RX_BASE_ADDR+0x011
+#define RX_SYS1_CLOCK_CONTROL_M_EXP_2   RX_BASE_ADDR+0x012
+#define RX_SYS1_CLOCK_CONTROL_N_EXP_0   RX_BASE_ADDR+0x013
+#define RX_SYS1_CLOCK_CONTROL_N_EXP_1   RX_BASE_ADDR+0x014
+#define RX_SYS1_CLOCK_CONTROL_N_EXP_2   RX_BASE_ADDR+0x015
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_0   RX_BASE_ADDR+0x016
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_1   RX_BASE_ADDR+0x017
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_2   RX_BASE_ADDR+0x018
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_3   RX_BASE_ADDR+0x019
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_4   RX_BASE_ADDR+0x01A
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_5   RX_BASE_ADDR+0x01B
+#define RX_SYS1_CLOCK_CONTROL_K1_IN_6   RX_BASE_ADDR+0x01C
+#define RX_SYS1_CLOCK_CONTROL_TIMER_0   RX_BASE_ADDR+0x01D
+#define RX_SYS1_CLOCK_CONTROL_TIMER_1   RX_BASE_ADDR+0x01E
+#define RX_SYS1_CLOCK_CONTROL_FSM       RX_BASE_ADDR+0x01F
 // system config 2
-#define RX_SYS2_CDR0_BYPASS_CNTRL       RX_BASE_ADDR+0x080 
-#define RX_SYS2_CDR0_EN_CNTRL           RX_BASE_ADDR+0x081 
-#define RX_SYS2_CDR1_BYPASS_CNTRL       RX_BASE_ADDR+0x082 
-#define RX_SYS2_CDR1_EN_CNTRL           RX_BASE_ADDR+0x083 
-#define RX_SYS2_CDR2_BYPASS_CNTRL       RX_BASE_ADDR+0x084 
-#define RX_SYS2_CDR2_EN_CNTRL           RX_BASE_ADDR+0x085 
-#define RX_SYS2_CDR3_BYPASS_CNTRL       RX_BASE_ADDR+0x086 
-#define RX_SYS2_CDR3_EN_CNTRL           RX_BASE_ADDR+0x087 
-#define RX_SYS2_PRBS0_CNTRL             RX_BASE_ADDR+0x088 
-#define RX_SYS2_PRBS1_CNTRL             RX_BASE_ADDR+0x089 
-#define RX_SYS2_PRBS2_CNTRL             RX_BASE_ADDR+0x08A 
-#define RX_SYS2_PRBS3_CNTRL             RX_BASE_ADDR+0x08B 
-#define RX_SYS2_PRBS_ERR_THR            RX_BASE_ADDR+0x08C 
-#define RX_SYS2_PRBS_TIME_WINDOW0       RX_BASE_ADDR+0x08D 
-#define RX_SYS2_PRBS_TIME_WINDOW1       RX_BASE_ADDR+0x08E 
+#define RX_SYS2_CDR0_BYPASS_CNTRL       RX_BASE_ADDR+0x080
+#define RX_SYS2_CDR0_EN_CNTRL           RX_BASE_ADDR+0x081
+#define RX_SYS2_CDR1_BYPASS_CNTRL       RX_BASE_ADDR+0x082
+#define RX_SYS2_CDR1_EN_CNTRL           RX_BASE_ADDR+0x083
+#define RX_SYS2_CDR2_BYPASS_CNTRL       RX_BASE_ADDR+0x084
+#define RX_SYS2_CDR2_EN_CNTRL           RX_BASE_ADDR+0x085
+#define RX_SYS2_CDR3_BYPASS_CNTRL       RX_BASE_ADDR+0x086
+#define RX_SYS2_CDR3_EN_CNTRL           RX_BASE_ADDR+0x087
+#define RX_SYS2_PRBS0_CNTRL             RX_BASE_ADDR+0x088
+#define RX_SYS2_PRBS1_CNTRL             RX_BASE_ADDR+0x089
+#define RX_SYS2_PRBS2_CNTRL             RX_BASE_ADDR+0x08A
+#define RX_SYS2_PRBS3_CNTRL             RX_BASE_ADDR+0x08B
+#define RX_SYS2_PRBS_ERR_THR            RX_BASE_ADDR+0x08C
+#define RX_SYS2_PRBS_TIME_WINDOW0       RX_BASE_ADDR+0x08D
+#define RX_SYS2_PRBS_TIME_WINDOW1       RX_BASE_ADDR+0x08E
 // system config 3
-#define RX_SYS3_RX_ACR_0                RX_BASE_ADDR+0x09C 
+#define RX_SYS3_RX_ACR_0                RX_BASE_ADDR+0x09C
 #define RX_SYS3_RX_ACR_1                RX_BASE_ADDR+0x09D
 // system config 4
-#define RX_SYS4_OSC_EXT_CLK_CNTL_0      RX_BASE_ADDR+0x0AD 
-#define RX_SYS4_OSC_EXT_CLK_CNTL_1      RX_BASE_ADDR+0x0AE 
+#define RX_SYS4_OSC_EXT_CLK_CNTL_0      RX_BASE_ADDR+0x0AD
+#define RX_SYS4_OSC_EXT_CLK_CNTL_1      RX_BASE_ADDR+0x0AE
 
 // HDCP CONFIG
-#define RX_HDCP_I2C_MASTER_CONFIG_0     RX_BASE_ADDR+0x020 
-#define RX_HDCP_I2C_MASTER_CONFIG_1     RX_BASE_ADDR+0x021 
-#define RX_HDCP_I2C_MASTER_CONFIG_2     RX_BASE_ADDR+0x022 
-#define RX_HDCP_ECC_CONFIG              RX_BASE_ADDR+0x024 
-#define RX_HDCP_CRC_CONFIG              RX_BASE_ADDR+0x025 
-#define RX_HDCP_EDID_CONFIG             RX_BASE_ADDR+0x026 
-#define RX_HDCP_MEM_CONFIG              RX_BASE_ADDR+0x027 
-#define RX_HDCP_HPD_FILTER_L            RX_BASE_ADDR+0x028 
-#define RX_HDCP_HPD_FILTER_H            RX_BASE_ADDR+0x029 
-#define RX_HDCP_BCAPS                   RX_BASE_ADDR+0x02A 
-#define RX_HDCP_CONFIG0                 RX_BASE_ADDR+0x02B 
-#define RX_HDCP_CONFIG1                 RX_BASE_ADDR+0x02C 
-#define RX_HDCP_CONFIG2                 RX_BASE_ADDR+0x02D 
-#define RX_HDCP_CONFIG3                 RX_BASE_ADDR+0x02E 
-#define RX_HDCP_MODE                    RX_BASE_ADDR+0x02F 
+#define RX_HDCP_I2C_MASTER_CONFIG_0     RX_BASE_ADDR+0x020
+#define RX_HDCP_I2C_MASTER_CONFIG_1     RX_BASE_ADDR+0x021
+#define RX_HDCP_I2C_MASTER_CONFIG_2     RX_BASE_ADDR+0x022
+#define RX_HDCP_ECC_CONFIG              RX_BASE_ADDR+0x024
+#define RX_HDCP_CRC_CONFIG              RX_BASE_ADDR+0x025
+#define RX_HDCP_EDID_CONFIG             RX_BASE_ADDR+0x026
+#define RX_HDCP_MEM_CONFIG              RX_BASE_ADDR+0x027
+#define RX_HDCP_HPD_FILTER_L            RX_BASE_ADDR+0x028
+#define RX_HDCP_HPD_FILTER_H            RX_BASE_ADDR+0x029
+#define RX_HDCP_BCAPS                   RX_BASE_ADDR+0x02A
+#define RX_HDCP_CONFIG0                 RX_BASE_ADDR+0x02B
+#define RX_HDCP_CONFIG1                 RX_BASE_ADDR+0x02C
+#define RX_HDCP_CONFIG2                 RX_BASE_ADDR+0x02D
+#define RX_HDCP_CONFIG3                 RX_BASE_ADDR+0x02E
+#define RX_HDCP_MODE                    RX_BASE_ADDR+0x02F
 
 // Video config, part 1
-#define RX_VIDEO_ACTIVE_PIXELS_0        RX_BASE_ADDR+0x030 
-#define RX_VIDEO_ACTIVE_PIXELS_1        RX_BASE_ADDR+0x031 
-#define RX_VIDEO_FRONT_PIXELS           RX_BASE_ADDR+0x032 
-#define RX_VIDEO_HSYNC_PIXELS           RX_BASE_ADDR+0x033 
-#define RX_VIDEO_BACK_PIXELS            RX_BASE_ADDR+0x034 
-#define RX_VIDEO_ACTIVE_LINES_0         RX_BASE_ADDR+0x035 
-#define RX_VIDEO_ACTIVE_LINES_1         RX_BASE_ADDR+0x036 
-#define RX_VIDEO_EOF_LINES              RX_BASE_ADDR+0x037 
-#define RX_VIDEO_VSYNC_LINES            RX_BASE_ADDR+0x038 
-#define RX_VIDEO_SOF_LINES              RX_BASE_ADDR+0x039 
-#define RX_VIDEO_DTV_TIMING             RX_BASE_ADDR+0x03A 
-#define RX_VIDEO_DTV_MODE               RX_BASE_ADDR+0x03B 
-#define RX_VIDEO_DTV_FORMAT0            RX_BASE_ADDR+0x03C 
-#define RX_VIDEO_DTV_FORMAT1            RX_BASE_ADDR+0x03D 
-#define RX_VIDEO_PIXEL_PACK             RX_BASE_ADDR+0x03F 
+#define RX_VIDEO_ACTIVE_PIXELS_0        RX_BASE_ADDR+0x030
+#define RX_VIDEO_ACTIVE_PIXELS_1        RX_BASE_ADDR+0x031
+#define RX_VIDEO_FRONT_PIXELS           RX_BASE_ADDR+0x032
+#define RX_VIDEO_HSYNC_PIXELS           RX_BASE_ADDR+0x033
+#define RX_VIDEO_BACK_PIXELS            RX_BASE_ADDR+0x034
+#define RX_VIDEO_ACTIVE_LINES_0         RX_BASE_ADDR+0x035
+#define RX_VIDEO_ACTIVE_LINES_1         RX_BASE_ADDR+0x036
+#define RX_VIDEO_EOF_LINES              RX_BASE_ADDR+0x037
+#define RX_VIDEO_VSYNC_LINES            RX_BASE_ADDR+0x038
+#define RX_VIDEO_SOF_LINES              RX_BASE_ADDR+0x039
+#define RX_VIDEO_DTV_TIMING             RX_BASE_ADDR+0x03A
+#define RX_VIDEO_DTV_MODE               RX_BASE_ADDR+0x03B
+#define RX_VIDEO_DTV_FORMAT0            RX_BASE_ADDR+0x03C
+#define RX_VIDEO_DTV_FORMAT1            RX_BASE_ADDR+0x03D
+#define RX_VIDEO_PIXEL_PACK             RX_BASE_ADDR+0x03F
 // video config, part 2
-#define RX_VIDEO_CSC_COEFF_B0           RX_BASE_ADDR+0x040 
-#define RX_VIDEO_CSC_COEFF_B1           RX_BASE_ADDR+0x041 
-#define RX_VIDEO_CSC_COEFF_R0           RX_BASE_ADDR+0x042 
-#define RX_VIDEO_CSC_COEFF_R1           RX_BASE_ADDR+0x043 
-#define RX_VIDEO_CSC_COEFF_CB0          RX_BASE_ADDR+0x044 
-#define RX_VIDEO_CSC_COEFF_CB1          RX_BASE_ADDR+0x045 
-#define RX_VIDEO_CSC_COEFF_CR0          RX_BASE_ADDR+0x046 
-#define RX_VIDEO_CSC_COEFF_CR1          RX_BASE_ADDR+0x047 
-#define RX_VIDEO_DTV_OPTION_L           RX_BASE_ADDR+0x048 
-#define RX_VIDEO_DTV_OPTION_H           RX_BASE_ADDR+0x049 
-#define RX_VIDEO_DTV_FILTER             RX_BASE_ADDR+0x04A 
-#define RX_VIDEO_DTV_DITHER             RX_BASE_ADDR+0x04B 
-#define RX_VIDEO_PROC_CONFIG0           RX_BASE_ADDR+0x04E 
-#define RX_VIDEO_PROC_CONFIG1           RX_BASE_ADDR+0x04F 
+#define RX_VIDEO_CSC_COEFF_B0           RX_BASE_ADDR+0x040
+#define RX_VIDEO_CSC_COEFF_B1           RX_BASE_ADDR+0x041
+#define RX_VIDEO_CSC_COEFF_R0           RX_BASE_ADDR+0x042
+#define RX_VIDEO_CSC_COEFF_R1           RX_BASE_ADDR+0x043
+#define RX_VIDEO_CSC_COEFF_CB0          RX_BASE_ADDR+0x044
+#define RX_VIDEO_CSC_COEFF_CB1          RX_BASE_ADDR+0x045
+#define RX_VIDEO_CSC_COEFF_CR0          RX_BASE_ADDR+0x046
+#define RX_VIDEO_CSC_COEFF_CR1          RX_BASE_ADDR+0x047
+#define RX_VIDEO_DTV_OPTION_L           RX_BASE_ADDR+0x048
+#define RX_VIDEO_DTV_OPTION_H           RX_BASE_ADDR+0x049
+#define RX_VIDEO_DTV_FILTER             RX_BASE_ADDR+0x04A
+#define RX_VIDEO_DTV_DITHER             RX_BASE_ADDR+0x04B
+#define RX_VIDEO_PROC_CONFIG0           RX_BASE_ADDR+0x04E
+#define RX_VIDEO_PROC_CONFIG1           RX_BASE_ADDR+0x04F
 
 // Reserved config
-#define RX_AUDIO_EQ_INDEX_CH3           RX_BASE_ADDR+0x056 
-#define RX_AUDIO_EQ_CNTRL_CH3           RX_BASE_ADDR+0x057 
+#define RX_AUDIO_EQ_INDEX_CH3           RX_BASE_ADDR+0x056
+#define RX_AUDIO_EQ_CNTRL_CH3           RX_BASE_ADDR+0x057
 // VIC and color depth control and interrupts
-#define RX_VIC_COLOR_DEPTH              RX_BASE_ADDR+0x063 
+#define RX_VIC_COLOR_DEPTH              RX_BASE_ADDR+0x063
 // Audio config
-#define RX_AUDIO_FORMAT                 RX_BASE_ADDR+0x058 
-#define RX_AUDIO_SPDIF                  RX_BASE_ADDR+0x059 
-#define RX_AUDIO_I2S                    RX_BASE_ADDR+0x05A 
-#define RX_AUDIO_FIFO                   RX_BASE_ADDR+0x05B 
-#define RX_AUDIO_SOFT_MUTE              RX_BASE_ADDR+0x05C 
-#define RX_AUDIO_CONTROL                RX_BASE_ADDR+0x05D 
-#define RX_AUDIO_RSV1                   RX_BASE_ADDR+0x05E 
-#define RX_AUDIO_SAMPLE                 RX_BASE_ADDR+0x05F 
-#define RX_AUDIO_RSV2                   RX_BASE_ADDR+0x060 
+#define RX_AUDIO_FORMAT                 RX_BASE_ADDR+0x058
+#define RX_AUDIO_SPDIF                  RX_BASE_ADDR+0x059
+#define RX_AUDIO_I2S                    RX_BASE_ADDR+0x05A
+#define RX_AUDIO_FIFO                   RX_BASE_ADDR+0x05B
+#define RX_AUDIO_SOFT_MUTE              RX_BASE_ADDR+0x05C
+#define RX_AUDIO_CONTROL                RX_BASE_ADDR+0x05D
+#define RX_AUDIO_RSV1                   RX_BASE_ADDR+0x05E
+#define RX_AUDIO_SAMPLE                 RX_BASE_ADDR+0x05F
+#define RX_AUDIO_RSV2                   RX_BASE_ADDR+0x060
 // tmds config
-#define RX_TMDS_MODE                    RX_BASE_ADDR+0x07E 
-#define RX_TMDS_PACKET_CONTROL          RX_BASE_ADDR+0x07F 
+#define RX_TMDS_MODE                    RX_BASE_ADDR+0x07E
+#define RX_TMDS_PACKET_CONTROL          RX_BASE_ADDR+0x07F
 
 // core config
-#define RX_CORE_DATA_CAPTURE_1          RX_BASE_ADDR+0x0F0 
-#define RX_CORE_DATA_CAPTURE_2          RX_BASE_ADDR+0x0F1 
-#define RX_CORE_DATA_MONITOR_1          RX_BASE_ADDR+0x0F2 
-#define RX_CORE_DATA_MONITOR_2          RX_BASE_ADDR+0x0F3 
-#define RX_CORE_CALIB_MODE              RX_BASE_ADDR+0x0F4 
-#define RX_CORE_WAIT_START              RX_BASE_ADDR+0x0F5 
-#define RX_CORE_WAIT_NEXT               RX_BASE_ADDR+0x0F6 
-#define RX_CORE_CALIB_VALUE             RX_BASE_ADDR+0x0F7 
-#define RX_CORE_INTERRUPT_CLEAR_0       RX_BASE_ADDR+0x0F8 
-#define RX_CORE_INTERRUPT_CLEAR_1       RX_BASE_ADDR+0x0F9 
-#define RX_CORE_INTERRUPT_CLEAR_2       RX_BASE_ADDR+0x0FA 
-#define RX_CORE_EQ_INDEX_CH0            RX_BASE_ADDR+0x0FB 
-#define RX_CORE_EQ_INDEX_CH1            RX_BASE_ADDR+0x0FC 
-#define RX_CORE_EQ_INDEX_CH2            RX_BASE_ADDR+0x0FD 
-#define RX_CORE_EQ_CNTRL_0              RX_BASE_ADDR+0x0FE 
-#define RX_CORE_EQ_CNTRL_1              RX_BASE_ADDR+0x0FF 
+#define RX_CORE_DATA_CAPTURE_1          RX_BASE_ADDR+0x0F0
+#define RX_CORE_DATA_CAPTURE_2          RX_BASE_ADDR+0x0F1
+#define RX_CORE_DATA_MONITOR_1          RX_BASE_ADDR+0x0F2
+#define RX_CORE_DATA_MONITOR_2          RX_BASE_ADDR+0x0F3
+#define RX_CORE_CALIB_MODE              RX_BASE_ADDR+0x0F4
+#define RX_CORE_WAIT_START              RX_BASE_ADDR+0x0F5
+#define RX_CORE_WAIT_NEXT               RX_BASE_ADDR+0x0F6
+#define RX_CORE_CALIB_VALUE             RX_BASE_ADDR+0x0F7
+#define RX_CORE_INTERRUPT_CLEAR_0       RX_BASE_ADDR+0x0F8
+#define RX_CORE_INTERRUPT_CLEAR_1       RX_BASE_ADDR+0x0F9
+#define RX_CORE_INTERRUPT_CLEAR_2       RX_BASE_ADDR+0x0FA
+#define RX_CORE_EQ_INDEX_CH0            RX_BASE_ADDR+0x0FB
+#define RX_CORE_EQ_INDEX_CH1            RX_BASE_ADDR+0x0FC
+#define RX_CORE_EQ_INDEX_CH2            RX_BASE_ADDR+0x0FD
+#define RX_CORE_EQ_CNTRL_0              RX_BASE_ADDR+0x0FE
+#define RX_CORE_EQ_CNTRL_1              RX_BASE_ADDR+0x0FF
 // HDCP shadow register
-#define RX_HDCP_SHW_BKSV_0              RX_BASE_ADDR+0x100 
-#define RX_HDCP_SHW_BKSV_1              RX_BASE_ADDR+0x101 
-#define RX_HDCP_SHW_BKSV_2              RX_BASE_ADDR+0x102 
-#define RX_HDCP_SHW_BKSV_3              RX_BASE_ADDR+0x103 
-#define RX_HDCP_SHW_BKSV_4              RX_BASE_ADDR+0x104 
-#define RX_HDCP_SHW_RI1_0               RX_BASE_ADDR+0x108 
-#define RX_HDCP_SHW_RI1_1               RX_BASE_ADDR+0x109 
-#define RX_HDCP_SHW_PJ1                 RX_BASE_ADDR+0x10A 
-#define RX_HDCP_SHW_AKSV_0              RX_BASE_ADDR+0x110 
-#define RX_HDCP_SHW_AKSV_1              RX_BASE_ADDR+0x111 
-#define RX_HDCP_SHW_AKSV_2              RX_BASE_ADDR+0x112 
-#define RX_HDCP_SHW_AKSV_3              RX_BASE_ADDR+0x113 
-#define RX_HDCP_SHW_AKSV_4              RX_BASE_ADDR+0x114 
-#define RX_HDCP_SHW_AINFO               RX_BASE_ADDR+0x115 
-#define RX_HDCP_SHW_AN_0                RX_BASE_ADDR+0x118 
-#define RX_HDCP_SHW_AN_1                RX_BASE_ADDR+0x119 
-#define RX_HDCP_SHW_AN_2                RX_BASE_ADDR+0x11A 
-#define RX_HDCP_SHW_AN_3                RX_BASE_ADDR+0x11B 
-#define RX_HDCP_SHW_AN_4                RX_BASE_ADDR+0x11C 
-#define RX_HDCP_SHW_AN_5                RX_BASE_ADDR+0x11D 
-#define RX_HDCP_SHW_AN_6                RX_BASE_ADDR+0x11E 
-#define RX_HDCP_SHW_AN_7                RX_BASE_ADDR+0x11F 
-#define RX_HDCP_SHW_V1_H0_0             RX_BASE_ADDR+0x120 
-#define RX_HDCP_SHW_V1_H0_1             RX_BASE_ADDR+0x121 
-#define RX_HDCP_SHW_V1_H0_2             RX_BASE_ADDR+0x122 
-#define RX_HDCP_SHW_V1_H0_3             RX_BASE_ADDR+0x123 
-#define RX_HDCP_SHW_V1_H1_0             RX_BASE_ADDR+0x124 
-#define RX_HDCP_SHW_V1_H1_1             RX_BASE_ADDR+0x125 
-#define RX_HDCP_SHW_V1_H1_2             RX_BASE_ADDR+0x126 
-#define RX_HDCP_SHW_V1_H1_3             RX_BASE_ADDR+0x127 
-#define RX_HDCP_SHW_V1_H2_0             RX_BASE_ADDR+0x128 
-#define RX_HDCP_SHW_V1_H2_1             RX_BASE_ADDR+0x129 
-#define RX_HDCP_SHW_V1_H2_2             RX_BASE_ADDR+0x12A 
-#define RX_HDCP_SHW_V1_H2_3             RX_BASE_ADDR+0x12B 
-#define RX_HDCP_SHW_V1_H3_0             RX_BASE_ADDR+0x12C 
-#define RX_HDCP_SHW_V1_H3_1             RX_BASE_ADDR+0x12D 
-#define RX_HDCP_SHW_V1_H3_2             RX_BASE_ADDR+0x12E 
-#define RX_HDCP_SHW_V1_H3_3             RX_BASE_ADDR+0x12F 
-#define RX_HDCP_SHW_V1_H4_0             RX_BASE_ADDR+0x130 
-#define RX_HDCP_SHW_V1_H4_1             RX_BASE_ADDR+0x131 
-#define RX_HDCP_SHW_V1_H4_2             RX_BASE_ADDR+0x132 
-#define RX_HDCP_SHW_V1_H4_3             RX_BASE_ADDR+0x133 
-#define RX_HDCP_SHW_BCAPS               RX_BASE_ADDR+0x140 
-#define RX_HDCP_SHW_BSTATUS_0           RX_BASE_ADDR+0x141 
-#define RX_HDCP_SHW_BSTATUS_1           RX_BASE_ADDR+0x142 
-#define RX_HDCP_SHW_KSV_FIFO            RX_BASE_ADDR+0x143 
-#define RX_HDCP_SHW_KM_0                RX_BASE_ADDR+0x148 
-#define RX_HDCP_SHW_KM_1                RX_BASE_ADDR+0x149 
-#define RX_HDCP_SHW_KM_2                RX_BASE_ADDR+0x14A 
-#define RX_HDCP_SHW_KM_3                RX_BASE_ADDR+0x14B 
-#define RX_HDCP_SHW_KM_4                RX_BASE_ADDR+0x14C 
-#define RX_HDCP_SHW_KM_5                RX_BASE_ADDR+0x14D 
-#define RX_HDCP_SHW_KM_6                RX_BASE_ADDR+0x14E 
+#define RX_HDCP_SHW_BKSV_0              RX_BASE_ADDR+0x100
+#define RX_HDCP_SHW_BKSV_1              RX_BASE_ADDR+0x101
+#define RX_HDCP_SHW_BKSV_2              RX_BASE_ADDR+0x102
+#define RX_HDCP_SHW_BKSV_3              RX_BASE_ADDR+0x103
+#define RX_HDCP_SHW_BKSV_4              RX_BASE_ADDR+0x104
+#define RX_HDCP_SHW_RI1_0               RX_BASE_ADDR+0x108
+#define RX_HDCP_SHW_RI1_1               RX_BASE_ADDR+0x109
+#define RX_HDCP_SHW_PJ1                 RX_BASE_ADDR+0x10A
+#define RX_HDCP_SHW_AKSV_0              RX_BASE_ADDR+0x110
+#define RX_HDCP_SHW_AKSV_1              RX_BASE_ADDR+0x111
+#define RX_HDCP_SHW_AKSV_2              RX_BASE_ADDR+0x112
+#define RX_HDCP_SHW_AKSV_3              RX_BASE_ADDR+0x113
+#define RX_HDCP_SHW_AKSV_4              RX_BASE_ADDR+0x114
+#define RX_HDCP_SHW_AINFO               RX_BASE_ADDR+0x115
+#define RX_HDCP_SHW_AN_0                RX_BASE_ADDR+0x118
+#define RX_HDCP_SHW_AN_1                RX_BASE_ADDR+0x119
+#define RX_HDCP_SHW_AN_2                RX_BASE_ADDR+0x11A
+#define RX_HDCP_SHW_AN_3                RX_BASE_ADDR+0x11B
+#define RX_HDCP_SHW_AN_4                RX_BASE_ADDR+0x11C
+#define RX_HDCP_SHW_AN_5                RX_BASE_ADDR+0x11D
+#define RX_HDCP_SHW_AN_6                RX_BASE_ADDR+0x11E
+#define RX_HDCP_SHW_AN_7                RX_BASE_ADDR+0x11F
+#define RX_HDCP_SHW_V1_H0_0             RX_BASE_ADDR+0x120
+#define RX_HDCP_SHW_V1_H0_1             RX_BASE_ADDR+0x121
+#define RX_HDCP_SHW_V1_H0_2             RX_BASE_ADDR+0x122
+#define RX_HDCP_SHW_V1_H0_3             RX_BASE_ADDR+0x123
+#define RX_HDCP_SHW_V1_H1_0             RX_BASE_ADDR+0x124
+#define RX_HDCP_SHW_V1_H1_1             RX_BASE_ADDR+0x125
+#define RX_HDCP_SHW_V1_H1_2             RX_BASE_ADDR+0x126
+#define RX_HDCP_SHW_V1_H1_3             RX_BASE_ADDR+0x127
+#define RX_HDCP_SHW_V1_H2_0             RX_BASE_ADDR+0x128
+#define RX_HDCP_SHW_V1_H2_1             RX_BASE_ADDR+0x129
+#define RX_HDCP_SHW_V1_H2_2             RX_BASE_ADDR+0x12A
+#define RX_HDCP_SHW_V1_H2_3             RX_BASE_ADDR+0x12B
+#define RX_HDCP_SHW_V1_H3_0             RX_BASE_ADDR+0x12C
+#define RX_HDCP_SHW_V1_H3_1             RX_BASE_ADDR+0x12D
+#define RX_HDCP_SHW_V1_H3_2             RX_BASE_ADDR+0x12E
+#define RX_HDCP_SHW_V1_H3_3             RX_BASE_ADDR+0x12F
+#define RX_HDCP_SHW_V1_H4_0             RX_BASE_ADDR+0x130
+#define RX_HDCP_SHW_V1_H4_1             RX_BASE_ADDR+0x131
+#define RX_HDCP_SHW_V1_H4_2             RX_BASE_ADDR+0x132
+#define RX_HDCP_SHW_V1_H4_3             RX_BASE_ADDR+0x133
+#define RX_HDCP_SHW_BCAPS               RX_BASE_ADDR+0x140
+#define RX_HDCP_SHW_BSTATUS_0           RX_BASE_ADDR+0x141
+#define RX_HDCP_SHW_BSTATUS_1           RX_BASE_ADDR+0x142
+#define RX_HDCP_SHW_KSV_FIFO            RX_BASE_ADDR+0x143
+#define RX_HDCP_SHW_KM_0                RX_BASE_ADDR+0x148
+#define RX_HDCP_SHW_KM_1                RX_BASE_ADDR+0x149
+#define RX_HDCP_SHW_KM_2                RX_BASE_ADDR+0x14A
+#define RX_HDCP_SHW_KM_3                RX_BASE_ADDR+0x14B
+#define RX_HDCP_SHW_KM_4                RX_BASE_ADDR+0x14C
+#define RX_HDCP_SHW_KM_5                RX_BASE_ADDR+0x14D
+#define RX_HDCP_SHW_KM_6                RX_BASE_ADDR+0x14E
 // system status extension
-#define RX_SYSST_EXT_CDR0_MONITOR_0     RX_BASE_ADDR+0x160 
-#define RX_SYSST_EXT_CDR0_MONITOR_1     RX_BASE_ADDR+0x161 
-#define RX_SYSST_EXT_CDR1_MONITOR_0     RX_BASE_ADDR+0x162 
-#define RX_SYSST_EXT_CDR1_MONITOR_1     RX_BASE_ADDR+0x163 
-#define RX_SYSST_EXT_CDR2_MONITOR_0     RX_BASE_ADDR+0x164 
-#define RX_SYSST_EXT_CDR2_MONITOR_1     RX_BASE_ADDR+0x165 
-#define RX_SYSST_EXT_CDR3_MONITOR_0     RX_BASE_ADDR+0x166 
-#define RX_SYSST_EXT_CDR3_MONITOR_1     RX_BASE_ADDR+0x167 
-#define RX_SYSST_EXT_PRBS_BER_METER_0   RX_BASE_ADDR+0x168 
-#define RX_SYSST_EXT_PRBS_BER_METER_1   RX_BASE_ADDR+0x169 
-#define RX_SYSST_EXT_PRBS_BER_METER_2   RX_BASE_ADDR+0x16A 
-#define RX_SYSST_EXT_PRBS_STATUS        RX_BASE_ADDR+0x16B 
-#define RX_SYSST_EXT_RCALIB_STATUS_0    RX_BASE_ADDR+0x16D 
-#define RX_SYSST_EXT_RCALIB_STATUS_1    RX_BASE_ADDR+0x16E 
-#define RX_SYSST_EXT_RX_FIFO_STATUS     RX_BASE_ADDR+0x16F 
+#define RX_SYSST_EXT_CDR0_MONITOR_0     RX_BASE_ADDR+0x160
+#define RX_SYSST_EXT_CDR0_MONITOR_1     RX_BASE_ADDR+0x161
+#define RX_SYSST_EXT_CDR1_MONITOR_0     RX_BASE_ADDR+0x162
+#define RX_SYSST_EXT_CDR1_MONITOR_1     RX_BASE_ADDR+0x163
+#define RX_SYSST_EXT_CDR2_MONITOR_0     RX_BASE_ADDR+0x164
+#define RX_SYSST_EXT_CDR2_MONITOR_1     RX_BASE_ADDR+0x165
+#define RX_SYSST_EXT_CDR3_MONITOR_0     RX_BASE_ADDR+0x166
+#define RX_SYSST_EXT_CDR3_MONITOR_1     RX_BASE_ADDR+0x167
+#define RX_SYSST_EXT_PRBS_BER_METER_0   RX_BASE_ADDR+0x168
+#define RX_SYSST_EXT_PRBS_BER_METER_1   RX_BASE_ADDR+0x169
+#define RX_SYSST_EXT_PRBS_BER_METER_2   RX_BASE_ADDR+0x16A
+#define RX_SYSST_EXT_PRBS_STATUS        RX_BASE_ADDR+0x16B
+#define RX_SYSST_EXT_RCALIB_STATUS_0    RX_BASE_ADDR+0x16D
+#define RX_SYSST_EXT_RCALIB_STATUS_1    RX_BASE_ADDR+0x16E
+#define RX_SYSST_EXT_RX_FIFO_STATUS     RX_BASE_ADDR+0x16F
 // Error Correction status
-#define RX_ERRST_ECC_STATUS_0           RX_BASE_ADDR+0x170 
-#define RX_ERRST_ECC_STATUS_1           RX_BASE_ADDR+0x171 
-#define RX_ERRST_ECC_STATUS_2           RX_BASE_ADDR+0x172 
-#define RX_ERRST_ECC_STATUS_3           RX_BASE_ADDR+0x173 
-#define RX_ERRST_ECC_STATUS_4           RX_BASE_ADDR+0x174 
-#define RX_ERRST_PACKET_CONTENTS        RX_BASE_ADDR+0x175 
-#define RX_ERRST_ERROR_LOCATION_0       RX_BASE_ADDR+0x176 
-#define RX_ERRST_ERROR_LOCATION_1       RX_BASE_ADDR+0x177 
-#define RX_ERRST_ERROR_LOCATION_2       RX_BASE_ADDR+0x178 
-#define RX_ERRST_ERROR_LOCATION_3       RX_BASE_ADDR+0x179 
-#define RX_ERRST_ERROR_LOCATION_4       RX_BASE_ADDR+0x17A 
-#define RX_ERRST_ERROR_LOCATION_5       RX_BASE_ADDR+0x17B 
-#define RX_ERRST_ERROR_LOCATION_6       RX_BASE_ADDR+0x17C 
-#define RX_ERRST_ERROR_LOCATION_7       RX_BASE_ADDR+0x17D 
-#define RX_ERRST_ERROR_LOCATION_8       RX_BASE_ADDR+0x17E 
-#define RX_ERRST_ERROR_LOCATION_9       RX_BASE_ADDR+0x17F 
+#define RX_ERRST_ECC_STATUS_0           RX_BASE_ADDR+0x170
+#define RX_ERRST_ECC_STATUS_1           RX_BASE_ADDR+0x171
+#define RX_ERRST_ECC_STATUS_2           RX_BASE_ADDR+0x172
+#define RX_ERRST_ECC_STATUS_3           RX_BASE_ADDR+0x173
+#define RX_ERRST_ECC_STATUS_4           RX_BASE_ADDR+0x174
+#define RX_ERRST_PACKET_CONTENTS        RX_BASE_ADDR+0x175
+#define RX_ERRST_ERROR_LOCATION_0       RX_BASE_ADDR+0x176
+#define RX_ERRST_ERROR_LOCATION_1       RX_BASE_ADDR+0x177
+#define RX_ERRST_ERROR_LOCATION_2       RX_BASE_ADDR+0x178
+#define RX_ERRST_ERROR_LOCATION_3       RX_BASE_ADDR+0x179
+#define RX_ERRST_ERROR_LOCATION_4       RX_BASE_ADDR+0x17A
+#define RX_ERRST_ERROR_LOCATION_5       RX_BASE_ADDR+0x17B
+#define RX_ERRST_ERROR_LOCATION_6       RX_BASE_ADDR+0x17C
+#define RX_ERRST_ERROR_LOCATION_7       RX_BASE_ADDR+0x17D
+#define RX_ERRST_ERROR_LOCATION_8       RX_BASE_ADDR+0x17E
+#define RX_ERRST_ERROR_LOCATION_9       RX_BASE_ADDR+0x17F
 
 // system status 0
-#define RX_SYSST0_AFE_REV_ID            RX_BASE_ADDR+0x180 
-#define RX_SYSST0_PWR_STATUS            RX_BASE_ADDR+0x189 
-#define RX_SYSST0_CTS_STATUS_L          RX_BASE_ADDR+0x18A 
-#define RX_SYSST0_CTS_STATUS_H          RX_BASE_ADDR+0x18B 
-#define RX_SYSST0_NCTS_STATUS           RX_BASE_ADDR+0x18C 
-#define RX_SYSST0_N_STATUS_L            RX_BASE_ADDR+0x18D 
-#define RX_SYSST0_N_STATUS_H            RX_BASE_ADDR+0x18E 
-#define RX_SYSST0_ROM_STATUS            RX_BASE_ADDR+0x18F 
+#define RX_SYSST0_AFE_REV_ID            RX_BASE_ADDR+0x180
+#define RX_SYSST0_PWR_STATUS            RX_BASE_ADDR+0x189
+#define RX_SYSST0_CTS_STATUS_L          RX_BASE_ADDR+0x18A
+#define RX_SYSST0_CTS_STATUS_H          RX_BASE_ADDR+0x18B
+#define RX_SYSST0_NCTS_STATUS           RX_BASE_ADDR+0x18C
+#define RX_SYSST0_N_STATUS_L            RX_BASE_ADDR+0x18D
+#define RX_SYSST0_N_STATUS_H            RX_BASE_ADDR+0x18E
+#define RX_SYSST0_ROM_STATUS            RX_BASE_ADDR+0x18F
 // system status 1
-#define RX_SYSST1_CLOCK_CONTROL_M_ACT_0         RX_BASE_ADDR+0x1E0 
-#define RX_SYSST1_CLOCK_CONTROL_M_ACT_1         RX_BASE_ADDR+0x1E1 
-#define RX_SYSST1_CLOCK_CONTROL_M_ACT_2         RX_BASE_ADDR+0x1E2 
-#define RX_SYSST1_CLOCK_CONTROL_N_ACT_0         RX_BASE_ADDR+0x1E3 
-#define RX_SYSST1_CLOCK_CONTROL_N_ACT_1         RX_BASE_ADDR+0x1E4 
-#define RX_SYSST1_CLOCK_CONTROL_N_ACT_2         RX_BASE_ADDR+0x1E5 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_0        RX_BASE_ADDR+0x1E6 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_1        RX_BASE_ADDR+0x1E7 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_2        RX_BASE_ADDR+0x1E8 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_3        RX_BASE_ADDR+0x1E9 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_4        RX_BASE_ADDR+0x1EA 
-#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_5        RX_BASE_ADDR+0x1EB 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_PRE_0       RX_BASE_ADDR+0x1EC 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_PRE_1       RX_BASE_ADDR+0x1ED 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_MAIN_0      RX_BASE_ADDR+0x1EE 
-#define RX_SYSST1_CLOCK_CONTROL_DIV_MAIN_1      RX_BASE_ADDR+0x1EF 
+#define RX_SYSST1_CLOCK_CONTROL_M_ACT_0         RX_BASE_ADDR+0x1E0
+#define RX_SYSST1_CLOCK_CONTROL_M_ACT_1         RX_BASE_ADDR+0x1E1
+#define RX_SYSST1_CLOCK_CONTROL_M_ACT_2         RX_BASE_ADDR+0x1E2
+#define RX_SYSST1_CLOCK_CONTROL_N_ACT_0         RX_BASE_ADDR+0x1E3
+#define RX_SYSST1_CLOCK_CONTROL_N_ACT_1         RX_BASE_ADDR+0x1E4
+#define RX_SYSST1_CLOCK_CONTROL_N_ACT_2         RX_BASE_ADDR+0x1E5
+#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_0        RX_BASE_ADDR+0x1E6
+#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_1        RX_BASE_ADDR+0x1E7
+#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_2        RX_BASE_ADDR+0x1E8
+#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_3        RX_BASE_ADDR+0x1E9
+#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_4        RX_BASE_ADDR+0x1EA
+#define RX_SYSST1_CLOCK_CONTROL_K1_OUT_5        RX_BASE_ADDR+0x1EB
+#define RX_SYSST1_CLOCK_CONTROL_DIV_PRE_0       RX_BASE_ADDR+0x1EC
+#define RX_SYSST1_CLOCK_CONTROL_DIV_PRE_1       RX_BASE_ADDR+0x1ED
+#define RX_SYSST1_CLOCK_CONTROL_DIV_MAIN_0      RX_BASE_ADDR+0x1EE
+#define RX_SYSST1_CLOCK_CONTROL_DIV_MAIN_1      RX_BASE_ADDR+0x1EF
 
 // hdcp status
-#define RX_HDCP_ST_AUTHENTICATION               RX_BASE_ADDR+0x190 
-#define RX_HDCP_ST_FRAME_COUNT                  RX_BASE_ADDR+0x191 
-#define RX_HDCP_ST_STATUS_0                     RX_BASE_ADDR+0x192 
-#define RX_HDCP_ST_STATUS_1                     RX_BASE_ADDR+0x193 
-#define RX_HDCP_ST_STATUS_2                     RX_BASE_ADDR+0x194 
-#define RX_HDCP_ST_STATUS_3                     RX_BASE_ADDR+0x195 
-#define RX_HDCP_ST_EDID_STATUS                  RX_BASE_ADDR+0x196 
-#define RX_HDCP_ST_MEM_STATUS                   RX_BASE_ADDR+0x197 
-#define RX_HDCP_ST_EDID_EXTENSIONS              RX_BASE_ADDR+0x198 
-#define RX_HDCP_ST_EDDC_MASTER_SEGMENT          RX_BASE_ADDR+0x199 
-#define RX_HDCP_ST_EDDC_MASTER_STATE            RX_BASE_ADDR+0x19A 
-#define RX_HDCP_ST_EDDC_SLAVE_SEGMENT           RX_BASE_ADDR+0x19B 
-#define RX_HDCP_ST_EDDC_SLAVE_STATE             RX_BASE_ADDR+0x19C 
-#define RX_HDCP_ST_CRC_STATUS                   RX_BASE_ADDR+0x19D 
-#define RX_HDCP_ST_REPEATER                     RX_BASE_ADDR+0x19E 
-#define RX_HDCP_ST_ST_MODE                      RX_BASE_ADDR+0x19F 
+#define RX_HDCP_ST_AUTHENTICATION               RX_BASE_ADDR+0x190
+#define RX_HDCP_ST_FRAME_COUNT                  RX_BASE_ADDR+0x191
+#define RX_HDCP_ST_STATUS_0                     RX_BASE_ADDR+0x192
+#define RX_HDCP_ST_STATUS_1                     RX_BASE_ADDR+0x193
+#define RX_HDCP_ST_STATUS_2                     RX_BASE_ADDR+0x194
+#define RX_HDCP_ST_STATUS_3                     RX_BASE_ADDR+0x195
+#define RX_HDCP_ST_EDID_STATUS                  RX_BASE_ADDR+0x196
+#define RX_HDCP_ST_MEM_STATUS                   RX_BASE_ADDR+0x197
+#define RX_HDCP_ST_EDID_EXTENSIONS              RX_BASE_ADDR+0x198
+#define RX_HDCP_ST_EDDC_MASTER_SEGMENT          RX_BASE_ADDR+0x199
+#define RX_HDCP_ST_EDDC_MASTER_STATE            RX_BASE_ADDR+0x19A
+#define RX_HDCP_ST_EDDC_SLAVE_SEGMENT           RX_BASE_ADDR+0x19B
+#define RX_HDCP_ST_EDDC_SLAVE_STATE             RX_BASE_ADDR+0x19C
+#define RX_HDCP_ST_CRC_STATUS                   RX_BASE_ADDR+0x19D
+#define RX_HDCP_ST_REPEATER                     RX_BASE_ADDR+0x19E
+#define RX_HDCP_ST_ST_MODE                      RX_BASE_ADDR+0x19F
 
 // video status
-#define RX_VIDEO_ST_ACTIVE_PIXELS_1     RX_BASE_ADDR+0x1A0 
-#define RX_VIDEO_ST_ACTIVE_PIXELS_2     RX_BASE_ADDR+0x1A1 
-#define RX_VIDEO_ST_FRONT_PIXELS        RX_BASE_ADDR+0x1A2 
-#define RX_VIDEO_ST_HSYNC_PIXELS        RX_BASE_ADDR+0x1A3 
-#define RX_VIDEO_ST_BACK_PIXELS         RX_BASE_ADDR+0x1A4 
-#define RX_VIDEO_ST_ACTIVE_LINES_1      RX_BASE_ADDR+0x1A5 
-#define RX_VIDEO_ST_ACTIVE_LINES_2      RX_BASE_ADDR+0x1A6 
-#define RX_VIDEO_ST_EOF_LINES           RX_BASE_ADDR+0x1A7 
-#define RX_VIDEO_ST_VSYNC_LINES         RX_BASE_ADDR+0x1A8 
-#define RX_VIDEO_ST_SOF_LINES           RX_BASE_ADDR+0x1A9 
-#define RX_VIDEO_ST_DTV_TIMING          RX_BASE_ADDR+0x1AA 
-#define RX_VIDEO_ST_DTV_MODE            RX_BASE_ADDR+0x1AB 
-// audio status 
-#define RX_AUDIOST_AUDIO_STATUS         RX_BASE_ADDR+0x1AC 
-#define RX_AUDIOST_AUDIO_HEADER         RX_BASE_ADDR+0x1AD 
-#define RX_AUDIOST_AUDIO_FIFO_LEVEL     RX_BASE_ADDR+0x1AE 
-#define RX_AUDIOST_CALIB_STATUS         RX_BASE_ADDR+0x1AF 
+#define RX_VIDEO_ST_ACTIVE_PIXELS_1     RX_BASE_ADDR+0x1A0
+#define RX_VIDEO_ST_ACTIVE_PIXELS_2     RX_BASE_ADDR+0x1A1
+#define RX_VIDEO_ST_FRONT_PIXELS        RX_BASE_ADDR+0x1A2
+#define RX_VIDEO_ST_HSYNC_PIXELS        RX_BASE_ADDR+0x1A3
+#define RX_VIDEO_ST_BACK_PIXELS         RX_BASE_ADDR+0x1A4
+#define RX_VIDEO_ST_ACTIVE_LINES_1      RX_BASE_ADDR+0x1A5
+#define RX_VIDEO_ST_ACTIVE_LINES_2      RX_BASE_ADDR+0x1A6
+#define RX_VIDEO_ST_EOF_LINES           RX_BASE_ADDR+0x1A7
+#define RX_VIDEO_ST_VSYNC_LINES         RX_BASE_ADDR+0x1A8
+#define RX_VIDEO_ST_SOF_LINES           RX_BASE_ADDR+0x1A9
+#define RX_VIDEO_ST_DTV_TIMING          RX_BASE_ADDR+0x1AA
+#define RX_VIDEO_ST_DTV_MODE            RX_BASE_ADDR+0x1AB
+// audio status
+#define RX_AUDIOST_AUDIO_STATUS         RX_BASE_ADDR+0x1AC
+#define RX_AUDIOST_AUDIO_HEADER         RX_BASE_ADDR+0x1AD
+#define RX_AUDIOST_AUDIO_FIFO_LEVEL     RX_BASE_ADDR+0x1AE
+#define RX_AUDIOST_CALIB_STATUS         RX_BASE_ADDR+0x1AF
 // core status
-#define RX_COREST_INTERRUPT_STATUS_0    RX_BASE_ADDR+0x1F0 
-#define RX_COREST_INTERRUPT_STATUS_1    RX_BASE_ADDR+0x1F1 
-#define RX_COREST_INTERRUPT_STATUS_2    RX_BASE_ADDR+0x1F2 
-#define RX_COREST_EQ_MEAS_STATUS        RX_BASE_ADDR+0x1F3 
-#define RX_COREST_TMDS_MEAS_STATUS_0    RX_BASE_ADDR+0x1F4 
-#define RX_COREST_TMDS_MEAS_STATUS_1    RX_BASE_ADDR+0x1F5 
-#define RX_COREST_TMDS_MEAS_STATUS_2    RX_BASE_ADDR+0x1F6 
-#define RX_COREST_TMDS_MEAS_STATUS_3    RX_BASE_ADDR+0x1F7 
+#define RX_COREST_INTERRUPT_STATUS_0    RX_BASE_ADDR+0x1F0
+#define RX_COREST_INTERRUPT_STATUS_1    RX_BASE_ADDR+0x1F1
+#define RX_COREST_INTERRUPT_STATUS_2    RX_BASE_ADDR+0x1F2
+#define RX_COREST_EQ_MEAS_STATUS        RX_BASE_ADDR+0x1F3
+#define RX_COREST_TMDS_MEAS_STATUS_0    RX_BASE_ADDR+0x1F4
+#define RX_COREST_TMDS_MEAS_STATUS_1    RX_BASE_ADDR+0x1F5
+#define RX_COREST_TMDS_MEAS_STATUS_2    RX_BASE_ADDR+0x1F6
+#define RX_COREST_TMDS_MEAS_STATUS_3    RX_BASE_ADDR+0x1F7
 // tmds status
-#define RX_TMDSST_ALIGN_STATUS_0        RX_BASE_ADDR+0x1F8 
-#define RX_TMDSST_ALIGN_STATUS_1        RX_BASE_ADDR+0x1F9 
-#define RX_TMDSST_ALIGN_STATUS_2        RX_BASE_ADDR+0x1FA 
-#define RX_TMDSST_ALIGN_STATUS_3        RX_BASE_ADDR+0x1FB 
-#define RX_TMDSST_HDMI_STATUS           RX_BASE_ADDR+0x1FC 
-#define RX_TMDSST_EQ_STATUS_CH0         RX_BASE_ADDR+0x1FD 
-#define RX_TMDSST_EQ_STATUS_CH1         RX_BASE_ADDR+0x1FE 
-#define RX_TMDSST_EQ_STATUS_CH2         RX_BASE_ADDR+0x1FF 
+#define RX_TMDSST_ALIGN_STATUS_0        RX_BASE_ADDR+0x1F8
+#define RX_TMDSST_ALIGN_STATUS_1        RX_BASE_ADDR+0x1F9
+#define RX_TMDSST_ALIGN_STATUS_2        RX_BASE_ADDR+0x1FA
+#define RX_TMDSST_ALIGN_STATUS_3        RX_BASE_ADDR+0x1FB
+#define RX_TMDSST_HDMI_STATUS           RX_BASE_ADDR+0x1FC
+#define RX_TMDSST_EQ_STATUS_CH0         RX_BASE_ADDR+0x1FD
+#define RX_TMDSST_EQ_STATUS_CH1         RX_BASE_ADDR+0x1FE
+#define RX_TMDSST_EQ_STATUS_CH2         RX_BASE_ADDR+0x1FF
 
 // Packet register
-#define RX_PKT_REG_SPD_INFO_BASE_ADDR           RX_BASE_ADDR+0x200 
-#define RX_PKT_REG_VEND_INFO_BASE_ADDR          RX_BASE_ADDR+0x220 
-#define RX_PKT_REG_MPEG_INFO_BASE_ADDR          RX_BASE_ADDR+0x240 
-#define RX_PKT_REG_AVI_INFO_BASE_ADDR           RX_BASE_ADDR+0x260 
-#define RX_PKT_REG_AUDIO_INFO_BASE_ADDR         RX_BASE_ADDR+0x280 
-#define RX_PKT_REG_ACP_INFO_BASE_ADDR           RX_BASE_ADDR+0x2A0 
-#define RX_PKT_REG_ISRC1_BASE_ADDR              RX_BASE_ADDR+0x2C0 
-#define RX_PKT_REG_ISRC2_BASE_ADDR              RX_BASE_ADDR+0x2E0 
-#define RX_PKT_REG_EXCEPT0_BASE_ADDR            RX_BASE_ADDR+0x300 
-#define RX_PKT_REG_EXCEPT1_BASE_ADDR            RX_BASE_ADDR+0x320 
-#define RX_PKT_REG_EXCEPT2_BASE_ADDR            RX_BASE_ADDR+0x340 
-#define RX_PKT_REG_EXCEPT3_BASE_ADDR            RX_BASE_ADDR+0x360 
-#define RX_PKT_REG_GAMUT_P0_BASE_ADDR           RX_BASE_ADDR+0x380 
-#define RX_PKT_REG_GAMUT_P1_2_BASE_ADDR         RX_BASE_ADDR+0x3A0 
-#define RX_PKT_REG_GAMUT_P1_3_BASE_ADDR         RX_BASE_ADDR+0x3C0 
-#define RX_PKT_REG_GAMUT_P1_4_BASE_ADDR         RX_BASE_ADDR+0x3E0 
+#define RX_PKT_REG_SPD_INFO_BASE_ADDR           RX_BASE_ADDR+0x200
+#define RX_PKT_REG_VEND_INFO_BASE_ADDR          RX_BASE_ADDR+0x220
+#define RX_PKT_REG_MPEG_INFO_BASE_ADDR          RX_BASE_ADDR+0x240
+#define RX_PKT_REG_AVI_INFO_BASE_ADDR           RX_BASE_ADDR+0x260
+#define RX_PKT_REG_AUDIO_INFO_BASE_ADDR         RX_BASE_ADDR+0x280
+#define RX_PKT_REG_ACP_INFO_BASE_ADDR           RX_BASE_ADDR+0x2A0
+#define RX_PKT_REG_ISRC1_BASE_ADDR              RX_BASE_ADDR+0x2C0
+#define RX_PKT_REG_ISRC2_BASE_ADDR              RX_BASE_ADDR+0x2E0
+#define RX_PKT_REG_EXCEPT0_BASE_ADDR            RX_BASE_ADDR+0x300
+#define RX_PKT_REG_EXCEPT1_BASE_ADDR            RX_BASE_ADDR+0x320
+#define RX_PKT_REG_EXCEPT2_BASE_ADDR            RX_BASE_ADDR+0x340
+#define RX_PKT_REG_EXCEPT3_BASE_ADDR            RX_BASE_ADDR+0x360
+#define RX_PKT_REG_GAMUT_P0_BASE_ADDR           RX_BASE_ADDR+0x380
+#define RX_PKT_REG_GAMUT_P1_2_BASE_ADDR         RX_BASE_ADDR+0x3A0
+#define RX_PKT_REG_GAMUT_P1_3_BASE_ADDR         RX_BASE_ADDR+0x3C0
+#define RX_PKT_REG_GAMUT_P1_4_BASE_ADDR         RX_BASE_ADDR+0x3E0
 
 
 //********** CEC related **********//
 //read/write
-#define CEC_TX_MSG_0_HEADER        0x00 
-#define CEC_TX_MSG_1_OPCODE        0x01 
-#define CEC_TX_MSG_2_OP1           0x02 
-#define CEC_TX_MSG_3_OP2           0x03 
-#define CEC_TX_MSG_4_OP3           0x04 
-#define CEC_TX_MSG_5_OP4           0x05 
-#define CEC_TX_MSG_6_OP5           0x06 
-#define CEC_TX_MSG_7_OP6           0x07 
-#define CEC_TX_MSG_8_OP7           0x08 
-#define CEC_TX_MSG_9_OP8           0x09 
-#define CEC_TX_MSG_A_OP9           0x0A 
-#define CEC_TX_MSG_B_OP10          0x0B 
-#define CEC_TX_MSG_C_OP11          0x0C 
-#define CEC_TX_MSG_D_OP12          0x0D 
-#define CEC_TX_MSG_E_OP13          0x0E 
-#define CEC_TX_MSG_F_OP14          0x0F 
+#define CEC_TX_MSG_0_HEADER        0x00
+#define CEC_TX_MSG_1_OPCODE        0x01
+#define CEC_TX_MSG_2_OP1           0x02
+#define CEC_TX_MSG_3_OP2           0x03
+#define CEC_TX_MSG_4_OP3           0x04
+#define CEC_TX_MSG_5_OP4           0x05
+#define CEC_TX_MSG_6_OP5           0x06
+#define CEC_TX_MSG_7_OP6           0x07
+#define CEC_TX_MSG_8_OP7           0x08
+#define CEC_TX_MSG_9_OP8           0x09
+#define CEC_TX_MSG_A_OP9           0x0A
+#define CEC_TX_MSG_B_OP10          0x0B
+#define CEC_TX_MSG_C_OP11          0x0C
+#define CEC_TX_MSG_D_OP12          0x0D
+#define CEC_TX_MSG_E_OP13          0x0E
+#define CEC_TX_MSG_F_OP14          0x0F
 
 //read/write
-#define CEC_TX_MSG_LENGTH          0x10 
-#define CEC_TX_MSG_CMD             0x11 
-#define CEC_TX_WRITE_BUF           0x12 
-#define CEC_TX_CLEAR_BUF           0x13 
-#define CEC_RX_MSG_CMD             0x14 
-#define CEC_RX_CLEAR_BUF           0x15 
-#define CEC_LOGICAL_ADDR0          0x16 
-#define CEC_LOGICAL_ADDR1          0x17 
-#define CEC_LOGICAL_ADDR2          0x18 
-#define CEC_LOGICAL_ADDR3          0x19 
-#define CEC_LOGICAL_ADDR4          0x1A 
-#define CEC_CLOCK_DIV_H            0x1B 
-#define CEC_CLOCK_DIV_L            0x1C 
+#define CEC_TX_MSG_LENGTH          0x10
+#define CEC_TX_MSG_CMD             0x11
+#define CEC_TX_WRITE_BUF           0x12
+#define CEC_TX_CLEAR_BUF           0x13
+#define CEC_RX_MSG_CMD             0x14
+#define CEC_RX_CLEAR_BUF           0x15
+#define CEC_LOGICAL_ADDR0          0x16
+#define CEC_LOGICAL_ADDR1          0x17
+#define CEC_LOGICAL_ADDR2          0x18
+#define CEC_LOGICAL_ADDR3          0x19
+#define CEC_LOGICAL_ADDR4          0x1A
+#define CEC_CLOCK_DIV_H            0x1B
+#define CEC_CLOCK_DIV_L            0x1C
 
 // The following registers are for fine tuning CEC bit timing parameters.
 // They are only valid in AO CEC, NOT valid in HDMITX CEC.
@@ -797,29 +797,29 @@
 #define CEC_BUGFIX_DISABLE_1                    0x61
 
 //read only
-#define CEC_RX_MSG_0_HEADER        0x80 
-#define CEC_RX_MSG_1_OPCODE        0x81 
-#define CEC_RX_MSG_2_OP1           0x82 
-#define CEC_RX_MSG_3_OP2           0x83 
-#define CEC_RX_MSG_4_OP3           0x84 
-#define CEC_RX_MSG_5_OP4           0x85 
-#define CEC_RX_MSG_6_OP5           0x86 
-#define CEC_RX_MSG_7_OP6           0x87 
-#define CEC_RX_MSG_8_OP7           0x88 
-#define CEC_RX_MSG_9_OP8           0x89 
-#define CEC_RX_MSG_A_OP9           0x8A 
-#define CEC_RX_MSG_B_OP10          0x8B 
-#define CEC_RX_MSG_C_OP11          0x8C 
-#define CEC_RX_MSG_D_OP12          0x8D 
-#define CEC_RX_MSG_E_OP13          0x8E 
-#define CEC_RX_MSG_F_OP14          0x8F 
+#define CEC_RX_MSG_0_HEADER        0x80
+#define CEC_RX_MSG_1_OPCODE        0x81
+#define CEC_RX_MSG_2_OP1           0x82
+#define CEC_RX_MSG_3_OP2           0x83
+#define CEC_RX_MSG_4_OP3           0x84
+#define CEC_RX_MSG_5_OP4           0x85
+#define CEC_RX_MSG_6_OP5           0x86
+#define CEC_RX_MSG_7_OP6           0x87
+#define CEC_RX_MSG_8_OP7           0x88
+#define CEC_RX_MSG_9_OP8           0x89
+#define CEC_RX_MSG_A_OP9           0x8A
+#define CEC_RX_MSG_B_OP10          0x8B
+#define CEC_RX_MSG_C_OP11          0x8C
+#define CEC_RX_MSG_D_OP12          0x8D
+#define CEC_RX_MSG_E_OP13          0x8E
+#define CEC_RX_MSG_F_OP14          0x8F
 
 //read only
-#define CEC_RX_MSG_LENGTH          0x90 
-#define CEC_RX_MSG_STATUS          0x91 
-#define CEC_RX_NUM_MSG             0x92 
-#define CEC_TX_MSG_STATUS          0x93 
-#define CEC_TX_NUM_MSG             0x94 
+#define CEC_RX_MSG_LENGTH          0x90
+#define CEC_RX_MSG_STATUS          0x91
+#define CEC_RX_NUM_MSG             0x92
+#define CEC_TX_MSG_STATUS          0x93
+#define CEC_TX_NUM_MSG             0x94
 
 // tx_msg_cmd definition
 #define TX_NO_OP                0  // No transaction
@@ -848,12 +848,12 @@
 
 
 //************ SIM related *************//
-#define SIM_MYREG_BASE_ADDR             SIM_BASE_ADDR+0x0000 
-#define SIM_CLKS_BASE_ADDR              SIM_BASE_ADDR+0x0800 
-#define SIM_SDI2HDMI_BASE_ADDR          SIM_BASE_ADDR+0x1000 
-#define SIM_VIDEOGEN_BASE_ADDR          SIM_BASE_ADDR+0x1800 
-#define SIM_VIDEO_ANALYZE_BASE_ADDR     SIM_BASE_ADDR+0x2000 
-#define SIM_AUDIOGEN_BASE_ADDR          SIM_BASE_ADDR+0x2800 
+#define SIM_MYREG_BASE_ADDR             SIM_BASE_ADDR+0x0000
+#define SIM_CLKS_BASE_ADDR              SIM_BASE_ADDR+0x0800
+#define SIM_SDI2HDMI_BASE_ADDR          SIM_BASE_ADDR+0x1000
+#define SIM_VIDEOGEN_BASE_ADDR          SIM_BASE_ADDR+0x1800
+#define SIM_VIDEO_ANALYZE_BASE_ADDR     SIM_BASE_ADDR+0x2000
+#define SIM_AUDIOGEN_BASE_ADDR          SIM_BASE_ADDR+0x2800
 
 #define SIM_MYREG_RESET                 SIM_MYREG_BASE_ADDR+0x0020
 
@@ -863,8 +863,8 @@
 #define SIM_MYREG_CPU_PRINT_CHAR        SIM_MYREG_BASE_ADDR+0x00FB
 #define SIM_MYREG_CMD_CNT               SIM_MYREG_BASE_ADDR+0x00FC
 #define SIM_MYREG_CPU_PRINT             SIM_MYREG_BASE_ADDR+0x00FD
-#define SIM_MYREG_END_SIM               SIM_MYREG_BASE_ADDR+0x00FE 
-#define SIM_MYREG_CONFIGEND             SIM_MYREG_BASE_ADDR+0x00FF 
+#define SIM_MYREG_END_SIM               SIM_MYREG_BASE_ADDR+0x00FE
+#define SIM_MYREG_CONFIGEND             SIM_MYREG_BASE_ADDR+0x00FF
 
 
 #endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index fb67e944422e..062745865693 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -13,7 +13,6 @@
  * GNU General Public License for more details.
  *
  */
-#define HDMI_DEBUG()  printk("HDMI DEBUG: %s [%d]\n", __FUNCTION__, __LINE__)
 
 #include <linux/version.h>
 #include <linux/module.h>
@@ -30,12 +29,12 @@
 #include <linux/platform_device.h>
 #include <linux/mutex.h>
 #include <linux/cdev.h>
-#include <linux/proc_fs.h> 
+#include <linux/switch.h>
+#include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
 
 #include <linux/amlogic/osd/osd_dev.h>
-#include <linux/switch.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 
 #include <plat/hdmi_config.h>
@@ -46,23 +45,16 @@
 #include <asm/io.h>
 #include <linux/of.h>
 
-#include "hdmi_info_global.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
 #include "hdmi_tx_cec.h"
-#include "hdmi_tx_module.h"
 #define DEVICE_NAME "amhdmitx"
 #define HDMI_TX_COUNT 32
 #define HDMI_TX_POOL_NUM  6
 #define HDMI_TX_RESOURCE_NUM 4
 #define HDMI_TX_PWR_CTRL_NUM    6
 
-#ifdef DEBUG
-#define pr_dbg(fmt, args...) printk(KERN_DEBUG "amhdmitx: " fmt, ## args)
-#else
-#define pr_dbg(fmt, args...)
-#endif
-#define pr_error(fmt, args...) printk(KERN_ERR "amhdmitx: " fmt, ## args)
-
-
 static dev_t hdmitx_id;
 static struct class *hdmitx_class;
 static struct device *hdmitx_dev;
@@ -74,12 +66,12 @@ const vinfo_t * hdmi_get_current_vinfo(void);
 struct hdmi_config_platform_data *hdmi_pdata;
 
 static hdmitx_dev_t hdmitx_device;
-static struct switch_dev sdev = {	// android ics switch device
-	.name = "hdmi",
-	};	
-static struct switch_dev hdcp_dev = {	// android ics switch device
-	.name = "hdcp",
-	};
+static struct switch_dev sdev = {      // android ics switch device
+       .name = "hdmi",
+       };
+static struct switch_dev hdcp_dev = {  // android ics switch device
+       .name = "hdcp",
+       };
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
@@ -88,10 +80,10 @@ static void hdmitx_early_suspend(struct early_suspend *h)
     const vinfo_t *info = hdmi_get_current_vinfo();
     hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
     if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
-    	return;
+        return;
     phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
     hdmi_pre_set_change_mode();
-    printk(KERN_INFO "HDMITX: early suspend\n");
+    hdmi_print(IMP, SYS "HDMITX: early suspend\n");
 }
 
 static void hdmitx_late_resume(struct early_suspend *h)
@@ -99,18 +91,18 @@ static void hdmitx_late_resume(struct early_suspend *h)
     const vinfo_t *info = hdmi_get_current_vinfo();
     hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
     if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0)) {
-    	hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
        return ;
     } else {
-    	hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_OUTPUT_ENABLE, 0);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
     }
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, 0);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HDCP_CNTL, HDCP_OFF);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
     hdmitx_device.internal_mode_change = 0;
     set_disp_mode_auto();
     pr_info("amhdmitx: late resume module %d\n", __LINE__);
     phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_LATE_RESUME);
-    printk(KERN_INFO "HDMITX: late resume\n");
+    hdmi_print(INF, SYS "late resume\n");
 }
 
 static struct early_suspend hdmitx_early_suspend_handler = {
@@ -128,37 +120,36 @@ static struct early_suspend hdmitx_early_suspend_handler = {
 
 #define INIT_FLAG_NOT_LOAD 0x80
 
-int hdmi_ch = 1;        //1: 2ch   
+int hdmi_ch = 1;        //1: 2ch
 
 static unsigned char init_flag=0;
 static unsigned char init_powermode=0;
 #undef DISABLE_AUDIO
 unsigned char hdmi_audio_off_flag = 0;        //if set to 1, then HDMI will output no audio
                                                 //In KTV case, HDMI output Picture only, and Audio is driven by other sources.
-static int hpdmode = 1; /* 
-                            0, do not unmux hpd when off or unplug ; 
+static int hpdmode = 1; /*
+                            0, do not unmux hpd when off or unplug ;
                             1, unmux hpd when unplug;
                             2, unmux hpd when unplug  or off;
                         */
 #ifdef CONFIG_AM_TV_OUTPUT2
-static int force_vout_index = 0;                      
+static int force_vout_index = 0;
 #endif
 static int hdmi_prbs_mode = 0xffff; /* 0xffff=disable; 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31*/
 static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
 
-#if 0
 // For most cases, we don't use HDCP
 // If using HDCP, need add follow command in boot/init.rc and recovery/boot/init.rc
 // write /sys/module/hdmitx/parameters/hdmi_output_force 0
 static int hdmi_output_force = 1;
-#endif
 
 static int hdmi_authenticated = -1;
-#if 0
 static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
-#endif
 static int hdmi_hdcp_status = 1;
 static int hdmi_hdcp_reset = 0;
+
+static int debug_level = 2;     // 0: error  1: important  2: normal  3: detailed
+
 /*****************************
 *    hdmitx attr management :
 *    enable
@@ -188,8 +179,8 @@ static void set_test_mode(void)
                         hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURN_ON_PRBS, hdmi_prbs_mode);
                     }
                 }
-#endif                
-    
+#endif
+
 }
 
 int get_cur_vout_index(void)
@@ -203,7 +194,7 @@ return value: 1, vout; 2, vout2;
         vout_index = force_vout_index;
     }
     else{
-//VPU_VIU_VENC_MUX_CTRL        
+//VPU_VIU_VENC_MUX_CTRL
 // [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
 //         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
 // [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
@@ -212,12 +203,12 @@ return value: 1, vout; 2, vout2;
         int viu1_sel = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
         if(((viu2_sel==1)||(viu2_sel==2))&&
             (viu1_sel!=1)&&(viu1_sel!=2)){
-            vout_index = 2;    
+            vout_index = 2;
         }
     }
 #endif
-    return vout_index;    
-}    
+    return vout_index;
+}
 
 const vinfo_t * hdmi_get_current_vinfo(void)
 {
@@ -236,7 +227,7 @@ const vinfo_t * hdmi_get_current_vinfo(void)
     info = get_current_vinfo();
 #endif
     return info;
-}    
+}
 
 static  int  set_disp_mode(const char *mode)
 {
@@ -258,7 +249,7 @@ static  int  set_disp_mode(const char *mode)
         vic = HDMI_4k2k_24;
     }
     else if(strncmp(mode, "4k2ksmpte", strlen("4k2ksmpte")) == 0) {
-        vic = HDMI_4k2k_smpte;
+        vic = HDMI_4k2k_smpte_24;
     }
     else {
         //nothing
@@ -290,13 +281,13 @@ static  int  set_disp_mode(const char *mode)
     if(hdmitx_device.cur_VIC == HDMI_Unkown){
         if(hpdmode == 2){
             hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
-            hdmitx_device.mux_hpd_if_pin_high_flag = 0; 
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
         }
         if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);    
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
         }
     }
-    
+
     return ret;
 }
 
@@ -306,24 +297,24 @@ static int set_disp_mode_auto(void)
     const vinfo_t *info = hdmi_get_current_vinfo();
     unsigned char mode[10];
     HDMI_Video_Codes_t vic;     //Prevent warning
-    
     if(info == NULL) {
-        printk("HDMITX: cann't get valid mode\n");
-        hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
+        hdmi_print(ERR, VID "cann't get valid mode\n");
+//        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
         return -1;
     }
     else
-        printk("HDMI: get current mode: %s\n", info->name);
-    if(!(hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_HPD_GPI_TEST, 0))) {
-        printk("HDMI: HPD deassert!\n");
-        hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
+        hdmi_print(IMP, VID "get current mode: %s\n", info->name);
+    if(!(hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_HPD_GPI_ST, 0))) {
+        hdmi_print(ERR, HPD "HPD deassert!\n");
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
         return -1;
     }
 
 // If info->name equals to cvbs, then set mode to I mode to hdmi
     memset(mode, 0, 10);
     if((strncmp(info->name, "480cvbs", 7) == 0) || (strncmp(info->name, "576cvbs", 7) == 0)) {
-        hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
+        hdmi_print(ERR, VID "%s not valid hdmi mode\n", info->name);
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
         return -1;
     }
     else {
@@ -331,13 +322,14 @@ static int set_disp_mode_auto(void)
     }
 
     if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0)) {
-    	hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
     } else {
-    	hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_OUTPUT_ENABLE, 0);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
     }
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, 0);
-
+#if 0
+    hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP,TMDS_PHY_DISABLE);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+#endif
     //msleep(500);
     if(hdmitx_device.tv_no_edid){
         vic = hdmitx_get_VIC(&hdmitx_device, mode);
@@ -356,7 +348,7 @@ static int set_disp_mode_auto(void)
         vic = HDMI_4k2k_24;
     }
     else if(strncmp(info->name, "4k2ksmpte", strlen("4k2ksmpte")) == 0) {
-        vic = HDMI_4k2k_smpte;
+        vic = HDMI_4k2k_smpte_24;
     }
     else {
         //nothing
@@ -381,11 +373,11 @@ static int set_disp_mode_auto(void)
         }
         // If current display is NOT panel, needn't TURNOFF_HDMIHW
         if(strncmp(mode, "panel", 5) == 0){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);    
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
         }
     }
     return ret;
-}    
+}
 #if 0
 static unsigned int set_cec_code(const char * buf, size_t count)
 {
@@ -397,21 +389,15 @@ static unsigned int set_cec_code(const char * buf, size_t count)
 
     while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
         tmpbuf[i]=buf[i];
-        i++;    
+        i++;
     }
     tmpbuf[i]=0;
 
     cec_code=simple_strtoul(tmpbuf, NULL, 16);
-    //cec_value=simple_strtoul(buf+i+1, NULL, 16);    
-    //cec_code = param[0];
-    //cec_value = param[1];
-    //printk("\n----------set_cec_code------------ \n");
 
-    //printk("\n----cec_code:%u\n",cec_code);
-    //printk("\n----cec_value:%u\n",cec_value);
     input_event(remote_cec_dev, EV_KEY, cec_code,1);
-    input_event(remote_cec_dev, EV_KEY, cec_code,0);       
-    input_sync(remote_cec_dev);  
+    input_event(remote_cec_dev, EV_KEY, cec_code,0);
+    input_sync(remote_cec_dev);
     return cec_code;
 }
 #endif
@@ -433,19 +419,19 @@ static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr
 {
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
-    return pos;    
+    return pos;
 }
-    
+
 static ssize_t store_disp_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     set_disp_mode(buf);
-    return 16;    
+    return 16;
 }
 
 /*cec attr*/
 static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
 {
-    ssize_t t = cec_usrcmd_get_global_info(buf);    
+    ssize_t t = cec_usrcmd_get_global_info(buf);
     return t;
 }
 
@@ -457,7 +443,7 @@ static ssize_t store_cec(struct device * dev, struct device_attribute *attr, con
 
 //static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
 //{
-//    ssize_t t = cec_usrcmd_get_global_info(buf);    
+//    ssize_t t = cec_usrcmd_get_global_info(buf);
 //    return t;
 //}
 
@@ -465,7 +451,7 @@ static ssize_t show_cec_config(struct device * dev, struct device_attribute *att
 {
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\r\n", aml_read_reg32(P_AO_DEBUG_REG0));
-    return pos;  
+    return pos;
 }
 
 static ssize_t store_cec_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
@@ -476,38 +462,38 @@ static ssize_t store_cec_config(struct device * dev, struct device_attribute *at
 
 static ssize_t store_cec_lang_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
-	printk("store_cec_lang_config\n");
-	//cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = strtoul(buf, NULL, 16);
-    cec_usrcmd_set_lang_config(buf, count);   
+    hdmi_print(INF, CEC "store_cec_lang_config\n");
+    //cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = strtoul(buf, NULL, 16);
+    cec_usrcmd_set_lang_config(buf, count);
     return count;
 }
 
 static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
-    printk("show_cec_lang_config\n");
-    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);   
+    hdmi_print(INF, CEC "show_cec_lang_config\n");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
     return pos;
 }
 
 /*aud_mode attr*/
 static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
 {
-    return 0;    
+    return 0;
 }
-    
+
 static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     //set_disp_mode(buf);
     Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
     if(strncmp(buf, "32k", 3)==0){
-        audio_param->sample_rate = FS_32K; 
+        audio_param->sample_rate = FS_32K;
     }
     else if(strncmp(buf, "44.1k", 5)==0){
-        audio_param->sample_rate = FS_44K1; 
+        audio_param->sample_rate = FS_44K1;
     }
     else if(strncmp(buf, "48k", 3)==0){
-        audio_param->sample_rate = FS_48K; 
+        audio_param->sample_rate = FS_48K;
     }
     else{
         hdmitx_device.force_audio_flag = 0;
@@ -515,12 +501,12 @@ static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr
     }
     audio_param->type = CT_PCM;
     audio_param->channel_num = CC_2CH;
-    audio_param->sample_size = SS_16BITS; 
-    
+    audio_param->sample_size = SS_16BITS;
+
     hdmitx_device.audio_param_update_flag = 1;
     hdmitx_device.force_audio_flag = 1;
-    
-    return count;    
+
+    return count;
 }
 
 /*edid attr*/
@@ -533,7 +519,7 @@ static ssize_t store_edid(struct device * dev, struct device_attribute *attr, co
 {
     if(buf[0]=='h'){
         int i;
-        printk("EDID hash value:\n");
+        hdmi_print(INF, EDID "EDID hash value:\n");
         for(i=0; i < 20; i++)
             printk("%02x", hdmitx_device.EDID_hash[i]);
         printk("\n");
@@ -552,17 +538,17 @@ static ssize_t store_edid(struct device * dev, struct device_attribute *attr, co
             printk("\n");
         }
     }
-    return 16;    
+    return 16;
 }
 
 /*config attr*/
 static ssize_t show_config(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int pos=0;
     pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
-    return pos;    
+    return pos;
 }
-    
+
 static ssize_t store_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     if(strncmp(buf, "force", 5)==0){
@@ -571,19 +557,6 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
     else if(strncmp(buf, "edid", 4)==0){
         hdmitx_device.disp_switch_config=DISP_SWITCH_EDID;
     }
-    else if(strncmp(buf, "vdacoff", 7)==0){
-        if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);    
-        }
-    }
-    else if(strncmp(buf, "powermode", 9)==0){
-        int tmp;
-        tmp = simple_strtoul(buf+9,NULL,10);
-        if(hdmitx_device.HWOp.Cntl){
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, tmp); 
-            printk("hdmi: set powermode %d\n", tmp);
-        }
-    }
     else if(strncmp(buf, "unplug_powerdown", 16) == 0){
         if(buf[16] == '0'){
             hdmitx_device.unplug_powerdown = 0;
@@ -597,7 +570,7 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
             hdmi_set_3d(&hdmitx_device, 6, 0);
         }
         else if(strncmp(buf+2, "lr", 2)==0){
-            int sub_sample_mode=0; 
+            int sub_sample_mode=0;
             if(buf[2])
                 sub_sample_mode = simple_strtoul(buf+2,NULL,10);
             hdmi_set_3d(&hdmitx_device, 8, sub_sample_mode); //side by side
@@ -608,25 +581,25 @@ static ssize_t store_config(struct device * dev, struct device_attribute *attr,
     }
     else if(strncmp(buf, "audio", 5)==0){
         if(buf[5] == '0') {
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_OFF);
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
         }
         else if(buf[5] == '1') {
-            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, AUDIO_ON); 
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
         }
     }
-    return 16;    
+    return 16;
 }
-  
-    
+
+
 static ssize_t store_dbg(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     hdmitx_device.HWOp.DebugFun(&hdmitx_device, buf);
-    return 16;    
+    return 16;
 }
 
 /**/
 static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int i,pos=0;
     char* disp_mode_t[]={"480i","480p","576i","576p","720p","1080i","1080p","720p50hz","1080i50hz","1080p50hz","1080p24hz","4k2k30hz","4k2k25hz","4k2k24hz","4k2ksmpte",NULL};
     char* native_disp_mode = hdmitx_edid_get_native_VIC(&hdmitx_device);
@@ -648,13 +621,13 @@ static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr,
             }
         }
     }
-    return pos;    
+    return pos;
 }
 
 
 /**/
 static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int i,pos=0;
     int j=0;
     char* disp_mode_t[]={"480i","480p","576i","576p","720p","1080i","1080p","720p50hz","1080i50hz","1080p50hz","1080p24hz","4k2k30hz","4k2k25hz","4k2k24hz","4k2ksmpte",NULL};
@@ -682,23 +655,23 @@ static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *at
     }
     pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
 
-    return pos;    
+    return pos;
 }
 
 /**/
 static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int i,pos=0, j;
-    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS_ATRAC", 
-				"OneBitAudio", "Dobly_Digital+", "DTS-HD", "MAT", "DST", "WMA_Pro", "Reserved", NULL};
+    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS_ATRAC",
+                "OneBitAudio", "Dobly_Digital+", "DTS-HD", "MAT", "DST", "WMA_Pro", "Reserved", NULL};
     const char* aud_sampling_frequency[] = {"ReferToStreamHeader", "32", "44.1", "48", "88.2", "96", "176.4", "192", NULL};
     const char* aud_sample_size[] = {"ReferToStreamHeader", "16", "20", "24", NULL};
 
     rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
     pos += snprintf(buf + pos, PAGE_SIZE, "CodingType, MaxChannels, SamplingFrequency, SampleSize\n");
     for(i = 0; i< pRXCap->AUD_count; i++) {
-        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code], 
-			pRXCap->RxAudioCap[i].channel_num_max + 1);
+        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code],
+            pRXCap->RxAudioCap[i].channel_num_max + 1);
         for(j = 0; j < 7; j++) {
             if(pRXCap->RxAudioCap[i].freq_cc & (1 << j))
                 pos += snprintf(buf + pos, PAGE_SIZE, "%s/", aud_sampling_frequency[j+1]);
@@ -724,22 +697,22 @@ static ssize_t show_aud_ch(struct device * dev, struct device_attribute *attr, c
 static ssize_t store_aud_ch(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
     if(strncmp(buf, "6ch", 3) == 0){
-        hdmi_ch = 5; 
+        hdmi_ch = 5;
     }
     else if(strncmp(buf, "8ch", 3) == 0){
-        hdmi_ch = 7; 
+        hdmi_ch = 7;
     }
     else if(strncmp(buf, "2ch", 3) == 0){
-        hdmi_ch = 1; 
+        hdmi_ch = 1;
     }
     else{
         return count;
     }
-    
+
     hdmitx_device.audio_param_update_flag = 1;
     hdmitx_device.force_audio_flag = 1;
 
-    return count;    
+    return count;
 }
 
 static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *attr, char * buf)
@@ -748,8 +721,9 @@ static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *
     char aksv_buf[5];
     char bksv_buf[5];
 
-    hdmi_hdcp_get_aksv(aksv_buf, 0);
-    hdmi_hdcp_get_bksv(bksv_buf, 0);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_AKSV, (unsigned int)aksv_buf);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_BKSV, (unsigned int)bksv_buf);
+
     pos+=snprintf(buf+pos, PAGE_SIZE, "AKSV: ");
     for(i = 0;i < 5; i++) {
         pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", aksv_buf[i]);
@@ -766,131 +740,22 @@ static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *
 }
 
 static ssize_t show_hpd_state(struct device * dev, struct device_attribute *attr, char * buf)
-{   
+{
     int pos=0;
     pos += snprintf(buf+pos, PAGE_SIZE,"%d", hdmitx_device.hpd_state);
-    return pos;    
-}
-
-static unsigned char* hdmi_log_buf=NULL;
-static unsigned int hdmi_log_wr_pos=0;
-static unsigned int hdmi_log_rd_pos=0;
-static unsigned int hdmi_log_buf_size=0;
-
-static DEFINE_SPINLOCK(hdmi_print_lock);
-
-#define PRINT_TEMP_BUF_SIZE 512
-int hdmi_print_buf(char* buf, int len)
-{
-    unsigned long flags;
-    int pos;
-    int hdmi_log_rd_pos_;
-    if(hdmi_log_buf_size==0)
-        return 0;
-    
-    spin_lock_irqsave(&hdmi_print_lock, flags);
-    hdmi_log_rd_pos_=hdmi_log_rd_pos;
-    if(hdmi_log_wr_pos>=hdmi_log_rd_pos)
-        hdmi_log_rd_pos_+=hdmi_log_buf_size;
-
-    for(pos=0;pos<len && hdmi_log_wr_pos<(hdmi_log_rd_pos_-1);pos++,hdmi_log_wr_pos++){
-        if(hdmi_log_wr_pos>=hdmi_log_buf_size)
-            hdmi_log_buf[hdmi_log_wr_pos-hdmi_log_buf_size]=buf[pos];
-        else
-            hdmi_log_buf[hdmi_log_wr_pos]=buf[pos];
-    }    
-    if(hdmi_log_wr_pos>=hdmi_log_buf_size)
-        hdmi_log_wr_pos-=hdmi_log_buf_size;
-    spin_unlock_irqrestore(&hdmi_print_lock, flags);
     return pos;
-    
 }
 
-int hdmi_print(int printk_flag, const char *fmt, ...)
+void hdmi_print(int dbg_lvl, const char *fmt, ...)
 {
     va_list args;
-    int avail = PRINT_TEMP_BUF_SIZE;
-    char buf[PRINT_TEMP_BUF_SIZE];
-    int pos,len=0;
-    if(printk_flag){
+    if(dbg_lvl == OFF)
+        return ;
+    if(dbg_lvl <= debug_level) {
         va_start(args, fmt);
-	      vprintk(fmt, args);
-        va_end(args);	
-    }
-    if(hdmi_log_buf_size==0)
-        return 0;
-        
-    va_start(args, fmt);
-    len += vsnprintf(buf+len, avail-len, fmt, args);
-    va_end(args);	
-
-    if ((avail-len) <= 0) {
-        buf[PRINT_TEMP_BUF_SIZE - 1] = '\0';
-    }
-    pos = hdmi_print_buf(buf, len);
-    //printk("hdmi_print:%d %d\n", hdmi_log_wr_pos, hdmi_log_rd_pos);
-	  return pos;
-}
-
-static ssize_t show_log(struct device * dev, struct device_attribute *attr, char * buf)
-{   
-    unsigned long flags;
-    int read_size=0;
-    if(hdmi_log_buf_size==0)
-        return 0;
-    //printk("show_log:%d %d\n", hdmi_log_wr_pos, hdmi_log_rd_pos);
-    spin_lock_irqsave(&hdmi_print_lock, flags);
-    if(hdmi_log_rd_pos<hdmi_log_wr_pos){
-        read_size = hdmi_log_wr_pos-hdmi_log_rd_pos;
-    }
-    else if(hdmi_log_rd_pos>hdmi_log_wr_pos){
-        read_size = hdmi_log_buf_size-hdmi_log_rd_pos;
-    }
-    if(read_size>PAGE_SIZE)
-        read_size=PAGE_SIZE;
-    if(read_size>0)
-        memcpy(buf, hdmi_log_buf+hdmi_log_rd_pos, read_size);
-    
-    hdmi_log_rd_pos += read_size;  
-    if(hdmi_log_rd_pos>=hdmi_log_buf_size)
-        hdmi_log_rd_pos = 0;
-    spin_unlock_irqrestore(&hdmi_print_lock, flags);
-    return read_size;    
-}
-
-static ssize_t store_log(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
-{
-    int tmp;
-    unsigned long flags;
-    if(strncmp(buf, "bufsize", 7)==0){
-        tmp = simple_strtoul(buf+7,NULL,10);
-        spin_lock_irqsave(&hdmi_print_lock, flags);
-        if(tmp==0){
-            if(hdmi_log_buf){
-                kfree(hdmi_log_buf);
-                hdmi_log_buf=NULL; 
-                hdmi_log_buf_size=0;
-                hdmi_log_rd_pos=0;   
-                hdmi_log_wr_pos=0;   
-            }    
-        }    
-        if((tmp>=1024)&&(hdmi_log_buf==NULL)){
-            hdmi_log_buf_size=0;
-            hdmi_log_rd_pos=0;   
-            hdmi_log_wr_pos=0;   
-            hdmi_log_buf=kmalloc(tmp, GFP_KERNEL);
-            if(hdmi_log_buf){
-                hdmi_log_buf_size=tmp;
-                hdmitx_device.HWOp.DebugFun(&hdmitx_device, "v");
-            }
-        }            
-        spin_unlock_irqrestore(&hdmi_print_lock, flags);
-        //printk("hdmi_store:set bufsize tmp %d %d\n",tmp, hdmi_log_buf_size);
-    }
-    else{
-        hdmi_print(0, "%s", buf);
+        vprintk(fmt, args);
+        va_end(args);
     }
-    return 16;
 }
 
 static DEVICE_ATTR(disp_mode, S_IWUSR | S_IRUGO, show_disp_mode, store_disp_mode);
@@ -904,15 +769,14 @@ static DEVICE_ATTR(aud_ch, S_IWUSR | S_IRUGO, show_aud_ch, store_aud_ch);
 static DEVICE_ATTR(disp_cap_3d, S_IWUSR | S_IRUGO, show_disp_cap_3d, NULL);
 static DEVICE_ATTR(hdcp_ksv_info, S_IWUSR | S_IRUGO, show_hdcp_ksv_info, NULL);
 static DEVICE_ATTR(hpd_state, S_IWUSR | S_IRUGO, show_hpd_state, NULL);
-static DEVICE_ATTR(log, S_IWUSR | S_IRUGO, show_log, store_log);
 static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
 static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO , show_cec_config, store_cec_config);
 //static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
 static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO , show_cec_lang_config, store_cec_lang_config);
 
 /*****************************
-*    hdmitx display client interface 
-*    
+*    hdmitx display client interface
+*
 ******************************/
 static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
 {
@@ -925,9 +789,9 @@ static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long
         if(is_dispmode_valid_for_hdmi()){
             hdmitx_device.mux_hpd_if_pin_high_flag = 1;
             if(hdmitx_device.unplug_powerdown){
-    			      return 0;
-    			  }
-		    }
+                      return 0;
+                  }
+            }
     }
 
     set_disp_mode_auto();
@@ -948,9 +812,9 @@ static int hdmitx_notify_callback_v2(struct notifier_block *block, unsigned long
         if(is_dispmode_valid_for_hdmi()){
             hdmitx_device.mux_hpd_if_pin_high_flag = 1;
             if(hdmitx_device.unplug_powerdown){
-    			      return 0;
-    			  }
-		    }
+                      return 0;
+                  }
+            }
     }
 
     set_disp_mode_auto();
@@ -969,8 +833,6 @@ static struct notifier_block hdmitx_notifier_nb_v2 = {
 };
 #endif
 
-#ifndef DISABLE_AUDIO
-
 // Refer to CEA-861-D Page 88
 #define AOUT_EVENT_REFER_TO_STREAM_HEADER       0x0
 #define AOUT_EVENT_IEC_60958_PCM                0x1
@@ -993,7 +855,6 @@ static struct notifier_block hdmitx_notifier_nb_v2 = {
 #include <sound/initval.h>
 #include <sound/control.h>
 
-#ifdef CONFIG_SND_AML_SOC
 extern int aout_register_client(struct notifier_block * ) ;
 extern int aout_unregister_client(struct notifier_block * ) ;
 static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long cmd , void *para);
@@ -1004,121 +865,118 @@ static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long
 {
     struct snd_pcm_substream *substream =(struct snd_pcm_substream*)para;
     Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
-    
+
     switch (substream->runtime->rate) {
         case 192000:
-            audio_param->sample_rate = FS_192K; 
+            audio_param->sample_rate = FS_192K;
             break;
         case 176400:
-            audio_param->sample_rate = FS_176K4; 
+            audio_param->sample_rate = FS_176K4;
             break;
         case 96000:
-            audio_param->sample_rate = FS_96K; 
+            audio_param->sample_rate = FS_96K;
             break;
         case 88200:
-            audio_param->sample_rate = FS_88K2; 
+            audio_param->sample_rate = FS_88K2;
             break;
         case 48000:
-            audio_param->sample_rate = FS_48K; 
+            audio_param->sample_rate = FS_48K;
             break;
         case 44100:
-            audio_param->sample_rate = FS_44K1; 
+            audio_param->sample_rate = FS_44K1;
             break;
         case 32000:
-            audio_param->sample_rate = FS_32K; 
+            audio_param->sample_rate = FS_32K;
             break;
         default:
-            printk("HDMI: unknown audio frequence\n");
+            hdmi_print(ERR, AUD "unknown audio frequence %d\n", substream->runtime->rate);
             break;
     }
-    hdmi_print(1, "HDMI: aout notify rate %d\n", substream->runtime->rate);
-    
+    hdmi_print(INF, AUD "aout notify rate %d\n", substream->runtime->rate);
+
     switch (cmd){
     case AOUT_EVENT_IEC_60958_PCM:
         audio_param->type = CT_PCM;
-        audio_param->sample_size = SS_16BITS;     
-        hdmi_print(1, "HDMI: aout notify format PCM\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format PCM\n");
         break;
     case AOUT_EVENT_RAWDATA_AC_3:
         audio_param->type = CT_AC_3;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format AC-3\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format AC-3\n");
         break;
     case AOUT_EVENT_RAWDATA_MPEG1:
         audio_param->type = CT_MPEG1;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format MPEG1(Layer1 2)\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format MPEG1(Layer1 2)\n");
         break;
     case AOUT_EVENT_RAWDATA_MP3:
         audio_param->type = CT_MP3;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format MP3(MPEG1 Layer3)\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format MP3(MPEG1 Layer3)\n");
         break;
     case AOUT_EVENT_RAWDATA_MPEG2:
         audio_param->type = CT_MPEG2;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format MPEG2\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format MPEG2\n");
         break;
     case AOUT_EVENT_RAWDATA_AAC:
         audio_param->type = CT_AAC;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format AAC\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format AAC\n");
         break;
     case AOUT_EVENT_RAWDATA_DTS:
         audio_param->type = CT_DTS;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format DTS\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format DTS\n");
         break;
     case AOUT_EVENT_RAWDATA_ATRAC:
         audio_param->type = CT_ATRAC;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format ATRAC\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format ATRAC\n");
         break;
     case AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO:
         audio_param->type = CT_ONE_BIT_AUDIO;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format One Bit Audio\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format One Bit Audio\n");
         break;
     case AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS:
         audio_param->type = CT_DOLBY_D;
-        audio_param->sample_size = SS_16BITS; 
+        audio_param->sample_size = SS_16BITS;
         //audio_param->sample_rate = FS_48K;//192K;      // FS_48K;       //
-        hdmi_print(1, "HDMI: aout notify format Dobly Digital +\n");
-        printk("audio sample_rate: %d\n", substream->runtime->rate);
+        hdmi_print(INF, AUD "aout notify format Dobly Digital +\n");
         break;
     case AOUT_EVENT_RAWDATA_DTS_HD:
         audio_param->type = CT_DTS_HD;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format DTS-HD\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format DTS-HD\n");
         break;
     case AOUT_EVENT_RAWDATA_MAT_MLP:
         audio_param->type = CT_MAT;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format MAT(MLP)\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format MAT(MLP)\n");
         break;
     case AOUT_EVENT_RAWDATA_DST:
         audio_param->type = CT_DST;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format DST\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format DST\n");
         break;
     case AOUT_EVENT_RAWDATA_WMA_PRO:
         audio_param->type = CT_WMA;
-        audio_param->sample_size = SS_16BITS; 
-        hdmi_print(1, "HDMI: aout notify format WMA Pro\n");
+        audio_param->sample_size = SS_16BITS;
+        hdmi_print(INF, AUD "aout notify format WMA Pro\n");
         break;
     default:
         break;
-    }    
+    }
 
     audio_param->channel_num = substream->runtime->channels - 1;
 
     hdmitx_device.audio_param_update_flag = 1;
     return 0;
 }
-#endif
 
 
-#endif
 /******************************
 *  hdmitx kernel task
 *******************************/
@@ -1148,45 +1006,35 @@ static int hdmi_task_monitor_handle(void *data)
     return 0;
 }
 
-static int hdmi_task_handle(void *data) 
+static int hdmi_task_handle(void *data)
 {
     extern void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t*);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)data;
     hdmitx_init_parameters(&hdmitx_device->hdmi_info);
 
     HDMITX_Meson_Init(hdmitx_device);
+    sdev.state = !!(hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0));
+    hdmitx_device->hpd_state = sdev.state;
 
     //When init hdmi, clear the hdmitx module edid ram and edid buffer.
     hdmitx_edid_ram_buffer_clear(hdmitx_device);
 
     hdmitx_device->HWOp.SetupIRQ(hdmitx_device);
-
-    if(hdmitx_device->HWOp.Cntl){
-        if(init_flag&INIT_FLAG_VDACOFF){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_VDAC_OFF, 0);    
-        }
-        if(init_powermode&0x80){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_POWERMODE_SWITCH, init_powermode&0x1f);    
-        }
-    }
     if(init_flag&INIT_FLAG_POWERDOWN){
         hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //power down
         hdmitx_device->unplug_powerdown=1;
         if(hdmitx_device->HWOp.Cntl){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);    
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
         }
     }
     else{
         if(hdmitx_device->HWOp.Cntl){
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);    
+            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);
         }
     }
     if(hdmitx_device->HWOp.Cntl){
         hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_IP_INTR_MASN_RST, 0);
     }
-    
-    HDMI_DEBUG();
-
     while (hdmitx_device->hpd_event != 0xff)
     {
         //if((hdmitx_device->vic_count == 0)&&(hdmitx_device->mux_hpd_if_pin_high_flag)){
@@ -1197,63 +1045,66 @@ static int hdmi_task_handle(void *data)
         }
         if(hdmitx_device->HWOp.Cntl) {
             static int st = 0;
-            st = hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_HPD_GPI_TEST, 0);
-            if(hdmitx_device->hpd_lock != 1) {
-                if((st == 0) && (hdmitx_device->hpd_state == 1)) {
-                    hdmitx_device->hpd_event = 2;
-                }
-                if((st == 1) && (hdmitx_device->hpd_state == 0)) {
-                    hdmitx_device->hpd_event = 1;
-                }
+            st = hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_HPD_GPI_ST, 0);
+            if(hdmitx_device->hpd_lock == 1) {
+                goto next;
+            }
+            if((st == 0) && (hdmitx_device->hpd_state == 1)) {
+                hdmitx_device->hpd_event = 2;
+            }
+            if((st == 1) && (hdmitx_device->hpd_state == 0)) {
+                hdmitx_device->hpd_event = 1;
             }
         }
-        
-        if((!hdmi_audio_off_flag)&&(hdmitx_device->audio_param_update_flag))//todo &&
-            //((hdmitx_device->cur_VIC != HDMI_Unkown)||(hdmitx_device->force_audio_flag))){
-                {
-            hdmitx_set_audio(hdmitx_device, &(hdmitx_device->cur_audio_param), hdmi_ch);
-            hdmitx_device->audio_param_update_flag = 0;
-            hdmi_print(1, "HDMI: set audio param\n");
+
+        if((!hdmi_audio_off_flag)&&(hdmitx_device->audio_param_update_flag)) {
+            if(hdmitx_device->hpd_state == 1) {     // plug-in & update audio param
+                hdmitx_set_audio(hdmitx_device, &(hdmitx_device->cur_audio_param), hdmi_ch);
+                hdmitx_device->audio_param_update_flag = 0;
+                hdmi_print(INF, AUD "set audio param\n");
+            }
         }
-        
+
         if(hdmitx_device->hpd_state == 0) {
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HMDITX_PHY_SUSPEND, 0);
+            hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
         }
 
         if (hdmitx_device->hpd_event == 1)
         {
+            hdmitx_device->hpd_event = 0;
+            // todo READ EDID AT LEAST TWICE
             msleep(500);
             hdmitx_device->hpd_state = 1;
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_PIN_MUX_OP, PIN_MUX);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_EDID, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_READ_DATA, 0);
 
-            if(hdmitx_device->HWOp.GetEDIDData(hdmitx_device)){
-                hdmi_print(1,"HDMI: EDID Ready\n");
+            if(hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_GET_DATA, 0)){
+                hdmi_print(IMP, EDID "edid ready\n");
                 hdmitx_edid_clear(hdmitx_device);
                 hdmitx_edid_parse(hdmitx_device);
                 hdmitx_device->tv_no_edid = 0;
-                set_disp_mode_auto();
-
-				switch_set_state(&sdev, 1);
-                cec_node_init(hdmitx_device);
-            }    
+            }
             else{
-                hdmi_print(1,"HDMI: EDID Bad\n");
+                hdmi_print(ERR, EDID "edid bad\n");
                 hdmitx_device->tv_no_edid = 1;
-                set_disp_mode_auto();
-                switch_set_state(&sdev, 1);
-                printk("test:aml_read_reg32(P_AO_DEBUG_REG0)%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
-                cec_node_init(hdmitx_device);
+                hdmi_print(INF, CEC "test:aml_read_reg32(P_AO_DEBUG_REG0)%x\n", aml_read_reg32(P_AO_DEBUG_REG0));
             }
-            if(hdmitx_device->hpd_event ==1)
-                hdmitx_device->hpd_event = 0;
+            set_disp_mode_auto();
+            switch_set_state(&sdev, 1);
+            cec_node_init(hdmitx_device);
         }
         if(hdmitx_device->hpd_event == 2)
         {
             if(hdmi_hdcp_status == 1){
                 hdmi_hdcp_reset = 1;
             }
+            hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_HPLL_OP, HPLL_DISABLE);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
             if(hdmitx_device->HWOp.Cntl){
-                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_OFF);
-                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_TMDS_PHY_CNTL, PHY_OFF);
+                hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+                hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
                 hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_IP_SW_RST, TX_SYS_SW_RST);
             }
             hdmitx_edid_clear(hdmitx_device);
@@ -1263,13 +1114,13 @@ static int hdmi_task_handle(void *data)
             if(hdmitx_device->unplug_powerdown){
                 hdmitx_set_display(hdmitx_device, HDMI_Unkown);
                 if(hdmitx_device->HWOp.Cntl){
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);    
+                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
                 }
             }
             hdmitx_device->cur_VIC = HDMI_Unkown;
             hdmitx_device->tv_cec_support = 0;
             hdmi_authenticated = -1;
-			switch_set_state(&sdev, 0);
+            switch_set_state(&sdev, 0);
             if(hdmitx_device->hpd_event == 2)
                 hdmitx_device->hpd_event = 0;
             hdmitx_device->hpd_state = 0;
@@ -1278,11 +1129,8 @@ static int hdmi_task_handle(void *data)
                 hdmi_hdcp_reset = 1;
             }
             switch_set_state(&hdcp_dev, 0);
-        }    
-        else{
         }
-        msleep(100);
-#if 0//TODO
+
         /* authentication process */
         if((hdmitx_device->cur_VIC != HDMI_Unkown) && (hdmitx_device->hpd_state == 1)){
             if(hdmitx_device->auth_process_timer>0){
@@ -1291,103 +1139,70 @@ static int hdmi_task_handle(void *data)
                 hdmitx_device->auth_process_timer--;
                 goto next;
             }
-#ifdef CONFIG_AM_HDMI_REPEATER
-            if(hdmitx_device->hdcp_repeater_mode){
-                if(hdmitx_device->repeater_hdcp_cmd == 2){    // 0: stop hdcp
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_OFF);
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, 1);
-
-                    printk("TX, stop hdcp\n");
-                    if(hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, IS_HDCP_ON)){
-                        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_OFF);
-                        /* reset hdcp */
-                        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_RESET);
-                        /**/
-                    }
-                    hdmi_authenticated = -1;
+            {
+                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_OFF);
+                if(hdmi_hdcp_process == 0){    // 0: stop hdcp
+                    hdmi_hdcp_process = -1;
                     hdmi_hdcp_status = 0;
-                    hdmitx_device->repeater_hdcp_cmd = 0;
+                    hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
                 }
-                if(hdmitx_device->repeater_hdcp_cmd == 1){    // 1: start hdcp
-                    printk("TX, start hdcp\n");
+                if(hdmi_hdcp_process == 1){    // 1: start hdcp
+                    hdmi_hdcp_process = -1;
                     hdmi_hdcp_status = 1;
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_ON);
-                    hdmitx_device->repeater_hdcp_cmd = 0;
+                    hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_ON);
+                }
+                if(hdmi_hdcp_reset == 1){
+                    hdmi_hdcp_reset = 0;
+                    hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_HDCP, 0);
+                }
+                hdmi_authenticated = hdmitx_device->HWOp.Cntl(hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+                switch_set_state(&hdcp_dev, hdmi_authenticated);
+                if(hdmi_output_force == 1) {
+                    hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+                    hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP,  AUDIO_UNMUTE);
                 }
-                
-                if(hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, IS_HDCP_ON)){
-                    hdmi_authenticated = hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_GET_AUTHENTICATE_STATE, 0);
-                    //printk("hdmi_authenticated =%d\n", hdmi_authenticated);
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, hdmi_authenticated);
-                    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, hdmi_authenticated);
+                else {
+                    hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, hdmi_authenticated ? VIDEO_UNBLANK: VIDEO_BLANK);
+                    hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, hdmi_authenticated ? AUDIO_UNMUTE : AUDIO_MUTE);
                 }
             }
-            else
-#endif                
-            {
-	            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_OFF);
-	            if(hdmi_hdcp_process == 0){    // 0: stop hdcp
-	                hdmi_hdcp_process = -1;
-	                hdmi_hdcp_status = 0;
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_OFF);
-	            }
-	            if(hdmi_hdcp_process == 1){    // 1: start hdcp
-	                hdmi_hdcp_process = -1;
-	                hdmi_hdcp_status = 1;
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_ON);
-	            }
-	            if(hdmi_hdcp_reset == 1){
-	                hdmi_hdcp_reset = 0;
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_CNTL, HDCP_ON);
-	            }
-	            hdmi_authenticated = hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_GET_AUTHENTICATE_STATE, 0);
-	            switch_set_state(&hdcp_dev, hdmi_authenticated);
-	            if(hdmi_output_force == 1) {
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, 1);
-	            }
-	            else {
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, hdmi_authenticated);
-	                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, hdmi_authenticated);
-	            }
-	        }
         }
         {
             // If current mode is PANEL, we should output normally.
             const vinfo_t *info = get_current_vinfo();
             if((info != NULL) && (strncmp(info->name, "panel", 5) == 0)) {
-                hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
             }
         }
         if(hdmi_output_force == 1) {
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_OUTPUT_ENABLE, 1);
-            hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_AUDIO_CNTL, 1);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
         }
-        /**/    
+        /**/
 next:
-        if(hdmitx_device->HWOp.Cntl(hdmitx_device, IS_HDCP_ON, 0)) {
-            msleep(10);
-        }
-        else {
-            msleep(100);
-        }
-#endif
+        msleep(100);
     }
     return 0;
 }
 
 void hdmi_pre_set_change_mode(void)
 {
+    HDMI_Video_Codes_t vic;
+    vic = hdmitx_device.HWOp.GetState(&hdmitx_device, STAT_VIDEO_VIC, 0);
+    if(vic != HDMI_Unkown) {
+        hdmi_print(IMP, SYS "[%s]ALREADY init VIC = %d\n", __func__, vic);
+        hdmitx_device.cur_VIC = vic;
+        return;
+    }
     hdmitx_device.cur_VIC = HDMI_Unkown;
     hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
     hdmitx_device.internal_mode_change = 1;
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_OUTPUT_ENABLE, 0);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, 0);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HDCP_CNTL, HDCP_OFF);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
     hdmi_authenticated = 0;
     //msleep(10);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_TMDS_PHY_CNTL, PHY_OFF);
+    hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
     hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_SET);
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_ENABLE);
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_CBUS_RST, 0);
@@ -1396,15 +1211,17 @@ void hdmi_pre_set_change_mode(void)
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
 //    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
 //    msleep(20);
-    printk("%s[%d]\n", __func__, __LINE__);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(DET);
     hdmitx_device.internal_mode_change = 0;
 }
 EXPORT_SYMBOL(hdmi_pre_set_change_mode);
 
 /* Linux */
 /*****************************
-*    hdmitx driver file_operations 
-*    
+*    hdmitx driver file_operations
+*
 ******************************/
 static int amhdmitx_open(struct inode *node, struct file *file)
 {
@@ -1460,25 +1277,25 @@ static int get_dt_vend_init_data(struct device_node *np, struct vendor_info_data
 
     ret = of_property_read_string(np, "vendor_name", (const char **)&(vend->vendor_name));
     if(ret) {
-        printk("not find vendor name\n");
+        hdmi_print(INF, SYS "not find vendor name\n");
         return 1;
     }
 
     ret = of_property_read_u32(np, "vendor_id", &(vend->vendor_id));
     if(ret) {
-        printk("not find vendor id\n");
+        hdmi_print(INF, SYS "not find vendor id\n");
         return 1;
     }
 
     ret = of_property_read_string(np, "product_desc", (const char **)&(vend->product_desc));
     if(ret) {
-        printk("not find product desc\n");
+        hdmi_print(INF, SYS "not find product desc\n");
         return 1;
     }
 
     ret = of_property_read_string(np, "cec_osd_string", (const char **)&(vend->cec_osd_string));
     if(ret) {
-        printk("not find cec osd string\n");
+        hdmi_print(INF, SYS "not find cec osd string\n");
         return 1;
     }
     return 0;
@@ -1505,14 +1322,14 @@ static int pwr_type_match(struct device_node *np, const char *str, int idx, stru
         ret = of_property_read_string_index(np, pwr_col, 1, &str);
         if(!ret) {
             gpio_val = amlogic_gpio_name_map_num(str);
-			ret = amlogic_gpio_request(gpio_val, DEVICE_NAME);
-			if (!ret) {
-			    var[idx]->var.gpo.pin = gpio_val;
+            ret = amlogic_gpio_request(gpio_val, DEVICE_NAME);
+            if (!ret) {
+                var[idx]->var.gpo.pin = gpio_val;
                 ret = of_property_read_string_index(np, pwr_col, 2, &str);
                 if(!ret) {
                     var[idx]->var.gpo.val = (strcmp(str, "H") == 0);
                 }
-			}
+            }
         }
         break;
     case AXP202:
@@ -1542,7 +1359,7 @@ static int get_dt_pwr_init_data(struct device_node *np, struct hdmi_pwr_ctl *pwr
 #if 0
     struct pwr_ctl_var (*var)[HDMI_TX_PWR_CTRL_NUM] = (struct pwr_ctl_var (*)[HDMI_TX_PWR_CTRL_NUM])pwr;
     for(idx = 0; idx < HDMI_TX_PWR_CTRL_NUM; idx++) {
-        printk("%d %d %d\n", var[idx]->type, var[idx]->var.gpo.pin, var[idx]->var.gpo.val);
+        hdmi_print(INF, SYS "%d %d %d\n", var[idx]->type, var[idx]->var.gpo.pin, var[idx]->var.gpo.val);
         return 1;
     }
 #endif
@@ -1566,7 +1383,7 @@ static void hdmitx_pwr_init(struct hdmi_pwr_ctl *ctl)
 
 static int amhdmitx_probe(struct platform_device *pdev)
 {
-	extern struct switch_dev lang_dev;
+    extern struct switch_dev lang_dev;
     int r,ret=0;
 
 #ifdef CONFIG_USE_OF
@@ -1575,14 +1392,14 @@ static int amhdmitx_probe(struct platform_device *pdev)
     struct device_node *init_data;
 #endif
 
-    HDMI_DEBUG();
-    pr_dbg("amhdmitx_probe\n");
- 
+    hdmi_print(IMP, SYS "amhdmitx_probe\n");
+
     r = alloc_chrdev_region(&hdmitx_id, 0, HDMI_TX_COUNT, DEVICE_NAME);
     if (r < 0) {
-        pr_error("Can't register major for amhdmitx device\n");
+        hdmi_print(INF, SYS "Can't register major for amhdmitx device\n");
         return r;
     }
+
     hdmitx_class = class_create(THIS_MODULE, DEVICE_NAME);
     if (IS_ERR(hdmitx_class))
     {
@@ -1590,17 +1407,17 @@ static int amhdmitx_probe(struct platform_device *pdev)
         return -1;
         //return PTR_ERR(aoe_class);
     }
-                    
+
     hdmitx_device.unplug_powerdown=0;
     hdmitx_device.vic_count=0;
     hdmitx_device.auth_process_timer=0;
     hdmitx_device.force_audio_flag=0;
     hdmitx_device.tv_cec_support=0;
-    
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
     register_early_suspend(&hdmitx_early_suspend_handler);
 #endif
-    
+
     if((init_flag&INIT_FLAG_POWERDOWN)&&(hpdmode==2)){
         hdmitx_device.mux_hpd_if_pin_high_flag=0;
     }
@@ -1613,7 +1430,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
     cdev_add(&(hdmitx_device.cdev), hdmitx_id, HDMI_TX_COUNT);
 
     //hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, "amhdmitx%d", 0);
-    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27 
+    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27
 
     ret=device_create_file(hdmitx_dev, &dev_attr_disp_mode);
     ret=device_create_file(hdmitx_dev, &dev_attr_aud_mode);
@@ -1626,13 +1443,12 @@ static int amhdmitx_probe(struct platform_device *pdev)
     ret=device_create_file(hdmitx_dev, &dev_attr_aud_ch);
     ret=device_create_file(hdmitx_dev, &dev_attr_hdcp_ksv_info);
     ret=device_create_file(hdmitx_dev, &dev_attr_hpd_state);
-    ret=device_create_file(hdmitx_dev, &dev_attr_log);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
-    
+
     if (hdmitx_dev == NULL) {
-        pr_error("device_create create error\n");
+        hdmi_print(ERR, SYS "device_create create error\n");
         class_destroy(hdmitx_class);
         r = -EEXIST;
         return r;
@@ -1641,93 +1457,89 @@ static int amhdmitx_probe(struct platform_device *pdev)
 #ifdef CONFIG_AM_TV_OUTPUT2
     vout2_register_client(&hdmitx_notifier_nb_v2);
 #endif
-#ifndef DISABLE_AUDIO
-#ifdef CONFIG_SND_AML_SOC
     aout_register_client(&hdmitx_notifier_nb_a);
-#endif
-#endif
 
 #ifdef CONFIG_USE_OF
-	if(pdev->dev.of_node){
+    if(pdev->dev.of_node){
         memset(&hdmitx_device.config_data, 0, sizeof(struct hdmi_config_platform_data));
 // Get physical setting data
-		ret = of_property_read_u32(pdev->dev.of_node, "phy-size", &psize);
-		if(!ret) {
-    	    hdmitx_device.config_data.phy_data = kzalloc(sizeof(struct hdmi_phy_set_data)*psize, GFP_KERNEL);
-    	    if(!hdmitx_device.config_data.phy_data) {
-		        printk("hdmitx: can not get phy_data mem\n");
-	        }
-	        else {
-		        ret = of_property_read_u32_array(pdev->dev.of_node, "phy-data", (unsigned int *)(hdmitx_device.config_data.phy_data), (sizeof(struct hdmi_phy_set_data))*psize/sizeof(struct hdmi_phy_set_data*));
-		        if(ret){
-			        printk("hdmitx: not find match psize\n");
-		        }
-	        }
+        ret = of_property_read_u32(pdev->dev.of_node, "phy-size", &psize);
+        if(!ret) {
+            hdmitx_device.config_data.phy_data = kzalloc(sizeof(struct hdmi_phy_set_data)*psize, GFP_KERNEL);
+            if(!hdmitx_device.config_data.phy_data) {
+                hdmi_print(INF, SYS "can not get phy_data mem\n");
+            }
+            else {
+                ret = of_property_read_u32_array(pdev->dev.of_node, "phy-data", (unsigned int *)(hdmitx_device.config_data.phy_data), (sizeof(struct hdmi_phy_set_data))*psize/sizeof(struct hdmi_phy_set_data*));
+                if(ret){
+                    hdmi_print(INF, SYS "not find match psize\n");
+                }
+            }
         }
 // Get vendor information
         ret = of_property_read_u32(pdev->dev.of_node,"vend-data",&val);
         if(ret) {
-	        printk("hdmitx: not find match init-data\n");
+            hdmi_print(INF, SYS "not find match init-data\n");
         }
         if(ret == 0) {
             phandle = val;
             init_data = of_find_node_by_phandle(phandle);
             if(!init_data) {
-                printk("hdmitx: not find device node\n");
+                hdmi_print(INF, SYS "not find device node\n");
             }
             hdmitx_device.config_data.vend_data = kzalloc(sizeof(struct vendor_info_data), GFP_KERNEL);
             if(!hdmitx_device.config_data.vend_data) {
-                printk("hdmitx: can not get vend_data mem\n");
+                hdmi_print(INF, SYS "can not get vend_data mem\n");
             }
             ret = get_dt_vend_init_data(init_data, hdmitx_device.config_data.vend_data);
             if(ret) {
-                printk("hdmitx: not find vend_init_data\n");
+                hdmi_print(INF, SYS "not find vend_init_data\n");
             }
         }
 // Get power control
         ret = of_property_read_u32(pdev->dev.of_node,"pwr-ctrl", &val);
         if(ret) {
-            printk("hdmitx: not find match pwr-ctl\n");
+            hdmi_print(INF, SYS "not find match pwr-ctl\n");
         }
         if(ret == 0) {
             phandle = val;
             init_data = of_find_node_by_phandle(phandle);
             if(!init_data) {
-                printk("hdmitx: not find device node\n");
+                hdmi_print(INF, SYS "not find device node\n");
             }
             hdmitx_device.config_data.pwr_ctl = kzalloc((sizeof(struct hdmi_pwr_ctl)) * HDMI_TX_PWR_CTRL_NUM, GFP_KERNEL);
             if(!hdmitx_device.config_data.pwr_ctl) {
-                printk("hdmitx: can not get pwr_ctl mem\n");
+                hdmi_print(INF, SYS "can not get pwr_ctl mem\n");
             }
             ret = get_dt_pwr_init_data(init_data, hdmitx_device.config_data.pwr_ctl);
             if(ret) {
-                printk("hdmitx: not find pwr_ctl\n");
+                hdmi_print(INF, SYS "not find pwr_ctl\n");
             }
         }
-	}
+    }
 // open hdmi power
     hdmitx_pwr_init(hdmitx_device.config_data.pwr_ctl);
 
 #else
     hdmi_pdata = pdev->dev.platform_data;
     if (!hdmi_pdata) {
-        dev_err(&pdev->dev, "HDMI: not get platform data\n");
+        hdmi_print(INF, SYS "not get platform data\n");
         r = -ENOENT;
     }
     else{
-        printk("HDMI: get hdmi platform data\n");
+        hdmi_print(INF, SYS "get hdmi platform data\n");
     }
 #endif
+    switch_dev_register(&sdev);
+    switch_dev_register(&lang_dev);
+    switch_dev_register(&hdcp_dev);
     hdmitx_device.task = kthread_run(hdmi_task_handle, &hdmitx_device, "kthread_hdmi");
     hdmitx_device.task_monitor = kthread_run(hdmi_task_monitor_handle, &hdmitx_device, "kthread_hdmi_monitor");
 
-	switch_dev_register(&sdev);
-	switch_dev_register(&lang_dev);
-	switch_dev_register(&hdcp_dev);
-	if (r < 0){
-		printk(KERN_ERR "hdmitx: register switch dev failed\n");
-		return r;
-	}
+    if (r < 0){
+        hdmi_print(INF, SYS "register switch dev failed\n");
+        return r;
+    }
     return r;
 }
 
@@ -1741,16 +1553,12 @@ static int amhdmitx_remove(struct platform_device *pdev)
     }
     hdmitx_device.hpd_event = 0xff;
     kthread_stop(hdmitx_device.task);
-    
-    vout_unregister_client(&hdmitx_notifier_nb_v);    
+
+    vout_unregister_client(&hdmitx_notifier_nb_v);
 #ifdef CONFIG_AM_TV_OUTPUT2
-    vout2_unregister_client(&hdmitx_notifier_nb_v2);    
+    vout2_unregister_client(&hdmitx_notifier_nb_v2);
 #endif
-#ifndef DISABLE_AUDIO
-#ifdef CONFIG_SND_AML_SOC
     aout_unregister_client(&hdmitx_notifier_nb_a);
-#endif
-#endif
 
     /* Remove the cdev */
     device_remove_file(hdmitx_dev, &dev_attr_disp_mode);
@@ -1761,7 +1569,6 @@ static int amhdmitx_remove(struct platform_device *pdev)
     device_remove_file(hdmitx_dev, &dev_attr_disp_cap);
     device_remove_file(hdmitx_dev, &dev_attr_disp_cap_3d);
     device_remove_file(hdmitx_dev, &dev_attr_hpd_state);
-    device_remove_file(hdmitx_dev, &dev_attr_log);
     device_remove_file(hdmitx_dev, &dev_attr_cec);
 
     cdev_del(&hdmitx_device.cdev);
@@ -1789,7 +1596,7 @@ static int amhdmitx_suspend(struct platform_device *pdev,pm_message_t state)
         hdmi_pdata->hdmi_3v3_ctrl ? hdmi_pdata->hdmi_3v3_ctrl(1) : 0;   // prevent Voff leak current
     }
     if(hdmitx_device.HWOp.Cntl)
-        hdmitx_device.HWOp.Cntl(&hdmitx_device, HMDITX_PHY_SUSPEND, 0);
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
 #endif
     return 0;
 }
@@ -1801,9 +1608,9 @@ static int amhdmitx_resume(struct platform_device *pdev)
     if(hdmi_pdata){
         hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(1) : 0;
     }
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_OUTPUT_ENABLE, 0);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AUDIO_CNTL, 0);
-    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HDCP_CNTL, HDCP_OFF);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
     hdmitx_device.internal_mode_change = 0;
     set_disp_mode_auto();
     pr_info("amhdmitx: resume module %d\n", __LINE__);
@@ -1814,10 +1621,10 @@ static int amhdmitx_resume(struct platform_device *pdev)
 
 #ifdef CONFIG_OF
 static const struct of_device_id meson_amhdmitx_dt_match[]={
-	{
-    	.compatible 	= "amlogic,amhdmitx",
-	},
-	{},
+    {
+        .compatible     = "amlogic,amhdmitx",
+    },
+    {},
 };
 #else
 #define meson_amhdmitx_dt_match NULL
@@ -1831,8 +1638,8 @@ static struct platform_driver amhdmitx_driver = {
 #endif
     .driver     = {
         .name   = DEVICE_NAME,
-		    .owner	= THIS_MODULE,
-		    .of_match_table = meson_amhdmitx_dt_match,
+            .owner    = THIS_MODULE,
+            .of_match_table = meson_amhdmitx_dt_match,
     }
 };
 
@@ -1840,30 +1647,15 @@ static struct platform_driver amhdmitx_driver = {
 
 static int  __init amhdmitx_init(void)
 {
-#ifdef CONFIG_ARCH_MESON8
-    extern void hdmi_tx_miniboot(void);
-    //fixed 1080p output formation
-    //TODO
-    hdmi_tx_miniboot();
-//    return 0;
-#endif
-
-    HDMI_DEBUG();
     if(init_flag&INIT_FLAG_NOT_LOAD)
         return 0;
-        
-    pr_dbg("amhdmitx_init\n");
-    printk("HDMI Ver: %s\n", HDMITX_VER);
-    if(hdmi_log_buf_size>0){
-        hdmi_log_buf=kmalloc(hdmi_log_buf_size, GFP_KERNEL);
-        if(hdmi_log_buf==NULL){
-            hdmi_log_buf_size=0;
-        }
-    }
+
+    hdmi_print(IMP, SYS "amhdmitx_init\n");
+    hdmi_print(IMP, SYS "Ver: %s\n", HDMITX_VER);
 
     if (platform_driver_register(&amhdmitx_driver)) {
-        pr_error("failed to register amhdmitx module\n");
-#if 0        
+        hdmi_print(ERR, SYS "failed to register amhdmitx module\n");
+#if 0
         platform_device_del(amhdmi_tx_device);
         platform_device_put(amhdmi_tx_device);
 #endif
@@ -1877,9 +1669,9 @@ static int  __init amhdmitx_init(void)
 
 static void __exit amhdmitx_exit(void)
 {
-    pr_dbg("amhdmitx_exit\n");
+    hdmi_print(INF, SYS "amhdmitx_exit\n");
     platform_driver_unregister(&amhdmitx_driver);
-//\\    platform_device_unregister(amhdmi_tx_device); 
+//\\    platform_device_unregister(amhdmi_tx_device);
 //\\    amhdmi_tx_device = NULL;
     return ;
 }
@@ -1895,36 +1687,36 @@ MODULE_VERSION("1.0.0");
 
 static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned offset, unsigned *token_len, unsigned *token_offset)
 { /* besides characters defined in seperator, '\"' are used as seperator; and any characters in '\"' will not act as seperator */
-	char *pToken = NULL;
+    char *pToken = NULL;
     char last_seperator = 0;
     char trans_char_flag = 0;
     if(buf){
-    	for (;offset<size;offset++){
-    	    int ii=0;
-    	    char ch;
+        for (;offset<size;offset++){
+            int ii=0;
+            char ch;
             if (buf[offset] == '\\'){
                 trans_char_flag = 1;
                 continue;
             }
-    	    while(((ch=seperator[ii++])!=buf[offset])&&(ch)){
-    	    }
-    	    if (ch){
+            while(((ch=seperator[ii++])!=buf[offset])&&(ch)){
+            }
+            if (ch){
                 if (!pToken){
-    	            continue;
+                    continue;
                 }
-    	        else {
+                else {
                     if (last_seperator != '"'){
-    	                *token_len = (unsigned)(buf + offset - pToken);
-    	                *token_offset = offset;
-    	                return pToken;
-    	            }
-    	        }
+                        *token_len = (unsigned)(buf + offset - pToken);
+                        *token_offset = offset;
+                        return pToken;
+                    }
+                }
             }
-    	    else if (!pToken)
+            else if (!pToken)
             {
                 if (trans_char_flag&&(buf[offset] == '"'))
                     last_seperator = buf[offset];
-    	        pToken = &buf[offset];
+                pToken = &buf[offset];
             }
             else if ((trans_char_flag&&(buf[offset] == '"'))&&(last_seperator == '"')){
                 *token_len = (unsigned)(buf + offset - pToken - 2);
@@ -1932,13 +1724,13 @@ static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned o
                 return pToken + 1;
             }
             trans_char_flag = 0;
-        }        
+        }
         if (pToken) {
             *token_len = (unsigned)(buf + offset - pToken);
             *token_offset = offset;
         }
     }
-	return pToken;
+    return pToken;
 }
 
 static  int __init hdmitx_boot_para_setup(char *s)
@@ -1947,8 +1739,7 @@ static  int __init hdmitx_boot_para_setup(char *s)
     char *token;
     unsigned token_len, token_offset, offset=0;
     int size=strlen(s);
-    
-    HDMI_DEBUG();
+
     do{
         token=next_token_ex(separator, s, size, offset, &token_len, &token_offset);
         if(token){
@@ -1966,45 +1757,34 @@ static  int __init hdmitx_boot_para_setup(char *s)
                 hdmi_pll_mode = 1;
             }
             else if((token_len==7)&& (strncmp(token, "hpdmode", token_len)==0)){
-                hpdmode = simple_strtoul(token+7,NULL,10);   
+                hpdmode = simple_strtoul(token+7,NULL,10);
             }
             else if((token_len==3)&&(strncmp(token, "rgb", 3)==0)){
-                hdmitx_output_rgb();    
+                hdmitx_output_rgb();
             }
             else if(strncmp(token, "audpara", 7)==0){
                 int tmp;
                 tmp = simple_strtoul(token+7,NULL,10);
                 hdmi_set_audio_para(tmp);
-                printk("hdmi: set hdmi aud_para %d\n", tmp);
-            }
-            else if(strncmp(token, "bufsize", 7)==0){
-                int tmp;
-                tmp = simple_strtoul(token+7,NULL,10);
-                if(tmp>=1024){
-                    hdmi_log_buf_size=0;
-                    hdmi_log_rd_pos=0;   
-                    hdmi_log_wr_pos=0;   
-                    hdmi_log_buf_size=tmp;
-                    printk("hdmi: set log buffer size %d\n", tmp);
-                }            
+                hdmi_print(INF, AUD "set hdmi aud_para %d\n", tmp);
             }
             else if(strncmp(token, "powermode", 9)==0){
                 int tmp;
                 tmp = simple_strtoul(token+9,NULL,10);
                 init_powermode=tmp|0x80;
-                printk("hdmi: set init powermode %d\n", tmp);                
+                hdmi_print(INF, SYS "set init powermode %d\n", tmp);
             }
             else if(strncmp(token, "audiooff", 8)==0){
                 hdmi_audio_off_flag = 1;
-                printk("hdmi: set no audio output\n");
+                hdmi_print(INF, AUD "set no audio output\n");
             }
             else if(strncmp(token, "prbs", 4)==0){
                 hdmi_prbs_mode = simple_strtoul(token+4,NULL,16);
-                printk("hdmi, set prbs mode as %x always\n", hdmi_prbs_mode);    
+                hdmi_print(INF, SYS "set prbs mode as %x always\n", hdmi_prbs_mode);
             }
             else if(strncmp(token, "480p_clk", 8)==0){
                 hdmi_480p_force_clk = simple_strtoul(token+8,NULL,10);
-                printk("hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);    
+                hdmi_print(INF, SYS "hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);
             }
             else if(strncmp(token, "cec", 3)==0) {
                 unsigned int list = simple_strtoul(token+3,NULL,16);
@@ -2012,15 +1792,15 @@ static  int __init hdmitx_boot_para_setup(char *s)
                     hdmitx_device.cec_func_config = list;
                     aml_write_reg32(P_AO_DEBUG_REG0, hdmitx_device.cec_func_config);         // save cec function list to AO_REG
                 }
-                printk("CEC Function List: %s, %s, %s, %s\n", (hdmitx_device.cec_func_config & (1 << CEC_FUNC_MSAK)) ? "enable" : "disable",
+                hdmi_print(INF, CEC "Function List: %s, %s, %s, %s\n", (hdmitx_device.cec_func_config & (1 << CEC_FUNC_MSAK)) ? "enable" : "disable",
                                                               (hdmitx_device.cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) ? "one touch play" : "",
                                                               (hdmitx_device.cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) ? "one touch standby" : "",
                                                               (hdmitx_device.cec_func_config & (1 << AUTO_POWER_ON_MASK)) ? "auto power by tv" : ""
                       );
-                printk("HDMI aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
-                printk("HDMI hdmi_cec_func_config:0x%x\n",hdmitx_device.cec_func_config);
+                hdmi_print(INF, CEC "HDMI aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
+                hdmi_print(INF, CEC "HDMI hdmi_cec_func_config:0x%x\n",hdmitx_device.cec_func_config);
             }
-        }    
+        }
         offset=token_offset;
     }while(token);
     return 0;
@@ -2028,47 +1808,6 @@ static  int __init hdmitx_boot_para_setup(char *s)
 
 __setup("hdmitx=",hdmitx_boot_para_setup);
 
-#ifdef CONFIG_AM_HDMI_REPEATER
-#define HDMI_TX_STATE_HPD                       0
-#define HDMI_TX_STATE_HDCP_AUTH                 1
-#define HDMI_TX_STATE_HDCP_CMD_DONE             2
-unsigned char get_hdmi_tx_state(unsigned char type)
-{
-    if(type == HDMI_TX_STATE_HPD){ //hdp
-        return hdmitx_device.hpd_state;
-    }
-    else if(type == HDMI_TX_STATE_HDCP_AUTH){ //hdcp
-        return hdmi_authenticated;    
-    }
-    else if(type == HDMI_TX_STATE_HDCP_CMD_DONE){
-        if(hdmitx_device.repeater_hdcp_cmd == 0){
-            return 1;  
-        }
-        else{
-            return 0;
-        }  
-    }
-    
-}
-
-#define HDMI_TX_HDCP_MODE_NONE_REPEATER     0
-#define HDMI_TX_HDCP_MODE_REPEATER          1
-void hdmi_repeater_set_hdcp_mode(unsigned char mode)
-{
-    hdmitx_device.hdcp_repeater_mode = mode;
-}
-
-void hdmi_repeater_enable_hdcp(unsigned char enable)
-{
-    if(enable){
-        hdmitx_device.repeater_hdcp_cmd = 1;
-    }
-    else{
-        hdmitx_device.repeater_hdcp_cmd = 2;
-    }
-    
-}
-
 #ifdef CONFIG_AM_TV_OUTPUT2
 MODULE_PARM_DESC(force_vout_index, "\n force_vout_index\n");
 module_param(force_vout_index, uint, 0664);
@@ -2083,12 +1822,11 @@ module_param(hdmi_prbs_mode, int, 0664);
 MODULE_PARM_DESC(hdmi_authenticated, "\n hdmi_authenticated \n");
 module_param(hdmi_authenticated, int, S_IRUGO);
 
-#if 0
 MODULE_PARM_DESC(hdmi_hdcp_process, "\n hdmi_hdcp_process \n");
 module_param(hdmi_hdcp_process, int, 0664);
 
 MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
 module_param(hdmi_output_force, int, 0664);
-#endif
 
-#endif
+MODULE_PARM_DESC(debug_level, "\n debug_level \n");
+module_param(debug_level, int, 0664);
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c
index 754aae2be386..300f1fcd60a8 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c
@@ -12,9 +12,8 @@
 #include <linux/mutex.h>
 #include <linux/cdev.h>
 
-#include "hdmi_tx_module.h"
-#include "hdmi_info_global.h"
-#include "hw/hdmi_tx_reg.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 
 #undef PCM_USE_INFOFRAME
 
@@ -27,8 +26,8 @@ static const unsigned char channel_status_freq[]=
     0x8, //88.2k
     0xa, //96k
     0xc, //176.4k
-    0xe, //192k    
-};    
+    0xe, //192k
+};
 
 static const unsigned char channel_status_sample_word_length[]=
 {
@@ -36,7 +35,7 @@ static const unsigned char channel_status_sample_word_length[]=
     0x2, //16 bits
     0x3, //20 bits
     0xb //24 bits
-};    
+};
 
 void hdmi_tx_set_N_CTS(unsigned N_value, unsigned CTS)
 {
@@ -46,10 +45,10 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
 {
 #ifndef PCM_USE_INFOFRAME
     if(audio_param->type == CT_PCM){
-        printk("HDMI Audio Type: PCM\n");
+        hdmi_print(INF, AUD "Audio Type: PCM\n");
         if(AUD_DB){
 //Note: HDMI Spec V1.4 Page 154
-            AUD_DB[0] = (CT_PCM<<4)|(audio_param->channel_num) ; 
+            AUD_DB[0] = (CT_PCM<<4)|(audio_param->channel_num) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
             AUD_DB[2] = 0x0;
             if(audio_param->channel_num == CC_6CH)
@@ -60,23 +59,21 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
                 }
                 else{
                     AUD_DB[3] = 0x13; //CA, 8 channel
-                                       
                }
-
             }
             else
                 AUD_DB[3] = 0; //CA, 2 channel, default
             AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
         }
         if(CHAN_STAT_BUF){
-            CHAN_STAT_BUF[2]=0x10|(audio_param->channel_num+1);  CHAN_STAT_BUF[24+2]=0x20|(audio_param->channel_num+1); 
+            CHAN_STAT_BUF[2]=0x10|(audio_param->channel_num+1);  CHAN_STAT_BUF[24+2]=0x20|(audio_param->channel_num+1);
             CHAN_STAT_BUF[3]=CHAN_STAT_BUF[24+3]=channel_status_freq[audio_param->sample_rate];
             CHAN_STAT_BUF[4]=CHAN_STAT_BUF[24+4]=channel_status_sample_word_length[audio_param->sample_size]|
                     ((~channel_status_freq[audio_param->sample_rate])<<4);
-        }            
+        }
     }
     else if(audio_param->type == CT_AC_3){
-        printk("HDMI Audio Type: AC3\n");
+        hdmi_print(INF, AUD "Audio Type: AC3\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_AC_3<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -85,7 +82,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_MPEG1){
-        printk("HDMI Audio Type: MPEG1\n");
+        hdmi_print(INF, AUD "Audio Type: MPEG1\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_MPEG1<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -94,7 +91,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_MP3){
-        printk("HDMI Audio Type: MP3\n");
+        hdmi_print(INF, AUD "Audio Type: MP3\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_MP3<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -103,7 +100,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_MPEG2){
-        printk("HDMI Audio Type: MPEG2\n");
+        hdmi_print(INF, AUD "Audio Type: MPEG2\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_MPEG2<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -112,7 +109,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_AAC){
-        printk("HDMI Audio Type: AAC\n");
+        hdmi_print(INF, AUD "Audio Type: AAC\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_AAC<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -121,7 +118,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_DTS){
-        printk("HDMI Audio Type: DTS\n");
+        hdmi_print(INF, AUD "Audio Type: DTS\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_DTS<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -130,7 +127,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_ATRAC){
-        printk("HDMI Audio Type: ATRAC\n");
+        hdmi_print(INF, AUD "Audio Type: ATRAC\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_ATRAC<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -139,7 +136,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_ONE_BIT_AUDIO){
-        printk("HDMI Audio Type: One Bit Audio\n");
+        hdmi_print(INF, AUD "Audio Type: One Bit Audio\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_ONE_BIT_AUDIO<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -148,7 +145,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_DOLBY_D){
-        printk("HDMI Audio Type: Dobly Digital +\n");
+        hdmi_print(INF, AUD "Audio Type: Dobly Digital +\n");
         if(AUD_DB){
             AUD_DB[0] = (FS_REFER_TO_STREAM<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -159,10 +156,10 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
             CHAN_STAT_BUF[0] = CHAN_STAT_BUF[24+0]= 0x2;
             CHAN_STAT_BUF[3] = CHAN_STAT_BUF[24+3]= 0x1e;
             CHAN_STAT_BUF[4] = CHAN_STAT_BUF[24+4]= 0x1;
-        }            
+        }
     }
     else if(audio_param->type == CT_DTS_HD){
-        printk("HDMI Audio Type: DTS-HD\n");
+        hdmi_print(INF, AUD "Audio Type: DTS-HD\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_DTS_HD<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -171,7 +168,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_MAT){
-        printk("HDMI Audio Type: MAT(MLP)\n");
+        hdmi_print(INF, AUD "Audio Type: MAT(MLP)\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_MAT<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -180,7 +177,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_DST){
-        printk("HDMI Audio Type: DST\n");
+        hdmi_print(INF, AUD "Audio Type: DST\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_DST<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -189,7 +186,7 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else if(audio_param->type == CT_WMA){
-        printk("HDMI Audio Type: WMA Pro\n");
+        hdmi_print(INF, AUD "Audio Type: WMA Pro\n");
         if(AUD_DB){
             AUD_DB[0] = (CT_WMA<<4)|(CC_REFER_TO_STREAM) ;
             AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
@@ -198,10 +195,10 @@ static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsi
         }
     }
     else
-#endif        
+#endif
     {
 //        if(AUD_DB){
-//            AUD_DB[0] = (audio_param->type<<4)|audio_param->channel_num ; 
+//            AUD_DB[0] = (audio_param->type<<4)|audio_param->channel_num ;
 //            AUD_DB[1] = (audio_param->sample_rate<<2)|audio_param->sample_size;
 //            AUD_DB[3] = 0; //CA, 2 channel
 //            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
@@ -221,7 +218,7 @@ int hdmitx_set_audio(hdmitx_dev_t* hdmitx_device, Hdmi_tx_audio_para_t* audio_pa
     for(i=0;i<(24*2);i++) CHAN_STAT_BUF[i]=0;
     if(hdmitx_device->HWOp.SetAudMode(hdmitx_device, audio_param)>=0){
         hdmi_tx_construct_aud_packet(audio_param, AUD_DB, CHAN_STAT_BUF, hdmi_ch);
-    
+
         hdmitx_device->HWOp.SetAudioInfoFrame(AUD_DB, CHAN_STAT_BUF);
         ret = 0;
     }
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.h
deleted file mode 100755
index 008680c948d2..000000000000
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.h
+++ /dev/null
@@ -1,11 +0,0 @@
-#ifndef _HDMI_TX_AUDIO_H
-#define _HDMI_TX_AUDIO_H
-
-#include "hdmi_info_global.h"
-
-extern void hdmi_tx_setting_avi_packet(HDMI_TX_INFO_t *info);
-extern void hdmi_tx_video_enable(HDMI_TX_INFO_t *info);
-extern void hdmi_tx_video_disable(HDMI_TX_INFO_t *info);
-
-#endif  // _HDMI_TX_AUDIO_H
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index aef299fbbe4c..833b75b5cfd0 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -49,9 +49,9 @@
 #include <linux/amlogic/tvin/tvin.h>
 
 #include <mach/gpio.h>
-#include "hw/hdmi_tx_reg.h"
-#include "hdmi_tx_module.h"
-#include "hdmi_info_global.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <mach/hdmi_tx_reg.h>
 #include "hdmi_tx_cec.h"
 
 //static void remote_cec_tasklet(unsigned long);
@@ -68,7 +68,7 @@ static DECLARE_WAIT_QUEUE_HEAD(cec_key_poll);
 //#define _RX_DATA_BUF_SIZE_ 6
 
 /* global variables */
-static	unsigned char    gbl_msg[MAX_MSG];
+static    unsigned char    gbl_msg[MAX_MSG];
 cec_global_info_t cec_global_info;
 unsigned char cec_power_flag = 0;
 unsigned char cec_tx_flag = 0;
@@ -81,7 +81,7 @@ static unsigned char test_buf[128] = { 0 };
 static int cec_fiq_flag = 0;
 static void cec_gpi_receive_bits(void);
 
-ssize_t	cec_lang_config_state(struct switch_dev *sdev, char *buf){
+ssize_t    cec_lang_config_state(struct switch_dev *sdev, char *buf){
     int pos=0;
     pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff, 
                                                   (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
@@ -89,10 +89,10 @@ ssize_t	cec_lang_config_state(struct switch_dev *sdev, char *buf){
     return pos;  
 };
 
-struct switch_dev lang_dev = {	// android ics switch device
-	.name = "lang_config",
-	.print_state = cec_lang_config_state,
-	};	
+struct switch_dev lang_dev = {    // android ics switch device
+    .name = "lang_config",
+    .print_state = cec_lang_config_state,
+    };
 EXPORT_SYMBOL(lang_dev);
 
 static struct semaphore  tv_cec_sema;
@@ -203,10 +203,10 @@ void cec_test_function(unsigned char* arg, unsigned char arg_cnt)
 //        cec_usrcmd_set_report_physical_address(arg[1], arg[2], arg[3], arg[4]);
 //        break;
 //    case 0x18:
-//    	{int i = 0;
-//    	cec_polling_online_dev(arg[1], &i);
-//    	}
-//    	break;
+//        {int i = 0;
+//        cec_polling_online_dev(arg[1], &i);
+//        }
+//        break;
 //    default:
 //        break;
 //    }
@@ -223,12 +223,12 @@ static void hdmitx_cec_early_suspend(struct early_suspend *h)
         cec_menu_status_smp(DEVICE_MENU_INACTIVE);
         cec_inactive_source();
 
-	    if(rc_long_press_pwr_key == 1) {
-	        cec_set_standby();
-	        printk(KERN_INFO "CEC: get power-off command from Romote Control\n");
-	        rc_long_press_pwr_key = 0;
-	    }
-	}
+        if(rc_long_press_pwr_key == 1) {
+            cec_set_standby();
+            hdmi_print(INF, CEC "get power-off command from Romote Control\n");
+            rc_long_press_pwr_key = 0;
+        }
+    }
 }
 
 static void hdmitx_cec_late_resume(struct early_suspend *h)
@@ -236,13 +236,13 @@ static void hdmitx_cec_late_resume(struct early_suspend *h)
 //    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
     //cec_node_init((hdmitx_dev_t *)h->param);
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-		cec_imageview_on_smp();
-		cec_active_source_smp();
-		msleep(200);
-		cec_active_source_smp();
-		cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-	}
-    printk(KERN_INFO "HDMITX CEC: late resume\n");
+        cec_imageview_on_smp();
+        cec_active_source_smp();
+        msleep(200);
+        cec_active_source_smp();
+        cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+    }
+    hdmi_print(INF, CEC "late resume\n");
 }
 
 #endif
@@ -315,7 +315,7 @@ int cec_ll_rx( unsigned char *msg, unsigned char *len)
         }
         pos += sprintf(msg_log_buf + pos, "\n");
         msg_log_buf[pos] = '\0';
-        printk("%s", msg_log_buf);
+        hdmi_print(INF, CEC "%s", msg_log_buf);
     }
     return rx_status;
 }
@@ -352,7 +352,7 @@ static int detect_tv_support_cec(unsigned addr)
     unsigned char msg[1];
     msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
     ret = cec_ll_tx(msg, 1);
-    printk("CEC: tv%shave CEC feature\n", ret ? " " : " don\'t ");
+    hdmi_print(INF, CEC "tv%shave CEC feature\n", ret ? " " : " don\'t ");
     return (hdmitx_device->tv_cec_support = ret);
 }
 #endif
@@ -372,18 +372,18 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
     cec_rx_flag = 1;
     cec_power_flag = 1;
     if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
-        printk("CEC not ready\n");
+        hdmi_print(INF, CEC "CEC not ready\n");
         return;
     }
     else {
-        printk("CEC node init\n");
+        hdmi_print(INF, CEC "CEC node init\n");
     }
 
     if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
         return ;
     // If VSDB is not valid, wait
     if(hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
-        printk("hdmitx: cec: no valid cec physical address\n");
+        hdmi_print(INF, CEC "no valid cec physical address\n");
         return ;
     }
     if(hdmitx_device->config_data.vend_data)
@@ -414,43 +414,40 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
 ////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
 
     
-	for(i = 0; i < 3; i++){ 
-	    //hdmitx_cec_dbg_print("CEC: start poll dev\n");  	
-		cec_polling_online_dev(player_dev[i], &bool);
-		hdmitx_cec_dbg_print("CEC: player_dev[%d]:0x%x\n", i, player_dev[i]);
-		//hdmitx_cec_dbg_print("CEC: end poll dev\n");
-		if(bool == 0){  // 0 means that no any respond
-		    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;	
+    for(i = 0; i < 3; i++){ 
+        //hdmitx_cec_dbg_print("CEC: start poll dev\n");
+        cec_polling_online_dev(player_dev[i], &bool);
+        hdmitx_cec_dbg_print("CEC: player_dev[%d]:0x%x\n", i, player_dev[i]);
+        //hdmitx_cec_dbg_print("CEC: end poll dev\n");
+        if(bool == 0){  // 0 means that no any respond
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
             cec_global_info.my_node_index = player_dev[i];
             aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
             cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
             // Set Physical address
             cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = ( ((hdmitx_device->hdmi_info.vsdb_phy_addr.a)<<12)
-            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.b)<< 8)
-            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.c)<< 4)
-            	    												 +((hdmitx_device->hdmi_info.vsdb_phy_addr.d)    )
-            	    												);
-            	    												
+                                                                     +((hdmitx_device->hdmi_info.vsdb_phy_addr.b)<< 8)
+                                                                     +((hdmitx_device->hdmi_info.vsdb_phy_addr.c)<< 4)
+                                                                     +((hdmitx_device->hdmi_info.vsdb_phy_addr.d)    )
+                                                                    );
+
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
-                        	    												
+
             cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
             //hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
             hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-		    
-     		hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", player_dev[i]);
             
+            hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", player_dev[i]);
             //cec_hw_reset();
             //spin_lock_irqsave(&cec_init_lock,cec_init_flags);
             hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
             
             cec_report_physical_address_smp();
-            
-
 
             cec_device_vendor_id((cec_rx_message_t*)0);
             
@@ -492,10 +489,10 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
             cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
             cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
             break;
-		}
-	}	
-	if(bool == 1)
-		hdmitx_cec_dbg_print("CEC: Can't get a valid logical address\n");
+        }
+    }
+    if(bool == 1)
+        hdmitx_cec_dbg_print("CEC: Can't get a valid logical address\n");
 }
 
 void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
@@ -515,7 +512,7 @@ void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
 
 static int cec_task(void *data)
 {
-	extern void dump_hdmi_cec_reg(void);
+    extern void dump_hdmi_cec_reg(void);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
 
 //    hdmitx_cec_dbg_print("CEC: Physical Address [A]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.a);
@@ -602,7 +599,7 @@ void register_cec_tx_msg(unsigned char *msg, unsigned char len )
         spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
 
         tx_msg_cnt++;
-        up(&tv_cec_sema); 
+        up(&tv_cec_sema);
     }
 }
 void cec_input_handle_message(void)
@@ -769,8 +766,8 @@ void cec_hw_reset(void)
     
     //mdelay(10);
     {//Delay some time
-    	int i = 10;
-    	while(i--);
+        int i = 10;
+        while(i--);
     }
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x0);
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x0);
@@ -985,7 +982,7 @@ void cec_polling_online_dev(int log_addr, int *bool)
         cec_global_info.my_node_index = log_addr;
         msg[0] = (log_addr<<4) | log_addr;
         hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
-        hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%lx\n",hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
+        hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%x\n",hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
         r = cec_ll_tx(msg, 1);
             
         if (r == 0) {
@@ -1003,7 +1000,7 @@ void cec_polling_online_dev(int log_addr, int *bool)
             //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
             //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);            
             cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-        	  *bool = 1;
+              *bool = 1;
         }
     if(*bool == 0) {
         hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
@@ -1303,9 +1300,9 @@ void cec_active_source(cec_rx_message_t* pcec_message)
 //                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
 //                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
         
-//        register_cec_tx_msg(gbl_msg, 4);         
+//        register_cec_tx_msg(gbl_msg, 4);
 //    }else{
-//        cec_deactive_source(pcec_message);    	
+//        cec_deactive_source(pcec_message);
 //    }
 }
 
@@ -1349,7 +1346,7 @@ void cec_set_system_audio_mode(void)
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
     else
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;    	      
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
 }
 
 void cec_system_audio_mode_request(void)
@@ -1361,16 +1358,16 @@ void cec_system_audio_mode_request(void)
                 cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
                 cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd
                 );
-        register_cec_tx_msg(gbl_msg, 4);    	
+        register_cec_tx_msg(gbl_msg, 4);
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
     }
     else{        
         MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
                 CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 
                 ); 
-        register_cec_tx_msg(gbl_msg, 2);    	
+        register_cec_tx_msg(gbl_msg, 2);
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF; 
-    }   	      
+    }
 }
 
 void cec_report_audio_status(void)
@@ -1384,7 +1381,7 @@ void cec_report_audio_status(void)
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
             );
 
-    register_cec_tx_msg(gbl_msg, 3);   	      
+    register_cec_tx_msg(gbl_msg, 3);
 }
 void cec_request_active_source(cec_rx_message_t* pcec_message)
 {
@@ -1424,8 +1421,8 @@ void cec_inactive_source(void)
         
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_INACTIVE_SOURCE;
-	msg[2] = phy_addr_ab;
-	msg[3] = phy_addr_cd;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
 
     cec_ll_tx(msg, 4);    
 }
@@ -1495,17 +1492,17 @@ void cec_set_standby(void)
     msg[1] = CEC_OC_STANDBY;
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
-			cec_ll_tx(msg, 2);
-			//mdelay(100);
-			cec_rx_flag = 0;
-		}
-	}
+            cec_ll_tx(msg, 2);
+            //mdelay(100);
+            cec_rx_flag = 0;
+        }
+    }
 }
 
 void cec_set_osd_name(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
-	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
     unsigned char msg[16];
         
@@ -1522,7 +1519,7 @@ void cec_set_osd_name(cec_rx_message_t* pcec_message)
 void cec_set_osd_name_init(void)
 {
     unsigned char index = cec_global_info.my_node_index;
-	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
     unsigned char msg[16];
 
     msg[0] = ((index & 0xf) << 4) | 0;
@@ -1572,17 +1569,17 @@ void cec_set_menu_language(cec_rx_message_t* pcec_message)
 
 void cec_handle_message(cec_rx_message_t* pcec_message)
 {
-    unsigned char	brdcst, opcode;
-    unsigned char	initiator, follower;
+    unsigned char    brdcst, opcode;
+    unsigned char    initiator, follower;
     unsigned char   operand_num;
     unsigned char   msg_length;
 
     /* parse message */
     if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) //return;
 
-    initiator	= pcec_message->content.msg.header >> 4;
-    follower	= pcec_message->content.msg.header & 0x0f;
-    opcode		= pcec_message->content.msg.opcode;
+    initiator    = pcec_message->content.msg.header >> 4;
+    follower    = pcec_message->content.msg.header & 0x0f;
+    opcode        = pcec_message->content.msg.opcode;
     operand_num = pcec_message->operand_num;
     brdcst      = (follower == 0x0f);
     msg_length  = pcec_message->msg_length;
@@ -1664,7 +1661,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             break;
         case CEC_OC_STANDBY:
             hdmitx_cec_dbg_print("CEC: system standby\n");
-        	//cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+            //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
             cec_deactive_source(pcec_message);
             cec_standby(pcec_message);
             break;
@@ -1691,12 +1688,12 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
             break;  
         case CEC_OC_ROUTING_CHANGE:
-        case CEC_OC_ROUTING_INFORMATION:    	
-        	cec_usrcmd_routing_information(pcec_message);	
-        	break;
-        case CEC_OC_GIVE_AUDIO_STATUS:   	  
-        	cec_report_audio_status();
-        	break;
+        case CEC_OC_ROUTING_INFORMATION:
+            cec_usrcmd_routing_information(pcec_message);
+            break;
+        case CEC_OC_GIVE_AUDIO_STATUS:
+            cec_report_audio_status();
+            break;
         case CEC_OC_MENU_REQUEST:
             cec_menu_status(pcec_message);
             break;
@@ -1705,13 +1702,13 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             switch(pcec_message->content.msg.operands[0]){
                 case 0x24:
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);	
+                    input_sync(remote_cec_dev);
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
                     input_sync(remote_cec_dev);
                     break;
                 case 0x25:
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);	
+                    input_sync(remote_cec_dev);
                     input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
                     input_sync(remote_cec_dev);
                     break;
@@ -1724,7 +1721,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             switch(pcec_message->content.msg.operands[0]){
                 case 0x3:
                     input_event(remote_cec_dev, EV_KEY, KEY_STOP, 1);
-                    input_sync(remote_cec_dev);	
+                    input_sync(remote_cec_dev);
                     input_event(remote_cec_dev, EV_KEY, KEY_STOP, 0);
                     input_sync(remote_cec_dev);
                     break;
@@ -1734,7 +1731,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             break;
         case CEC_OC_GET_MENU_LANGUAGE:
             //cec_set_menu_language(pcec_message);
-            //break;                 	  
+            //break;
         case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
         case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
         case CEC_OC_CLEAR_ANALOGUE_TIMER:
@@ -1959,8 +1956,8 @@ void cec_usrcmd_set_active_source(void)
     
     MSG_P2(index, CEC_BROADCAST_ADDR, 
             CEC_OC_ACTIVE_SOURCE,
-			phy_addr_ab,
-			phy_addr_cd);
+            phy_addr_ab,
+            phy_addr_cd);
 
     register_cec_tx_msg(gbl_msg, 4);
 }
@@ -2044,9 +2041,9 @@ void cec_usrcmd_set_report_physical_address(void)
            phy_addr_ab,
            phy_addr_cd,
            CEC_PLAYBACK_DEVICE_TYPE);
-			//cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-			//cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd,
-			//cec_global_info.cec_node_info[index].dev_type);
+            //cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
+            //cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd,
+            //cec_global_info.cec_node_info[index].dev_type);
 
     register_cec_tx_msg(gbl_msg, 5);
 }
@@ -2360,10 +2357,10 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
 //                                                         ((cec_info_mask)param[5]));
 //        break;
     case REPORT_PHYSICAL_ADDRESS:    //17 
-    	cec_usrcmd_set_report_physical_address();
-    	break;
+        cec_usrcmd_set_report_physical_address();
+        break;
     case SET_TEXT_VIEW_ON:          //18 LA
-    	cec_usrcmd_text_view_on(param[1]);
+        cec_usrcmd_text_view_on(param[1]);
         break;
     case POLLING_ONLINE_DEV:    //19 LA 
         hdmitx_cec_dbg_print("\n-----POLLING_ONLINE_DEV------\n");
@@ -2384,7 +2381,7 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         break;
     case 0xaa : //for cec tx test.
         for(i = 0; i < 128; i++)                             
-            printk("test_buf[%d]:%d\n", i, test_buf[i]);
+            hdmi_print(INF, CEC "test_buf[%d]:%d\n", i, test_buf[i]);
     default:
         break;
     }
@@ -2485,7 +2482,7 @@ static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
         }
         pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
         msg_log_buf[pos] = '\0';
-        printk("%s", msg_log_buf);
+        hdmi_print(INF, CEC "%s", msg_log_buf);
     }
     return ret;
 }
@@ -2516,9 +2513,9 @@ int cec_ll_tx(const unsigned char *msg, unsigned char len)
         cec_hw_reset();
     } while((ret == 0) && (repeat < 3));
 
-    cec_msg_dbg_en ? printk("cec: ret = %d\n", ret) : 0;
+    cec_msg_dbg_en ? hdmi_print(INF, CEC "ret = %d\n", ret) : 0;
     if(repeat > 1) {
-        printk("cec: try %d times\n", repeat);
+        hdmi_print(INF, CEC "try %d times\n", repeat);
     }
 
     return ret;
@@ -2602,7 +2599,7 @@ static void cec_gpi_init(void)
     aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge 
     aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 16, 1);
     request_fiq(INT_GPIO_0, &cec_gpi_receive_bits);
-    printk("cec: register fiq\n");
+    hdmi_print(INF, CEC "register fiq\n");
 
 ////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
 }
@@ -2610,6 +2607,6 @@ static void cec_gpi_init(void)
 // DELETE LATER, TEST ONLY
 void cec_test_(unsigned int cmd)
 {
-    printk("CEC: bus level: %s\n", BUS_LEVEL() ? "High" : "Low");
+    hdmi_print(INF, CEC "bus level: %s\n", BUS_LEVEL() ? "High" : "Low");
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
index c1f50eb0f701..e4d326ddaf5f 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
@@ -17,7 +17,7 @@
 
 #ifndef _TV_CEC_H_
 #define _TV_CEC_H_
-#include "hdmi_tx_module.h"
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 
 //#define CEC0_LOG_ADDR 0 // TV logical address
 #define CEC0_LOG_ADDR 4 // MBX logical address
@@ -48,43 +48,43 @@ extern unsigned int cec_tx_irq_syn_flag;
 void fiq_gpio_test(unsigned int cmd);
 
 
-#define MSG_P0( init, follow, opcode )	{				\
-	gbl_msg[0] = (init)<<4 | (follow);					\
-	gbl_msg[1] = (opcode);								\
+#define MSG_P0( init, follow, opcode )    {                \
+    gbl_msg[0] = (init)<<4 | (follow);                    \
+    gbl_msg[1] = (opcode);                                \
 }
 
-#define MSG_P1( i, f, o, p1 )	{ \
-	gbl_msg[2]=(p1); MSG_P0((i),(f),(o)); }
-#define MSG_P2( i, f, o, p1, p2 )	{ \
-	gbl_msg[3]=(p2); MSG_P1((i),(f),(o),(p1)); }
-#define MSG_P3( i, f, o, p1, p2, p3 )	{ \
-	gbl_msg[4]=(p3); MSG_P2((i),(f),(o),(p1),(p2)); }
-#define MSG_P4( i, f, o, p1, p2, p3, p4 )	{ \
-	gbl_msg[5]=(p4); MSG_P3((i),(f),(o),(p1),(p2),(p3)); }
-#define MSG_P5( i, f, o, p1, p2, p3, p4, p5 )	{ \
-	gbl_msg[6]=(p5); MSG_P4((i),(f),(o),(p1),(p2),(p3),(p4)); }
-#define MSG_P6( i, f, o, p1, p2, p3, p4, p5, p6 )	{ \
-	gbl_msg[7]=(p6); MSG_P5((i),(f),(o),(p1),(p2),(p3),(p4),(p5)); }
-#define MSG_P7( i, f, o, p1, p2, p3, p4, p5, p6, p7 )	{ \
-	gbl_msg[8]=(p7); MSG_P6((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6)); }
-#define MSG_P8( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8 )	{ \
-	gbl_msg[9]=(p8); MSG_P7((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7)); }
-#define MSG_P9( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9 )	{ \
-	gbl_msg[10]=(p9); MSG_P8((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8)); }
-#define MSG_P10( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 )	{ \
-	gbl_msg[11]=(p10); MSG_P9((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9)); }
-#define MSG_P11( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 )	{ \
-	gbl_msg[12]=(p11); MSG_P10((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10)); }
-#define MSG_P12( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 )	{ \
-	gbl_msg[13]=(p12); MSG_P11((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10),(p11)); }
-#define MSG_P13( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 )	{ \
-	gbl_msg[14]=(p13); MSG_P12((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10),(p11),(p12)); }
-#define MSG_P14( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 )	{ \
-	gbl_msg[15]=(p14); MSG_P13((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10),(p11),(p12),(p13)); }
-
-
-#define MAX_MSG		16
-#define MAX_NUM_OF_DEV	16
+#define MSG_P1( i, f, o, p1 )    { \
+    gbl_msg[2]=(p1); MSG_P0((i),(f),(o)); }
+#define MSG_P2( i, f, o, p1, p2 )    { \
+    gbl_msg[3]=(p2); MSG_P1((i),(f),(o),(p1)); }
+#define MSG_P3( i, f, o, p1, p2, p3 )    { \
+    gbl_msg[4]=(p3); MSG_P2((i),(f),(o),(p1),(p2)); }
+#define MSG_P4( i, f, o, p1, p2, p3, p4 )    { \
+    gbl_msg[5]=(p4); MSG_P3((i),(f),(o),(p1),(p2),(p3)); }
+#define MSG_P5( i, f, o, p1, p2, p3, p4, p5 )    { \
+    gbl_msg[6]=(p5); MSG_P4((i),(f),(o),(p1),(p2),(p3),(p4)); }
+#define MSG_P6( i, f, o, p1, p2, p3, p4, p5, p6 )    { \
+    gbl_msg[7]=(p6); MSG_P5((i),(f),(o),(p1),(p2),(p3),(p4),(p5)); }
+#define MSG_P7( i, f, o, p1, p2, p3, p4, p5, p6, p7 )    { \
+    gbl_msg[8]=(p7); MSG_P6((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6)); }
+#define MSG_P8( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8 )    { \
+    gbl_msg[9]=(p8); MSG_P7((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7)); }
+#define MSG_P9( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9 )    { \
+    gbl_msg[10]=(p9); MSG_P8((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8)); }
+#define MSG_P10( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 )    { \
+    gbl_msg[11]=(p10); MSG_P9((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9)); }
+#define MSG_P11( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 )    { \
+    gbl_msg[12]=(p11); MSG_P10((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10)); }
+#define MSG_P12( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 )    { \
+    gbl_msg[13]=(p12); MSG_P11((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10),(p11)); }
+#define MSG_P13( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 )    { \
+    gbl_msg[14]=(p13); MSG_P12((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10),(p11),(p12)); }
+#define MSG_P14( i, f, o, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 )    { \
+    gbl_msg[15]=(p14); MSG_P13((i),(f),(o),(p1),(p2),(p3),(p4),(p5),(p6),(p7),(p8),(p9),(p10),(p11),(p12),(p13)); }
+
+
+#define MAX_MSG        16
+#define MAX_NUM_OF_DEV    16
 
 enum _cec_ping_e {
     CEC_PING_REPLY = 0,
@@ -92,7 +92,7 @@ enum _cec_ping_e {
 };
 
 enum _cec_log_dev_addr_e {
-    CEC_TV_ADDR					= 0x00,
+    CEC_TV_ADDR                    = 0x00,
     CEC_RECORDING_DEVICE_1_ADDR,
     CEC_RECORDING_DEVICE_2_ADDR,
     CEC_TUNER_1_ADDR,
@@ -112,28 +112,28 @@ enum _cec_log_dev_addr_e {
 
 #define CEC_BROADCAST_ADDR CEC_UNREGISTERED_ADDR
 
-#define CEC_TV						( 1 << CEC_TV_ADDR )
-#define CEC_RECORDING_DEVICE_1		( 1 << CEC_RECORDING_DEVICE_1_ADDR )
-#define CEC_RECORDING_DEVICE_2		( 1 << CEC_RECORDING_DEVICE_2_ADDR )
-#define CEC_TUNER_1					( 1 << CEC_TUNER_1_ADDR )
-#define CEC_PLAYBACK_DEVICE_1		( 1 << CEC_PLAYBACK_DEVICE_1_ADDR )
-#define CEC_AUDIO_SYSTEM			( 1 << CEC_AUDIO_SYSTEM_ADDR )
-#define CEC_TUNER_2					( 1 << CEC_TUNER_2_ADDR )
-#define CEC_TUNER_3					( 1 << CEC_TUNER_3_ADDR )
-#define CEC_PLAYBACK_DEVICE_2		( 1 << CEC_PLAYBACK_DEVICE_2_ADDR )
-#define CEC_RECORDING_DEVICE_3		( 1 << CEC_RECORDING_DEVICE_3_ADDR )
-#define CEC_TUNER_4					( 1 << CEC_TUNER_4_ADDR )
-#define CEC_PLAYBACK_DEVICE_3		( 1 << CEC_PLAYBACK_DEVICE_3_ADDR )
-#define CEC_RESERVED_1				( 1 << CEC_RESERVED_1_ADDR )
-#define CEC_RESERVED_2				( 1 << CEC_RESERVED_2_ADDR )
-#define CEC_FREE_USE				( 1 << CEC_FREE_USE_ADDR )
-#define CEC_UNREGISTERED			( 1 << CEC_UNREGISTERED_ADDR )
-
-#define CEC_DISPLAY_DEVICE			( CEC_TV | CEC_FREE_USE )
-#define	CEC_RECORDING_DEVICE		( CEC_RECORDING_DEVICE_1 | CEC_RECORDING_DEVICE_2 | CEC_RECORDING_DEVICE_3 )
-#define	CEC_PLAYBACK_DEVICE			( CEC_PLAYBACK_DEVICE_1 | CEC_PLAYBACK_DEVICE_2 | CEC_PLAYBACK_DEVICE_3 )
-#define	CEC_TUNER_DEVICE			( CEC_TUNER_1 | CEC_TUNER_2 | CEC_TUNER_3 | CEC_TUNER_4 )
-#define	CEC_AUDIO_SYSTEM_DEVICE		( CEC_AUDIO_SYSTEM )
+#define CEC_TV                        ( 1 << CEC_TV_ADDR )
+#define CEC_RECORDING_DEVICE_1        ( 1 << CEC_RECORDING_DEVICE_1_ADDR )
+#define CEC_RECORDING_DEVICE_2        ( 1 << CEC_RECORDING_DEVICE_2_ADDR )
+#define CEC_TUNER_1                    ( 1 << CEC_TUNER_1_ADDR )
+#define CEC_PLAYBACK_DEVICE_1        ( 1 << CEC_PLAYBACK_DEVICE_1_ADDR )
+#define CEC_AUDIO_SYSTEM            ( 1 << CEC_AUDIO_SYSTEM_ADDR )
+#define CEC_TUNER_2                    ( 1 << CEC_TUNER_2_ADDR )
+#define CEC_TUNER_3                    ( 1 << CEC_TUNER_3_ADDR )
+#define CEC_PLAYBACK_DEVICE_2        ( 1 << CEC_PLAYBACK_DEVICE_2_ADDR )
+#define CEC_RECORDING_DEVICE_3        ( 1 << CEC_RECORDING_DEVICE_3_ADDR )
+#define CEC_TUNER_4                    ( 1 << CEC_TUNER_4_ADDR )
+#define CEC_PLAYBACK_DEVICE_3        ( 1 << CEC_PLAYBACK_DEVICE_3_ADDR )
+#define CEC_RESERVED_1                ( 1 << CEC_RESERVED_1_ADDR )
+#define CEC_RESERVED_2                ( 1 << CEC_RESERVED_2_ADDR )
+#define CEC_FREE_USE                ( 1 << CEC_FREE_USE_ADDR )
+#define CEC_UNREGISTERED            ( 1 << CEC_UNREGISTERED_ADDR )
+
+#define CEC_DISPLAY_DEVICE            ( CEC_TV | CEC_FREE_USE )
+#define    CEC_RECORDING_DEVICE        ( CEC_RECORDING_DEVICE_1 | CEC_RECORDING_DEVICE_2 | CEC_RECORDING_DEVICE_3 )
+#define    CEC_PLAYBACK_DEVICE            ( CEC_PLAYBACK_DEVICE_1 | CEC_PLAYBACK_DEVICE_2 | CEC_PLAYBACK_DEVICE_3 )
+#define    CEC_TUNER_DEVICE            ( CEC_TUNER_1 | CEC_TUNER_2 | CEC_TUNER_3 | CEC_TUNER_4 )
+#define    CEC_AUDIO_SYSTEM_DEVICE        ( CEC_AUDIO_SYSTEM )
 
 enum cec_dev_type_addr {
     CEC_DISPLAY_DEVICE_TYPE = 0x0,
@@ -161,69 +161,69 @@ typedef enum  {
 /*
  * CEC OPCODES
  */
-#define	CEC_OC_ABORT_MESSAGE 					0xFF
-#define	CEC_OC_ACTIVE_SOURCE 					0x82
-#define	CEC_OC_CEC_VERSION 						0x9E
-#define	CEC_OC_CLEAR_ANALOGUE_TIMER 			0x33
-#define	CEC_OC_CLEAR_DIGITAL_TIMER 				0x99
-#define	CEC_OC_CLEAR_EXTERNAL_TIMER 			0xA1
-#define	CEC_OC_DECK_CONTROL 					0x42
-#define	CEC_OC_DECK_STATUS 						0x1B
-#define	CEC_OC_DEVICE_VENDOR_ID 				0x87
-#define	CEC_OC_FEATURE_ABORT 					0x00
-#define	CEC_OC_GET_CEC_VERSION 					0x9F
-#define	CEC_OC_GET_MENU_LANGUAGE 				0x91
-#define	CEC_OC_GIVE_AUDIO_STATUS 				0x71
-#define	CEC_OC_GIVE_DECK_STATUS 				0x1A
-#define	CEC_OC_GIVE_DEVICE_POWER_STATUS 		0x8F
-#define	CEC_OC_GIVE_DEVICE_VENDOR_ID 			0x8C
-#define	CEC_OC_GIVE_OSD_NAME 					0x46
-#define	CEC_OC_GIVE_PHYSICAL_ADDRESS 			0x83
-#define	CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS 	0x7D
-#define	CEC_OC_GIVE_TUNER_DEVICE_STATUS 		0x08
-#define	CEC_OC_IMAGE_VIEW_ON 					0x04
-#define	CEC_OC_INACTIVE_SOURCE 					0x9D
-#define	CEC_OC_MENU_REQUEST 					0x8D
-#define	CEC_OC_MENU_STATUS 						0x8E
-#define	CEC_OC_PLAY 							0x41
-#define	CEC_OC_POLLING_MESSAGE 					0xFC	/* Fake Code - <Poll Message> has no OP Code and requires only the header byte */
-#define	CEC_OC_RECORD_OFF 						0x0B
-#define	CEC_OC_RECORD_ON 						0x09
-#define	CEC_OC_RECORD_STATUS 					0x0A
-#define	CEC_OC_RECORD_TV_SCREEN 				0x0F
-#define	CEC_OC_REPORT_AUDIO_STATUS 				0x7A
-#define	CEC_OC_REPORT_PHYSICAL_ADDRESS 			0x84
-#define	CEC_OC_REPORT_POWER_STATUS 				0x90
-#define	CEC_OC_REQUEST_ACTIVE_SOURCE 			0x85
-#define	CEC_OC_ROUTING_CHANGE 					0x80
-#define	CEC_OC_ROUTING_INFORMATION 				0x81
-#define	CEC_OC_SELECT_ANALOGUE_SERVICE 			0x92
-#define	CEC_OC_SELECT_DIGITAL_SERVICE 			0x93
-#define	CEC_OC_SET_ANALOGUE_TIMER 				0x34
-#define	CEC_OC_SET_AUDIO_RATE 					0x9A
-#define	CEC_OC_SET_DIGITAL_TIMER 				0x97
-#define	CEC_OC_SET_EXTERNAL_TIMER 				0xA2
-#define	CEC_OC_SET_MENU_LANGUAGE 				0x32
-#define	CEC_OC_SET_OSD_NAME 					0x47
-#define	CEC_OC_SET_OSD_STRING 					0x64
-#define	CEC_OC_SET_STREAM_PATH 					0x86
-#define	CEC_OC_SET_SYSTEM_AUDIO_MODE 			0x72
-#define	CEC_OC_SET_TIMER_PROGRAM_TITLE 			0x67
-#define	CEC_OC_STANDBY 							0x36
-#define	CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 		0x70
-#define	CEC_OC_SYSTEM_AUDIO_MODE_STATUS 		0x7E
-#define	CEC_OC_TEXT_VIEW_ON 					0x0D
-#define	CEC_OC_TIMER_CLEARED_STATUS 			0x43
-#define	CEC_OC_TIMER_STATUS 					0x35
-#define	CEC_OC_TUNER_DEVICE_STATUS 				0x07
-#define	CEC_OC_TUNER_STEP_DECREMENT 			0x06
-#define	CEC_OC_TUNER_STEP_INCREMENT 			0x05
-#define	CEC_OC_USER_CONTROL_PRESSED 			0x44
-#define	CEC_OC_USER_CONTROL_RELEASED 			0x45
-#define	CEC_OC_VENDOR_COMMAND 					0x89
-#define	CEC_OC_VENDOR_COMMAND_WITH_ID 			0xA0
-#define	CEC_OC_VENDOR_REMOTE_BUTTON_DOWN 		0x8A
-#define	CEC_OC_VENDOR_REMOTE_BUTTON_UP 			0x8B
+#define    CEC_OC_ABORT_MESSAGE                     0xFF
+#define    CEC_OC_ACTIVE_SOURCE                     0x82
+#define    CEC_OC_CEC_VERSION                         0x9E
+#define    CEC_OC_CLEAR_ANALOGUE_TIMER             0x33
+#define    CEC_OC_CLEAR_DIGITAL_TIMER                 0x99
+#define    CEC_OC_CLEAR_EXTERNAL_TIMER             0xA1
+#define    CEC_OC_DECK_CONTROL                     0x42
+#define    CEC_OC_DECK_STATUS                         0x1B
+#define    CEC_OC_DEVICE_VENDOR_ID                 0x87
+#define    CEC_OC_FEATURE_ABORT                     0x00
+#define    CEC_OC_GET_CEC_VERSION                     0x9F
+#define    CEC_OC_GET_MENU_LANGUAGE                 0x91
+#define    CEC_OC_GIVE_AUDIO_STATUS                 0x71
+#define    CEC_OC_GIVE_DECK_STATUS                 0x1A
+#define    CEC_OC_GIVE_DEVICE_POWER_STATUS         0x8F
+#define    CEC_OC_GIVE_DEVICE_VENDOR_ID             0x8C
+#define    CEC_OC_GIVE_OSD_NAME                     0x46
+#define    CEC_OC_GIVE_PHYSICAL_ADDRESS             0x83
+#define    CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS     0x7D
+#define    CEC_OC_GIVE_TUNER_DEVICE_STATUS         0x08
+#define    CEC_OC_IMAGE_VIEW_ON                     0x04
+#define    CEC_OC_INACTIVE_SOURCE                     0x9D
+#define    CEC_OC_MENU_REQUEST                     0x8D
+#define    CEC_OC_MENU_STATUS                         0x8E
+#define    CEC_OC_PLAY                             0x41
+#define    CEC_OC_POLLING_MESSAGE                     0xFC    /* Fake Code - <Poll Message> has no OP Code and requires only the header byte */
+#define    CEC_OC_RECORD_OFF                         0x0B
+#define    CEC_OC_RECORD_ON                         0x09
+#define    CEC_OC_RECORD_STATUS                     0x0A
+#define    CEC_OC_RECORD_TV_SCREEN                 0x0F
+#define    CEC_OC_REPORT_AUDIO_STATUS                 0x7A
+#define    CEC_OC_REPORT_PHYSICAL_ADDRESS             0x84
+#define    CEC_OC_REPORT_POWER_STATUS                 0x90
+#define    CEC_OC_REQUEST_ACTIVE_SOURCE             0x85
+#define    CEC_OC_ROUTING_CHANGE                     0x80
+#define    CEC_OC_ROUTING_INFORMATION                 0x81
+#define    CEC_OC_SELECT_ANALOGUE_SERVICE             0x92
+#define    CEC_OC_SELECT_DIGITAL_SERVICE             0x93
+#define    CEC_OC_SET_ANALOGUE_TIMER                 0x34
+#define    CEC_OC_SET_AUDIO_RATE                     0x9A
+#define    CEC_OC_SET_DIGITAL_TIMER                 0x97
+#define    CEC_OC_SET_EXTERNAL_TIMER                 0xA2
+#define    CEC_OC_SET_MENU_LANGUAGE                 0x32
+#define    CEC_OC_SET_OSD_NAME                     0x47
+#define    CEC_OC_SET_OSD_STRING                     0x64
+#define    CEC_OC_SET_STREAM_PATH                     0x86
+#define    CEC_OC_SET_SYSTEM_AUDIO_MODE             0x72
+#define    CEC_OC_SET_TIMER_PROGRAM_TITLE             0x67
+#define    CEC_OC_STANDBY                             0x36
+#define    CEC_OC_SYSTEM_AUDIO_MODE_REQUEST         0x70
+#define    CEC_OC_SYSTEM_AUDIO_MODE_STATUS         0x7E
+#define    CEC_OC_TEXT_VIEW_ON                     0x0D
+#define    CEC_OC_TIMER_CLEARED_STATUS             0x43
+#define    CEC_OC_TIMER_STATUS                     0x35
+#define    CEC_OC_TUNER_DEVICE_STATUS                 0x07
+#define    CEC_OC_TUNER_STEP_DECREMENT             0x06
+#define    CEC_OC_TUNER_STEP_INCREMENT             0x05
+#define    CEC_OC_USER_CONTROL_PRESSED             0x44
+#define    CEC_OC_USER_CONTROL_RELEASED             0x45
+#define    CEC_OC_VENDOR_COMMAND                     0x89
+#define    CEC_OC_VENDOR_COMMAND_WITH_ID             0xA0
+#define    CEC_OC_VENDOR_REMOTE_BUTTON_DOWN         0x8A
+#define    CEC_OC_VENDOR_REMOTE_BUTTON_UP             0x8B
 
 /* cec message structure */
 typedef struct {
@@ -432,7 +432,7 @@ typedef struct {
             struct {
                 unsigned char audio_mute_status : 1;
                 unsigned char audio_volume_status : 7;
-            } audio_status;      	
+            } audio_status;
         } audio;
     }specific_info;
 } cec_node_info_t;
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
index 47d6a16098cd..bf3c477cfc84 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
@@ -14,14 +14,14 @@
 #include <asm/uaccess.h>
 //#include <mach/register.h>
 #include <plat/io.h>
-#include "hw/hdmi_tx_reg.h"
+//#include "hw/hdmi_tx_reg.h"
 #include <crypto/hash.h>
 #include <linux/crypto.h>
 #include <linux/scatterlist.h>
 #include <mach/am_regs.h>
 
-#include "hdmi_tx_module.h"
-#include "hdmi_info_global.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 
 #define CEA_DATA_BLOCK_COLLECTION_ADDR_1StP 0x04
 #define VIDEO_TAG 0x40
@@ -55,17 +55,17 @@ static int Edid_DecodeHeader(HDMI_TX_INFO_t *info, unsigned char *buff)
     {
         for(i = 1; i < 7; i++){
            if(buff[i]!= 0xFF)
-           	{
-			    info->output_state = CABLE_PLUGIN_DVI_OUT;
+               {
+                info->output_state = CABLE_PLUGIN_DVI_OUT;
                 ret = -1;
-           	}
+               }
         }
     }
     else
-    	{
-		    info->output_state = CABLE_PLUGIN_DVI_OUT;
+        {
+            info->output_state = CABLE_PLUGIN_DVI_OUT;
             ret = -1;
-    	}
+        }
     return ret;
 }
 
@@ -126,70 +126,70 @@ void Edid_DecodeStandardTiming(HDMI_TX_INFO_t * info, unsigned char * Data, unsi
              frame_rate = (int)((Data[i*2 + 1])& 0x3F) + 60;
 
              if((hor_pixel == 720) && (frame_rate == 30))
-             	{
-             	  info->hdmi_sup_480i  = 1;
-             	}
+                 {
+                   info->hdmi_sup_480i  = 1;
+                 }
 
              else if((hor_pixel == 720) && (frame_rate == 25))
-        	    {
-             	  info->hdmi_sup_576i  = 1;
-             	}
+                {
+                   info->hdmi_sup_576i  = 1;
+                 }
 
              else if((hor_pixel == 720) && (frame_rate == 60))
-        	    {
-             	  info->hdmi_sup_480p  = 1;
-//             	  if(TmpVal==0x40)
-//             	  	info->video_480p.support_4_3  = 1;
-//             	  else if(TmpVal==0xc0)
-//             	  	info->video_480p.support_16_9  = 1;
-             	}
+                {
+                   info->hdmi_sup_480p  = 1;
+//                   if(TmpVal==0x40)
+//                       info->video_480p.support_4_3  = 1;
+//                   else if(TmpVal==0xc0)
+//                       info->video_480p.support_16_9  = 1;
+                 }
 
              else if((hor_pixel == 720) && (frame_rate == 50))
-        	   {
-             	  info->hdmi_sup_576p  = 1;
-             	}
+               {
+                   info->hdmi_sup_576p  = 1;
+                 }
 
              else if((hor_pixel == 1280) && (frame_rate == 60))
              {
-             	  info->hdmi_sup_720p_60hz  = 1;
-             	}
+                   info->hdmi_sup_720p_60hz  = 1;
+                 }
 
              else if((hor_pixel == 1280) && (frame_rate == 50))
              {
-             	  info->hdmi_sup_720p_50hz  = 1;
-             	}
+                   info->hdmi_sup_720p_50hz  = 1;
+                 }
 
              else if((hor_pixel == 1920) && (frame_rate == 30))
              {
-             	  info->hdmi_sup_1080i_60hz  = 1;
-             	}
+                   info->hdmi_sup_1080i_60hz  = 1;
+                 }
 
              else if((hor_pixel == 1920) && (frame_rate == 25))
              {
-             	  info->hdmi_sup_1080i_50hz  = 1;
-             	}
+                   info->hdmi_sup_1080i_50hz  = 1;
+                 }
 
              else if((hor_pixel == 1920) && (frame_rate == 60))
              {
-             	  info->hdmi_sup_1080p_60hz  = 1;
-             	}
+                   info->hdmi_sup_1080p_60hz  = 1;
+                 }
 
              else if((hor_pixel == 1920) && (frame_rate == 50))
              {
-             	  info->hdmi_sup_1080p_50hz  = 1;
-             	}
+                   info->hdmi_sup_1080p_50hz  = 1;
+                 }
              else if((hor_pixel == 1920) && (frame_rate == 24))
              {
-             	  info->hdmi_sup_1080p_24hz  = 1;
-             	}
+                   info->hdmi_sup_1080p_24hz  = 1;
+                 }
              else if((hor_pixel == 1920) && (frame_rate == 25))
              {
-             	  info->hdmi_sup_1080p_25hz  = 1;
-             	}
+                   info->hdmi_sup_1080p_25hz  = 1;
+                 }
              else if((hor_pixel == 1920) && (frame_rate == 30))
              {
-             	  info->hdmi_sup_1080p_30hz  = 1;
-             	}
+                   info->hdmi_sup_1080p_30hz  = 1;
+                 }
 
           }
      }
@@ -223,7 +223,7 @@ void Edid_CompareTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char *Data)
 {
    int index1,index2;
 
-	for(index1=0;index1<17;index1++)
+    for(index1=0;index1<17;index1++)
     {
         for(index2=0;index2<12;index2++)
         {
@@ -241,12 +241,12 @@ void Edid_CompareTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char *Data)
 
                 case 2:
                 case 3:
-             	    info->hdmi_sup_576i  = 1;
+                     info->hdmi_sup_576i  = 1;
                    break;
 
                 case 4:
                 case 5:
-             	    info->hdmi_sup_480p  = 1;
+                     info->hdmi_sup_480p  = 1;
 //                  if((Data[12]==Edid_TimingDescriptors[4*14 + 12]) && (Data[13]==Edid_TimingDescriptors[4*14 + 13]))
 //                     info->video_480p.support_4_3  = 1;
 //                  else if((Data[12]==Edid_TimingDescriptors[5*14 + 12]) && (Data[13]==Edid_TimingDescriptors[5*14 + 13]))
@@ -255,48 +255,48 @@ void Edid_CompareTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char *Data)
 
                 case 6:
                 case 7:
-             	    info->hdmi_sup_576p  = 1;
+                     info->hdmi_sup_576p  = 1;
                     break;
 
                 case 8:
-             	    info->hdmi_sup_720p_60hz  = 1;
-             	  	break;
+                     info->hdmi_sup_720p_60hz  = 1;
+                       break;
 
-	            case 9:
-             	    info->hdmi_sup_720p_50hz  = 1;
-             	  	break;
+                case 9:
+                     info->hdmi_sup_720p_50hz  = 1;
+                       break;
 
                 case 10:
-             	    info->hdmi_sup_1080i_60hz  = 1;
-             	  	break;
+                     info->hdmi_sup_1080i_60hz  = 1;
+                       break;
 
                 case 11:
-             	    info->hdmi_sup_1080i_50hz  = 1;
+                     info->hdmi_sup_1080i_50hz  = 1;
                     break;
 
                 case 12:
-             	    info->hdmi_sup_1080p_60hz  = 1;
-					break;
+                     info->hdmi_sup_1080p_60hz  = 1;
+                    break;
 
                 case 13:
-             	    info->hdmi_sup_1080p_50hz  = 1;
-					break;
+                     info->hdmi_sup_1080p_50hz  = 1;
+                    break;
 
                 case 14:
-             	    info->hdmi_sup_1080p_24hz  = 1;
+                     info->hdmi_sup_1080p_24hz  = 1;
                     break;
 
                 case 15:
-             	    info->hdmi_sup_1080p_25hz  = 1;
+                     info->hdmi_sup_1080p_25hz  = 1;
                     break;
 
                 case 16:
-             	    info->hdmi_sup_1080p_30hz  = 1;
+                     info->hdmi_sup_1080p_30hz  = 1;
                     break;
                 default:
                     break;
             }
-			break;
+            break;
         }
     }
 }
@@ -305,14 +305,14 @@ void Edid_CompareTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char *Data)
 //-----------------------------------------------------------
 void Edid_ParseCEADetailedTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char blk_mun, unsigned char BaseAddr, unsigned char *buff)
 {
-	unsigned char index_edid;
+    unsigned char index_edid;
 
-	for( index_edid = 0; index_edid < blk_mun; index_edid++)
+    for( index_edid = 0; index_edid < blk_mun; index_edid++)
     {
         Edid_CompareTimingDescriptors(info, &buff[BaseAddr]);
         BaseAddr += 18;
        if((BaseAddr + 18) > 0x7d)   //there is not the TimingDescriptors
-				break;
+                break;
       }
 
 }
@@ -325,70 +325,63 @@ int get_vsdb_phy_addr(vsdb_phy_addr_t * vsdb)
 
 void set_vsdb_phy_addr(vsdb_phy_addr_t * vsdb, unsigned char *edid_offset)
 {
-	vsdb->a = (edid_offset[4] >> 4 ) & 0xf;
-	vsdb->b = (edid_offset[4] >> 0 ) & 0xf;
-	vsdb->c = (edid_offset[5] >> 4 ) & 0xf;
-	vsdb->d = (edid_offset[5] >> 0 ) & 0xf;
-	vsdb_local = *vsdb;
-	vsdb->valid = 1;
+    vsdb->a = (edid_offset[4] >> 4 ) & 0xf;
+    vsdb->b = (edid_offset[4] >> 0 ) & 0xf;
+    vsdb->c = (edid_offset[5] >> 4 ) & 0xf;
+    vsdb->d = (edid_offset[5] >> 0 ) & 0xf;
+    vsdb_local = *vsdb;
+    vsdb->valid = 1;
 }
 
 int Edid_Parse_check_HDMI_VSDB(HDMI_TX_INFO_t * info, unsigned char *buff)
 {
-	unsigned char  VSpecificBoundary, BlockAddr,  len;
-	int temp_addr=0;
-	VSpecificBoundary = buff[2] ;
-	if(VSpecificBoundary < 4)
-	{
-		info->output_state = CABLE_PLUGIN_DVI_OUT;
-		return -1;
-	}
-	BlockAddr = CEA_DATA_BLOCK_COLLECTION_ADDR_1StP;
-	while( BlockAddr < VSpecificBoundary) {
-		len = buff[BlockAddr] & 0x1F;
-             if((buff[BlockAddr] & 0xE0)== VENDOR_TAG){		//find the HDMI Vendor Specific Data Block
-                	break;
-		}
-		temp_addr = 	BlockAddr + len + 1;
-		if(temp_addr >= VSpecificBoundary)
-			break;
-		BlockAddr = BlockAddr + len + 1;
-	}
+    unsigned char  VSpecificBoundary, BlockAddr,  len;
+    int temp_addr=0;
+    VSpecificBoundary = buff[2] ;
+    if(VSpecificBoundary < 4)
+    {
+        info->output_state = CABLE_PLUGIN_DVI_OUT;
+        return -1;
+    }
+    BlockAddr = CEA_DATA_BLOCK_COLLECTION_ADDR_1StP;
+    while( BlockAddr < VSpecificBoundary) {
+        len = buff[BlockAddr] & 0x1F;
+             if((buff[BlockAddr] & 0xE0)== VENDOR_TAG){        //find the HDMI Vendor Specific Data Block
+                    break;
+        }
+        temp_addr =     BlockAddr + len + 1;
+        if(temp_addr >= VSpecificBoundary)
+            break;
+        BlockAddr = BlockAddr + len + 1;
+    }
 
     set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
-	if(info->vsdb_phy_addr.a == 0) {
-		printk("CEC: not a valid physical address\n");
-	}
+    if(info->vsdb_phy_addr.a == 0) {
+        hdmi_print(IMP, EDID "not a valid CEC physical address\n");
+    }
     else {
         vsdb_phy_addr_t *tmp = &info->vsdb_phy_addr;
         if(tmp->valid){
             aml_write_reg32(P_AO_DEBUG_REG1, (((tmp->a) & 0xf) << 12) | (((tmp->b) & 0xf) << 8) | (((tmp->c) & 0xf) << 4) | ((tmp->d) & 0xf));
-            printk("CEC: Physical address: 0x%x\n",aml_read_reg32(P_AO_DEBUG_REG1));
-            printk("CEC: Physical address: %1x.%1x.%1x.%1x\n", tmp->a, tmp->b, tmp->c, tmp->d);
+            hdmi_print(IMP, EDID "CEC Physical address: 0x%x\n",aml_read_reg32(P_AO_DEBUG_REG1));
+            hdmi_print(IMP, EDID "CEC Physical address: %1x.%1x.%1x.%1x\n", tmp->a, tmp->b, tmp->c, tmp->d);
         }
     }
 
-	//For test only.
-	hdmi_print(0,"HDMI DEBUG [%s]\n", __FUNCTION__);
-    hdmi_print(0,"max_tmds_clk_7:%d\n",buff[BlockAddr + 7]);
-    hdmi_print(0,"Field 8:%d\n",buff[BlockAddr + 8]);
-    hdmi_print(0,"video_latency_9:%d\n",buff[BlockAddr + 9]);
-    hdmi_print(0,"audio_latency_10:%d\n",buff[BlockAddr + 10]);
-
-	if(temp_addr >= VSpecificBoundary)
-	{
-		info->output_state = CABLE_PLUGIN_DVI_OUT;
-		return -1;
-	}
-	else
-	{
-		if((buff[BlockAddr + 1]!= 0x03)||(buff[BlockAddr + 2]!= 0x0C)||(buff[BlockAddr + 3]!= 0x0))
-		{
-			info->output_state = CABLE_PLUGIN_DVI_OUT;
-			return -1;
-		}
-	}
-	return 0;
+    if(temp_addr >= VSpecificBoundary)
+    {
+        info->output_state = CABLE_PLUGIN_DVI_OUT;
+        return -1;
+    }
+    else
+    {
+        if((buff[BlockAddr + 1]!= 0x03)||(buff[BlockAddr + 2]!= 0x0C)||(buff[BlockAddr + 3]!= 0x0))
+        {
+            info->output_state = CABLE_PLUGIN_DVI_OUT;
+            return -1;
+        }
+    }
+    return 0;
 }
 
 //-----------------------------------------------------------
@@ -399,15 +392,15 @@ void Edid_MonitorCapable861(HDMI_TX_INFO_t * info, unsigned char edid_flag)
      if(edid_flag & 0x40)
         info->support_basic_audio_flag =1;
      if(edid_flag & 0x20)
-     	{
-        	info->support_ycbcr444_flag =1;
-//        	info->videopath_outindex = 1;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
+         {
+            info->support_ycbcr444_flag =1;
+//            info->videopath_outindex = 1;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
       }
      if(edid_flag & 0x10)
-     	{
-        	info->support_ycbcr422_flag =1 ;
-//       	 if(!(edid_flag & 0x20))
-//        		info->videopath_outindex = 2;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
+         {
+            info->support_ycbcr422_flag =1 ;
+//            if(!(edid_flag & 0x20))
+//                info->videopath_outindex = 2;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
       }
 }
 
@@ -419,8 +412,8 @@ static void Edid_ParsingVideoDATABlock(HDMI_TX_INFO_t * info, unsigned char *buf
     NBytes &= 0x1F;
     for(i = 0; i < NBytes; i++)
       {
-		switch(buff[i + BaseAddr]&0x7F)
-		{
+        switch(buff[i + BaseAddr]&0x7F)
+        {
             case 6:
             case 7:
                 info->hdmi_sup_480i  = 1;
@@ -429,12 +422,12 @@ static void Edid_ParsingVideoDATABlock(HDMI_TX_INFO_t * info, unsigned char *buf
             case 21:
             case 22:
                 info->hdmi_sup_576i  = 1;
-			  	break;
+                  break;
 
             case 2:
             case 3:
                 info->hdmi_sup_480p  = 1;
-				break;
+                break;
 
             case 17:
             case 18:
@@ -484,301 +477,301 @@ static void Edid_ParsingVideoDATABlock(HDMI_TX_INFO_t * info, unsigned char *buf
 //-----------------------------------------------------------
 static void Edid_ParsingAudioDATABlock(HDMI_TX_INFO_t * info, unsigned char *Data, unsigned char BaseAddr, unsigned char NBytes)
 {
-	 unsigned char AudioFormatCode;
-	 int i = BaseAddr ;
+     unsigned char AudioFormatCode;
+     int i = BaseAddr ;
    NBytes&=0x1F;
    do{
         AudioFormatCode = (Data[i]&0xF8)>>3;
         switch(AudioFormatCode)
           {
                 case 1:
-       	              info->tv_audio_info._60958_PCM.support_flag = 1;
-       	              info->tv_audio_info._60958_PCM.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._60958_PCM._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._60958_PCM._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._60958_PCM._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._60958_PCM._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._60958_PCM._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._60958_PCM._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._60958_PCM._32k = 1;
-       	              if((Data[i+2]&0x04))
-       	              	info->tv_audio_info._60958_PCM._24bit = 1;
-       	              if((Data[i+2]&0x02))
-       	              	info->tv_audio_info._60958_PCM._20bit = 1;
-       	              if((Data[i+2]&0x01))
-       	              	info->tv_audio_info._60958_PCM._16bit = 1;
-                     	break;
+                         info->tv_audio_info._60958_PCM.support_flag = 1;
+                         info->tv_audio_info._60958_PCM.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._60958_PCM._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._60958_PCM._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._60958_PCM._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._60958_PCM._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._60958_PCM._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._60958_PCM._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._60958_PCM._32k = 1;
+                         if((Data[i+2]&0x04))
+                             info->tv_audio_info._60958_PCM._24bit = 1;
+                         if((Data[i+2]&0x02))
+                             info->tv_audio_info._60958_PCM._20bit = 1;
+                         if((Data[i+2]&0x01))
+                             info->tv_audio_info._60958_PCM._16bit = 1;
+                         break;
 
                 case 2:
-       	              info->tv_audio_info._AC3.support_flag = 1;
-       	              info->tv_audio_info._AC3.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._AC3._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._AC3._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._AC3._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._AC3._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._AC3._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._AC3._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._AC3._32k = 1;
-       	              info->tv_audio_info._AC3._max_bit = Data[i+2];
-                     	break;
+                         info->tv_audio_info._AC3.support_flag = 1;
+                         info->tv_audio_info._AC3.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._AC3._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._AC3._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._AC3._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._AC3._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._AC3._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._AC3._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._AC3._32k = 1;
+                         info->tv_audio_info._AC3._max_bit = Data[i+2];
+                         break;
 
                 case 3:
-       	              info->tv_audio_info._MPEG1.support_flag = 1;
-       	              info->tv_audio_info._MPEG1.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._MPEG1._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._MPEG1._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._MPEG1._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._MPEG1._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._MPEG1._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._MPEG1._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._MPEG1._32k = 1;
-       	              info->tv_audio_info._MPEG1._max_bit = Data[i+2];
-                     	break;
+                         info->tv_audio_info._MPEG1.support_flag = 1;
+                         info->tv_audio_info._MPEG1.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MPEG1._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MPEG1._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MPEG1._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MPEG1._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MPEG1._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MPEG1._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MPEG1._32k = 1;
+                         info->tv_audio_info._MPEG1._max_bit = Data[i+2];
+                         break;
 
                 case 4:
-       	              info->tv_audio_info._MP3.support_flag = 1;
-       	              info->tv_audio_info._MP3.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._MP3._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._MP3._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._MP3._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._MP3._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._MP3._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._MP3._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._MP3._32k = 1;
-       	              info->tv_audio_info._MP3._max_bit = Data[i+2];
-                     	break;
+                         info->tv_audio_info._MP3.support_flag = 1;
+                         info->tv_audio_info._MP3.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MP3._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MP3._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MP3._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MP3._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MP3._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MP3._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MP3._32k = 1;
+                         info->tv_audio_info._MP3._max_bit = Data[i+2];
+                         break;
 
                 case 5:
-        	            info->tv_audio_info._MPEG2.support_flag = 1;
-       	              info->tv_audio_info._MPEG2.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._MPEG2._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._MPEG2._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._MPEG2._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._MPEG2._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._MPEG2._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._MPEG2._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._MPEG2._32k = 1;
-       	              info->tv_audio_info._MPEG2._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._MPEG2.support_flag = 1;
+                         info->tv_audio_info._MPEG2.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MPEG2._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MPEG2._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MPEG2._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MPEG2._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MPEG2._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MPEG2._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MPEG2._32k = 1;
+                         info->tv_audio_info._MPEG2._max_bit = Data[i+2];
+                         break;
 
                 case 6:
-        	            info->tv_audio_info._AAC.support_flag = 1;
-       	              info->tv_audio_info._AAC.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._AAC._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._AAC._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._AAC._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._AAC._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._AAC._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._AAC._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._AAC._32k = 1;
-       	              info->tv_audio_info._AAC._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._AAC.support_flag = 1;
+                         info->tv_audio_info._AAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._AAC._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._AAC._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._AAC._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._AAC._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._AAC._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._AAC._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._AAC._32k = 1;
+                         info->tv_audio_info._AAC._max_bit = Data[i+2];
+                         break;
 
                 case 7:
-        	            info->tv_audio_info._DTS.support_flag = 1;
-       	              info->tv_audio_info._DTS.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._DTS._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._DTS._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._DTS._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._DTS._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._DTS._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._DTS._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._DTS._32k = 1;
-       	              info->tv_audio_info._DTS._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._DTS.support_flag = 1;
+                         info->tv_audio_info._DTS.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DTS._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DTS._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DTS._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DTS._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DTS._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DTS._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DTS._32k = 1;
+                         info->tv_audio_info._DTS._max_bit = Data[i+2];
+                         break;
 
                 case 8:
-        	            info->tv_audio_info._ATRAC.support_flag = 1;
-       	              info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._ATRAC._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._ATRAC._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._ATRAC._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._ATRAC._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._ATRAC._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._ATRAC._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._ATRAC._32k = 1;
-       	              info->tv_audio_info._ATRAC._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._ATRAC.support_flag = 1;
+                         info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._ATRAC._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._ATRAC._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._ATRAC._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._ATRAC._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._ATRAC._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._ATRAC._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._ATRAC._32k = 1;
+                         info->tv_audio_info._ATRAC._max_bit = Data[i+2];
+                         break;
 
                 case 9:
-        	            info->tv_audio_info._One_Bit_Audio.support_flag = 1;
-       	              info->tv_audio_info._One_Bit_Audio.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._One_Bit_Audio._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._One_Bit_Audio._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._One_Bit_Audio._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._One_Bit_Audio._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._One_Bit_Audio._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._One_Bit_Audio._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._One_Bit_Audio._32k = 1;
-       	              info->tv_audio_info._One_Bit_Audio._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._One_Bit_Audio.support_flag = 1;
+                         info->tv_audio_info._One_Bit_Audio.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._One_Bit_Audio._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._One_Bit_Audio._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._One_Bit_Audio._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._One_Bit_Audio._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._One_Bit_Audio._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._One_Bit_Audio._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._One_Bit_Audio._32k = 1;
+                         info->tv_audio_info._One_Bit_Audio._max_bit = Data[i+2];
+                         break;
 
                 case 10:
-        	            info->tv_audio_info._Dolby.support_flag = 1;
-       	              info->tv_audio_info._Dolby.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._Dolby._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._Dolby._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._Dolby._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._Dolby._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._Dolby._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._Dolby._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._Dolby._32k = 1;
-       	              info->tv_audio_info._Dolby._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._Dolby.support_flag = 1;
+                         info->tv_audio_info._Dolby.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._Dolby._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._Dolby._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._Dolby._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._Dolby._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._Dolby._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._Dolby._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._Dolby._32k = 1;
+                         info->tv_audio_info._Dolby._max_bit = Data[i+2];
+                         break;
 
                 case 11:
-        	            info->tv_audio_info._DTS_HD.support_flag = 1;
-       	              info->tv_audio_info._DTS_HD.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._DTS_HD._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._DTS_HD._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._DTS_HD._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._DTS_HD._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._DTS_HD._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._DTS_HD._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._DTS_HD._32k = 1;
-       	              info->tv_audio_info._DTS_HD._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._DTS_HD.support_flag = 1;
+                         info->tv_audio_info._DTS_HD.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DTS_HD._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DTS_HD._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DTS_HD._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DTS_HD._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DTS_HD._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DTS_HD._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DTS_HD._32k = 1;
+                         info->tv_audio_info._DTS_HD._max_bit = Data[i+2];
+                         break;
 
 
                 case 12:
-        	            info->tv_audio_info._MAT.support_flag = 1;
-       	              info->tv_audio_info._MAT.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._MAT._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._MAT._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._MAT._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._MAT._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._MAT._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._MAT._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._MAT._32k = 1;
-       	              info->tv_audio_info._MAT._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._MAT.support_flag = 1;
+                         info->tv_audio_info._MAT.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MAT._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MAT._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MAT._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MAT._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MAT._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MAT._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MAT._32k = 1;
+                         info->tv_audio_info._MAT._max_bit = Data[i+2];
+                         break;
 
                 case 13:
-        	            info->tv_audio_info._ATRAC.support_flag = 1;
-       	              info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._DST._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._DST._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._DST._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._DST._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._DST._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._DST._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._DST._32k = 1;
-       	              info->tv_audio_info._DST._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._ATRAC.support_flag = 1;
+                         info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DST._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DST._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DST._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DST._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DST._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DST._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DST._32k = 1;
+                         info->tv_audio_info._DST._max_bit = Data[i+2];
+                         break;
 
                 case 14:
-        	            info->tv_audio_info._WMA.support_flag = 1;
-       	              info->tv_audio_info._WMA.max_channel_num = (Data[i]&0x07);
-       	              if((Data[i+1]&0x40))
-       	              	info->tv_audio_info._WMA._192k = 1;
-       	              if((Data[i+1]&0x20))
-       	              	info->tv_audio_info._WMA._176k = 1;
-       	              if((Data[i+1]&0x10))
-       	              	info->tv_audio_info._WMA._96k = 1;
-       	              if((Data[i+1]&0x08))
-       	              	info->tv_audio_info._WMA._88k = 1;
-       	              if((Data[i+1]&0x04))
-       	              	info->tv_audio_info._WMA._48k = 1;
-       	              if((Data[i+1]&0x02))
-       	              	info->tv_audio_info._WMA._44k = 1;
-       	              if((Data[i+1]&0x01))
-       	              	info->tv_audio_info._WMA._32k = 1;
-       	              info->tv_audio_info._WMA._max_bit = Data[i+2];
-                     	break;
+                        info->tv_audio_info._WMA.support_flag = 1;
+                         info->tv_audio_info._WMA.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._WMA._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._WMA._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._WMA._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._WMA._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._WMA._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._WMA._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._WMA._32k = 1;
+                         info->tv_audio_info._WMA._max_bit = Data[i+2];
+                         break;
 
                 default:
-       	              break;
+                         break;
                  }
                 i+=3;
       }while (i < (NBytes + BaseAddr));
@@ -792,36 +785,36 @@ static void Edid_ParsingSpeakerDATABlock(HDMI_TX_INFO_t * info, unsigned char *b
    {
      switch(buff[BaseAddr] & ii)
       {
-        	case 0x40:
-        		info->tv_audio_info.speaker_allocation.rlc_rrc = 1;
-        		break;
+            case 0x40:
+                info->tv_audio_info.speaker_allocation.rlc_rrc = 1;
+                break;
 
-        	case 0x20:
-        		info->tv_audio_info.speaker_allocation.flc_frc = 1;
-        		break;
+            case 0x20:
+                info->tv_audio_info.speaker_allocation.flc_frc = 1;
+                break;
 
-        	case 0x10:
-        		info->tv_audio_info.speaker_allocation.rc = 1;
-        		break;
+            case 0x10:
+                info->tv_audio_info.speaker_allocation.rc = 1;
+                break;
 
-        	case 0x08:
-        		info->tv_audio_info.speaker_allocation.rl_rr = 1;
-        		break;
+            case 0x08:
+                info->tv_audio_info.speaker_allocation.rl_rr = 1;
+                break;
 
-        	case 0x04:
-        		info->tv_audio_info.speaker_allocation.fc = 1;
-        		break;
+            case 0x04:
+                info->tv_audio_info.speaker_allocation.fc = 1;
+                break;
 
-        	case 0x02:
-        		info->tv_audio_info.speaker_allocation.lfe = 1;
-        		break;
+            case 0x02:
+                info->tv_audio_info.speaker_allocation.lfe = 1;
+                break;
 
-        	case 0x01:
-        		info->tv_audio_info.speaker_allocation.fl_fr = 1;
-        		break;
+            case 0x01:
+                info->tv_audio_info.speaker_allocation.fl_fr = 1;
+                break;
 
           default :
-          	break;
+              break;
        }
        ii = ii << 1;
      }
@@ -845,34 +838,34 @@ int Edid_ParsingCEADataBlockCollection(HDMI_TX_INFO_t * info, unsigned char *buf
         {
             case VIDEO_TAG:
                 if((Addr + (Data&0x1f)) < D)
-              	    Edid_ParsingVideoDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
+                      Edid_ParsingVideoDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
                 break;
 
             case AUDIO_TAG:
                 if((Addr + (Data&0x1f)) < D)
-              	    Edid_ParsingAudioDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
+                      Edid_ParsingAudioDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
                 break;
 
             case SPEAKER_TAG:
                 if((Addr + (Data&0x1f)) < D)
-              	    Edid_ParsingSpeakerDATABlock(info, buff, Addr + 1 );
+                      Edid_ParsingSpeakerDATABlock(info, buff, Addr + 1 );
                 break;
 
             case VENDOR_TAG:
                 if((Addr + (Data&0x1f)) < D)
                 {
-           	  	    if((buff[Addr + 1] != 0x03) || (buff[Addr + 2] != 0x0c) || (buff[Addr + 3] != 0x00))
-           	  	    {
-           	  	 	    info->auth_state = HDCP_NO_AUTH ;
-           	  	 	    info->output_state = CABLE_PLUGIN_DVI_OUT;
-           	  	    }
-          		    if((Data&0x1f) > 5)
-          		    {
-            		 //A Source shall not transmit an ISRC1 or ISRC2 Packet to a Sink that does not have Supports_AI = 1
-            		 //International Standard Recording Code (ISRC)
-          			    if(buff[Addr + 6] & 0x80)
-          				    info->support_ai_flag = 1;
-          		    }
+                         if((buff[Addr + 1] != 0x03) || (buff[Addr + 2] != 0x0c) || (buff[Addr + 3] != 0x00))
+                         {
+                              info->auth_state = HDCP_NO_AUTH ;
+                              info->output_state = CABLE_PLUGIN_DVI_OUT;
+                         }
+                      if((Data&0x1f) > 5)
+                      {
+                     //A Source shall not transmit an ISRC1 or ISRC2 Packet to a Sink that does not have Supports_AI = 1
+                     //International Standard Recording Code (ISRC)
+                          if(buff[Addr + 6] & 0x80)
+                              info->support_ai_flag = 1;
+                      }
                 }
                 break;
 
@@ -881,9 +874,9 @@ int Edid_ParsingCEADataBlockCollection(HDMI_TX_INFO_t * info, unsigned char *buf
           }
           Addr += ( Data & 0x1F ) ;   // next Tag Address
           AddrTag = ++Addr;
-		temp_addr =   Addr + ( Data & 0x1F ) ;
-		if(temp_addr >= D)	//force to break;
-			break;
+        temp_addr =   Addr + ( Data & 0x1F ) ;
+        if(temp_addr >= D)    //force to break;
+            break;
      }while (Addr < D);
 
    return 0;
@@ -955,7 +948,7 @@ static int hdmitx_edid_3d_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigned s
 static void hdmitx_edid_4k2k_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigned size)
 {
     if((size > 4) || (size == 0)) {
-        printk("HDMI: 4k2k in edid out of range, SIZE = %d\n", size);
+        hdmi_print(ERR, EDID "HDMI: 4k2k in edid out of range, SIZE = %d\n", size);
         return;
     }
     while(size--) {
@@ -966,7 +959,7 @@ static void hdmitx_edid_4k2k_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigne
         else if(*dat == 3)
             pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_24;
         else if(*dat == 4)
-            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_smpte;
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_smpte_24;
         else {
         }
         dat ++;
@@ -987,7 +980,7 @@ static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *B
     End = BlockBuf[2]  ; // CEA description.
     pRXCap->native_Mode = BlockBuf[3] ;
 
-	  pRXCap->VIC_count = 0 ;
+      pRXCap->VIC_count = 0 ;
     pRXCap->native_VIC = 0xff ;
     for( offset = 4 ; offset < End ; ){
         tag = BlockBuf[offset] >> 5 ;
@@ -1102,7 +1095,7 @@ static void hdmitx_edid_set_default_vic(hdmitx_dev_t* hdmitx_device)
     pRXCap->VIC[2] = 16;
     pRXCap->native_VIC = 4;
     hdmitx_device->vic_count = pRXCap->VIC_count;
-    printk("HDMI: set default vic\n");
+    hdmi_print(IMP, EDID "HDMI: set default vic\n");
 }
 
 #if 0
@@ -1168,7 +1161,7 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
         hdmi_print(0, "PLUGIN_DVI_OUT\n");
 //        return -1 ;
     }
-	
+    
     Edid_ReceiverBrandNameParse(&hdmitx_device->RXCap, &EDID_buf[8]);
 
     idx[0] = EDID_DETAILED_TIMING_DES_BLOCK0_POS;
@@ -1197,7 +1190,7 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
             if(EDID_buf[i] == 0)
                 zero_numbers ++;
         }
-        printk("HDMI: edid blk0 checksum:%d ext_flag:%d\n",CheckSum, EDID_buf[0x7e]);
+        hdmi_print(INF, EDID "edid blk0 checksum:%d ext_flag:%d\n",CheckSum, EDID_buf[0x7e]);
         if((CheckSum & 0xff) == 0) {
             hdmitx_device->RXCap.IEEEOUI = 0;
         } else {
@@ -1218,7 +1211,7 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
     {
         BlockCount = EDID_MAX_BLOCK ;
     }
-        	
+
     for( i = 1 ; i <= BlockCount ; i++ )
     {
 
@@ -1247,7 +1240,6 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
                 Edid_ParseCEADetailedTimingDescriptors(&hdmitx_device->hdmi_info, 5, EDID_buf[i * 128 + 2], &EDID_buf[i * 128]);
                 if(hdmitx_device->hdmi_info.output_state != CABLE_PLUGIN_DVI_OUT)
                     hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_HDMI_OUT;
-
             }
 
         }
@@ -1269,7 +1261,6 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
 #if 1    
     i=hdmitx_edid_dump(hdmitx_device, (char*)(hdmitx_device->tmp_buf), HDMI_TMP_BUF_SIZE);
     hdmitx_device->tmp_buf[i]=0;
-    hdmi_print_buf((char*)(hdmitx_device->tmp_buf), strlen((char*)(hdmitx_device->tmp_buf)));
     hdmi_print(0,"\n");
 #endif    
     return 0;
@@ -1302,7 +1293,7 @@ static dispmode_vic_t dispmode_VIC_tab[]=
     {"4k2k30hz", HDMI_4k2k_30},
     {"4k2k25hz", HDMI_4k2k_25},
     {"4k2k24hz", HDMI_4k2k_24},
-    {"4k2ksmpte", HDMI_4k2k_smpte},
+    {"4k2ksmpte", HDMI_4k2k_smpte_24},
 };
 
 HDMI_Video_Codes_t hdmitx_get_VIC(hdmitx_dev_t* hdmitx_device, const char* disp_mode)
@@ -1328,7 +1319,7 @@ HDMI_Video_Codes_t hdmitx_edid_get_VIC(hdmitx_dev_t* hdmitx_device, const char*
     int count=ARRAY_SIZE(dispmode_VIC_tab);
     HDMI_Video_Codes_t vic=HDMI_Unkown;
     int mode_name_len=0;
-    //printk("disp_mode is %s\n", disp_mode);
+
     for(i=0;i<count;i++)
     {
         if(strncmp(disp_mode, dispmode_VIC_tab[i].disp_mode, strlen(dispmode_VIC_tab[i].disp_mode))==0)
@@ -1369,17 +1360,14 @@ char* hdmitx_edid_get_native_VIC(hdmitx_dev_t* hdmitx_device)
     return disp_mode_ret;
 }    
 
-#define EDID_RAM_ADDR_SIZE      (4*128)
 //Clear HDMI Hardware Module EDID RAM and EDID Buffer
 void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t* hdmitx_device)
 {
     unsigned int i = 0;
     
     //Clear HDMI Hardware Module EDID RAM
-    for(i = 0; i < EDID_RAM_ADDR_SIZE; i++)
-    {
-        hdmi_wr_reg(TX_RX_EDID_OFFSET + i, 0);
-    }
+    hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_CLEAR_RAM, 0);
+    
     //Clear EDID Buffer
     for(i = 0; i < EDID_MAX_BLOCK*128; i++)
     {
@@ -1432,7 +1420,7 @@ int hdmitx_edid_dump(hdmitx_dev_t* hdmitx_device, char* buffer, int buffer_len)
     pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\r\n",hdmitx_device->EDID_buf[0x7e]);
 
     pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\r\n",
-    	hdmitx_device->hdmi_info.vsdb_phy_addr.a, hdmitx_device->hdmi_info.vsdb_phy_addr.b, hdmitx_device->hdmi_info.vsdb_phy_addr.c, hdmitx_device->hdmi_info.vsdb_phy_addr.d);
+        hdmitx_device->hdmi_info.vsdb_phy_addr.a, hdmitx_device->hdmi_info.vsdb_phy_addr.b, hdmitx_device->hdmi_info.vsdb_phy_addr.c, hdmitx_device->hdmi_info.vsdb_phy_addr.d);
 
     pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\r\n",
         pRXCap->native_Mode, pRXCap->native_VIC);
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c
index 987e5bcd06e6..f1d834599416 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c
@@ -14,10 +14,9 @@
 //#include <linux/amports/canvas.h>
 #include <asm/uaccess.h>
 #include <mach/am_regs.h>
-
-#include "hdmi_info_global.h"
-#include "hdmi_tx_module.h"
-#include "hw/hdmi_tx_reg.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <mach/hdmi_tx_reg.h>
 #include "hdmi_tx_hdcp.h"
 /*
     hdmi_tx_hdcp.c
@@ -28,38 +27,6 @@
 // On MBX project, it is too late for HDCP get from 
 // other devices
 
-// buf: store buffer
-// endian: 0: little endian  1: big endian
-void hdmi_hdcp_get_aksv(char* buf, int endian)
-{
-    int i;
-    if(endian ==1) {
-        for(i = 0;i < 5; i++) {
-            buf[i] = hdmi_rd_reg(TX_HDCP_SHW_AKSV_0 + i);
-        }
-    }
-    else {
-        for(i = 0;i < 5; i++) {
-            buf[i] = hdmi_rd_reg(TX_HDCP_SHW_AKSV_0 + 4 - i);
-        }
-    }
-}
-
-void hdmi_hdcp_get_bksv(char* buf, int endian)
-{
-    int i;
-    if(endian ==1){
-        for(i = 0;i < 5; i++) {
-            buf[i] = hdmi_rd_reg(TX_HDCP_SHW_BKSV_0 + i);
-        }
-    }
-    else {
-        for(i = 0;i < 5; i++) {
-            buf[i] = hdmi_rd_reg(TX_HDCP_SHW_BKSV_0 + 4 - i);
-        }
-    }
-}
-
 /* verify ksv, 20 ones and 20 zeroes*/
 int hdcp_ksv_valid(unsigned char * dat)
 {
@@ -72,7 +39,7 @@ int hdcp_ksv_valid(unsigned char * dat)
         }
     }
     if(one_num == 0)
-        printk("HDMITX: no HDCP key available\n");
+        hdmi_print(INF, HDCP "no HDCP key available\n");
     return (one_num == 20);
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h
index ba769065aa94..eac0270f0ef3 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h
@@ -6,17 +6,11 @@
 */
 
 // Notic: the HDCP key setting has been moved to uboot
-// On MBX project, it is too late for HDCP get from 
+// On MBX project, it is too late for HDCP get from
 // other devices
 
 //int task_tx_key_setting(unsigned force_wrong);
 
-// buf: store buffer
-// endian: 0: little endian  1: big endian
-void hdmi_hdcp_get_aksv(char* buf, int endian);
-
-void hdmi_hdcp_get_bksv(char* buf, int endian);
-
 int hdcp_ksv_valid(unsigned char * dat);
 
 #endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c
deleted file mode 100755
index 0567a0e1497a..000000000000
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.c
+++ /dev/null
@@ -1,606 +0,0 @@
-#include "hdmi_tx_miniboot.h"
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-#include <linux/proc_fs.h> 
-#include <linux/amlogic/logo/logo.h>
-
-#include <mach/am_regs.h>
-#include <mach/io.h>
-#include <mach/register.h>
-
-#include "hdmi_parameter.h"
-#include "test_prm.h"
-
-#define VFIFO2VD_TO_HDMI_LATENCY    2   // Latency in pixel clock from ENCP_VFIFO2VD request to data ready to HDMI
-    #define NUM_INT_VSYNC   INT_VEC_VIU1_VSYNC
-
-void hdmi_test_function(void);
-unsigned long modulo(unsigned long a, unsigned long b);
-signed int to_signed(unsigned int a);
-
-static void aml_write_reg32_op(unsigned int _reg, const unsigned _value)
-{
-    aml_write_reg32(_reg, _value);
-#ifdef HDMI_MINIBOOT_DEBUG
-    printk(" A:0x%08x 0x%04x  wD:0x%x ", _reg, (_reg & 0xffff)>>2, _value);
-    if(_value == aml_read_reg32(_reg))
-        printk("\n");
-    else
-        printk(" rD: 0x%08x\n", aml_read_reg32(_reg));
-#endif
-}
-
-static unsigned int aml_read_reg32_op(unsigned int _reg)
-{
-    return aml_read_reg32(_reg);
-}
-
-static void aml_set_reg32_bits_op(uint32_t _reg, const uint32_t _val, const uint32_t _start, const uint32_t _len)
-{
-    unsigned int tmp;
-    tmp = (aml_read_reg32(_reg) & ~(((1L<<(_len))-1)<<(_start))) | ((unsigned int)(_val) << (_start));
-    aml_write_reg32_op(_reg, tmp);
-}
-
-static void hdmi_wr_reg(unsigned long addr, unsigned long data)
-{
-    aml_write_reg32_op(P_HDMI_ADDR_PORT, addr);
-    aml_write_reg32_op(P_HDMI_ADDR_PORT, addr);
-    aml_write_reg32_op(P_HDMI_DATA_PORT, data);
-}
-//FILE: test.c
-
-// --------------------------------------------------------
-//                     C_Entry
-// --------------------------------------------------------
-unsigned char   field_n = 0;
-
-void set_hdmi_enc(void)
-{
-    unsigned long total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
-    unsigned long active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
-    unsigned long front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
-    unsigned long hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
-
-    unsigned long de_h_begin, de_h_end;
-    unsigned long de_v_begin_even, de_v_end_even, de_v_begin_odd, de_v_end_odd;
-    unsigned long hs_begin, hs_end;
-    unsigned long vs_adjust;
-    unsigned long vs_bline_evn, vs_eline_evn, vs_bline_odd, vs_eline_odd;
-    unsigned long vso_begin_evn, vso_begin_odd;
-
-    de_h_begin = modulo(aml_read_reg32_op(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc);
-    de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc);
-    aml_write_reg32_op(P_ENCP_DE_H_BEGIN, de_h_begin);
-    aml_write_reg32_op(P_ENCP_DE_H_END,   de_h_end);
-    // Program DE timing for even field
-    de_v_begin_even = aml_read_reg32_op(P_ENCP_VIDEO_VAVON_BLINE);
-    de_v_end_even   = modulo(de_v_begin_even + ACTIVE_LINES, TOTAL_LINES);
-    aml_write_reg32_op(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);
-    aml_write_reg32_op(P_ENCP_DE_V_END_EVEN,  de_v_end_even);
-    // Program DE timing for odd field if needed
-    if (INTERLACE_MODE) {
-        // Calculate de_v_begin_odd according to enc480p_timing.v:
-        //wire[10:0]	cfg_ofld_vavon_bline	= {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline	+ ofld_line;
-        de_v_begin_odd  = to_signed((aml_read_reg32_op(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
-        de_v_end_odd    = modulo(de_v_begin_odd + ACTIVE_LINES, TOTAL_LINES);
-        aml_write_reg32_op(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
-        aml_write_reg32_op(P_ENCP_DE_V_END_ODD,   de_v_end_odd);
-    }
-
-    // Program Hsync timing
-    if (de_h_end + front_porch_venc >= total_pixels_venc) {
-        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc;
-        vs_adjust   = 1;
-    } else {
-        hs_begin    = de_h_end + front_porch_venc;
-        vs_adjust   = 0;
-    }
-    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc);
-    aml_write_reg32_op(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
-    aml_write_reg32_op(P_ENCP_DVI_HSO_END,    hs_end);
-    
-    // Program Vsync timing for even field
-    if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
-        vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
-    } else {
-        vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
-    }
-    vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
-    aml_write_reg32_op(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);
-    aml_write_reg32_op(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);
-    vso_begin_evn = hs_begin;
-    aml_write_reg32_op(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);
-    aml_write_reg32_op(P_ENCP_DVI_VSO_END_EVN,   vso_begin_evn);
-    // Program Vsync timing for odd field if needed
-    if (INTERLACE_MODE) {
-        vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
-        vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
-        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);
-        aml_write_reg32_op(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
-        aml_write_reg32_op(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
-        aml_write_reg32_op(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
-        aml_write_reg32_op(P_ENCP_DVI_VSO_END_ODD,   vso_begin_odd);
-    }
-    aml_write_reg32_op(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
-                         (0                                 << 1) | // [    1] src_sel_encp
-                         (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
-                         (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
-                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
-                         (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
-                                                                    //                          0=output CrYCb(BRG);
-                                                                    //                          1=output YCbCr(RGB);
-                                                                    //                          2=output YCrCb(RBG);
-                                                                    //                          3=output CbCrY(GBR);
-                                                                    //                          4=output CbYCr(GRB);
-                                                                    //                          5=output CrCbY(BGR);
-                                                                    //                          6,7=Rsrv.
-                         (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
-                         (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
-    );
-    aml_set_reg32_bits_op(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
-    aml_write_reg32_op(P_ENCP_VIDEO_EN, 1); // Enable VENC
-}
-
-void clocks_set_sys_defaults(void)
-{
-    aml_write_reg32_op(P_HHI_HDMI_CLK_CNTL,  ((1 << 9)  |   // select "fclk_div4" PLL
-                             (1 << 8)  |   // Enable gated clock
-                             (6 << 0)) );  // Divide by 7
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL,   (1    << 30)    | 
-                            (0    << 29)    |
-                            (0    << 18)    |   // HDMI direct divide by 1
-                            (1    << 16)    |   // HDMI (lvds divider) divide by 2
-                            (4    << 10)    | 
-                            (495  << 0) );
-    //aml_write_reg32_op(P_HHI_VPU_CLK_CNTL,   0x101 );   //TODO DELETE LATER
-    //aml_write_reg32_op(P_HHI_VPU_CLK_CNTL, (aml_read_reg32_op(P_HHI_VPU_CLK_CNTL) | (1 << 8)) ); //moved to vpu.c, default config by dts
-    //aml_write_reg32_op(P_HHI_VPU_MEM_PD_REG0, 0x00000000 );
-    //aml_write_reg32_op(P_HHI_VPU_MEM_PD_REG1, 0x00000000 );
-
-    //aml_write_reg32_op(P_VPU_MEM_PD_REG0, 0x00000000 );
-    //aml_write_reg32_op(P_VPU_MEM_PD_REG1, 0x00000000 );
-}
-
-void vclk_set_encp_1920x1080( int pll_sel, int pll_div_sel, int vclk_sel, int upsample)
-{
-    unsigned long pll_reg;
-    unsigned long vid_div_reg;
-    unsigned int xd; 
-    unsigned long data32;
-
-
-#ifdef NO_2ND_PLL
-    pll_sel = 0;
-#endif
-
-    if (pll_sel) { // Setting for VID2_PLL
-        pll_reg = 0x00020863;
-        vid_div_reg = 0x00010803;
-        xd = 2; 
-    } else { // Setting for VID_PLL, consideration for supporting HDMI clock
-        pll_reg = 0x400611ef;
-        vid_div_reg = 0x00010843;
-        xd = 1; 
-    }
-
-    vid_div_reg |= (1 << 16) ; // turn clock gate on
-    vid_div_reg |= (pll_sel << 15); // vid_div_clk_sel
-    
-   
-    if(vclk_sel) {
-      aml_write_reg32_op(P_HHI_VIID_CLK_CNTL, aml_read_reg32_op(P_HHI_VIID_CLK_CNTL) & ~(1 << 19) );     //disable clk_div0 
-    }
-    else {
-      aml_write_reg32_op(P_HHI_VID_CLK_CNTL, aml_read_reg32_op(P_HHI_VID_CLK_CNTL) & ~(1 << 19) );     //disable clk_div0 
-      aml_write_reg32_op(P_HHI_VID_CLK_CNTL, aml_read_reg32_op(P_HHI_VID_CLK_CNTL) & ~(1 << 20) );     //disable clk_div1 
-    } 
-
-    msleep(5);
-
-    if(pll_sel) aml_write_reg32_op(P_HHI_VID2_PLL_CNTL,       pll_reg );    
-    else aml_write_reg32_op(P_HHI_VID_PLL_CNTL,       pll_reg );
-
-    if(pll_div_sel ) {
-      aml_write_reg32_op(P_HHI_VIID_DIVIDER_CNTL,   vid_div_reg);
-    }
-    else {
-      aml_write_reg32_op(P_HHI_VID_DIVIDER_CNTL,   vid_div_reg);
-    }
-
-    if(vclk_sel) aml_write_reg32_op(P_HHI_VIID_CLK_DIV, (aml_read_reg32_op(P_HHI_VIID_CLK_DIV) & ~(0xFF << 0)) | (xd-1) );   // setup the XD divider value
-    else aml_write_reg32_op(P_HHI_VID_CLK_DIV, (aml_read_reg32_op(P_HHI_VID_CLK_DIV) & ~(0xFF << 0)) | (xd-1) );   // setup the XD divider value
-
-    msleep(5);    
-
-    if(vclk_sel) {
-      if(pll_div_sel) aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 4, 16, 3);  // Bit[18:16] - v2_cntl_clk_in_sel
-      else aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 0, 16, 3);  // Bit[18:16] - cntl_clk_in_sel
-      aml_write_reg32_op(P_HHI_VIID_CLK_CNTL, aml_read_reg32_op(P_HHI_VIID_CLK_CNTL) |  (1 << 19) );     //enable clk_div0 
-    }
-    else {
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_DIV,
-                        1,              //divide 2 for clk_div1
-                        8, 8);
-    
-      if(pll_div_sel) aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 4, 16, 3);  // Bit[18:16] - v2_cntl_clk_in_sel
-      else aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 0, 16, 3);  // Bit[18:16] - cntl_clk_in_sel
-      aml_write_reg32_op(P_HHI_VID_CLK_CNTL, aml_read_reg32_op(P_HHI_VID_CLK_CNTL) |  (1 << 19) );     //enable clk_div0 
-    }
-    
-    msleep(5);
-
-    if(vclk_sel) {
-      aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 
-                   (1<<0),  // Enable cntl_div1_en
-                   0, 1    // cntl_div1_en
-                   );
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_DIV, 
-                   8,      // select clk_div1 
-                   24, 4); // [23:20] encp_clk_sel 
-      aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 1, 15, 1);  //soft reset
-      aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 0, 15, 1);  //release soft reset
-    }
-    else {
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 
-                   (1<<0),  // Enable cntl_div1_en
-                   0, 1    // cntl_div1_en
-                   );
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_DIV, 
-                   0,      // select clk_div1 
-                   24, 4); // [23:20] encp_clk_sel 
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 1, 15, 1);  //soft reset
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 0, 15, 1);  //release soft reset
-    }
-    
-    msleep(5);
-
-//    aml_set_reg32_bits_op(P_HHI_VID_CLK_DIV, 
-//                   1|(vclk_sel<<3),      // select clk_div2 
-//                   24, 4); // [23:20] encp_clk_sel 
-
-    if(upsample) {
-        aml_set_reg32_bits_op(P_HHI_VIID_CLK_DIV, 
-                     0|(vclk_sel<<3)|(vclk_sel<<7)|(vclk_sel<<11),      // select clk_div1 
-                     20, 12); // [31:20] dac0_clk_sel, dac1_clk_sel, dac2_clk_sel
-    }
-    else {
-        data32 = aml_read_reg32_op(P_HHI_VID_CLK_CNTL);  // Save HHI_VID_CLK_CNTL value
-        aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 0, 0, 1);  // Disable cntl_div1_en first before select other clock, to avoid glitch
-        aml_set_reg32_bits_op(P_HHI_VIID_CLK_DIV, 
-                     0x111|(vclk_sel<<3)|(vclk_sel<<7)|(vclk_sel<<11),      // select clk_div2 
-                     20, 12); // [31:20] dac0_clk_sel, dac1_clk_sel, dac2_clk_sel
-        aml_write_reg32_op(P_HHI_VID_CLK_CNTL, data32);   // Recover HHI_VID_CLK_CNTL value
-    }
-
-    if(vclk_sel) {
-      aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 
-                   (3<<0),  // Enable cntl_div1_en and cntl_div2_en
-                   0, 2    // cntl_div1_en
-                   );
-      aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 1, 15, 1);  //soft reset
-      aml_set_reg32_bits_op(P_HHI_VIID_CLK_CNTL, 0, 15, 1);  //release soft reset
-    }
-    else {
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 
-                   (3<<0),  // Enable cntl_div1_en and cntl_div2_en
-                   0, 2    // cntl_div1_en
-                   );
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 1, 15, 1);  //soft reset
-      aml_set_reg32_bits_op(P_HHI_VID_CLK_CNTL, 0, 15, 1);  //release soft reset
-    }
-} /* vclk_set_encp_1920x1080 */
-
-void set_tv_enc_1920x1080p (int viu1_sel, int viu2_sel, int enable)
-{
-#ifdef CONFIG_AM_LOGO
-	logo_object_t  *init_logo_obj=NULL;
-#endif
-    aml_write_reg32_op(P_ENCP_VIDEO_MODE,             0x0040 | (1<<14)); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
-    aml_write_reg32_op(P_ENCP_VIDEO_MODE_ADV,         0x0008); // Sampling rate: 1
-    aml_write_reg32_op(P_ENCP_VIDEO_YFP1_HTIME,       140);
-    aml_write_reg32_op(P_ENCP_VIDEO_YFP2_HTIME,       2060);
-    aml_write_reg32_op(P_ENCP_VIDEO_MAX_PXCNT,        2199);
-    aml_write_reg32_op(P_ENCP_VIDEO_HSPULS_BEGIN,     2156);
-    aml_write_reg32_op(P_ENCP_VIDEO_HSPULS_END,       44);
-    aml_write_reg32_op(P_ENCP_VIDEO_HSPULS_SWITCH,    44);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSPULS_BEGIN,     140);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSPULS_END,       2059);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSPULS_BLINE,     0);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSPULS_ELINE,     4);
-    aml_write_reg32_op(P_ENCP_VIDEO_HAVON_BEGIN,      148);
-    aml_write_reg32_op(P_ENCP_VIDEO_HAVON_END,        2067);
-    aml_write_reg32_op(P_ENCP_VIDEO_VAVON_BLINE,      41);
-    aml_write_reg32_op(P_ENCP_VIDEO_VAVON_ELINE,      1120);
-    aml_write_reg32_op(P_ENCP_VIDEO_HSO_BEGIN,	    44);
-    aml_write_reg32_op(P_ENCP_VIDEO_HSO_END, 		    2156);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSO_BEGIN,	    2100);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSO_END, 		    2164);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSO_BLINE,        3);
-    aml_write_reg32_op(P_ENCP_VIDEO_VSO_ELINE,        5);
-    aml_write_reg32_op(P_ENCP_VIDEO_MAX_LNCNT,        1124);
-
-#ifdef CONFIG_AM_LOGO
-    init_logo_obj = get_current_logo_obj();
-#endif
-
-    if(NULL==init_logo_obj || !init_logo_obj->para.loaded){
-        if (viu1_sel) { // 1=Connect to ENCP
-            aml_set_reg32_bits_op(P_VPU_VIU_VENC_MUX_CTRL, 2, 0, 2); // [1:0] cntl_viu1_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
-        }
-    }
-
-    if (viu2_sel) { // 1=Connect to ENCP
-        aml_set_reg32_bits_op(P_VPU_VIU_VENC_MUX_CTRL, 2, 2, 2); // [3:2] cntl_viu2_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
-    }
-    if (enable) {
-        aml_write_reg32_op(P_ENCP_VIDEO_EN, 1); // Enable Interlace video encoder
-    }
-}
-
-void hdmi_test_function(void)
-{
-    unsigned int tmp_add_data;
-    
-    // Enable APB3 fail on error
-    aml_set_reg32_bits_op(P_HDMI_CTRL_PORT, 1, 15, 1);
-
-    // Disable these interrupts: [2] tx_edid_int_rise [1] tx_hpd_int_fall [0] tx_hpd_int_rise
-    hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_MASKN, 0x0);
-
-    // HPD glitch filter
-    hdmi_wr_reg(TX_HDCP_HPD_FILTER_L, 0xa0);
-    hdmi_wr_reg(TX_HDCP_HPD_FILTER_H, 0xa0);
-
-    // Disable MEM power-down
-    hdmi_wr_reg(TX_MEM_PD_REG0, 0);
-
-    // Keep TX (except register I/F) in reset, while programming the registers:
-    tmp_add_data  = 0;
-    tmp_add_data |= 1   << 7; // [7] tx_pixel_rstn
-    tmp_add_data |= 1   << 6; // [6] tx_tmds_rstn
-    tmp_add_data |= 1   << 5; // [5] tx_audio_master_rstn
-    tmp_add_data |= 1   << 4; // [4] tx_audio_sample_rstn
-    tmp_add_data |= 1   << 3; // [3] tx_i2s_reset_rstn
-    tmp_add_data |= 1   << 2; // [2] tx_dig_reset_n_ch2
-    tmp_add_data |= 1   << 1; // [1] tx_dig_reset_n_ch1
-    tmp_add_data |= 1   << 0; // [0] tx_dig_reset_n_ch0
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 4; // [4] HDMI_CH0_RST_IN
-    tmp_add_data |= 1   << 2; // [0] tx_ddc_hdcp_reset_n
-    tmp_add_data |= 1   << 1; // [0] tx_ddc_edid_reset_n
-    tmp_add_data |= 1   << 0; // [0] tx_dig_reset_n_ch3
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] forced_sys_trigger
-    tmp_add_data |= 0   << 6; // [6] sys_trigger_config
-    tmp_add_data |= 0   << 5; // [5] mem_acc_seq_mode
-    tmp_add_data |= 0   << 4; // [4] mem_acc_seq_start
-    tmp_add_data |= 1   << 3; // [3] forced_mem_copy_done
-    tmp_add_data |= 1   << 2; // [2] mem_copy_done_config
-    tmp_add_data |= 0   << 1; // [1] edid_int_forced_clear
-    tmp_add_data |= 0   << 0; // [0] edid_int_auto_clear
-    hdmi_wr_reg(TX_HDCP_EDID_CONFIG, tmp_add_data);
-
-    // Enable HDMI TX PHY clock
-    tmp_add_data  = 0;
-    tmp_add_data  |= (1   << 1);        // [1]      phy clock enable
-    aml_write_reg32_op(P_HHI_HDMI_PHY_CNTL1, tmp_add_data);
-
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0               << 7; // [7]   Force DTV timing (Auto)
-    tmp_add_data |= 0               << 6; // [6]   Force Video Scan, only if [7]is set
-    tmp_add_data |= 0               << 5; // [5]   Force Video field, only if [7]is set
-    tmp_add_data |= ((VIC==39)?0:1) << 4; // [4]   disable_vic39_correction
-    tmp_add_data |= 0               << 0; // [3:0] Rsrv
-    hdmi_wr_reg(TX_VIDEO_DTV_TIMING, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0                       << 7; // [7]   forced_default_phase
-    tmp_add_data |= 0                       << 2; // [6:2] Rsrv
-    tmp_add_data |= TX_OUTPUT_COLOR_DEPTH   << 0; // [1:0] Color_depth:0=24-bit pixel; 1=30-bit pixel; 2=36-bit pixel; 3=48-bit pixel
-    hdmi_wr_reg(TX_VIDEO_DTV_MODE, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 1                       << 7; // [7]   gc_pack_mode: 0=clear color_depth and pixel_phase when GC packet is transmitting AV_mute/clear info;
-                                                  //                     1=do not clear.
-    tmp_add_data |= 0                       << 0; // [6:0] forced_islands_per_period_active
-    hdmi_wr_reg(TX_PACKET_ALLOC_ACTIVE_1, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   Force packet timing
-    tmp_add_data |= 0   << 6; // [6]   PACKET ALLOC MODE
-    tmp_add_data |= 58  << 0; // [5:0] PACKET_START_LATENCY
-    hdmi_wr_reg(TX_PACKET_CONTROL_1, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 6; // [7:6] audio_source_select[1:0]
-    tmp_add_data |= 0   << 5; // [5]   external_packet_enable
-    tmp_add_data |= 1   << 4; // [4]   internal_packet_enable
-    tmp_add_data |= 0   << 2; // [3:2] afe_fifo_source_select_lane_1[1:0]
-    tmp_add_data |= 0   << 0; // [1:0] afe_fifo_source_select_lane_0[1:0]
-    hdmi_wr_reg(TX_CORE_DATA_CAPTURE_2, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   monitor_lane_1
-    tmp_add_data |= 0   << 4; // [6:4] monitor_select_lane_1[2:0]
-    tmp_add_data |= 1   << 3; // [3]   monitor_lane_0
-    tmp_add_data |= 7   << 0; // [2:0] monitor_select_lane_0[2:0]
-    hdmi_wr_reg(TX_CORE_DATA_MONITOR_1, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 3; // [7:3] Rsrv
-    tmp_add_data |= 2   << 0; // [2:0] monitor_select[2:0]
-    hdmi_wr_reg(TX_CORE_DATA_MONITOR_2, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 1   << 7; // [7]   forced_hdmi
-    tmp_add_data |= 1   << 6; // [6]   hdmi_config
-    tmp_add_data |= 0   << 4; // [5:4] Rsrv
-    tmp_add_data |= 0   << 3; // [3]   bit_swap.
-    tmp_add_data |= 0   << 0; // [2:0] channel_swap[2:0]
-    hdmi_wr_reg(TX_TMDS_MODE, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7]   Rsrv
-    tmp_add_data |= 0   << 6; // [6]   TX_CONNECT_SEL: 0=use lower channel data[29:0]; 1=use upper channel data[59:30]
-    tmp_add_data |= 0   << 0; // [5:0] Rsrv
-    hdmi_wr_reg(TX_SYS4_CONNECT_SEL_1, tmp_add_data);
-    
-    // Normally it makes sense to synch 3 channel output with clock channel's rising edge,
-    // as HDMI's serializer is LSB out first, invert tmds_clk pattern from "1111100000" to
-    // "0000011111" actually enable data synch with clock rising edge.
-    tmp_add_data = 1 << 4; // Set tmds_clk pattern to be "0000011111" before being sent to AFE clock channel
-    hdmi_wr_reg(TX_SYS4_CK_INV_VIDEO, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] Rsrv
-    tmp_add_data |= 0   << 6; // [6] TX_AFE_FIFO channel 2 bypass=0
-    tmp_add_data |= 0   << 5; // [5] TX_AFE_FIFO channel 1 bypass=0
-    tmp_add_data |= 0   << 4; // [4] TX_AFE_FIFO channel 0 bypass=0
-    tmp_add_data |= 1   << 3; // [3] output enable of clk channel (channel 3)
-    tmp_add_data |= 1   << 2; // [2] TX_AFE_FIFO channel 2 enable
-    tmp_add_data |= 1   << 1; // [1] TX_AFE_FIFO channel 1 enable
-    tmp_add_data |= 1   << 0; // [0] TX_AFE_FIFO channel 0 enable
-    hdmi_wr_reg(TX_SYS5_FIFO_CONFIG, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= TX_OUTPUT_COLOR_FORMAT  << 6; // [7:6] output_color_format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-    tmp_add_data |= TX_INPUT_COLOR_FORMAT   << 4; // [5:4] input_color_format:  0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-    tmp_add_data |= TX_OUTPUT_COLOR_DEPTH   << 2; // [3:2] output_color_depth:  0=24-b; 1=30-b; 2=36-b; 3=48-b.
-    tmp_add_data |= TX_INPUT_COLOR_DEPTH    << 0; // [1:0] input_color_depth:   0=24-b; 1=30-b; 2=36-b; 3=48-b.
-    hdmi_wr_reg(TX_VIDEO_DTV_OPTION_L, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 0                       << 4; // [7:4] Rsrv
-    tmp_add_data |= TX_OUTPUT_COLOR_RANGE   << 2; // [3:2] output_color_range:  0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-    tmp_add_data |= TX_INPUT_COLOR_RANGE    << 0; // [1:0] input_color_range:   0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-    hdmi_wr_reg(TX_VIDEO_DTV_OPTION_H, tmp_add_data);
-
-    tmp_add_data  = 0;
-    tmp_add_data |= 0   << 7; // [7] cp_desired
-    tmp_add_data |= 0   << 6; // [6] ess_config
-    tmp_add_data |= 0   << 5; // [5] set_avmute
-    tmp_add_data |= 1   << 4; // [4] clear_avmute
-    tmp_add_data |= 0   << 3; // [3] hdcp_1_1
-    tmp_add_data |= 0   << 2; // [2] Vsync/Hsync forced_polarity_select
-    tmp_add_data |= 0   << 1; // [1] forced_vsync_polarity
-    tmp_add_data |= 0   << 0; // [0] forced_hsync_polarity
-    hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
-
-    // AVI frame
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x00, 0x46);              // PB0: Checksum
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x01, 0x5e);              // PB1 (Note: the value should be meaningful but is not!)
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x02, 0xa8);              // PB2 (Note: the value should be meaningful but is not!)
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x03, 0x13);              // PB3 (Note: the value should be meaningful but is not!)
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x04, VIC);               // PB4: [7]    Rsrv
-                                                                        //      [6:0]  VIC
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x05, PIXEL_REPEAT_HDMI); // PB5: [7:4]  Rsrv
-                                                                        //      [3:0]  PixelRepeat
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1C, 0x82);              // HB0: packet type=0x82
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1D, 0x02);              // HB1: packet version =0x02
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1E, 0x0D);              // HB2: payload bytes=13
-    hdmi_wr_reg(TX_PKT_REG_AVI_INFO_BASE_ADDR+0x1F, 0xFF);              // Enable AVI packet generation
-
-    
-    tmp_add_data = 0xa; // time_divider[7:0] for DDC I2C bus clock
-    hdmi_wr_reg(TX_HDCP_CONFIG3, tmp_add_data);
-    
-    tmp_add_data  = 0;
-    tmp_add_data |= 1   << 7; // [7] cp_desired 
-    tmp_add_data |= 1   << 6; // [6] ess_config 
-    tmp_add_data |= 0   << 5; // [5] set_avmute 
-    tmp_add_data |= 0   << 4; // [4] clear_avmute 
-    tmp_add_data |= 1   << 3; // [3] hdcp_1_1 
-    tmp_add_data |= 0   << 2; // [2] forced_polarity 
-    tmp_add_data |= 0   << 1; // [1] forced_vsync_polarity 
-    tmp_add_data |= 0   << 0; // [0] forced_hsync_polarity
-    hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
-    
-    // --------------------------------------------------------
-    // Release TX out of reset
-    // --------------------------------------------------------
-    aml_write_reg32_op(P_HHI_HDMI_PLL_CNTL1, 0x00040000);         // turn off phy_clk
-    aml_write_reg32_op(P_HHI_HDMI_PLL_CNTL1, 0x00040003);         // turn on phy_clk
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00); // Release reset on TX digital clock channel
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
-}
-
-// Use this self-made function rather than %, because % appears to produce wrong
-// value for divisor which are not 2's exponential.
-unsigned long modulo(unsigned long a, unsigned long b)
-{
-    if (a >= b) {
-        return(a-b);
-    } else {
-        return(a);
-    }
-}
-        
-signed int to_signed(unsigned int a)
-{
-    if (a <= 7) {
-        return(a);
-    } else {
-        return(a-16);
-    }
-}
-
-void hdmi_tx_miniboot(void) 
-{
-printk("%s[%d]\n", __func__, __LINE__);
-    clocks_set_sys_defaults();    // set MPEG, audio and default video
-    aml_set_reg32_bits_op(P_HHI_HDMI_CLK_CNTL, 0, 16, 4);  // Set [19:16] hdmi_tx_pixel_clk comes from clk_div1
-    vclk_set_encp_1920x1080(0,          0,              0,          0);
-printk("%s[%d]\n", __func__, __LINE__);
-
-    aml_set_reg32_bits_op(P_PERIPHS_PIN_MUX_1, 0xf, 23, 4);  //HPD SCL CEC pinmux
-
-    hdmi_test_function();
-printk("%s[%d]\n", __func__, __LINE__);
-
-    set_tv_enc_1920x1080p(  1,          0,          0);
-
-printk("%s[%d]\n", __func__, __LINE__);
-    set_hdmi_enc();
-
-    printk("config HPLL\n");
-printk("%s[%d]\n", __func__, __LINE__);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL2, 0x69c88000);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL3, 0xca563823);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL4, 0x00238100);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL5, 0x00012286);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL,  0x6001043d);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL,  0x4001043d);
-    printk("waiting HPLL lock\n");
-    while(!(aml_read_reg32_op(P_HHI_VID_PLL_CNTL) & (1 << 31))) {
-        ;
-    }
-printk("%s[%d]\n", __func__, __LINE__);
-    aml_write_reg32_op(P_HHI_VID_PLL_CNTL2, 0x69c8ce00);
-    aml_write_reg32_op(P_HHI_HDMI_PHY_CNTL1, 2);
-    aml_write_reg32_op(P_HHI_HDMI_PHY_CNTL0, 0x08c38d0b);
-
-printk("%s[%d]\n", __func__, __LINE__);
-    return;
-}
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.h
deleted file mode 100644
index 1fd9d540728f..000000000000
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_miniboot.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef __HDMI_TX_MINIBOOT_H__
-#define __HDMI_TX_MINIBOOT_H__
-
-
-#endif
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c
index 44d05b80d275..98da926c374d 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c
@@ -12,17 +12,16 @@
 #include <linux/mutex.h>
 #include <linux/cdev.h>
 
-#include "hdmi_tx_module.h"
-#include "hdmi_info_global.h"
-#include "hw/hdmi_tx_reg.h"
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 
 static unsigned char hdmi_output_rgb = 0;
 static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device);
 static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode);
 
-static Hdmi_tx_video_para_t hdmi_tx_video_params[] = 
+static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
 {
-    { 
+    {
         .VIC            = HDMI_640x480p60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -30,10 +29,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_4_3,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_480p60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -41,10 +40,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_4_3,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_480p60_16x9,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -52,10 +51,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_720p60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -64,13 +63,13 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = HDMI_2_TIMES_REPEAT,
 #else
         .repeat_time    = NO_REPEAT,
-#endif        
+#endif
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080i60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -79,13 +78,13 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = HDMI_2_TIMES_REPEAT,
 #else
         .repeat_time    = NO_REPEAT,
-#endif        
+#endif
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_480i60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -93,10 +92,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = HDMI_2_TIMES_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_4_3,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_480i60_16x9,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -104,10 +103,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = HDMI_2_TIMES_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1440x480p60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -115,10 +114,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_4_3,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080p60,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -126,10 +125,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_576p50,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -137,10 +136,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_4_3,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_576p50_16x9,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -148,10 +147,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_720p50,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -159,10 +158,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080i50,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -170,10 +169,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_576i50,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -181,10 +180,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = HDMI_2_TIMES_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_4_3,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_576i50_16x9,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -192,10 +191,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = HDMI_2_TIMES_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU601,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080p50,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -203,10 +202,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080p24,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -214,10 +213,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080p25,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -225,10 +224,10 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
-    { 
+    {
         .VIC            = HDMI_1080p30,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
@@ -236,7 +235,7 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .repeat_time    = NO_REPEAT,
         .aspect_ratio   = TV_ASPECT_RATIO_16_9,
         .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
+        .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
     },
     {
@@ -273,7 +272,7 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .sc             = SC_SCALE_HORIZ_VERT,
     },
     {
-        .VIC            = HDMI_4k2k_smpte,
+        .VIC            = HDMI_4k2k_smpte_24,
         .color_prefer   = COLOR_SPACE_RGB444,
         .color_depth    = COLOR_24BIT,
         .bar_info       = B_BAR_VERT_HORIZ,
@@ -292,14 +291,14 @@ static Hdmi_tx_video_para_t *hdmi_get_video_param(HDMI_Video_Codes_t VideoCode)
     int count=ARRAY_SIZE(hdmi_tx_video_params);
     for(i=0;i<count;i++){
         if(hdmi_tx_video_params[i].VIC == VideoCode){
-            break;    
+            break;
         }
-    }    
+    }
     if(i<count){
-        video_param = &(hdmi_tx_video_params[i]);        
+        video_param = &(hdmi_tx_video_params[i]);
     }
     return video_param;
-}    
+}
 
 static void hdmi_tx_construct_avi_packet(Hdmi_tx_video_para_t *video_param, char* AVI_DB)
 {
@@ -333,7 +332,7 @@ static void hdmi_tx_construct_avi_packet(Hdmi_tx_video_para_t *video_param, char
     //AVI_DB[2] = 0;
 
     AVI_DB[3] = video_param->VIC;
-    if((video_param->VIC == HDMI_4k2k_30) || (video_param->VIC == HDMI_4k2k_25) || (video_param->VIC == HDMI_4k2k_24) || (video_param->VIC == HDMI_4k2k_smpte))
+    if((video_param->VIC == HDMI_4k2k_30) || (video_param->VIC == HDMI_4k2k_25) || (video_param->VIC == HDMI_4k2k_24) || (video_param->VIC == HDMI_4k2k_smpte_24))
         AVI_DB[3] = 0;      // HDMI Spec V1.4b P151
 
     AVI_DB[4] = video_param->repeat_time;
@@ -346,9 +345,9 @@ static void hdmi_tx_construct_avi_packet(Hdmi_tx_video_para_t *video_param, char
 void hdmitx_init_parameters(HDMI_TX_INFO_t *info)
 {
     memset(info, 0, sizeof(HDMI_TX_INFO_t));
-    
+
     info->video_out_changing_flag = 1;
-    
+
     info->audio_flag = 1;
     info->audio_info.type = CT_REFER_TO_STREAM;
     info->audio_info.format = AF_I2S;
@@ -357,7 +356,7 @@ void hdmitx_init_parameters(HDMI_TX_INFO_t *info)
     info->audio_info.channels = CC_2CH;
     info->audio_info.audio_mclk = MCLK_256_Fs;
     info->audio_out_changing_flag = 1;
-    
+
     info->auto_hdcp_ri_flag = 1;     // If == 1, turn on Auto Ri Checking
     info->hw_sha_calculator_flag = 1;    // If  == 1, use the HW SHA calculator, otherwise, use SW SHA calculator
 
@@ -370,7 +369,7 @@ static int is_dvi_device(rx_cap_t* pRXCap)
     hdmitx_dev_t *hdmitx_device = container_of(pRXCap, struct hdmi_tx_dev_s, RXCap);
     if(hdmitx_device->tv_no_edid)
         return 0;
-    
+
     if(pRXCap->IEEEOUI != 0x000c03)
         return 1;
     else
@@ -385,55 +384,60 @@ void hdmitx_output_rgb(void)
 int hdmitx_set_display(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode)
 {
     Hdmi_tx_video_para_t *param;
+    HDMI_Video_Codes_t vic;
     int i,ret=-1;
     unsigned char AVI_DB[32];
     unsigned char AVI_HB[32];
-    AVI_HB[0] = TYPE_AVI_INFOFRAMES ; 
-    AVI_HB[1] = AVI_INFOFRAMES_VERSION ; 
-    AVI_HB[2] = AVI_INFOFRAMES_LENGTH ; 
+    AVI_HB[0] = TYPE_AVI_INFOFRAMES ;
+    AVI_HB[1] = AVI_INFOFRAMES_VERSION ;
+    AVI_HB[2] = AVI_INFOFRAMES_LENGTH ;
     for(i=0;i<32;i++){
         AVI_DB[i]=0;
     }
 
+    vic = hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0);
+    hdmi_print(IMP, SYS "already init VIC = %d  Now VIC = %d\n", vic, VideoCode);
+    if((vic != HDMI_Unkown) && (vic == VideoCode)) {
+        hdmitx_device->cur_VIC = vic;
+        return 1;;
+    }
+
     param = hdmi_get_video_param(VideoCode);
     if(param){
         param->color = param->color_prefer;
-		if(hdmi_output_rgb){
- 	       param->color = COLOR_SPACE_RGB444;        
+        if(hdmi_output_rgb){
+            param->color = COLOR_SPACE_RGB444;
         }
         else{
 //HDMI CT 7-24 Pixel Encoding - YCbCr to YCbCr Sink
-	        switch(hdmitx_device->RXCap.native_Mode & 0x30)
-	        {
-	            case 0x20:    //bit5==1, then support YCBCR444 + RGB
-	            case 0x30:
-	                param->color = COLOR_SPACE_YUV444;
-	                break;
-	            case 0x10:    //bit4==1, then support YCBCR422 + RGB
-	                param->color = COLOR_SPACE_YUV422;
-	                break;
-	            default:
-	                param->color = COLOR_SPACE_RGB444;
-	        }
-        }  
+            switch(hdmitx_device->RXCap.native_Mode & 0x30)
+            {
+                case 0x20:    //bit5==1, then support YCBCR444 + RGB
+                case 0x30:
+                    param->color = COLOR_SPACE_YUV444;
+                    break;
+                case 0x10:    //bit4==1, then support YCBCR422 + RGB
+                    param->color = COLOR_SPACE_YUV422;
+                    break;
+                default:
+                    param->color = COLOR_SPACE_RGB444;
+            }
+        }
         if(hdmitx_device->HWOp.SetDispMode(hdmitx_device, param)>=0){
 //HDMI CT 7-33 DVI Sink, no HDMI VSDB nor any other VSDB, No GB or DI expected
 //TMDS_MODE[hdmi_config]
 //0: DVI Mode       1: HDMI Mode
             //if(hdmitx_device->hdmi_info.output_state==CABLE_PLUGIN_DVI_OUT)
-            if(is_dvi_device(&hdmitx_device->RXCap))
-            {
+            if(is_dvi_device(&hdmitx_device->RXCap)) {
                 hdmi_print(1,"Sink is DVI device\n");
-                hdmi_wr_reg(TX_TMDS_MODE, hdmi_rd_reg(TX_TMDS_MODE) & ~(1<<6));
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);        //todo ColorFormat
             }
-            else
-            {
+            else {
                 hdmi_print(1,"Sink is HDMI device\n");
-                hdmi_wr_reg(TX_TMDS_MODE, hdmi_rd_reg(TX_TMDS_MODE) |  (3<<6));
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, HDMI_MODE);
             }
-
 //check system status by reading EDID_STATUS
-            switch(hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) >> 6)
+            switch(hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_SYSTEM_ST, 0))
             {
                 case 0:
                     hdmi_print(1,"No sink attached\n");
@@ -453,20 +457,20 @@ int hdmitx_set_display(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode
 
             hdmi_tx_construct_avi_packet(param, (char*)AVI_DB);
 
-            if((VideoCode == HDMI_4k2k_30) || (VideoCode == HDMI_4k2k_25) || (VideoCode == HDMI_4k2k_24) || (VideoCode == HDMI_4k2k_smpte)) {
+            if((VideoCode == HDMI_4k2k_30) || (VideoCode == HDMI_4k2k_25) || (VideoCode == HDMI_4k2k_24) || (VideoCode == HDMI_4k2k_smpte_24)) {
                 hdmi_set_vend_spec_infofram(hdmitx_device, VideoCode);
             }
             else {
                 hdmi_set_vend_spec_infofram(hdmitx_device, 0);
             }
-    
+
             hdmitx_device->HWOp.SetPacket(HDMI_PACKET_AVI, AVI_DB, AVI_HB);
             ret = 0;
         }
     }
     else{
         if(hdmitx_device->HWOp.SetDispMode) {
-            hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //disable HDMI    
+            hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //disable HDMI
         }
     }
     hdmitx_set_spd_info(hdmitx_device);
@@ -478,9 +482,9 @@ static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_
     int i;
     unsigned char VEN_DB[6];
     unsigned char VEN_HB[3];
-    VEN_HB[0] = 0x81; 
-    VEN_HB[1] = 0x01; 
-    VEN_HB[2] = 0x6; 
+    VEN_HB[0] = 0x81;
+    VEN_HB[1] = 0x01;
+    VEN_HB[2] = 0x6;
 
     for(i = 0; i < 0x6; i++){
         VEN_DB[i] = 0;
@@ -500,7 +504,7 @@ static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_
         VEN_DB[4] = 0x2;
     else if(VideoCode == HDMI_4k2k_24)
         VEN_DB[4] = 0x3;
-    else if(VideoCode == HDMI_4k2k_smpte)
+    else if(VideoCode == HDMI_4k2k_smpte_24)
         VEN_DB[4] = 0x4;
     else {
         // nothing
@@ -513,9 +517,9 @@ int hdmi_set_3d(hdmitx_dev_t* hdmitx_device, int type, unsigned int param)
     int i;
     unsigned char VEN_DB[6];
     unsigned char VEN_HB[3];
-    VEN_HB[0] = 0x81 ; 
-    VEN_HB[1] = 0x01 ; 
-    VEN_HB[2] = 0x6 ; 
+    VEN_HB[0] = 0x81 ;
+    VEN_HB[1] = 0x01 ;
+    VEN_HB[2] = 0x6 ;
     if(type==0xf){
         hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
     }
@@ -526,15 +530,15 @@ int hdmi_set_3d(hdmitx_dev_t* hdmitx_device, int type, unsigned int param)
         VEN_DB[0]=0x03;
         VEN_DB[1]=0x0c;
         VEN_DB[2]=0x00;
-        
+
         VEN_DB[3]=0x40;
         VEN_DB[4]=type<<4;
-        VEN_DB[5]=param<<4;    
+        VEN_DB[5]=param<<4;
         hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
-    }  
-    return 0;          
+    }
+    return 0;
 
-}    
+}
 
 // Set Source Product Descriptor InfoFrame
 static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device)
@@ -547,7 +551,7 @@ static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device)
         vend_data = hdmitx_device->config_data.vend_data;
     }
     else {
-        printk("hdmitx: packet: can\'t get vendor data\n");
+        hdmi_print(INF, SYS "packet: can\'t get vendor data\n");
         return;
     }
     if(vend_data->vendor_name) {
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.h
deleted file mode 100755
index a0076b97ce76..000000000000
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef _HDMI_TX_VIDEO_H
-#define _HDMI_TX_VIDEO_H
-
-#include "hdmi_info_global.h"
-
-#endif  // _HDMI_TX_VIDEO_H
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hw/Makefile b/drivers/amlogic/hdmi/hdmi_tx/hw/Makefile
deleted file mode 100644
index 79053cb7494c..000000000000
--- a/drivers/amlogic/hdmi/hdmi_tx/hw/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-y				+= hdmi_tx_reg.o hdmi_tx_hw.o
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/test_prm.h b/drivers/amlogic/hdmi/hdmi_tx/test_prm.h
deleted file mode 100644
index 084786e5f3dd..000000000000
--- a/drivers/amlogic/hdmi/hdmi_tx/test_prm.h
+++ /dev/null
@@ -1,56 +0,0 @@
-//------------------------------------------------------------------------------
-// Video
-//------------------------------------------------------------------------------
-
-//#define VIDEO_PATH_2      // If defined use video from path 2; if UN-defined used video from path 1.
-
-#define VIC                 16                      // Video format identification code: 1920x1080p@59.94/60Hz
-#define INTERLACE_MODE      0                       // 0=Progressive; 1=Interlace.
-#define PIXEL_REPEAT_VENC   0                       // Pixel repeat factor seen in VENC
-#define PIXEL_REPEAT_HDMI   0                       // Pixel repeat factor seen by HDMI TX
-
-#define ACTIVE_PIXELS       (1920*(1+PIXEL_REPEAT_HDMI)) // Number of active pixels per line.
-#define ACTIVE_LINES        (1080/(1+INTERLACE_MODE))    // Number of active lines per field.
-
-#define LINES_F0            1125                    // Number of lines in the even field.
-#define LINES_F1            1125                    // Number of lines in the odd field.
-
-#define FRONT_PORCH         88                      // Number of pixels from DE Low to HSYNC high. 
-#define HSYNC_PIXELS        44                      // Number of pixels of HSYNC pulse. 
-#define BACK_PORCH          148                     // Number of pixels from HSYNC low to DE high.
-
-#define EOF_LINES           4                       // HSYNC count between last line of active video and start of VSYNC 
-                                                    // a.k.a. End of Field (EOF). In interlaced mode,
-                                                    // HSYNC count will be eof_lines at the end of even field  
-                                                    // and eof_lines+1 at the end of odd field.
-#define VSYNC_LINES         5                       // HSYNC count of VSYNC assertion
-                                                    // In interlaced mode VSYNC will be in-phase with HSYNC in the even field and 
-                                                    // out-of-phase with HSYNC in the odd field.
-#define SOF_LINES           36                      // HSYNC count between VSYNC de-assertion and first line of active video
-
-#define HSYNC_POLARITY      1                       // HSYNC polarity invert 
-#define VSYNC_POLARITY      1                       // HSYNC polarity invert
-
-#define TOTAL_FRAMES        4                       // Number of frames to run in simulation
-
-#define TX_INPUT_COLOR_DEPTH    1                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-#define TX_OUTPUT_COLOR_DEPTH   0                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-#define RX_INPUT_COLOR_DEPTH    0                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-#define RX_OUTPUT_COLOR_DEPTH   1                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
-
-#define TX_INPUT_COLOR_FORMAT   1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-#define TX_OUTPUT_COLOR_FORMAT  1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-#define RX_INPUT_COLOR_FORMAT   1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-#define RX_OUTPUT_COLOR_FORMAT  1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
-
-#define TX_INPUT_COLOR_RANGE    0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-#define TX_OUTPUT_COLOR_RANGE   0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-#define RX_INPUT_COLOR_RANGE    0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-#define RX_OUTPUT_COLOR_RANGE   0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
-
-//------------------------------------------------------------------------------
-// The following parameters are not to be modified
-//------------------------------------------------------------------------------
-
-#define TOTAL_PIXELS        (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS) // Number of total pixels per line.
-#define TOTAL_LINES         (LINES_F0+(LINES_F1*INTERLACE_MODE))                // Number of total lines per frame.
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_info_global.h b/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
old mode 100755
new mode 100644
similarity index 95%
rename from drivers/amlogic/hdmi/hdmi_tx/hdmi_info_global.h
rename to include/linux/amlogic/hdmi_tx/hdmi_info_global.h
index 6aea8d9b0b7c..9cf42e755374
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_info_global.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
@@ -24,10 +24,14 @@ typedef enum HDMI_Video_Type_ {
     HDMI_1080p24,
     HDMI_1080p25,
     HDMI_1080p30,
-    HDMI_4k2k_30 = 68,  //tmp VIC
+    HDMI_4k2k_24 = 93,      // CEA-861-F
     HDMI_4k2k_25,
-    HDMI_4k2k_24,
-    HDMI_4k2k_smpte,
+    HDMI_4k2k_30,
+    HDMI_4k2k_50,
+    HDMI_4k2k_60,
+    HDMI_4k2k_smpte_24 = 98,   //24 Hz
+    HDMI_4k2k_smpte_50 = 101,
+    HDMI_4k2k_smpte_60,
 } HDMI_Video_Codes_t ;
 
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
old mode 100755
new mode 100644
similarity index 56%
rename from drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_module.h
rename to include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
index 3afdadb1ecbb..7474dd34591f
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
@@ -11,7 +11,7 @@
 /************************************
 *    hdmitx device structure
 *************************************/
-#define VIC_MAX_NUM 72  // consider 4k2k
+#define VIC_MAX_NUM 128  // consider 4k2k
 #define AUD_MAX_NUM 60
 typedef struct
 {
@@ -66,13 +66,18 @@ typedef struct hdmi_tx_dev_s {
     struct {
         void (*SetPacket)(int type, unsigned char* DB, unsigned char* HB);
         void (*SetAudioInfoFrame)(unsigned char* AUD_DB, unsigned char* CHAN_STAT_BUF);
-        unsigned char (*GetEDIDData)(struct hdmi_tx_dev_s* hdmitx_device);
         int (*SetDispMode)(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_video_para_t *param);
         int (*SetAudMode)(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio_para_t* audio_param);
         void (*SetupIRQ)(struct hdmi_tx_dev_s* hdmitx_device);
         void (*DebugFun)(struct hdmi_tx_dev_s* hdmitx_device, const char * buf);
         void (*UnInit)(struct hdmi_tx_dev_s* hdmitx_device);
-        int (*Cntl)(struct hdmi_tx_dev_s* hdmitx_device, int cmd, unsigned arg);
+        int (*CntlPower)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);       // Power control
+        int (*CntlDDC)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);         // edid/hdcp control
+        int (*GetState)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);      // Audio/Video/System Status
+        int (*CntlPacket)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);      // Packet control
+        int (*CntlConfig)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);      // Configure control
+        int (*CntlMisc)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);            // Other control
+        int (*Cntl)(struct hdmi_tx_dev_s* hdmitx_device, unsigned cmd, unsigned arg);            // Other control
     }HWOp;
 
     struct hdmi_config_platform_data config_data;
@@ -110,12 +115,75 @@ typedef struct hdmi_tx_dev_s {
     unsigned int  tv_cec_support;
     unsigned int  tv_no_edid;           // For some un-well-known TVs, no edid at all
     unsigned int  hpd_lock;
-#ifdef CONFIG_AM_HDMI_REPEATER
-    unsigned int  hdcp_repeater_mode;
-    unsigned int  repeater_hdcp_cmd; /* 1, start; 2, stop */
-#endif    
 }hdmitx_dev_t;
 
+#define CMD_DDC_OFFSET          (0x10 << 24)
+#define CMD_STATUS_OFFSET       (0x11 << 24)
+#define CMD_PACKET_OFFSET       (0x12 << 24)
+#define CMD_MISC_OFFSET         (0x13 << 24)
+#define CMD_CONF_OFFSET         (0x14 << 24)
+#define CMD_STAT_OFFSET         (0x15 << 24)
+
+/***********************************************************************
+ *             DDC CONTROL //CntlDDC
+ **********************************************************************/
+#define DDC_RESET_EDID          (CMD_DDC_OFFSET + 0x00)
+#define DDC_RESET_HDCP          (CMD_DDC_OFFSET + 0x01)
+#define DDC_HDCP_OP             (CMD_DDC_OFFSET + 0x02)
+    #define HDCP_ON             0x1
+    #define HDCP_OFF            0x2
+#define DDC_IS_HDCP_ON          (CMD_DDC_OFFSET + 0x04)
+#define DDC_HDCP_GET_AKSV       (CMD_DDC_OFFSET + 0x05)
+#define DDC_HDCP_GET_BKSV       (CMD_DDC_OFFSET + 0x06)
+#define DDC_HDCP_GET_AUTH       (CMD_DDC_OFFSET + 0x07)
+#define DDC_PIN_MUX_OP          (CMD_DDC_OFFSET + 0x08)
+    #define PIN_MUX             0x1
+    #define PIN_UNMUX           0x2
+#define DDC_EDID_READ_DATA      (CMD_DDC_OFFSET + 0x0a)
+#define DDC_IS_EDID_DATA_READY  (CMD_DDC_OFFSET + 0x0b)
+#define DDC_EDID_GET_DATA       (CMD_DDC_OFFSET + 0x0c)
+#define DDC_EDID_CLEAR_RAM      (CMD_DDC_OFFSET + 0x0d)
+
+/***********************************************************************
+ *             CONFIG CONTROL //CntlConfig
+ **********************************************************************/
+// Video part
+#define CONF_VIDEO_BLANK_OP     (CMD_CONF_OFFSET + 0x00)
+    #define VIDEO_BLANK         0x1
+    #define VIDEO_UNBLANK       0x2
+#define CONF_HDMI_DVI_MODE      (CMD_CONF_OFFSET + 0x02)
+    #define HDMI_MODE           0x1
+    #define DVI_MODE            0x2
+#define CONF_SYSTEM_ST          (CMD_CONF_OFFSET + 0x03)
+// Audio part
+#define CONF_CLR_AVI_PACKET     (CMD_CONF_OFFSET + 0x04)
+#define CONF_CLR_VSDB_PACKET    (CMD_CONF_OFFSET + 0x05)
+#define CONF_AUDIO_MUTE_OP      (CMD_CONF_OFFSET + 0x1000 + 0x00)
+    #define AUDIO_MUTE          0x1
+    #define AUDIO_UNMUTE        0x2
+#define CONF_CLR_AUDINFO_PACKET (CMD_CONF_OFFSET + 0x1000 + 0x01)
+
+/***********************************************************************
+ *             MISC control, hpd, hpll //CntlMisc
+ **********************************************************************/
+#define MISC_HPD_MUX_OP         (CMD_MISC_OFFSET + 0x00)
+#define MISC_HPD_GPI_ST         (CMD_MISC_OFFSET + 0x02)
+#define MISC_HPLL_OP            (CMD_MISC_OFFSET + 0x03)
+    #define HPLL_ENABLE         0x1
+    #define HPLL_DISABLE        0x2
+#define MISC_TMDS_PHY_OP        (CMD_MISC_OFFSET + 0x04)
+    #define TMDS_PHY_ENABLE     0x1
+    #define TMDS_PHY_DISABLE    0x2
+
+/***********************************************************************
+ *                          Get State //GetState
+ **********************************************************************/
+#define STAT_VIDEO_VIC          (CMD_STAT_OFFSET + 0x00)
+#define STAT_VIDEO_CLK          (CMD_STAT_OFFSET + 0x01)
+#define STAT_AUDIO_FORMAT       (CMD_STAT_OFFSET + 0x10)
+#define STAT_AUDIO_CHANNEL      (CMD_STAT_OFFSET + 0x11)
+#define STAT_AUDIO_CLK_STABLE   (CMD_STAT_OFFSET + 0x12)
+
 // HDMI LOG
 #define HDMI_LOG_HDCP           (1 << 0)
 
@@ -130,11 +198,11 @@ typedef struct hdmi_tx_dev_s {
 #define HDMI_PROCESS_DELAY  msleep(10)
 #define AUTH_PROCESS_TIME   (1000/100)       // reduce a little time, previous setting is 4000/10
 
-#define HDMITX_VER "2013Aug25a"
+#define HDMITX_VER "2014Jan5a"
 
-/************************************
+/***********************************************************************
 *    hdmitx protocol level interface
-*************************************/
+ **********************************************************************/
 extern void hdmitx_init_parameters(HDMI_TX_INFO_t *info);
 
 extern int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device);
@@ -155,7 +223,6 @@ extern int hdmi_set_3d(hdmitx_dev_t* hdmitx_device, int type, unsigned int param
 
 extern int hdmitx_set_audio(hdmitx_dev_t* hdmitx_device, Hdmi_tx_audio_para_t* audio_param, int hdmi_ch);
 
-extern int hdmi_print(int printk_flag, const char *fmt, ...);
 
 extern  int hdmi_print_buf(char* buf, int len);
 
@@ -165,9 +232,9 @@ extern void hdmitx_output_rgb(void);
 
 extern int get_cur_vout_index(void);
 
-/************************************
+/***********************************************************************
 *    hdmitx hardware level interface
-*************************************/
+***********************************************************************/
 //#define DOUBLE_CLK_720P_1080I
 extern unsigned char hdmi_pll_mode; /* 1, use external clk as hdmi pll source */
 
@@ -175,31 +242,18 @@ extern void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device);
 
 extern unsigned char hdmi_audio_off_flag;
 
-#define HDMITX_HWCMD_POWERMODE_SWITCH    0x1
-#define HDMITX_HWCMD_VDAC_OFF           0x2
 #define HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH       0x3
 #define HDMITX_HWCMD_TURNOFF_HDMIHW           0x4
 #define HDMITX_HWCMD_MUX_HPD                0x5
 #define HDMITX_HWCMD_PLL_MODE                0x6
 #define HDMITX_HWCMD_TURN_ON_PRBS           0x7
 #define HDMITX_FORCE_480P_CLK                0x8
-#define HDMITX_OUTPUT_ENABLE                 0x9
-    #define HDMITX_SET_AVMUTE                0x0
-    #define HDMITX_CLEAR_AVMUTE              0x1
 #define HDMITX_GET_AUTHENTICATE_STATE        0xa
 #define HDMITX_SW_INTERNAL_HPD_TRIG          0xb
 #define HDMITX_HWCMD_OSD_ENABLE              0xf
-#define HDMITX_HDCP_CNTL                     0x10
-    #define HDCP_OFF    0x0
-    #define HDCP_ON     0x1
-    #define IS_HDCP_ON  0x2
-#ifdef CONFIG_AM_HDMI_REPEATER
-    #define HDCP_RESET  0x3
-#endif
-    
+
 #define HDMITX_HDCP_MONITOR                  0x11
 #define HDMITX_IP_INTR_MASN_RST              0x12
-#define HDMITX_HWCMD_HPD_RESET               0X13
 #define HDMITX_EARLY_SUSPEND_RESUME_CNTL     0x14
     #define HDMITX_EARLY_SUSPEND             0x1
     #define HDMITX_LATE_RESUME               0x2
@@ -208,13 +262,6 @@ extern unsigned char hdmi_audio_off_flag;
     #define TX_SYS_SW_RST       (1<<4)
     #define CEC_CREG_SW_RST     (1<<3)
     #define CEC_SYS_SW_RST      (1<<2)
-#define HDMITX_TMDS_PHY_CNTL                 0x16   // Refer to HDMI_OTHER_CTRL0 in hdmi_tx_reg.h
-    #define PHY_OFF             0
-    #define PHY_ON              1
-#define HDMITX_AUDIO_CNTL                    0x17
-    #define AUDIO_OFF           0
-    #define AUDIO_ON            1
-#define HMDITX_PHY_SUSPEND                   0x18
 #define HDMITX_AVMUTE_CNTL                   0x19
     #define AVMUTE_SET          0   // set AVMUTE to 1
     #define AVMUTE_CLEAR        1   // set AVunMUTE to 1
@@ -224,7 +271,6 @@ extern unsigned char hdmi_audio_off_flag;
     #define INTR_MASKN_ENABLE   0
     #define INTR_MASKN_DISABLE  1
     #define INTR_CLEAR          2
-#define HDMITX_HWCMD_HPD_GPI_TEST               0x1C
 
 #define HDMI_HDCP_DELAYTIME_AFTER_DISPLAY    20      // unit: ms
 
@@ -235,5 +281,30 @@ typedef struct {
     unsigned hdcp_sub_len;
 }hdcp_sub_t;
 
+/***********************************************************************
+ *                   hdmi debug printk
+ * level: 0 ~ 4     Default is 2
+ *      0: ERRor  1: IMPortant  2: INFormative  3: DETtal  4: LOW
+ * hdmi_print(ERR, EDID "edid bad\");
+ * hdmi_print(IMP, AUD "set audio format: AC-3\n");
+ * hdmi_print(DET)
+ **********************************************************************/
+#define HD          "hdmitx: "
+#define VID         HD "video: "
+#define AUD         HD "audio: "
+#define CEC         HD "cec: "
+#define EDID        HD "edid: "
+#define HDCP        HD "hdcp: "
+#define SYS         HD "system: "
+#define HPD         HD "hpd: "
+
+#define ERR         1
+#define IMP         2
+#define INF         3
+#define LOW         4
+#define DET         5, "%s[%d]", __FUNCTION__, __LINE__
+
+extern void hdmi_print(int level, const char *fmt, ...);
+
 #endif
 
-- 
2.19.0

