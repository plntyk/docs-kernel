From b8531bad515065719664dec2a269ab074b14cb22 Mon Sep 17 00:00:00 2001
From: "shuai.li" <shuai.li@amlogic.com>
Date: Wed, 8 Jan 2014 11:03:34 +0800
Subject: [PATCH 2972/5965] PD#85968 [audio]add m8 internal codec controls and
 dapms;use one machine layer to fit all codecs

Conflicts:

	arch/arm/configs/meson8_defconfig
	sound/soc/aml/Kconfig
	sound/soc/aml/Makefile
---
 arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd     |  42 +-
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |  55 +-
 arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd  |  55 +-
 arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd  |  75 +--
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |  79 +--
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd  |  42 +-
 arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd  |  42 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd |  42 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd |  42 +-
 arch/arm/boot/dts/amlogic/meson8_pxp.dtd      |  42 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd      |  42 +-
 arch/arm/configs/meson8_defconfig             |   1 -
 include/linux/amlogic/aml_audio_codec_probe.h |  18 +-
 sound/soc/aml/m8/Kconfig                      |   7 +-
 sound/soc/aml/m8/Makefile                     |   3 -
 sound/soc/aml/m8/aml_i2s_dai.c                |   2 +-
 sound/soc/aml/m8/aml_m8.c                     |  88 ++-
 sound/soc/codecs/aml_m8_codec.c               | 564 +++---------------
 sound/soc/codecs/aml_m8_codec.h               |  17 +-
 .../soc/codecs/common/aml_audio_codec_probe.c | 306 ++++++----
 sound/soc/codecs/rt5616.c                     |  16 +-
 21 files changed, 796 insertions(+), 784 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd b/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
index 68f856ef11d2..9a57330112db 100755
--- a/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
@@ -827,6 +827,35 @@ void root_func(){
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -839,8 +868,17 @@ void root_func(){
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 1bd90f9988cb..9fa85785adcd 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1292,6 +1292,35 @@ sdio{
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -1302,8 +1331,17 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
@@ -1311,16 +1349,11 @@ sdio{
             "MICBIAS","MAIN MIC",
             "LINPUT1","MICBIAS";
         mute_gpio = "GPIOY_15";
-        //mute_inv;
         hp_paraments = <800 300 0 5 1>;
-        pinctrl-names = "aml_snd_m8";
-        pinctrl-0 = <&audio_pins>;
-        status = "okay";
-        
-    };
-
-
-
+		pinctrl-names = "aml_snd_m8";
+		pinctrl-0 = <&audio_pins>;
+		status = "okay"; 
+	};
 
 /// ***************************************************************************************
 ///	-	Camera
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
index db3befc83586..5cb808008f73 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
@@ -1300,6 +1300,35 @@ sdio{
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -1310,8 +1339,17 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
@@ -1319,16 +1357,11 @@ sdio{
             "MICBIAS","MAIN MIC",
             "LINPUT1","MICBIAS";
         mute_gpio = "GPIOY_15";
-        //mute_inv;
         hp_paraments = <800 300 0 5 1>;
-        pinctrl-names = "aml_snd_m8";
-        pinctrl-0 = <&audio_pins>;
-        status = "okay";
-        
-    };
-
-
-
+		pinctrl-names = "aml_snd_m8";
+		pinctrl-0 = <&audio_pins>;
+		status = "okay"; 
+	};
 
 /// ***************************************************************************************
 ///	-	Camera
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
index 0a04d908981f..268282d8cfdf 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
@@ -1298,36 +1298,38 @@ lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{	//k101
     audio_m8_audio{
         compatible = "amlogic,m8_audio_codec";
         dev_name = "aml_m8_codec.0";
-        status = "disabled";
+        status = "okay";
     };
 
-		aml_audio_codc{
+    aml_audio_codec{
         compatible = "amlogic,audio_codec";
-         codec_rt5616:rt5616{
+        rt5616:rt5616{
             codec_name = "rt5616";
             i2c_addr = <0x1B>;
             i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
             capless = <0>;
             status = "okay";
-                
         };
-        codec_rt5631:rt5631{
+        rt5631:rt5631{
             codec_name = "rt5631";
             i2c_addr = <0x1A>;
             i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
             capless = <0>;
-            status = "disabled";
-                
+            status = "disable";      
         };  
-        codec_wm8960:wm8960{
+        wm8960:wm8960{
             codec_name = "wm8960";
             i2c_addr = <0x1A>;
             i2c_bus = "i2c_bus_b";
             capless = <1>;
-			status = "disabled";
+	    status = "disable";
         };
-		};
- 
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -1338,51 +1340,30 @@ lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{	//k101
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
-            "Ext Spk","LINEOUTL",
-            "Ext Spk","LINEOUTR",
-            "HP","HP_L",
-            "HP","HP_R",
-            "MICBIAS","MAIN MIC",
-            "LINPUT1","MICBIAS";
-            mute_gpio = "GPIOY_15";
-			pinctrl-names = "aml_snd_m8";
-			pinctrl-0 = <&audio_pins>;
-			status = "disabled"; 
-		};
-
-//$$ DEVICE="aml_m8_sound_card"
-//$$ L2 PROP_STR = "aml,sound_card"
-//$$ L2 PROP_STR = "aml,codec_dai"
-//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
-//$$ L2 PROP_STR = "mute_gpio"
-//$$ L2 PROP_U32 5 = "hp_paraments"
-//$$ L2 PROP_STR = "status"
-    aml_m8_rt5616{
-        compatible = "sound_card, aml_m8_rt5616";
-        aml,sound_card = "AML-M8AUDIO-RT5616";
-        aml,codec_dai = "rt5616-aif1";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
             "Ext Spk","LOUTL",
             "Ext Spk","LOUTR",
             "HP","HPOL",
             "HP","HPOR",
             "micbias1","MAIN MIC",
             "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
         mute_gpio = "GPIOY_15";
-        I2S_MCLK = "GPIOAO_8";
-        I2S_SCLK = "GPIOAO_9";
-        I2S_LRCLK = "GPIOAO_10";
-        I2S_ODAT = "GPIOAO_11";
-        //mute_inv;
         hp_paraments = <800 300 0 5 1>;
-        pinctrl-names = "aml_snd_m8";
-        pinctrl-0 = <&audio_pins>;
-		status = "okay";
+		pinctrl-names = "aml_snd_m8";
+		pinctrl-0 = <&audio_pins>;
+		status = "okay"; 
+	};
 
-		};
- 
 /// ***************************************************************************************
 ///	-	Camera
 //$$ MODULE="Camera"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index fee118fb8e83..acca12ed90b7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1315,32 +1315,38 @@ sdio{
     audio_m8_audio{
         compatible = "amlogic,m8_audio_codec";
         dev_name = "aml_m8_codec.0";
-        status = "disabled";
+        status = "okay";
     };
-aml_audio_codc{
+
+    aml_audio_codec{
         compatible = "amlogic,audio_codec";
-         codec_rt5616:rt5616{
+        rt5616:rt5616{
             codec_name = "rt5616";
             i2c_addr = <0x1B>;
             i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
             capless = <0>;
-        status = "okay";
-    };
-        codec_rt5631:rt5631{
+            status = "okay";
+        };
+        rt5631:rt5631{
             codec_name = "rt5631";
             i2c_addr = <0x1A>;
             i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
             capless = <0>;
-            status = "disabled";
+            status = "disable";      
         };  
-        codec_wm8960:wm8960{
+        wm8960:wm8960{
             codec_name = "wm8960";
             i2c_addr = <0x1A>;
             i2c_bus = "i2c_bus_b";
             capless = <1>;
-            status = "disabled";
+	    status = "disable";
         };
-};
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -1351,52 +1357,29 @@ aml_audio_codc{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
-            "Ext Spk","LINEOUTL",
-            "Ext Spk","LINEOUTR",
-            "HP","HP_L",
-            "HP","HP_R",
-            "MICBIAS","MAIN MIC",
-            "LINPUT1","MICBIAS";
-            mute_gpio = "GPIOY_15";
-			pinctrl-names = "aml_snd_m8";
-			pinctrl-0 = <&audio_pins>;
-			status = "disabled"; 
-		};
-//$$ DEVICE="aml_m8_sound_card"
-//$$ L2 PROP_STR = "aml,sound_card"
-//$$ L2 PROP_STR = "aml,codec_dai"
-//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
-//$$ L2 PROP_STR = "mute_gpio"
-//$$ L2 PROP_U32 5 = "hp_paraments"
-//$$ L2 PROP_STR = "status"
-    aml_m8_rt5616{
-        compatible = "sound_card, aml_m8_rt5616";
-        aml,sound_card = "AML-M8AUDIO-RT5616";
-        aml,codec_dai = "rt5616-aif1";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
             "Ext Spk","LOUTL",
             "Ext Spk","LOUTR",
             "HP","HPOL",
             "HP","HPOR",
             "micbias1","MAIN MIC",
             "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
         mute_gpio = "GPIOY_15";
-        I2S_MCLK = "GPIOAO_8";
-        I2S_SCLK = "GPIOAO_9";
-        I2S_LRCLK = "GPIOAO_10";
-        I2S_ODAT = "GPIOAO_11";
-        //mute_inv;
         hp_paraments = <800 300 0 5 1>;
-        pinctrl-names = "aml_snd_m8";
-        pinctrl-0 = <&audio_pins>;
-        status = "okay";
-        
-    };
-
-
-
+		pinctrl-names = "aml_snd_m8";
+		pinctrl-0 = <&audio_pins>;
+		status = "okay"; 
+	};
 
 /// ***************************************************************************************
 ///	-	Camera
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index 4e0d2df78c5d..aa8129b01e20 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -903,6 +903,35 @@ sdio{
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -915,8 +944,17 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
index 48871cfd7aa0..edb431fba95f 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
@@ -903,6 +903,35 @@ sdio{
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -915,8 +944,17 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
index 126ffec7bc03..fee134e1e6a7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
@@ -904,6 +904,35 @@ sdio{
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -916,8 +945,17 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
index e1ea957ffedf..28f90921bfe7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
@@ -902,6 +902,35 @@ sdio{
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -914,8 +943,17 @@ sdio{
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/boot/dts/amlogic/meson8_pxp.dtd b/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
index 1e3e977db06a..91ea6798b0f5 100755
--- a/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
@@ -828,6 +828,35 @@ void root_func(){
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -840,8 +869,17 @@ void root_func(){
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index 930ae966a1ba..15874680fce5 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -850,6 +850,35 @@ void root_func(){
         status = "okay";
     };
 
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
 //$$ DEVICE="aml_m8_sound_card"
 //$$ L2 PROP_STR = "aml,sound_card"
 //$$ L2 PROP_STR = "aml,codec_dai"
@@ -862,8 +891,17 @@ void root_func(){
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","dit-hifi";
-        aml,audio-routing =
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
             "Ext Spk","LINEOUTL",
             "Ext Spk","LINEOUTR",
             "HP","HP_L",
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index eeefba9827a0..c2bc090ab613 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -279,7 +279,6 @@ CONFIG_BACKLIGHT_LCD_SUPPORT=y
 CONFIG_SND_USB_AUDIO=y
 CONFIG_SND_AML_M8_SOC=y
 CONFIG_SND_AML_M8=y
-CONFIG_SND_AML_M8_RT5616=y
 CONFIG_UHID=y
 CONFIG_USB=y
 CONFIG_USB_ACM=y
diff --git a/include/linux/amlogic/aml_audio_codec_probe.h b/include/linux/amlogic/aml_audio_codec_probe.h
index 15e534cdccff..97f9649470dc 100755
--- a/include/linux/amlogic/aml_audio_codec_probe.h
+++ b/include/linux/amlogic/aml_audio_codec_probe.h
@@ -9,6 +9,7 @@
 #define AML_I2C_BUS_C 3
 #define AML_I2C_BUS_D 4
 
+#define NAME_SIZE 32
 
 typedef int(*aml_audio_codec_probe_fun_t)(struct i2c_adapter *);
 
@@ -17,11 +18,24 @@ typedef struct {
 	const char* status;
 	unsigned i2c_bus_type;
 	unsigned i2c_addr;
+	unsigned id_reg;
+	unsigned id_val;
     unsigned capless;
 }aml_audio_codec_info_t;
 
-extern bool is_rt5631;
-extern bool is_wm8960;
+enum codecs_enum{
+	aml_codec = 0,
+	rt5616,
+	rt5631,
+	wm8960,
+};
 
+typedef struct {
+	enum codecs_enum codec_index;
+	char name[NAME_SIZE];
+	char name_bus[NAME_SIZE];
+}codec_info_t;
+
+extern codec_info_t codec_info;
 
 #endif
diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index 4d9ad2cf0582..cfcfa52a9fa6 100755
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -6,13 +6,12 @@ config SND_AML_M8
 	tristate "AML-SND-M8 Board"
 	depends on SND_AML_M8_SOC && SWITCH
 	select SND_SOC_AML_M8_CODEC if SND_AML_M8
+	select SND_SOC_RT5616 if SND_AML_M8
+	select SND_SOC_WM8960
+	select SND_SOC_RT5631
 	
 config SND_AML_M8_PCM
 	tristate "M8 evaluation board with PCM2BT"
 	depends on SND_AML_M8_SOC
 	select SND_SOC_PCM2BT if SND_AML_M8_PCM
 	
-config SND_AML_M8_RT5616
-tristate "M8 evaluation board with RT5616"
-depends on SND_AML_M8_SOC
-select SND_SOC_RT5616 if SND_AML_M8_RT5616
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
index 52ccdce40772..b0db67d6bb7f 100755
--- a/sound/soc/aml/m8/Makefile
+++ b/sound/soc/aml/m8/Makefile
@@ -27,6 +27,3 @@ obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-spdif-codec.o
 snd-soc-aml-m8-objs := aml_m8.o
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-m8.o
 
-#AML M8 Machine support
-snd-soc-aml-m8-rt5616-objs := aml_m8_rt5616.o
-obj-$(CONFIG_SND_AML_M8_RT5616) += snd-soc-aml-m8-rt5616.o
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index 06c1524e9d04..0db88b739936 100755
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -28,7 +28,7 @@
 
 static aml_dai_info_t dai_info[3] = {{0}};
 static int i2s_pos_sync = 0;
-#define AML_DAI_DEBUG
+//#define AML_DAI_DEBUG
 //#define AML_DAI_PCM_SUPPORT 
 
 
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 1221214c201c..55bcbb1d1ef1 100755
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -44,6 +44,7 @@
 #include <linux/of.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/amlogic/aml_audio_codec_probe.h>
 #include <linux/of_gpio.h>
 #include <mach/pinmux.h>
 #include <plat/io.h>
@@ -124,7 +125,6 @@ static int hp_det_adc_value(struct aml_audio_private_data *p_aml_audio)
 
 static int aml_audio_hp_detect(struct aml_audio_private_data *p_aml_audio)
 {
-       // return 0;
    int loop_num = 0;
    int ret;
 
@@ -169,11 +169,11 @@ static void aml_asoc_work_func(struct work_struct *work)
         p_aml_audio->detect_flag = flag;
         
         if (flag & 0x1) {
-            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            //amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
             switch_set_state(&p_aml_audio->sdev, 2);  // 1 :have mic ;  2 no mic
             adac_wr_reg (71, 0x0101); // use board mic
             printk(KERN_INFO "aml aduio hp pluged 3 jack_type: %d\n", SND_JACK_HEADPHONE);
-           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
 
            // mic port detect
            if(p_aml_audio->mic_det){
@@ -186,17 +186,17 @@ static void aml_asoc_work_func(struct work_struct *work)
            }
 
         } else if(flag & 0x2){
-            amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
+            //amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
             switch_set_state(&p_aml_audio->sdev, 1);  // 1 :have mic ;  2 no mic
             adac_wr_reg (71, 0x0005); // use hp mic
             printk(KERN_INFO "aml aduio hp pluged 4 jack_type: %d\n", SND_JACK_HEADSET);
-           // snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
+            snd_soc_jack_report(&p_aml_audio->jack, status, SND_JACK_HEADPHONE);
         } else {
             printk(KERN_INFO "aml audio hp unpluged\n");
-            amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+            //amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
             adac_wr_reg (71, 0x0101); // use board mic
             switch_set_state(&p_aml_audio->sdev, 0);
-            //snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
+            snd_soc_jack_report(&p_aml_audio->jack, 0, SND_JACK_HEADPHONE);
 
             // mic port detect
             if(p_aml_audio->mic_det){
@@ -248,7 +248,7 @@ static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
         printk(KERN_ERR "%s: set cpu dai fmt failed!\n", __func__);
         return ret;
     }
-#if 0
+#if 1
     /* set codec DAI clock */
     ret = snd_soc_dai_set_sysclk(codec_dai, 0, params_rate(params) * 256, SND_SOC_CLOCK_IN);
     if (ret < 0) {
@@ -303,10 +303,12 @@ static int aml_set_bias_level(struct snd_soc_card *card,
 {
     int ret = 0;
     struct aml_audio_private_data * p_aml_audio;
-    p_aml_audio = snd_soc_card_get_drvdata(card);
+    int hp_state;
+
     printk(KERN_DEBUG "enter %s level: %d\n", __func__, level);
+    p_aml_audio = snd_soc_card_get_drvdata(card);
+	hp_state = p_aml_audio->detect_flag;
 
-    int hp_state = p_aml_audio->detect_flag;
     if (p_aml_audio->bias_level == (int)level)
         return 0;
 
@@ -375,14 +377,32 @@ static int aml_resume_post(struct snd_soc_card *card)
 #define aml_resume_pre   NULL
 #define aml_resume_post  NULL
 #endif
+static int speaker_events(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		amlogic_set_value(p_audio->gpio_mute, 1, "mute_spk");
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		amlogic_set_value(p_audio->gpio_mute, 0, "mute_spk");
+		break;
+	}
+
+	return 0;
+}
 
 static const struct snd_soc_dapm_widget aml_asoc_dapm_widgets[] = {
-    SND_SOC_DAPM_SPK("Ext Spk", NULL),
+    SND_SOC_DAPM_SPK("Ext Spk", speaker_events),
     SND_SOC_DAPM_HP("HP", NULL),
     SND_SOC_DAPM_MIC("MAIN MIC", NULL),
     SND_SOC_DAPM_MIC("HEADSET MIC", NULL),
 };
 
+static const struct snd_kcontrol_new aml_asoc_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
 static struct snd_soc_jack_pin jack_pins[] = {
     {
         .pin = "HP",
@@ -391,16 +411,19 @@ static struct snd_soc_jack_pin jack_pins[] = {
 };
 
 static const struct snd_kcontrol_new aml_m8_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
 
-    SOC_SINGLE_BOOL_EXT("Amp Spk enable", 0,
-        aml_m8_get_spk,
-        aml_m8_set_spk),
 /*
+	SOC_SINGLE_BOOL_EXT("Amp Spk enable", 0,
+		aml_m8_get_spk,
+		aml_m8_set_spk),
+
     SOC_SINGLE_BOOL_EXT("Audio MPLL9 Switch", 0,
     aml_m8_get_MPLL9,
     aml_m8_set_MPLL9),
     */
 };
+
 static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_card *card = rtd->card;
@@ -418,8 +441,8 @@ static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
        return ret;
 
     /* Add specific widgets */
-    //snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
-    //              ARRAY_SIZE(aml_asoc_dapm_widgets));
+    snd_soc_dapm_new_controls(dapm, aml_asoc_dapm_widgets,
+                  ARRAY_SIZE(aml_asoc_dapm_widgets));
     ret = snd_soc_jack_new(codec, "hp switch", SND_JACK_HEADPHONE, &p_aml_audio->jack);
     if (ret < 0) {
         printk(KERN_WARNING "Failed to alloc resource for hp switch\n");
@@ -473,7 +496,7 @@ static struct snd_soc_dai_link aml_codec_dai_link[] = {
         .cpu_dai_name = "aml-i2s-dai.0",
         .init = aml_asoc_init,
         .platform_name = "aml-i2s.0",
-        .codec_name = "aml_m8_codec.0",
+        //.codec_name = "aml_m8_codec.0",
         .ops = &aml_asoc_ops,
     },
 #ifdef CONFIG_SND_SOC_PCM2BT
@@ -533,8 +556,8 @@ static void aml_m8_pinmux_init(struct snd_soc_card *card)
 	}else{
 		p_aml_audio->gpio_mute = amlogic_gpio_name_map_num(str);
 		p_aml_audio->mute_inv = of_property_read_bool(card->dev->of_node,"mute_inv");
-		amlogic_gpio_request_one(p_aml_audio->gpio_mute,GPIOF_OUT_INIT_HIGH,"mute_spk");
-		amlogic_set_value(p_aml_audio->gpio_mute, 1, "mute_spk");
+		amlogic_gpio_request_one(p_aml_audio->gpio_mute,GPIOF_OUT_INIT_LOW,"mute_spk");
+		amlogic_set_value(p_aml_audio->gpio_mute, 0, "mute_spk");
 	}
 
 	printk("=%s==,aml_m8_pinmux_init done,---%d\n",__func__,p_aml_audio->det_pol_inv);
@@ -554,13 +577,12 @@ static void aml_m8_pinmux_deinit(struct snd_soc_card *card)
 }
 static int aml_m8_audio_probe(struct platform_device *pdev)
 {
-    //struct device_node *np = pdev->dev.of_node;
+    struct device_node *np;
     struct snd_soc_card *card = &aml_snd_soc_card;
     struct aml_audio_private_data *p_aml_audio;
+	char tmp[NAME_SIZE];
     int ret = 0;
 
-    printk(KERN_DEBUG "enter %s\n", __func__);
-
 #ifdef CONFIG_USE_OF
     p_aml_audio = devm_kzalloc(&pdev->dev,
             sizeof(struct aml_audio_private_data), GFP_KERNEL);
@@ -582,18 +604,28 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
     ret = snd_soc_of_parse_card_name(card, "aml,sound_card");
     if (ret)
         goto err;
-    
+
     ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
-            0, &aml_codec_dai_link[0].codec_dai_name);
+            codec_info.codec_index, &aml_codec_dai_link[0].codec_dai_name);
     if (ret)
         goto err;
 
-    //ret = snd_soc_of_parse_audio_routing(card, "aml,audio-routing");
+	printk("codec_name = %s\n", codec_info.name_bus);
+
+	aml_codec_dai_link[0].codec_name = codec_info.name_bus;
+
+    //ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_name",
+    //        0, &aml_codec_dai_link[0].codec_name);
     //if (ret)
-    //  goto err;
+    //    goto err;
 
-//  aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
-//          pdev->dev.of_node, "aml,audio-codec", 0);
+	 //aml_codec_dai_link[0].codec_of_node = of_parse_phandle(
+	//		 pdev->dev.of_node, "aml,audio-codec", 0);
+	snprintf(tmp, NAME_SIZE, "%s-%s", "aml,audio-routing", codec_info.name);
+
+    ret = snd_soc_of_parse_audio_routing(card, tmp);
+    if (ret)
+    	goto err;
 
     ret = snd_soc_register_card(card);
     if (ret) {
diff --git a/sound/soc/codecs/aml_m8_codec.c b/sound/soc/codecs/aml_m8_codec.c
index 71377f62aeec..1a3657a8b908 100755
--- a/sound/soc/codecs/aml_m8_codec.c
+++ b/sound/soc/codecs/aml_m8_codec.c
@@ -27,10 +27,6 @@
 
 #include <linux/of.h>
 
-//#define MODELQUICKSTART
-#define stimulus_print   printk
-u16 aml_m8_reg[252] = {0};
-
 unsigned int acodec_regbank[252] = {0x00, 0x05, 0x00, 0x01, 0x7d, 0x02, 0x7d, 0x02, 0x01, 0x7d, // Reg   0 -   9
                                     0x02, 0x7d, 0x02, 0x01, 0x7d, 0x02, 0x7d, 0x02, 0x00, 0x00, // Reg  10 -  19
                                     0xce, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Reg  20 -  29
@@ -83,8 +79,8 @@ unsigned  long adac_rd_reg (unsigned long addr)
 
 static bool aml_m8_is_16bit_reg(unsigned int reg)
 {
-	return 	(reg == 0x24) || (reg == 0x26) || (reg == 0x34) ||
-			(reg == 0x38) || (reg == 0x47) || (reg == 0x59) ||
+	return 	(reg == 0x24) || (reg == 0x26) || //(reg == 0x34) ||
+			/*(reg == 0x38) ||*/ (reg == 0x47) || //(reg == 0x59) ||
 			(reg == 0x5d) || (reg == 0x80) || (reg == 0x82) ||
 			(reg == 0x88) || (reg == 0x8a);
 }
@@ -149,7 +145,7 @@ static int aml_m8_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
 	}
 
 	/* set iface */
-	//snd_soc_write(codec, AMLM8_I2S1_CONFIG_0, iface);
+	snd_soc_write(codec, AMLM8_I2S1_CONFIG_0, iface);
 	return 0;
 }
 
@@ -157,9 +153,27 @@ static int aml_m8_codec_hw_params(struct snd_pcm_substream *substream,
 			    struct snd_pcm_hw_params *params,
 			    struct snd_soc_dai *dai)
 {
-	//struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	//struct snd_soc_codec *codec = rtd->codec;
-	//u16 iface = snd_soc_read(codec, AMLM8_I2S1_CONFIG_0) & 0xcf;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	u16 iface = snd_soc_read(codec, AMLM8_I2S1_CONFIG_0) & 0xcf;
+
+    /* bit size */
+    switch (params_format(params)) {
+    case SNDRV_PCM_FORMAT_S16_LE:
+		iface |= 0x30;
+        break;
+    case SNDRV_PCM_FORMAT_S20_3LE:
+        iface |= 0x10;
+        break;
+    case SNDRV_PCM_FORMAT_S24_LE:
+        break;
+	case SNDRV_PCM_FORMAT_S18_3LE:
+        iface |= 0x20;
+        break;
+    }
+	
+	/* set iface */
+	snd_soc_write(codec, AMLM8_I2S1_CONFIG_0, iface);
 
 	return 0;
 }
@@ -190,7 +204,7 @@ static int aml_m8_codec_set_dai_sysclk(struct snd_soc_dai *dai,
 		reg |= 0x07;
 		break;
 	default:
-		return -EINVAL;
+		break;
 	}
 	
 	snd_soc_write(codec, AMLM8_CLK_EXT_SELECT, reg);
@@ -198,6 +212,12 @@ static int aml_m8_codec_set_dai_sysclk(struct snd_soc_dai *dai,
 	return 0;
 }
 
+static int aml_m8_codec_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,
+            unsigned int freq_in, unsigned int freq_out)
+{
+    return 0;
+}
+
 static int aml_m8_codec_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
 		int div_id, int div)
 {
@@ -228,8 +248,9 @@ static int aml_m8_codec_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
 static struct snd_soc_dai_ops aml_m8_codec_dai_ops = {
  	.hw_params	= aml_m8_codec_hw_params,
 	.digital_mute = aml_m8_codec_mute,
-	//.set_sysclk	= aml_m8_codec_set_dai_sysclk,
-	//.set_clkdiv = aml_m8_codec_set_dai_clkdiv,
+	.set_sysclk	= aml_m8_codec_set_dai_sysclk,
+	.set_clkdiv = aml_m8_codec_set_dai_clkdiv,
+    .set_pll = aml_m8_codec_set_dai_pll,
 	.set_fmt	= aml_m8_codec_set_dai_fmt,
 };
 #define AML_RATES SNDRV_PCM_RATE_8000_96000
@@ -257,8 +278,6 @@ struct snd_soc_dai_driver aml_m8_codec_dai = {
 static int aml_m8_set_bias_level(struct snd_soc_codec *codec,
                  enum snd_soc_bias_level level)
 {
-    //printk("****aml_m8_bias_level**level=%d,codec->dapm.bias_level=%d\n",level,codec->dapm.bias_level);
-#if 1
     switch (level) {
     case SND_SOC_BIAS_ON:
         break;
@@ -299,145 +318,12 @@ static int aml_m8_set_bias_level(struct snd_soc_codec *codec,
     }
     codec->dapm.bias_level = level;
     return 0;
-#else
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		break;
-	case SND_SOC_BIAS_PREPARE:
-		switch (codec->dapm.bias_level) {
-		case SND_SOC_BIAS_STANDBY:
-			/* 1/60 current */
-			snd_soc_update_bits(codec, AMLM8_IREF, 0xf, 0xc);
-			/* pdz to high */
-			snd_soc_update_bits(codec, AMLM8_PD_0, 0x1, 0x1);
-			/* normal current */
-			snd_soc_update_bits(codec, AMLM8_IREF, 0xf, 0x0);
-			break;
-
-		default:
-			break;
-		}
-
-		break;
-	case SND_SOC_BIAS_STANDBY:
-		switch (codec->dapm.bias_level) {
-		case SND_SOC_BIAS_PREPARE:
-			/* 3/2 current */
-			snd_soc_update_bits(codec, AMLM8_IREF, 0xf, 0x3);
-			/* pdz to high */
-			snd_soc_update_bits(codec, AMLM8_PD_0, 0x1, 0x0);
-			/* normal current */
-			snd_soc_update_bits(codec, AMLM8_IREF, 0xf, 0x0);			
-			break;
-
-		default:
-			break;
-		}
-
-		break;
-		
-	case SND_SOC_BIAS_OFF:
-	    break;
-	default:
-	    break;
-	}
-	codec->dapm.bias_level = level;
-	return 0;
-#endif
 }
 static void acodec_delay_us (int us)
 {
 	msleep(us/1000);
 } /* acodec_delay_us */
 
-
-static void adac_rd_check_reg (unsigned int addr, unsigned int exp_data, unsigned int mask)
-{
-    unsigned int rd_data;
-    rd_data = adac_rd_reg(addr);
-    if ((rd_data | mask) != (exp_data | mask)) {
-        stimulus_print("[TEST.C] Error: audio CODEC register read data mismatch!\n");
-        stimulus_print("addr=0x%x ,",addr);
-        stimulus_print(" rd_data=0x%x ,",rd_data);
-        stimulus_print(" exp_data=0x%x\n",exp_data);
-    }
-    printk("adac_rd_check_reg addr %x ,value %x \n", addr,rd_data);	
-} /* adac_rd_check_reg */
-
-void acodec_standby (struct snd_soc_codec *codec)
-{
-    unsigned long data32;
-    
-    stimulus_print("[TEST.C] audio CODEC Standby mode -- Begin\n");
-
-    // Apply reset for at least 3 clk_ext cycles
-    aml_set_reg32_bits(P_AIU_AUDAC_CTRL0, 1, 15, 1); 
-    acodec_delay_us(20);
-    aml_set_reg32_bits(P_AIU_AUDAC_CTRL0, 0, 15, 1); 
-
-    // Set up register :
-    //   pd* all low
-    //   ensleep high
-    //   cfganasleep high
-    //   cfgdigsleep low
-
-    data32  = 0;
-    data32 |= 0 << 1;   // [    1] cfg_prech_anaref
-    data32 |= 0 << 0;   // [    0] bypass_pwr_seq
-    snd_soc_write(codec, 19, data32);
-
-    data32  = 0;
-    data32 |= 0 << 4;   // [    4] pd_micb2z
-    data32 |= 0 << 3;   // [    3] pd_micb1z
-    data32 |= 0 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 0 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 0 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-
-    data32  = 0;
-    data32 |= 0 << 5;   // [    5] pd_pga2rz
-    data32 |= 0 << 4;   // [    4] pd_pga2lz
-    data32 |= 0 << 3;   // [    3] pd_pga1rz
-    data32 |= 0 << 2;   // [    2] pd_pga1lz
-    data32 |= 0 << 1;   // [    1] pd_adcrz
-    data32 |= 0 << 0;   // [    0] pd_adclz
-    snd_soc_write(codec, 22, data32);
-
-    data32  = 0;
-    data32 |= 0 << 7;   // [    7] pd_ld1rz
-    data32 |= 0 << 6;   // [    6] pd_ld1lz
-    data32 |= 0 << 5;   // [    5] pd_hs1rz
-    data32 |= 0 << 4;   // [    4] pd_hs1lz
-    data32 |= 0 << 1;   // [    1] pd_dacrz
-    data32 |= 0 << 0;   // [    0] pd_daclz
-    snd_soc_write(codec, 24, data32);
-
-    data32  = 0;
-    data32 |= 5 << 0;   // [ 3: 0] clk_ext_sel
-    snd_soc_write(codec, 1, data32);
-
-    data32  = 0;
-    data32 |= 0xc << 4; // [ 7: 4] cfganasleepiref
-    data32 |= 1   << 3; // [    3] cfganasleep
-    data32 |= 0   << 2; // [    2] cfgdigsleep
-    data32 |= 1   << 1; // [    1] envcmhold
-    data32 |= 1   << 0; // [    0] ensleep
-    snd_soc_write(codec, 20, data32);
-
-    // Set pdz to high
-    data32  = 0;
-    data32 |= 0 << 4;   // [    4] pd_micb2z
-    data32 |= 0 << 3;   // [    3] pd_micb1z
-    data32 |= 0 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 0 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 1 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-
-    acodec_delay_us(10);
-    stimulus_print("[TEST.C] audio CODEC Standby mode -- End\n");
-} /* acodec_standby */
-
-
 void acodec_normal_startup (struct snd_soc_codec *codec)
 {
 	unsigned int data32;
@@ -454,6 +340,7 @@ void acodec_normal_startup (struct snd_soc_codec *codec)
     snd_soc_write(codec, 6, 64);
     snd_soc_write(codec, 7, 4);
     
+	snd_soc_write(codec, 3, 1);//i2s1_mode
     data32  = 0;
     data32 |= 0 << 1;   // [    1] rstadcdpz
     data32 |= 0 << 0;   // [    0] rstdacdpz
@@ -466,81 +353,18 @@ void acodec_normal_startup (struct snd_soc_codec *codec)
     data32 |= 1 << 0;   // [    0] rstdacdpz
     snd_soc_write(codec, 0, data32);
     
-    data32  = 0;
-    data32 |= 1 << 4;   // [    4] pd_micb2z
-    data32 |= 1 << 3;   // [    3] pd_micb1z
-    data32 |= 1 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 1 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 1 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-
-	data32 = 0;
-	while(1){
-		data32 |= (snd_soc_read(codec, 83) | 0x3);
-		printk("acodec_normal_startup::reg83=%d\n", data32);
-		if(data32 == 3)
-			break;
-	}
-	
-}
-
-void acodec_startup_sequence (struct snd_soc_codec *codec)
-{
-    unsigned int data32;
-
-    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- Begin\n");
-    
-    //--------------------------------------------------------------------------
-    // 1.	select the master clock mode mclksel[3:0] bit
-    // 2.	start the master clock
-    // 3.	set pdz bit to high
-    // 4.	select the sampling rate
-    // 5.	reset the signal path (rstdpz pin to low and back to high after 100ns)
-    // 6.	start the individual codec blocks
-    // 	    7.1.1	Pop free start up recommendations
-    // 	    To obtain a pop-free start-up for the playback channel, the corresponding 
-    // 	    blocks in the desired playback signal path must also be enable when setting
-    // 	    the master power up control active, as per the start-up sequence step 3 
-    // 	    (above).
-    //      
-    // 	    For example, when setting pdz bit to high, pddacl/rz bit, pdhsdrvl/rz bit 
-    // 	    and/or pdauxdrvl/rz bit should also be set to high at the same time to
-    // 	    obtain a clean, pop-free start up.
-    // 	    By using the latch signal properly, it is possible to guarantee that all the
-    // 	    required power control, signals are loaded to the Audio Codec IP
-    // 	    simultaneously.
-
-    // Apply reset for at least 3 clk_ext cycles
-    WRITE_MPEG_REG_BITS(AIU_AUDAC_CTRL0, 1, 15, 1); 
-    acodec_delay_us(20);
-    WRITE_MPEG_REG_BITS(AIU_AUDAC_CTRL0, 0, 15, 1); 
-
-    // Set pdz to low
-    data32  = 0;
-    data32 |= 0 << 4;   // [    4] pd_micb2z
-    data32 |= 0 << 3;   // [    3] pd_micb1z
-    data32 |= 0 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 0 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 0 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-    
-    acodec_delay_us(3000);
-
-    snd_soc_write(codec, 71, 0);
+	//set the nominal current
+	snd_soc_write(codec, 0x12, 0x0);
 
     // Disable soft-ramping
     data32  = 0;
-    data32 |= 1 << 7;   // [    7] disable_sr
-    data32 |= 2 << 5;   // [ 6: 5] dither_lvl
+    data32 |= 0 << 7;   // [    7] disable_sr
+    data32 |= 0 << 5;   // [ 6: 5] dither_lvl
     data32 |= 0 << 4;   // [    4] noise_shape_en
-    data32 |= 0 << 2;   // [ 3: 2] dem_cfg
+    data32 |= 3 << 2;   // [ 3: 2] dem_cfg
     data32 |= 0 << 0;   // [ 1: 0] cfg_adc_dither
-    snd_soc_write(codec, 243, data32);
-    acodec_delay_us(4000);
-
-    acodec_delay_us(10);
-    stimulus_print("[TEST.C] audio CODEC Startup Sequence -- End\n");
-} /* acodec_startup_sequence */
+    snd_soc_write(codec, 0xF3, data32);
+}
 
 void acodec_config(unsigned int clk_ext_sel,           // [3:0]: 0=1.958M~2.65M; 1=2.6M~3.5M; 2=3.9M~5.3M; 3=5.2M~7.06M; 4=10.2M~13.8M;
                                                         //        5=15.3M~20.7M; 6=20.4M~26.6M; 7=25.5M~34.5M; 8=30.6M~41.4M; 9=40.8M~55.2M.
@@ -577,7 +401,6 @@ void acodec_config(unsigned int clk_ext_sel,           // [3:0]: 0=1.958M~2.65M;
                    unsigned int ctr,                   // [2:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback, 4=Shaping filters loop-back.
                    unsigned int enhp)                  // Record channel high pass filter enable.
 {
-    stimulus_print("[TEST.C] audio CODEC register config -- Begin\n");
     adac_wr_reg(1, clk_ext_sel);
     adac_wr_reg(5, i2s1_play_sclk_div);
     adac_wr_reg(4, i2s1_play_lrclk_div);
@@ -596,134 +419,19 @@ void acodec_config(unsigned int clk_ext_sel,           // [3:0]: 0=1.958M~2.65M;
     adac_wr_reg(93, ld2_sel);
     adac_wr_reg(210, ctr);
     adac_wr_reg(211, (enhp<<2));
-    stimulus_print("[TEST.C] audio CODEC register config -- End\n");
 }
 
-void acodec_prepare_register (struct snd_soc_codec *codec)
+void acodec_reserved_reg_set (struct snd_soc_codec *codec)
 {
-    unsigned int data32;
-    
-    stimulus_print("[TEST.C] acodec_prepare_register -- Begin\n");
-    
-    // Individual blocks out of power down
-
-    data32  = 0;
-    data32 |= 1 << 4;   // [    4] pd_micb2z
-    data32 |= 1 << 3;   // [    3] pd_micb1z
-    data32 |= 1 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 1 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 0 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-
-    data32  = 0;
-    data32 |= 1 << 5;   // [    5] pd_pga2rz
-    data32 |= 1 << 4;   // [    4] pd_pga2lz
-    data32 |= 1 << 3;   // [    3] pd_pga1rz
-    data32 |= 1 << 2;   // [    2] pd_pga1lz
-    data32 |= 1 << 1;   // [    1] pd_adcrz
-    data32 |= 1 << 0;   // [    0] pd_adclz
-    snd_soc_write(codec, 22, data32);
-
-    data32  = 0;
-    data32 |= 1 << 7;   // [    7] pd_ld1rz
-    data32 |= 1 << 6;   // [    6] pd_ld1lz
-    data32 |= 1 << 5;   // [    5] pd_hs1rz
-    data32 |= 1 << 4;   // [    4] pd_hs1lz
-    data32 |= 1 << 1;   // [    1] pd_dacrz
-    data32 |= 1 << 0;   // [    0] pd_daclz
-    snd_soc_write(codec, 24, data32);
-
-    data32  = 0;
-    data32 |= 1 << 7;   // [    7] pd_ggbda2rz
-    data32 |= 1 << 6;   // [    6] pd_ggbda2lz
-    data32 |= 1 << 5;   // [    5] pd_ggbda1rz
-    data32 |= 1 << 4;   // [    4] pd_ggbda1lz
-    data32 |= 1 << 3;   // [    3] pd_ld2rz
-    data32 |= 1 << 2;   // [    2] pd_ld2lz
-    data32 |= 1 << 1;   // [    1] pd_hs2rz
-    data32 |= 1 << 0;   // [    0] pd_hs2lz
-    snd_soc_write(codec, 25, data32);
-
-//    data32  = 0;
-//    data32 |= 5 << 0;   // [ 3: 0] clk_ext_sel
-//    adac_wr_reg(1, data32);
-
-    data32  = 0;
-    data32 |= 0xc << 4; // [ 7: 4] cfganasleepiref
-    data32 |= 1   << 3; // [    3] cfganasleep
-    data32 |= 1   << 2; // [    2] cfgdigsleep
-    data32 |= 1   << 1; // [    1] envcmhold
-    data32 |= 0   << 0; // [    0] ensleep
-    snd_soc_write(codec, 20, data32);
-
-//    adac_wr_reg(38, 0x0606);
+	unsigned int data32;
 
-    data32  = 0;
+	data32  = 0;
     data32 |= 0   << 5; // [ 6: 5] cfg_adc_vcmi
     data32 |= 0   << 3; // [ 4: 3] cfg_dac_vcmi
     data32 |= 0   << 2; // [    2] sel_in_vcm_buf
     data32 |= 0   << 0; // [ 1: 0] cfg_vcm_buf
     snd_soc_write(codec, 220, data32);
 
-    data32  = 0;
-    data32 |= 0   << 0; // [ 3: 0] config_ana_3
-    snd_soc_write(codec, 251, data32);
-
-    stimulus_print("[TEST.C] acodec_prepare_register -- End\n");
-} /* acodec_prepare_register */
-
-void acodec_powerup_bypassfastcharge (struct snd_soc_codec *codec)
-{
-    unsigned int data32;
-    
-    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- Begin\n");
-
-    data32  = 0;
-    data32 |= 0 << 1;   // [    1] cfg_prech_anaref
-    data32 |= 1 << 0;   // [    0] bypass_pwr_seq
-    snd_soc_write(codec, 19, data32);
-    acodec_delay_us(1000);
-
-//    // Configure FS related registers
-//    data32  = 0;
-//    data32 |= 0 << 7;   // [    7] pport1_en
-//    data32 |= 0 << 6;   // [    6] i2s1_ext_clk_en
-//    data32 |= 0 << 4;   // [ 5: 4] i2s1_word_sel
-//    data32 |= 0 << 3;   // [    3] i2s1_ms_mode
-//    data32 |= 1 << 0;   // [ 2: 0] i2s1_mode
-//    adac_wr_reg(3, data32);
-
-//    adac_wr_reg(4, 125);    // [7:0] i2s1_play_lrclk_div
-//    adac_wr_reg(5, 2);      // [7:0] i2s1_play_sclk_div
-//    adac_wr_reg(6, 125);    // [7:0] i2s1_rec_lrclk_div
-//    adac_wr_reg(7, 2);      // [7:0] i2s1_rec_sclk_div
-
-    // Cycle reset on data path
-
-    data32  = 0;
-    data32 |= 0 << 1;   // [    1] rstadcdpz
-    data32 |= 0 << 0;   // [    0] rstdacdpz
-    snd_soc_write(codec, 0, data32);
-
-    data32  = 0;
-    data32 |= 1 << 1;   // [    1] rstadcdpz
-    data32 |= 1 << 0;   // [    0] rstdacdpz
-    snd_soc_write(codec, 0, data32);
-
-    data32  = 0;
-    data32 |= 1 << 4;   // [    4] pd_micb2z
-    data32 |= 1 << 3;   // [    3] pd_micb1z
-    data32 |= 1 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 1 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 1 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-
-    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- End\n");
-} /* acodec_powerup_bypassfastcharge */
-void acodec_reserved_reg_set (struct snd_soc_codec *codec)
-{
-	unsigned int data32;
-
 	data32  = 0;
 	data32 |= 0 << 7;    //[7]      tstenadcch
 	data32 |= 1 << 6;    //[6]      enmux
@@ -788,45 +496,6 @@ static void set_acodec_source (unsigned int src)
     // Wait until data change is settled
     while ( (((aml_read_reg32(P_AIU_CODEC_CLK_DATA_CTRL)) >> 12) & 0x3) != src) {}
 } /* set_acodec_source */
-void acodec_powerup_fastcharge (struct snd_soc_codec *codec)
-{
-    unsigned int data32;
-    
-    stimulus_print("[TEST.C] acodec_powerup_fastcharge -- Begin\n");
-
-    data32  = 0;
-    data32 |= 0 << 1;   // [    1] cfg_prech_anaref
-    data32 |= 0 << 0;   // [    0] bypass_pwr_seq
-    snd_soc_write(codec, 19, data32);
-
-    data32  = 0;
-    data32 |= 0 << 0;   // [ 2: 0] DIVa
-    snd_soc_write(codec, 162, data32);
-
-    acodec_delay_us(1000);
-
-    // Cycle reset on data path
-#if 1 
-    data32  = 0;
-    data32 |= 0 << 1;   // [    1] rstadcdpz
-    data32 |= 0 << 0;   // [    0] rstdacdpz
-    snd_soc_write(codec, 0, data32);
-
-    data32  = 0;
-    data32 |= 1 << 1;   // [    1] rstadcdpz
-    data32 |= 1 << 0;   // [    0] rstdacdpz
-    snd_soc_write(codec, 0, data32);
-
-    data32  = 0;
-    data32 |= 1 << 4;   // [    4] pd_micb2z
-    data32 |= 1 << 3;   // [    3] pd_micb1z
-    data32 |= 1 << 2;   // [    2] pd_pgbuf2z
-    data32 |= 1 << 1;   // [    1] pd_pgbuf1z
-    data32 |= 1 << 0;   // [    0] pdz
-    snd_soc_write(codec, 21, data32);
-#endif
-    stimulus_print("[TEST.C] acodec_powerup_bypassfastcharge -- End\n");
-} /* acodec_powerup_fastcharge */
 
 static void start_codec(struct snd_soc_codec *codec)
 {
@@ -841,63 +510,9 @@ static void start_codec(struct snd_soc_codec *codec)
     data32 |= 0x55  << 1;   // [7:1]    audac_i2caddr
     data32 |= 0     << 0;   // [0]      audac_intfsel: 0=use host bus; 1=use I2C.
     aml_write_reg32(P_AIU_AUDAC_CTRL0, data32);
-    // Check read back data
-    data32 = aml_read_reg32(P_AIU_AUDAC_CTRL0);
-    if (data32 != ((1<<14) | (0x55<<1))) {
-        stimulus_print("[TEST.C] Error: AIU_AUDAC_CTRL0 read data mismatch!");
-    }
 
-    // --------------------------------------------------------
-    // audio CODEC register access testing
-    // --------------------------------------------------------
-#if 0
-
-    snd_soc_write(codec, 36, 0xdead);
-    snd_soc_write(codec, 38, 0xbeef);
-    snd_soc_write(codec, 52, 0x1234);
-    snd_soc_write(codec, 56, 0x5678);
-
-    adac_rd_check_reg(36, acodec_regbank[36], 0);
-    adac_rd_check_reg(37, acodec_regbank[37], 0);
-    adac_rd_check_reg(38, acodec_regbank[38], 0);
-    adac_rd_check_reg(39, acodec_regbank[39], 0);
-    adac_rd_check_reg(52, acodec_regbank[52], 0);
-    adac_rd_check_reg(53, acodec_regbank[53], 0);
-    adac_rd_check_reg(56, acodec_regbank[56], 0);
-    adac_rd_check_reg(57, acodec_regbank[57], 0);
-
-    snd_soc_write(codec, 36, 0xbfbf);
-    snd_soc_write(codec, 38, 0x1212);
-    snd_soc_write(codec, 52, 0xe7e7);
-    snd_soc_write(codec, 56, 0x0d0d);
-
-    adac_rd_check_reg(36, acodec_regbank[36], 0);
-    adac_rd_check_reg(37, acodec_regbank[37], 0);
-    adac_rd_check_reg(38, acodec_regbank[38], 0);
-    adac_rd_check_reg(39, acodec_regbank[39], 0);
-    adac_rd_check_reg(52, acodec_regbank[52], 0);
-    adac_rd_check_reg(53, acodec_regbank[53], 0);
-    adac_rd_check_reg(56, acodec_regbank[56], 0);
-    adac_rd_check_reg(57, acodec_regbank[57], 0);
-#endif
-    // --------------------------------------
-    // Setup Audio CODEC
-    // --------------------------------------
-
-    //acodec_standby();
-#if 1
-#ifdef MODELQUICKSTART
-		acodec_powerup_bypassfastcharge(codec);
-#else
-		// TODO
-		acodec_powerup_fastcharge(codec);
-#endif  /* MODELQUICKSTART */
-#endif
-    //acodec_startup_sequence(codec);
 	acodec_normal_startup(codec);
 
-    acodec_prepare_register(codec);
-
     acodec_config(  5,      // clk_ext_sel[3:0]: 0=2.304M+/-15%; 1=3.072M+/-15%; 2=4.608M+/-15%; 3=6.144M+/-15%; 4=9.216M+/-15%;
                             //                   5=12.288M+/-15%; 6=18.432M+/-15%; 7=24.576M+/-15%; 8=30.720M+/-15%; 9=36.864M+/-15%; 10=49.152M+/-15%.
                     4,      // i2s1_play_sclk_div
@@ -905,7 +520,7 @@ static void start_codec(struct snd_soc_codec *codec)
                     4,      // i2s1_rec_sclk_div 
                     64,     // i2s1_rec_lrclk_div
                     0,      // en_i2s1_ext_clk
-                    0,      // i2s1_word_sel: 0=24-bit; 1=20bit; 2=18-bit; 3=16-bit.
+                    3,      // i2s1_word_sel: 0=24-bit; 1=20bit; 2=18-bit; 3=16-bit.
                     0,      // i2s1_ms_mode: 0=slave mode; 1=master mode.
                     1,      // i2s1_mode[2:0]: 0=Right justify, 1=I2S, 2=Left justify, 3=Burst1, 4=Burst2, 5=Mono burst1, 6=Mono burst2, 7=Rsrv.
                     0,      // pga1_mute[1:0]: [0] Input PGA left channel mute; [1] Input PGA right channel mute. 0=un-mute; 1=mute.
@@ -915,7 +530,7 @@ static void start_codec(struct snd_soc_codec *codec)
                     0,      // ld1_out_mute[1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
                     0,      // ld2_out_mute[1:0]: [0] Playback left channel analog mute; [1] Playback right channel analog mute. 0=un-mute; 1=mute.
                     0xbfbf,//0xbfbf, // rec_vol[15:0]: Recording digital master volume control. [7:0] Left; [15:8] Right. 0xbf=0dB.
-                    0x1414, // 0x0606,pga1_vol[15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x12=0dB.
+                    0x2a2a, // 0x0606,pga1_vol[15:0]: Input PGA volume control. [7:0] Left; [15:8] Right. 0x12=0dB.
                     0xe7e7, // lm_vol[15:0]: Digital playback master volume control. [7:0] Left; [15:8] Right. 0xe7=0dB.
                     0x0d0d, // hs1_vol[15:0]: Headset analog volume control. [7:0] Left; [15:8] Right. 0x0d=0dB.
                     0x0101, // pga1_sel[15:0]: PGA input selection. [7:0] Left; [15:8] Right. 0=ain1p/n, 1=ain1p, 4=ain2p/n, 5=ain2p, 3=ain3.
@@ -932,7 +547,7 @@ static void start_codec(struct snd_soc_codec *codec)
                             // [ 0] Signal from left channel DAC output.  0=Disabled; 1=Enabled;
                     0,      // ctr[2:0]: test mode sel. 0=Normal, 1=Digital filter loopback, 2=Digital filter bypass, 3=Digital audio I/F loopback, 4=Shaping filters loop-back.
                     1);     // enhp: Record channel high pass filter enable.
-//acodec_powerup_fastcharge(codec);
+
     data32  = 0;
     data32 |= 0 << 1;   // [    1] rstadcdpz
     data32 |= 0 << 0;   // [    0] rstdacdpz
@@ -967,7 +582,6 @@ void aml_m8_codec_reset(struct snd_soc_codec* codec)
 
 	set_acodec_source(2);
 	audio_util_set_dac_i2s_format(0);
-    stimulus_print("I2S clock setting over!!\n");
 
 	start_codec(codec);
     snd_soc_write(codec,0x7b,0x03);  // record left frame output the playback left and right channels. 
@@ -1005,22 +619,22 @@ static const char *wf_freq[] = {
 };
 static const char *digi_mixer[] = {
 	"Stereo Mode", "Mixed Mode", "Switch Mode", 
-	"Left Mono Mode", "Left Mono Mode"
+	"Left Mono Mode", "Right Mono Mode"
 };
 
 static const struct soc_enum amlm8_enum[] = {
 	SOC_ENUM_SINGLE(AMLM8_WIND_FILTER, 0, 8, wf_freq),	
 	SOC_ENUM_SINGLE(AMLM8_NOISE_GATE_0, 1, 4, noise_gate),
-	SOC_ENUM_SINGLE(AMLM8_REC_DMIX, 1, 5, digi_mixer),
-	SOC_ENUM_SINGLE(AMLM8_PB_DMIX, 1, 5, digi_mixer),
-	SOC_ENUM_SINGLE(AMLM8_I2S1_DMIX, 1, 5, digi_mixer)
+	SOC_ENUM_SINGLE(AMLM8_REC_DMIX, 0, 5, digi_mixer),
+	SOC_ENUM_SINGLE(AMLM8_PB_DMIX, 0, 5, digi_mixer),
+	SOC_ENUM_SINGLE(AMLM8_I2S1_DMIX, 0, 5, digi_mixer)
 };
 
 static const struct snd_kcontrol_new amlm8_snd_controls[] = {
-SOC_DOUBLE_TLV("Master Playback Volume", AMLM8_LM_VOL, 0, 8, 0xFF, 0, dac_tlv),
-SOC_DOUBLE_TLV("Headphone Volume", AMLM8_HS_VOL, 0, 8, 0x0F, 0, hs_tlv),
-SOC_DOUBLE_TLV("Capture Volume", AMLM8_REC_VOL, 0, 8, 0xFF, 0, adc_tlv),
-SOC_DOUBLE_TLV("MIC PGA Volume", AMLM8_PGA_VOL, 0, 8, 0x35, 0, pga_tlv),
+SOC_DOUBLE_R_TLV("Master Playback Volume", AMLM8_LM_LEFT_VOL, AMLM8_LM_RIGHT_VOL, 0, 0xFF, 0, dac_tlv),
+SOC_DOUBLE_R_TLV("Headphone Volume", AMLM8_HS_LEFT_VOL, AMLM8_HS_RIGHT_VOL, 0, 0x0F, 0, hs_tlv),
+SOC_DOUBLE_R_TLV("Record Volume", AMLM8_REC_LEFT_VOL, AMLM8_REC_RIGHT_VOL, 0, 0xFF, 0, adc_tlv),
+SOC_DOUBLE_R_TLV("MIC PGA Volume", AMLM8_PGA_LEFT_VOL, AMLM8_PGA_RIGHT_VOL, 0, 0x35, 0, pga_tlv),
 
 SOC_DOUBLE("Headphone Switch", AMLM8_MUTE_2, 4, 5, 1, 1),
 SOC_DOUBLE("Capture Switch", AMLM8_MUTE_0, 0, 1, 1, 1),
@@ -1042,18 +656,18 @@ SOC_VALUE_ENUM("Right LINEIN Select", right_linein_select),
 
 };
 static const struct snd_kcontrol_new amlm8_left_ld1_mixer[] = {
-SOC_DAPM_SINGLE("LEFT DAC Switch", AMLM8_LDR1_SEL, 0, 1, 0),
-SOC_DAPM_SINGLE("LEFT RECORDING PGA Switch", AMLM8_LDR1_SEL, 1, 1, 0),
-SOC_DAPM_SINGLE("RIGHT RECORDING PGA Switch", AMLM8_LDR1_SEL, 2, 1, 0),
+SOC_DAPM_SINGLE("LEFT DAC Switch", AMLM8_LDR1_LEFT_SEL, 0, 1, 0),
+SOC_DAPM_SINGLE("LEFT REC PGA Switch", AMLM8_LDR1_LEFT_SEL, 1, 1, 0),
+SOC_DAPM_SINGLE("RIGHT REC PGA Switch", AMLM8_LDR1_LEFT_SEL, 2, 1, 0),
 };
 static const struct snd_kcontrol_new amlm8_right_ld1_mixer[] = {
-SOC_DAPM_SINGLE("RIGHT DAC Switch", AMLM8_LDR1_SEL, 8, 1, 0),
-SOC_DAPM_SINGLE("RIGHT RECORDING PGA Switch", AMLM8_LDR1_SEL, 9, 1, 0),
-SOC_DAPM_SINGLE("LEFT RECORDING PGA Switch", AMLM8_LDR1_SEL, 10, 1, 0),
+SOC_DAPM_SINGLE("RIGHT DAC Switch", AMLM8_LDR1_RIGHT_SEL, 0, 1, 0),
+SOC_DAPM_SINGLE("RIGHT REC PGA Switch", AMLM8_LDR1_RIGHT_SEL, 1, 1, 0),
+SOC_DAPM_SINGLE("LEFT REC PGA Switch", AMLM8_LDR1_RIGHT_SEL, 2, 1, 0),
 };
 static const struct snd_kcontrol_new amlm8_mono_ld2_mixer[] = {
 SOC_DAPM_SINGLE("LEFT DAC Switch", AMLM8_LDR2_SEL, 0, 1, 0),
-SOC_DAPM_SINGLE("LEFT RECORDING PGA Switch", AMLM8_LDR2_SEL, 1, 1, 0),
+SOC_DAPM_SINGLE("LEFT REC PGA Switch", AMLM8_LDR2_SEL, 1, 1, 0),
 SOC_DAPM_SINGLE("RIGHT DAC Switch", AMLM8_LDR2_SEL, 2, 1, 0),
 };
 
@@ -1108,27 +722,26 @@ static const struct snd_soc_dapm_route aml_m8_audio_map[] = {
 	{ "Right ADC", NULL, "Right IN PGA" },
 
 	{ "Left Output Mixer", "LEFT DAC Switch", "Left DAC" },
-	{ "Left Output Mixer", "LEFT RECORDING PGA Switch", "Left IN PGA" },
-	{ "Left Output Mixer", "RIGHT RECORDING PGA Switch", "RIGHT IN PGA" },
+	{ "Left Output Mixer", "LEFT REC PGA Switch", "Left IN PGA" },
+	{ "Left Output Mixer", "RIGHT REC PGA Switch", "Right IN PGA" },
 
-	{ "Right Output Mixer", "Right DAC Switch", "Right DAC" },
-	{ "Right Output Mixer", "RIGHT RECORDING PGA Switch", "RIGHT IN PGA" },
-	{ "Right Output Mixer", "LEFT RECORDING PGA Switch", "Left IN PGA" },
+	{ "Right Output Mixer", "RIGHT DAC Switch", "Right DAC" },
+	{ "Right Output Mixer", "RIGHT REC PGA Switch", "Right IN PGA" },
+	{ "Right Output Mixer", "LEFT REC PGA Switch", "Left IN PGA" },
 
-	{ "Mono Output Mixer", "LEFT DAC Switch", "LEFT DAC" },
-	{ "Mono Output Mixer", "LEFT RECORDING PGA Switch", "RIGHT IN PGA" },
-	{ "Mono Output Mixer", "RIGHT DAC Switch", "RIGHT DAC" },
+	{ "Mono Output Mixer", "LEFT DAC Switch", "Left DAC" },
+	{ "Mono Output Mixer", "LEFT REC PGA Switch", "Left IN PGA" },
+	{ "Mono Output Mixer", "RIGHT DAC Switch", "Right DAC" },
 
 	{ "LINEOUTL", NULL, "Left Output Mixer" },
 	{ "LINEOUTR", NULL, "Right Output Mixer" },
 	
-	{ "LINEOUTMONO", NULL, "Left Output Mixer" },
-	{ "LINEOUTMONO", NULL, "Right Output Mixer" },
-	
-	{ "HP_L", NULL, "Left Output Mixer" },
-	{ "HP_R", NULL, "Right Output Mixer" },
-	{ "HP_L", NULL, "PG VCM" },
-	{ "HP_R", NULL, "PG VCM" },
+	{ "LINEOUTMONO", NULL, "Mono Output Mixer" },
+
+	{ "Left HP OUT PGA", NULL, "Left Output Mixer" },
+	{ "Right HP OUT PGA", NULL, "Right Output Mixer" },
+	{ "HP_L", NULL, "Left HP OUT PGA" },
+	{ "HP_R", NULL, "Right HP OUT PGA" },
 };
 
 static int aml_m8_soc_probe(struct snd_soc_codec *codec){
@@ -1136,17 +749,10 @@ static int aml_m8_soc_probe(struct snd_soc_codec *codec){
 	audio_aiu_pg_enable(1);
 	aml_m8_codec_reset(codec);
 	audio_aiu_pg_enable(0);
-    	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
-#if 0	
-	aml_m8_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-	snd_soc_add_codec_controls(codec, amlm8_snd_controls,
-				ARRAY_SIZE(amlm8_snd_controls));
-	
-	snd_soc_dapm_new_controls(dapm, aml_m8_dapm_widgets,
-				  ARRAY_SIZE(aml_m8_dapm_widgets));
+   	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
+
+	snd_soc_dapm_force_enable_pin(dapm, "MICBIAS");
 
-	snd_soc_dapm_add_routes(dapm, aml_m8_audio_map, ARRAY_SIZE(aml_m8_audio_map));
-#endif
     return 0;
 }
 static int aml_m8_soc_remove(struct snd_soc_codec *codec){
@@ -1175,14 +781,16 @@ static struct snd_soc_codec_driver soc_codec_dev_amlm8 = {
 	.read = aml_m8_read,
 	.write = aml_m8_write,
 	.set_bias_level = aml_m8_set_bias_level,
-	.reg_cache_size = ARRAY_SIZE(aml_m8_reg),
+	.reg_cache_size = ARRAY_SIZE(acodec_regbank),
 	.reg_word_size = sizeof(u16),
 	.reg_cache_step = 1,
-	.reg_cache_default = aml_m8_reg,
-/*	.dapm_widgets = aml_m8_dapm_widgets,
+	.reg_cache_default = acodec_regbank,
+	.controls = amlm8_snd_controls,
+	.num_controls = ARRAY_SIZE(amlm8_snd_controls),
+	.dapm_widgets = aml_m8_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(aml_m8_dapm_widgets),
 	.dapm_routes = aml_m8_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(aml_m8_audio_map),*/
+	.num_dapm_routes = ARRAY_SIZE(aml_m8_audio_map),
 };
 
 static int aml_m8_codec_probe(struct platform_device *pdev)
diff --git a/sound/soc/codecs/aml_m8_codec.h b/sound/soc/codecs/aml_m8_codec.h
index c05f32e2c4b5..9c2b4f2450df 100755
--- a/sound/soc/codecs/aml_m8_codec.h
+++ b/sound/soc/codecs/aml_m8_codec.h
@@ -39,10 +39,14 @@
 #define AMLM8_MUTE_2			0x1F
 #define AMLM8_MUTE_4			0x21
 
-#define AMLM8_REC_VOL			0x24
-#define AMLM8_PGA_VOL			0x26
-#define AMLM8_LM_VOL			0x34
-#define AMLM8_HS_VOL			0x38
+#define AMLM8_REC_LEFT_VOL		0x24
+#define AMLM8_REC_RIGHT_VOL		0x25
+#define AMLM8_PGA_LEFT_VOL		0x26
+#define AMLM8_PGA_RIGHT_VOL		0x27
+#define AMLM8_LM_LEFT_VOL		0x34
+#define AMLM8_LM_RIGHT_VOL		0x35
+#define AMLM8_HS_LEFT_VOL		0x38
+#define AMLM8_HS_RIGHT_VOL		0x39
 
 #define AMLM8_PGA_SEL			0x47
 
@@ -54,8 +58,9 @@
 #define AMLM8_INT_LEVLE_0		0x54
 #define AMLM8_INT_LEVLE_1		0x55
 
-#define AMLM8_LDR1_SEL			0x59
-#define AMLM8_LDR2_SEL			0x5d
+#define AMLM8_LDR1_LEFT_SEL		0x59
+#define AMLM8_LDR1_RIGHT_SEL	0x5A
+#define AMLM8_LDR2_SEL			0x5D
 
 #define AMLM8_REC_DMIX			0x7B
 #define AMLM8_PB_DMIX			0x7C
diff --git a/sound/soc/codecs/common/aml_audio_codec_probe.c b/sound/soc/codecs/common/aml_audio_codec_probe.c
index 0296a3b564f7..f4a2f2384d7e 100755
--- a/sound/soc/codecs/common/aml_audio_codec_probe.c
+++ b/sound/soc/codecs/common/aml_audio_codec_probe.c
@@ -15,6 +15,7 @@
 #include <linux/platform_device.h>
 #include <linux/of.h>
 #include <linux/slab.h>
+#include <linux/regmap.h>
 #include <linux/pinctrl/consumer.h>
 #include <mach/am_regs.h>
 #include <linux/delay.h>
@@ -22,145 +23,206 @@
 #include <linux/amlogic/aml_audio_codec_probe.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 
+codec_info_t codec_info;
+
+static const struct regmap_config codec_regmaps[] = {
+	{
+		.name = "rt5616",
+		.reg_bits =		8,
+		.val_bits =		16,
+		.max_register =		0xff,
+	},
+	{
+		.name = "rt5631",
+		.reg_bits = 	8,
+		.val_bits = 	16,
+		.max_register = 	0x7e,
+	},
+	{
+		.name = "wm8960",
+		.reg_bits = 	7,
+		.val_bits = 	9,
+		.max_register = 	0x37,
+	},
+};
 
-
-extern struct i2c_client * i2c_new_device(struct i2c_adapter *adap,
-            struct i2c_board_info const *info);
-
-
-static struct platform_device* audio_codec_pdev = NULL;
-
-bool is_rt5631;
-bool is_wm8960;
-bool is_rt5616;
-
-static int regist_codec_info(struct device_node* p_node, aml_audio_codec_info_t* audio_codec_dev)
+static int test_codec_of_node(struct device_node* p_node, aml_audio_codec_info_t* audio_codec_dev)
 {
-    int ret = 0;
-    ret = of_property_read_string(p_node, "codec_name", &audio_codec_dev->name);
-    if (ret) {
-        printk("get audio codec name failed!\n");
-    }
-    ret = of_property_read_string(p_node, "status", &audio_codec_dev->status);
-    if(ret){
-        printk("%s:this audio codec is disabled!\n",audio_codec_dev->name);
+	int ret = 0, val = 0;
+	const char* str;
+	struct i2c_board_info board_info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct regmap *regmap;
+	
+	memset(&board_info, 0, sizeof(board_info));
+
+	ret = of_property_read_string(p_node, "codec_name", &audio_codec_dev->name);
+	if (ret) {
+        printk("no of property codec_name!\n");
+		goto exit;
     }
-    if(!strcmp(audio_codec_dev->name, "rt5631") && !strcmp(audio_codec_dev->status,"okay")){
-        is_rt5631 = true;
-    }else if(strcmp(audio_codec_dev->name, "wm8960") && strcmp(audio_codec_dev->status,"okay")){
-        is_wm8960 = true;
-    }else if(strcmp(audio_codec_dev->name, "rt5616") && strcmp(audio_codec_dev->status,"okay")){
-        is_rt5616 = true;
-    }
-
-    printk("*********is_rt5631=%d,is_wm8960=%d,is_rt5616=%d*\n",is_rt5631,is_wm8960,is_rt5616);
-    return 0;
+	printk("test codec %s\n", audio_codec_dev->name);
+	ret = of_property_read_string(p_node, "status", &audio_codec_dev->status);
+	if(ret){
+		printk("%s:can't get status info!\n",audio_codec_dev->name);
+		goto exit;
+	}
+
+	if (strcmp(audio_codec_dev->status, "okay") && strcmp(audio_codec_dev->status, "ok")){
+		printk("test_codec_of_node, node %s disable\n", audio_codec_dev->name);
+		ret = -ENODEV;
+		goto exit;
+	}
+	
+	ret = of_property_read_u32(p_node,"i2c_addr", &audio_codec_dev->i2c_addr);
+	if(ret){
+		printk("%s fail to get i2c_addr\n", __func__);
+		goto exit;
+	}
+
+	ret = of_property_read_u32(p_node,"id_reg", &audio_codec_dev->id_reg);
+	if(ret){
+		printk("%s fail to get id_reg\n", __func__);
+		goto exit;
+	}
+
+	ret = of_property_read_u32(p_node,"id_val", &audio_codec_dev->id_val);
+	if(ret){
+		printk("%s fail to get id_val\n", __func__);
+		goto exit;
+	}
+
+	ret = of_property_read_string(p_node, "i2c_bus", &str);
+	if(ret){
+		printk("%s fail to get i2c_bus\n", __func__);
+		goto exit;
+	}
+	
+	if (!strncmp(str, "i2c_bus_ao", 10))
+        audio_codec_dev->i2c_bus_type = AML_I2C_BUS_AO;
+	else if (!strncmp(str, "i2c_bus_a", 9))
+        audio_codec_dev->i2c_bus_type = AML_I2C_BUS_A;
+    else if (!strncmp(str, "i2c_bus_b", 9))
+        audio_codec_dev->i2c_bus_type = AML_I2C_BUS_B;
+    else if (!strncmp(str, "i2c_bus_c", 9))
+        audio_codec_dev->i2c_bus_type = AML_I2C_BUS_C;
+    else if (!strncmp(str, "i2c_bus_d", 9))
+        audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
+    else
+		printk("ERR, unsupported i2c bus addr: %s \n", str);
+	
+	adapter = i2c_get_adapter(audio_codec_dev->i2c_bus_type);
+	if (!adapter){
+		ret = -ENODEV;
+		goto exit;
+	}
+	
+	strncpy(board_info.type, "codec_i2c", I2C_NAME_SIZE);
+	board_info.addr = audio_codec_dev->i2c_addr;
+	client = i2c_new_device(adapter, &board_info);
+	if (!client) {
+		/* I2C device registration failed, continue with the next */
+		printk("Unable to add I2C device for 0x%x\n",
+			 board_info.addr);
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	regmap = devm_regmap_init_i2c(client, &codec_regmaps[codec_info.codec_index]);
+	if (IS_ERR(regmap)){
+		ret = PTR_ERR(regmap);
+		goto err1;
+	}
+	
+	ret = regmap_read(regmap, audio_codec_dev->id_reg, &val);
+	if (ret){
+		printk("try regmap_read err, so %s disabled\n", audio_codec_dev->name);
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	if (val != audio_codec_dev->id_val){
+		printk("ID value mismatch, so %s disabled!\n", audio_codec_dev->name);
+		ret = -ENODEV;
+	}
+	
+err1:
+	i2c_unregister_device(client);
+err2:
+	i2c_put_adapter(adapter);
+exit:
+	return ret;
 }
 
-
-static int get_audio_codec_i2c_info(struct device_node* p_node, aml_audio_codec_info_t* audio_codec_dev)
+static int register_i2c_codec_device(aml_audio_codec_info_t* audio_codec_dev)
 {
-    const char* str;
-    int ret = 0;
-    unsigned i2c_addr;
-    struct i2c_adapter *adapter;
-
-    ret = of_property_read_string(p_node, "codec_name", &audio_codec_dev->name);
-    if (ret) {
-        printk("get audio codec name failed!\n");
-        goto err_out;
-    }
-
-    ret = of_property_match_string(p_node,"status","okay");
-    if(ret){
-        printk("%s:this audio codec is disabled!\n",audio_codec_dev->name);
-        goto err_out;
-    }
-    printk("use audio codec %s\n",audio_codec_dev->name);
-
-    ret = of_property_read_u32(p_node,"capless",&audio_codec_dev->capless);
-    if(ret){
-        printk("don't find audio codec capless mode!\n");
-    }
-
-    ret = of_property_read_string(p_node, "i2c_bus", &str);
-    if (ret) {
-        printk("%s: faild to get i2c_bus str,use default i2c bus!\n", audio_codec_dev->name);
-        audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
-    } else {
-        if (!strncmp(str, "i2c_bus_a", 9))
-            audio_codec_dev->i2c_bus_type = AML_I2C_BUS_A;
-        else if (!strncmp(str, "i2c_bus_b", 9))
-            audio_codec_dev->i2c_bus_type = AML_I2C_BUS_B;
-        else if (!strncmp(str, "i2c_bus_c", 9))
-            audio_codec_dev->i2c_bus_type = AML_I2C_BUS_C;
-        else if (!strncmp(str, "i2c_bus_d", 9))
-            audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
-        else if (!strncmp(str, "i2c_bus_ao", 10))
-            audio_codec_dev->i2c_bus_type = AML_I2C_BUS_AO;
-        else
-            audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
-    }
-
-    ret = of_property_read_u32(p_node,"i2c_addr",&i2c_addr);
-    if(ret){
-        printk("don't find i2c adress capless,use default!\n");
-        audio_codec_dev->i2c_addr = 0x1B;
-    }else{
-        audio_codec_dev->i2c_addr = i2c_addr;
-    }
-    printk("audio codec addr: 0x%x\n", audio_codec_dev->i2c_addr);
-    printk("audio codec i2c bus: %d\n", audio_codec_dev->i2c_bus_type);
-
-    /* test if the camera is exist */
-    adapter = i2c_get_adapter(audio_codec_dev->i2c_bus_type);
-    if (!adapter) {
-        printk("can not do probe function\n");
-        ret = -1;
-        goto err_out;
-    }
-    ret = 0;
-
-err_out:
-    return ret;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct i2c_board_info board_info;
+	char tmp[NAME_SIZE];
+
+	strncpy(board_info.type, audio_codec_dev->name, I2C_NAME_SIZE);
+	board_info.addr = audio_codec_dev->i2c_addr;
+	
+	adapter = i2c_get_adapter(audio_codec_dev->i2c_bus_type);
+	client = i2c_new_device(adapter, &board_info);
+	snprintf(tmp, NAME_SIZE, "%s", audio_codec_dev->name);
+	strlcpy(codec_info.name, tmp, NAME_SIZE);
+	snprintf(tmp, NAME_SIZE, "%s.%s", audio_codec_dev->name, dev_name(&client->dev));
+	strlcpy(codec_info.name_bus, tmp, NAME_SIZE);
+
+	return 0;
 }
 
-
 static int aml_audio_codec_probe(struct platform_device *pdev)
 {
-    struct device_node* audio_codec_node = pdev->dev.of_node;
+	int ret = 0, ext_codec = 0;
+	struct device_node* audio_codec_node = pdev->dev.of_node;
     struct device_node* child;
-    struct i2c_board_info board_info;
-    struct i2c_adapter *adapter;
-    aml_audio_codec_info_t temp_audio_codec;
-    audio_codec_pdev = pdev;
-    is_rt5631 = false;
-    is_wm8960 = false;
-    is_rt5616 = false;
-    for_each_child_of_node(audio_codec_node, child) {
+    aml_audio_codec_info_t *audio_codec_dev;
 
-        memset(&temp_audio_codec, 0, sizeof(aml_audio_codec_info_t));
-        regist_codec_info(child,&temp_audio_codec);
-        if (get_audio_codec_i2c_info(child, &temp_audio_codec)) {
-            continue;
-        }
-        memset(&board_info, 0, sizeof(board_info));
-        strncpy(board_info.type, temp_audio_codec.name, I2C_NAME_SIZE);
-        adapter = i2c_get_adapter(temp_audio_codec.i2c_bus_type);
-        board_info.addr = temp_audio_codec.i2c_addr;
-        board_info.platform_data = &temp_audio_codec;
-        i2c_new_device(adapter, &board_info);
+	audio_codec_dev = kzalloc(sizeof(aml_audio_codec_info_t), GFP_KERNEL);
+	if (!audio_codec_dev) {
+		printk("ERROR, temp_audio_codec device create fail.\n");
+		ret = -ENOMEM;
+		goto exit;
     }
-    return 0;
-}
+	
+	memset(&codec_info, 0, sizeof(codec_info));
 
+    for_each_child_of_node(audio_codec_node, child) {
+        memset(audio_codec_dev, 0, sizeof(aml_audio_codec_info_t));
+		ret = test_codec_of_node(child, audio_codec_dev);
+		codec_info.codec_index++;
+		
+		if (ret == 0){
+			ext_codec = 1;
+			printk("using external codec, index = %d\n", codec_info.codec_index);
+			break;
+		}
+    }
+	
+	if (!ext_codec){
+		printk("no external codec, using aml default codec\n");
+		strlcpy(codec_info.name_bus, "aml_m8_codec.0", NAME_SIZE);
+		strlcpy(codec_info.name, "amlm8", NAME_SIZE);
+		codec_info.codec_index = aml_codec;
+		ret = 0;
+		goto exit;
+	}
+
+	ret = register_i2c_codec_device(audio_codec_dev);
+	if (ret)
+        dev_err(&pdev->dev, "register_codec_device failed (%d)\n", ret);
+
+exit:
+	kfree(audio_codec_dev);
+    return ret;
+}
 
 static int aml_audio_codec_remove(struct platform_device *pdev)
 {
-    is_rt5631 = false;
-    is_wm8960 = false;
-    is_rt5616 = false;
-
     return 0;
 }
 
diff --git a/sound/soc/codecs/rt5616.c b/sound/soc/codecs/rt5616.c
index 48e6682867bb..bcb6b2b29221 100755
--- a/sound/soc/codecs/rt5616.c
+++ b/sound/soc/codecs/rt5616.c
@@ -40,8 +40,8 @@
 
 #define POWER_ON_MICBIAS1
 
-extern int spk_gpio_mute;
-static unsigned int spk_mute_num = 0;
+//extern int spk_gpio_mute;
+//static unsigned int spk_mute_num = 0;
 
 struct rt5616_init_reg {
     u8 reg;
@@ -821,11 +821,13 @@ static int rt5616_lout_event(struct snd_soc_dapm_widget *w,
         /*snd_soc_update_bits(codec, RT5616_LOUT_CTRL1,
             RT5616_L_MUTE | RT5616_R_MUTE, 0);
             */
+#if 0
         if(!spk_mute_num){
             spk_mute_num = 1;
             amlogic_set_value(spk_gpio_mute, 1, "mute_spk");
             msleep(100);
         }
+#endif
         break;
 
     case SND_SOC_DAPM_PRE_PMD:
@@ -1160,7 +1162,6 @@ static const struct snd_soc_dapm_route rt5616_dapm_routes[] = {
 static int rt5616_codec_digital_mute(struct snd_soc_dai *dai, int mute)
 {
     int ret;
-    printk(KERN_INFO"rt5616_codec_digital_mute : mute=%d\n",mute);
     unsigned int reg_value;
     struct snd_soc_codec *codec = dai->codec;
     
@@ -1516,7 +1517,6 @@ static DEVICE_ATTR(index_reg, 0444, rt5616_index_show, NULL);
 static int rt5616_set_bias_level(struct snd_soc_codec *codec,
             enum snd_soc_bias_level level)
 {
-   printk(KERN_INFO"rt5616_set_bias_level : level=%d\n",level);
     switch (level) {
     case SND_SOC_BIAS_ON:
         snd_soc_update_bits(codec, RT5616_HP_VOL,
@@ -1622,8 +1622,8 @@ static int rt5616_remove(struct snd_soc_codec *codec)
 #ifdef CONFIG_PM
 static int rt5616_suspend(struct snd_soc_codec *codec, pm_message_t state)
 {
-    amlogic_set_value(spk_gpio_mute, 0, "mute_spk");
-    spk_mute_num = 0;
+    //amlogic_set_value(spk_gpio_mute, 0, "mute_spk");
+    //spk_mute_num = 0;
     rt5616_set_bias_level(codec, SND_SOC_BIAS_OFF);
     return 0;
 }
@@ -1732,8 +1732,8 @@ static int rt5616_i2c_shutdown(struct i2c_client *client)
 {
     struct rt5616_priv *rt5616 = i2c_get_clientdata(client);
     struct snd_soc_codec *codec = rt5616->codec;
-    amlogic_set_value(spk_gpio_mute, 0, "mute_spk");
-    spk_mute_num = 0;
+    //amlogic_set_value(spk_gpio_mute, 0, "mute_spk");
+    //spk_mute_num = 0;
     if (codec != NULL)
     {
         snd_soc_write(codec, RT5616_HP_VOL, 0xc8c8);
-- 
2.19.0

