From 1cddbd293927faf6db1f35043fe135700c8b9636 Mon Sep 17 00:00:00 2001
From: "pengfei.hao" <pengfei.hao@amlogic.com>
Date: Mon, 6 Jan 2014 20:59:36 +0800
Subject: [PATCH 2980/5965] Pd#85875:Add hm5065 and sp1628 camera sensor driver

---
 arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd |   46 +
 arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd |   44 +
 arch/arm/configs/meson8_defconfig            |    2 +
 drivers/amlogic/camera/Kconfig               |   26 +
 drivers/amlogic/camera/Makefile              |    4 +
 drivers/amlogic/camera/aml.dtd               |   46 +
 drivers/amlogic/camera/common/cam_prober.c   |   29 +-
 drivers/amlogic/camera/hm5065.c              | 2549 ++++++++++++++++
 drivers/amlogic/camera/hm5065_firmware.h     | 2080 +++++++++++++
 drivers/amlogic/camera/sp1628.c              | 2883 ++++++++++++++++++
 include/media/v4l2-chip-ident.h              |    8 +-
 11 files changed, 7713 insertions(+), 4 deletions(-)
 create mode 100755 drivers/amlogic/camera/hm5065.c
 create mode 100755 drivers/amlogic/camera/hm5065_firmware.h
 create mode 100755 drivers/amlogic/camera/sp1628.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
index 5cb808008f73..dcc24b5078f1 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_v1.dtd
@@ -1577,6 +1577,52 @@ sdio{
 			bt_path = "gpio";
 			status = "okay";
 		};
+
+
+///	-	hm5065
+//$$ DEVICE="hm5065"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_9{
+			cam_name = "hm5065";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_5";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+
+///	-    sp1628
+//$$ DEVICE="sp1628"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_10{
+			cam_name = "sp1628";
+			front_back = <1>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
 	};	
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
index 268282d8cfdf..7b665bba2e1d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_v1.dtd
@@ -1487,6 +1487,50 @@ lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{	//k101
 			bt_path = "gpio";
 			status = "okay";
 		};
+///	-	hm5065
+//$$ DEVICE="hm5065"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_5{
+			cam_name = "hm5065";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_5";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+///	-    sp1628
+//$$ DEVICE="sp1628"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_6{
+			cam_name = "sp1628";
+			front_back = <1>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
 	};	
 
 /// ***************************************************************************************
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index c2bc090ab613..938302561b94 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -233,8 +233,10 @@ CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0328=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_GC2035=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5640=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_SP0A19=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_SP1628=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_HI253=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_HM2057=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_HM5065=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5647=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0543=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE_AR0833=y
diff --git a/drivers/amlogic/camera/Kconfig b/drivers/amlogic/camera/Kconfig
index 6b92d5ad6651..45ce83df80ad 100755
--- a/drivers/amlogic/camera/Kconfig
+++ b/drivers/amlogic/camera/Kconfig
@@ -247,6 +247,19 @@ config VIDEO_AMLOGIC_CAPTURE_SP0A19
 	  Amlogic capture driver.
 	  Say Y here if you want this driver.
 
+config VIDEO_AMLOGIC_CAPTURE_SP1628
+	tristate "Amlogic Platform Capture Driver for SP1628"
+	depends on VIDEO_AMLOGIC_CAPTURE
+	select VIDEOBUF_VMALLOC
+	select AMLOGIC_VIDEOIN_MANAGER
+	select TVIN
+	select TVIN_BT656
+	select TVIN_VDIN
+	default n
+	---help---
+	  Amlogic capture driver.
+	  Say Y here if you want this driver.
+
 config VIDEO_AMLOGIC_CAPTURE_HI253
 	tristate "Amlogic Platform Capture Driver for HI253"
 	depends on VIDEO_AMLOGIC_CAPTURE
@@ -286,6 +299,19 @@ config VIDEO_AMLOGIC_CAPTURE_HM2057
 	  Amlogic capture driver.
 	  Say Y here if you want this driver. 
 
+config VIDEO_AMLOGIC_CAPTURE_HM5065
+	tristate "Amlogic Platform Capture Driver for HM5065"
+	depends on VIDEO_AMLOGIC_CAPTURE
+	select VIDEOBUF_VMALLOC
+	select AMLOGIC_VIDEOIN_MANAGER
+	select TVIN
+	select TVIN_BT656
+	select TVIN_VDIN
+	default n
+	---help---
+	  Amlogic capture driver.
+	  Say Y here if you want this driver. 
+
 config VIDEO_AMLOGIC_CAPTURE_OV3660
 	tristate "Amlogic Platform Capture Driver for OV3660"
 	depends on VIDEO_AMLOGIC_CAPTURE
diff --git a/drivers/amlogic/camera/Makefile b/drivers/amlogic/camera/Makefile
index 2e6dfe5d39f9..61bfbfed83b7 100755
--- a/drivers/amlogic/camera/Makefile
+++ b/drivers/amlogic/camera/Makefile
@@ -18,10 +18,12 @@ ov2655dri-objs := ov2655.o
 sp0838dri-objs := sp0838.o
 sp2518dri-objs := sp2518.o
 sp0a19dri-objs := sp0a19.o
+sp1628dri-objs := sp1628.o
 hi253dri-objs := hi253.o
 hi704dri-objs := hi704.o
 hi2056dri-objs := hi2056.o
 hm2057dri-objs := hm2057.o
+hm5065dri-objs := hm5065.o
 ov3660dri-objs := ov3660.o
 nt99250dri-objs := nt99250.o
 nt99252dri-objs := nt99252.o
@@ -48,10 +50,12 @@ obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_OV2655) += ov2655dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_SP0838) += sp0838dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_SP2518) += sp2518dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_SP0A19) += sp0a19dri.o
+obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_SP1628) += sp1628dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_HI253) += hi253dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_HI704) += hi704dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_HI2056) += hi2056dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_HM2057) += hm2057dri.o
+obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_HM5065) += hm5065dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_OV3660) += ov3660dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_NT99250) += nt99250dri.o
 obj-$(CONFIG_VIDEO_AMLOGIC_CAPTURE_NT99252) += nt99252dri.o
diff --git a/drivers/amlogic/camera/aml.dtd b/drivers/amlogic/camera/aml.dtd
index 3a0fe39913cc..f006e4a748ca 100755
--- a/drivers/amlogic/camera/aml.dtd
+++ b/drivers/amlogic/camera/aml.dtd
@@ -202,6 +202,52 @@
 			bt_path = "gpio";
 			status = "okay";
 		};
+
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_HM5065
+///	-	hm5065
+//$$ DEVICE="hm5065"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_8{
+			cam_name = "hm5065";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_5";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_SP1628
+///	-    sp1628
+//$$ DEVICE="sp1628"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_9{
+			cam_name = "sp1628";
+			front_back = <1>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
 #endif
 	};	
 #endif
\ No newline at end of file
diff --git a/drivers/amlogic/camera/common/cam_prober.c b/drivers/amlogic/camera/common/cam_prober.c
index fb3624d64fba..d938f4bcb815 100755
--- a/drivers/amlogic/camera/common/cam_prober.c
+++ b/drivers/amlogic/camera/common/cam_prober.c
@@ -394,14 +394,15 @@ int hm5065_v4l2_probe(struct i2c_adapter *adapter)
 {
 	int ret = 0;
 	unsigned char reg[2];   
-	reg[0] = aml_i2c_get_byte(adapter, 0x16, 0x0000);
-	reg[1] = aml_i2c_get_byte(adapter, 0x16, 0x0001);
+	reg[0] = aml_i2c_get_byte(adapter, 0x1F, 0x0000);
+	reg[1] = aml_i2c_get_byte(adapter, 0x1F, 0x0001);
 	if (reg[0] == 0x03 && reg[1] == 0x9e)
 		ret = 1;
 	return ret;
 }
 #endif
 
+
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_HI2056
 int hi2056_v4l2_probe(struct i2c_adapter *adapter)
 {
@@ -455,6 +456,18 @@ int ar0833_v4l2_probe(struct i2c_adapter *adapter)
 }
 #endif
 
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_SP1628
+int __init sp1628_v4l2_probe(struct i2c_adapter *adapter)
+{
+    int ret = 0;
+	unsigned char reg[2];   
+	reg[0] = aml_i2c_get_byte_add8(adapter, 0x3c, 0x02);
+	reg[1] = aml_i2c_get_byte_add8(adapter, 0x3c, 0xa0);
+	if (reg[0] == 0x16 && reg[1] == 0x28)
+		ret = 1;
+    return ret;
+}
+#endif
 
 typedef struct {
 	unsigned char addr;
@@ -633,7 +646,7 @@ static aml_cam_dev_info_t cam_devs[] = {
 #endif
 #ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_HM5065
 	{
-		.addr = 0x16,
+		.addr = 0x1f,
 		.name = "hm5065",
 		.pwdn = 0,
 		.max_cap_size = SIZE_2592X1944,
@@ -667,6 +680,16 @@ static aml_cam_dev_info_t cam_devs[] = {
 		.probe_func = ar0833_v4l2_probe,
 	},
 #endif
+#ifdef CONFIG_VIDEO_AMLOGIC_CAPTURE_SP1628
+	{
+		.addr = 0x3c,
+		.name = "sp1628",
+		.pwdn = 1,
+		.max_cap_size = SIZE_1280X960,
+		.probe_func = sp1628_v4l2_probe,
+	},
+#endif
+
 };
 
 static aml_cam_dev_info_t* get_cam_info_by_name(const char* name)
diff --git a/drivers/amlogic/camera/hm5065.c b/drivers/amlogic/camera/hm5065.c
new file mode 100755
index 000000000000..8223f385423e
--- /dev/null
+++ b/drivers/amlogic/camera/hm5065.c
@@ -0,0 +1,2549 @@
+/*
+ *HM5065 - This code emulates a real video device with v4l2 api
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence, GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ */
+#include <linux/sizes.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/highmem.h>
+#include <linux/freezer.h>
+#include <media/videobuf-res.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <linux/wakelock.h>
+
+#include <linux/i2c.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/amlogic/camera/aml_cam_info.h>
+#include <linux/amlogic/vmapi.h>
+
+#include <mach/am_regs.h>
+//#include <mach/am_eth_pinmux.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+
+#include "common/plat_ctrl.h"
+#include "common/vm.h"
+#include "hm5065_firmware.h"
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#include <mach/mod_gate.h>
+#endif
+#define HM5065_CAMERA_MODULE_NAME "hm5065"
+#define MAGIC_RE_MEM 0x123039dc
+#define HM5065_RES0_CANVAS_INDEX CAMERA_USER_CANVAS_INDEX
+
+/* Wake up at about 30 fps */
+#define WAKE_NUMERATOR 30
+#define WAKE_DENOMINATOR 1001
+#define BUFFER_TIMEOUT     msecs_to_jiffies(500)  /* 0.5 seconds */
+#define AF_STATUS     	0x07AE
+#define FACE_LC			0x0714
+#define FACE_START_XH 	0x0715
+#define FACE_START_XL 	0x0716
+#define FACE_SIZE_XH  	0x0717
+#define FACE_SIZE_XL 	0x0718
+#define FACE_START_YH 	0x0719
+#define FACE_START_YL 	0x071A
+#define FACE_SIZE_YH 	0x071B
+#define FACE_SIZE_YL 	0x071C
+
+#define HM5065_CAMERA_MAJOR_VERSION 0
+#define HM5065_CAMERA_MINOR_VERSION 7
+#define HM5065_CAMERA_RELEASE 0
+#define HM5065_CAMERA_VERSION \
+	KERNEL_VERSION(HM5065_CAMERA_MAJOR_VERSION, HM5065_CAMERA_MINOR_VERSION, HM5065_CAMERA_RELEASE)
+
+MODULE_DESCRIPTION("hm5065 On Board");
+MODULE_AUTHOR("amlogic-sh");
+MODULE_LICENSE("GPL v2");
+
+static unsigned video_nr = -1;  /* videoX start number, -1 is autodetect. */
+
+static unsigned debug;
+//module_param(debug, uint, 0644);
+//MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 32;
+//module_param(vid_limit, uint, 0644);
+//MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+
+
+//extern int disable_hm5065;
+static int hm5065_have_opened = 0;
+static unsigned char focus_position_hi, focus_position_lo;
+static struct vdin_v4l2_ops_s *vops;
+
+static bool bDoingAutoFocusMode=false;
+
+static struct v4l2_fract hm5065_frmintervals_active = {
+	.numerator = 1,
+	.denominator = 15,
+};
+
+static struct v4l2_frmivalenum hm5065_frmivalenum[]={
+	{
+		.index = 0,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 640,
+		.height = 480,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 30,
+			}
+		}
+	},{
+		.index = 0,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 1024,
+		.height = 768,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 30,
+			}
+		}
+	},{
+		.index = 0,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 1280,
+		.height = 720,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 30,
+			}
+		}
+	},{
+		.index = 0,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 1920,
+		.height = 1080,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 30,
+			}
+		}
+	},{
+		.index = 1,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 1600,
+		.height = 1200,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 5,
+			}
+		}
+	},{
+		.index = 1,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 2048,
+		.height = 1536,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 5,
+			}
+		}
+	},{
+		.index = 1,
+		.pixel_format = V4L2_PIX_FMT_NV21,
+		.width = 2592,
+		.height = 1944,
+		.type = V4L2_FRMIVAL_TYPE_DISCRETE,
+		{
+			.discrete ={
+				.numerator = 1,
+				.denominator = 5,
+			}
+		}
+	},
+};
+
+/* supported controls */
+static struct v4l2_queryctrl hm5065_qctrl[] = {
+	{
+		.id            = V4L2_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 127,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}, {
+		.id            = V4L2_CID_CONTRAST,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Contrast",
+		.minimum       = 0x10,
+		.maximum       = 0x60,
+		.step          = 0xa,
+		.default_value = 0x30,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_HFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on horizontal",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_DISABLED,
+	} ,{
+		.id            = V4L2_CID_VFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on vertical",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_DISABLED,
+	},{
+		.id            = V4L2_CID_DO_WHITE_BALANCE,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "white balance",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_EXPOSURE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "exposure",
+		.minimum       = 0,
+		.maximum       = 8,
+		.step          = 0x1,
+		.default_value = 4,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_COLORFX,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "effect",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_WHITENESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "banding",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_FOCUS_AUTO,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "auto focus",
+		.minimum       = CAM_FOCUS_MODE_RELEASE,
+		.maximum       = CAM_FOCUS_MODE_CONTI_PIC,
+		.step          = 0x1,
+		.default_value = CAM_FOCUS_MODE_CONTI_PIC,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "flash",
+		.minimum       = FLASHLIGHT_ON,
+		.maximum       = FLASHLIGHT_TORCH,
+		.step          = 0x1,
+		.default_value = FLASHLIGHT_OFF,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_ZOOM_ABSOLUTE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Zoom, Absolute",
+		.minimum       = 100,
+		.maximum       = 300,
+		.step          = 20,
+		.default_value = 100,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id		= V4L2_CID_ROTATE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotate",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_AUTO_FOCUS_STATUS,
+		.type          = 8,//V4L2_CTRL_TYPE_BITMASK,
+		.name          = "focus status",
+		.minimum       = 0,
+		.maximum       = ~3,
+		.step          = 0x1,
+		.default_value = V4L2_AUTO_FOCUS_STATUS_IDLE,
+		.flags         = V4L2_CTRL_FLAG_READ_ONLY,
+	},{
+		.id		= V4L2_CID_FOCUS_ABSOLUTE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "focus center",
+		.minimum	= 0,
+		.maximum	= ((2000) << 16) | 2000,
+		.step		= 1,
+		.default_value	= (1000 << 16) | 1000,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+ 	}
+};
+
+struct v4l2_querymenu hm5065_qmenu_autofocus[] = {
+	{
+		.id         = V4L2_CID_FOCUS_AUTO,
+		.index      = CAM_FOCUS_MODE_INFINITY,
+		.name       = "infinity",
+		.reserved   = 0,
+	},{
+		.id         = V4L2_CID_FOCUS_AUTO,
+		.index      = CAM_FOCUS_MODE_AUTO,
+		.name       = "auto",
+		.reserved   = 0,
+	},{
+		.id         = V4L2_CID_FOCUS_AUTO,
+		.index      = CAM_FOCUS_MODE_CONTI_VID,
+		.name       = "continuous-video",
+		.reserved   = 0,
+	},{
+		.id         = V4L2_CID_FOCUS_AUTO,
+		.index      = CAM_FOCUS_MODE_CONTI_PIC,
+		.name       = "continuous-picture",
+		.reserved   = 0,
+	}
+};
+
+struct v4l2_querymenu hm5065_qmenu_flashmode[] = {
+	{
+		.id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.index      = FLASHLIGHT_ON,
+		.name       = "on",
+		.reserved   = 0,
+	},{
+		.id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.index      = FLASHLIGHT_OFF,
+		.name       = "off",
+		.reserved   = 0,
+	},{
+		.id         = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.index      = FLASHLIGHT_TORCH,
+		.name       = "torch",
+		.reserved   = 0,
+	}
+};
+
+struct v4l2_querymenu hm5065_qmenu_wbmode[] = {
+    {
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_CLOUD,
+        .name       = "cloudy-daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_INCANDESCENCE,
+        .name       = "incandescent",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_DAYLIGHT,
+        .name       = "daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "fluorescent", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "warm-fluorescent", 
+        .reserved   = 0,
+    },
+};
+
+typedef struct {
+	__u32   id;
+	int     num;
+	struct v4l2_querymenu* hm5065_qmenu;
+}hm5065_qmenu_set_t;
+
+hm5065_qmenu_set_t hm5065_qmenu_set[] = {
+	{
+		.id             = V4L2_CID_FOCUS_AUTO,
+		.num            = ARRAY_SIZE(hm5065_qmenu_autofocus),
+		.hm5065_qmenu   = hm5065_qmenu_autofocus,
+	}, {
+		.id             = V4L2_CID_BACKLIGHT_COMPENSATION,
+		.num            = ARRAY_SIZE(hm5065_qmenu_flashmode),
+		.hm5065_qmenu   = hm5065_qmenu_flashmode,
+	},{
+        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .num            = ARRAY_SIZE(hm5065_qmenu_wbmode),
+        .hm5065_qmenu   = hm5065_qmenu_wbmode,
+    }
+};
+
+#define dprintk(dev, level, fmt, arg...) \
+	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+
+/* ------------------------------------------------------------------
+	Basic structures
+   ------------------------------------------------------------------*/
+
+struct hm5065_fmt {
+	char  *name;
+	u32   fourcc;          /* v4l2 format id */
+	int   depth;
+};
+
+static struct hm5065_fmt formats[] = {
+	{
+		.name     = "RGB565 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+		.depth    = 16,
+	}, {
+		.name     = "RGB888 (24)",
+		.fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
+		.depth    = 24,
+	}, {
+		.name     = "BGR888 (24)",
+		.fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
+		.depth    = 24,
+	}, {
+		.name     = "12  Y/CbCr 4:2:0SP",
+		.fourcc   = V4L2_PIX_FMT_NV12,
+		.depth    = 12,    
+	}, {
+		.name     = "12  Y/CbCr 4:2:0SP",
+		.fourcc   = V4L2_PIX_FMT_NV21,
+		.depth    = 12,    
+	}, {
+		.name     = "YUV420P",
+		.fourcc   = V4L2_PIX_FMT_YUV420,
+		.depth    = 12,
+	},{
+		.name     = "YVU420P",
+		.fourcc   = V4L2_PIX_FMT_YVU420,
+		.depth    = 12,
+	}
+};
+
+static struct hm5065_fmt *get_format(struct v4l2_format *f)
+{
+	struct hm5065_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat)
+			break;
+	}
+
+	if (k == ARRAY_SIZE(formats))
+    	return NULL;
+
+	return &formats[k];
+}
+
+struct sg_to_addr {
+	int pos;
+	struct scatterlist *sg;
+};
+
+/* buffer for one video frame */
+struct hm5065_buffer {
+    /* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+
+	struct hm5065_fmt        *fmt;
+
+	unsigned int canvas_id;
+};
+
+struct hm5065_dmaqueue {
+	struct list_head       active;
+
+    /* thread for generating video stream*/
+	struct task_struct         *kthread;
+	wait_queue_head_t          wq;
+    /* Counters to control fps rate */
+	int                        frame;
+	int                        ini_jiffies;
+};
+
+typedef struct resolution_param {
+	struct v4l2_frmsize_discrete frmsize;
+	struct v4l2_frmsize_discrete active_frmsize;
+	int active_fps;
+	resulution_size_t size_type;
+	struct aml_camera_i2c_fig_s* reg_script;
+} resolution_param_t;
+
+static LIST_HEAD(hm5065_devicelist);
+
+struct hm5065_device {
+	struct list_head	    	hm5065_devicelist;
+	struct v4l2_subdev	    	sd;
+	struct v4l2_device	    	v4l2_dev;
+
+	spinlock_t                 slock;
+	struct mutex	        	mutex;
+
+	int                        users;
+
+	/* various device info */
+	struct video_device        *vdev;
+
+	struct hm5065_dmaqueue       vidq;
+
+	/* Several counters */
+	unsigned long              jiffies;
+
+	/* Input Number */
+	int	           input;
+
+	/* platform device data from board initting. */
+	aml_cam_info_t  cam_info;
+    
+	/* Control 'registers' */
+	int                qctl_regs[ARRAY_SIZE(hm5065_qctrl)];
+	
+	/* current resolution param for preview and capture */
+	resolution_param_t* cur_resolution_param;
+	
+	/* wake lock */
+	struct wake_lock	wake_lock;
+	
+	/* for down load firmware */
+	struct work_struct dl_work;
+	
+	int firmware_ready;
+};
+
+static DEFINE_MUTEX(firmware_mutex);
+
+static inline struct hm5065_device *to_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct hm5065_device, sd);
+}
+
+struct hm5065_fh {
+	struct hm5065_device            *dev;
+
+	/* video capture */
+	struct hm5065_fmt            *fmt;
+	unsigned int               width, height;
+	struct videobuf_queue      vb_vidq;
+
+	struct videobuf_res_privdata res;
+
+	enum v4l2_buf_type         type;
+	int	           input;     /* Input Number on bars */
+	int  stream_on;
+	unsigned int		f_flags;
+};
+
+/*static inline struct hm5065_fh *to_fh(struct hm5065_device *dev)
+{
+	return container_of(dev, struct hm5065_fh, dev);
+}*/
+
+/* ------------------------------------------------------------------
+	reg spec of HM5065
+   ------------------------------------------------------------------*/
+static struct aml_camera_i2c_fig_s HM5065_script[] = {
+		{0x0083,0x00},   //	; HFlip disable
+		{0x0084,0x00},   //	; VFlip	disable
+		{0x0040,0x01},//	binning mode and subsampling mode for frame rate   
+		{0x0041,0x04},//	04 : VGA mode : 0A : self define , 00 : 5M ,03:SVGA
+		{0xffff,0xff},
+};
+
+#define FPS_15_HZ_960P
+static struct aml_camera_i2c_fig_s HM5065_preview_960P_script[] ={
+    
+	  {0x0010,0x02},
+	  {0x00b2,0x50},//713M P：89M
+	  {0x00b3,0xca},
+	  {0x00b4,0x01},
+	  {0x00b5,0x01},
+	  {0x0030,0x12},
+#if 1
+	//固定30帧
+	  {0x00E8,0x00},
+	  {0x00C8,0x00},
+	  {0x00C9,0x1E},
+	  {0x00CA,0x01},
+#else
+	//最低10帧-30帧
+	  {0x00E8,0x01},
+	  {0x00ED,0x0a},
+	  {0x00EE,0x1E},
+#endif
+		{0x0040,0x01},
+		{0x0041,0x0A},
+		{0x0042,0x05},//1280
+		{0x0043,0x00},
+		{0x0044,0x03}, //960
+		{0x0045,0xC0},
+        {0x0010,0x01},
+		{0xffff,0xff},
+} ;
+
+static struct aml_camera_i2c_fig_s HM5065_preview_QVGA_script[] ={
+    {0xffff, 0xff}
+} ;
+
+static struct aml_camera_i2c_fig_s HM5065_capture_5M_script[] ={
+		{0x0030,0x11},
+		{0x0040,0x00},//Full size                    
+		{0x0041,0x0A},//00:full size                 
+		{0x0042,0x0A},//X:2048                       
+		{0x0043,0x20},                               
+		{0x0044,0x07},//Y:1536                       
+		{0x0045,0x98},   	
+		{0xffff,0xff}
+} ;
+
+static struct aml_camera_i2c_fig_s HM5065_capture_3M_script[] = {
+ 		{0x0030,0x11},
+		{0x0040,0x00},
+		{0x0041,0x0a},
+		{0x0042,0x08},
+		{0x0043,0x00},
+		{0x0044,0x06},
+		{0x0045,0x00},
+		{0x0010,0x01},
+	  	{0xffff, 0xff}
+};
+
+static struct aml_camera_i2c_fig_s HM5065_capture_2M_script[] ={
+    	{0x0030,0x11},
+		{0x0040,0x00},
+		{0x0041,0x01},
+	  	{0xffff,0xff}
+} ;
+
+static resolution_param_t  prev_resolution_array[] = {
+    {
+		.frmsize			= {1280, 960},
+		.active_frmsize			= {1280, 958},
+		.active_fps			= 30,
+		.size_type			= SIZE_1280X960,
+		.reg_script			= HM5065_preview_960P_script,
+	},{
+		.frmsize			= {1280, 720},
+		.active_frmsize			= {1280, 718},
+		.active_fps			= 30,
+		.size_type			= SIZE_1280X720,
+		.reg_script			= HM5065_preview_960P_script,
+	},{
+		.frmsize			= {1024, 768},
+		.active_frmsize			= {1280, 958},
+		.active_fps			= 30,
+		.size_type			= SIZE_1024X768,
+		.reg_script			= HM5065_preview_960P_script,
+	},{
+		.frmsize			= {640, 480},
+		.active_frmsize			= {640, 478},
+		.active_fps			= 30,
+		.size_type			= SIZE_640X480,
+		.reg_script			= HM5065_script,
+	},{
+		.frmsize			= {320, 240},
+		.active_frmsize			= {320, 240},
+		.active_fps			= 30,
+		.size_type			= SIZE_320X240,
+		.reg_script			= HM5065_preview_QVGA_script,
+	},{
+		.frmsize			= {352, 288},
+		.active_frmsize			= {320, 240},
+		.active_fps			= 30,
+		.size_type			= SIZE_320X240,
+		.reg_script			= HM5065_preview_QVGA_script,
+	},
+};
+
+static resolution_param_t  capture_resolution_array[] = {
+	{
+		.frmsize			= {2592, 1944},
+		.active_frmsize			= {2592, 1942},
+		.active_fps			= 5,
+		.size_type			= SIZE_2592X1944,
+		.reg_script			= HM5065_capture_5M_script,
+	}, 
+	{
+		.frmsize			= {1600, 1200},
+		.active_frmsize			= {1600, 1198},
+		.active_fps			= 5,
+		.size_type			= SIZE_1600X1200,
+		.reg_script			= HM5065_capture_2M_script,
+	},{
+		.frmsize			= {2048, 1536},
+		.active_frmsize			= {2032, 1534},
+		.active_fps			= 5,
+		.size_type			= SIZE_2048X1536,
+		.reg_script			= HM5065_capture_3M_script,
+	},
+};
+static camera_focus_mode_t start_focus_mode = CAM_FOCUS_MODE_RELEASE;
+static int HM5065_AutoFocus(struct hm5065_device *dev, int focus_mode);
+void HM5065_init_regs(struct hm5065_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int i=0;
+
+	while (1) {
+		if (HM5065_script_step[i].val==0xff&&HM5065_script_step[i].addr==0xffff) {
+		//if (HM5065_preview_960P_script[i].val==0xff&&HM5065_preview_960P_script[i].addr==0xffff) {
+			printk("success in initial HM5065.\n");
+			break;
+		}
+		if ((i2c_put_byte(client,HM5065_script_step[i].addr, HM5065_script_step[i].val)) < 0) {
+			printk("fail in initial HM5065. \n");
+			return;
+		}
+		i++;
+	}
+	msleep(300);
+	return;
+}
+
+static unsigned long hm5065_preview_exposure;
+static unsigned long hm5065_preview_extra_lines;
+static unsigned long hm5065_gain;
+static unsigned long hm5065_preview_maxlines;
+/*************************************************************************
+* FUNCTION
+*    HM5065_set_param_wb
+*
+* DESCRIPTION
+*    wb setting.
+*
+* PARAMETERS
+*    none
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void HM5065_set_param_wb(struct hm5065_device *dev,enum  camera_wb_flip_e para)//白平衡
+	{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
+		switch (para) { 	 
+			case CAM_WB_AUTO://自动
+			   // i2c_put_byte(client, 0x0085, 0x02);	
+				i2c_put_byte(client, 0x01a0, 0x01); 		   
+				break;
+	
+			case CAM_WB_CLOUD: //阴天
+				i2c_put_byte(client, 0x01a0, 0x03);
+				i2c_put_byte(client, 0x01a1, 0x62);
+				i2c_put_byte(client, 0x01a2, 0x08);
+				i2c_put_byte(client, 0x01a3, 0x00); 		
+				break;
+	
+			case CAM_WB_DAYLIGHT: //
+				//i2c_put_byte(client, 0x0085, 0x03); 
+				i2c_put_byte(client, 0x01a0, 0x03);
+				i2c_put_byte(client, 0x01a1, 0x7F);
+				i2c_put_byte(client, 0x01a2, 0x3F);
+				i2c_put_byte(client, 0x01a3, 0x01);
+				break;
+	
+			case CAM_WB_INCANDESCENCE: 
+				i2c_put_byte(client, 0x01a0, 0x03);
+				i2c_put_byte(client, 0x01a1, 0x39);
+				i2c_put_byte(client, 0x01a2, 0x00);
+				i2c_put_byte(client, 0x01a3, 0x59);
+				break;
+				
+			case CAM_WB_TUNGSTEN: 
+				i2c_put_byte(client, 0x01a0, 0x03);
+				i2c_put_byte(client, 0x01a1, 0x05);
+				i2c_put_byte(client, 0x01a2, 0x00);
+				i2c_put_byte(client, 0x01a3, 0x7f);
+				break;
+	
+			case CAM_WB_FLUORESCENT:
+				i2c_put_byte(client, 0x01a0, 0x03);
+				i2c_put_byte(client, 0x01a1, 0x1F);
+				i2c_put_byte(client, 0x01a2, 0x00);
+				i2c_put_byte(client, 0x01a3, 0x4D);
+				break;
+	
+			case CAM_WB_MANUAL:
+					// TODO
+				break;
+		}
+		
+	
+	}
+
+ /* HM5065_set_param_wb */
+/*************************************************************************
+* FUNCTION
+*    HM5065_set_param_exposure
+*
+* DESCRIPTION
+*    exposure setting.
+*
+* PARAMETERS
+*    none
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void HM5065_set_param_exposure(struct hm5065_device *dev,enum camera_exposure_e para)//曝光调节
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    switch (para) {
+    	case EXPOSURE_N4_STEP:  //负4档  
+            i2c_put_byte(client, 0x0130, 0xfc);       	
+        	break;
+            
+    	case EXPOSURE_N3_STEP:
+            i2c_put_byte(client, 0x0130, 0xfd); 
+        	break;
+            
+    	case EXPOSURE_N2_STEP:
+            i2c_put_byte(client, 0x0130, 0xfe); 
+        	break;
+            
+    	case EXPOSURE_N1_STEP:
+            i2c_put_byte(client, 0x0130, 0xff); 
+        	break;
+            
+    	case EXPOSURE_0_STEP://默认零档
+            i2c_put_byte(client, 0x0130, 0x00); 
+        	break;
+            
+    	case EXPOSURE_P1_STEP://正一档
+            i2c_put_byte(client, 0x0130, 0x01); 
+        	break;
+            
+    	case EXPOSURE_P2_STEP:
+            i2c_put_byte(client, 0x0130, 0x02); 
+        	break;
+            
+    	case EXPOSURE_P3_STEP:
+            i2c_put_byte(client, 0x0130, 0x03); 
+        	break;
+            
+    	case EXPOSURE_P4_STEP:    
+            i2c_put_byte(client, 0x0130, 0x04); 
+        	break;
+            
+    	default:
+            i2c_put_byte(client, 0x0130, 0x00); 
+        	break;
+    }
+} /* HM5065_set_param_exposure */
+/*************************************************************************
+* FUNCTION
+*    HM5065_set_param_effect
+*
+* DESCRIPTION
+*    effect setting.
+*
+* PARAMETERS
+*    none
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void HM5065_set_param_effect(struct hm5065_device *dev,enum camera_effect_flip_e para)//特效设置
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+  
+    switch (para) {
+    	case CAM_EFFECT_ENC_NORMAL://正常
+      i2c_put_byte(client, 0x0380, 0x00);
+			i2c_put_byte(client, 0x0381, 0x00);
+			i2c_put_byte(client, 0x0382, 0x00);
+			i2c_put_byte(client, 0x0384, 0x00);
+			i2c_put_byte(client, 0x01a0, 0x01);
+			i2c_put_byte(client, 0x01a1, 0x80);
+			i2c_put_byte(client, 0x01a2, 0x80);
+			i2c_put_byte(client, 0x01a3, 0x80);
+			i2c_put_byte(client, 0x01a5, 0x3e);
+			i2c_put_byte(client, 0x01a6, 0x00);
+			i2c_put_byte(client, 0x01a7, 0x3e);
+			i2c_put_byte(client, 0x01a8, 0x00);
+        	break;        
+
+    	case CAM_EFFECT_ENC_GRAYSCALE://灰阶
+      i2c_put_byte(client, 0x0380, 0x00);
+			i2c_put_byte(client, 0x0381, 0x00);
+			i2c_put_byte(client, 0x0382, 0x00);
+			i2c_put_byte(client, 0x0384, 0x05);
+			i2c_put_byte(client, 0x01a0, 0x01);
+			i2c_put_byte(client, 0x01a1, 0x80);
+			i2c_put_byte(client, 0x01a2, 0x80);
+			i2c_put_byte(client, 0x01a3, 0x80);
+			i2c_put_byte(client, 0x01a5, 0x3e);
+			i2c_put_byte(client, 0x01a6, 0x00);
+			i2c_put_byte(client, 0x01a7, 0x3e);
+			i2c_put_byte(client, 0x01a8, 0x00);
+        	break;
+
+    	case CAM_EFFECT_ENC_SEPIA://复古
+      i2c_put_byte(client, 0x0380, 0x00);
+			i2c_put_byte(client, 0x0381, 0x00);
+			i2c_put_byte(client, 0x0382, 0x00);
+			i2c_put_byte(client, 0x0384, 0x06);
+			i2c_put_byte(client, 0x01a0, 0x01);
+			i2c_put_byte(client, 0x01a1, 0x80);
+			i2c_put_byte(client, 0x01a2, 0x80);
+			i2c_put_byte(client, 0x01a3, 0x80);
+			i2c_put_byte(client, 0x01a5, 0x3e);
+			i2c_put_byte(client, 0x01a6, 0x00);
+			i2c_put_byte(client, 0x01a7, 0x3e);
+			i2c_put_byte(client, 0x01a8, 0x00);
+        	break;        
+                
+    	case CAM_EFFECT_ENC_SEPIAGREEN://复古绿
+      i2c_put_byte(client, 0x0380, 0x00);
+			i2c_put_byte(client, 0x0381, 0x00);
+			i2c_put_byte(client, 0x0382, 0x00);
+			i2c_put_byte(client, 0x0384, 0x07);
+			i2c_put_byte(client, 0x01a0, 0x01);
+			i2c_put_byte(client, 0x01a1, 0x80);
+			i2c_put_byte(client, 0x01a2, 0x80);
+			i2c_put_byte(client, 0x01a3, 0x80);
+			i2c_put_byte(client, 0x01a5, 0x3e);
+			i2c_put_byte(client, 0x01a6, 0x00);
+			i2c_put_byte(client, 0x01a7, 0x3e);
+			i2c_put_byte(client, 0x01a8, 0x00);
+        	break;                    
+
+    	case CAM_EFFECT_ENC_SEPIABLUE://复古蓝
+      i2c_put_byte(client, 0x0380, 0x00);
+			i2c_put_byte(client, 0x0381, 0x00);
+			i2c_put_byte(client, 0x0382, 0x00);
+			i2c_put_byte(client, 0x0384, 0x08);
+			i2c_put_byte(client, 0x01a0, 0x01);
+			i2c_put_byte(client, 0x01a1, 0x80);
+			i2c_put_byte(client, 0x01a2, 0x80);
+			i2c_put_byte(client, 0x01a3, 0x80);
+			i2c_put_byte(client, 0x01a5, 0x3e);
+			i2c_put_byte(client, 0x01a6, 0x00);
+			i2c_put_byte(client, 0x01a7, 0x3e);
+			i2c_put_byte(client, 0x01a8, 0x00);
+        	break;                                
+
+    	case CAM_EFFECT_ENC_COLORINV://底片
+      i2c_put_byte(client, 0x0380, 0x01);
+			i2c_put_byte(client, 0x0381, 0x00);
+			i2c_put_byte(client, 0x0382, 0x00);
+			i2c_put_byte(client, 0x0384, 0x00);
+			i2c_put_byte(client, 0x01a0, 0x01);
+			i2c_put_byte(client, 0x01a1, 0x80);
+			i2c_put_byte(client, 0x01a2, 0x80);
+			i2c_put_byte(client, 0x01a3, 0x80);
+			i2c_put_byte(client, 0x01a5, 0x3e);
+			i2c_put_byte(client, 0x01a6, 0x00);
+			i2c_put_byte(client, 0x01a7, 0x3e);
+			i2c_put_byte(client, 0x01a8, 0x00);
+        	break;        
+
+    	default:
+        	break;
+    }
+} /* HM5065_set_param_effect */
+
+/*************************************************************************
+* FUNCTION
+*	HM5065_night_mode
+*
+* DESCRIPTION
+*    This function night mode of HM5065.
+*
+* PARAMETERS
+*    none
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void HM5065_set_param_banding(struct hm5065_device *dev,enum  camera_banding_flip_e banding)
+{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+		unsigned char buf[4];
+		switch(banding){
+			case CAM_BANDING_60HZ:
+							printk("set banding 60Hz\n");
+							i2c_put_byte(client, 0x0190, 0x00);
+							i2c_put_byte(client, 0x019c, 0x4b);
+							i2c_put_byte(client, 0x019d, 0xc0);
+				break;
+			case CAM_BANDING_50HZ:
+							printk("set banding 50Hz\n");
+							i2c_put_byte(client, 0x0190, 0x00);
+							i2c_put_byte(client, 0x019c, 0x4b);
+							i2c_put_byte(client, 0x019d, 0x20);
+				break;
+		}
+}
+
+static int HM5065_AutoFocus(struct hm5065_device *dev, int focus_mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int ret = 0;
+    int i = 0;
+    
+	switch (focus_mode) {
+					case CAM_FOCUS_MODE_AUTO:
+					i2c_put_byte(client, 0x070a , 0x03);			
+					//msleep(100);
+					i2c_put_byte(client, 0x070b , 0x01);			
+					msleep(200);
+					i2c_put_byte(client, 0x070b , 0x02);
+					bDoingAutoFocusMode = true;
+					printk("single auto focus mode start\n");
+					break;
+					case CAM_FOCUS_MODE_CONTI_VID:
+					case CAM_FOCUS_MODE_CONTI_PIC:
+					i2c_put_byte(client, 0x070a , 0x01); //start to continous focus            
+					printk("start continous focus\n");
+					break;
+					case CAM_FOCUS_MODE_RELEASE:
+					case CAM_FOCUS_MODE_FIXED:
+					default:
+					//i2c_put_byte(client, 0x070a , 0x00);
+					//i2c_put_byte(client, 0x070c , 0x00);
+					//i2c_put_byte(client, 0x070c , 0x03);			
+					printk("release focus to infinit\n");
+					break;
+    }
+    return ret;
+
+}    /* HM5065_AutoFocus */
+
+static int HM5065_FlashCtrl(struct hm5065_device *dev, int flash_mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int ret = 0;
+    int i = 0;
+    return ret;
+
+}    /* HM5065_FlashCtrl */
+
+static resulution_size_t get_size_type(int width, int height)
+{
+	resulution_size_t rv = SIZE_NULL;
+	if (width * height >= 2500 * 1900)
+		rv = SIZE_2592X1944;
+	else if (width * height >= 2000 * 1500)
+		rv = SIZE_2048X1536;
+	else if (width * height >= 1920 * 1080)
+		rv = SIZE_1920X1080;
+	else if (width * height >= 1600 * 1200)
+		rv = SIZE_1600X1200;
+	else if (width * height >= 1280 * 960)
+		rv = SIZE_1280X960;
+	else if (width * height >= 1280 * 720)
+		rv = SIZE_1280X720;
+	else if (width * height >= 1024 * 768)
+		rv = SIZE_1024X768;
+	else if (width * height >= 800 * 600)
+		rv = SIZE_800X600;
+	else if (width * height >= 600 * 400)
+		rv = SIZE_640X480;
+	else if (width * height >= 300 * 200)
+		rv = SIZE_320X240;
+	return rv;
+}
+
+static int set_flip(struct hm5065_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	unsigned char temp;
+	temp = i2c_get_byte(client, 0x0083);
+	temp &= 0xfd;
+	temp |= dev->cam_info.m_flip << 0;
+	if((i2c_put_byte(client, 0x0083,temp)) < 0) {
+		printk("fail in setting sensor orientation\n");
+		return -1;
+        }
+	temp = i2c_get_byte(client, 0x0084);
+	temp &= 0xfd;
+	temp |= dev->cam_info.v_flip << 0;
+	if((i2c_put_byte(client, 0x0084, temp)) < 0) {
+		printk("fail in setting sensor orientation\n");
+		return -1;
+        }
+        
+        return 0;
+}
+
+static resolution_param_t* get_resolution_param(struct hm5065_device *dev, int is_capture, int width, int height)
+{
+	int i = 0;
+	int arry_size = 0;
+	resolution_param_t* tmp_resolution_param = NULL;
+	resulution_size_t res_type = SIZE_NULL;
+	res_type = get_size_type(width, height);
+	if (res_type == SIZE_NULL)
+		return NULL;
+	if (is_capture) {
+		tmp_resolution_param = capture_resolution_array;
+		arry_size = sizeof(capture_resolution_array);
+	} else {
+		tmp_resolution_param = prev_resolution_array;
+		arry_size = sizeof(prev_resolution_array);
+		hm5065_frmintervals_active.denominator = 23;
+		hm5065_frmintervals_active.numerator = 1;
+	}
+	
+	for (i = 0; i < arry_size; i++) {
+		if (tmp_resolution_param[i].size_type == res_type) {
+			hm5065_frmintervals_active.denominator = tmp_resolution_param[i].active_fps;
+			hm5065_frmintervals_active.numerator = 1;
+			return &tmp_resolution_param[i];
+		}
+	}
+	return NULL;
+}
+
+static int set_resolution_param(struct hm5065_device *dev, resolution_param_t* res_param)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int i=0;
+	//int rc = -1;
+	if (!res_param->reg_script) {
+		printk("error, resolution reg script is NULL\n");
+		return -1;
+	}
+	while(1) {
+		if (res_param->reg_script[i].val==0xff&&res_param->reg_script[i].addr==0xffff) {
+			printk("setting resolutin param complete\n");
+			break;
+		}
+		if((i2c_put_byte(client,res_param->reg_script[i].addr, res_param->reg_script[i].val)) < 0) {
+			printk("fail in setting resolution param. i=%d\n",i);
+			break;
+		}
+		i++;
+	}
+	dev->cur_resolution_param = res_param;
+	set_flip(dev);
+	return 0;
+}
+
+static int set_focus_zone(struct hm5065_device *dev, int value)
+	{	  
+			int xc, yc;
+			struct i2c_client *client =v4l2_get_subdevdata(&dev->sd);
+			int retry_count = 9;
+			int reg_value = 0;
+			int ret = -1;
+			printk("xc = %d, yc = %d\n", xc, yc);	
+			xc = ((value >> 16) & 0xffff) * 80 / 2000;
+			yc = (value & 0xffff) * 60 / 2000;
+			printk("xc1 = %d, yc1 = %d\n", xc, yc); 	
+			if(-1==ret)
+		   {
+			i2c_put_byte(client,0x0808,0x01);
+			i2c_put_byte(client,0x0809,0x00); 
+			i2c_put_byte(client,0x080a,0x00);
+			i2c_put_byte(client,0x080b,0x00);  
+			i2c_put_byte(client,0x080c,0x00);
+			i2c_put_byte(client,0x080d,0x00);
+			i2c_put_byte(client,0x080e,0x00); 
+		#if 1
+		  i2c_put_byte(client,FACE_LC,0x01);//enable	
+			i2c_put_byte(client,FACE_START_XH, xc>>8);
+			i2c_put_byte(client,FACE_START_XL, xc&0xFF);		
+			i2c_put_byte(client,FACE_START_YH, yc>>8);
+			i2c_put_byte(client,FACE_START_YL, yc&0xFF);
+			i2c_put_byte(client,FACE_SIZE_XH, 0x00);
+			i2c_put_byte(client,FACE_SIZE_XL, 80);
+			i2c_put_byte(client,FACE_SIZE_YH, 0x00);
+			i2c_put_byte(client,FACE_SIZE_YL, 60);
+			printk("SENSOR: _hm5065_Foucs_stareX: %d, %d\n",(xc>>8),(xc&0xFF)); 
+			printk("SENSOR: _hm5065_Foucs_stareY: %d, %d\n",(yc>>8),(yc&0xFF)); 
+		#endif
+			i2c_put_byte(client, 0x070a , 0x03);			
+			//msleep(100);
+			i2c_put_byte(client, 0x070b , 0x01);			
+			msleep(200);
+			i2c_put_byte(client, 0x070b , 0x02);
+			do
+			{
+				if(0x00==retry_count)
+				{
+					printk("SENSOR: _hm5065_AutoFocusZone error!\n"); 
+					ret=-1;
+					i2c_put_byte(client,0x0700, 0x01);
+				   i2c_put_byte(client,0x0701, 0xFD);
+					break ;
+				}
+				msleep(1);		  
+				reg_value=i2c_get_byte(client,AF_STATUS);
+				retry_count--;
+			}while(0x01!=reg_value);
+			ret=0;
+			focus_position_hi = i2c_get_byte(client,0x06F0);
+			focus_position_lo = i2c_get_byte(client,0x06F1);
+			i2c_put_byte(client,0x0700, focus_position_hi&0xFF);// target position H
+			i2c_put_byte(client,0x0701, focus_position_lo&0xFF);// target position L
+			printk("SENSOR: _hm5065_AF status %d\n",i2c_get_byte(client,AF_STATUS)); 
+		}
+		return ret; 		
+		}
+
+
+unsigned char v4l_2_hm5065(int val)
+{
+	int ret=val/0x20;
+	if(ret<4) return ret*0x20+0x80;
+	else if(ret<8) return ret*0x20+0x20;
+	else return 0;
+}
+
+static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_canvas)
+{
+	int canvas = start_canvas;
+
+	switch(v4l2_format){
+	case V4L2_PIX_FMT_RGB565X:
+	case V4L2_PIX_FMT_VYUY:
+		canvas = start_canvas;
+		break;
+	case V4L2_PIX_FMT_YUV444:
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB24:
+		canvas = start_canvas;
+		break; 
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21: 
+		canvas = start_canvas | ((start_canvas+1)<<8);
+		break;
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV420:
+		if(V4L2_PIX_FMT_YUV420 == v4l2_format){
+			canvas = start_canvas|((start_canvas+1)<<8)|((start_canvas+2)<<16);
+		}else{
+			canvas = start_canvas|((start_canvas+2)<<8)|((start_canvas+1)<<16);
+		}
+		break;
+	default:
+		break;
+	}
+	return canvas;
+}
+
+static int hm5065_setting(struct hm5065_device *dev,int PROP_ID,int value ) 
+{
+	int ret=0;
+	//unsigned char cur_val;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	switch(PROP_ID)  {
+	case V4L2_CID_BRIGHTNESS:
+		mutex_lock(&firmware_mutex);
+		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_hm5065(value));
+		ret=i2c_put_byte(client,0x0201,v4l_2_hm5065(value));
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_CONTRAST:
+		mutex_lock(&firmware_mutex);
+		ret=i2c_put_byte(client,0x0200, value);
+		mutex_unlock(&firmware_mutex);
+		break;    
+	case V4L2_CID_SATURATION:
+		mutex_lock(&firmware_mutex);
+		ret=i2c_put_byte(client,0x0202, value);
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_HFLIP:    /* set flip on H. */
+		value = value & 0x3;
+		if(hm5065_qctrl[2].default_value!=value){
+			hm5065_qctrl[2].default_value=value;
+			printk(" set camera  h filp =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_VFLIP:    /* set flip on V. */
+		break;    
+	case V4L2_CID_DO_WHITE_BALANCE:
+		mutex_lock(&firmware_mutex);
+		if(hm5065_qctrl[4].default_value!=value){
+			hm5065_qctrl[4].default_value=value;
+			HM5065_set_param_wb(dev,value);
+			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
+		}
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_EXPOSURE:
+		mutex_lock(&firmware_mutex);
+		if(hm5065_qctrl[5].default_value!=value){
+			hm5065_qctrl[5].default_value=value;
+			HM5065_set_param_exposure(dev,value);
+			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
+		}
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_COLORFX:
+		mutex_lock(&firmware_mutex);
+		if(hm5065_qctrl[6].default_value!=value){
+			hm5065_qctrl[6].default_value=value;
+			HM5065_set_param_effect(dev,value);
+			printk(KERN_INFO " set camera  effect=%d. \n ",value);
+		}
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_WHITENESS:
+		mutex_lock(&firmware_mutex);
+		if(hm5065_qctrl[7].default_value!=value){
+			hm5065_qctrl[7].default_value=value;
+			HM5065_set_param_banding(dev,value);
+			printk(KERN_INFO " set camera  banding=%d. \n ",value);
+		}
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		mutex_lock(&firmware_mutex);
+		if (hm5065_have_opened) {
+			if (dev->firmware_ready) 
+				ret = HM5065_AutoFocus(dev,value);
+			else if (value == CAM_FOCUS_MODE_CONTI_VID ||
+        				value == CAM_FOCUS_MODE_CONTI_PIC)
+				start_focus_mode = value;
+			else
+				ret = -1;
+		}
+		mutex_unlock(&firmware_mutex);
+		break;
+	case V4L2_CID_BACKLIGHT_COMPENSATION:
+		if (dev->cam_info.flash_support) 
+			ret = HM5065_FlashCtrl(dev,value);
+		else
+			ret = -1;
+		break;
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		if(hm5065_qctrl[10].default_value!=value){
+			hm5065_qctrl[10].default_value=value;
+			//printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_ROTATE:
+		if(hm5065_qctrl[11].default_value!=value){
+			hm5065_qctrl[11].default_value=value;
+			printk(" set camera  rotate =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		if(hm5065_qctrl[12].default_value!=value){
+			hm5065_qctrl[12].default_value=value;
+			printk(" set camera  focus zone =%d. \n ",value);
+			set_focus_zone(dev, value);
+		}
+		break;
+	default:
+		ret=-1;
+		break;
+	}
+	return ret;
+    
+}
+
+static void power_down_hm5065(struct hm5065_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	i2c_put_byte(client,0x070a, 0x00); //release focus
+	i2c_put_byte(client,0x0010, 0x02);//in soft power down mode
+}
+
+/* ------------------------------------------------------------------
+	DMA and thread functions
+   ------------------------------------------------------------------*/
+
+#define TSTAMP_MIN_Y	24
+#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X	10
+#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
+
+static void hm5065_fillbuff(struct hm5065_fh *fh, struct hm5065_buffer *buf)
+{
+	struct hm5065_device *dev = fh->dev;
+	//void *vbuf = videobuf_to_vmalloc(&buf->vb);
+	void *vbuf = (void *)videobuf_to_res(&buf->vb);
+	vm_output_para_t para = {0};
+	dprintk(dev,1,"%s\n", __func__);    
+	if (!vbuf)
+    	return;
+	/*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
+	if(buf->canvas_id == 0)
+           buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, HM5065_RES0_CANVAS_INDEX+buf->vb.i*3);
+	para.mirror = hm5065_qctrl[2].default_value&3;
+	para.v4l2_format = fh->fmt->fourcc;
+	para.v4l2_memory = MAGIC_RE_MEM;//0x18221223;
+	para.zoom = hm5065_qctrl[10].default_value;
+	para.angle = hm5065_qctrl[11].default_value;
+	para.vaddr = (unsigned)vbuf;
+	para.ext_canvas = buf->canvas_id;
+	para.width = buf->vb.width;
+	para.height = buf->vb.height;
+	vm_fill_buffer(&buf->vb,&para);
+	buf->vb.state = VIDEOBUF_DONE;
+}
+
+static void hm5065_thread_tick(struct hm5065_fh *fh)
+{
+	struct hm5065_buffer *buf;
+	struct hm5065_device *dev = fh->dev;
+	struct hm5065_dmaqueue *dma_q = &dev->vidq;
+
+	unsigned long flags = 0;
+
+	dprintk(dev, 1, "Thread tick\n");
+	if(!fh->stream_on){
+		dprintk(dev, 1, "sensor doesn't stream on\n");
+		return ;
+	}
+
+	spin_lock_irqsave(&dev->slock, flags);
+	if (list_empty(&dma_q->active)) {
+		dprintk(dev, 1, "No active queue to serve\n");
+		goto unlock;
+	}
+
+	buf = list_entry(dma_q->active.next,
+ 			struct hm5065_buffer, vb.queue);
+	dprintk(dev, 1, "%s\n", __func__);
+	dprintk(dev, 1, "list entry get buf is %x\n", (unsigned)buf);
+
+
+	if(!(fh->f_flags & O_NONBLOCK)){
+		/* Nobody is waiting on this buffer, return */
+		if (!waitqueue_active(&buf->vb.done))
+			goto unlock;
+	}
+	buf->vb.state = VIDEOBUF_ACTIVE;
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+
+	/* Fill buffer */
+	spin_unlock_irqrestore(&dev->slock, flags);
+	hm5065_fillbuff(fh, buf);
+	dprintk(dev, 1, "filled buffer %p\n", buf);
+
+	wake_up(&buf->vb.done);
+	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+	return;
+unlock:
+	spin_unlock_irqrestore(&dev->slock, flags);
+	return;
+}
+
+static void hm5065_sleep(struct hm5065_fh *fh)
+{
+	struct hm5065_device *dev = fh->dev;
+	struct hm5065_dmaqueue *dma_q = &dev->vidq;
+
+	//int timeout;
+	DECLARE_WAITQUEUE(wait, current);
+
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
+        (unsigned long)dma_q);
+
+	add_wait_queue(&dma_q->wq, &wait);
+	if (kthread_should_stop())
+    	goto stop_task;
+
+	/* Calculate time to wake up */
+	//timeout = msecs_to_jiffies(1);
+
+	hm5065_thread_tick(fh);
+
+	schedule_timeout_interruptible(1);
+
+stop_task:
+	remove_wait_queue(&dma_q->wq, &wait);
+	try_to_freeze();
+}
+
+static int hm5065_thread(void *data)
+{
+	struct hm5065_fh  *fh = data;
+	struct hm5065_device *dev = fh->dev;
+
+	dprintk(dev, 1, "thread started\n");
+
+	set_freezable();
+
+	for (;;) {
+		hm5065_sleep(fh);
+		
+		if (kthread_should_stop())
+			break;
+	}
+	dprintk(dev, 1, "thread: exit\n");
+	return 0;
+}
+
+static int hm5065_start_thread(struct hm5065_fh *fh)
+{
+	struct hm5065_device *dev = fh->dev;
+	struct hm5065_dmaqueue *dma_q = &dev->vidq;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	dma_q->kthread = kthread_run(hm5065_thread, fh, "hm5065");
+
+	if (IS_ERR(dma_q->kthread)) {
+		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+		return PTR_ERR(dma_q->kthread);
+	}
+	/* Wakes thread */
+	wake_up_interruptible(&dma_q->wq);
+
+	dprintk(dev, 1, "returning from %s\n", __func__);
+	return 0;
+}
+
+static void hm5065_stop_thread(struct hm5065_dmaqueue  *dma_q)
+{
+	struct hm5065_device *dev = container_of(dma_q, struct hm5065_device, vidq);
+
+	dprintk(dev, 1, "%s\n", __func__);
+	/* shutdown control thread */
+	if (dma_q->kthread) {
+		kthread_stop(dma_q->kthread);
+		dma_q->kthread = NULL;
+	}
+}
+
+/* ------------------------------------------------------------------
+	Videobuf operations
+   ------------------------------------------------------------------*/
+static int
+buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct hm5065_fh *fh  = container_of(res, struct hm5065_fh, res);
+	struct hm5065_device *dev  = fh->dev;
+	//int bytes = fh->fmt->depth >> 3 ;
+	int height = fh->height;
+	if(height==1080)
+           height = 1088;
+	*size = (fh->width*height*fh->fmt->depth)>>3;    
+	if (0 == *count)
+        *count = 32;
+
+	while (*size * *count > vid_limit * 1024 * 1024)
+        (*count)--;
+
+	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+        *count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct hm5065_buffer *buf)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct hm5065_fh *fh  = container_of(res, struct hm5065_fh, res);
+	struct hm5065_device *dev  = fh->dev;
+
+	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+	videobuf_waiton(vq, &buf->vb, 0, 0);
+
+	if (in_interrupt())
+    		BUG();
+
+	videobuf_res_free(vq, &buf->vb);
+	dprintk(dev, 1, "free_buffer: freed\n");
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+#define norm_maxw() 3000
+#define norm_maxh() 3000
+static int
+buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+                    	enum v4l2_field field)
+{
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct hm5065_fh *fh  = container_of(res, struct hm5065_fh, res);
+	struct hm5065_device    *dev = fh->dev;
+	struct hm5065_buffer *buf = container_of(vb, struct hm5065_buffer, vb);
+	int rc;
+	//int bytes = fh->fmt->depth >> 3 ;
+	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+
+	BUG_ON(NULL == fh->fmt);
+
+	if (fh->width  < 48 || fh->width  > norm_maxw() ||
+			fh->height < 32 || fh->height > norm_maxh())
+		return -EINVAL;
+
+	buf->vb.size = (fh->width*fh->height*fh->fmt->depth)>>3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+    	return -EINVAL;
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = fh->fmt;
+	buf->vb.width  = fh->width;
+	buf->vb.height = fh->height;
+	buf->vb.field  = field;
+
+	//precalculate_bars(fh);
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+    	rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0)
+			goto fail;
+	}
+
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void
+buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct hm5065_buffer    *buf  = container_of(vb, struct hm5065_buffer, vb);
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct hm5065_fh *fh  = container_of(res, struct hm5065_fh, res);
+	struct hm5065_device       *dev  = fh->dev;
+	struct hm5065_dmaqueue *vidq = &dev->vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+               struct videobuf_buffer *vb)
+{
+	struct hm5065_buffer   *buf  = container_of(vb, struct hm5065_buffer, vb);
+	struct videobuf_res_privdata *res = vq->priv_data;
+	struct hm5065_fh *fh  = container_of(res, struct hm5065_fh, res);
+	struct hm5065_device *dev = (struct hm5065_device *)fh->dev;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops hm5065_video_qops = {
+	.buf_setup      = buffer_setup,
+	.buf_prepare    = buffer_prepare,
+	.buf_queue      = buffer_queue,
+	.buf_release    = buffer_release,
+};
+
+/* ------------------------------------------------------------------
+	IOCTL vidioc handling
+   ------------------------------------------------------------------*/
+static int vidioc_querycap(struct file *file, void  *priv,
+                	struct v4l2_capability *cap)
+{
+	struct hm5065_fh  *fh  = priv;
+	struct hm5065_device *dev = fh->dev;
+
+	strcpy(cap->driver, "hm5065");
+	strcpy(cap->card, "hm5065.canvas");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+	cap->version = HM5065_CAMERA_VERSION;
+	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
+        			V4L2_CAP_STREAMING     |
+        			V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+                	struct v4l2_fmtdesc *f)
+{
+	struct hm5065_fmt *fmt;
+
+	if (f->index >= ARRAY_SIZE(formats))
+    	return -EINVAL;
+
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+                	struct v4l2_format *f)
+{
+	struct hm5065_fh *fh = priv;
+
+	printk("vidioc_g_fmt_vid_cap...fh->width =%d,fh->height=%d\n",fh->width,fh->height);
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vb_vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+    	f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return (0);
+}
+
+static int vidioc_enum_frameintervals(struct file *file, void *priv,
+					struct v4l2_frmivalenum *fival)
+{
+	unsigned int k;
+	
+	if(fival->index > ARRAY_SIZE(hm5065_frmivalenum))
+	return -EINVAL;
+	
+	for(k =0; k< ARRAY_SIZE(hm5065_frmivalenum); k++) {
+		if( (fival->index==hm5065_frmivalenum[k].index)&&
+				(fival->pixel_format ==hm5065_frmivalenum[k].pixel_format )&&
+				(fival->width==hm5065_frmivalenum[k].width)&&
+				(fival->height==hm5065_frmivalenum[k].height)){
+			memcpy( fival, &hm5065_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
+			return 0;
+		}
+	}
+	
+	return -EINVAL;
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+        	struct v4l2_format *f)
+{
+	struct hm5065_fh  *fh  = priv;
+	struct hm5065_device *dev = fh->dev;
+	struct hm5065_fmt *fmt;
+	enum v4l2_field field;
+	unsigned int maxw, maxh;
+
+	fmt = get_format(f);
+	if (!fmt) {
+		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+				f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	field = f->fmt.pix.field;
+	
+	if (field == V4L2_FIELD_ANY) {
+		field = V4L2_FIELD_INTERLACED;
+	} else if (V4L2_FIELD_INTERLACED != field) {
+		dprintk(dev, 1, "Field type invalid.\n");
+		return -EINVAL;
+	}
+
+	maxw  = norm_maxw();
+	maxh  = norm_maxh();
+
+	f->fmt.pix.field = field;
+	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
+                  &f->fmt.pix.height, 32, maxh, 0, 0);
+	f->fmt.pix.bytesperline =
+        	(f->fmt.pix.width * fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+    		f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+static resolution_param_t* prev_res = NULL;
+
+/*FIXME: This seems to be generic enough to be at videodev2 */
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+                	struct v4l2_format *f)
+{
+	struct hm5065_fh *fh = priv;
+	struct videobuf_queue *q = &fh->vb_vidq;
+	struct hm5065_device *dev = fh->dev;
+	resolution_param_t* res_param = NULL;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char gain = 0, exposurelow = 0, exposuremid = 0, exposurehigh = 0;
+	int cap_fps, pre_fps;
+
+        f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
+	if ((f->fmt.pix.pixelformat==V4L2_PIX_FMT_YVU420) ||
+            (f->fmt.pix.pixelformat==V4L2_PIX_FMT_YUV420)){
+                f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
+        }
+	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	if (ret < 0)
+    	return ret;
+
+	mutex_lock(&q->vb_lock);
+
+	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	fh->fmt           = get_format(f);
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+	printk("system aquire ...fh->height=%d, fh->width= %d\n",fh->height,fh->width);//potti
+#if 1
+	if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
+		res_param = get_resolution_param(dev, 1, fh->width,fh->height);
+		if (!res_param) {
+			printk("error, resolution param not get\n");
+			goto out;
+		}
+		/*get_exposure_param(dev, &gain, &exposurelow, &exposuremid, &exposurehigh);
+		printk("gain=0x%x, exposurelow=0x%x, exposuremid=0x%x, exposurehigh=0x%x\n",
+				 gain, exposurelow, exposuremid, exposurehigh);
+		*/
+		set_resolution_param(dev, res_param);
+		//set_exposure_param_500m(dev, gain, exposurelow, exposuremid, exposurehigh);
+		if (prev_res && (prev_res->size_type == SIZE_1280X960 
+				|| prev_res->size_type == SIZE_1024X768)) {
+			pre_fps = 1500;
+		} else if (prev_res && prev_res->size_type == SIZE_1280X720 ) {
+			pre_fps = 3000;
+		} else {
+			pre_fps = 1500;
+		} 
+		if (res_param && res_param->size_type == SIZE_2592X1944 ) {
+			//cap_fps = 750;
+			cap_fps = 500;
+		} else {
+			cap_fps = 750;
+		} 
+		printk("pre_fps=%d,cap_fps=%d\n", pre_fps, cap_fps);
+	} else {
+		res_param = get_resolution_param(dev, 0, fh->width,fh->height);
+		if (!res_param) {
+			printk("error, resolution param not get\n");
+			goto out;
+		}
+		set_resolution_param(dev, res_param);
+		prev_res = res_param;
+	}
+    
+#endif
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+	
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+ 				struct v4l2_streamparm *parms)
+{
+	struct hm5065_fh *fh = priv;
+	struct hm5065_device *dev = fh->dev;
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	
+	dprintk(dev,3,"vidioc_g_parm\n");
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	
+	cp->timeperframe = hm5065_frmintervals_active;
+	printk("g_parm,deno=%d, numerator=%d\n", cp->timeperframe.denominator,
+	cp->timeperframe.numerator );
+	return 0;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+              struct v4l2_requestbuffers *p)
+{
+	struct hm5065_fh  *fh = priv;
+
+	return (videobuf_reqbufs(&fh->vb_vidq, p));
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct hm5065_fh  *fh = priv;
+	int ret = videobuf_querybuf(&fh->vb_vidq, p);
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+	if(ret == 0){
+	    p->reserved  = convert_canvas_index(fh->fmt->fourcc, HM5065_RES0_CANVAS_INDEX+p->index*3);
+	}else{
+	    p->reserved = 0;
+	}
+#endif
+	return ret;
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct hm5065_fh *fh = priv;
+
+	return (videobuf_qbuf(&fh->vb_vidq, p));
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct hm5065_fh  *fh = priv;
+
+	return (videobuf_dqbuf(&fh->vb_vidq, p,
+            	file->f_flags & O_NONBLOCK));
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct hm5065_fh  *fh = priv;
+
+	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
+}
+#endif
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+        struct hm5065_fh  *fh = priv;
+        struct hm5065_device *dev = fh->dev;
+        vdin_parm_t para;
+        int ret = 0 ;
+        if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+                return -EINVAL;
+        if (i != fh->type)
+                return -EINVAL;
+
+        memset( &para, 0, sizeof( para ));
+        para.port  = TVIN_PORT_CAMERA;
+        para.fmt = TVIN_SIG_FMT_MAX;//TVIN_SIG_FMT_MAX+1;;TVIN_SIG_FMT_CAMERA_1280x720P_30Hz
+        if (fh->dev->cur_resolution_param) {
+                para.frame_rate = hm5065_frmintervals_active.denominator;
+                para.h_active = fh->dev->cur_resolution_param->active_frmsize.width;
+                para.v_active = fh->dev->cur_resolution_param->active_frmsize.height;
+                para.hs_bp = 0;
+                para.vs_bp = 2;
+                para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
+        } else {
+                para.frame_rate = hm5065_frmintervals_active.denominator;;
+                para.h_active = fh->dev->cur_resolution_param->active_frmsize.width;
+                para.v_active = fh->dev->cur_resolution_param->active_frmsize.height;
+                para.hs_bp = 0;
+                para.vs_bp = 2;
+                para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
+        }
+
+        printk("hm5065: h_active = %d; v_active = %d, frame_rate=%d\n",
+                        para.h_active, para.v_active, para.frame_rate);
+        para.cfmt = TVIN_YUV422;
+        para.dfmt = TVIN_NV21;
+        para.hsync_phase = 1;
+        para.vsync_phase  = 1;    
+        para.skip_count =  2;
+        para.bt_path = dev->cam_info.bt_path;
+        ret =  videobuf_streamon(&fh->vb_vidq);
+        if(ret == 0){
+                vops->start_tvin_service(0,&para);
+                fh->stream_on = 1;
+        }
+		HM5065_set_param_wb(dev,hm5065_qctrl[4].default_value);
+        return ret;
+}
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct hm5065_fh  *fh = priv;
+
+        int ret = 0 ;
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+    	return -EINVAL;
+	if (i != fh->type)
+    	return -EINVAL;
+	ret = videobuf_streamoff(&fh->vb_vidq);
+	if(ret == 0 ){
+		vops->stop_tvin_service(0);
+		fh->stream_on        = 0;
+	}
+	return ret;
+}
+
+static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsizeenum *fsize)
+{
+        int ret = 0,i=0;
+        struct hm5065_fmt *fmt = NULL;
+        struct v4l2_frmsize_discrete *frmsize = NULL;
+        for (i = 0; i < ARRAY_SIZE(formats); i++) {
+                if (formats[i].fourcc == fsize->pixel_format){
+                        fmt = &formats[i];
+                        break;
+                }
+        }
+        if (fmt == NULL)
+                return -EINVAL;
+        if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+                        ||(fmt->fourcc == V4L2_PIX_FMT_NV12)
+                        ||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
+                        ||(fmt->fourcc == V4L2_PIX_FMT_YVU420)){
+                printk("hm5065_prev_resolution[fsize->index]"
+                                "   before fsize->index== %d\n",fsize->index);//potti
+                if (fsize->index >= ARRAY_SIZE(prev_resolution_array))
+                        return -EINVAL;
+                frmsize = &prev_resolution_array[fsize->index].frmsize;
+                printk("hm5065_prev_resolution[fsize->index]"
+                                "   after fsize->index== %d\n",fsize->index);
+                fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+                fsize->discrete.width = frmsize->width;
+                fsize->discrete.height = frmsize->height;
+        } else if (fmt->fourcc == V4L2_PIX_FMT_RGB24){
+                printk("hm5065_pic_resolution[fsize->index]"
+                                "   before fsize->index== %d\n",fsize->index);
+                if (fsize->index >= ARRAY_SIZE(capture_resolution_array))
+                        return -EINVAL;
+                frmsize = &capture_resolution_array[fsize->index].frmsize;
+                printk("hm5065_pic_resolution[fsize->index]"
+                                "   after fsize->index== %d\n",fsize->index);
+                fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+                fsize->discrete.width = frmsize->width;
+                fsize->discrete.height = frmsize->height;
+        }
+        return ret;
+}
+
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+{
+	return 0;
+}
+
+/* only one input in this sample driver */
+static int vidioc_enum_input(struct file *file, void *priv,
+            	struct v4l2_input *inp)
+{
+    //if (inp->index >= NUM_INPUTS)
+        //return -EINVAL;
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->std = V4L2_STD_525_60;
+	sprintf(inp->name, "Camera %u", inp->index);
+
+	return (0);
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct hm5065_fh *fh = priv;
+	struct hm5065_device *dev = fh->dev;
+
+	*i = dev->input;
+
+	return (0);
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct hm5065_fh *fh = priv;
+	struct hm5065_device *dev = fh->dev;
+
+    //if (i >= NUM_INPUTS)
+        //return -EINVAL;
+
+	dev->input = i;
+    //precalculate_bars(fh);
+
+	return (0);
+}
+
+    /* --- controls ---------------------------------------------- */
+static int vidioc_queryctrl(struct file *file, void *priv,
+                struct v4l2_queryctrl *qc)
+{
+	int i;
+	struct hm5065_fh *fh = priv;
+	struct hm5065_device *dev = fh->dev;
+	
+	if (!dev->cam_info.flash_support 
+			&& qc->id == V4L2_CID_BACKLIGHT_COMPENSATION)
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(hm5065_qctrl); i++)
+		if (qc->id && qc->id == hm5065_qctrl[i].id) {
+			memcpy(qc, &(hm5065_qctrl[i]),
+				sizeof(*qc));
+			if (hm5065_qctrl[i].type == V4L2_CTRL_TYPE_MENU)
+				return hm5065_qctrl[i].maximum+1;
+			else
+				return (0);
+		}
+
+	return -EINVAL;
+}
+
+static int vidioc_querymenu(struct file *file, void *priv,
+                struct v4l2_querymenu *a)
+{
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(hm5065_qmenu_set); i++)
+ 		if (a->id && a->id == hm5065_qmenu_set[i].id) {
+ 			for(j = 0; j < hm5065_qmenu_set[i].num; j++)
+ 				if (a->index == hm5065_qmenu_set[i].hm5065_qmenu[j].index) {
+ 					memcpy(a, &( hm5065_qmenu_set[i].hm5065_qmenu[j]),
+ 		    			sizeof(*a));
+ 					return (0);
+ 				}
+ 		}
+
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+             struct v4l2_control *ctrl)
+{
+	struct hm5065_fh *fh = priv;
+	struct hm5065_device *dev = fh->dev;
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int i;
+	int i2cret = -1;
+
+	for (i = 0; i < ARRAY_SIZE(hm5065_qctrl); i++)
+		if (ctrl->id == hm5065_qctrl[i].id) {
+			if( (V4L2_CID_FOCUS_AUTO == ctrl->id)
+					&& bDoingAutoFocusMode){
+				if(i2c_get_byte(client, 0x3023)){
+					return -EBUSY;
+				}else{
+					bDoingAutoFocusMode = false;
+					if(i2c_get_byte(client, 0x3028) == 0){
+						printk("auto mode failed!\n");
+						return -EAGAIN;
+					}else {
+						i2c_put_byte(client, 0x3022 , 0x6); //pause the auto focus
+						i2c_put_byte(client, 0x3023 , 0x1);
+						printk("pause auto focus\n");
+					}
+				}
+			}else if( V4L2_CID_AUTO_FOCUS_STATUS == ctrl->id){
+				i2cret = i2c_get_byte(client, 0x3029);
+				if( 0x00 == i2cret){
+					ctrl->value = V4L2_AUTO_FOCUS_STATUS_BUSY;
+				}else if( 0x10 == i2cret){
+					ctrl->value = V4L2_AUTO_FOCUS_STATUS_REACHED;
+				}else if( 0x20 == i2cret){
+					ctrl->value = V4L2_AUTO_FOCUS_STATUS_IDLE;
+				}else{
+					printk("should resart focus\n");
+					ctrl->value = V4L2_AUTO_FOCUS_STATUS_FAILED;
+				}
+		        	
+				return 0;
+			}
+			ctrl->value = dev->qctl_regs[i];
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+            	struct v4l2_control *ctrl)
+{
+	struct hm5065_fh *fh = priv;
+	struct hm5065_device *dev = fh->dev;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hm5065_qctrl); i++)
+    	if (ctrl->id == hm5065_qctrl[i].id) {
+        	if (ctrl->value < hm5065_qctrl[i].minimum ||
+			ctrl->value > hm5065_qctrl[i].maximum ||
+			hm5065_setting(dev,ctrl->id,ctrl->value)<0) {
+			return -ERANGE;
+		}
+        	dev->qctl_regs[i] = ctrl->value;
+        	return 0;
+        }
+	return -EINVAL;
+}
+
+/* ------------------------------------------------------------------
+	File operations for the device
+   ------------------------------------------------------------------*/
+
+static int hm5065_open(struct file *file)
+{
+	struct hm5065_device *dev = video_drvdata(file);
+	struct hm5065_fh *fh = NULL;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	resource_size_t mem_start = 0;
+	unsigned int mem_size = 0;
+	int retval = 0;
+	//int reg_val;
+	//int i = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(32*SZ_1M);
+    if(retval <0) {
+    	printk("error: no cma memory\n");
+        return -1;
+    }
+#endif
+	mutex_lock(&firmware_mutex);
+	hm5065_have_opened=1;
+	mutex_unlock(&firmware_mutex);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 1);
+#endif	
+	aml_cam_init(&dev->cam_info);
+	
+	HM5065_init_regs(dev);
+	
+	msleep(10);
+	
+	/*if(HM5065_download_firmware(dev) >= 0) {
+		while(i2c_get_byte(client, 0x3029) != 0x70 && i < 10) { //wait for the mcu ready 
+        	msleep(5);
+        	i++;
+    	}
+    	dev->firmware_ready = 1;
+	}*/
+	
+	schedule_work(&(dev->dl_work));
+
+	mutex_lock(&dev->mutex);
+	dev->users++;
+	if (dev->users > 1) {
+		dev->users--;
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	dprintk(dev, 1, "open %s type=%s users=%d\n",
+    	video_device_node_name(dev->vdev),
+    	v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+        /* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	init_waitqueue_head(&dev->vidq.wq);
+	spin_lock_init(&dev->slock);
+	/* allocate + initialize per filehandle data */
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh) {
+		dev->users--;
+		retval = -ENOMEM;
+	}
+	mutex_unlock(&dev->mutex);
+
+	if (retval)
+    	return retval;
+
+	wake_lock(&(dev->wake_lock));
+	file->private_data = fh;
+	fh->dev      = dev;
+
+	fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fh->fmt      = &formats[0];
+	fh->width    = 640;
+	fh->height   = 480;
+	fh->stream_on = 0 ;
+	fh->f_flags  = file->f_flags;
+	/* Resets frame counters */
+	dev->jiffies = jiffies;
+
+	get_vm_buf_info(&mem_start, &mem_size, NULL);
+	fh->res.start = mem_start;
+	fh->res.end = mem_start+mem_size-1;
+	fh->res.magic = MAGIC_RE_MEM;
+	fh->res.priv = NULL;		
+	videobuf_queue_res_init(&fh->vb_vidq, &hm5065_video_qops,
+					NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+					sizeof(struct hm5065_buffer), (void*)&fh->res, NULL);
+
+	bDoingAutoFocusMode=false;
+	hm5065_start_thread(fh);
+	return 0;
+}
+
+static ssize_t
+hm5065_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct hm5065_fh *fh = file->private_data;
+
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
+                	file->f_flags & O_NONBLOCK);
+	}
+	return 0;
+}
+
+static unsigned int
+hm5065_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct hm5065_fh        *fh = file->private_data;
+	struct hm5065_device       *dev = fh->dev;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+    	return POLLERR;
+
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int hm5065_close(struct file *file)
+{
+	struct hm5065_fh         *fh = file->private_data;
+	struct hm5065_device *dev       = fh->dev;
+	struct hm5065_dmaqueue *vidq = &dev->vidq;
+	struct video_device  *vdev = video_devdata(file);
+	mutex_lock(&firmware_mutex);
+	hm5065_have_opened=0;
+	dev->firmware_ready = 0;
+	mutex_unlock(&firmware_mutex);
+	hm5065_stop_thread(vidq);
+	videobuf_stop(&fh->vb_vidq);
+	if(fh->stream_on){
+		vops->stop_tvin_service(0);     
+	}
+	videobuf_mmap_free(&fh->vb_vidq);
+
+	kfree(fh);
+
+	mutex_lock(&dev->mutex);
+	dev->users--;
+	mutex_unlock(&dev->mutex);
+
+	dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+    	video_device_node_name(vdev), dev->users);
+#if 1	    
+	hm5065_qctrl[4].default_value=0;
+	hm5065_qctrl[5].default_value=4;
+	hm5065_qctrl[6].default_value=0;
+	
+	hm5065_qctrl[2].default_value=0;
+	hm5065_qctrl[10].default_value=100;
+	hm5065_qctrl[11].default_value=0;
+	power_down_hm5065(dev);
+#endif
+	hm5065_frmintervals_active.numerator = 1;
+	hm5065_frmintervals_active.denominator = 25;
+	
+	aml_cam_uninit(&dev->cam_info);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 0);
+#endif	
+	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
+	return 0;
+}
+
+static int hm5065_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct hm5065_fh  *fh = file->private_data;
+	struct hm5065_device *dev = fh->dev;
+	int ret;
+
+	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+
+	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+		ret);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations hm5065_fops = {
+	.owner	    = THIS_MODULE,
+	.open       = hm5065_open,
+	.release    = hm5065_close,
+	.read       = hm5065_read,
+	.poll	    = hm5065_poll,
+	.ioctl      = video_ioctl2, /* V4L2 ioctl handler */
+	.mmap       = hm5065_mmap,
+};
+
+static const struct v4l2_ioctl_ops hm5065_ioctl_ops = {
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_querymenu     = vidioc_querymenu,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+	.vidioc_enum_framesizes = vidioc_enum_framesizes,
+	.vidioc_g_parm = vidioc_g_parm,
+	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf          = vidiocgmbuf,
+#endif
+};
+
+static struct video_device hm5065_template = {
+	.name	        = "hm5065_v4l",
+	.fops           = &hm5065_fops,
+	.ioctl_ops      = &hm5065_ioctl_ops,
+	.release	    = video_device_release,
+	
+	.tvnorms        = V4L2_STD_525_60,
+	.current_norm   = V4L2_STD_NTSC_M,
+};
+
+static int hm5065_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_HM5065, 0);
+}
+
+static const struct v4l2_subdev_core_ops hm5065_core_ops = {
+	.g_chip_ident = hm5065_g_chip_ident,
+};
+
+static const struct v4l2_subdev_ops hm5065_ops = {
+	.core = &hm5065_core_ops,
+};
+
+static int hm5065_probe(struct i2c_client *client,
+        	const struct i2c_device_id *id)
+{
+	aml_cam_info_t* plat_dat;
+	int err;
+	struct hm5065_device *t;
+	struct v4l2_subdev *sd;
+	vops = get_vdin_v4l2_ops();
+	v4l_info(client, "chip found @ 0x%x (%s)\n",
+        	client->addr << 1, client->adapter->name);
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (t == NULL)
+    		return -ENOMEM;
+	sd = &t->sd;
+	v4l2_i2c_subdev_init(sd, client, &hm5065_ops);
+	mutex_init(&t->mutex);
+
+	/* Now create a video4linux device */
+	t->vdev = video_device_alloc();
+	if (t->vdev == NULL) {
+		kfree(t);
+		kfree(client);
+		return -ENOMEM;
+	}
+	memcpy(t->vdev, &hm5065_template, sizeof(*t->vdev));
+	
+	video_set_drvdata(t->vdev, t);
+	
+	wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "hm5065");
+	/* Register it */
+	plat_dat= (aml_cam_info_t*)client->dev.platform_data;
+	if (plat_dat) {
+		memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
+		if (plat_dat->front_back >=0)  
+			video_nr = plat_dat->front_back;
+	} else {
+		printk("camera hm5065: have no platform data\n");
+		kfree(t);
+		kfree(client);
+		return -1;
+	}
+	err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (err < 0) {
+		video_device_release(t->vdev);
+		kfree(t);
+		return err;
+	}
+	return 0;
+}
+
+static int hm5065_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hm5065_device *t = to_dev(sd);
+
+	video_unregister_device(t->vdev);
+	v4l2_device_unregister_subdev(sd);
+	wake_lock_destroy(&(t->wake_lock));
+	kfree(t);
+	return 0;
+}
+
+static const struct i2c_device_id hm5065_id[] = {
+	{ "hm5065", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, hm5065_id);
+
+static struct i2c_driver hm5065_i2c_driver = {
+	.driver = {
+		.name = "hm5065",
+	},
+	.probe = hm5065_probe,
+	.remove = hm5065_remove,
+	.id_table = hm5065_id,
+};
+
+module_i2c_driver(hm5065_i2c_driver);
+
diff --git a/drivers/amlogic/camera/hm5065_firmware.h b/drivers/amlogic/camera/hm5065_firmware.h
new file mode 100755
index 000000000000..28d16380dd81
--- /dev/null
+++ b/drivers/amlogic/camera/hm5065_firmware.h
@@ -0,0 +1,2080 @@
+#ifndef OV5640_FIRMWARE_H
+#define OV5640_FIRMWARE_H
+#define CMD_MAIN	0x3022
+#define CMD_ACK		0x3023
+#define CMD_PARA0	0x3024
+#define CMD_PARA1	0x3025
+#define CMD_PARA2	0x3026
+#define CMD_PARA3	0x3027
+#define CMD_PARA4	0x3028
+#define FW_STATUS	0x3029
+struct aml_camera_i2c_fig_s HM5065_script_step[] = {
+
+{0xffff,0x01},  //	; MCU bypass;
+{0x9000,0x03},  //	; Enable Ram and enable Write;
+{0xA000,0x90},  //	;    MOV      DPTR,#fpInputRange(0x0C56)
+{0xA001,0x0C},  //	; 
+{0xA002,0x56},  //	; 
+{0xA003,0xE0},  //	;    MOVX     A,@DPTR
+{0xA004,0xFE},  //	;    MOV      R6,A
+{0xA005,0xA3},  //	;    INC      DPTR
+{0xA006,0xE0},  //	;    MOVX     A,@DPTR
+{0xA007,0xFF},  //	;    MOV      R7,A
+{0xA008,0x12},  //	;    LCALL    FPAlu_FloatToInt16(C:4285)
+{0xA009,0x42},  //	; 
+{0xA00A,0x85},  //	; 
+{0xA00B,0x90},  //	;    MOV      DPTR,#0x01B7  (0x0B4D)
+{0xA00C,0x01},  //	; 
+{0xA00D,0xB7},  //	; 
+{0xA00E,0xEE},  //	;    MOV      A,R6
+{0xA00F,0xF0},  //	;    MOVX     @DPTR,A
+{0xA010,0xFC},  //	;    MOV      R4,A
+{0xA011,0xA3},  //	;    INC      DPTR
+{0xA012,0xEF},  //	;    MOV      A,R7
+{0xA013,0xF0},  //	;    MOVX     @DPTR,A
+{0xA014,0xFD},  //	;    MOV      R5,A
+{0xA015,0x90},  //	;    MOV      DPTR,#0x0605
+{0xA016,0x06},  //	; 
+{0xA017,0x05},  //	; 
+{0xA018,0xE0},  //	;    MOVX     A,@DPTR
+{0xA019,0x75},  //	;    MOV      B(0xF0),#0x02
+{0xA01A,0xF0},  //	; 
+{0xA01B,0x02},  //	; 
+{0xA01C,0xA4},  //	;    MUL      AB
+{0xA01D,0x2D},  //	;    ADD      A,R5
+{0xA01E,0xFF},  //	;    MOV      R7,A
+{0xA01F,0xE5},  //	;    MOV      A,B(0xF0)
+{0xA020,0xF0},  //	; 
+{0xA021,0x3C},  //	;    ADDC     A,R4
+{0xA022,0xFE},  //	;    MOV      R6,A
+{0xA023,0xAB},  //	;    MOV      R3 07
+{0xA024,0x07},  //	; 
+{0xA025,0xFA},  //	;    MOV      R2,A
+{0xA026,0x33},  //	;    RLC      A
+{0xA027,0x95},  //	;    SUBB     A,ACC(0xE0)
+{0xA028,0xE0},  //	; 
+{0xA029,0xF9},  //	;    MOV      R1,A
+{0xA02A,0xF8},  //	;    MOV      R0,A
+{0xA02B,0x90},  //	;    MOV      DPTR,#0x0B4B
+{0xA02C,0x0B},  //	; 
+{0xA02D,0x4B},  //	; 
+{0xA02E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA02F,0xFE},  //	;    MOV      R6,A
+{0xA030,0xA3},  //	;    INC      DPTR
+{0xA031,0xE0},  //	;    MOVX     A,@DPTR
+{0xA032,0xFF},  //	;    MOV      R7,A
+{0xA033,0xEE},  //	;    MOV      A,R6
+{0xA034,0x33},  //	;    RLC      A
+{0xA035,0x95},  //	;    SUBB     A,ACC(0xE0)
+{0xA036,0xE0},  //	; 
+{0xA037,0xFD},  //	;    MOV      R5,A
+{0xA038,0xFC},  //	;    MOV      R4,A
+{0xA039,0x12},  //	;    LCALL    C?LMUL(C:0C7B)
+{0xA03A,0x0C},  //	; 
+{0xA03B,0x7B},  //	; 
+{0xA03C,0x90},  //	;    MOV      DPTR,#0x01B9(0x0B4F)
+{0xA03D,0x01},  //	; 
+{0xA03E,0xB9},  //	; 
+{0xA03F,0x12},  //	;    LCALL    C?LSTXDATA(C:0E05)
+{0xA040,0x0E},  //	; 
+{0xA041,0x05},  //	; 
+{0xA042,0x90},  //	;    MOV      DPTR,#0x01B9(0x0B4F)
+{0xA043,0x01},  //	; 
+{0xA044,0xB9},  //	; 
+{0xA045,0xE0},  //	;    MOVX     A,@DPTR
+{0xA046,0xFC},  //	;    MOV      R4,A
+{0xA047,0xA3},  //	;    INC      DPTR
+{0xA048,0xE0},  //	;    MOVX     A,@DPTR
+{0xA049,0xFD},  //	;    MOV      R5,A
+{0xA04A,0xA3},  //	;    INC      DPTR
+{0xA04B,0xE0},  //	;    MOVX     A,@DPTR
+{0xA04C,0xFE},  //	;    MOV      R6,A
+{0xA04D,0xA3},  //	;    INC      DPTR
+{0xA04E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA04F,0xFF},  //	;    MOV      R7,A
+{0xA050,0x78},  //	;    MOV      R0,#g_fTimer0TimeOut(0x08)
+{0xA051,0x08},  //	; 
+{0xA052,0x12},  //	;    LCALL    C?ULSHR(C:0DBF)
+{0xA053,0x0D},  //	; 
+{0xA054,0xBF},  //	; 
+{0xA055,0xA8},  //	;    MOV      R0,uwDelay1000(0x04)
+{0xA056,0x04},  //	; 
+{0xA057,0xA9},  //	;    MOV      R1 05
+{0xA058,0x05},  //	; 
+{0xA059,0xAA},  //	;    MOV      R2,uwDelay100(0x06)
+{0xA05A,0x06},  //	; 
+{0xA05B,0xAB},  //	;    MOV      R3 07
+{0xA05C,0x07},  //	; 
+{0xA05D,0x90},  //	;    MOV      DPTR,#0x0B49
+{0xA05E,0x0B},  //	; 
+{0xA05F,0x49},  //	; 
+{0xA060,0xE0},  //	;    MOVX     A,@DPTR
+{0xA061,0xFE},  //	;    MOV      R6,A
+{0xA062,0xA3},  //	;    INC      DPTR
+{0xA063,0xE0},  //	;    MOVX     A,@DPTR
+{0xA064,0xFF},  //	;    MOV      R7,A
+{0xA065,0xEE},  //	;    MOV      A,R6
+{0xA066,0x33},  //	;    RLC      A
+{0xA067,0x95},  //	;    SUBB     A,ACC(0xE0)
+{0xA068,0xE0},  //	; 
+{0xA069,0xFD},  //	;    MOV      R5,A
+{0xA06A,0xFC},  //	;    MOV      R4,A
+{0xA06B,0xC3},  //	;    CLR      C
+{0xA06C,0xEF},  //	;    MOV      A,R7
+{0xA06D,0x9B},  //	;    SUBB     A,R3
+{0xA06E,0xFF},  //	;    MOV      R7,A
+{0xA06F,0xEE},  //	;    MOV      A,R6
+{0xA070,0x9A},  //	;    SUBB     A,R2
+{0xA071,0xFE},  //	;    MOV      R6,A
+{0xA072,0xED},  //	;    MOV      A,R5
+{0xA073,0x99},  //	;    SUBB     A,R1
+{0xA074,0xFD},  //	;    MOV      R5,A
+{0xA075,0xEC},  //	;    MOV      A,R4
+{0xA076,0x98},  //	;    SUBB     A,R0
+{0xA077,0xFC},  //	;    MOV      R4,A
+{0xA078,0x78},  //	;    MOV      R0,#0x01
+{0xA079,0x01},  //	; 
+{0xA07A,0x12},  //	;    LCALL    C?ULSHR(C:0DBF)
+{0xA07B,0x0D},  //	; 
+{0xA07C,0xBF},  //	; 
+{0xA07D,0x90},  //	;    MOV      DPTR,#m_pxwOffsetVector(0x0C4A)
+{0xA07E,0x0C},  //	; 
+{0xA07F,0x4A},  //	; 
+{0xA080,0xE0},  //	;    MOVX     A,@DPTR
+{0xA081,0xFC},  //	;    MOV      R4,A
+{0xA082,0xA3},  //	;    INC      DPTR
+{0xA083,0xE0},  //	;    MOVX     A,@DPTR
+{0xA084,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA085,0x82},  //	; 
+{0xA086,0x8C},  //	;    MOV      DPH(0x83),R4
+{0xA087,0x83},  //	; 
+{0xA088,0xC0},  //	;    PUSH     DPH(0x83)
+{0xA089,0x83},  //	; 
+{0xA08A,0xC0},  //	;    PUSH     DPL(0x82)
+{0xA08B,0x82},  //	; 
+{0xA08C,0x90},  //	;    MOV      DPTR,#0x0B48
+{0xA08D,0x0B},  //	; 
+{0xA08E,0x48},  //	; 
+{0xA08F,0xE0},  //	;    MOVX     A,@DPTR
+{0xA090,0xD0},  //	;    POP      DPL(0x82)
+{0xA091,0x82},  //	; 
+{0xA092,0xD0},  //	;    POP      DPH(0x83)
+{0xA093,0x83},  //	; 
+{0xA094,0x75},  //	;    MOV      B(0xF0),#0x02
+{0xA095,0xF0},  //	; 
+{0xA096,0x02},  //	; 
+{0xA097,0x12},  //	;    LCALL    C?OFFXADD(C:0E45)
+{0xA098,0x0E},  //	; 
+{0xA099,0x45},  //	; 
+{0xA09A,0xEE},  //	;    MOV      A,R6
+{0xA09B,0xF0},  //	;    MOVX     @DPTR,A
+{0xA09C,0xA3},  //	;    INC      DPTR
+{0xA09D,0xEF},  //	;    MOV      A,R7
+{0xA09E,0xF0},  //	;    MOVX     @DPTR,A
+{0xA09F,0x02},  //	;    LJMP     C:BAD8
+{0xA0A0,0xBA},  //	; 
+{0xA0A1,0xD8},  //	; 
+{0xA0A2,0x90},  //    ;         
+{0xA0A3,0x30},  //    ;        MOV      DPTR,#0x0036
+{0xA0A4,0x18},  //    ;        
+{0xA0A5,0xe4},  //    ;        
+{0xA0A6,0xf0},  //    ;        MOV      A,#0x00
+{0xA0A7,0x74},  //    ;        
+{0xA0A8,0x3f},  //    ;        MOVX     @DPTR,A
+{0xA0A9,0xf0},  //    ;        INC      DPTR
+{0xA0AA,0x22},  //    ;        INC      DPTR
+{0xA0BF,0x90},  //	;    MOV      DPTR,#0x005E
+{0xA0C0,0x00},  //	; 
+{0xA0C1,0x5E},  //	; 
+{0xA0C2,0xE0},  //	;    MOVX     A,@DPTR
+{0xA0C3,0xFF},  //	;    MOV      R7,A
+{0xA0C4,0x70},  //	;    JNZ      B00:A9AF
+{0xA0C5,0x20},  //	; 
+{0xA0C6,0x90},  //	;    MOV      DPTR,#Av2x2_H_Size(0x4704)
+{0xA0C7,0x47},  //	; 
+{0xA0C8,0x04},  //	; 
+{0xA0C9,0x74},  //	;    MOV      A,#bInt_Event_Status(0x0A)
+{0xA0CA,0x0A},  //	; 
+{0xA0CB,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0CC,0xA3},  //	;    INC      DPTR
+{0xA0CD,0x74},  //	;    MOV      A,#0x30
+{0xA0CE,0x30},  //	; 
+{0xA0CF,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0D0,0x90},  //	;    MOV      DPTR,#Av2x2_V_Size(0x470C)
+{0xA0D1,0x47},  //	; 
+{0xA0D2,0x0C},  //	; 
+{0xA0D3,0x74},  //	;    MOV      A,#0x07
+{0xA0D4,0x07},  //	; 
+{0xA0D5,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0D6,0xA3},  //	;    INC      DPTR
+{0xA0D7,0x74},  //	;    MOV      A,#IE(0xA8)
+{0xA0D8,0xA8},  //	; 
+{0xA0D9,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0DA,0x90},  //	;    MOV      DPTR,#Av2x2_Xscale(0x47A4)
+{0xA0DB,0x47},  //	; 
+{0xA0DC,0xA4},  //	; 
+{0xA0DD,0x74},  //	;    MOV      A,#0x01
+{0xA0DE,0x01},  //	; 
+{0xA0DF,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0E0,0x90},  //	;    MOV      DPTR,#Av2x2_Yscale(0x47A8)
+{0xA0E1,0x47},  //	; 
+{0xA0E2,0xA8},  //	; 
+{0xA0E3,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0E4,0x80},  //	;    SJMP     B00:A9FF
+{0xA0E5,0x50},  //	; 
+{0xA0E6,0xEF},  //	;    MOV      A,R7
+{0xA0E7,0x64},  //	;    XRL      A,#0x01
+{0xA0E8,0x01},  //	; 
+{0xA0E9,0x60},  //	;    JZ       B00:A9B8
+{0xA0EA,0x04},  //	; 
+{0xA0EB,0xEF},  //	;    MOV      A,R7
+{0xA0EC,0xB4},  //	;    CJNE     A,#0x03,B00:A9D8
+{0xA0ED,0x03},  //	; 
+{0xA0EE,0x20},  //	; 
+{0xA0EF,0x90},  //	;    MOV      DPTR,#Av2x2_H_Size(0x4704)
+{0xA0F0,0x47},  //	; 
+{0xA0F1,0x04},  //	; 
+{0xA0F2,0x74},  //	;    MOV      A,#0x05
+{0xA0F3,0x05},  //	; 
+{0xA0F4,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0F5,0xA3},  //	;    INC      DPTR
+{0xA0F6,0x74},  //	;    MOV      A,#0x18
+{0xA0F7,0x18},  //	; 
+{0xA0F8,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0F9,0x90},  //	;    MOV      DPTR,#Av2x2_V_Size(0x470C)
+{0xA0FA,0x47},  //	; 
+{0xA0FB,0x0C},  //	; 
+{0xA0FC,0x74},  //	;    MOV      A,#0x03
+{0xA0FD,0x03},  //	; 
+{0xA0FE,0xF0},  //	;    MOVX     @DPTR,A
+{0xA0FF,0xA3},  //	;    INC      DPTR
+{0xA100,0x74},  //	;    MOV      A,#m_fDitherBitFormat(0xD4)
+{0xA101,0xD4},  //	; 
+{0xA102,0xF0},  //	;    MOVX     @DPTR,A
+{0xA103,0x90},  //	;    MOV      DPTR,#Av2x2_Xscale(0x47A4)
+{0xA104,0x47},  //	; 
+{0xA105,0xA4},  //	; 
+{0xA106,0x74},  //	;    MOV      A,#0x02
+{0xA107,0x02},  //	; 
+{0xA108,0xF0},  //	;    MOVX     @DPTR,A
+{0xA109,0x90},  //	;    MOV      DPTR,#Av2x2_Yscale(0x47A8)
+{0xA10A,0x47},  //	; 
+{0xA10B,0xA8},  //	; 
+{0xA10C,0xF0},  //	;    MOVX     @DPTR,A
+{0xA10D,0x80},  //	;    SJMP     B00:A9FF
+{0xA10E,0x27},  //	; 
+{0xA10F,0xEF},  //	;    MOV      A,R7
+{0xA110,0x64},  //	;    XRL      A,#0x02
+{0xA111,0x02},  //	; 
+{0xA112,0x60},  //	;    JZ       B00:A9E1
+{0xA113,0x04},  //	; 
+{0xA114,0xEF},  //	;    MOV      A,R7
+{0xA115,0xB4},  //	;    CJNE     A,#uwDelay1000(0x04),B00:A9FF
+{0xA116,0x04},  //	; 
+{0xA117,0x1E},  //	; 
+{0xA118,0x90},  //	;    MOV      DPTR,#Av2x2_H_Size(0x4704)
+{0xA119,0x47},  //	; 
+{0xA11A,0x04},  //	; 
+{0xA11B,0x74},  //	;    MOV      A,#0x02
+{0xA11C,0x02},  //	; 
+{0xA11D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA11E,0xA3},  //	;    INC      DPTR
+{0xA11F,0x74},  //	;    MOV      A,#TH0(0x8C)
+{0xA120,0x8C},  //	; 
+{0xA121,0xF0},  //	;    MOVX     @DPTR,A
+{0xA122,0x90},  //	;    MOV      DPTR,#Av2x2_V_Size(0x470C)
+{0xA123,0x47},  //	; 
+{0xA124,0x0C},  //	; 
+{0xA125,0x74},  //	;    MOV      A,#0x01
+{0xA126,0x01},  //	; 
+{0xA127,0xF0},  //	;    MOVX     @DPTR,A
+{0xA128,0xA3},  //	;    INC      DPTR
+{0xA129,0x74},  //	;    MOV      A,#0xEA
+{0xA12A,0xEA},  //	; 
+{0xA12B,0xF0},  //	;    MOVX     @DPTR,A
+{0xA12C,0x90},  //	;    MOV      DPTR,#Av2x2_Xscale(0x47A4)
+{0xA12D,0x47},  //	; 
+{0xA12E,0xA4},  //	; 
+{0xA12F,0x74},  //	;    MOV      A,#uwDelay1000(0x04)
+{0xA130,0x04},  //	; 
+{0xA131,0xF0},  //	;    MOVX     @DPTR,A
+{0xA132,0x90},  //	;    MOV      DPTR,#Av2x2_Yscale(0x47A8)
+{0xA133,0x47},  //	; 
+{0xA134,0xA8},  //	; 
+{0xA135,0xF0},  //	;    MOVX     @DPTR,A
+{0xA136,0x22},  //	;    RTN
+{0xA137,0x74},  //	;    MOV      A,#uwDelay1000(0x04)
+{0xA138,0x04},  //	; 
+{0xA139,0xF0},  //	;    MOVX     @DPTR,A
+{0xA13A,0xA3},  //	;    INC      DPTR
+{0xA13B,0x74},  //	;    MOV      A,#ZoomPanControl(0x20)
+{0xA13C,0x20},  //	; 
+{0xA13D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA13E,0xE4},  //	;    CLR      A
+{0xA13F,0xF5},  //	;    MOV      0x22,A
+{0xA140,0x22},  //	; 
+{0xA141,0xE5},  //	;    MOV      A 22
+{0xA142,0x22},  //	; 
+{0xA143,0xC3},  //	;    CLR      C
+{0xA144,0x94},  //	;    SUBB     A,#PipeSetupBank0(0x40)
+{0xA145,0x40},  //	; 
+{0xA146,0x40},  //	;    JC       B00:AB81
+{0xA147,0x03},  //	; 
+{0xA148,0x02},  //	;    LJMP     B00:AC33
+{0xA149,0xF1},  //	; 
+{0xA14A,0xFD},  //	; 
+{0xA14B,0x90},  //	;    MOV      DPTR,#0x0ABA
+{0xA14C,0x0A},  //	; 
+{0xA14D,0xBA},  //	; 
+{0xA14E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA14F,0xFE},  //	;    MOV      R6,A
+{0xA150,0xA3},  //	;    INC      DPTR
+{0xA151,0xE0},  //	;    MOVX     A,@DPTR
+{0xA152,0xFF},  //	;    MOV      R7,A
+{0xA153,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA154,0x82},  //	; 
+{0xA155,0x8E},  //	;    MOV      DPH(0x83),R6
+{0xA156,0x83},  //	; 
+{0xA157,0xE0},  //	;    MOVX     A,@DPTR
+{0xA158,0x54},  //	;    ANL      A,#0x70
+{0xA159,0x70},  //	; 
+{0xA15A,0xFD},  //	;    MOV      R5,A
+{0xA15B,0xC4},  //	;    SWAP     A
+{0xA15C,0x54},  //	;    ANL      A,#0x0F
+{0xA15D,0x0F},  //	; 
+{0xA15E,0xFD},  //	;    MOV      R5,A
+{0xA15F,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA160,0x0A},  //	; 
+{0xA161,0xBC},  //	; 
+{0xA162,0xE0},  //	;    MOVX     A,@DPTR
+{0xA163,0xFA},  //	;    MOV      R2,A
+{0xA164,0xA3},  //	;    INC      DPTR
+{0xA165,0xE0},  //	;    MOVX     A,@DPTR
+{0xA166,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA167,0x82},  //	; 
+{0xA168,0x8A},  //	;    MOV      DPH(0x83),R2
+{0xA169,0x83},  //	; 
+{0xA16A,0xED},  //	;    MOV      A,R5
+{0xA16B,0xF0},  //	;    MOVX     @DPTR,A
+{0xA16C,0x90},  //	;    MOV      DPTR,#0x0ABD
+{0xA16D,0x0A},  //	; 
+{0xA16E,0xBD},  //	; 
+{0xA16F,0xE0},  //	;    MOVX     A,@DPTR
+{0xA170,0x04},  //	;    INC      A
+{0xA171,0xF0},  //	;    MOVX     @DPTR,A
+{0xA172,0x70},  //	;    JNZ      B00:ABB0
+{0xA173,0x06},  //	; 
+{0xA174,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA175,0x0A},  //	; 
+{0xA176,0xBC},  //	; 
+{0xA177,0xE0},  //	;    MOVX     A,@DPTR
+{0xA178,0x04},  //	;    INC      A
+{0xA179,0xF0},  //	;    MOVX     @DPTR,A
+{0xA17A,0x8F},  //	;    MOV      DPL(0x82),R7
+{0xA17B,0x82},  //	; 
+{0xA17C,0x8E},  //	;    MOV      DPH(0x83),R6
+{0xA17D,0x83},  //	; 
+{0xA17E,0xA3},  //	;    INC      DPTR
+{0xA17F,0xE0},  //	;    MOVX     A,@DPTR
+{0xA180,0xFF},  //	;    MOV      R7,A
+{0xA181,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA182,0x0A},  //	; 
+{0xA183,0xBC},  //	; 
+{0xA184,0xE0},  //	;    MOVX     A,@DPTR
+{0xA185,0xFC},  //	;    MOV      R4,A
+{0xA186,0xA3},  //	;    INC      DPTR
+{0xA187,0xE0},  //	;    MOVX     A,@DPTR
+{0xA188,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA189,0x82},  //	; 
+{0xA18A,0x8C},  //	;    MOV      DPH(0x83),R4
+{0xA18B,0x83},  //	; 
+{0xA18C,0xEF},  //	;    MOV      A,R7
+{0xA18D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA18E,0x90},  //	;    MOV      DPTR,#0x0ABD
+{0xA18F,0x0A},  //	; 
+{0xA190,0xBD},  //	; 
+{0xA191,0xE0},  //	;    MOVX     A,@DPTR
+{0xA192,0x04},  //	;    INC      A
+{0xA193,0xF0},  //	;    MOVX     @DPTR,A
+{0xA194,0x70},  //	;    JNZ      B00:ABD2
+{0xA195,0x06},  //	; 
+{0xA196,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA197,0x0A},  //	; 
+{0xA198,0xBC},  //	; 
+{0xA199,0xE0},  //	;    MOVX     A,@DPTR
+{0xA19A,0x04},  //	;    INC      A
+{0xA19B,0xF0},  //	;    MOVX     @DPTR,A
+{0xA19C,0x90},  //	;    MOV      DPTR,#0x0ABA
+{0xA19D,0x0A},  //	; 
+{0xA19E,0xBA},  //	; 
+{0xA19F,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1A0,0xFE},  //	;    MOV      R6,A
+{0xA1A1,0xA3},  //	;    INC      DPTR
+{0xA1A2,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1A3,0xFF},  //	;    MOV      R7,A
+{0xA1A4,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA1A5,0x82},  //	; 
+{0xA1A6,0x8E},  //	;    MOV      DPH(0x83),R6
+{0xA1A7,0x83},  //	; 
+{0xA1A8,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1A9,0x54},  //	;    ANL      A,#0x07
+{0xA1AA,0x07},  //	; 
+{0xA1AB,0xFD},  //	;    MOV      R5,A
+{0xA1AC,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA1AD,0x0A},  //	; 
+{0xA1AE,0xBC},  //	; 
+{0xA1AF,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1B0,0xFA},  //	;    MOV      R2,A
+{0xA1B1,0xA3},  //	;    INC      DPTR
+{0xA1B2,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1B3,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA1B4,0x82},  //	; 
+{0xA1B5,0x8A},  //	;    MOV      DPH(0x83),R2
+{0xA1B6,0x83},  //	; 
+{0xA1B7,0xED},  //	;    MOV      A,R5
+{0xA1B8,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1B9,0x90},  //	;    MOV      DPTR,#0x0ABD
+{0xA1BA,0x0A},  //	; 
+{0xA1BB,0xBD},  //	; 
+{0xA1BC,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1BD,0x04},  //	;    INC      A
+{0xA1BE,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1BF,0x70},  //	;    JNZ      B00:ABFD
+{0xA1C0,0x06},  //	; 
+{0xA1C1,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA1C2,0x0A},  //	; 
+{0xA1C3,0xBC},  //	; 
+{0xA1C4,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1C5,0x04},  //	;    INC      A
+{0xA1C6,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1C7,0x8F},  //	;    MOV      DPL(0x82),R7
+{0xA1C8,0x82},  //	; 
+{0xA1C9,0x8E},  //	;    MOV      DPH(0x83),R6
+{0xA1CA,0x83},  //	; 
+{0xA1CB,0xA3},  //	;    INC      DPTR
+{0xA1CC,0xA3},  //	;    INC      DPTR
+{0xA1CD,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1CE,0xFF},  //	;    MOV      R7,A
+{0xA1CF,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA1D0,0x0A},  //	; 
+{0xA1D1,0xBC},  //	; 
+{0xA1D2,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1D3,0xFC},  //	;    MOV      R4,A
+{0xA1D4,0xA3},  //	;    INC      DPTR
+{0xA1D5,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1D6,0xF5},  //	;    MOV      DPL(0x82),A
+{0xA1D7,0x82},  //	; 
+{0xA1D8,0x8C},  //	;    MOV      DPH(0x83),R4
+{0xA1D9,0x83},  //	; 
+{0xA1DA,0xEF},  //	;    MOV      A,R7
+{0xA1DB,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1DC,0x90},  //	;    MOV      DPTR,#0x0ABD
+{0xA1DD,0x0A},  //	; 
+{0xA1DE,0xBD},  //	; 
+{0xA1DF,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1E0,0x04},  //	;    INC      A
+{0xA1E1,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1E2,0x70},  //	;    JNZ      B00:AC20
+{0xA1E3,0x06},  //	; 
+{0xA1E4,0x90},  //	;    MOV      DPTR,#0x0ABC
+{0xA1E5,0x0A},  //	; 
+{0xA1E6,0xBC},  //	; 
+{0xA1E7,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1E8,0x04},  //	;    INC      A
+{0xA1E9,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1EA,0x90},  //	;    MOV      DPTR,#0x0ABB
+{0xA1EB,0x0A},  //	; 
+{0xA1EC,0xBB},  //	; 
+{0xA1ED,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1EE,0x24},  //	;    ADD      A,#0x03
+{0xA1EF,0x03},  //	; 
+{0xA1F0,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1F1,0x90},  //	;    MOV      DPTR,#0x0ABA
+{0xA1F2,0x0A},  //	; 
+{0xA1F3,0xBA},  //	; 
+{0xA1F4,0xE0},  //	;    MOVX     A,@DPTR
+{0xA1F5,0x34},  //	;    ADDC     A,#DeviceParameters(0x00)
+{0xA1F6,0x00},  //	; 
+{0xA1F7,0xF0},  //	;    MOVX     @DPTR,A
+{0xA1F8,0x05},  //	;    INC      0x22
+{0xA1F9,0x22},  //	; 
+{0xA1FA,0x02},  //	;    LJMP     B00:A409
+{0xA1FB,0xF1},  //	; 
+{0xA1FC,0x41},  //	; 
+{0xA1FD,0x90},  //	;    MOV      DPTR,#0x0ABA
+{0xA1FE,0x0A},  //	; 
+{0xA1FF,0xBA},  //	; 
+{0xA200,0x74},  //	;    MOV      A,#g_fpPixelCount(0x0E)
+{0xA201,0x0E},  //	; 
+{0xA202,0xF0},  //	;    MOVX     @DPTR,A
+{0xA203,0xA3},  //	;    INC      DPTR
+{0xA204,0x74},  //	;    MOV      A,#0xDC
+{0xA205,0xDC},  //	; 
+{0xA206,0xF0},  //	;    MOVX     @DPTR,A
+{0xA207,0xA3},  //	;    INC      DPTR
+{0xA208,0x74},  //	;    MOV      A,#0x05
+{0xA209,0x05},  //	; 
+{0xA20A,0xF0},  //	;    MOVX     @DPTR,A
+{0xA20B,0xA3},  //	;    INC      DPTR
+{0xA20C,0x74},  //	;    MOV      A,#0x61
+{0xA20D,0x61},  //	; 
+{0xA20E,0xF0},  //	;    MOVX     @DPTR,A
+{0xA20F,0x90},  //	;    MOV      DPTR,#0x0ABA
+{0xA210,0x0A},  //	; 
+{0xA211,0xBA},  //	; 
+{0xA212,0xE0},  //	;    MOVX     A,@DPTR
+{0xA213,0xFE},  //	;    MOV      R6,A
+{0xA214,0xA3},  //	;    INC      DPTR
+{0xA215,0xE0},  //	;    MOVX     A,@DPTR
+{0xA216,0xAA},  //	;    MOV      R2,uwDelay100(0x06)
+{0xA217,0x06},  //	; 
+{0xA218,0xF9},  //	;    MOV      R1,A
+{0xA219,0x7B},  //	;    MOV      R3,#0x01
+{0xA21A,0x01},  //	; 
+{0xA21B,0xC0},  //	;    PUSH     0x02
+{0xA21C,0x02},  //	; 
+{0xA21D,0xA3},  //	;    INC      DPTR
+{0xA21E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA21F,0xFE},  //	;    MOV      R6,A
+{0xA220,0xA3},  //	;    INC      DPTR
+{0xA221,0xE0},  //	;    MOVX     A,@DPTR
+{0xA222,0xAA},  //	;    MOV      R2,uwDelay100(0x06)
+{0xA223,0x06},  //	; 
+{0xA224,0xF8},  //	;    MOV      R0,A
+{0xA225,0xAC},  //	;    MOV      R4 02
+{0xA226,0x02},  //	; 
+{0xA227,0x7D},  //	;    MOV      R5,#0x01
+{0xA228,0x01},  //	; 
+{0xA229,0xD0},  //	;    POP      0x02
+{0xA22A,0x02},  //	; 
+{0xA22B,0x7E},  //	;    MOV      R6,#DeviceParameters(0x00)
+{0xA22C,0x00},  //	; 
+{0xA22D,0x7F},  //	;    MOV      R7,#uwDelay1000(0x04)
+{0xA22E,0x04},  //	; 
+{0xA22F,0x12},  //	;    LCALL    C?COPY517(C:0F6F)
+{0xA230,0x0F},  //	; 
+{0xA231,0x6F},  //	; 
+{0xA232,0x02},  //	;    JUMP    
+{0xA233,0x66},  //	; 
+{0xA234,0xD9},  //	; 
+{0xA235,0x90},  //	;    MOV      R4 02
+{0xA236,0x07},  //	; 
+{0xA237,0xD0},  //	;    MOV      R5,#0x01
+{0xA238,0x02},  //	; 
+{0xA239,0xA2},  //	;    POP      0x02
+{0xA23A,0x69},  //	; 
+{0xA240,0x02},  //	;    ANL      A,#0xFD
+{0xA241,0x21},  //	; 
+{0xA242,0x7F},  //	;    MOVX     @DPTR,A
+{0xA243,0x02},  //	;    ANL      A,#0xFD
+{0xA244,0x21},  //	; 
+{0xA245,0xF4},  //	;    MOVX     @DPTR,A
+{0xA246,0x02},  //	;    ANL      A,#0xFD
+{0xA247,0xA6},  //	; 
+{0xA248,0x15},  //	;    MOVX     @DPTR,A
+{0xA249,0x60},  //	;    JZ       C:29EF
+{0xA24A,0x0A},  //	; 
+{0xA24B,0xEF},  //	;    MOV      A,R7
+{0xA24C,0xB4},  //	;    CJNE     A,#0x01,C:29FF
+{0xA24D,0x01},  //	; 
+{0xA24E,0x16},  //	; 
+{0xA24F,0x90},  //	;    MOV      DPTR,#ModeSetup(0x005D)
+{0xA250,0x00},  //	; 
+{0xA251,0x5D},  //	; 
+{0xA252,0xE0},  //	;    MOVX     A,@DPTR
+{0xA253,0x70},  //	;    JNZ      C:29FF
+{0xA254,0x10},  //	; 
+{0xA255,0x12},  //	;    LCALL    StreamManager_ResumeStreaming(C:26C8)
+{0xA256,0x26},  //	; 
+{0xA257,0xC8},  //	; 
+{0xA258,0x90},  //	;    MOV      DPTR,#0x0011
+{0xA259,0x00},  //	; 
+{0xA25A,0x11},  //	; 
+{0xA25B,0x74},  //	;    MOV      A,#0x30
+{0xA25C,0x30},  //	; 
+{0xA25D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA25E,0x90},  //	;    MOV      DPTR,#fpHighClipForDesiredExposure(0x0010)
+{0xA25F,0x00},  //	; 
+{0xA260,0x10},  //	; 
+{0xA261,0x74},  //	;    MOV      A,#0x01
+{0xA262,0x01},  //	; 
+{0xA263,0xF0},  //	;    MOVX     @DPTR,A
+{0xA264,0x22},  //	;    RET      
+{0xA265,0x12},  //	;    LCALL    C:25A8
+{0xA266,0x25},  //	; 
+{0xA267,0xA8},  //	; 
+{0xA268,0x02},  //	;      RET     
+{0xA269,0x29},  //	; 
+{0xA26A,0xFC},  //	; 
+{0xA26B,0x44},  //	;    ORL      A,#fpHighClipForDesiredExposure(0x10)
+{0xA26C,0x18},  //	; 
+{0xA26D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA26E,0x90},  //	;    MOV      DPTR,#Tx_Csi2_Dphy_Datalane2_Pwr_Ctrl(0x7218)
+{0xA26F,0x72},  //	; 
+{0xA270,0x18},  //	; 
+{0xA271,0xE0},  //	;    MOVX     A,@DPTR
+{0xA272,0x44},  //	;    ORL      A,#fpHighClipForDesiredExposure(0x10)
+{0xA273,0x18},  //	; 
+{0xA274,0xF0},  //	;    MOVX     @DPTR,A
+{0xA275,0x00},  //	;    MOV      DPTR,#Tx_Csi2_Dphy_Clklane_Pwr_Ctrl(0x7208)
+{0xA276,0x00},  //	; 
+{0xA277,0x00},  //	; 
+{0xA278,0x00},  //	;    MOVX     A,@DPTR
+{0xA279,0x00},  //	;    ORL      A,#fpHighClipForDesiredExposure(0x10)
+{0xA27A,0x00},  //	; 
+{0xA27B,0x90},  //	;    MOVX     @DPTR,A
+{0xA27C,0x72},  //	;    MOV      DPTR,#Tx_Csi2_Pwr_Ctrl(0x7214)
+{0xA27D,0x08},  //	; 
+{0xA27E,0xE0},  //	; 
+{0xA27F,0x44},  //	;    MOVX     A,@DPTR
+{0xA280,0x10},  //	;    ANL      A,#0xFD
+{0xA281,0xF0},  //	; 
+{0xA282,0x90},  //	;    MOVX     @DPTR,A
+{0xA283,0x72},  //	;    MOV      DPTR,#Tx_Csi2_Dphy_Pwr_Ctrl(0x7204)
+{0xA284,0x14},  //	; 
+{0xA285,0xE0},  //	; 
+{0xA286,0x54},  //	;    MOV      A,#0x1F
+{0xA287,0xFD},  //	; 
+{0xA288,0xF0},  //	;    MOVX     @DPTR,A
+{0xA289,0x22},  //	;    RET     
+{0xA29B,0xF0},  //	;    MOVX     @DPTR,A
+{0xA29C,0xD3},  //	;    SETB     C
+{0xA29D,0x90},  //	;    MOV      DPTR,#0x0791
+{0xA29E,0x07},  //	; 
+{0xA29F,0x91},  //	; 
+{0xA2A0,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2A1,0x94},  //	;    SUBB     A,#0x21
+{0xA2A2,0x21},  //	; 
+{0xA2A3,0x90},  //	;    MOV      DPTR,#AutoFocusInput(0x0790)
+{0xA2A4,0x07},  //	; 
+{0xA2A5,0x90},  //	; 
+{0xA2A6,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2A7,0x64},  //	;    XRL      A,#PipeSetupCommon(0x80)
+{0xA2A8,0x80},  //	; 
+{0xA2A9,0x94},  //	;    SUBB     A,#SP(0x81)
+{0xA2AA,0x81},  //	; 
+{0xA2AB,0x40},  //	;    JC       B01:B152
+{0xA2AC,0x08},  //	; 
+{0xA2AD,0x90},  //	;    MOV      DPTR,#0x07CB
+{0xA2AE,0x07},  //	; 
+{0xA2AF,0xCB},  //	; 
+{0xA2B0,0x74},  //	;    MOV      A,#0xFF
+{0xA2B1,0xFF},  //	; 
+{0xA2B2,0xF0},  //	;    MOVX     @DPTR,A
+{0xA2B3,0x80},  //	;    SJMP     B01:B158
+{0xA2B4,0x06},  //	; 
+{0xA2B5,0x90},  //	;    MOV      DPTR,#0x07CB
+{0xA2B6,0x07},  //	; 
+{0xA2B7,0xCB},  //	; 
+{0xA2B8,0x74},  //	;    MOV      A,#0x01
+{0xA2B9,0x01},  //	; 
+{0xA2BA,0xF0},  //	;    MOVX     @DPTR,A
+{0xA2BB,0x02},  //	;    JUMP
+{0xA2BC,0xB5},  //	; 
+{0xA2BD,0xC3},  //	; 
+{0xA2BE,0x90},  //	;    MOV      DPTR,#0x0834
+{0xA2BF,0x08},  //	; 
+{0xA2C0,0x34},  //	; 
+{0xA2C1,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2C2,0xFC},  //	;    MOV      R4,A
+{0xA2C3,0xA3},  //	;    INC      DPTR
+{0xA2C4,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2C5,0xFD},  //	;    MOV      R5,A
+{0xA2C6,0xA3},  //	;    INC      DPTR
+{0xA2C7,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2C8,0xFE},  //	;    MOV      R6,A
+{0xA2C9,0xA3},  //	;    INC      DPTR
+{0xA2CA,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2CB,0xFF},  //	;    MOV      R7,A
+{0xA2CC,0x90},  //	;    MOV      DPTR,#AutoFocusMeasureData(0x07D0)
+{0xA2CD,0x07},  //	; 
+{0xA2CE,0xD0},  //	; 
+{0xA2CF,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2D0,0xF8},  //	;    MOV      R0,A
+{0xA2D1,0xA3},  //	;    INC      DPTR
+{0xA2D2,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2D3,0xF9},  //	;    MOV      R1,A
+{0xA2D4,0xA3},  //	;    INC      DPTR
+{0xA2D5,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2D6,0xFA},  //	;    MOV      R2,A
+{0xA2D7,0xA3},  //	;    INC      DPTR
+{0xA2D8,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2D9,0xFB},  //	;    MOV      R3,A
+{0xA2DA,0xD3},  //	;    SETB     C
+{0xA2DB,0x12},  //	;    LCALL    C?ULCMP(C:0DAE)
+{0xA2DC,0x0D},  //	; 
+{0xA2DD,0xAE},  //	; 
+{0xA2DE,0x40},  //	;    JC       B01:9FDA
+{0xA2DF,0x0B},  //	; 
+{0xA2E0,0x12},  //	;    LCALL    HCS_Initialization(B01:B0EF)
+{0xA2E1,0xB5},  //	; 
+{0xA2E2,0x49},  //	; 
+{0xA2E3,0x90},  //	;    MOV      DPTR,#0x07A4
+{0xA2E4,0x07},  //	; 
+{0xA2E5,0xA4},  //	; 
+{0xA2E6,0x74},  //	;    MOV      A,#0x02
+{0xA2E7,0x02},  //	; 
+{0xA2E8,0xF0},  //	;    MOVX     @DPTR,A
+{0xA2E9,0x80},  //	;    SJMP     B01:9FE3
+{0xA2EA,0x09},  //	; 
+{0xA2EB,0x12},  //	;    LCALL    LowFocusMeasureFullSearchInit(B01:B7AE)
+{0xA2EC,0xB7},  //	; 
+{0xA2ED,0x51},  //	; 
+{0xA2EE,0x90},  //	;    MOV      DPTR,#0x07A4
+{0xA2EF,0x07},  //	; 
+{0xA2F0,0xA4},  //	; 
+{0xA2F1,0x74},  //	;    MOV      A,#0x05
+{0xA2F2,0x05},  //	; 
+{0xA2F3,0xF0},  //	;    MOVX     @DPTR,A
+{0xA2F4,0x02},  //	;    JUM
+{0xA2F5,0xA2},  //	; 
+{0xA2F6,0xDA},  //	; 
+{0xA2F7,0x90},  //	;    MOV      DPTR,#fOTPRed(0x0EE0)
+{0xA2F8,0x0E},  //	; 
+{0xA2F9,0xE0},  //	; 
+{0xA2FA,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2FB,0xFD},  //	;    MOV      R5,A
+{0xA2FC,0xA3},  //	;    INC      DPTR
+{0xA2FD,0xE0},  //	;    MOVX     A,@DPTR
+{0xA2FE,0x90},  //	;    MOV      DPTR,#0x02A2
+{0xA2FF,0x02},  //	; 
+{0xA300,0xA2},  //	; 
+{0xA301,0xCD},  //	;    XCH      A,R5
+{0xA302,0xF0},  //	;    MOVX     @DPTR,A
+{0xA303,0xA3},  //	;    INC      DPTR
+{0xA304,0xED},  //	;    MOV      A,R5
+{0xA305,0xF0},  //	;    MOVX     @DPTR,A
+{0xA306,0x90},  //	;    MOV      DPTR,#fOTPBlue(0x0EE2)
+{0xA307,0x0E},  //	; 
+{0xA308,0xE2},  //	; 
+{0xA309,0xE0},  //	;    MOVX     A,@DPTR
+{0xA30A,0xFD},  //	;    MOV      R5,A
+{0xA30B,0xA3},  //	;    INC      DPTR
+{0xA30C,0xE0},  //	;    MOVX     A,@DPTR
+{0xA30D,0x90},  //	;    MOV      DPTR,#0x02A8
+{0xA30E,0x02},  //	; 
+{0xA30F,0xA8},  //	; 
+{0xA310,0xCD},  //	;    XCH      A,R5
+{0xA311,0xF0},  //	;    MOVX     @DPTR,A
+{0xA312,0xA3},  //	;    INC      DPTR
+{0xA313,0xED},  //	;    MOV      A,R5
+{0xA314,0xF0},  //	;    MOVX     @DPTR,A
+{0xA315,0xE4},  //	;    CLR      A
+{0xA316,0x90},  //	;    MOV      DPTR,#PresetControl(0x0638)
+{0xA317,0x06},  //	; 
+{0xA318,0x38},  //	; 
+{0xA319,0xF0},  //	;    MOVX     @DPTR,A
+{0xA31A,0x02},  //	;    JUMP     #676
+{0xA31B,0x67},  //	; 
+{0xA31C,0x63},  //	; 
+{0xA31D,0x90},  //	;    MOV      DPTR,#bDarkCalSR(0x0EE8)
+{0xA31E,0x0E},  //	; 
+{0xA31F,0xE8},  //	; 
+{0xA320,0xE0},  //	;    MOVX     A,@DPTR
+{0xA321,0x90},  //	;    MOV      DPTR,#0x0262
+{0xA322,0x02},  //	; 
+{0xA323,0x62},  //	; 
+{0xA324,0xF0},  //	;    MOVX     @DPTR,A
+{0xA325,0x90},  //	;    MOV      DPTR,#bDarkCalAB4(0x0EE9)
+{0xA326,0x0E},  //	; 
+{0xA327,0xE9},  //	; 
+{0xA328,0xE0},  //	;    MOVX     A,@DPTR
+{0xA329,0x90},  //	;    MOV      DPTR,#0x0263
+{0xA32A,0x02},  //	; 
+{0xA32B,0x63},  //	; 
+{0xA32C,0xF0},  //	;    MOVX     @DPTR,A
+{0xA32D,0x02},  //	;    JUMP     #676
+{0xA32E,0x67},  //	; 
+{0xA32F,0x1F},  //	; 
+{0xA33B,0x90},  //	;    MOV      DPTR,#INFINITY_OTP(0xE014)
+{0xA33C,0x0E},  //	; 
+{0xA33D,0x14},  //	; 
+{0xA33E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA33F,0xFE},  //	;    MOV      R6,A
+{0xA340,0xA3},  //	;    INC      DPTR
+{0xA341,0xE0},  //	;    MOVX     A,@DPTR
+{0xA342,0xFF},  //	;    MOV      R7,A
+{0xA343,0x90},  //	;    MOV      DPTR,#0x06D9
+{0xA344,0x06},  //	; 
+{0xA345,0xD9},  //	; 
+{0xA346,0xEE},  //	;    MOV      A,R6
+{0xA347,0xF0},  //	;    MOVX     @DPTR,A
+{0xA348,0xA3},  //	;    INC      DPTR
+{0xA349,0xEF},  //	;    MOV      A,R7
+{0xA34A,0xF0},  //	;    MOVX     @DPTR,A
+{0xA34B,0x90},  //	;    MOV      DPTR,#DELTA_UP_OTP(0xE018)
+{0xA34C,0x0E},  //	; 
+{0xA34D,0x18},  //	; 
+{0xA34E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA34F,0xFD},  //	;    MOV      R5,A
+{0xA350,0x7C},  //	;    MOV      R4,#DeviceParameters(0x00)
+{0xA351,0x00},  //	; 
+{0xA352,0xC3},  //	;    CLR      C
+{0xA353,0xEF},  //	;    MOV      A,R7
+{0xA354,0x9D},  //	;    SUBB     A,R5
+{0xA355,0xEE},  //	;    MOV      A,R6
+{0xA356,0x9C},  //	;    SUBB     A,R4
+{0xA357,0x50},  //	;    JNC      C:2067
+{0xA358,0x09},  //	; 
+{0xA359,0xE4},  //	;    CLR      A
+{0xA35A,0x90},  //	;    MOV      DPTR,#0x06D7
+{0xA35B,0x06},  //	; 
+{0xA35C,0xD7},  //	; 
+{0xA35D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA35E,0xA3},  //	;    INC      DPTR
+{0xA35F,0xF0},  //	;    MOVX     @DPTR,A
+{0xA360,0x80},  //	;    SJMP     C:207A
+{0xA361,0x13},  //	; 
+{0xA362,0xC3},  //	;    CLR      C
+{0xA363,0x90},  //	;    MOV      DPTR,#0x06DA
+{0xA364,0x06},  //	; 
+{0xA365,0xDA},  //	; 
+{0xA366,0xE0},  //	;    MOVX     A,@DPTR
+{0xA367,0x9D},  //	;    SUBB     A,R5
+{0xA368,0xFE},  //	;    MOV      R6,A
+{0xA369,0x90},  //	;    MOV      DPTR,#0x06D9
+{0xA36A,0x06},  //	; 
+{0xA36B,0xD9},  //	; 
+{0xA36C,0xE0},  //	;    MOVX     A,@DPTR
+{0xA36D,0x9C},  //	;    SUBB     A,R4
+{0xA36E,0x90},  //	;    MOV      DPTR,#0x06D7
+{0xA36F,0x06},  //	; 
+{0xA370,0xD7},  //	; 
+{0xA371,0xF0},  //	;    MOVX     @DPTR,A
+{0xA372,0xA3},  //	;    INC      DPTR
+{0xA373,0xCE},  //	;    XCH      A,R6
+{0xA374,0xF0},  //	;    MOVX     @DPTR,A
+{0xA375,0x90},  //	;    MOV      DPTR,#DELTA_UP_OTP(0xE018)
+{0xA376,0x0E},  //	; 
+{0xA377,0x18},  //	; 
+{0xA378,0xE0},  //	;    MOVX     A,@DPTR
+{0xA379,0xF9},  //	;    MOV      R1,A
+{0xA37A,0xFF},  //	;    MOV      R7,A
+{0xA37B,0x90},  //	;    MOV      DPTR,#0x06C2
+{0xA37C,0x06},  //	; 
+{0xA37D,0xC2},  //	; 
+{0xA37E,0xE0},  //	;    MOVX     A,@DPTR
+{0xA37F,0xFC},  //	;    MOV      R4,A
+{0xA380,0xA3},  //	;    INC      DPTR
+{0xA381,0xE0},  //	;    MOVX     A,@DPTR
+{0xA382,0xFD},  //	;    MOV      R5,A
+{0xA383,0xC3},  //	;    CLR      C
+{0xA384,0x9F},  //	;    SUBB     A,R7
+{0xA385,0xFF},  //	;    MOV      R7,A
+{0xA386,0xEC},  //	;    MOV      A,R4
+{0xA387,0x94},  //	;    SUBB     A,#DeviceParameters(0x00)
+{0xA388,0x00},  //	; 
+{0xA389,0xFE},  //	;    MOV      R6,A
+{0xA38A,0x90},  //	;    MOV      DPTR,#MACRO_OTP(0xE016)
+{0xA38B,0x0E},  //	; 
+{0xA38C,0x16},  //	; 
+{0xA38D,0xE0},  //	;    MOVX     A,@DPTR
+{0xA38E,0xFA},  //	;    MOV      R2,A
+{0xA38F,0xA3},  //	;    INC      DPTR
+{0xA390,0xE0},  //	;    MOVX     A,@DPTR
+{0xA391,0xFB},  //	;    MOV      R3,A
+{0xA392,0xD3},  //	;    SETB     C
+{0xA393,0x9F},  //	;    SUBB     A,R7
+{0xA394,0xEA},  //	;    MOV      A,R2
+{0xA395,0x9E},  //	;    SUBB     A,R6
+{0xA396,0x40},  //	;    JC       C:20A7
+{0xA397,0x0A},  //	; 
+{0xA398,0x90},  //	;    MOV      DPTR,#0x06D5
+{0xA399,0x06},  //	; 
+{0xA39A,0xD5},  //	; 
+{0xA39B,0xEC},  //	;    MOV      A,R4
+{0xA39C,0xF0},  //	;    MOVX     @DPTR,A
+{0xA39D,0xA3},  //	;    INC      DPTR
+{0xA39E,0xED},  //	;    MOV      A,R5
+{0xA39F,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3A0,0x80},  //	;    SJMP     C:20B5
+{0xA3A1,0x0E},  //	; 
+{0xA3A2,0xE9},  //	;    MOV      A,R1
+{0xA3A3,0x7E},  //	;    MOV      R6,#DeviceParameters(0x00)
+{0xA3A4,0x00},  //	; 
+{0xA3A5,0x2B},  //	;    ADD      A,R3
+{0xA3A6,0xFF},  //	;    MOV      R7,A
+{0xA3A7,0xEE},  //	;    MOV      A,R6
+{0xA3A8,0x3A},  //	;    ADDC     A,R2
+{0xA3A9,0x90},  //	;    MOV      DPTR,#0x06D5
+{0xA3AA,0x06},  //	; 
+{0xA3AB,0xD5},  //	; 
+{0xA3AC,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3AD,0xA3},  //	;    INC      DPTR
+{0xA3AE,0xEF},  //	;    MOV      A,R7
+{0xA3AF,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3B0,0xE9},  //	;    MOV      A,R1
+{0xA3B1,0xFB},  //	;    MOV      R3,A
+{0xA3B2,0x7A},  //	;    MOV      R2,#DeviceParameters(0x00)
+{0xA3B3,0x00},  //	; 
+{0xA3B4,0x90},  //	;    MOV      DPTR,#0xE015
+{0xA3B5,0x0E},  //	; 
+{0xA3B6,0x15},  //	; 
+{0xA3B7,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3B8,0x2B},  //	;    ADD      A,R3
+{0xA3B9,0xFE},  //	;    MOV      R6,A
+{0xA3BA,0x90},  //	;    MOV      DPTR,#INFINITY_OTP(0xE014)
+{0xA3BB,0x0E},  //	; 
+{0xA3BC,0x14},  //	; 
+{0xA3BD,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3BE,0x3A},  //	;    ADDC     A,R2
+{0xA3BF,0x90},  //	;    MOV      DPTR,#0x06E1
+{0xA3C0,0x06},  //	; 
+{0xA3C1,0xE1},  //	; 
+{0xA3C2,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3C3,0xA3},  //	;    INC      DPTR
+{0xA3C4,0xCE},  //	;    XCH      A,R6
+{0xA3C5,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3C6,0xC3},  //	;    CLR      C
+{0xA3C7,0x90},  //	;    MOV      DPTR,#0xE017
+{0xA3C8,0x0E},  //	; 
+{0xA3C9,0x17},  //	; 
+{0xA3CA,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3CB,0x9B},  //	;    SUBB     A,R3
+{0xA3CC,0xFE},  //	;    MOV      R6,A
+{0xA3CD,0x90},  //	;    MOV      DPTR,#MACRO_OTP(0xE016)
+{0xA3CE,0x0E},  //	; 
+{0xA3CF,0x16},  //	; 
+{0xA3D0,0x02},  //	;    JUMP    
+{0xA3D1,0x20},  //	; 
+{0xA3D2,0xD5},  //	; 
+{0xA3D3,0x90},  //	;    MOV      DPTR,#bDarkCalHFPN(0x0EE4)
+{0xA3d4,0x0E},  //	; 
+{0xA3d5,0xE4},  //	; 
+{0xA3d6,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3d7,0x90},  //	;    MOV      DPTR,#0x0266
+{0xA3d8,0x02},  //	; 
+{0xA3d9,0x66},  //	; 
+{0xA3da,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3DB,0x90},  //	;    MOV      DPTR,#bDarkCalHFPN(0x0EE4)
+{0xA3dc,0x0E},  //	; 
+{0xA3dd,0xE5},  //	; 
+{0xA3de,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3df,0x90},  //	;    MOV      DPTR,#0x0266
+{0xA3e0,0x02},  //	; 
+{0xA3e1,0x64},  //	; 
+{0xA3e2,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3e3,0x90},  //	;    MOV      DPTR,#bDarkCalHFPN(0x0EE4)
+{0xA3e4,0x0E},  //	; 
+{0xA3e5,0xE6},  //	; 
+{0xA3e6,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3e7,0x90},  //	;    MOV      DPTR,#0x0266
+{0xA3e8,0x02},  //	; 
+{0xA3e9,0x65},  //	; 
+{0xA3ea,0xF0},  //	;    MOVX     @DPTR,A
+{0xA3eb,0x02},  //	;    JUMP    
+{0xA3ec,0x67},  //	; 
+{0xA3ed,0xA5},  //	; 
+{0xA3f0,0x12},  //	; 
+{0xA3f1,0x47},  //	; 
+{0xA3f2,0x59},  //	;    MOVX     @DPTR,A
+{0xA3f3,0x90},  //	;    MOV      DPTR,#bDarkCalHFPN(0x0EE4)
+{0xA3f4,0x00},  //	; 
+{0xA3f5,0xB5},  //	; 
+{0xA3f6,0xE0},  //	;    MOVX     A,@DPTR
+{0xA3f7,0xB4},  //	;    MOVX     A,@DPTR
+{0xA3f8,0x02},  //	;    MOV      DPTR,#0x0266
+{0xA3f9,0x03},  //	; 
+{0xA3fa,0x12},  //	; 
+{0xA3fb,0x47},  //	;    MOVX     @DPTR,A
+{0xA3fc,0x59},  //	;    JUMP    
+{0xA3fd,0x02},  //	; 
+{0xA3fe,0xC5},  //	; 
+{0xA3ff,0xC3},  //	; 
+{0xA400,0x90},  //	;    MOV      DPTR,#c_HFlip(0x003D)
+{0xA401,0x00},  //	; 
+{0xA402,0x3D},  //	; 
+{0xA403,0xF0},  //	;    MOVX     @DPTR,A
+{0xA404,0x90},  //	;    MOV      DPTR,#0x0084
+{0xA405,0x00},  //	; 
+{0xA406,0x84},  //	; 
+{0xA407,0xE0},  //	;    MOVX     A,@DPTR
+{0xA408,0xFE},  //	;    MOV      R6,A
+{0xA409,0x90},  //	;    MOV      DPTR,#c_VFlip(0x003E)
+{0xA40A,0x00},  //	; 
+{0xA40B,0x3E},  //	; 
+{0xA40C,0xF0},  //	;    MOVX     @DPTR,A
+{0xA40D,0xEF},  //	;    MOV      A,R7
+{0xA40E,0x70},  //	;    JNZ      B00:8201
+{0xA40F,0x03},  //	; 
+{0xA410,0xEE},  //	;    MOV      A,R6
+{0xA411,0x60},  //	;    JZ       B00:8205
+{0xA412,0x04},  //	; 
+{0xA413,0x7F},  //	;    MOV      R7,#0x01
+{0xA414,0x01},  //	; 
+{0xA415,0x80},  //	;    SJMP     B00:8207
+{0xA416,0x02},  //	; 
+{0xA417,0x7F},  //	;    MOV      R7,#DeviceParameters(0x00)
+{0xA418,0x00},  //	; 
+{0xA419,0x90},  //	;    MOV      DPTR,#c_HVFlip(0x003F)
+{0xA41A,0x00},  //	; 
+{0xA41B,0x3F},  //	; 
+{0xA41C,0xEF},  //	;    MOV      A,R7
+{0xA41D,0xF0},  //	;    MOVX     @DPTR,A
+{0xA41E,0x02},  //	;    JUMP bac
+{0xA41F,0x89},  //	; 
+{0xA420,0xD3},  //	; 
+{0xA421,0x90},  //	;    MOV      DPTR,#uwI2CSIndex(0x0012)
+{0xA422,0x00},  //	; 
+{0xA423,0x12},  //	; 
+{0xA424,0xE0},  //	;    MOVX     A,@DPTR
+{0xA425,0xFF},  //	;    MOV      R7,A
+{0xA426,0x70},  //	;    JNZ      B00:9AC3
+{0xA427,0x0C},  //	; 
+{0xA428,0x90},  //	;    MOV      DPTR,#0x0046
+{0xA429,0x00},  //	; 
+{0xA42A,0x46},  //	; 
+{0xA42B,0xE0},  //	;    MOVX     A,@DPTR
+{0xA42C,0xC3},  //	;    CLR      C
+{0xA42D,0x94},  //	;    SUBB     A,#0x07
+{0xA42E,0x07},  //	; 
+{0xA42F,0x40},  //	;    JC       B00:9AC3
+{0xA430,0x03},  //	; 
+{0xA431,0x75},  //	;    MOV      0x2E,#0x02
+{0xA432,0x2E},  //	; 
+{0xA433,0x02},  //	; 
+{0xA434,0xEF},  //	;    MOV      A,R7
+{0xA435,0xB4},  //	;    CJNE     A,#0x01,B00:9AD3
+{0xA436,0x01},  //	; 
+{0xA437,0x0C},  //	; 
+{0xA438,0x90},  //	;    MOV      DPTR,#XDroop_Reverse_Croping(0x0066)
+{0xA439,0x00},  //	; 
+{0xA43A,0x66},  //	; 
+{0xA43B,0xE0},  //	;    MOVX     A,@DPTR
+{0xA43C,0xC3},  //	;    CLR      C
+{0xA43D,0x94},  //	;    SUBB     A,#0x07
+{0xA43E,0x07},  //	; 
+{0xA43F,0x40},  //	;    JC       B00:9AD3
+{0xA440,0x03},  //	; 
+{0xA441,0x75},  //	;    MOV      0x2E,#0x02
+{0xA442,0x2E},  //	; 
+{0xA443,0x02},  //	; 
+{0xA444,0x02},  //	;    JUMP   
+{0xA445,0xA7},  //	; 
+{0xA446,0x9E},  //	; 
+{0xA447,0xC3},  //	;   CLR      C
+{0xA448,0x90},  //	;   MOV      DPTR,#0x0B8F
+{0xA449,0x0B},  //	;
+{0xA44A,0x8F},  //	;
+{0xA44B,0xE0},  //	;   MOVX     A,@DPTR
+{0xA44C,0x94},  //	;   SUBB     A,#PipeSetupCommon(0x80)
+{0xA44D,0x80},  //	;
+{0xA44E,0x90},  //	;   MOV      DPTR,#CalculateNormalisedStatistics?BYTE(0x0B8E)
+{0xA44F,0x0B},  //	;
+{0xA450,0x8E},  //	;
+{0xA451,0xE0},  //	;   MOVX     A,@DPTR
+{0xA452,0x94},  //	;   SUBB     A,#0x44
+{0xA453,0x44},  //	;
+{0xA454,0x40},  //	;   JC       B00:827D
+{0xA455,0x22},  //	;
+{0xA456,0x90},  //	;   MOV      DPTR,#0x0B91
+{0xA457,0x0B},  //	;
+{0xA458,0x91},  //	;
+{0xA459,0xE0},  //	;   MOVX     A,@DPTR
+{0xA45A,0x94},  //	;   SUBB     A,#PipeSetupCommon(0x80)
+{0xA45B,0x80},  //	;
+{0xA45C,0x90},  //	;   MOV      DPTR,#0x0B90
+{0xA45D,0x0B},  //	;
+{0xA45E,0x90},  //	;
+{0xA45F,0xE0},  //	;   MOVX     A,@DPTR
+{0xA460,0x94},  //	;   SUBB     A,#0x44
+{0xA461,0x44},  //	;
+{0xA462,0x40},  //	;   JC       B00:827D
+{0xA463,0x14},  //	;
+{0xA464,0x90},  //	;   MOV      DPTR,#0x0B93
+{0xA465,0x0B},  //	;
+{0xA466,0x93},  //	;
+{0xA467,0xE0},  //	;   MOVX     A,@DPTR
+{0xA468,0x94},  //	;   SUBB     A,#PipeSetupCommon(0x80)
+{0xA469,0x80},  //	;
+{0xA46A,0x90},  //	;   MOV      DPTR,#0x0B92
+{0xA46B,0x0B},  //	;
+{0xA46C,0x92},  //	;
+{0xA46D,0xE0},  //	;   MOVX     A,@DPTR
+{0xA46E,0x94},  //	;   SUBB     A,#0x44
+{0xA46F,0x44},  //	;
+{0xA470,0x40},  //	;   JC       B00:827D
+{0xA471,0x06},  //	;
+{0xA472,0x90},  //	;   MOV      DPTR,#0x01A4
+{0xA473,0x01},  //	;
+{0xA474,0xA4},  //	;
+{0xA475,0x02},  //	;   LJMP     back
+{0xA476,0x86},  //	;
+{0xA477,0x57},  //	;
+{0xA478,0x02},  //	;   LJMP     back
+{0xA479,0x86},  //	;
+{0xA47A,0x5C},  //	;                                                               
+{0xA500,0xF5},  //     ;    MOV      c_HeightScale(0x3B),A                              
+{0xA501,0x3B},  //     ;                                                                
+{0xA502,0x90},  //     ;    MOV      DPTR,#0x066C                                       
+{0xA503,0x06},  //     ;                                                                
+{0xA504,0x6C},  //     ;                                                                
+{0xA505,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA506,0xFF},  //     ;    MOV      R7,A                                               
+{0xA507,0xE5},  //     ;    MOV      A,c_HeightScale(0x3B)                              
+{0xA508,0x3B},  //     ;                                                                
+{0xA509,0xC3},  //     ;    CLR      C                                                  
+{0xA50A,0x9F},  //     ;    SUBB     A,R7                                               
+{0xA50B,0x40},  //     ;    JC       B01:98E8                                           
+{0xA50C,0x03},  //     ;                                                                
+{0xA50D,0x02},  //     ;    LJMP     B01:99E6                                           
+{0xA50E,0xF6},  //     ;                                                                
+{0xA50F,0x0E},  //     ;                                                                
+{0xA510,0x90},  //     ;    MOV      DPTR,#0x0BC6                                       
+{0xA511,0x0B},  //     ;                                                                
+{0xA512,0xC6},  //     ;                                                                
+{0xA513,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA514,0x14},  //     ;    DEC      A                                                  
+{0xA515,0x60},  //     ;    JZ       B01:992B                                           
+{0xA516,0x3C},  //     ;                                                                
+{0xA517,0x14},  //     ;    DEC      A                                                  
+{0xA518,0x60},  //     ;    JZ       B01:995D                                           
+{0xA519,0x6B},  //     ;                                                                
+{0xA51A,0x24},  //     ;    ADD      A,#0x02                                            
+{0xA51B,0x02},  //     ;                                                                
+{0xA51C,0x60},  //     ;    JZ       B01:98F9                                           
+{0xA51D,0x03},  //     ;                                                                
+{0xA51E,0x02},  //     ;    LJMP     B01:998D                                           
+{0xA51F,0xF5},  //     ;                                                                
+{0xA520,0xB5},  //     ;                                                                
+{0xA521,0x90},  //     ;    MOV      DPTR,#AutoFocusInstableFocusMeasureValues(0x0A9A)  
+{0xA522,0x0A},  //     ;                                                                
+{0xA523,0x9A},  //     ;                                                                
+{0xA524,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA525,0xFB},  //     ;    MOV      R3,A                                               
+{0xA526,0xA3},  //     ;    INC      DPTR                                               
+{0xA527,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA528,0xFA},  //     ;    MOV      R2,A                                               
+{0xA529,0xA3},  //     ;    INC      DPTR                                               
+{0xA52A,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA52B,0xF9},  //     ;    MOV      R1,A                                               
+{0xA52C,0x85},  //     ;    MOV      DPL(0x82),c_HeightScale(0x3B)                      
+{0xA52D,0x3B},  //     ;                                                                
+{0xA52E,0x82},  //     ;                                                                
+{0xA52F,0x75},  //     ;    MOV      DPH(0x83),#DeviceParameters(0x00)                  
+{0xA530,0x83},  //     ;                                                                
+{0xA531,0x00},  //     ;                                                                
+{0xA532,0x12},  //     ;    LCALL    C?CLDOPTR(C:0AB8)                                  
+{0xA533,0x0A},  //     ;                                                                
+{0xA534,0xB8},  //     ;                                                                
+{0xA535,0xFF},  //     ;    MOV      R7,A                                               
+{0xA536,0x74},  //     ;    MOV      A,#0xAB                                            
+{0xA537,0xAB},  //     ;                                                                
+{0xA538,0x25},  //     ;    ADD      A,c_HeightScale(0x3B)                              
+{0xA539,0x3B},  //     ;                                                                
+{0xA53A,0xF5},  //     ;    MOV      DPL(0x82),A                                        
+{0xA53B,0x82},  //     ;                                                                
+{0xA53C,0xE4},  //     ;    CLR      A                                                  
+{0xA53D,0x34},  //     ;    ADDC     A,#bInt_Event_Status(0x0A)                         
+{0xA53E,0x0A},  //     ;                                                                
+{0xA53F,0xF5},  //     ;    MOV      DPH(0x83),A                                        
+{0xA540,0x83},  //     ;                                                                
+{0xA541,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA542,0xFD},  //     ;    MOV      R5,A                                               
+{0xA543,0xC3},  //     ;    CLR      C                                                  
+{0xA544,0xEF},  //     ;    MOV      A,R7                                               
+{0xA545,0x9D},  //     ;    SUBB     A,R5                                               
+{0xA546,0xFE},  //     ;    MOV      R6,A                                               
+{0xA547,0xE4},  //     ;    CLR      A                                                  
+{0xA548,0x94},  //     ;    SUBB     A,#DeviceParameters(0x00)                          
+{0xA549,0x00},  //     ;                                                                
+{0xA54A,0x90},  //     ;    MOV      DPTR,#0x0BCA                                       
+{0xA54B,0x0B},  //     ;                                                                
+{0xA54C,0xCA},  //     ;                                                                
+{0xA54D,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA54E,0xA3},  //     ;    INC      DPTR                                               
+{0xA54F,0xCE},  //     ;    XCH      A,R6                                               
+{0xA550,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA551,0x80},  //     ;    SJMP     B01:998D                                           
+{0xA552,0x62},  //     ;                                                                
+{0xA553,0x90},  //     ;    MOV      DPTR,#AutoFocusInstableFocusMeasureValues(0x0A9A)  
+{0xA554,0x0A},  //     ;                                                                
+{0xA555,0x9A},  //     ;                                                                
+{0xA556,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA557,0xFB},  //     ;    MOV      R3,A                                               
+{0xA558,0xA3},  //     ;    INC      DPTR                                               
+{0xA559,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA55A,0xFA},  //     ;    MOV      R2,A                                               
+{0xA55B,0xA3},  //     ;    INC      DPTR                                               
+{0xA55C,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA55D,0xF9},  //     ;    MOV      R1,A                                               
+{0xA55E,0x85},  //     ;    MOV      DPL(0x82),c_HeightScale(0x3B)                      
+{0xA55F,0x3B},  //     ;                                                                
+{0xA560,0x82},  //     ;                                                                
+{0xA561,0x75},  //     ;    MOV      DPH(0x83),#DeviceParameters(0x00)                  
+{0xA562,0x83},  //     ;                                                                
+{0xA563,0x00},  //     ;                                                                
+{0xA564,0x12},  //     ;    LCALL    C?CLDOPTR(C:0AB8)                                  
+{0xA565,0x0A},  //     ;                                                                
+{0xA566,0xB8},  //     ;                                                                
+{0xA567,0xFF},  //     ;    MOV      R7,A                                               
+{0xA568,0x74},  //     ;    MOV      A,#0x9D                                            
+{0xA569,0x9D},  //     ;                                                                
+{0xA56A,0x25},  //     ;    ADD      A,c_HeightScale(0x3B)                              
+{0xA56B,0x3B},  //     ;                                                                
+{0xA56C,0xF5},  //     ;    MOV      DPL(0x82),A                                        
+{0xA56D,0x82},  //     ;                                                                
+{0xA56E,0xE4},  //     ;    CLR      A                                                  
+{0xA56F,0x34},  //     ;    ADDC     A,#bInt_Event_Status(0x0A)                         
+{0xA570,0x0A},  //     ;                                                                
+{0xA571,0xF5},  //     ;    MOV      DPH(0x83),A                                        
+{0xA572,0x83},  //     ;                                                                
+{0xA573,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA574,0xFD},  //     ;    MOV      R5,A                                               
+{0xA575,0xC3},  //     ;    CLR      C                                                  
+{0xA576,0xEF},  //     ;    MOV      A,R7                                               
+{0xA577,0x9D},  //     ;    SUBB     A,R5                                               
+{0xA578,0xFE},  //     ;    MOV      R6,A                                               
+{0xA579,0xE4},  //     ;    CLR      A                                                  
+{0xA57A,0x94},  //     ;    SUBB     A,#DeviceParameters(0x00)                          
+{0xA57B,0x00},  //     ;                                                                
+{0xA57C,0x90},  //     ;    MOV      DPTR,#0x0BCA                                       
+{0xA57D,0x0B},  //     ;                                                                
+{0xA57E,0xCA},  //     ;                                                                
+{0xA57F,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA580,0xA3},  //     ;    INC      DPTR                                               
+{0xA581,0xCE},  //     ;    XCH      A,R6                                               
+{0xA582,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA583,0x80},  //     ;    SJMP     B01:998D                                           
+{0xA584,0x30},  //     ;                                                                
+{0xA585,0x90},  //     ;    MOV      DPTR,#AutoFocusInstableFocusMeasureValues(0x0A9A)  
+{0xA586,0x0A},  //     ;                                                                
+{0xA587,0x9A},  //     ;                                                                
+{0xA588,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA589,0xFB},  //     ;    MOV      R3,A                                               
+{0xA58A,0xA3},  //     ;    INC      DPTR                                               
+{0xA58B,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA58C,0xFA},  //     ;    MOV      R2,A                                               
+{0xA58D,0xA3},  //     ;    INC      DPTR                                               
+{0xA58E,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA58F,0xF9},  //     ;    MOV      R1,A                                               
+{0xA590,0x85},  //     ;    MOV      DPL(0x82),c_HeightScale(0x3B)                      
+{0xA591,0x3B},  //     ;                                                                
+{0xA592,0x82},  //     ;                                                                
+{0xA593,0x75},  //     ;    MOV      DPH(0x83),#DeviceParameters(0x00)                  
+{0xA594,0x83},  //     ;                                                                
+{0xA595,0x00},  //     ;                                                                
+{0xA596,0x12},  //     ;    LCALL    C?CLDOPTR(C:0AB8)                                  
+{0xA597,0x0A},  //     ;                                                                
+{0xA598,0xB8},  //     ;                                                                
+{0xA599,0xFF},  //     ;    MOV      R7,A                                               
+{0xA59A,0x74},  //     ;    MOV      A,#0xA4                                            
+{0xA59B,0xA4},  //     ;                                                                
+{0xA59C,0x25},  //     ;    ADD      A,c_HeightScale(0x3B)                              
+{0xA59D,0x3B},  //     ;                                                                
+{0xA59E,0xF5},  //     ;    MOV      DPL(0x82),A                                        
+{0xA59F,0x82},  //     ;                                                                
+{0xA5A0,0xE4},  //     ;    CLR      A                                                  
+{0xA5A1,0x34},  //     ;    ADDC     A,#bInt_Event_Status(0x0A)                         
+{0xA5A2,0x0A},  //     ;                                                                
+{0xA5A3,0xF5},  //     ;    MOV      DPH(0x83),A                                        
+{0xA5A4,0x83},  //     ;                                                                
+{0xA5A5,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5A6,0xFD},  //     ;    MOV      R5,A                                               
+{0xA5A7,0xC3},  //     ;    CLR      C                                                  
+{0xA5A8,0xEF},  //     ;    MOV      A,R7                                               
+{0xA5A9,0x9D},  //     ;    SUBB     A,R5                                               
+{0xA5AA,0xFE},  //     ;    MOV      R6,A                                               
+{0xA5AB,0xE4},  //     ;    CLR      A                                                  
+{0xA5AC,0x94},  //     ;    SUBB     A,#DeviceParameters(0x00)                          
+{0xA5AD,0x00},  //     ;                                                                
+{0xA5AE,0x90},  //     ;    MOV      DPTR,#0x0BCA                                       
+{0xA5AF,0x0B},  //     ;                                                                
+{0xA5B0,0xCA},  //     ;                                                                
+{0xA5B1,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA5B2,0xA3},  //     ;    INC      DPTR                                               
+{0xA5B3,0xCE},  //     ;    XCH      A,R6                                               
+{0xA5B4,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA5B5,0x90},  //     ;    MOV      DPTR,#0x0783                                       
+{0xA5B6,0x07},  //     ;                                                                
+{0xA5B7,0x83},  //     ;                                                                
+{0xA5B8,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5B9,0xFF},  //     ;    MOV      R7,A                                               
+{0xA5BA,0x7E},  //     ;    MOV      R6,#DeviceParameters(0x00)                         
+{0xA5BB,0x00},  //     ;                                                                
+{0xA5BC,0x90},  //     ;    MOV      DPTR,#patch_wLightGap(0x0DF6)                      
+{0xA5BD,0x0D},  //     ;                                                                
+{0xA5BE,0xF6},  //     ;                                                                
+{0xA5BF,0xEE},  //     ;    MOV      A,R6                                               
+{0xA5C0,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA5C1,0xA3},  //     ;    INC      DPTR                                               
+{0xA5C2,0xEF},  //     ;    MOV      A,R7                                               
+{0xA5C3,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA5C4,0x90},  //     ;    MOV      DPTR,#0x0BCA                                       
+{0xA5C5,0x0B},  //     ;                                                                
+{0xA5C6,0xCA},  //     ;                                                                
+{0xA5C7,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5C8,0xFC},  //     ;    MOV      R4,A                                               
+{0xA5C9,0xA3},  //     ;    INC      DPTR                                               
+{0xA5CA,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5CB,0xFD},  //     ;    MOV      R5,A                                               
+{0xA5CC,0xD3},  //     ;    SETB     C                                                  
+{0xA5CD,0x9F},  //     ;    SUBB     A,R7                                               
+{0xA5CE,0x74},  //     ;    MOV      A,#PipeSetupCommon(0x80)                           
+{0xA5CF,0x80},  //     ;                                                                
+{0xA5D0,0xF8},  //     ;    MOV      R0,A                                               
+{0xA5D1,0xEC},  //     ;    MOV      A,R4                                               
+{0xA5D2,0x64},  //     ;    XRL      A,#PipeSetupCommon(0x80)                           
+{0xA5D3,0x80},  //     ;                                                                
+{0xA5D4,0x98},  //     ;    SUBB     A,R0                                               
+{0xA5D5,0x40},  //     ;    JC       B01:99BB                                           
+{0xA5D6,0x0C},  //     ;                                                                
+{0xA5D7,0x90},  //     ;    MOV      DPTR,#0x0BC8                                       
+{0xA5D8,0x0B},  //     ;                                                                
+{0xA5D9,0xC8},  //     ;                                                                
+{0xA5DA,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5DB,0x04},  //     ;    INC      A                                                  
+{0xA5DC,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA5DD,0xA3},  //     ;    INC      DPTR                                               
+{0xA5DE,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5DF,0x04},  //     ;    INC      A                                                  
+{0xA5E0,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA5E1,0x80},  //     ;    SJMP     B01:99E1                                           
+{0xA5E2,0x26},  //     ;                                                                
+{0xA5E3,0x90},  //     ;    MOV      DPTR,#patch_wLightGap(0x0DF6)                      
+{0xA5E4,0x0D},  //     ;                                                                
+{0xA5E5,0xF6},  //     ;                                                                
+{0xA5E6,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5E7,0xFE},  //     ;    MOV      R6,A                                               
+{0xA5E8,0xA3},  //     ;    INC      DPTR                                               
+{0xA5E9,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA5EA,0xFF},  //     ;    MOV      R7,A                                               
+{0xA5EB,0xC3},  //     ;    CLR      C                                                  
+{0xA5EC,0xE4},  //     ;    CLR      A                                                  
+{0xA5ED,0x9F},  //     ;    SUBB     A,R7                                               
+{0xA5EE,0xFF},  //     ;    MOV      R7,A                                               
+{0xA5EF,0xE4},  //     ;    CLR      A                                                  
+{0xA5F0,0x9E},  //     ;    SUBB     A,R6                                               
+{0xA5F1,0xFE},  //     ;    MOV      R6,A                                               
+{0xA5F2,0xC3},  //     ;    CLR      C                                                  
+{0xA5F3,0xED},  //     ;    MOV      A,R5                                               
+{0xA5F4,0x9F},  //     ;    SUBB     A,R7                                               
+{0xA5F5,0xEE},  //     ;    MOV      A,R6                                               
+{0xA5F6,0x64},  //     ;    XRL      A,#PipeSetupCommon(0x80)                           
+{0xA5F7,0x80},  //     ;                                                                
+{0xA5F8,0xF8},  //     ;    MOV      R0,A                                               
+{0xA5F9,0xEC},  //     ;    MOV      A,R4                                               
+{0xA5FA,0x64},  //     ;    XRL      A,#PipeSetupCommon(0x80)                           
+{0xA5FB,0x80},  //     ;                                                                
+{0xA5FC,0x98},  //     ;    SUBB     A,R0                                               
+{0xA5FD,0x50},  //     ;    JNC      B01:99E1                                           
+{0xA5FE,0x0A},  //     ;                                                                
+{0xA5FF,0x90},  //     ;    MOV      DPTR,#0x0BC8                                       
+{0xA600,0x0B},  //     ;                                                                
+{0xA601,0xC8},  //     ;                                                                
+{0xA602,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA603,0x14},  //     ;    DEC      A                                                  
+{0xA604,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA605,0xA3},  //     ;    INC      DPTR                                               
+{0xA606,0xE0},  //     ;    MOVX     A,@DPTR                                            
+{0xA607,0x04},  //     ;    INC      A                                                  
+{0xA608,0xF0},  //     ;    MOVX     @DPTR,A                                            
+{0xA609,0x05},  //     ;    INC      c_HeightScale(0x3B)                                
+{0xA60A,0x3B},  //     ;                                                                
+{0xA60B,0x02},  //     ;    LJMP     B01:98DA                                           
+{0xA60C,0xF5},  //     ;                                                                
+{0xA60D,0x02},  //     ;                                                                
+{0xA60E,0x90},  //     ;    MOV      DPTR,#AutoFocusInstableFocusMeasureStatus(0x0858)  
+{0xA60F,0x08},  //     ;                                                                
+{0xA610,0x58},  //     ;                                                                
+{0xA611,0x02},  //     ;    LJMP                                                        
+{0xA612,0x9D},  //     ;                                                                
+{0xA613,0x50},  //     ;                                                                
+{0x9006,0xBA},  //	; Patch break point address high byte;
+{0x9007,0x75},  //	; Patch break point address low byte;
+{0x9008,0x00},  //	; Offset High byte;
+{0x9009,0x00},  //	; Offset Low byte;
+{0x900A,0x02},  //	; Enable BP 0;
+{0x900D,0x01},  //	; Patch break point address bank;
+{0x900E,0xA2},  //	; Patch break point address high byte;
+{0x900F,0x8F},  //	; Patch break point address low byte;
+{0x9010,0x00},  //	; Offset High byte;
+{0x9011,0xCB},  //	; Offset Low byte;
+{0x9012,0x03},  //	; Enable BP 1;
+{0x9016,0xE6},  //	; Patch break point address high byte;
+{0x9017,0x6B},  //	; Patch break point address low byte;
+{0x9018,0x02},  //	; Offset High byte;
+{0x9019,0x6B},  //	; Offset Low byte;
+{0x901A,0x02},  //	; Enable BP 2;
+{0x901D,0x01},  //    ;	
+{0x901E,0xAC},  //	; Patch break point address high byte;
+{0x901F,0x70},  //	; Patch break point address low byte;
+{0x9020,0x00},  //	; Offset High byte;
+{0x9021,0xC5},  //	; Offset Low byte;
+{0x9022,0x03},  //	; Enable BP 3;
+{0x9026,0x9C},  //	; Patch break point address high byte;
+{0x9027,0x5B},  //	; Patch break point address low byte;
+{0x9028,0x00},  //	; Offset High byte;
+{0x9029,0xBF},  //	; Offset Low byte;
+{0x902A,0x02},  //	; Enable BP 4;
+{0x902E,0x60},  //	; Patch break point address high byte;
+{0x902F,0x1C},  //	; Patch break point address low byte;
+{0x9030,0x01},  //	; Offset High byte;
+{0x9031,0x37},  //	; Offset Low byte;
+{0x9032,0x02},  //	; Enable BP 3;
+{0x9035,0x01},  //	; Patch break point address bank;
+{0x9036,0xBA},  //	; Patch break point address high byte;
+{0x9037,0x70},  //	; Patch break point address low byte;
+{0x9038,0x00},  //	; Offset High byte;
+{0x9039,0x00},  //	; Offset Low byte;
+{0x903A,0x03},  //	; Enable BP 6;
+{0x903E,0x21},  //	; Patch break point address high byte;
+{0x903F,0x3F},  //	; Patch break point address low byte;
+{0x9040,0x02},  //	; Offset High byte;
+{0x9041,0x40},  //	; Offset Low byte;
+{0x9042,0x02},  //	; Enable BP 7;
+{0x9046,0x21},  //	; Patch break point address high byte;
+{0x9047,0xEA},  //	; Patch break point address low byte;
+{0x9048,0x02},  //	; Offset High byte;
+{0x9049,0x43},  //	; Offset Low byte;
+{0x904A,0x02},  //	; Enable BP 8;
+{0x904E,0xA6},  //	; Patch break point address high byte;
+{0x904F,0x12},  //	; Patch break point address low byte;
+{0x9050,0x02},  //	; Offset High byte;
+{0x9051,0x46},  //	; Offset Low byte;
+{0x9052,0x02},  //	; Enable BP 9;
+{0x9056,0x29},  //	; Patch break point address high byte;
+{0x9057,0xE3},  //	; Patch break point address low byte;
+{0x9058,0x02},  //	; Offset High byte;
+{0x9059,0x49},  //	; Offset Low byte;
+{0x905A,0x02},  //	; Enable BP 10;
+{0x905D,0x01},  //	; Patch break point address bank;
+{0x905E,0x9C},  //	; Patch break point address high byte;
+{0x905F,0x6E},  //	; Patch break point address low byte;
+{0x9060,0x05},  //	; Offset High byte;
+{0x9061,0x00},  //	; Offset Low byte;
+{0x9062,0x02},  //	; Enable BP 11;
+{0x9065,0x01},  //	; Patch break point address bank;
+{0x9066,0xA2},  //	; Patch break point address high byte;
+{0x9067,0x66},  //	; Patch break point address low byte;
+{0x9068,0x02},  //	; Offset High byte;
+{0x9069,0x35},  //	; Offset Low byte;
+{0x906A,0x02},  //	; Enable BP 12;
+{0x906D,0x01},  //	; Patch break point address bank;
+{0x906E,0xB5},  //	; Patch break point address high byte;
+{0x906F,0xC2},  //	; Patch break point address low byte;
+{0x9070,0x02},  //	; Offset High byte;
+{0x9071,0x9B},  //	; Offset Low byte;
+{0x9072,0x02},  //	; Enable BP 13;
+{0x9075,0x01},  //	; Patch break point address bank;
+{0x9076,0xA2},  //	; Patch break point address high byte;
+{0x9077,0xD4},  //	; Patch break point address low byte;
+{0x9078,0x02},  //	; Offset High byte;
+{0x9079,0xBE},  //	; Offset Low byte;
+{0x907A,0x02},  //	; Enable BP 14;
+{0x907D,0x01},  //	; Patch break point address bank;
+{0x907E,0xB7},  //	; Patch break point address high byte;
+{0x907F,0xEA},  //	; Patch break point address low byte;
+{0x9080,0x00},  //	; Offset High byte;
+{0x9081,0x02},  //	; Offset Low byte;
+{0x9082,0x03},  //	; Enable BP 15;
+{0x9086,0x67},  //	; Patch break point address high byte;
+{0x9087,0x31},  //	; Patch break point address low byte;
+{0x9088,0x02},  //	; Offset High byte;
+{0x9089,0xF7},  //	; Offset Low byte;
+{0x908A,0x02},  //	; Enable BP 16;
+{0x908E,0x66},  //	; Patch break point address high byte;
+{0x908F,0xED},  //	; Patch break point address low byte;
+{0x9090,0x03},  //	; Offset High byte;
+{0x9091,0x1D},  //	; Offset Low byte;
+{0x9092,0x02},  //	; Enable BP 17;
+{0x9096,0x67},  //	; Patch break point address high byte;
+{0x9097,0x73},  //	; Patch break point address low byte;
+{0x9098,0x03},  //	; Offset High byte;
+{0x9099,0xD3},  //	; Offset Low byte;
+{0x909A,0x02},  //	; Enable BP 18;
+{0x909E,0x20},  //	; Patch break point address high byte;
+{0x909F,0x40},  //	; Patch break point address low byte;
+{0x90A0,0x03},  //	; Offset High byte;
+{0x90A1,0x3B},  //	; Offset Low byte;
+{0x90A2,0x02},  //	; Enable BP 19;
+{0x90A6,0xC5},  //	; Patch break point address high byte;
+{0x90A7,0xC0},  //	; Patch break point address low byte;
+{0x90A8,0x03},  //	; Offset High byte;
+{0x90A9,0xF0},  //	; Offset Low byte;
+{0x90AA,0x02},  //	; Enable BP 20;
+{0x90AE,0x41},  //	; Patch break point address high byte;
+{0x90AF,0xB3},  //	; Patch break point address low byte;
+{0x90B0,0x00},  //	; Offset High byte;
+{0x90B1,0xA2},  //	; Offset Low byte;
+{0x90B2,0x02},  //	; Enable BP 21;
+{0x90B6,0x44},  //	; Patch break point address high byte;
+{0x90B7,0xBA},  //	; Patch break point address low byte;
+{0x90B8,0x00},  //	; Offset High byte;
+{0x90B9,0xF0},  //	; Offset Low byte;
+{0x90BA,0x03},  //	; Enable BP 22;
+{0x90BE,0x89},  //	; Patch break point address high byte;
+{0x90BF,0x99},  //	; Patch break point address low byte;
+{0x90C0,0x04},  //	; Offset High byte;
+{0x90C1,0x00},  //	; Offset Low byte;
+{0x90C2,0x02},  //	; Enable BP 23;
+{0x90C6,0xA7},  //	; Patch break point address high byte;
+{0x90C7,0x91},  //	; Patch break point address low byte;
+{0x90C8,0x04},  //	; Offset High byte;
+{0x90C9,0x21},  //	; Offset Low byte;
+{0x90CA,0x02},  //	; Enable BP 24;
+{0x90CE,0x3A},  //   ; Patch break point address high byte;
+{0x90CF,0x51},  //   ; Patch break point address low byte;
+{0x90D0,0x00},  //   ; Offset High byte;
+{0x90D1,0xA2},  //   ; Offset Low byte;
+{0x90D2,0x02},  //   ; Enable BP 25;
+{0x90D6,0x86},  //    ; Patch break point address high byte;
+{0x90D7,0x54},  //    ; Patch break point address low byte; 
+{0x90D8,0x04},  //    ; Offset High byte;                   
+{0x90D9,0x47},  //    ; Offset Low byte;                    
+{0x90DA,0x02},  //    ; Enable BP 26;                       
+{0x9000,0x01},  //	; Enable patch;
+{0xffff,0x00},  //	; MCU release;delay200ms
+{0x0010,0x00},//delay 200ms
+{0x0009,0x16},  //
+{0x0012,0x00},  //
+{0x0013,0x00},  //
+{0x0016,0x00},  //
+{0x0021,0x00},  //
+{0x0022,0x01},  //
+{0x0040,0x01},  // 	; AB2
+{0x0041,0x0a},  // 	; Image Size Manual
+{0x0042,0x05},  // 	; 1280
+{0x0043,0x00},  // 
+{0x0044,0x03},  // 	; 960
+{0x0045,0xC0},  // 
+{0x0046,0x02},  // 	; DataFormat_YCbCr_Custom
+{0x0060,0x00},  //
+{0x0061,0x00},  //
+{0x0066,0x02},  //
+{0x0083,0x00},  //        ; Horizontal Mirror Enable
+{0x0084,0x00},  //        ; Vertical Flip Enable
+{0x0085,0x03},  //	; YCbYCr Order
+{0x00B2,0x50},  //        ; set PLL output 713MHz
+{0x00B3,0x80},  //
+{0x00B4,0x01},  //        ; E_div
+{0x00B5,0x01},  //        ; PLL3_div
+{0x00E8,0x01},  //
+{0x00ED,0x10},  //	; Min Framerate
+{0x00EE,0x1E},  //	; Max Framerate
+{0x0129,0x00},  //
+{0x0130,0x00},  //
+{0x019C,0x4B},  //
+{0x019D,0xC0},  //
+{0x01A0,0x01},  //
+{0x01A1,0x80},  //
+{0x01A2,0x80},  //
+{0x01A3,0x80},  //
+{0x5200,0x01},  //
+{0x7000,0x0C},  //
+{0x7101,0xC4},  //
+{0x7102,0x09},  //
+{0x7103,0x00},  //
+{0x7104,0x00},  //	; OIF threshold = 128
+{0x7105,0x80},  //	;
+{0x7158,0x00},  //
+{0x0143,0x5F},  //
+{0x0144,0x0D},  //
+{0x02C2,0x00},  //
+{0x02C3,0xC0},  //
+{0x015E,0x40},  //
+{0x015F,0x00},  //
+{0x0390,0x01},  //	; ArcticControl fArcticEnable
+{0x0391,0x00},  //	; ArcticControl fArcticConfig DEFAULT CONFIG
+{0x0392,0x00},  //	; ArcticControl fGNFConfig    DEFAULT CONFIG
+{0x03A0,0x14},  //	; ArcticCCSigmaControl fMaximumCCSigma 
+{0x03A1,0x00},  //	; ArcticCCSigmaControl fDisablePromotion {CompiledExposureTime}
+{0x03A2,0x5A},  //	; ArcticCCSigmaControl fDamperLowThreshold {MSB}   //2400
+{0x03A3,0xEE},  //	; ArcticCCSigmaControl fDamperLowThreshold {LSB}   
+{0x03A4,0x69},  //	; ArcticCCSigmaControl fDamperHighThreshold {MSB}   //3444736
+{0x03A5,0x49},  //	; ArcticCCSigmaControl fDamperHighThreshold {LSB}
+{0x03A6,0x3E},  //	; ArcticCCSigmaControl fY1 {MSB}  // Low threshold
+{0x03A7,0x00},  //	; ArcticCCSigmaControl fY1 {LSB} 
+{0x03A8,0x39},  //	; ArcticCCSigmaControl fY2 {MSB}  // High threshold
+{0x03A9,0x33},  //	; ArcticCCSigmaControl fY2 {LSB} 
+{0x03B0,0x60},  //	; ArcticCCSigmaControl fMaximumRing 
+{0x03B1,0x00},  //	; ArcticCCSigmaControl fDisablePromotion {CompiledExposureTime}
+{0x03B2,0x5A},  //	; ArcticCCSigmaControl fDamperLowThreshold {MSB}    //24000
+{0x03B3,0xEE},  //	; ArcticCCSigmaControl fDamperLowThreshold {LSB}
+{0x03B4,0x69},  //	; ArcticCCSigmaControl DamperHighThreshold {MSB}    //3444736
+{0x03B5,0x49},  //	; ArcticCCSigmaControl DamperHighThreshold {LSB}
+{0x03B6,0x3E},  //	; ArcticCCSigmaControl fY1 {MSB}  //Low threshold
+{0x03B7,0x00},  //	; ArcticCCSigmaControl fY1 {LSB} 
+{0x03B8,0x3D},  //	; ArcticCCSigmaControl fY2 {MSB}  //High threshold
+{0x03B9,0x20},  //	; ArcticCCSigmaControl fY2 {LSB}  
+{0x03C0,0x10},  //	; ArcticCCSigmaControl fMaximumScoring 
+{0x03C1,0x00},  //	; ArcticCCSigmaControl fDisablePromotion {CompiledExposureTime}
+{0x03C2,0x5A},  //	; ArcticCCSigmaControl fDamperLowThreshold {MSB}    //24000
+{0x03C3,0xEE},  //	; ArcticCCSigmaControl fDamperLowThreshold {LSB}
+{0x03C4,0x69},  //	; ArcticCCSigmaControl DamperHighThreshold {MSB}    //3444736
+{0x03C5,0x49},  //	; ArcticCCSigmaControl DamperHighThreshold {LSB}
+{0x03C6,0x3A},  //	; ArcticCCSigmaControl fMinimumDamperOutput {MSB}
+{0x03C7,0x80},  //	; ArcticCCSigmaControl fMinimumDamperOutput {LSB} 
+{0x03D0,0x64},  //	; ArcticCCSigmaControl fMaximumScoring 
+{0x03D1,0x00},  //	; ArcticCCSigmaControl fDisablePromotion {CompiledExposureTime}
+{0x03D2,0x5A},  //	; ArcticCCSigmaControl fDamperLowThreshold {MSB}   //24000
+{0x03D3,0xEE},  //	; ArcticCCSigmaControl fDamperLowThreshold {LSB}
+{0x03D4,0x69},  //	; ArcticCCSigmaControl DamperHighThreshold {MSB}   //3444736
+{0x03D5,0x49},  //	; ArcticCCSigmaControl DamperHighThreshold {LSB}
+{0x03D6,0x34},  //	; ArcticCCSigmaControl fMinimumDamperOutput {MSB}
+{0x03D7,0xD1},  //	; ArcticCCSigmaControl fMinimumDamperOutput {LSB} 
+{0x004C,0x08},  //	; PipeSetupBank0 fPeakingGain
+{0x006C,0x08},  //	; PipeSetupBank1 fPeakingGain
+{0x0350,0x00},  //	; PeakingControl fDisableGainDamping  {CompiledExposureTime}
+{0x0351,0x5A},  //	; PeakingControl fDamperLowThreshold_Gain  {MSB}   //24000
+{0x0352,0xEE},  //	; PeakingControl fDamperLowThreshold_Gain  {LSB}
+{0x0353,0x69},  //	; PeakingControl fDamperHighThreshold_Gain  {MSB}  //3444736
+{0x0354,0x49},  //	; PeakingControl fDamperHighThreshold_Gain  {LSB}
+{0x0355,0x39},  //	; PeakingControl fMinimumDamperOutput_Gain  {MSB}
+{0x0356,0x6D},  //	; PeakingControl fMinimumDamperOutput_Gain  {LSB}
+{0x0357,0x19},  //	; PeakingControl fUserPeakLoThresh 
+{0x0358,0x00},  //	; PeakingControl fDisableCoringDamping  {CompiledExposureTime}
+{0x0359,0x3C},  //	; PeakingControl fUserPeakHiThresh
+{0x035A,0x5A},  //	; PeakingControl fDamperLowThreshold_Coring  {MSB}  //24000
+{0x035B,0xEE},  //	; PeakingControl fDamperLowThreshold_Coring  {LSB}
+{0x035C,0x69},  //	; PeakingControl fDamperHighThreshold_Coring {MSB}  //3444736
+{0x035D,0x49},  //	; PeakingControl fDamperHighThreshold_Coring  {LSB}
+{0x035E,0x39},  //	; PeakingControl fMinimumDamperOutput_Coring  {MSB}
+{0x035F,0x85},  //	; PeakingControl fMinimumDamperOutput_Coring  {LSB}
+{0x0049,0x14},  //	; PipeSetupBank0 bGammaGain 
+{0x004A,0x0D},  //	; PipeSetupBank0 bGammaInterpolationGain
+{0x0069,0x14},  //	; PipeSetupBank1 bGammaGain 
+{0x006A,0x0D},  //	; PipeSetupBank1 bGammaInterpolationGain
+{0x0090,0x5A},  //	; GammaGainDamperControl fpX1 {MSB}   //24000
+{0x0091,0xEE},  //	; GammaGainDamperControl fpX1 {LSB}
+{0x0092,0x3E},  //	; GammaGainDamperControl fpY1 {MSB}   //1
+{0x0093,0x00},  //	; GammaGainDamperControl fpY1 {LSB}
+{0x0094,0x69},  //	; GammaGainDamperControl fpX2 {MSB}   //3444736
+{0x0095,0x49},  //	; GammaGainDamperControl fpX2 {LSB}
+{0x0096,0x39},  //	; GammaGainDamperControl fpY2 {MSB}   //0.238
+{0x0097,0xCF},  //	; GammaGainDamperControl fpY2 {LSB}
+{0x0098,0x00},  //  ; GammaGainDamperControl fDisable {CompiledExposureTime}
+{0x00A0,0x5A},  //	; GammaInterpolationDamperControl fpX1 {MSB}   //24000 
+{0x00A1,0xEE},  //	; GammaInterpolationDamperControl fpX1 {LSB} 
+{0x00A2,0x3E},  //	; GammaInterpolationDamperControl fpY1 {MSB}   //1 
+{0x00A3,0x00},  //	; GammaInterpolationDamperControl fpY1 {LSB} 
+{0x00A4,0x69},  //	; GammaInterpolationDamperControl fpX2 {MSB}   //3444736 
+{0x00A5,0x49},  //	; GammaInterpolationDamperControl fpX2 {LSB} 
+{0x00A6,0x3B},  //	; GammaInterpolationDamperControl fpY2 {MSB}   //0.4375 
+{0x00A7,0x80},  //	; GammaInterpolationDamperControl fpY2 {LSB} 
+{0x00A8,0x00},  //	; GammaInterpolationDamperControl fDisable {CompiledExposureTime} 
+{0x0420,0x00},  //    ; C0_GreenRed_X 145
+{0x0421,0x91},  //    ; C0_GreenRed_X LSB
+{0x0422,0xff},  //    ; C0_GreenRed_Y -108
+{0x0423,0x94},  //    ; C0_GreenRed_Y LSB
+{0x0424,0x00},  //    ; C0_GreenRed_X2 125
+{0x0425,0x7d},  //    ; C0_GreenRed_X2 LSB
+{0x0426,0x00},  //    ; C0_GreenRed_Y2 170
+{0x0427,0xaa},  //    ; C0_GreenRed_Y2 LSB
+{0x0428,0x00},  //    ; C0_GreenRed_XY 57
+{0x0429,0x39},  //    ; C0_GreenRed_XY LSB
+{0x042a,0xff},  //    ; C0_GreenRed_X2Y -75
+{0x042b,0xb5},  //    ; C0_GreenRed_X2Y LSB
+{0x042c,0x01},  //    ; C0_GreenRed_XY2 444
+{0x042d,0xbc},  //    ; C0_GreenRed_XY2 LSB
+{0x042e,0xff},  //    ; C0_GreenRed_X2Y2 -45
+{0x042f,0xd3},  //    ; C0_GreenRed_X2Y2 LSB
+{0x0430,0x00},  //    ; C0_Red_X 175
+{0x0431,0xaf},  //    ; C0_Red_X LSB
+{0x0432,0xff},  //    ; C0_Red_Y -164
+{0x0433,0x5c},  //    ; C0_Red_Y LSB
+{0x0434,0x00},  //    ; C0_Red_X2 248
+{0x0435,0xf8},  //    ; C0_Red_X2 LSB
+{0x0436,0x01},  //    ; C0_Red_Y2 285
+{0x0437,0x1d},  //    ; C0_Red_Y2 LSB
+{0x0438,0xff},  //    ; C0_Red_XY -127
+{0x0439,0x81},  //    ; C0_Red_XY LSB
+{0x043a,0xff},  //    ; C0_Red_X2Y -143
+{0x043b,0x71},  //    ; C0_Red_X2Y LSB
+{0x043c,0x01},  //    ; C0_Red_XY2 375
+{0x043d,0x77},  //    ; C0_Red_XY2 LSB
+{0x043e,0xff},  //    ; C0_Red_X2Y2 -174
+{0x043f,0x52},  //    ; C0_Red_X2Y2 LSB
+{0x0450,0x00},  //    ; C0_Blue_X 117
+{0x0451,0x75},  //    ; C0_Blue_X LSB
+{0x0452,0xff},  //    ; C0_Blue_Y -114
+{0x0453,0x8e},  //    ; C0_Blue_Y LSB
+{0x0454,0x00},  //    ; C0_Blue_X2 106
+{0x0455,0x6a},  //    ; C0_Blue_X2 LSB
+{0x0456,0x00},  //    ; C0_Blue_Y2 138
+{0x0457,0x8a},  //    ; C0_Blue_Y2 LSB
+{0x0458,0xff},  //    ; C0_Blue_XY -90
+{0x0459,0xa6},  //    ; C0_Blue_XY LSB
+{0x045a,0xff},  //    ; C0_Blue_X2Y -86
+{0x045b,0xaa},  //    ; C0_Blue_X2Y LSB
+{0x045c,0x00},  //    ; C0_Blue_XY2 224
+{0x045d,0xe0},  //    ; C0_Blue_XY2 LSB
+{0x045e,0xff},  //    ; C0_Blue_X2Y2 -48
+{0x045f,0xd0},  //    ; C0_Blue_X2Y2 LSB
+{0x0440,0x00},  //    ; C0_GreenBlue_X 91
+{0x0441,0x5b},  //    ; C0_GreenBlue_X LSB
+{0x0442,0xff},  //    ; C0_GreenBlue_Y -123
+{0x0443,0x85},  //    ; C0_GreenBlue_Y LSB
+{0x0444,0x00},  //    ; C0_GreenBlue_X2 145
+{0x0445,0x91},  //    ; C0_GreenBlue_X2 LSB
+{0x0446,0x00},  //    ; C0_GreenBlue_Y2 151
+{0x0447,0x97},  //    ; C0_GreenBlue_Y2 LSB
+{0x0448,0x00},  //    ; C0_GreenBlue_XY 44
+{0x0449,0x2c},  //    ; C0_GreenBlue_XY LSB
+{0x044a,0xff},  //    ; C0_GreenBlue_X2Y -207
+{0x044b,0x31},  //    ; C0_GreenBlue_X2Y LSB
+{0x044c,0x01},  //    ; C0_GreenBlue_XY2 349
+{0x044d,0x5d},  //    ; C0_GreenBlue_XY2 LSB
+{0x044e,0xff},  //    ; C0_GreenBlue_X2Y2 -42
+{0x044f,0xd6},  //    ; C0_GreenBlue_X2Y2 LSB
+{0x0460,0x00},  //    ; C1_GreenRed_X 148
+{0x0461,0x94},  //    ; C1_GreenRed_X LSB
+{0x0462,0xff},  //    ; C1_GreenRed_Y -106
+{0x0463,0x96},  //    ; C1_GreenRed_Y LSB
+{0x0464,0x00},  //    ; C1_GreenRed_X2 124
+{0x0465,0x7c},  //    ; C1_GreenRed_X2 LSB
+{0x0466,0x00},  //    ; C1_GreenRed_Y2 165
+{0x0467,0xa5},  //    ; C1_GreenRed_Y2 LSB
+{0x0468,0x00},  //    ; C1_GreenRed_XY 66
+{0x0469,0x42},  //    ; C1_GreenRed_XY LSB
+{0x046a,0xff},  //    ; C1_GreenRed_X2Y -80
+{0x046b,0xb0},  //    ; C1_GreenRed_X2Y LSB
+{0x046c,0x01},  //    ; C1_GreenRed_XY2 450
+{0x046d,0xc2},  //    ; C1_GreenRed_XY2 LSB
+{0x046e,0xff},  //    ; C1_GreenRed_X2Y2 -35
+{0x046f,0xdd},  //    ; C1_GreenRed_X2Y2 LSB
+{0x0470,0x00},  //    ; C1_Red_X 170
+{0x0471,0xaa},  //    ; C1_Red_X LSB
+{0x0472,0xff},  //    ; C1_Red_Y -155
+{0x0473,0x65},  //    ; C1_Red_Y LSB
+{0x0474,0x00},  //    ; C1_Red_X2 234
+{0x0475,0xea},  //    ; C1_Red_X2 LSB
+{0x0476,0x01},  //    ; C1_Red_Y2 270
+{0x0477,0x0e},  //    ; C1_Red_Y2 LSB
+{0x0478,0xff},  //    ; C1_Red_XY -121
+{0x0479,0x87},  //    ; C1_Red_XY LSB
+{0x047a,0xff},  //    ; C1_Red_X2Y -145
+{0x047b,0x6f},  //    ; C1_Red_X2Y LSB
+{0x047c,0x01},  //    ; C1_Red_XY2 360
+{0x047d,0x68},  //    ; C1_Red_XY2 LSB
+{0x047e,0xff},  //    ; C1_Red_X2Y2 -152
+{0x047f,0x68},  //    ; C1_Red_X2Y2 LSB
+{0x0490,0x00},  //    ; C1_Blue_X 125
+{0x0491,0x7d},  //    ; C1_Blue_X LSB
+{0x0492,0xff},  //    ; C1_Blue_Y -110
+{0x0493,0x92},  //    ; C1_Blue_Y LSB
+{0x0494,0x00},  //    ; C1_Blue_X2 103
+{0x0495,0x67},  //    ; C1_Blue_X2 LSB
+{0x0496,0x00},  //    ; C1_Blue_Y2 132
+{0x0497,0x84},  //    ; C1_Blue_Y2 LSB
+{0x0498,0xff},  //    ; C1_Blue_XY -93
+{0x0499,0xa3},  //    ; C1_Blue_XY LSB
+{0x049a,0xff},  //    ; C1_Blue_X2Y -104
+{0x049b,0x98},  //    ; C1_Blue_X2Y LSB
+{0x049c,0x01},  //    ; C1_Blue_XY2 256
+{0x049d,0x00},  //    ; C1_Blue_XY2 LSB
+{0x049e,0xff},  //    ; C1_Blue_X2Y2 -32
+{0x049f,0xe0},  //    ; C1_Blue_X2Y2 LSB
+{0x0480,0x00},  //    ; C1_GreenBlue_X 90
+{0x0481,0x5a},  //    ; C1_GreenBlue_X LSB
+{0x0482,0xff},  //    ; C1_GreenBlue_Y -116
+{0x0483,0x8c},  //    ; C1_GreenBlue_Y LSB
+{0x0484,0x00},  //    ; C1_GreenBlue_X2 141
+{0x0485,0x8d},  //    ; C1_GreenBlue_X2 LSB
+{0x0486,0x00},  //    ; C1_GreenBlue_Y2 148
+{0x0487,0x94},  //    ; C1_GreenBlue_Y2 LSB
+{0x0488,0x00},  //    ; C1_GreenBlue_XY 55
+{0x0489,0x37},  //    ; C1_GreenBlue_XY LSB
+{0x048a,0xff},  //    ; C1_GreenBlue_X2Y -226
+{0x048b,0x1e},  //    ; C1_GreenBlue_X2Y LSB
+{0x048c,0x01},  //    ; C1_GreenBlue_XY2 349
+{0x048d,0x5d},  //    ; C1_GreenBlue_XY2 LSB
+{0x048e,0xff},  //    ; C1_GreenBlue_X2Y2 -33
+{0x048f,0xdf},  //    ; C1_GreenBlue_X2Y2 LSB
+{0x04a0,0x00},  //    ; C2_GreenRed_X 150
+{0x04a1,0x96},  //    ; C2_GreenRed_X LSB
+{0x04a2,0xff},  //    ; C2_GreenRed_Y -97
+{0x04a3,0x9f},  //    ; C2_GreenRed_Y LSB
+{0x04a4,0x00},  //    ; C2_GreenRed_X2 117
+{0x04a5,0x75},  //    ; C2_GreenRed_X2 LSB
+{0x04a6,0x00},  //    ; C2_GreenRed_Y2 150
+{0x04a7,0x96},  //    ; C2_GreenRed_Y2 LSB
+{0x04a8,0x00},  //    ; C2_GreenRed_XY 62
+{0x04a9,0x3e},  //    ; C2_GreenRed_XY LSB
+{0x04aa,0xff},  //    ; C2_GreenRed_X2Y -118
+{0x04ab,0x8a},  //    ; C2_GreenRed_X2Y LSB
+{0x04ac,0x01},  //    ; C2_GreenRed_XY2 456
+{0x04ad,0xc8},  //    ; C2_GreenRed_XY2 LSB
+{0x04ae,0xff},  //    ; C2_GreenRed_X2Y2 -12
+{0x04af,0xf4},  //    ; C2_GreenRed_X2Y2 LSB
+{0x04b0,0x00},  //    ; C2_Red_X 136
+{0x04b1,0x88},  //    ; C2_Red_X LSB
+{0x04b2,0xff},  //    ; C2_Red_Y -118
+{0x04b3,0x8a},  //    ; C2_Red_Y LSB
+{0x04b4,0x00},  //    ; C2_Red_X2 166
+{0x04b5,0xa6},  //    ; C2_Red_X2 LSB
+{0x04b6,0x00},  //    ; C2_Red_Y2 194
+{0x04b7,0xc2},  //    ; C2_Red_Y2 LSB
+{0x04b8,0xff},  //    ; C2_Red_XY -96
+{0x04b9,0xa0},  //    ; C2_Red_XY LSB
+{0x04ba,0xff},  //    ; C2_Red_X2Y -229
+{0x04bb,0x1b},  //    ; C2_Red_X2Y LSB
+{0x04bc,0x01},  //    ; C2_Red_XY2 339
+{0x04bd,0x53},  //    ; C2_Red_XY2 LSB
+{0x04be,0xff},  //    ; C2_Red_X2Y2 -50
+{0x04bf,0xce},  //    ; C2_Red_X2Y2 LSB
+{0x04d0,0x00},  //    ; C2_Blue_X 137
+{0x04d1,0x89},  //    ; C2_Blue_X LSB
+{0x04d2,0xff},  //    ; C2_Blue_Y -101
+{0x04d3,0x9b},  //    ; C2_Blue_Y LSB
+{0x04d4,0x00},  //    ; C2_Blue_X2 94
+{0x04d5,0x5e},  //    ; C2_Blue_X2 LSB
+{0x04d6,0x00},  //    ; C2_Blue_Y2 120
+{0x04d7,0x78},  //    ; C2_Blue_Y2 LSB
+{0x04d8,0xff},  //    ; C2_Blue_XY -107
+{0x04d9,0x95},  //    ; C2_Blue_XY LSB
+{0x04da,0xff},  //    ; C2_Blue_X2Y -135
+{0x04db,0x79},  //    ; C2_Blue_X2Y LSB
+{0x04dc,0x01},  //    ; C2_Blue_XY2 274
+{0x04dd,0x12},  //    ; C2_Blue_XY2 LSB
+{0x04de,0xff},  //    ; C2_Blue_X2Y2 -4
+{0x04df,0xfc},  //    ; C2_Blue_X2Y2 LSB
+{0x04c0,0x00},  //    ; C2_GreenBlue_X 91
+{0x04c1,0x5b},  //    ; C2_GreenBlue_X LSB
+{0x04c2,0xff},  //    ; C2_GreenBlue_Y -100
+{0x04c3,0x9c},  //    ; C2_GreenBlue_Y LSB
+{0x04c4,0x00},  //    ; C2_GreenBlue_X2 130
+{0x04c5,0x82},  //    ; C2_GreenBlue_X2 LSB
+{0x04c6,0x00},  //    ; C2_GreenBlue_Y2 139
+{0x04c7,0x8b},  //    ; C2_GreenBlue_Y2 LSB
+{0x04c8,0x00},  //    ; C2_GreenBlue_XY 54
+{0x04c9,0x36},  //    ; C2_GreenBlue_XY LSB
+{0x04ca,0xfe},  //    ; C2_GreenBlue_X2Y -260
+{0x04cb,0xfc},  //    ; C2_GreenBlue_X2Y LSB
+{0x04cc,0x01},  //    ; C2_GreenBlue_XY2 380
+{0x04cd,0x7c},  //    ; C2_GreenBlue_XY2 LSB
+{0x04ce,0xff},  //    ; C2_GreenBlue_X2Y2 -10
+{0x04cf,0xf6},  //    ; C2_GreenBlue_X2Y2 LSB
+{0x04e0,0x00},  //    ; C3_GreenRed_X 149
+{0x04e1,0xea},  //    ; C3_GreenRed_X LSB
+{0x04e2,0xff},  //    ; C3_GreenRed_Y -90
+{0x04e3,0xa6},  //    ; C3_GreenRed_Y LSB
+{0x04e4,0x00},  //    ; C3_GreenRed_X2 118
+{0x04e5,0x76},  //    ; C3_GreenRed_X2 LSB
+{0x04e6,0x00},  //    ; C3_GreenRed_Y2 148
+{0x04e7,0x94},  //    ; C3_GreenRed_Y2 LSB
+{0x04e8,0xff},  //    ; C3_GreenRed_XY 76
+{0x04e9,0x8b},  //    ; C3_GreenRed_XY LSB
+{0x04ea,0xff},  //    ; C3_GreenRed_X2Y -64
+{0x04eb,0xc0},  //    ; C3_GreenRed_X2Y LSB
+{0x04ec,0x01},  //    ; C3_GreenRed_XY2 449
+{0x04ed,0xc1},  //    ; C3_GreenRed_XY2 LSB
+{0x04ee,0xff},  //    ; C3_GreenRed_X2Y2 -24
+{0x04ef,0xe8},  //    ; C3_GreenRed_X2Y2 LSB
+{0x04f0,0x00},  //    ; C3_Red_X 146
+{0x04f1,0xfb},  //    ; C3_Red_X LSB
+{0x04f2,0xff},  //    ; C3_Red_Y -119
+{0x04f3,0x89},  //    ; C3_Red_Y LSB
+{0x04f4,0x00},  //    ; C3_Red_X2 179
+{0x04f5,0xd0},  //    ; C3_Red_X2 LSB
+{0x04f6,0x00},  //    ; C3_Red_Y2 215
+{0x04f7,0xd0},  //    ; C3_Red_Y2 LSB
+{0x04f8,0x01},  //    ; C3_Red_XY -84
+{0x04f9,0x3e},  //    ; C3_Red_XY LSB
+{0x04fa,0xff},  //    ; C3_Red_X2Y -122
+{0x04fb,0x86},  //    ; C3_Red_X2Y LSB
+{0x04fc,0x01},  //    ; C3_Red_XY2 287
+{0x04fd,0x1f},  //    ; C3_Red_XY2 LSB
+{0x04fe,0xff},  //    ; C3_Red_X2Y2 -102
+{0x04ff,0x20},  //    ; C3_Red_X2Y2 LSB
+{0x0510,0x00},  //    ; C3_Blue_X 144
+{0x0511,0xff},  //    ; C3_Blue_X LSB
+{0x0512,0xff},  //    ; C3_Blue_Y -94
+{0x0513,0xa2},  //    ; C3_Blue_Y LSB
+{0x0514,0x00},  //    ; C3_Blue_X2 96
+{0x0515,0x60},  //    ; C3_Blue_X2 LSB
+{0x0516,0x00},  //    ; C3_Blue_Y2 123
+{0x0517,0x7b},  //    ; C3_Blue_Y2 LSB
+{0x0518,0xff},  //    ; C3_Blue_XY -118
+{0x0519,0x8a},  //    ; C3_Blue_XY LSB
+{0x051a,0xff},  //    ; C3_Blue_X2Y -126
+{0x051b,0x82},  //    ; C3_Blue_X2Y LSB
+{0x051c,0xff},  //    ; C3_Blue_XY2 272
+{0x051d,0x8a},  //    ; C3_Blue_XY2 LSB
+{0x051e,0x00},  //    ; C3_Blue_X2Y2 -19
+{0x051f,0x10},  //    ; C3_Blue_X2Y2 LSB
+{0x0500,0x00},  //    ; C3_GreenBlue_X 84
+{0x0501,0xea},  //    ; C3_GreenBlue_X LSB
+{0x0502,0xff},  //    ; C3_GreenBlue_Y -99
+{0x0503,0x9d},  //    ; C3_GreenBlue_Y LSB
+{0x0504,0x00},  //    ; C3_GreenBlue_X2 125
+{0x0505,0x7d},  //    ; C3_GreenBlue_X2 LSB
+{0x0506,0x00},  //    ; C3_GreenBlue_Y2 142
+{0x0507,0x8e},  //    ; C3_GreenBlue_Y2 LSB
+{0x0508,0xff},  //    ; C3_GreenBlue_XY 75
+{0x0509,0x8b},  //    ; C3_GreenBlue_XY LSB
+{0x050a,0xff},  //    ; C3_GreenBlue_X2Y -200
+{0x050b,0x38},  //    ; C3_GreenBlue_X2Y LSB
+{0x050c,0x01},  //    ; C3_GreenBlue_XY2 348
+{0x050d,0x5c},  //    ; C3_GreenBlue_XY2 LSB
+{0x050e,0xff},  //    ; C3_GreenBlue_X2Y2 -21
+{0x050f,0xeb},  //    ; C3_GreenBlue_X2Y2 LSB
+{0x0561,0x0d},  //    ;C0 Unity
+{0x0562,0x0a},  //    ;C1 Unity
+{0x0563,0x06},  //    ;C2 Unity
+{0x0564,0x01},  //    ;C3 Unity
+{0x0324,0x39},  //    ; NormRedGain_Cast0 Hor
+{0x0325,0xAE},  //    ; NormRedGain_Cast0_LSB 
+{0x0326,0x3A},  //    ; NormRedGain_Cast1 IncA
+{0x0327,0x29},  //    ; NormRedGain_Cast1_LSB 
+{0x0328,0x3B},  //    ; NormRedGain_Cast2 CWF
+{0x0329,0x0A},  //    ; NormRedGain_Cast2_LSB 
+{0x032A,0x3B},  //    ; NormRedGain_Cast3 D65
+{0x032B,0x62},  //    ; NormRedGain_Cast3_LSB 
+{0x0320,0x01},  //    ; AntiVignetteControl - Enable
+{0x0321,0x04},  //    ; NbOfPresets
+{0x0322,0x01},  //    ; AdaptiveAntiVignetteControlEnable - Enable
+{0x0323,0x01},  //    ; LoLightAntiVignetteControlDisable - Damper Off
+{0x0330,0x01},  //	; Turn off colour matrix damper
+{0x0384,0x00},  //	; Turn off colour effects
+{0x0337,0x01},  //	; Turn on adaptive colour matrix
+{0x03EC,0x39},  //	; Matrix 0
+{0x03ED,0x85},  //	; LSB
+{0x03FC,0x3A},  //	; Matrix 1
+{0x03FD,0x14},  //	; LSB
+{0x040C,0x3A},  //	; Matrix 2
+{0x040D,0xF6},  //	; LSB
+{0x041C,0x3B},  //	; Matrix 3
+{0x041D,0x9A},  //	; LSB
+{0x03E0,0xB6},  //	; GInR
+{0x03E1,0x04},  //	;
+{0x03E2,0xBB},  //	; BInR
+{0x03E3,0xE9},  //	;
+{0x03E4,0xBC},  //	; RInG
+{0x03E5,0x70},  //	;
+{0x03E6,0x37},  //	; BInG
+{0x03E7,0x02},  //	;
+{0x03E8,0xBC},  //	; RInB
+{0x03E9,0x00},  //	;
+{0x03EA,0xBF},  //	; GInB
+{0x03EB,0x12},  //	;
+{0x03F0,0xBA},  //	; GInR
+{0x03F1,0x7B},  //	;
+{0x03F2,0xBA},  //	; BInR
+{0x03F3,0x83},  //	;
+{0x03F4,0xBB},  //	; RInG
+{0x03F5,0xBC},  //	;
+{0x03F6,0x38},  //	; BInG
+{0x03F7,0x2D},  //	;
+{0x03F8,0xBB},  //	; RInB
+{0x03F9,0x23},  //	;
+{0x03FA,0xBD},  //	; GInB
+{0x03FB,0xAC},  //	;
+{0x0400,0xBE},  //	; GInR
+{0x0401,0x96},  //	;
+{0x0402,0xB9},  //	; BInR
+{0x0403,0xBE},  //	;
+{0x0404,0xBB},  //	; RInG
+{0x0405,0x57},  //	;
+{0x0406,0x3A},  //	; BInG
+{0x0407,0xBB},  //	;
+{0x0408,0xB3},  //	; RInB
+{0x0409,0x17},  //	;
+{0x040A,0xBE},  //	; GInB
+{0x040B,0x66},  //	;
+{0x0410,0xBB},  //	; GInR
+{0x0411,0x2A},  //	;
+{0x0412,0xBA},  //	; BInR
+{0x0413,0x00},  //	;
+{0x0414,0xBB},  //	; RInG
+{0x0415,0x10},  //	;
+{0x0416,0xB8},  //	; BInG
+{0x0417,0xCD},  //	;
+{0x0418,0xB7},  //	; RInB
+{0x0419,0x5C},  //	;
+{0x041A,0xBB},  //	; GInB
+{0x041B,0x6C},  //	;
+{0x01f8,0x3c},  //    ;fpMaximumDistanceAllowedFromLocus
+{0x01f9,0x00},  //    ;=0.5
+{0x01fa,0x00},  //    ;fEnableConstrainedWhiteBalance = false
+{0x02a2,0x3e},  //    ;fpRedTilt
+{0x02a3,0x00},  //    ;= 1.00
+{0x02a4,0x3e},  //    ;fpGreenTilt1
+{0x02a5,0x00},  //    ;= 1.00
+{0x02a6,0x3e},  //    ;fpGreenTilt2
+{0x02a7,0x00},  //    ;= 1.00
+{0x02a8,0x3e},  //    ;fpBlueTilt
+{0x02a9,0x00},  //    ;= 1.00
+{0x056c,0x42},  //    ;fpRedTilt
+{0x056d,0x00},  //    ;= 4.00
+{0x056e,0x42},  //    ;fpGreenTilt1
+{0x056f,0x00},  //    ;= 4.00
+{0x0570,0x42},  //    ;fpGreenTilt2
+{0x0571,0x00},  //    ;= 4.00
+{0x0572,0x42},  //    ;fpBlueTilt
+{0x0573,0x00},  //    ;= 4.00
+{0x0081,0x58},  //	; PipeSetupCommon bColourSaturation
+{0x0588,0x00},  //	; ColourSaturationDamper fDisable {CompiledExposureTime}
+{0x0589,0x5A},  //	; ColourSaturationDamper fpLowThreshold {MSB}
+{0x058A,0xEE},  //	; ColourSaturationDamper fpLowThreshold {LSB}
+{0x058B,0x69},  //	; ColourSaturationDamper fpHighThreshold {MSB}
+{0x058C,0x49},  //	; ColourSaturationDamper fpHighThreshold {LSB}
+{0x058D,0x3D},  //	; ColourSaturationDamper fpMinimumOutput {MSB}
+{0x058E,0x3D},  //	; ColourSaturationDamper fpMinimumOutput {LSB}
+{0x0080,0x6C},  //	; PipeSetupCommon bContrast
+{0x0082,0x5A},  //	; PipeSetupCommon bBrightness
+{0x065A,0x00},  //    ; AFStatsControls->bWindowsSystem = 7 zone AF system 
+{0x06C9,0x01},  //    ; FLADriverLowLevelParameters->AutoSkipNextFrame = ENABLED
+{0x06CD,0x01},  //    ; FLADriverLowLevelParameters->AF_OTP_uwHostDefMacro MSB = 445
+{0x06CE,0xBD},  //    ; FLADriverLowLevelParameters->AF_OTP_uwHostDefMacro LSB
+{0x06CF,0x00},  //    ; FLADriverLowLevelParameters->AF_OTP_uwHostDefInfinity MSB = 147
+{0x06D0,0x93},  //    ; FLADriverLowLevelParameters->AF_OTP_uwHostDefInfinity LSB
+{0x06D1,0x02},  //    ; FLADriverLowLevelParameters->AF_OTP_bStepsMultiStepDriver = 2 step driver
+{0x06D2,0x30},  //    ; FLADriverLowLevelParameters->AF_OTP_uwMultiStepTimeDelay MSB = 12.5ms
+{0x06D3,0xD4},  //    ; FLADriverLowLevelParameters->AF_OTP_uwMultiStepTimeDelay LSB
+{0x06D4,0x01},  //    ; FLADriverLowLevelParameters->AF_OTP_fHostEnableOTPRead (1 = disabled)
+{0x06DB,0x59},  //    ; FLADriverLowLevelParameters->fpActuatorResponseTime MSB 12.5ms (FP900) 
+{0x06DC,0x0d},  //    ; FLADriverLowLevelParameters->fpActuatorResponseTime LSB
+{0x0730,0x00},  //    ; FocusRangeConstants->wFullRange_LensMinPosition MSB = 0
+{0x0731,0x00},  //    ; FocusRangeConstants->wFullRange_LensMinPosition LSB
+{0x0732,0x03},  //    ; FocusRangeConstants->wFullRange_LensMaxPosition MSB = 1023
+{0x0733,0xFF},  //    ; FocusRangeConstants->wFullRange_LensMaxPosition LSB
+{0x0734,0x03},  //    ; FocusRangeConstants->wFullRange_LensRecoveryPosition MSB = 880
+{0x0735,0x70},  //    ; FocusRangeConstants->wFullRange_LensRecoveryPosition LSB
+{0x0755,0x01},  //    ; AutoFocusControls->fEnableSimpleCoarseThEvaluation = ENABLED
+{0x0756,0x03},  //    ; AutoFocusControls->bSelectedMultizoneBehavior = REGIONSELECTIONMETHOD_AVERAGE //mk change to 0x3
+{0x075B,0x01},  //    ; AutoFocusControls->fEnableTrackingThresholdEvaluation = DISABLED //MK change to 0x1
+{0x075E,0x00},  //    ; AutoFocusControls->fFineToCoarseAutoTransitionEnable = DISABLED
+{0x0764,0x01},  //    ; AutoFocusControls->fResetHCSPos = TRUE = Start from Recovery Position for every HCS
+{0x0766,0x01},  //    ; AutoFocusControls->fEnablePrioritiesMacro = FALSE = Do not prioritise Macro //mk change to 0x01
+{0x0768,0x01},  //    ; AutoFocusControls->fEnableInterpolationAfterFineSearch = TRUE
+{0x076A,0x00},  //    ; AutoFocusControls->fReducedZoneSetup = TRUE //mk change to 0x0
+{0x0758,0x01},  //    ; AutoFocusControls->bWeighedFunctionSelected = TRAPEZIUM
+{0x075C,0x01},  //    ; AutoFocusControls->fEnableHeuristicMethod = FALSE
+{0x0770,0x98},  //    ; AutoFocusConstants->bCoarseStep = 95
+{0x0771,0x19},  //    ; AutoFocusConstants->bFineStep = 16
+{0x0772,0x1B},  //    ; AutoFocusConstants->bFullSearchStep = 27
+{0x0774,0x01},  //    ; AutoFocusConstants->uwFineThreshold MSB = 330 
+{0x0775,0x4a},  //    ; AutoFocusConstants->uwFineThreshold LSB 
+{0x0777,0x00},  //    ; AutoFocusConstants->uwBacklightThreshold MSB = 69
+{0x0778,0x45},  //    ; AutoFocusConstants->uwBacklightThreshold LSB 
+{0x0779,0x00},  //    ; AutoFocusConstants->uwMotionBlurInRatio MSB = 2
+{0x077A,0x02},  //    ; AutoFocusConstants->uwMotionBlurInRatio LSB
+{0x077D,0x01},  //    ; AutoFocusConstants->bMaxNumberContinuouslyInstableTime = 1
+{0x077E,0x03},  //    ; AutoFocusConstants->bMaxNumberContinuouslyStableFrame = 3
+{0x0783,0x10},  //    ; AutoFocusConstants->bLightGap = 10 
+{0x0785,0x14},  //    ; AutoFocusConstants->uwDeltaValue = 20
+{0x0788,0x04},  //    ; AutoFocusConstants->bMinNumberMacroRegion = 4 //mk add
+{0x0846,0x06},  //    ; AutoFocusHeuristicConstants->bHighToMaxFMShiftFactor = 6
+{0x0847,0x05},  //    ; AutoFocusHeuristicConstants->bLowToHighFMShiftFactor = 5
+{0xC41A,0x05},  //    ; TEST_LP_TX (clock slew rate)
+{0xC423,0x11},  //    ; TEST_LP_TX_SLEW_RATE_DL1
+{0xC427,0x11},  //    ; TEST_LP_TX_SLEW_RATE_DL2
+{0x300B,0x09},  //    ; esc_clk_div (clk_sys div by 10)
+{0x00B2,0x50},//4f
+{0x00B3,0x80},//c0
+{0x00B5,0x02},
+{0x0030,0x14},
+{0x0040,0x01},
+{0x0041,0x04},
+{0x0046,0x00},
+{0x00EE,0x1E},
+{0x0010,0x01},  //    ; CMD_RUN
+{0x0714,0x00},
+{0x4708,0x00},  //	; av2x2_h_offset
+{0x4709,0x00},  //	; LSB
+{0x4710,0x00},  //	; av2x2_v_offset {0x4710 & 11} are correct!
+{0x4711,0x00},  //	; LSB
+{0xffff,0xff},
+};
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/camera/sp1628.c b/drivers/amlogic/camera/sp1628.c
new file mode 100755
index 000000000000..2f519c20c509
--- /dev/null
+++ b/drivers/amlogic/camera/sp1628.c
@@ -0,0 +1,2883 @@
+/*
+ *sp1628 - This code emulates a real video device with v4l2 api
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence, GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ */
+#include <linux/sizes.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/highmem.h>
+#include <linux/freezer.h>
+#include <media/videobuf-vmalloc.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <linux/wakelock.h>
+
+#include <linux/i2c.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/amlogic/camera/aml_cam_info.h>
+#include <linux/amlogic/vmapi.h>
+
+#include <mach/am_regs.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+//#include <mach/gpio_data.h>
+#include "common/plat_ctrl.h"
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#include <mach/mod_gate.h>
+#endif
+
+#define SP1628_CAMERA_MODULE_NAME "sp1628"
+#define P1_Ae_Target_0xeb         0x78
+#define P1_Ae_Target_0xec         0x78
+typedef enum{
+	DCAMERA_FLICKER_50HZ = 0,
+	DCAMERA_FLICKER_60HZ,
+	FLICKER_MAX
+}DCAMERA_FLICKER;
+static unsigned short Antiflicker = DCAMERA_FLICKER_50HZ;
+
+/* Wake up at about 30 fps */
+#define WAKE_NUMERATOR 30
+#define WAKE_DENOMINATOR 1001
+#define BUFFER_TIMEOUT     msecs_to_jiffies(500)  /* 0.5 seconds */
+
+#define SP1628_CAMERA_MAJOR_VERSION 0
+#define SP1628_CAMERA_MINOR_VERSION 7
+#define SP1628_CAMERA_RELEASE 0
+#define SP1628_CAMERA_VERSION \
+	KERNEL_VERSION(SP1628_CAMERA_MAJOR_VERSION, SP1628_CAMERA_MINOR_VERSION, SP1628_CAMERA_RELEASE)
+
+MODULE_DESCRIPTION("sp1628 On Board");
+MODULE_AUTHOR("amlogic-sh");
+MODULE_LICENSE("GPL v2");
+
+static unsigned video_nr = -1;  /* videoX start number, -1 is autodetect. */
+
+static unsigned debug;
+//module_param(debug, uint, 0644);
+//MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 16;
+//module_param(vid_limit, uint, 0644);
+//MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+static int sp1628_night_or_normal = 0;	//add by sp_yjp,20120905
+static int sp1628_h_active=640;
+static int sp1628_v_active=480;
+static struct v4l2_fract sp1628_frmintervals_active = {
+    .numerator = 1,
+    .denominator = 15,
+};
+
+static struct vdin_v4l2_ops_s *vops;
+
+/* supported controls */
+static struct v4l2_queryctrl sp1628_qctrl[] = {
+	{
+		.id            = V4L2_CID_DO_WHITE_BALANCE,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "white balance",
+		.minimum       = CAM_WB_AUTO,
+		.maximum       = CAM_WB_WARM_FLUORESCENT,
+		.step          = 0x1,
+		.default_value = CAM_WB_AUTO,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_EXPOSURE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "exposure",
+		.minimum       = 0,
+		.maximum       = 8,
+		.step          = 0x1,
+		.default_value = 4,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_COLORFX,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "effect",
+		.minimum       = 0,
+		.maximum       = 6,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_POWER_LINE_FREQUENCY,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "banding",
+		.minimum       = CAM_BANDING_50HZ,
+		.maximum       = CAM_BANDING_60HZ,
+		.step          = 0x1,
+		.default_value = CAM_BANDING_50HZ,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_BLUE_BALANCE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "scene mode",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_HFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on horizontal",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_VFLIP,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "flip on vertical",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id            = V4L2_CID_ZOOM_ABSOLUTE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Zoom, Absolute",
+		.minimum       = 100,
+		.maximum       = 300,
+		.step          = 20,
+		.default_value = 100,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	},{
+		.id		= V4L2_CID_ROTATE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotate",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}
+};
+
+static struct v4l2_frmivalenum sp1628_frmivalenum[]={
+        {
+                .index 		= 0,
+                .pixel_format	= V4L2_PIX_FMT_NV21,
+                .width		= 640,
+                .height		= 480,
+                .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+                {
+                        .discrete	={
+                                .numerator	= 1,
+                                .denominator	= 15,
+                        }
+                }
+        },
+};
+
+struct v4l2_querymenu sp1628_qmenu_wbmode[] = {
+    {
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_AUTO,
+        .name       = "auto",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_CLOUD,
+        .name       = "cloudy-daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_INCANDESCENCE,
+        .name       = "incandescent",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_DAYLIGHT,
+        .name       = "daylight",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "fluorescent", 
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_DO_WHITE_BALANCE,
+        .index      = CAM_WB_FLUORESCENT,
+        .name       = "warm-fluorescent", 
+        .reserved   = 0,
+    },
+};
+
+struct v4l2_querymenu sp1628_qmenu_anti_banding_mode[] = {
+    {
+        .id         = V4L2_CID_POWER_LINE_FREQUENCY,
+        .index      = CAM_BANDING_50HZ, 
+        .name       = "50hz",
+        .reserved   = 0,
+    },{
+        .id         = V4L2_CID_POWER_LINE_FREQUENCY,
+        .index      = CAM_BANDING_60HZ, 
+        .name       = "60hz",
+        .reserved   = 0,
+    },
+};
+
+typedef struct {
+    __u32   id;
+    int     num;
+    struct v4l2_querymenu* sp1628_qmenu;
+}sp1628_qmenu_set_t;
+
+sp1628_qmenu_set_t sp1628_qmenu_set[] = {
+    {
+        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .num            = ARRAY_SIZE(sp1628_qmenu_wbmode),
+        .sp1628_qmenu   = sp1628_qmenu_wbmode,
+    },{
+        .id         	= V4L2_CID_POWER_LINE_FREQUENCY,
+        .num            = ARRAY_SIZE(sp1628_qmenu_anti_banding_mode),
+        .sp1628_qmenu   = sp1628_qmenu_anti_banding_mode,
+    },
+};
+
+static int vidioc_querymenu(struct file *file, void *priv,
+                struct v4l2_querymenu *a)
+{
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(sp1628_qmenu_set); i++)
+	if (a->id && a->id == sp1628_qmenu_set[i].id) {
+	    for(j = 0; j < sp1628_qmenu_set[i].num; j++)
+		if (a->index == sp1628_qmenu_set[i].sp1628_qmenu[j].index) {
+			memcpy(a, &( sp1628_qmenu_set[i].sp1628_qmenu[j]),
+				sizeof(*a));
+			return (0);
+		}
+	}
+
+	return -EINVAL;
+}
+
+#define dprintk(dev, level, fmt, arg...) \
+	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+
+/* ------------------------------------------------------------------
+	Basic structures
+   ------------------------------------------------------------------*/
+
+struct sp1628_fmt {
+	char  *name;
+	u32   fourcc;          /* v4l2 format id */
+	int   depth;
+};
+
+static struct sp1628_fmt formats[] = {
+	{
+		.name     = "RGB565 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+		.depth    = 16,
+	},
+
+	{
+		.name     = "RGB888 (24)",
+		.fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
+		.depth    = 24,
+	},
+	{
+		.name     = "BGR888 (24)",
+		.fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
+		.depth    = 24,
+	},
+	{
+		.name     = "12  Y/CbCr 4:2:0",
+		.fourcc   = V4L2_PIX_FMT_NV12,
+		.depth    = 12,
+	},
+	{
+		.name     = "12  Y/CbCr 4:2:0",
+		.fourcc   = V4L2_PIX_FMT_NV21,
+		.depth    = 12,
+	},
+	{
+		.name     = "YUV420P",
+		.fourcc   = V4L2_PIX_FMT_YUV420,
+		.depth    = 12,
+	},
+	{
+		.name     = "YVU420P",
+		.fourcc   = V4L2_PIX_FMT_YVU420,
+		.depth    = 12,
+	}
+#if 0
+	{
+		.name     = "4:2:2, packed, YUYV",
+		.fourcc   = V4L2_PIX_FMT_VYUY,
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB565 (LE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565, /* gggbbbbb rrrrrggg */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB555 (LE)",
+		.fourcc   = V4L2_PIX_FMT_RGB555, /* gggbbbbb arrrrrgg */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB555 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB555X, /* arrrrrgg gggbbbbb */
+		.depth    = 16,
+	},
+#endif
+};
+
+static struct sp1628_fmt *get_format(struct v4l2_format *f)
+{
+	struct sp1628_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat)
+			break;
+	}
+
+	if (k == ARRAY_SIZE(formats))
+		return NULL;
+
+	return &formats[k];
+}
+
+struct sg_to_addr {
+	int pos;
+	struct scatterlist *sg;
+};
+
+/* buffer for one video frame */
+struct sp1628_buffer {
+	/* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+
+	struct sp1628_fmt        *fmt;
+};
+
+struct sp1628_dmaqueue {
+	struct list_head       active;
+
+	/* thread for generating video stream*/
+	struct task_struct         *kthread;
+	wait_queue_head_t          wq;
+	/* Counters to control fps rate */
+	int                        frame;
+	int                        ini_jiffies;
+};
+
+static LIST_HEAD(sp1628_devicelist);
+
+struct sp1628_device {
+	struct list_head			sp1628_devicelist;
+	struct v4l2_subdev			sd;
+	struct v4l2_device			v4l2_dev;
+
+	spinlock_t                 slock;
+	struct mutex				mutex;
+
+	int                        users;
+
+	/* various device info */
+	struct video_device        *vdev;
+
+	struct sp1628_dmaqueue       vidq;
+
+	/* Several counters */
+	unsigned long              jiffies;
+
+	/* Input Number */
+	int			   input;
+
+	/* platform device data from board initting. */
+	aml_cam_info_t  cam_info;
+	
+	/* wake lock */
+	struct wake_lock	wake_lock;
+
+	/* Control 'registers' */
+	int 			   qctl_regs[ARRAY_SIZE(sp1628_qctrl)];
+};
+
+static inline struct sp1628_device *to_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sp1628_device, sd);
+}
+
+struct sp1628_fh {
+	struct sp1628_device            *dev;
+
+	/* video capture */
+	struct sp1628_fmt            *fmt;
+	unsigned int               width, height;
+	struct videobuf_queue      vb_vidq;
+
+	enum v4l2_buf_type         type;
+	int			   input; 	/* Input Number on bars */
+	int  stream_on;
+	unsigned int		f_flags;
+};
+
+
+static struct v4l2_frmsize_discrete sp1628_prev_resolution[2]= //should include 352x288 and 640x480, those two size are used for recording
+{
+	{352,288},
+	{640,480},
+};
+
+static struct v4l2_frmsize_discrete sp1628_pic_resolution[]=
+{
+	{1280,960},
+};
+
+
+/* ------------------------------------------------------------------
+	reg spec of SP1628
+   ------------------------------------------------------------------*/
+
+#if 1
+
+struct aml_camera_i2c_fig1_s SP1628_script[] ={
+  {0xfd,0x00},//
+  {0x1b,0x60},//
+  {0x2f,0x10},//20//;24M*2=48M//20 3pll
+  {0x1c,0x10},//10
+  {0x30,0x00},//;00		
+  {0x0c,0x66},//;analog
+  {0x0d,0x12},//
+  {0x13,0x1d},//
+  {0x6b,0x20},//
+  {0x6d,0x20},//
+  {0x6f,0x21},//
+  {0x73,0x22},//
+  {0x7a,0x20},//
+  {0x15,0x30},// 
+  {0x71,0x32},//
+  {0x76,0x34},//  
+  {0x29,0x08},//
+  {0x18,0x01},//
+  {0x19,0x10},//
+  {0x1a,0xc3},//;c1
+  {0x1b,0x6f},//
+  {0x1d,0x11},//;01
+  {0x1e,0x00},//;1e
+  {0x1f,0xa0},//80
+  {0x20,0x7f},//
+  {0x22,0x3c},//;1b
+  {0x25,0xff},//
+  {0x2b,0x88},//
+  {0x2c,0x85},//
+  {0x2d,0x00},//
+  {0x2e,0x80},//
+  {0x27,0x38},//
+  {0x28,0x03},// 
+  {0x70,0x40},//
+  {0x72,0x40},//    
+  {0x74,0x38},//    
+  {0x75,0x38},//
+  {0x77,0x38},//  
+  {0x7f,0x40},//       
+  //{0x31,0x30},//70//		;mirror/flip 960
+  {0xfd,0x01},//
+  {0x5d,0x11},//		;position
+  {0x5f,0x00},//		;延长
+  {0xfb,0x25},//		;blacklevl
+  {0x48,0x00},//		;dp
+  {0x49,0x99},// 
+  {0xf2,0x0a},//		;同SP1628 0xf4     
+  {0xfd,0x02},//;AE
+  {0x52,0x34},//
+  {0x53,0x02},//		;测试是否ae抖
+  {0x54,0x0c},//
+  {0x55,0x08},// 
+  {0x86,0x0c},//		;其中满足条件帧数
+  {0x87,0x10},//		;检测总帧数
+  {0x8b,0x10},// 
+
+  
+
+#if 0
+//capture preview daylight 24M 3pll 50hz 17.6-9FPS vga 
+{0xfd,0x00},
+{0x03,0x04},
+{0x04,0x38},
+{0x05,0x00},
+{0x06,0x01},
+{0x09,0x01},
+{0x0a,0xde},
+{0xfd,0x01},
+{0xf0,0x00},
+{0xf7,0xb4},
+{0xf8,0x96},
+{0x02,0x0b},
+{0x03,0x01},
+{0x06,0xb4},
+{0x07,0x00},
+{0x08,0x01},
+{0x09,0x00},
+{0xfd,0x02},
+{0x40,0x0d},
+{0x41,0x96},
+{0x42,0x00},
+{0x88,0xd8},
+{0x89,0x69},
+{0x8a,0x32},
+{0xfd,0x02},
+{0xbe,0xbc},
+{0xbf,0x07},
+{0xd0,0xbc},
+{0xd1,0x07},
+{0xfd,0x01},
+{0x5b,0x07},
+{0x5c,0xbc},
+{0xfd,0x00},
+#elif 0
+  {0xfd,0x00},
+  {0x03,0x04},
+  {0x04,0x44},
+  {0x05,0x00},
+  {0x06,0x01},
+  {0x09,0x01},
+  {0x0a,0xd3},
+  {0xfd,0x01},
+  {0xf0,0x00},
+  {0xf7,0xb6},
+  {0xf8,0x98},
+  {0x02,0x0b},
+  {0x03,0x01},
+  {0x06,0xb6},
+  {0x07,0x00},
+  {0x08,0x01},
+  {0x09,0x00},
+  {0xfd,0x02},
+  {0x40,0x0d},
+  {0x41,0x98},
+  {0x42,0x00},
+  {0x88,0xd0},
+  {0x89,0x5e},
+  {0x8a,0x32},
+  {0xfd,0x02},
+  {0xbe,0xd2},
+  {0xbf,0x07},
+  {0xd0,0xd2},
+  {0xd1,0x07},
+  {0xfd,0x01},
+  {0x5b,0x07},
+  {0x5c,0xd2},
+  {0xfd,0x00},
+ #else
+ //capture preview daylight 24M 2pll 50hz 17-9FPS vga 
+  {0xfd,0x00},
+  {0x03,0x04},
+  {0x04,0x08},
+  {0x05,0x00},
+  {0x06,0x01},
+  {0x09,0x00},
+  {0x0a,0xaf},
+  {0xfd,0x01},
+  {0xf0,0x00},
+  {0xf7,0xac},
+  {0xf8,0x90},
+  {0x02,0x0b},
+  {0x03,0x01},
+  {0x06,0xac},
+  {0x07,0x00},
+  {0x08,0x01},
+  {0x09,0x00},
+  {0xfd,0x02},
+  {0x40,0x0d},
+  {0x41,0x90},
+  {0x42,0x00},
+  {0x88,0xfa},
+  {0x89,0x8e},
+  {0x8a,0x32},
+  {0xfd,0x02},
+  {0xbe,0x64},
+  {0xbf,0x07},
+  {0xd0,0x64},
+  {0xd1,0x07},
+  {0xfd,0x01},
+  {0x5b,0x07},
+  {0x5c,0x64},
+  {0xfd,0x00},
+ #endif
+
+  {0xfd,0x01},//;fix status
+  {0x5a,0x38},//		;DP_gain
+  {0xfd,0x02},//
+  {0xba,0x30},//		;mean_dummy_low
+  {0xbb,0x50},//		;mean_low_dummy
+  {0xbc,0xc0},//		;rpc_heq_low
+  {0xbd,0xa0},//		;rpc_heq_dummy
+  {0xb8,0x80},//		;mean_nr_dummy
+  {0xb9,0x90},//		;mean_dummy_nr
+  
+  {0xfd,0x01},//;rpc
+  {0xe0,0x54},//;6c 
+  {0xe1,0x40},//;54 
+  {0xe2,0x38},//;48 
+  {0xe3,0x34},//;40
+  {0xe4,0x34},//;40
+  {0xe5,0x30},//;3e
+  {0xe6,0x30},//;3e
+  {0xe7,0x2e},//;3a
+  {0xe8,0x2e},//;3a
+  {0xe9,0x2e},//;3a
+  {0xea,0x2c},//;38
+  {0xf3,0x2c},//;38
+  {0xf4,0x2c},//;38
+  {0xfd,0x01},//;ae min gain 
+  {0x04,0xc0},//		;rpc_max_indr
+  {0x05,0x2c},//;38		;1e;rpc_min_indr 
+  {0x0a,0xc0},//		;rpc_max_outdr
+  {0x0b,0x2c},//;38		;rpc_min_outdr 
+  {0xfd,0x01},//;ae target
+  {0xeb,0x78},//		 
+  {0xec,0x78},//		
+  {0xed,0x05},//
+  {0xee,0x0a},//
+  {0xfd,0x01},//		;lsc
+  {0x26,0x30},//
+  {0x27,0xdc},//
+  {0x28,0x05},//
+  {0x29,0x08},//
+  {0x2a,0x00},//
+  {0x2b,0x03},//
+  {0x2c,0x00},//
+  {0x2d,0x2f},//
+  {0xfd,0x01},//		;RGain
+  {0xa1,0x46},//;48		;left
+  {0xa2,0x50},//;58		;right
+  {0xa3,0x50},//;58		;up
+  {0xa4,0x47},//;50		;down
+  {0xad,0x08},//;08		;lu
+  {0xae,0x0a},//;10		;ru
+  {0xaf,0x0a},//;10		;ld
+  {0xb0,0x06},//;10		;rd
+  {0x18,0x00},//;40		;left  
+  {0x19,0x00},//;50		;right 
+  {0x1a,0x00},//;32		;up    
+  {0x1b,0x00},//;30		;down  
+  {0xbf,0x00},//;a5		;lu    
+  {0xc0,0x00},//;a0		;ru    
+  {0xc1,0x00},//;08		;ld    
+  {0xfa,0x00},//;00		;rd   
+  {0xa5,0x30},//;38	;GGain
+  {0xa6,0x36},//;48
+  {0xa7,0x30},//;48
+  {0xa8,0x38},//;40
+  {0xb1,0x00},//;00
+  {0xb2,0x00},//;00
+  {0xb3,0x00},//;00
+  {0xb4,0x00},//;00
+  {0x1c,0x00},//;28
+  {0x1d,0x00},//;40
+  {0x1e,0x00},//;2c
+  {0xb9,0x00},//;25 
+  {0x21,0x00},//;b0
+  {0x22,0x00},//;a0
+  {0x23,0x00},//;50
+  {0x24,0x00},//;0d  
+  {0xa9,0x31},//;38		;BGain
+  {0xaa,0x36},//;48
+  {0xab,0x30},//;46
+  {0xac,0x38},//;46
+  {0xb5,0x00},//;08
+  {0xb6,0x00},//;08
+  {0xb7,0x04},//;08
+  {0xb8,0x02},//;08
+  {0xba,0x00},//;12
+  {0xbc,0x00},//;30
+  {0xbd,0x00},//;31
+  {0xbe,0x00},//;1e
+  {0x25,0x00},//;a0
+  {0x45,0x00},//;a0
+  {0x46,0x00},//;12
+  {0x47,0x00},//;09    
+  {0xfd,0x01},//		;awb
+  {0x32,0x15},//
+  {0xfd,0x02},//
+  {0x26,0xc9},//
+  {0x27,0x8b},//
+  {0x1b,0x80},//
+  {0x1a,0x80},//
+  {0x18,0x27},//
+  {0x19,0x26},//
+  {0x2a,0x01},//
+  {0x2b,0x10},//
+  {0x28,0xf8},//		;0xa0
+  {0x29,0x08},// ;d65 88
+  {0x66,0x38},//;35		;0x48
+  {0x67,0x54},//;60		;0x69
+  {0x68,0xba},//;b0		;c8;0xb5;0xaa
+  {0x69,0xce},//;e0		;f4;0xda;0xed
+  {0x6a,0xa5},//;indoor 89
+  {0x7c,0x17},//;43
+  {0x7d,0x40},//
+  {0x7e,0xe6},//
+  {0x7f,0x13},//
+  {0x80,0xa6},//;cwf   8a
+  {0x70,0x15},//;2f		;0x3b
+  {0x71,0x38},//;4a		;0x55
+  {0x72,0x08},//		;0x28
+  {0x73,0x20},//;24		;0x45
+  {0x74,0xaa},//;tl84  8b
+  {0x6b,0x08},//;18
+  {0x6c,0x24},//;34		;0x25;0x2f
+  {0x6d,0x12},//;17		;0x35
+  {0x6e,0x32},//		;0x52
+  {0x6f,0xaa},//;f    8c
+  {0x61,0xf0},//;e0;10		;04;0xf4;0xed
+  {0x62,0x1a},//;38		;22;0x14;0f
+  {0x63,0x1c},//		;30;0x5d
+  {0x64,0x3a},//		;55;0x75;0x8f
+  {0x65,0x6a},//		;0x6a
+  {0x75,0x80},//
+  {0x76,0x09},//
+  {0x77,0x02},//
+  {0x24,0x25},//
+  {0x0e,0x16},//
+  {0x3b,0x09},//
+  {0xfd,0x02},//		; sharp
+  {0xde,0x0f},//
+  {0xd2,0x0c},//		;控制黑白边；0-边粗，f-变细
+  {0xd3,0x0c},//0a
+  {0xd4,0x0a},//08
+  {0xd5,0x08},//
+  {0xd7,0x0a},//	10	;轮廓判断
+  {0xd8,0x14},//1d
+  {0xd9,0x28},//32
+  {0xda,0x34},//
+  {0xdb,0x08},//
+  {0xe8,0x58},//	38	;轮廓强度
+  {0xe9,0x54},//38
+  {0xea,0x3c},//
+  {0xeb,0x26},//
+  {0xec,0x74},//
+  {0xed,0x5c},//
+  {0xee,0x3e},//
+  {0xef,0x26},//
+  {0xf3,0x00},//		;平坦区域锐化力度
+  {0xf4,0x00},//
+  {0xf5,0x00},//
+  {0xf6,0x00},//
+  {0xfd,0x02},//		;skin sharpen
+  {0xdc,0x04},//		;肤色降锐化
+  {0x05,0x6f},//		;排除肤色降锐化对分辨率卡引起的干扰
+  {0x09,0x10},//		;肤色排除白点区域
+  {0xfd,0x01},//		;dns
+  {0x64,0x22},//		;沿方向边缘平滑力度  ;0-最强，8-最弱
+  {0x65,0x22},//		
+  {0x86,0x20},//		;沿方向边缘平滑阈值，越小越弱
+  {0x87,0x20},//		
+  {0x88,0x20},//		
+  {0x89,0x20},//		
+  {0x6d,0x0f},//		;强平滑（平坦）区域平滑阈值
+  {0x6e,0x0f},//		
+  {0x6f,0x10},//		
+  {0x70,0x10},//		
+  {0x71,0x0d},//		;弱轮廓（非平坦）区域平滑阈值	
+  {0x72,0x23},//		
+  {0x73,0x2a},//		
+  {0x74,0x2f},//		
+  {0x75,0x46},//		;[7:4]平坦区域强度，[3:0]非平坦区域强度；0-最强，8-最弱；
+  {0x76,0x36},//		
+  {0x77,0x25},//		
+  {0x78,0x12},//		
+  {0x81,0x1d},//		;2x;根据增益判定区域阈值
+  {0x82,0x2b},//		;4x
+  {0x83,0xff},//		;8x
+  {0x84,0xff},//		;16x
+  {0x85,0x0a},//		; 12/8+reg0x81 第二阈值，在平坦和非平坦区域做连接
+  {0xfd,0x01},//		;gamma  
+  {0x8b,0x00},//;00;00;00;     
+  {0x8c,0x10},//;02;0b;0b;     
+  {0x8d,0x20},//;0a;19;17;     
+  {0x8e,0x31},//;13;2a;27;     
+  {0x8f,0x3f},//;1d;37;35;     
+  {0x90,0x53},//;30;4b;51;     
+  {0x91,0x64},//;40;5e;64;     
+  {0x92,0x74},//;4e;6c;74;     
+  {0x93,0x80},//;5a;78;80;     
+  {0x94,0x92},//;71;92;92;     
+  {0x95,0xa2},//;85;a6;a2;     
+  {0x96,0xaf},//;96;b5;af;     
+  {0x97,0xbb},//;a6;bf;bb;     
+  {0x98,0xc6},//;b3;ca;c6;     
+  {0x99,0xd0},//;c0;d2;d0;     
+  {0x9a,0xd9},//;cb;d9;d9;     
+  {0x9b,0xe0},//;d5;e1;e0;     
+  {0x9c,0xe8},//;df;e8;e8;     
+  {0x9d,0xee},//;e9;ee;ee;     
+  {0x9e,0xf4},//;f2;f4;f4;     
+  {0x9f,0xfa},//;fa;fa;fa;     
+  {0xa0,0xff},//;ff;ff;ff;     
+  {0xfd,0x02},//		;CCM
+  {0x15,0xac},//		;b>th a4
+  {0x16,0x90},//		;r<th 87
+  {0xa0,0x80},//;99;a6;a6;8c;80; 非F
+  {0xa1,0x00},//;0c;da;da;da;fa;00;
+  {0xa2,0x00},//;da;00;00;00;fa;00;
+  {0xa3,0x00},//;00;e7;e7;da;da;e7;
+  {0xa4,0x80},//;99;c0;c0;c0;c0;a6;
+  {0xa5,0x00},//;e7;da;da;e7;e7;f4;
+  {0xa6,0x00},//;00;00;00;00;00;00;
+  {0xa7,0xe7},//;e7;b4;b4;a7;cd;da;
+  {0xa8,0x99},//;99;cc;d9;b3;a6;
+  {0xa9,0x00},//;30;0c;0c;0c;3c;00;
+  {0xaa,0x00},//;30;33;33;33;33;33;
+  {0xab,0x0c},//;0c;0c;0c;0c;0c;0c;
+  {0xac,0x99},//;80;a2;b3;8c;F
+  {0xad,0x26},//;00;04;0c;0c;
+  {0xae,0xc0},//;00;da;c0;e7;
+  {0xaf,0xed},//;e7;cd;cd;b4;
+  {0xb0,0xcc},//;c0;d9;e6;e6;
+  {0xb1,0xcd},//;da;da;cd;e7;
+  {0xb2,0xed},//;e7;f6;e7;e7;
+  {0xb3,0xda},//;b4;98;9a;9a;
+  {0xb4,0xb9},//;e6;f3;00;00;
+  {0xb5,0x30},//;00;30;30;30;
+  {0xb6,0x33},//;33;33;33;33;
+  {0xb7,0x0f},//;0f;0f;1f;1f; 
+  {0xfd,0x01},//		;sat u 
+  {0xd3,0x98},//	过标准105%
+  {0xd4,0x98},//	
+  {0xd5,0x80},//		
+  {0xd6,0x70},//		
+  {0xd7,0x98},// ;sat v 
+  {0xd8,0x98},//	
+  {0xd9,0x80},//		
+  {0xda,0x70},//		
+  {0xfd,0x01},//		;auto_sat
+  {0xd2,0x00},//		;autosa_en
+  {0xfd,0x01},//		;uv_th	
+  {0xc2,0xee},//   ;白色物体表面有彩色噪声降低此值  
+  {0xc3,0xee},//
+  {0xc4,0xdd},//
+  {0xc5,0xbb},//
+  {0xfd,0x01},//		;low_lum_offset
+  {0xcd,0x10},//
+  {0xce,0x1f},//
+  {0xfd,0x02},//		;gw
+  {0x35,0x6f},//
+  {0x37,0x13},//
+  {0xfd,0x01},//		;heq
+  {0xdb,0x00},//  
+  {0x10,0x00},// 
+  {0x14,0x15},//  
+  {0x11,0x00},//
+  {0x15,0x10},//
+  {0x16,0x10},// 
+  {0xfd,0x02},//		;cnr 找张国华解释  
+  {0x8e,0x10},// 
+  {0x90,0x20},//
+  {0x91,0x20},//
+  {0x92,0x60},//
+  {0x93,0x80},//
+  {0xfd,0x02},//		;auto 
+  {0x85,0x00},//	;12 enable 50Hz/60Hz function
+  {0xfd,0x01},// 
+  {0x00,0x00},// 	;fix mode   
+  {0x32,0x15},//;		;ae en
+  {0x33,0xef},//		;lsc\bpc en
+  {0x34,0xc7},//		;ynr\cnr\gamma\color en
+  {0x35,0x41},//	40	;YUYV
+  {0xfd,0x00},		  
+ #if 1
+ 	//set VGA
+	{0xfd,0x00},
+	{0x19,0x17},
+	{0x30,0x00}, //pclk/2
+	{0x31,0x54},//74
+#endif //end vga set	
+
+#if 0
+   //mipi
+	{0x94,0x80}, 
+	{0x95,0x02},
+	{0x96,0xe0},//  0x2d0=720P
+	{0x97,0x01},//	  0x3c0=960
+#endif
+
+	{0xfd,0x01},
+	{0xfb,0x25},
+
+
+	
+	{0xe7,0x03},
+	{0xe7,0x00},
+	{0xff,0xff},
+} ;
+
+
+void SP1628_init_regs(struct sp1628_device *dev)
+{
+	int i=0;//,j;
+	unsigned char buf[2];
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
+	while (1) {
+		buf[0] = SP1628_script[i].addr;
+		buf[1] = SP1628_script[i].val;
+		if(SP1628_script[i].val==0xff&&SP1628_script[i].addr==0xff){
+			printk("SP1628_write_regs success in initial SP1628.\n");
+			break;
+		}
+		if((i2c_put_byte_add8(client,buf, 2)) < 0){
+			printk("fail in initial SP1628. \n");
+			return;
+		}
+		i++;
+	}
+	return;
+}
+
+#endif
+
+
+static int set_flip(struct sp1628_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	unsigned char temp;
+	unsigned char buf[2];
+	temp = i2c_get_byte_add8(client, 0x31);
+	temp &= 0x9f;
+	temp |= dev->cam_info.m_flip << 5;
+	temp |= dev->cam_info.v_flip << 6;
+	buf[0] = 0x31;
+	buf[1] = temp;
+	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
+            printk("fail in setting sensor orientation\n");
+            return -1;
+        }
+        return 0;
+}
+
+
+static void sp1628_set_resolution(struct sp1628_device *dev,int height,int width)
+{
+	int i=0;
+	unsigned char buf[2];
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	if (width*height >= 640*480) {
+		printk("set resolution 1280X960\n");
+		
+		i2c_put_byte_add8_new(client,0xfd,0x00);
+		i2c_put_byte_add8_new(client,0x19,0x10);//1280*960		
+		i2c_put_byte_add8_new(client,0x30,0x00);
+		i2c_put_byte_add8_new(client,0x31,0x50);
+		
+		/*i2c_put_byte_add8_new(client,0xfd,0x01);
+		i2c_put_byte_add8_new(client,0x4a,0x00);
+		i2c_put_byte_add8_new(client,0x4b,0x03);
+		i2c_put_byte_add8_new(client,0x4c,0xc0);
+		i2c_put_byte_add8_new(client,0x4d,0x00);
+		i2c_put_byte_add8_new(client,0x4e,0x05);
+		i2c_put_byte_add8_new(client,0x4f,0x00);
+		i2c_put_byte_add8_new(client,0xfd,0x00);
+		i2c_put_byte_add8_new(client,0x19,0x10);
+		i2c_put_byte_add8_new(client,0x30,0x00);
+		i2c_put_byte_add8_new(client,0x31,0x10);
+		i2c_put_byte_add8_new(client,0xfd,0x00);
+		mdelay(100);*/
+		/*while (1) {
+			buf[0] = resolution_script[i].addr;
+			buf[1] = resolution_script[i].val;
+			if(resolution_script[i].val==0xff&&resolution_script[i].addr==0xff){
+				break;
+			}
+			if((i2c_put_byte_add8(client,buf, 2)) < 0){
+				printk("fail in set resolution. \n");
+				return;
+			}
+			i++;
+		}
+		mdelay(100);*/
+		sp1628_h_active = 1280;
+		sp1628_v_active = 958;
+		sp1628_frmintervals_active.denominator 	= 15;
+		sp1628_frmintervals_active.numerator	= 1;
+		/*
+		i2c_put_byte_add8_new(client,0xfd,0x00);
+		i2c_put_byte_add8_new(client,0x19,0x17);	//640*480	
+		i2c_put_byte_add8_new(client,0x30,0x00);
+		i2c_put_byte_add8_new(client,0x31,0x54);*/
+		
+		/*i2c_put_byte_add8_new(client,0xfd,0x00);
+		i2c_put_byte_add8_new(client,0x19,0x10);//1280*960		
+		i2c_put_byte_add8_new(client,0x30,0x00);
+		i2c_put_byte_add8_new(client,0x31,0x50);*/
+		
+	} else {
+		printk("set resolution 320X240\n");
+		sp1628_h_active = 320;
+		sp1628_v_active = 240;
+		sp1628_frmintervals_active.denominator 	= 15;
+		sp1628_frmintervals_active.numerator	= 1;
+	}
+    //set_flip(dev);
+}
+/*************************************************************************
+* FUNCTION
+*	set_SP1628_param_wb
+*
+* DESCRIPTION
+*	SP1628 wb setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED  白平衡参数
+*
+*************************************************************************/
+void set_SP1628_param_wb(struct sp1628_device *dev,enum  camera_wb_flip_e para)
+	{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
+		switch (para)
+		{
+	
+			case CAM_WB_AUTO://auto
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x05);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x03);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x26,0xc9);
+				i2c_put_byte_add8_new(client,0x27,0x8b);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x15);
+				break;
+	
+			case CAM_WB_CLOUD: //cloud
+	
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x05);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x03);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x26,0xdb);
+				i2c_put_byte_add8_new(client,0x27,0x63);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+				break;
+	
+			case CAM_WB_DAYLIGHT: //
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x05);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x03);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x26,0xca);
+				i2c_put_byte_add8_new(client,0x27,0x73);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+				break;
+	
+			case CAM_WB_INCANDESCENCE:
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x05);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x03);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x26,0x8c);
+				i2c_put_byte_add8_new(client,0x27,0xb3);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+				break;
+	
+			case CAM_WB_TUNGSTEN:
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x05);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x03);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x26,0x90);
+				i2c_put_byte_add8_new(client,0x27,0xa5);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+				break;
+	
+			case CAM_WB_FLUORESCENT:
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x32,0x05);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x03);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x26,0x95);
+				i2c_put_byte_add8_new(client,0x27,0x9c);
+				
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+				break;
+	
+			case CAM_WB_MANUAL:
+					// TODO
+				break;
+		}
+	
+	
+	}
+
+
+/*************************************************************************
+* FUNCTION
+*	SP1628_night_mode
+*
+* DESCRIPTION
+*	This function night mode of SP1628.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void SP1628_night_mode(struct sp1628_device *dev,enum  camera_night_mode_flip_e enable)
+	{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
+		
+		if (enable)
+		{
+			sp1628_night_or_normal = 1; //=1,night mode; =0,normal mode //add by sp_yjp,20120905
+	
+			if(Antiflicker== DCAMERA_FLICKER_50HZ)
+			{
+				//i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
+				//i2c_put_byte_add8_new(client,0x32,0x08);
+				printk("night mode 50hz\r\n");
+				#if 0					   
+					//capture preview night  24M 3pll 50hz 17.6-6FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x04);
+				i2c_put_byte_add8_new(client,0x04,0x44);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x01);
+				i2c_put_byte_add8_new(client,0x0a,0xd3);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0xb6);
+				i2c_put_byte_add8_new(client,0xf8,0x98);
+				i2c_put_byte_add8_new(client,0x02,0x0b);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0xb6);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x0d);
+				i2c_put_byte_add8_new(client,0x41,0x98);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0xd0);
+				i2c_put_byte_add8_new(client,0x89,0x5e);
+				i2c_put_byte_add8_new(client,0x8a,0x32);
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0xd2);
+				i2c_put_byte_add8_new(client,0xbf,0x07);
+				i2c_put_byte_add8_new(client,0xd0,0xd2);
+				i2c_put_byte_add8_new(client,0xd1,0x07);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x07);
+				i2c_put_byte_add8_new(client,0x5c,0xd2);
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				#else
+				//capture preview night  24M 2pll 50hz 17-6FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x04);
+				i2c_put_byte_add8_new(client,0x04,0x08);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0x0a,0xaf);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0xac);
+				i2c_put_byte_add8_new(client,0xf8,0x90);
+				i2c_put_byte_add8_new(client,0x02,0x10);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0xac);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x14);
+				i2c_put_byte_add8_new(client,0x41,0x90);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0xfa);
+				i2c_put_byte_add8_new(client,0x89,0x8e);
+				i2c_put_byte_add8_new(client,0x8a,0x32);
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0xc0);
+				i2c_put_byte_add8_new(client,0xbf,0x0a);
+				i2c_put_byte_add8_new(client,0xd0,0xc0);
+				i2c_put_byte_add8_new(client,0xd1,0x0a);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x0a);
+				i2c_put_byte_add8_new(client,0x5c,0xc0);
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				
+				#endif
+				
+				i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
+				i2c_put_byte_add8_new(client,0xe7,0x00);			
+	
+			}
+			else
+			{
+				//i2c_put_byte_add8_new(client,,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
+				//i2c_put_byte_add8_new(client,,0x32,0x08);
+				printk("night mode 60hz\r\n");
+	            #if 0
+				 //capture preview night  24M 3pll 60hz 17.6-6FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x03);
+				i2c_put_byte_add8_new(client,0x04,0x84);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x01);
+				i2c_put_byte_add8_new(client,0x0a,0xde);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0x96);
+				i2c_put_byte_add8_new(client,0xf8,0x96);
+				i2c_put_byte_add8_new(client,0x02,0x14);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0x96);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x14);
+				i2c_put_byte_add8_new(client,0x41,0x96);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0x69);
+				i2c_put_byte_add8_new(client,0x89,0x69);
+				i2c_put_byte_add8_new(client,0x8a,0x33);  
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0xb8);
+				i2c_put_byte_add8_new(client,0xbf,0x0b);
+				i2c_put_byte_add8_new(client,0xd0,0xb8);
+				i2c_put_byte_add8_new(client,0xd1,0x0b);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x0b);
+				i2c_put_byte_add8_new(client,0x5c,0xb8);
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+	            #else
+			    //capture preview night  24M 2pll 60hz 17-6FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x03);
+				i2c_put_byte_add8_new(client,0x04,0x60);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0x0a,0xac);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0x90);
+				i2c_put_byte_add8_new(client,0xf8,0x90);
+				i2c_put_byte_add8_new(client,0x02,0x14);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0x90);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x14);
+				i2c_put_byte_add8_new(client,0x41,0x90);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0x8e);
+				i2c_put_byte_add8_new(client,0x89,0x8e);
+				i2c_put_byte_add8_new(client,0x8a,0x33);  
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0x40);
+				i2c_put_byte_add8_new(client,0xbf,0x0b);
+				i2c_put_byte_add8_new(client,0xd0,0x40);
+				i2c_put_byte_add8_new(client,0xd1,0x0b);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x0b);
+				i2c_put_byte_add8_new(client,0x5c,0x40);
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				#endif
+				i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+	
+			}
+		}
+		else
+		{
+			//i2c_put_byte_add8_new(client,); //Camera Enable night mode  1/5 Frame rate //zyy test
+			sp1628_night_or_normal = 0; //=1,night mode; =0,normal mode //add by sp_yjp,20120905
+	
+	
+			if(Antiflicker== DCAMERA_FLICKER_50HZ)
+			{
+				//i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
+				//i2c_put_byte_add8_new(client,0x32,0x08);
+				printk("normal mode 50hz\r\n"); 
+	            #if 0
+			   //capture preview daylight 24M 3pll 50hz 17.6-9FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x04);
+				i2c_put_byte_add8_new(client,0x04,0x38);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x01);
+				i2c_put_byte_add8_new(client,0x0a,0xde);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0xb4);
+				i2c_put_byte_add8_new(client,0xf8,0x96);
+				i2c_put_byte_add8_new(client,0x02,0x0b);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0xb4);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x0d);
+				i2c_put_byte_add8_new(client,0x41,0x96);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0xd8);
+				i2c_put_byte_add8_new(client,0x89,0x69);
+				i2c_put_byte_add8_new(client,0x8a,0x32);
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0xbc);
+				i2c_put_byte_add8_new(client,0xbf,0x07);
+				i2c_put_byte_add8_new(client,0xd0,0xbc);
+				i2c_put_byte_add8_new(client,0xd1,0x07);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x07);
+				i2c_put_byte_add8_new(client,0x5c,0xbc);
+				i2c_put_byte_add8_new(client,0xfd,0x00); 		
+				#else
+				//capture preview daylight 24M 2pll 50hz 17-9FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x04);
+				i2c_put_byte_add8_new(client,0x04,0x08);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0x0a,0xaf);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0xac);
+				i2c_put_byte_add8_new(client,0xf8,0x90);
+				i2c_put_byte_add8_new(client,0x02,0x0b);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0xac);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x0d);
+				i2c_put_byte_add8_new(client,0x41,0x90);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0xfa);
+				i2c_put_byte_add8_new(client,0x89,0x8e);
+				i2c_put_byte_add8_new(client,0x8a,0x32);
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0x64);
+				i2c_put_byte_add8_new(client,0xbf,0x07);
+				i2c_put_byte_add8_new(client,0xd0,0x64);
+				i2c_put_byte_add8_new(client,0xd1,0x07);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x07);
+				i2c_put_byte_add8_new(client,0x5c,0x64);
+				i2c_put_byte_add8_new(client,0xfd,0x00); 	
+				#endif
+	
+				i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+			}
+			else
+			{
+				//i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
+				//i2c_put_byte_add8_new(client,0x32,0x08);
+				printk("normal mode 60hz\r\n"); 
+			    #if 0
+				//capture preview daylight 24M 3pll 60hz 17.6-9FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x03);
+				i2c_put_byte_add8_new(client,0x04,0x84);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x01);
+				i2c_put_byte_add8_new(client,0x0a,0xde);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0x96);
+				i2c_put_byte_add8_new(client,0xf8,0x96);
+				i2c_put_byte_add8_new(client,0x02,0x0d);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0x96);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x0d);
+				i2c_put_byte_add8_new(client,0x41,0x96);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0x69);
+				i2c_put_byte_add8_new(client,0x89,0x69);
+				i2c_put_byte_add8_new(client,0x8a,0x33);
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0x9e);
+				i2c_put_byte_add8_new(client,0xbf,0x07);
+				i2c_put_byte_add8_new(client,0xd0,0x9e);
+				i2c_put_byte_add8_new(client,0xd1,0x07);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x07);
+				i2c_put_byte_add8_new(client,0x5c,0x9e);
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				#else
+				//capture preview daylight 24M 3pll 60hz 17.6-9FPS vga
+				i2c_put_byte_add8_new(client,0xfd,0x00);
+				i2c_put_byte_add8_new(client,0x03,0x03);
+				i2c_put_byte_add8_new(client,0x04,0x60);
+				i2c_put_byte_add8_new(client,0x05,0x00);
+				i2c_put_byte_add8_new(client,0x06,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0x0a,0xac);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0xf0,0x00);
+				i2c_put_byte_add8_new(client,0xf7,0x90);
+				i2c_put_byte_add8_new(client,0xf8,0x90);
+				i2c_put_byte_add8_new(client,0x02,0x0d);
+				i2c_put_byte_add8_new(client,0x03,0x01);
+				i2c_put_byte_add8_new(client,0x06,0x90);
+				i2c_put_byte_add8_new(client,0x07,0x00);
+				i2c_put_byte_add8_new(client,0x08,0x01);
+				i2c_put_byte_add8_new(client,0x09,0x00);
+				i2c_put_byte_add8_new(client,0xfd,0x02);
+				i2c_put_byte_add8_new(client,0x40,0x0d);
+				i2c_put_byte_add8_new(client,0x41,0x90);
+				i2c_put_byte_add8_new(client,0x42,0x00);
+				i2c_put_byte_add8_new(client,0x88,0x8e);
+				i2c_put_byte_add8_new(client,0x89,0x8e);
+				i2c_put_byte_add8_new(client,0x8a,0x33);
+				i2c_put_byte_add8_new(client,0xfd,0x02);//Status
+				i2c_put_byte_add8_new(client,0xbe,0x50);
+				i2c_put_byte_add8_new(client,0xbf,0x07);
+				i2c_put_byte_add8_new(client,0xd0,0x50);
+				i2c_put_byte_add8_new(client,0xd1,0x07);
+				i2c_put_byte_add8_new(client,0xfd,0x01);
+				i2c_put_byte_add8_new(client,0x5b,0x07);
+				i2c_put_byte_add8_new(client,0x5c,0x50);
+				i2c_put_byte_add8_new(client,0xfd,0x00); 
+				#endif
+	
+				i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
+				i2c_put_byte_add8_new(client,0xe7,0x00);
+			}
+		//i2c_put_byte_add8_new(client,); //Disable night mode	1/2 Frame rate
+		}
+		//i2c_put_byte_add8_new(client,0xfd,0x00);	//enable AE,add by sp_yjp,20120905
+		//i2c_put_byte_add8_new(client,0x32,0x0d);
+	}
+
+/*************************************************************************
+* FUNCTION
+*	SP1628_night_mode
+*
+* DESCRIPTION
+*	This function night mode of SP1628.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+
+void SP1628_set_param_banding(struct sp1628_device *dev,enum  camera_banding_flip_e banding)
+	{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+		unsigned char buf[4];
+		
+		  switch(banding)
+		
+		 {
+			 case CAM_BANDING_50HZ: 		
+		
+			Antiflicker = DCAMERA_FLICKER_50HZ;
+		
+			printk( " set_SP1628_anti_flicker  50hz \r\n" );
+		
+			break;
+		
+			 case CAM_BANDING_60HZ:
+		
+			Antiflicker = DCAMERA_FLICKER_60HZ;
+		
+			printk( " set_SP1628_anti_flicker  60hz \r\n" );
+		
+			break;
+		
+			 //default:
+		
+				 break;
+		
+		 }
+		
+	}
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_SP1628_param_exposure
+*
+* DESCRIPTION
+*	SP1628 exposure setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED  亮度等级 调节参数
+*
+*************************************************************************/
+void set_SP1628_param_exposure(struct sp1628_device *dev,enum camera_exposure_e para)//曝光调节
+	{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
+	
+		switch (para)
+		{
+	
+			case EXPOSURE_N4_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb-0x40);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec-0x40);
+				break;
+	
+	
+	
+			case EXPOSURE_N3_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb-0x30);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec-0x30);
+				break;
+	
+	
+			case EXPOSURE_N2_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb-0x20);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec-0x20);
+				break;
+	
+	
+			case EXPOSURE_N1_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb-0x10);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec-0x10);
+				break;
+				
+			case EXPOSURE_0_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb);//-40
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec);//-40
+				break;
+				
+			case EXPOSURE_P1_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb+0x10);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec+0x10);
+				break;
+				
+			case EXPOSURE_P2_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb+0x20);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec+0x20);
+				break;
+	
+			case EXPOSURE_P3_STEP:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb+0x30);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec+0x30);
+				break;
+						
+			case EXPOSURE_P4_STEP:	
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb+0x40);
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec+0x40);
+				break;
+	
+			default:
+				i2c_put_byte_add8_new(client,0xfd , 0x01);
+				i2c_put_byte_add8_new(client,0xeb , P1_Ae_Target_0xeb);//
+				i2c_put_byte_add8_new(client,0xec , P1_Ae_Target_0xec);//
+				break;
+					//break;
+	
+	
+	
+		}
+	
+	
+	}
+
+
+/*************************************************************************
+* FUNCTION
+*	set_SP1628_param_effect
+*
+* DESCRIPTION
+*	SP1628 effect setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED  特效参数
+*
+*************************************************************************/
+void set_SP1628_param_effect(struct sp1628_device *dev,enum camera_effect_flip_e para)//特效设置
+	{
+		struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	
+	
+		switch (para)
+		{
+			case CAM_EFFECT_ENC_NORMAL:
+				i2c_put_byte_add8_new(client,0xfd, 0x01);
+				i2c_put_byte_add8_new(client,0x66, 0x00);
+				i2c_put_byte_add8_new(client,0x67, 0x80);
+				i2c_put_byte_add8_new(client,0x68, 0x80);
+				i2c_put_byte_add8_new(client,0xdb, 0x00);
+				i2c_put_byte_add8_new(client,0x34, 0xc7);
+				i2c_put_byte_add8_new(client,0xfd, 0x02);
+				i2c_put_byte_add8_new(client,0x14, 0x00);
+				break;
+	
+			case CAM_EFFECT_ENC_GRAYSCALE:
+				i2c_put_byte_add8_new(client,0xfd, 0x01);
+				i2c_put_byte_add8_new(client,0x66, 0x20);
+				i2c_put_byte_add8_new(client,0x67, 0x80);
+				i2c_put_byte_add8_new(client,0x68, 0x80);
+				i2c_put_byte_add8_new(client,0xdb, 0x00);
+				i2c_put_byte_add8_new(client,0x34, 0xc7);
+				i2c_put_byte_add8_new(client,0xfd, 0x02);
+				i2c_put_byte_add8_new(client,0x14, 0x00);
+				break;
+	
+			case CAM_EFFECT_ENC_SEPIA:
+				i2c_put_byte_add8_new(client,0xfd, 0x01);
+				i2c_put_byte_add8_new(client,0x66, 0x10);
+				i2c_put_byte_add8_new(client,0x67, 0x98);
+				i2c_put_byte_add8_new(client,0x68, 0x58);
+				i2c_put_byte_add8_new(client,0xdb, 0x00);
+				i2c_put_byte_add8_new(client,0x34, 0xc7);
+				i2c_put_byte_add8_new(client,0xfd, 0x02);
+				i2c_put_byte_add8_new(client,0x14, 0x00);
+				break;
+	
+			case CAM_EFFECT_ENC_SEPIAGREEN:
+				i2c_put_byte_add8_new(client,0xfd, 0x01);
+				i2c_put_byte_add8_new(client,0x66, 0x10);
+				i2c_put_byte_add8_new(client,0x67, 0x50);
+				i2c_put_byte_add8_new(client,0x68, 0x50);
+				i2c_put_byte_add8_new(client,0xdb, 0x00);
+				i2c_put_byte_add8_new(client,0x34, 0xc7);
+				i2c_put_byte_add8_new(client,0xfd, 0x02);
+				i2c_put_byte_add8_new(client,0x14, 0x00);
+				break;
+	
+			case CAM_EFFECT_ENC_SEPIABLUE:
+				i2c_put_byte_add8_new(client,0xfd, 0x01);
+				i2c_put_byte_add8_new(client,0x66, 0x10);
+				i2c_put_byte_add8_new(client,0x67, 0x80);
+				i2c_put_byte_add8_new(client,0x68, 0xb0);
+				i2c_put_byte_add8_new(client,0xdb, 0x00);
+				i2c_put_byte_add8_new(client,0x34, 0xc7);
+				i2c_put_byte_add8_new(client,0xfd, 0x02);
+				i2c_put_byte_add8_new(client,0x14, 0x00);
+				break;
+	
+			case CAM_EFFECT_ENC_COLORINV:
+	
+				break;
+	
+			default:
+				break;
+		}
+	
+	
+	
+	}
+
+
+unsigned char v4l_2_sp1628(int val)
+{
+	int ret=val/0x20;
+	if(ret<4) return ret*0x20+0x80;
+	else if(ret<8) return ret*0x20+0x20;
+	else return 0;
+}
+
+static int sp1628_setting(struct sp1628_device *dev,int PROP_ID,int value )
+{
+	int ret=0;
+	switch(PROP_ID)  {
+#if 0
+	case V4L2_CID_BRIGHTNESS:
+		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_sp1628(value));
+		ret=i2c_put_byte(client,0x0201,v4l_2_sp1628(value));
+		break;
+	case V4L2_CID_CONTRAST:
+		ret=i2c_put_byte(client,0x0200, value);
+		break;
+	case V4L2_CID_SATURATION:
+		ret=i2c_put_byte(client,0x0202, value);
+		break;
+	case V4L2_CID_HFLIP:    /* set flip on H. */
+		ret=i2c_get_byte(client,0x0101);
+		if(ret>0) {
+			cur_val=(char)ret;
+			if(value!=0)
+				cur_val=cur_val|0x1;
+			else
+				cur_val=cur_val&0xFE;
+			ret=i2c_put_byte(client,0x0101,cur_val);
+			if(ret<0) dprintk(dev, 1, "V4L2_CID_HFLIP setting error\n");
+		}  else {
+			dprintk(dev, 1, "vertical read error\n");
+		}
+		break;
+	case V4L2_CID_VFLIP:    /* set flip on V. */
+		ret=i2c_get_byte(client,0x0101);
+		if(ret>0) {
+			cur_val=(char)ret;
+			if(value!=0)
+				cur_val=cur_val|0x10;
+			else
+				cur_val=cur_val&0xFD;
+			ret=i2c_put_byte(client,0x0101,cur_val);
+		} else {
+			dprintk(dev, 1, "vertical read error\n");
+		}
+		break;
+#endif
+	case V4L2_CID_DO_WHITE_BALANCE:
+		if(sp1628_qctrl[0].default_value!=value){
+			sp1628_qctrl[0].default_value=value;
+			set_SP1628_param_wb(dev,value);
+			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_EXPOSURE:
+		if(sp1628_qctrl[1].default_value!=value){
+			sp1628_qctrl[1].default_value=value;
+			set_SP1628_param_exposure(dev,value);
+			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_COLORFX:
+		if(sp1628_qctrl[2].default_value!=value){
+			sp1628_qctrl[2].default_value=value;
+			set_SP1628_param_effect(dev,value);
+			printk(KERN_INFO " set camera  effect=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		if(sp1628_qctrl[3].default_value!=value){
+			sp1628_qctrl[3].default_value=value;
+			SP1628_set_param_banding(dev,value);
+			printk(KERN_INFO " set camera  banding=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		if(sp1628_qctrl[4].default_value!=value){
+			sp1628_qctrl[4].default_value=value;
+			SP1628_night_mode(dev,value);
+			printk(KERN_INFO " set camera  scene mode=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_HFLIP:    /* set flip on H. */          
+		value = value & 0x3;
+		if(sp1628_qctrl[5].default_value!=value){
+			sp1628_qctrl[5].default_value=value;
+			printk(" set camera  h filp =%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_VFLIP:    /* set flip on V. */         
+		break;
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		if(sp1628_qctrl[7].default_value!=value){
+			sp1628_qctrl[7].default_value=value;
+			//printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
+		}
+		break;
+	case V4L2_CID_ROTATE:
+		if(sp1628_qctrl[8].default_value!=value){
+			sp1628_qctrl[8].default_value=value;
+			printk(" set camera  rotate =%d. \n ",value);
+		}
+		break;
+	default:
+		ret=-1;
+		break;
+	}
+	return ret;
+
+}
+
+/*static void power_down_sp1628(struct sp1628_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	unsigned char buf[4];
+	buf[0]=0x1a;
+	buf[1]=0x17;
+	i2c_put_byte_add8(client,buf,2);
+	buf[0]=0x25;
+	buf[1]=0x00;
+	i2c_put_byte_add8(client,buf,2);
+	
+	msleep(5);
+	return;
+}*/
+
+/* ------------------------------------------------------------------
+	DMA and thread functions
+   ------------------------------------------------------------------*/
+
+#define TSTAMP_MIN_Y	24
+#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X	10
+#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
+
+static void sp1628_fillbuff(struct sp1628_fh *fh, struct sp1628_buffer *buf)
+{
+	struct sp1628_device *dev = fh->dev;
+	void *vbuf = videobuf_to_vmalloc(&buf->vb);
+	vm_output_para_t para = {0};
+	dprintk(dev,1,"%s\n", __func__);
+	if (!vbuf)
+		return;
+ /*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
+	para.mirror = sp1628_qctrl[5].default_value&3;// not set
+	para.v4l2_format = fh->fmt->fourcc;
+	para.v4l2_memory = 0x18221223;
+	para.zoom = sp1628_qctrl[7].default_value;
+	para.vaddr = (unsigned)vbuf;
+	para.angle = sp1628_qctrl[8].default_value;
+	vm_fill_buffer(&buf->vb,&para);
+	buf->vb.state = VIDEOBUF_DONE;
+}
+
+static void sp1628_thread_tick(struct sp1628_fh *fh)
+{
+	struct sp1628_buffer *buf;
+	struct sp1628_device *dev = fh->dev;
+	struct sp1628_dmaqueue *dma_q = &dev->vidq;
+
+	unsigned long flags = 0;
+
+	dprintk(dev, 1, "Thread tick\n");
+	if(!fh->stream_on){
+		dprintk(dev, 1, "sensor doesn't stream on\n");
+		return ;
+	}
+
+	spin_lock_irqsave(&dev->slock, flags);
+	if (list_empty(&dma_q->active)) {
+		dprintk(dev, 1, "No active queue to serve\n");
+		goto unlock;
+	}
+
+	buf = list_entry(dma_q->active.next,
+			 struct sp1628_buffer, vb.queue);
+        dprintk(dev, 1, "%s\n", __func__);
+        dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
+
+        if(!(fh->f_flags & O_NONBLOCK)){
+                /* Nobody is waiting on this buffer, return */
+                if (!waitqueue_active(&buf->vb.done))
+                        goto unlock;
+        }
+        buf->vb.state = VIDEOBUF_ACTIVE;
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+
+	/* Fill buffer */
+	spin_unlock_irqrestore(&dev->slock, flags);
+	sp1628_fillbuff(fh, buf);
+	dprintk(dev, 1, "filled buffer %p\n", buf);
+
+	wake_up(&buf->vb.done);
+	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+	return;
+unlock:
+	spin_unlock_irqrestore(&dev->slock, flags);
+	return;
+}
+
+#define frames_to_ms(frames)					\
+	((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+
+static void sp1628_sleep(struct sp1628_fh *fh)
+{
+	struct sp1628_device *dev = fh->dev;
+	struct sp1628_dmaqueue *dma_q = &dev->vidq;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
+		(unsigned long)dma_q);
+
+	add_wait_queue(&dma_q->wq, &wait);
+	if (kthread_should_stop())
+		goto stop_task;
+
+	/* Calculate time to wake up */
+	//timeout = msecs_to_jiffies(frames_to_ms(1));
+
+	sp1628_thread_tick(fh);
+
+	schedule_timeout_interruptible(2);//if fps > 25 , 2->1
+
+stop_task:
+	remove_wait_queue(&dma_q->wq, &wait);
+	try_to_freeze();
+}
+
+static int sp1628_thread(void *data)
+{
+	struct sp1628_fh  *fh = data;
+	struct sp1628_device *dev = fh->dev;
+
+	dprintk(dev, 1, "thread started\n");
+
+	set_freezable();
+
+	for (;;) {
+		sp1628_sleep(fh);
+
+		if (kthread_should_stop())
+			break;
+	}
+	dprintk(dev, 1, "thread: exit\n");
+	return 0;
+}
+
+static int sp1628_start_thread(struct sp1628_fh *fh)
+{
+	struct sp1628_device *dev = fh->dev;
+	struct sp1628_dmaqueue *dma_q = &dev->vidq;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	dma_q->kthread = kthread_run(sp1628_thread, fh, "sp1628");
+
+	if (IS_ERR(dma_q->kthread)) {
+		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+		return PTR_ERR(dma_q->kthread);
+	}
+	/* Wakes thread */
+	wake_up_interruptible(&dma_q->wq);
+
+	dprintk(dev, 1, "returning from %s\n", __func__);
+	return 0;
+}
+
+static void sp1628_stop_thread(struct sp1628_dmaqueue  *dma_q)
+{
+	struct sp1628_device *dev = container_of(dma_q, struct sp1628_device, vidq);
+
+	dprintk(dev, 1, "%s\n", __func__);
+	/* shutdown control thread */
+	if (dma_q->kthread) {
+		kthread_stop(dma_q->kthread);
+		dma_q->kthread = NULL;
+	}
+}
+
+/* ------------------------------------------------------------------
+	Videobuf operations
+   ------------------------------------------------------------------*/
+static int
+buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct sp1628_fh  *fh = vq->priv_data;
+	struct sp1628_device *dev  = fh->dev;
+    //int bytes = fh->fmt->depth >> 3 ;
+	*size = fh->width*fh->height*fh->fmt->depth >> 3;
+	if (0 == *count)
+		*count = 32;
+
+	while (*size * *count > vid_limit * 1024 * 1024)
+		(*count)--;
+
+	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+		*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct sp1628_buffer *buf)
+{
+	struct sp1628_fh  *fh = vq->priv_data;
+	struct sp1628_device *dev  = fh->dev;
+
+	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+
+	videobuf_waiton(vq, &buf->vb, 0, 0);
+	if (in_interrupt())
+		BUG();
+
+	videobuf_vmalloc_free(&buf->vb);
+	dprintk(dev, 1, "free_buffer: freed\n");
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+#define norm_maxw() 3000
+#define norm_maxh() 3000
+static int
+buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						enum v4l2_field field)
+{
+	struct sp1628_fh     *fh  = vq->priv_data;
+	struct sp1628_device    *dev = fh->dev;
+	struct sp1628_buffer *buf = container_of(vb, struct sp1628_buffer, vb);
+	int rc;
+    //int bytes = fh->fmt->depth >> 3 ;
+	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+
+	BUG_ON(NULL == fh->fmt);
+
+	if (fh->width  < 48 || fh->width  > norm_maxw() ||
+	    fh->height < 32 || fh->height > norm_maxh())
+		return -EINVAL;
+
+	buf->vb.size = fh->width*fh->height*fh->fmt->depth >> 3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+		return -EINVAL;
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = fh->fmt;
+	buf->vb.width  = fh->width;
+	buf->vb.height = fh->height;
+	buf->vb.field  = field;
+
+	//precalculate_bars(fh);
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0)
+			goto fail;
+	}
+
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void
+buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct sp1628_buffer    *buf  = container_of(vb, struct sp1628_buffer, vb);
+	struct sp1628_fh        *fh   = vq->priv_data;
+	struct sp1628_device       *dev  = fh->dev;
+	struct sp1628_dmaqueue *vidq = &dev->vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct sp1628_buffer   *buf  = container_of(vb, struct sp1628_buffer, vb);
+	struct sp1628_fh       *fh   = vq->priv_data;
+	struct sp1628_device      *dev  = (struct sp1628_device *)fh->dev;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops sp1628_video_qops = {
+	.buf_setup      = buffer_setup,
+	.buf_prepare    = buffer_prepare,
+	.buf_queue      = buffer_queue,
+	.buf_release    = buffer_release,
+};
+
+/* ------------------------------------------------------------------
+	IOCTL vidioc handling
+   ------------------------------------------------------------------*/
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct sp1628_fh  *fh  = priv;
+	struct sp1628_device *dev = fh->dev;
+
+	strcpy(cap->driver, "sp1628");
+	strcpy(cap->card, "sp1628");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+	cap->version = SP1628_CAMERA_VERSION;
+	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
+				V4L2_CAP_STREAMING     |
+				V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct sp1628_fmt *fmt;
+
+	if (f->index >= ARRAY_SIZE(formats))
+		return -EINVAL;
+
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+static int vidioc_enum_frameintervals(struct file *file, void *priv,
+                struct v4l2_frmivalenum *fival)
+{
+        unsigned int k;
+
+        if(fival->index > ARRAY_SIZE(sp1628_frmivalenum))
+                return -EINVAL;
+
+        for(k =0; k< ARRAY_SIZE(sp1628_frmivalenum); k++)
+        {
+                if( (fival->index==sp1628_frmivalenum[k].index)&&
+                                (fival->pixel_format ==sp1628_frmivalenum[k].pixel_format )&&
+                                (fival->width==sp1628_frmivalenum[k].width)&&
+                                (fival->height==sp1628_frmivalenum[k].height)){
+                        memcpy( fival, &sp1628_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
+                        return 0;
+                }
+        }
+
+        return -EINVAL;
+
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct sp1628_fh *fh = priv;
+
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vb_vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return (0);
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct sp1628_fh  *fh  = priv;
+	struct sp1628_device *dev = fh->dev;
+	struct sp1628_fmt *fmt;
+	enum v4l2_field field;
+	unsigned int maxw, maxh;
+
+	fmt = get_format(f);
+	if (!fmt) {
+		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+			f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	field = f->fmt.pix.field;
+
+	if (field == V4L2_FIELD_ANY) {
+		field = V4L2_FIELD_INTERLACED;
+	} else if (V4L2_FIELD_INTERLACED != field) {
+		dprintk(dev, 1, "Field type invalid.\n");
+		return -EINVAL;
+	}
+
+	maxw  = norm_maxw();
+	maxh  = norm_maxh();
+
+	f->fmt.pix.field = field;
+	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
+			      &f->fmt.pix.height, 32, maxh, 0, 0);
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+/*FIXME: This seems to be generic enough to be at videodev2 */
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct sp1628_fh *fh = priv;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&q->vb_lock);
+
+	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	fh->fmt           = get_format(f);
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+#if 1
+	if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
+		sp1628_set_resolution(fh->dev,fh->height,fh->width);
+	} else {
+		sp1628_set_resolution(fh->dev,fh->height,fh->width);
+	}
+#endif
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+                struct v4l2_streamparm *parms)
+{
+        struct sp1628_fh *fh = priv;
+        struct sp1628_device *dev = fh->dev;
+        struct v4l2_captureparm *cp = &parms->parm.capture;
+
+        dprintk(dev,3,"vidioc_g_parm\n");
+        if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+                return -EINVAL;
+
+        memset(cp, 0, sizeof(struct v4l2_captureparm));
+        cp->capability = V4L2_CAP_TIMEPERFRAME;
+
+        cp->timeperframe = sp1628_frmintervals_active;
+        printk("g_parm,deno=%d, numerator=%d\n", cp->timeperframe.denominator,
+                        cp->timeperframe.numerator );
+        return 0;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct sp1628_fh  *fh = priv;
+
+	return (videobuf_reqbufs(&fh->vb_vidq, p));
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct sp1628_fh  *fh = priv;
+
+	return (videobuf_querybuf(&fh->vb_vidq, p));
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct sp1628_fh *fh = priv;
+
+	return (videobuf_qbuf(&fh->vb_vidq, p));
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct sp1628_fh  *fh = priv;
+
+	return (videobuf_dqbuf(&fh->vb_vidq, p,
+				file->f_flags & O_NONBLOCK));
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct sp1628_fh  *fh = priv;
+
+	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
+}
+#endif
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct sp1628_fh  *fh = priv;
+	vdin_parm_t para;
+	int ret = 0 ;
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+
+	memset( &para, 0, sizeof( para ));
+	para.port  = TVIN_PORT_CAMERA;
+	para.fmt = TVIN_SIG_FMT_MAX;
+	para.frame_rate = sp1628_frmintervals_active.denominator;
+	para.h_active = sp1628_h_active;
+	para.v_active = sp1628_v_active;
+	para.hsync_phase = 0;
+	para.vsync_phase = 1;
+	para.hs_bp = 0;
+	para.vs_bp = 2;
+	para.cfmt = TVIN_YUV422;
+	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
+	para.skip_count =  2; //skip_num
+	printk("0308,h=%d, v=%d, frame_rate=%d\n",
+		sp1628_h_active, sp1628_v_active, sp1628_frmintervals_active.denominator);
+	ret =  videobuf_streamon(&fh->vb_vidq);
+	if(ret == 0){
+	    vops->start_tvin_service(0,&para);
+	    fh->stream_on        = 1;
+	}
+	return ret;
+}
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct sp1628_fh  *fh = priv;
+
+    int ret = 0 ;
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+	ret = videobuf_streamoff(&fh->vb_vidq);
+    if(ret == 0 ){
+        vops->stop_tvin_service(0);
+        fh->stream_on        = 0;
+    }
+	return ret;
+}
+
+static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsizeenum *fsize)
+{
+	int ret = 0,i=0;
+	struct sp1628_fmt *fmt = NULL;
+	struct v4l2_frmsize_discrete *frmsize = NULL;
+	for (i = 0; i < ARRAY_SIZE(formats); i++) {
+		if (formats[i].fourcc == fsize->pixel_format){
+			fmt = &formats[i];
+			break;
+		}
+	}
+	if (fmt == NULL)
+		return -EINVAL;
+	if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+		||(fmt->fourcc == V4L2_PIX_FMT_NV12)
+		||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
+		||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
+		){
+		if (fsize->index >= ARRAY_SIZE(sp1628_prev_resolution))
+			return -EINVAL;
+		frmsize = &sp1628_prev_resolution[fsize->index];
+		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+		fsize->discrete.width = frmsize->width;
+		fsize->discrete.height = frmsize->height;
+	}
+	else if(fmt->fourcc == V4L2_PIX_FMT_RGB24){
+		if (fsize->index >= ARRAY_SIZE(sp1628_pic_resolution))
+			return -EINVAL;
+		frmsize = &sp1628_pic_resolution[fsize->index];
+		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+		fsize->discrete.width = frmsize->width;
+		fsize->discrete.height = frmsize->height;
+	}
+	return ret;
+}
+
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+{
+	return 0;
+}
+
+/* only one input in this sample driver */
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	//if (inp->index >= NUM_INPUTS)
+		//return -EINVAL;
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->std = V4L2_STD_525_60;
+	sprintf(inp->name, "Camera %u", inp->index);
+
+	return (0);
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct sp1628_fh *fh = priv;
+	struct sp1628_device *dev = fh->dev;
+
+	*i = dev->input;
+
+	return (0);
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct sp1628_fh *fh = priv;
+	struct sp1628_device *dev = fh->dev;
+
+	//if (i >= NUM_INPUTS)
+		//return -EINVAL;
+
+	dev->input = i;
+	//precalculate_bars(fh);
+
+	return (0);
+}
+
+	/* --- controls ---------------------------------------------- */
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sp1628_qctrl); i++)
+		if (qc->id && qc->id == sp1628_qctrl[i].id) {
+			memcpy(qc, &(sp1628_qctrl[i]),
+				sizeof(*qc));
+			return (0);
+		}
+
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct sp1628_fh *fh = priv;
+	struct sp1628_device *dev = fh->dev;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sp1628_qctrl); i++)
+		if (ctrl->id == sp1628_qctrl[i].id) {
+			ctrl->value = dev->qctl_regs[i];
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct sp1628_fh *fh = priv;
+	struct sp1628_device *dev = fh->dev;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sp1628_qctrl); i++)
+		if (ctrl->id == sp1628_qctrl[i].id) {
+			if (ctrl->value < sp1628_qctrl[i].minimum ||
+			    ctrl->value > sp1628_qctrl[i].maximum ||
+			    sp1628_setting(dev,ctrl->id,ctrl->value)<0) {
+				return -ERANGE;
+			}
+			dev->qctl_regs[i] = ctrl->value;
+			return 0;
+		}
+	return -EINVAL;
+}
+
+/* ------------------------------------------------------------------
+	File operations for the device
+   ------------------------------------------------------------------*/
+
+static int sp1628_open(struct file *file)
+{
+	struct sp1628_device *dev = video_drvdata(file);
+	struct sp1628_fh *fh = NULL;
+	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 1);
+#endif	
+	aml_cam_init(&dev->cam_info);	
+	
+	SP1628_init_regs(dev);
+	msleep(100);//40
+	mutex_lock(&dev->mutex);
+	dev->users++;
+	if (dev->users > 1) {
+		dev->users--;
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	dprintk(dev, 1, "open %s type=%s users=%d\n",
+		video_device_node_name(dev->vdev),
+		v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+    	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	init_waitqueue_head(&dev->vidq.wq);
+	spin_lock_init(&dev->slock);
+	/* allocate + initialize per filehandle data */
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh) {
+		dev->users--;
+		retval = -ENOMEM;
+	}
+	mutex_unlock(&dev->mutex);
+
+	if (retval)
+		return retval;
+
+	wake_lock(&(dev->wake_lock));
+	file->private_data = fh;
+	fh->dev      = dev;
+
+	fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fh->fmt      = &formats[0];
+	fh->width    = 640;
+	fh->height   = 480;
+	fh->stream_on = 0 ;
+	fh->f_flags  = file->f_flags;
+	/* Resets frame counters */
+	dev->jiffies = jiffies;
+
+//    TVIN_SIG_FMT_CAMERA_640X480P_30Hz,
+//    TVIN_SIG_FMT_CAMERA_800X600P_30Hz,
+//    TVIN_SIG_FMT_CAMERA_1024X768P_30Hz, // 190
+//    TVIN_SIG_FMT_CAMERA_1920X1080P_30Hz,
+//    TVIN_SIG_FMT_CAMERA_1280X720P_30Hz,
+
+	videobuf_queue_vmalloc_init(&fh->vb_vidq, &sp1628_video_qops,
+			NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+			sizeof(struct sp1628_buffer), fh,NULL);
+
+	sp1628_start_thread(fh);
+
+	return 0;
+}
+
+static ssize_t
+sp1628_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct sp1628_fh *fh = file->private_data;
+
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+	}
+	return 0;
+}
+
+static unsigned int
+sp1628_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct sp1628_fh        *fh = file->private_data;
+	struct sp1628_device       *dev = fh->dev;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	dprintk(dev, 1, "%s\n", __func__);
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+		return POLLERR;
+
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int sp1628_close(struct file *file)
+{
+	struct sp1628_fh         *fh = file->private_data;
+	struct sp1628_device *dev       = fh->dev;
+	struct sp1628_dmaqueue *vidq = &dev->vidq;
+	struct video_device  *vdev = video_devdata(file);
+
+	sp1628_stop_thread(vidq);
+	videobuf_stop(&fh->vb_vidq);
+	if(fh->stream_on){
+	    vops->stop_tvin_service(0);
+	}
+	videobuf_mmap_free(&fh->vb_vidq);
+
+	kfree(fh);
+
+	mutex_lock(&dev->mutex);
+	dev->users--;
+	mutex_unlock(&dev->mutex);
+
+	dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+		video_device_node_name(vdev), dev->users);
+#if 1
+	sp1628_qctrl[0].default_value=0;
+	sp1628_qctrl[1].default_value=4;
+	sp1628_qctrl[2].default_value=0;
+	sp1628_qctrl[3].default_value= CAM_BANDING_50HZ;
+	sp1628_qctrl[4].default_value=0;
+
+	sp1628_qctrl[5].default_value=0;
+	sp1628_qctrl[7].default_value=100;
+	sp1628_qctrl[8].default_value=0;
+
+	sp1628_frmintervals_active.numerator = 1;
+	sp1628_frmintervals_active.denominator = 15;
+	//power_down_sp1628(dev);
+#endif
+	aml_cam_uninit(&dev->cam_info);
+	
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 0);
+#endif	
+	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
+	return 0;
+}
+
+static int sp1628_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct sp1628_fh  *fh = file->private_data;
+	struct sp1628_device *dev = fh->dev;
+	int ret;
+
+	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+
+	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+		ret);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations sp1628_fops = {
+	.owner		= THIS_MODULE,
+	.open           = sp1628_open,
+	.release        = sp1628_close,
+	.read           = sp1628_read,
+	.poll		= sp1628_poll,
+	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+	.mmap           = sp1628_mmap,
+};
+
+static const struct v4l2_ioctl_ops sp1628_ioctl_ops = {
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_querymenu     = vidioc_querymenu,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+	.vidioc_enum_framesizes = vidioc_enum_framesizes,
+	.vidioc_g_parm = vidioc_g_parm,
+	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf          = vidiocgmbuf,
+#endif
+};
+
+static struct video_device sp1628_template = {
+	.name		= "sp1628_v4l",
+	.fops           = &sp1628_fops,
+	.ioctl_ops 	= &sp1628_ioctl_ops,
+	.release	= video_device_release,
+
+	.tvnorms              = V4L2_STD_525_60,
+	.current_norm         = V4L2_STD_NTSC_M,
+};
+
+static int sp1628_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SP1628, 0);
+}
+
+static const struct v4l2_subdev_core_ops sp1628_core_ops = {
+	.g_chip_ident = sp1628_g_chip_ident,
+};
+
+static const struct v4l2_subdev_ops sp1628_ops = {
+	.core = &sp1628_core_ops,
+};
+
+static int sp1628_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	aml_cam_info_t* plat_dat;
+	int err;
+	struct sp1628_device *t;
+	struct v4l2_subdev *sd;
+    vops = get_vdin_v4l2_ops();
+	v4l_info(client, "chip found @ 0x%x (%s)\n",
+			client->addr << 1, client->adapter->name);
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (t == NULL)
+		return -ENOMEM;
+	sd = &t->sd;
+	v4l2_i2c_subdev_init(sd, client, &sp1628_ops);
+
+	plat_dat = (aml_cam_info_t*)client->dev.platform_data;
+	
+	/* Now create a video4linux device */
+	mutex_init(&t->mutex);
+
+	/* Now create a video4linux device */
+	t->vdev = video_device_alloc();
+	if (t->vdev == NULL) {
+		kfree(t);
+		kfree(client);
+		return -ENOMEM;
+	}
+	memcpy(t->vdev, &sp1628_template, sizeof(*t->vdev));
+
+	video_set_drvdata(t->vdev, t);
+
+	wake_lock_init(&(t->wake_lock), WAKE_LOCK_SUSPEND, "sp1628");
+	
+	/* Register it */
+	if (plat_dat) {
+		memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
+		if (plat_dat->front_back >=0)  
+			video_nr = plat_dat->front_back;
+	} else {
+		printk("camera sp1628: have no platform data\n");
+		kfree(t);
+		kfree(client);
+		return -1;
+	}
+	err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (err < 0) {
+		video_device_release(t->vdev);
+		kfree(t);
+		return err;
+	}
+
+	return 0;
+}
+
+static int sp1628_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct sp1628_device *t = to_dev(sd);
+
+	video_unregister_device(t->vdev);
+	v4l2_device_unregister_subdev(sd);
+	wake_lock_destroy(&(t->wake_lock));
+	kfree(t);
+	return 0;
+}
+
+static const struct i2c_device_id sp1628_id[] = {
+	{ "sp1628", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sp1628_id);
+
+static struct i2c_driver sp1628_i2c_driver = {
+	.driver = {
+		.name = "sp1628",
+	},
+	.probe = sp1628_probe,
+	.remove = sp1628_remove,
+	.id_table = sp1628_id,
+};
+
+module_i2c_driver(sp1628_i2c_driver);
+
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index 1613dcc8942e..2b5e1727045d 100755
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -86,9 +86,15 @@ enum {
         /* AR0833  */
         V4L2_IDENT_AR0833 = 40,
 
-	  /* HM20057  */
+	  /* HM2057  */
      V4L2_IDENT_HM2057 = 41,
 
+     /* HM5065  */
+     V4L2_IDENT_HM5065 = 42,
+
+	 /* SP1628  */
+     V4L2_IDENT_SP1628 = 43,
+
 	/* module tvaudio: reserved range 50-99 */
 	V4L2_IDENT_TVAUDIO = 50,	/* A tvaudio chip, unknown which it is exactly */
 
-- 
2.19.0

