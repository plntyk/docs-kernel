From 8faaca456f7bc92eeedb70819d072221751eaf2d Mon Sep 17 00:00:00 2001
From: "yu.zheng" <yu.zheng@amlogic.com>
Date: Thu, 16 Jan 2014 14:35:38 +0800
Subject: [PATCH 3070/5965] PD# 86367: HDMI CEC: M8 cec driver arch modified.

---
 arch/arm/mach-meson6/hdmi_tx_hw/Makefile      |    2 +-
 .../mach-meson6/hdmi_tx_hw/hdmi_tx_cec_hw.c   |  278 +++
 arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c  |    3 +-
 arch/arm/mach-meson8/hdmi_tx_hw/Makefile      |    2 +-
 .../mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c   |  336 +++
 arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c  |    3 +-
 arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c |   38 +
 .../include/mach}/hdmi_parameter.h            |    0
 .../mach-meson8/include/mach/hdmi_tx_reg.h    |    3 +
 drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c   |   78 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c        |    7 +-
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c    | 1808 +++++------------
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c   |   11 -
 .../amlogic/input/new_remote/remote_func.c    |   20 +
 drivers/amlogic/input/remote/am_remote.c      |   10 +-
 .../linux/amlogic}/hdmi_tx/hdmi_tx_cec.h      |  103 +-
 16 files changed, 1310 insertions(+), 1392 deletions(-)
 create mode 100755 arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_cec_hw.c
 create mode 100755 arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c
 rename {drivers/amlogic/hdmi/hdmi_tx => arch/arm/mach-meson8/include/mach}/hdmi_parameter.h (100%)
 mode change 100644 => 100755
 rename {drivers/amlogic/hdmi => include/linux/amlogic}/hdmi_tx/hdmi_tx_cec.h (90%)

diff --git a/arch/arm/mach-meson6/hdmi_tx_hw/Makefile b/arch/arm/mach-meson6/hdmi_tx_hw/Makefile
index ffa592f8ba00..64b17e5a7a9d 100644
--- a/arch/arm/mach-meson6/hdmi_tx_hw/Makefile
+++ b/arch/arm/mach-meson6/hdmi_tx_hw/Makefile
@@ -1 +1 @@
-obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o
+obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o hdmi_tx_cec_hw.o
diff --git a/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_cec_hw.c b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_cec_hw.c
new file mode 100755
index 000000000000..866b37ba3579
--- /dev/null
+++ b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_cec_hw.c
@@ -0,0 +1,278 @@
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+#include <mach/hdmi_tx_reg.h>
+#include <mach/hdmi_parameter.h> 
+
+static DEFINE_MUTEX(cec_mutex);
+
+extern int cec_msg_dbg_en;
+void cec_disable_irq(void)
+{
+    //Disable irq
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));
+    //Clear the interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));
+    hdmi_print(INF, CEC "disable:int mask:0x%x\n", aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK));
+}
+void cec_enable_irq(void)
+{
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) & ~(1 << 23));
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));
+
+    hdmi_print(INF, CEC "enable:int mask:0x%x\n", aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK));
+}
+
+void cec_hw_reset(void)
+{
+    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
+    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0xc); //[3]cec_creg_sw_rst [2]cec_sys_sw_rst
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x1);
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x1);
+    
+    //mdelay(10);
+    {//Delay some time
+        int i = 10;
+        while(i--);
+    }
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x0);
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x0);
+    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0x0);
+    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)&(~(1<<16)));
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
+
+    hdmi_print(INF, CEC "hw reset :logical addr:0x%x\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
+}
+
+
+int cec_ll_rx( unsigned char *msg, unsigned char *len)
+{
+    unsigned char i;
+    unsigned char rx_status;
+    unsigned char data;
+    unsigned char msg_log_buf[128];
+    int pos;
+    unsigned char n;
+    unsigned char *msg_start = msg;
+    int rx_msg_length;
+
+    if(RX_DONE != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS)){
+        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+
+    if(1 != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_NUM_MSG)){
+        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+    
+    rx_msg_length = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_MSG_LENGTH) + 1;
+
+    hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+
+    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
+        data = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_MSG_0_HEADER +i);
+        *msg = data;
+        msg++;
+    }
+    *len = rx_msg_length;
+    rx_status = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS);
+
+    hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
+
+    if(cec_msg_dbg_en  == 1){
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
+        for(n = 0; n < rx_msg_length; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg_start[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        hdmi_print(INF, CEC "%s", msg_log_buf);
+    }
+    return rx_status;
+}
+
+
+/*************************** cec arbitration cts code ******************************/
+// using the cec pin as fiq gpi to assist the bus arbitration
+static unsigned char msg_log_buf[128] = { 0 };
+// return value: 1: successful      0: error
+static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+    unsigned int cnt = 30;
+    int pos;
+
+    for (i = 0; i < len; i++) {
+        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
+    //cec_tx_start = 1;
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, RX_ACK_CURRENT);//TX_REQ_NEXT
+    msleep(len * 24 + 5);
+
+    ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
+
+    if(ret == TX_DONE)
+        ret = 1;
+    else
+        ret = 0;
+
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
+
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+
+        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
+
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+	unsigned int j = 30;
+    int pos;
+
+    for (i = 0; i < len; i++) {
+     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
+    //cec_tx_start = 1;
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, RX_ACK_CURRENT);//TX_REQ_NEXT
+    msleep(len * 24 + 5);
+
+    ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
+
+    if(ret == TX_DONE)
+        ret = 1;
+    else
+        ret = 0;
+
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
+
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+
+void tx_irq_handle(void){
+
+}
+
+// Return value: 0: fail    1: success
+int cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int ret = 0;
+    int repeat = 0;
+    int i;
+
+    mutex_lock(&cec_mutex);
+    
+    //if transmit message error, try repeat(4) times
+    do {
+        ret = cec_ll_tx_once(msg, len);
+        repeat ++;
+        if(repeat > 1)
+            cec_hw_reset();
+    } while((ret == 0) && (repeat < 3));
+
+    cec_msg_dbg_en  ? hdmi_print(INF, CEC "tx: ret = %d\n", ret) : 0;
+    if(repeat > 1) {
+        hdmi_print(INF, CEC "tx: try %d times\n", repeat);
+    }
+    mutex_unlock(&cec_mutex);
+    return ret;
+}
+
+static void cec_gpi_init(void)
+{
+    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+        aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq.
+        hdmi_print(INF, CEC "TX FIQ return.\n");
+        return;
+    }
+    if(cec_global_info.cec_fiq_flag){ //This function run only once.
+        return;
+    }
+    cec_global_info.cec_fiq_flag = 1;
+    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 0, 0, 1);     // disable irq
+    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
+
+    aml_set_reg32_bits(P_GPIO_INTR_GPIO_SEL0, 0x76, 0, 8);      // set GPIOC_23 as GPIO IRQ #0 source
+    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge
+    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 16, 1);
+    request_fiq(INT_GPIO_0, &cec_gpi_receive_bits);
+    hdmi_print(INF, CEC "tx: register fiq\n");
+
+    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
+}
+
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+    unsigned long r;
+    unsigned char msg[1];
+
+    cec_global_info.my_node_index = log_addr;
+    msg[0] = (log_addr<<4) | log_addr;
+
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    r = cec_ll_tx(msg, 1);
+
+    if (r == 0) {
+        *bool = 0;
+    }else{
+        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
+        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+    	  *bool = 1;
+    }
+    if(*bool == 0) {
+        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
+    }
+    hdmi_print(INF, CEC "CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
+
+}
+
+// DELETE LATER, TEST ONLY
+void cec_test_(unsigned int cmd)
+{
+    
+}
\ No newline at end of file
diff --git a/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c
index d3ff0b9f1f58..8f14b88856e8 100644
--- a/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c
+++ b/arch/arm/mach-meson6/hdmi_tx_hw/hdmi_tx_hw.c
@@ -44,8 +44,9 @@
 
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
 #if 0   //todo
-#include "../hdmi_tx_cec.h"
 #include "../hdmi_tx_hdcp.h"
 #include "../hdmi_tx_compliance.h"
 #endif
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/Makefile b/arch/arm/mach-meson8/hdmi_tx_hw/Makefile
index ffa592f8ba00..64b17e5a7a9d 100644
--- a/arch/arm/mach-meson8/hdmi_tx_hw/Makefile
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/Makefile
@@ -1 +1 @@
-obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o
+obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o hdmi_tx_cec_hw.o
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c
new file mode 100755
index 000000000000..4a99a94732ff
--- /dev/null
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c
@@ -0,0 +1,336 @@
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+#include <mach/hdmi_tx_reg.h>
+#include <mach/hdmi_parameter.h> 
+
+static DEFINE_MUTEX(cec_mutex);
+
+extern int cec_msg_dbg_en;
+void cec_disable_irq(void)
+{
+    // disable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 0, 3);
+    hdmi_print(INF, CEC "disable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+}
+void cec_enable_irq(void)
+{
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+    hdmi_print(INF, CEC "enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+}
+
+void cec_hw_reset(void)
+{
+    //unsigned long data32;
+    // Assert SW reset AO_CEC
+    //data32  = 0;
+    //data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    //data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    // Enable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
+
+    //Cec arbitration 3/5/7 bit time set.
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+
+    hdmi_print(INF, CEC "hw reset :logical addr:0x%x\n", aocec_rd_reg(CEC_LOGICAL_ADDR0));
+
+}
+
+int cec_ll_rx( unsigned char *msg, unsigned char *len)
+{
+    unsigned char i;
+    unsigned char rx_status;
+    unsigned char data;
+    unsigned char msg_log_buf[128];
+    int pos;
+    unsigned char n;
+    unsigned char *msg_start = msg;
+    int rx_msg_length;
+
+    if(RX_DONE != aocec_rd_reg(CEC_RX_MSG_STATUS)){
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+    if(1 != aocec_rd_reg(CEC_RX_NUM_MSG)){
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+    rx_msg_length = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
+
+    aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+
+    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
+        data = aocec_rd_reg(CEC_RX_MSG_0_HEADER +i);
+        *msg = data;
+        msg++;
+    }
+    *len = rx_msg_length;
+    rx_status = aocec_rd_reg(CEC_RX_MSG_STATUS);
+
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
+
+    if(cec_msg_dbg_en  == 1){
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
+        for(n = 0; n < rx_msg_length; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg_start[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        hdmi_print(INF, CEC "%s", msg_log_buf);
+    }
+    return rx_status;
+}
+
+
+/*************************** cec arbitration cts code ******************************/
+// using the cec pin as fiq gpi to assist the bus arbitration
+static unsigned char msg_log_buf[128] = { 0 };
+// return value: 1: successful      0: error
+static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+    unsigned int cnt = 30;
+    int pos;
+
+    while(aocec_rd_reg(CEC_TX_MSG_STATUS) || aocec_rd_reg(CEC_RX_MSG_STATUS)){
+        msleep(5);
+        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            //cec_hw_reset();
+            break;
+        }
+        if(!(cnt--)){
+            hdmi_print(INF, CEC "tx busy time out.\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        }
+    }
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+	unsigned int j = 30;
+    int pos;
+
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 1, 1);
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+    while((TX_DONE != aocec_rd_reg(CEC_TX_MSG_STATUS)) && (j--)){
+		msleep(5);
+	}
+
+    ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
+
+    if(ret == TX_DONE)
+        ret = 1;
+    else
+        ret = 0;
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 1, 1, 1);
+
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+void tx_irq_handle(void){
+    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    switch(tx_status){
+    case TX_DONE:
+      aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+      break;
+    case TX_BUSY:
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        break;
+    case TX_ERROR:
+        cec_hw_reset();
+        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        break;
+    default:
+        break;
+    }
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 1));
+    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) | (1 << 2));
+
+}
+
+// Return value: 0: fail    1: success
+int cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int ret = 0;
+    
+    mutex_lock(&cec_mutex);
+    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) & ~(1 << 2));
+    cec_ll_tx_once(msg, len);
+
+    mutex_unlock(&cec_mutex);
+    
+    return ret;
+}
+
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+    unsigned long r;
+    unsigned char msg[1];
+
+    cec_global_info.my_node_index = log_addr;
+    msg[0] = (log_addr<<4) | log_addr;
+
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    hdmi_print(INF, CEC "CEC_LOGICAL_ADDR0:0x%lx\n",aocec_rd_reg(CEC_LOGICAL_ADDR0));
+    r = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
+
+    if (r == 0) {
+        *bool = 0;
+    }else{
+        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
+        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+    	  *bool = 1;
+    }
+    if(*bool == 0) {
+        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
+    }
+    hdmi_print(INF, CEC "CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
+
+}
+
+
+//--------------------------------------------------------------------------
+// AO CEC0 config
+//--------------------------------------------------------------------------
+void ao_cec_init(void)
+{
+    unsigned long data32;
+    // Assert SW reset AO_CEC
+    data32  = 0;
+    data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, data32);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    // Enable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+
+    // Device 0 config
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+}
+
+
+void cec_arbit_bit_time_read(void){//11bit:bit[10:0]
+    //3 bit
+    hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+    //5 bit
+    hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+    //7 bit
+    hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+}
+
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag){//11bit:bit[10:0]
+    if(flag)
+        hdmi_print(INF, CEC "bit_set:0x%x;time_set:0x%x \n", bit_set, time_set);
+    switch(bit_set){
+    case 3:
+        //3 bit
+        if(flag)
+            hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
+        if(flag)
+            hdmi_print(INF, CEC "write 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+        break;
+        //5 bit
+    case 5:
+        if(flag)
+            hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
+        if(flag)
+            hdmi_print(INF, CEC "write 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        //7 bit
+	case 7:
+        if(flag)
+            hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
+        if(flag)
+            hdmi_print(INF, CEC "write 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+        break;
+    default:
+        break;
+    }
+}
+
+// DELETE LATER, TEST ONLY
+void cec_test_(unsigned int cmd)
+{
+    
+}
\ No newline at end of file
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c
index 46ed75ddc1e4..ebbef85f2798 100644
--- a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_hw.c
@@ -44,8 +44,9 @@
 
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
 #if 0   //todo
-#include "../hdmi_tx_cec.h"
 #include "../hdmi_tx_hdcp.h"
 #include "../hdmi_tx_compliance.h"
 #endif
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c
index 8d765b938549..4e9e8bfc2c85 100644
--- a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_reg.c
@@ -32,6 +32,7 @@
 
 #include <mach/hdmi_tx_reg.h>
 static DEFINE_SPINLOCK(reg_lock);
+static DEFINE_SPINLOCK(reg_lock2);
 // if the following bits are 0, then access HDMI IP Port will cause system hungup
 #define GATE_NUM    2
 Hdmi_Gate_s hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
@@ -84,3 +85,40 @@ void hdmi_wr_reg(unsigned int addr, unsigned int data)
     raw_local_irq_restore(fiq_flag);
     spin_unlock_irqrestore(&reg_lock, flags);
 }
+
+#ifdef CONFIG_ARCH_MESON8
+#define waiting_aocec_free()    while(aml_read_reg32(P_AO_CEC_RW_REG) & (1<<23))
+unsigned long aocec_rd_reg (unsigned long addr)
+{
+    unsigned long data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&reg_lock2, flags);
+    data32  = 0;
+    data32 |= 0     << 16;  // [16]     cec_reg_wr
+    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+
+    waiting_aocec_free();
+    data32 = ((aml_read_reg32(P_AO_CEC_RW_REG)) >> 24) & 0xff;
+    spin_unlock_irqrestore(&reg_lock2, flags);
+    return (data32);
+} /* aocec_rd_reg */
+
+void aocec_wr_reg (unsigned long addr, unsigned long data)
+{
+    unsigned long data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&reg_lock2, flags);
+    data32  = 0;
+    data32 |= 1     << 16;  // [16]     cec_reg_wr
+    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+    spin_unlock_irqrestore(&reg_lock2, flags);
+    waiting_aocec_free();
+    //waiting_aocec_free();
+} /* aocec_wr_only_reg */
+#endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h b/arch/arm/mach-meson8/include/mach/hdmi_parameter.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/amlogic/hdmi/hdmi_tx/hdmi_parameter.h
rename to arch/arm/mach-meson8/include/mach/hdmi_parameter.h
diff --git a/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h b/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h
index 65ebaa95ad5f..96f6919272a4 100644
--- a/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h
+++ b/arch/arm/mach-meson8/include/mach/hdmi_tx_reg.h
@@ -29,6 +29,9 @@ void hdmi_wr_reg(unsigned int addr, unsigned int data);
 #define hdmi_set_reg_bits(reg, val, start, len) \
   hdmi_wr_reg(reg, (hdmi_rd_reg(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
 
+unsigned long aocec_rd_reg(unsigned long addr);
+void aocec_wr_reg(unsigned long addr, unsigned long data);
+
 typedef struct {
     unsigned short cbus_addr;
     unsigned char gate_bit;
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
index 732cb2de1845..0762be0a90e1 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
@@ -31,14 +31,11 @@
 #include <linux/amlogic/tvin/tvin.h>
 
 #include <mach/gpio.h>
-
+#include <mach/hdmi_tx_reg.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
-#include "hdmi_tx_cec.h"
-
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
 hdmitx_dev_t *hdmitx_device = NULL;
 
-unsigned int cec_key_flag =0;
-
 __u16 cec_key_map[128] = {
     KEY_SELECT, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
     0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
@@ -49,14 +46,14 @@ __u16 cec_key_map[128] = {
     0 , 0, 0, 0, 0, 0, 0, 0,//0x30
     0 , 0, 0, 0, 0, 0, 0, 0,
     
-    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, 0,//0x40
-    KEY_REWIND, KEY_FASTFORWARD, 0, KEY_PREVIOUSSONG, KEY_NEXTSONG, 0, 0, 0,
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
     0 , 0, 0, 0, 0, 0, 0, 0,//0x50
     0 , 0, 0, 0, 0, 0, 0, 0,
     KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
     0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
     0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
-    0 , 0, 0, 0, 0, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
 };
 
 void cec_send_event(cec_rx_message_t* pcec_message)
@@ -80,20 +77,18 @@ void cec_send_event(cec_rx_message_t* pcec_message)
     
     for (i = 0; i < operand_num; i++ ) {
        operands[i] = pcec_message->content.msg.operands[i]; 
-       hdmitx_cec_dbg_print("CEC:operands[%d]:%u\n", i, operands[i]);       
+       hdmi_print(INF, CEC  ":operands[%d]:%u\n", i, operands[i]);       
     }
-    if(cec_key_flag) {
-        input_event(remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
-        input_sync(remote_cec_dev);
-        hdmitx_cec_dbg_print("CEC:cec_key_map[operands[0]]:%d\n",cec_key_map[operands[0]]);
+    if(cec_global_info.cec_flag.cec_key_flag) {
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
     }
     else{
-        input_event(remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
-        input_sync(remote_cec_dev);
-        hdmitx_cec_dbg_print("CEC:cec_key_map[operands[0]]:%d\n",cec_key_map[operands[0]]);
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
     }   
-
-    hdmitx_cec_dbg_print("CEC:cec_send_event\n");
 }
 
 
@@ -103,16 +98,17 @@ void cec_send_event_irq(void)
     unsigned char   operand_num_irq;
     unsigned char operands_irq[14];
          
-    operand_num_irq = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num;
+    operand_num_irq = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
     for (i = 0; i < operand_num_irq; i++ )
     {
-        operands_irq[i] = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.operands[i]; 
-        hdmitx_cec_dbg_print("CEC:operands_irq[%d]:0x%x\n", i, operands_irq[i]);       
+        operands_irq[i] = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[i]; 
+        hdmi_print(INF, CEC  ":operands_irq[%d]:0x%x\n", i, operands_irq[i]);       
     }
     
-    switch(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
+    switch(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
     case 0x33:
-        cec_system_audio_mode_request();
+        //cec_system_audio_mode_request();
+        //cec_set_system_audio_mode();
         break;
     case 0x35:
         break;
@@ -120,37 +116,35 @@ void cec_send_event_irq(void)
         break;      
     }	
     
-    input_event(remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 1);
-    input_sync(remote_cec_dev);	
-    input_event(remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
-    input_sync(remote_cec_dev);
-    hdmitx_cec_dbg_print("CEC:cec_key_map[operands_irq[0]]:%d\n",cec_key_map[operands_irq[0]]);       		
-   	
-    hdmitx_cec_dbg_print("CEC:cec_send_event_irq\n");  	 	
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 1);
+    input_sync(cec_global_info.remote_cec_dev);	
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
+    input_sync(cec_global_info.remote_cec_dev);
+    hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands_irq[0]]);      		  	 	
 }
 
 void cec_user_control_pressed_irq(void)
 {
-    hdmitx_cec_dbg_print("CEC Key pressed \n");
+    hdmi_print(INF, CEC  ": Key pressed \n");
     cec_send_event_irq();
 }
 
 void cec_user_control_released_irq(void)  
 {
-    hdmitx_cec_dbg_print("CEC Key released \n");
-}
+    hdmi_print(INF, CEC  ": Key released \n");
+} 
 
 void cec_user_control_pressed(cec_rx_message_t* pcec_message)
 {
-    printk("\nCEC Key pressed \n");
-    cec_key_flag = 1;
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
     cec_send_event(pcec_message);
 }
 
 void cec_user_control_released(cec_rx_message_t* pcec_message)  
 {
-    printk("\nCEC Key released \n");
-    cec_key_flag = 1;
+    hdmi_print(INF, CEC  ": Key released \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
     cec_send_event(pcec_message);
 }
 
@@ -162,11 +156,11 @@ void cec_standby(cec_rx_message_t* pcec_message)
 {
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
-            printk("CEC: System will be in standby mode\n");
-            input_event(remote_cec_dev, EV_KEY, KEY_POWER, 1);
-            input_sync(remote_cec_dev);
-            input_event(remote_cec_dev, EV_KEY, KEY_POWER, 0);
-            input_sync(remote_cec_dev);
+            hdmi_print(INF, CEC  ": System will be in standby mode\n");
+            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 1);
+            input_sync(cec_global_info.remote_cec_dev);
+            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 0);
+            input_sync(cec_global_info.remote_cec_dev);
         }
     }
 }
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 3547dd99f8a0..f01253fea716 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -47,8 +47,8 @@
 
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
 
-#include "hdmi_tx_cec.h"
 #define DEVICE_NAME "amhdmitx"
 #define HDMI_TX_COUNT 32
 #define HDMI_TX_POOL_NUM  6
@@ -1184,7 +1184,6 @@ edid_op:
             hdmitx_edid_clear(hdmitx_device);
             //When unplug hdmi, clear the hdmitx module edid ram and edid buffer.
             hdmitx_edid_ram_buffer_clear(hdmitx_device);
-            cec_node_uninit(hdmitx_device);
             if(hdmitx_device->unplug_powerdown){
                 hdmitx_set_display(hdmitx_device, HDMI_Unkown);
                 if(hdmitx_device->HWOp.Cntl){
@@ -1203,6 +1202,10 @@ edid_op:
                 hdmi_hdcp_reset = 1;
             }
             switch_set_state(&hdcp_dev, 0);
+#ifdef CONFIG_ARCH_MESON6
+
+            aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear int for cec fiq.
+#endif
         }
 #if 0
         /* authentication process */
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index 833b75b5cfd0..3516db8d39dc 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -41,6 +41,7 @@
 #include <linux/spinlock.h>
 #include <linux/spinlock_types.h>
 #include <linux/switch.h>
+#include <linux/workqueue.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -52,34 +53,19 @@
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 #include <mach/hdmi_tx_reg.h>
-#include "hdmi_tx_cec.h"
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+#include <mach/hdmi_parameter.h>
 
-//static void remote_cec_tasklet(unsigned long);
-//static int REMOTE_CEC_IRQ = INT_REMOTE;
-//DECLARE_TASKLET_DISABLED(tasklet_cec, remote_cec_tasklet, 0);
-static hdmitx_dev_t *hdmitx_device = NULL;
-struct input_dev *remote_cec_dev;
-DEFINE_SPINLOCK(cec_input_key);
-DEFINE_SPINLOCK(cec_rx_lock);
-DEFINE_SPINLOCK(cec_tx_lock);
-DEFINE_SPINLOCK(cec_init_lock); 
-static DECLARE_WAIT_QUEUE_HEAD(cec_key_poll);
+static hdmitx_dev_t* hdmitx_device = NULL;
 
-//#define _RX_DATA_BUF_SIZE_ 6
+DEFINE_SPINLOCK(cec_input_key);
 
 /* global variables */
 static    unsigned char    gbl_msg[MAX_MSG];
 cec_global_info_t cec_global_info;
-unsigned char cec_power_flag = 0;
-unsigned char cec_tx_flag = 0;
-unsigned char cec_rx_flag = 0;
-EXPORT_SYMBOL(cec_power_flag);
 unsigned char rc_long_press_pwr_key = 0;
 EXPORT_SYMBOL(rc_long_press_pwr_key);
-static bool cec_msg_dbg_en = 0; 
-static unsigned char test_buf[128] = { 0 };
-static int cec_fiq_flag = 0;
-static void cec_gpi_receive_bits(void);
+int cec_msg_dbg_en = 0;
 
 ssize_t    cec_lang_config_state(struct switch_dev *sdev, char *buf){
     int pos=0;
@@ -95,19 +81,11 @@ struct switch_dev lang_dev = {    // android ics switch device
     };
 EXPORT_SYMBOL(lang_dev);
 
-static struct semaphore  tv_cec_sema;
-
 static DEFINE_SPINLOCK(p_tx_list_lock);
-//static DEFINE_SPINLOCK(cec_tx_lock);
-
 static unsigned long cec_tx_list_flags;
-//static unsigned long cec_tx_flags;
 static unsigned int tx_msg_cnt = 0;
-
 static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
 
-//static tv_cec_polling_state_e cec_polling_state = TV_CEC_POLLING_OFF;
-
 unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
                                   (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
                                   (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
@@ -120,111 +98,23 @@ unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')
 static unsigned char * osd_name = "Amlogic MBox";
 static unsigned int vendor_id = 0x00;
 
-cec_rx_msg_buf_t cec_rx_msg_buf;
-
 static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
+#ifdef CONFIG_ARCH_MESON6
 static void cec_gpi_init(void);
-
-//static unsigned char dev = 0;
-static unsigned char cec_init_flag = 0;
-static unsigned char cec_mutex_flag = 0;
-
-
-//static unsigned int hdmi_rd_reg(unsigned long addr);
-//static void hdmi_wr_reg(unsigned long addr, unsigned long data);
-
-void cec_test_function(unsigned char* arg, unsigned char arg_cnt)
-{
-//    int i;
-//    char buf[512];
-//
-//    switch (arg[0]) {
-//    case 0x0:
-//        cec_usrcmd_parse_all_dev_online();
-//        break;
-//    case 0x2:
-//        cec_usrcmd_get_audio_status(arg[1]);
-//        break;
-//    case 0x3:
-//        cec_usrcmd_get_deck_status(arg[1]);
-//        break;
-//    case 0x4:
-//        cec_usrcmd_get_device_power_status(arg[1]);
-//        break;
-//    case 0x5:
-//        cec_usrcmd_get_device_vendor_id(arg[1]);
-//        break;
-//    case 0x6:
-//        cec_usrcmd_get_osd_name(arg[1]);
-//        break;
-//    case 0x7:
-//        cec_usrcmd_get_physical_address(arg[1]);
-//        break;
-//    case 0x8:
-//        cec_usrcmd_get_system_audio_mode_status(arg[1]);
-//        break;
-//    case 0x9:
-//        cec_usrcmd_get_tuner_device_status(arg[1]);
-//        break;
-//    case 0xa:
-//        cec_usrcmd_set_deck_cnt_mode(arg[1], arg[2]);
-//        break;
-//    case 0xc:
-//        cec_usrcmd_set_imageview_on(arg[1]);
-//        break;
-//    case 0xd:
-//        cec_usrcmd_set_play_mode(arg[1], arg[2]);
-//        break;
-//    case 0xe:
-//        cec_usrcmd_get_menu_state(arg[1]);
-//        break;
-//    case 0xf:
-//        cec_usrcmd_set_menu_state(arg[1], arg[2]);
-//        break;
-//    case 0x10:
-//        cec_usrcmd_get_global_info(buf);
-//        break;
-//    case 0x11:
-//        cec_usrcmd_get_menu_language(arg[1]);
-//        break;
-//    case 0x12:
-//        cec_usrcmd_set_menu_language(arg[1], arg[2]);
-//        break;
-//    case 0x13:
-//        cec_usrcmd_get_active_source();
-//        break;
-//    case 0x14:
-//        cec_usrcmd_set_active_source();
-//        break;
-//    case 0x15:
-//        cec_usrcmd_set_deactive_source(arg[1]);
-//        break;
-//    case 0x17:
-//        cec_usrcmd_set_report_physical_address(arg[1], arg[2], arg[3], arg[4]);
-//        break;
-//    case 0x18:
-//        {int i = 0;
-//        cec_polling_online_dev(arg[1], &i);
-//        }
-//        break;
-//    default:
-//        break;
-//    }
-}
+#endif
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend hdmitx_cec_early_suspend_handler;
 static void hdmitx_cec_early_suspend(struct early_suspend *h)
 {
-//    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
-    //cec_node_uninit((hdmitx_dev_t *)h->param);
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         cec_menu_status_smp(DEVICE_MENU_INACTIVE);
         cec_inactive_source();
 
         if(rc_long_press_pwr_key == 1) {
             cec_set_standby();
+            msleep(100);
             hdmi_print(INF, CEC "get power-off command from Romote Control\n");
             rc_long_press_pwr_key = 0;
         }
@@ -233,8 +123,7 @@ static void hdmitx_cec_early_suspend(struct early_suspend *h)
 
 static void hdmitx_cec_late_resume(struct early_suspend *h)
 {
-//    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
-    //cec_node_init((hdmitx_dev_t *)h->param);
+    cec_hw_reset();//for M8 CEC standby.
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         cec_imageview_on_smp();
         cec_active_source_smp();
@@ -247,89 +136,12 @@ static void hdmitx_cec_late_resume(struct early_suspend *h)
 
 #endif
 
-/***************************** cec low level code *****************************/
-/*
-static unsigned int cec_get_ms_tick(void)
-{
-    unsigned int ret = 0;
-    struct timeval cec_tick;
-    do_gettimeofday(&cec_tick);
-    ret = cec_tick.tv_sec * 1000 + cec_tick.tv_usec / 1000;
-
-    return ret;
-}
-*/
-/*
-static unsigned int cec_get_ms_tick_interval(unsigned int last_tick)
-{
-    unsigned int ret = 0;
-    unsigned int tick = 0;
-    struct timeval cec_tick;
-    do_gettimeofday(&cec_tick);
-    tick = cec_tick.tv_sec * 1000 + cec_tick.tv_usec / 1000;
-
-    if (last_tick < tick) ret = tick - last_tick;
-    else ret = ((unsigned int)(-1) - last_tick) + tick;
-    return ret;
-}
-*/
-
-int cec_ll_rx( unsigned char *msg, unsigned char *len)
-{
-    unsigned char i;
-    unsigned char rx_status;
-    unsigned char data;
-    unsigned char msg_log_buf[128];
-    int pos;
-    unsigned char n;
-    unsigned char *msg_start = msg;
-    int rx_msg_length;
-    
-    if(RX_DONE != hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS)){
-        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        //hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD, RX_DISABLE);
-        hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
-        return -1;
-    }
-    
-    rx_msg_length = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_MSG_LENGTH) + 1;
-
-    hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-
-    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
-        data = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_MSG_0_HEADER +i);
-        *msg = data;
-        msg++;
-    }
-    *len = rx_msg_length;
-    rx_status = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS);
-
-    //hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD, RX_DISABLE);
-
-    hdmi_wr_reg(CEC0_BASE_ADDR + CEC_RX_MSG_CMD,  RX_NO_OP);
-    if(cec_msg_dbg_en == 1){
-        pos = 0;
-        pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
-        for(n = 0; n < rx_msg_length; n++) {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg_start[n]);
-        }
-        pos += sprintf(msg_log_buf + pos, "\n");
-        msg_log_buf[pos] = '\0';
-        hdmi_print(INF, CEC "%s", msg_log_buf);
-    }
-    return rx_status;
-}
-
 void cec_isr_post_process(void)
 {
     /* isr post process */
-    while(cec_rx_msg_buf.rx_read_pos != cec_rx_msg_buf.rx_write_pos) {
-        cec_handle_message(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_read_pos]));
-        if (cec_rx_msg_buf.rx_read_pos == cec_rx_msg_buf.rx_buf_size - 1) {
-            cec_rx_msg_buf.rx_read_pos = 0;
-        } else {
-            cec_rx_msg_buf.rx_read_pos++;
-        }
+    while(cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos) {
+        cec_handle_message(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_read_pos]));
+        (cec_global_info.cec_rx_msg_buf.rx_read_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_read_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_read_pos++);
     }
 }
 
@@ -337,8 +149,6 @@ void cec_usr_cmd_post_process(void)
 {
     cec_tx_message_list_t *p, *ptmp;
     /* usr command post process */
-    //spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
-
     list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list) {
         cec_ll_tx(p->msg, p->length);
         unregister_cec_tx_msg(p);
@@ -351,7 +161,8 @@ static int detect_tv_support_cec(unsigned addr)
     unsigned int ret = 0;
     unsigned char msg[1];
     msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
-    ret = cec_ll_tx(msg, 1);
+    ret = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
     hdmi_print(INF, CEC "tv%shave CEC feature\n", ret ? " " : " don\'t ");
     return (hdmitx_device->tv_cec_support = ret);
 }
@@ -367,10 +178,8 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
                                                     CEC_PLAYBACK_DEVICE_3_ADDR,
                                                    };
 
-    //unsigned long cec_init_flags;
-    cec_tx_flag = 1;
-    cec_rx_flag = 1;
-    cec_power_flag = 1;
+    unsigned long cec_phy_addr;
+
     if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
         hdmi_print(INF, CEC "CEC not ready\n");
         return;
@@ -381,11 +190,8 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
 
     if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
         return ;
-    // If VSDB is not valid, wait
-    if(hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
-        hdmi_print(INF, CEC "no valid cec physical address\n");
-        return ;
-    }
+
+#if 1       //todo
     if(hdmitx_device->config_data.vend_data)
         vend_data = hdmitx_device->config_data.vend_data;
     if((vend_data) && (vend_data->cec_osd_string)) {
@@ -397,102 +203,112 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
     if((vend_data) && (vend_data->vendor_id)) {
         vendor_id = (vend_data->vendor_id ) & 0xffffff;
     }
-
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1); 
-#if 0
-    //Init GPIOx_27 IN for HDMI CEC arbitration
-    //Disable I2C_SDA_B:reg5[31]
-    //Disable I2C_SDA_SLAVE:reg5[29]
-    //Enable GPIOx_27 IN:0x2018[27]
-    //GPIOx_27 IN:0x201a[27]
-    aml_write_reg32(P_PERIPHS_PIN_MUX_5, aml_read_reg32(P_PERIPHS_PIN_MUX_5) & (~(1 << 31)));
-    aml_write_reg32(P_PERIPHS_PIN_MUX_5, aml_read_reg32(P_PERIPHS_PIN_MUX_5) & (~(1 << 29))); 
-    aml_write_reg32(P_PREG_PAD_GPIO4_EN_N, aml_read_reg32(P_PREG_PAD_GPIO4_EN_N) | (1 << 27));
 #endif
+#ifdef CONFIG_ARCH_MESON6
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
     // Clear CEC Int. state and set CEC Int. mask
-////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
-////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
+
+#endif
+#ifdef CONFIG_ARCH_MESON8
+#if 1           // Please match with H/W cec config
+// GPIOAO_12
+    aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 0, 12, 1);       // disable AO_12 internal pull-up   //fe60002c
+    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);      // AO_CEC pinmux                    //fe600014
+    ao_cec_init();
+#else
+// GPIOH_3
+    aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG1, 0, 19, 1);    // disable gpioh_3 internal pull-up
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 23, 1);      // gpioh_3 cec pinmux
+#endif
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+#endif
+    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
 
     
     for(i = 0; i < 3; i++){ 
-        //hdmitx_cec_dbg_print("CEC: start poll dev\n");
+	    hdmi_print(INF, CEC "CEC: start poll dev\n");
         cec_polling_online_dev(player_dev[i], &bool);
-        hdmitx_cec_dbg_print("CEC: player_dev[%d]:0x%x\n", i, player_dev[i]);
-        //hdmitx_cec_dbg_print("CEC: end poll dev\n");
+        hdmi_print(INF, CEC "player_dev[%d]:0x%x\n", i, player_dev[i]);
         if(bool == 0){  // 0 means that no any respond
+            // If VSDB is not valid,use last or default physical address.  
+            if(hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
+                hdmi_print(INF, CEC "no valid cec physical address\n");
+                if(aml_read_reg32(P_AO_DEBUG_REG1))
+                    hdmi_print(INF, CEC "use last physical address\n");
+                else{
+                    aml_write_reg32(P_AO_DEBUG_REG1, 0x1000);
+                    hdmi_print(INF, CEC "use default physical address\n"); 
+                }  
+            }else{
+                aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+            } 
+            hdmi_print(INF, CEC "physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
+            
             cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
             cec_global_info.my_node_index = player_dev[i];
             aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
             cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
             // Set Physical address
-            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = ( ((hdmitx_device->hdmi_info.vsdb_phy_addr.a)<<12)
-                                                                     +((hdmitx_device->hdmi_info.vsdb_phy_addr.b)<< 8)
-                                                                     +((hdmitx_device->hdmi_info.vsdb_phy_addr.c)<< 4)
-                                                                     +((hdmitx_device->hdmi_info.vsdb_phy_addr.d)    )
-                                                                    );
+            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
 
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
             cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
 
+            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
             cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
             strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
-            //hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
+#ifdef CONFIG_ARCH_MESON6
             hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-            
-            hdmitx_cec_dbg_print("CEC: Set logical address: %d\n", player_dev[i]);
-            //cec_hw_reset();
-            //spin_lock_irqsave(&cec_init_lock,cec_init_flags);
-            hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
-            
-            cec_report_physical_address_smp();
-
+#endif
+#ifdef CONFIG_ARCH_MESON8
+            aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
+#endif
+     		hdmi_print(INF, CEC "Set logical address: %d\n", player_dev[i]);
+
+            hdmi_print(INF, CEC "aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
+        	if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
+        	    break;
+            msleep(100);
+			cec_report_physical_address_smp();
+            msleep(150);
             cec_device_vendor_id((cec_rx_message_t*)0);
-            
-            cec_imageview_on_smp();
-            msleep(200);
+
+            msleep(150);
             cec_imageview_on_smp();
+            msleep(100);
 
             // here, we need to detect whether TV is supporting the CEC function
             // if not, jump out to save system time
-            //if(!detect_tv_support_cec(player_dev[i])) 
+            //if(!detect_tv_support_cec(player_dev[i])) {
+            //    hdmi_print(INF, CEC "HDMI CEC: No TV detected.\n");
             //    break;
+            //}
             cec_get_menu_language_smp();
-            
-            cec_active_source_smp();
-            //cec_usrcmd_set_report_physical_address();
+            msleep(350);
 
-            //cec_report_physical_address_smp();
+            cec_active_source_smp();
+            msleep(120);
 
-            //cec_get_menu_language_smp();
-            
-            //cec_device_vendor_id((cec_rx_message_t*)0);
-            
-            //cec_set_osd_name_init();
-            
-            //cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-            
-            //msleep(200);
-            //cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV again
-            //msleep(200);
-            //hdmitx_cec_dbg_print("CEC: Set physical address: %x\n", cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4);
-            
-            //cec_usrcmd_set_active_source(); 
-            
-            //spin_unlock_irqrestore(&cec_init_lock,cec_init_flags);
-            //cec_active_source(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_read_pos]));    
-            
             cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-            
+            msleep(100);
+
             cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
             cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
             break;
         }
     }
     if(bool == 1)
-        hdmitx_cec_dbg_print("CEC: Can't get a valid logical address\n");
+        hdmi_print(INF, CEC "Can't get a valid logical address\n");
 }
 
 void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
@@ -500,13 +316,7 @@ void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
     if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
        return ;
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
-    cec_power_flag = 0;
-    cec_tx_flag = 0;
-    cec_rx_flag = 0;
-    hdmitx_cec_dbg_print("CEC: cec node uninit!\n");
-    //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-////    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
-    //free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
+    hdmi_print(INF, CEC "cec node uninit!\n");
     cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
 }
 
@@ -514,13 +324,7 @@ static int cec_task(void *data)
 {
     extern void dump_hdmi_cec_reg(void);
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
-
-//    hdmitx_cec_dbg_print("CEC: Physical Address [A]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.a);
-//    hdmitx_cec_dbg_print("CEC: Physical Address [B]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.b);
-//    hdmitx_cec_dbg_print("CEC: Physical Address [C]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.c);
-//    hdmitx_cec_dbg_print("CEC: Physical Address [D]: %x\n",hdmitx_device->hdmi_info.vsdb_phy_addr.d);
-
-    cec_init_flag = 1;
+    cec_global_info.cec_flag.cec_init_flag = 1;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
     hdmitx_cec_early_suspend_handler.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
@@ -531,25 +335,20 @@ static int cec_task(void *data)
     register_early_suspend(&hdmitx_cec_early_suspend_handler);
 #endif
 
-    //cec_node_init(hdmitx_device);
-    
-//    dump_hdmi_cec_reg();
-    
     // Get logical address
 
-    hdmitx_cec_dbg_print("CEC: CEC task process\n");
+    hdmi_print(INF, CEC "CEC task process\n");
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
         msleep(10000);
+#ifdef CONFIG_ARCH_MESON6
         cec_gpi_init();
+#endif
         cec_node_init(hdmitx_device);
     }
     while (1) {
-        if(down_interruptible(&tv_cec_sema))
-           continue; 
-                
+        msleep(5);
         cec_isr_post_process();
-        cec_usr_cmd_post_process();
-        //\\cec_timer_post_process();
+        //cec_usr_cmd_post_process();
     }
 
     return 0;
@@ -563,26 +362,17 @@ static int cec_task(void *data)
 void register_cec_rx_msg(unsigned char *msg, unsigned char len )
 {
     unsigned long flags;
-    //    hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);  
-    memset((void*)(&(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
-    memcpy(cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
-
-    cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
-    cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].msg_length = len;
-    
-    //spin_lock(&cec_input_key);
     spin_lock_irqsave(&cec_input_key,flags);
+    memset((void*)(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
+    memcpy(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
+
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].msg_length = len;
+
     cec_input_handle_message();
-    spin_unlock_irqrestore(&cec_input_key,flags);
-    //spin_unlock(&cec_input_key);    
-    //wake_up_interruptible(&cec_key_poll);
-    if (cec_rx_msg_buf.rx_write_pos == cec_rx_msg_buf.rx_buf_size - 1) {
-        cec_rx_msg_buf.rx_write_pos = 0;
-    } else {
-        cec_rx_msg_buf.rx_write_pos++;
-    }
 
-    up(&tv_cec_sema);    
+    (cec_global_info.cec_rx_msg_buf.rx_write_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_write_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_write_pos++);
+    spin_unlock_irqrestore(&cec_input_key,flags);
 }
 
 void register_cec_tx_msg(unsigned char *msg, unsigned char len )
@@ -599,146 +389,29 @@ void register_cec_tx_msg(unsigned char *msg, unsigned char len )
         spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
 
         tx_msg_cnt++;
-        up(&tv_cec_sema);
     }
 }
 void cec_input_handle_message(void)
 {
     unsigned char   opcode;
-    //unsigned char   operand_num;
-    //unsigned char   msg_length;
-    
-//    hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);  
 
-    opcode = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].content.msg.opcode;   
-    //operand_num = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].operand_num;
-    //msg_length  = cec_rx_msg_buf.cec_rx_message[cec_rx_msg_buf.rx_write_pos].msg_length;
+    opcode = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
 
-    /* process messages from tv polling and cec devices */
-    //hdmitx_cec_dbg_print("----OP code----: %x\n", opcode);
-    if((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) && cec_power_flag)
+    /* process key event messages from tv */
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
     {
         switch (opcode) {
-        /*case CEC_OC_ACTIVE_SOURCE:
-            cec_active_source(pcec_message);
-            break;
-        case CEC_OC_INACTIVE_SOURCE:
-            cec_deactive_source(pcec_message);
-            break;
-        case CEC_OC_CEC_VERSION:
-            cec_report_version(pcec_message);
-            break;
-        case CEC_OC_DECK_STATUS:
-            cec_deck_status(pcec_message);
-            break;
-        case CEC_OC_DEVICE_VENDOR_ID:
-            cec_device_vendor_id(pcec_message);
-            break;
-        case CEC_OC_FEATURE_ABORT:
-            cec_feature_abort(pcec_message);
-            break;
-        case CEC_OC_GET_CEC_VERSION:
-            cec_get_version(pcec_message);
-            break;
-        case CEC_OC_GIVE_DECK_STATUS:
-            cec_give_deck_status(pcec_message);
-            break;
-        case CEC_OC_MENU_STATUS:
-            cec_menu_status(pcec_message);
-            break;
-        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-            cec_report_phy_addr(pcec_message);
-            break;
-        case CEC_OC_REPORT_POWER_STATUS:
-            cec_report_power_status(pcec_message);
-            break;
-        case CEC_OC_SET_OSD_NAME:
-            cec_set_osd_name(pcec_message);
-            break;
-        case CEC_OC_VENDOR_COMMAND_WITH_ID:
-            cec_vendor_cmd_with_id(pcec_message);
-            break;
-        case CEC_OC_SET_MENU_LANGUAGE:
-            cec_set_menu_language(pcec_message);
-            break;
-        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
-            cec_give_physical_address(pcec_message);
-            break;
-        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-            cec_give_device_vendor_id(pcec_message);
-            break;
-        case CEC_OC_GIVE_OSD_NAME:
-            cec_give_osd_name(pcec_message);
-            break;
-        case CEC_OC_STANDBY:
-              hdmitx_cec_dbg_print("----cec_standby-----");
-            cec_standby(pcec_message);
-            break;
-        case CEC_OC_SET_STREAM_PATH:
-            cec_set_stream_path(pcec_message);
-            break;
-        case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            cec_request_active_source(pcec_message);
-            break;
-        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-            cec_give_device_power_status(pcec_message);
-            break;
-            
-         case CEC_OC_STANDBY:
-            if(POWER_ON != cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status)
-                break; 
-            cec_standby_irq();
-            break;
-            */      
         case CEC_OC_USER_CONTROL_PRESSED:
+            // check valid msg
+            {
+                unsigned char opernum;
+                unsigned char follower;
+                opernum  = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+                follower = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
+                if(opernum != 1 || follower == 0xf) break;
+            }
             cec_user_control_pressed_irq();
             break;
-        case CEC_OC_USER_CONTROL_RELEASED:
-            //cec_user_control_released_irq();
-            break; 
-        //case CEC_OC_IMAGE_VIEW_ON:      //not support in source
-        //      cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-        //      break;  
-        case CEC_OC_ROUTING_CHANGE: 
-        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
-        case CEC_OC_CLEAR_ANALOGUE_TIMER:
-        case CEC_OC_CLEAR_DIGITAL_TIMER:
-        case CEC_OC_CLEAR_EXTERNAL_TIMER:
-        case CEC_OC_DECK_CONTROL:
-        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
-        case CEC_OC_MENU_REQUEST:
-        case CEC_OC_SET_OSD_STRING:
-        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
-        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
-        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
-        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:       //not support in source
-        case CEC_OC_TIMER_CLEARED_STATUS:
-        case CEC_OC_TIMER_STATUS:
-        case CEC_OC_TUNER_DEVICE_STATUS:
-        case CEC_OC_TUNER_STEP_DECREMENT:
-        case CEC_OC_TUNER_STEP_INCREMENT:
-        case CEC_OC_VENDOR_COMMAND:
-        case CEC_OC_ROUTING_INFORMATION:
-        case CEC_OC_SELECT_ANALOGUE_SERVICE:
-        case CEC_OC_SELECT_DIGITAL_SERVICE:
-        case CEC_OC_SET_ANALOGUE_TIMER :
-        case CEC_OC_SET_AUDIO_RATE:
-        case CEC_OC_SET_DIGITAL_TIMER:
-        case CEC_OC_SET_EXTERNAL_TIMER:
-        case CEC_OC_PLAY:
-        case CEC_OC_RECORD_OFF:
-        case CEC_OC_RECORD_ON:
-        case CEC_OC_RECORD_STATUS:
-        case CEC_OC_RECORD_TV_SCREEN:
-        case CEC_OC_REPORT_AUDIO_STATUS:
-        case CEC_OC_GET_MENU_LANGUAGE:
-        case CEC_OC_GIVE_AUDIO_STATUS:
-        case CEC_OC_ABORT_MESSAGE:
-            //hdmitx_cec_dbg_print("CEC: not support cmd: %x\n", opcode);
-            break;
         default:
             break;
         }
@@ -757,33 +430,12 @@ void unregister_cec_tx_msg(cec_tx_message_list_t* cec_tx_message_list)
     }
 }
 
-void cec_hw_reset(void)
-{
-    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
-    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0xc); //[3]cec_creg_sw_rst [2]cec_sys_sw_rst
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x1);
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x1);
-    
-    //mdelay(10);
-    {//Delay some time
-        int i = 10;
-        while(i--);
-    }
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x0);
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x0);
-    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0x0);
-    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)&(~(1<<16)));
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
-
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
-}
-
 unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
 {
     unsigned char rt = 0;
     unsigned char opcode;
     unsigned char opernum;
+    unsigned char follower;
     if (!pcec_message)
         return rt;
 
@@ -892,34 +544,117 @@ unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
             break;
     }
 
+ // for CTS12.2
+    follower = pcec_message->content.msg.header & 0x0f;
+    switch (opcode) {
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            // broadcast only
+            if(follower != 0xf) rt = 0;
+            break;
+
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_SET_OSD_NAME:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            // directly addressed only
+            if(follower == 0xf) rt = 0;
+            break;
+
+        case CEC_OC_STANDBY:
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+            // both broadcast and directly addressed
+            break;
+
+        default:
+            break;
+    }
+
     if ((rt == 0) & (opcode != 0)){
         hdmirx_cec_dbg_print("CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
     }
-    
-    //?????rt = 1; // temporal
     return rt;
 }
 
-//static char *tx_status[] = {
-//    "TX_IDLE ",
-//    "TX_BUSY ",
-//    "TX_DONE ",
-//    "TX_ERROR",
-//};
-
 static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
 {
-    unsigned int data_msg_num;
     unsigned char rx_msg[MAX_MSG], rx_len;
+    unsigned int intr_stat = 0;
+
+    //cec_disable_irq();
+
+#ifdef CONFIG_ARCH_MESON8
+    intr_stat = aml_read_reg32(P_AO_CEC_INTR_STAT);
+    hdmi_print(INF, CEC "aocec irq %x\n", intr_stat);
 
-    data_msg_num = hdmi_rd_reg(CEC0_BASE_ADDR + CEC_RX_NUM_MSG);             
-    //cec_ll_rx(rx_msg, &rx_len);
-    if((-1) == cec_ll_rx(rx_msg, &rx_len))
+    if(intr_stat & (1<<1)) { // aocec tx intr
+        tx_irq_handle();
+        //cec_enable_irq();
         return IRQ_HANDLED;
-    register_cec_rx_msg(rx_msg, rx_len);                
+    }
+#endif
+    if((-1) == cec_ll_rx(rx_msg, &rx_len)){
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
 
-//    Clear the interrupt
-//    WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) & ~(1 << 23));
+    register_cec_rx_msg(rx_msg, rx_len);
+
+    //cec_enable_irq();
 
     return IRQ_HANDLED;
 }
@@ -931,128 +666,17 @@ unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
         us = CEC_DISPLAY_DEVICE_TYPE;
     } else if ((1 << log_addr) & CEC_RECORDING_DEVICE) {
         us = CEC_RECORDING_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE) {
-        us = CEC_PLAYBACK_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_TUNER_DEVICE) {
-        us = CEC_TUNER_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE) {
-        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
-    }
-
-    return us;
-}
-//
-//static cec_hdmi_port_e cec_find_hdmi_port(unsigned char log_addr)
-//{
-//    cec_hdmi_port_e rt = CEC_HDMI_PORT_UKNOWN;
-//
-//    if ((cec_global_info.dev_mask & (1 << log_addr)) &&
-//            (cec_global_info.cec_node_info[log_addr].phy_addr != 0) &&
-//            (cec_global_info.cec_node_info[log_addr].hdmi_port == CEC_HDMI_PORT_UKNOWN)) {
-//        if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x1000) {
-//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_1;
-//        } else if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x2000) {
-//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_2;
-//        } else if ((cec_global_info.cec_node_info[log_addr].phy_addr & 0xF000) == 0x3000) {
-//            cec_global_info.cec_node_info[log_addr].hdmi_port = CEC_HDMI_PORT_3;
-//        }
-//    }
-//
-//    rt = cec_global_info.cec_node_info[log_addr].hdmi_port;
-//
-//    return rt;
-//}
-
-// -------------- command from cec devices ---------------------
-
-void cec_polling_online_dev(int log_addr, int *bool)
-{
-    //int log_addr = 0;
-    unsigned long r;
-    unsigned short dev_mask_tmp = 0;
-    unsigned char msg[1];
-
-    //for (log_addr = 1; log_addr < CEC_UNREGISTERED_ADDR; log_addr++) {
-        hdmitx_cec_dbg_print("aml_read_reg32(P_AO_DEBUG_REG3):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG3));
-        //if(aml_read_reg32(P_AO_DEBUG_REG3) & 0xf){
-        //    *bool = 0;
-        //    cec_global_info.my_node_index = aml_read_reg32(P_AO_DEBUG_REG3) & 0xf;
-        //    return;
-        //}
-        cec_global_info.my_node_index = log_addr;
-        msg[0] = (log_addr<<4) | log_addr;
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
-        hdmitx_cec_dbg_print("CEC_LOGICAL_ADDR0:0x%x\n",hdmi_rd_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0));
-        r = cec_ll_tx(msg, 1);
-            
-        if (r == 0) {
-            //dev_mask_tmp |= 1 << log_addr;
-            //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
-            //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-            //cec_global_info.cec_node_info[log_addr].dev_type = CEC_PLAYBACK_DEVICE_TYPE;
-//            cec_find_hdmi_port(log_addr);
-            *bool = 0;
-            //cec_hw_reset();
-            //msleep(200);
-        }else{
-            dev_mask_tmp &= ~(1 << log_addr);
-            memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
-            //cec_global_info.cec_node_info[log_addr].log_addr = log_addr;
-            //cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);            
-            cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-              *bool = 1;
-        }
-    if(*bool == 0) {
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
-    }
-    hdmitx_cec_dbg_print("CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
-
-    if (cec_global_info.dev_mask != dev_mask_tmp) {
-        cec_global_info.dev_mask = dev_mask_tmp;
+    } else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE) {
+        us = CEC_PLAYBACK_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_TUNER_DEVICE) {
+        us = CEC_TUNER_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE) {
+        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
     }
-}
-
-void cec_report_phy_addr(cec_rx_message_t* pcec_message)
-{
-    //unsigned char index = cec_global_info.my_node_index;
-    ////unsigned char log_addr = pcec_message->content.msg.header >> 4;
-
-    //cec_global_info.dev_mask |= 1 << index;
-    //cec_global_info.cec_node_info[index].dev_type = cec_log_addr_to_dev_type(index);
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DEVICE_TYPE;
-    //memcpy(cec_global_info.cec_node_info[index].osd_name_def, default_osd_name[index], 16);
-    //if ((cec_global_info.cec_node_info[index].real_info_mask & INFO_MASK_OSD_NAME) == 0) {
-    //    memcpy(cec_global_info.cec_node_info[index].osd_name, osd_name_uninit, 16);
-    //}
-    //cec_global_info.cec_node_info[index].log_addr = index;
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_LOGIC_ADDRESS;
-    //cec_global_info.cec_node_info[index].phy_addr.phy_addr_4 = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_PHYSICAL_ADDRESS;
-//
-
-}
 
-void cec_give_physical_address(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-        unsigned char msg[5];
-        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-        msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
-        msg[2] = phy_addr_ab;
-        msg[3] = phy_addr_cd;
-        msg[4] = cec_global_info.cec_node_info[index].log_addr;
-        //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-        //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-        //msg[4] = cec_global_info.cec_node_info[index].log_addr;
-        cec_ll_tx(msg, 5);
-    //}
-//    hdmirx_cec_dbg_print("cec_report_phy_addr: %x\n", cec_global_info.cec_node_info[index].log_addr);
+    return us;
 }
-
+// -------------- command from cec devices ---------------------
 //***************************************************************
 void cec_device_vendor_id(cec_rx_message_t* pcec_message)
 {
@@ -1070,13 +694,14 @@ void cec_device_vendor_id(cec_rx_message_t* pcec_message)
 
 void cec_report_power_status(cec_rx_message_t* pcec_message)
 {
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
     unsigned char index = cec_global_info.my_node_index;
-    if (cec_global_info.dev_mask & (1 << index)) {
-        cec_global_info.cec_node_info[index].power_status = pcec_message->content.msg.operands[0];
-        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_POWER_STATUS;
-        hdmirx_cec_dbg_print("cec_report_power_status: %x\n", cec_global_info.cec_node_info[index].power_status);
-    }
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_REPORT_POWER_STATUS;
+    msg[2] = cec_global_info.cec_node_info[index].power_status;
+    cec_ll_tx(msg, 3);
+
 }
 
 void cec_feature_abort(cec_rx_message_t* pcec_message)
@@ -1084,8 +709,8 @@ void cec_feature_abort(cec_rx_message_t* pcec_message)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char opcode = pcec_message->content.msg.opcode;
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-
-    if(opcode != 0xf){
+    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
+    if(dst_log_addr != 0xf){
         unsigned char msg[4];
         
         msg[0] = ((index & 0xf) << 4) | src_log_addr;
@@ -1095,19 +720,11 @@ void cec_feature_abort(cec_rx_message_t* pcec_message)
         
         cec_ll_tx(msg, 4);        
     }
-    
-    //hdmirx_cec_dbg_print("cec_feature_abort: opcode %x\n", pcec_message->content.msg.opcode);
 }
 
 void cec_report_version(cec_rx_message_t* pcec_message)
 {
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index;   
-    if (cec_global_info.dev_mask & (1 << index)) {
-        cec_global_info.cec_node_info[index].cec_version = pcec_message->content.msg.operands[0];
-        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_CEC_VERSION;
-        hdmirx_cec_dbg_print("cec_report_version: %x\n", cec_global_info.cec_node_info[index].cec_version);
-    }
+    ;//todo
 }
 
 
@@ -1116,17 +733,14 @@ void cec_report_physical_address_smp(void)
     unsigned char msg[5]; 
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;    
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);     
-    
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
     msg[2] = phy_addr_ab;
     msg[3] = phy_addr_cd;
-    //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-    //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-    msg[4] = cec_global_info.cec_node_info[index].dev_type;                        
-    
+    msg[4] = cec_global_info.cec_node_info[index].dev_type;
+
     cec_ll_tx(msg, 5);
         
 }
@@ -1136,8 +750,6 @@ void cec_imageview_on_smp(void)
     unsigned char msg[2];
     unsigned char index = cec_global_info.my_node_index;
 
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);   
-    //hdmitx_cec_dbg_print("cec_func_config:0x%x\n",hdmitx_device->cec_func_config);  
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
             msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
@@ -1151,8 +763,6 @@ void cec_get_menu_language_smp(void)
 {
     unsigned char msg[2];
     unsigned char index = cec_global_info.my_node_index;
-    
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
 
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_GET_MENU_LANGUAGE;
@@ -1168,17 +778,9 @@ void cec_menu_status(cec_rx_message_t* pcec_message)
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
 
      if(0xf != src_log_addr) {
-            msg[0] = ((index & 0xf) << 4) | src_log_addr;
-            msg[1] = CEC_OC_MENU_STATUS;
-        if((2 == pcec_message->content.msg.operands[0])){    
-            msg[2] = cec_global_info.cec_node_info[index].menu_status;
-        }else if(0 == pcec_message->content.msg.operands[0]){
-            cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
-            msg[2] = DEVICE_MENU_INACTIVE;        
-        }else{
-            cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
-            msg[2] = DEVICE_MENU_ACTIVE; 
-        }
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = cec_global_info.cec_node_info[index].menu_status;
         cec_ll_tx(msg, 3);
     }
 }
@@ -1188,71 +790,41 @@ void cec_menu_status_smp(cec_device_menu_state_e status)
     unsigned char msg[3];
     unsigned char index = cec_global_info.my_node_index;
 
-    if(status == DEVICE_MENU_ACTIVE){    
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_MENU_STATUS;
+    if(status == DEVICE_MENU_ACTIVE){
         msg[2] = DEVICE_MENU_ACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
     }else{
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = DEVICE_MENU_INACTIVE;        
+        msg[2] = DEVICE_MENU_INACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
     }
     cec_ll_tx(msg, 3);
-    
-    //MSG_P1( index, CEC_TV_ADDR,
-    //        CEC_OC_MENU_STATUS, 
-    //        DEVICE_MENU_ACTIVE
-    //        );
-
-    //register_cec_tx_msg(gbl_msg, 3); 
-
 }
 
-void cec_menu_status_smp_irq(unsigned int status)
+void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
 {
-    unsigned char msg[3];
     unsigned char index = cec_global_info.my_node_index;
 
-    if(status == DEVICE_MENU_ACTIVE){    
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = DEVICE_MENU_ACTIVE;
-    }else{
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = DEVICE_MENU_INACTIVE;        
+    if(1 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }else if(0 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
     }
-    cec_ll_tx(msg, 3);
-    
-    //MSG_P1( index, CEC_TV_ADDR,
-    //        CEC_OC_MENU_STATUS, 
-    //        DEVICE_MENU_ACTIVE
-    //        );
-
-    //register_cec_tx_msg(gbl_msg, 3); 
-
 }
-EXPORT_SYMBOL(cec_menu_status_smp_irq);
 
-void cec_active_source_irq(void)
+void cec_active_source_rx(cec_rx_message_t* pcec_message)
 {
-    unsigned char msg[4];
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
+    unsigned int phy_addr_active;
 
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {    
-            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-            msg[1] = CEC_OC_ACTIVE_SOURCE;
-            msg[2] = phy_addr_ab;
-            msg[3] = phy_addr_cd;
-            //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-            //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-            cec_ll_tx(msg, 4);
-        }
-    }
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 
 void cec_active_source_smp(void)
@@ -1261,88 +833,58 @@ void cec_active_source_smp(void)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
-    //hdmitx_cec_dbg_print("\nCEC:function:%s,file:%s,line:%d\n",__FUNCTION__,__FILE__,__LINE__);    
 
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {    
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
             msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
             msg[1] = CEC_OC_ACTIVE_SOURCE;
             msg[2] = phy_addr_ab;
             msg[3] = phy_addr_cd;
-            //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-            //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
             cec_ll_tx(msg, 4);
         }
     }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
 }
 void cec_active_source(cec_rx_message_t* pcec_message)
 {
     unsigned char msg[4];
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
     unsigned char index = cec_global_info.my_node_index;
-    //unsigned short phy_addr = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;    
-
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-//    if (phy_addr == cec_global_info.cec_node_info[index].phy_addr.phy_addr_4) {
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
 
-        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-        msg[1] = CEC_OC_ACTIVE_SOURCE;
-        msg[2] = phy_addr_ab;
-        msg[3] = phy_addr_cd;
-        //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-        //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-        cec_ll_tx(msg, 4);
-        
-//        MSG_P2( index, CEC_TV_ADDR, 
-//                CEC_OC_ACTIVE_SOURCE, 
-//                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-//                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
-        
-//        register_cec_tx_msg(gbl_msg, 4);
-//    }else{
-//        cec_deactive_source(pcec_message);
-//    }
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
 }
 
-//////////////////////////////////
+
 void cec_set_stream_path(cec_rx_message_t* pcec_message)
 {
-//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned short phy_addr = (pcec_message->content.msg.operands[0] << 8) | pcec_message->content.msg.operands[1];
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
-            
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {    
-        if(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))
-        {    
-            if (phy_addr == cec_global_info.cec_node_info[index].phy_addr.phy_addr_4) {    
-                unsigned char msg[4];
-                msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-                msg[1] = CEC_OC_ACTIVE_SOURCE;
-                msg[2] = phy_addr_ab;
-                msg[3] = phy_addr_cd;
-                //msg[2] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-                //msg[3] = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
-                cec_ll_tx(msg, 4);
-            }
-        }
-    }
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_active_source_smp();
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 void cec_set_system_audio_mode(void)
 {
     unsigned char index = cec_global_info.my_node_index;
 
     MSG_P1( index, CEC_TV_ADDR,
-    //MSG_P1( index, CEC_BROADCAST_ADDR,  
-            CEC_OC_SET_SYSTEM_AUDIO_MODE, 
+            CEC_OC_SET_SYSTEM_AUDIO_MODE,
             cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
             );
-    
-    register_cec_tx_msg(gbl_msg, 3);
+
+    cec_ll_tx(gbl_msg, 3);
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
     else
@@ -1352,21 +894,24 @@ void cec_set_system_audio_mode(void)
 void cec_system_audio_mode_request(void)
 {
     unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
     if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF){
-        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST, 
-                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-                cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd
+        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                phy_addr_ab,
+                phy_addr_cd
                 );
-        register_cec_tx_msg(gbl_msg, 4);
+        cec_ll_tx(gbl_msg, 4);
         cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
     }
-    else{        
-        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR, 
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST 
-                ); 
-        register_cec_tx_msg(gbl_msg, 2);
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF; 
+    else{
+        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
+                );
+        cec_ll_tx(gbl_msg, 2);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
     }
 }
 
@@ -1375,41 +920,27 @@ void cec_report_audio_status(void)
     unsigned char index = cec_global_info.my_node_index;
 
     MSG_P1( index, CEC_TV_ADDR,
-    //MSG_P1( index, CEC_BROADCAST_ADDR,  
-            CEC_OC_REPORT_AUDIO_STATUS, 
+            CEC_OC_REPORT_AUDIO_STATUS,
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
             cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
             );
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 void cec_request_active_source(cec_rx_message_t* pcec_message)
 {
     cec_set_stream_path(pcec_message);
 }
 
-void cec_give_device_power_status(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
-
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_REPORT_POWER_STATUS;
-        msg[2] = cec_global_info.cec_node_info[index].power_status;
-        cec_ll_tx(msg, 3);
-    //}
-}
-
 void cec_set_imageview_on_irq(void)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[2];
-    
+
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_IMAGE_VIEW_ON;
 
-    cec_ll_tx(msg, 2);    
+    cec_ll_tx(msg, 2);
 }
 
 void cec_inactive_source(void)
@@ -1417,33 +948,20 @@ void cec_inactive_source(void)
     unsigned char index = cec_global_info.my_node_index;
     unsigned char msg[4];
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
-        
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
     msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
     msg[1] = CEC_OC_INACTIVE_SOURCE;
-    msg[2] = phy_addr_ab;
-    msg[3] = phy_addr_cd;
+	msg[2] = phy_addr_ab;
+	msg[3] = phy_addr_cd;
 
-    cec_ll_tx(msg, 4);    
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
 }
-void cec_deactive_source(cec_rx_message_t* pcec_message)
-{
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index;    
-    
-    //if (cec_global_info.dev_mask & (1 << log_addr)) {
-    //    if (cec_global_info.active_log_dev == log_addr) {
-    //    cec_global_info.active_log_dev = 0;
-    //    }
-    //    hdmirx_cec_dbg_print("cec_deactive_source: %x\n", log_addr);
-    //}
-    
-    MSG_P2( index, CEC_TV_ADDR, 
-            CEC_OC_INACTIVE_SOURCE, 
-            cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-            cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd);
 
-    register_cec_tx_msg(gbl_msg, 4); 
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
+{
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
 }
 
 void cec_get_version(cec_rx_message_t* pcec_message)
@@ -1455,27 +973,27 @@ void cec_get_version(cec_rx_message_t* pcec_message)
     if (0xf != dest_log_addr) {
         msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
         msg[1] = CEC_OC_CEC_VERSION;
-        msg[2] = CEC_VERSION_13A;
+        msg[2] = CEC_VERSION_14A;
         cec_ll_tx(msg, 3);
     }
 }
 
 void cec_give_deck_status(cec_rx_message_t* pcec_message)
 {
-    unsigned char index = cec_global_info.my_node_index; 
-    MSG_P1( index, CEC_TV_ADDR, 
-            CEC_OC_DECK_STATUS, 
-            0x1a);
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
 
-    register_cec_tx_msg(gbl_msg, 3); 
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_DECK_STATUS;
+    msg[2] = 0x1a;
+    cec_ll_tx(msg, 3);
 }
 
 
 void cec_deck_status(cec_rx_message_t* pcec_message)
 {
-//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
-    unsigned char index = cec_global_info.my_node_index; 
-        
+    unsigned char index = cec_global_info.my_node_index;
+
     if (cec_global_info.dev_mask & (1 << index)) {
         cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
         cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
@@ -1492,24 +1010,21 @@ void cec_set_standby(void)
     msg[1] = CEC_OC_STANDBY;
     if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
         if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
-            cec_ll_tx(msg, 2);
-            //mdelay(100);
-            cec_rx_flag = 0;
-        }
-    }
+			cec_ll_tx(msg, 2);
+		}
+	}
 }
 
 void cec_set_osd_name(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
-    unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
     unsigned char msg[16];
-        
+
     if(0xf != src_log_addr) {
         msg[0] = ((index & 0xf) << 4) | src_log_addr;
         msg[1] = CEC_OC_SET_OSD_NAME;
-
         memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
 
         cec_ll_tx(msg, 2 + osd_len);
@@ -1519,7 +1034,7 @@ void cec_set_osd_name(cec_rx_message_t* pcec_message)
 void cec_set_osd_name_init(void)
 {
     unsigned char index = cec_global_info.my_node_index;
-    unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
     unsigned char msg[16];
 
     msg[0] = ((index & 0xf) << 4) | 0;
@@ -1531,18 +1046,7 @@ void cec_set_osd_name_init(void)
 
 void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
 {
-//    unsigned char log_addr = pcec_message->content.msg.header >> 4;
-//    unsigned char index = cec_global_info.my_node_index;  
-//    if (cec_global_info.dev_mask & (1 << index)) {
-//        if (cec_global_info.cec_node_info[index].vendor_id.vendor_id_byte_num != 0) {
-//            int i = cec_global_info.cec_node_info[index].vendor_id.vendor_id_byte_num;
-//            int tmp = 0;
-//            for ( ; i < pcec_message->operand_num; i++) {
-//                tmp |= (pcec_message->content.msg.operands[i] << ((cec_global_info.cec_node_info[log_addr].vendor_id.vendor_id_byte_num - i - 1)*8));
-//            }
-//            hdmirx_cec_dbg_print("cec_vendor_cmd_with_id: %lx, %x\n", cec_global_info.cec_node_info[log_addr].vendor_id.vendor_id, tmp);
-//        }
-//    }
+    ;//todo
 }
 
 
@@ -1550,72 +1054,60 @@ void cec_set_menu_language(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-    
+
     if(0x0 == src_log_addr) {
         cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
                                                                (pcec_message->content.msg.operands[1] <<  8)  |
                                                                (pcec_message->content.msg.operands[2]));
-        
-        
+
         switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
         cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
-        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff, 
+        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
                                                                  (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
                                                                  (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
-    }else{
-        //cec_feature_abort(pcec_message);
     }
 }
 
 void cec_handle_message(cec_rx_message_t* pcec_message)
 {
-    unsigned char    brdcst, opcode;
-    unsigned char    initiator, follower;
+    unsigned char	brdcst, opcode;
+    unsigned char	initiator, follower;
     unsigned char   operand_num;
     unsigned char   msg_length;
 
     /* parse message */
-    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) //return;
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
+        return;
 
-    initiator    = pcec_message->content.msg.header >> 4;
-    follower    = pcec_message->content.msg.header & 0x0f;
-    opcode        = pcec_message->content.msg.opcode;
+    initiator	= pcec_message->content.msg.header >> 4;
+    follower	= pcec_message->content.msg.header & 0x0f;
+    opcode		= pcec_message->content.msg.opcode;
     operand_num = pcec_message->operand_num;
     brdcst      = (follower == 0x0f);
     msg_length  = pcec_message->msg_length;
 
     if(0 == pcec_message->content.msg.header)
         return;
+
     /* process messages from tv polling and cec devices */
-//    hdmitx_cec_dbg_print("OP code: 0x%x\n", opcode);
-//    hdmitx_cec_dbg_print("cec_power_flag: 0x%x\n", cec_power_flag);
-//    hdmitx_cec_dbg_print("cec: cec_func_config: 0x%x\n", hdmitx_device->cec_func_config);
     if(CEC_OC_GIVE_OSD_NAME == opcode)
         cec_set_osd_name(pcec_message);
-    if((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) && cec_power_flag)
-    {    
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
 
         switch (opcode) {
         case CEC_OC_ACTIVE_SOURCE:
-            //if((0 == pcec_message->content.msg.operands[0]) && (0 == pcec_message->content.msg.operands[1]))
-                //cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-                //cec_active_source_smp();
-            //cec_deactive_source(pcec_message);
+            cec_active_source_rx(pcec_message);
             break;
         case CEC_OC_INACTIVE_SOURCE:
-            //cec_deactive_source(pcec_message);
             break;
         case CEC_OC_CEC_VERSION:
-            //cec_report_version(pcec_message);
             break;
         case CEC_OC_DECK_STATUS:
-            //cec_deck_status(pcec_message);
             break;
         case CEC_OC_DEVICE_VENDOR_ID:
-            //cec_device_vendor_id(pcec_message);
             break;
         case CEC_OC_FEATURE_ABORT:
-            //cec_feature_abort(pcec_message);
             break;
         case CEC_OC_GET_CEC_VERSION:
             cec_get_version(pcec_message);
@@ -1624,114 +1116,94 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
             cec_give_deck_status(pcec_message);
             break;
         case CEC_OC_MENU_STATUS:
-            //cec_menu_status(pcec_message);
-            //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+            cec_menu_status_smp_irq(pcec_message);
             break;
         case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-            cec_report_phy_addr(pcec_message);
             break;
         case CEC_OC_REPORT_POWER_STATUS:
-            //cec_report_power_status(pcec_message);
             break;
         case CEC_OC_SET_OSD_NAME:
-            //cec_set_osd_name(pcec_message);
             break;
         case CEC_OC_VENDOR_COMMAND_WITH_ID:
-            //cec_feature_abort(pcec_message);
-            //cec_vendor_cmd_with_id(pcec_message);
             break;
         case CEC_OC_SET_MENU_LANGUAGE:
             cec_set_menu_language(pcec_message);
             break;
         case CEC_OC_GIVE_PHYSICAL_ADDRESS:
             cec_report_physical_address_smp();
-            //cec_report_phy_addr(pcec_message);//
-            //cec_give_physical_address(pcec_message);
-            //cec_usrcmd_set_report_physical_address();
             break;
         case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-            //cec_feature_abort(pcec_message);
             cec_device_vendor_id(pcec_message);
-            //cec_usrcmd_set_device_vendor_id();
             break;
         case CEC_OC_GIVE_OSD_NAME:
-            cec_set_osd_name(pcec_message);
-            //cec_give_osd_name(pcec_message);
-            //cec_usrcmd_set_osd_name(pcec_message);
             break;
         case CEC_OC_STANDBY:
-            hdmitx_cec_dbg_print("CEC: system standby\n");
-            //cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-            cec_deactive_source(pcec_message);
+            cec_inactive_source_rx(pcec_message);
             cec_standby(pcec_message);
             break;
         case CEC_OC_SET_STREAM_PATH:
             cec_set_stream_path(pcec_message);
             break;
         case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            //cec_request_active_source(pcec_message);
-            //cec_usrcmd_set_active_source();
+            if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
+                break;
             cec_active_source_smp();
             break;
         case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-            cec_give_device_power_status(pcec_message);
+            cec_report_power_status(pcec_message);
             break;
         case CEC_OC_USER_CONTROL_PRESSED:
-            //hdmitx_cec_dbg_print("----cec_user_control_pressed-----");
-            //cec_user_control_pressed(pcec_message);
             break;
         case CEC_OC_USER_CONTROL_RELEASED:
-            //hdmitx_cec_dbg_print("----cec_user_control_released----");
-            //cec_user_control_released(pcec_message);
-            break; 
+            break;
         case CEC_OC_IMAGE_VIEW_ON:      //not support in source
             cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-            break;  
+            break;
         case CEC_OC_ROUTING_CHANGE:
-        case CEC_OC_ROUTING_INFORMATION:
-            cec_usrcmd_routing_information(pcec_message);
+            cec_routing_change(pcec_message);
             break;
+        case CEC_OC_ROUTING_INFORMATION:
+        	cec_routing_information(pcec_message);
+        	break;
         case CEC_OC_GIVE_AUDIO_STATUS:
-            cec_report_audio_status();
-            break;
+        	cec_report_audio_status();
+        	break;
         case CEC_OC_MENU_REQUEST:
             cec_menu_status(pcec_message);
             break;
         case CEC_OC_PLAY:
-            hdmitx_cec_dbg_print("CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);        
+            hdmi_print(INF,CEC, "CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
             switch(pcec_message->content.msg.operands[0]){
                 case 0x24:
-                    input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);
-                    input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
-                    input_sync(remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
                     break;
                 case 0x25:
-                    input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(remote_cec_dev);
-                    input_event(remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
-                    input_sync(remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
                     break;
                 default:
-                    break;                
+                    break;
             }
             break;
         case CEC_OC_DECK_CONTROL:
-            hdmitx_cec_dbg_print("CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);        
+            hdmi_print(INF, CEC "CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
             switch(pcec_message->content.msg.operands[0]){
                 case 0x3:
-                    input_event(remote_cec_dev, EV_KEY, KEY_STOP, 1);
-                    input_sync(remote_cec_dev);
-                    input_event(remote_cec_dev, EV_KEY, KEY_STOP, 0);
-                    input_sync(remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
                     break;
                 default:
-                    break;                
+                    break;
             }
             break;
         case CEC_OC_GET_MENU_LANGUAGE:
-            //cec_set_menu_language(pcec_message);
-            //break;
         case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
         case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
         case CEC_OC_CLEAR_ANALOGUE_TIMER:
@@ -1744,7 +1216,7 @@ void cec_handle_message(cec_rx_message_t* pcec_message)
         case CEC_OC_SET_TIMER_PROGRAM_TITLE:
         case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
         case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:       //not support in source
+        case CEC_OC_TEXT_VIEW_ON:
         case CEC_OC_TIMER_CLEARED_STATUS:
         case CEC_OC_TIMER_STATUS:
         case CEC_OC_TUNER_DEVICE_STATUS:
@@ -1806,174 +1278,160 @@ void cec_usrcmd_parse_all_dev_online(void)
     hdmirx_cec_dbg_print("##############################################################\n");
 }
 
-//////////////////////////////////////////////////
 void cec_usrcmd_get_cec_version(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr, 
+    MSG_P0(cec_global_info.my_node_index, log_addr,
             CEC_OC_GET_CEC_VERSION);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_audio_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_deck_status(unsigned char log_addr)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_device_power_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_osd_name(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_physical_address(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_standby(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 /////////////////////////
 void cec_usrcmd_set_imageview_on(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr, 
+    MSG_P0(cec_global_info.my_node_index, log_addr,
             CEC_OC_IMAGE_VIEW_ON);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_text_view_on(unsigned char log_addr)
 {
-    MSG_P0(cec_global_info.my_node_index, log_addr, 
+    MSG_P0(cec_global_info.my_node_index, log_addr,
             CEC_OC_TEXT_VIEW_ON);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_menu_state(unsigned char log_addr)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
 
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
 {
     MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
 
-
-    register_cec_tx_msg(gbl_msg, 3);
+    cec_ll_tx(gbl_msg, 3);
 }
 
 void cec_usrcmd_get_menu_language(unsigned char log_addr)
 {
     MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
 
-    register_cec_tx_msg(gbl_msg, 2);
+    cec_ll_tx(gbl_msg, 2);
 }
 
-//void cec_usrcmd_set_menu_language(unsigned char log_addr, cec_menu_lang_e menu_lang)
-//{
-//    MSG_P3(cec_global_info.my_node_index, log_addr, CEC_OC_SET_MENU_LANGUAGE, (menu_lang_array[menu_lang]>>16)&0xFF,
-//           (menu_lang_array[menu_lang]>>8)&0xFF,
-//           (menu_lang_array[menu_lang])&0xFF);
-//    register_cec_tx_msg(gbl_msg, 5);
-//}
-
 void cec_usrcmd_get_active_source(void)
 {
     MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
-        
-    register_cec_tx_msg(gbl_msg, 2);
+
+    cec_ll_tx(gbl_msg, 2);
 }
 
 void cec_usrcmd_set_active_source(void)
 {
     unsigned char index = cec_global_info.my_node_index;
-    //unsigned char phy_addr_ab = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab;
-    //unsigned char phy_addr_cd = cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;  
-    
-    MSG_P2(index, CEC_BROADCAST_ADDR, 
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(index, CEC_BROADCAST_ADDR,
             CEC_OC_ACTIVE_SOURCE,
-            phy_addr_ab,
-            phy_addr_cd);
+			phy_addr_ab,
+			phy_addr_cd);
 
-    register_cec_tx_msg(gbl_msg, 4);
+    cec_ll_tx(gbl_msg, 4);
 }
 
 void cec_usrcmd_set_deactive_source(unsigned char log_addr)
 {
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    
+
     MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
            phy_addr_ab,
            phy_addr_cd);
-          //cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.ab,
-          //cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.cd);
 
-    register_cec_tx_msg(gbl_msg, 4);
+    cec_ll_tx(gbl_msg, 4);
 }
 
 void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
@@ -1981,39 +1439,31 @@ void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_m
     cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
 }
 
-//void cec_usrcmd_set_stream_path(unsigned char log_addr)
-//{
-//    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_SET_STREAM_PATH, 
-//                                                  cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.ab,
-//                                                  cec_global_info.cec_node_info[log_addr].phy_addr.phy_addr_2.cd);
-//
-//    register_cec_tx_msg(gbl_msg, 4);
-//}
 
 void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
 {
 
-    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;  
+    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
     unsigned char index = cec_global_info.my_node_index;
 
-    MSG_P14(index, log_addr, 
-            CEC_OC_SET_OSD_NAME, 
+    MSG_P14(index, log_addr,
+            CEC_OC_SET_OSD_NAME,
             cec_global_info.cec_node_info[index].osd_name[0],
             cec_global_info.cec_node_info[index].osd_name[1],
             cec_global_info.cec_node_info[index].osd_name[2],
             cec_global_info.cec_node_info[index].osd_name[3],
             cec_global_info.cec_node_info[index].osd_name[4],
-            cec_global_info.cec_node_info[index].osd_name[5],           
+            cec_global_info.cec_node_info[index].osd_name[5],
             cec_global_info.cec_node_info[index].osd_name[6],
             cec_global_info.cec_node_info[index].osd_name[7],
             cec_global_info.cec_node_info[index].osd_name[8],
             cec_global_info.cec_node_info[index].osd_name[9],
             cec_global_info.cec_node_info[index].osd_name[10],
-            cec_global_info.cec_node_info[index].osd_name[11],  
+            cec_global_info.cec_node_info[index].osd_name[11],
             cec_global_info.cec_node_info[index].osd_name[12],
             cec_global_info.cec_node_info[index].osd_name[13]);
 
-    register_cec_tx_msg(gbl_msg, 16);
+    cec_ll_tx(gbl_msg, 16);
 }
 
 
@@ -2022,64 +1472,67 @@ void cec_usrcmd_set_device_vendor_id(void)
 {
     unsigned char index = cec_global_info.my_node_index;
 
-    MSG_P3(index, CEC_BROADCAST_ADDR, 
-            CEC_OC_DEVICE_VENDOR_ID, 
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+            CEC_OC_DEVICE_VENDOR_ID,
             (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
             (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
             (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
 
-    register_cec_tx_msg(gbl_msg, 5);
+    cec_ll_tx(gbl_msg, 5);
 }
 void cec_usrcmd_set_report_physical_address(void)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    
-    MSG_P3(index, CEC_BROADCAST_ADDR, 
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
            CEC_OC_REPORT_PHYSICAL_ADDRESS,
            phy_addr_ab,
            phy_addr_cd,
            CEC_PLAYBACK_DEVICE_TYPE);
-            //cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.ab,
-            //cec_global_info.cec_node_info[index].phy_addr.phy_addr_2.cd,
-            //cec_global_info.cec_node_info[index].dev_type);
 
-    register_cec_tx_msg(gbl_msg, 5);
+    cec_ll_tx(gbl_msg, 5);
 }
 
-void cec_usrcmd_routing_change(cec_rx_message_t* pcec_message)
+void cec_routing_change(cec_rx_message_t* pcec_message)
 {
-    //unsigned char index = cec_global_info.my_node_index;
-    //unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
-    //cec_global_info.cec_node_info[index].log_addr = index;
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_LOGIC_ADDRESS;
-    //cec_global_info.cec_node_info[index].phy_addr.phy_addr_4 = (pcec_message->content.msg.operands[2] << 8) | pcec_message->content.msg.operands[3];
-    //cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_PHYSICAL_ADDRESS;    
-    //MSG_P4(index, CEC_BROADCAST_ADDR, 
-    //        CEC_OC_ROUTING_CHANGE, 
-        //  cec_global_info.cec_node_info[original_index].phy_addr.phy_addr_2.ab,
-        //  cec_global_info.cec_node_info[original_index].phy_addr.phy_addr_2.cd,
-        //  cec_global_info.cec_node_info[new_index].phy_addr.phy_addr_2.ab,
-        //  cec_global_info.cec_node_info[new_index].phy_addr.phy_addr_2.cd,
-        //  );
+    unsigned int phy_addr_origin;
+    unsigned int phy_addr_destination;
 
-    //register_cec_tx_msg(gbl_msg, 6);
+    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
+                                         (pcec_message->content.msg.operands[3] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 
-void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message)
+void cec_routing_information(cec_rx_message_t* pcec_message)
 {
     unsigned char index = cec_global_info.my_node_index;
     unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
     unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    unsigned int phy_addr_destination;
     unsigned char msg[4];
 
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                         (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
     msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
     msg[1] = CEC_OC_ROUTING_INFORMATION;
     msg[2] = phy_addr_ab;
     msg[3] = phy_addr_cd;
     cec_ll_tx(msg, 4);
-
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
 }
 /***************************** cec middle level code end *****************************/
 
@@ -2088,80 +1541,73 @@ void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message)
 
 static int __init cec_init(void)
 {
-    int i;    
+    int i;
     extern __u16 cec_key_map[128];
     extern hdmitx_dev_t * get_hdmitx_device(void);
     hdmitx_device = get_hdmitx_device();
     cec_key_init();
-
-    //if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
-    //    hdmitx_cec_dbg_print("CEC not init\n");
-    //    return 0;
-    //}
-    //else {
-        hdmitx_cec_dbg_print("CEC init\n");
-    //}
-
+    hdmi_print(INF, CEC "CEC init\n");
+    cec_global_info.cec_flag.cec_key_flag = 0; 
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
+    cec_global_info.cec_flag.cec_init_flag = 0;
+    
+#ifdef CONFIG_ARCH_MESON6
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+#endif
 
-    cec_rx_msg_buf.rx_write_pos = 0;
-    cec_rx_msg_buf.rx_read_pos = 0;
-    cec_rx_msg_buf.rx_buf_size = sizeof(cec_rx_msg_buf.cec_rx_message)/sizeof(cec_rx_msg_buf.cec_rx_message[0]);
-    memset(cec_rx_msg_buf.cec_rx_message, 0, sizeof(cec_rx_msg_buf.cec_rx_message));
+    cec_global_info.cec_rx_msg_buf.rx_write_pos = 0;
+    cec_global_info.cec_rx_msg_buf.rx_read_pos = 0;
+    cec_global_info.cec_rx_msg_buf.rx_buf_size = sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message)/sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message[0]);
+    memset(cec_global_info.cec_rx_msg_buf.cec_rx_message, 0, sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message));
 
     memset(&cec_global_info, 0, sizeof(cec_global_info_t));
-    //cec_global_info.my_node_index = CEC0_LOG_ADDR;
-
-    if (cec_mutex_flag == 0) {
-        //init_MUTEX(&tv_cec_sema);
-        sema_init(&tv_cec_sema,1);
-        cec_mutex_flag = 1;
-    }
+    
+    cec_global_info.hdmitx_device = hdmitx_device;
     
     kthread_run(cec_task, (void*)hdmitx_device, "kthread_cec");
+#ifdef CONFIG_ARCH_MESON6
     if(request_irq(INT_HDMI_CEC, &cec_isr_handler,
                 IRQF_SHARED, "amhdmitx-cec",
                 (void *)hdmitx_device)){
-        hdmitx_cec_dbg_print("HDMI CEC:Can't register IRQ %d\n",INT_HDMI_CEC);
-        return -EFAULT;               
+        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+#ifdef CONFIG_ARCH_MESON8
+    if(request_irq(INT_AO_CEC, &cec_isr_handler,
+                IRQF_SHARED, "amhdmitx-aocec",
+                (void *)hdmitx_device)){
+        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
     }
+#endif
 
-    remote_cec_dev = input_allocate_device();   
-    if (!remote_cec_dev)                          
-    {  
-        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Not enough memory\n");   
+    cec_global_info.remote_cec_dev = input_allocate_device();
+    if (!cec_global_info.remote_cec_dev)
+    {
+        hdmi_print(INF, CEC "remote_cec.c: Not enough memory\n");
     }
-    remote_cec_dev->name = "cec_input";
-   
-    //hdmitx_cec_dbg_print("\n--111--function:%s,line:%d,count:%d\n",__FUNCTION__,__LINE__,tasklet_cec.count);
-   // tasklet_enable(&tasklet_cec);
-    //hdmitx_cec_dbg_print("\n--222--function:%s,line:%d,count:%d\n",__FUNCTION__,__LINE__,tasklet_cec.count);
-      //tasklet_cec.data = (unsigned long)remote_cec;
-                                           
-    remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);      
-    remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0); 
-    remote_cec_dev->id.bustype = BUS_ISA;
-    remote_cec_dev->id.vendor = 0x1b8e;
-    remote_cec_dev->id.product = 0x0cec;
-    remote_cec_dev->id.version = 0x0001;
+    cec_global_info.remote_cec_dev->name = "cec_input";
+
+    cec_global_info.remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
+    cec_global_info.remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+    cec_global_info.remote_cec_dev->id.bustype = BUS_ISA;
+    cec_global_info.remote_cec_dev->id.vendor = 0x1b8e;
+    cec_global_info.remote_cec_dev->id.product = 0x0cec;
+    cec_global_info.remote_cec_dev->id.version = 0x0001;
 
     for (i = 0; i < 128; i++){
-          set_bit( cec_key_map[i], remote_cec_dev->keybit);
+          set_bit( cec_key_map[i], cec_global_info.remote_cec_dev->keybit);
       }
-                   
-    if(input_register_device(remote_cec_dev)) {  
-        hdmitx_cec_dbg_print(KERN_ERR "remote_cec.c: Failed to register device\n");  
-        input_free_device(remote_cec_dev);   
+
+    if(input_register_device(cec_global_info.remote_cec_dev)) {
+        hdmi_print(INF, CEC "remote_cec.c: Failed to register device\n");
+        input_free_device(cec_global_info.remote_cec_dev);
     }
 
     hdmitx_device->cec_init_ready = 1;
-    
-    //if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
-    //    msleep(10000);
-    //    cec_gpi_init();
-    //    cec_node_init(hdmitx_device);
-    //}
+    hdmi_print(INF, CEC "hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
     return 0;
 }
 
@@ -2170,16 +1616,22 @@ static void __exit cec_uninit(void)
     if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
         return ;
     }
-    hdmitx_cec_dbg_print("CEC: cec uninit!\n");
-    if (cec_init_flag == 1) {
-////        WRITE_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK, READ_MPEG_REG(SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+    hdmi_print(INF, CEC "cec uninit!\n");
+    if (cec_global_info.cec_flag.cec_init_flag == 1) {
+
+#ifdef CONFIG_ARCH_MESON6
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
         free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
-        cec_init_flag = 0;
+#endif
+#ifdef CONFIG_ARCH_MESON8
+        free_irq(INT_AO_CEC, (void *)hdmitx_device);
+#endif
+        cec_global_info.cec_flag.cec_init_flag = 0;
     }
+
     hdmitx_device->cec_init_ready = 0;
-    input_unregister_device(remote_cec_dev);
-    free_fiq(INT_GPIO_0, &cec_gpi_receive_bits); 
-    cec_fiq_flag = 0;   
+    input_unregister_device(cec_global_info.remote_cec_dev);
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
 }
 
 size_t cec_usrcmd_get_global_info(char * buf)
@@ -2199,15 +1651,15 @@ size_t cec_usrcmd_get_global_info(char * buf)
     buf[0] = dev_num;
     buf[1] = cec_global_info.active_log_dev;
 #if 0
-    hdmitx_cec_dbg_print("\n");
-    hdmitx_cec_dbg_print("%x\n",(unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
-    hdmitx_cec_dbg_print("%x\n", ((cec_global_info_to_usr_t*)buf)->dev_number);
-    hdmitx_cec_dbg_print("%x\n", ((cec_global_info_to_usr_t*)buf)->active_log_dev);
-    hdmitx_cec_dbg_print("%x\n", ((cec_global_info_to_usr_t*)buf)->cec_node_info_online[0].hdmi_port);
+    hdmi_print(INF, CEC "\n");
+    hdmi_print(INF, CEC "%x\n",(unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->dev_number);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->active_log_dev);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->cec_node_info_online[0].hdmi_port);
     for (i=0; i < (sizeof(cec_node_info_t) * dev_num) + 2; i++) {
-        hdmitx_cec_dbg_print("%x,",buf[i]);
+        hdmi_print(INF, CEC "%x,",buf[i]);
     }
-    hdmitx_cec_dbg_print("\n");
+    hdmi_print(INF, CEC "\n");
 #endif
     return (sizeof(cec_node_info_t) * dev_num) + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online);
 }
@@ -2233,7 +1685,7 @@ void cec_usrcmd_set_config(const char * buf, size_t count)
     char param[16] = {0};
 
     if(count > 32){
-        hdmitx_cec_dbg_print("CEC: too many args\n");
+        hdmi_print(INF, CEC "too many args\n");
     }
     for(i = 0; i < count; i++){
         if ( (buf[i] >= '0') && (buf[i] <= 'f') ){
@@ -2252,7 +1704,9 @@ void cec_usrcmd_set_config(const char * buf, size_t count)
     if((0 == value) && (1 == (param[0] & 1))){
         hdmitx_device->cec_init_ready = 1;
         hdmitx_device->hpd_state = 1;
+#ifdef CONFIG_ARCH_MESON6
         cec_gpi_init();
+#endif
         cec_node_init(hdmitx_device);
     }
     if((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2))){
@@ -2269,12 +1723,17 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
 {
     int i = 0;
     int j = 0;
+    int n = 0;
+    int m = 0;
     int bool = 0;
     char param[16] = {0};
+    char tmpbuf[32] = {0};
+    unsigned bit_set;
+    unsigned time_set;
     unsigned char msg[4] = {0};
 
     if(count > 32){
-        hdmitx_cec_dbg_print("CEC: too many args\n");
+        hdmi_print(INF, CEC "too many args\n");
     }
     for(i = 0; i < count; i++){
         if ( (buf[i] >= '0') && (buf[i] <= 'f') ){
@@ -2284,9 +1743,22 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         while ( buf[i] != ' ' )
             i ++;
     }
-   
-    hdmirx_cec_dbg_print("cec_usrcmd_set_dispatch: \n");
 
+    while((buf[n]!=',')&&(buf[i]!=' ')){
+        tmpbuf[n]=buf[n];
+        n++;
+    }
+    tmpbuf[n]=0;
+    hdmirx_cec_dbg_print("cec_usrcmd_set_dispatch: \n");
+    if(strncmp(tmpbuf, "waocec", 6)==0){
+        bit_set = simple_strtoul(tmpbuf+6, NULL, 16);
+        time_set = simple_strtoul(buf+n+1, NULL, 16);
+        cec_arbit_bit_time_set(bit_set, time_set, 1);
+        return;
+    }else if(strncmp(tmpbuf, "raocec", 6)==0){
+        cec_arbit_bit_time_read();
+        return;
+    }
     switch (param[0]) {
     case GET_CEC_VERSION:   //0 LA
         cec_usrcmd_get_cec_version(param[1]);
@@ -2336,12 +1808,11 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         cec_usrcmd_set_menu_state(param[1], param[2]);
         break;
     case SET_MENU_LANGAGE:
-        //cec_usrcmd_set_menu_language(param[1], param[2]);
         break;
     case GET_MENU_LANGUAGE:
         cec_usrcmd_get_menu_language(param[1]);
         break;
-    case GET_ACTIVE_SOURCE:     //13???????
+    case GET_ACTIVE_SOURCE:     //13
         cec_usrcmd_get_active_source();
         break;
     case SET_ACTIVE_SOURCE:
@@ -2350,20 +1821,13 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
     case SET_DEACTIVE_SOURCE:
         cec_usrcmd_set_deactive_source(param[1]);
         break;
-//    case CLR_NODE_DEV_REAL_INFO_MASK:
-//        cec_usrcmd_clear_node_dev_real_info_mask(param[1], (((cec_info_mask)param[2]) << 24) |
-//                                                         (((cec_info_mask)param[3]) << 16) |
-//                                                         (((cec_info_mask)param[4]) << 8)  |
-//                                                         ((cec_info_mask)param[5]));
-//        break;
-    case REPORT_PHYSICAL_ADDRESS:    //17 
-        cec_usrcmd_set_report_physical_address();
-        break;
+    case REPORT_PHYSICAL_ADDRESS:    //17
+    	cec_usrcmd_set_report_physical_address();
+    	break;
     case SET_TEXT_VIEW_ON:          //18 LA
-        cec_usrcmd_text_view_on(param[1]);
+    	cec_usrcmd_text_view_on(param[1]);
         break;
-    case POLLING_ONLINE_DEV:    //19 LA 
-        hdmitx_cec_dbg_print("\n-----POLLING_ONLINE_DEV------\n");
+    case POLLING_ONLINE_DEV:    //19 LA
         cec_polling_online_dev(param[1], &bool);
         break;
 
@@ -2376,12 +1840,9 @@ void cec_usrcmd_set_dispatch(const char * buf, size_t count)
         msg[1] = CEC_OC_FEATURE_ABORT;
         msg[2] = 0;
         msg[3] = CEC_UNRECONIZED_OPCODE;
-        
+
         cec_ll_tx(msg, 4);
         break;
-    case 0xaa : //for cec tx test.
-        for(i = 0; i < 128; i++)                             
-            hdmi_print(INF, CEC "test_buf[%d]:%d\n", i, test_buf[i]);
     default:
         break;
     }
@@ -2393,220 +1854,13 @@ late_initcall(cec_init);
 module_exit(cec_uninit);
 MODULE_DESCRIPTION("AMLOGIC HDMI TX CEC driver");
 MODULE_LICENSE("GPL");
+//MODULE_LICENSE("Dual BSD/GPL");
 //MODULE_VERSION("1.0.0");
 
 MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
 module_param(cec_msg_dbg_en, bool, 0664);
 
 
-/*************************** cec arbitration cts code ******************************/
-// using the cec pin as fiq gpi to assist the bus arbitration
-
-struct _cec_msg_ {
-    unsigned char msg[16];
-    unsigned char len;
-};
-
-static struct _cec_msg_ cec_msg_bak;
-
-static unsigned long frame_time_log[512] = { 0 };
-static unsigned long frame_time_idx = 0;
-static int test_idx = 0;
-static int ack_check_point[16] = { 0 };
-static unsigned char msg_log_buf[128] = { 0 };
-static unsigned int cec_tx_start = 0;
-static unsigned int cec_rx_start = 0;
-
-#define BUS_LEVEL()         (!!(aml_read_reg32(P_PREG_PAD_GPIO2_I) & (1<<13)))
-static void get_bus_free(void)
-{
-    unsigned int cnt = 0;
-    do {
-        frame_time_idx = 0;
-        while(!BUS_LEVEL()) {  // judge whether cec bus level is low
-            msleep(30);
-            cnt ++;
-            if(frame_time_idx != 0) {       // if frame_time_idx > 0, means the bus is busy
-                break;
-            }
-            if((frame_time_idx == 0) && (cnt > 33)) {       // test 1 second, if always low, return
-                pr_err("CEC: bus error, always low\n");
-                return ;
-            }
-        }
-        frame_time_idx = 0;
-        msleep(30);             // judge whether cec bus is busy
-        cnt ++;
-        if(cnt & (1 << 7)) {
-            pr_err("CEC: bus busy\n");
-        }
-    } while (frame_time_idx);   // frame_time_idx > 0, means that cec line is working
-}
-
-// return value: 1: successful      0: error
-static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
-{
-    int i;
-    unsigned int ret = 0xf;
-    unsigned int n;
-    int pos;
-    
-    cec_tx_start = 1;
-    cec_rx_start = 1;
-    get_bus_free();
-    cec_rx_start = 0;
-    frame_time_idx = 0;
-
-    for (i = 0; i < len; i++) {
-     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_0_HEADER + i, msg[i]);
-    }
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_LENGTH, len-1);
-    //cec_tx_start = 1;
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_REQ_CURRENT);//TX_REQ_NEXT
-    msleep(len * 24 + 5);
-
-    ret = hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS);
-
-    if(ret == TX_DONE)
-        ret = 1;
-    else
-        ret = 0;
-
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-    cec_tx_start = 0;
-    if(cec_msg_dbg_en == 1) {
-        pos = 0;
-        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
-        for(n = 0; n < len; n++) {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
-        }
-        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
-        msg_log_buf[pos] = '\0';
-        hdmi_print(INF, CEC "%s", msg_log_buf);
-    }
-    return ret;
-}
-
-// Return value: 0: fail    1: success
-int cec_ll_tx(const unsigned char *msg, unsigned char len)
-{
-    int ret = 0;
-    int repeat = 0;
-    int i;
-
-    memset(&cec_msg_bak, 0, sizeof(cec_msg_bak));
-    memset(ack_check_point, 0, sizeof(ack_check_point));
-
-    // save msg
-    cec_msg_bak.len = len;
-    for(i = 0; i < len; i++) {
-        cec_msg_bak.msg[i] = msg[i];
-        ack_check_point[i] = (i + 1) * 20 + 1;
-    }
-    
-    // if transmit message error, try repeat(4) times
-    do {
-        ret = cec_ll_tx_once(msg, len);
-        //ret ? msleep(18) : ((!repeat) ? msleep(12) : msleep(8));       // if transmit fails, waiting proper time to try again.
-        repeat ++;
-        ret ? 0 : msleep(31);       // if transmit fails, wait 31ms and try send again
-        cec_hw_reset();
-    } while((ret == 0) && (repeat < 3));
-
-    cec_msg_dbg_en ? hdmi_print(INF, CEC "ret = %d\n", ret) : 0;
-    if(repeat > 1) {
-        hdmi_print(INF, CEC "try %d times\n", repeat);
-    }
-
-    return ret;
-}
-
-static inline int get_value(unsigned time_rise, unsigned time_fall)
-{
-    unsigned time;
-    if(time_rise > time_fall)
-        time = time_rise - time_fall;
-    else
-        time = ((unsigned int)(0xffffffff)) - time_fall + time_rise;
-    if((time > 1300) && (time < 1700))
-        return 0;
-    if((time > 400) && (time < 800))
-        return 1;
-    if((time > 2400) && (time < 3500))
-        return 2;
-    return -1;
-}
-
-static inline int need_check_ack(unsigned idx)
-{
-    int i;
-    for(i = 0; (ack_check_point[i]) && (i < 16) ; i++) {
-        if(ack_check_point[i] == idx) {
-            return 1;
-        }
-    }
-    return 0;
-}
-
-static void cec_gpi_receive_bits(void)
-{
-    int val = 0;
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
-    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, BUS_LEVEL(), 16, 1);
-    if(!cec_tx_start)
-        return;
-    frame_time_log[frame_time_idx] = aml_read_reg32(P_ISA_TIMERE);
-
-    // ack rising position
-    val = get_value(frame_time_log[frame_time_idx], frame_time_log[frame_time_idx - 1]);
-
-    if(128 == test_idx)
-        test_idx = 0;
-    if((!cec_rx_start) && (val == 2) && (frame_time_idx > 20)) {
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_ABORT);       // stop cec tx
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-        //test_buf[test_idx++] = frame_time_idx; //for cec tx arbitration point test.
-    }
-    
-    if((!cec_rx_start) && need_check_ack(frame_time_idx)) {
-        // if val == 1, and DES != 0xf
-        // if val == 0, and DES == 0xf
-        // means we need stop cec tx
-        if(((val == 1) ? ((cec_msg_bak.msg[0] & 0xf) != 0xf) : ((cec_msg_bak.msg[0] & 0xf) == 0xf)) || (val == -1)) {
-            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_ABORT);       // stop cec tx
-            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_MSG_CMD, TX_NO_OP);
-            //test_buf[test_idx++] = frame_time_idx;//for cec tx arbitration point test.
-        }
-    }
-    (512 == frame_time_idx) ? (frame_time_idx = 0) : frame_time_idx++;
-    if(test_buf[test_idx] < frame_time_idx)
-        test_buf[test_idx] = frame_time_idx;
-    if(1 == frame_time_idx)
-        test_idx++;
-    
-}
-
-static void cec_gpi_init(void)
-{
-    if(cec_fiq_flag){
-        return;
-    }
-    cec_fiq_flag = 1;
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 0, 0, 1);     // disable irq
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR, 1, 0, 1); // Write 1 to clear irq
-
-    aml_set_reg32_bits(P_GPIO_INTR_GPIO_SEL0, 0x76, 0, 8);      // set GPIOC_23 as GPIO IRQ #0 source
-    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 0, 1);          // interrupt mode:  0: level     1: edge 
-    aml_set_reg32_bits(P_GPIO_INTR_EDGE_POL, 1, 16, 1);
-    request_fiq(INT_GPIO_0, &cec_gpi_receive_bits);
-    hdmi_print(INF, CEC "register fiq\n");
 
-////    aml_set_reg32_bits(P_MEDIA_CPU_IRQ_IN2_INTR_MASK, 1, 0, 1);     // enable irq
-}
 
-// DELETE LATER, TEST ONLY
-void cec_test_(unsigned int cmd)
-{
-    hdmi_print(INF, CEC "bus level: %s\n", BUS_LEVEL() ? "High" : "Low");
-}
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
index fd8835764a04..a8e5a0df1b37 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
@@ -356,17 +356,6 @@ int Edid_Parse_check_HDMI_VSDB(HDMI_TX_INFO_t * info, unsigned char *buff)
     }
 
     set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
-    if(info->vsdb_phy_addr.a == 0) {
-        hdmi_print(IMP, EDID "not a valid CEC physical address\n");
-    }
-    else {
-        vsdb_phy_addr_t *tmp = &info->vsdb_phy_addr;
-        if(tmp->valid){
-            aml_write_reg32(P_AO_DEBUG_REG1, (((tmp->a) & 0xf) << 12) | (((tmp->b) & 0xf) << 8) | (((tmp->c) & 0xf) << 4) | ((tmp->d) & 0xf));
-            hdmi_print(IMP, EDID "CEC Physical address: 0x%x\n",aml_read_reg32(P_AO_DEBUG_REG1));
-            hdmi_print(IMP, EDID "CEC Physical address: %1x.%1x.%1x.%1x\n", tmp->a, tmp->b, tmp->c, tmp->d);
-        }
-    }
 
     if(temp_addr >= VSpecificBoundary)
     {
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index 4ee9ff9972c0..55cdfc33fc3e 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -15,6 +15,13 @@
 #include <asm/io.h>
 #include <mach/am_regs.h>
 #include "remote_main.h"
+
+#ifdef CONFIG_AML_HDMI_TX
+#ifdef CONFIG_ARCH_MESON8
+extern int cec_power_flag;
+unsigned char cec_repeat = 10;
+#endif
+#endif
 extern char *remote_log_buf;
 static int auto_repeat_count,repeat_count = 0;
 static void remote_rel_timer_sr(unsigned long data);
@@ -417,6 +424,19 @@ int remote_hw_reprot_key(struct remote *remote_data)
 			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
 	}
 	else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg){	//repeate key
+#ifdef CONFIG_AML_HDMI_TX
+#ifdef CONFIG_ARCH_MESON8
+       extern int rc_long_press_pwr_key;
+		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
+            rc_long_press_pwr_key = 1;
+		    cec_repeat = 10;
+		    mdelay(20);
+		}
+		if(remote_data->repeat_release_code == 0x1a)
+ 		    cec_repeat--;
+
+#endif
+#endif
 		if (remote_data->repeat_enable) {
 			repeat_count++;
 			if (remote_data->repeat_tick < jiffies) {
diff --git a/drivers/amlogic/input/remote/am_remote.c b/drivers/amlogic/input/remote/am_remote.c
index 09d4815e90fb..b4a3ea275466 100755
--- a/drivers/amlogic/input/remote/am_remote.c
+++ b/drivers/amlogic/input/remote/am_remote.c
@@ -59,11 +59,10 @@
 
 type_printk input_dbg;
 #ifdef CONFIG_AML_HDMI_TX
-extern void cec_inactive_source(void);
-extern void cec_set_standby(void);
-extern int cec_power_flag;
+#ifdef CONFIG_ARCH_MESON6
 unsigned char cec_repeat = 10;
 #endif
+#endif
 
 static DEFINE_MUTEX(remote_enable_mutex);
 static DEFINE_MUTEX(remote_file_mutex);
@@ -390,14 +389,17 @@ static inline int remote_hw_reprot_key(struct remote *remote_data)
 			return -1;
 		}
 #ifdef CONFIG_AML_HDMI_TX
+#ifdef CONFIG_ARCH_MESON6
 		//printk("last_scan_code:%x\n", last_scan_code);
 		if((((scan_code >> 16) & 0xff) == 0x1a) && (!cec_repeat)) {
+            extern int rc_long_press_pwr_key;
+            rc_long_press_pwr_key = 1;
 		    cec_repeat = 10;
-		    cec_set_standby();
 		    mdelay(20);
 		}
 		if(((scan_code >> 16) & 0xff) == 0x1a)
  		    cec_repeat--;
+#endif
 #endif
 		if (remote_data->repeat_enable) {
 			if ((remote_data->repeat_tick < jiffies)&&(repeat_flag == 1)) {
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
similarity index 90%
rename from drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
rename to include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
index e4d326ddaf5f..fcabc7ffe9ec 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
@@ -17,17 +17,15 @@
 
 #ifndef _TV_CEC_H_
 #define _TV_CEC_H_
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h> 
+#include <mach/hdmi_parameter.h>
 
-//#define CEC0_LOG_ADDR 0 // TV logical address
 #define CEC0_LOG_ADDR 4 // MBX logical address
 #define TV_CEC_INTERVAL     (HZ*3)
 
 #define CEC_VERSION     "v1.3"
-#define _RX_DATA_BUF_SIZE_ 6
+#define _RX_DATA_BUF_SIZE_ 16
 
-
-//#define _SUPPORT_CEC_TV_MASTER_
 #define _RX_CEC_DBG_ON_
 #define _TX_CEC_DBG_ON_
 
@@ -42,6 +40,7 @@
 #else
 #define hdmitx_cec_dbg_print(fmt, args...)
 #endif
+#define HDMI_CEC_DEBUG()  printk("HDMI CEC DEBUG: %s [%d]\n", __FUNCTION__, __LINE__)
 
 extern unsigned int cec_tx_irq_flag;
 extern unsigned int cec_tx_irq_syn_flag;
@@ -234,7 +233,6 @@ typedef struct {
             unsigned char opcode;          // message opcode
             unsigned char operands[14];    // the maximun operand is 14
             //unsigned int  flag;            // flag = 1 ,cec key pressed;flag = 0, cec key released
-            //struct input_dev *remote_cec_dev; //cec input device
         }msg;                              // message struct
     }content;                              // message content
     unsigned char operand_num;             // number of operand
@@ -334,6 +332,7 @@ typedef enum {
     CEC_VERSION_12A,
     CEC_VERSION_13,
     CEC_VERSION_13A,
+    CEC_VERSION_14A,
 } cec_version_e;
 
 typedef enum {
@@ -343,16 +342,6 @@ typedef enum {
     CEC_HDMI_PORT_3,
 } cec_hdmi_port_e;
 
-//typedef enum {
-//    CEC_MENU_LANG_CHN = 0,
-//    CEC_MENU_LANG_ENG,
-//    CEC_MENU_LANG_JAP,
-//    CEC_MENU_LANG_KOR,
-//    CEC_MENU_LANG_FRA,
-//    CEC_MENU_LANG_GER,
-//    //CEC_MENU_LANG_UNSUPPORTED = 0xff;
-//} cec_menu_lang_e;
-
 typedef enum {
     OFF = 0,
     ON,
@@ -377,23 +366,12 @@ typedef unsigned long cec_info_mask;
 #define ONE_TOUCH_STANDBY_MASK               2
 #define AUTO_POWER_ON_MASK                   3
 
-//typedef struct {
-//    unsigned long vendor_id;
-//    unsigned char vendor_id_byte_num;
-//} vendor_id_t;
-
-//typedef struct {
-//    unsigned char vsdb_phy_addr_offset;
-//    unsigned short phy_addr[3];
-//    unsigned char checksum[3];
-//} vsdb_phy_addr_t;
 
 typedef struct {
     cec_hdmi_port_e hdmi_port;
     cec_info_mask real_info_mask;
     unsigned char cec_version;
     unsigned int vendor_id:24;
-//    vendor_id_t vendor_id;
     unsigned char dev_type;
     unsigned char menu_status;
     cec_power_status_e power_status;
@@ -435,16 +413,31 @@ typedef struct {
             } audio_status;
         } audio;
     }specific_info;
+    
 } cec_node_info_t;
 
+typedef struct {
+    cec_rx_message_t cec_rx_message[_RX_DATA_BUF_SIZE_];
+    unsigned char rx_write_pos;
+    unsigned char rx_read_pos;
+    unsigned char rx_buf_size;
+} cec_rx_msg_buf_t;
+
+typedef struct {
+    unsigned int cec_key_flag;
+    unsigned int cec_init_flag;
+    int cec_fiq_flag;
+    int cec_repeat_flag;
+} cec_flag_t;
 
 typedef struct {
     unsigned short dev_mask;
-    //unsigned char tv_log_addr;
-    //unsigned short tv_phy_addr;
     unsigned char active_log_dev;
     unsigned char my_node_index;
+    cec_flag_t cec_flag;
+    struct input_dev *remote_cec_dev; //cec input device
     cec_node_info_t cec_node_info[MAX_NUM_OF_DEV];
+    cec_rx_msg_buf_t cec_rx_msg_buf;
     hdmitx_dev_t* hdmitx_device;
 } cec_global_info_t;
 
@@ -478,7 +471,6 @@ typedef enum {
     SET_ACTIVE_SOURCE,
     SET_DEACTIVE_SOURCE,
     CLR_NODE_DEV_REAL_INFO_MASK,
-    //SET_STREAM_PATH,
     REPORT_PHYSICAL_ADDRESS,    //0x17
     SET_TEXT_VIEW_ON,
     POLLING_ONLINE_DEV, //0x19
@@ -494,22 +486,23 @@ typedef enum {
     TV_CEC_POLLING_OFF = 0,
     TV_CEC_POLLING_ON,
 } tv_cec_polling_state_e;
-typedef struct {
-    cec_rx_message_t cec_rx_message[_RX_DATA_BUF_SIZE_];
-    unsigned char rx_write_pos;
-    unsigned char rx_read_pos;
-    unsigned char rx_buf_size;
-} cec_rx_msg_buf_t;
 
 typedef enum {
     DEVICE_MENU_ACTIVE = 0,
     DEVICE_MENU_INACTIVE,    
 } cec_device_menu_state_e;
 
-extern cec_rx_msg_buf_t cec_rx_msg_buf;
-extern unsigned char cec_power_flag;
+void cec_enable_irq(void);
+void cec_disable_irq(void);
+
+void tx_irq_handle(void);
+void ao_cec_init(void);
+
+int cec_ll_tx_polling(const unsigned char *msg, unsigned char len);
+void cec_gpi_receive_bits(void);
 
 int cec_ll_tx(const unsigned char *msg, unsigned char len);
+int cec_ll_rx( unsigned char *msg, unsigned char *len);
 
 void cec_test_function(unsigned char* arg, unsigned char arg_cnt);
 void cec_node_init(hdmitx_dev_t* hdmitx_device);
@@ -526,8 +519,8 @@ void cec_set_pending(tv_cec_pending_e on_off);
 void cec_polling_online_dev(int log_addr, int *bool);
 unsigned short cec_log_addr_to_dev_type(unsigned char log_addr);
 
-void cec_usrcmd_routing_information(cec_rx_message_t* pcec_message);
-void cec_usrcmd_routing_change(cec_rx_message_t* pcec_message);
+void cec_routing_information(cec_rx_message_t* pcec_message);
+void cec_routing_change(cec_rx_message_t* pcec_message);
 void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message);
 void cec_usrcmd_set_device_vendor_id(void);
 void cec_usrcmd_get_cec_version(unsigned char log_addr);
@@ -547,7 +540,6 @@ void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode);
 void cec_usrcmd_get_menu_state(unsigned char log_addr);
 void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type);
 void cec_usrcmd_get_menu_language(unsigned char log_addr);
-//void cec_usrcmd_set_menu_language(unsigned char log_addr, cec_menu_lang_e menu_lang);
 void cec_usrcmd_get_active_source(void);
 void cec_usrcmd_set_active_source(void);
 void cec_usrcmd_set_deactive_source(unsigned char log_addr);
@@ -561,7 +553,7 @@ void cec_active_source(cec_rx_message_t* pcec_message);
 void cec_set_stream_path(cec_rx_message_t* pcec_message);
 void cec_set_osd_name(cec_rx_message_t* pcec_message);
 void cec_set_osd_name_init(void);
-void cec_deactive_source(cec_rx_message_t* pcec_message);
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message);
 void cec_set_system_audio_mode(void);
 void cec_system_audio_mode_request(void);
 void cec_report_audio_status(void);
@@ -569,11 +561,12 @@ void cec_get_menu_language_smp(void);
 void cec_device_vendor_id_smp(void);
 void cec_menu_status_smp(cec_device_menu_state_e status);
 void cec_set_imageview_on_irq(void);
+void cec_active_source_irq(void);
 
 void cec_report_physical_address_smp(void);
 void cec_imageview_on_smp(void);
 void cec_active_source_smp(void);
-void cec_active_source_irq(void);
+void cec_active_source_rx(cec_rx_message_t* pcec_message);
 
 size_t cec_usrcmd_get_global_info(char * buf);
 void cec_usrcmd_set_dispatch(const char * buf, size_t count);
@@ -586,17 +579,23 @@ void cec_user_control_released_irq(void);
 void cec_user_control_pressed_irq(void);
 void cec_inactive_source(void);
 void cec_set_standby(void);
+void cec_isr_post_process(void);
+void cec_clear_buf(unsigned int flag);
+#ifdef CONFIG_ARCH_MESON8
 
-extern struct input_dev *remote_cec_dev;
-extern __u16 cec_key_map[];
-extern unsigned int cec_key_flag;
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag);
+void tx_irq_handle(void);
+void cec_arbit_bit_time_read(void);
+#endif
+unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message);
+void cec_send_event(cec_rx_message_t* pcec_message);
+void cec_user_control_pressed(cec_rx_message_t* pcec_message);
+void cec_user_control_released(cec_rx_message_t* pcec_message);  
+void cec_standby(cec_rx_message_t* pcec_message);
+extern void cec_key_init(void);
 
+extern __u16 cec_key_map[];
 extern cec_global_info_t cec_global_info;
-extern unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message);
-extern void cec_send_event(cec_rx_message_t* pcec_message);
-extern void cec_user_control_pressed(cec_rx_message_t* pcec_message);
-extern void cec_user_control_released(cec_rx_message_t* pcec_message);  
-extern void cec_standby(cec_rx_message_t* pcec_message);
-extern void cec_key_init(void);
+
 #endif
 
-- 
2.19.0

