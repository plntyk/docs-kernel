From d09557277d0f415caba991d501e092782e41be5b Mon Sep 17 00:00:00 2001
From: "chunhai.guo" <chunhai.guo@amlogic.com>
Date: Tue, 21 Jan 2014 17:14:36 +0800
Subject: [PATCH 3097/5965] PD #85897:  add sdhc support base on M8 RevB

---
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd |  162 ++
 arch/arm/mach-meson8/include/mach/sd.h       |  101 +-
 drivers/amlogic/mmc/Kconfig                  |    4 +
 drivers/amlogic/mmc/Makefile                 |    6 +-
 drivers/amlogic/mmc/aml_sdhc.dtd             |  179 ++
 drivers/amlogic/mmc/aml_sdhc_m8.c            | 1709 ++++++++++++------
 drivers/amlogic/mmc/aml_sdio.c               |  604 +++----
 drivers/amlogic/mmc/amlsd.c                  |  145 +-
 drivers/amlogic/mmc/amlsd.h                  |   40 +-
 drivers/mmc/card/block.c                     |   25 +-
 drivers/mmc/core/sd.c                        |    2 +
 11 files changed, 2060 insertions(+), 917 deletions(-)
 create mode 100755 drivers/amlogic/mmc/aml_sdhc.dtd
 mode change 100644 => 100755 drivers/mmc/card/block.c
 mode change 100644 => 100755 drivers/mmc/core/sd.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index cc4c4bbfa1ae..169b4f94e682 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -484,7 +484,104 @@ sdio{
             card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
         };
     };
+	
+    // sdhc{
+        // compatible = "amlogic,aml_sdhc";
+        // dev_name = "aml_sdhc.0";
+        // reg = <0xc1108e00 0x3c>;
+        // pinctrl-names = "sdhc_sd_clk_cmd_pins", "sdhc_sd_all_pins", "sdhc_emmc_clk_cmd_pins", "sdhc_emmc_all_pins", "sdhc_sdio_clk_cmd_pins", "sdhc_sdio_all_pins";
+        // pinctrl-0 = <&sdhc_sd_clk_cmd_pins>;
+        // pinctrl-1 = <&sdhc_sd_all_pins>;
+        // pinctrl-2 = <&sdhc_emmc_clk_cmd_pins>;
+        // pinctrl-3 = <&sdhc_emmc_all_pins>;
+        // pinctrl-4 = <&sdhc_sdio_clk_cmd_pins>;
+        // pinctrl-5 = <&sdhc_sdio_all_pins>;
+        // //pinctrl-6 = <&sd_1bit_pins>;
+
+//$$ DEVICE="sd"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 3 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_STR = "jtag_pin"
+//$$ L2 PROP_STR = "gpio_cd"
+//$$ L2 PROP_STR = "gpio_ro"
+//$$ L2 PROP_U32 = "irq_in"
+//$$ L2 PROP_U32 = "irq_out"
+//$$ L2 PROP_U32 = "card_type"
+        // sd{
+        //     status = "okay";
+        //     port = <4>;          /**0:sdhc_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+        //     pinname = "sd";
+        //     ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+        //     caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED","MMC_CAP_UHS_SDR12","MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50","MMC_CAP_UHS_SDR104";
+        //     f_min = <300000>;
+        //     f_max = <100000000>;
+        //     max_req_size = <0x20000>;          /**128KB*/
+        //     gpio_dat3 = "CARD_4";
+        //     //jtag_pin = "CARD_0";
+        //     gpio_cd = "CARD_6";
+        //     //gpio_ro = "GPIOZ_0";
+        //     irq_in = <3>;
+        //     irq_out = <5>;
+        //     card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        // };
 
+//$$ DEVICE="emmc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_U32 = "card_type"
+        // emmc{
+        //     status = "okay";
+        //     port = <5>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+        //     pinname = "emmc";
+        //     ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+        //     caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+        //     f_min = <300000>;
+        //     f_max = <50000000>;
+        //     f_max_w = <50000000>;
+        //     max_req_size = <0x20000>;          /**128KB*/
+        //     gpio_dat3 = "BOOT_3";
+        //     card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        // };   
+
+//$$ DEVICE="sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"    
+//$$ L2 PROP_U32 = "card_type"    
+        // sdio{
+        //     status = "okay";
+        //     port = <3>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+        //     pinname = "sdio";
+        //     ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+        //     caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_UHS_SDR12","MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50","MMC_CAP_UHS_SDR104";
+        //     f_min = <300000>;
+        //     f_max = <100000000>;
+        //     max_req_size = <0x20000>;          /**128KB*/
+        //     card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        // };
+    // };
+        
 /// ***************************************************************************************
 ///	-	I2C
 //$$ MODULE="I2C"
@@ -1418,6 +1515,71 @@ sdio{
             amlogic,pullup=<1>;
             amlogic,pullupen=<1>;
         };
+        
+        sdhc_sd_clk_cmd_pins:sdhc_sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000030>;         /*sdhc b*/
+            amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                4 0x7c000000        /*sdhc c*/
+                                2 0x0000fc00        /*sdio b*/
+                                8 0x00000600>;      /*UART*/
+            amlogic,pins = "CARD_2","CARD_3"; /* CARD_2:CLK, CARD_3:CMD */
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        sdhc_sd_all_pins:sdhc_sd_all_pins{
+            amlogic,setmask=<2 0x000000f0>;         /*sdhc b*/
+            amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                4 0x7c000000        /*sdhc c*/
+                                2 0x0000fc00        /*sdio b*/
+                                8 0x00000600>;      /*UART*/
+            amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+        sdhc_emmc_clk_cmd_pins:sdhc_emmc_clk_cmd_pins{
+            amlogic,setmask=<4 0x0c000000>;         /*bit[26-27] */
+            amlogic,clrmask=<2 0x04c000f0           /*sdhc b & nand*/
+                                5 0x00007c00        /*sdhc a*/
+                                6 0x3f000000>;        /*sdio c*/
+            amlogic,pins = "BOOT_16","BOOT_17"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        sdhc_emmc_all_pins:sdhc_emmc_all_pins{
+            amlogic,setmask=<4 0x7c000000>;         /*sdhc c*/
+            amlogic,clrmask=<2 0x04c000f0           /*sdhc b & nand*/
+                                5 0x00007c00        /*sdhc a*/
+                                6 0x3f000000>;        /*sdio c*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4","BOOT_5","BOOT_6","BOOT_7","BOOT_16","BOOT_17";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+        sdhc_sdio_clk_cmd_pins:sdhc_sdio_clk_cmd_pins{
+            amlogic,setmask=<5 0x00000c00>;         /*sdhc a bit[10-11] */
+            amlogic,clrmask=<2 0x058000f0           /*sdhc b*/
+                                4 0x7c000000        /*sdhc c */
+                                8 0x0000003f>;        /*sdio a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        sdhc_sdio_all_pins:sdhc_sdio_all_pins{
+            amlogic,setmask=<5 0x00006c00>;         /*sdhc a*/
+            amlogic,clrmask=<2 0x058000f0           /*sdhc b*/
+                                4 0x7c000000        /*sdhc c */
+                                8 0x0000003f>;        /*sdio a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
 
 //$$ MATCH "I2C_AO_pin_match" = "&ao_i2c_master"
 //$$ L2 PROP_U32 2 = "amlogic,setmask"
diff --git a/arch/arm/mach-meson8/include/mach/sd.h b/arch/arm/mach-meson8/include/mach/sd.h
index 52980d0e0079..c2f893591974 100755
--- a/arch/arm/mach-meson8/include/mach/sd.h
+++ b/arch/arm/mach-meson8/include/mach/sd.h
@@ -14,23 +14,33 @@
 #include <linux/earlysuspend.h>
 
 enum aml_mmc_waitfor {
-	XFER_INIT,
+	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
-	XFER_IRQ_OCCUR,			/* 2 */
-	XFER_IRQ_FIFO_ERR,		/* 3 */
-	XFER_IRQ_CRC_ERR,		/* 4 */
-	XFER_IRQ_TIMEOUT_ERR,	/* 5 */
-	XFER_IRQ_TASKLET_CMD,	/* 6 */
-	XFER_IRQ_TASKLET_DATA,	/* 7 */
-	XFER_IRQ_TASKLET_BUSY,	/* 8 */
-	XFER_IRQ_UNKNOWN_IRQ,	/* 9 */
-	XFER_TIMER_TIMEOUT,		/* 10 */
-	XFER_TASKLET_CMD,		/* 11 */
-	XFER_TASKLET_DATA,		/* 12 */
-	XFER_TASKLET_BUSY,		/* 13 */
-	XFER_TIMEDOUT,			/* 14 */
-	XFER_FINISHED,			/* 15 */
-	XFER_AFTER_START,		/* 16 */
+	XFER_AFTER_START,		/* 2 */
+	XFER_IRQ_OCCUR,			/* 3 */
+	XFER_IRQ_TASKLET_CMD,	/* 4 */
+	XFER_IRQ_TASKLET_DATA,	/* 5 */
+	XFER_IRQ_TASKLET_BUSY,	/* 6 */
+	XFER_IRQ_UNKNOWN_IRQ,	/* 7 */
+	XFER_TIMER_TIMEOUT,		/* 8 */
+	XFER_TASKLET_CMD,		/* 9 */
+	XFER_TASKLET_DATA,		/* 10 */
+	XFER_TASKLET_BUSY,		/* 11 */
+	XFER_TIMEDOUT,			/* 12 */
+	XFER_FINISHED,			/* 13 */
+};
+
+enum aml_host_status { /* Host controller status */
+	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
+	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
+	HOST_TX_FIFO_EMPTY,	    /* 2 */
+	HOST_RSP_CRC_ERR,	    /* 3 */
+	HOST_DAT_CRC_ERR,	    /* 4 */
+	HOST_RSP_TIMEOUT_ERR,   /* 5 */
+	HOST_DAT_TIMEOUT_ERR,   /* 6 */
+    HOST_ERR_END,	        /* 7, end of errors */
+	HOST_TASKLET_CMD,	    /* 8 */
+	HOST_TASKLET_DATA,	    /* 9 */
 };
 
 struct amlsd_host;
@@ -38,8 +48,8 @@ struct amlsd_platform {
 	struct amlsd_host* host;
 	struct mmc_host *mmc;
 	struct list_head sibling;
-	unsigned long ocr_avail;
-	unsigned int port;
+	u32 ocr_avail;
+	u32 port;
 #define     PORT_SDIO_A     0
 #define     PORT_SDIO_B     1
 #define     PORT_SDIO_C     2
@@ -56,9 +66,12 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
+	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
+	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
+
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -71,6 +84,7 @@ struct amlsd_platform {
 	unsigned int gpio_ro;
     unsigned int gpio_dat3;
     unsigned int jtag_pin;
+
     int is_sduart;
     bool is_in;
 
@@ -130,21 +144,21 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	struct tasklet_struct cmd_tlet;
-	struct tasklet_struct data_tlet;
-	struct tasklet_struct busy_tlet;
-	struct tasklet_struct to_tlet;
+	// struct tasklet_struct cmd_tlet;
+	// struct tasklet_struct data_tlet;
+	// struct tasklet_struct busy_tlet;
+	// struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	struct early_suspend amlsd_early_suspend;
+	// struct early_suspend amlsd_early_suspend;
 
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	unsigned int clkc_w;
-	unsigned int pdma;
-	unsigned int pdma_s;
-	unsigned int pdma_low;
+	// unsigned int clkc_w;
+	// unsigned int pdma;
+	// unsigned int pdma_s;
+	// unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -157,12 +171,18 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
+	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-	char		*status;
-	unsigned int		ccnt, dcnt;
+    bool    is_gated;
+	// unsigned int		ccnt, dcnt;
+
+	int     status; // host status: xx_error/ok
+
+    char    *msg_buf;
+#define MESSAGE_BUF_SIZE            512
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -174,20 +194,22 @@ struct amlsd_host {
 	struct notifier_block	freq_transition;
 #endif
 
-    u32			opcode; // add by gch for debug
-	u32			arg; // add by gch for debug
+    u32			opcode;
+	u32			arg;
+    u32         cmd25_cnt;
     
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
     u32         time_req_sta; // request start time
+
+    u32         reg_buf[16];
 #endif
     
-    struct pinctrl *pinctrl;
-    char pinctrl_name[30];
-
-    int storage_flag; // used for judging if there is a tsd/emmc
+    struct pinctrl  *pinctrl;
+    char        pinctrl_name[30];
 
+    int         storage_flag; // used for judging if there is a tsd/emmc
     int         version; // bit[7-0]--minor version, bit[31-8]--major version
 };
 
@@ -514,7 +536,7 @@ struct sdhc_ista{
 	u32 rxfifo_full:1; /*[12] RxFIFO Full(W1C)*/
 	u32 txfifo_empty:1; /*[13] TxFIFO Empty(W1C)*/
 	u32 addi_dat1_irq:1; /*[14] Additional SDIO DAT1 Interrupt*/
-	u32 reserved:19; /*[31:13] reserved*/
+	u32 reserved:17; /*[31:13] reserved*/
 };
 
 /*
@@ -548,6 +570,7 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
+#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
@@ -611,6 +634,12 @@ extern struct mmc_host *sdio_host;
 		printk("[%s] " fmt, __FUNCTION__, ##args);	\
 }while(0)
 
+
+#define print_dbg(fmt, args...) do{\
+	printk("[%s]\033[0;40;35m " fmt "\033[0m", __FUNCTION__, ##args);  \
+}while(0)
+
+
 // P_AO_SECURE_REG1 is "Secure Register 1" in <M8-Secure-AHB-Registers.doc>
 #define aml_jtag_gpioao() do{\
     aml_clr_reg32_mask(P_AO_SECURE_REG1, ((1<<5) | (1<<9))); \
diff --git a/drivers/amlogic/mmc/Kconfig b/drivers/amlogic/mmc/Kconfig
index 90d655a22bee..1d12e115afeb 100755
--- a/drivers/amlogic/mmc/Kconfig
+++ b/drivers/amlogic/mmc/Kconfig
@@ -16,5 +16,9 @@ config MMC_AML
 config MMC_AML_DEBUG
     bool "Amlogic Multimedia Card Debug support"
 	default n
+	
+config AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW
+    bool "force read and write to use single-block mode(CMD17/24)."
+	default n
     
 endmenu
diff --git a/drivers/amlogic/mmc/Makefile b/drivers/amlogic/mmc/Makefile
index 0f43afc04bab..bc5f7f82cc0e 100755
--- a/drivers/amlogic/mmc/Makefile
+++ b/drivers/amlogic/mmc/Makefile
@@ -8,9 +8,9 @@ endif
 
 obj-$(CONFIG_MMC_AML)   += aml_sdio.o amlsd.o amlsd_of.o
 
-#ifeq ($(CONFIG_ARCH_MESON8),y)
-#obj-$(CONFIG_MMC_AML) += aml_sdhc_m8.o
-#endif
+ifeq ($(CONFIG_ARCH_MESON8),y)
+	obj-$(CONFIG_MMC_AML) += aml_sdhc_m8.o
+endif
 
 # ifeq ($(CONFIG_ARCH_MESON6),y)
 # obj-$(CONFIG_MMC_AML) += aml_sdhc.o
diff --git a/drivers/amlogic/mmc/aml_sdhc.dtd b/drivers/amlogic/mmc/aml_sdhc.dtd
new file mode 100755
index 000000000000..3cae57fcfb89
--- /dev/null
+++ b/drivers/amlogic/mmc/aml_sdhc.dtd
@@ -0,0 +1,179 @@
+#ifdef CONFIG_MMC_AML
+#ifdef CONFIG_ARCH_MESON8
+//$$ DEVICE="aml_sdhc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 7 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "sdhc_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "sdhc_pin_1_match" = "pinctrl-1"
+//$$ L2 PROP_CHOICE "sdhc_pin_2_match" = "pinctrl-2"
+//$$ L2 PROP_CHOICE "sdhc_pin_3_match" = "pinctrl-3"
+//$$ L2 PROP_CHOICE "sdhc_pin_4_match" = "pinctrl-4"
+//$$ L2 PROP_CHOICE "sdhc_pin_5_match" = "pinctrl-5"
+//$$ L2 PROP_CHOICE "sdhc_pin_6_match" = "pinctrl-6"
+    sdhc{
+        compatible = "amlogic,aml_sdhc";
+        dev_name = "aml_sdhc.0";
+        reg = <0xc1108e00 0x3c>;
+        pinctrl-names = "sdhc_sd_clk_cmd_pins", "sdhc_sd_all_pins", "sdhc_emmc_clk_cmd_pins", "sdhc_emmc_all_pins", "sdhc_sdio_clk_cmd_pins", "sdhc_sdio_all_pins";
+        pinctrl-0 = <&sdhc_sd_clk_cmd_pins>;
+        pinctrl-1 = <&sdhc_sd_all_pins>;
+        pinctrl-2 = <&sdhc_emmc_clk_cmd_pins>;
+        pinctrl-3 = <&sdhc_emmc_all_pins>;
+        pinctrl-4 = <&sdhc_sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdhc_sdio_all_pins>;
+        //pinctrl-6 = <&sd_1bit_pins>;
+
+//$$ DEVICE="sd"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 3 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_STR = "jtag_pin"
+//$$ L2 PROP_STR = "gpio_cd"
+//$$ L2 PROP_STR = "gpio_ro"
+//$$ L2 PROP_U32 = "irq_in"
+//$$ L2 PROP_U32 = "irq_out"
+//$$ L2 PROP_U32 = "card_type"
+        sd{
+            status = "okay";
+            port = <4>;          /**0:sdhc_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED","MMC_CAP_UHS_SDR12","MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50","MMC_CAP_UHS_SDR104";
+            f_min = <300000>;
+            f_max = <100000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "CARD_4";
+            //jtag_pin = "CARD_0";
+            gpio_cd = "CARD_6";
+            //gpio_ro = "GPIOZ_0";
+            irq_in = <3>;
+            irq_out = <5>;
+            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+//$$ DEVICE="emmc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_U32 = "card_type"
+        emmc{
+            status = "okay";
+            port = <5>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "BOOT_3";
+            card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };   
+
+//$$ DEVICE="sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"    
+//$$ L2 PROP_U32 = "card_type"    
+        sdio{
+            status = "okay";
+            port = <3>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sdio";
+            ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_UHS_SDR12","MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50","MMC_CAP_UHS_SDR104";
+            f_min = <300000>;
+            f_max = <100000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+    };
+#endif
+#endif
+
+
+
+
+        sdhc_sd_all_pins:sdhc_sd_all_pins{
+            amlogic,setmask=<2 0x000000f0>;         /*sdhc b*/
+            amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                4 0x7c000000        /*sdhc c*/
+                                2 0x0000fc00        /*sdio b*/
+                                8 0x00000600>;      /*UART*/
+            amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        sdhc_sd_clk_cmd_pins:sdhc_sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000030>;         /*sdhc b*/
+            amlogic,clrmask=<5 0x00007c00           /*sdhc a*/
+                                4 0x7c000000        /*sdhc c*/
+                                2 0x0000fc00        /*sdio b*/
+                                8 0x00000600>;      /*UART*/
+            amlogic,pins = "CARD_2","CARD_3"; /* CARD_2:CLK, CARD_3:CMD */
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+        sdhc_emmc_clk_cmd_pins:sdhc_emmc_clk_cmd_pins{
+            amlogic,setmask=<4 0x0c000000>;         /*bit[26-27] */
+            amlogic,clrmask=<2 0x04c000f0           /*sdhc b & nand*/
+                                5 0x00007c00        /*sdhc a*/
+                                6 0x3f000000>;        /*sdio c*/
+            amlogic,pins = "BOOT_16","BOOT_17"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        sdhc_emmc_all_pins:sdhc_emmc_all_pins{
+            amlogic,setmask=<4 0x7c000000>;         /*sdhc c*/
+            amlogic,clrmask=<2 0x04c000f0           /*sdhc b & nand*/
+                                5 0x00007c00        /*sdhc a*/
+                                6 0x3f000000>;        /*sdio c*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4","BOOT_5","BOOT_6","BOOT_7","BOOT_16","BOOT_17";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+        sdhc_sdio_clk_cmd_pins:sdhc_sdio_clk_cmd_pins{
+            amlogic,setmask=<5 0x00000c00>;         /*sdhc a bit[10-11] */
+            amlogic,clrmask=<2 0x058000f0           /*sdhc b*/
+                                4 0x7c000000        /*sdhc c */
+                                8 0x0000003f>;        /*sdio a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        sdhc_sdio_all_pins:sdhc_sdio_all_pins{
+            amlogic,setmask=<5 0x00006c00>;         /*sdhc a*/
+            amlogic,clrmask=<2 0x058000f0           /*sdhc b*/
+                                4 0x7c000000        /*sdhc c */
+                                8 0x0000003f>;        /*sdio a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
diff --git a/drivers/amlogic/mmc/aml_sdhc_m8.c b/drivers/amlogic/mmc/aml_sdhc_m8.c
index d81ad9b419f5..82cdc17c2868 100755
--- a/drivers/amlogic/mmc/aml_sdhc_m8.c
+++ b/drivers/amlogic/mmc/aml_sdhc_m8.c
@@ -23,13 +23,92 @@
 #include <mach/power_gate.h>
 #include <linux/clk.h>
 #include <mach/register.h>
-#include <mach/gpio.h>
+// #include <mach/gpio.h>
 #include <mach/pinmux.h>
 #include <mach/irqs.h>
 #include <linux/irq.h>
 #include <mach/sd.h>
+#include <mach/mod_gate.h>
 #include "amlsd.h"
 
+unsigned int rx_clk_phase_set=10;
+unsigned int sd_clk_phase_set=1;
+unsigned int rx_endian=7;
+unsigned int tx_endian=7;
+unsigned int val1=0;
+
+static void aml_sdhc_clk_switch (struct amlsd_platform* pdata, int clk_div, int clk_src_sel);
+static int aml_sdhc_status (struct amlsd_host* host);
+
+#if 0
+//NAND RB pin
+static void aml_sdhc_gpio_dbg_level(unsigned val)
+{
+    //clear pinmux
+    aml_clr_reg32_mask(P_PERIPHS_PIN_MUX_2, (1<<17));
+    
+    //set output mode   
+    aml_clr_reg32_mask(P_PREG_PAD_GPIO3_EN_N, (1<<10));
+    
+    //set output value
+    if(val == 1)  
+        aml_set_reg32_mask(P_PREG_PAD_GPIO3_O, (1<<10));
+    else
+        aml_clr_reg32_mask(P_PREG_PAD_GPIO3_O, (1<<10));         
+}
+#endif
+
+void aml_debug_print_buf (char *buf, int size)
+{
+    int i;
+
+    if (size > 512)
+        size = 512;
+
+    printk("%8s : ", "Address");
+    for (i=0; i<16; i++) {
+        printk("%02x ", i);
+    }
+    printk("\n");
+    printk("==========================================================\n");
+
+    for (i=0; i<size; i++) {
+        if ((i % 16) == 0)
+            printk("%08x : ", i);
+
+        printk("%02x ", buf[i]);
+
+        if ((i % 16) == 15)
+            printk("\n");
+    }
+    printk("\n");
+}
+
+int aml_buf_verify (int *buf, int blocks, int lba)
+{
+    int block_size;
+    int i, j;
+    int lba_bak = lba;
+
+    sdhc_err("Enter\n");
+    for (i=0; i<blocks; i++) {
+        for (j=0; j<128; j++) {
+            if (buf[j] != (lba*512 + j)) {
+                sdhc_err("buf is error, lba_bak=%#x, lba=%#x, offset=%#x, blocks=%d\n", lba_bak, lba, j, blocks);
+                sdhc_err("buf[j]=%#x, target=%#x\n", buf[j], (lba*512 + j));
+                block_size = (lba - lba_bak)*512;
+                aml_debug_print_buf((char*)(buf+block_size), 512);
+
+                return -1;
+            }
+        }
+        lba++;
+        buf += 128;
+    }
+
+    return 0;
+}
+
 /*soft reset after errors*/
 void aml_sdhc_host_reset(struct amlsd_host* host)
 {
@@ -44,63 +123,58 @@ void aml_sdhc_host_reset(struct amlsd_host* host)
 static void aml_sdhc_reg_init(struct amlsd_host* host)
 {
     struct sdhc_ctrl ctrl = {0};
-    struct sdhc_clkc clkc = {0};
-    struct sdhc_pdma pdma = {0};
+    // struct sdhc_pdma pdma = {0};
+    u32 vpdma = readl(host->base+SDHC_PDMA);
+    struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
     struct sdhc_misc misc = {0};
-    struct sdhc_enhc enhc = {0};
-    struct sdhc_clk2 clk2 = {0};
-    u32 val;
+    u32 vclkc;
+    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
+    // struct sdhc_clk2 clk2 = {0};
+    u32 venhc;
+    struct sdhc_enhc *enhc = (struct sdhc_enhc *)&venhc;
+    // u32 val;
+
+    switch_mod_gate_by_type(MOD_SDHC, 1);
+    // print_dbg("HHI_GCLK_MPEG0=%#x\n", READ_CBUS_REG(HHI_GCLK_MPEG0));
 
     aml_sdhc_host_reset(host);
 
-    ctrl.rx_timeout = 0x7f;
-    ctrl.rx_period = 0xf;
+    ctrl.rx_period = 0xf;//0x08; // 0xf;
+    ctrl.rx_timeout = 0x7f;//0x40; // 0x7f;
 
     /*R/W endian 7*/
     ctrl.rx_endian = 0x7;
-    ctrl.tx_endian = 0;
+    ctrl.tx_endian = 0x7;
     writel(*(u32*)&ctrl, host->base + SDHC_CTRL);
-#if 0
-    /*
-        * Clock Module Enable, Should set before switch on, and after switch off
-        */
-    clkc.mod_clk_on = 1;
-    writel(*(u32*)&clkc, host->base+SDHC_CLKC);
-    clkc.tx_clk_on = 1;
-    clkc.rx_clk_on = 1;
-    clkc.sd_clk_on = 1;
-    writel(*(u32*)&clkc, host->base+SDHC_CLKC);
-    clkc.clk_src_sel = SDHC_CLOCK_SRC_FCLK_DIV5;
-    clkc.mem_pwr_off = 0;
-    writel(*(u32*)&clkc, host->base + SDHC_CLKC);
-    printk("[aml_sdhc_reg_init] clkc %x\n", *(u32*)&clkc);
-    val = readl(host->base + SDHC_CLKC);
-    printk("[aml_sdhc_reg_init] val %x\n", val);
-#endif
-    clk2.rx_clk_phase = 31;
-    clk2.sd_clk_phase = 0;
-    writel(*(u32*)&clk2, host->base + SDHC_CLK2);
-
-    pdma.dma_mode = 0;
-    pdma.dma_urgent = 1;
-    pdma.rd_burst = 3;
-    pdma.wr_burst = 3;
-    pdma.rxfifo_th = 7;
-    pdma.txfifo_th = 0x18;
-    host->pdma = *(u32*)&pdma;
-    writel(*(u32*)&pdma, host->base + SDHC_PDMA);
+
+    vclkc = readl(host->base+SDHC_CLKC);
+    clkc->mem_pwr_off = 0;
+    writel(vclkc, host->base+SDHC_CLKC);
+
+    pdma->dma_mode = 0;
+    pdma->dma_urgent = 1;
+    pdma->wr_burst = 3; // means 4
+    pdma->txfifo_th = 49; // means 49
+    pdma->rd_burst = 7; // means 8
+    pdma->rxfifo_th = 8; // means 8
+    // pdma->rd_burst = 3;
+    // pdma->wr_burst = 3;
+    // pdma->rxfifo_th = 7;
+    // pdma->txfifo_th = 0x18;
+    writel(vpdma, host->base+SDHC_PDMA);
 
     /*Send Stop Cmd automatically*/
     misc.manual_stop = 0;
-	//writel(*(u32*)&misc, host->base + SDHC_MISC);
-	writel(0x80000150, host->base + SDHC_MISC);
+    //writel(*(u32*)&misc, host->base + SDHC_MISC);
+    writel(0x80000150, host->base + SDHC_MISC);
 
-    enhc.rxfifo_th = 16;
-    enhc.dma_rd_resp = 1;
-    enhc.dma_wr_resp = 0;
-    enhc.sdio_irq_period = 12;
-    enhc.rx_timeout = 255;
-    writel(*(u32*)&enhc, host->base + SDHC_ENHC);
+    venhc = readl(host->base+SDHC_ENHC);
+    enhc->rxfifo_th = 60;
+    enhc->dma_rd_resp = 0;
+    enhc->dma_wr_resp = 1;
+    enhc->sdio_irq_period = 12;
+    enhc->rx_timeout = 255;
+    writel(venhc, host->base + SDHC_ENHC);
 
     /*Disable All Irq*/
     writel(0, host->base + SDHC_ICTL);
@@ -112,7 +186,7 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
 /*wait sdhc controller cmd send*/
 int aml_sdhc_wait_ready(struct amlsd_host* host, u32 timeout)
 {
-    u32 i, vstat;
+    u32 i, vstat=0;
     struct sdhc_stat* stat;
 
     for(i=0; i< timeout; i++){
@@ -123,6 +197,7 @@ int aml_sdhc_wait_ready(struct amlsd_host* host, u32 timeout)
         udelay(1);
     }
 
+    sdhc_err("SDHC_STAT=%#x, sdhc controller is busy.\n", vstat);
     aml_sdhc_print_reg(host);
     aml_sdhc_host_reset(host);
     WARN_ON(1);
@@ -135,8 +210,8 @@ read response from REG0_ARGU(136bit or 48bit)
 int aml_sdhc_read_response(struct mmc_host *mmc, struct mmc_command *cmd)
 {
     u32 i=0, j=0;
-	struct amlsd_platform* pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
+    struct amlsd_platform* pdata = mmc_priv(mmc);
+    struct amlsd_host* host = pdata->host;
     u32 vpdma = readl(host->base+SDHC_PDMA);
     struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
     u32* presp = (u32*)cmd->resp;
@@ -187,22 +262,42 @@ inline void aml_sdhc_disable_imask(struct amlsd_host* host, u32 irq)
     writel(ictl, host->base+SDHC_ICTL);
 }
 
-void aml_sdhc_set_pdma(struct mmc_host* mmc, struct mmc_request* mrq)
+void aml_sdhc_set_pdma(struct amlsd_platform* pdata, struct mmc_request* mrq)
 {
-	struct amlsd_platform* pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
-    struct sdhc_pdma* pdma = (struct sdhc_pdma*)&host->pdma;
+    struct amlsd_host* host = pdata->host;
+    u32 vpdma = readl(host->base+SDHC_PDMA);
+    struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
 
-    pdma->dma_mode = 1;
     BUG_ON(!mrq->data);
+#if 1
+    pdma->dma_mode = 1;
     if(mrq->data->flags & MMC_DATA_WRITE){
         /*self-clear-fill, recommend to write before sd send*/
         pdma->txfifo_fill = 1;
+        // pdma->dma_urgent = 1;
+        // pdma->wr_burst = 3; // means 4
+        // pdma->txfifo_th = 49; // means 49
+        writel(*(u32*)pdma, host->base+SDHC_PDMA);
+        
+    }
+    // else{
+        // pdma->txfifo_fill = 0;
+        // pdma->rxfifo_manual_flush = 2; // ???? this can be deleted. try
+        // pdma->dma_urgent = 1;
+        // pdma->rd_burst = 7; // means 8
+        // pdma->rxfifo_th = 8; // means 8
+    // }
+
+#else
+    if(mrq->data->flags & MMC_DATA_WRITE){
+        /*self-clear-fill, recommend to write before sd send*/
         if(mrq->data->blocks > 1){
+            pdma->txfifo_fill = 1;
+
             pdma->rd_burst = 7;
             pdma->wr_burst = 7;
             pdma->rxfifo_th = 7;
-            pdma->txfifo_th = 0x18;
+            pdma->txfifo_th = 32;
         }else{
             pdma->rd_burst = 3;
             pdma->wr_burst = 3;
@@ -210,11 +305,11 @@ void aml_sdhc_set_pdma(struct mmc_host* mmc, struct mmc_request* mrq)
             pdma->txfifo_th = 0x7;
         }
     }else{
-        pdma->rxfifo_manual_flush = 2;
+        //pdma->rxfifo_manual_flush = 2;
         if(mrq->data->blocks > 1){
             pdma->rd_burst = 7;
             pdma->wr_burst = 7;
-            pdma->rxfifo_th = 0x18;
+            pdma->rxfifo_th = 32;
             pdma->txfifo_th = 7;
         }else{
             pdma->rd_burst = 3;
@@ -223,65 +318,117 @@ void aml_sdhc_set_pdma(struct mmc_host* mmc, struct mmc_request* mrq)
             pdma->txfifo_th = 0x7;
         }
     }
+#endif
+    
     writel(*(u32*)pdma, host->base+SDHC_PDMA);
 }
 
 /*copy buffer from data->sg to dma buffer, set dma addr to reg*/
-void aml_sdhc_prepare_dma(struct amlsd_host *host, struct mmc_data *data)
+void aml_sdhc_prepare_dma(struct amlsd_host *host, struct mmc_request *mrq)
 {
-#if 0 //for temp write test
+    struct mmc_data *data = mrq->data;
+    
+#if 1 //for temp write test
     if(data->flags & MMC_DATA_WRITE){
         aml_sg_copy_buffer(data->sg, data->sg_len,
                 host->bn_buf, data->blksz*data->blocks, 1);
         sdhc_dbg(AMLSD_DBG_WR_DATA,"W Cmd %d, %x-%x-%x-%x\n",
-                host->mrq->cmd->opcode,
+                mrq->cmd->opcode,
                 host->bn_buf[0], host->bn_buf[1],
                 host->bn_buf[2], host->bn_buf[3]);
     }
  #endif
-    host->dma_addr = host->bn_dma_buf;
 }
 
 /*
 * set host->clkc_w for 8bit emmc write cmd as it would fail on TXFIFO EMPTY,
 * we decrease the clock for write cmd, and set host->clkc for other cmd
 */
-void aml_sdhc_set_clkc(struct mmc_host* mmc, struct mmc_request* mrq)
+void aml_sdhc_set_clkc(struct amlsd_platform* pdata)
 {
-	struct amlsd_platform* pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
+    struct amlsd_host* host = pdata->host;
     u32 vclkc = readl(host->base + SDHC_CLKC);
-    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
+    u32 clk2 = readl(host->base+SDHC_CLK2);
 
-    if(pdata->clkc == vclkc)
+    if (!host->is_gated && (pdata->clkc == vclkc) && (pdata->clk2 == clk2))
         return;
 
-    sdhc_dbg(AMLSD_DBG_CLKC, "[aml_sdhc_set_clkc]vclkc %x pdata->clkc %x,"
-            "clk_div %d\n", vclkc, pdata->clkc, clkc->clk_div);
+    if (host->is_gated) { // if clock is switch off, we need turn on
+        struct sdhc_clkc* clkc = (struct sdhc_clkc*)&(pdata->clkc);
+        aml_sdhc_clk_switch(pdata, clkc->clk_div, clkc->clk_src_sel);
+    } else {
+        writel(pdata->clkc, host->base+SDHC_CLKC);
+    }
+
+    writel(pdata->clk2, host->base+SDHC_CLK2);
+    
+    // sdhc_dbg(AMLSD_DBG_CLKC, "[aml_sdhc_set_clkc]vclkc %x pdata->clkc %x,"
+            // "clk_div %d\n", vclkc, pdata->clkc, clkc->clk_div);
 }
 
-void aml_sdhc_start_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
+void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
 {
-	struct amlsd_platform* pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
-	struct sdhc_send send = {0};
-	struct sdhc_ictl ictl = {0};
-	u32 vctrl = readl(host->base + SDHC_CTRL);
+    struct amlsd_host* host = pdata->host;
+    struct sdhc_send send = {0};
+    struct sdhc_ictl ictl = {0};
+    u32 vctrl = readl(host->base + SDHC_CTRL);
     struct sdhc_ctrl* ctrl = (struct sdhc_ctrl*)&vctrl;
+    u32 vstat;
+    struct sdhc_stat* stat = (struct sdhc_stat*)&vstat;
+    u32 vsrst;
+    u32 vesta;
+    struct sdhc_srst *srst = (struct sdhc_srst *)&vsrst;
+    u32 vmisc = readl(host->base + SDHC_MISC);
+    struct sdhc_misc* misc = (struct sdhc_misc*)&vmisc;        
+    int i, loop_limit;
+
+    /*Set clock for each port, change clock before wait ready*/
+    aml_sdhc_set_clkc(pdata);
 
     /*Set Irq Control*/
     ictl.data_timeout = 1;
     ictl.data_err_crc = 1;
     ictl.rxfifo_full = 1;
     ictl.txfifo_empty = 1;
+    // ictl.resp_timeout = 1; // try
+    ictl.resp_err_crc = 1; // try
 
     /*Response with busy*/
-    if((mrq->cmd->flags & MMC_RSP_R1B)== MMC_RSP_R1B){
-        send.r1b = 1;
-        sdhc_err("cmd %d set r1b\n", mrq->cmd->opcode);
-    }
+    //if((mrq->cmd->flags & MMC_RSP_R1B)== MMC_RSP_R1B){
+        //send.r1b = 1;
+        //sdhc_err("cmd %d set r1b\n", mrq->cmd->opcode);
+    //}
+    
 
     if(mrq->data){
+        if(((mrq->cmd->opcode == SD_IO_RW_DIRECT) || (mrq->cmd->opcode == SD_IO_RW_EXTENDED))
+                && (mrq->data->blocks > 1)){
+            misc->manual_stop = 1;
+        }
+        else{
+            misc->manual_stop = 0;
+        }
+        writel(vmisc, host->base + SDHC_MISC);
+        
+        vstat = readl(host->base + SDHC_STAT);
+        if(stat->txfifo_cnt || stat->rxfifo_cnt){
+            // sdhc_err("cmd%d: txfifo_cnt:%d, rxfifo_cnt:%d\n", 
+                // mrq->cmd->opcode, stat->txfifo_cnt, stat->rxfifo_cnt);
+
+            vsrst = readl(host->base + SDHC_SRST);        
+            srst->rxfifo = 1;
+            srst->txfifo = 1;
+            srst->main_ctrl = 1;
+            writel(vsrst, host->base+SDHC_SRST);
+            udelay(5);
+            writel(vsrst, host->base+SDHC_SRST);
+        }
+        vstat = readl(host->base + SDHC_STAT);
+        if(stat->txfifo_cnt || stat->rxfifo_cnt){
+            sdhc_err("FAIL to clear FIFO, cmd%d: txfifo_cnt:%d, rxfifo_cnt:%d\n", 
+                mrq->cmd->opcode, stat->txfifo_cnt, stat->rxfifo_cnt);
+        }
+
         /*Command has data*/
         send.cmd_has_data = 1;
 
@@ -289,440 +436,768 @@ void aml_sdhc_start_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
         if(mrq->data->flags & MMC_DATA_WRITE)
             send.data_dir = 1;
 
-    	/*Set package size*/
+        /*Set package size*/
         if(mrq->data->blksz < 512)
             ctrl->pack_len = mrq->data->blksz;
         else
             ctrl->pack_len = 0;
 
-    	/*Set blocks in package*/
+        /*Set blocks in package*/
         send.total_pack = mrq->data->blocks - 1;
 
         /*
-               * If command with no data, just wait response done
-               * interrupt(int[0]), and if command with data transfer, just
-               * wait dma done interrupt(int[11]), don't need care about
-               * dat0 busy or not.
-               */
+         * If command with no data, just wait response done
+         * interrupt(int[0]), and if command with data transfer, just
+         * wait dma done interrupt(int[11]), don't need care about
+         * dat0 busy or not.
+         */
         ictl.dma_done = 1;
     }else
-    	ictl.resp_ok = 1;
+        ictl.resp_ok = 1;
 
     /*Set Bus Width*/
     ctrl->dat_type = pdata->width;
 
-	if(mrq->cmd->flags & MMC_RSP_136)
-		send.resp_len = 1;
-	if(mrq->cmd->flags & MMC_RSP_PRESENT)
-		send.cmd_has_resp = 1;
-	if(!(mrq->cmd->flags & MMC_RSP_CRC)|| mrq->cmd->flags & MMC_RSP_136)
-		send.resp_no_crc = 1;
+    if(mrq->cmd->flags & MMC_RSP_136)
+        send.resp_len = 1;
+    if(mrq->cmd->flags & MMC_RSP_PRESENT)
+        send.cmd_has_resp = 1;
+    if(!(mrq->cmd->flags & MMC_RSP_CRC)|| mrq->cmd->flags & MMC_RSP_136)
+        send.resp_no_crc = 1;
 
     /*Command Index*/
-	send.cmd_index = mrq->cmd->opcode;
+    send.cmd_index = mrq->cmd->opcode;
+
+    writel(*(u32*)&ictl, host->base+SDHC_ICTL);
 
-	writel(*(u32*)&ictl, host->base+SDHC_ICTL);
     /*Set irq status: write 1 clear*/
-	writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
+    writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
 
-	writel(mrq->cmd->arg, host->base+SDHC_ARGU);
-	writel(vctrl, host->base+SDHC_CTRL);
-	writel(host->dma_addr, host->base+SDHC_ADDR);
-	aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT); /*Wait command busy*/
+    writel(mrq->cmd->arg, host->base+SDHC_ARGU);
+    writel(vctrl, host->base+SDHC_CTRL);
+    writel(host->bn_dma_buf, host->base+SDHC_ADDR);
+    aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT); /*Wait command busy*/
     if(mrq->data)
-	    aml_sdhc_set_pdma(mmc, mrq);/*Start dma transfer*/
-	writel(*(u32*)&send, host->base+SDHC_SEND); /*Command send*/
-}
+        aml_sdhc_set_pdma(pdata, mrq);/*Start dma transfer*/
 
+#ifdef      CONFIG_MMC_AML_DEBUG
+    if (0) {
+        memcpy_fromio(host->reg_buf, host->base, 0x3C);
+        host->reg_buf[SDHC_SEND/4] = *(u32*)&send; 
+    }
+#endif
+
+    loop_limit = 100;
+    for (i = 0; i < loop_limit; i++) {
+        vesta = readl(host->base + SDHC_ESTA);
+        if (vesta == 0) {
+            // sdhc_err("ok: %s: cmd%d, SDHC_ESTA=%#x, i=%d\n", 
+                    // mmc_hostname(host->mmc), mrq->cmd->opcode, vesta, i);
+            break;
+        }
+        if (i > 50) {
+            sdhc_err("udelay\n");
+            udelay(1);
+        }
+    }
+    if (i >= loop_limit) {
+        sdhc_err("Warning: %s: cmd%d, SDHC_ESTA=%#x\n", 
+                mmc_hostname(host->mmc), mrq->cmd->opcode, vesta);
+    }
+
+    if (mrq->data && (mrq->data->flags & MMC_DATA_WRITE)) {
+        for (i = 0; i < loop_limit; i++) {
+            vstat = readl(host->base + SDHC_STAT);
+            if (stat->txfifo_cnt != 0) {
+                // sdhc_err("OK: %s: cmd%d, txfifo_cnt=%d, i=%d\n", 
+                        // mmc_hostname(host->mmc), mrq->cmd->opcode, stat->txfifo_cnt, i);
+                break;
+            }
+            udelay(1);
+        }
+        if (i >= loop_limit) {
+            sdhc_err("Warning: %s: cmd%d, txfifo_cnt=%d\n", 
+                    mmc_hostname(host->mmc), mrq->cmd->opcode, stat->txfifo_cnt);
+        }
+
+    }
+
+    writel(*(u32*)&send, host->base+SDHC_SEND); /*Command send*/
+}
 
 /*mmc_request_done & do nothing in xfer_post*/
 void aml_sdhc_request_done(struct mmc_host *mmc, struct mmc_request *mrq)
 {
-	struct amlsd_platform * pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
+    struct amlsd_platform * pdata = mmc_priv(mmc);
+    struct amlsd_host* host = pdata->host;
+    unsigned long flags;
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    host->xfer_step = XFER_FINISHED;
+    host->mrq = NULL;
+    host->status = HOST_INVALID;
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+#ifdef      CONFIG_MMC_AML_DEBUG
+    host->req_cnt--;
+
+    aml_dbg_verify_pinmux(pdata);
+    aml_dbg_verify_pull_up(pdata);
 
-	host->xfer_step = XFER_FINISHED;
-	if(pdata->xfer_post)
-		pdata->xfer_post(pdata);
-	aml_sdhc_disable_imask(host, SDHC_ICTL_ALL);
+    if (0) {
+        sdhc_err("%s: cmd%d, start sdhc reg:\n", mmc_hostname(host->mmc), mrq->cmd->opcode);
+        aml_sdhc_print_reg_(host->reg_buf);
+        sdhc_err("done reg:\n");
+        aml_sdhc_print_reg(host);
+    }
+#endif
+
+    if (pdata->xfer_post)
+        pdata->xfer_post(pdata);
+
+    aml_sdhc_disable_imask(host, SDHC_ICTL_ALL);
     /*Set irq status: write 1 clear*/
-	writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
-	mmc_request_done(host->mmc, mrq);
-	aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
+    aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    mmc_request_done(host->mmc, mrq);
 }
 
-/*error handler*/
-void aml_sdhc_timeout(unsigned long data)
+char *msg_err[] = {
+    "invalid",          /* 0 */
+    "rxfifo full",      /* 1 */
+    "txfifo empty",     /* 2 */
+    "rsp CRC",          /* 3 */
+    "data CRC",         /* 4 */
+    "rsp timeout",      /* 5 */
+    "data timeout",     /* 6 */
+};
+static void aml_sdhc_print_err (struct amlsd_host *host)
 {
-	struct amlsd_host* host = (void*)data;
-	u32 vista = readl(host->base + SDHC_ISTA);
-    struct sdhc_ista* ista = (struct sdhc_ista*)&vista;
-	struct mmc_request* mrq;
-	unsigned long flags;
+    char *msg, *msg_timer="";
+    char *p;
+    u32 tmp_reg, xfer_step, xfer_step_prev, status;
+    int left_size;
+    struct clk* clk_src = clk_get_sys("clk81", NULL);
+    int clk18_clk_rate = clk_get_rate(clk_src);
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
+    u32 vista = readl(host->base + SDHC_ISTA);
+    u32 vstat = readl(host->base + SDHC_STAT);
+    u32 vclkc = readl(host->base+SDHC_CLKC);
+    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
+    u32 vctrl = readl(host->base + SDHC_CTRL);
+    struct sdhc_ctrl* ctrl = (struct sdhc_ctrl*)&vctrl;
+    u32 clk_rate;
+    unsigned long flags;
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    xfer_step = host->xfer_step;
+    xfer_step_prev = host->xfer_step_prev;
+    status = host->status;
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+    clk_src = clk_get_sys("pll_fixed", NULL); // fclk
+    clk_rate = clk_get_rate(clk_src)/3; // for SDHC_CLOCK_SRC_FCLK_DIV3
+
+    p = host->msg_buf;
+    left_size = MESSAGE_BUF_SIZE;
+
+    if (((status < HOST_ERR_END) && (status > HOST_INVALID))
+            && (status < ARRAY_SIZE(msg_err))) { // valid sdhc errors
+        msg = msg_err[status];
+    } else {
+        msg = "status is invalid";
+    }
 
-	spin_lock_irqsave(&host->mrq_lock, flags);
-	mrq = host->mrq;
-	// sdhc_err("host->xfer_step %d\n", host->xfer_step);
+    if (xfer_step == XFER_TIMER_TIMEOUT) { // by aml_sdhc_timeout()
+        if (((status < HOST_ERR_END) && (status > HOST_INVALID))
+                && (status < ARRAY_SIZE(msg_err))) { // valid sdhc errors
+            msg_timer = "timer timeout WITH sdhc ";
+        } else {
+            msg_timer = "timer timeout";
+            msg = "";
+        }
+    }
 
-    sdhc_err("%s: Timeout Cmd%d arg %08x Xfer %d Bytes, "
-            "host->xfer_step=%d, host->cmd_is_stop=%d, pdata->port=%d\n",
-            mmc_hostname(host->mmc),
+    aml_snprint(&p, &left_size, "%s: %s%s error, port=%d, Cmd%d Arg %08x, xfer_step=%d, status=%d, ",
+            mmc_hostname(host->mmc), 
+            msg_timer,
+            msg,
+            pdata->port,
             host->mrq->cmd->opcode,
             host->mrq->cmd->arg,
-            host->mrq->data?host->mrq->data->blksz*host->mrq->data->blocks:0,
-            host->xfer_step,
-            host->cmd_is_stop,
-            pdata->port);
+            xfer_step,
+            status);
+
+    switch (status) // more to print for different error cases
+    {
+        case HOST_RX_FIFO_FULL:
+        case HOST_TX_FIFO_EMPTY:
+            aml_snprint(&p, &left_size, "clk81=%d, clock=%d, ", 
+                    clk18_clk_rate, clk_rate/(clkc->clk_div+1));
+            break;
+    }
+
+    if (xfer_step == XFER_TIMER_TIMEOUT) { // by aml_sdhc_timeout()
+        aml_snprint(&p, &left_size, "xfer_step_prev=%d, ", xfer_step_prev);
+    }    
+
+    if (host->mrq->data) {
+        int byte = host->mrq->data->blksz*host->mrq->data->blocks;
+
+        aml_snprint(&p, &left_size, "Xfer %d Bytes, ", byte);
+        if (byte > 512) // multi-block mode
+            aml_snprint(&p, &left_size, "SEND=%#x, ", readl(host->base+SDHC_SEND));
+
+        if (pdata->width != ctrl->dat_type) { // error: bus width is different
+            aml_snprint(&p, &left_size, "pdata->width=%d, ctrl->dat_type=%d, ",
+                    pdata->width, ctrl->dat_type);
+        }
 
+        if (pdata->clkc != vclkc) { // error: clock setting is different
+            aml_snprint(&p, &left_size, "pdata->clkc=%d, vclkc=%#x, ",
+                    pdata->clkc, vclkc);
+        }
+    }
+    aml_snprint(&p, &left_size, "iSTA=%#x, STAT=%#x", vista, vstat);
+
+    sdhc_err("%s\n", host->msg_buf);
+
+    // tmp_reg = readl((u32 *)P_AO_SECURE_REG1);
+    // if (tmp_reg) {
+        // sdhc_err("P_AO_SECURE_REG1=%#x\n", tmp_reg);
+    // }
+    tmp_reg = READ_CBUS_REG(HHI_GCLK_MPEG0);
+    if (!(tmp_reg & 0x00004000)) {
+        sdhc_err("Error: SDHC is gated clock, HHI_GCLK_MPEG0=%#x, bit14 is 0\n", tmp_reg);
+    }
     aml_dbg_print_pinmux();
-	host->xfer_step = XFER_TIMEDOUT;
+
+#ifdef      CONFIG_MMC_AML_DEBUG
+    if (xfer_step == XFER_TIMER_TIMEOUT) { // by aml_sdhc_timeout()
+        sdhc_err("old sdhc reg:\n");
+        aml_sdhc_print_reg_(host->reg_buf);
+    }    
+#endif
+    aml_sdhc_print_reg(host);
+}
+
+/*error handler*/
+static void aml_sdhc_timeout(struct work_struct *work)
+{
+    static int timeout_cnt = 0;
+    struct amlsd_host *host = container_of(work, struct amlsd_host, timeout.work);
+    // u32 vista = readl(host->base + SDHC_ISTA);
+    // struct sdhc_ista* ista = (struct sdhc_ista*)&vista;
+    struct mmc_request* mrq;
+    unsigned long flags;
+
+    BUG_ON(!host->mrq || !host->mrq->cmd);
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    if(host->xfer_step == XFER_FINISHED){
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        sdhc_err("timeout after xfer finished\n");
+        return;
+    }
+
+    if ((host->xfer_step == XFER_IRQ_TASKLET_DATA) 
+            || (host->xfer_step == XFER_IRQ_TASKLET_CMD)) {
+        schedule_delayed_work(&host->timeout, 10);
+        
+        timeout_cnt++;
+        if (timeout_cnt > 100)
+            goto timeout_handle;
+
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d\n",
+                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step);
+        return;
+    }
+timeout_handle:
+    timeout_cnt = 0;
+
+    mrq = host->mrq;
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+    aml_sdhc_status(host);
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    host->xfer_step_prev = host->xfer_step;
+    host->xfer_step = XFER_TIMER_TIMEOUT;
+    mrq->cmd->error = -ETIMEDOUT;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
 
-	BUG_ON(!mrq || !mrq->cmd);
+    aml_sdhc_read_response(host->mmc, mrq->cmd);
+    aml_sdhc_print_err(host);
 
-	/*read response, if error, set -EILSEQ, then retry in aml_sdhc_request_done*/
-	aml_sdhc_read_response(host->mmc, mrq->cmd);
-	sdhc_err("Cmd %d Resp 0x%x Xfer %d\n", host->mrq->cmd->opcode,
-		host->mrq->cmd->resp[0],
-		mrq->data?mrq->data->blksz*mrq->data->blocks:0);
-	if(R1_STATUS(host->mrq->cmd->resp[0]) & R1_COM_CRC_ERROR ){
-		mrq->cmd->error = -EILSEQ;
-		sdhc_err("Cmd CRC error\n");
-        	vista = readl(host->base+SDHC_ISTA);
-		goto req_done;
-	}
+    /*read response, if error, set -EILSEQ, then retry in aml_sdhc_request_done*/
+    // if(R1_STATUS(host->mrq->cmd->resp[0]) & R1_COM_CRC_ERROR ){
+        // mrq->cmd->error = -EILSEQ;
+        // sdhc_err("Cmd CRC error\n");
+        // vista = readl(host->base+SDHC_ISTA);
+        // sdhc_err("Cmd %d Resp 0x%x Xfer %d\n", host->mrq->cmd->opcode,
+                // host->mrq->cmd->resp[0],
+                // mrq->data?mrq->data->blksz*mrq->data->blocks:0);
+        // goto req_done;
+    // }
 
-	mrq->cmd->error = -ETIMEDOUT;
-	aml_sdhc_print_reg(host);
 
-	/*
+    /*
         * response crc error & data crc error with xfer size >= 512,
         * ignore crc error with data transfer less then 512, for example 64B
         */
-	if((ista->resp_err_crc && !mrq->data)||
-        (ista->data_err_crc && mrq->data && mrq->data->blksz == 512)){
-        mrq->cmd->error = -EILSEQ;
-		sdhc_err("CRC error Cmd %d Ista 0x%x\n", mrq->cmd->opcode, vista);
-		goto req_done;
-	}
-
-	/*get TXFIFO_EMPTY as a CRC error */
-	if(ista->txfifo_empty){
-		mrq->cmd->error = -EILSEQ;
-		sdhc_err("TXFIFO_EMPTY Cmd %d Size 0x%x\n",
-				mrq->cmd->opcode, mrq->data->blksz*mrq->data->blocks);
-		goto req_done;
-	}
-	/*get RXFIFO_FULL as a CRC error */
-	if(ista->rxfifo_full){
-		mrq->cmd->error = -EILSEQ;
-		sdhc_err("RXFIFO_FULL Cmd %d Size 0x%x\n",
-				mrq->cmd->opcode, mrq->data->blksz*mrq->data->blocks);
-		goto req_done;
-	}
-
-	if(ista->resp_timeout){
-		sdhc_err("TIMEOUT Cmd %d Ista 0x%x\n", mrq->cmd->opcode, vista);
-		mrq->cmd->error = -ETIMEDOUT;
-		goto req_done;
-	}
-
-	sdhc_err("Cmd %d, Ista 0x%x Request done\n", mrq->cmd->opcode, vista);
-	mrq->cmd->error = -1;
-
-req_done:
-	host->mrq = NULL;
-	aml_sdhc_request_done(host->mmc, mrq);
-	/*write 1 clear irq status reg*/
-	writel(vista, host->base+SDHC_ISTA);
+    // if((ista->resp_err_crc && !mrq->data)||
+        // (ista->data_err_crc && mrq->data && mrq->data->blksz == 512)){
+        // mrq->cmd->error = -EILSEQ;
+        // sdhc_err("CRC error Cmd %d Ista 0x%x\n", mrq->cmd->opcode, vista);
+        // goto req_done;
+    // }
+
+    // [>get TXFIFO_EMPTY as a CRC error <]
+    // if(ista->txfifo_empty){
+        // mrq->cmd->error = -EILSEQ;
+        // sdhc_err("TXFIFO_EMPTY Cmd %d Size 0x%x\n",
+                // mrq->cmd->opcode, mrq->data->blksz*mrq->data->blocks);
+        // goto req_done;
+    // }
+    // [>get RXFIFO_FULL as a CRC error <]
+    // if(ista->rxfifo_full){
+        // mrq->cmd->error = -EILSEQ;
+        // sdhc_err("RXFIFO_FULL Cmd %d Size 0x%x\n",
+                // mrq->cmd->opcode, mrq->data->blksz*mrq->data->blocks);
+        // goto req_done;
+    // }
+
+    // if(ista->resp_timeout){
+        // sdhc_err("TIMEOUT Cmd %d Ista 0x%x\n", mrq->cmd->opcode, vista);
+        // mrq->cmd->error = -ETIMEDOUT;
+        // goto req_done;
+    // }
+
+    // sdhc_err("Cmd %d, Ista 0x%x Request done\n", mrq->cmd->opcode, vista);
+    // mrq->cmd->error = -1;
+
+// req_done:
+    aml_sdhc_host_reset(host);
+    /*write 1 clear irq status reg*/
+    // writel(vista, host->base+SDHC_ISTA);
+    aml_sdhc_request_done(host->mmc, mrq);
     return ;
 }
 
-/*sdhc controller does not support wifi now, return*/
-int aml_sdhc_check_unsupport_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
-{
-    if(mrq->cmd->opcode == SD_IO_SEND_OP_COND ||
-		mrq->cmd->opcode == SD_IO_RW_DIRECT ||
-		mrq->cmd->opcode == SD_IO_RW_EXTENDED){
-        mrq->cmd->error = -EINVAL;
-        mmc_request_done(mmc, mrq);
-        return -EINVAL;
-    }
-    return 0;
-}
-
 /*cmd request interface*/
 void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
-	struct amlsd_platform * pdata = mmc_priv(mmc);
-	struct amlsd_host *host = (void*)pdata->host;
-	u32 vista = readl(host->base+SDHC_ISTA);
-	unsigned long flags;
+    struct amlsd_platform * pdata;
+    struct amlsd_host *host;
+    // u32 vista;
+    unsigned long flags;
+    unsigned int timeout;
+    
+    BUG_ON(!mmc);
+    BUG_ON(!mrq);
+
+    pdata = mmc_priv(mmc);
+    host = (void*)pdata->host;
 
-	/*check wifi cmd*/
-    if(aml_sdhc_check_unsupport_cmd(mmc, mrq))
+    if (aml_check_unsupport_cmd(mmc, mrq))
         return;
-	if(pdata->eject){
-        mrq->cmd->error = -ETIMEDOUT;
+
+    if(!pdata->is_in){
+        spin_lock_irqsave(&host->mrq_lock, flags);
+        mrq->cmd->error = -ENOMEDIUM;
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
         mmc_request_done(mmc, mrq);
-		return;
-	}
+        return;
+    }
 
-	aml_sdhc_host_reset(host);
-	writel(vista, host->base+SDHC_ISTA);
-	aml_sdhc_disable_imask(host, SDHC_ICTL_ALL);
+    // aml_sdhc_host_reset(host);
+    // vista = readl(host->base+SDHC_ISTA);
+    // writel(vista, host->base+SDHC_ISTA);
+    aml_sdhc_disable_imask(host, SDHC_ICTL_ALL);
 
-    /*Set clock for each port, change clock before wait ready*/
-	//aml_sdhc_set_clkc(mmc, mrq);
-
-	/*clear pinmux & set pinmux*/
-	if(pdata->xfer_pre)
-		pdata->xfer_pre(pdata);
-
-	sdhc_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
-		mmc_hostname(mmc), mrq->cmd->opcode,
-		mrq->cmd->arg, mrq->cmd->flags);
-	/*setup reg  especially for cmd with transfering data*/
-	if(mrq->data){
-		sdhc_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
-			"tsac %d ms nsac %d\n",
-			mmc_hostname(mmc), mrq->data->blksz,
-			mrq->data->blocks, mrq->data->flags,
-			mrq->data->timeout_ns / 1000000,
-			mrq->data->timeout_clks);
-	}
-
-	if(!mrq->data)
-		mod_timer(&host->timeout_tlist, jiffies + 500);
-	else
-		mod_timer(&host->timeout_tlist,
-				jiffies + 500);
-
-	/*Copy data to dma buffer for write request*/
-	if(mrq->data)
-		aml_sdhc_prepare_dma(host, mrq->data);
-
-	spin_lock_irqsave(&host->mrq_lock, flags);
-	if(host->xfer_step != XFER_FINISHED && host->xfer_step != XFER_INIT)
-		sdhc_err("host->xfer_step %d\n", host->xfer_step);
-
-	/*host->mrq, used in irq & tasklet*/
-	host->mrq = mrq;
-	host->mmc = mmc;
-	host->xfer_step = XFER_START;
+    sdhc_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
+        mmc_hostname(mmc), mrq->cmd->opcode,
+        mrq->cmd->arg, mrq->cmd->flags);
+
+#ifdef      CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW
+    if ((mrq->cmd->opcode == 18) || (mrq->cmd->opcode == 25)) { // ???? for debug
+        sdhc_err("cmd%d\n", mrq->cmd->opcode);
+    }
+#endif
+
+    /*setup reg  especially for cmd with transfering data*/
+    if(mrq->data) {
+        /*Copy data to dma buffer for write request*/
+        aml_sdhc_prepare_dma(host, mrq);
+
+        sdhc_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
+            "tsac %d ms nsac %d\n",
+            mmc_hostname(mmc), mrq->data->blksz,
+            mrq->data->blocks, mrq->data->flags,
+            mrq->data->timeout_ns / 1000000,
+            mrq->data->timeout_clks);
+    }
+
+    /*clear pinmux & set pinmux*/
+    if(pdata->xfer_pre)
+        pdata->xfer_pre(pdata);
+
+#ifdef      CONFIG_MMC_AML_DEBUG
+    aml_dbg_verify_pull_up(pdata);
+    aml_dbg_verify_pinmux(pdata);
+#endif
+
+    if(!mrq->data)
+        timeout = 100; //mod_timer(&host->timeout_tlist, jiffies + 100); // 1s
+    else
+        timeout = 500;//mod_timer(&host->timeout_tlist,
+                //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
+    schedule_delayed_work(&host->timeout, timeout);
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    if(host->xfer_step != XFER_FINISHED && host->xfer_step != XFER_INIT)
+        sdhc_err("host->xfer_step %d\n", host->xfer_step);
+
+    /*host->mrq, used in irq & tasklet*/
+    host->mrq = mrq;
+    host->mmc = mmc;
+    host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
 
-	/*setup reg for all cmd*/
-	aml_sdhc_start_cmd(mmc, mrq);
-	host->xfer_step = XFER_AFTER_START;
-	spin_unlock_irqrestore(&host->mrq_lock, flags);
+    /*setup reg for all cmd*/
+    aml_sdhc_start_cmd(pdata, mrq);
+    host->xfer_step = XFER_AFTER_START;
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
 }
 
-/*sdhc controller irq*/
-static irqreturn_t aml_sdhc_irq(int irq, void *dev_id)
+static int aml_sdhc_status (struct amlsd_host* host)
 {
-	struct amlsd_host* host = dev_id;
-	struct mmc_host* mmc;
-	struct amlsd_platform* pdata;
-	u32 victl = readl(host->base + SDHC_ICTL);
+    int ret = -1; // error
+    u32 victl = readl(host->base + SDHC_ICTL);
     u32 vista = readl(host->base + SDHC_ISTA);
     struct sdhc_ista* ista = (struct sdhc_ista*)&vista;
-	struct mmc_request* mrq;
-	unsigned long flags;
-
-	spin_lock_irqsave(&host->mrq_lock, flags);
-	mrq = host->mrq;
-	mmc = host->mmc;
-	pdata = mmc_priv(mmc);
-	if(!mrq){
-		sdhc_err("NULL mrq in aml_sdhc_irq step %d\n", host->xfer_step);
-		if(host->xfer_step == XFER_FINISHED ||
-			host->xfer_step == XFER_TIMEDOUT){
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			return IRQ_HANDLED;
-		}
-		WARN_ON(!mrq);
-		aml_sdhc_print_reg(host);
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
-		return IRQ_HANDLED;
-	}
-
-	host->xfer_step = XFER_IRQ_OCCUR;
-
-	if(victl & vista){
-		/*TXFIFO EMPTY & RXFIFO FULL as CRC error*/
+    struct mmc_request* mrq = host->mrq;
+    unsigned long flags;
+
+    if(!mrq){
+        sdhc_err("NULL mrq\n");
+        return ret;
+    }
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    if (victl & vista) {
+        if(ista->rxfifo_full){
+            host->status = HOST_RX_FIFO_FULL;
+            goto _status_exit;
+        }
         if(ista->txfifo_empty){
-			sdhc_err("%s Cmd %d TXFIFO_EMPTY!!! Xfer %d Bytes\n",
-					pdata->pinname, mrq->cmd->opcode,
-					mrq->data?mrq->data->blksz*mrq->data->blocks:0);
-            host->xfer_step = XFER_IRQ_FIFO_ERR;
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			return IRQ_WAKE_THREAD;
+            host->status = HOST_TX_FIFO_EMPTY;
+            goto _status_exit;
         }
-		if(ista->rxfifo_full){
- 			sdhc_err("%s Cmd %d RXFIFO_FULL!!! Xfer %d Bytes\n",
-					pdata->pinname, mrq->cmd->opcode,
-					mrq->data?mrq->data->blksz*mrq->data->blocks:0);
-            host->xfer_step = XFER_IRQ_FIFO_ERR;
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			return IRQ_WAKE_THREAD;
+        if (ista->resp_err_crc) {
+            host->status = HOST_RSP_CRC_ERR;
+            goto _status_exit;
+        }
+        if (ista->data_err_crc) {
+            host->status = HOST_DAT_CRC_ERR;
+            goto _status_exit;
+        }
+        if (ista->resp_timeout) {
+            host->status = HOST_RSP_TIMEOUT_ERR;
+            goto _status_exit;
+        }
+        if (ista->data_timeout) {
+            host->status = HOST_DAT_TIMEOUT_ERR;
+            goto _status_exit;
         }
-        if((ista->resp_err_crc && !mrq->data)||
-                (ista->data_err_crc && mrq->data && mrq->data->blksz == 512)){
-            mrq->cmd->error = -EILSEQ;
-			sdhc_err("%s CRC ERR Cmd %d Ista 0x%x, Xfer %d Bytes\n",
-				pdata->pinname, host->mrq->cmd->opcode, vista,
-				mrq->data?mrq->data->blksz*mrq->data->blocks:0);
-    		goto req_done;
-	    }
-		if(ista->data_timeout || ista->resp_timeout){
-			BUG_ON(!pdata);
-			sdhc_err("%s Timeout Cmd %d Ista 0x%x, Xfer %d Bytes\n",
-					pdata->pinname, mrq->cmd->opcode, vista,
-					mrq->data?mrq->data->blksz*mrq->data->blocks:0);
-            aml_sdhc_print_reg(host);
-	        aml_sdhc_read_response(host->mmc, mrq->cmd);
-			mrq->cmd->error = -ETIMEDOUT;
-			goto req_done;
-		}
         if(ista->dma_done){
-            //writel(ista, host->base+SDHC_ISTA);
-            host->xfer_step = XFER_IRQ_TASKLET_DATA;
+            host->status = HOST_TASKLET_DATA;
+            ret = 0; // ok
+            goto _status_exit;
+        }
+        if(ista->resp_ok_noclear){
+            host->status = HOST_TASKLET_CMD;
+            ret = 0; // ok
+            goto _status_exit;
+        }
+    }
+    ret = 0; // ok
+_status_exit:
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+    return ret;
+}
+
+/*sdhc controller irq*/
+static irqreturn_t aml_sdhc_irq(int irq, void *dev_id)
+{
+    struct amlsd_host* host = dev_id;
+    struct mmc_host* mmc;
+    struct amlsd_platform* pdata;
+    struct mmc_request* mrq;
+    unsigned long flags;
+    u32 victl = readl(host->base + SDHC_ICTL);
+    u32 vista = readl(host->base + SDHC_ISTA);
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    mrq = host->mrq;
+    mmc = host->mmc;
+    pdata = mmc_priv(mmc);
+    if(!mrq){
+        sdhc_err("NULL mrq in aml_sdhc_irq step %d\n", host->xfer_step);
+        if(host->xfer_step == XFER_FINISHED ||
+            host->xfer_step == XFER_TIMER_TIMEOUT){
             spin_unlock_irqrestore(&host->mrq_lock, flags);
-            return IRQ_WAKE_THREAD;
+            return IRQ_HANDLED;
         }
-		if(ista->resp_ok_noclear){
-			writel(ista, host->base+SDHC_ISTA);
-            host->xfer_step = XFER_IRQ_TASKLET_CMD;
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			return IRQ_WAKE_THREAD;
-		}
-	}else{
-		host->xfer_step = XFER_IRQ_UNKNOWN_IRQ;
-		sdhc_err("%s Unknown Irq Ictl 0x%x, Ista 0x%x,"
-			"cmd %d, xfer %d bytes \n",
-			pdata->pinname, victl, vista, mrq->cmd->opcode,
-			mrq->data?mrq->data->blksz*mrq->data->blocks:0);
-	}
-	spin_unlock_irqrestore(&host->mrq_lock, flags);
-	return IRQ_HANDLED;
-
-req_done:
-	del_timer(&host->timeout_tlist);
-	host->mrq = NULL;
-	spin_unlock_irqrestore(&host->mrq_lock, flags);
-	aml_sdhc_request_done(mmc, mrq);
-	return IRQ_HANDLED;
+        WARN_ON(!mrq);
+        aml_sdhc_print_reg(host);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_HANDLED;
+    }
+
+    if (host->xfer_step != XFER_AFTER_START) {
+        sdhc_err("host->xfer_step=%d\n", host->xfer_step);
+    }
+
+    host->xfer_step = XFER_IRQ_OCCUR;
+
+    if (victl & vista) {
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        aml_sdhc_status(host);
+        spin_lock_irqsave(&host->mrq_lock, flags);
+        switch(host->status)
+        {
+            case HOST_RX_FIFO_FULL:
+                mrq->cmd->error = -HOST_RX_FIFO_FULL;
+                break;
+            case HOST_TX_FIFO_EMPTY:
+                mrq->cmd->error = -HOST_TX_FIFO_EMPTY;
+                break;
+            case HOST_RSP_CRC_ERR:
+            case HOST_DAT_CRC_ERR:
+                mrq->cmd->error = -EILSEQ;
+                break;
+            case HOST_RSP_TIMEOUT_ERR:
+            case HOST_DAT_TIMEOUT_ERR:
+                mrq->cmd->error = -ETIMEDOUT;
+                break;
+            case HOST_TASKLET_DATA:
+            case HOST_TASKLET_CMD:
+                writel(vista, host->base+SDHC_ISTA);
+                break;
+            default:
+                break;
+        }
+
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_WAKE_THREAD;
+
+    }
+    // else{
+        host->xfer_step = XFER_IRQ_UNKNOWN_IRQ;
+        sdhc_err("%s Unknown Irq Ictl 0x%x, Ista 0x%x,"
+            "cmd %d, xfer %d bytes \n",
+            pdata->pinname, victl, vista, mrq->cmd->opcode,
+            mrq->data?mrq->data->blksz*mrq->data->blocks:0);
+    // }
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+    return IRQ_HANDLED;
+
+// req_done:
+    // cancel_delayed_work(&host->timeout);
+    // spin_unlock_irqrestore(&host->mrq_lock, flags);
+    // aml_sdhc_request_done(mmc, mrq);
+    // return IRQ_HANDLED;
+}
+
+static void aml_sdhc_com_err_handler (struct amlsd_host* host)
+{
+    cancel_delayed_work(&host->timeout);
+    aml_sdhc_print_err(host);
+    aml_sdhc_host_reset(host);
+    aml_sdhc_request_done(host->mmc, host->mrq);
+}
+
+static void aml_sdhc_not_timeout_err_handler (struct amlsd_host* host)
+{
+    aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    aml_sdhc_read_response(host->mmc, host->mrq->cmd);
+    aml_sdhc_com_err_handler(host);
 }
 
 irqreturn_t aml_sdhc_data_thread(int irq, void *data)
 {
-	struct amlsd_host* host = data;
-	u32 xfer_bytes;
-	struct mmc_request* mrq;
-	enum aml_mmc_waitfor	xfer_step;
-	unsigned long flags;
-
-	if(host->xfer_step == XFER_TIMEDOUT){
-		sdhc_err("Timeout Return\n");
-		return IRQ_HANDLED;
-	}
-	if(host->xfer_step == XFER_INIT){
-		return IRQ_HANDLED;
-	}
-
-	if(host->xfer_step == XFER_FINISHED){
-		sdhc_err("XFER_FINISHED Return\n");
-		return IRQ_HANDLED;
-	}
-
-	spin_lock_irqsave(&host->mrq_lock, flags);
-	mrq = host->mrq;
-	xfer_step = host->xfer_step;
-	if(!mrq){
-		sdhc_err("!mrq xfer_step %d\n", xfer_step);
-		if(xfer_step == XFER_FINISHED ||
-			xfer_step == XFER_TIMEDOUT){
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			return IRQ_HANDLED;
-		}
-		BUG();
-	}
-	spin_unlock_irqrestore(&host->mrq_lock, flags);
-
-	BUG_ON(!host->mrq->cmd);
-
-	switch(xfer_step){
-		case XFER_IRQ_TASKLET_DATA:
-			BUG_ON(!mrq->data);
-
-			xfer_bytes = mrq->data->blksz*mrq->data->blocks;
-			/* copy buffer from dma to data->sg in read cmd*/
-			if(host->mrq->data->flags & MMC_DATA_READ){
-				aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len, host->bn_buf,
-							xfer_bytes, 0);
-				sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd %d, %x-%x-%x-%x-%x-%x-%x-%x\n",
-					host->mrq->cmd->opcode,
-					host->bn_buf[0], host->bn_buf[1],
-					host->bn_buf[2], host->bn_buf[3],
-					host->bn_buf[4], host->bn_buf[5],
-					host->bn_buf[6], host->bn_buf[7]);
-			}
-
-			del_timer(&host->timeout_tlist);
-			mrq->cmd->error = 0;
-			mrq->data->bytes_xfered = xfer_bytes;
-			host->xfer_step = XFER_TASKLET_DATA;
-			host->mrq = NULL;
-			aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
-			aml_sdhc_read_response(host->mmc, mrq->cmd);
-			aml_sdhc_clear_fifo(host);
-			aml_sdhc_request_done(host->mmc, mrq);
-			break;
-		case XFER_IRQ_TASKLET_CMD:
-			if(!host->mrq->data){
-				del_timer(&host->timeout_tlist);
-				aml_sdhc_read_response(host->mmc, host->mrq->cmd);
-				host->mrq->cmd->error = 0;
-				host->xfer_step = XFER_TASKLET_CMD;
-				host->mrq = NULL;
-				aml_sdhc_request_done(host->mmc, mrq);
-			}
-			break;
-		case XFER_IRQ_FIFO_ERR:
-		case XFER_IRQ_CRC_ERR:
-			del_timer(&host->timeout_tlist);
-			aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
-			aml_sdhc_read_response(host->mmc, host->mrq->cmd);
-			aml_sdhc_host_reset(host);
-			host->mrq->cmd->error = -EILSEQ;
-			aml_sdhc_request_done(host->mmc, mrq);
-			break;
-		case XFER_IRQ_TIMEOUT_ERR:
-			del_timer(&host->timeout_tlist);
-			host->mrq->cmd->error = -ETIMEDOUT;
-			aml_sdhc_host_reset(host);
-			aml_sdhc_request_done(host->mmc, mrq);
-			break;
-		case XFER_INIT:
-		case XFER_START:
-		case XFER_IRQ_UNKNOWN_IRQ:
-		case XFER_TIMER_TIMEOUT:
-		case XFER_TASKLET_CMD:
-		case XFER_TASKLET_DATA:
-		case XFER_TASKLET_BUSY:
-		case XFER_TIMEDOUT:
-		case XFER_AFTER_START:
-		case XFER_FINISHED:
-		default:
-			sdhc_err("BUG xfer_step %d\n", xfer_step);
-			BUG();
-
-	}
-
-	return IRQ_HANDLED;
+    struct amlsd_host* host = data;
+    u32 xfer_bytes;
+    struct mmc_request* mrq;
+    enum aml_mmc_waitfor xfer_step;
+    unsigned long flags;
+    u32 vstat, status;
+    struct sdhc_stat* stat = (struct sdhc_stat*)&vstat;
+    
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    if (host->xfer_step != XFER_IRQ_OCCUR) {
+        sdhc_err("host->xfer_step=%d\n", host->xfer_step);
+    }
+
+    // if(host->xfer_step == XFER_TIMER_TIMEOUT){
+        // sdhc_err("Timeout Return\n");
+        // return IRQ_HANDLED;
+    // }
+
+    mrq = host->mrq;
+    xfer_step = host->xfer_step;
+    status = host->status;
+    
+    if(!mrq){
+        sdhc_err("!mrq xfer_step %d\n", xfer_step);
+        if(xfer_step == XFER_FINISHED ||
+            xfer_step == XFER_TIMER_TIMEOUT){
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+            return IRQ_HANDLED;
+        }
+        BUG();
+    }
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+    BUG_ON(!host->mrq->cmd);
+
+    switch (status) {
+        case HOST_TASKLET_DATA:
+            BUG_ON(!mrq->data);
+            cancel_delayed_work(&host->timeout);
+
+            xfer_bytes = mrq->data->blksz*mrq->data->blocks;
+            /* copy buffer from dma to data->sg in read cmd*/
+            if(host->mrq->data->flags & MMC_DATA_READ){
+                aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len, host->bn_buf,
+                            xfer_bytes, 0);
+                sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd%d, arg %#x, size=%d\n",
+                        mrq->cmd->opcode, mrq->cmd->arg, xfer_bytes);
+                sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd %d, %x-%x-%x-%x-%x-%x-%x-%x\n",
+                    host->mrq->cmd->opcode,
+                    host->bn_buf[0], host->bn_buf[1],
+                    host->bn_buf[2], host->bn_buf[3],
+                    host->bn_buf[4], host->bn_buf[5],
+                    host->bn_buf[6], host->bn_buf[7]);
+                // aml_debug_print_buf(host->bn_buf, xfer_bytes);
+            }
+
+            vstat = readl(host->base + SDHC_STAT);
+            if (stat->rxfifo_cnt) {
+                sdhc_err("cmd%d, rxfifo_cnt=%d\n", mrq->cmd->opcode, stat->rxfifo_cnt);
+            }
+            // if (stat->txfifo_cnt) {
+                // sdhc_err("cmd%d, txfifo_cnt=%d\n", mrq->cmd->opcode, stat->txfifo_cnt);
+            // }
+
+            spin_lock_irqsave(&host->mrq_lock, flags);
+            mrq->cmd->error = 0;
+            mrq->data->bytes_xfered = xfer_bytes;
+            host->xfer_step = XFER_TASKLET_DATA;
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+            aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+            aml_sdhc_read_response(host->mmc, mrq->cmd);
+            // aml_sdhc_clear_fifo(host);
+            aml_sdhc_request_done(host->mmc, mrq);
+            break;
+        case HOST_TASKLET_CMD:
+            if(!host->mrq->data){
+                cancel_delayed_work(&host->timeout);
+                spin_lock_irqsave(&host->mrq_lock, flags);
+                host->mrq->cmd->error = 0;
+                host->xfer_step = XFER_TASKLET_CMD;
+                spin_unlock_irqrestore(&host->mrq_lock, flags);
+                aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+                aml_sdhc_read_response(host->mmc, host->mrq->cmd);
+                aml_sdhc_request_done(host->mmc, mrq);
+            } else {
+                sdhc_err("xfer_step is HOST_TASKLET_CMD, while host->mrq->data is not NULL\n");
+            }
+            break;
+        case HOST_RX_FIFO_FULL:
+        case HOST_TX_FIFO_EMPTY:
+        case HOST_RSP_CRC_ERR:
+        case HOST_DAT_CRC_ERR:
+            aml_sdhc_not_timeout_err_handler(host);
+            break;
+        case HOST_RSP_TIMEOUT_ERR:
+        case HOST_DAT_TIMEOUT_ERR:
+            aml_sdhc_com_err_handler(host);
+            break;
+        default:
+            sdhc_err("BUG xfer_step=%d, host->status=%d\n", xfer_step, status);
+            BUG();
+    }
+
+    return IRQ_HANDLED;
+}
+
+static void aml_sdhc_clk_switch_off (struct amlsd_host* host)
+{
+    u32 vclkc = readl(host->base+SDHC_CLKC);
+    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
+
+    if (host->is_gated) {
+        // sdhc_err("direct return\n");
+        return;
+    }
+
+    /*Turn off Clock*/
+    clkc->tx_clk_on = 0;
+    clkc->rx_clk_on = 0;
+    clkc->sd_clk_on = 0;
+    writel(vclkc, host->base+SDHC_CLKC);
+    clkc->mod_clk_on = 0;
+    writel(vclkc, host->base+SDHC_CLKC);
+
+    host->is_gated = true;
+    // sdhc_err("clock off\n");
+}
+
+static void aml_sdhc_clk_switch_on (struct amlsd_platform* pdata, int clk_div, int clk_src_sel)
+{
+    struct amlsd_host* host = (void*)pdata->host;
+    u32 vclkc = readl(host->base+SDHC_CLKC);
+    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
+
+    /*Set clock divide*/
+    clkc->clk_div = clk_div;
+    clkc->clk_src_sel = clk_src_sel;
+    writel(vclkc, host->base+SDHC_CLKC);
+
+    /*Turn on Clock*/
+    clkc->mod_clk_on = 1;
+    writel(vclkc, host->base+SDHC_CLKC);
+
+    clkc->tx_clk_on = 1;
+    clkc->rx_clk_on = 1;
+    clkc->sd_clk_on = 1;
+    writel(vclkc, host->base+SDHC_CLKC);
+
+    host->is_gated = false;
+    // udelay(10);
+    // sdhc_err("clock on, SDHC_CLKC=%#x\n", readl(host->base+SDHC_CLKC));
+}
+
+static void aml_sdhc_clk_switch (struct amlsd_platform* pdata, int clk_div, int clk_src_sel)
+{
+    struct amlsd_host* host = (void*)pdata->host;
+    u32 vclkc = readl(host->base + SDHC_CLKC);
+    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
+    
+    if (!host->is_gated && (clkc->clk_div == clk_div) && (clkc->clk_src_sel == clk_src_sel)) {
+        // sdhc_err("direct return\n");
+        return; // if the same, return directly
+    }
+
+    aml_sdhc_clk_switch_off(host);
+    // mdelay(1);
+    aml_sdhc_clk_switch_on(pdata, clk_div, clk_src_sel);
 }
 
 /*
@@ -733,22 +1208,48 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
 */
 static void aml_sdhc_set_clk_rate(struct mmc_host *mmc, unsigned int clk_ios)
 {
-    u32 clk_rate, clk_div;
+    u32 clk_rate, clk_div, clk_src_sel, clk_src_div;
     struct clk *clk_src;
     struct amlsd_platform* pdata = mmc_priv(mmc);
     struct amlsd_host* host = (void*)pdata->host;
-    u32 vclkc = readl(host->base+SDHC_CLKC);
-    struct sdhc_clkc* clkc = (struct sdhc_clkc*)&vclkc;
-    struct sdhc_clk2 clk2;
+    u32 vclk2;
+    struct sdhc_clk2 *clk2 = (struct sdhc_clk2*)&vclk2;
 
-    sdhc_err("[aml_sdhc_set_clk_rate] vclkc %x\n", vclkc);
-    //aml_sdhc_host_reset(host);
+    if (clk_ios == 0) {
+        aml_sdhc_clk_switch_off(host);
+        return;
+    }
 
-    clk_src = clk_get_sys("pll_fixed", NULL);
-    clk_rate = clk_get_rate(clk_src)/4;
+    if ((clk_ios > 10000000) && (val1 > 10000000)) // for debug, 10M
+        clk_ios = val1;
 
-    sdhc_dbg(AMLSD_DBG_IOS, "Clk IOS %d, Clk Src %d, Host Max Clk %d\n",
-        clk_ios, clk_rate, pdata->f_max);
+    clk_src_div = -1;
+    clk_src_sel = SDHC_CLOCK_SRC_FCLK_DIV3;
+    switch(clk_src_sel)
+    {
+        case SDHC_CLOCK_SRC_FCLK_DIV3:
+            clk_src_div = 3;
+            break;
+        case SDHC_CLOCK_SRC_FCLK_DIV4:
+            clk_src_div = 4;
+            break;
+        case SDHC_CLOCK_SRC_FCLK_DIV5:
+            clk_src_div = 5;
+            break;
+        case SDHC_CLOCK_SRC_OSC:
+            clk_src_div = 0;
+            break;
+        default:
+            sdhc_err("Clock source error: %d\n", clk_src_sel);
+            return; // clk_src_div = -1;
+    }
+
+    if (clk_src_sel != SDHC_CLOCK_SRC_OSC) {
+        clk_src = clk_get_sys("pll_fixed", NULL); // fclk
+        clk_rate = clk_get_rate(clk_src)/clk_src_div;
+    } else { // OSC, 24MHz
+        clk_rate = 24000000;
+    }
 
     if(clk_ios > pdata->f_max)
         clk_ios = pdata->f_max;
@@ -757,51 +1258,71 @@ static void aml_sdhc_set_clk_rate(struct mmc_host *mmc, unsigned int clk_ios)
 
     /*0: dont set it, 1:div2, 2:div3, 3:div4...*/
     clk_div = clk_rate / clk_ios - !(clk_rate%clk_ios);
+    // sdhc_err("clk_rate=%d, clk_ios=%d, clk_div=%d\n",
+        // clk_rate, clk_ios, clk_div);
 
     /*Turn off Clock*/
-    clkc->tx_clk_on = 0;
-    clkc->rx_clk_on = 0;
-    clkc->sd_clk_on = 0;
-    writel(vclkc, host->base+SDHC_CLKC);
-    clkc->mod_clk_on = 0;
-    writel(vclkc, host->base+SDHC_CLKC);
+    // clkc->tx_clk_on = 0;
+    // clkc->rx_clk_on = 0;
+    // clkc->sd_clk_on = 0;
+    // writel(vclkc, host->base+SDHC_CLKC);
+    // clkc->mod_clk_on = 0;
+    // writel(vclkc, host->base+SDHC_CLKC);
 
-    mdelay(1);
+    // mdelay(1);
 
     /*Set clock divide*/
-    clkc->clk_div = clk_div;
-    writel(vclkc, host->base+SDHC_CLKC);
+    // clkc->clk_div = clk_div;
+    // writel(vclkc, host->base+SDHC_CLKC);
+
+    // mdelay(1);
 
-    mdelay(1);
     /*Turn on Clock*/
-    clkc->mod_clk_on = 1;
-    writel(vclkc, host->base+SDHC_CLKC);
+    // clkc->mod_clk_on = 1;
+    // writel(vclkc, host->base+SDHC_CLKC);
 
-    clkc->tx_clk_on = 1;
-    clkc->rx_clk_on = 1;
-    clkc->sd_clk_on = 1;
-    clkc->clk_src_sel = SDHC_CLOCK_SRC_FCLK_DIV4;
-    clkc->mem_pwr_off = 0;
-    writel(*(u32*)&clk2, host->base+SDHC_CLK2);
+    // clkc->tx_clk_on = 1;
+    // clkc->rx_clk_on = 1;
+    // clkc->sd_clk_on = 1;
+    // clkc->clk_src_sel = clk_src_sel;
+    // clkc->mem_pwr_off = 0;
+    // writel(*(u32*)&clk2, host->base+SDHC_CLK2); // ???? can be deleted?
 
     /*Set to platform data*/
-    pdata->clkc = vclkc;
-    pdata->clock = clk_ios;
-    printk("%s pdata->clkc %x, clk_div %d, vclkc %x\n", pdata->pinname,
-        pdata->clkc, clkc->clk_div, vclkc);
-    writel(vclkc, host->base+SDHC_CLKC);
-
-    clk2.rx_clk_phase = 31;
-    clk2.sd_clk_phase = 0;
-    writel(*(u32*)&clk2, host->base + SDHC_CLK2);
-    sdhc_err("clock %d pdata->clock %d clk2.rx_clk_phase %d\n",
-        mmc->ios.clock, pdata->clock, clk2.rx_clk_phase);
+    // pdata->clock = clk_ios;
+    // printk("%s pdata->clkc %x, clk_div %d, vclkc %x\n", pdata->pinname,
+        // pdata->clkc, clkc->clk_div, vclkc);
+    // writel(vclkc, host->base+SDHC_CLKC);
+
+    aml_sdhc_clk_switch(pdata, clk_div, clk_src_sel);
+    pdata->clkc = readl(host->base+SDHC_CLKC);
+
+    pdata->mmc->actual_clock = clk_rate / (clk_div + 1);
+
+    vclk2 = readl(host->base+SDHC_CLK2);
+    if (pdata->mmc->actual_clock > 5000000) { // if > 50M
+        clk2->rx_clk_phase = 8;
+        clk2->sd_clk_phase = 1; // sd_clk_phase_set
+    } else if (pdata->mmc->actual_clock > 25000000) { // if > 25M
+        clk2->rx_clk_phase = 10;
+        clk2->sd_clk_phase = 1; // sd_clk_phase_set
+    } else {
+        clk2->rx_clk_phase = 24;
+        clk2->sd_clk_phase = 0;
+        // clk2->sd_clk_phase = sd_clk_phase_set;
+    }
+    writel(vclk2, host->base+SDHC_CLK2);
+    pdata->clk2 = vclk2;
 
     /*Disable All Irq*/
     writel(0, host->base+SDHC_ICTL);
 
     /*Wait for a while after clock setting*/
-    udelay(100);
+    // udelay(100);
+
+    sdhc_dbg(AMLSD_DBG_IOS, "Clk IOS %d, Clk Src %d, Host Max Clk %d, vclkc=%#x, clk2=%#x, actual_clock=%d, rx_clk_phase=%d, sd_clk_phase=%d\n",
+        clk_ios, clk_rate, pdata->f_max, readl(host->base+SDHC_CLKC), readl(host->base+SDHC_CLK2), pdata->mmc->actual_clock, clk2->rx_clk_phase, clk2->sd_clk_phase);
+
     return;
 }
 
@@ -840,11 +1361,11 @@ static void aml_sdhc_set_power(struct amlsd_platform* pdata, u32 power_mode)
 {
     switch (power_mode) {
         case MMC_POWER_ON:
-            if(pdata->pwr_on)
-                pdata->pwr_on(pdata);
             if(pdata->pwr_pre)
                 pdata->pwr_pre(pdata);
-                break;
+            if(pdata->pwr_on)
+                    pdata->pwr_on(pdata);
+            break;
         case MMC_POWER_UP:
             break;
         case MMC_POWER_OFF:
@@ -853,7 +1374,7 @@ static void aml_sdhc_set_power(struct amlsd_platform* pdata, u32 power_mode)
                 pdata->pwr_pre(pdata);
             if(pdata->pwr_off)
                 pdata->pwr_off(pdata);
-                break;
+            break;
     }
 }
 
@@ -862,15 +1383,14 @@ static void aml_sdhc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
     struct amlsd_platform * pdata = mmc_priv(mmc);
 
-    if(pdata->eject)
+    if(!pdata->is_in)
         return;
 
     /*Set Power*/
     aml_sdhc_set_power(pdata, ios->power_mode);
 
     /*Set Clock*/
-    if(ios->clock)
-        aml_sdhc_set_clk_rate(mmc, ios->clock);
+    aml_sdhc_set_clk_rate(mmc, ios->clock);
 
     /*Set Bus Width*/
     aml_sdhc_set_bus_width(pdata, ios->bus_width);
@@ -899,59 +1419,94 @@ static int aml_sdhc_get_ro(struct mmc_host *mmc)
 int aml_sdhc_get_cd(struct mmc_host *mmc)
 {
     struct amlsd_platform * pdata = mmc_priv(mmc);
-    int ret = 1;
+    return pdata->is_in; // 0: no inserted  1: inserted
+}
 
-    if(pdata->cd)
-        ret = pdata->cd(pdata);
-    else
-        ret = 0; //inserted
-    pdata->eject = ret;
-    return (ret?0:1);
+int aml_signal_voltage_switch (struct mmc_host *mmc, struct mmc_ios *ios)
+{
+    struct amlsd_platform* pdata = mmc_priv(mmc);
+
+    return aml_sd_voltage_switch(pdata, ios->signal_voltage);
 }
 
-static irqreturn_t aml_sdhc_irq_cd(int irq, void *dev_id)
+/* Check if the card is pulling dat[0:3] low */
+static int aml_sdhc_card_busy (struct mmc_host *mmc)
 {
-    struct amlsd_platform *pdata = (struct amlsd_platform*)dev_id;
+    struct amlsd_platform * pdata = mmc_priv(mmc);
+    struct amlsd_host *host = pdata->host;
+    u32 vstat;
+    struct sdhc_stat* stat = (struct sdhc_stat*)&vstat;
 
-    mmc_detect_change(pdata->mmc, msecs_to_jiffies(500));
-    aml_sdhc_get_cd(pdata->mmc);
-    return IRQ_HANDLED;
+    vstat = readl(host->base + SDHC_STAT);
+    sdhc_dbg(AMLSD_DBG_COMMON, "dat[0:3]=%#x\n", stat->dat3_0);
+
+    return (stat->dat3_0 == 0);
 }
 
 #ifdef CONFIG_PM
 
 static int aml_sdhc_suspend(struct platform_device *pdev, pm_message_t state)
 {
+    int ret = 0;
+    int i;
     struct amlsd_host *host = platform_get_drvdata(pdev);
     struct mmc_host* mmc;
     struct amlsd_platform* pdata;
 
-    printk(KERN_INFO 	"***Entered %s:%s\n", __FILE__,__func__);
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+    i = 0;
     list_for_each_entry(pdata, &host->sibling, sibling){
         mmc = pdata->mmc;
-        mmc_suspend_host(mmc);
+        //mmc_power_save_host(mmc);
+        ret = mmc_suspend_host(mmc);
+        if (ret)
+            break;
+
+        i++;
     }
-    return 0;
+
+    if (ret) {
+        list_for_each_entry(pdata, &host->sibling, sibling) {
+            i--;
+            if (i < 0) {
+                break;
+            }
+            mmc = pdata->mmc;
+            mmc_resume_host(mmc);
+        }
+    }
+    printk("***Exited %s:%s\n", __FILE__,__func__);
+
+    return ret;
 }
 
 static int aml_sdhc_resume(struct platform_device *pdev)
 {
+    int ret = 0;
     struct amlsd_host *host = platform_get_drvdata(pdev);
     struct mmc_host* mmc;
     struct amlsd_platform* pdata;
 
-    printk(KERN_INFO 	"***Entered %s:%s\n", __FILE__,__func__);
+    printk("***Entered %s:%s\n", __FILE__,__func__);
     list_for_each_entry(pdata, &host->sibling, sibling){
+        // detect if a card is exist or not if it is removable
+        if (!(pdata->caps & MMC_CAP_NONREMOVABLE)) {
+            aml_sd_uart_detect(pdata);
+        }
         mmc = pdata->mmc;
-        mmc_resume_host(mmc);
+        //mmc_power_restore_host(mmc);
+        ret = mmc_resume_host(mmc);
+        if (ret)
+            break;
     }
-    return 0;
+    printk("***Exited %s:%s\n", __FILE__,__func__);
+    return ret;
 }
 
 #else
 
-#define aml_mmc_suspend	NULL
-#define aml_mmc_resume		NULL
+#define aml_sdhc_suspend    NULL
+#define aml_sdhc_resume        NULL
 
 #endif
 
@@ -960,12 +1515,14 @@ static const struct mmc_host_ops aml_sdhc_ops = {
     .set_ios = aml_sdhc_set_ios,
     .get_cd = aml_sdhc_get_cd,
     .get_ro = aml_sdhc_get_ro,
+    .start_signal_voltage_switch = aml_signal_voltage_switch,
+    .card_busy = aml_sdhc_card_busy,
 };
 
 /*for multi host claim host*/
 static struct mmc_claim aml_sdhc_claim;
 
-static struct amlsd_host* aml_sdhc_init_host(struct amlsd_platform* pdata)
+static struct amlsd_host* aml_sdhc_init_host(void)
 {
     struct amlsd_host *host;
 
@@ -981,21 +1538,40 @@ static struct amlsd_host* aml_sdhc_init_host(struct amlsd_platform* pdata)
     }
 
     host->bn_buf = dma_alloc_coherent(NULL, SDHC_BOUNCE_REQ_SIZE,
-    						&host->bn_dma_buf, GFP_KERNEL);
-    sdhc_err("host->bn_buf %x, host->bn_dma_buf %x\n", host->bn_buf,
-                host->bn_dma_buf);
+                            &host->bn_dma_buf, GFP_KERNEL);
+    // sdhc_err("host->bn_buf %x, host->bn_dma_buf %x\n", (int)host->bn_buf,
+                // (int)host->bn_dma_buf);
     if(NULL == host->bn_buf){
         sdhc_err("Dma alloc Fail!\n");
         return NULL;
     }
-
-    setup_timer(&host->timeout_tlist, aml_sdhc_timeout, (ulong)host);
+    // setup_timer(&host->timeout_tlist, aml_sdhc_timeout, (ulong)host);
+    INIT_DELAYED_WORK(&host->timeout, aml_sdhc_timeout);
 
     spin_lock_init(&host->mrq_lock);
     host->xfer_step = XFER_INIT;
 
     INIT_LIST_HEAD(&host->sibling);
+    
+    host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
+    host->pinctrl = NULL;
+    host->is_gated = false;
+    host->status = HOST_INVALID;
+    host->msg_buf = kmalloc(MESSAGE_BUF_SIZE, GFP_KERNEL);
+    if (!host->msg_buf) {
+        printk("malloc message buffer fail\n");
+    }
+
+#ifdef      CONFIG_MMC_AML_DEBUG
+    host->req_cnt = 0;
+    sdhc_err("CONFIG_MMC_AML_DEBUG is on!\n");
+#endif
+
+#ifdef      CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW
+    sdhc_err("CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW is on!\n");
+#endif
+
     return host;
 }
 
@@ -1004,10 +1580,13 @@ static int aml_sdhc_probe(struct platform_device *pdev)
     struct mmc_host *mmc = NULL;
     struct amlsd_host *host = NULL;
     struct amlsd_platform* pdata;
-    struct amlsd_platform* opdata = (void*)pdev->dev.platform_data;
     int ret = 0, i;
 
-    host = aml_sdhc_init_host(opdata);
+    // pre_probe_host_ops(); // for tmp debug
+
+    aml_mmc_ver_msg_show();
+
+    host = aml_sdhc_init_host();
     if(!host)
         goto fail_init_host;
     if(amlsd_get_reg_base(pdev, host))
@@ -1042,11 +1621,16 @@ static int aml_sdhc_probe(struct platform_device *pdev)
                     break;
                 }
             }
-		}
+        }
         dev_set_name(&mmc->class_dev, "%s", pdata->pinname);
+        if (pdata->caps & MMC_CAP_NONREMOVABLE) {
+            pdata->is_in = true;
+        }
 
         pdata->host = host;
         pdata->mmc = mmc;
+        pdata->is_fir_init = true;
+        pdata->signal_voltage = 0xff; // init as an invalid value
 
         mmc->index = i;
         mmc->ops = &aml_sdhc_ops;
@@ -1064,15 +1648,25 @@ static int aml_sdhc_probe(struct platform_device *pdev)
         mmc->caps2 = pdata->caps2;
         mmc->f_min = pdata->f_min;
         mmc->f_max = pdata->f_max;
+        mmc->max_current_180 = 300; // 300 mA in 1.8V
+        mmc->max_current_330 = 300; // 300 mA in 3.3V
 
         if(pdata->port_init)
             pdata->port_init(pdata);
 
+        aml_sduart_pre(pdata);
+
         ret = mmc_add_host(mmc);
-        if (ret) {
+        if (ret) { // error
             sdhc_err("Failed to add mmc host.\n");
             goto probe_free_host;
+        } else { // ok
+            if (aml_card_type_sdio(pdata)) { // if sdio_wifi
+                sdio_host = mmc;
+                mmc->rescan_entered = 1; // do NOT run mmc_rescan for the first time
+            }
         }
+
         aml_sdhc_init_debugfs(mmc);
         /*Add each mmc host pdata to this controller host list*/
         INIT_LIST_HEAD(&pdata->sibling);
@@ -1081,17 +1675,28 @@ static int aml_sdhc_probe(struct platform_device *pdev)
         /*Register card detect irq : plug in & unplug*/
         if(pdata->irq_in && pdata->irq_out){
             pdata->irq_init(pdata);
-            ret = request_irq(pdata->irq_in+INT_GPIO_0, aml_sdhc_irq_cd,
-                        IRQF_DISABLED, "sdhc_mmc_in", pdata);
-            ret |= request_irq(pdata->irq_out+INT_GPIO_0, aml_sdhc_irq_cd,
-                        IRQF_DISABLED, "sdhc_mmc_out", pdata);
+            ret = request_threaded_irq(pdata->irq_in+INT_GPIO_0,
+                    (irq_handler_t)aml_sd_irq_cd, aml_irq_cd_thread,
+                    IRQF_DISABLED, "sdhc_mmc_in", (void*)pdata);
             if (ret) {
-                sdio_err("Failed to request mmc detect\n");
+                sdhc_err("Failed to request mmc IN detect\n");
+                goto probe_free_host;
+            }
+            ret |= request_threaded_irq(pdata->irq_out+INT_GPIO_0,
+                    (irq_handler_t)aml_sd_irq_cd, aml_irq_cd_thread,
+                    IRQF_DISABLED, "sdhc_mmc_out", (void*)pdata);
+            // ret = request_irq(pdata->irq_in+INT_GPIO_0, aml_sdhc_irq_cd,
+                        // IRQF_DISABLED, "sdhc_mmc_in", pdata);
+            // ret |= request_irq(pdata->irq_out+INT_GPIO_0, aml_sdhc_irq_cd,
+                        // IRQF_DISABLED, "sdhc_mmc_out", pdata);
+            if (ret) {
+                sdhc_err("Failed to request mmc OUT detect\n");
                 goto fail_cd_irq_in;
             }
         }
     }
 
+    print_tmp("%s() success!\n", __FUNCTION__);
     platform_set_drvdata(pdev, host);
     return 0;
 
@@ -1110,15 +1715,15 @@ fail_init_host:
     dma_free_coherent(NULL, SDHC_BOUNCE_REQ_SIZE, host->bn_buf,
         (dma_addr_t)host->bn_dma_buf);
     kfree(host);
+    print_tmp("aml_sdhc_probe() fail!\n");
     return ret;
 }
 
-
 int aml_sdhc_remove(struct platform_device *pdev)
 {
     struct amlsd_host* host  = platform_get_drvdata(pdev);
-    struct amlsd_platform* pdata;
     struct mmc_host* mmc;
+    struct amlsd_platform* pdata;
 
     dma_free_coherent(NULL, SDHC_BOUNCE_REQ_SIZE, host->bn_buf,
         (dma_addr_t )host->bn_dma_buf);
@@ -1131,7 +1736,14 @@ int aml_sdhc_remove(struct platform_device *pdev)
         mmc_remove_host(mmc);
         mmc_free_host(mmc);
     }
+    
+    aml_devm_pinctrl_put(host);
+
+    kfree(host->msg_buf);
     kfree(host);
+
+    switch_mod_gate_by_type(MOD_SDHC, 0); // gate clock of SDHC
+
     return 0;
 }
 
@@ -1145,13 +1757,11 @@ static const struct of_device_id aml_sdhc_dt_match[]={
 MODULE_DEVICE_TABLE(of, aml_sdhc_dt_match);
 
 static struct platform_driver aml_sdhc_driver = {
-    .probe 		= aml_sdhc_probe,
-    .remove		= aml_sdhc_remove,
-#ifdef CONFIG_PM
-    .suspend	= aml_sdhc_suspend,
-    .resume		= aml_sdhc_resume,
-#endif
-    .driver		= {
+    .probe         = aml_sdhc_probe,
+    .remove        = aml_sdhc_remove,
+    .suspend    = aml_sdhc_suspend,
+    .resume        = aml_sdhc_resume,
+    .driver        = {
         .name = "aml_sdhc",
         .owner = THIS_MODULE,
         .of_match_table=aml_sdhc_dt_match,
@@ -1174,3 +1784,44 @@ module_exit(aml_sdhc_cleanup);
 MODULE_DESCRIPTION("Amlogic Multimedia Card driver");
 MODULE_LICENSE("GPL");
 
+static int __init rx_clk_phase_setup(char *str)
+{
+    rx_clk_phase_set = simple_strtol(str, NULL, 0);
+    print_dbg("rx_clk_phase=%d\n", rx_clk_phase_set);
+    return 1;
+}
+__setup("rx_clk_phase=", rx_clk_phase_setup);
+
+static int __init sd_clk_phase_setup(char *str)
+{
+    sd_clk_phase_set = simple_strtol(str, NULL, 0);
+    print_dbg("sd_clk_phase_set=%d\n", sd_clk_phase_set);
+    return 1;
+}
+__setup("sd_clk_phase=", sd_clk_phase_setup);
+
+static int __init rx_endian_setup(char *str)
+{
+    rx_endian = simple_strtol(str, NULL, 0);
+    print_dbg("rx_endian=%#x\n", rx_endian);
+    return 1;
+}
+__setup("rx_endian=", rx_endian_setup);
+
+static int __init tx_endian_setup(char *str)
+{
+    tx_endian = simple_strtol(str, NULL, 0);
+    print_dbg("tx_endian=%#x\n", tx_endian);
+    
+    return 1;
+}
+__setup("tx_endian=", tx_endian_setup);
+
+static int __init val1_setup(char *str)
+{
+    val1 = simple_strtol(str, NULL, 0);
+    print_dbg("val1=%d\n", val1);
+    
+    return 1;
+}
+__setup("val1=", val1_setup);
diff --git a/drivers/amlogic/mmc/aml_sdio.c b/drivers/amlogic/mmc/aml_sdio.c
index 5d936ad89be9..c5dbf41ab03f 100755
--- a/drivers/amlogic/mmc/aml_sdio.c
+++ b/drivers/amlogic/mmc/aml_sdio.c
@@ -44,7 +44,7 @@ static void aml_sdio_soft_reset(struct amlsd_host* host)
     /*soft reset*/
     irqc.soft_reset = 1;
     writel(*(u32*)&irqc, host->base + SDIO_IRQC);
-	udelay(2);
+    udelay(2);
 }
 
 /*
@@ -128,9 +128,9 @@ void aml_sdio_prepare_dma(struct amlsd_host *host, struct mmc_request *mrq)
 {
     struct mmc_data *data = mrq->data;
 
-	if(data->flags & MMC_DATA_WRITE){
-		aml_sg_copy_buffer(data->sg, data->sg_len,
-			host->bn_buf, data->blksz*data->blocks, 1);
+    if(data->flags & MMC_DATA_WRITE){
+        aml_sg_copy_buffer(data->sg, data->sg_len,
+            host->bn_buf, data->blksz*data->blocks, 1);
         sdio_dbg(AMLSD_DBG_WR_DATA,"W Cmd %d, %x-%x-%x-%x\n",
             mrq->cmd->opcode,
             host->bn_buf[0], host->bn_buf[1],
@@ -174,8 +174,8 @@ void aml_sdio_set_port_ios(struct mmc_host* mmc)
 void aml_sdio_start_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
 {
     u32 pack_size;
-	struct amlsd_platform* pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
+    struct amlsd_platform* pdata = mmc_priv(mmc);
+    struct amlsd_host* host = pdata->host;
     struct cmd_send send={0};
     struct sdio_extension ext={0};
     u32 virqc = readl(host->base + SDIO_IRQC);
@@ -185,22 +185,22 @@ void aml_sdio_start_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
     u32 vmult = readl(host->base + SDIO_MULT);
     struct sdio_mult_config* mult = (void*)&vmult;
 
-	switch (mmc_resp_type(mrq->cmd)) {
-    	case MMC_RSP_R1:
-    	case MMC_RSP_R1B:
-    	case MMC_RSP_R3:
+    switch (mmc_resp_type(mrq->cmd)) {
+        case MMC_RSP_R1:
+        case MMC_RSP_R1B:
+        case MMC_RSP_R3:
             /*7(cmd)+32(respnse)+7(crc)-1 data*/
             send.cmd_response_bits = 45;
-    		break;
-    	case MMC_RSP_R2:
+            break;
+        case MMC_RSP_R2:
             /*7(cmd)+120(respnse)+7(crc)-1 data*/
-    		send.cmd_response_bits = 133;
+            send.cmd_response_bits = 133;
             send.response_crc7_from_8 = 1;
-    		break;
-    	default:
+            break;
+        default:
             /*no response*/
-    		break;
-	}
+            break;
+    }
 
     if(!(mrq->cmd->flags & MMC_RSP_CRC))
         send.response_do_not_have_crc7 = 1;
@@ -210,7 +210,7 @@ void aml_sdio_start_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
     if(mrq->data){
         /*total package num*/
         send.repeat_package_times = mrq->data->blocks - 1;
-		BUG_ON(mrq->data->blocks > 256);
+        BUG_ON(mrq->data->blocks > 256);
         /*package size*/
         if(pdata->width) /*0: 1bit, 1: 4bit*/
            pack_size = mrq->data->blksz*8 + (16-1)*4;
@@ -250,8 +250,8 @@ void aml_sdio_start_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
  */
 void aml_sdio_request_done(struct mmc_host *mmc, struct mmc_request *mrq)
 {
-	struct amlsd_platform * pdata = mmc_priv(mmc);
-	struct amlsd_host* host = pdata->host;
+    struct amlsd_platform * pdata = mmc_priv(mmc);
+    struct amlsd_host* host = pdata->host;
     unsigned long flags;
     struct mmc_command *cmd;
     // u32 virqs = readl(host->base + SDIO_IRQS);
@@ -298,7 +298,7 @@ void aml_sdio_request_done(struct mmc_host *mmc, struct mmc_request *mrq)
     }
 
 #ifdef      CONFIG_MMC_AML_DEBUG
-	host->req_cnt--;
+    host->req_cnt--;
 
     aml_dbg_verify_pinmux(pdata);
     aml_dbg_verify_pull_up(pdata);
@@ -342,42 +342,43 @@ static void aml_sdio_print_err (struct amlsd_host *host, char *msg)
 }
 
 /*setup delayed workstruct in aml_sdio_request*/
-static void aml_sdio_timeout(struct work_struct *data)
+static void aml_sdio_timeout(struct work_struct *work)
 {
     static int timeout_cnt = 0;
-    unsigned long flags;
-    //struct amlsd_host* host = (void*)data;
-    struct amlsd_host *host = container_of(data, struct amlsd_host, timeout);
+    struct amlsd_host *host = container_of(work, struct amlsd_host, timeout.work);
     // struct mmc_request *mrq = host->mrq;
     u32 virqs = readl(host->base + SDIO_IRQS);
     struct sdio_status_irq* irqs = (void*)&virqs;
     u32 virqc =readl(host->base + SDIO_IRQC);
     struct sdio_irq_config* irqc = (void*)&virqc;
+    unsigned long flags;
 #ifdef      CONFIG_MMC_AML_DEBUG
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
 #endif
 
     spin_lock_irqsave(&host->mrq_lock, flags);
-	if(host->xfer_step == XFER_FINISHED){
+    if(host->xfer_step == XFER_FINISHED){
         spin_unlock_irqrestore(&host->mrq_lock, flags);
-		sdio_err("timeout after xfer finished\n");
-		return;
-	}
+        sdio_err("timeout after xfer finished\n");
+        return;
+    }
     if((irqs->sdio_cmd_int)                             // irq have been occured
             || (host->xfer_step == XFER_IRQ_OCCUR)){    // isr have been run
         //mod_timer(&host->timeout_tlist, jiffies + 10);
         schedule_delayed_work(&host->timeout, 10);
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        
         if(irqs->sdio_cmd_int) {
             timeout_cnt++;
-            if (timeout_cnt > 100)
+            if (timeout_cnt > 10)
                 goto timeout_handle;
             sdio_err("%s: irq have been occured\n", mmc_hostname(host->mmc));
         }
         else
             sdio_err("%s: isr have been run\n",  mmc_hostname(host->mmc));
-		return;
-	}
+            
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return;
+    }
 timeout_handle:
     timeout_cnt = 0;
 
@@ -391,6 +392,10 @@ timeout_handle:
     irqc->arc_cmd_int_en = 0;   // disable cmd irq
     writel(virqc, host->base + SDIO_IRQC);
 
+    host->xfer_step = XFER_TIMEDOUT;
+    host->mrq->cmd->error = -ETIMEDOUT;
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+    
     aml_sdio_print_err(host, "Timeout error");
     // if (pdata->port == MESON_SDIO_PORT_A) {
         // sdio_err("power_on_pin=%d\n",
@@ -410,12 +415,6 @@ timeout_handle:
     // aml_dbg_print_pinmux();
 #endif
 
-    host->xfer_step = XFER_TIMEDOUT;
-
-    /*set error*/
-    host->mrq->cmd->error = -ETIMEDOUT;
-    spin_unlock_irqrestore(&host->mrq_lock, flags);
-
     /*request done*/
     aml_sdio_request_done(host->mmc, host->mrq);
 
@@ -430,7 +429,7 @@ timeout_handle:
 
     /*print reg*/
     // aml_sdio_print_reg(host);
-	// sdio_err("Timeout out func\n");
+    // sdio_err("Timeout out func\n");
 }
 
 /*
@@ -455,59 +454,58 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-	if(!pdata->is_in){
+    if(!pdata->is_in){
         mrq->cmd->error = -ENOMEDIUM;
         mmc_request_done(mmc, mrq);
-		return;
-	}
+        return;
+    }
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     if (host->req_cnt) {
         sdio_err("Reentry error! host->req_cnt=%d\n", host->req_cnt);
     }
-	host->req_cnt++;
+    host->req_cnt++;
 #endif
 
-	sdio_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
-		mmc_hostname(mmc), mrq->cmd->opcode,
-		mrq->cmd->arg, mrq->cmd->flags);
+    sdio_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
+        mmc_hostname(mmc), mrq->cmd->opcode,
+        mrq->cmd->arg, mrq->cmd->flags);
 
-	if(mrq->data) {
+    if(mrq->data) {
         /*Copy data to dma buffer for write request*/
-		aml_sdio_prepare_dma(host, mrq);
+        aml_sdio_prepare_dma(host, mrq);
         writel(host->bn_dma_buf, host->base + SDIO_ADDR);
 
-		sdio_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
-			"tsac %d ms nsac %d\n",
-			mmc_hostname(mmc), mrq->data->blksz,
-			mrq->data->blocks, mrq->data->flags,
-			mrq->data->timeout_ns / 1000000,
-			mrq->data->timeout_clks);
+        sdio_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
+            "tsac %d ms nsac %d\n",
+            mmc_hostname(mmc), mrq->data->blksz,
+            mrq->data->blocks, mrq->data->flags,
+            mrq->data->timeout_ns / 1000000,
+            mrq->data->timeout_clks);
     }
 
-	/*clear pinmux & set pinmux*/
-	if(pdata->xfer_pre)
-		pdata->xfer_pre(pdata);
+    /*clear pinmux & set pinmux*/
+    if(pdata->xfer_pre)
+        pdata->xfer_pre(pdata);
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     aml_dbg_verify_pull_up(pdata);
     aml_dbg_verify_pinmux(pdata);
 #endif
 
-	if(!mrq->data)
-		timeout = 100; //mod_timer(&host->timeout_tlist, jiffies + 100); // 1s
-	else
-		timeout = 500;//mod_timer(&host->timeout_tlist,
-				//jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
-
-	schedule_delayed_work(&host->timeout, timeout);
+    if(!mrq->data)
+        timeout = 100; //mod_timer(&host->timeout_tlist, jiffies + 100); // 1s
+    else
+        timeout = 500;//mod_timer(&host->timeout_tlist,
+                //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
+    schedule_delayed_work(&host->timeout, timeout);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
     if(host->xfer_step != XFER_FINISHED && host->xfer_step != XFER_INIT)
         sdio_err("host->xfer_step %d\n", host->xfer_step);
 
     host->mrq = mrq;
-	host->mmc = mmc;
+    host->mmc = mmc;
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
@@ -551,36 +549,36 @@ static irqreturn_t aml_sdio_irq(int irq, void *dev_id)
     u32 virqs = readl(host->base + SDIO_IRQS);
     struct sdio_status_irq* irqs = (void*)&virqs;
     // int is_stop;
-	struct mmc_request* mrq;
-	unsigned long flags;
+    struct mmc_request* mrq;
+    unsigned long flags;
 
-	spin_lock_irqsave(&host->mrq_lock, flags);
-	mrq = host->mrq;
-	if(!mrq){
-		sdio_err("CMD%u, arg %08x, virqs=%08x, NULL mrq in aml_sdio_irq xfer_step %d\n",
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    mrq = host->mrq;
+    if(!mrq){
+        sdio_err("CMD%u, arg %08x, virqs=%08x, NULL mrq in aml_sdio_irq xfer_step %d\n",
                 host->opcode, host->arg, virqs, host->xfer_step);
-		if(host->xfer_step == XFER_FINISHED ||
-			host->xfer_step == XFER_TIMEDOUT){
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			return IRQ_HANDLED;
-		}
-		WARN_ON(!mrq);
-		aml_sdio_print_reg(host);
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
-		return IRQ_HANDLED;
-	}
+        if(host->xfer_step == XFER_FINISHED ||
+            host->xfer_step == XFER_TIMEDOUT){
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+            return IRQ_HANDLED;
+        }
+        WARN_ON(!mrq);
+        aml_sdio_print_reg(host);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_HANDLED;
+    }
 
     if(irqs->sdio_cmd_int){
         // writel(virqs, host->base + SDIO_IRQS); // clear irq
         if(host->cmd_is_stop)
-        	host->xfer_step = XFER_IRQ_TASKLET_BUSY;
+            host->xfer_step = XFER_IRQ_TASKLET_BUSY;
         else
-        	host->xfer_step = XFER_IRQ_OCCUR;
+            host->xfer_step = XFER_IRQ_OCCUR;
         // host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
         return IRQ_WAKE_THREAD;
     }else
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
 
     if(irqs->sdio_if_int){
         if(host->mmc->sdio_irq_thread)
@@ -601,8 +599,8 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     u32 vsend = readl(host->base + SDIO_SEND);
     struct cmd_send* send = (void*)&vsend;
     unsigned long flags;
-	struct mmc_request* mrq;
-	enum aml_mmc_waitfor	xfer_step;
+    struct mmc_request* mrq;
+    enum aml_mmc_waitfor    xfer_step;
     // u32 time = READ_CBUS_REG(ISA_TIMERE);
 
     // time = time - host->time_req_sta;
@@ -610,26 +608,26 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
         // printk(KERN_DEBUG "TIME_STAMP: %8d[%s]\n", READ_CBUS_REG(ISA_TIMERE), __FUNCTION__);
         // printk(KERN_DEBUG "Time spend: %8d, CMD%u, arg %08x\n", time, host->opcode, host->arg);
     // }
-	spin_lock_irqsave(&host->mrq_lock, flags);
-	mrq = host->mrq;
-	xfer_step = host->xfer_step;
-	if(!mrq){
-		sdio_err("CMD%u, arg %08x, mrq NULL xfer_step %d\n", host->opcode, host->arg, xfer_step);
-		if(xfer_step == XFER_FINISHED ||
-			xfer_step == XFER_TIMEDOUT){
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
-			sdio_err("[aml_sdio_irq_thread] out\n");
-			return IRQ_HANDLED;
-		}
-		BUG();
-	}
-	if(host->cmd_is_stop){
-		host->cmd_is_stop = 0;
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
-    	aml_sdio_request_done(host->mmc, mrq);
-		return IRQ_HANDLED;
-	}
-	host->xfer_step = XFER_TASKLET_DATA;
+    spin_lock_irqsave(&host->mrq_lock, flags);
+    mrq = host->mrq;
+    xfer_step = host->xfer_step;
+    if(!mrq){
+        sdio_err("CMD%u, arg %08x, mrq NULL xfer_step %d\n", host->opcode, host->arg, xfer_step);
+        if(xfer_step == XFER_FINISHED ||
+            xfer_step == XFER_TIMEDOUT){
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+            sdio_err("[aml_sdio_irq_thread] out\n");
+            return IRQ_HANDLED;
+        }
+        BUG();
+    }
+    if(host->cmd_is_stop){
+        host->cmd_is_stop = 0;
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        aml_sdio_request_done(host->mmc, mrq);
+        return IRQ_HANDLED;
+    }
+    host->xfer_step = XFER_TASKLET_DATA;
 
     if(!mrq->data){
         if(irqs->sdio_response_crc7_ok || send->response_do_not_have_crc7)
@@ -638,7 +636,7 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             mrq->cmd->error = -EILSEQ;
             aml_sdio_print_err(host, "cmd crc7 error");
         }
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
     }else{
         if(irqs->sdio_data_read_crc16_ok||irqs->sdio_data_write_crc16_ok)
@@ -648,26 +646,26 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             aml_sdio_print_err(host, "data crc16 error");
         }
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
-		spin_unlock_irqrestore(&host->mrq_lock, flags);
-	    if(mrq->data->flags & MMC_DATA_READ){
-			aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len,
-				host->bn_buf, mrq->data->blksz*mrq->data->blocks, 0);
-			sdio_dbg(AMLSD_DBG_RD_DATA, "R Cmd %d, %x-%x-%x-%x\n",
-				host->mrq->cmd->opcode,
-				host->bn_buf[0], host->bn_buf[1],
-				host->bn_buf[2], host->bn_buf[3]);
-	    }
-		spin_lock_irqsave(&host->mrq_lock, flags);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        if(mrq->data->flags & MMC_DATA_READ){
+            aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len,
+                host->bn_buf, mrq->data->blksz*mrq->data->blocks, 0);
+            sdio_dbg(AMLSD_DBG_RD_DATA, "R Cmd %d, %x-%x-%x-%x\n",
+                host->mrq->cmd->opcode,
+                host->bn_buf[0], host->bn_buf[1],
+                host->bn_buf[2], host->bn_buf[3]);
+        }
+        spin_lock_irqsave(&host->mrq_lock, flags);
         if(mrq->stop){
             aml_sdio_send_stop(host);
-        	spin_unlock_irqrestore(&host->mrq_lock, flags);
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
         }
         else{
-			spin_unlock_irqrestore(&host->mrq_lock, flags);
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
             aml_sdio_request_done(host->mmc, mrq);
         }
     }
-	return IRQ_HANDLED;
+    return IRQ_HANDLED;
 }
 
 /*
@@ -678,25 +676,25 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
 */
 static void aml_sdio_set_clk_rate(struct amlsd_platform* pdata, u32 clk_ios)
 {
-	struct amlsd_host* host = (void*)pdata->host;
+    struct amlsd_host* host = (void*)pdata->host;
     u32 vconf = readl(host->base + SDIO_CONF);
     struct sdio_config* conf = (void*)&vconf;
     struct clk* clk_src = clk_get_sys("clk81", NULL);
     u32 clk_rate = clk_get_rate(clk_src)/2;
     // u32 clk_rate = 159000000/2; //tmp for 3.10
-	u32 clk_div;
+    u32 clk_div;
 
     // aml_sdio_init_param(pdata);
 
-	if(clk_ios > pdata->f_max)
-		clk_ios = pdata->f_max;
-	if(clk_ios < pdata->f_min)
-		clk_ios = pdata->f_min;
+    if(clk_ios > pdata->f_max)
+        clk_ios = pdata->f_max;
+    if(clk_ios < pdata->f_min)
+        clk_ios = pdata->f_min;
 
     BUG_ON(!clk_ios);
 
-	/*0: dont set it, 1:div2, 2:div3, 3:div4...*/
-	clk_div = clk_rate / clk_ios - !(clk_rate%clk_ios);
+    /*0: dont set it, 1:div2, 2:div3, 3:div4...*/
+    clk_div = clk_rate / clk_ios - !(clk_rate%clk_ios);
 
    if(aml_card_type_sdio(pdata) && (pdata->f_max > 50000000)) // if > 50MHz
           clk_div = 0;
@@ -706,16 +704,16 @@ static void aml_sdio_set_clk_rate(struct amlsd_platform* pdata, u32 clk_ios)
     pdata->mmc->actual_clock = clk_rate / (clk_div + 1);
     writel(vconf, host->base + SDIO_CONF);
 
-	sdio_dbg(AMLSD_DBG_IOS, "Clk IOS %d, Clk Src %d, Host Max Clk %d, clk_divide=%d\n",
-        	clk_ios, (clk_rate*2), pdata->f_max, clk_div);
-	// sdio_err("Clk IOS %d, Clk Src %d, Host Max Clk %d, clk_divide=%d, actual_clock=%d\n",
+    sdio_dbg(AMLSD_DBG_IOS, "Clk IOS %d, Clk Src %d, Host Max Clk %d, clk_divide=%d\n",
+            clk_ios, (clk_rate*2), pdata->f_max, clk_div);
+    // sdio_err("Clk IOS %d, Clk Src %d, Host Max Clk %d, clk_divide=%d, actual_clock=%d\n",
             // clk_ios, (clk_rate*2), pdata->f_max, clk_div, pdata->mmc->actual_clock);
 }
 
 static void aml_sdio_set_bus_width(struct amlsd_platform* pdata, u32 busw_ios)
 {
     u32 bus_width=0;
-	struct amlsd_host* host = (void*)pdata->host;
+    struct amlsd_host* host = (void*)pdata->host;
     u32 vconf = readl(host->base + SDIO_CONF);
     struct sdio_config* conf = (void*)&vconf;
 
@@ -736,38 +734,38 @@ static void aml_sdio_set_bus_width(struct amlsd_platform* pdata, u32 busw_ios)
     conf->bus_width = bus_width;
     pdata->width = bus_width;
     writel(vconf, host->base + SDIO_CONF);
-	sdio_dbg(AMLSD_DBG_IOS, "Bus Width Ios %d\n", bus_width);
+    sdio_dbg(AMLSD_DBG_IOS, "Bus Width Ios %d\n", bus_width);
 }
 
 
 static void aml_sdio_set_power(struct amlsd_platform* pdata, u32 power_mode)
 {
-	switch (power_mode) {
-		case MMC_POWER_ON:
-			if(pdata->pwr_pre)
-				pdata->pwr_pre(pdata);
-			if(pdata->pwr_on)
-					pdata->pwr_on(pdata);
-			break;
-		case MMC_POWER_UP:
-			break;
-		case MMC_POWER_OFF:
-		default:
-			if(pdata->pwr_pre)
-				pdata->pwr_pre(pdata);
-			if(pdata->pwr_off)
-				pdata->pwr_off(pdata);
-			break;
-	}
+    switch (power_mode) {
+        case MMC_POWER_ON:
+            if(pdata->pwr_pre)
+                pdata->pwr_pre(pdata);
+            if(pdata->pwr_on)
+                    pdata->pwr_on(pdata);
+            break;
+        case MMC_POWER_UP:
+            break;
+        case MMC_POWER_OFF:
+        default:
+            if(pdata->pwr_pre)
+                pdata->pwr_pre(pdata);
+            if(pdata->pwr_off)
+                pdata->pwr_off(pdata);
+            break;
+    }
 }
 
 /* Routine to configure clock values. Exposed API to core */
 static void aml_sdio_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	struct amlsd_platform * pdata = mmc_priv(mmc);
+    struct amlsd_platform * pdata = mmc_priv(mmc);
 
-	if(!pdata->is_in)
-		return;
+    if(!pdata->is_in)
+        return;
 
     /*set power*/
     aml_sdio_set_power(pdata, ios->power_mode);
@@ -790,17 +788,17 @@ static void aml_sdio_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 static int aml_sdio_get_ro(struct mmc_host *mmc)
 {
-	struct amlsd_platform * pdata = mmc_priv(mmc);
-	u32 ro = 0;
+    struct amlsd_platform * pdata = mmc_priv(mmc);
+    u32 ro = 0;
 
-	if(pdata->ro)
-		ro = pdata->ro(pdata);
-	return ro;
+    if(pdata->ro)
+        ro = pdata->ro(pdata);
+    return ro;
 }
 
 int aml_sdio_get_cd(struct mmc_host *mmc)
 {
-	struct amlsd_platform * pdata = mmc_priv(mmc);
+    struct amlsd_platform * pdata = mmc_priv(mmc);
     return pdata->is_in; // 0: no inserted  1: inserted
 }
 
@@ -810,16 +808,16 @@ static int aml_sdio_suspend(struct platform_device *pdev, pm_message_t state)
 {
     int ret = 0;
     int i;
-	struct amlsd_host *host = platform_get_drvdata(pdev);
-	struct mmc_host* mmc;
-	struct amlsd_platform* pdata;
+    struct amlsd_host *host = platform_get_drvdata(pdev);
+    struct mmc_host* mmc;
+    struct amlsd_platform* pdata;
 
-	printk("***Entered %s:%s\n", __FILE__,__func__);
+    printk("***Entered %s:%s\n", __FILE__,__func__);
     i = 0;
-	list_for_each_entry(pdata, &host->sibling, sibling){
-		mmc = pdata->mmc;
-		//mmc_power_save_host(mmc);
-		ret = mmc_suspend_host(mmc);
+    list_for_each_entry(pdata, &host->sibling, sibling){
+        mmc = pdata->mmc;
+        //mmc_power_save_host(mmc);
+        ret = mmc_suspend_host(mmc);
         if (ret)
             break;
 
@@ -829,7 +827,7 @@ static int aml_sdio_suspend(struct platform_device *pdev, pm_message_t state)
         // }
 
         i++;
-	}
+    }
 
     if (ret) {
         list_for_each_entry(pdata, &host->sibling, sibling) {
@@ -855,123 +853,123 @@ static int aml_sdio_suspend(struct platform_device *pdev, pm_message_t state)
 static int aml_sdio_resume(struct platform_device *pdev)
 {
     int ret = 0;
-	struct amlsd_host *host = platform_get_drvdata(pdev);
-	struct mmc_host* mmc;
-	struct amlsd_platform* pdata;
+    struct amlsd_host *host = platform_get_drvdata(pdev);
+    struct mmc_host* mmc;
+    struct amlsd_platform* pdata;
 
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-	list_for_each_entry(pdata, &host->sibling, sibling){
+    printk("***Entered %s:%s\n", __FILE__,__func__);
+    list_for_each_entry(pdata, &host->sibling, sibling){
         // if(pdata->port == MESON_SDIO_PORT_A) { // sdio_wifi
         // if(aml_card_type_sdio(pdata)) {
             // wifi_setup_dt();
         // }
 
-        // detect if a card is insert or inset if it is removable
+        // detect if a card is exist or not if it is removable
         if (!(pdata->caps & MMC_CAP_NONREMOVABLE)) {
             aml_sd_uart_detect(pdata);
         }
-		mmc = pdata->mmc;
-		//mmc_power_restore_host(mmc);
-		ret = mmc_resume_host(mmc);
+        mmc = pdata->mmc;
+        //mmc_power_restore_host(mmc);
+        ret = mmc_resume_host(mmc);
         if (ret)
             break;
-	}
-	printk("***Exited %s:%s\n", __FILE__,__func__);
-	return ret;
+    }
+    printk("***Exited %s:%s\n", __FILE__,__func__);
+    return ret;
 }
 
 #else
 
-#define aml_sdio_suspend	NULL
-#define aml_sdio_resume		NULL
+#define aml_sdio_suspend    NULL
+#define aml_sdio_resume        NULL
 
 #endif
 
 static const struct mmc_host_ops aml_sdio_ops = {
-	.request = aml_sdio_request,
-	.set_ios = aml_sdio_set_ios,
-	.get_cd = aml_sdio_get_cd,
-	.get_ro = aml_sdio_get_ro,
+    .request = aml_sdio_request,
+    .set_ios = aml_sdio_set_ios,
+    .get_cd = aml_sdio_get_cd,
+    .get_ro = aml_sdio_get_ro,
 };
 
 static struct amlsd_host* aml_sdio_init_host(void)
 {
-	struct amlsd_host *host;
+    struct amlsd_host *host;
 
-	spin_lock_init(&aml_sdio_claim.lock);
-	init_waitqueue_head(&aml_sdio_claim.wq);
+    spin_lock_init(&aml_sdio_claim.lock);
+    init_waitqueue_head(&aml_sdio_claim.wq);
 
-	host = kzalloc(sizeof(struct amlsd_host), GFP_KERNEL);
+    host = kzalloc(sizeof(struct amlsd_host), GFP_KERNEL);
 
-	if(request_threaded_irq(INT_SDIO, (irq_handler_t)aml_sdio_irq,
-			aml_sdio_irq_thread, IRQF_DISABLED, "sdio", (void*)host)){
+    if(request_threaded_irq(INT_SDIO, (irq_handler_t)aml_sdio_irq,
+            aml_sdio_irq_thread, IRQF_DISABLED, "sdio", (void*)host)){
         sdio_err("Request SDIO Irq Error!\n");
-		return NULL;
-	}
+        return NULL;
+    }
 
-	host->bn_buf = dma_alloc_coherent(NULL, SDIO_BOUNCE_REQ_SIZE,
-							&host->bn_dma_buf, GFP_KERNEL);
-	if(NULL == host->bn_buf){
+    host->bn_buf = dma_alloc_coherent(NULL, SDIO_BOUNCE_REQ_SIZE,
+                            &host->bn_dma_buf, GFP_KERNEL);
+    if(NULL == host->bn_buf){
         sdio_err("Dma alloc Fail!\n");
-		return NULL;
-	}
+        return NULL;
+    }
     //setup_timer(&host->timeout_tlist, aml_sdio_timeout, (ulong)host);
     INIT_DELAYED_WORK(&host->timeout, aml_sdio_timeout);
 
-	spin_lock_init(&host->mrq_lock);
-	host->xfer_step = XFER_INIT;
+    spin_lock_init(&host->mrq_lock);
+    host->xfer_step = XFER_INIT;
 
-	INIT_LIST_HEAD(&host->sibling);
+    INIT_LIST_HEAD(&host->sibling);
     
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
 
 #ifdef      CONFIG_MMC_AML_DEBUG
-	host->req_cnt = 0;
+    host->req_cnt = 0;
     sdio_err("CONFIG_MMC_AML_DEBUG is on!\n");
 #endif
-	return host;
+    return host;
 }
 
 static int aml_sdio_probe(struct platform_device *pdev)
 {
-	struct mmc_host *mmc = NULL;
-	struct amlsd_host *host = NULL;
-	struct amlsd_platform* pdata;
-	int ret = 0, i;
+    struct mmc_host *mmc = NULL;
+    struct amlsd_host *host = NULL;
+    struct amlsd_platform* pdata;
+    int ret = 0, i;
 
     // print_tmp("%s() begin!\n", __FUNCTION__);
 
     aml_mmc_ver_msg_show();
 
-	host = aml_sdio_init_host();
-	if(!host)
-		goto fail_init_host;
+    host = aml_sdio_init_host();
+    if(!host)
+        goto fail_init_host;
 
-	if(amlsd_get_reg_base(pdev, host))
-		goto fail_init_host;
+    if(amlsd_get_reg_base(pdev, host))
+        goto fail_init_host;
     
     //init sdio reg here
     aml_sdio_init_param(host);
 
-	host->pdev = pdev;
-	for(i=0;i<MMC_MAX_DEVICE;i++){
-		/*malloc extra amlsd_platform*/
-		mmc = mmc_alloc_host(sizeof(struct amlsd_platform), &pdev->dev);
-		if (!mmc) {
-			ret = -ENOMEM;
-			goto probe_free_host;
-		}
-
-		pdata = mmc_priv(mmc);
-		memset(pdata, 0, sizeof(struct amlsd_platform));
-		if(amlsd_get_platform_data(pdev, pdata, mmc, i)) {
+    host->pdev = pdev;
+    for(i=0;i<MMC_MAX_DEVICE;i++){
+        /*malloc extra amlsd_platform*/
+        mmc = mmc_alloc_host(sizeof(struct amlsd_platform), &pdev->dev);
+        if (!mmc) {
+            ret = -ENOMEM;
+            goto probe_free_host;
+        }
+
+        pdata = mmc_priv(mmc);
+        memset(pdata, 0, sizeof(struct amlsd_platform));
+        if(amlsd_get_platform_data(pdev, pdata, mmc, i)) {
             mmc_free_host(mmc);
-			break;
+            break;
         }
 
-		// if(pdata->parts){
+        // if(pdata->parts){
         if (pdata->port == PORT_SDIO_C) {
             if (is_emmc_exist(host)) {
                 mmc->is_emmc_port = 1;
@@ -986,60 +984,60 @@ static int aml_sdio_probe(struct platform_device *pdev)
                     break;
                 }
             }
-		}
-		dev_set_name(&mmc->class_dev, "%s", pdata->pinname);
+        }
+        dev_set_name(&mmc->class_dev, "%s", pdata->pinname);
         if (pdata->caps & MMC_CAP_NONREMOVABLE) {
             pdata->is_in = true;
         }
 
-		pdata->host = host;
+        pdata->host = host;
         // host->pdata = pdata; // should not do this here, it will conflict with aml_sdio_request
         // host->mmc = mmc;
-		pdata->mmc = mmc;
-		pdata->is_fir_init = true;
-
-		mmc->index = i;
-		mmc->ops = &aml_sdio_ops;
-		mmc->alldev_claim = &aml_sdio_claim;
-		mmc->ios.clock = 400000;
-		mmc->ios.bus_width = MMC_BUS_WIDTH_1;
-		mmc->max_blk_count = 4095;
-		mmc->max_blk_size = 4095;
-		mmc->max_req_size = pdata->max_req_size;
-		mmc->max_seg_size = mmc->max_req_size;
-		mmc->max_segs = 1024;
-		mmc->ocr_avail = pdata->ocr_avail;
-		mmc->ocr = pdata->ocr_avail;
-		mmc->caps = pdata->caps;
-		mmc->caps2 = pdata->caps2;
-		mmc->f_min = pdata->f_min;
-		mmc->f_max = pdata->f_max;
-
-		if(pdata->port_init)
-			pdata->port_init(pdata);
+        pdata->mmc = mmc;
+        pdata->is_fir_init = true;
+
+        mmc->index = i;
+        mmc->ops = &aml_sdio_ops;
+        mmc->alldev_claim = &aml_sdio_claim;
+        mmc->ios.clock = 400000;
+        mmc->ios.bus_width = MMC_BUS_WIDTH_1;
+        mmc->max_blk_count = 4095;
+        mmc->max_blk_size = 4095;
+        mmc->max_req_size = pdata->max_req_size;
+        mmc->max_seg_size = mmc->max_req_size;
+        mmc->max_segs = 1024;
+        mmc->ocr_avail = pdata->ocr_avail;
+        mmc->ocr = pdata->ocr_avail;
+        mmc->caps = pdata->caps;
+        mmc->caps2 = pdata->caps2;
+        mmc->f_min = pdata->f_min;
+        mmc->f_max = pdata->f_max;
+
+        if(pdata->port_init)
+            pdata->port_init(pdata);
 
         aml_sduart_pre(pdata);
 
-		ret = mmc_add_host(mmc);
-		if (ret) { // error
-			sdhc_err("Failed to add mmc host.\n");
-			goto probe_free_host;
-		} else { // ok
+        ret = mmc_add_host(mmc);
+        if (ret) { // error
+            sdhc_err("Failed to add mmc host.\n");
+            goto probe_free_host;
+        } else { // ok
             if (aml_card_type_sdio(pdata)) { // if sdio_wifi
                 sdio_host = mmc;
                 mmc->rescan_entered = 1; // do NOT run mmc_rescan for the first time
             }
         }
 
-		aml_sdio_init_debugfs(mmc);
-		/*Add each mmc host pdata to this controller host list*/
-		INIT_LIST_HEAD(&pdata->sibling);
+        aml_sdio_init_debugfs(mmc);
+        /*Add each mmc host pdata to this controller host list*/
+        INIT_LIST_HEAD(&pdata->sibling);
         list_add_tail(&pdata->sibling, &host->sibling);
 
-		/*Register card detect irq : plug in & unplug*/
-		if(pdata->irq_in && pdata->irq_out){
-			pdata->irq_init(pdata);
-			ret = request_threaded_irq(pdata->irq_in+INT_GPIO_0,
+        /*Register card detect irq : plug in & unplug*/
+        if(pdata->irq_in && pdata->irq_out){
+            pdata->irq_init(pdata);
+            ret = request_threaded_irq(pdata->irq_in+INT_GPIO_0,
                     (irq_handler_t)aml_sd_irq_cd, aml_irq_cd_thread,
                     IRQF_DISABLED, "mmc_in", (void*)pdata);
             if (ret) {
@@ -1063,46 +1061,46 @@ static int aml_sdio_probe(struct platform_device *pdev)
     return 0;
 
 fail_cd_irq_in:
-	if(pdata->irq_in)
-		free_irq(pdata->irq_in, pdata);
+    if(pdata->irq_in)
+        free_irq(pdata->irq_in, pdata);
 probe_free_host:
-	list_for_each_entry(pdata, &host->sibling, sibling){
-		mmc = pdata->mmc;
-		mmc_remove_host(mmc);
-		mmc_free_host(mmc);
-	}
+    list_for_each_entry(pdata, &host->sibling, sibling){
+        mmc = pdata->mmc;
+        mmc_remove_host(mmc);
+        mmc_free_host(mmc);
+    }
 fail_init_host:
-	iounmap(host->base);
-	free_irq(INT_SDIO, host);
-	dma_free_coherent(NULL, SDIO_BOUNCE_REQ_SIZE, host->bn_buf,
-			(dma_addr_t)host->bn_dma_buf);
-	kfree(host);
+    iounmap(host->base);
+    free_irq(INT_SDIO, host);
+    dma_free_coherent(NULL, SDIO_BOUNCE_REQ_SIZE, host->bn_buf,
+            (dma_addr_t)host->bn_dma_buf);
+    kfree(host);
     print_tmp("aml_sdio_probe() fail!\n");
-	return ret;
+    return ret;
 }
 
 int aml_sdio_remove(struct platform_device *pdev)
 {
-	struct amlsd_host* host = platform_get_drvdata(pdev);
-	struct mmc_host* mmc;
-	struct amlsd_platform* pdata;
+    struct amlsd_host* host = platform_get_drvdata(pdev);
+    struct mmc_host* mmc;
+    struct amlsd_platform* pdata;
 
-	dma_free_coherent(NULL, SDIO_BOUNCE_REQ_SIZE, host->bn_buf,
-			(dma_addr_t )host->bn_dma_buf);
+    dma_free_coherent(NULL, SDIO_BOUNCE_REQ_SIZE, host->bn_buf,
+            (dma_addr_t )host->bn_dma_buf);
 
-	free_irq(INT_SDIO, host);
-	iounmap(host->base);
+    free_irq(INT_SDIO, host);
+    iounmap(host->base);
 
-	list_for_each_entry(pdata, &host->sibling, sibling){
-		mmc = pdata->mmc;
-		mmc_remove_host(mmc);
-		mmc_free_host(mmc);
-	}
+    list_for_each_entry(pdata, &host->sibling, sibling){
+        mmc = pdata->mmc;
+        mmc_remove_host(mmc);
+        mmc_free_host(mmc);
+    }
     
     aml_devm_pinctrl_put(host);
 
     kfree(host);
-	return 0;
+    return 0;
 }
 
 static const struct of_device_id aml_sdio_dt_match[]={
@@ -1115,25 +1113,25 @@ static const struct of_device_id aml_sdio_dt_match[]={
 MODULE_DEVICE_TABLE(of, aml_sdio_dt_match);
 
 static struct platform_driver aml_sdio_driver = {
-	.probe 		= aml_sdio_probe,
-	.remove		= aml_sdio_remove,
-	.suspend	= aml_sdio_suspend,
-	.resume		= aml_sdio_resume,
-	.driver		= {
-		.name = "aml_sdio",
-		.owner = THIS_MODULE,
-		.of_match_table=aml_sdio_dt_match,
-	},
+    .probe         = aml_sdio_probe,
+    .remove        = aml_sdio_remove,
+    .suspend    = aml_sdio_suspend,
+    .resume        = aml_sdio_resume,
+    .driver        = {
+        .name = "aml_sdio",
+        .owner = THIS_MODULE,
+        .of_match_table=aml_sdio_dt_match,
+    },
 };
 
 static int __init aml_sdio_init(void)
 {
-	return platform_driver_register(&aml_sdio_driver);
+    return platform_driver_register(&aml_sdio_driver);
 }
 
 static void __exit aml_sdio_cleanup(void)
 {
-	platform_driver_unregister(&aml_sdio_driver);
+    platform_driver_unregister(&aml_sdio_driver);
 }
 
 module_init(aml_sdio_init);
diff --git a/drivers/amlogic/mmc/amlsd.c b/drivers/amlogic/mmc/amlsd.c
index 7acb3935c84d..cc2c4fc9d245 100755
--- a/drivers/amlogic/mmc/amlsd.c
+++ b/drivers/amlogic/mmc/amlsd.c
@@ -50,6 +50,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/of_gpio.h>
+#include <linux/amlogic/aml_pmu_common.h>
 #include <linux/amlogic/wifi_dt.h>
 #include "amlsd.h"
 
@@ -63,7 +64,13 @@ static struct mtd_partition *card_table[16];
 
 void aml_mmc_ver_msg_show (void)
 {
-    printk("mmc driver version: %d.%02d, %s\n", AML_MMC_MAJOR_VERSION, AML_MMC_MINOR_VERSION, AML_MMC_VER_MESSAGE);
+    static bool one_time_flag = false;
+
+    if (!one_time_flag) {
+        printk("mmc driver version: %d.%02d, %s\n", AML_MMC_MAJOR_VERSION, AML_MMC_MINOR_VERSION, AML_MMC_VER_MESSAGE);
+
+        one_time_flag = true;
+    }
 }
 
 static inline int card_proc_info (struct seq_file *m, char* dev_name, int i)
@@ -413,24 +420,31 @@ bool is_emmc_exist (struct amlsd_host* host) // is eMMC/tSD exist
 
 /*----sdhc----*/
 
+void aml_sdhc_print_reg_(u32 *buf)
+{
+    printk("***********SDHC_REGS***********\n");
+    printk("SDHC_ARGU: 0x%08x\n", buf[SDHC_ARGU/4]);
+    printk("SDHC_SEND: 0x%08x\n", buf[SDHC_SEND/4]);
+    printk("SDHC_CTRL: 0x%08x\n", buf[SDHC_CTRL/4]);
+    printk("SDHC_STAT: 0x%08x\n", buf[SDHC_STAT/4]);
+    printk("SDHC_CLKC: 0x%08x\n", buf[SDHC_CLKC/4]);
+    printk("SDHC_ADDR: 0x%08x\n", buf[SDHC_ADDR/4]);
+    printk("SDHC_PDMA: 0x%08x\n", buf[SDHC_PDMA/4]);
+    printk("SDHC_MISC: 0x%08x\n", buf[SDHC_MISC/4]);
+    printk("SDHC_DATA: 0x%08x\n", buf[SDHC_DATA/4]);
+    printk("SDHC_ICTL: 0x%08x\n", buf[SDHC_ICTL/4]);
+    printk("SDHC_ISTA: 0x%08x\n", buf[SDHC_ISTA/4]);
+    printk("SDHC_SRST: 0x%08x\n", buf[SDHC_SRST/4]);
+    printk("SDHC_ESTA: 0x%08x\n", buf[SDHC_ESTA/4]);
+    printk("SDHC_ENHC: 0x%08x\n", buf[SDHC_ENHC/4]);
+    printk("SDHC_CLK2: 0x%08x\n", buf[SDHC_CLK2/4]);
+}
+
 void aml_sdhc_print_reg(struct amlsd_host* host)
 {
     u32 buf[16];
-    memcpy_fromio(buf, host->base, 0x30);
-
-    printk(KERN_DEBUG "***********SDHC_REGS***********\n");
-    printk(KERN_DEBUG "SDHC_ARGU: 0x%x\n", buf[SDHC_ARGU/4]);
-    printk(KERN_DEBUG "SDHC_SEND: 0x%x\n", buf[SDHC_SEND/4]);
-    printk(KERN_DEBUG "SDHC_CTRL: 0x%x\n", buf[SDHC_CTRL/4]);
-    printk(KERN_DEBUG "SDHC_STAT: 0x%x\n", buf[SDHC_STAT/4]);
-    printk(KERN_DEBUG "SDHC_CLKC: 0x%x\n", buf[SDHC_CLKC/4]);
-    printk(KERN_DEBUG "SDHC_ADDR: 0x%x\n", buf[SDHC_ADDR/4]);
-    printk(KERN_DEBUG "SDHC_PDMA: 0x%x\n", buf[SDHC_PDMA/4]);
-    printk(KERN_DEBUG "SDHC_MISC: 0x%x\n", buf[SDHC_MISC/4]);
-    printk(KERN_DEBUG "SDHC_DATA: 0x%x\n", buf[SDHC_DATA/4]);
-    printk(KERN_DEBUG "SDHC_ICTL: 0x%x\n", buf[SDHC_ICTL/4]);
-    printk(KERN_DEBUG "SDHC_ISTA: 0x%x\n", buf[SDHC_ISTA/4]);
-    printk(KERN_DEBUG "SDHC_SRST: 0x%x\n", buf[SDHC_SRST/4]);
+    memcpy_fromio(buf, host->base, 0x3C);
+    aml_sdhc_print_reg_(buf);
 }
 
 static int aml_sdhc_regs_show(struct seq_file *s, void *v)
@@ -535,7 +549,7 @@ static int amlsd_param_show(struct seq_file *s, void *v)
 	seq_printf(s, "f_min : %d\n", pdata->f_min);
 	seq_printf(s, "port : %d\n", pdata->port);
 	seq_printf(s, "caps : 0x%x\n", pdata->caps);
-	seq_printf(s, "ocr_avail : 0x%lx\n", pdata->ocr_avail);
+	seq_printf(s, "ocr_avail : 0x%x\n", pdata->ocr_avail);
 	seq_printf(s, "max_req_size : %d\n", pdata->max_req_size);
 	return 0;
 }
@@ -741,12 +755,14 @@ static struct pinctrl * __must_check aml_devm_pinctrl_get_select (
 	
 	s = pinctrl_lookup_state(p, name);
 	if (IS_ERR(s)) {
+        sdio_err("lookup %s fail\n", name);
 		devm_pinctrl_put(p);
 		return ERR_CAST(s);
 	}
 	
 	ret = pinctrl_select_state(p, s);
 	if (ret < 0) {
+        sdio_err("select %s fail\n", name);
 		devm_pinctrl_put(p);
 		return ERR_PTR(ret);
 	}
@@ -765,20 +781,19 @@ void of_amlsd_xfer_pre(struct amlsd_platform* pdata)
         udelay(65);
     }
 
+    size = sizeof(pinctrl);
     if (pdata->port > PORT_SDIO_C) { // so it should be PORT_SDHC_X
-        strncpy(p, "sdhc_", sizeof(pinctrl));
-        size = strlen(p);
-        p += size;
+        aml_snprint(&p, &size, "sdhc_");
     }
 
     if (pdata->mmc->ios.chip_select == MMC_CS_DONTCARE) {
-        if ((pdata->mmc->caps & MMC_CAP_4_BIT_DATA) || (pdata->port != MESON_SDIO_PORT_B)) {
-            snprintf(p, sizeof(pinctrl)-size, "%s_all_pins", pdata->pinname);
+        if ((pdata->mmc->caps & MMC_CAP_4_BIT_DATA) || (pdata->port != MESON_SDIO_PORT_B) || (pdata->mmc->caps & MMC_CAP_8_BIT_DATA)) {
+            aml_snprint(&p, &size, "%s_all_pins", pdata->pinname);
         }else{
-            snprintf(p, sizeof(pinctrl)-size, "%s_1bit_pins", pdata->pinname);
+            aml_snprint(&p, &size, "%s_1bit_pins", pdata->pinname);
         }
     } else { // MMC_CS_HIGH
-        snprintf(p, sizeof(pinctrl)-size, "%s_clk_cmd_pins", pdata->pinname);
+        aml_snprint(&p, &size, "%s_clk_cmd_pins", pdata->pinname);
     }
     
     // if pinmux setting is changed (pinctrl_name is different)
@@ -1042,7 +1057,7 @@ void aml_sd_uart_detect (struct amlsd_platform* pdata)
     static bool is_jtag = false;
 
     if (aml_is_card_insert(pdata)){
-        if(aml_is_sduart(pdata)){
+        if (aml_is_sduart(pdata) && (!mmc_host_uhs(pdata->mmc))) {
             if (!pdata->is_sduart) { // status change
                 printk("\033[0;40;33m Uart in\033[0m\n");
                 aml_uart_switch(pdata, 1);
@@ -1087,6 +1102,7 @@ void aml_sd_uart_detect (struct amlsd_platform* pdata)
         pdata->is_in = false;
         aml_uart_switch(pdata, 0);
         aml_jtag_gpioao();
+        aml_sd_voltage_switch(pdata, MMC_SIGNAL_VOLTAGE_330); // switch to 3.3V
         if(pdata->caps & MMC_CAP_4_BIT_DATA)
             pdata->mmc->caps |= MMC_CAP_4_BIT_DATA;
     }
@@ -1146,10 +1162,13 @@ void aml_sduart_pre (struct amlsd_platform* pdata)
 
 static int aml_cmd_invalid (struct mmc_host* mmc, struct mmc_request* mrq)
 {
-    // struct amlsd_platform * pdata = mmc_priv(mmc);
+    struct amlsd_platform * pdata = mmc_priv(mmc);
+    unsigned long flags;
 
+    spin_lock_irqsave(&pdata->host->mrq_lock, flags);
     // sdio_err("%s: filter cmd%d, card_type=%d\n", mmc_hostname(mmc), mrq->cmd->opcode, pdata->card_type);
     mrq->cmd->error = -EINVAL;
+    spin_unlock_irqrestore(&pdata->host->mrq_lock, flags);
     mmc_request_done(mmc, mrq);
 
     return -EINVAL;
@@ -1209,6 +1228,61 @@ int aml_check_unsupport_cmd(struct mmc_host* mmc, struct mmc_request* mrq)
     return 0;
 }
 
+int aml_sd_voltage_switch (struct amlsd_platform* pdata, char signal_voltage)
+{
+#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU 
+    int vol = LDO4DAC_REG_3_3_V;
+    int delay_ms = 0;
+    char *str;
+    struct aml_pmu_driver *pmu_driver; 
+
+    if ((pdata->port != PORT_SDHC_B) // only SDHC_B support voltage switch
+            || (pdata->signal_voltage == signal_voltage)) {
+        // print_dbg("signal_voltage=%d, direct return\n", signal_voltage);
+        return 0; // voltage is the same, return directly
+    }
+
+    pmu_driver = aml_pmu_get_driver(); 
+    if (pmu_driver == NULL) { 
+        sdhc_err("no pmu driver\n"); 
+        return -EINVAL;
+    } 
+    else if (pmu_driver->pmu_reg_write) { 
+        switch (signal_voltage) {
+            case MMC_SIGNAL_VOLTAGE_180:
+                vol = LDO4DAC_REG_1_8_V;
+                delay_ms = 20;
+                str = "1.80 V";
+
+                if (!mmc_host_uhs(pdata->mmc)) {
+                    sdhc_err("switch to 1.8V for a non-uhs device.\n"); 
+                }
+
+                break;
+            case MMC_SIGNAL_VOLTAGE_330:
+                vol = LDO4DAC_REG_3_3_V;
+                delay_ms = 20;
+                str = "3.30 V";
+                break;
+                // case MMC_SIGNAL_VOLTAGE_120: // we don't support 1.2V now
+                // str = "1.20 V";
+                // break;
+            default:
+                str = "invalid";
+                break;
+        }
+ 
+        pmu_driver->pmu_reg_write(LDO4DAC_REG_ADDR, vol); // set voltage
+        pdata->signal_voltage = signal_voltage;
+        mdelay(delay_ms); // wait for voltage to be stable
+        sdhc_dbg(AMLSD_DBG_COMMON, "voltage: %s\n", str);
+        // sdhc_err("delay %dms.\n", delay_ms); 
+    }
+#endif 
+
+    return 0;
+}
+
 /*-------------------debug---------------------*/
 
 unsigned int sdhc_debug=0x0; // 0xffffffff;
@@ -1241,6 +1315,25 @@ void aml_dbg_print_pinmux (void)
             READ_CBUS_REG(PERIPHS_PIN_MUX_8));
 }
 
+void aml_snprint (char **pp, int *left_size,  const char *fmt, ...)
+{
+    va_list args;
+    char *p = *pp;
+    int size;
+
+    if (*left_size <= 1) {
+        sdhc_err("buf is full\n");
+        return;
+    }
+
+    va_start(args, fmt);
+    size = vsnprintf(p, *left_size, fmt, args);
+    va_end(args);
+    *pp += size;
+    *left_size -= size;
+}
+
+
 #ifdef      CONFIG_MMC_AML_DEBUG
 
 #define     CARD_PULL_UP_REG            PAD_PULL_UP_REG2
diff --git a/drivers/amlogic/mmc/amlsd.h b/drivers/amlogic/mmc/amlsd.h
index 102cc24f2f51..4ea60a961845 100755
--- a/drivers/amlogic/mmc/amlsd.h
+++ b/drivers/amlogic/mmc/amlsd.h
@@ -5,9 +5,9 @@
 
 
 #define AML_MMC_MAJOR_VERSION   1
-#define AML_MMC_MINOR_VERSION   03
+#define AML_MMC_MINOR_VERSION   05
 #define AML_MMC_VERSION         ((AML_MMC_MAJOR_VERSION << 8) | AML_MMC_MINOR_VERSION)
-#define AML_MMC_VER_MESSAGE     "2013-12-20: defer init&resume of sdio-wifi"
+#define AML_MMC_VER_MESSAGE     "2014-01-16: sdhc eMMC run at 8bit@50MHz ok"
 
 extern unsigned sdhc_debug;
 extern unsigned sdio_debug;
@@ -16,17 +16,23 @@ extern unsigned sdio_debug;
 
 #define MODULE_NAME		"amlsd"
 
-#define AMLSD_DBG_REQ		(1<<0)
-#define AMLSD_DBG_RESP		(1<<1)
-#define AMLSD_DBG_REG		(1<<2)
-#define AMLSD_DBG_RD_TIME	(1<<3)
-#define AMLSD_DBG_WR_TIME	(1<<4)
-#define AMLSD_DBG_BUSY_TIME	(1<<5)
-#define AMLSD_DBG_RD_DATA	(1<<6)
-#define AMLSD_DBG_WR_DATA	(1<<7)
-#define AMLSD_DBG_IOS		(1<<8)
-#define AMLSD_DBG_IRQ		(1<<9)
-#define AMLSD_DBG_CLKC		(1<<10)
+#define LDO4DAC_REG_ADDR        0x4f
+#define LDO4DAC_REG_1_8_V       0x24
+#define LDO4DAC_REG_2_8_V       0x4c
+#define LDO4DAC_REG_3_3_V       0x60
+
+#define AMLSD_DBG_COMMON	(1<<0)
+#define AMLSD_DBG_REQ		(1<<1)
+#define AMLSD_DBG_RESP		(1<<2)
+#define AMLSD_DBG_REG		(1<<3)
+#define AMLSD_DBG_RD_TIME	(1<<4)
+#define AMLSD_DBG_WR_TIME	(1<<5)
+#define AMLSD_DBG_BUSY_TIME	(1<<6)
+#define AMLSD_DBG_RD_DATA	(1<<7)
+#define AMLSD_DBG_WR_DATA	(1<<8)
+#define AMLSD_DBG_IOS		(1<<9)
+#define AMLSD_DBG_IRQ		(1<<10)
+#define AMLSD_DBG_CLKC		(1<<11)
 
 #define     DETECT_CARD_IN          1
 #define     DETECT_CARD_OUT         2
@@ -48,7 +54,7 @@ void aml_sd_uart_detect_clr (struct amlsd_platform* pdata);
 }while(0)
 
 #define sdhc_err(fmt, args...) do{\
-	printk("[%s]\033[0;40;32m" fmt "\033[0m", __FUNCTION__, ##args);  \
+	printk("[%s]\033[0;40;32m " fmt "\033[0m", __FUNCTION__, ##args);  \
 }while(0)
 
 #define sdio_dbg(dbg_level, fmt, args...) do{\
@@ -57,7 +63,7 @@ void aml_sd_uart_detect_clr (struct amlsd_platform* pdata);
 }while(0)
 
 #define sdio_err(fmt, args...) do{\
-	printk("[%s]\033[0;40;33m" fmt "\033[0m", __FUNCTION__, ##args);	\
+	printk("[%s]\033[0;40;33m " fmt "\033[0m", __FUNCTION__, ##args);	\
 }while(0)
 
 #define SD_PARSE_U32_PROP(node, prop_name, prop, value)      		\
@@ -99,6 +105,7 @@ extern int storage_flag;
 
 void aml_mmc_ver_msg_show (void);
 extern void aml_sdhc_init_debugfs(struct mmc_host *mmc);
+void aml_sdhc_print_reg_(u32 *buf);
 extern void aml_sdhc_print_reg(struct amlsd_host* host);
 extern void aml_sdio_init_debugfs(struct mmc_host *mmc);
 extern void aml_sdio_print_reg(struct amlsd_host* host);
@@ -130,6 +137,7 @@ void aml_sd_uart_detect (struct amlsd_platform* pdata);
 irqreturn_t aml_sd_irq_cd(int irq, void *dev_id);
 irqreturn_t aml_irq_cd_thread(int irq, void *data);
 void aml_sduart_pre (struct amlsd_platform* pdata);
+int aml_sd_voltage_switch (struct amlsd_platform* pdata, char signal_voltage);
 int aml_check_unsupport_cmd(struct mmc_host* mmc, struct mmc_request* mrq);
 
 void aml_cs_high (struct amlsd_platform * pdata); // chip select high
@@ -138,6 +146,8 @@ bool is_emmc_exist (struct amlsd_host* host); // is eMMC/tSD exist
 void aml_devm_pinctrl_put (struct amlsd_host* host);
 // void of_init_pins (struct amlsd_platform* pdata);
 
+void aml_snprint (char **pp, int *left_size,  const char *fmt, ...);
+
 void aml_dbg_print_pinmux (void);
 #ifdef      CONFIG_MMC_AML_DEBUG
 void aml_dbg_verify_pull_up (struct amlsd_platform * pdata);
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
old mode 100644
new mode 100755
index 1a5adc90c565..13c95c7ad25a
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1770,11 +1770,17 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
 				goto cmd_abort;
 			}
 
-			if (reqs >= packed_nr)
+			if (reqs >= packed_nr) {
 				mmc_blk_packed_hdr_wrq_prep(mq->mqrq_cur,
 							    card, mq);
-			else
-				mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+            }
+			else {
+#ifdef CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW
+				mmc_blk_rw_rq_prep(mq->mqrq_cur, card, true, mq); // --debug: force single block
+#else 
+                mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+#endif
+            }
 			areq = &mq->mqrq_cur->mmc_active;
 		} else
 			areq = NULL;
@@ -1883,8 +1889,13 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
 				 * In case of a incomplete request
 				 * prepare it again and resend.
 				 */
+#ifdef CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW
+				mmc_blk_rw_rq_prep(mq_rq, card,
+						true, mq); // --debug: force single block
+#else
 				mmc_blk_rw_rq_prep(mq_rq, card,
-						disable_multi, mq);
+                        disable_multi, mq);
+#endif
 				mmc_start_req(card->host,
 						&mq_rq->mmc_active, NULL);
 			}
@@ -1916,7 +1927,11 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
 			if (mmc_packed_cmd(mq->mqrq_cur->cmd_type))
 				mmc_blk_revert_packed_req(mq, mq->mqrq_cur);
 
-			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+#ifdef CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW
+			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, true, mq); // --debug: force single block
+#else
+            mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+#endif
 			mmc_start_req(card->host,
 				      &mq->mqrq_cur->mmc_active, NULL);
 		}
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
old mode 100644
new mode 100755
index f0a7c92725d3..a5d382980cd2
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -767,9 +767,11 @@ try_again:
 	   ((*rocr & 0x41000000) == 0x41000000)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 		if (err == -EAGAIN) {
+		    printk("1) switch to 1.8V fail, ret=%d\n", err);
 			retries--;
 			goto try_again;
 		} else if (err) {
+            printk("2) switch to 1.8V fail, ret=%d\n", err);
 			retries = 0;
 			goto try_again;
 		}
-- 
2.19.0

