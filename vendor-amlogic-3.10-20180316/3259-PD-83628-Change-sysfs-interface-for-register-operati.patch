From ef8029c6cf0e9b8bcc8357ce430055a1d1f8d371 Mon Sep 17 00:00:00 2001
From: "tao.zeng" <tao.zeng@amlogic.com>
Date: Wed, 12 Feb 2014 10:25:58 +0800
Subject: [PATCH 3259/5965] PD #83628: Change sysfs interface for register
 operation of AML1216

---
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd | 2284 ++++++++++++++++++
 arch/arm/configs/meson8_defconfig            |    2 +
 drivers/amlogic/power/aml_pmu/Kconfig        |    8 +
 drivers/amlogic/power/aml_pmu/Makefile       |    1 +
 drivers/amlogic/power/aml_pmu/aml1216-rw.c   |  339 +++
 drivers/amlogic/power/aml_pmu/aml1216-sply.c | 1572 ++++++++++++
 drivers/amlogic/power/aml_pmu/aml_pmu.c      |  119 +-
 include/linux/amlogic/aml_pmu.h              |  183 +-
 8 files changed, 4480 insertions(+), 28 deletions(-)
 create mode 100755 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
 create mode 100755 drivers/amlogic/power/aml_pmu/aml1216-rw.c
 create mode 100755 drivers/amlogic/power/aml_pmu/aml1216-sply.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
new file mode 100755
index 000000000000..87ab91bf1374
--- /dev/null
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -0,0 +1,2284 @@
+/dts-v1/;
+/// ***************************************************************************************\n
+//$$ PROJECT="meson8"
+//$$ REMOVE 1
+void root_func(){
+//$$ ADD /{
+	compatible = "AMLOGIC,8726_M8";
+	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	
+/// ***************************************************************************************
+///	-	CPU
+//$$ MODULE="CPU"
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+//$$ DEVICE="cpu0"
+        cpu@0 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x200>;
+        };
+//$$ DEVICE="cpu1"
+        cpu@1 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x1>;
+        };
+//$$ DEVICE="cpu2"
+        cpu@2 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x2>;
+        };
+//$$ DEVICE="cpu3"
+        cpu@3 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x3>;
+        };
+    };
+
+/// ***************************************************************************************
+///	-	Cache
+//$$ MODULE="Cache"
+//$$ DEVICE="cache"
+    cache-controller {
+          compatible = "arm,meson-pl310-cache";
+          reg = <0xc4200000 0x1000>;
+          arm,data-latency = <3 3 3>;
+          arm,tag-latency = <2 2 2>;
+          cache-unified;
+          cache-level = <2>;
+          aux-instruction_prefetch;
+          aux-data_prefetch;
+          aux-ns_lockdown;
+          aux-force_no_write_alloc;
+          aux-cache_replace_policy_round_robin;
+          aux-early_write_response;
+          aux-full_line_of_zero;
+          aux-ns_int_ctrl;
+          aux-share_override;
+          prefetch-double_line_fill;
+          prefetch-prefetch_drop;
+          prefetch-prefetch_offset = <7>;
+    };
+
+/// ***************************************************************************************
+///	-	Memory
+//$$ MODULE="Memory"
+//$$ DEVICE="memory"
+//$$ L2 PROP_U32 = "aml_reserved_start"
+//$$ L2 PROP_U32 = "aml_reserved_end"
+//$$ L2 PROP_U32 6 = "linux,usable-memory"
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x06000000>; /**reserved memory start */
+		aml_reserved_end = <0x05000000>;/**reserved memory end */
+		phys_offset = <0x00000000>;
+		linux,total-memory = <0x40000000>;
+	};
+/// ***************************************************************************************
+///	-	GIC
+//$$ MODULE="GIC"
+//$$ DEVICE="gic"	
+	gic:interrupt-controller{
+        compatible = "arm,cortex-a9-gic";
+        reg = <0xc4301000 0x1000
+               0xc4300100 0x0100>;
+        interrupt-controller;
+        #interrupt-cells = <3>;
+        #address-cells = <0>;
+    };
+    
+/// ***************************************************************************************
+///	-	VPU
+//$$ MODULE="VPU"
+//$$ DEVICE="vpu"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "clk_level"
+    vpu{
+		compatible = "amlogic,vpu";
+		dev_name = "vpu";	
+		status = "ok";
+		clk_level = <4>;
+		/**    	0: 106.25M		1: 127.5M		2: 159.375M
+				3: 182.15M		4: 212.5M		5: 255M
+		    	6: 318.75M		7: 364.3M					 */
+	};
+	
+/// **************************************************************************************	
+/// -   DISP&MM-FB
+//$$ MODULE = "DISP&MM-FB"	
+//$$ DEVICE = "mesonfb"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+//$$ L2 PROP_U32 = "rotation"
+//$$ L2 PROP_U32 = "vmode"
+//$$ L2 PROP_U32 5 = "display_size_default"
+	mesonfb{
+		compatible = "amlogic,mesonfb";
+		dev_name = "mesonfb";
+		status = "okay";
+        reserve-memory = <0x01000000  0x00100000>;
+	   	reserve-iomap = "true";
+        vmode = <1>; /**0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P 3:VMODE_1080P*/
+        display_size_default = <768 1024 768 3072 32>;//1024x768x4x3==0x0900000 < 0x01000000
+	};
+//$$ DEVICE = "mesonfb-ext"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+//$$ L2 PROP_U32 5 = "display_size_default"
+	mesonfb-ext{
+		compatible = "amlogic,mesonfb-ext";
+		dev_name = "mesonfb-ext";
+		status = "ok";
+	   	reserve-memory = <0x01000000  0x00100000>;
+	   	reserve-iomap = "true";
+        display_size_default = <768 1024 768 3072 32>;//1024x768x4x3==0x0900000 < 0x01000000
+	 
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-A/V stream
+//$$ MODULE = "DISP&MM-A/V stream"
+//$$ DEVICE="mesonstream"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+	mesonstream{
+		compatible = "amlogic,mesonstream";
+		dev_name = "mesonstream.0";
+		status = "okay";
+		reserve-memory = <0x00a00000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///     -       DISP&MM-A/V stream
+//$$ MODULE = "DISP&MM-A/V video dec"
+//$$ DEVICE="vdec"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+        vdec{
+                compatible = "amlogic,vdec";
+                dev_name = "vdec.0";
+                status = "okay";
+                reserve-memory = <0x04000000>;
+		reserve-iomap = "true";
+        };
+
+        
+/// ***************************************************************************************
+///	-	DISP&MM-PostProcess
+//$$ MODULE="DISP&MM-PostProcess"
+//$$ DEVICE="ppmgr"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    ppmgr{
+		compatible = "amlogic,ppmgr";
+		dev_name = "ppmgr";
+		status = "okay";
+		reserve-memory = <0x01000000>;
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-AVC Video Encoder
+//$$ MODULE = "DISP&MM-AVC Video Encoder"
+//$$ DEVICE="amvenc_avc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    amvenc_avc{
+		compatible = "amlogic,amvenc_avc";
+		dev_name = "amvenc_avc.0";
+		status = "okay";
+		reserve-memory = <0x00f00000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-VDIN
+//$$ MODULE = "DISP&MM-VDIN"
+//$$ DEVICE="vdin0"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//$$ L2 PROP_U32 = "irq"
+//$$ L2 PROP_U32 = "vdin_id"
+    vdin0{
+        compatible = "amlogic,vdin";
+        dev_name = "vdin0";
+        status = "ok";
+	reserve-memory = <0x02700000>;
+	camera_size = <2592 1944>;//2592x1944x2x4=41M
+	 reserve-iomap = "true";
+        irq = <115>;
+        vdin_id = <0>;
+	};
+	
+//$$ DEVICE="vdin1"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//$$ L2 PROP_U32 = "irq"
+//$$ L2 PROP_U32 = "vdin_id"
+    vdin1{
+        compatible = "amlogic,vdin";
+        dev_name = "vdin1";
+        status = "ok";
+        reserve-memory = <0x01000000>;
+	miracast_size = <1920 1080>;//1920x1080x2x4=17M
+	reserve-iomap = "true";
+        irq = <117>;
+        vdin_id = <1>;
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-AMLVIDEO2
+//$$ MODULE = "DISP&MM-AMLVIDEO2"
+//$$ DEVICE="amlvideo2"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    amlvideo2{
+		compatible = "amlogic,amlvideo2";
+		dev_name = "amlvideo2.0";
+		status = "okay";
+		reserve-memory = <0x01800000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-Video Input Manager
+//$$ MODULE = "DISP&MM-Video Input Manager"
+//$$ DEVICE="vm"
+//$$ L2 PROP_STR = "status"
+    vm{
+		compatible = "amlogic,vm";
+		dev_name = "vm.0";
+		status = "okay";
+		reserve-memory = <0x01800000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///	-	ION
+//$$ MODULE="ION"
+//$$ DEVICE="ion_dev"
+//$$ L2 PROP_STR = "status"
+    ion_dev{
+        compatible = "amlogic,ion_dev";
+        dev_name = "ion_dev";
+        status = "ok";
+        share-memory-name = "ppmgr0";
+        share-memory-offset = <0>;
+        share-memory-size = <0x01000000>;
+    };
+/// ***************************************************************************************
+///	-	DISP&MM-Vout
+//$$ MODULE = "DISP&MM-Vout"
+//$$ DEVICE = "mesonvout"
+//$$ L2 PROP_STR = "status"
+	mesonvout{
+		compatible = "amlogic,mesonvout";
+		dev_name = "mesonvout";
+		status = "okay";
+	};
+//$$ DEVICE = "mesonvout2"
+//$$ L2 PROP_STR = "status"
+	mesonvout2{
+		compatible = "amlogic,mesonvout2";
+		dev_name = "mesonvout2";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	RTC
+//$$ MODULE="RTC"
+//$$ DEVICE="Rtc"
+//$$ L2 PROP_STR = "status"
+    rtc{
+		compatible = "amlogic,aml_rtc";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	UART
+//$$ MODULE="UART"
+//$$ DEVICE="uart_ao"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L3 PROP_CHOICE "uart_ao_pin_match" = "pinctrl-0"
+	uart_ao{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_ao";
+		status = "okay";
+		dev_name = "uart_ao";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ao_uart_pins>;
+	};
+	
+//$$ DEVICE="uart_0"
+//$$ L2 PROP_STR = "status"
+	uart_0{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_a";
+		status = "okay";
+		dev_name = "uart_0";
+	};
+	
+//$$ DEVICE="uart_1"
+//$$ L2 PROP_STR = "status"
+	uart_1{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_b";
+		status = "disabled";
+		dev_name = "uart_1";
+	};
+	
+//$$ DEVICE="uart_2"
+//$$ L2 PROP_STR = "status"
+	uart_2{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_c";
+		status = "disabled";
+		dev_name = "uart_2";
+	};
+	
+//$$ DEVICE="uart_3"
+//$$ L2 PROP_STR = "status"	
+	uart_3{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_d";
+		status = "ok";
+		dev_name = "uart_3";
+	};
+
+
+/// ***************************************************************************************
+///	-	MMC
+//$$ MODULE="MMC"
+//$$ DEVICE="aml_sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 7 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "sdio_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "sdio_pin_1_match" = "pinctrl-1"
+//$$ L2 PROP_CHOICE "sdio_pin_2_match" = "pinctrl-2"
+//$$ L2 PROP_CHOICE "sdio_pin_3_match" = "pinctrl-3"
+//$$ L2 PROP_CHOICE "sdio_pin_4_match" = "pinctrl-4"
+//$$ L2 PROP_CHOICE "sdio_pin_5_match" = "pinctrl-5"
+//$$ L2 PROP_CHOICE "sdio_pin_6_match" = "pinctrl-6"
+sdio{
+        compatible = "amlogic,aml_sdio";
+        dev_name = "aml_sdio.0";
+        status = "okay";
+        reg = <0xc1108c20 0x20>;
+        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins","sd_1bit_pins"; // "jtag_pin", "uartao_default";
+        pinctrl-0 = <&sd_clk_cmd_pins>;
+        pinctrl-1 = <&sd_all_pins>;
+        pinctrl-2 = <&emmc_clk_cmd_pins>;
+        pinctrl-3 = <&emmc_all_pins>;
+        pinctrl-4 = <&sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdio_all_pins>;
+        pinctrl-6 = <&sd_1bit_pins>;
+
+//$$ DEVICE="sd"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 3 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_STR = "jtag_pin"
+//$$ L2 PROP_STR = "gpio_cd"
+//$$ L2 PROP_U32 = "irq_in"
+//$$ L2 PROP_U32 = "irq_out"
+//$$ L2 PROP_U32 = "card_type"
+        sd{
+            status = "okay";
+            port = <1>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            f_min = <300000>;
+            f_max = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "CARD_4";
+            jtag_pin = "CARD_0";
+            gpio_cd = "CARD_6";
+            irq_in = <3>;
+            irq_out = <5>;
+            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+//$$ DEVICE="emmc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"       	
+//$$ L2 PROP_U32 = "card_type"
+        emmc{
+            status = "ok";
+            port = <2>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "BOOT_3";
+            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+    };
+
+/// ***************************************************************************************
+///	-	I2C
+//$$ MODULE="I2C"
+//$$ DEVICE="I2C_AO"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_AO_pin_match" = "pinctrl-0"	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		status = "ok";
+		reg = <0xc8100500 0x1d>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+
+//$$ DEVICE = "I2C_A"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_A_pin_match" = "pinctrl-0"
+    i2c@c1108500{ /*I2C-A*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-A";
+		status = "ok";
+		reg = <0xc1108500 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+		pinctrl-0=<&a_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	
+//$$ DEVICE="I2C_B"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_B_pin_match" = "pinctrl-0"	
+	i2c@c11087c0{ /*I2C-B*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-B";
+		status = "ok";
+		reg = <0xc11087c0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&b_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+ 	};
+
+//$$ DEVICE="I2C_C"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+    i2c@c11087e0{ /*I2C-C*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-C";
+		status = "ok";
+		reg = <0xc11087e0 0x20>;
+		device_id = <3>;
+		pinctrl-names="default";
+//		pinctrl-0=<&c_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+//$$ DEVICE="I2C_D"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_D_pin_match" = "pinctrl-0"	
+	i2c@c1108d20{ /*I2C-D*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-D";
+		status = "ok";
+		reg = <0xc1108d20 0x20>;
+		device_id = <4>;
+		pinctrl-names="default";
+		pinctrl-0=<&d_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+/// ***************************************************************************************
+///	-	Power
+//$$ MODULE="Power"
+//$$ DEVICE="dvfs"
+//$$ L2 PROP_STR = "status"
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+//$$ L2 PROP_U32 = "dvfs_id"
+//$$ L2 PROP_U32 = "table_count"
+//$$ L2 PROP_U32 16*3 = "dvfs_table"
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <14>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+            /* NOTE: frequent in this table must be ascending order */
+            /* frequent(Khz)    min_uV      max_uV                  */
+                  96000         825000      825000
+                 192000         825000      825000
+                 312000         825000      825000
+                 408000         825000      825000
+                 504000         825000      825000
+                 600000         850000      850000
+                 720000         850000      850000
+                 816000         875000      875000
+                1008000         925000      925000
+                1200000         975000      975000
+                1416000        1025000     1025000
+                1608000        1100000     1100000
+                1800000        1125000     1125000
+                1992000        1150000     1150000
+            >;
+        };
+    };
+
+//$$ DEVICE="arm_pmu"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 4*3 = "interrupts"
+    arm_pmu {
+        compatible = "arm,cortex-a9-pmu";
+        status = "ok";
+        interrupts = <0     137     0x04
+                      0     138     0x04
+                      0     153     0x04
+                      0     154     0x04>;
+    };
+
+//$$ DEVICE="Battery_parameter"
+//$$ MATCH "battery_parameter_match" = <&battery_parameter>
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "pmu_twi_id"
+//$$ L2 PROP_U32 = "pmu_irq_id"
+//$$ L2 PROP_U32 = "pmu_twi_addr"
+//$$ L2 PROP_U32 = "pmu_battery_rdc"
+//$$ L2 PROP_U32 = "pmu_battery_cap"
+//$$ L2 PROP_U32 = "pmu_battery_technology"
+//$$ L2 PROP_STR = "pmu_battery_name"
+//$$ L2 PROP_U32 = "pmu_init_chgvol"
+//$$ L2 PROP_U32 = "pmu_init_chgend_rate"
+//$$ L2 PROP_U32 = "pmu_init_chg_enabled"
+//$$ L2 PROP_U32 = "pmu_init_adc_freq"
+//$$ L2 PROP_U32 = "pmu_init_adc_freqc"
+//$$ L2 PROP_U32 = "pmu_init_chg_pretime"
+//$$ L2 PROP_U32 = "pmu_init_chg_csttime"
+//$$ L2 PROP_U32 = "pmu_init_chgcur"
+//$$ L2 PROP_U32 = "pmu_suspend_chgcur"
+//$$ L2 PROP_U32 = "pmu_resume_chgcur"
+//$$ L2 PROP_U32 = "pmu_shutdown_chgcur"
+//$$ L2 PROP_U32 = "pmu_usbcur_limit"
+//$$ L2 PROP_U32 = "pmu_usbcur"
+//$$ L2 PROP_U32 = "pmu_usbvol_limit"
+//$$ L2 PROP_U32 = "pmu_usbvol"
+//$$ L2 PROP_U32 = "pmu_pwroff_vol"
+//$$ L2 PROP_U32 = "pmu_pwron_vol"
+//$$ L2 PROP_U32 = "pmu_pekoff_time"
+//$$ L2 PROP_U32 = "pmu_pekoff_en"
+//$$ L2 PROP_U32 = "pmu_peklong_time"
+//$$ L2 PROP_U32 = "pmu_pwrok_time"
+//$$ L2 PROP_U32 = "pmu_pwrnoe_time"
+//$$ L2 PROP_U32 = "pmu_intotp_en"
+//$$ L2 PROP_U32 = "pmu_pekon_time"
+//$$ L2 PROP_U32 = "pmu_charge_efficiency"
+//$$ L2 PROP_U32 16*3 ="pmu_bat_curve"
+    battery_parameter:battery_parameter{
+        status = "okay";
+	    pmu_twi_id = <2>;                   /** PMU i2c bus                          */
+        pmu_irq_id = <0>;                   /** INT_WATCHDOG                         */
+        pmu_twi_addr = <0x32>;              /** PMU i2c addr                         */
+        pmu_battery_rdc = <135>;             /** battery internal resistor            */
+        pmu_battery_cap = <3800>;           /** battery capacity                     */
+        pmu_battery_technology = <4>;       /** POWER_SUPPLY_TECHNOLOGY_LiFe         */
+        pmu_battery_name = "PTI PL336078";  /** battery name                         */
+        pmu_init_chgvol = <4200000>;        /** target charge voltage                */
+        pmu_init_chgend_rate = <10>;        /** set initial charing end current rate */
+        pmu_init_chg_enabled = <1>;         /** set initial charing enabled          */
+        pmu_init_adc_freq = <25>;           /** set initial adc frequency            */
+        pmu_init_adc_freqc = <100>;         /** set initial coulomb adc coufrequency */
+        pmu_init_chg_pretime = <80>;        /** set initial pre-charging time        */
+        pmu_init_chg_csttime = <720>;       /** set initial rapid-charging time      */
+        pmu_init_chgcur = <10>;             /** initial charge current, 0.1c         */
+        pmu_suspend_chgcur = <20>;          /** suspend charge current, 0.2c         */
+        pmu_resume_chgcur = <10>;           /** resume charge current, 0.1c          */
+        pmu_shutdown_chgcur = <20>;         /** shutdown charge current, 0.2c        */
+        pmu_usbcur_limit = <1>;             /** enable usb current limit?            */
+        pmu_usbcur = <500>;                 /** usb limit current value if enabled   */
+        pmu_usbvol_limit = <1>;             /** enable usb vbus voltage limit        */
+        pmu_usbvol = <4400>;                /** voltage limit value if enabled       */
+        pmu_pwroff_vol = <3200>;            /** hardware force power off voltage     */
+        pmu_pwron_vol = <2900>;             /** power on when battery voltage above  */
+        pmu_pekoff_time = <6000>;           /** long press to power off system       */
+        pmu_pekoff_en  = <1>;               /** enable long press to PWR OFF system  */
+        pmu_peklong_time = <1500>;          /** threshold to detect long press       */
+        pmu_pwrok_time   = <64>;            /** delay to detect pwr ok signal        */
+        pmu_pwrnoe_time = <2000>;           /**                                      */
+        pmu_intotp_en = <1>;                /** over temperature protection enable   */
+        pmu_pekon_time = <128>;             /** powerkey hold time for power on      */
+        pmu_charge_efficiency = <93>;       /** efficient of charging                */
+        pmu_bat_curve = <
+         /* ocv, charge, discharge */
+            3132      0       0
+            3273      0       0
+            3414      0       0
+            3555      0       0  
+            3625      1       2  
+            3660      2       3  
+            3696      3      12 
+            3731     10      18 
+            3766     15      31 
+            3801     22      45 
+            3836     40      55
+            3872     55      62
+            3942     68      73
+            4012     79      83
+            4083     88      90
+            4153    100     100>;
+	};
+
+    pmu {
+        compatible = "amlogic, aml_pmu_prober";                 /* fixed for pmu driver, don't change   */
+        #address-cells = <1>;
+        #size-cells = <0>;
+//$$ DEVICE = "Pmu_axp202"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_CHOICE "battery_parameter_match" = "board_battery"
+//$$ L2 PROP_STR = "status"
+        axp202 { /* PMU for AXP */
+            compatible = "axp_mfd";                             /* for driver probe, must have          */
+            sub_type = "axp20_mfd";                             /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x34>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            board_battery = <&battery_parameter>;               /** battery parameter used, must have    */
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+//$$ DEVICE = "Pmu_aml1212"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_CHOICE "battery_parameter_match" = "board_battery"
+//$$ L2 PROP_STR = "status"
+        aml1212{                                                /* PMU for AML1212, see comment above   */
+            compatible = "amlogic_pmu";                         /** for driver probe, must have          */
+            sub_type = "aml1212";                               /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x35>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            board_battery = <&battery_parameter>;               /** battery parameter used, must have    */
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+//$$ DEVICE = "Pmu_rn5t618"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_CHOICE "battery_parameter_match" = "board_battery"
+//$$ L2 PROP_STR = "status"
+        rn5t618{                                                /* PMU for RN5T618, see comment above   */
+            compatible = "ricoh_pmu";                           /* for driver probe, must have          */
+            sub_type = "rn5t618";                               /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x32>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            board_battery = <&battery_parameter>;               /** battery parameter used, must have    */
+            vbus_dcin_short_connect = <0>;
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+    
+//$$ DEVICE = "Pmu_aml1216"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_CHOICE "battery_parameter_match" = "board_battery"
+//$$ L2 PROP_STR = "status"
+        aml1216{
+            compatible = "amlogic_pmu";                         /** compatible to amlogic PMU            */
+            sub_type = "aml1216_pmu";                           /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x35>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            board_battery = <&battery_parameter>;               /** battery parameter used, must have    */
+            vbus_dcin_short_connect = <0>;
+            status = "okay";                                    /** status of pmu, only one should be OK */
+        };
+    };
+
+/// ***************************************************************************************
+///	-	USB Controller
+//$$ MODULE="USB Controller"
+    usb_con {
+		lm-compatible = "logicmodule-bus";
+
+//$$ DEVICE="usb_b"
+//$$ L2 PROP_U32 = "lm-periph-id"
+//$$ L2 PROP_STR = "clock-src"
+//$$ L2 PROP_U32 = "port-id"
+//$$ L2 PROP_U32 = "port-type"
+//$$ L2 PROP_U32 = "port-speed"
+//$$ L2 PROP_U32 = "port-config"
+//$$ L2 PROP_U32 = "port-dma"
+//$$ L2 PROP_U32 = "port-id-mode"
+//$$ L2 PROP_STR = "status"
+		usb_b{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <1>; /** lm name */
+			clock-src = "usb1"; /** clock src */
+			port-id = <1>; /** ref to mach/usb.h */
+			port-type = <1>;	/** 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /** 0: default, 1: high, 2: full */
+			port-config = <0>; /** 0: default */
+			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <1>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+			status = "okay";
+		};
+		
+//$$ DEVICE="usb_a"
+//$$ L2 PROP_U32 = "lm-periph-id"
+//$$ L2 PROP_STR = "clock-src"
+//$$ L2 PROP_U32 = "port-id"
+//$$ L2 PROP_U32 = "port-type"
+//$$ L2 PROP_U32 = "port-speed"
+//$$ L2 PROP_U32 = "port-config"
+//$$ L2 PROP_U32 = "port-dma"
+//$$ L2 PROP_U32 = "port-id-mode"
+//$$ L2 PROP_STR = "gpio-vbus-power"
+//$$ L2 PROP_U32 = "gpio-work-mask"
+//$$ L2 PROP_U32 = "charger_detect"
+//$$ L2 PROP_STR = "status"
+		usb_a{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <0>; /** lm name */
+			clock-src = "usb0"; /** clock src */
+			port-id = <0>;  /** ref to mach/usb.h */
+			port-type = <0>;	/** 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /** 0: default, high, 1: full */
+			port-config = <0>; /** 0: default */
+			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+			gpio-vbus-power = "GPIOZ_1";
+			gpio-work-mask	= <1>; /**0: work on pulldown,1:work on pullup*/
+			charger_detect = <1>;
+			status = "okay";
+		};
+	};
+    
+/// ***************************************************************************************
+///	-	LCD
+//$$ MODULE="LCD"
+//$$ DEVICE="backlight"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_CHOICE "Bl_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Bl_pin_1_match" = "pinctrl-1"
+//$$ L2 PROP_U32 2= "bl_level_default_uboot_kernel"
+//$$ L2 PROP_U32 2= "bl_level_middle_mapping"
+//$$ L2 PROP_U32 2= "bl_level_max_min"
+//$$ L2 PROP_U32 = "bl_ctrl_method"
+//$$ L2 PROP_STR = "bl_gpio_port"
+//$$ L2 PROP_U32 2 = "bl_gpio_dim_max_min"
+//$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
+//$$ L2 PROP_U32 = "bl_pwm_freq"
+//$$ L2 PROP_U32 2 = "bl_pwm_duty_max_min"
+//$$ L2 PROP_U32 = "bl_pwm_combo_high_low_level_switch"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_high_port_method"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_low_port_method"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_high_freq_duty_max_min"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_low_freq_duty_max_min"
+    backlight{
+		compatible = "amlogic,backlight";
+		dev_name = "backlight";
+		status = "okay";
+		pinctrl-names = "default","pwm_combo";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
+		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
+		
+		bl_level_default_uboot_kernel=<10 102>;	/** default brightness level for uboot & kernel */
+		bl_level_middle_mapping=<128 102>;	/** brightness middle level mapping to a new level*/
+		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
+		
+		/* backlight power ctrl */
+		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive, 3=pwm_combo. decided by hardware design) */
+		
+		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
+		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
+		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
+		bl_pwm_freq=<300000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<90 30>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		
+		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
+		bl_pwm_combo_high_low_level_switch=<220>;	/** backlight pwm_combo control switch level */
+		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_low_port_method="PWM_D","2";	/** backlight pwm_combo low port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_high_freq_duty_max_min=<300000 96 89>;	/** backlight pwm_combo level_high port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+		bl_pwm_combo_low_freq_duty_max_min=<10000 100 10>;	/** backlight pwm_combo level_low port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+	};
+//$$ DEVICE="lcd"
+//$$ L2 PROP_STR = "status"
+
+//$$ L2 PROP_STR = "lcd_model_name"
+//$$ L2 PROP_CHOICE "lcd_model_config_match" = "lcd_model_config"
+//$$ L2 PROP_U32 = "lcd_bits_user"
+
+//$$ L2 PROP_U32 2 = "ttl_rb_bit_swap"
+//$$ L2 PROP_U32 = "lvds_channel_pn_swap"
+
+//$$ L2 PROP_U32 2 = "valid_hvsync_de"
+//$$ L3 PROP_U32 4 = "hsign_hoffset_vsign_voffset"
+
+//$$ L3 PROP_U32 2 = "dither_user_ctrl"
+//$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
+
+//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
+//$$ L3 PROP_U32 256 = "gamma_table"
+
+//$$ L4 PROP_U32 = "clock_spread_spectrum"
+//$$ L4 PROP_U32 = "clock_auto_generation"
+//$$ L4 PROP_U32 3 = "clk_pll_div_clk_ctrl"
+//$$ L4 PROP_U32 3 = "mipi_dsi_lane_speed_user_min_max"
+//$$ L4 PROP_U32 = "lvds_vswing"
+//$$ L4 PROP_U32 2 = "lvds_user_repack"
+//$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
+//$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 2 = "rgb_base_coeff"
+//$$ L4 PROP_U32 2 = "video_on_pixel_line"
+
+//$$ L2 PROP_STR 3 = "power_on_uboot"
+//$$ L2 PROP_STR 3 = "power_on_step_1"
+//$$ L2 PROP_STR 3 = "power_on_step_2"
+//$$ L2 PROP_STR 3 = "power_on_step_3"
+//$$ L2 PROP_STR 3 = "power_on_step_4"
+//$$ L2 PROP_STR 3 = "power_on_step_5"
+//$$ L2 PROP_STR 3 = "power_on_step_6"
+//$$ L2 PROP_STR 3 = "power_on_step_7"
+//$$ L2 PROP_STR 3 = "power_on_step_8"
+//$$ L2 PROP_STR 3 = "power_on_step_9"
+//$$ L2 PROP_STR 3 = "power_on_step_10"
+//$$ L2 PROP_STR 3 = "power_on_step_11"
+//$$ L2 PROP_STR 3 = "power_on_step_12"
+//$$ L2 PROP_STR 3 = "power_on_step_13"
+//$$ L2 PROP_STR 3 = "power_on_step_14"
+//$$ L2 PROP_STR 3 = "power_on_step_15"
+//$$ L2 PROP_U32 15 = "power_on_delay"
+//$$ L2 PROP_STR 3 = "power_off_step_1"
+//$$ L2 PROP_STR 3 = "power_off_step_2"
+//$$ L2 PROP_STR 3 = "power_off_step_3"
+//$$ L2 PROP_STR 3 = "power_off_step_4"
+//$$ L2 PROP_STR 3 = "power_off_step_5"
+//$$ L2 PROP_STR 3 = "power_off_step_6"
+//$$ L2 PROP_STR 3 = "power_off_step_7"
+//$$ L2 PROP_STR 3 = "power_off_step_8"
+//$$ L2 PROP_STR 3 = "power_off_step_9"
+//$$ L2 PROP_STR 3 = "power_off_step_10"
+//$$ L2 PROP_STR 3 = "power_off_step_11"
+//$$ L2 PROP_STR 3 = "power_off_step_12"
+//$$ L2 PROP_STR 3 = "power_off_step_13"
+//$$ L2 PROP_STR 3 = "power_off_step_14"
+//$$ L2 PROP_STR 3 = "power_off_step_15"
+//$$ L2 PROP_U32 15 = "power_off_delay"
+//$$ L2 PROP_STR 3 = "power_off_uboot"
+	lcd{
+		compatible = "amlogic,lcd";
+		dev_name = "lcd";
+		status = "okay";
+		pinctrl-names = "ttl_6bit_hvsync_de_on","ttl_6bit_hvsync_on","ttl_6bit_de_on","ttl_8bit_hvsync_de_on","ttl_8bit_hvsync_on","ttl_8bit_de_on",
+						"ttl_6bit_hvsync_de_off","ttl_8bit_hvsync_de_off";
+		pinctrl-0 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-1 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-2 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-3 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-4 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-5 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-6 = <&lcd_ttl_rgb_6bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		pinctrl-7 = <&lcd_ttl_rgb_8bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+
+ 		lcd_model_name ="lcd_B080XAN01";	/** lcd model name for uboot driver */
+ 		lcd_model_config = <&lcd_B080XAN01>;	/** choose panel model config */
+ 		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
+
+		/* below configs are decided by hardware design, you can modify them if needed. */
+		//ttl config
+		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
+		//lvds config
+		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
+
+		/* recommend settings, you can modify them if needed. */
+		valid_hvsync_de=<1 1>;	/** hvsync_signal_valid, DE_signal_valid : (0=disable signal, 1=enable signal) */
+		hsign_hoffset_vsign_voffset=<1 0 1 0>;	/** hsign, hoffset, vsign, voffset :("sign-offset" is a pair. sign: 0 for negative, 1 for positive) */
+
+		dither_user_ctrl=<0 0x000>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
+		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
+
+		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
+		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
+		gamma_table=<0 1 2 3 4 5 6 7 8 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
+					32 33 34 35 36 37 37 38 39 40 41 42 43 44 45 46 47 48 49 50 50 51 52 53 54 55 56 57 57 58 59 60 
+					61 62 63 64 65 65 67 67 68 69 70 71 72 73 74 75 76 76 77 78 79 80 81 82 82 83 84 85 86 87 88 88 
+					89 90 91 92 93 94 95 96 97 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 
+					120 121 122 123 124 125 126 127 128 129 130 131 131 132 133 135 136 136 138 139 140 141 142 143 144 145 146 147 148 149 151 152 
+					153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 176 177 178 179 180 181 182 183 184 185 
+					186 188 189 190 191 192 193 195 196 197 198 199 200 202 203 204 205 206 208 209 210 211 212 213 214 216 217 218 219 220 221 222 
+					223 224 225 226 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
+
+		/* default settings, don't modify them unless there is display problem */
+		clock_spread_spectrum=<0>;	/** ss_level(0=disable, 1=0.5%, 2=1%, 3=2%, 4=3%, 5=4%, 6=5%) */
+		clock_auto_generation=<1>;	/** clk_auto_generation(0=use customer clock parameters, as clk_pll_div_clk_ctrl defined, 1=auto generate clock parameters by lcd_clock) */
+		clk_pll_div_clk_ctrl=<0x100042b 0x18833 0x03a82102>;	/** pll_ctrl, div_ctrl, clk_ctrl : (only valid when clk_auto_generation=0) */
+		mipi_dsi_lane_speed_user_min_max=<0 200 1000>; /** mipi_lane_speed_user(0=auto setting, 1=user define), speed_min,spend_max(unit in MHz, only valid when mipi_lane_speed_user=1)*/
+		lvds_vswing=<1>;	/** lvds_vswing_level(default level=1, support level 0,1,2,3,4) */
+		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
+		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
+		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
+		video_on_pixel_line=<120 32>;  /** video_on_pixel, video_on_line */  
+
+		//lcd power ctrl	//support up to 15 steps for each sequence
+		power_on_uboot="n","n","n";	/** only for uboot, ahead of lcd_power_on, no need config delay */
+		power_on_step_1="pmu","GPIO1","0";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_2="cpu","GPIODV_29","0";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_3="cpu","GPIODV_0","0";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_4="cpu","GPIODV_0","1";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_5="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_on_step_6="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_7="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_8="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_9="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_10="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_11="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_12="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_13="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_14="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_15="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+ 		power_on_delay=<20 14 5 70 5 0 0 0 0 0 0 0 0 0 0>;	/** power on delay after each step */
+		power_off_step_1="signal";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+ 		power_off_step_2="cpu","GPIODV_29","1";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+ 		power_off_step_3="cpu","GPIODV_0","0";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_4="pmu","GPIO1","2";	/** gpio_type(cpu, pmu, signal), gpio_name(valid when gpio_type is cpu or pmu), gpio_value(valid when gpio_type is cpu or pmu) */
+		power_off_step_5="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_6="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_7="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_8="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_9="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_10="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_11="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_12="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_13="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_14="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_15="n","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_delay=<5 14 0 100 0 0 0 0 0 0 0 0 0 0 0>;	/** power off delay after each step */
+		power_off_uboot="n","n","n";	/** only for uboot, at the end of lcd_power_off, no need config delay */
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_LP097QX1>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+	lcd_LP097QX1:lcd_LP097QX1{	//k100
+		model_name="LP097QX1";	/** lcd model name */
+		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<197 147>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		
+		resolution=<2048 1536>;	/** horizontal resolution, vertical resolution */
+		period=<2219 1560>;		/** horizontal period(htotal), vertical period(vtotal) */
+		
+		clock_hz_pol=<207700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "lane_num"
+//$$ L2 PROP_U32 2 = "dsi_clk_min_max"
+	lcd_B080XAN01:lcd_B080XAN01{	//k101
+		model_name="B080XAN01";	/** lcd model name */
+		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<119 159>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<6 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+		resolution=<768 1024>;	/** horizontal resolution, vertical resolution */
+		period=<948 1140>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+		clock_hz_pol=<64843200 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<64 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<50 80>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+    lane_num=<4>;//lane num
+    dsi_clk_min_max=<500 600>;/*area of bit rate of one lane:(dsi_clk_min=500, dsi_clk_max=600)*/
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+	lcd_CLAP070NJ02:lcd_CLAP070NJ02{	//g33
+		model_name="CLAP070NJ02";	/** lcd model name */
+		interface="ttl";			/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<154 86>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		
+		resolution=<1024 600>;	/** horizontal resolution, vertical resolution */
+		period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
+		
+		clock_hz_pol=<42700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 160>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_TN070TN92>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+	lcd_TN070TN92:lcd_TN070TN92{	//800*480
+		model_name="TN070TN92";	/** lcd model name */
+		interface="ttl";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<154 86>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		
+		resolution=<800 480>;	/** horizontal resolution, vertical resolution */
+		period=<1056 525>;		/** horizontal period(htotal), vertical period(vtotal) */
+		
+		clock_hz_pol=<33300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 46>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_LP097X02>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"	
+	lcd_LP097X02:lcd_LP097X02{	//g24
+		model_name="LP097X02";	/** lcd model name */
+		interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<197 147>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<6 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		
+		resolution=<1024 768>;	/** horizontal resolution, vertical resolution */
+		period=<2084 810>;		/** horizontal period(htotal), vertical period(vtotal) */
+		
+		clock_hz_pol=<85700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<3 30>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_CLAA101FP05XG>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "lane_num"
+//$$ L2 PROP_U32 2 = "pclk_div_lanebyteclk"
+//$$ L2 PROP_U32 2 = "dsi_clk_min_max"     	
+lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{	//k101
+		model_name="CLAA101FP05XG";	/** lcd model name */
+		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<216 135>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+		resolution=<1920 1200>;	/** horizontal resolution, vertical resolution */
+		period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+		clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+    lane_num=<4>;//lane num
+    pclk_div_lanebyteclk =<15>;/**(pix_clk/lane_byte_clk)*10 */                                    
+	  dsi_clk_min_max=<900 1000>;/*area of bit rate of one lane:(dsi_clk_min=900, dsi_clk_max=1000)*/  
+	};
+
+//$$ DEVICE="lcd_extern"
+//$$ L2 PROP_STR = "status"
+	lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		status = "disabled";
+
+//$$ DEVICE = "lcd_extern_tc101"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_STR = "status"
+		lcd_extern_tc101{
+			dev_name ="lcd_tc101";
+			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
+			address = <0x7e>;
+			i2c_bus = "i2c_bus_a";
+			status = "disabled";
+		};
+	};
+/// ***************************************************************************************
+///     -       Sensors
+//$$ MODULE="Sensors"
+//$$ DEVICE="sensor"
+//$$ L2 PROP_STR = "status"
+    sensor{
+		compatible = "amlogic,aml_sensor";
+		status = "okay";
+
+//$$ DEVICE="stk831x"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+        stk831x{
+            dev_name = "stk831x";
+            status = "okay";
+            address = <0x3d>;
+            i2c_bus = "i2c_bus_b";
+        };
+
+//$$ DEVICE="mma7660"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+        mma7660{
+            dev_name = "mma7660";
+            status = "okay";
+            address = <0x4c>;
+            i2c_bus = "i2c_bus_b";
+        };
+
+//$$ DEVICE="mma8452"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "acc_dir"
+        mma8452{
+            dev_name = "mma8452";
+            status = "okay";
+            address = <0x1c>;
+            i2c_bus = "i2c_bus_b";
+            acc_dir = <0x0101>;
+        };
+
+//$$ DEVICE="mma865x"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "acc_dir"
+        mma865x{
+            dev_name = "mma865x";
+            status = "okay";
+            address = <0x1d>;
+            i2c_bus = "i2c_bus_b";
+            acc_dir = <0x0101>;
+        };
+
+//$$ DEVICE="afa750"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+        afa750{
+            dev_name = "afa750";
+            status = "okay";
+            address = <0x3c>;
+            i2c_bus = "i2c_bus_b";
+        };
+};
+
+/// ***************************************************************************************
+/// -   Audio
+//$$ MODULE="Audio"
+//$$ DEVICE="audio_i2s"
+//$$ L2 PROP_STR = "status"
+    audio_platform{
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_i2s_dai"
+//$$ L2 PROP_STR = "status"
+    audio_dai{
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
+        status = "okay";
+    };
+
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_m8_audio"
+//$$ L2 PROP_STR = "status"
+    audio_m8_audio{
+        compatible = "amlogic,m8_audio_codec";
+        dev_name = "aml_m8_codec.0";
+        status = "okay";
+    };
+
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
+//$$ DEVICE="aml_m8_sound_card"
+//$$ L2 PROP_STR = "aml,sound_card"
+//$$ L2 PROP_STR = "aml,codec_dai"
+//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
+//$$ L2 PROP_STR = "mute_gpio"
+//$$ L2 PROP_U32 5 = "hp_paraments"
+//$$ L2 PROP_STR = "status"
+    aml_m8_sound_card{
+        compatible = "sound_card, aml_snd_m8";
+        aml,sound_card = "AML-M8AUDIO";
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
+        mute_gpio = "GPIOY_15";
+        I2S_MCLK = "GPIOAO_8";
+        I2S_SCLK = "GPIOAO_9";
+        I2S_LRCLK = "GPIOAO_10";
+        I2S_ODAT = "GPIOAO_11";
+        hp_paraments = <800 300 0 5 1>;
+		pinctrl-names = "aml_snd_m8";
+		pinctrl-0 = <&audio_pins>;
+		status = "okay"; 
+	};
+
+/// ***************************************************************************************
+///	-	Camera
+//$$ MODULE="Camera"
+///	-	aml_cams
+//$$ DEVICE = "aml_cams"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR 2 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Camera_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Camera_pin_1_match" = "pinctrl-1"
+	aml_cams{
+		compatible = "amlogic,cams_prober";
+		status = "okay";
+		pinctrl-names = "gpio","csi";
+		pinctrl-0 = <&aml_cam_gpio_pins> ;
+		pinctrl-1 = <&aml_cam_csi_pins> ;
+
+///	-	gc2035
+//$$ DEVICE="gc2035"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+        	cam_0{
+			cam_name = "gc2035";
+			front_back = <1>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_5";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <1>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+///	-	ov5640
+//$$ DEVICE="ov5640"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_1{
+			cam_name = "ov5640";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <1>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";	
+		};
+
+///	-	gc2035
+//$$ DEVICE="gc2035"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+        	cam_2{
+			cam_name = "gc2035";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+ ///	-	hm2057
+//$$ DEVICE="hm2057"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"    
+            	 cam_3{
+			cam_name = "hm2057";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_5";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+//$$ DEVICE="sp0a19"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+        cam_4{
+			cam_name = "sp0a19";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+///	-	hm5065
+//$$ DEVICE="hm5065"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_5{
+			cam_name = "hm5065";
+			front_back = <0>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_5";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+///	-    sp1628
+//$$ DEVICE="sp1628"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "front_back"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_pwdn"
+//$$ L2 PROP_STR = "gpio_rst"
+//$$ L2 PROP_U32 = "mirror_flip"
+//$$ L2 PROP_U32 = "vertical_flip"
+//$$ L2 PROP_STR = "bt_path"
+		cam_6{
+			cam_name = "sp1628";
+			front_back = <1>;
+			i2c_bus = "i2c_bus_d";
+			gpio_pwdn = "GPIOH_6";
+			gpio_rst = "GPIOH_4";
+			mirror_flip = <0>;
+			vertical_flip = <0>;	
+			bt_path = "gpio";
+			status = "okay";
+		};
+
+	};	
+
+/// ***************************************************************************************
+///	-	Input
+//$$ MODULE="Input"
+//$$ DEVICE="gpio_keypad"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "scan_period"
+//$$ L2 PROP_U32 = "key_num"
+//$$ L2 PROP_STR = "key_name"
+//$$ L2 PROP_U32 = "key_code"
+//$$ L2 PROP_STR = "key_pin"
+//$$ L2 PROP_U32 = "irq_keyup"
+//$$ L2 PROP_U32 = "irq_keydown"
+    gpio_keypad{
+		compatible = "amlogic,gpio_keypad";
+		status = "okay";
+		scan_period = <20>;
+		key_num = <1>;
+        key_name = "power";
+		key_code = <116>;
+		key_pin = "GPIOAO_3";
+        irq_keyup = <6>;
+        irq_keydown = <7>;
+	};
+//$$ DEVICE="saradc"
+//$$ L2 PROP_STR = "status"
+	saradc{
+		compatible = "amlogic,saradc";
+		status = "okay";
+	};
+//$$ DEVICE="adc_keypad"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "key_name"
+//$$ L2 PROP_U32 = "key_num"
+//$$ L2 PROP_U32 2 = "key_code"
+//$$ L2 PROP_U32 2 = "key_chan"
+//$$ L2 PROP_U32 2 = "key_val"
+//$$ L2 PROP_U32 2 = "key_tolerance"
+    adc_keypad{
+		compatible = "amlogic,adc_keypad";
+		status = "okay";
+		key_name = "vol-","vol+";
+		key_num = <2>;
+		key_code = <114 115>;
+		key_chan = <0 0>;
+		key_val = <144 267>;
+		key_tolerance = <40 40>;
+	};
+
+/// ***************************************************************************************
+///	-	WiFi
+//$$ MODULE="WiFi"
+//$$ DEVICE="wifi_power"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "power_gpio"
+	wifi_power{
+            compatible = "amlogic,wifi_power";
+            dev_name = "wifi_power";
+            status = "okay";
+            power_gpio = "GPIOAO_6";
+	};  
+    
+/// ***************************************************************************************
+///	-	Nand
+//$$ MODULE="Nand"
+//$$ DEVICE="aml_nand"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 2 = "pinctrl-names"
+//$$ L2 PROP_CHOICE 3 "Nand_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE 3 "Nand_pin_1_match" = "pinctrl-1"
+//$$ L3 PROP_STR ="plat-names"
+//$$ L2 PROP_U32 = "plat-num"
+//$$ L2 PROP_CHOICE "plat-part-0_match" = "plat-part-0"
+	nand{
+		compatible = "amlogic,aml_nand";
+		dev_name = "nand";
+		status = "ok";
+		reg = <0xd0048600 0x24>;
+		pinctrl-names = "nand_rb_mod","nand_norb_mod";
+		pinctrl-0 = <&nand_input_state &conf_nand_state &nand_base>;
+		pinctrl-1 = <&nand_input_state &conf_nand_state &nand_base>;
+		device_id = <0>;
+		plat-names = "nandnormal";
+		plat-num = <1>;
+		plat-part-0 = <&normal>;
+
+//$$ MATCH "plat-part-0_match" = <&normal>
+//$$ L2 PROP_STR 4 = "enable_pad"
+//$$ L2 PROP_STR = "busy_pad"
+		normal: normal{
+			enable_pad ="ce0","ce1","ce2","ce3";
+			busy_pad = "rb0";
+		};
+	};
+
+/// ***************************************************************************************
+///	-	Efuse
+//$$ MODULE="Efuse"
+//$$ DEVICE="efuse"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "plat-pos"
+//$$ L2 PROP_U32 = "plat-count"
+//$$ L2 PROP_U32 = "usid-min"
+//$$ L2 PROP_U32 = "usid-max"
+    efuse{
+		compatible = "amlogic,efuse";
+		dev_name = "efuse";
+		status = "okay";
+		plat-pos = <0 454>;
+		plat-count = <58>;
+		usid-min = <8>; /*reserved*/
+		usid-max = <31>; /*reserved*/
+	};
+/// ***************************************************************************************
+///	-	Thermal
+//$$ MODULE="Thermal"
+//$$ DEVICE="thermal"
+//$$ L2 PROP_U32 3*3 = "trip_point"
+//$$ L2 PROP_U32 = "#thermal-cells"
+//$$ L2 PROP_U32 = "cpu_cali_a"
+//$$ L2 PROP_U32 = "idle_interval"
+	thermal{
+		compatible = "amlogic-thermal";
+		#thermal-cells=<3>;
+		dev_name = "aml_thermal";
+		trip_point=<50 1200000 1200000
+			    70  800000 800000
+			    110 0xffffffff 0xffffffff>;
+		cpu_cali_a=<0>;
+		idle_interval=<1000>;
+
+	};
+
+/// ***************************************************************************************
+///	-	HDMI
+//$$ MODULE="HDMI"
+//$$ DEVICE="amhdmitx"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_CHOICE "HDMI_vend-data_match" = "vend-data"
+//$$ L2 PROP_CHOICE "HDMI_pwr-ctrl_match" = "pwr-ctrl"
+    amhdmitx{
+		compatible = "amlogic,amhdmitx";
+		dev_name = "amhdmitx";
+		status = "ok";
+        vend-data = <&vend_data>;
+        pwr-ctrl = <&pwr_ctrl>;
+        
+//$$ MATCH "HDMI_vend-data_match" = <&vend_data>
+//$$ L2 PROP_STR = "vendor_name"
+//$$ L2 PROP_U32 = "vendor_id"
+//$$ L2 PROP_STR = "product_desc"
+//$$ L2 PROP_STR = "cec_osd_string"        
+        vend_data: vend_data{
+            vendor_name = "Amlogic";           /* Max Chars: 8     */
+            vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+            product_desc = "M8 MBox SKTv1";        /* Max Chars: 16    */
+            cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
+        };
+        
+//$$ MATCH "HDMI_pwr-ctrl_match" = <&pwr_ctrl>
+//$$ L2 PROP_STR = "pwr_5v_on"
+//$$ L2 PROP_STR = "pwr_5v_off"
+//$$ L2 PROP_STR = "pwr_3v3_on"
+//$$ L2 PROP_STR = "pwr_3v3_off"
+//$$ L2 PROP_STR = "pwr_hpll_vdd_on"
+//$$ L2 PROP_STR = "pwr_hpll_vdd_off"
+        pwr_ctrl: pwr_ctrl{
+            pwr_5v_on = "";
+            pwr_5v_off = "";
+            pwr_3v3_on = "";
+            pwr_3v3_off = "";
+            pwr_hpll_vdd_on = "";
+            pwr_hpll_vdd_off = "";
+        };
+	};
+	
+/// ***************************************************************************************
+///	-	Securitykey
+//$$ MODULE="Securitykey"
+//$$ DEVICE="securitykey"
+//$$ L2 PROP_STR = "status"
+    securitykey{
+		compatible = "amlogic,aml_keys";
+		status = "ok";
+	};
+
+/// ***************************************************************************************
+///	-	Unifykey
+//$$ MODULE="Unifykey"
+//$$ DEVICE="securitykey"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 ="unifykey-num"
+//$$ L2 PROP_CHOICE "Unifykey_0_match" = "unifykey-index-0"
+//$$ L2 PROP_CHOICE "Unifykey_1_match" = "unifykey-index-1"
+//$$ L2 PROP_CHOICE "Unifykey_2_match" = "unifykey-index-2"
+    	unifykey{
+		compatible = "amlogic,unifykey";
+		status = "ok";
+
+		/*efuse-version = <0>;*/ /*m6 efuse version 2,m3 efuse version 1, not config efuse version in default*/
+		unifykey-num = <3>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+
+
+//$$ MATCH "Unifykey_0_match" = <&keysn_0>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_0: key_0{
+			key-name = "key0";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+		
+//$$ MATCH "Unifykey_1_match" = <&keysn_1>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_1:key_1{
+			key-name = "key1";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+		
+//$$ MATCH "Unifykey_2_match" = <&keysn_2>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_2:key_2{
+			key-name = "key2";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+	};
+
+	
+/// ***************************************************************************************
+///	-	PowerManager
+//$$ MODULE="PowerManager"
+//$$ DEVICE="amvenc_avc"
+//$$ L2 PROP_STR = "status"
+    aml_pm{
+		compatible = "amlogic,pm-m8";
+		dev_name = "aml_pm_m8";
+		status = "okay";
+	};
+	
+/// ***************************************************************************************
+///	-	Touch
+//$$ MODULE="Touch"
+//$$ DEVICE="touch"
+//$$ L2 PROP_STR = "status"
+    touch{
+        compatible = "amlogic,aml_touch";
+        status = "okay";
+        #address-cells = <1>;
+		#size-cells = <0>;
+		
+//$$ DEVICE = "touch_ct36x"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "touch_name"
+//$$ L3 PROP_STR = "i2c_bus"
+//$$ L3 PROP_U32 ="reg"
+//$$ L3 PROP_U32 ="irq"
+//$$ L3 PROP_STR = "gpio_interrupt"
+//$$ L3 PROP_STR = "gpio_reset"
+//$$ L3 PROP_U32 ="xres"
+//$$ L3 PROP_U32 ="yres"
+//$$ L3 PROP_U32 ="pol"
+//$$ L3 PROP_STR = "fw_file"
+        touch_ct36x:ct36x{
+			compatible = "vtl,ct36x";
+			touch_name = "ct36x";
+			i2c_bus = "i2c_bus_a";
+			reg = <0x01>;
+			irq = <0>;
+			gpio_interrupt = "GPIOZ_7";
+			gpio_reset = "GPIOZ_6";
+			xres = <1024>;
+			yres = <768>;
+			pol = <0x6>;
+			fw_file = "/etc/touch/ct36x.dat";
+			status = "okay";
+		};
+   };
+
+/// ***************************************************************************************
+///	-	Cpufreq
+//$$ MODULE="Cpufreq"
+//$$ DEVICE="cpufreq-meson"
+//$$ L2 PROP_STR = "status"
+    cpufreq-meson{
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+
+/// **************************************************************************************
+/// -   GPIO
+//$$ MODULE="GPIO"
+//$$ DEVICE="m8-gpio"
+	gpio:gpio{
+		compatible = "amlogic,m8-gpio";
+		dev_name = "gpio";
+		#gpio-cells=<2>;
+	};
+
+/// **************************************************************************************
+/// -   Pinmux
+//$$ MODULE="Pinmux"
+//$$ DEVICE="pinmux-m8"
+    pinmux{ 
+		compatible = "amlogic,pinmux-m8";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;    
+    
+//$$ MATCH "uart_ao_pin_match" = "&ao_uart_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+        ao_uart_pins:ao_uart{
+			amlogic,setmask=<10 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		
+//$$ MATCH "uart_0_pin_match" = "&a_uart_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 4 = "amlogic,pins"
+		a_uart_pins:a_uart{
+			amlogic,setmask=<4 0x3c00>;
+			amlogic,pins="GPIOX_12", "GPIOX_13", "GPIOX_14", "GPIOX_15";
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&nand_input_state"
+//$$ MATCH "Nand_pin_1_match" = "&nand_input_state"
+//$$ L2 PROP_STR 18 = "amlogic,pins"
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+		nand_input_state:nand_input{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_8","BOOT_9","BOOT_10","BOOT_11",
+						"BOOT_14","BOOT_15","BOOT_16","BOOT_17";
+			amlogic,enable-output=<1>;
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&conf_nand_state"
+//$$ MATCH "Nand_pin_1_match" = "&conf_nand_state"
+//$$ L2 PROP_STR 9 = "amlogic,pins"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+		conf_nand_state: conf_nand{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_15";
+			amlogic,pullup=<0>;
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&nand_base"
+//$$ MATCH "Nand_pin_1_match" = "&nand_base"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 17 = "amlogic,pins"
+		nand_base: nand{
+			amlogic,setmask=<2 0x7fe0000>;
+			amlogic,clrmask=<	5 0xe
+							6 0x3f000000
+							4 0x7c000000>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_8","BOOT_9",
+						"BOOT_10","BOOT_12","BOOT_13",
+						"BOOT_14","BOOT_15","BOOT_16","BOOT_17";
+		};
+		
+//$$ MATCH "Card_pin_0_match" = "&sdhc_b_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+
+		sdhc_b_pins:sdhc_b_pin{
+			amlogic,setmask=<2 0xfc00>;
+			amlogic,clrmask=<2 0xf0 8 0x600>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+		};
+
+//$$ MATCH "Card_pin_1_match" = "&sdhc_c_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+		sdhc_c_pins:sdhc_c_pin{
+			amlogic,setmask=<6 0x3f000000>;
+			amlogic,clrmask=<4 0x6c000000 2 0x4c00000>;
+			amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+		};
+
+//$$ MATCH "Card_pin_2_match" = "&sdhc_a_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"		
+		sdhc_a_pins:sdhc_a_pin{
+			amlogic,setmask=<8 0x3f>;
+			amlogic,clrmask=<5 0x6c00 >;
+			amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+		};
+
+//$$ MATCH "sdio_pin_5_match" = "&sdio_all_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"	
+        sdio_all_pins:sdio_all_pins{
+            amlogic,setmask=<8 0x0000003f>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_4_match" = "&sdio_clk_cmd_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sdio_clk_cmd_pins:sdio_clk_cmd_pins{
+            amlogic,setmask=<8 0x00000003>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9"; /** GPIOX_8:CLK, GPIOX_9:CMD */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+//$$ MATCH "sdio_pin_1_match" = "&sd_all_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_all_pins:sd_all_pins{
+            amlogic,setmask=<2 0x0000fc00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000063f        /*sdio a, UART*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_6_match" = "&sd_1bit_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_1bit_pins:sd_1bit_pins{
+            amlogic,setmask=<2 0x00008c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_0_match" = "&sd_clk_cmd_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_clk_cmd_pins:sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_2","CARD_3"; /** CARD_2:CLK, CARD_3:CMD */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_3_match" = "&emmc_all_pins"  
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"      
+        emmc_all_pins:emmc_all_pins{
+            amlogic,setmask=<6 0x3f000000>;         /*sdio c*/
+            amlogic,clrmask=<2 0x04c0fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000>;        /*sdhc c*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_16","BOOT_17";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_2_match" = "&emmc_clk_cmd_pins" 
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+            amlogic,setmask=<6 0x03000000>;         /*bit[24-25] */
+            amlogic,clrmask=<2 0x04c0fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000>;        /*sdhc c*/
+            amlogic,pins = "BOOT_16","BOOT_17"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+//$$ MATCH "Camera_pin_0_match" = "&aml_cam_gpio_pins"
+//$$ L2 PROP_U32 4 = "amlogic,setmask"
+//$$ L2 PROP_STR 10 = "amlogic,pins"	
+        aml_cam_gpio_pins: aml_cam_gpio_pins{
+			amlogic,setmask=<3 0x80000
+					         9 0x37c>;
+			amlogic,pins = "GPIOH_9","GPIOY_6","GPIOY_7","GPIOY_8","GPIOY_9","GPIOY_10","GPIOY_11","GPIOY_12","GPIOY_13","GPIOY_14";
+		};
+		
+//$$ MATCH "Camera_pin_1_match" = "&aml_cam_csi_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR = "amlogic,pins"	
+		aml_cam_csi_pins: aml_cam_csi_pins{
+			amlogic,setmask=<3 0x80000>;
+			amlogic,pins = "GPIOH_9";
+		};
+
+//$$ MATCH "I2C_AO_pin_match" = "&ao_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		ao_i2c_master:ao_i2c{
+			amlogic,setmask=<10 0x60>;
+			amlogic,clrmask=<10 0x1800006>;
+			amlogic,pins="GPIOAO_4","GPIOAO_5";
+		};
+		
+//$$ MATCH "I2C_A_pin_match" = "&a_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		a_i2c_master:a_i2c{
+//			amlogic,setmask=<5 0xc0000000>;
+//			amlogic,clrmask=<9 0x58000 7 3000000>;
+//			amlogic,pins="GPIOZ_0","GPIOZ_1";
+
+//			amlogic,setmask=<5 0x300>;
+//			amlogic,clrmask=<6 0x900 8 11000>;
+//			amlogic,pins="GPIOZ_9","GPIOZ_10";
+
+			amlogic,setmask=<5 0xc0>;
+			amlogic,clrmask=<6 0xc0 8 0xc000>;
+			amlogic,pins="GPIOZ_11","GPIOZ_12";
+		};
+		
+//$$ MATCH "I2C_B_pin_match" = "&b_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		b_i2c_master:b_i2c{
+			amlogic,setmask=<5 0xc000000>;
+			amlogic,pins="GPIOZ_2","GPIOZ_3";
+		};
+
+// MATCH "I2C_C_pin_match" = "&c_i2c_master"
+// L2 PROP_U32 2 = "amlogic,setmask"
+// L2 PROP_U32 2 = "amlogic,clrmask"
+// L2 PROP_STR 2 = "amlogic,pins"	
+//		c_i2c_master:c_i2c{
+//			amlogic,setmask=<5 0x3000000>;
+//			amlogic,clrmask=<6 0xc000>;
+//			amlogic,pins="GPIOZ_4","GPIOZ_5";
+
+//			amlogic,setmask=<1 0xc000>;
+//			amlogic,clrmask=<1 0xc0400 3 0x6 9 0x300>;
+//			amlogic,pins="GPIOY_0","GPIOY_1";
+//		};
+
+//$$ MATCH "I2C_D_pin_match" = "&d_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		d_i2c_master:d_i2c{
+			amlogic,setmask=<4 0xc>;
+			amlogic,pins="GPIOH_7","GPIOH_8";
+		};
+		
+//$$ MATCH "Bl_pin_0_match" = "&lcd_backlight_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR = "amlogic,pins"	
+		lcd_backlight_pins:lcd_backlight{
+			amlogic,setmask=<3 0x1000000>;
+			amlogic,clrmask=<0 0x48 7 0x10000200>;
+			amlogic,pins = "GPIODV_9";
+		};
+		
+//$$ MATCH "Bl_pin_1_match" = "&lcd_backlight_combo_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		lcd_backlight_combo_pins:lcd_backlight_combo{
+			amlogic,setmask=<3 0x5000000>;
+			amlogic,clrmask=<0 0x48 7 0x18000200>;
+			amlogic,pins = "GPIODV_9","GPIODV_28";
+		};
+		
+		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
+			amlogic,setmask=<8 0x1800000>;
+			amlogic,clrmask=<0 0x3c0300 6 0xc00000>;
+			amlogic,pins = "GPIODV_24","GPIODV_25";
+		};
+		
+		lcd_ttl_hvsync_pins_off:lcd_ttl_hvsync_off{
+			amlogic,clrmask=<0 0x3c0300 6 0xc00000 8 0x1800000>;
+			amlogic,pins = "GPIODV_24","GPIODV_25";
+			amlogic,enable-output=<1>;
+		};
+		
+		lcd_ttl_de_pins_on:lcd_ttl_de_on{
+			amlogic,setmask=<8 0x10000000>;
+			amlogic,clrmask=<0 0x400 6 0x100000 8 0x80000>;
+			amlogic,pins = "GPIODV_27";
+		};
+		
+		lcd_ttl_de_pins_off:lcd_ttl_de_off{
+			amlogic,clrmask=<0 0x400 6 0x100000 8 0x10080000>;
+			amlogic,pins = "GPIODV_27";
+			amlogic,enable-output=<1>;
+		};
+		
+		lcd_ttl_clk_pins_on:lcd_ttl_clk_on{
+			amlogic,setmask=<8 0x400000>;
+			amlogic,clrmask=<0 0x80 6 0x200000 8 0x300000>;
+			amlogic,pins = "GPIODV_26";
+		};
+		
+		lcd_ttl_clk_pins_off:lcd_ttl_clk_off{
+			amlogic,clrmask=<0 0x80 6 0x200000 8 0x700000>;
+			amlogic,pins = "GPIODV_26";
+			amlogic,enable-output=<1>;
+		};
+		
+		lcd_ttl_rgb_8bit_pins_on:lcd_ttl_rgb_8bit_on{
+			amlogic,setmask=<0 0x3f>;
+			amlogic,clrmask=<0 0x40 3 0x1000000 7 0x1003ffff 8 0xe000000>;
+			amlogic,pins = "GPIODV_0","GPIODV_1","GPIODV_2","GPIODV_3","GPIODV_4","GPIODV_5","GPIODV_6","GPIODV_7",		//R0~R7
+						"GPIODV_8","GPIODV_9","GPIODV_10","GPIODV_11","GPIODV_12","GPIODV_13","GPIODV_14","GPIODV_15",	//G0~G7
+						"GPIODV_16","GPIODV_17","GPIODV_18","GPIODV_19","GPIODV_20","GPIODV_21","GPIODV_22","GPIODV_23";//B0~B7
+		};
+		
+		lcd_ttl_rgb_8bit_pins_off:lcd_ttl_rgb_8bit_off{
+			amlogic,clrmask=<0 0x7f 3 0x1000000 7 0x1003ffff 8 0xe000000>;
+			amlogic,pins = "GPIODV_0","GPIODV_1","GPIODV_2","GPIODV_3","GPIODV_4","GPIODV_5","GPIODV_6","GPIODV_7",		//R0~R7
+						"GPIODV_8","GPIODV_9","GPIODV_10","GPIODV_11","GPIODV_12","GPIODV_13","GPIODV_14","GPIODV_15",	//G0~G7
+						"GPIODV_16","GPIODV_17","GPIODV_18","GPIODV_19","GPIODV_20","GPIODV_21","GPIODV_22","GPIODV_23";//B0~B7
+			amlogic,enable-output=<1>;
+		};
+		
+		lcd_ttl_rgb_6bit_pins_on:lcd_ttl_rgb_6bit_on{
+			amlogic,setmask=<0 0x15>;
+			amlogic,clrmask=<0 0x40 7 0xfcfc>;
+			amlogic,pins = "GPIODV_2","GPIODV_3","GPIODV_4","GPIODV_5","GPIODV_6","GPIODV_7",		//R2~R7
+						"GPIODV_10","GPIODV_11","GPIODV_12","GPIODV_13","GPIODV_14","GPIODV_15",	//G2~G7
+						"GPIODV_18","GPIODV_19","GPIODV_20","GPIODV_21","GPIODV_22","GPIODV_23";	//B2~B7
+		};
+		
+		lcd_ttl_rgb_6bit_pins_off:lcd_ttl_rgb_6bit_off{
+			amlogic,clrmask=<0 0x55 7 0xfcfc>;
+			amlogic,pins = "GPIODV_2","GPIODV_3","GPIODV_4","GPIODV_5","GPIODV_6","GPIODV_7",		//R2~R7
+						"GPIODV_10","GPIODV_11","GPIODV_12","GPIODV_13","GPIODV_14","GPIODV_15",	//G2~G7
+						"GPIODV_18","GPIODV_19","GPIODV_20","GPIODV_21","GPIODV_22","GPIODV_23";	//B2~B7
+			amlogic,enable-output=<1>;
+        };
+        
+//$$ MATCH "Audio_pin_0_match" = "&audio_pins"
+//$$ L2 PROP_U32 4 = "amlogic,setmask"
+//$$ L2 PROP_U32 10 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"
+		audio_pins:audio_pin{
+				amlogic,setmask=<10 0x78000000 1 0x20>;
+				amlogic,clrmask=<4 0x1000000 3 0x8000 9 0x80>;
+				amlogic,pins = "GPIOAO_8","GPIOAO_9","GPIOAO_10","GPIOAO_11","GPIOY_5";
+		};
+	};
+
+}; /* end of / */
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index b56d3b22efd5..9aff20a8c25b 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -189,6 +189,8 @@ CONFIG_LIGHT_STK220X=y
 CONFIG_LIGHT_LTR558=y
 CONFIG_AML_GPIO_KEY=y
 CONFIG_RICOH_PMU=y
+CONFIG_AML_PMU=y
+CONFIG_AML1216=y
 CONFIG_SECURITYKEY=y
 CONFIG_EFUSE=y
 CONFIG_AMLOGIC_THERMAL=y
diff --git a/drivers/amlogic/power/aml_pmu/Kconfig b/drivers/amlogic/power/aml_pmu/Kconfig
index 596504b414d1..7a89d7448b2e 100755
--- a/drivers/amlogic/power/aml_pmu/Kconfig
+++ b/drivers/amlogic/power/aml_pmu/Kconfig
@@ -1,5 +1,6 @@
 menuconfig AML_PMU
     bool    "Amlogic PMU drivers"
+    depends on AMLOGIC_BOARD_HAS_PMU
     select  I2C
     select  REGULATOR
     default n
@@ -9,12 +10,19 @@ if AML_PMU
 choice 
     prompt "AML PMU type"
     default AML1212
+
 config AML1212
     bool "AML1212 driver"
     select AML_PMU_ALGORITHM_SUPPORT
     ---help---
         drivers for AML1212
 
+config AML1216
+    bool "AML1216 driver"
+    select AML_PMU_ALGORITHM_SUPPORT
+    ---help---
+        drivers for amlogic pmu AML1216 
+
 endchoice
 
 endif #AML_PMU
diff --git a/drivers/amlogic/power/aml_pmu/Makefile b/drivers/amlogic/power/aml_pmu/Makefile
index 8d5adcd935bb..45b03611424a 100755
--- a/drivers/amlogic/power/aml_pmu/Makefile
+++ b/drivers/amlogic/power/aml_pmu/Makefile
@@ -1,3 +1,4 @@
 obj-y += aml_pmu.o
 obj-$(CONFIG_AML1212) += aml1212-sply.o
+obj-$(CONFIG_AML1216) += aml1216-sply.o aml1216-rw.o
 
diff --git a/drivers/amlogic/power/aml_pmu/aml1216-rw.c b/drivers/amlogic/power/aml_pmu/aml1216-rw.c
new file mode 100755
index 000000000000..96047b7a4a38
--- /dev/null
+++ b/drivers/amlogic/power/aml_pmu/aml1216-rw.c
@@ -0,0 +1,339 @@
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/utsname.h>
+#include <linux/i2c.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <mach/am_regs.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/aml_rtc.h>
+#include <linux/amlogic/aml_pmu.h>
+
+#define MAX_BUF         100
+#define CHECK_DRIVER()      \
+    if (!g_aml1216_client) {        \
+        AML_DBG("driver is not ready right now, wait...\n");   \
+        dump_stack();       \
+        return -ENODEV;     \
+    }
+
+int aml1216_write(int32_t add, uint8_t val)
+{
+    int ret;
+    uint8_t buf[3] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1216_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g_aml1216_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    buf[2] = val & 0xff;
+    ret = i2c_transfer(pdev->adapter, msg, 1);
+    if (ret < 0) {
+        AML_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_write);
+
+int aml1216_write16(int32_t add, uint16_t val)
+{
+    int ret;
+    uint8_t buf[4] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1216_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g_aml1216_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    buf[2] = val & 0xff;
+    buf[3] = (val >> 8) & 0xff;
+    ret = i2c_transfer(pdev->adapter, msg, 1);
+    if (ret < 0) {
+        AML_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_write16);
+
+int aml1216_writes(int32_t add, uint8_t *buff, int len)
+{
+    int ret;
+    uint8_t buf[MAX_BUF] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1216_ADDR,
+            .flags = 0,
+            .len   = len + 2,
+            .buf   = buf,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g_aml1216_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    memcpy(buf + 2, buff, len > MAX_BUF ? MAX_BUF : len);
+    ret = i2c_transfer(pdev->adapter, msg, 1);
+    if (ret < 0) {
+        AML_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_writes);
+
+int aml1216_read(int add, uint8_t *val)
+{
+    int ret;
+    uint8_t buf[2] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1216_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },
+        {
+            .addr  = AML1216_ADDR,
+            .flags = I2C_M_RD,
+            .len   = 1,
+            .buf   = val,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g_aml1216_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    ret = i2c_transfer(pdev->adapter, msg, 2);
+    if (ret < 0) {
+        AML_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_read);
+
+int aml1216_read16(int add, uint16_t *val)
+{
+    int ret;
+    uint8_t buf[2] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1216_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },
+        {
+            .addr  = AML1216_ADDR,
+            .flags = I2C_M_RD,
+            .len   = 2, 
+            .buf   = (uint8_t *)val,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g_aml1216_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    ret = i2c_transfer(pdev->adapter, msg, 2);
+    if (ret < 0) {
+        AML_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_read16);
+
+int aml1216_reads(int add, uint8_t *buff, int len)
+{
+    int ret;
+    uint8_t buf[2] = {};
+    struct i2c_client *pdev;
+    struct i2c_msg msg[] = {
+        {
+            .addr  = AML1216_ADDR,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },
+        {
+            .addr  = AML1216_ADDR,
+            .flags = I2C_M_RD,
+            .len   = len,
+            .buf   = buff,
+        }
+    };
+
+    CHECK_DRIVER();
+    pdev = to_i2c_client(g_aml1216_supply->master);
+
+    buf[0] = add & 0xff;
+    buf[1] = (add >> 8) & 0x0f;
+    ret = i2c_transfer(pdev->adapter, msg, 2);
+    if (ret < 0) {
+        AML_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        return ret;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_reads);
+
+int aml1216_set_bits(int addr, uint8_t bits, uint8_t mask)
+{
+    uint8_t val; 
+    int ret; 
+ 
+    ret = aml1216_read(addr, &val); 
+    if (ret) { 
+        return ret; 
+    } 
+    val &= ~(mask); 
+    val |=  (bits & mask); 
+    return aml1216_write(addr, val); 
+} 
+EXPORT_SYMBOL_GPL(aml1216_set_bits); 
+
+static int find_idx(uint32_t start, uint32_t target, uint32_t step, int size)
+{
+    int i = 0; 
+
+    if (start >= target) {
+        AML_DBG("%s, invalid input of voltage:%u\n", __func__, target);    
+        return -1;
+    }
+    do { 
+        if (start >= target) {
+            break;    
+        }    
+        start += step;
+        i++; 
+    } while (i < size);
+    if (i >= size) {
+        AML_DBG("%s, input voltage %u outof range\n", __func__, target);    
+        return -1;
+    }
+
+    return i;
+}
+
+int aml1216_set_dcdc_voltage(int dcdc, uint32_t voltage)
+{
+    int addr;
+    int idx_to;
+    int range    = 64; 
+    int step     = 19 * 1000; 
+    int start    = 700 * 1000;
+    int bit_mask = 0x3f;
+    int idx_cur;
+    int val;
+    static uint8_t dcdc_val[3] = {};
+
+    if (dcdc > 3 || dcdc < 0) {
+        return -1;    
+    }   
+    addr = 0x34+(dcdc-1)*9;
+    if (dcdc == 3) {
+        step     = 50 * 1000; 
+        range    = 64; 
+        start    = 2050 * 1000;
+        bit_mask = 0x1f;
+    }   
+    if (dcdc_val[dcdc] == 0) {
+        aml1216_read(addr, &val);                               // read first time
+    } else {
+        val = dcdc_val[dcdc];
+    }
+    idx_to   = find_idx(start, voltage, step, range);
+    idx_to  ^= bit_mask;
+    idx_cur  = val >> 2;
+    while (idx_cur != idx_to) {
+        if (idx_cur < idx_to) {                                 // adjust to target voltage step by step
+            idx_cur++;    
+        } else {
+            idx_cur--;
+        }
+        val &= ~0xfc;
+        val |= (idx_cur << 2);
+        aml1216_write(addr, val);
+        udelay(50);                                             // atleast delay 100uS
+    }
+    dcdc_val[dcdc] = val;
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_set_dcdc_voltage);
+
+int aml1216_get_dcdc_voltage(int dcdc, uint32_t *uV)
+{
+    int addr;
+    uint8_t val;
+    int ret;
+    int step  = 25000;
+
+    if (dcdc > 3 || dcdc < 0) {
+        return -EINVAL;    
+    }
+
+    addr = 0x34+(dcdc-1)*9;
+    
+    ret = aml1216_read(addr, &val);
+    if (ret) {
+        return ret;    
+    }
+    if (dcdc == 3)
+    {
+        *uV = (1450 * 1000 + val * 50000); //step: 50 mv
+       
+    }
+    else
+    {
+        *uV = (680 * 1000 + val * 20000); //step: 20 mv
+    }
+    
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_get_dcdc_voltage);
diff --git a/drivers/amlogic/power/aml_pmu/aml1216-sply.c b/drivers/amlogic/power/aml_pmu/aml1216-sply.c
new file mode 100755
index 000000000000..c528f9e4e579
--- /dev/null
+++ b/drivers/amlogic/power/aml_pmu/aml1216-sply.c
@@ -0,0 +1,1572 @@
+/*
+ * Implement driver of AML1216 PMU
+ * Author: chunjian.zheng@amlogic.com
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/utsname.h>
+#include <linux/i2c.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <mach/am_regs.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/aml_rtc.h>
+#include <linux/amlogic/aml_pmu.h>
+#include <mach/usbclock.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#ifdef CONFIG_UBOOT_BATTERY_PARAMETERS
+#include <linux/amlogic/battery_parameter.h>
+#endif
+
+#define CHECK_DRIVER()      \
+    if (!g_aml1216_supply) {        \
+        AML_DBG("driver is not ready right now, wait...\n");   \
+        dump_stack();       \
+        return -ENODEV;     \
+    }
+
+#define POWER_OK_THRESHOLD      4500
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend aml1216_early_suspend;
+#endif
+struct aml1216_supply           *g_aml1216_supply  = NULL;
+struct amlogic_pmu_init         *g_aml1216_init    = NULL;
+struct battery_parameter        *aml1216_battery   = NULL;
+struct input_dev                *aml1216_power_key = NULL;
+
+static int power_protection   = 0;
+static int over_discharge_cnt = 0;
+static int battery_pre_state  = 0;
+static int battery_state      = 0;
+static int adc_sign_bit       = 0; 
+#define BATTERY_CHARGING      1
+#define BATTERY_DISCHARGING   0
+
+
+#ifdef CONFIG_AMLOGIC_USB
+struct work_struct          aml1216_otg_work;
+extern int dwc_otg_power_register_notifier(struct notifier_block *nb);
+extern int dwc_otg_power_unregister_notifier(struct notifier_block *nb);
+extern int dwc_otg_charger_detect_register_notifier(struct notifier_block *nb);
+extern int dwc_otg_charger_detect_unregister_notifier(struct notifier_block *nb);
+#endif
+
+static int aml1216_update_state(struct aml_charger *charger);
+
+uint32_t charge_timeout = 0;
+int      re_charge_cnt  = 0;
+int      current_dir    = -1;
+int      power_flag     = 0;
+int      pmu_version    = 0;
+int      chg_status_reg  = 0;
+
+int aml1216_get_battery_voltage(void)
+{
+    uint8_t val[2] = {};
+    int result = 0;
+    int tmp;
+    
+    aml1216_reads(0x00AF, val, 2);        
+    tmp = (((val[1] & 0x1f) << 8) + val[0]);
+    result = (tmp * 4800) / 4096;
+    
+    return result;
+}
+EXPORT_SYMBOL_GPL(aml1216_get_battery_voltage);
+
+int aml1216_get_dcin_voltage(void)
+{
+    uint8_t val[2] = {};
+    int     result;
+
+    aml1216_write(0x00AA, 0xC1);                            // select DCIN channel
+    aml1216_write(0x009A, 0x28);
+    udelay(100);
+    aml1216_reads(0x00B1, val, 2);
+    result = ((val[1] & 0x1f) << 8) + val[0];
+    if (result & 0x1000) {                                  // complement code
+        result = 0;                                         // avoid ADC offset 
+    } else {
+        result = (result * 12800) / 4096;
+    }
+
+    return result;
+}
+
+int aml1216_get_vbus_voltage(void)
+{
+    uint8_t val[2] = {};
+    int     result;
+
+    aml1216_write(0x00AA, 0xC2);                            // select VBUS channel
+    aml1216_write(0x009A, 0x28);
+    udelay(100);
+    aml1216_reads(0x00B1, val, 2);
+    result = ((val[1] & 0x1f) << 8) + val[0];
+    if (result & 0x1000) {                                  // complement code
+        result = 0;                                         // avoid ADC offset 
+    } else {
+        result = result * 6400 / 4096;
+    }
+
+    return result;
+}
+
+int aml1216_get_battery_current(void)
+{
+    uint8_t  buf[2] = {};
+    uint32_t tmp;
+    int      sign_bit, result;
+
+    aml1216_reads(0x00AB, buf, 2);
+    tmp = ((buf[1] & 0x1f) << 8) + buf[0];
+    sign_bit = tmp & 0x1000;
+    adc_sign_bit = sign_bit;
+
+    if (tmp & 0x1000) {                                              // complement code
+        tmp = (tmp ^ 0x1fff) + 1;
+    }
+    result = (tmp * 5333) / 4096; 
+    return result;
+}
+EXPORT_SYMBOL_GPL(aml1216_get_battery_current);
+
+int aml1216_set_dcin(int enable)
+{
+    uint8_t val = 0;
+
+    if (!enable) {
+        val |= 0x01;
+    }
+    AML_DBG("%s:%s\n", __func__, enable ? "enable" : "disable");
+
+    return aml1216_set_bits(0x002a, val, 0x01);
+}
+EXPORT_SYMBOL_GPL(aml1216_set_dcin);
+
+int aml1216_set_gpio(int pin, int val)
+{
+    uint32_t data;
+
+    if (pin <= 0 || pin > 3 || val > 1 || val < 0) { 
+        AML_DBG("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
+        return -1;
+    }    
+    if (val < 2) { 
+        data = ((val ? 1 : 0) << (pin));
+    } else {
+        AML_DBG("%s, not support value for 1216:%d\n", __func__, val);
+        return -1;
+    }    
+    AML_DBG("%s, GPIO:%d, val:%d\n", __func__, pin, val);
+    return aml1216_set_bits(0x0013, data, (1 << pin));
+}
+EXPORT_SYMBOL_GPL(aml1216_set_gpio);
+
+int aml1216_get_gpio(int gpio, int *val)
+{
+    int ret;
+    uint8_t data;
+
+    if (gpio <= 0 || gpio> 4 || !val) { 
+        AML_DBG("ERROR, invalid input value, gpio = %d, val= %p\n", gpio, val);
+        return -EINVAL;
+    }
+    ret = aml1216_read(AML1216_GPIO_INPUT_STATUS, &data);
+    if (ret) {                                                  // read failed
+        return ret;    
+    }
+    if (data & (1 << (gpio - 1))) {
+        *val = 1;    
+    } else {
+        *val = 0;    
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_get_gpio);
+
+void aml1216_power_off()
+{
+    uint8_t buf = (1 << 5);                                     // software goto OFF state
+
+    aml1216_set_gpio(1, 1);
+    aml1216_set_gpio(2, 1);
+    aml1216_set_gpio(3, 1);
+    AML_DBG("software goto OFF state\n");
+    mdelay(10);
+    aml1216_write(AML1216_GEN_CNTL1, buf);    
+    udelay(1000);
+    while (1) {
+        msleep(1000);
+        AML_DBG("%s, error\n", __func__);
+    }
+}
+EXPORT_SYMBOL_GPL(aml1216_power_off);
+
+int aml1216_set_usb_current_limit(int limit)
+{
+    int val;
+    if ((limit < 0 || limit > 2000) && (limit != -1)) {
+       AML_DBG("%s, wrong usb current limit:%d\n", __func__, limit); 
+       return -1;
+    }
+    if (limit == -1) {                                       // -1 means not limit, so set limit to max
+        limit = 2000;    
+    }
+    val = (limit-500)/ 100;
+    
+    AML_DBG("%s, set usb current limit to %d\n", __func__, limit);
+    return aml1216_set_bits(0x002D, val, 0x0f);
+    
+}
+EXPORT_SYMBOL_GPL(aml1216_set_usb_current_limit);
+
+int aml1216_set_usb_voltage_limit(int voltage)
+{
+    uint8_t val;
+
+    if (voltage > 4600 || voltage < 4300) {
+        AML_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
+    }
+    aml1216_read(AML1216_CHG_CTRL5, &val);
+    val &= ~(0xc0);
+    switch (voltage) {
+    case 4300:
+        val |= (0x01 << 6);
+        break;
+
+    case 4400:
+        val |= (0x02 << 6);
+        break;
+
+    case 4500:
+        val |= (0x00 << 6);
+        break;
+
+    case 4600:
+        val |= (0x03 << 6);
+        break;
+    
+    default:
+        AML_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
+        return -1;
+    }
+    aml1216_write(AML1216_CHG_CTRL5, val);
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_set_usb_voltage_limit);
+
+int aml1216_set_charge_enable(int enable)
+{
+    return aml1216_set_bits(0x0017, ((enable & 0x01)), 0x01); 
+}
+EXPORT_SYMBOL_GPL(aml1216_set_charge_enable);
+
+int aml1216_set_recharge_voltage(void)
+{
+    return aml1216_set_bits(0x012c, 0x04, 0x0c);
+}
+EXPORT_SYMBOL_GPL(aml1216_set_recharge_voltage);
+
+
+int aml1216_set_charging_current(int curr)
+{
+    int idx_cur, idx_to, val = 0;
+
+    if (curr > 2100 * 1000 || curr < 0) {
+        AML_DBG("%s, wrong input of charge current:%d\n", __func__, curr);
+        return -1;
+    }
+    if (curr > 100) {                        // input is uA
+        curr = curr / 1000;
+    } else {                                    // input is charge ratio
+        curr = (curr * aml1216_battery->pmu_battery_cap) / 100 + 100; 
+    } 
+    if (curr > 1050) {                       // limit current to 1050mA 
+        curr = 1050;    
+    }
+    idx_to = (curr - 300) / 150;
+    aml1216_read(0x012b, &val);
+    AML_DBG("%s to %dmA, idx_to:%x, idx_cur:%x\n", __func__, idx_to * 150 + 300, idx_to, val);
+    idx_cur = val & 0x0f;
+
+    while (idx_cur != idx_to) {
+        if (idx_cur < idx_to) {
+            idx_cur++;    
+        } else {
+            idx_cur--;    
+        }
+        val &= ~0x0f;
+        val |= (idx_cur & 0x0f);
+        aml1216_write(0x012b, val);
+        udelay(100);
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_set_charging_current);
+
+int aml1216_set_trickle_time(int minutes)
+{
+    int bits;
+
+    if (minutes < 30 && minutes > 80) {
+        AML_DBG("%s, invalid trickle time:%d\n", __func__, minutes);
+        return -EINVAL;
+    }
+    switch (minutes) {
+    case 30:     bits = 0x04;     break;
+    case 50:     bits = 0x08;     break;
+    case 80:     bits = 0x0c;     break;
+    default:
+        AML_DBG("%s, unsupported trickle value:%d\n", __func__, minutes);
+        return -EINVAL;
+    }
+    return aml1216_set_bits(0x012A, bits, 0x0c);
+}
+
+int aml1216_set_rapid_time(int minutes)
+{
+    int bits;
+
+    if (minutes > 360 || minutes < 720) {
+        AML_DBG("%s, invalid rapid time:%d\n", __func__, minutes);
+        return -EINVAL;
+    }
+    switch (minutes) {
+    case 360:     bits = 0x04;     break;
+    case 540:     bits = 0x08;     break;
+    case 720:     bits = 0x0c;     break;
+    default:
+        AML_DBG("%s, unsupported rapid value:%d\n", __func__, minutes);
+        return -EINVAL;
+    }
+    return aml1216_set_bits(0x0129, bits, 0x0c);
+}
+
+int aml1216_set_full_charge_voltage(int voltage)
+{
+    uint8_t val;
+    uint8_t tmp;
+    
+    if (voltage > 4400000 || voltage < 4050000) {
+        AML_DBG("%s,Wrong charge voltage:%d\n", __func__, voltage);
+        return -1;
+    }
+    tmp = ((voltage - 4050000) / 50000);
+    aml1216_read(AML1216_CHG_CTRL0, &val);
+    val &= ~(0x38);
+    val |= (tmp << 3);
+    aml1216_write(AML1216_CHG_CTRL0, val);
+
+    return 0; 
+}
+
+int aml1216_set_charge_end_rate(int rate) 
+{
+    uint8_t val;
+
+#if 1
+    aml1216_read(AML1216_CHG_CTRL6, &val);
+    switch (rate) {
+    case 10:
+        val &= ~(0x01 << 3);
+        break;
+
+    case 20:
+        val |= (0x01 << 3);
+        break;
+
+    default:
+        AML_DBG("%s, Wrong charge end rate:%d\n", __func__, rate);
+        return -1;
+    }
+    aml1216_write(AML1216_CHG_CTRL6, val);
+#endif
+    return 0;
+}
+EXPORT_SYMBOL_GPL(aml1216_set_charge_end_rate);
+
+int aml1216_set_long_press_time(int ms)
+{   
+    uint16_t  val;
+    uint16_t tmp;
+     
+    aml1216_read16(0x90, &val);
+    tmp = ms/100 -1; 
+    val |= tmp;                                        // set power key long press to 10s
+    return aml1216_set_bits(0x0090, val, 0x7f);
+}
+
+static int aml1216_get_coulomber(struct aml_charger *charger)
+{
+    uint8_t buf[8]= {};
+    int ret;
+    int charge_result;
+    int discharge_result;
+
+    ret = aml1216_reads(0x0152, buf, 4);
+    if (ret) {
+        AML_DBG("%s, failed: %d\n", __func__, __LINE__);
+        return ret;
+    }
+
+    /*
+     * Convert to mAh:
+     * 8ms per SAR ADC result accumulator, 125 add per second
+     * LSB is 5333 / 4096, an hour is 3600 second
+     * register value is 32MSB of 48bit register value.
+     * coulomb = (65536 * [register vaule] * 5333 / 4096) / (3600 * 125)
+     *         = 0.1896178 * [register vaule]
+     *         = (97.084302 / 512) * [register vaule]
+     * if [register vaule] > 2147483630(mAh) = [2^31 / 97]
+     * this simple calculate method ill cause overflow bug due to 32bit 
+     * register range, but fortunately, No battery has capacity large than
+     * this value
+     */
+    charge_result  = (buf[0] <<  0) |
+                     (buf[1] <<  8) |
+                     (buf[2] << 16) |
+                     (buf[3] << 24);
+    charge_result *= -1;                                                // charge current is negative
+    charge_result  = ((charge_result * 97) / 512);                      // convert to mAh
+
+    ret = aml1216_reads(0x0158, buf, 4);
+    if (ret) {
+        AML_DBG("%s, failed: %d\n", __func__, __LINE__);
+        return ret;
+    }
+    discharge_result = (buf[0] <<  0) |
+                       (buf[1] <<  8) |
+                       (buf[2] << 16) |
+                       (buf[3] << 24);
+    discharge_result = (discharge_result * 97) / 512;                   // convert to mAh
+    charger->charge_cc    = charge_result;
+    charger->discharge_cc = discharge_result;
+    return 0;
+}
+
+static int aml1216_clear_coulomber(struct aml_charger *charger)
+{
+    return aml1216_set_bits(0x009A, 0x80, 0x80);    
+}
+
+int aml1216_get_battery_percent(void)
+{
+    CHECK_DRIVER();
+    return g_aml1216_supply->aml_charger.rest_vol;    
+}
+EXPORT_SYMBOL_GPL(aml1216_get_battery_percent);
+
+int aml1216_first_init(struct aml1216_supply *supply)
+{
+    /*
+     * initialize charger from battery parameters
+     */
+    if (aml1216_battery) {
+        aml1216_set_charging_current   (aml1216_battery->pmu_init_chgcur);
+        aml1216_set_full_charge_voltage(aml1216_battery->pmu_init_chgvol);
+        aml1216_set_charge_end_rate    (aml1216_battery->pmu_init_chgend_rate);
+        aml1216_set_trickle_time       (aml1216_battery->pmu_init_chg_pretime);
+        aml1216_set_rapid_time         (aml1216_battery->pmu_init_chg_csttime);
+        aml1216_set_recharge_voltage   ();
+        aml1216_set_long_press_time    (aml1216_battery->pmu_pekoff_time);
+        aml1216_set_charge_enable      (aml1216_battery->pmu_init_chg_enabled);
+
+        if (aml1216_battery->pmu_usbvol_limit) {
+            aml1216_set_usb_voltage_limit(aml1216_battery->pmu_usbvol); 
+        }
+    }
+
+    return 0;
+}
+
+static enum power_supply_property aml1216_battery_props[] = {
+    POWER_SUPPLY_PROP_MODEL_NAME,
+    POWER_SUPPLY_PROP_STATUS,
+    POWER_SUPPLY_PROP_PRESENT,
+    POWER_SUPPLY_PROP_ONLINE,
+    POWER_SUPPLY_PROP_HEALTH,
+    POWER_SUPPLY_PROP_TECHNOLOGY,
+    POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+    POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+    POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_CURRENT_NOW,
+    POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+    POWER_SUPPLY_PROP_CAPACITY,
+    POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property aml1216_ac_props[] = {
+    POWER_SUPPLY_PROP_MODEL_NAME,
+    POWER_SUPPLY_PROP_PRESENT,
+    POWER_SUPPLY_PROP_ONLINE,
+    POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property aml1216_usb_props[] = {
+    POWER_SUPPLY_PROP_MODEL_NAME,
+    POWER_SUPPLY_PROP_PRESENT,
+    POWER_SUPPLY_PROP_ONLINE,
+    POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static void aml1216_battery_check_status(struct aml1216_supply       *supply,
+                                         union  power_supply_propval *val)
+{
+    struct aml_charger *charger = &supply->aml_charger;
+
+    if (!aml1216_battery) {
+        val->intval = POWER_SUPPLY_STATUS_UNKNOWN;                      // for no battery case
+    } else {
+        if (charger->bat_det) {
+            if (charger->ext_valid) {
+                if (charger->rest_vol == 100) {
+                    val->intval = POWER_SUPPLY_STATUS_FULL;
+                } else if (charger->rest_vol == 0 && 
+                           charger->charge_status == CHARGER_DISCHARGING) {   // protect for over-discharging
+                    val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+                } else {
+                    val->intval = POWER_SUPPLY_STATUS_CHARGING;
+                }
+            } else {
+                val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+            }
+        } else {
+            val->intval = POWER_SUPPLY_STATUS_FULL;
+        }
+    }
+}
+
+static void aml1216_battery_check_health(struct aml1216_supply       *supply,
+                                         union  power_supply_propval *val)
+{
+    int status = supply->aml_charger.fault & 0x30;
+
+    if (status == 0x30) {
+        // TODO: add other check method?
+        AML_DBG("%s, battery error detect\n", __func__);
+        val->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+    } else {
+        val->intval = POWER_SUPPLY_HEALTH_GOOD;
+    }
+}
+
+static int aml1216_battery_get_property(struct power_supply *psy,
+                                        enum   power_supply_property psp,
+                                        union  power_supply_propval *val)
+{
+    struct aml1216_supply *supply;
+    struct aml_charger    *charger;
+    int ret = 0;
+    int sign_bit = 1;
+    supply  = container_of(psy, struct aml1216_supply, batt);
+    charger = &supply->aml_charger;
+    
+    switch (psp) {
+    case POWER_SUPPLY_PROP_STATUS:
+        aml1216_battery_check_status(supply, val);
+        break;
+
+    case POWER_SUPPLY_PROP_HEALTH:
+        aml1216_battery_check_health(supply, val);
+        break;
+
+    case POWER_SUPPLY_PROP_TECHNOLOGY:
+        val->intval = supply->battery_info->technology;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+        val->intval = supply->battery_info->voltage_max_design;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+        val->intval = supply->battery_info->voltage_min_design;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        val->intval = charger->vbat * 1000; 
+        break;
+
+    case POWER_SUPPLY_PROP_CURRENT_NOW:             // charging : +, discharging -;
+        if (ABS(charger->ibat) > 20 && charger->charge_status != CHARGER_NONE) {
+            if (charger->charge_status == CHARGER_CHARGING) {
+                sign_bit = 1;    
+            } else if (charger->charge_status == CHARGER_DISCHARGING) {
+                sign_bit = -1;
+            }
+            val->intval = charger->ibat * 1000 * sign_bit; 
+        } else {
+            val->intval = 0;                        // when charge time out, report 0
+        }
+        break;
+
+    case POWER_SUPPLY_PROP_MODEL_NAME:
+        val->strval = supply->batt.name;
+        break;
+
+    case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+        val->intval = supply->battery_info->energy_full_design;
+        break;
+
+    case POWER_SUPPLY_PROP_CAPACITY:
+        if (aml1216_battery) {
+            val->intval = charger->rest_vol;
+        } else {
+            val->intval = 100;    
+        }
+        break;
+
+    case POWER_SUPPLY_PROP_ONLINE:
+        if (aml1216_battery) {
+            val->intval = charger->bat_det; 
+        } else {
+            val->intval = 0;    
+        }
+        break;
+
+    case POWER_SUPPLY_PROP_PRESENT:
+        if (aml1216_battery) {
+            val->intval = charger->bat_det; 
+        } else {
+            val->intval = 0;    
+        }
+        break;
+
+    case POWER_SUPPLY_PROP_TEMP:
+        val->intval = 300; 
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    
+    return ret;
+}
+
+static int aml1216_ac_get_property(struct power_supply *psy,
+                                   enum   power_supply_property psp,
+                                   union  power_supply_propval *val)
+{
+    struct aml1216_supply *supply;
+    struct aml_charger    *charger;
+    int ret = 0;
+    supply  = container_of(psy, struct aml1216_supply, ac);
+    charger = &supply->aml_charger;
+
+    switch(psp){
+    case POWER_SUPPLY_PROP_MODEL_NAME:
+        val->strval = supply->ac.name;
+        break;
+
+    case POWER_SUPPLY_PROP_PRESENT:
+        val->intval = charger->dcin_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_ONLINE:
+        val->intval = charger->dcin_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        val->intval = 5000 * 1000;
+        break;
+
+    case POWER_SUPPLY_PROP_CURRENT_NOW:
+        val->intval = 1000 * 1000;
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static int aml1216_usb_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+    struct aml1216_supply *supply;
+    struct aml_charger    *charger;
+    int ret = 0;
+    supply  = container_of(psy, struct aml1216_supply, usb);
+    charger = &supply->aml_charger;
+    
+    switch(psp){
+    case POWER_SUPPLY_PROP_MODEL_NAME:
+        val->strval = supply->usb.name;
+        break;
+
+    case POWER_SUPPLY_PROP_PRESENT:
+        val->intval = charger->usb_valid;
+        break;
+
+    case POWER_SUPPLY_PROP_ONLINE:
+        val->intval = charger->usb_valid; 
+        break;
+
+    case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+        val->intval = 5000 * 1000;
+        break;
+
+    case POWER_SUPPLY_PROP_CURRENT_NOW:
+        val->intval = 1000 * 1000;      // charger->iusb * 1000;
+        break;
+
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    return ret;
+}
+
+static char *supply_list[] = {
+    "battery",
+};
+
+static void aml1216_battery_setup_psy(struct aml1216_supply *supply)
+{
+    struct power_supply      *batt = &supply->batt;
+    struct power_supply      *ac   = &supply->ac;
+    struct power_supply      *usb  = &supply->usb;
+    struct power_supply_info *info =  supply->battery_info;
+    
+    batt->name           = "battery";
+    batt->use_for_apm    = info->use_for_apm;
+    batt->type           = POWER_SUPPLY_TYPE_BATTERY;
+    batt->get_property   = aml1216_battery_get_property;
+    batt->properties     = aml1216_battery_props;
+    batt->num_properties = ARRAY_SIZE(aml1216_battery_props);
+    
+    ac->name             = "ac";
+    ac->type             = POWER_SUPPLY_TYPE_MAINS;
+    ac->get_property     = aml1216_ac_get_property;
+    ac->supplied_to      = supply_list;
+    ac->num_supplicants  = ARRAY_SIZE(supply_list);
+    ac->properties       = aml1216_ac_props;
+    ac->num_properties   = ARRAY_SIZE(aml1216_ac_props);
+    
+    usb->name            = "usb";
+    usb->type            = POWER_SUPPLY_TYPE_USB;
+    usb->get_property    = aml1216_usb_get_property;
+    usb->supplied_to     = supply_list,
+    usb->num_supplicants = ARRAY_SIZE(supply_list),
+    usb->properties      = aml1216_usb_props;
+    usb->num_properties  = ARRAY_SIZE(aml1216_usb_props);
+}
+
+#ifdef CONFIG_AMLOGIC_USB
+
+static int aml1216_otg_value = -1;
+static void aml1216_otg_work_fun(struct work_struct *work)
+{
+    uint8_t val;
+    if (aml1216_otg_value == -1) {
+        return ;    
+    }
+    AML_DBG("%s, OTG value:%d, is_short:%d\n", __func__, aml1216_otg_value, g_aml1216_init->vbus_dcin_short_connect);
+    if (aml1216_otg_value) {
+        aml1216_write(0x0019, 0xD0); 
+    } else {
+        aml1216_write(0x0019, 0x10); 
+    }
+    msleep(10);
+    aml1216_read(0x19, &val);
+    printk("register 0x19:%02x\n", val);
+    aml1216_otg_value = -1;
+    aml1216_update_state(&g_aml1216_supply->aml_charger);
+    power_supply_changed(&g_aml1216_supply->batt);
+}
+
+static int aml1216_otg_change(struct notifier_block *nb, unsigned long value, void *pdata)
+{
+    aml1216_otg_value = value;
+    schedule_work(&aml1216_otg_work);
+    return 0;
+}
+
+static int aml1216_usb_charger(struct notifier_block *nb, unsigned long value, void *pdata)
+{
+    switch (value) {
+    case USB_BC_MODE_DISCONNECT:                                        // disconnect
+    case USB_BC_MODE_SDP:                                               // pc
+        if (aml1216_battery && aml1216_battery->pmu_usbcur_limit) {     // limit usb current
+            aml1216_set_usb_current_limit(aml1216_battery->pmu_usbcur); 
+        }
+        break;
+
+    case USB_BC_MODE_DCP:                                               // charger
+    case USB_BC_MODE_CDP:                                               // PC + charger
+        if (aml1216_battery) {                                          // limit usb current
+            aml1216_set_usb_current_limit(-1);                          // not limit usb current
+        }
+        break;
+        
+    default:
+        break;
+    }
+    return 0;
+}
+#endif
+
+/*
+ * add for debug 
+ */
+static int printf_usage(void)
+{
+
+    printk(" \n"
+           "usage:\n"
+           "echo [r/w/] [addr] [value] > pmu_reg\n"
+           "Example:\n"
+           "   echo r 0x33 > pmu_reg        ---- read  register 0x33\n"
+           "   echo w 0x33 0xa5 > pmu_reg   ---- write register 0x33 to 0xa5\n"
+           " \n");
+    return 0;
+}
+
+static ssize_t pmu_reg_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return printf_usage(); 
+}
+
+static ssize_t pmu_reg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    int ret;
+    int addr;
+    uint8_t value;
+    char *arg[3] = {}, *para, *buf_work, *p;
+    int i;
+
+    buf_work = kstrdup(buf, GFP_KERNEL);
+    p = buf_work;
+    for (i = 0; i < 3; i++) {
+        para = strsep(&p, " ");
+        if (para == NULL) {
+            break;
+        }
+        arg[i] = para;
+    }
+    if (i < 2 || i > 3) {
+        ret = 1;
+        goto error;
+    }
+    switch (arg[0][0]) {
+    case 'r':
+        addr = simple_strtoul(arg[1], NULL, 16);
+        ret = aml1216_read(addr, &value);
+        if (!ret) {
+            printk("reg[0x%02x] = 0x%02x\n", addr, value);
+        }
+        break;
+
+    case 'w':
+        if (i != 3) {                       // parameter is not enough
+            ret = 1;
+            break;
+        }
+        addr  = simple_strtoul(arg[1], NULL, 16);
+        value = simple_strtoul(arg[2], NULL, 16);
+        ret   = aml1216_write(addr, value);
+        if (!ret) {
+            printk("set reg[0x%02x] to 0x%02x\n", addr, value);
+        }
+        break;
+
+    default:
+        ret = 1;
+        break;
+    }
+error:
+    kfree(buf_work);
+    if (ret == 1) {
+        printf_usage();
+    }
+    return count;
+}
+
+static ssize_t driver_version_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "AML PMU AML1216 driver version is %s, build time:%s\n", 
+                   AML1216_DRIVER_VERSION, init_uts_ns.name.version);
+}
+
+static ssize_t driver_version_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count; 
+}
+
+static ssize_t clear_rtc_mem_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return 0;
+}
+
+static ssize_t clear_rtc_mem_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{ 
+    aml_write_rtc_mem_reg(0, 0);
+    aml1216_power_off();
+    return count; 
+}
+
+void aml1216_dump_all_register(void)
+{
+    uint8_t val[16];
+    int     i;
+    printk("[AML1216] DUMP ALL REGISTERS:\n");
+    for (i = 0; i < 24; i++) {
+        aml1216_reads(i*16, val, 16);
+        printk("0x%03x - %03x: ", i * 16, i * 16 + 15);
+        printk("%02x %02x %02x %02x ",   val[0],  val[1],  val[2],  val[3]);
+        printk("%02x %02x %02x %02x   ", val[4],  val[5],  val[6],  val[7]);
+        printk("%02x %02x %02x %02x ",   val[8],  val[9],  val[10], val[11]);
+        printk("%02x %02x %02x %02x\n",  val[12], val[13], val[14], val[15]);
+    }
+}
+
+static ssize_t dump_pmu_regs_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    aml1216_dump_all_register();
+    return sprintf(buf, "[AML1216] DUMP ALL REGISTERS OVER!\n"); 
+}
+static ssize_t dump_pmu_regs_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;                                           /* nothing to do        */
+}
+
+static ssize_t dbg_info_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct power_supply   *battery = dev_get_drvdata(dev);
+    struct aml1216_supply *supply = container_of(battery, struct aml1216_supply, batt); 
+    int size;
+
+    size = aml_pmu_format_dbg_buffer(&supply->aml_charger, buf);
+
+    return size;
+}
+
+static ssize_t dbg_info_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;                                           /* nothing to do        */
+}
+
+static ssize_t battery_para_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct power_supply   *battery = dev_get_drvdata(dev);
+    struct aml1216_supply *supply  = container_of(battery, struct aml1216_supply, batt); 
+    struct aml_charger    *charger = &supply->aml_charger;
+    int i = 0; 
+    int size;
+
+    if (!aml1216_battery) {
+        return sprintf(buf, "No battery parameter find\n");
+    }
+    size = sprintf(buf, "\n i,      ocv,    charge,  discharge,\n");
+    for (i = 0; i < 16; i++) {
+        size += sprintf(buf + size, "%2d,     %4d,       %3d,        %3d,\n",
+                        i, 
+                        aml1216_battery->pmu_bat_curve[i].ocv,
+                        aml1216_battery->pmu_bat_curve[i].charge_percent,
+                        aml1216_battery->pmu_bat_curve[i].discharge_percent);
+    }
+    size += sprintf(buf + size, "\nBattery capability:%4d@3700mAh, RDC:%3d mohm\n", 
+                                aml1216_battery->pmu_battery_cap, 
+                                aml1216_battery->pmu_battery_rdc);
+    size += sprintf(buf + size, "Charging efficiency:%3d%%, capability now:%3d%%\n", 
+                                aml1216_battery->pmu_charge_efficiency,
+                                charger->rest_vol);
+    size += sprintf(buf + size, "ocv_empty:%4d, ocv_full:%4d\n\n",
+                                charger->ocv_empty, 
+                                charger->ocv_full);
+    return size;
+}
+
+static ssize_t battery_para_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;                                           /* nothing to do        */    
+}
+
+static ssize_t report_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "report_delay = %d\n", aml_pmu_get_report_delay()); 
+}
+
+static ssize_t report_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    uint32_t tmp = simple_strtoul(buf, NULL, 10);
+
+    if (tmp > 200) {
+        AML_DBG("input too large, failed to set report_delay\n");    
+        return count;
+    }
+    aml_pmu_set_report_delay(tmp);
+    return count;
+}
+
+static struct device_attribute aml1216_supply_attrs[] = {
+    AML_ATTR(pmu_reg),
+    AML_ATTR(dbg_info),
+    AML_ATTR(battery_para),
+    AML_ATTR(report_delay),
+    AML_ATTR(driver_version),
+    AML_ATTR(clear_rtc_mem),
+    AML_ATTR(dump_pmu_regs),
+};
+
+int aml1216_supply_create_attrs(struct power_supply *psy)
+{
+    int j,ret;
+    for (j = 0; j < ARRAY_SIZE(aml1216_supply_attrs); j++) {
+        ret = device_create_file(psy->dev, &aml1216_supply_attrs[j]);
+        if (ret)
+            goto sysfs_failed;
+    }
+    goto succeed;
+
+sysfs_failed:
+    while (j--) {
+        device_remove_file(psy->dev, &aml1216_supply_attrs[j]);
+    }
+succeed:
+    return ret;
+}
+
+int aml1216_cal_ocv(int ibat, int vbat, int dir)
+{
+    int result;
+
+    if (dir == CHARGER_CHARGING && aml1216_battery) {           // charging
+        result = vbat - (ibat * aml1216_battery->pmu_battery_rdc) / 1000;
+    } else if (dir == CHARGER_DISCHARGING && aml1216_battery) { // discharging
+        result = vbat + (ibat * aml1216_battery->pmu_battery_rdc) / 1000;    
+    } else {
+        result = vbat;    
+    }
+    return result;
+}
+
+static int aml1216_update_state(struct aml_charger *charger)
+{
+#if 0
+    uint8_t buff[5] = {};
+    static int chg_gat_bat_lv = 0;
+
+    aml1216_reads(AML1216_SP_CHARGER_STATUS0, buff, sizeof(buff));
+
+    if (!(buff[3] & 0x02)) {                                            // CHG_GAT_BAT_LV = 0, discharging
+        aml1216_charger->bat_current_direction = 2; 
+        current_dir = 0;
+    } else if ((buff[3] & 0x02) && (buff[2] & 0x04)) {
+        aml1216_charger->bat_current_direction = 1;                             // charging
+        current_dir = 1;
+    } else {
+        aml1216_charger->bat_current_direction = 3;                             // Not charging 
+        current_dir = 2;
+    }
+    charger->bat_det                = 1;                                // do not check register 0xdf, bug here
+    aml1216_charger->ac_det   = buff[2] & 0x10 ? 1 : 0;
+    aml1216_charger->usb_det               = buff[2] & 0x08 ? 1 : 0;
+    charger->ext_valid              = buff[2] & 0x18;                   // to differ USB / AC status update 
+
+    chg_status_reg = (buff[0] <<  0) | (buff[1] <<  8) |
+                     (buff[2] << 16) | (buff[3] << 24);
+    if ((!(buff[3] & 0x02)) && !chg_gat_bat_lv) {                       // according David Wang
+        AML_DBG("CHG_GAT_BAT_LV is 0, limit usb current to 500mA\n");
+        aml1216_set_usb_current_limit(500); 
+        chg_gat_bat_lv = 1;
+    } else if (buff[3] & 0x02 && chg_gat_bat_lv) {
+        chg_gat_bat_lv = 0;    
+        if (aml1216_charger->usb_connect_type == USB_BC_MODE_DCP || 
+            aml1216_charger->usb_connect_type == USB_BC_MODE_CDP) {             // reset to 900 when enough current supply
+            aml1216_set_usb_current_limit(900);    
+            AML_DBG("CHG_GAT_BAT_LV is 1, limit usb current to 900mA\n");
+        }
+    }
+    if (buff[1] & 0x40) {                                               // charge timeout detect
+        AML_DBG("Charge timeout deteceted\n");
+        if ((aml1216_charger->charge_timeout_retry) &&
+            (aml1216_charger->charge_timeout_retry > re_charge_cnt)) {
+            re_charge_cnt++;
+            AML_DBG("reset charger due to charge timeout occured, ocv :%d, retry:%d\n", 
+                        charger->ocv, re_charge_cnt);
+            aml1216_set_fastcharge_time(360);                           // only retry charge 6 hours, for safe problem
+            aml1216_set_charge_enable(0);
+            msleep(1000);
+            aml1216_set_charge_enable(1);
+        }
+        charge_timeout = 1;
+    } else {
+        charge_timeout = 0;    
+    }
+    if (charger->ext_valid && !(power_flag & 0x01)) {                   // enable charger when detect extern power
+        power_flag |=  0x01;                                            // remember enabled charger 
+        power_flag &= ~0x02;
+    } else if (!charger->ext_valid && !(power_flag & 0x02)) {
+        re_charge_cnt = 0;
+        aml1216_set_fastcharge_time(aml1216_battery->pmu_init_chg_csttime);
+        power_flag |=  0x02;                                            // remember disabled charger
+        power_flag &= ~0x01;
+    }
+    if (!charger->ext_valid && aml1216_charger->vbus_dcin_short_connect) {
+        aml1216_set_dcin(0);                                            // disable DCIN when no extern power
+    }
+#else
+    int dcin_vol, vbus_vol;
+
+    charger->ibat = aml1216_get_battery_current();
+    dcin_vol = aml1216_get_dcin_voltage();
+    vbus_vol = aml1216_get_vbus_voltage();
+    if ((dcin_vol >= POWER_OK_THRESHOLD) || 
+        (vbus_vol >= POWER_OK_THRESHOLD)) {
+        if (charger->ibat >= 20) {
+            charger->charge_status = CHARGER_CHARGING;                  // charging
+        } else {
+            charger->charge_status = CHARGER_NONE;                      // Not charging 
+        } 
+    } else {
+        charger->charge_status = CHARGER_DISCHARGING; 
+    }
+    charger->bat_det    = 1;                                            // do not check register 0xdf, bug here
+    charger->dcin_valid = (dcin_vol >= POWER_OK_THRESHOLD) ? 1 : 0; 
+    charger->usb_valid  = (vbus_vol >= POWER_OK_THRESHOLD) ? 1 : 0; 
+    charger->ext_valid  = charger->dcin_valid | (charger->usb_valid << 1); 
+
+    charger->vbat = aml1216_get_battery_voltage();
+    charger->ocv  = aml1216_cal_ocv(charger->ibat, charger->vbat, charger->charge_status);
+
+    battery_pre_state = battery_state;
+
+    if (charger->ext_valid ==1 )
+    {
+        if ( (charger->ibat > 20) && (adc_sign_bit == 1 ) ) 
+        {
+            battery_state = BATTERY_CHARGING;
+        }
+        else
+        {
+            battery_state = BATTERY_DISCHARGING;
+        }
+
+        if( battery_pre_state != battery_state)
+        {
+            if (battery_state == BATTERY_CHARGING)
+            {
+                aml1216_set_charge_enable(0);
+                msleep(1000);
+                aml1216_set_charge_enable(1);               
+            }
+        }
+
+    }
+
+
+#endif
+    return 0;
+}
+
+static void aml1216_charging_monitor(struct work_struct *work)
+{
+    struct   aml1216_supply *supply;
+    struct   aml_charger    *charger;
+    int32_t pre_rest_cap;
+    uint8_t pre_chg_status;
+    uint8_t  pre_pwr_status;
+
+    supply  = container_of(work, struct aml1216_supply, work.work);
+    charger = &supply->aml_charger;
+    pre_pwr_status = charger->ext_valid;
+    pre_chg_status = charger->charge_status;
+    pre_rest_cap   = charger->rest_vol;
+
+    /*
+     * 1. update status of PMU and all ADC value
+     * 2. read ocv value and calculate ocv percent of battery
+     * 3. read coulomb value and calculate movement of energy
+     * 4. if battery capacity is larger than 429496 mAh, will cause over flow
+     */
+    if (aml1216_battery) {
+        aml_pmu_update_battery_capacity(charger, aml1216_battery);
+    } else {
+        aml1216_update_state(charger);
+    }
+    /*
+     * protection for over-discharge with large loading usage
+     */
+    if (charger->rest_vol <= 0 && 
+        charger->ext_valid     && 
+        charger->charge_status == CHARGER_DISCHARGING) {
+        over_discharge_cnt++;
+        if (over_discharge_cnt >= 5) {
+            AML_DBG("%s, battery is over-discharge now, force system power off\n", __func__);
+            power_protection = 1;
+        }
+    } else {
+        over_discharge_cnt = 0; 
+        power_protection   = 0;
+    }
+    if ((charger->rest_vol - pre_rest_cap)         || 
+        (pre_pwr_status != charger->ext_valid)     || 
+        (pre_chg_status != charger->charge_status) ||
+        charger->resume                            ||
+        power_protection) {
+        AML_DBG("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
+        if (unlikely(charger->resume)) {
+            charger->resume = 0;                                        // MUST clear this flag
+        }
+        power_supply_changed(&supply->batt);
+    } 
+    /* reschedule for the next time */
+    schedule_delayed_work(&supply->work, supply->interval);
+}
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+static int early_power_status = 0;
+
+static void aml1216_earlysuspend(struct early_suspend *h)
+{
+    struct aml1216_supply *supply = (struct aml1216_supply *)h->param;
+    if (aml1216_battery) {
+        aml1216_set_charging_current(aml1216_battery->pmu_suspend_chgcur);
+        early_power_status = supply->aml_charger.ext_valid; 
+    }
+}
+
+static void aml1216_lateresume(struct early_suspend *h)
+{
+    struct  aml1216_supply *supply = (struct aml1216_supply *)h->param;
+
+    schedule_work(&supply->work.work);                                      // update for upper layer 
+    if (aml1216_battery) {
+        aml1216_set_charging_current(aml1216_battery->pmu_resume_chgcur);
+        early_power_status = supply->aml_charger.ext_valid; 
+        input_report_key(aml1216_power_key, KEY_POWER, 0);                  // cancel power key 
+        input_sync(aml1216_power_key);
+    }
+}
+#endif
+
+irqreturn_t aml1216_irq_handler(int irq, void *dev_id)
+{
+    struct   aml1216_supply *supply = (struct aml1216_supply *)dev_id;
+
+    disable_irq_nosync(supply->irq);
+    schedule_work(&supply->irq_work);
+
+    return IRQ_HANDLED;
+}
+
+static void aml1216_irq_work_func(struct work_struct *work)
+{
+    struct aml1216_supply *supply = container_of(work, struct aml1216_supply, irq_work);
+
+    //TODO: add code here
+    enable_irq(supply->irq);
+}
+
+struct aml_pmu_driver aml1216_pmu_driver = {
+    .name                      = "aml1216",
+    .pmu_get_coulomb           = aml1216_get_coulomber, 
+    .pmu_clear_coulomb         = aml1216_clear_coulomber,
+    .pmu_update_status         = aml1216_update_state,
+    .pmu_set_rdc               = NULL,
+    .pmu_set_gpio              = aml1216_set_gpio,
+    .pmu_get_gpio              = aml1216_get_gpio,
+    .pmu_reg_read              = aml1216_read,
+    .pmu_reg_write             = aml1216_write,
+    .pmu_reg_reads             = aml1216_reads,
+    .pmu_reg_writes            = aml1216_writes,
+    .pmu_set_bits              = aml1216_set_bits,
+    .pmu_set_usb_current_limit = aml1216_set_usb_current_limit,
+    .pmu_set_charge_current    = aml1216_set_charging_current,
+    .pmu_power_off             = aml1216_power_off,
+};
+
+static int aml1216_battery_probe(struct platform_device *pdev)
+{
+    struct   aml1216_supply *supply;
+    struct   aml_charger    *charger;
+    int      ret;
+    uint32_t tmp2;
+
+	AML_DBG("call %s in", __func__);
+    g_aml1216_init = pdev->dev.platform_data;
+    if (g_aml1216_init == NULL) {
+        AML_DBG("%s, NO platform data\n", __func__);
+        return -EINVAL;
+    }
+    aml1216_power_key = input_allocate_device();
+    if (!aml1216_power_key) {
+        kfree(aml1216_power_key);
+        return -ENODEV;
+    }
+
+    aml1216_power_key->name       = pdev->name;
+    aml1216_power_key->phys       = "m1kbd/input2";
+    aml1216_power_key->id.bustype = BUS_HOST;
+    aml1216_power_key->id.vendor  = 0x0001;
+    aml1216_power_key->id.product = 0x0001;
+    aml1216_power_key->id.version = 0x0100;
+    aml1216_power_key->open       = NULL;
+    aml1216_power_key->close      = NULL;
+    aml1216_power_key->dev.parent = &pdev->dev;
+
+    set_bit(EV_KEY, aml1216_power_key->evbit);
+    set_bit(EV_REL, aml1216_power_key->evbit);
+    set_bit(KEY_POWER, aml1216_power_key->keybit);
+
+    ret = input_register_device(aml1216_power_key);
+
+#ifdef CONFIG_UBOOT_BATTERY_PARAMETERS 
+    if (get_uboot_battery_para_status() == UBOOT_BATTERY_PARA_SUCCESS) {
+        aml1216_battery = get_uboot_battery_para();
+        AML_DBG("use uboot passed battery parameters\n");
+    } else {
+        aml1216_battery = g_aml1216_init->board_battery; 
+        AML_DBG("uboot battery parameter not get, use BSP configed battery parameters\n");
+    }
+#else
+    aml1216_battery = g_aml1216_init->board_battery; 
+    AML_DBG("use BSP configed battery parameters\n");
+#endif
+
+    /*
+     * initialize parameters for supply 
+     */
+    supply = kzalloc(sizeof(*supply), GFP_KERNEL);
+    if (supply == NULL) {
+        return -ENOMEM;
+    }
+    supply->battery_info = kzalloc(sizeof(struct power_supply_info), GFP_KERNEL);
+    if (supply->battery_info == NULL) {
+        kfree(supply);
+        return -ENOMEM;    
+    }
+    supply->master = pdev->dev.parent;
+
+    g_aml1216_supply = supply;
+    charger = &supply->aml_charger;
+    if (aml1216_battery) {
+        for (tmp2 = 1; tmp2 < 16; tmp2++) {
+            if (!charger->ocv_empty && aml1216_battery->pmu_bat_curve[tmp2].discharge_percent > 0) {
+                charger->ocv_empty = aml1216_battery->pmu_bat_curve[tmp2-1].ocv;
+            }
+            if (!charger->ocv_full && aml1216_battery->pmu_bat_curve[tmp2].discharge_percent == 100) {
+                charger->ocv_full = aml1216_battery->pmu_bat_curve[tmp2].ocv;    
+            }
+        }
+
+        supply->irq = aml1216_battery->pmu_irq_id;
+        supply->battery_info->technology         = aml1216_battery->pmu_battery_technology;
+        supply->battery_info->voltage_max_design = aml1216_battery->pmu_init_chgvol;
+        supply->battery_info->energy_full_design = aml1216_battery->pmu_battery_cap;
+        supply->battery_info->voltage_min_design = charger->ocv_empty * 1000;
+        supply->battery_info->use_for_apm        = 1;
+        supply->battery_info->name               = aml1216_battery->pmu_battery_name;
+    } else {
+        AML_DBG(" NO BATTERY_PARAMETERS FOUND\n");
+    }
+
+    charger->soft_limit_to99     = g_aml1216_init->soft_limit_to99;
+    charger->coulomb_type        = COULOMB_BOTH; 
+    supply->charge_timeout_retry = g_aml1216_init->charge_timeout_retry;
+#ifdef CONFIG_AMLOGIC_USB
+    supply->otg_nb.notifier_call = aml1216_otg_change;
+    supply->usb_nb.notifier_call = aml1216_usb_charger;
+    INIT_WORK(&aml1216_otg_work, aml1216_otg_work_fun);
+    dwc_otg_power_register_notifier(&supply->otg_nb);
+    dwc_otg_charger_detect_register_notifier(&supply->usb_nb);
+#endif
+    if (supply->irq == AML1216_IRQ_NUM) {
+        INIT_WORK(&supply->irq_work, aml1216_irq_work_func); 
+        ret = request_irq(supply->irq, 
+                          aml1216_irq_handler, 
+                          IRQF_DISABLED | IRQF_SHARED,
+                          AML1216_IRQ_NAME,
+                          supply); 
+        if (ret) {
+            AML_DBG("request irq failed, ret:%d, irq:%d\n", ret, supply->irq);    
+        }
+    }
+
+    ret = aml1216_first_init(supply);
+    if (ret) {
+        goto err_charger_init;
+    }
+
+    aml1216_battery_setup_psy(supply);
+    ret = power_supply_register(&pdev->dev, &supply->batt);
+    if (ret) {
+        goto err_ps_register;
+    }
+
+    ret = power_supply_register(&pdev->dev, &supply->ac);
+    if (ret){
+        power_supply_unregister(&supply->batt);
+        goto err_ps_register;
+    }
+    ret = power_supply_register(&pdev->dev, &supply->usb);
+    if (ret){
+        power_supply_unregister(&supply->ac);
+        power_supply_unregister(&supply->batt);
+        goto err_ps_register;
+    }
+
+    ret = aml1216_supply_create_attrs(&supply->batt);
+    if(ret){
+        return ret;
+    }
+
+    platform_set_drvdata(pdev, supply);
+
+    supply->interval = msecs_to_jiffies(AML1216_WORK_CYCLE);
+    INIT_DELAYED_WORK(&supply->work, aml1216_charging_monitor);
+    schedule_delayed_work(&supply->work, supply->interval);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    aml1216_early_suspend.suspend = aml1216_earlysuspend;
+    aml1216_early_suspend.resume  = aml1216_lateresume;
+    aml1216_early_suspend.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 2;
+    aml1216_early_suspend.param   = supply;
+    register_early_suspend(&aml1216_early_suspend);
+#endif
+    if (aml1216_battery) {
+        aml_pmu_probe_process(charger, aml1216_battery);
+        power_supply_changed(&supply->batt);                    // update battery status
+    }
+    
+    aml1216_dump_all_register();
+	AML_DBG("call %s exit, ret:%d", __func__, ret);
+    return ret;
+
+err_ps_register:
+    free_irq(supply->irq, supply);
+    cancel_delayed_work_sync(&supply->work);
+
+err_charger_init:
+    kfree(supply->battery_info);
+    kfree(supply);
+    input_unregister_device(aml1216_power_key);
+    kfree(aml1216_power_key);
+	AML_DBG("call %s exit, ret:%d", __func__, ret);
+    return ret;
+}
+
+static int aml1216_battery_remove(struct platform_device *dev)
+{
+    struct aml1216_supply *supply= platform_get_drvdata(dev);
+
+#ifdef CONFIG_AMLOGIC_USB
+    dwc_otg_power_unregister_notifier(&supply->otg_nb);
+    dwc_otg_charger_detect_unregister_notifier(&supply->usb_nb);
+#endif
+    cancel_work_sync(&supply->irq_work);
+    cancel_delayed_work_sync(&supply->work);
+    power_supply_unregister( &supply->usb);
+    power_supply_unregister( &supply->ac);
+    power_supply_unregister( &supply->batt);
+    
+    free_irq(supply->irq, supply);
+    kfree(supply->battery_info);
+    kfree(supply);
+    input_unregister_device(aml1216_power_key);
+    kfree(aml1216_power_key);
+
+    return 0;
+}
+
+
+static int aml1216_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct aml1216_supply *supply = platform_get_drvdata(dev);
+
+    cancel_delayed_work_sync(&supply->work);
+    if (aml1216_battery) {
+        aml1216_set_charging_current(aml1216_battery->pmu_suspend_chgcur);
+        aml_pmu_suspend_process(&supply->aml_charger);
+    }
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    if (early_power_status != supply->aml_charger.ext_valid) {
+       AML_DBG("%s, power status changed, prev:%x, now:%x, exit suspend process\n", 
+                  __func__, early_power_status, supply->aml_charger.ext_valid);
+        input_report_key(aml1216_power_key, KEY_POWER, 1);              // assume power key pressed 
+        input_sync(aml1216_power_key);
+        return -1;
+    }
+#endif
+
+    return 0;
+}
+
+static int aml1216_resume(struct platform_device *dev)
+{
+    struct   aml1216_supply *supply = platform_get_drvdata(dev);
+
+    if (aml1216_battery) {
+         aml_pmu_resume_process(&supply->aml_charger, aml1216_battery);
+        aml1216_set_charging_current(aml1216_battery->pmu_resume_chgcur);
+    }
+    schedule_work(&supply->work.work);
+
+    return 0;
+}
+
+static void aml1216_shutdown(struct platform_device *dev)
+{
+    // add code here
+}
+
+static struct platform_driver aml1216_battery_driver = {
+    .driver = {
+        .name  = AML1216_DRIVER_NAME, 
+        .owner = THIS_MODULE,
+    },
+    .probe    = aml1216_battery_probe,
+    .remove   = aml1216_battery_remove,
+    .suspend  = aml1216_suspend,
+    .resume   = aml1216_resume,
+    .shutdown = aml1216_shutdown,
+};
+
+static int aml1216_battery_init(void)
+{
+    int ret;
+    ret = platform_driver_register(&aml1216_battery_driver);
+	AML_DBG("call %s, ret = %d\n", __func__, ret);
+	return ret;
+}
+
+static void aml1216_battery_exit(void)
+{
+    platform_driver_unregister(&aml1216_battery_driver);
+}
+
+//subsys_initcall(aml1216_battery_init);
+module_init(aml1216_battery_init);
+module_exit(aml1216_battery_exit);
+
+MODULE_DESCRIPTION("AML PMU AML1216 battery driver");
+MODULE_AUTHOR("tao.zeng@amlogic.com, Amlogic, Inc");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/power/aml_pmu/aml_pmu.c b/drivers/amlogic/power/aml_pmu/aml_pmu.c
index 6f8840a561c1..86523c0a8c66 100755
--- a/drivers/amlogic/power/aml_pmu/aml_pmu.c
+++ b/drivers/amlogic/power/aml_pmu/aml_pmu.c
@@ -9,6 +9,18 @@
 #include <mach/am_regs.h>
 #include <mach/gpio.h>
 #include <linux/amlogic/aml_pmu.h>
+#ifdef CONFIG_AML_DVFS
+#include <linux/amlogic/aml_dvfs.h>
+#endif
+
+struct i2c_client *g_aml1216_client = NULL; 
+static const struct i2c_device_id aml_pmu_id_table[] = {
+#ifdef CONFIG_AML1216
+	{ AML1216_DRIVER_NAME, 0},
+#endif
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, aml_pmu_id_table);
 
 #ifdef CONFIG_OF
 #define DEBUG_TREE      0
@@ -114,11 +126,91 @@ static struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *l
 static struct amlogic_pmu_init *init_data;
 #endif /* CONFIG_OF */
 
-static const struct i2c_device_id aml_pmu_id_table[] = {
-	{ "aml1212-supplyer", 0},
-	{},
+#if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1216)
+extern struct aml_pmu_driver aml1216_pmu_driver;
+static int convert_id_to_dcdc(uint32_t id)
+{
+    int dcdc = 0; 
+    switch (id) {
+    case AML_DVFS_ID_VCCK:
+        dcdc = 1;
+        break;
+
+    case AML_DVFS_ID_VDDEE:
+        dcdc = 2;
+        break;
+
+    case AML_DVFS_ID_DDR:
+        dcdc = 3;
+        break;
+
+    default:
+        break;
+    }
+    return dcdc;
+}
+
+static int aml1216_set_voltage(uint32_t id, uint32_t min_uV, uint32_t max_uV)
+{
+    int dcdc = convert_id_to_dcdc(id);
+    uint32_t vol = 0;
+    
+    if (min_uV > max_uV) {
+        return -1;    
+    }
+    vol = (min_uV + max_uV) / 2;
+    if (dcdc >= 1 && dcdc <= 3) {
+        return aml1216_set_dcdc_voltage(dcdc, vol);
+    }
+    return -EINVAL;
+}
+
+static int aml1216_get_voltage(uint32_t id, uint32_t *uV)
+{
+    int dcdc = convert_id_to_dcdc(id);
+
+    if (dcdc >= 1 && dcdc <= 3) {
+        return aml1216_get_dcdc_voltage(dcdc, uV);    
+    }
+
+    return -EINVAL;
+}
+
+struct aml_dvfs_driver aml1216_dvfs_driver = {
+    .name        = "aml1216-dvfs",
+    .id_mask     = (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
+    .set_voltage = aml1216_set_voltage, 
+    .get_voltage = aml1216_get_voltage,
 };
-MODULE_DEVICE_TABLE(i2c, aml_pmu_id_table);
+
+#endif
+
+static int aml_pmu_check_device(struct i2c_client *client)
+{
+    int ret;
+    uint8_t buf[2] = {}; 
+    struct i2c_msg msg[] = { 
+        {   
+            .addr  = client->addr & 0xff,
+            .flags = 0,
+            .len   = sizeof(buf),
+            .buf   = buf,
+        },  
+        {   
+            .addr  = client->addr & 0xff,
+            .flags = I2C_M_RD,
+            .len   = 1,
+            .buf   = &buf[1],
+        }   
+    };  
+
+    ret = i2c_transfer(client->adapter, msg, 2); 
+    if (ret < 0) {
+        DBG("%s: i2c transfer for %x failed, ret:%d\n", __func__, client->addr, ret);
+        return ret;
+    }   
+    return 0;
+}
 
 static int aml_pmu_probe(struct i2c_client *client,
 				  const struct i2c_device_id *id)
@@ -129,6 +221,9 @@ static int aml_pmu_probe(struct i2c_client *client,
     struct  i2c_device_id *type = NULL;
 	int     ret;
     
+    if (aml_pmu_check_device(client)) {
+        return -ENODEV;    
+    }
     /*
      * allocate and regist AML1212 devices, then kernel will probe driver for AML1212
      */
@@ -148,6 +243,15 @@ static int aml_pmu_probe(struct i2c_client *client,
         goto out_free_chip;
     }
 
+#ifdef CONFIG_AML1216
+    if (type->driver_data == 0) {
+        g_aml1216_client = client;            
+    #if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1216)
+        aml_dvfs_register_driver(&aml1216_dvfs_driver);
+    #endif
+        aml_pmu_register_driver(&aml1216_pmu_driver);
+    }
+#endif
     pdev = platform_device_alloc(sub_type, 0);
     if (pdev == NULL) {
         printk(">> %s, allocate platform device failed\n", __func__);
@@ -172,6 +276,13 @@ static int aml_pmu_remove(struct i2c_client *client)
 {
     struct platform_device *pdev = i2c_get_clientdata(client);
 
+#ifdef CONFIG_AML1216
+    g_aml1216_client = NULL;
+#if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1216)
+    aml_dvfs_unregister_driver(&aml1216_dvfs_driver);
+#endif
+    aml_pmu_clear_driver();
+#endif
     platform_device_del(pdev);
 
 	return 0;
diff --git a/include/linux/amlogic/aml_pmu.h b/include/linux/amlogic/aml_pmu.h
index 5aaa1d795daf..2fdda6489f00 100755
--- a/include/linux/amlogic/aml_pmu.h
+++ b/include/linux/amlogic/aml_pmu.h
@@ -3,7 +3,7 @@
 
 #include <linux/power_supply.h>
 #include <linux/amlogic/aml_pmu_common.h>
-
+#include <linux/notifier.h>
 #define BATCAPCORRATE           5                                       // battery capability is very low
 #define ABS(x)                  ((x) >0 ? (x) : -(x))
 #define AML_PMU_WORK_CYCLE      2000                                    // PMU work cycle
@@ -21,6 +21,21 @@
     .store = _name##_store,                         \
 }
 
+/*
+ * @soft_limit_to99: flag for if we need to restrict battery capacity to 99% when have charge current,
+ *                   even battery voltage is over ocv_full;
+ * @para:            parameters for call back funtions, user implement;
+ * @pmu_call_back:   call back function for axp_charging_monitor, you can add anything you want to do
+ *                   in this function, this funtion will be called every 2 seconds by default
+ */
+struct amlogic_pmu_init {
+    int   soft_limit_to99;                          // software limit battery volume to 99% when have charge current
+    int   charge_timeout_retry;                     // retry charge count when charge timeout
+    int   vbus_dcin_short_connect;                  // if VBUS and DCIN are short connected
+    struct battery_parameter *board_battery;        // battery parameter
+};
+
+#ifdef CONFIG_AML1212
 #define AML1212_ADDR                    0x35
 #define AML1212_SUPPLY_NAME             "aml1212-supplyer"
 #define AML1212_IRQ_NAME                "aml1212-irq"
@@ -80,6 +95,22 @@
 #define AML_PMU_LDO4                    7
 #define AML_PMU_LDO5                    8
 
+struct aml1212_supply {
+    struct aml_charger aml_charger;
+	int32_t  interval;                                                  // PMU work cycle
+    int32_t  usb_connect_type;
+    int32_t  irq;
+
+	struct power_supply batt;                                           // power supply sysfs
+	struct power_supply	ac;
+	struct power_supply	usb;
+	struct power_supply_info *battery_info;
+	struct delayed_work work;                                           // work struct
+    struct work_struct  irq_work;                                       // work for IRQ 
+
+	struct device *master;
+};
+
 /*
  * function declaration here
  */
@@ -114,38 +145,142 @@ void aml_pmu_set_voltage(int dcdc, int voltage);                        // set d
 void aml_pmu_poweroff(void);                                            // power off PMU
 
 void aml_pmu_clear_coulomb(void);                                       // clear coulomb register
+extern struct aml1212_supply *g1212_supply;                             // export global charger struct
+#endif  /* CONFIG_AML1212 */
 
-/*
- * @soft_limit_to99: flag for if we need to restrict battery capacity to 99% when have charge current,
- *                   even battery voltage is over ocv_full;
- * @para:            parameters for call back funtions, user implement;
- * @pmu_call_back:   call back function for axp_charging_monitor, you can add anything you want to do
- *                   in this function, this funtion will be called every 2 seconds by default
- */
-struct amlogic_pmu_init {
-    int   soft_limit_to99;                          // software limit battery volume to 99% when have charge current
-    int   charge_timeout_retry;                     // retry charge count when charge timeout
-    int   vbus_dcin_short_connect;                  // if VBUS and DCIN are short connected
-    struct battery_parameter *board_battery;        // battery parameter
-};
+#ifdef CONFIG_AML1216
+#define AML1216_ADDR    0x35
 
-struct aml1212_supply {
-    struct aml_charger aml_charger;
+#define AML1216_DRIVER_VERSION              "v1.0"
+#define AML1216_DRIVER_NAME                 "aml1216_pmu"
+#define AML1216_IRQ_NUM                     INT_GPIO_2
+#define AML1216_IRQ_NAME                    "aml1216_irq"
+#define AML1216_WORK_CYCLE                  2000
+
+//add for AML1216 ctroller.
+#define AML1216_OTP_GEN_CONTROL0        0x17
+
+#define AML1216_CHG_CTRL0               0x29
+#define AML1216_CHG_CTRL1               0x2A
+#define AML1216_CHG_CTRL2               0x2B
+#define AML1216_CHG_CTRL3               0x2C
+#define AML1216_CHG_CTRL4               0x2D
+#define AML1216_CHG_CTRL5               0x2E
+#define AML1216_CHG_CTRL6               0x129
+#define AML1216_SAR_ADJ                 0x73
+
+
+#define AML1216_GEN_CNTL0               0x80
+#define AML1216_GEN_CNTL1               0x81
+#define AML1216_PWR_UP_SW_ENABLE        0x82        // software power up
+#define AML1216_PWR_DN_SW_ENABLE        0x84        // software power down
+#define AML1216_GEN_STATUS0             0x86
+#define AML1216_GEN_STATUS1             0x87
+#define AML1216_GEN_STATUS2             0x88
+#define AML1216_GEN_STATUS3             0x89
+#define AML1216_GEN_STATUS4             0x8A
+#define AML1216_WATCH_DOG               0x8F
+#define AML1216_PWR_KEY_ADDR            0x90
+#define AML1216_SAR_SW_EN_FIELD         0x9A
+#define AML1216_SAR_CNTL_REG0           0x9B
+#define AML1216_SAR_CNTL_REG2           0x9D
+#define AML1216_SAR_CNTL_REG3           0x9E
+#define AML1216_SAR_CNTL_REG5           0xA0
+#define AML1216_SAR_RD_IBAT_LAST        0xAB        // battery current measure
+#define AML1216_SAR_RD_VBAT_ACTIVE      0xAF        // battery voltage measure
+#define AML1216_SAR_RD_MANUAL           0xB1        // manual measure
+#define AML1216_SAR_RD_IBAT_ACC         0xB5        // IBAT accumulated result, coulomb
+#define AML1216_SAR_RD_IBAT_CNT         0xB9        // IBAT measure count
+#define AML1216_GPIO_OUTPUT_CTRL        0xC3        // GPIO output control
+#define AML1216_GPIO_INPUT_STATUS       0xC4        // GPIO input status
+#define AML1216_IRQ_MASK_0              0xC8        // IRQ Mask base address
+#define AML1216_IRQ_STATUS_CLR_0        0xCF        // IRQ status base address
+#define AML1216_SP_CHARGER_STATUS0      0xDE        // charge status0
+#define AML1216_SP_CHARGER_STATUS1      0xDF        // charge status1
+#define AML1216_SP_CHARGER_STATUS2      0xE0        // charge status2
+#define AML1216_SP_CHARGER_STATUS3      0xE1        // charge status3
+#define AML1216_SP_CHARGER_STATUS4      0xE2        // charge status4
+#define AML1216_PIN_MUX4                0xF4        // pin mux select 4
+
+#define AML1216_DCDC1                   0
+#define AML1216_DCDC2                   1
+#define AML1216_DCDC3                   2
+#define AML1216_BOOST                   3
+#define AML1216_LDO1                    4
+#define AML1216_LDO2                    5
+#define AML1216_LDO3                    6
+#define AML1216_LDO4                    7
+#define AML1216_LDO5                    8
+
+#define AML1216_CHARGER_CHARGING            1
+#define AML1216_CHARGER_DISCHARGING         2
+#define AML1216_CHARGER_NONE                3 
+
+#define AML_DBG(format,args...)                 \
+    if (1) printk(KERN_ERR "[AML1216]"format,##args)  
+#define ABS(x)                  ((x) >0 ? (x) : -(x))
+
+#define AML_ATTR(_name)                           \
+{                                                   \
+    .attr = { .name = #_name,.mode = 0644 },        \
+    .show =  _name##_show,                          \
+    .store = _name##_store,                         \
+}
+
+struct aml1216_supply {
+    struct   aml_charger aml_charger;
 	int32_t  interval;                                                  // PMU work cycle
-    int32_t  usb_connect_type;
+    int32_t  usb_connect_type;                                          // usb is connect to PC or adapter
+    int32_t  charge_timeout_retry;                                      // retry charge count when charge timeout
+    int32_t  vbus_dcin_short_connect;                                   // indicate VBUS and DCIN are short connected
     int32_t  irq;
 
-	struct power_supply batt;                                           // power supply sysfs
-	struct power_supply	ac;
-	struct power_supply	usb;
-	struct power_supply_info *battery_info;
-	struct delayed_work work;                                           // work struct
+    struct power_supply batt;                                           // power supply sysfs
+    struct power_supply	ac;
+    struct power_supply	usb;
+    struct power_supply_info *battery_info;
+    struct delayed_work work;                                           // work struct
     struct work_struct  irq_work;                                       // work for IRQ 
+    struct notifier_block nb;
 
-	struct device *master;
+    struct notifier_block otg_nb;                                       // notifier_block for OTG issue
+    struct notifier_block usb_nb;                                       // notifier_block for USB charger issue
+
+    struct device *master;
 };
 
-extern struct aml1212_supply *g1212_supply;                             // export global charger struct
+/*
+ * API export of pmu base operation
+ */
+extern int  aml1216_write(int32_t add, uint8_t val);
+extern int  aml1216_write16(int32_t add, uint16_t val);
+extern int  aml1216_writes(int32_t add, uint8_t *buff, int len);
+extern int  aml1216_read    (int add, uint8_t *val);
+extern int  aml1216_read16(int add, uint16_t *val);
+extern int  aml1216_reads   (int add, uint8_t *buff, int len);
+extern int  aml1216_set_bits(int addr, uint8_t bits, uint8_t mask);
+extern int  aml1216_get_battery_voltage(void);                           // in mV
+extern int  aml1216_get_battery_temperature(void);                       // in C
+extern int  aml1216_get_battery_current(void);                           // in mA
+extern int  aml1216_get_charge_status(void);                             // see status of charger
+extern int  aml1216_set_gpio(int gpio, int output);                      // gpio 0 ~ 3, output: 1->high, 0->low
+extern int  aml1216_get_gpio(int gpio, int *val);                        // gpio 0 ~ 3, val: 1->high, 0->low
+extern int  aml1216_set_dcin_current_limit(int limit);                   // current limit for DCIN, in mA
+extern int  aml1216_set_usb_current_limit(int limit);                    // current limit of VBUS, in mA
+extern int  aml1216_set_usb_voltage_limit(int voltage);                  // voltage limit of VBUS, in mV
+extern int  aml1216_set_dcdc_voltage(int dcdc, uint32_t voltage);        // dcdc 0 ~ 3, voltage in mV
+extern int  aml1216_get_dcdc_voltage(int dcdc, uint32_t *uV);            // return dcdc voltage
+extern int  aml1216_set_charge_enable(int enable);                       // 0->disable charger, 1->enable charger
+extern int  aml1216_set_charge_current(int curr);                        // current of charge, in uA
+extern int  aml1216_get_battery_percent(void);                           // return volume of battery, in 1%
+extern int  aml1216_cal_ocv(int ibat, int vbat, int dir);                // ibat in mA, vbat in mV
+extern void aml1216_power_off(void);                                     // power of system
+/*
+ * Global variable declaration
+ */
+extern struct aml1216_supply *g_aml1216_supply;                           // export global charger struct
+extern struct i2c_client *g_aml1216_client;                              // i2c client for register RW
+#endif      /* CONFIG_AML1216 */
 
 #endif /* __AML_PMU_H__ */
 
-- 
2.19.0

