From 7cbe386518dea719bb6b6d8036f81271e3796436 Mon Sep 17 00:00:00 2001
From: "bo.yang" <bo.yang@amlogic.com>
Date: Sun, 16 Feb 2014 20:09:18 +0800
Subject: [PATCH 3433/5965] m6tvd:vecm: add vecm support for m6tvd

by lei.yang@amlogic.com
---
 arch/arm/configs/meson6tv_defconfig |    1 +
 drivers/amlogic/Kconfig             |    2 +-
 drivers/amlogic/Makefile            |    2 +-
 drivers/amlogic/amvecm/Kconfig      |   14 +
 drivers/amlogic/amvecm/Makefile     |    7 +
 drivers/amlogic/amvecm/amcm.c       |  272 ++++++
 drivers/amlogic/amvecm/amcm.h       |   47 +
 drivers/amlogic/amvecm/amve.c       | 1008 +++++++++++++++++++++
 drivers/amlogic/amvecm/amve.h       |   68 ++
 drivers/amlogic/amvecm/amvecm.c     | 1276 +++++++++++++++++++++++++++
 drivers/amlogic/amvecm/cm_regs.h    |  186 ++++
 drivers/amlogic/amvecm/ve_regs.h    |  483 ++++++++++
 include/linux/amlogic/amstream.h    |  311 +++++++
 include/linux/amlogic/amvecm.h      |   96 ++
 include/linux/amlogic/cm.h          |  167 ++++
 include/linux/amlogic/ve.h          |  200 +++++
 include/linux/amlogic/vframe.h      |  210 +++++
 17 files changed, 4348 insertions(+), 2 deletions(-)
 create mode 100755 drivers/amlogic/amvecm/Kconfig
 create mode 100755 drivers/amlogic/amvecm/Makefile
 create mode 100755 drivers/amlogic/amvecm/amcm.c
 create mode 100755 drivers/amlogic/amvecm/amcm.h
 create mode 100755 drivers/amlogic/amvecm/amve.c
 create mode 100755 drivers/amlogic/amvecm/amve.h
 create mode 100755 drivers/amlogic/amvecm/amvecm.c
 create mode 100755 drivers/amlogic/amvecm/cm_regs.h
 create mode 100755 drivers/amlogic/amvecm/ve_regs.h
 create mode 100755 include/linux/amlogic/amstream.h
 create mode 100755 include/linux/amlogic/amvecm.h
 create mode 100755 include/linux/amlogic/cm.h
 create mode 100755 include/linux/amlogic/ve.h
 create mode 100755 include/linux/amlogic/vframe.h

diff --git a/arch/arm/configs/meson6tv_defconfig b/arch/arm/configs/meson6tv_defconfig
index 83c67096c10c..97d386bfb027 100755
--- a/arch/arm/configs/meson6tv_defconfig
+++ b/arch/arm/configs/meson6tv_defconfig
@@ -40,6 +40,7 @@ CONFIG_AM_REMOTE=y
 # CONFIG_AMLOGIC_ION is not set
 # CONFIG_CRYPTO_AML_HW_CRYPRO is not set
 # CONFIG_CRYPTO_DEVICE_DRIVER is not set
+CONFIG_AM_VECM=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index f1a886b1e74b..f7a9ee8add62 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -89,7 +89,7 @@ source "drivers/amlogic/deinterlace/Kconfig"
 #source "drivers/amlogic/freescale/Kconfig"
 source "drivers/amlogic/mipi/Kconfig"
 #source "drivers/amlogic/d2d3/Kconfig"
-#source "drivers/amlogic/amvecm/Kconfig"
+source "drivers/amlogic/amvecm/Kconfig"
 
 #deferred module for speed
 #source "drivers/amlogic/load_deferred_module/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index c3d184701882..a279565324eb 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -52,7 +52,7 @@ obj-$(CONFIG_AM_CANVAS) += canvas/
 obj-y += amports/
 
 # ve&cm
-#obj-y += amvecm/
+obj-y += amvecm/
 
 obj-$(CONFIG_I2C) += i2c/
 
diff --git a/drivers/amlogic/amvecm/Kconfig b/drivers/amlogic/amvecm/Kconfig
new file mode 100755
index 000000000000..b433340dabda
--- /dev/null
+++ b/drivers/amlogic/amvecm/Kconfig
@@ -0,0 +1,14 @@
+#
+# AMLOGIC tvin devices configuration
+#
+
+menu "Amlogic VE & CM"
+
+config AM_VECM
+	tristate "Amlogic VE & CM"
+	default n
+	help
+		Video Enhancement & Color Management.
+
+endmenu
+
diff --git a/drivers/amlogic/amvecm/Makefile b/drivers/amlogic/amvecm/Makefile
new file mode 100755
index 000000000000..0d5e9f310eda
--- /dev/null
+++ b/drivers/amlogic/amvecm/Makefile
@@ -0,0 +1,7 @@
+#
+# AMLOGIC VE & CM.
+#
+
+obj-$(CONFIG_AM_VECM) += am_vecm.o
+am_vecm-objs := amve.o amcm.o amvecm.o
+
diff --git a/drivers/amlogic/amvecm/amcm.c b/drivers/amlogic/amvecm/amcm.c
new file mode 100755
index 000000000000..2085091bc4ee
--- /dev/null
+++ b/drivers/amlogic/amvecm/amcm.c
@@ -0,0 +1,272 @@
+/*
+ * Color Management
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <mach/am_regs.h>
+#include <linux/module.h>
+#include <linux/amlogic/cm.h>
+#include <linux/amlogic/aml_common.h>
+#include <linux/amlogic/vframe.h>
+#include "cm_regs.h"
+#include "amcm.h"
+
+#if 0
+struct cm_region_s cm_region;
+struct cm_top_s    cm_top;
+struct cm_demo_s   cm_demo;
+#endif
+
+unsigned int cm2_patch_flag = 0;
+
+#ifdef AMVIDEO_REG_TABLE_DYNAMIC
+void am_set_regmap(unsigned int cnt, struct am_reg_s *p)
+{
+    unsigned short i;
+    unsigned int temp = 0;
+
+    for (i=0; i<cnt; i++) {
+        switch (p->type)
+        {
+            case REG_TYPE_PHY:
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: bus type: phy..............\n", __func__);
+                #endif
+            break;
+            case REG_TYPE_CBUS:
+                if (p->mask == 0xffffffff)
+                    WRITE_CBUS_REG(p->addr, p->val);
+                else
+                    WRITE_CBUS_REG(p->addr, (READ_CBUS_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: cbus: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            case REG_TYPE_APB:
+                if (p->mask == 0xffffffff)
+                    WRITE_APB_REG(p->addr, p->val);
+                else
+                    WRITE_APB_REG(p->addr, (READ_APB_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: apb bus: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            case REG_TYPE_MPEG:
+                if (p->mask == 0xffffffff)
+                    WRITE_MPEG_REG(p->addr, p->val);
+                else
+                    WRITE_MPEG_REG(p->addr, (READ_MPEG_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: mpeg: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            case REG_TYPE_AXI:
+                if (p->mask == 0xffffffff)
+                    WRITE_AXI_REG(p->addr, p->val);
+                else
+                    WRITE_AXI_REG(p->addr, (READ_AXI_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: axi: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            case REG_TYPE_AHB:
+                if (p->mask == 0xffffffff)
+                    WRITE_AHB_REG(p->addr, p->val);
+                else
+                    WRITE_AHB_REG(p->addr, (READ_AHB_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: ahb: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            case REG_TYPE_INDEX_VPPCHROMA:
+                WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->addr);
+                if (p->mask == 0xffffffff)
+                {
+                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->val);
+                }
+                else
+                {
+                    temp = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
+                    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->addr);
+                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (temp & (~p->mask)) | (p->val & p->mask));
+                }
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: vppchroma: 0x1d70:port0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            case REG_TYPE_INDEX_GAMMA:
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: bus type: REG_TYPE_INDEX_GAMMA..............\n", __func__);
+                #endif
+            break;
+            case VALUE_TYPE_CONTRAST_BRIGHTNESS:
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: bus type: VALUE_TYPE_CONTRAST_BRIGHTNESS..............\n", __func__);
+                #endif
+            break;
+            case REG_TYPE_INDEX_VPP_COEF:
+		    	if (((p->addr&0xf) == 0)||((p->addr&0xf) == 0x8))
+		    		{
+		            WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->addr);
+					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->val);
+		    		}
+				else
+					{
+					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->val);
+					}
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: vppcoef: 0x1d70:port0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
+                #endif
+            break;
+            default:
+                pr_info("%s: bus type error!!!bustype = 0x%x................\n", __func__, p->type);
+            break;
+        }
+        p++;
+    }
+
+    return;
+}
+#else
+void am_set_regmap(struct am_regs_s *p)
+{
+    unsigned short i;
+    unsigned int temp = 0;
+
+    for (i=0; i<p->length; i++) {
+        switch (p->am_reg[i].type)
+        {
+            case REG_TYPE_PHY:
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: bus type: phy..............\n", __func__);
+                #endif
+            break;
+            case REG_TYPE_CBUS:
+                if (p->am_reg[i].mask == 0xffffffff)
+                    WRITE_CBUS_REG(p->am_reg[i].addr, p->am_reg[i].val);
+                else
+                    WRITE_CBUS_REG(p->am_reg[i].addr, (READ_CBUS_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+                #ifdef PQ_DEBUG_EN
+					pr_info("%s: cbus: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            case REG_TYPE_APB:
+                if (p->am_reg[i].mask == 0xffffffff)
+                    WRITE_APB_REG(p->am_reg[i].addr, p->am_reg[i].val);
+                else
+                    WRITE_APB_REG(p->am_reg[i].addr, (READ_APB_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+                #ifdef PQ_DEBUG_EN
+					pr_info("%s: apb: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            case REG_TYPE_MPEG:
+                if (p->am_reg[i].mask == 0xffffffff)
+                    WRITE_MPEG_REG(p->am_reg[i].addr, p->am_reg[i].val);
+                else
+                    WRITE_MPEG_REG(p->am_reg[i].addr, (READ_MPEG_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+                #ifdef PQ_DEBUG_EN
+					pr_info("%s: mpeg: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            case REG_TYPE_AXI:
+                if (p->am_reg[i].mask == 0xffffffff)
+                    WRITE_AXI_REG(p->am_reg[i].addr, p->am_reg[i].val);
+                else
+                    WRITE_AXI_REG(p->am_reg[i].addr, (READ_AXI_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+                #ifdef PQ_DEBUG_EN
+					pr_info("%s: axi: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            case REG_TYPE_AHB:
+                if (p->am_reg[i].mask == 0xffffffff)
+                    WRITE_AHB_REG(p->am_reg[i].addr, p->am_reg[i].val);
+                else
+                    WRITE_AHB_REG(p->am_reg[i].addr, (READ_AHB_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+                #ifdef PQ_DEBUG_EN
+					pr_info("%s: ahb: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            case REG_TYPE_INDEX_VPPCHROMA:
+				/*  add for vm2 demo frame size setting */
+				if (p->am_reg[i].addr == 0x20f) {
+                	if ((p->am_reg[i].val & 0xff) != 0) {
+						cm2_patch_flag = p->am_reg[i].val;
+                    	p->am_reg[i].val = p->am_reg[i].val & 0xffffff00;
+                    }
+                    else
+                  		cm2_patch_flag = 0;
+                }
+                WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+                if (p->am_reg[i].mask == 0xffffffff)
+                {
+                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+                }
+                else
+                {
+                    temp = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
+                    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (temp & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+                }
+                #ifdef PQ_DEBUG_EN
+					pr_info("%s: chroma: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            case REG_TYPE_INDEX_GAMMA:
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: bus type: REG_TYPE_INDEX_GAMMA..............\n", __func__);
+                #endif
+            break;
+            case VALUE_TYPE_CONTRAST_BRIGHTNESS:
+                #ifdef PQ_DEBUG_EN
+                    pr_info("%s: bus type: VALUE_TYPE_CONTRAST_BRIGHTNESS..............\n", __func__);
+                #endif
+            break;
+			case REG_TYPE_INDEX_VPP_COEF:
+				if (((p->am_reg[i].addr&0xf) == 0)||((p->am_reg[i].addr&0xf) == 0x8))
+					{
+					WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+					}
+				else
+					{
+					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+					}
+				#ifdef PQ_DEBUG_EN
+					pr_info("%s: coef: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
+					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
+                #endif
+            break;
+            default:
+            #ifdef PQ_DEBUG_EN
+                pr_info("%s: bus type error!!!bustype = 0x%x................\n", __func__, p->am_reg[i].type);
+            #endif
+            break;
+        }
+    }
+
+    return;
+}
+#endif
+
diff --git a/drivers/amlogic/amvecm/amcm.h b/drivers/amlogic/amvecm/amcm.h
new file mode 100755
index 000000000000..4b17ac442bb3
--- /dev/null
+++ b/drivers/amlogic/amvecm/amcm.h
@@ -0,0 +1,47 @@
+/*
+ * Color Management
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __AM_CM_H
+#define __AM_CM_H
+
+
+#include "linux/amlogic/vframe.h"
+#include "linux/amlogic/cm.h"
+
+typedef struct cm_regs_s {
+    unsigned int val  : 32;
+    unsigned int reg  : 14;
+    unsigned int port :  2; // port port_addr            port_data            remark
+                        // 0    NA                   NA                   direct access
+                        // 1    VPP_CHROMA_ADDR_PORT VPP_CHROMA_DATA_PORT CM port registers
+                        // 2    NA                   NA                   reserved
+                        // 3    NA                   NA                   reserved
+    unsigned int bit  :  5;
+    unsigned int wid  :  5;
+    unsigned int mode :  1; // 0:read, 1:write
+    unsigned int rsv  :  5;
+} cm_regs_t;
+
+
+// ***************************************************************************
+// *** IOCTL-oriented functions *********************************************
+// ***************************************************************************
+#ifdef AMVIDEO_REG_TABLE_DYNAMIC
+void am_set_regmap(unsigned int cnt, struct am_reg_s *p);
+#else
+void am_set_regmap(struct am_regs_s *p);
+#endif
+
+
+#endif
+
diff --git a/drivers/amlogic/amvecm/amve.c b/drivers/amlogic/amvecm/amve.c
new file mode 100755
index 000000000000..31cafee38607
--- /dev/null
+++ b/drivers/amlogic/amvecm/amve.c
@@ -0,0 +1,1008 @@
+/*
+ * Video Enhancement
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+
+
+#include <mach/am_regs.h>
+#include <linux/amlogic/amstream.h>
+#include <linux/amlogic/ve.h>
+
+#include <linux/amlogic/aml_common.h>
+#include <linux/amlogic/vframe.h>
+
+#include "ve_regs.h"
+#include "amve.h"
+
+// 0: Invalid
+// 1: Valid
+// 2: Updated in 2D mode
+// 3: Updated in 3D mode
+unsigned long flags;
+//#define NEW_DNLP_AFTER_PEAKING
+
+struct ve_hist_s video_ve_hist;
+
+static unsigned char ve_dnlp_tgt[64];
+bool ve_en;
+unsigned int ve_dnlp_white_factor;
+unsigned int ve_dnlp_rt = 0;
+unsigned int ve_dnlp_rl;
+unsigned int ve_dnlp_black;
+unsigned int ve_dnlp_white;
+unsigned int ve_dnlp_luma_sum;
+static ulong ve_dnlp_lpf[64], ve_dnlp_reg[16];
+
+static bool frame_lock_nosm = 1;
+static int ve_dnlp_waist_h = 128;
+static int ve_dnlp_waist_l = 128;
+static int ve_dnlp_ankle = 16;
+static int ve_dnlp_strength = 255;
+
+module_param(ve_dnlp_waist_h, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_waist_h, "ve_dnlp_waist_h");
+module_param(ve_dnlp_waist_l, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_waist_l, "ve_dnlp_waist_l");
+module_param(ve_dnlp_ankle, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_ankle, "ve_dnlp_ankle");
+module_param(ve_dnlp_strength, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_strength, "ve_dnlp_strength");
+
+static int dnlp_respond = 0;
+module_param(dnlp_respond, int, 0664);
+MODULE_PARM_DESC(dnlp_respond, "dnlp_respond");
+
+static int dnlp_debug = 0;
+module_param(dnlp_debug, int, 0664);
+MODULE_PARM_DESC(dnlp_debug, "dnlp_debug");
+
+static int ve_dnlp_method = 0;
+module_param(ve_dnlp_method, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_method, "ve_dnlp_method");
+
+static int ve_dnlp_cliprate = 6;
+module_param(ve_dnlp_cliprate, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_cliprate, "ve_dnlp_cliprate");
+
+static int ve_dnlp_lowrange = 18;
+module_param(ve_dnlp_lowrange, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_lowrange, "ve_dnlp_lowrange");
+
+static int ve_dnlp_hghrange = 18;
+module_param(ve_dnlp_hghrange, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_hghrange, "ve_dnlp_hghrange");
+
+static int ve_dnlp_lowalpha = 24;
+module_param(ve_dnlp_lowalpha, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_lowalpha, "ve_dnlp_lowalpha");
+
+static int ve_dnlp_midalpha = 24;
+module_param(ve_dnlp_midalpha, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_midalpha, "ve_dnlp_midalpha");
+
+static int ve_dnlp_hghalpha = 24;
+module_param(ve_dnlp_hghalpha, int, 0664);
+MODULE_PARM_DESC(ve_dnlp_hghalpha, "ve_dnlp_hghalpha");
+
+module_param(frame_lock_nosm, bool, 0664);
+MODULE_PARM_DESC(frame_lock_nosm, "frame_lock_nosm");
+
+static int dnlp_adj_level = 6;
+module_param(dnlp_adj_level, int, 0664);
+MODULE_PARM_DESC(dnlp_adj_level, "dnlp_adj_level");
+
+// ***************************************************************************
+// *** VPP_FIQ-oriented functions *********************************************
+// ***************************************************************************
+static void ve_hist_gamma_tgt(vframe_t *vf)
+{
+    struct vframe_prop_s *p = &vf->prop;
+    video_ve_hist.sum    = p->hist.luma_sum;
+    video_ve_hist.width  = p->hist.width;
+    video_ve_hist.height = p->hist.height;
+}
+
+static void ve_dnlp_calculate_tgt_ext(vframe_t *vf)
+{
+    struct vframe_prop_s *p = &vf->prop;
+	static unsigned int sum_b = 0, sum_c = 0;
+    ulong i = 0, j = 0, sum = 0, ave = 0, ankle = 0, waist = 0, peak = 0, start = 0;
+    ulong qty_h = 0, qty_l = 0, ratio_h = 0, ratio_l = 0;
+    ulong div1  = 0, div2  = 0, step_h  = 0, step_l  = 0;
+    ulong data[55];
+    bool  flag[55], previous_state_high = false;
+	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
+
+    // old historic luma sum
+    sum_b = sum_c;
+    sum_c = ve_dnlp_luma_sum;
+    // new historic luma sum
+    ve_dnlp_luma_sum = p->hist.luma_sum;
+	if(dnlp_debug)
+	printk("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
+
+    // picture mode: freeze dnlp curve
+    if(dnlp_respond)
+    {
+		if (// new luma sum is 0, something is wrong, freeze dnlp curve
+			(!ve_dnlp_luma_sum)
+		   )
+		return;
+    }
+	else
+	{
+	    if (// new luma sum is 0, something is wrong, freeze dnlp curve
+	        (!ve_dnlp_luma_sum) ||
+	        // new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
+	        ((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&
+	         (ve_dnlp_luma_sum > sum_b - (sum_b>> dnlp_adj_level))
+	        )
+	       )
+	    return;
+	}
+
+    // calculate ave (55 times of ave & data[] for accuracy)
+    // ave    22-bit
+    // data[] 22-bit
+    //printk("ankle=%d,waist_h=%d,waist_l=%d,strenth=%d\n",ve_dnlp_ankle,ve_dnlp_waist_h,ve_dnlp_waist_l,ve_dnlp_strength);
+    ave = 0;
+    for (i = 0; i < 55; i++)
+    {
+        data[i]  = (ulong)p->hist.gamma[i + 4];
+        ave     += data[i];
+        data[i] *= 55;
+        flag[i]  = false;
+    }
+
+    // calculate ankle
+    // ankle 22-bit
+    // waist 22-bit
+    // qty_h 6-bit
+    ankle = (ave * ve_dnlp_ankle+ 128) >> 8;
+
+    // scan data[] to find out waist pulses
+    qty_h = 0;
+    previous_state_high = false;
+    for (i = 0; i < 55; i++)
+    {
+        if (data[i] >= ankle)
+        {
+            // ankle pulses start
+            if (!previous_state_high)
+            {
+                previous_state_high = true;
+                start = i;
+                peak = 0;
+            }
+            // normal maintenance
+            if (peak < data[i])
+                peak = data[i];
+        }
+        else
+        {
+            // ankle pulses end + 1
+            if (previous_state_high)
+            {
+                previous_state_high = false;
+                // calculate waist of high area pulses
+                if (peak >= ave)
+                    waist = ((peak - ankle) * ve_dnlp_waist_h + 128) >> 8;
+	                // calculate waist of high area pulses
+	                else
+	                    waist = ((peak - ankle) * ve_dnlp_waist_l + 128) >> 8;
+	                // find out waist pulses
+	                for (j = start; j < i; j++)
+	                {
+	                    if (data[j] >= waist)
+	                    {
+	                        flag[j] = true;
+	                        qty_h++;
+	                    }
+	                }
+	            }
+        }
+    }
+
+    // calculate ratio_h and ratio_l (div2 = 512*H*L times of value for accuracy)
+    // averaged duty > 1/3
+    // qty_l 6-bit
+    // div1 20-bit
+    // div2 21-bit
+    // ratio_h 22-bit
+    // ratio_l 21-bit
+    qty_l =  55 - qty_h;
+	if ((!qty_h) || (!qty_l))
+		{
+			for (i = 5; i <= 58; i++)
+			{
+				ve_dnlp_tgt[i] = i << 2;
+			}
+		}
+	else
+		{
+		    div1  = 256 * qty_h * qty_l;
+		    div2  = 512 * qty_h * qty_l;
+		    if (qty_h > 18)
+		    {
+		        ratio_h = div2 + ve_dnlp_strength * qty_l * qty_l; // [1.0 ~ 2.0)
+		        ratio_l = div2 - ve_dnlp_strength * qty_h * qty_l; // [0.5 ~ 1.0]
+		    }
+		    // averaged duty < 1/3
+		    {
+		        ratio_h = div2 + (ve_dnlp_strength << 1) * qty_h * qty_l; // [1.0 ~ 2.0]
+		        ratio_l = div2 - (ve_dnlp_strength << 1) * qty_h * qty_h; // (0.5 ~ 1.0]
+		    }
+
+		    // distribute ratio_h & ratio_l to ve_dnlp_tgt[5] ~ ve_dnlp_tgt[58]
+		    // sum 29-bit
+		    // step_h 24-bit
+		    // step_l 23-bit
+
+		    sum = div2 << 4; // start from 16
+		    step_h = ratio_h << 2;
+		    step_l = ratio_l << 2;
+		    for (i = 5; i <= 58; i++)
+		    {
+		        // high phase
+		        if (flag[i - 5])
+		            sum += step_h;
+		        // low  phase
+		        else
+		            sum += step_l;
+		        ve_dnlp_tgt[i] = (sum + div1) / div2;
+		    }
+			if(cnt)
+			{
+			for(i=0;i<64;i++)
+				printk(" ve_dnlp_tgte[%ld]=%d\n",i,ve_dnlp_tgt[i]);
+			WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
+			}
+		}
+
+    // calculate black extension
+
+    // calculate white extension
+}
+
+void GetWgtLst(ulong *iHst, ulong tAvg, ulong nLen, ulong alpha)
+{
+	ulong iMax=0;
+	ulong iMin=0;
+	ulong iPxl=0;
+	ulong iT=0;
+
+	for(iT=0;iT<nLen;iT++)
+	{
+		iPxl = iHst[iT];
+		if(iPxl>tAvg)
+		{
+			iMax=iPxl;
+			iMin=tAvg;
+		}
+		else
+		{
+			iMax=tAvg;
+			iMin=iPxl;
+		}
+
+		if(alpha<16)
+		{
+			iPxl = ((16-alpha)*iMin+8)>>4;
+			iPxl += alpha*iMin;
+		}
+		else if(alpha<32)
+		{
+			iPxl = (32-alpha)*iMin;
+			iPxl += (alpha-16)*iMax;
+		}
+		else
+		{
+			iPxl = (48-alpha)+4*(alpha-32);
+			iPxl *= iMax;
+		}
+
+		iPxl = (iPxl+8)>>4;
+
+		iHst[iT] = iPxl<1 ? 1 : iPxl;
+	}
+}
+
+static void ve_dnlp_calculate_tgtx(vframe_t *vf)
+{
+    struct vframe_prop_s *p = &vf->prop;
+    ulong iHst[64];
+    ulong oHst[64];
+	static unsigned int sum_b = 0, sum_c = 0;
+    ulong i = 0, j = 0, sum = 0, max = 0;
+	ulong cLmt=0, nStp=0, stp=0, uLmt=0;
+	long nExc=0;
+	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
+	unsigned int cnt2 = READ_CBUS_REG(ASSIST_SPARE8_REG2);
+
+	unsigned int clip_rate = ve_dnlp_cliprate; //8bit
+	unsigned int low_range = ve_dnlp_lowrange;//18; //6bit [0-54]
+	unsigned int hgh_range = ve_dnlp_hghrange;//18; //6bit [0-54]
+	unsigned int low_alpha = ve_dnlp_lowalpha;//24; //6bit [0--48]
+	unsigned int mid_alpha = ve_dnlp_midalpha;//24; //6bit [0--48]
+	unsigned int hgh_alpha = ve_dnlp_hghalpha;//24; //6bit [0--48]
+	//-------------------------------------------------
+	ulong tAvg=0;
+	ulong nPnt=0;
+	ulong mRng=0;
+
+
+    // old historic luma sum
+    sum_b = sum_c;
+    sum_c = ve_dnlp_luma_sum;
+    // new historic luma sum
+    ve_dnlp_luma_sum = p->hist.luma_sum;
+	if(dnlp_debug)
+	printk("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
+
+    // picture mode: freeze dnlp curve
+    if(dnlp_respond)
+    {
+		if (// new luma sum is 0, something is wrong, freeze dnlp curve
+			(!ve_dnlp_luma_sum)
+		   )
+		return;
+    }
+	else
+	{
+	    if (// new luma sum is 0, something is wrong, freeze dnlp curve
+	        (!ve_dnlp_luma_sum) ||
+	        // new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
+	        ((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&
+	         (ve_dnlp_luma_sum > sum_b - (sum_b >> dnlp_adj_level))
+	        )
+	       )
+	    return;
+	}
+
+    // 64 bins, max, ave
+    for (i = 0; i < 64; i++)
+    {
+        iHst[i] = (ulong)p->hist.gamma[i];
+
+		if(i>=4 && i<=58) { //55 bins
+			oHst[i] = iHst[i];
+
+			if (max < iHst[i])
+				max = iHst[i];
+			sum += iHst[i];
+		}
+		else {
+			oHst[i] = 0;
+		}
+    }
+	cLmt = (clip_rate*sum)>>8;
+	tAvg = sum/55;
+
+
+    // invalid histgram: freeze dnlp curve
+    if (max<=55)
+        return;
+
+    // get 1st 4 points
+    for (i = 4; i <= 58; i++)
+    {
+		if(iHst[i]>cLmt)
+			nExc += (iHst[i]-cLmt);
+    }
+	nStp = (nExc+28)/55;
+	uLmt = cLmt-nStp;
+    if(cnt2)
+    	{
+	    printk(" ve_dnlp_tgtx:cLmt=%ld,nStp=%ld,uLmt=%ld\n",cLmt,nStp,uLmt);
+		WRITE_CBUS_REG(ASSIST_SPARE8_REG2, 0);
+    	}
+    if(clip_rate<=4 || tAvg<=2)
+    {
+        cLmt = (sum+28)/55;
+        sum = cLmt*55;
+
+        for(i=4; i<=58; i++)
+        {
+             oHst[i] = cLmt;
+        }
+    }
+    else if(nStp!=0)
+    {
+		for(i=4; i<=58; i++)
+			{
+				if(iHst[i]>=cLmt)
+					oHst[i] = cLmt;
+				else {
+					if(iHst[i]>uLmt)
+					{
+						oHst[i] = cLmt;
+						nExc -= cLmt-iHst[i];
+					}
+					else
+					{
+						oHst[i] = iHst[i]+nStp;
+						nExc -= nStp;
+					}
+                    if(nExc<0 )
+					nExc = 0;
+				}
+			}
+
+        j=4;
+        while(nExc>0) {
+            if(nExc>=55)
+            {
+                nStp = 1;
+                stp = nExc/55;
+            }
+            else
+            {
+                nStp = 55/nExc;
+                stp = 1;
+            }
+            for(i=j;i<=58;i+=nStp)
+			{
+                if(oHst[i]<cLmt)
+                {
+                    oHst[i] += stp;
+                    nExc -= stp;
+                }
+                if(nExc<=0)
+                    break;
+            }
+            j += 1;
+            if(j>58)
+                break;
+        }
+    }
+	if(low_range==0 && hgh_range==0)
+		nPnt = 0;
+	else
+	{
+		if(low_range==0 || hgh_range==0)
+		{
+			nPnt = 1;
+			mRng = (hgh_range>low_range ? hgh_range : low_range); //max
+		}
+		else if(low_range+hgh_range>=54)
+		{
+			nPnt = 1;
+			mRng = (hgh_range<low_range ? hgh_range : low_range); //min
+		}
+		else
+			nPnt = 2;
+	}
+	if(nPnt==0 && low_alpha>=16 && low_alpha<=32)
+	{
+		sum = 0;
+		for(i=5;i<=59;i++)
+		{
+			j = oHst[i]*(32-low_alpha)+tAvg*(low_alpha-16);
+			j = (j+8)>>4;
+			oHst[i] = j;
+			sum += j;
+			}
+    	}
+	else if(nPnt==1)
+	{
+		GetWgtLst(oHst+4, tAvg, mRng, low_alpha);
+		GetWgtLst(oHst+4+mRng, tAvg, 54-mRng, hgh_alpha);
+	}
+	else if(nPnt==2)
+	{
+		mRng = 55-(low_range+hgh_range);
+		GetWgtLst(oHst+4, tAvg, low_range, low_alpha);
+		GetWgtLst(oHst+4+low_range, tAvg, mRng, mid_alpha);
+		GetWgtLst(oHst+4+mRng+low_range, tAvg, hgh_range, hgh_alpha);
+	}
+	sum=0;
+	for(i=4;i<=58;i++)
+	{
+		if(oHst[i]>cLmt)
+			oHst[i] = cLmt;
+		sum += oHst[i];
+	}
+
+	nStp = 0;
+	//sum -= oHst[4];
+	for(i=5;i<=59;i++)//5,59
+	{
+		nStp += oHst[i-1];
+		//nStp += oHst[i];
+
+		j = (236-16)*nStp;
+		j += (sum>>1);
+		j /= sum;
+
+		ve_dnlp_tgt[i] = j + 16;
+	}
+	if(cnt)
+	{
+	for(i=0;i<64;i++)
+		printk(" ve_dnlp_tgtx[%ld]=%d\n",i,ve_dnlp_tgt[i]);
+	WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
+	}
+	return;
+}
+
+static void ve_dnlp_calculate_tgt(vframe_t *vf)
+{
+    struct vframe_prop_s *p = &vf->prop;
+    ulong data[5];
+	static unsigned int sum_b = 0, sum_c = 0;
+    ulong i = 0, j = 0, ave = 0, max = 0, div = 0;
+	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
+
+    // old historic luma sum
+    sum_b = sum_c;
+    sum_c = ve_dnlp_luma_sum;
+    // new historic luma sum
+    ve_dnlp_luma_sum = p->hist.luma_sum;
+	if(dnlp_debug)
+	printk("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
+
+    // picture mode: freeze dnlp curve
+    if(dnlp_respond)
+    {
+		if (// new luma sum is 0, something is wrong, freeze dnlp curve
+			(!ve_dnlp_luma_sum)
+		   )
+	    return;
+    }
+	else
+	{
+	    if (// new luma sum is 0, something is wrong, freeze dnlp curve
+	        (!ve_dnlp_luma_sum) ||
+	        // new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
+	        ((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&//5
+	         (ve_dnlp_luma_sum > sum_b - (sum_b >> dnlp_adj_level)) //5
+	        )
+	       )
+	    return;
+	}
+
+    // get 5 regions
+    for (i = 0; i < 5; i++)
+    {
+        j = 4 + 11 * i;
+        data[i] = (ulong)p->hist.gamma[j     ] +
+                  (ulong)p->hist.gamma[j +  1] +
+                  (ulong)p->hist.gamma[j +  2] +
+                  (ulong)p->hist.gamma[j +  3] +
+                  (ulong)p->hist.gamma[j +  4] +
+                  (ulong)p->hist.gamma[j +  5] +
+                  (ulong)p->hist.gamma[j +  6] +
+                  (ulong)p->hist.gamma[j +  7] +
+                  (ulong)p->hist.gamma[j +  8] +
+                  (ulong)p->hist.gamma[j +  9] +
+                  (ulong)p->hist.gamma[j + 10];
+    }
+
+    // get max, ave, div
+    for (i = 0; i < 5; i++)
+    {
+        if (max < data[i])
+            max = data[i];
+        ave += data[i];
+        data[i] *= 5;
+    }
+    max *= 5;
+    div = (max - ave > ave) ? max - ave : ave;
+
+    // invalid histgram: freeze dnlp curve
+    if (!max)
+        return;
+
+    // get 1st 4 points
+    for (i = 0; i < 4; i++)
+    {
+        if (data[i] > ave)
+            data[i] = 64 + (((data[i] - ave) << 1) + div) * ve_dnlp_rl / (div << 1);
+        else if (data[i] < ave)
+            data[i] = 64 - (((ave - data[i]) << 1) + div) * ve_dnlp_rl / (div << 1);
+        else
+            data[i] = 64;
+        ve_dnlp_tgt[4 + 11 * (i + 1)] = ve_dnlp_tgt[4 + 11 * i] +
+                                        ((44 * data[i] + 32) >> 6);
+    }
+
+    // fill in region 0 with black extension
+    data[0] = ve_dnlp_black;
+    if (data[0] > 16)
+        data[0] = 16;
+    data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[4]) * (16 - data[0]);
+    for (j = 1; j <= 6; j++)
+        ve_dnlp_tgt[4 + j] = ve_dnlp_tgt[4] + (data[0] * j + 88) / 176;
+    data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[10]) << 1;
+    for (j = 1; j <=4; j++)
+        ve_dnlp_tgt[10 + j] = ve_dnlp_tgt[10] + (data[0] * j + 5) / 10;
+
+    // fill in regions 1~3
+    for (i = 1; i <= 3; i++)
+    {
+        data[i] = (ve_dnlp_tgt[11 * i + 15] - ve_dnlp_tgt[11 * i + 4]) << 1;
+        for (j = 1; j <= 10; j++)
+            ve_dnlp_tgt[11 * i + 4 + j] = ve_dnlp_tgt[11 * i + 4] + (data[i] * j + 11) / 22;
+    }
+
+    // fill in region 4 with white extension
+    data[4] /= 20;
+    data[4] = (ve_dnlp_white * ((ave << 4) - data[4] * ve_dnlp_white_factor)  + (ave << 3)) / (ave << 4);
+    if (data[4] > 16)
+        data[4] = 16;
+    data[4] = (ve_dnlp_tgt[59] - ve_dnlp_tgt[48]) * (16 - data[4]);
+    for (j = 1; j <= 6; j++)
+        ve_dnlp_tgt[59 - j] = ve_dnlp_tgt[59] - (data[4] * j + 88) / 176;
+    data[4] = (ve_dnlp_tgt[53] - ve_dnlp_tgt[48]) << 1;
+    for (j = 1; j <= 4; j++)
+        ve_dnlp_tgt[53 - j] = ve_dnlp_tgt[53] - (data[4] * j + 5) / 10;
+	if(cnt)
+	{
+	for(i=0;i<64;i++)
+		printk(" ve_dnlp_tgt[%ld]=%d\n",i,ve_dnlp_tgt[i]);
+	WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
+	}
+
+}
+
+static void ve_dnlp_calculate_lpf(void) // lpf[0] is always 0 & no need calculation
+{
+    ulong i = 0;
+
+    for (i = 0; i < 64; i++) {
+        ve_dnlp_lpf[i] = ve_dnlp_lpf[i] - (ve_dnlp_lpf[i] >> ve_dnlp_rt) + ve_dnlp_tgt[i];
+    }
+}
+
+static void ve_dnlp_calculate_reg(void)
+{
+    ulong i = 0, j = 0, cur = 0, data = 0, offset = ve_dnlp_rt ? (1 << (ve_dnlp_rt - 1)) : 0;
+
+    for (i = 0; i < 16; i++)
+    {
+        ve_dnlp_reg[i] = 0;
+        cur = i << 2;
+        for (j = 0; j < 4; j++)
+        {
+            data = (ve_dnlp_lpf[cur + j] + offset) >> ve_dnlp_rt;
+            if (data > 255)
+                data = 255;
+            ve_dnlp_reg[i] |= data << (j << 3);
+        }
+    }
+}
+
+static void ve_dnlp_load_reg(void)
+{
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_00, ve_dnlp_reg[0]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_01, ve_dnlp_reg[1]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_02, ve_dnlp_reg[2]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_03, ve_dnlp_reg[3]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_04, ve_dnlp_reg[4]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_05, ve_dnlp_reg[5]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_06, ve_dnlp_reg[6]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_07, ve_dnlp_reg[7]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_08, ve_dnlp_reg[8]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_09, ve_dnlp_reg[9]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_10, ve_dnlp_reg[10]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_11, ve_dnlp_reg[11]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_12, ve_dnlp_reg[12]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_13, ve_dnlp_reg[13]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_14, ve_dnlp_reg[14]);
+    WRITE_CBUS_REG(VPP_DNLP_CTRL_15, ve_dnlp_reg[15]);
+}
+static unsigned int lock_range_50hz_fast =  7; // <= 14
+static unsigned int lock_range_50hz_slow =  7; // <= 14
+static unsigned int lock_range_60hz_fast =  5; // <=  4
+static unsigned int lock_range_60hz_slow =  2; // <= 10
+#define FLAG_LVDS_FREQ_SW1       (1 <<  6)
+
+void ve_on_vs(vframe_t *vf)
+{
+
+    if (ve_en) {
+        // calculate dnlp target data
+        if(ve_dnlp_method == 0)
+        ve_dnlp_calculate_tgt(vf);
+		else if(ve_dnlp_method == 1)
+		ve_dnlp_calculate_tgtx(vf);
+		else if(ve_dnlp_method == 2)
+		ve_dnlp_calculate_tgt_ext(vf);
+		else
+        ve_dnlp_calculate_tgt(vf);
+        // calculate dnlp low-pass-filter data
+        ve_dnlp_calculate_lpf();
+        // calculate dnlp reg data
+        ve_dnlp_calculate_reg();
+        // load dnlp reg data
+        ve_dnlp_load_reg();
+    }
+	ve_hist_gamma_tgt(vf);
+    /* comment for duration algorithm is not based on panel vsync */
+    if (vf->prop.meas.vs_cycle && !frame_lock_nosm)
+    {
+        if ((vecm_latch_flag & FLAG_LVDS_FREQ_SW1) &&
+          (vf->duration >= 1920 - 19) &&
+          (vf->duration <= 1920 + 19)
+         )
+            vpp_phase_lock_on_vs(vf->prop.meas.vs_cycle,
+                                 vf->prop.meas.vs_stamp,
+                                 true,
+                                 lock_range_50hz_fast,
+                                 lock_range_50hz_slow);
+        if ((!(vecm_latch_flag & FLAG_LVDS_FREQ_SW1)) &&
+          (vf->duration >= 1600 - 5) &&
+          (vf->duration <= 1600 + 13)
+         )
+            vpp_phase_lock_on_vs(vf->prop.meas.vs_cycle,
+                                 vf->prop.meas.vs_stamp,
+                                 false,
+                                 lock_range_60hz_fast,
+                                 lock_range_60hz_slow);
+    }
+
+}
+EXPORT_SYMBOL(ve_on_vs);
+
+// ***************************************************************************
+// *** IOCTL-oriented functions *********************************************
+// ***************************************************************************
+
+void vpp_enable_lcd_gamma_table(void)
+{
+    WRITE_MPEG_REG_BITS(L_GAMMA_CNTL_PORT, 1, GAMMA_EN, 1);
+}
+
+void vpp_disable_lcd_gamma_table(void)
+{
+    WRITE_MPEG_REG_BITS(L_GAMMA_CNTL_PORT, 0, GAMMA_EN, 1);
+}
+
+void vpp_set_lcd_gamma_table(u16 *data, u32 rgb_mask)
+{
+    int i;
+
+    while (!(READ_MPEG_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY)));
+    WRITE_MPEG_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
+                                    (0x1 << rgb_mask)   |
+                                    (0x0 << HADR));
+    for (i=0;i<256;i++) {
+        while (!( READ_MPEG_REG(L_GAMMA_CNTL_PORT) & (0x1 << WR_RDY) )) ;
+        WRITE_MPEG_REG(L_GAMMA_DATA_PORT, data[i]);
+    }
+    while (!(READ_MPEG_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY)));
+    WRITE_MPEG_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
+                                    (0x1 << rgb_mask)   |
+                                    (0x23 << HADR));
+}
+
+void vpp_set_rgb_ogo(struct tcon_rgb_ogo_s *p)
+{
+
+    // write to registers
+    WRITE_CBUS_REG(VPP_GAINOFF_CTRL0, ((p->en            << 31) & 0x80000000) |
+                                      ((p->r_gain        << 16) & 0x07ff0000) |
+                                      ((p->g_gain        <<  0) & 0x000007ff));
+    WRITE_CBUS_REG(VPP_GAINOFF_CTRL1, ((p->b_gain        << 16) & 0x07ff0000) |
+                                      ((p->r_post_offset <<  0) & 0x000007ff));
+    WRITE_CBUS_REG(VPP_GAINOFF_CTRL2, ((p->g_post_offset << 16) & 0x07ff0000) |
+                                      ((p->b_post_offset <<  0) & 0x000007ff));
+    WRITE_CBUS_REG(VPP_GAINOFF_CTRL3, ((p->r_pre_offset  << 16) & 0x07ff0000) |
+                                      ((p->g_pre_offset  <<  0) & 0x000007ff));
+    WRITE_CBUS_REG(VPP_GAINOFF_CTRL4, ((p->b_pre_offset  <<  0) & 0x000007ff));
+
+}
+
+void ve_enable_dnlp(void)
+{
+    ve_en = 1;
+    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+}
+
+void ve_disable_dnlp(void)
+{
+    ve_en = 0;
+    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+}
+
+void ve_set_dnlp(struct ve_dnlp_s *p)
+{
+    ulong i = 0;
+
+    // get command parameters
+    ve_en                = p->en;
+    ve_dnlp_white_factor = (p->rt >> 4) & 0xf;
+    ve_dnlp_rt           = p->rt & 0xf;
+    ve_dnlp_rl           = p->rl;
+    ve_dnlp_black        = p->black;
+    ve_dnlp_white        = p->white;
+    if (ve_en)
+    {
+        // clear historic luma sum
+        ve_dnlp_luma_sum = 0;
+        // init tgt & lpf
+        for (i = 0; i < 64; i++) {
+            ve_dnlp_tgt[i] = i << 2;
+            ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
+        }
+        // calculate dnlp reg data
+        ve_dnlp_calculate_reg();
+        // load dnlp reg data
+        ve_dnlp_load_reg();
+#ifdef NEW_DNLP_AFTER_PEAKING
+        // enable dnlp
+        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 1, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
+    }
+    else
+    {
+        // disable dnlp
+        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 0, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
+    }
+#else
+        // enable dnlp
+        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+    }
+    else
+    {
+        // disable dnlp
+        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+    }
+#endif
+}
+
+void ve_set_new_dnlp(struct ve_dnlp_table_s *p)
+{
+    ulong i = 0;
+
+    // get command parameters
+    ve_en                = p->en;
+	ve_dnlp_method       = p->method;
+    ve_dnlp_cliprate     = p->cliprate;
+    ve_dnlp_hghrange     = p->hghrange;
+    ve_dnlp_lowrange     = p->lowrange;
+    ve_dnlp_hghalpha     = p->hghalpha;
+    ve_dnlp_midalpha     = p->midalpha;
+    ve_dnlp_lowalpha     = p->lowalpha;
+
+    if (ve_en)
+    {
+        // clear historic luma sum
+        ve_dnlp_luma_sum = 0;
+        // init tgt & lpf
+        for (i = 0; i < 64; i++) {
+            ve_dnlp_tgt[i] = i << 2;
+            ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
+        }
+        // calculate dnlp reg data
+        ve_dnlp_calculate_reg();
+        // load dnlp reg data
+        ve_dnlp_load_reg();
+#ifdef NEW_DNLP_AFTER_PEAKING
+        // enable dnlp
+        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 1, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
+    }
+    else
+    {
+        // disable dnlp
+        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 0, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
+    }
+#else
+        // enable dnlp
+        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+    }
+    else
+    {
+        // disable dnlp
+        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+    }
+#endif
+}
+unsigned int ve_get_vs_cnt(void)
+{
+    return (READ_CBUS_REG(VPP_VDO_MEAS_VS_COUNT_LO));
+}
+
+unsigned int vpp_log[128][10];
+
+void vpp_phase_lock_on_vs(unsigned int cycle,
+                          unsigned int stamp,
+                          bool         lock50,
+                          unsigned int range_fast,
+                          unsigned int range_slow)
+{
+    unsigned int vtotal_ori = READ_CBUS_REG(ENCL_VIDEO_MAX_LNCNT);
+    unsigned int vtotal     = lock50 ? 1349 : 1124;
+	unsigned int stamp_in   = READ_CBUS_REG(VDIN_MEAS_VS_COUNT_LO);
+    unsigned int stamp_out  = ve_get_vs_cnt();
+    unsigned int phase      = 0;
+	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
+	int step = 0, i = 0;
+
+    // get phase
+    if (stamp_out < stamp)
+        phase = 0xffffffff - stamp + stamp_out + 1;
+    else
+        phase = stamp_out - stamp;
+    while (phase >= cycle)
+        phase -= cycle;
+    // 225~315 degree => tune fast panel output
+    if ((phase > ((cycle * 5) >> 3)) &&
+        (phase < ((cycle * 7) >> 3))
+       )
+    {
+        vtotal -= range_slow;
+		step = 1;
+    }
+    // 45~135 degree => tune slow panel output
+    else if ((phase > ( cycle      >> 3)) &&
+             (phase < ((cycle * 3) >> 3))
+            )
+    {
+        vtotal += range_slow;
+		step = -1;
+    }
+    // 315~360 degree => tune fast panel output
+    else if (phase >= ((cycle * 7) >> 3))
+    {
+        vtotal -= range_fast;
+		step = +2;
+    }
+    // 0~45 degree => tune slow panel output
+    else if (phase <= (cycle >> 3))
+    {
+        vtotal += range_fast;
+		step = -2;
+    }
+    // 135~225 degree => keep still
+    else
+    {
+        vtotal = vtotal_ori;
+		step = 0;
+    }
+    if (vtotal != vtotal_ori)
+        WRITE_CBUS_REG(ENCL_VIDEO_MAX_LNCNT, vtotal);
+    if (cnt)
+    {
+        cnt--;
+        WRITE_CBUS_REG(ASSIST_SPARE8_REG1, cnt);
+        if (cnt)
+        {
+            vpp_log[cnt][0] = stamp;
+            vpp_log[cnt][1] = stamp_in;
+            vpp_log[cnt][2] = stamp_out;
+            vpp_log[cnt][3] = cycle;
+            vpp_log[cnt][4] = phase;
+            vpp_log[cnt][5] = vtotal;
+            vpp_log[cnt][6] = step;
+        }
+        else
+        {
+            for (i = 127; i > 0; i--)
+            {
+                printk("Ti=%10u Tio=%10u To=%10u CY=%6u PH =%10u Vt=%4u S=%2d\n",
+                       vpp_log[i][0],
+                       vpp_log[i][1],
+                       vpp_log[i][2],
+                       vpp_log[i][3],
+                       vpp_log[i][4],
+                       vpp_log[i][5],
+                       vpp_log[i][6]
+                       );
+            }
+            }
+        }
+
+}
+
diff --git a/drivers/amlogic/amvecm/amve.h b/drivers/amlogic/amvecm/amve.h
new file mode 100755
index 000000000000..5b71775ae13a
--- /dev/null
+++ b/drivers/amlogic/amvecm/amve.h
@@ -0,0 +1,68 @@
+/*
+ * Video Enhancement
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __AM_VE_H
+#define __AM_VE_H
+
+#include "linux/amlogic/vframe.h"
+#include "linux/amlogic/ve.h"
+
+typedef struct ve_regs_s {
+    unsigned int val  : 32;
+    unsigned int reg  : 14;
+    unsigned int port :  2; // port port_addr            port_data            remark
+                        // 0    NA                   NA                   direct access
+                        // 1    VPP_CHROMA_ADDR_PORT VPP_CHROMA_DATA_PORT CM port registers
+                        // 2    NA                   NA                   reserved
+                        // 3    NA                   NA                   reserved
+    unsigned int bit  :  5;
+    unsigned int wid  :  5;
+    unsigned int mode :  1; // 0:read, 1:write
+    unsigned int rsv  :  5;
+} ve_regs_t;
+
+
+//void ve_on_vs(vframe_t *vf, int* change_notify);
+
+void ve_set_bext(struct ve_bext_s *p);
+void ve_set_dnlp(struct ve_dnlp_s *p);
+void ve_set_new_dnlp(struct ve_dnlp_table_s *p);
+void ve_set_hsvs(struct ve_hsvs_s *p);
+void ve_set_ccor(struct ve_ccor_s *p);
+void ve_set_benh(struct ve_benh_s *p);
+void ve_set_demo(struct ve_demo_s *p);
+void ve_set_regs(struct ve_regs_s *p);
+void ve_set_regmap(struct ve_regmap_s *p);
+extern struct ve_hist_s video_ve_hist;
+extern void ve_enable_dnlp(void);
+extern void ve_disable_dnlp(void);
+
+extern void vpp_enable_lcd_gamma_table(void);
+extern void vpp_disable_lcd_gamma_table(void);
+extern void vpp_set_lcd_gamma_table(u16 *data, u32 rgb_mask);
+extern void vpp_set_rgb_ogo(struct tcon_rgb_ogo_s *p);
+extern void vd1_brightness_contrast(signed int brightness, signed int contrast);
+extern void vpp_phase_lock_on_vs(unsigned int cycle,
+                                 unsigned int stamp,
+                                 bool         lock50,
+                                 unsigned int range_fast,
+                                 unsigned int range_slow);
+
+extern unsigned int vecm_latch_flag;
+extern unsigned int cm_size;
+//#if defined(CONFIG_ARCH_MESON2)
+//unsigned long long ve_get_vs_cnt(void);
+//#endif
+
+#endif
+
diff --git a/drivers/amlogic/amvecm/amvecm.c b/drivers/amlogic/amvecm/amvecm.c
new file mode 100755
index 000000000000..d3dd6b08eca3
--- /dev/null
+++ b/drivers/amlogic/amvecm/amvecm.c
@@ -0,0 +1,1276 @@
+/*
+ * amvecm char device driver.
+ *
+ * Copyright (c) 2010 Frank Zhao<frank.zhao@amlogic.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the smems of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+/* Standard Linux headers */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include <linux/amlogic/aml_common.h>
+
+
+#include <mach/am_regs.h>
+#include <linux/amlogic/vframe.h>
+
+#include <linux/amlogic/amvecm.h>        /* For user used */
+#include "ve_regs.h"
+#include "amve.h"
+#include "cm_regs.h"
+#include "amcm.h"
+
+/* local defines */
+#define AMVECM_COUNT              1
+
+#define AMVECM_NAME               "amvecm"
+#define AMVECM_DRIVER_NAME        "amvecm"
+#define AMVECM_MODULE_NAME        "amvecm"
+#define AMVECM_DEVICE_NAME        "amvecm"
+#define AMVECM_CLASS_NAME         "amvecm"
+
+typedef struct amvecm_dev_s {
+    dev_t                       devt;
+    struct cdev                 cdev;
+    dev_t                       devno;
+    struct device               *dev;
+    struct class                *clsp;
+} amvecm_dev_t;
+
+static bool hold_cmd_en = 0;
+module_param(hold_cmd_en, bool, 0664);
+MODULE_PARM_DESC(hold_cmd_en, "\n hold_cmd_en \n");
+
+static struct amvecm_dev_s amvecm_dev;
+static struct ve_dnlp_s am_ve_dnlp;
+static struct ve_dnlp_table_s am_ve_new_dnlp;
+
+unsigned int vecm_latch_flag;
+unsigned int cm_size;
+static int video_rgb_ogo_mode_sw = 0;
+static signed int vd1_brightness = 0, vd1_contrast = 0;
+extern unsigned int cm2_patch_flag;
+
+static struct am_regs_s amregs0;
+static struct am_regs_s amregs1;
+static struct am_regs_s amregs2;
+static struct am_regs_s amregs3;
+static struct am_regs_s amregs4;
+static struct am_regs_s amregs5;
+
+module_param(video_rgb_ogo_mode_sw, int, 0664);
+MODULE_PARM_DESC(video_rgb_ogo_mode_sw, "enable/disable video_rgb_ogo_mode_sw");
+
+static int frame_lock_freq = 0;
+module_param(frame_lock_freq, int, 0664);
+MODULE_PARM_DESC(frame_lock_freq, "frame_lock_50");
+
+/*
+* set the frame size for cm2 demo
+*/
+static void cm2_frame_switch_patch(void)
+{
+	WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x20f);
+	WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, cm2_patch_flag);
+}
+
+static void cm2_frame_size_patch(void)
+{
+    unsigned int vpp_size , hs, he, vs, ve;
+    /*check if the cm2 enable/disable to config the cm2 size*/
+    if(!(READ_CBUS_REG(VPP_MISC)&(0x1<<28)))
+        return;
+
+    hs = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,16,12);
+    he = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,0,12);
+
+    vs = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,16,12);
+    ve = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,0,12);
+
+    vpp_size = (he - hs + 1) | ((ve - vs + 1) << 16);
+    if(cm_size == 0){
+         WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x205);
+         cm_size = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
+    }
+    if (cm_size != vpp_size) {
+        WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x205);
+        WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, vpp_size);
+        WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x209);
+        WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (he-hs+1)<<15);
+        WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x20a);
+        WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (ve-vs+1)<<16);
+        cm_size =  vpp_size;
+    }
+#ifdef PQ_DEBUG_EN
+	printk("\n[amvecm..]cm2_frame_patch: set cm2 framesize %x, set demo mode  %x\n",vpp_size, cm2_patch_flag);
+#endif
+}
+
+void amvecm_video_latch(void)
+{
+    if ((vecm_latch_flag & FLAG_REG_MAP0) ||
+    	(vecm_latch_flag & FLAG_REG_MAP1) ||
+    	(vecm_latch_flag & FLAG_REG_MAP2) ||
+    	(vecm_latch_flag & FLAG_REG_MAP3) ||
+    	(vecm_latch_flag & FLAG_REG_MAP4) ||
+    	(vecm_latch_flag & FLAG_REG_MAP5)
+       )
+    {
+    	if (vecm_latch_flag & FLAG_REG_MAP0) {
+            am_set_regmap(&amregs0);
+            vecm_latch_flag &= ~FLAG_REG_MAP0;
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] load reg 0 table OK!!!\n");
+#endif
+    	}
+    	if (vecm_latch_flag & FLAG_REG_MAP1) {
+            am_set_regmap(&amregs1);
+            vecm_latch_flag &= ~FLAG_REG_MAP1;
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] load reg 1 table OK!!!\n");
+#endif
+    	}
+    	if (vecm_latch_flag & FLAG_REG_MAP2) {
+            am_set_regmap(&amregs2);
+            vecm_latch_flag &= ~FLAG_REG_MAP2;
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] load reg 2 table OK!!!\n");
+#endif
+    	}
+    	if (vecm_latch_flag & FLAG_REG_MAP3) {
+            am_set_regmap(&amregs3);
+            vecm_latch_flag &= ~FLAG_REG_MAP3;
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] load reg 3 table OK!!!\n");
+#endif
+    	}
+    	if (vecm_latch_flag & FLAG_REG_MAP4) {
+            am_set_regmap(&amregs4);
+            vecm_latch_flag &= ~FLAG_REG_MAP4;
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] load reg 4 table OK!!!\n");
+#endif
+    	}
+    	if (vecm_latch_flag & FLAG_REG_MAP5) {
+            am_set_regmap(&amregs5);
+            vecm_latch_flag &= ~FLAG_REG_MAP5;
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] load reg 5 table OK!!!\n");
+#endif
+    	}
+
+		if((cm2_patch_flag & 0xff) > 0)
+		cm2_frame_switch_patch();
+    }
+    cm2_frame_size_patch();
+    if (vecm_latch_flag & FLAG_VE_DNLP)
+    {
+        vecm_latch_flag &= ~FLAG_VE_DNLP;
+        ve_set_dnlp(&am_ve_dnlp);
+    }
+    if (vecm_latch_flag & FLAG_VE_NEW_DNLP)
+    {
+        vecm_latch_flag &= ~FLAG_VE_NEW_DNLP;
+        ve_set_new_dnlp(&am_ve_new_dnlp);
+    }
+	if (vecm_latch_flag & FLAG_VE_DNLP_EN)
+	{
+		vecm_latch_flag &= ~FLAG_VE_DNLP_EN;
+		ve_enable_dnlp();
+#ifdef PQ_DEBUG_EN
+		printk("\n[amvecm..] set vpp_enable_dnlp OK!!!\n");
+#endif
+	}
+	if (vecm_latch_flag & FLAG_VE_DNLP_DIS)
+	{
+		vecm_latch_flag &= ~FLAG_VE_DNLP_DIS;
+		ve_disable_dnlp();
+#ifdef PQ_DEBUG_EN
+		printk("\n[amvecm..] set vpp_disable_dnlp OK!!!\n");
+#endif
+	}
+    if (vecm_latch_flag & FLAG_GAMMA_TABLE_EN)
+    {
+        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_EN;
+        vpp_enable_lcd_gamma_table();
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] set vpp_enable_lcd_gamma_table OK!!!\n");
+#endif
+    }
+    if (vecm_latch_flag & FLAG_GAMMA_TABLE_DIS)
+    {
+        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_DIS;
+        vpp_disable_lcd_gamma_table();
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] set vpp_disable_lcd_gamma_table OK!!!\n");
+#endif
+    }
+    if (vecm_latch_flag & FLAG_GAMMA_TABLE_R)
+    {
+        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_R;
+        vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
+#endif
+    }
+    if (vecm_latch_flag & FLAG_GAMMA_TABLE_G)
+    {
+        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_G;
+        vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
+#endif
+    }
+    if (vecm_latch_flag & FLAG_GAMMA_TABLE_B)
+    {
+        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_B;
+        vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
+#endif
+    }
+    if (vecm_latch_flag & FLAG_RGB_OGO)
+    {
+        vecm_latch_flag &= ~FLAG_RGB_OGO;
+        if (video_rgb_ogo_mode_sw)
+        {
+            if (video_rgb_ogo.en)
+            {
+                vpp_set_lcd_gamma_table(video_gamma_table_r_adj.data, H_SEL_R);
+                vpp_set_lcd_gamma_table(video_gamma_table_g_adj.data, H_SEL_G);
+                vpp_set_lcd_gamma_table(video_gamma_table_b_adj.data, H_SEL_B);
+            }
+            else
+            {
+                vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
+                vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
+                vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
+            }
+	#ifdef PQ_DEBUG_EN
+            printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
+	#endif
+        }
+        else
+        {
+            vpp_set_rgb_ogo(&video_rgb_ogo);
+	#ifdef PQ_DEBUG_EN
+            printk("\n[amvecm..] set vpp_set_rgb_ogo OK!!!\n");
+	#endif
+        }
+    }
+    if (vecm_latch_flag & FLAG_BRI_CON)
+    {
+        vecm_latch_flag &= ~FLAG_BRI_CON;
+        vd1_brightness_contrast(vd1_brightness, vd1_contrast);
+#ifdef PQ_DEBUG_EN
+        printk("\n[amvecm..] set vd1_brightness_contrast OK!!!\n");
+#endif
+    }
+    /* lvds freq 50Hz/60Hz */
+    if (frame_lock_freq == 1)  //50 hz
+    {
+        // panel freq is 60Hz => change back to 50Hz
+        if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) < 1237) // (1124 + 1349 +1) / 2
+        {
+            WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1349);
+        }
+    }
+    else if (frame_lock_freq == 2)  //60 hz
+    {
+        // panel freq is 50Hz => change back to 60Hz
+        if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) >= 1237) // (1124 + 1349 + 1) / 2
+        {
+            WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1124);
+        }
+    }
+    else if (frame_lock_freq == 0)
+    {
+        /* lvds freq 50Hz/60Hz */
+        if (vecm_latch_flag & FLAG_LVDS_FREQ_SW)  //50 hz
+        {
+            // panel freq is 60Hz => change back to 50Hz
+            if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) < 1237) // (1124 + 1349 +1) / 2
+            {
+                WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1349);
+            }
+        }
+        else   //60 hz
+        {
+            // panel freq is 50Hz => change back to 60Hz
+            if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) >= 1237) // (1124 + 1349 + 1) / 2
+            {
+                WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1124);
+            }
+        }
+    }
+
+}
+EXPORT_SYMBOL(amvecm_video_latch);
+
+/*
+amvecm device driver
+*/
+struct tcon_gamma_table_s video_curve_2d2_inv =
+{
+	{
+	   0,	82,  113,  136,  155,  171,  186,  199,  212,  223,  234,  245,  255,  264,  273,  282,
+	 290,  298,  306,  314,  321,  328,  335,  342,  349,  356,  362,  368,  374,  380,  386,  392,
+	 398,  403,  409,  414,  420,  425,  430,  435,  440,  445,  450,  455,  460,  464,  469,  474,
+	 478,  483,  487,  492,  496,  500,  505,  509,  513,  517,  521,  525,  529,  533,  537,  541,
+	 545,  549,  553,  556,  560,  564,  568,  571,  575,  579,  582,  586,  589,  593,  596,  600,
+	 603,  607,  610,  613,  617,  620,  623,  627,  630,  633,  636,  640,  643,  646,  649,  652,
+	 655,  658,  661,  665,  668,  671,  674,  677,  680,  683,  686,  688,  691,  694,  697,  700,
+	 703,  706,  709,  711,  714,  717,  720,  723,  725,  728,  731,  733,  736,  739,  742,  744,
+	 747,  750,  752,  755,  757,  760,  763,  765,  768,  770,  773,  775,  778,  780,  783,  785,
+	 788,  790,  793,  795,  798,  800,  803,  805,  808,  810,  812,  815,  817,  820,  822,  824,
+	 827,  829,  831,  834,  836,  838,  841,  843,  845,  847,  850,  852,  854,  856,  859,  861,
+	 863,  865,  868,  870,  872,  874,  876,  879,  881,  883,  885,  887,  889,  892,  894,  896,
+	 898,  900,  902,  904,  906,  909,  911,  913,  915,  917,  919,  921,  923,  925,  927,  929,
+	 931,  933,  935,  937,  939,  941,  943,  945,  947,  949,  951,  953,  955,  957,  959,  961,
+	 963,  965,  967,  969,  971,  973,  975,  977,  979,  981,  982,  984,  986,  988,  990,  992,
+	 994,  996,  998,  999, 1001, 1003, 1005, 1007, 1009, 1011, 1012, 1014, 1016, 1018, 1020, 1022,
+	},
+};
+
+struct tcon_gamma_table_s video_curve_2d2 =
+{
+	{
+	   0,	 0,    0,	 0,    0,	 0,    0,	 0,    1,	 1,    1,	 1,    1,	 1,    2,	 2,
+	   2,	 3,    3,	 3,    4,	 4,    5,	 5,    6,	 6,    7,	 7,    8,	 9,    9,	10,
+	  11,	11,   12,	13,   14,	15,   15,	16,   17,	18,   19,	20,   21,	22,   23,	25,
+	  26,	27,   28,	29,   31,	32,   33,	35,   36,	38,   39,	41,   42,	44,   45,	47,
+	  49,	50,   52,	54,   55,	57,   59,	61,   63,	65,   67,	69,   71,	73,   75,	77,
+	  79,	82,   84,	86,   88,	91,   93,	95,   98,  100,  103,  105,  108,  110,  113,  116,
+	 118,  121,  124,  127,  130,  132,  135,  138,  141,  144,  147,  150,  154,  157,  160,  163,
+	 166,  170,  173,  176,  180,  183,  187,  190,  194,  197,  201,  204,  208,  212,  216,  219,
+	 223,  227,  231,  235,  239,  243,  247,  251,  255,  259,  263,  267,  272,  276,  280,  285,
+	 289,  294,  298,  303,  307,  312,  316,  321,  326,  330,  335,  340,  345,  350,  355,  360,
+	 365,  370,  375,  380,  385,  390,  395,  401,  406,  411,  417,  422,  427,  433,  438,  444,
+	 450,  455,  461,  467,  472,  478,  484,  490,  496,  502,  508,  514,  520,  526,  532,  538,
+	 544,  551,  557,  563,  570,  576,  583,  589,  596,  602,  609,  615,  622,  629,  636,  642,
+	 649,  656,  663,  670,  677,  684,  691,  698,  705,  713,  720,  727,  735,  742,  749,  757,
+	 764,  772,  779,  787,  795,  802,  810,  818,  826,  833,  841,  849,  857,  865,  873,  881,
+	 889,  898,  906,  914,  922,  931,  939,  948,  956,  965,  973,  982,  990,  999, 1008, 1016,
+	},
+};
+
+static void video_data_limitation(int *val)
+{
+	if (*val > 1023)
+		*val = 1023;
+	if (*val <	  0)
+		*val =	  0;
+}
+
+static void video_lookup(struct tcon_gamma_table_s *tbl, int *val)
+{
+	unsigned int idx = (*val) >> 2, mod = (*val) & 3;
+
+	if (idx < 255)
+		*val = tbl->data[idx] + (((tbl->data[idx + 1] - tbl->data[idx]) * mod + 2) >> 2);
+	else
+		*val = tbl->data[idx] + (((1023 			  - tbl->data[idx]) * mod + 2) >> 2);
+}
+
+static void video_set_rgb_ogo(void)
+{
+	int i = 0, r = 0, g = 0, b = 0;
+
+	for (i = 0; i < 256; i++)
+	{
+		// Get curve_straight = input(curve_2d2_inv) * video_curve_2d2
+		r = video_curve_2d2.data[i];
+		g = video_curve_2d2.data[i];
+		b = video_curve_2d2.data[i];
+		// Pre_offset
+		r += video_rgb_ogo.r_pre_offset;
+		g += video_rgb_ogo.g_pre_offset;
+		b += video_rgb_ogo.b_pre_offset;
+		video_data_limitation(&r);
+		video_data_limitation(&g);
+		video_data_limitation(&b);
+		// Gain
+		r  *= video_rgb_ogo.r_gain;
+		r >>= 10;
+		g  *= video_rgb_ogo.g_gain;
+		g >>= 10;
+		b  *= video_rgb_ogo.b_gain;
+		b >>= 10;
+		video_data_limitation(&r);
+		video_data_limitation(&g);
+		video_data_limitation(&b);
+		// Post_offset
+		r += video_rgb_ogo.r_post_offset;
+		g += video_rgb_ogo.g_post_offset;
+		b += video_rgb_ogo.b_post_offset;
+		video_data_limitation(&r);
+		video_data_limitation(&g);
+		video_data_limitation(&b);
+		// Get curve_2d2_inv_ogo = curve_straight_ogo * video_curve_2d2_inv
+		video_lookup(&video_curve_2d2_inv, &r);
+		video_lookup(&video_curve_2d2_inv, &g);
+		video_lookup(&video_curve_2d2_inv, &b);
+		// Get gamma_ogo = curve_2d2_inv_ogo * gamma
+		video_lookup(&video_gamma_table_r, &r);
+		video_lookup(&video_gamma_table_g, &g);
+		video_lookup(&video_gamma_table_b, &b);
+		// Save gamma_ogo
+		video_gamma_table_r_adj.data[i] = r;
+		video_gamma_table_g_adj.data[i] = g;
+		video_gamma_table_b_adj.data[i] = b;
+	}
+}
+
+void vd1_brightness_contrast(signed int brightness, signed int contrast)
+{
+      signed int ao0 =  -64, g00 = 1024, g01 =    0, g02 =    0, po0 =  64;
+      signed int ao1 = -512, g10 =    0, g11 = 1024, g12 =    0, po1 = 512;
+      signed int ao2 = -512, g20 =    0, g21 =    0, g22 = 1024, po2 = 512;
+    unsigned int gc0 =    0, gc1 =    0, gc2 =    0, gc3 =    0, gc4 =   0;
+    unsigned int a01 =    0, a_2 =    0, p01 =    0, p_2 =    0;
+    // enable vd0_csc
+    unsigned int ori = READ_CBUS_REG(VPP_MATRIX_CTRL) | 0x00000020;
+    // point to vd0_csc
+    unsigned int ctl = (ori & 0xfffffcff) | 0x00000100;
+
+    po0 += brightness >> 1;
+    if (po0 >  1023)
+        po0 =  1023;
+    if (po0 < -1024)
+        po0 = -1024;
+
+    g00  *= contrast + 2048;
+    g00 >>= 11;
+    if (g00 >  4095)
+        g00 =  4095;
+    if (g00 < -4096)
+        g00 = -4096;
+
+    if (contrast < 0)
+    {
+        g11  *= contrast   + 2048;
+        g11 >>= 11;
+    }
+
+    if (brightness < 0)
+    {
+        g11  += brightness >> 1;
+        if (g11 >  4095)
+            g11 =  4095;
+        if (g11 < -4096)
+            g11 = -4096;
+    }
+
+    if (contrast < 0)
+    {
+        g22  *= contrast   + 2048;
+        g22 >>= 11;
+    }
+
+    if (brightness < 0)
+    {
+        g22  += brightness >> 1;
+        if (g22 >  4095)
+            g22 =  4095;
+        if (g22 < -4096)
+            g22 = -4096;
+    }
+
+    gc0 = ((g00 << 16) & 0x1fff0000) |
+          ((g01 <<  0) & 0x00001fff);
+    gc1 = ((g02 << 16) & 0x1fff0000) |
+          ((g10 <<  0) & 0x00001fff);
+    gc2 = ((g11 << 16) & 0x1fff0000) |
+          ((g12 <<  0) & 0x00001fff);
+    gc3 = ((g20 << 16) & 0x1fff0000) |
+          ((g21 <<  0) & 0x00001fff);
+    gc4 = ((g22 <<  0) & 0x00001fff);
+    a01 = ((ao0 << 16) & 0x07ff0000) |
+          ((ao1 <<  0) & 0x000007ff);
+    a_2 = ((ao2 <<  0) & 0x000007ff);
+    p01 = ((po0 << 16) & 0x07ff0000) |
+          ((po1 <<  0) & 0x000007ff);
+    p_2 = ((po2 <<  0) & 0x000007ff);
+
+    WRITE_CBUS_REG(VPP_MATRIX_CTRL         , ctl);
+    WRITE_CBUS_REG(VPP_MATRIX_COEF00_01    , gc0);
+    WRITE_CBUS_REG(VPP_MATRIX_COEF02_10    , gc1);
+    WRITE_CBUS_REG(VPP_MATRIX_COEF11_12    , gc2);
+    WRITE_CBUS_REG(VPP_MATRIX_COEF20_21    , gc3);
+    WRITE_CBUS_REG(VPP_MATRIX_COEF22       , gc4);
+    WRITE_CBUS_REG(VPP_MATRIX_PRE_OFFSET0_1, a01);
+    WRITE_CBUS_REG(VPP_MATRIX_PRE_OFFSET2  , a_2);
+    WRITE_CBUS_REG(VPP_MATRIX_OFFSET0_1    , p01);
+    WRITE_CBUS_REG(VPP_MATRIX_OFFSET2      , p_2);
+    WRITE_CBUS_REG(VPP_MATRIX_CTRL         , ori);
+}
+
+static int amvecm_open(struct inode *inode, struct file *file)
+{
+    amvecm_dev_t *devp;
+
+    /* Get the per-device structure that contains this cdev */
+    devp = container_of(inode->i_cdev, amvecm_dev_t, cdev);
+    file->private_data = devp;
+
+    return 0;
+}
+
+static int amvecm_release(struct inode *inode, struct file *file)
+{
+    //amvecm_dev_t *devp = file->private_data;
+
+    file->private_data = NULL;
+
+    return 0;
+}
+
+static long amvecm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+
+    switch (cmd)
+    {
+		case AMVECM_IOC_LOAD_REG: {
+#if 1
+		    if ((vecm_latch_flag & FLAG_REG_MAP0) &&
+		    	(vecm_latch_flag & FLAG_REG_MAP1) &&
+		    	(vecm_latch_flag & FLAG_REG_MAP2) &&
+		    	(vecm_latch_flag & FLAG_REG_MAP3) &&
+		    	(vecm_latch_flag & FLAG_REG_MAP4) &&
+		    	(vecm_latch_flag & FLAG_REG_MAP5)
+		       ) {
+		           ret = -EBUSY;
+			   printk(KERN_ERR "[amvecm..] load regs error: loading regs, please wait\n");
+			   goto out;
+		    }
+		    ret = -EFAULT;
+                    /*force set cm size to 0,enable check vpp size*/
+                    cm_size = 0;
+		    if (!(vecm_latch_flag & FLAG_REG_MAP0)) {
+		        if (copy_from_user(&amregs0, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..]0 load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs0.length || (amregs0.length > 512)) {
+				printk(KERN_ERR "[amvecm..]0 load regs error: buffer length overflow!!!, length=0x%x \n",
+					amregs0.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..]0 reg length=0x%x ......\n", amregs0.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP0;
+		        ret = 0;
+			goto out;
+		    }
+		    if (!(vecm_latch_flag & FLAG_REG_MAP1)) {
+		        if (copy_from_user(&amregs1, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..]1 load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs1.length || (amregs1.length > 512)) {
+				printk(KERN_ERR "[amvecm..]1 load regs error: buffer length overflow!!!, length=0x%x \n",
+					amregs1.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..]1 reg length=0x%x ......\n", amregs1.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP1;
+		        ret = 0;
+			goto out;
+		    }
+		    if (!(vecm_latch_flag & FLAG_REG_MAP2)) {
+		        if (copy_from_user(&amregs2, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..]2 load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs2.length || (amregs2.length > 512)) {
+				printk(KERN_ERR "[amvecm..]2 load regs error: buffer length overflow!!!, length=0x%x \n",
+					amregs2.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..]2 reg length=0x%x ......\n", amregs1.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP2;
+		        ret = 0;
+			goto out;
+		    }
+		    if (!(vecm_latch_flag & FLAG_REG_MAP3)) {
+		        if (copy_from_user(&amregs3, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..]3 load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs3.length || (amregs3.length > 512)) {
+				printk(KERN_ERR "[amvecm..]3 load regs error: buffer length overflow!!!, length=0x%x \n",
+					amregs3.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..]3 reg length=0x%x ......\n", amregs3.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP3;
+		        ret = 0;
+			goto out;
+		    }
+		    if (!(vecm_latch_flag & FLAG_REG_MAP4)) {
+		        if (copy_from_user(&amregs4, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..]4 load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs4.length || (amregs4.length > 512)) {
+				printk(KERN_ERR "[amvecm..]4 load regs error: buffer length overflow!!!, length=0x%x \n",
+					amregs4.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..]4 reg length=0x%x ......\n", amregs1.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP4;
+		        ret = 0;
+			goto out;
+		    }
+		    if (!(vecm_latch_flag & FLAG_REG_MAP5)) {
+		        if (copy_from_user(&amregs5, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..]5 load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs5.length || (amregs5.length > 512)) {
+				printk(KERN_ERR "[amvecm..]5 load regs error: buffer length overflow!!!, length=0x%x \n",
+					amregs5.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..]5 reg length=0x%x ......\n", amregs5.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP5;
+		        ret = 0;
+			goto out;
+		    }
+
+#else
+			if (vecm_latch_flag & FLAG_REG_MAP)
+			{
+			    if (hold_cmd_en) {
+			        while (vecm_latch_flag & FLAG_REG_MAP) {
+                #ifdef PQ_DEBUG_EN
+			            printk(KERN_ERR "[amvecm..] command busy, please wait!!!\n");
+                #else
+			            ;
+                #endif
+			         }
+			     } else {
+			         ret = -EBUSY;
+			         printk(KERN_ERR "[amvecm..] load regs error: loading regs, please wait\n");
+			         goto out;
+			     }
+			}
+			ret = -EFAULT;
+			if (copy_from_user(&amregs, (void __user *)arg, sizeof(struct am_regs_s))) {
+				printk(KERN_ERR "[amvecm..] load reg errors: can't get buffer lenght\n");
+				goto out;
+			}
+			ret = -EINVAL;
+			if (!amregs.length || (amregs.length > 512)) {
+				printk(KERN_ERR "[amvecm..] load regs error: buffer length overflow!!!, length=0x%x \n", amregs.length);
+				goto out;
+			}
+#ifdef PQ_DEBUG_EN
+			printk("\n[amvecm..] reg length=0x%x ......\n", amregs.length);
+#endif
+			vecm_latch_flag |= FLAG_REG_MAP;
+			ret = 0;
+#endif
+		out:
+			break;
+		}
+
+        case AMVECM_IOC_VE_DNLP_EN: {
+            if (vecm_latch_flag & FLAG_VE_DNLP_EN)
+            {
+                ret = -EFAULT;
+            }
+            else
+            {
+                vecm_latch_flag |= FLAG_VE_DNLP_EN;
+                printk(KERN_ERR "[amvecm..] ioctl: enable dnlp function\n");
+            }
+            break;
+        }
+
+        case AMVECM_IOC_VE_DNLP_DIS: {
+            if (vecm_latch_flag & FLAG_VE_DNLP_DIS)
+            {
+                ret = -EFAULT;
+            }
+            else
+            {
+                vecm_latch_flag |= FLAG_VE_DNLP_DIS;
+                printk(KERN_ERR "[amvecm..] ioctl: disenable dnlp function\n");
+            }
+            break;
+        }
+
+        case AMVECM_IOC_VE_DNLP:
+        {
+            if (vecm_latch_flag & FLAG_VE_DNLP)
+            {
+                ret = -EFAULT;
+            }
+            else if (copy_from_user(&am_ve_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_s)))
+            {
+                ret = -EFAULT;
+            }
+            else
+            {
+                if (am_ve_dnlp.en    >  1)
+                    am_ve_dnlp.en    =  1;
+                if (am_ve_dnlp.black > 16)
+                    am_ve_dnlp.black = 16;
+                if (am_ve_dnlp.white > 16)
+                    am_ve_dnlp.white = 16;
+                vecm_latch_flag |= FLAG_VE_DNLP;
+            }
+            break;
+        }
+
+		case AMVECM_IOC_VE_NEW_DNLP:
+        {
+            if (vecm_latch_flag & FLAG_VE_NEW_DNLP)
+            {
+                ret = -EFAULT;
+            }
+            else if (copy_from_user(&am_ve_new_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_table_s)))
+            {
+                ret = -EFAULT;
+            }
+            else
+            {
+                if (am_ve_new_dnlp.en    >  1)
+                    am_ve_new_dnlp.en    =  1;
+                if (am_ve_new_dnlp.cliprate> 256)
+                    am_ve_new_dnlp.cliprate= 256;
+                if (am_ve_new_dnlp.lowrange> 54)
+                    am_ve_new_dnlp.lowrange= 54;
+                if (am_ve_new_dnlp.hghrange> 54)
+                    am_ve_new_dnlp.hghrange= 54;
+                if (am_ve_new_dnlp.lowalpha> 48)
+                    am_ve_new_dnlp.lowalpha= 48;
+                if (am_ve_new_dnlp.midalpha> 48)
+                    am_ve_new_dnlp.midalpha= 48;
+                if (am_ve_new_dnlp.hghalpha> 48)
+                    am_ve_new_dnlp.hghalpha= 48;
+                vecm_latch_flag |= FLAG_VE_NEW_DNLP;
+            }
+            break;
+        }
+
+        case AMVECM_IOC_G_HIST_AVG: {
+            void __user *argp = (void __user *)arg;
+            if ((video_ve_hist.height == 0) || (video_ve_hist.width == 0))
+            {
+                ret = -EFAULT;
+            }
+            else
+            {
+                video_ve_hist.ave = video_ve_hist.sum/(video_ve_hist.height*video_ve_hist.width);
+                if (copy_to_user(argp, &video_ve_hist, sizeof(struct ve_hist_s)))
+                    ret = -EFAULT;
+            }
+            break;
+        }
+		/**********************************************************************
+		gamma ioctl
+		**********************************************************************/
+		case AMVECM_IOC_GAMMA_TABLE_EN: {
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;
+			break;
+		}
+
+		case AMVECM_IOC_GAMMA_TABLE_DIS: {
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;
+			break;
+		}
+
+		case AMVECM_IOC_GAMMA_TABLE_R: {
+			if (vecm_latch_flag & FLAG_GAMMA_TABLE_R)
+			{
+				ret = -EFAULT;
+			}
+			else if (copy_from_user(&video_gamma_table_r, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
+			{
+				ret = -EFAULT;
+			}
+			else
+			{
+				vecm_latch_flag |= FLAG_GAMMA_TABLE_R;
+			}
+			break;
+		}
+
+		case AMVECM_IOC_GAMMA_TABLE_G: {
+			if (vecm_latch_flag & FLAG_GAMMA_TABLE_G)
+			{
+				ret = -EFAULT;
+			}
+			else if (copy_from_user(&video_gamma_table_g, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
+			{
+				ret = -EFAULT;
+			}
+			else
+			{
+				vecm_latch_flag |= FLAG_GAMMA_TABLE_G;
+			}
+			break;
+		}
+
+		case AMVECM_IOC_GAMMA_TABLE_B: {
+			if (vecm_latch_flag & FLAG_GAMMA_TABLE_B)
+			{
+				ret = -EFAULT;
+			}
+			else if (copy_from_user(&video_gamma_table_b, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
+			{
+				ret = -EFAULT;
+			}
+			else
+			{
+				vecm_latch_flag |= FLAG_GAMMA_TABLE_B;
+			}
+			break;
+		}
+
+		case AMVECM_IOC_S_RGB_OGO: {
+			if (vecm_latch_flag & FLAG_RGB_OGO)
+			{
+				ret = -EFAULT;
+			}
+			else if (copy_from_user(&video_rgb_ogo, (void __user *)arg, sizeof(struct tcon_rgb_ogo_s)))
+			{
+				ret = -EFAULT;
+			}
+			else
+			{
+				// en
+				if (video_rgb_ogo.en > 1)
+					video_rgb_ogo.en = 1;
+				// r_pre_offset
+				if (video_rgb_ogo.r_pre_offset > 1023)
+					video_rgb_ogo.r_pre_offset = 1023;
+				if (video_rgb_ogo.r_pre_offset < -1024)
+					video_rgb_ogo.r_pre_offset = -1024;
+				// g_pre_offset
+				if (video_rgb_ogo.g_pre_offset > 1023)
+					video_rgb_ogo.g_pre_offset = 1023;
+				if (video_rgb_ogo.g_pre_offset < -1024)
+					video_rgb_ogo.g_pre_offset = -1024;
+				// b_pre_offset
+				if (video_rgb_ogo.b_pre_offset > 1023)
+					video_rgb_ogo.b_pre_offset = 1023;
+				if (video_rgb_ogo.b_pre_offset < -1024)
+					video_rgb_ogo.b_pre_offset = -1024;
+				// r_gain
+				if (video_rgb_ogo.r_gain > 2047)
+					video_rgb_ogo.r_gain = 2047;
+				// g_gain
+				if (video_rgb_ogo.g_gain > 2047)
+					video_rgb_ogo.g_gain = 2047;
+				// b_gain
+				if (video_rgb_ogo.b_gain > 2047)
+					video_rgb_ogo.b_gain = 2047;
+				// r_post_offset
+				if (video_rgb_ogo.r_post_offset > 1023)
+					video_rgb_ogo.r_post_offset = 1023;
+				if (video_rgb_ogo.r_post_offset < -1024)
+					video_rgb_ogo.r_post_offset = -1024;
+				// g_post_offset
+				if (video_rgb_ogo.g_post_offset > 1023)
+					video_rgb_ogo.g_post_offset = 1023;
+				if (video_rgb_ogo.g_post_offset < -1024)
+					video_rgb_ogo.g_post_offset = -1024;
+				// b_post_offset
+				if (video_rgb_ogo.b_post_offset > 1023)
+					video_rgb_ogo.b_post_offset = 1023;
+				if (video_rgb_ogo.b_post_offset < -1024)
+					video_rgb_ogo.b_post_offset = -1024;
+				if (video_rgb_ogo_mode_sw)
+					video_set_rgb_ogo();
+				vecm_latch_flag |= FLAG_RGB_OGO;
+			}
+			break;
+		}
+
+		case AMVECM_IOC_G_RGB_OGO: {
+			if (copy_to_user((void __user *)arg, &video_rgb_ogo, sizeof(struct tcon_rgb_ogo_s)))
+			{
+				ret = -EFAULT;
+				break;
+			}
+			break;
+		}
+
+       default:
+            return -EINVAL;
+    }
+    return ret;
+}
+
+static ssize_t amvecm_dnlp_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "0x%x\n", (am_ve_dnlp.en    << 28) |
+                                  (am_ve_dnlp.rt    << 24) |
+                                  (am_ve_dnlp.rl    << 16) |
+                                  (am_ve_dnlp.black <<  8) |
+                                  (am_ve_dnlp.white <<  0));
+}
+// [   28] en    0~1
+// [27:20] rt    0~16
+// [19:16] rl-1  0~15
+// [15: 8] black 0~16
+// [ 7: 0] white 0~16
+static ssize_t amvecm_dnlp_store(struct class *cla, struct class_attribute *attr, const char *buf,
+                                      size_t count)
+{
+    size_t r;
+    s32 val;
+
+    r = sscanf(buf, "0x%x", &val);
+
+    if ((r != 1) || (vecm_latch_flag & FLAG_VE_DNLP)){
+        return -EINVAL;
+    }
+
+    am_ve_dnlp.en    = (val & 0xf0000000) >> 28;
+    am_ve_dnlp.rt    =  (val & 0x0f000000) >> 24;
+    am_ve_dnlp.rl    = (val & 0x00ff0000) >> 16;
+    am_ve_dnlp.black =  (val & 0x0000ff00) >>  8;
+    am_ve_dnlp.white = (val & 0x000000ff) >>  0;
+
+    if (am_ve_dnlp.en    >  1)
+        am_ve_dnlp.en    =  1;
+    if (am_ve_dnlp.rl    > 64)
+        am_ve_dnlp.rl    = 64;
+    if (am_ve_dnlp.black > 16)
+        am_ve_dnlp.black = 16;
+    if (am_ve_dnlp.white > 16)
+        am_ve_dnlp.white = 16;
+
+    vecm_latch_flag |= FLAG_VE_DNLP;
+
+    return count;
+}
+
+static ssize_t amvecm_brightness_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", vd1_brightness);
+}
+
+static ssize_t amvecm_brightness_store(struct class *cla, struct class_attribute *attr, const char *buf,
+                                      size_t count)
+{
+    size_t r;
+    int val;
+
+    r = sscanf(buf, "%d", &val);
+    if ((r != 1) || (val < -1024) || (val > 1024)) {
+        return -EINVAL;
+    }
+
+    vd1_brightness = val;
+    vecm_latch_flag |= FLAG_BRI_CON;
+
+    return count;
+}
+
+static ssize_t amvecm_contrast_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", vd1_contrast);
+}
+
+static ssize_t amvecm_contrast_store(struct class *cla, struct class_attribute *attr, const char *buf,
+                                    size_t count)
+{
+    size_t r;
+    int val;
+
+    r = sscanf(buf, "%d", &val);
+    if ((r != 1) || (val < -1024) || (val > 1024)) {
+        return -EINVAL;
+    }
+
+    vd1_contrast = val;
+    vecm_latch_flag |= FLAG_BRI_CON;
+
+    return count;
+}
+
+static ssize_t amvecm_saturation_hue_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "0x%x\n", READ_MPEG_REG(VPP_VADJ1_MA_MB));
+}
+
+static ssize_t amvecm_saturation_hue_store(struct class *cla, struct class_attribute *attr, const char *buf,
+                                      size_t count)
+{
+    size_t r;
+    s32 mab = 0;
+    s16 mc = 0, md = 0;
+
+    r = sscanf(buf, "0x%x", &mab);
+    if ((r != 1) || (mab&0xfc00fc00)) {
+        return -EINVAL;
+    }
+
+    WRITE_MPEG_REG(VPP_VADJ1_MA_MB, mab);
+    mc = (s16)((mab<<22)>>22); // mc = -mb
+    mc = 0 - mc;
+    if (mc> 511)
+        mc= 511;
+    if (mc<-512)
+        mc=-512;
+    md = (s16)((mab<<6)>>22);  // md =  ma;
+    mab = ((mc&0x3ff)<<16)|(md&0x3ff);
+    WRITE_MPEG_REG(VPP_VADJ1_MC_MD, mab);
+    WRITE_MPEG_REG(VPP_VADJ_CTRL, 1);
+#ifdef PQ_DEBUG_EN
+    printk("\n[amvideo..] set video_saturation_hue OK!!!\n");
+#endif
+    return count;
+}
+
+//static CLASS_ATTR(dnlp, S_IRUGO | S_IWUSR, amvecm_dnlp_show, amvecm_dnlp_store);
+static struct class_attribute amvecm_class_attrs[] = {
+	__ATTR(dnlp, S_IRUGO | S_IWUSR,
+		amvecm_dnlp_show, amvecm_dnlp_store),
+	__ATTR(brightness, S_IRUGO | S_IWUSR,
+		amvecm_brightness_show, amvecm_brightness_store),
+	__ATTR(contrast, S_IRUGO | S_IWUSR,
+		amvecm_contrast_show, amvecm_contrast_store),
+	__ATTR(saturation_hue,S_IRUGO | S_IWUSR,
+		amvecm_saturation_hue_show,
+		amvecm_saturation_hue_store),
+	__ATTR_NULL
+};
+
+#if 0
+static int amvecm_probe(struct platform_device *pdev)
+{
+    int ret;
+
+    ret = alloc_chrdev_region(&amvecm_devno, 0, AMVECM_COUNT, AMVECM_NAME);
+	if (ret < 0) {
+		pr_info("[amvecm.] : failed to allocate major number\n");
+		return 0;
+	}
+
+    amvecm_clsp = class_create(THIS_MODULE, AMVECM_NAME);
+    if (IS_ERR(amvecm_clsp))
+    {
+        pr_info(KERN_ERR "[amvecm.] : can't get amvecm_clsp\n");
+        unregister_chrdev_region(amvecm_devno, 0);
+        return PTR_ERR(amvecm_clsp);
+	}
+
+    /* allocate memory for the per-device structure */
+    amvecm_devp = kmalloc(sizeof(struct amvecm_dev_s), GFP_KERNEL);
+    if (!amvecm_devp)
+    {
+        pr_info("[amvecm.] : failed to allocate memory for amvecm device\n");
+        return -ENOMEM;
+    }
+
+    memset(amvecm_devp, 0, sizeof(struct amvecm_dev_s));
+
+    /* connect the file operations with cdev */
+    cdev_init(&amvecm_devp->cdev, &amvecm_fops);
+    amvecm_devp->cdev.owner = THIS_MODULE;
+    ret = cdev_add(&amvecm_devp->cdev, amvecm_devno, 1);
+    if (ret) {
+        pr_err("[amvecm.] : failed to add device\n");
+        /* @todo do with error */
+        return ret;
+    }
+    /* create /dev nodes */
+    //amvecm_devp->devt = MKDEV(MAJOR(amvecm_devno), 0);
+    amvecm_devp->dev = device_create(amvecm_clsp, NULL, MKDEV(MAJOR(amvecm_devno), 0),
+                        NULL, "%s%d", AMVECM_NAME, 0);
+    if (IS_ERR(amvecm_devp->dev)) {
+         pr_info("[amvecm.] : failed to create device node\n");
+         cdev_del(&amvecm_devp->cdev);
+		 kfree(amvecm_devp);
+         return PTR_ERR(amvecm_devp->dev);;
+    }
+
+    device_create_file(amvecm_devp->dev, &dev_attr_dnlp);
+
+    pr_info("[amvecm.] : driver probe ok\n");
+
+    return ret;
+}
+
+static int amvecm_remove(struct platform_device *pdev)
+{
+    int i = 0;
+
+    device_remove_file(amvecm_devp->dev, &dev_attr_dnlp);
+    device_destroy(amvecm_clsp, MKDEV(MAJOR(amvecm_devno), i));
+    cdev_del(&amvecm_devp->cdev);
+    kfree(amvecm_devp);
+    class_destroy(amvecm_clsp);
+    unregister_chrdev_region(amvecm_devno, 0);
+
+    pr_info("[amvecm.] : driver removed ok.\n");
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int amvecm_suspend(struct platform_device *pdev,pm_message_t state)
+{
+    pr_info("[amvecm.] : suspend module\n");
+    return 0;
+}
+
+static int amvecm_resume(struct platform_device *pdev)
+{
+    pr_info("[amvecm.] : resume module\n");
+    return 0;
+}
+#endif
+
+static struct platform_driver amvecm_driver = {
+    .probe      = amvecm_probe,
+    .remove     = amvecm_remove,
+#ifdef CONFIG_PM
+    .suspend    = amvecm_suspend,
+    .resume     = amvecm_resume,
+#endif
+    .driver     = {
+        .name   = AMVECM_DRIVER_NAME,
+    }
+};
+#endif
+static struct file_operations amvecm_fops = {
+    .owner   = THIS_MODULE,
+    .open    = amvecm_open,
+    .release = amvecm_release,
+    .unlocked_ioctl   = amvecm_ioctl,
+};
+
+static int __init amvecm_init(void)
+{
+    //int ret = 0;
+
+    //ret = platform_driver_register(&amvecm_driver);
+    //if (ret != 0) {
+    //    pr_info("failed to register amvecm module, error %d\n", ret);
+    //    return -ENODEV;
+    //}
+    int ret = 0;
+	int i = 0;
+    struct amvecm_dev_s *devp = &amvecm_dev;
+
+    memset(devp, 0, (sizeof(struct amvecm_dev_s)));
+
+    printk("\n\n VECM init \n\n");
+
+    ret = alloc_chrdev_region(&devp->devno, 0, 1, AMVECM_NAME);
+    if (ret < 0)
+    {
+        goto fail_alloc_region;
+    }
+
+    devp->clsp = class_create(THIS_MODULE, AMVECM_CLASS_NAME);
+    if (IS_ERR(devp->clsp)) {
+        ret = PTR_ERR(devp->clsp);
+        goto fail_create_class;
+    }
+
+	for(i = 0; amvecm_class_attrs[i].attr.name; i++){
+		if(class_create_file(devp->clsp,
+				&amvecm_class_attrs[i]) < 0)
+		goto fail_class_create_file;
+	}
+
+    cdev_init(&devp->cdev, &amvecm_fops);
+    devp->cdev.owner = THIS_MODULE;
+    ret = cdev_add(&devp->cdev, devp->devno, 1);
+    if (ret)
+    {
+        goto fail_add_cdev;
+    }
+
+    devp->dev = device_create(devp->clsp, NULL, devp->devno, NULL, AMVECM_NAME);
+
+    if (IS_ERR(devp->dev)) {
+        ret = PTR_ERR(devp->dev);
+        goto fail_create_device;
+    }
+
+    return 0;
+
+fail_create_device:
+	pr_info("[amvecm.] : amvecm device create error.\n");
+    cdev_del(&devp->cdev);
+fail_add_cdev:
+	pr_info("[amvecm.] : amvecm add device error.\n");
+    kfree(devp);
+fail_class_create_file:
+	pr_info("[amvecm.] : amvecm class create file error.\n");
+	for(i=0; amvecm_class_attrs[i].attr.name; i++){
+		class_remove_file(devp->clsp,
+				&amvecm_class_attrs[i]);
+	}
+    class_destroy(devp->clsp);
+fail_create_class:
+	pr_info("[amvecm.] : amvecm class create error.\n");
+    unregister_chrdev_region(devp->devno, 1);
+fail_alloc_region:
+    pr_info("[amvecm.] : amvecm alloc error.\n");
+    pr_info("[amvecm.] : amvecm_init.\n");
+    return ret;
+}
+
+static void __exit amvecm_exit(void)
+{
+    //platform_driver_unregister(&amvecm_driver);
+
+    struct amvecm_dev_s *devp = &amvecm_dev;
+
+    device_destroy(devp->clsp, devp->devno);
+    cdev_del(&devp->cdev);
+    class_destroy(devp->clsp);
+    unregister_chrdev_region(devp->devno, 1);
+    kfree(devp);
+
+    pr_info("[amvecm.] : amvecm_exit.\n");
+}
+
+module_init(amvecm_init);
+module_exit(amvecm_exit);
+
+MODULE_DESCRIPTION("AMLOGIC amvecm driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/amlogic/amvecm/cm_regs.h b/drivers/amlogic/amvecm/cm_regs.h
new file mode 100755
index 000000000000..ec224fab8b5e
--- /dev/null
+++ b/drivers/amlogic/amvecm/cm_regs.h
@@ -0,0 +1,186 @@
+/*
+ * Color Management
+ * registers' definition only access-able by port registers VPP_CHROMA_ADDR_PORT & VPP_CHROMA_DATA_PORT
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __CM_REG_H
+#define __CM_REG_H
+
+// *****************************************************************************
+// ******** COLOR MANAGEMENT INDIRECT REGISTERS ********
+// *****************************************************************************
+
+//#define CHROMA_GAIN_REG00   0x00
+//#define CHROMA_GAIN_REG01   0x06
+//#define CHROMA_GAIN_REG02   0x0C
+//#define CHROMA_GAIN_REG03   0x12
+//#define CHROMA_GAIN_REG04   0x18
+//#define CHROMA_GAIN_REG05   0x1E
+//#define CHROMA_GAIN_REG06   0x24
+//#define CHROMA_GAIN_REG07   0x2A
+#define SAT_EN_BIT          31
+#define SAT_EN_WID           1
+#define SAT_INC_BIT         27
+#define SAT_INC_WID          1
+#define SAT_CENTRAL_EN_BIT  25
+#define SAT_CENTRAL_EN_WID   2
+#define SAT_SHAPE_BIT       24
+#define SAT_SHAPE_WID        1
+#define SAT_GAIN_BIT        16
+#define SAT_GAIN_WID         8
+#define HUE_EN_BIT          15
+#define HUE_EN_WID           1
+#define HUE_CLOCKWISE_BIT   11
+#define HUE_CLOCKWISE_WID    1
+#define HUE_CENTRAL_EN_BIT   9
+#define HUE_CENTRAL_EN_WID   2
+#define HUE_SHAPE_BIT        8
+#define HUE_SHAPE_WID        1
+#define HUE_GAIN_BIT         0
+#define HUE_GAIN_WID         8
+
+//#define HUE_HUE_RANGE_REG00 0x01
+//#define HUE_HUE_RANGE_REG01 0x07
+//#define HUE_HUE_RANGE_REG02 0x0D
+//#define HUE_HUE_RANGE_REG03 0x13
+//#define HUE_HUE_RANGE_REG04 0x19
+//#define HUE_HUE_RANGE_REG05 0x1F
+//#define HUE_HUE_RANGE_REG06 0x25
+//#define HUE_HUE_RANGE_REG07 0x2B
+#define HUE_SHF_RAN_BIT     16
+#define HUE_SHF_RAN_WID      8
+#define SYM_EN_BIT          15
+#define SYM_EN_WID           1
+#define HUE_SHF_STA_BIT      0
+#define HUE_SHF_STA_WID     15
+
+//#define HUE_RANGE_INV_REG00 0x02
+//#define HUE_RANGE_INV_REG01 0x08
+//#define HUE_RANGE_INV_REG02 0x0E
+//#define HUE_RANGE_INV_REG03 0x14
+//#define HUE_RANGE_INV_REG04 0x1A
+//#define HUE_RANGE_INV_REG05 0x20
+//#define HUE_RANGE_INV_REG06 0x26
+//#define HUE_RANGE_INV_REG07 0x2C
+#define HUE_SHF_RAN_INV_BIT  0
+#define HUE_SHF_RAN_INV_WID 16
+
+//#define HUE_LUM_RANGE_REG00 0x03
+//#define HUE_LUM_RANGE_REG01 0x09
+//#define HUE_LUM_RANGE_REG02 0x0F
+//#define HUE_LUM_RANGE_REG03 0x15
+//#define HUE_LUM_RANGE_REG04 0x1B
+//#define HUE_LUM_RANGE_REG05 0x21
+//#define HUE_LUM_RANGE_REG06 0x27
+//#define HUE_LUM_RANGE_REG07 0x2D
+//  for belowing each low, high, low_slope, high_slope group:
+//            a_____________b
+//            /             \               a = low  + 2^low_slope
+//           /               \              b = high - 2^high_slope
+//          /                 \             low_slope <= 7; high_slope <= 7
+//         /                   \            b >= a
+//  ______/_____________________\________
+//       low                    high
+#define SAT_LUM_L_BIT       24
+#define SAT_LUM_L_WID        8
+#define HUE_LUM_H_SLOPE_BIT 20
+#define HUE_LUM_H_SLOPE_WID  4
+#define HUE_LUM_L_SLOPE_BIT 16
+#define HUE_LUM_L_SLOPE_WID  4
+#define HUE_LUM_H_BIT        8
+#define HUE_LUM_H_WID        8
+#define HUE_LUM_L_BIT        0
+#define HUE_LUM_L_WID        8
+
+//#define HUE_SAT_RANGE_REG00 0x04
+//#define HUE_SAT_RANGE_REG01 0x0A
+//#define HUE_SAT_RANGE_REG02 0x10
+//#define HUE_SAT_RANGE_REG03 0x16
+//#define HUE_SAT_RANGE_REG04 0x1C
+//#define HUE_SAT_RANGE_REG05 0x22
+//#define HUE_SAT_RANGE_REG06 0x28
+//#define HUE_SAT_RANGE_REG07 0x2E
+#define SAT_LUM_H_BIT       24
+#define SAT_LUM_H_WID        8
+#define HUE_SAT_H_SLOPE_BIT 20
+#define HUE_SAT_H_SLOPE_WID  4
+#define HUE_SAT_L_SLOPE_BIT 16
+#define HUE_SAT_L_SLOPE_WID  4
+#define HUE_SAT_H_BIT        8
+#define HUE_SAT_H_WID        8
+#define HUE_SAT_L_BIT        0
+#define HUE_SAT_L_WID        8
+
+//#define SAT_SAT_RANGE_REG00 0x05
+//#define SAT_SAT_RANGE_REG01 0x0B
+//#define SAT_SAT_RANGE_REG02 0x11
+//#define SAT_SAT_RANGE_REG03 0x17
+//#define SAT_SAT_RANGE_REG04 0x1D
+//#define SAT_SAT_RANGE_REG05 0x23
+//#define SAT_SAT_RANGE_REG06 0x29
+//#define SAT_SAT_RANGE_REG07 0x2F
+#define SAT_LUM_H_SLOPE_BIT 28
+#define SAT_LUM_H_SLOPE_WID  4
+#define SAT_LUM_L_SLOPE_BIT 24
+#define SAT_LUM_L_SLOPE_WID  4
+#define SAT_SAT_H_SLOPE_BIT 20
+#define SAT_SAT_H_SLOPE_WID  4
+#define SAT_SAT_L_SLOPE_BIT 16
+#define SAT_SAT_L_SLOPE_WID  4
+#define SAT_SAT_H_BIT        8
+#define SAT_SAT_H_WID        8
+#define SAT_SAT_L_BIT        0
+#define SAT_SAT_L_WID        8
+
+//#define REG_CHROMA_CONTROL  0x30
+#define CHROMA_EN_BIT       31
+#define CHROMA_EN_WID        1
+#if defined(CONFIG_ARCH_MESON)
+//1'b0: demo adjust on right, 1'b1: demo adjust on left
+#elif defined(CONFIG_ARCH_MESON2)
+//2'b00: demo adjust on top, 2'b01: demo adjust on bottom
+//2'b10: demo adjust on left,2'b11: demo adjust on right
+#endif
+#define CM_DEMO_POS_BIT        22
+#define CM_DEMO_POS_WID         2
+#define DEMO_HLIGHT_ADJ_BIT 21
+#define DEMO_HLIGHT_ADJ_WID  1
+#define DEMO_EN_BIT         20
+#define DEMO_EN_WID          1
+#define CM_DEMO_WID_BIT         8
+#define CM_DEMO_WID_WID        12
+#define SAT_SEL_BIT          6
+#define SAT_SEL_WID          1
+#define UV_ADJ_EN_BIT        5
+#define UV_ADJ_EN_WID        1
+#define RGB_TO_HUE_EN_BIT    2
+#define RGB_TO_HUE_EN_WID    1
+//2'b00: 601(16-235)  2'b01: 709(16-235)
+//2'b10: 601(0-255)   2'b11: 709(0-255)
+#define CSC_SEL_BIT          0
+#define CSC_SEL_WID          2
+
+#if defined(CONFIG_ARCH_MESON2)
+//#define REG_DEMO_CENTER_BAR   0x31   // default 32h'0
+#define CM_CBAR_EN_BIT      31  //center bar enable
+#define CM_CBAR_EN_WID       1
+#define CM_CBAR_WID_BIT     24  //center bar width    (*2)
+#define CM_CBAR_WID_WID      4
+#define CM_CBAR_CR_BIT      16  //center bar Cr       (*4)
+#define CM_CBAR_CR_WID       8
+#define CM_CBAR_CB_BIT       8  //center bar Cb       (*4)
+#define CM_CBAR_CB_WID       8
+#define CM_CBAR_Y_BIT        0  //center bar y        (*4)
+#define CM_CBAR_Y_WID        8
+#endif
+
+#endif  // _CM_REG_H
diff --git a/drivers/amlogic/amvecm/ve_regs.h b/drivers/amlogic/amvecm/ve_regs.h
new file mode 100755
index 000000000000..8a7e0da6d129
--- /dev/null
+++ b/drivers/amlogic/amvecm/ve_regs.h
@@ -0,0 +1,483 @@
+#ifndef _VE_REG_H
+#define _VE_REG_H
+
+// *****************************************************************************
+// ******** GAMMA REGISTERS ********
+// *****************************************************************************
+//#define P_L_GAMMA_CNTL_PORT                            0x1400
+   #define  GAMMA_VCOM_POL    7     //RW
+   #define  GAMMA_RVS_OUT     6     //RW
+   #define  ADR_RDY           5     //Read Only
+   #define  WR_RDY            4     //Read Only
+   #define  RD_RDY            3     //Read Only
+   #define  GAMMA_TR          2     //RW
+   #define  GAMMA_SET         1     //RW
+   #define  GAMMA_EN          0     //RW
+//#define P_L_GAMMA_DATA_PORT                            0x1401
+//#define P_L_GAMMA_ADDR_PORT                            0x1402
+   #define  H_RD              12
+   #define  H_AUTO_INC        11
+   #define  H_SEL_R           10
+   #define  H_SEL_G           9
+   #define  H_SEL_B           8
+   #define  HADR_MSB          7            //7:0
+   #define  HADR              0            //7:0
+// *****************************************************************************
+// ******** VIDEO ENHANCEMENT REGISTERS ********
+// *****************************************************************************
+
+//#define VPP_BLACKEXT_CTRL             0x1d80
+#define BEXT_START_BIT         24
+#define BEXT_START_WID          8
+#define BEXT_SLOPE1_BIT        16
+#define BEXT_SLOPE1_WID         8
+#define BEXT_MIDPT_BIT          8
+#define BEXT_MIDPT_WID          8
+#define BEXT_SLOPE2_BIT         0
+#define BEXT_SLOPE2_WID         8
+
+//#define VPP_DNLP_CTRL_00              0x1d81
+#define DNLP_GAMMA03_BIT       24
+#define DNLP_GAMMA03_WID        8
+#define DNLP_GAMMA02_BIT       16
+#define DNLP_GAMMA02_WID        8
+#define DNLP_GAMMA01_BIT        8
+#define DNLP_GAMMA01_WID        8
+#define DNLP_GAMMA00_BIT        0
+#define DNLP_GAMMA00_WID        8
+
+//#define VPP_DNLP_CTRL_01              0x1d82
+#define DNLP_GAMMA07_BIT       24
+#define DNLP_GAMMA07_WID        8
+#define DNLP_GAMMA06_BIT       16
+#define DNLP_GAMMA06_WID        8
+#define DNLP_GAMMA05_BIT        8
+#define DNLP_GAMMA05_WID        8
+#define DNLP_GAMMA04_BIT        0
+#define DNLP_GAMMA04_WID        8
+
+//#define VPP_DNLP_CTRL_02              0x1d83
+#define DNLP_GAMMA11_BIT       24
+#define DNLP_GAMMA11_WID        8
+#define DNLP_GAMMA10_BIT       16
+#define DNLP_GAMMA10_WID        8
+#define DNLP_GAMMA09_BIT        8
+#define DNLP_GAMMA09_WID        8
+#define DNLP_GAMMA08_BIT        0
+#define DNLP_GAMMA08_WID        8
+
+//#define VPP_DNLP_CTRL_03              0x1d84
+#define DNLP_GAMMA15_BIT       24
+#define DNLP_GAMMA15_WID        8
+#define DNLP_GAMMA14_BIT       16
+#define DNLP_GAMMA14_WID        8
+#define DNLP_GAMMA13_BIT        8
+#define DNLP_GAMMA13_WID        8
+#define DNLP_GAMMA12_BIT        0
+#define DNLP_GAMMA12_WID        8
+
+//#define VPP_DNLP_CTRL_04              0x1d85
+#define DNLP_GAMMA19_BIT       24
+#define DNLP_GAMMA19_WID        8
+#define DNLP_GAMMA18_BIT       16
+#define DNLP_GAMMA18_WID        8
+#define DNLP_GAMMA17_BIT        8
+#define DNLP_GAMMA17_WID        8
+#define DNLP_GAMMA16_BIT        0
+#define DNLP_GAMMA16_WID        8
+
+//#define VPP_DNLP_CTRL_05              0x1d86
+#define DNLP_GAMMA23_BIT       24
+#define DNLP_GAMMA23_WID        8
+#define DNLP_GAMMA22_BIT       16
+#define DNLP_GAMMA22_WID        8
+#define DNLP_GAMMA21_BIT        8
+#define DNLP_GAMMA21_WID        8
+#define DNLP_GAMMA20_BIT        0
+#define DNLP_GAMMA20_WID        8
+
+//#define VPP_DNLP_CTRL_06              0x1d87
+#define DNLP_GAMMA27_BIT       24
+#define DNLP_GAMMA27_WID        8
+#define DNLP_GAMMA26_BIT       16
+#define DNLP_GAMMA26_WID        8
+#define DNLP_GAMMA25_BIT        8
+#define DNLP_GAMMA25_WID        8
+#define DNLP_GAMMA24_BIT        0
+#define DNLP_GAMMA24_WID        8
+
+//#define VPP_DNLP_CTRL_07              0x1d88
+#define DNLP_GAMMA31_BIT       24
+#define DNLP_GAMMA31_WID        8
+#define DNLP_GAMMA30_BIT       16
+#define DNLP_GAMMA30_WID        8
+#define DNLP_GAMMA29_BIT        8
+#define DNLP_GAMMA29_WID        8
+#define DNLP_GAMMA28_BIT        0
+#define DNLP_GAMMA28_WID        8
+
+//#define VPP_DNLP_CTRL_08              0x1d89
+#define DNLP_GAMMA35_BIT       24
+#define DNLP_GAMMA35_WID        8
+#define DNLP_GAMMA34_BIT       16
+#define DNLP_GAMMA34_WID        8
+#define DNLP_GAMMA33_BIT        8
+#define DNLP_GAMMA33_WID        8
+#define DNLP_GAMMA32_BIT        0
+#define DNLP_GAMMA32_WID        8
+
+//#define VPP_DNLP_CTRL_09              0x1d8a
+#define DNLP_GAMMA39_BIT       24
+#define DNLP_GAMMA39_WID        8
+#define DNLP_GAMMA38_BIT       16
+#define DNLP_GAMMA38_WID        8
+#define DNLP_GAMMA37_BIT        8
+#define DNLP_GAMMA37_WID        8
+#define DNLP_GAMMA36_BIT        0
+#define DNLP_GAMMA36_WID        8
+
+//#define VPP_DNLP_CTRL_10              0x1d8b
+#define DNLP_GAMMA43_BIT       24
+#define DNLP_GAMMA43_WID        8
+#define DNLP_GAMMA42_BIT       16
+#define DNLP_GAMMA42_WID        8
+#define DNLP_GAMMA41_BIT        8
+#define DNLP_GAMMA41_WID        8
+#define DNLP_GAMMA40_BIT        0
+#define DNLP_GAMMA40_WID        8
+
+//#define VPP_DNLP_CTRL_11              0x1d8c
+#define DNLP_GAMMA47_BIT       24
+#define DNLP_GAMMA47_WID        8
+#define DNLP_GAMMA46_BIT       16
+#define DNLP_GAMMA46_WID        8
+#define DNLP_GAMMA45_BIT        8
+#define DNLP_GAMMA45_WID        8
+#define DNLP_GAMMA44_BIT        0
+#define DNLP_GAMMA44_WID        8
+
+//#define VPP_DNLP_CTRL_12              0x1d8d
+#define DNLP_GAMMA51_BIT       24
+#define DNLP_GAMMA51_WID        8
+#define DNLP_GAMMA50_BIT       16
+#define DNLP_GAMMA50_WID        8
+#define DNLP_GAMMA49_BIT        8
+#define DNLP_GAMMA49_WID        8
+#define DNLP_GAMMA48_BIT        0
+#define DNLP_GAMMA48_WID        8
+
+//#define VPP_DNLP_CTRL_13              0x1d8e
+#define DNLP_GAMMA55_BIT       24
+#define DNLP_GAMMA55_WID        8
+#define DNLP_GAMMA54_BIT       16
+#define DNLP_GAMMA54_WID        8
+#define DNLP_GAMMA53_BIT        8
+#define DNLP_GAMMA53_WID        8
+#define DNLP_GAMMA52_BIT        0
+#define DNLP_GAMMA52_WID        8
+
+//#define VPP_DNLP_CTRL_14              0x1d8f
+#define DNLP_GAMMA59_BIT       24
+#define DNLP_GAMMA59_WID        8
+#define DNLP_GAMMA58_BIT       16
+#define DNLP_GAMMA58_WID        8
+#define DNLP_GAMMA57_BIT        8
+#define DNLP_GAMMA57_WID        8
+#define DNLP_GAMMA56_BIT        0
+#define DNLP_GAMMA56_WID        8
+
+//#define VPP_DNLP_CTRL_15              0x1d90
+#define DNLP_GAMMA63_BIT       24
+#define DNLP_GAMMA63_WID        8
+#define DNLP_GAMMA62_BIT       16
+#define DNLP_GAMMA62_WID        8
+#define DNLP_GAMMA61_BIT        8
+#define DNLP_GAMMA61_WID        8
+#define DNLP_GAMMA60_BIT        0
+#define DNLP_GAMMA60_WID        8
+
+//#define VPP_PEAKING_HGAIN             0x1d91
+#define VLTI_STEP_BIT          28
+#define VLTI_STEP_WID           1
+#define VLTI_STEP2_BIT         27
+#define VLTI_STEP2_WID          1
+#define HLTI_STEP_BIT          25
+#define HLTI_STEP_WID           2
+#define PEAK_GAIN_H1_BIT       20
+#define PEAK_GAIN_H1_WID        5
+#define PEAK_GAIN_H2_BIT       15
+#define PEAK_GAIN_H2_WID        5
+#define PEAK_GAIN_H3_BIT       10
+#define PEAK_GAIN_H3_WID        5
+#define PEAK_GAIN_H4_BIT        5
+#define PEAK_GAIN_H4_WID        5
+#define PEAK_GAIN_H5_BIT        0
+#define PEAK_GAIN_H5_WID        5
+
+//#define VPP_PEAKING_VGAIN             0x1d92
+#define VCTI_BUF_EN_BIT        31
+#define VCTI_BUF_EN_WID         1
+#define VCTI_BUF_MODE_C5L_BIT  30
+#define VCTI_BUF_MODE_C5L_WID   1
+#define PEAK_GAIN_V1_BIT       25
+#define PEAK_GAIN_V1_WID        5
+#define PEAK_GAIN_V2_BIT       20
+#define PEAK_GAIN_V2_WID        5
+#define PEAK_GAIN_V3_BIT       15
+#define PEAK_GAIN_V3_WID        5
+#define PEAK_GAIN_V4_BIT       10
+#define PEAK_GAIN_V4_WID        5
+#define PEAK_GAIN_V5_BIT        5
+#define PEAK_GAIN_V5_WID        5
+#define PEAK_GAIN_V6_BIT        0
+#define PEAK_GAIN_V6_WID        5
+
+//#define VPP_PEAKING_NLP_1             0x1d93
+#define HPEAK_SLOPE1_BIT       26
+#define HPEAK_SLOPE1_WID        6
+#define HPEAK_SLOPE2_BIT       20
+#define HPEAK_SLOPE2_WID        6
+#define HPEAK_THR1_BIT         12
+#define HPEAK_THR1_WID          8
+#define VPEAK_SLOPE1_BIT        6
+#define VPEAK_SLOPE1_WID        6
+#define VPEAK_SLOPE2_BIT        0
+#define VPEAK_SLOPE2_WID        6
+
+//#define VPP_PEAKING_NLP_2             0x1d94
+#define HPEAK_THR2_BIT         24
+#define HPEAK_THR2_WID          8
+#define HPEAK_NLP_COR_THR_BIT  16
+#define HPEAK_NLP_COR_THR_WID   8
+#define HPEAK_NLP_GAIN_POS_BIT  8
+#define HPEAK_NLP_GAIN_POS_WID  8
+#define HPEAK_NLP_GAIN_NEG_BIT  0
+#define HPEAK_NLP_GAIN_NEG_WID  8
+
+//#define VPP_PEAKING_NLP_3             0x1d95
+#define VPEAK_THR1_BIT         24
+#define VPEAK_THR1_WID          8
+#define SPEAK_SLOPE1_BIT       18
+#define SPEAK_SLOPE1_WID        6
+#define SPEAK_SLOPE2_BIT       12
+#define SPEAK_SLOPE2_WID        6
+#define SPEAK_THR1_BIT          4
+#define SPEAK_THR1_WID          8
+#define PEAK_COR_GAIN_BIT       0
+#define PEAK_COR_GAIN_WID       4
+
+//#define VPP_PEAKING_NLP_4             0x1d96
+#define VPEAK_THR2_BIT         24
+#define VPEAK_THR2_WID          8
+#define VPEAK_NLP_COR_THR_BIT  16
+#define VPEAK_NLP_COR_THR_WID   8
+#define VPEAK_NLP_GAIN_POS_BIT  8
+#define VPEAK_NLP_GAIN_POS_WID  8
+#define VPEAK_NLP_GAIN_NEG_BIT  0
+#define VPEAK_NLP_GAIN_NEG_WID  8
+
+//#define VPP_PEAKING_NLP_5             0x1d97
+#define SPEAK_THR2_BIT         24
+#define SPEAK_THR2_WID          8
+#define SPEAK_NLP_COR_THR_BIT  16
+#define SPEAK_NLP_COR_THR_WID   8
+#define SPEAK_NLP_GAIN_POS_BIT  8
+#define SPEAK_NLP_GAIN_POS_WID  8
+#define SPEAK_NLP_GAIN_NEG_BIT  0
+#define SPEAK_NLP_GAIN_NEG_WID  8
+
+//#define VPP_HSVS_LIMIT                0x1d98
+#define PEAK_COR_THR_L_BIT     24
+#define PEAK_COR_THR_L_WID      8
+#define PEAK_COR_THR_H_BIT     16
+#define PEAK_COR_THR_H_WID      8
+#define VLIMIT_COEF_H_BIT      12
+#define VLIMIT_COEF_H_WID       4
+#define VLIMIT_COEF_L_BIT       8
+#define VLIMIT_COEF_L_WID       4
+#define HLIMIT_COEF_H_BIT       4
+#define HLIMIT_COEF_H_WID       4
+#define HLIMIT_COEF_L_BIT       0
+#define HLIMIT_COEF_L_WID       4
+
+//#define VPP_VLTI_CTRL                 0x1d99
+#define VLTI_GAIN_NEG_BIT      24
+#define VLTI_GAIN_NEG_WID       8
+#define VLTI_GAIN_POS_BIT      16
+#define VLTI_GAIN_POS_WID       8
+#define VLTI_THR_BIT            8
+#define VLTI_THR_WID            8
+#define VLTI_BLEND_FACTOR_BIT   0
+#define VLTI_BLEND_FACTOR_WID   8
+
+//#define VPP_HLTI_CTRL                 0x1d9a
+#define HLTI_GAIN_NEG_BIT      24
+#define HLTI_GAIN_NEG_WID       8
+#define HLTI_GAIN_POS_BIT      16
+#define HLTI_GAIN_POS_WID       8
+#define HLTI_THR_BIT            8
+#define HLTI_THR_WID            8
+#define HLTI_BLEND_FACTOR_BIT   0
+#define HLTI_BLEND_FACTOR_WID   8
+
+//#define VPP_CTI_CTRL                  0x1d9b
+#define CTI_C444TO422_EN_BIT   30
+#define CTI_C444TO422_EN_WID    1
+//2'b00: no filter, 2'b01: (1, 0, 1),
+//2'b10: (1, 2, 1), 2'b11: (1, 2, 2, 2, 1),
+#define VCTI_FILTER_BIT        28
+#define VCTI_FILTER_WID         2
+#define CTI_C422TO444_EN_BIT   27
+#define CTI_C422TO444_EN_WID    1
+#define HCTI_STEP2_BIT         24
+#define HCTI_STEP2_WID          3
+#define HCTI_STEP_BIT          21
+#define HCTI_STEP_WID           3
+#define CTI_BLEND_FACTOR_BIT   16
+#define CTI_BLEND_FACTOR_WID    5
+#define HCTI_MODE_MEDIAN_BIT   15
+#define HCTI_MODE_MEDIAN_WID    1
+#define HCTI_THR_BIT            8
+#define HCTI_THR_WID            7
+#define HCTI_GAIN_BIT           0
+#define HCTI_GAIN_WID           8
+
+//#define VPP_BLUE_STRETCH_1            0x1d9c
+#define BENH_CB_INC_BIT        29
+#define BENH_CB_INC_WID         1
+#define BENH_CR_INC_BIT        28
+#define BENH_CR_INC_WID         1
+#define BENH_ERR_CRP_INV_H_BIT 27
+#define BENH_ERR_CRP_INV_H_WID  1
+#define BENH_ERR_CRN_INV_H_BIT 26
+#define BENH_ERR_CRN_INV_H_WID  1
+#define BENH_ERR_CBP_INV_H_BIT 25
+#define BENH_ERR_CBP_INV_H_WID  1
+#define BENH_ERR_CBN_INV_H_BIT 24
+#define BENH_ERR_CBN_INV_H_WID  1
+#define BENH_GAIN_CR_BIT       16
+#define BENH_GAIN_CR_WID        8
+#define BENH_GAIN_CB4CR_BIT     8
+#define BENH_GAIN_CB4CR_WID     8
+#define BENH_LUMA_H_BIT         0
+#define BENH_LUMA_H_WID         8
+
+//#define VPP_BLUE_STRETCH_2            0x1d9d
+#define BENH_ERR_CRP_BIT       27
+#define BENH_ERR_CRP_WID        5
+#define BENH_ERR_CRP_INV_L_BIT 16
+#define BENH_ERR_CRP_INV_L_WID 11
+#define BENH_ERR_CRN_BIT       11
+#define BENH_ERR_CRN_WID        5
+#define BENH_ERR_CRN_INV_L_BIT  0
+#define BENH_ERR_CRN_INV_L_WID 11
+
+//#define VPP_BLUE_STRETCH_3            0x1d9e
+#define BENH_ERR_CBP_BIT       27
+#define BENH_ERR_CBP_WID        5
+#define BENH_ERR_CBP_INV_L_BIT 16
+#define BENH_ERR_CBP_INV_L_WID 11
+#define BENH_ERR_CBN_BIT       11
+#define BENH_ERR_CBN_WID        5
+#define BENH_ERR_CBN_INV_L_BIT  0
+#define BENH_ERR_CBN_INV_L_WID 11
+
+//#define VPP_CCORING_CTRL              0x1da0
+#define CCOR_THR_BIT            8
+#define CCOR_THR_WID            8
+#define CCOR_SLOPE_BIT          0
+#define CCOR_SLOPE_WID          4
+
+//#define VPP_VE_ENABLE_CTRL            0x1da1
+#define DEMO_CCOR_BIT          20
+#define DEMO_CCOR_WID           1
+#define DEMO_BEXT_BIT          19
+#define DEMO_BEXT_WID           1
+#define DEMO_DNLP_BIT          18
+#define DEMO_DNLP_WID           1
+#define DEMO_HSVS_BIT          17
+#define DEMO_HSVS_WID           1
+#define DEMO_BENH_BIT          16
+#define DEMO_BENH_WID           1
+#if defined(CONFIG_ARCH_MESON)
+//1'b0: demo adjust on right, 1'b1: demo adjust on left
+#define VE_DEMO_POS_BIT           15
+#define VE_DEMO_POS_WID            1
+#elif defined(CONFIG_ARCH_MESON2)
+//2'b00: demo adjust on top, 2'b01: demo adjust on bottom,
+//2'b10: demo adjust on left, 2'b11: demo adjust on right
+#define VE_DEMO_POS_BIT        14
+#define VE_DEMO_POS_WID         2
+#endif
+#define CCOR_EN_BIT             4
+#define CCOR_EN_WID             1
+#define BEXT_EN_BIT             3
+#define BEXT_EN_WID             1
+#define DNLP_EN_BIT             2
+#define DNLP_EN_WID             1
+#define HSVS_EN_BIT             1
+#define HSVS_EN_WID             1
+#define BENH_EN_BIT             0
+#define BENH_EN_WID             1
+
+#if defined(CONFIG_ARCH_MESON)
+//#define VPP_VE_DEMO_LEFT_SCREEN_WIDTH 0x1da2
+#elif defined(CONFIG_ARCH_MESON2)
+//#define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x1da2
+#endif
+#define VE_DEMO_WID_BIT         0
+#define VE_DEMO_WID_WID        12
+
+#if defined(CONFIG_ARCH_MESON2)
+//#define VPP_VE_DEMO_CENTER_BAR              0x1da3
+#define VE_CBAR_EN_BIT         31  //center bar enable
+#define VE_CBAR_EN_WID          1
+#define VE_CBAR_WID_BIT        24  //center bar width    (*2)
+#define VE_CBAR_WID_WID         4
+#define VE_CBAR_CR_BIT         16  //center bar Cr       (*4)
+#define VE_CBAR_CR_WID          8
+#define VE_CBAR_CB_BIT          8  //center bar Cb       (*4)
+#define VE_CBAR_CB_WID          8
+#define VE_CBAR_Y_BIT           0  //center bar y        (*4)
+#define VE_CBAR_Y_WID           8
+#endif
+
+#if defined(CONFIG_ARCH_MESON2)
+//#define VPP_VDO_MEAS_CTRL                   0x1da8
+#define VDO_MEAS_RST_BIT       10  //reset bit, high active
+#define VDO_MEAS_RST_WID        1
+#define VDO_MEAS_EDGE_BIT       9  //0: rising edge, 1: falling edge
+#define VDO_MEAS_EDGE_WID       1
+#define VDO_MEAS_ACCUM_CNT_BIT  8  //1: accumulate the counter number, 0: not
+#define VDO_MEAS_ACCUM_CNT_WID  1
+#define VDO_MEAS_VS_SPAN_BIT    0  //how many vsync span need to measure
+#define VDO_MEAS_VS_SPAN_WID    8
+#endif
+
+#if defined(CONFIG_ARCH_MESON2)
+//#define VPP_VDO_MEAS_VS_COUNT_HI            0x1da9  //Read only
+#define VDO_IND_MEAS_CNT_N_BIT 16  //every number of sync_span vsyncs, this counter add 1
+#define VDO_IND_MEAS_CNT_N_WID  4
+#define VDO_MEAS_VS_CNT_HI_BIT  0  //high bit portion of counter
+#define VDO_MEAS_VS_CNT_HI_WID 16
+#endif
+
+#if defined(CONFIG_ARCH_MESON2)
+//#define VPP_VDO_MEAS_VS_COUNT_LO            0x1daa  //Read only
+#define VDO_MEAS_VS_CNT_LO_BIT  0  //low bit portion of counter
+#define VDO_MEAS_VS_CNT_LO_WID 32
+#endif
+//bit 15:8  peaking_factor
+//bit 5     peaking_dnlp_demo_en
+//bit 4     peaking_dnlp_en
+//bit 3:0   peaking_filter_sel
+//#define VPP_PEAKING_DNLP                            0x1db8
+#define PEAKING_FACTOR_BIT          8
+#define PEAKING_FACTOR_WID          8
+#define PEAKING_DNLP_DEMO_EN_BIT    5
+#define PEAKING_DNLP_DEMO_EN_WID    1
+#define PEAKING_DNLP_EN_BIT         4
+#define PEAKING_DNLP_EN_WID         1
+#define PEAKING_FILTER_SEL_BIT      0
+#define PEAKING_FILTER_SEL_WID      4
+#endif // _VE_REG_H
\ No newline at end of file
diff --git a/include/linux/amlogic/amstream.h b/include/linux/amlogic/amstream.h
new file mode 100755
index 000000000000..813508c2254d
--- /dev/null
+++ b/include/linux/amlogic/amstream.h
@@ -0,0 +1,311 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef AMSTREAM_H
+#define AMSTREAM_H
+
+//#include <linux/interrupt.h>
+#include "ve.h"
+
+#ifdef __KERNEL__
+#define PORT_FLAG_IN_USE    0x0001
+#define PORT_FLAG_VFORMAT   0x0002
+#define PORT_FLAG_AFORMAT   0x0004
+#define PORT_FLAG_FORMAT    (PORT_FLAG_VFORMAT | PORT_FLAG_AFORMAT)
+#define PORT_FLAG_VID       0x0008
+#define PORT_FLAG_AID       0x0010
+#define PORT_FLAG_SID       0x0020
+#define PORT_FLAG_UD       0x0040
+#define PORT_FLAG_ID        (PORT_FLAG_VID | PORT_FLAG_AID | PORT_FLAG_SID | PORT_FLAG_UD)
+#define PORT_FLAG_INITED    0x100
+
+#define PORT_TYPE_VIDEO     0x01
+#define PORT_TYPE_AUDIO     0x02
+#define PORT_TYPE_MPTS      0x04
+#define PORT_TYPE_MPPS      0x08
+#define PORT_TYPE_ES        0x10
+#define PORT_TYPE_RM        0x20
+#define PORT_TYPE_SUB       0x40
+#define PORT_TYPE_SUB_RD    0x80
+#define PORT_TYPE_USERDATA	0x200
+#endif
+
+#define AMSTREAM_IOC_MAGIC  'S'
+
+#define AMSTREAM_IOC_VB_START   _IOW(AMSTREAM_IOC_MAGIC, 0x00, int)
+#define AMSTREAM_IOC_VB_SIZE    _IOW(AMSTREAM_IOC_MAGIC, 0x01, int)
+#define AMSTREAM_IOC_AB_START   _IOW(AMSTREAM_IOC_MAGIC, 0x02, int)
+#define AMSTREAM_IOC_AB_SIZE    _IOW(AMSTREAM_IOC_MAGIC, 0x03, int)
+#define AMSTREAM_IOC_VFORMAT    _IOW(AMSTREAM_IOC_MAGIC, 0x04, int)
+#define AMSTREAM_IOC_AFORMAT    _IOW(AMSTREAM_IOC_MAGIC, 0x05, int)
+#define AMSTREAM_IOC_VID        _IOW(AMSTREAM_IOC_MAGIC, 0x06, int)
+#define AMSTREAM_IOC_AID        _IOW(AMSTREAM_IOC_MAGIC, 0x07, int)
+#define AMSTREAM_IOC_VB_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x08, unsigned long)
+#define AMSTREAM_IOC_AB_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x09, unsigned long)
+#define AMSTREAM_IOC_SYSINFO    _IOW(AMSTREAM_IOC_MAGIC, 0x0a, int)
+#define AMSTREAM_IOC_ACHANNEL   _IOW(AMSTREAM_IOC_MAGIC, 0x0b, int)
+#define AMSTREAM_IOC_SAMPLERATE _IOW(AMSTREAM_IOC_MAGIC, 0x0c, int)
+#define AMSTREAM_IOC_DATAWIDTH  _IOW(AMSTREAM_IOC_MAGIC, 0x0d, int)
+#define AMSTREAM_IOC_TSTAMP     _IOW(AMSTREAM_IOC_MAGIC, 0x0e, unsigned long)
+#define AMSTREAM_IOC_VDECSTAT   _IOR(AMSTREAM_IOC_MAGIC, 0x0f, unsigned long)
+#define AMSTREAM_IOC_ADECSTAT   _IOR(AMSTREAM_IOC_MAGIC, 0x10, unsigned long)
+
+#define AMSTREAM_IOC_PORT_INIT   _IO(AMSTREAM_IOC_MAGIC, 0x11)
+#define AMSTREAM_IOC_TRICKMODE   _IOW(AMSTREAM_IOC_MAGIC, 0x12, unsigned long)
+
+#define AMSTREAM_IOC_AUDIO_INFO	 _IOW(AMSTREAM_IOC_MAGIC, 0x13, unsigned long)
+#define AMSTREAM_IOC_TRICK_STAT  _IOR(AMSTREAM_IOC_MAGIC, 0x14, unsigned long)
+#define AMSTREAM_IOC_AUDIO_RESET _IO(AMSTREAM_IOC_MAGIC, 0x15)
+#define AMSTREAM_IOC_SID         _IOW(AMSTREAM_IOC_MAGIC, 0x16, int)
+#define AMSTREAM_IOC_VPAUSE      _IOW(AMSTREAM_IOC_MAGIC, 0x17, int)
+#define AMSTREAM_IOC_AVTHRESH    _IOW(AMSTREAM_IOC_MAGIC, 0x18, int)
+#define AMSTREAM_IOC_SYNCTHRESH  _IOW(AMSTREAM_IOC_MAGIC, 0x19, int)
+#define AMSTREAM_IOC_SUB_RESET   _IOW(AMSTREAM_IOC_MAGIC, 0x1a, int)
+#define AMSTREAM_IOC_SUB_LENGTH  _IOR(AMSTREAM_IOC_MAGIC, 0x1b, unsigned long)
+#define AMSTREAM_IOC_SET_DEC_RESET _IOW(AMSTREAM_IOC_MAGIC, 0x1c, int)
+#define AMSTREAM_IOC_TS_SKIPBYTE _IOW(AMSTREAM_IOC_MAGIC, 0x1d, int)
+#define AMSTREAM_IOC_SUB_TYPE    _IOW(AMSTREAM_IOC_MAGIC, 0x1e, int)
+#define AMSTREAM_IOC_CLEAR_VIDEO _IOW(AMSTREAM_IOC_MAGIC, 0x1f, int)
+
+#define AMSTREAM_IOC_APTS               _IOR(AMSTREAM_IOC_MAGIC, 0x40, unsigned long)
+#define AMSTREAM_IOC_VPTS               _IOR(AMSTREAM_IOC_MAGIC, 0x41, unsigned long)
+#define AMSTREAM_IOC_PCRSCR             _IOR(AMSTREAM_IOC_MAGIC, 0x42, unsigned long)
+#define AMSTREAM_IOC_SYNCENABLE         _IOW(AMSTREAM_IOC_MAGIC, 0x43, unsigned long)
+#define AMSTREAM_IOC_GET_SYNC_ADISCON   _IOR(AMSTREAM_IOC_MAGIC, 0x44, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_ADISCON   _IOW(AMSTREAM_IOC_MAGIC, 0x45, unsigned long)
+#define AMSTREAM_IOC_GET_SYNC_VDISCON   _IOR(AMSTREAM_IOC_MAGIC, 0x46, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_VDISCON   _IOW(AMSTREAM_IOC_MAGIC, 0x47, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_DISABLE  _IOR(AMSTREAM_IOC_MAGIC, 0x48, unsigned long)
+#define AMSTREAM_IOC_SET_VIDEO_DISABLE  _IOW(AMSTREAM_IOC_MAGIC, 0x49, unsigned long)
+#define AMSTREAM_IOC_SET_PCRSCR         _IOW(AMSTREAM_IOC_MAGIC, 0x4a, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_AXIS     _IOR(AMSTREAM_IOC_MAGIC, 0x4b, unsigned long)
+#define AMSTREAM_IOC_SET_VIDEO_AXIS     _IOW(AMSTREAM_IOC_MAGIC, 0x4c, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_CROP     _IOR(AMSTREAM_IOC_MAGIC, 0x4d, unsigned long)
+#define AMSTREAM_IOC_SET_VIDEO_CROP     _IOW(AMSTREAM_IOC_MAGIC, 0x4e, unsigned long)
+
+// VPP.VE IOCTL command list
+#define AMSTREAM_IOC_VE_BEXT     _IOW(AMSTREAM_IOC_MAGIC, 0x20, struct ve_bext_s  )
+#define AMSTREAM_IOC_VE_DNLP     _IOW(AMSTREAM_IOC_MAGIC, 0x21, struct ve_dnlp_s  )
+#define AMSTREAM_IOC_VE_HSVS     _IOW(AMSTREAM_IOC_MAGIC, 0x22, struct ve_hsvs_s  )
+#define AMSTREAM_IOC_VE_CCOR     _IOW(AMSTREAM_IOC_MAGIC, 0x23, struct ve_ccor_s  )
+#define AMSTREAM_IOC_VE_BENH     _IOW(AMSTREAM_IOC_MAGIC, 0x24, struct ve_benh_s  )
+#define AMSTREAM_IOC_VE_DEMO     _IOW(AMSTREAM_IOC_MAGIC, 0x25, struct ve_demo_s  )
+#define AMSTREAM_IOC_VE_VDO_MEAS _IOW(AMSTREAM_IOC_MAGIC, 0x27, struct vdo_meas_s )
+#define AMSTREAM_IOC_VE_DEBUG    _IOWR(AMSTREAM_IOC_MAGIC, 0x28, unsigned long long)
+#define AMSTREAM_IOC_VE_REGMAP   _IOW(AMSTREAM_IOC_MAGIC, 0x29, struct ve_regmap_s)
+
+// VPP.CM IOCTL command list
+#define AMSTREAM_IOC_CM_REGION  _IOW(AMSTREAM_IOC_MAGIC, 0x30, struct cm_region_s)
+#define AMSTREAM_IOC_CM_TOP     _IOW(AMSTREAM_IOC_MAGIC, 0x31, struct cm_top_s   )
+#define AMSTREAM_IOC_CM_DEMO    _IOW(AMSTREAM_IOC_MAGIC, 0x32, struct cm_demo_s  )
+#define AMSTREAM_IOC_CM_DEBUG   _IOWR(AMSTREAM_IOC_MAGIC, 0x33, unsigned long long)
+#define AMSTREAM_IOC_CM_REGMAP  _IOW(AMSTREAM_IOC_MAGIC, 0x34, struct cm_regmap_s)
+
+//VPP.3D IOCTL command list
+#define  AMSTREAM_IOC_SET_3D_TYPE  _IOW(AMSTREAM_IOC_MAGIC, 0x3c, unsigned int)
+#define  AMSTREAM_IOC_GET_3D_TYPE  _IOW(AMSTREAM_IOC_MAGIC, 0x3d, unsigned int)
+
+#define AMSTREAM_IOC_SUB_NUM	_IOR(AMSTREAM_IOC_MAGIC, 0x50, unsigned long)
+#define AMSTREAM_IOC_SUB_INFO	_IOR(AMSTREAM_IOC_MAGIC, 0x51, unsigned long)
+#define AMSTREAM_IOC_GET_BLACKOUT_POLICY   _IOR(AMSTREAM_IOC_MAGIC, 0x52, unsigned long)
+#define AMSTREAM_IOC_SET_BLACKOUT_POLICY   _IOW(AMSTREAM_IOC_MAGIC, 0x53, unsigned long)
+#define AMSTREAM_IOC_GET_SCREEN_MODE _IOR(AMSTREAM_IOC_MAGIC, 0x58, int)
+#define AMSTREAM_IOC_SET_SCREEN_MODE _IOW(AMSTREAM_IOC_MAGIC, 0x59, int)
+#define AMSTREAM_IOC_GET_VIDEO_DISCONTINUE_REPORT _IOR(AMSTREAM_IOC_MAGIC, 0x5a, int)
+#define AMSTREAM_IOC_SET_VIDEO_DISCONTINUE_REPORT _IOW(AMSTREAM_IOC_MAGIC, 0x5b, int)
+#define AMSTREAM_IOC_VF_STATUS  _IOR(AMSTREAM_IOC_MAGIC, 0x60, unsigned long)
+#define AMSTREAM_IOC_CLEAR_VBUF _IO(AMSTREAM_IOC_MAGIC, 0x80)
+
+#define AMSTREAM_IOC_APTS_LOOKUP    _IOR(AMSTREAM_IOC_MAGIC, 0x81, unsigned long)
+#define GET_FIRST_APTS_FLAG         _IOR(AMSTREAM_IOC_MAGIC, 0x82, long)
+
+#define AMSTREAM_IOC_GET_SYNC_ADISCON_DIFF  _IOR(AMSTREAM_IOC_MAGIC, 0x83, unsigned long)
+#define AMSTREAM_IOC_GET_SYNC_VDISCON_DIFF  _IOR(AMSTREAM_IOC_MAGIC, 0x84, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_ADISCON_DIFF  _IOW(AMSTREAM_IOC_MAGIC, 0x85, unsigned long)
+#define AMSTREAM_IOC_SET_SYNC_VDISCON_DIFF  _IOW(AMSTREAM_IOC_MAGIC, 0x86, unsigned long)
+#define AMSTREAM_IOC_GET_FREERUN_MODE  _IOR(AMSTREAM_IOC_MAGIC, 0x87, unsigned long)
+#define AMSTREAM_IOC_SET_FREERUN_MODE  _IOW(AMSTREAM_IOC_MAGIC, 0x88, unsigned long)
+#define AMSTREAM_IOC_SET_DEMUX         _IOW(AMSTREAM_IOC_MAGIC, 0x90, unsigned long)
+
+#define AMSTREAM_IOC_SET_VIDEO_DELAY_LIMIT_MS _IOW(AMSTREAM_IOC_MAGIC, 0xa0, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_DELAY_LIMIT_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa1, unsigned long)
+#define AMSTREAM_IOC_SET_AUDIO_DELAY_LIMIT_MS _IOW(AMSTREAM_IOC_MAGIC, 0xa2, unsigned long)
+#define AMSTREAM_IOC_GET_AUDIO_DELAY_LIMIT_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa3, unsigned long)
+#define AMSTREAM_IOC_GET_AUDIO_CUR_DELAY_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa4, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_CUR_DELAY_MS _IOR(AMSTREAM_IOC_MAGIC, 0xa5, unsigned long)
+#define AMSTREAM_IOC_GET_AUDIO_AVG_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xa6, unsigned long)
+#define AMSTREAM_IOC_GET_VIDEO_AVG_BITRATE_BPS _IOR(AMSTREAM_IOC_MAGIC, 0xa7, unsigned long)
+
+#define TRICKMODE_NONE       0x00
+#define TRICKMODE_I          0x01
+#define TRICKMODE_FFFB       0x02
+
+#define TRICK_STAT_DONE      0x01
+#define TRICK_STAT_WAIT      0x00
+
+#define AUDIO_EXTRA_DATA_SIZE   (4096)
+#define MAX_SUB_NUM		32
+
+enum VIDEO_DEC_TYPE
+{
+        VIDEO_DEC_FORMAT_UNKNOW,
+        VIDEO_DEC_FORMAT_MPEG4_3,
+        VIDEO_DEC_FORMAT_MPEG4_4,
+        VIDEO_DEC_FORMAT_MPEG4_5,
+        VIDEO_DEC_FORMAT_H264,
+        VIDEO_DEC_FORMAT_MJPEG,
+        VIDEO_DEC_FORMAT_MP4,
+        VIDEO_DEC_FORMAT_H263,
+        VIDEO_DEC_FORMAT_REAL_8,
+        VIDEO_DEC_FORMAT_REAL_9,
+        VIDEO_DEC_FORMAT_WMV3,
+        VIDEO_DEC_FORMAT_WVC1,
+        VIDEO_DEC_FORMAT_SW,
+        VIDEO_DEC_FORMAT_MAX
+};
+
+struct buf_status {
+        int size;
+        int data_len;
+        int free_len;
+        unsigned int read_pointer;
+        unsigned int write_pointer;
+};
+
+
+struct vdec_status {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fps;
+        unsigned int error_count;
+        unsigned int status;
+};
+
+struct adec_status {
+        unsigned int channels;
+        unsigned int sample_rate;
+        unsigned int resolution;
+        unsigned int error_count;
+        unsigned int status;
+};
+
+struct am_io_param {
+        union {
+                int data;
+                int id;//get bufstatus? //or others
+        };
+
+        int len; //buffer size;
+
+        union {
+                char buf[1];
+                struct buf_status status;
+                struct vdec_status vstatus;
+                struct adec_status astatus;
+        };
+};
+struct audio_info {
+        int valid;
+        int sample_rate;
+        int channels;
+        int bitrate;
+        int codec_id;
+        int block_align;
+        int extradata_size;
+        char extradata[AUDIO_EXTRA_DATA_SIZE];
+};
+
+struct dec_sysinfo {
+        unsigned int    format;
+        unsigned int    width;
+        unsigned int    height;
+        unsigned int    rate;
+        unsigned int    extra;
+        unsigned int    status;
+        unsigned int    ratio;
+        void *          param;
+        unsigned long long    ratio64;
+};
+
+struct subtitle_info
+{
+        unsigned char id;
+        unsigned char width;
+        unsigned char height;
+        unsigned char type;
+};
+
+struct codec_profile_t
+{
+        char *name;		// video codec short name
+        char *profile;	// Attributes,seperated by commas
+};
+#define SUPPORT_VDEC_NUM	(8)
+
+int vcodec_profile_register(const struct codec_profile_t *vdec_profile);
+ssize_t vcodec_profile_read(char *buf);
+
+#ifdef __KERNEL__
+#ifdef ENABLE_DEMUX_DRIVER
+/*TS demux operation interface*/
+struct tsdemux_ops {
+        int (*reset)(void);
+        int (*set_reset_flag)(void);
+        int (*request_irq)(irq_handler_t handler, void *data);
+        int (*free_irq)(void);
+        int (*set_vid)(int vpid);
+        int (*set_aid)(int apid);
+        int (*set_sid)(int spid);
+        int (*set_skipbyte)(int skipbyte);
+        int (*set_demux)(int dev);
+};
+
+void tsdemux_set_ops(struct tsdemux_ops *ops);
+int  tsdemux_set_reset_flag(void);
+
+#endif /*ENABLE_DEMUX_DRIVER*/
+void set_vdec_func(int (*vdec_func)(struct vdec_status *));
+void set_adec_func(int (*adec_func)(struct adec_status *));
+void set_trickmode_func(int (*trickmode_func)(unsigned long trickmode));
+void wakeup_sub_poll(void);
+int  wakeup_userdata_poll(int wp, int start_phyaddr, int buf_size);
+int  get_sub_type(void);
+#endif
+
+typedef struct tcon_gamma_table_s {
+        u16 data[256];
+} tcon_gamma_table_t;
+
+typedef struct tcon_rgb_ogo_s {
+        unsigned int en;
+        int r_pre_offset;  // s11.0, range -1024~+1023, default is 0
+        int g_pre_offset;  // s11.0, range -1024~+1023, default is 0
+        int b_pre_offset;  // s11.0, range -1024~+1023, default is 0
+        unsigned int r_gain;        // u1.10, range 0~2047, default is 1024 (1.0x)
+        unsigned int g_gain;        // u1.10, range 0~2047, default is 1024 (1.0x)
+        unsigned int b_gain;        // u1.10, range 0~2047, default is 1024 (1.0x)
+        int r_post_offset; // s11.0, range -1024~+1023, default is 0
+        int g_post_offset; // s11.0, range -1024~+1023, default is 0
+        int b_post_offset; // s11.0, range -1024~+1023, default is 0
+} tcon_rgb_ogo_t;
+
+#endif /* AMSTREAM_H */
+
diff --git a/include/linux/amlogic/amvecm.h b/include/linux/amlogic/amvecm.h
new file mode 100755
index 000000000000..fc6dc84b15d3
--- /dev/null
+++ b/include/linux/amlogic/amvecm.h
@@ -0,0 +1,96 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef AMVECM_H
+#define AMVECM_H
+
+#include "linux/amlogic/ve.h"
+#include "linux/amlogic/cm.h"
+#include <linux/amlogic/amstream.h>
+
+
+struct ve_dnlp_s          video_ve_dnlp;
+struct tcon_gamma_table_s video_gamma_table_r;
+struct tcon_gamma_table_s video_gamma_table_g;
+struct tcon_gamma_table_s video_gamma_table_b;
+struct tcon_gamma_table_s video_gamma_table_r_adj;
+struct tcon_gamma_table_s video_gamma_table_g_adj;
+struct tcon_gamma_table_s video_gamma_table_b_adj;
+struct tcon_rgb_ogo_s     video_rgb_ogo;
+
+#define FLAG_RSV31              (1 << 31)
+#define FLAG_RSV30              (1 << 30)
+#define FLAG_VE_DNLP            (1 << 29)
+#define FLAG_VE_NEW_DNLP        (1 << 28)
+#define FLAG_RSV27              (1 << 27)
+#define FLAG_RSV26              (1 << 26)
+#define FLAG_RSV25              (1 << 25)
+#define FLAG_RSV24              (1 << 24)
+#define FLAG_RSV23              (1 << 23)
+#define FLAG_RSV22              (1 << 22)
+#define FLAG_RSV21              (1 << 21)
+#define FLAG_RSV20              (1 << 20)
+#define FLAG_VE_DNLP_EN         (1 << 19)
+#define FLAG_VE_DNLP_DIS        (1 << 18)
+#define FLAG_RSV17              (1 << 17)
+#define FLAG_RSV16              (1 << 16)
+#define FLAG_GAMMA_TABLE_EN     (1 << 15)
+#define FLAG_GAMMA_TABLE_DIS    (1 << 14)
+#define FLAG_GAMMA_TABLE_R      (1 << 13)
+#define FLAG_GAMMA_TABLE_G      (1 << 12)
+#define FLAG_GAMMA_TABLE_B      (1 << 11)
+#define FLAG_RGB_OGO            (1 << 10)
+#define FLAG_RSV9               (1 <<  9)
+#define FLAG_RSV8               (1 <<  8)
+#define FLAG_BRI_CON            (1 <<  7)
+#define FLAG_LVDS_FREQ_SW       (1 <<  6)
+#define FLAG_REG_MAP5           (1 <<  5)
+#define FLAG_REG_MAP4           (1 <<  4)
+#define FLAG_REG_MAP3           (1 <<  3)
+#define FLAG_REG_MAP2           (1 <<  2)
+#define FLAG_REG_MAP1           (1 <<  1)
+#define FLAG_REG_MAP0           (1 <<  0)
+
+
+#define AMVECM_IOC_MAGIC  'C'
+
+#define AMVECM_IOC_VE_DNLP       _IOW(AMVECM_IOC_MAGIC, 0x21, struct ve_dnlp_s  )
+#define AMVECM_IOC_G_HIST_AVG    _IOW(AMVECM_IOC_MAGIC, 0x22, struct ve_hist_s  )
+#define AMVECM_IOC_VE_DNLP_EN     _IO(AMVECM_IOC_MAGIC, 0x23)
+#define AMVECM_IOC_VE_DNLP_DIS    _IO(AMVECM_IOC_MAGIC, 0x24)
+#define AMVECM_IOC_VE_NEW_DNLP   _IOW(AMVECM_IOC_MAGIC, 0x25, struct ve_dnlp_table_s  )
+
+
+// VPP.CM IOCTL command list
+#define AMVECM_IOC_LOAD_REG     _IOW(AMVECM_IOC_MAGIC, 0x30, struct am_regs_s)
+
+
+// VPP.GAMMA IOCTL command list
+#define AMVECM_IOC_GAMMA_TABLE_EN  _IO(AMVECM_IOC_MAGIC, 0x40)
+#define AMVECM_IOC_GAMMA_TABLE_DIS _IO(AMVECM_IOC_MAGIC, 0x41)
+#define AMVECM_IOC_GAMMA_TABLE_R  _IOW(AMVECM_IOC_MAGIC, 0x42, struct tcon_gamma_table_s)
+#define AMVECM_IOC_GAMMA_TABLE_G  _IOW(AMVECM_IOC_MAGIC, 0x43, struct tcon_gamma_table_s)
+#define AMVECM_IOC_GAMMA_TABLE_B  _IOW(AMVECM_IOC_MAGIC, 0x44, struct tcon_gamma_table_s)
+#define AMVECM_IOC_S_RGB_OGO      _IOW(AMVECM_IOC_MAGIC, 0x45, struct tcon_rgb_ogo_s)
+#define AMVECM_IOC_G_RGB_OGO      _IOR(AMVECM_IOC_MAGIC, 0x46, struct tcon_rgb_ogo_s)
+
+#endif /* AMVECM_H */
+
diff --git a/include/linux/amlogic/cm.h b/include/linux/amlogic/cm.h
new file mode 100755
index 000000000000..8fba6a346a6c
--- /dev/null
+++ b/include/linux/amlogic/cm.h
@@ -0,0 +1,167 @@
+/*
+ * Color Management
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef _TVOUT_CM_H
+#define _TVOUT_CM_H
+
+// ***************************************************************************
+// *** enum definitions *********************************************
+// ***************************************************************************
+
+typedef enum cm_region_idx_e {
+    CM_REGION_IDX_0 = 0,
+    CM_REGION_IDX_1,
+    CM_REGION_IDX_2,
+    CM_REGION_IDX_3,
+    CM_REGION_IDX_4,
+    CM_REGION_IDX_5,
+    CM_REGION_IDX_6,
+    CM_REGION_IDX_7,
+} cm_region_idx_t;
+
+typedef enum cm_sat_shape_e {
+    CM_SAT_SHAPE_RIGHT_BIGGEST = 0,
+    CM_SAT_SHAPE_LEFT_BIGGEST,
+} cm_sat_shape_t;
+
+typedef enum cm_hue_shape_e {
+    CM_HUE_SHAPE_LEFT_MORE = 0,
+    CM_HUE_SHAPE_RIGHT_MORE,
+} cm_hue_shape_t;
+
+typedef enum cm_demo_pos_e {
+    CM_DEMO_POS_TOP = 0,
+    CM_DEMO_POS_BOTTOM,
+    CM_DEMO_POS_LEFT,
+    CM_DEMO_POS_RIGHT,
+} cm_demo_pos_t;
+
+typedef enum cm_sat_sel_e {
+    CM_SAT_SEL_U2_V2 = 0,
+    CM_SAT_SEL_UV_MAX,
+} cm_sat_sel_t;
+
+typedef enum cm_csc_e {
+    CM_CSC_601 = 0,
+    CM_CSC_709,
+    CM_CSC_FULL_601,
+    CM_CSC_FULL_709,
+} cm_csc_t;
+
+// ***************************************************************************
+// *** struct definitions *********************************************
+// ***************************************************************************
+
+typedef struct cm_region_s {
+    enum cm_region_idx_e region_idx;
+    // sym
+    unsigned char       sym_en;
+    // sat - top
+    unsigned char       sat_en;
+    unsigned char       sat_central_en;
+    enum cm_sat_shape_e sat_shape;
+    unsigned char       sat_gain;
+    unsigned char       sat_inc;
+    // sat - lum
+    unsigned char       sat_lum_h_slope;
+    unsigned char       sat_lum_l_slope;
+    unsigned char       sat_lum_h;
+    unsigned char       sat_lum_l;
+    // sat - sat
+    unsigned char       sat_sat_h_slope;
+    unsigned char       sat_sat_l_slope;
+    unsigned char       sat_sat_h;
+    unsigned char       sat_sat_l;
+    // hue - top
+    unsigned char       hue_en;
+    unsigned char       hue_central_en;
+    enum cm_hue_shape_e hue_shape;
+    unsigned char       hue_gain;
+    unsigned char       hue_clockwise;
+    unsigned char       hue_shf_ran;
+    ushort              hue_shf_sta;
+    // hue - lum
+    unsigned char       hue_lum_h_slope;
+    unsigned char       hue_lum_l_slope;
+    unsigned char       hue_lum_h;
+    unsigned char       hue_lum_l;
+    // hue - sat
+    unsigned char       hue_sat_h_slope;
+    unsigned char       hue_sat_l_slope;
+    unsigned char       hue_sat_h;
+    unsigned char       hue_sat_l;
+} cm_region_t;
+
+typedef struct cm_top_s {
+    unsigned char       chroma_en;
+    enum cm_sat_sel_e   sat_sel;
+    unsigned char       uv_adj_en;
+    unsigned char       rgb_to_hue_en;
+    enum cm_csc_e       csc_sel;
+} cm_top_t;
+
+typedef struct cm_cbar_s {
+    unsigned char en;
+    unsigned char wid;
+    unsigned char cr;
+    unsigned char cb;
+    unsigned char y;
+} cm_cbar_t;
+typedef struct cm_demo_s {
+    unsigned char       en;
+    enum cm_demo_pos_e  pos;
+    unsigned char       hlight_adj;
+    ushort              wid;
+    struct cm_cbar_s   cbar;
+} cm_demo_t;
+
+typedef struct cm_regmap_s {
+    ulong reg[50];
+} cm_regmap_t;
+
+typedef enum reg_bus_type_e {
+    REG_TYPE_PHY = 0,
+    REG_TYPE_CBUS,
+    REG_TYPE_APB,
+    REG_TYPE_AXI,
+    REG_TYPE_AHB,
+    REG_TYPE_MPEG,
+    REG_TYPE_INDEX_VPPCHROMA,
+    REG_TYPE_INDEX_GAMMA,
+    VALUE_TYPE_CONTRAST_BRIGHTNESS,
+    REG_TYPE_INDEX_VPP_COEF,
+    REG_TYPE_MAX,
+} reg_bus_type_t;
+
+/* Register table structure */
+typedef struct am_reg_s {
+    unsigned int type; //32-bits; 0: CBUS; 1: APB BUS...
+    unsigned int addr; //32-bits; Register address
+    unsigned int mask; //32-bits; Valid bits
+    unsigned int  val; //32-bits; Register Value
+} am_reg_t;
+
+#ifdef AMVIDEO_REG_TABLE_DYNAMIC
+typedef struct am_regs_s {
+    unsigned int    length; // Length of total am_reg
+    struct am_reg_s *am_reg;
+} am_regs_t;
+#else
+typedef struct am_regs_s {
+    unsigned int    length; // Length of total am_reg
+    struct am_reg_s am_reg[512];
+} am_regs_t;
+#endif
+
+#endif  // _TVOUT_CM_H
diff --git a/include/linux/amlogic/ve.h b/include/linux/amlogic/ve.h
new file mode 100755
index 000000000000..a058d68c8d87
--- /dev/null
+++ b/include/linux/amlogic/ve.h
@@ -0,0 +1,200 @@
+/*
+ * Video Enhancement
+ *
+ * Author: Lin Xu <lin.xu@amlogic.com>
+ *         Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __VE_H
+#define __VE_H
+
+// ***************************************************************************
+// *** enum definitions *********************************************
+// ***************************************************************************
+
+typedef enum ve_demo_pos_e {
+  VE_DEMO_POS_TOP = 0,
+  VE_DEMO_POS_BOTTOM,
+  VE_DEMO_POS_LEFT,
+  VE_DEMO_POS_RIGHT,
+} ve_demo_pos_t;
+
+typedef enum ve_dnlp_rt_e {
+	VE_DNLP_RT_0S = 0,
+	VE_DNLP_RT_1S = 6,
+    VE_DNLP_RT_2S,
+    VE_DNLP_RT_4S,
+    VE_DNLP_RT_8S,
+    VE_DNLP_RT_16S,
+    VE_DNLP_RT_32S,
+    VE_DNLP_RT_64S,
+    VE_DNLP_RT_FREEZE,
+} ve_dnlp_rt_t;
+
+// ***************************************************************************
+// *** struct definitions *********************************************
+// ***************************************************************************
+
+typedef struct ve_bext_s {
+    unsigned char en;
+    unsigned char start;
+    unsigned char slope1;
+    unsigned char midpt;
+    unsigned char slope2;
+} ve_bext_t;
+#if defined(CONFIG_AM_VECM)
+typedef struct ve_dnlp_s {
+    unsigned int      en;
+    unsigned int rt;    //       0 ~ 255,
+    unsigned int rl;    //       0 ~  15, 1.0000x ~ 1.9375x, step 0.0625x
+    unsigned int black; //       0 ~  16, weak ~ strong
+    unsigned int white; //       0 ~  16, weak ~ strong
+} ve_dnlp_t;
+typedef struct ve_hist_s {
+    ulong sum;
+    int width;
+    int height;
+    int ave;
+} ve_hist_t;
+typedef struct ve_dnlp_table_s {
+	unsigned int en;
+	unsigned int method;
+	unsigned int cliprate;
+	unsigned int lowrange;
+	unsigned int hghrange;
+	unsigned int lowalpha;
+	unsigned int midalpha;
+	unsigned int hghalpha;
+} ve_dnlp_table_t;
+#else
+typedef struct ve_dnlp_s {
+    unsigned char en;
+    enum  ve_dnlp_rt_e rt;
+    unsigned char gamma[64];
+} ve_dnlp_t;
+#endif
+typedef struct ve_hsvs_s {
+    unsigned char en;
+    unsigned char peak_gain_h1;
+    unsigned char peak_gain_h2;
+    unsigned char peak_gain_h3;
+    unsigned char peak_gain_h4;
+    unsigned char peak_gain_h5;
+    unsigned char peak_gain_v1;
+    unsigned char peak_gain_v2;
+    unsigned char peak_gain_v3;
+    unsigned char peak_gain_v4;
+    unsigned char peak_gain_v5;
+    unsigned char peak_gain_v6;
+    unsigned char hpeak_slope1;
+    unsigned char hpeak_slope2;
+    unsigned char hpeak_thr1;
+    unsigned char hpeak_thr2;
+    unsigned char hpeak_nlp_cor_thr;
+    unsigned char hpeak_nlp_gain_pos;
+    unsigned char hpeak_nlp_gain_neg;
+    unsigned char vpeak_slope1;
+    unsigned char vpeak_slope2;
+    unsigned char vpeak_thr1;
+    unsigned char vpeak_thr2;
+    unsigned char vpeak_nlp_cor_thr;
+    unsigned char vpeak_nlp_gain_pos;
+    unsigned char vpeak_nlp_gain_neg;
+    unsigned char speak_slope1;
+    unsigned char speak_slope2;
+    unsigned char speak_thr1;
+    unsigned char speak_thr2;
+    unsigned char speak_nlp_cor_thr;
+    unsigned char speak_nlp_gain_pos;
+    unsigned char speak_nlp_gain_neg;
+    unsigned char peak_cor_gain;
+    unsigned char peak_cor_thr_l;
+    unsigned char peak_cor_thr_h;
+    unsigned char vlti_step;
+    unsigned char vlti_step2;
+    unsigned char vlti_thr;
+    unsigned char vlti_gain_pos;
+    unsigned char vlti_gain_neg;
+    unsigned char vlti_blend_factor;
+    unsigned char hlti_step;
+    unsigned char hlti_thr;
+    unsigned char hlti_gain_pos;
+    unsigned char hlti_gain_neg;
+    unsigned char hlti_blend_factor;
+    unsigned char vlimit_coef_h;
+    unsigned char vlimit_coef_l;
+    unsigned char hlimit_coef_h;
+    unsigned char hlimit_coef_l;
+    unsigned char cti_444_422_en;
+    unsigned char cti_422_444_en;
+    unsigned char cti_blend_factor;
+    unsigned char vcti_buf_en;
+    unsigned char vcti_buf_mode_c5l;
+    unsigned char vcti_filter;
+    unsigned char hcti_step;
+    unsigned char hcti_step2;
+    unsigned char hcti_thr;
+    unsigned char hcti_gain;
+    unsigned char hcti_mode_median;
+} ve_hsvs_t;
+
+typedef struct ve_ccor_s {
+    unsigned char en;
+    unsigned char slope;
+    unsigned char thr;
+} ve_ccor_t;
+
+typedef struct ve_benh_s {
+    unsigned char en;
+    unsigned char cb_inc;
+    unsigned char cr_inc;
+    unsigned char gain_cr;
+    unsigned char gain_cb4cr;
+    unsigned char luma_h;
+    unsigned char err_crp;
+    unsigned char err_crn;
+    unsigned char err_cbp;
+    unsigned char err_cbn;
+} ve_benh_t;
+
+typedef struct ve_cbar_s {
+    unsigned char en;
+    unsigned char wid;
+    unsigned char cr;
+    unsigned char cb;
+    unsigned char y;
+} ve_cbar_t;
+typedef struct ve_demo_s {
+    unsigned char bext;
+    unsigned char dnlp;
+    unsigned char hsvs;
+    unsigned char ccor;
+    unsigned char benh;
+    enum  ve_demo_pos_e  pos;
+    unsigned long wid;
+    struct ve_cbar_s   cbar;
+} ve_demo_t;
+
+typedef struct vdo_meas_s {
+    //...
+} vdo_meas_t;
+
+typedef struct ve_regmap_s {
+    unsigned long reg[43];
+} ve_regmap_t;
+
+// ***************************************************************************
+// *** MACRO definitions **********
+// ***************************************************************************
+
+// ***************************************************************************
+// *** FUNCTION definitions **********
+// ***************************************************************************
+
+#endif  // _VE_H
diff --git a/include/linux/amlogic/vframe.h b/include/linux/amlogic/vframe.h
new file mode 100755
index 000000000000..1480acad73b1
--- /dev/null
+++ b/include/linux/amlogic/vframe.h
@@ -0,0 +1,210 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef VFRAME_H
+#define VFRAME_H
+
+#include <linux/types.h>
+#include <linux/tvin/tvin.h>
+
+#define VIDTYPE_PROGRESSIVE             0x0
+#define VIDTYPE_INTERLACE_TOP           0x1
+#define VIDTYPE_INTERLACE_BOTTOM        0x3
+#define VIDTYPE_TYPEMASK                0x7
+#define VIDTYPE_INTERLACE               0x1
+#define VIDTYPE_INTERLACE_FIRST         0x8
+#define VIDTYPE_MVC                     0x10
+#define VIDTYPE_NO_VIDEO_ENABLE         0x20
+#define VIDTYPE_VIU_422                 0x800
+#define VIDTYPE_VIU_FIELD               0x1000
+#define VIDTYPE_VIU_SINGLE_PLANE        0x2000
+#define VIDTYPE_VIU_444                 0x4000
+#define VIDTYPE_VIU_NV21                0x8000
+#define VIDTYPE_VSCALE_DISABLE          0x10000
+#define VIDTYPE_CANVAS_TOGGLE           0x20000
+#define VIDTYPE_PRE_INTERLACE           0x40000
+
+#define DISP_RATIO_FORCECONFIG          0x80000000
+#define DISP_RATIO_FORCE_NORMALWIDE     0x40000000
+#define DISP_RATIO_FORCE_FULL_STRETCH   0x20000000
+#define DISP_RATIO_CTRL_MASK            0x00000003
+#define DISP_RATIO_NO_KEEPRATIO         0x00000000
+#define DISP_RATIO_KEEPRATIO            0x00000001
+#define DISP_RATIO_PORTRAIT_MODE        0x00000004
+
+#define DISP_RATIO_ASPECT_RATIO_MASK    0x0003ff00
+#define DISP_RATIO_ASPECT_RATIO_BIT     8
+#define DISP_RATIO_ASPECT_RATIO_MAX     0x3ff
+
+typedef enum pixel_aspect_ratio_e {
+        PIXEL_ASPECT_RATIO_1_1,
+        PIXEL_ASPECT_RATIO_8_9,
+        PIXEL_ASPECT_RATIO_16_15,
+} pixel_aspect_ratio_t;
+
+/*
+ * If pixel_sum[21:0] == 0, then all Histogram information are invalid
+ */
+typedef struct vframe_hist_s
+{
+        unsigned int   luma_sum;
+        unsigned int   chroma_sum;
+        unsigned int   pixel_sum;  // [31:30] POW [21:0] PIXEL_SUM
+        unsigned int   height;
+        unsigned int   width;
+        unsigned char  luma_max;
+        unsigned char  luma_min;
+        unsigned short gamma[64];
+#ifdef AML_LOCAL_DIMMING
+        unsigned int   ldim_max[100];
+#endif
+} vframe_hist_t;
+
+
+/*
+ * If bottom == 0 or right == 0, then all Blackbar information are invalid
+ */
+typedef struct vframe_bbar_s
+{
+        unsigned short top;
+        unsigned short bottom;
+        unsigned short left;
+        unsigned short right;
+} vfame_bbar_t;
+
+
+/*
+ * If vsin == 0, then all Measurement information are invalid
+ */
+typedef struct vframe_meas_s
+{
+        //float          frin;      // Frame Rate of Video Input in the unit of Hz
+        unsigned int        vs_span_cnt;
+        unsigned long long  vs_cnt;
+        unsigned int        hs_cnt0;
+        unsigned int        hs_cnt1;
+        unsigned int        hs_cnt2;
+        unsigned int        hs_cnt3;
+        unsigned int vs_cycle;
+        unsigned int vs_stamp;
+} vframe_meas_t;
+
+typedef struct vframe_view_s {
+        int start_x;
+        int start_y;
+        unsigned int width;
+        unsigned int height;
+} vframe_view_t;
+
+/* vframe properties */
+typedef struct vframe_prop_s
+{
+        struct vframe_hist_s hist;
+        struct vframe_bbar_s bbar;
+        struct vframe_meas_s meas;
+} vframe_prop_t;
+
+typedef enum vframe_source_type_e {
+        VFRAME_SOURCE_TYPE_OTHERS = 0,
+        VFRAME_SOURCE_TYPE_TUNER,
+        VFRAME_SOURCE_TYPE_CVBS,
+        VFRAME_SOURCE_TYPE_COMP,
+        VFRAME_SOURCE_TYPE_HDMI,
+        VFRAME_SOURCE_TYPE_PPMGR,
+        VFRAME_SOURCE_TYPE_OSD,
+} vframe_source_type_t;
+
+typedef enum vframe_source_mode_e {
+        VFRAME_SOURCE_MODE_OTHERS = 0,
+        VFRAME_SOURCE_MODE_PAL,
+        VFRAME_SOURCE_MODE_NTSC,
+        VFRAME_SOURCE_MODE_SECAM,
+} vframe_source_mode_t;
+typedef enum vframe_secam_phase_e {
+        VFRAME_PHASE_DB = 0,
+        VFRAME_PHASE_DR,
+} vframe_secam_phase_t;
+typedef struct vframe_s {
+        u32 index;
+        u32 type;
+        u32 type_backup;
+        u32 blend_mode;
+        u32 duration;
+        u32 duration_pulldown;
+        u32 pts;
+        u32 flag;
+
+        u32 canvas0Addr;
+        u32 canvas1Addr;
+
+        u32 bufWidth;
+        u32 width;
+        u32 height;
+        u32 ratio_control;
+
+        u32 orientation;
+        enum vframe_source_type_e source_type;
+        enum vframe_secam_phase_e  phase;
+        enum vframe_source_mode_e source_mode;
+        tvin_sig_fmt_t sig_fmt;
+
+        enum tvin_trans_fmt  trans_fmt;
+        struct vframe_view_s left_eye;
+        struct vframe_view_s right_eye;
+
+        u32   mode_3d_enable ;
+
+        /* vframe extension */
+        int (*early_process_fun)(void* arg, struct vframe_s* vf);
+        int (*process_fun)(void* arg, unsigned zoom_start_x_lines,
+                        unsigned zoom_end_x_lines, unsigned zoom_start_y_lines, unsigned zoom_end_y_lines, struct vframe_s* vf);
+        void* private_data;
+#if 1
+        /* vframe properties */
+        struct vframe_prop_s prop;
+#endif
+        struct list_head list;
+        struct tvafe_vga_parm_s vga_parm;
+        /* pixel aspect ratio */
+        enum pixel_aspect_ratio_e pixel_ratio;
+        u32  frame_dirty;
+} vframe_t;
+
+#if 0
+struct vframe_prop_s * vdin_get_vframe_prop(u32 index);
+#endif
+int get_curren_frame_para(int* top ,int* left , int* bottom, int* right);
+
+
+#ifdef CONFIG_VSYNC_RDMA
+int VSYNC_WR_MPEG_REG(unsigned long adr, unsigned long val);
+
+int VSYNC_WR_MPEG_REG_BITS(unsigned long adr, unsigned long val, unsigned long start, unsigned long len);
+
+unsigned long VSYNC_RD_MPEG_REG(unsigned long adr);
+#else
+#define VSYNC_WR_MPEG_REG(adr,val) WRITE_MPEG_REG(adr, val)
+#define VSYNC_WR_MPEG_REG_BITS(adr, val, start, len)  WRITE_MPEG_REG_BITS(adr, val, start, len)
+#define VSYNC_RD_MPEG_REG(adr) READ_MPEG_REG(adr)
+#endif
+
+#endif /* VFRAME_H */
+
-- 
2.19.0

